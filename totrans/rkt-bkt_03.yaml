- en: '**2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2'
- en: 'FESTI ROOTKIT: THE MOST ADVANCED SPAM AND DDOS BOT**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**FESTI ROOTKIT：最先进的垃圾邮件和 DDoS 僵尸网络**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: This chapter is devoted to one of the most advanced spam and distributed denial
    of service (DDoS) botnets discovered—the Win32/Festi botnet, which we’ll refer
    to simply as Festi from now on. Festi has powerful spam delivery and DDoS capabilities,
    as well as interesting rootkit functionality that allows it to stay under the
    radar by hooking into the filesystem and system registry. Festi also conceals
    its presence by actively counteracting dynamic analysis with debugger and sandbox
    evasion techniques.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门讨论了发现的最先进的垃圾邮件和分布式拒绝服务（DDoS）僵尸网络之一——Win32/Festi 僵尸网络，我们将从现在起简单地称之为Festi。Festi
    拥有强大的垃圾邮件发送和 DDoS 能力，并且具有有趣的 rootkit 功能，能够通过挂钩文件系统和系统注册表来保持低调。Festi 还通过主动反制动态分析，采用调试器和沙盒规避技术来隐藏其存在。
- en: 'From a high-level point of view, Festi has a well-designed modular architecture
    implemented entirely in the kernel-mode driver. Kernel-mode programming is, of
    course, fraught with danger: a single error in the code can cause the system to
    crash and render it unusable, potentially leading the user to reinstall the system
    afresh, wiping the malware. For this reason, it’s rare for spam-sending malware
    to rely heavily on kernel-mode programming. The fact that Festi was able to inflict
    so much damage is indicative of the solid technical skills of its developer(s)
    and their in-depth understanding of the Windows system. Indeed, they came up with
    several interesting architectural decisions, which we’ll cover in this chapter.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次的角度来看，Festi 拥有一个精心设计的模块化架构，完全实现于内核模式驱动程序中。内核模式编程当然充满了危险：代码中的一个小错误就可能导致系统崩溃并使其无法使用，可能迫使用户重新安装系统，从而清除恶意软件。因此，垃圾邮件发送恶意软件通常很少依赖于内核模式编程。Festi
    能够造成如此大的损害，表明其开发者拥有扎实的技术能力，并深入理解 Windows 系统。事实上，他们提出了几个有趣的架构决策，本章将介绍这些内容。
- en: '**The Case of Festi Botnet**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Festi 僵尸网络案件**'
- en: The Festi botnet was first discovered in the fall of 2009, and by May 2012,
    it was one of the most powerful and active botnets for sending spam and performing
    DDoS attacks. The botnet was initially available to anyone for lease, but after
    early 2010, it was restricted to major spam partners, like Pavel Vrublebsky, one
    of the actors who used the Festi botnet for criminal activities as detailed in
    the book *Spam Nation* by Brian Krebs (Sourcebooks, 2014).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Festi 僵尸网络首次发现是在 2009 年秋季，到 2012 年 5 月，它已经成为最强大和活跃的垃圾邮件发送及 DDoS 攻击僵尸网络之一。最初，这个僵尸网络对任何人开放租用，但在
    2010 年初之后，它仅限于主要的垃圾邮件合作伙伴，如 Pavel Vrublebsky，他是使用 Festi 僵尸网络进行犯罪活动的其中一位参与者，该事件在
    Brian Krebs 的《垃圾邮件国家》（Spam Nation）一书中有详细描述（Sourcebooks，2014）。
- en: According to statistics from M86 Security Labs (currently Trustwave) for 2011,
    shown in [Figure 2-1](ch02.xhtml#ch02fig01), Festi was one of the three most active
    spam botnets in the world in the reported period.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 M86 Security Labs（现为 Trustwave）2011年的统计数据，如 [图 2-1](ch02.xhtml#ch02fig01)
    所示，Festi 是报告期内全球三大最活跃的垃圾邮件僵尸网络之一。
- en: '![image](../images/02fig01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig01.jpg)'
- en: '*Figure 2-1: The most prevalent spam botnets according to M86 Security Labs*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：根据 M86 Security Labs 的数据，最流行的垃圾邮件僵尸网络*'
- en: Festi’s rise in popularity stemmed from a particular attack on Assist, a payment-processing
    company.^([1](footnotes.xhtml#ch02fn1)) Assist was one of the companies bidding
    for a contract with Aeroflot, Russia’s largest airline, but a few weeks before
    Aeroflot was due to make its decision, cybercriminals used Festi to launch a massive
    DDoS attack against Assist. The attack rendered the processing system unusable
    for an extended period of time, eventually forcing Aeroflot to award another company
    the contract. This event is a prime example of how rootkits may be used in real-world
    crime.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Festi 在流行度上的崛起源于对 Assist，一家支付处理公司，发起的特别攻击。^([1](footnotes.xhtml#ch02fn1)) Assist
    是竞标俄罗斯最大航空公司 Aeroflot 合同的公司之一，但在 Aeroflot 准备做出决定前几周，网络犯罪分子利用 Festi 发起了对 Assist
    的大规模 DDoS 攻击。这次攻击使得处理系统在一段较长的时间内无法使用，最终迫使 Aeroflot 将合同授予另一家公司。这一事件是 rootkit 如何在现实犯罪中被使用的典型例子。
- en: '**Dissecting the Rootkit Driver**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**剖析 Rootkit 驱动程序**'
- en: The Festi rootkit is distributed mainly through a PPI scheme similar to the
    TDL3 rootkit discussed in [Chapter 1](ch01.xhtml#ch01). The dropper’s rather simple
    functionality installs into the system a kernel-mode driver that implements the
    main logic of the malware. The kernel-mode component is registered as a “system
    start” kernel-mode driver with a randomly generated name, meaning the malicious
    driver is loaded and executed at system bootup during initialization.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Festi rootkit主要通过类似于[第1章](ch01.xhtml#ch01)中讨论的TDL3 rootkit的PPI计划分发。引导程序的相当简单的功能将内核模式驱动程序安装到系统中，后者实现了恶意软件的主要逻辑。内核模式组件作为一个“系统启动”内核模式驱动程序注册，名称随机生成，这意味着恶意驱动程序会在系统启动时加载并执行。
- en: '**DROPPER INFECTOR**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**引导程序感染者**'
- en: A *dropper* is a special type of infector. Droppers carry a payload to the victim
    system within itself. The payload is frequently compressed and encrypted or obfuscated.
    Once executed, a dropper extracts the payload from its image and installs it on
    a victim system (that is, drops it on the system—thus the name for this type of
    infector). Unlike droppers, *downloaders*—another type of infector—don’t carry
    payloads within themselves but rather download it from a remote server.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dropper*（引导程序）是一种特殊类型的感染程序。引导程序将负载携带到受害者系统中。负载通常会被压缩和加密或混淆。一旦执行，引导程序会从其映像中提取负载，并将其安装到受害者系统中（即将其"丢到"系统中——因此得名此类感染程序）。与引导程序不同，*下载程序*（另一种感染程序）不携带负载，而是从远程服务器下载负载。'
- en: The Festi botnet targets only the Microsoft Windows x86 platform and does not
    have a kernel-mode driver for 64-bit platforms. This was fine at the time of its
    distribution, as there were still many 32-bit operating systems in use, but now
    means the rootkit has largely been rendered obsolete as 64-bit systems have outnumbered
    32-bit systems.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Festi僵尸网络仅针对Microsoft Windows x86平台，并且没有针对64位平台的内核模式驱动程序。这在其分发时是可行的，因为当时仍有许多32位操作系统在使用，但现在随着64位系统的数量超越32位系统，这意味着该rootkit在很大程度上已经过时。
- en: 'The kernel-mode driver has two main duties: requesting configuration information
    from the command and control (C&C) server and downloading and executing malicious
    modules in the form of plug-ins (illustrated in [Figure 2-2](ch02.xhtml#ch02fig02)).
    Each plug-in is dedicated to a certain job, such as performing DDoS attacks against
    a specified network resource or sending spam to an email list provided by the
    C&C server.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模式驱动程序有两个主要任务：从命令和控制（C&C）服务器请求配置信息，并下载和执行以插件形式存在的恶意模块（如[图2-2](ch02.xhtml#ch02fig02)所示）。每个插件都专门用于某个任务，例如对指定的网络资源执行DDoS攻击或向C&C服务器提供的邮件列表发送垃圾邮件。
- en: '![image](../images/02fig02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig02.jpg)'
- en: '*Figure 2-2: Operation of the Festi rootkit*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-2：Festi rootkit的操作*'
- en: Interestingly, the plug-ins aren’t stored on the system hard drive but instead
    in volatile memory, meaning that when the infected computer is powered off or
    rebooted, the plug-ins vanish from system memory. This makes forensic analysis
    of the malware significantly harder since the only file stored on the hard drive
    is the main kernel-mode driver, which contains neither the payload nor any information
    on attack targets.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这些插件并未存储在系统硬盘上，而是存储在易失性内存中，这意味着当感染的计算机关闭或重启时，插件会从系统内存中消失。这使得恶意软件的取证分析变得更加困难，因为硬盘上仅存储了主内核模式驱动程序，且该驱动程序既不包含负载，也不包含任何攻击目标的信息。
- en: '***Festi Configuration Information for C&C Communication***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Festi用于C&C通信的配置信息***'
- en: 'To enable it to communicate with C&C server, Festi is distributed with three
    pieces of predefined configuration information: the domain names of C&C servers,
    the key to encrypt data transmitted between the bot and C&C, and the bot version
    information'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其能够与C&C服务器通信，Festi分发时带有三项预定义的配置信息：C&C服务器的域名、加密bot与C&C之间传输数据的密钥，以及bot的版本信息。
- en: This configuration information is hardcoded into the driver’s binary. [Figure
    2-3](ch02.xhtml#ch02fig03) shows a section table of the kernel-mode driver with
    a writable section named `.cdata`, which stores the configuration data as well
    as strings that are used to perform the malicious activity.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置信息是硬编码到驱动程序的二进制文件中的。[图2-3](ch02.xhtml#ch02fig03)显示了一个内核模式驱动的节表，其中有一个可写节`.cdata`，该节存储了配置信息以及执行恶意活动所需的字符串。
- en: '![image](../images/02fig03.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig03.jpg)'
- en: '*Figure 2-3: Section table of Festi kernel-mode driver*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-3：Festi内核模式驱动的节表*'
- en: The malware obfuscates the contents with a simple algorithm that XORs the data
    with a 4-byte key. The `.cdata` section in decrypted at the very beginning of
    the driver initialization.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件使用一种简单的算法对内容进行混淆，该算法将数据与一个4字节的密钥进行异或。`.cdata`部分在驱动程序初始化的最初阶段被解密。
- en: The strings within the `.cdata` section, listed in [Table 2-1](ch02.xhtml#ch02tab01),
    can garner the attention of security software, so obfuscating them helps the bot
    evade detection.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`.cdata`部分中的字符串，列在[表2-1](ch02.xhtml#ch02tab01)中，可能引起安全软件的注意，因此对它们进行混淆有助于恶意软件逃避检测。'
- en: '**Table 2-1:** Encrypted Strings in the Festi Configuration Data Section'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-1：** Festi配置数据部分中的加密字符串'
- en: '| **String** | **Purpose** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| **字符串** | **用途** |'
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `\Device\Tcp``\Device\Udp` | Names of device objects used by the malware
    to send and receive data over the network |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `\Device\Tcp``\Device\Udp` | 恶意软件用于发送和接收数据的设备对象名称 |'
- en: '| `\REGISTRY\MACHINE\SYSTEM\ CurrentControlSet\Services\ SharedAccess\Parameters\FirewallPolicy\
    StandardProfile\GloballyOpenPorts\List` | Path to the registry key with the parameters
    of the Windows firewall, used by the malware to disable the local firewall |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `\REGISTRY\MACHINE\SYSTEM\ CurrentControlSet\Services\ SharedAccess\Parameters\FirewallPolicy\
    StandardProfile\GloballyOpenPorts\List` | 存储Windows防火墙参数的注册表键路径，恶意软件用此路径来禁用本地防火墙
    |'
- en: '| `ZwDeleteFile, ZwQueryInformationFile, ZwLoadDriver, KdDebuggerEnabled, ZwDeleteValueKey,
    ZwLoadDriver` | Names of system services used by the malware |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `ZwDeleteFile, ZwQueryInformationFile, ZwLoadDriver, KdDebuggerEnabled, ZwDeleteValueKey,
    ZwLoadDriver` | 恶意软件使用的系统服务名称 |'
- en: '***Festi’s Object-Oriented Framework***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Festi的面向对象框架***'
- en: 'Unlike many kernel-mode drivers, which are usually written in plain C using
    the procedural programming paradigm, the Festi driver has an object-oriented architecture.
    The main components (classes) of the architecture implemented by the malware are:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多内核模式驱动程序不同，这些驱动程序通常使用面向过程的编程范式用纯C语言编写，而Festi驱动程序具有面向对象的架构。恶意软件实现的架构的主要组件（类）包括：
- en: '**Memory manager** Allocates and releases memory buffers'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存管理器** 分配和释放内存缓冲区'
- en: '**Network sockets** Send and receive data over the network'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络套接字** 在网络上发送和接收数据'
- en: '**C&C protocol parser** Parses C&C messages and executes received commands'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**C&C协议解析器** 解析C&C消息并执行接收到的命令'
- en: '**Plug-in manager** Manages downloaded plug-ins'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**插件管理器** 管理下载的插件'
- en: The relationships among these components are illustrated in [Figure 2-4](ch02.xhtml#ch02fig04).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件之间的关系如[图2-4](ch02.xhtml#ch02fig04)所示。
- en: '![image](../images/02fig04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig04.jpg)'
- en: '*Figure 2-4: Architecture of the Festi kernel-mode driver*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-4：Festi内核模式驱动程序的架构*'
- en: As you can see, the memory manager is the central component used by all other
    components.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，内存管理器是所有其他组件使用的核心组件。
- en: This object-oriented approach allows the malware to be easily ported to other
    platforms, like Linux. To do so, an attacker would need to change only system-specific
    code (like the code that calls system services for memory management and network
    communication) that is isolated by the component’s interface. Downloaded plug-ins,
    for instance, rely almost completely on the interfaces provided by the main module;
    they rarely use routines provided by the system to do system-specific operations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种面向对象的方法使得恶意软件能够轻松移植到其他平台，如Linux。为了做到这一点，攻击者只需要修改由组件接口隔离的系统特定代码（例如调用系统服务进行内存管理和网络通信的代码）。例如，下载的插件几乎完全依赖于主模块提供的接口；它们很少使用系统提供的例程来执行系统特定的操作。
- en: '***Plug-in Management***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***插件管理***'
- en: Plug-ins downloaded from the C&C server are loaded and executed by the malware.
    To manage the downloaded plug-ins efficiently, Festi maintains an array of pointers
    to a specially defined `PLUGIN_INTERFACE` structure. Each structure corresponds
    to a particular plug-in in memory and provides the bot with specific entry points—routines
    responsible for handling data received from C&C, as shown in [Figure 2-5](ch02.xhtml#ch02fig05).
    This way, Festi keeps track of all the malicious plug-ins loaded in memory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从C&C服务器下载的插件被恶意软件加载并执行。为了有效管理下载的插件，Festi维护了一个指向特定定义的`PLUGIN_INTERFACE`结构体的指针数组。每个结构体对应内存中的一个特定插件，并为机器人提供特定的入口点——处理从C&C接收的数据的例程，如[图2-5](ch02.xhtml#ch02fig05)所示。通过这种方式，Festi跟踪内存中加载的所有恶意插件。
- en: '![image](../images/02fig05.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig05.jpg)'
- en: '*Figure 2-5: Layout of the array of pointers to `PLUGIN_INTERFACE` structures*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-5：指向`PLUGIN_INTERFACE`结构体的指针数组布局*'
- en: '[Listing 2-1](ch02.xhtml#ch02list01) shows the layout of the `PLUGIN_INTERFACE`
    structure.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-1](ch02.xhtml#ch02list01)显示了`PLUGIN_INTERFACE`结构的布局。'
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 2-1: Defining the `PLUGIN_INTERFACE` structure*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-1：定义`PLUGIN_INTERFACE`结构*'
- en: The first two routines, `Initialize` and `Release`, are intended for plug-in
    initialization and termination, respectively. The following two routines, `GetVersionInfo_1`
    and `GetVersionInfo_2`, are used to obtain version information for the plug-in
    in question.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个例程，`Initialize`和`Release`，分别用于插件的初始化和终止。接下来的两个例程，`GetVersionInfo_1`和`GetVersionInfo_2`，用于获取当前插件的版本信息。
- en: The routines `WriteIntoTcpStream` and `ReadFromTcpStream` are used to exchange
    data between the plug-in and the C&C server. When Festi transmits data to the
    C&C server, it runs through the array of pointers to the plug-in interfaces and
    executes the `WriteIntoTcpStream` routine of each registered plug-in, passing
    a pointer to a TCP stream object as a parameter. The TCP stream object implements
    the functionality of the network communication interface.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteIntoTcpStream`和`ReadFromTcpStream`例程用于在插件与C&C服务器之间交换数据。当Festi向C&C服务器传输数据时，它会遍历指向插件接口的指针数组，并执行每个已注册插件的`WriteIntoTcpStream`例程，将指向TCP流对象的指针作为参数传递。TCP流对象实现了网络通信接口的功能。'
- en: On receiving data from the C&C server, the bot executes the plug-ins’ `ReadFromTcpStream`
    routine, so that the registered plug-ins can get parameters and plug-in-specific
    configuration information from the network stream. As a result, every loaded plug-in
    can communicate with the C&C server independently of all other plug-ins, which
    means plug-ins can be developed independently of one another, increasing the efficiency
    of their development and the stability of the architecture.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收到来自C&C服务器的数据时，机器人执行插件的`ReadFromTcpStream`例程，以便已注册的插件能够从网络流中获取参数和插件特定的配置信息。因此，每个加载的插件可以独立于其他插件与C&C服务器进行通信，这意味着插件可以独立开发，从而提高开发效率和架构的稳定性。
- en: '***Built-in Plug-ins***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内置插件***'
- en: 'Upon installation, the main malicious kernel-mode driver implements two built-in
    plug-ins: the *configuration information manager* and the *bot plug-in manager*.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 安装时，主要的恶意内核模式驱动程序实现了两个内置插件：*配置信息管理器*和*机器人插件管理器*。
- en: '**Configuration Information Manager**'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**配置信息管理器**'
- en: The configuration information manager plug-in is responsible for requesting
    configuration information and downloading plug-ins from the C&C server. This simple
    plug-in periodically connects to the C&C server to download the data. The delay
    between two consecutive requests is specified by the C&C server itself, likely
    to avoid static patterns that security software can use to detect infections.
    We describe the network communication protocol between the bot and the C&C server
    in “[The Festi Network Communication Protocol](ch02.xhtml#ch02lev1sec3)” on [page
    26](ch02.xhtml#page_26).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 配置信息管理器插件负责请求配置信息并从C&C服务器下载插件。这个简单的插件定期连接到C&C服务器以下载数据。两次连续请求之间的延迟由C&C服务器本身指定，可能是为了避免安全软件用来检测感染的静态模式。我们在“[Festi网络通信协议](ch02.xhtml#ch02lev1sec3)”中描述了机器人与C&C服务器之间的网络通信协议，详见[第26页](ch02.xhtml#page_26)。
- en: '**Bot Plug-in Manager**'
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**机器人插件管理器**'
- en: The bot plug-in manager is responsible for maintaining the array of downloaded
    plug-ins. It receives remote commands from the C&C server and loads and unloads
    specific plug-ins, delivered in compressed form, onto the system. Each plug-in
    has a default entry point—`DriverEntry`—and exports the two routines `CreateModule`
    and `DeleteModule`, as shown in [Figure 2-6](ch02.xhtml#ch02fig06).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人插件管理器负责维护已下载插件的数组。它接收来自C&C服务器的远程命令，并加载和卸载特定的插件，这些插件以压缩形式传送到系统中。每个插件都有一个默认的入口点—`DriverEntry`—并导出两个例程`CreateModule`和`DeleteModule`，如[图
    2-6](ch02.xhtml#ch02fig06)所示。
- en: '![image](../images/02fig06.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig06.jpg)'
- en: '*Figure 2-6: Export Address table of a Festi plug-in*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：Festi插件的导出地址表*'
- en: The `CreateModule` routine is executed upon plug-in initialization and returns
    a pointer to the `PLUGIN_INTERFACE` structure, as described back in [Listing 2-1](ch02.xhtml#ch02list01).
    It takes as a parameter a pointer to several interfaces provided by the main module,
    such as the memory manager and network interface.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateModule`例程在插件初始化时执行，并返回指向`PLUGIN_INTERFACE`结构的指针，如[列表 2-1](ch02.xhtml#ch02list01)中所述。它以指向由主模块提供的几个接口的指针作为参数，例如内存管理器和网络接口。'
- en: The `DeleteModule` routine is executed when the plug-in is unloaded and frees
    all the previously allocated resources. [Figure 2-7](ch02.xhtml#ch02fig07) shows
    the plug-in manager’s algorithm for loading the plug-in.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当插件被卸载时，`DeleteModule`例程会被执行，释放之前分配的所有资源。[图 2-7](ch02.xhtml#ch02fig07)展示了插件管理器加载插件的算法。
- en: '![image](../images/02fig07.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig07.jpg)'
- en: '*Figure 2-7: Plug-in manager algorithm*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：插件管理器算法*'
- en: The malware first decompresses the plug-in into the memory buffer and then maps
    it into the kernel-mode address space as a PE image. The plug-in manager initializes
    the Import Address table (IAT) and relocates it to the mapped image. In this algorithm,
    Festi also emulates a typical operating system’s runtime loader and dynamic linker
    of OS modules.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件首先将插件解压到内存缓冲区中，然后将其映射到内核模式地址空间作为 PE 镜像。插件管理器初始化导入地址表（IAT）并将其重定位到映射的镜像中。在这个算法中，Festi
    还模拟了典型操作系统的运行时加载器和操作系统模块的动态链接器。
- en: Depending on whether the plug-in is being loaded or unloaded, the plug-in manager
    executes either the `CreateModule` or `DeleteModule` routine. If the plug-in is
    being loaded, the plug-in manager obtains the plug-in’s ID and version information,
    then registers it to the `PLUGIN_INTERFACE` structures.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 根据插件是加载还是卸载，插件管理器执行`CreateModule`或`DeleteModule`例程。如果插件正在加载，插件管理器获取插件的 ID 和版本信息，然后将其注册到`PLUGIN_INTERFACE`结构中。
- en: If the plug-in is being unloaded, the malware releases all memory previously
    allocated to the plug-in image.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果插件正在卸载，恶意软件会释放之前分配给插件镜像的所有内存。
- en: '***Anti–Virtual Machine Techniques***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***反虚拟机技术***'
- en: Festi has techniques for detecting whether it is running inside a VMware virtual
    machine in order to evade sandboxes and automated malware analysis environments.
    It attempts to obtain the version of any existent VMWare software by executing
    the code shown in [Listing 2-2](ch02.xhtml#ch02list02).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Festi 有检测其是否在 VMware 虚拟机中运行的技术，以规避沙盒和自动化恶意软件分析环境。它尝试通过执行[列表 2-2](ch02.xhtml#ch02list02)中的代码获取任何现有的
    VMWare 软件版本。
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 2-2: Obtaining the VMWare software version*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-2：获取 VMWare 软件版本*'
- en: Festi checks the `ebx` register, which will contain the value `VMX` if the code
    is being executed in a VMware virtual environment and `0` if not.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Festi 检查`ebx`寄存器，如果代码在 VMware 虚拟环境中执行，寄存器的值为`VMX`，否则为`0`。
- en: Interestingly, if Festi detects the presence of a virtual environment, it doesn’t
    immediately terminate execution but proceeds as if it were being executed on the
    physical computer. When the malware requests plug-ins from the C&C server, it
    submits certain information that reveals whether it’s being executed in the virtual
    environment; if it is, the C&C server may not return any plug-ins.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果 Festi 检测到虚拟环境的存在，它不会立即终止执行，而是像在物理计算机上执行一样继续。当恶意软件从 C&C 服务器请求插件时，它提交某些信息，揭示它是否在虚拟环境中执行；如果是，C&C
    服务器可能不会返回任何插件。
- en: 'This is likely a technique for evading dynamic analysis: Festi doesn’t terminate
    communication with the C&C server in an effort to trick the automatic analysis
    system into thinking Festi hasn’t noticed it, while in fact the C&C server is
    aware of being monitored and so won’t provide any commands or plug-ins. It’s common
    for malware to terminate execution once it detects that it’s running under a debugger
    or in a sandbox environment in order to avoid revealing the configuration information
    and payload modules.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一种规避动态分析的技术：Festi 不终止与 C&C 服务器的通信，试图欺骗自动分析系统，使其认为 Festi 没有察觉到自己被监控，而实际上
    C&C 服务器已经意识到自己正在被监控，因此不会提供任何命令或插件。恶意软件通常会在检测到它在调试器或沙盒环境中运行时终止执行，以避免泄露配置信息和有效载荷模块。
- en: 'However, malware researchers are savvy to this behavior: if the malware promptly
    terminates without performing any malicious activity, it can draw the attention
    of an analyst, who will likely then perform a deeper analysis to find out why
    it didn’t work, eventually discovering the data and code the malware is trying
    to conceal. By not terminating its execution when a sandbox is detected, Festi
    attempts to avoid these consequences, but it does instruct its C&C to not provide
    the sandbox with malicious modules and configuration data.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，恶意软件研究人员对这种行为非常敏感：如果恶意软件在没有执行任何恶意活动的情况下迅速终止，它可能会引起分析员的注意，分析员可能会进行更深入的分析，查明为什么它没有起作用，最终发现恶意软件试图隐藏的数据和代码。通过不在检测到沙箱时终止执行，Festi
    试图避免这些后果，但它确实指示其 C&C 不向沙箱提供恶意模块和配置数据。
- en: Festi also checks for the presence of network traffic monitoring software on
    the system, which may indicate that the malware has been executed in a malware
    analysis and monitoring environment. Festi looks for the kernel-mode driver *npf.sys*
    (network packet filter). This driver belongs to the Windows packet capture library,
    WinPcap, which is frequently used by network monitoring software like Wireshark
    to gain access to the data link network layer. The presence of the *npf.sys* driver
    indicates that there are network monitoring tools installed on the system, meaning
    it is unsafe for the malware.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Festi 还检查系统中是否存在网络流量监控软件，这可能表明恶意软件已在恶意软件分析和监控环境中执行。Festi 查找内核模式驱动程序 *npf.sys*（网络数据包过滤器）。该驱动程序属于
    Windows 数据包捕获库 WinPcap，常用于网络监控软件如 Wireshark，通过它可以访问数据链路层网络。*npf.sys* 驱动程序的存在表明系统上安装了网络监控工具，这对恶意软件来说是不安全的。
- en: '**WINPCAP**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**WINPCAP**'
- en: The *Windows packet capture library* (WinPcap) allows applications to capture
    and transmit network packets, bypassing the protocol stack. It provides functionality
    for kernel-level network packet filtering and monitoring. This library is used
    extensively as a filtering engine by many open source and commercial network tools,
    like protocol analyzers, network monitors, network intrusion detection systems,
    and sniffers, including widely known tools such as Wireshark, Nmap, Snort, and
    ntop.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*Windows 数据包捕获库*（WinPcap）允许应用程序捕获和传输网络数据包，绕过协议栈。它提供内核级网络数据包过滤和监控功能。许多开源和商业网络工具广泛使用此库作为过滤引擎，例如协议分析器、网络监控器、网络入侵检测系统和嗅探器，包括知名工具如
    Wireshark、Nmap、Snort 和 ntop。'
- en: '***Antidebugging Techniques***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***反调试技术***'
- en: Festi also checks for the presence of a kernel debugger in the system by examining
    the `KdDebuggerEnabled` variable exported from the operating system kernel image.
    If a system debugger is attached to the operating system, this variable contains
    the value `TRUE`; otherwise, it contains `FALSE`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Festi 还通过检查从操作系统内核镜像导出的 `KdDebuggerEnabled` 变量，来检测系统中是否存在内核调试器。如果操作系统附加了系统调试器，该变量的值为
    `TRUE`；否则，值为 `FALSE`。
- en: Festi actively counteracts the system debugger by periodically zeroing the debugging
    registers `dr0` through `dr3`. These registers are used to store addresses for
    breakpoints, and removing the hardware breakpoints hinders the debugging process.
    The code for clearing the debugging registers is shown in [Listing 2-3](ch02.xhtml#ch02list03).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Festi 通过定期将调试寄存器 `dr0` 到 `dr3` 清零，积极对抗系统调试器。这些寄存器用于存储断点的地址，移除硬件断点会阻碍调试过程。清除调试寄存器的代码在[清单
    2-3](ch02.xhtml#ch02list03)中展示。
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 2-3: Clearing debugging registers in Festi code*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-3：Festi 代码中清除调试寄存器*'
- en: The highlighted `writedr` instructions perform write operations on the debugging
    registers. As you can see, Festi writes zeros to these registers before executing
    the `_ProtoHandler` routine, which is responsible for handling the communication
    protocol between the malware and C&C servers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的 `writedr` 指令对调试寄存器执行写操作。正如你所看到的，Festi 在执行负责处理恶意软件与 C&C 服务器之间通信协议的 `_ProtoHandler`
    例程之前，将零写入这些寄存器。
- en: '***The Method for Hiding the Malicious Driver on Disk***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***隐藏磁盘上恶意驱动程序的方法***'
- en: To protect and conceal the image of the malicious kernel-mode driver stored
    on the hard drive, Festi hooks the filesystem driver so that it can intercept
    and modify all requests sent to the filesystem driver to exclude evidence of its
    presence.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护和隐藏存储在硬盘上的恶意内核模式驱动程序映像，Festi 钩住了文件系统驱动程序，以便它可以拦截并修改发送到文件系统驱动程序的所有请求，从而排除其存在的证据。
- en: A simplified version of the routine for installing the hook is shown in [Listing
    2-4](ch02.xhtml#ch02list04).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 安装钩子的简化版例程见[清单2-4](ch02.xhtml#ch02list04)。
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 2-4: Hooking the filesystem device driver stack*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单2-4：挂钩文件系统设备驱动程序堆栈*'
- en: The malware first tries to obtain a handle to the special system file `SystemRoot`,
    which corresponds to the Windows installation directory ➊. Then, by executing
    the `ObReferenceObjectByHandle` system routine ➋, Festi obtains a pointer to the
    `FILE_OBJECT` that corresponds to the handle for `SystemRoot`. The `FILE_OBJECT`
    is a special data structure used by the operating system to manage access to device
    objects and so contains a pointer to the related device object. In our case, since
    we opened a handle for `SystemRoot`, the `DEVICE_OBJECT` is related to the operating
    system filesystem driver. The malware obtains the pointer to the `DEVICE_OBJECT`
    by executing the `IoGetRelatedDeviceObject` system routine ➌, then creates a new
    device object and attaches it to the acquired device object pointer by calling
    `IoAttachDeviceToDeviceStack` ➍, as shown in the layout of the filesystem device
    stack in [Figure 2-8](ch02.xhtml#ch02fig08). Festi’s malicious device object is
    located on top of the stack, meaning the I/O requests intended for the filesystem
    are rerouted to the malware. This allows Festi to conceal itself by altering request
    and return data to and from the filesystem driver.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件首先尝试获取指向特殊系统文件`SystemRoot`的句柄，该文件对应于Windows安装目录 ➊。然后，通过执行`ObReferenceObjectByHandle`系统例程
    ➋，Festi获得指向与`SystemRoot`句柄对应的`FILE_OBJECT`的指针。`FILE_OBJECT`是操作系统用于管理设备对象访问的特殊数据结构，因此它包含指向相关设备对象的指针。在我们的案例中，由于我们打开了`SystemRoot`的句柄，`DEVICE_OBJECT`与操作系统的文件系统驱动程序相关联。恶意软件通过执行`IoGetRelatedDeviceObject`系统例程
    ➌来获取指向`DEVICE_OBJECT`的指针，然后通过调用`IoAttachDeviceToDeviceStack` ➍将新设备对象附加到获取的设备对象指针上，如[图2-8](ch02.xhtml#ch02fig08)中所示的文件系统设备堆栈布局。Festi的恶意设备对象位于堆栈的顶部，这意味着针对文件系统的I/O请求会被重定向到恶意软件。这使得Festi能够通过修改与文件系统驱动程序的请求和返回数据来隐藏自己。
- en: '![image](../images/02fig08.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig08.jpg)'
- en: '*Figure 2-8: Layout of the filesystem device stack hooked by Festi*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-8：Festi挂钩的文件系统设备堆栈布局*'
- en: At the very bottom of [Figure 2-8](ch02.xhtml#ch02fig08), you can see the filesystem
    driver object and the corresponding device object that handles OS filesystem requests.
    Some additional filesystem filters might be attached here too. Toward the top
    of the figure, you can see the Festi driver attached to the filesystem device
    stack.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图2-8](ch02.xhtml#ch02fig08)的最底部，您可以看到文件系统驱动程序对象以及处理操作系统文件系统请求的相应设备对象。这里可能还附加了一些额外的文件系统过滤器。朝图形的顶部，您可以看到Festi驱动程序附加到文件系统设备堆栈。
- en: 'This design uses and closely follows the Windows stacked I/O driver design,
    reproducing the design pattern of the native OS. By now, you probably see the
    trend: the rootkit aims to blend with the OS cleanly and reliably, emulating winning
    OS design patterns for its own modules. In fact, you can learn a lot about OS
    internals from analyzing aspects of rootkits, such as Festi’s handling of input/output
    requests.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 该设计使用并严格遵循Windows堆栈式I/O驱动程序设计，重现了本地操作系统的设计模式。到现在，您可能已经看到了趋势：rootkit旨在与操作系统紧密集成，可靠地模仿成功的操作系统设计模式，为其模块提供支持。事实上，通过分析rootkit的各个方面（如Festi处理输入/输出请求的方式），您可以学到很多操作系统内部的知识。
- en: In Windows, a filesystem I/O request is represented as an IRP, which goes through
    the stack from top to bottom. Every driver in the stack can observe and modify
    the request or returned data. This means that, as shown in [Figure 2-8](ch02.xhtml#ch02fig08),
    Festi can modify IRP requests addressed to the filesystem driver and any corresponding
    returned data.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，文件系统I/O请求以IRP的形式表示，该请求从上到下经过堆栈。堆栈中的每个驱动程序都可以观察和修改请求或返回的数据。这意味着，如[图2-8](ch02.xhtml#ch02fig08)所示，Festi可以修改针对文件系统驱动程序的IRP请求以及任何相应的返回数据。
- en: Festi monitors the IRPs using the `IRP_MJ_DIRECTORY_CONTROL` request code, used
    to query the contents of the directory, watching for queries related to where
    the malware’s kernel-mode driver is located. If it detects such a request, Festi
    modifies the returned data from the filesystem driver to exclude any entry corresponding
    to the malicious driver file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Festi通过`IRP_MJ_DIRECTORY_CONTROL`请求代码监视IRP，该代码用于查询目录的内容，监视与恶意软件内核模式驱动程序所在位置相关的查询。如果它检测到此类请求，Festi会修改文件系统驱动程序返回的数据，以排除任何与恶意驱动程序文件对应的条目。
- en: '***The Method for Protecting the Festi Registry Key***'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***保护Festi注册表键的方法***'
- en: Festi also hides a registry key corresponding to the registered kernel-mode
    driver using a similar method. Located in *HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services*,
    the registry key contains Festi’s driver type and the path to the driver’s image
    on the filesystem. This makes it vulnerable to detection by security software,
    so Festi must hide the key.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Festi 还使用类似的方法隐藏一个对应于已注册内核模式驱动程序的注册表项。该注册表项位于 *HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services*
    中，包含 Festi 驱动程序的类型及其在文件系统中的路径。这使得它容易被安全软件检测到，因此 Festi 必须隐藏该项。
- en: To do so, Festi first hooks the `ZwEnumerateKey`, a system service that queries
    information on a specified registry key and returns all of its subkeys, by modifying
    the *System Service Descriptor Table (SSDT)*, a special data structure in the
    operating system kernel that contains addresses of the system service handlers.
    Festi replaces the address of the original `ZwEnumerateKey` handler with the address
    of the hook.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，Festi 首先通过修改*系统服务描述符表（SSDT）*钩住 `ZwEnumerateKey`，这是一种查询指定注册表项信息并返回所有子项的系统服务。SSDT
    是操作系统内核中的一个特殊数据结构，包含系统服务处理程序的地址。Festi 将原始 `ZwEnumerateKey` 处理程序的地址替换为钩子地址。
- en: '**WINDOWS KERNEL PATCH PROTECTION**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows 内核补丁保护**'
- en: It’s worth mentioning that this hooking approach—modifying SSDT—works only on
    32-bit Microsoft Windows operating systems. As mentioned in [Chapter 1](ch01.xhtml#ch01),
    the 64-bit editions of Windows implement *Kernel Patch Protection* (also known
    as PatchGuard) technology to prevent software from patching certain system structures,
    including SSDT. If PatchGuard detects a modification of any of the monitored data
    structures, it crashes the system.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，这种钩子方法——修改 SSDT——仅适用于 32 位的 Microsoft Windows 操作系统。正如在[第 1 章](ch01.xhtml#ch01)中提到的，Windows
    的 64 位版本实现了*内核补丁保护*（也称为 PatchGuard）技术，以防止软件修改某些系统结构，包括 SSDT。如果 PatchGuard 检测到任何受监控的数据结构被修改，它将导致系统崩溃。
- en: The `ZwEnumerateKey` hook monitors requests addressed to the *HKLM\System\CurrentControlSet\Service*
    registry key, which contains subkeys related to kernel-mode drivers installed
    on the system, including the Festi driver. Festi modifies the list of subkeys
    in the hook to exclude the entry corresponding to its driver. Any software that
    relies on `ZwEnumerateKey` to obtain the list of installed kernel-mode drivers
    will not notice the presence of Festi’s malicious driver.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`ZwEnumerateKey` 钩子监控针对 *HKLM\System\CurrentControlSet\Service* 注册表项的请求，该项包含与系统上安装的内核模式驱动程序相关的子项，包括
    Festi 驱动程序。Festi 修改钩子中的子项列表，排除与其驱动程序相关的条目。任何依赖 `ZwEnumerateKey` 获取已安装内核模式驱动程序列表的软件都无法察觉
    Festi 恶意驱动程序的存在。'
- en: If the registry is discovered by security software and removed during shutdown,
    Festi is also capable of replacing the registry key. In this case, Festi first
    executes the system routine `IoRegisterShutdownNotification` in order to receive
    shutdown notifications when the system is turned off. It checks the shutdown notification
    handler to see if the malicious driver and the corresponding registry key are
    present in the system, and if they’re not (that is, if they’ve been removed),
    it restores them, guaranteeing that it will persist through reboot.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果注册表在关机过程中被安全软件发现并删除，Festi 还能够替换注册表项。在这种情况下，Festi 首先执行系统例程 `IoRegisterShutdownNotification`，以便在系统关闭时接收关机通知。它检查关机通知处理程序，查看恶意驱动程序和相应的注册表项是否存在于系统中，如果不存在（即如果它们被删除了），它会恢复它们，从而保证其在重启后仍能存在。
- en: '**The Festi Network Communication Protocol**'
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Festi 网络通信协议**'
- en: 'To communicate with C&C servers and perform its malicious activities, Festi
    employs a custom network communication protocol that it must protect against eavesdropping.
    In the course of our investigation of the Festi botnet,^([2](footnotes.xhtml#ch02fn2))
    we obtained a list of C&C servers it communicates with and found that while some
    focused on sending spam and others performed DDoS attacks, both types implemented
    a single communication protocol. The Festi communication protocol consists of
    two phases: the initialization phase, when it obtains C&C IP addresses, and the
    work phase, when it requests a job description from C&C.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与 C&C 服务器通信并执行其恶意活动，Festi 使用了一种自定义的网络通信协议，并且它必须保护该协议以防被窃听。在我们对 Festi 僵尸网络的调查过程中^([2](footnotes.xhtml#ch02fn2))，我们获取了它与之通信的
    C&C 服务器列表，并发现虽然有些服务器专注于发送垃圾邮件，其他则执行 DDoS 攻击，但两种类型的服务器都采用了相同的通信协议。Festi 的通信协议分为两个阶段：初始化阶段，它获取
    C&C 的 IP 地址；工作阶段，它从 C&C 请求任务描述。
- en: '***Initialization Phase***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***初始化阶段***'
- en: During the initialization phase, the malware obtains the IP addresses of the
    C&C server, whose domain names are stored in the bot’s binary. What’s interesting
    about this process is that the malware manually resolves the C&C IP address from
    the C&C server domain names. Specifically, it constructs a DNS request packet
    to resolve the C&C server domain name and sends the packet to one of two hosts,
    8.8.8.8 or 8.8.4.4 at port 53, both of which are Google DNS servers. In reply,
    Festi receives an IP address it can use in subsequent communication.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化阶段，恶意软件获取C&C服务器的IP地址，这些域名存储在机器人（bot）的二进制文件中。这个过程有趣之处在于，恶意软件手动解析C&C IP地址。具体来说，它构造一个DNS请求包来解析C&C服务器域名，并将该包发送到8.8.8.8或8.8.4.4这两个Google
    DNS服务器的53端口。作为回应，Festi接收到一个IP地址，以供后续通信使用。
- en: Manually resolving domain names makes the botnet more resilient to takedown
    attempts. If Festi had to rely on a local ISP’s DNS servers for resolving domain
    names, it would be possible for the ISP to block access to the C&C servers by
    modifying DNS information on them—say, if a law enforcement agency issued a warrant
    to block those domain names. By manually crafting DNS requests and sending them
    to Google servers, however, the malware bypasses an ISP’s DNS infrastructure and
    makes a takedown more difficult.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 手动解析域名使得僵尸网络更具抗查杀能力。如果Festi必须依赖本地ISP的DNS服务器来解析域名，ISP有可能通过修改DNS信息来阻止对C&C服务器的访问——比如，如果执法机构发出命令封锁这些域名。然而，通过手动构造DNS请求并将其发送到Google服务器，恶意软件绕过了ISP的DNS基础设施，使得封锁变得更加困难。
- en: '***Work Phase***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***工作阶段***'
- en: The work phase is when Festi requests information from the C&C server on what
    tasks it is to perform. Communication with the C&C servers is performed over the
    TCP protocol. The layout of the network packet request sent to the C&C server,
    shown in [Figure 2-9](ch02.xhtml#ch02fig09), consists of a message header and
    an array of plug-in-specific data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 工作阶段是Festi向C&C服务器请求执行任务的阶段。与C&C服务器的通信通过TCP协议进行。发送给C&C服务器的网络数据包请求布局如[图2-9](ch02.xhtml#ch02fig09)所示，包括消息头和特定插件数据数组。
- en: '![image](../images/02fig09.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig09.jpg)'
- en: '*Figure 2-9: Layout of the network packet sent to the C&C server*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-9：发送到C&C服务器的网络数据包布局*'
- en: 'The message header is generated by the configuration manager plug-in and contains
    the following information:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 消息头由配置管理插件生成，包含以下信息：
- en: Festi version information
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Festi 版本信息
- en: Whether a system debugger is present
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否存在系统调试器
- en: Whether virtualization software (VMWare) is present
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否存在虚拟化软件（VMWare）
- en: Whether network traffic monitoring software (WinPcap) is present
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否存在网络流量监控软件（WinPcap）
- en: Operating system version information
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统版本信息
- en: 'The plug-in-specific data consists of an array of *tag-value-term* entries:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 插件特定数据由一系列*标签-值-终止*条目组成：
- en: '**Tag** A 16-bit integer specifying a type of value that follows the tag'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**标签** 一个16位整数，指定标签后面的值类型'
- en: '**Value** Specific data in the form of a byte, word, dword, null-terminated
    string, or binary array'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**值** 以字节、字、双字、以null结尾的字符串或二进制数组形式的特定数据'
- en: '**Term** The terminating word, 0xABDC, signifying the end of the entry'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**终止** 终止词，0xABDC，表示条目的结束'
- en: The tag-value-term scheme provides a convenient way for malware to serialize
    plug-in-specific data into a network request to the C&C server.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 标签-值-终止方案为恶意软件提供了一种方便的方式，将插件特定的数据序列化成网络请求并发送到C&C服务器。
- en: The data is obfuscated with a simple encryption algorithm before being sent
    over the network. The Python implementation of the encryption algorithm is shown
    in [Listing 2-5](ch02.xhtml#ch02list05).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 数据在发送到网络之前，使用简单的加密算法进行了混淆。加密算法的Python实现如[列表 2-5](ch02.xhtml#ch02list05)所示。
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 2-5: Python implementation of the network encryption algorithm*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-5：网络加密算法的Python实现*'
- en: The malware uses a rolling XOR algorithm with a fixed 4-byte key ➊.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件使用一个滚动的XOR算法，配合一个固定的4字节密钥 ➊。
- en: '**Bypassing Security and Forensics Software**'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**绕过安全和取证软件**'
- en: In order to communicate over the network with C&C servers, send spam, and perform
    DDoS attacks while eluding security software, Festi relies on a TCP/IP stack implemented
    in kernel mode in Windows.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够通过网络与C&C服务器通信、发送垃圾邮件并执行DDoS攻击，同时避开安全软件，Festi依赖于Windows内核模式下实现的TCP/IP堆栈。
- en: To send and receive packets, the malware opens a handle to the *\Device\Tcp*
    or *\Device\Udp* devices depending on the protocol type being used, employing
    a rather interesting technique to acquire the handle without drawing the attention
    of security software. In designing this technique, Festi’s authors again demonstrated
    a superb understanding of Windows system internals.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发送和接收数据包，恶意软件会根据使用的协议类型打开 *\Device\Tcp* 或 *\Device\Udp* 设备的句柄，并采用一种相当有趣的技术来获取该句柄，而不会引起安全软件的注意。在设计这种技术时，Festi
    的作者再次展现了对 Windows 系统内部结构的出色理解。
- en: 'In order to control access to the network on the host, some security software
    monitors access to these devices by intercepting `IRP_MJ_CREATE` requests, which
    are sent to the transport driver when someone tries to open a handle to communicate
    with the device object. This allows the security software to determine which process
    is trying to communicate over the network. Generally speaking, the most common
    ways for security software to monitor access to the device objects are:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制主机上对网络的访问，一些安全软件通过拦截 `IRP_MJ_CREATE` 请求来监控对这些设备的访问。当有人尝试打开句柄以与设备对象通信时，这些请求会被发送到传输驱动程序。这样，安全软件就可以确定哪个进程正在尝试通过网络进行通信。一般来说，安全软件监控对设备对象访问的最常见方法是：
- en: Hooking the `ZwCreateFile` system service handler to intercept all attempts
    to open the devices
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂钩 `ZwCreateFile` 系统服务处理程序，以拦截所有尝试打开设备的操作
- en: Attaching to *\Device\Tcp* or *\Device\Udp* in order to intercept all IRP requests
    sent
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加到 *\Device\Tcp* 或 *\Device\Udp* 以拦截所有发送的 IRP 请求
- en: Festi cleverly bypasses both techniques to establish a connection with a remote
    host over the network.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Festi 聪明地绕过了这两种技术，从而建立了与远程主机的网络连接。
- en: First, instead of using the system implementation of the `ZwCreateFile` system
    service, Festi implements its own system service with almost the same functionality
    as the original one. [Figure 2-10](ch02.xhtml#ch02fig10) shows the custom implementation
    of the `ZwCreateFile` routine.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Festi 并没有使用系统实现的 `ZwCreateFile` 系统服务，而是实现了一个几乎具有与原版相同功能的自定义系统服务。[Figure 2-10](ch02.xhtml#ch02fig10)
    展示了 `ZwCreateFile` 例程的自定义实现。
- en: '![image](../images/02fig10.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig10.jpg)'
- en: '*Figure 2-10: Custom implementation of `ZwCreateFile` routine*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 2-10: `ZwCreateFile` 例程的自定义实现*'
- en: You can see that Festi manually creates a file object to communicate with the
    device being opened and sends an `IRP_MJ_CREATE` request directly to the transport
    driver. Thus, all the devices attached to *\Device\Tcp* or *\Device\Udp* will
    miss the request, and the operation goes unnoticed by security software, as illustrated
    in [Figure 2-11](ch02.xhtml#ch02fig11).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，Festi 手动创建了一个文件对象，以便与正在打开的设备进行通信，并直接向传输驱动程序发送 `IRP_MJ_CREATE` 请求。因此，所有附加到
    *\Device\Tcp* 或 *\Device\Udp* 的设备将错过该请求，而安全软件不会注意到这一操作，如 [Figure 2-11](ch02.xhtml#ch02fig11)
    所示。
- en: On the left side of the figure, you can see how an IRP is normally processed.
    The IRP packet goes through the complete driver stack, and all the drivers hooked
    within it—including the security software—receive the IRP packet and inspect its
    contents. The right side of the figure shows how Festi instead sends the IRP packet
    directly to the target driver, bypassing all the intermediate ones.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在图的左侧，你可以看到 IRP 是如何被正常处理的。IRP 包会经过完整的驱动程序堆栈，所有钩入其中的驱动程序——包括安全软件——都会接收到 IRP 包并检查其内容。图的右侧展示了
    Festi 如何直接将 IRP 包发送到目标驱动程序，绕过了所有中间驱动程序。
- en: '![image](../images/02fig11.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig11.jpg)'
- en: '*Figure 2-11: Bypassing network monitoring security software*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*Figure 2-11: 绕过网络监控安全软件*'
- en: Festi sidesteps the second security software technique just as deftly. To send
    a request directly to *\Device\Tcp* or *\Device\Udp*, the malware requires pointers
    to the corresponding device objects. The fragment of code responsible for this
    maneuver is presented in [Listing 2-6](ch02.xhtml#ch02list06).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Festi 同样巧妙地绕过了第二种安全软件技术。为了直接向 *\Device\Tcp* 或 *\Device\Udp* 发送请求，恶意软件需要指向相应设备对象的指针。负责此操作的代码片段在
    [Listing 2-6](ch02.xhtml#ch02list06) 中展示。
- en: '[PRE5]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 2-6: Implementing the network monitoring security software bypassing
    technique*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*Listing 2-6: 实现绕过网络监控安全软件的技术*'
- en: Festi obtains a pointer to the *tcpip.sys* driver object by executing the `ObReferenceObjectByName`
    routine ➊, an undocumented system routine, and passing as a parameter a pointer
    to a Unicode string with the target driver’s name. Then the malware iterates through
    the list of device objects ➋ corresponding to the driver object and compares its
    names with *\Device\Tcp* ➌ and *\Device\Udp* ➍.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Festi通过执行`ObReferenceObjectByName`例程➊（一个未公开的系统例程）并传递一个指向Unicode字符串的指针，该字符串包含目标驱动程序的名称，来获取指向*tcpip.sys*驱动程序对象的指针。然后，恶意软件遍历与该驱动程序对象对应的设备对象列表➋，并将其名称与*\Device\Tcp*
    ➌和*\Device\Udp* ➍进行比较。
- en: When the malware obtains a handle for the opened device in this way, it uses
    the handle to send and receive data over the network. Though Festi is able to
    avoid security software, it’s possible to see packets it sends by using network
    traffic filters operating at a lower level (for instance, at the Network Driver
    Interface Specification, or NDIS, level) than Festi.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当恶意软件以这种方式获取打开的设备句柄时，它使用该句柄在网络上发送和接收数据。尽管Festi能够避开安全软件，但通过使用操作在比Festi更低层次的网络流量过滤器（例如，在网络驱动接口规范NDIS层次）仍然可以看到它发送的包。
- en: '**The Domain Generation Algorithm for C&C Failure**'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**C&C服务器失效的域名生成算法**'
- en: Another of Festi’s remarkable features is its implementation of a domain name
    generation algorithm (DGA), used as a fallback mechanism when the C&C servers’
    domain names in the bot’s configuration data are unreachable. This can happen,
    for instance, if a law enforcement agency takes down the domain names of Festi
    C&C servers and the malware is unable to download plug-ins and commands. The algorithm
    takes the current date as input and outputs a domain name.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Festi的另一个显著特点是它实现了一个域名生成算法（DGA），用于在C&C服务器的域名在机器人的配置数据中无法访问时作为回退机制。例如，如果执法机构关闭了Festi
    C&C服务器的域名，而恶意软件无法下载插件和命令时，就会发生这种情况。该算法以当前日期为输入，并输出一个域名。
- en: '[Table 2-2](ch02.xhtml#ch02tab02) lists the DGA-based domain names for a Festi
    sample. As you can see, all the generated domain names are pseudorandom, which
    is a characteristic of DGA-generated domain names.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[表2-2](ch02.xhtml#ch02tab02)列出了Festi样本的基于DGA的域名。如您所见，所有生成的域名都是伪随机的，这是DGA生成的域名的特点。'
- en: '**Table 2-2:** List of DGA Domain Names Generated by Festi'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**表2-2：** Festi生成的DGA域名列表'
- en: '| **Date** | **DGA domain name** |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **日期** | **DGA域名** |'
- en: '| --- | --- |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 07/11/2012 | *fzcbihskf.com* |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 07/11/2012 | *fzcbihskf.com* |'
- en: '| 08/11/2012 | *pzcaihszf.com* |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 08/11/2012 | *pzcaihszf.com* |'
- en: '| 09/11/2012 | *dzcxifsff.com* |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 09/11/2012 | *dzcxifsff.com* |'
- en: '| 10/11/2012 | *azcgnfsmf.com* |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 10/11/2012 | *azcgnfsmf.com* |'
- en: '| 11/11/2012 | *bzcfnfsif.com* |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 11/11/2012 | *bzcfnfsif.com* |'
- en: Implementing DGA functionality makes the botnet resilient to takedown attempts.
    Even if law enforcement managed to disable the primary C&C server domains, the
    botnet master could still regain control of the botnet by falling back on DGA.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 实现DGA功能使得僵尸网络对接管尝试具有抗性。即使执法机关成功禁用了主要的C&C服务器域名，僵尸网络主控者仍然可以通过回退到DGA重新获得对僵尸网络的控制。
- en: '**Malicious Functionality**'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**恶意功能**'
- en: 'Now that we’ve covered the rootkit functionality, let’s look at the malicious
    plug-ins downloaded from the C&C servers. In the course of our investigation,
    we obtained a sample of these plug-ins and have identified three types:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了rootkit功能，接下来来看一下从C&C服务器下载的恶意插件。在我们的调查过程中，我们获取了这些插件的样本，并已识别出三种类型：
- en: '*BotSpam.sys* for sending spam emails'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*BotSpam.sys*用于发送垃圾邮件'
- en: '*BotDos.sys* for performing DDoS attacks'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*BotDos.sys*用于执行DDoS攻击'
- en: '*BotSocks.sys* to provide proxy services'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*BotSocks.sys*提供代理服务'
- en: 'We found that different C&C servers tend to provide different types of plug-ins:
    some C&C servers provide only bots with spam plug-ins while others deal only in
    DDoS plug-ins, indicating that the malicious functionality of the malware depends
    on the C&C servers it reports to. The Festi botnet is not a monolith but rather
    comprises subbotnets dedicated to different targets.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现，不同的C&C服务器倾向于提供不同类型的插件：一些C&C服务器仅向机器人提供垃圾邮件插件，而其他服务器则只处理DDoS插件，这表明恶意软件的功能取决于它所报告的C&C服务器。Festi僵尸网络并非一个统一体，而是由多个针对不同目标的子僵尸网络组成。
- en: '***The Spam Module***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***垃圾邮件模块***'
- en: The *BotSpam.sys* plug-in is responsible for sending junk emails. The C&C server
    sends it a spam template and a list of recipient email addresses. [Figure 2-12](ch02.xhtml#ch02fig12)
    illustrates the workflow for the spam plug-ins.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*BotSpam.sys*插件负责发送垃圾邮件。C&C服务器向其发送一个垃圾邮件模板和一个收件人电子邮件地址列表。[图2-12](ch02.xhtml#ch02fig12)展示了垃圾邮件插件的工作流程。'
- en: '![image](../images/02fig12.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig12.jpg)'
- en: '*Figure 2-12: Workflow diagram of Festi spam plug-in*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-12：Festi 垃圾邮件插件的工作流程图*'
- en: First, the plug-in initiates an encrypted connection with its C&C server to
    download a list of email addresses with sender parameters and the actual spam
    templates. It then distributes the spam letters to the recipients. Meanwhile,
    the malware reports the status to the C&C server and requests updates for the
    email list and spam templates.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，插件与其 C&C 服务器建立加密连接，以下载包含发件人参数和实际垃圾邮件模板的电子邮件地址列表。然后，它将垃圾邮件分发给收件人。与此同时，恶意软件向
    C&C 服务器报告状态，并请求更新电子邮件列表和垃圾邮件模板。
- en: The plug-in then checks the status of sent emails by scanning responses from
    an SMTP server for specific strings that signify problems—for instance, if there
    is no recipient with the specified address, an email wasn’t received, or an email
    was classified as junk. If any of these strings is found in the responses from
    the SMTP server, the plug-in gracefully terminates its session with the SMTP server
    and fetches the next address in the list. This precautionary step helps the malware
    to avoid an SMTP server blacklisting the infected machine’s IP address as a spam
    sender and preventing the malware from sending any more spam.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 插件会检查通过 SMTP 服务器发送的电子邮件的状态，扫描来自 SMTP 服务器的响应，寻找特定字符串以指示问题——例如，如果没有找到指定地址的收件人，电子邮件未被接收，或电子邮件被归类为垃圾邮件。如果在
    SMTP 服务器的响应中发现这些字符串，插件会优雅地终止与 SMTP 服务器的会话，并获取列表中的下一个地址。这个预防措施有助于恶意软件避免 SMTP 服务器将感染机器的
    IP 地址列入黑名单，防止其继续发送垃圾邮件。
- en: '***The DDoS Engine***'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***DDoS 引擎***'
- en: The *BotDos.sys* plug-in allows the bot to perform DDoS attacks against specified
    hosts. The plug-in supports several types of DDoS attacks against remote hosts,
    covering a variety of architectures and hosts with different software installed.
    The types of attacks depend on the configuration data received from the C&C and
    include TCP flood, UDP flood, DNS flood, and HTTP flood attacks.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*BotDos.sys* 插件使僵尸网络能够对指定主机执行 DDoS 攻击。该插件支持多种类型的 DDoS 攻击，能够针对不同软件安装的各种架构和主机进行攻击。攻击类型取决于从
    C&C 接收到的配置信息，涵盖 TCP 洪水、UDP 洪水、DNS 洪水和 HTTP 洪水等攻击。'
- en: '**TCP Flood**'
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**TCP 洪水**'
- en: In the case of TCP flooding, the bot initiates a large number of connections
    to a port on the target machine. Every time Festi connects to a target port on
    a server, the server allocates resources to handle the incoming connection. Soon
    the server runs out of resources and stops responding to clients.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TCP 洪水攻击中，僵尸网络向目标机器上的端口发起大量连接。每次 Festi 连接到服务器上的目标端口时，服务器会分配资源来处理传入的连接。很快，服务器的资源耗尽，无法再响应客户端请求。
- en: The default port is the HTTP port, port 80, but this can be changed with corresponding
    configuration information from the C&C server, allowing the malware to attack
    HTTP servers that listen on ports other than 80.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 默认端口是 HTTP 端口 80，但可以通过来自 C&C 服务器的相应配置信息更改，从而使恶意软件能够攻击监听其他端口（而非 80 端口）的 HTTP
    服务器。
- en: '**UDP Flood**'
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**UDP 洪水**'
- en: In a UDP flood, the bot sends UDP packets of randomly generated lengths, filled
    with random data. The length of a packet can be anywhere from 256 to 1,024 bytes.
    The target port is also randomly generated and is therefore unlikely to be open.
    As a result, the attack causes the target host to generate an enormous number
    of ICMP Destination Unreachable packets in reply, and the target machine becomes
    unavailable.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 UDP 洪水攻击中，僵尸网络发送长度随机生成的 UDP 数据包，并填充随机数据。数据包的长度可以是 256 到 1,024 字节之间。目标端口也是随机生成的，因此不太可能是开放的。结果，攻击会导致目标主机生成大量
    ICMP 目标不可达数据包进行回应，从而使目标机器无法使用。
- en: '**DNS Flood**'
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**DNS 洪水**'
- en: The bot is also able to perform DNS flood attacks by sending high volumes of
    UDP packets to port 53 (DNS service) on the target host. The packets contain requests
    to resolve a randomly generated domain name in the *.com* domain zone.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 僵尸网络还能够通过向目标主机的 53 端口（DNS 服务）发送大量 UDP 数据包来执行 DNS 洪水攻击。数据包包含解析在 *.com* 域区中随机生成的域名的请求。
- en: '**HTTP Flood**'
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**HTTP 洪水**'
- en: In HTTP flood attacks against web servers, the bot’s binary contains many different
    user-agent strings, which are used to create a large number of HTTP sessions with
    the web server, overloading the remote host. [Listing 2-7](ch02.xhtml#ch02list07)
    contains the code for assembling the HTTP request that’s sent.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在针对 Web 服务器的 HTTP 洪水攻击中，僵尸网络的二进制文件包含多个不同的用户代理字符串，用于与 Web 服务器创建大量 HTTP 会话，导致远程主机超载。[列表
    2-7](ch02.xhtml#ch02list07) 包含了组装并发送 HTTP 请求的代码。
- en: '[PRE6]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 2-7: Fragment of Festi DDoS plug-in assembling an HTTP request*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-7：Festi DDoS 插件组装 HTTP 请求的片段*'
- en: At ➊ the code generates a value that’s then used at ➋ as an index in the array
    of user-agent strings.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ➊ 处，代码生成一个值，然后在 ➋ 处作为用户代理字符串数组的索引使用。
- en: '***Festi Proxy Plug-in***'
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Festi 代理插件***'
- en: The *BotSocks.sys* plug-in provides remote proxy service to the attacker by
    implementing the SOCKS server over the TCP and UDP protocols. The SOCKS server
    establishes a network connection to another target server on behalf of a client,
    then routes all the traffic back and forth between the client and the target server.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*BotSocks.sys* 插件通过在 TCP 和 UDP 协议上实现 SOCKS 服务器，为攻击者提供远程代理服务。SOCKS 服务器代表客户端与另一个目标服务器建立网络连接，然后将所有流量在客户端和目标服务器之间来回转发。'
- en: As a result a Festi-infected machine becomes a proxy server that allows attackers
    to connect to remote servers through the infected machine. Cybercriminals may
    use such a service for anonymization—that is, to conceal the attacker’s IP address.
    Since the connection happens via the infected host, the remote server can see
    the victim’s IP address but not that of the attacker.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，感染 Festi 的计算机变成了一个代理服务器，允许攻击者通过感染的计算机连接到远程服务器。网络犯罪分子可能会使用这种服务进行匿名化——即隐藏攻击者的
    IP 地址。由于连接是通过感染的主机发生的，远程服务器可以看到受害者的 IP 地址，但看不到攻击者的 IP 地址。
- en: Festi’s *BotSocks.sys* plug-in doesn’t use any reverse-connect proxy mechanisms
    to bypass NAT (Network Address Translation), which enables multiple computers
    in the network to share a single externally visible IP address. Once the malware
    has loaded the plug-in, it opens a network port and starts listening for incoming
    connections. The port number is chosen at random in a range from 4000 to 65536\.
    The plug-in sends the port number it’s listening on to the C&C server so that
    an attacker could establish a network connection with the victim computer. The
    NAT would normally prevent such incoming connections (unless port forwarding is
    configured for the target port).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Festi 的 *BotSocks.sys* 插件没有使用任何反向连接代理机制来绕过 NAT（网络地址转换），NAT 使得网络中的多个计算机可以共享一个外部可见的
    IP 地址。一旦恶意软件加载了插件，它会打开一个网络端口并开始监听传入连接。端口号是从 4000 到 65536 的范围内随机选择的。插件将它所监听的端口号发送给
    C&C 服务器，以便攻击者能够与受害计算机建立网络连接。NAT 通常会阻止这种传入连接（除非为目标端口配置了端口转发）。
- en: The *BotSocks.sys* plug-in also attempts to bypass the Windows firewall, which
    may otherwise prevent the port from being opened. The plug-in modifies the registry
    key *SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\DomainProfile\GloballyOpenPorts\List*,
    which contains a list of ports that may be opened in the Windows firewall profile.
    The malware adds two subkeys in this registry key to enable incoming TCP and UDP
    connections from any destination accordingly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*BotSocks.sys* 插件还试图绕过 Windows 防火墙，否则防火墙可能会阻止端口的打开。该插件修改了注册表项 *SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\DomainProfile\GloballyOpenPorts\List*，该项包含可以在
    Windows 防火墙配置文件中打开的端口列表。恶意软件在此注册表项中添加了两个子项，以便允许来自任何目标的 TCP 和 UDP 传入连接。'
- en: '**SOCKS**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**SOCKS**'
- en: '*Socket Secure (SOCKS)* is an internet protocol that exchanges network packets
    between a client and server through a proxy server. A SOCKS server proxies TCP
    connections from a SOCKS client to an arbitrary IP address and provides a means
    for UDP packets to be forwarded. The SOCKS protocol is often used by cybercriminals
    as a circumvention tool that allows traffic to bypass internet filtering to access
    content that’s otherwise blocked.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*Socket Secure (SOCKS)* 是一种互联网协议，通过代理服务器在客户端和服务器之间交换网络数据包。SOCKS 服务器将来自 SOCKS
    客户端的 TCP 连接代理到任意 IP 地址，并提供转发 UDP 数据包的手段。SOCKS 协议通常被网络犯罪分子用作一种绕过工具，允许流量绕过互联网过滤器，从而访问本应被封锁的内容。'
- en: '**Conclusion**'
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**结论**'
- en: 'You should now have a complete picture of what the Festi rootkit is and what
    it can do. Festi is an interesting piece of malware with well-designed architecture
    and carefully crafted functionality. Every technical aspect of the malware accords
    with its design principles: be stealthy and be resilient to automated analysis,
    monitoring systems, and forensic analysis.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该已经完整了解了 Festi rootkit 的功能及其用途。Festi 是一款有趣的恶意软件，具有精心设计的架构和精心打造的功能。恶意软件的每个技术方面都符合其设计原则：保持隐蔽，并且能够抵抗自动化分析、监控系统和取证分析。
- en: The volatile malicious plug-ins downloaded from C&C servers don’t leave any
    trace on the hard drive of the infected machine. Using encryption to protect the
    network communication protocol that connects it with C&C servers makes it hard
    to detect Festi in the network traffic, and advanced usage of kernel-mode network
    sockets allows Festi to bypass certain Host Intrusion Prevention Systems (HIPS)
    and personal firewalls.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从C&C服务器下载的易变恶意插件不会在感染机器的硬盘上留下任何痕迹。使用加密技术保护连接C&C服务器的网络通信协议，使得在网络流量中难以检测到Festi，且通过高级的内核模式网络套接字使用，允许Festi绕过某些主机入侵防御系统（HIPS）和个人防火墙。
- en: 'The bot eludes security software by implementing rootkit functionality that
    hides its main module and the corresponding registry key in the system. These
    methods were effective against security software at the height of Festi’s popularity,
    but they also constitute one of its major flaws: it targets 32-bit systems only.
    The 64-bit editions of the Windows operating systems implement modern security
    features, such as PatchGuard, that render Festi’s intrusive arsenal ineffective.
    The 64-bit versions also require kernel-mode drivers to have a valid digital signature,
    which is obviously not an easy option for malicious software. As mentioned in
    [Chapter 1](ch01.xhtml#ch01), the solution malware developers came up with to
    circumvent this limitation was to implement bootkit technology, which we’ll cover
    in detail in [Part 2](part02.xhtml#part02).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 该僵尸程序通过实现rootkit功能，隐藏其主模块及相应的注册表键值，从而避开安全软件。这些方法在Festi最为流行时对安全软件非常有效，但也暴露了其一个主要缺陷：它仅针对32位系统。Windows操作系统的64位版本实施了现代安全功能，如PatchGuard，使得Festi的入侵工具无效。64位版本还要求内核模式驱动程序拥有有效的数字签名，这显然对于恶意软件来说不是容易的选择。如[第1章](ch01.xhtml#ch01)所述，为了绕过这一限制，恶意软件开发者想出了实现引导工具技术的解决方案，我们将在[第2部分](part02.xhtml#part02)中详细介绍这一技术。
