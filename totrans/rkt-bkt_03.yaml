- en: '**2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**2'
- en: 'FESTI ROOTKIT: THE MOST ADVANCED SPAM AND DDOS BOT**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**FESTI ROOTKIT：最先进的垃圾邮件和 DDoS 僵尸网络**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: This chapter is devoted to one of the most advanced spam and distributed denial
    of service (DDoS) botnets discovered—the Win32/Festi botnet, which we’ll refer
    to simply as Festi from now on. Festi has powerful spam delivery and DDoS capabilities,
    as well as interesting rootkit functionality that allows it to stay under the
    radar by hooking into the filesystem and system registry. Festi also conceals
    its presence by actively counteracting dynamic analysis with debugger and sandbox
    evasion techniques.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门讨论了发现的最先进的垃圾邮件和分布式拒绝服务（DDoS）僵尸网络之一——Win32/Festi 僵尸网络，我们将从现在起简单地称之为Festi。Festi
    拥有强大的垃圾邮件发送和 DDoS 能力，并且具有有趣的 rootkit 功能，能够通过挂钩文件系统和系统注册表来保持低调。Festi 还通过主动反制动态分析，采用调试器和沙盒规避技术来隐藏其存在。
- en: 'From a high-level point of view, Festi has a well-designed modular architecture
    implemented entirely in the kernel-mode driver. Kernel-mode programming is, of
    course, fraught with danger: a single error in the code can cause the system to
    crash and render it unusable, potentially leading the user to reinstall the system
    afresh, wiping the malware. For this reason, it’s rare for spam-sending malware
    to rely heavily on kernel-mode programming. The fact that Festi was able to inflict
    so much damage is indicative of the solid technical skills of its developer(s)
    and their in-depth understanding of the Windows system. Indeed, they came up with
    several interesting architectural decisions, which we’ll cover in this chapter.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次的角度来看，Festi 拥有一个精心设计的模块化架构，完全实现于内核模式驱动程序中。内核模式编程当然充满了危险：代码中的一个小错误就可能导致系统崩溃并使其无法使用，可能迫使用户重新安装系统，从而清除恶意软件。因此，垃圾邮件发送恶意软件通常很少依赖于内核模式编程。Festi
    能够造成如此大的损害，表明其开发者拥有扎实的技术能力，并深入理解 Windows 系统。事实上，他们提出了几个有趣的架构决策，本章将介绍这些内容。
- en: '**The Case of Festi Botnet**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**Festi 僵尸网络案件**'
- en: The Festi botnet was first discovered in the fall of 2009, and by May 2012,
    it was one of the most powerful and active botnets for sending spam and performing
    DDoS attacks. The botnet was initially available to anyone for lease, but after
    early 2010, it was restricted to major spam partners, like Pavel Vrublebsky, one
    of the actors who used the Festi botnet for criminal activities as detailed in
    the book *Spam Nation* by Brian Krebs (Sourcebooks, 2014).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Festi 僵尸网络首次发现是在 2009 年秋季，到 2012 年 5 月，它已经成为最强大和活跃的垃圾邮件发送及 DDoS 攻击僵尸网络之一。最初，这个僵尸网络对任何人开放租用，但在
    2010 年初之后，它仅限于主要的垃圾邮件合作伙伴，如 Pavel Vrublebsky，他是使用 Festi 僵尸网络进行犯罪活动的其中一位参与者，该事件在
    Brian Krebs 的《垃圾邮件国家》（Spam Nation）一书中有详细描述（Sourcebooks，2014）。
- en: According to statistics from M86 Security Labs (currently Trustwave) for 2011,
    shown in [Figure 2-1](ch02.xhtml#ch02fig01), Festi was one of the three most active
    spam botnets in the world in the reported period.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 M86 Security Labs（现为 Trustwave）2011年的统计数据，如 [图 2-1](ch02.xhtml#ch02fig01)
    所示，Festi 是报告期内全球三大最活跃的垃圾邮件僵尸网络之一。
- en: '![image](../images/02fig01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig01.jpg)'
- en: '*Figure 2-1: The most prevalent spam botnets according to M86 Security Labs*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：根据 M86 Security Labs 的数据，最流行的垃圾邮件僵尸网络*'
- en: Festi’s rise in popularity stemmed from a particular attack on Assist, a payment-processing
    company.^([1](footnotes.xhtml#ch02fn1)) Assist was one of the companies bidding
    for a contract with Aeroflot, Russia’s largest airline, but a few weeks before
    Aeroflot was due to make its decision, cybercriminals used Festi to launch a massive
    DDoS attack against Assist. The attack rendered the processing system unusable
    for an extended period of time, eventually forcing Aeroflot to award another company
    the contract. This event is a prime example of how rootkits may be used in real-world
    crime.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Festi 在流行度上的崛起源于对 Assist，一家支付处理公司，发起的特别攻击。^([1](footnotes.xhtml#ch02fn1)) Assist
    是竞标俄罗斯最大航空公司 Aeroflot 合同的公司之一，但在 Aeroflot 准备做出决定前几周，网络犯罪分子利用 Festi 发起了对 Assist
    的大规模 DDoS 攻击。这次攻击使得处理系统在一段较长的时间内无法使用，最终迫使 Aeroflot 将合同授予另一家公司。这一事件是 rootkit 如何在现实犯罪中被使用的典型例子。
- en: '**Dissecting the Rootkit Driver**'
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**剖析 Rootkit 驱动程序**'
- en: The Festi rootkit is distributed mainly through a PPI scheme similar to the
    TDL3 rootkit discussed in [Chapter 1](ch01.xhtml#ch01). The dropper’s rather simple
    functionality installs into the system a kernel-mode driver that implements the
    main logic of the malware. The kernel-mode component is registered as a “system
    start” kernel-mode driver with a randomly generated name, meaning the malicious
    driver is loaded and executed at system bootup during initialization.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Festi rootkit主要通过类似于[第1章](ch01.xhtml#ch01)中讨论的TDL3 rootkit的PPI计划分发。引导程序的相当简单的功能将内核模式驱动程序安装到系统中，后者实现了恶意软件的主要逻辑。内核模式组件作为一个“系统启动”内核模式驱动程序注册，名称随机生成，这意味着恶意驱动程序会在系统启动时加载并执行。
- en: '**DROPPER INFECTOR**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**引导程序感染者**'
- en: A *dropper* is a special type of infector. Droppers carry a payload to the victim
    system within itself. The payload is frequently compressed and encrypted or obfuscated.
    Once executed, a dropper extracts the payload from its image and installs it on
    a victim system (that is, drops it on the system—thus the name for this type of
    infector). Unlike droppers, *downloaders*—another type of infector—don’t carry
    payloads within themselves but rather download it from a remote server.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*Dropper*（引导程序）是一种特殊类型的感染程序。引导程序将负载携带到受害者系统中。负载通常会被压缩和加密或混淆。一旦执行，引导程序会从其映像中提取负载，并将其安装到受害者系统中（即将其"丢到"系统中——因此得名此类感染程序）。与引导程序不同，*下载程序*（另一种感染程序）不携带负载，而是从远程服务器下载负载。'
- en: The Festi botnet targets only the Microsoft Windows x86 platform and does not
    have a kernel-mode driver for 64-bit platforms. This was fine at the time of its
    distribution, as there were still many 32-bit operating systems in use, but now
    means the rootkit has largely been rendered obsolete as 64-bit systems have outnumbered
    32-bit systems.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Festi僵尸网络仅针对Microsoft Windows x86平台，并且没有针对64位平台的内核模式驱动程序。这在其分发时是可行的，因为当时仍有许多32位操作系统在使用，但现在随着64位系统的数量超越32位系统，这意味着该rootkit在很大程度上已经过时。
- en: 'The kernel-mode driver has two main duties: requesting configuration information
    from the command and control (C&C) server and downloading and executing malicious
    modules in the form of plug-ins (illustrated in [Figure 2-2](ch02.xhtml#ch02fig02)).
    Each plug-in is dedicated to a certain job, such as performing DDoS attacks against
    a specified network resource or sending spam to an email list provided by the
    C&C server.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 内核模式驱动程序有两个主要任务：从命令和控制（C&C）服务器请求配置信息，并下载和执行以插件形式存在的恶意模块（如[图2-2](ch02.xhtml#ch02fig02)所示）。每个插件都专门用于某个任务，例如对指定的网络资源执行DDoS攻击或向C&C服务器提供的邮件列表发送垃圾邮件。
- en: '![image](../images/02fig02.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig02.jpg)'
- en: '*Figure 2-2: Operation of the Festi rootkit*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-2：Festi rootkit的操作*'
- en: Interestingly, the plug-ins aren’t stored on the system hard drive but instead
    in volatile memory, meaning that when the infected computer is powered off or
    rebooted, the plug-ins vanish from system memory. This makes forensic analysis
    of the malware significantly harder since the only file stored on the hard drive
    is the main kernel-mode driver, which contains neither the payload nor any information
    on attack targets.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，这些插件并未存储在系统硬盘上，而是存储在易失性内存中，这意味着当感染的计算机关闭或重启时，插件会从系统内存中消失。这使得恶意软件的取证分析变得更加困难，因为硬盘上仅存储了主内核模式驱动程序，且该驱动程序既不包含负载，也不包含任何攻击目标的信息。
- en: '***Festi Configuration Information for C&C Communication***'
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Festi用于C&C通信的配置信息***'
- en: 'To enable it to communicate with C&C server, Festi is distributed with three
    pieces of predefined configuration information: the domain names of C&C servers,
    the key to encrypt data transmitted between the bot and C&C, and the bot version
    information'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其能够与C&C服务器通信，Festi分发时带有三项预定义的配置信息：C&C服务器的域名、加密bot与C&C之间传输数据的密钥，以及bot的版本信息。
- en: This configuration information is hardcoded into the driver’s binary. [Figure
    2-3](ch02.xhtml#ch02fig03) shows a section table of the kernel-mode driver with
    a writable section named `.cdata`, which stores the configuration data as well
    as strings that are used to perform the malicious activity.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置信息是硬编码到驱动程序的二进制文件中的。[图2-3](ch02.xhtml#ch02fig03)显示了一个内核模式驱动的节表，其中有一个可写节`.cdata`，该节存储了配置信息以及执行恶意活动所需的字符串。
- en: '![image](../images/02fig03.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig03.jpg)'
- en: '*Figure 2-3: Section table of Festi kernel-mode driver*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-3：Festi内核模式驱动的节表*'
- en: The malware obfuscates the contents with a simple algorithm that XORs the data
    with a 4-byte key. The `.cdata` section in decrypted at the very beginning of
    the driver initialization.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The strings within the `.cdata` section, listed in [Table 2-1](ch02.xhtml#ch02tab01),
    can garner the attention of security software, so obfuscating them helps the bot
    evade detection.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-1:** Encrypted Strings in the Festi Configuration Data Section'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '| **String** | **Purpose** |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: '| `\Device\Tcp``\Device\Udp` | Names of device objects used by the malware
    to send and receive data over the network |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: '| `\REGISTRY\MACHINE\SYSTEM\ CurrentControlSet\Services\ SharedAccess\Parameters\FirewallPolicy\
    StandardProfile\GloballyOpenPorts\List` | Path to the registry key with the parameters
    of the Windows firewall, used by the malware to disable the local firewall |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: '| `ZwDeleteFile, ZwQueryInformationFile, ZwLoadDriver, KdDebuggerEnabled, ZwDeleteValueKey,
    ZwLoadDriver` | Names of system services used by the malware |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
- en: '***Festi’s Object-Oriented Framework***'
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Unlike many kernel-mode drivers, which are usually written in plain C using
    the procedural programming paradigm, the Festi driver has an object-oriented architecture.
    The main components (classes) of the architecture implemented by the malware are:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory manager** Allocates and releases memory buffers'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '**Network sockets** Send and receive data over the network'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '**C&C protocol parser** Parses C&C messages and executes received commands'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '**Plug-in manager** Manages downloaded plug-ins'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The relationships among these components are illustrated in [Figure 2-4](ch02.xhtml#ch02fig04).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig04.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-4: Architecture of the Festi kernel-mode driver*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the memory manager is the central component used by all other
    components.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: This object-oriented approach allows the malware to be easily ported to other
    platforms, like Linux. To do so, an attacker would need to change only system-specific
    code (like the code that calls system services for memory management and network
    communication) that is isolated by the component’s interface. Downloaded plug-ins,
    for instance, rely almost completely on the interfaces provided by the main module;
    they rarely use routines provided by the system to do system-specific operations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '***Plug-in Management***'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Plug-ins downloaded from the C&C server are loaded and executed by the malware.
    To manage the downloaded plug-ins efficiently, Festi maintains an array of pointers
    to a specially defined `PLUGIN_INTERFACE` structure. Each structure corresponds
    to a particular plug-in in memory and provides the bot with specific entry points—routines
    responsible for handling data received from C&C, as shown in [Figure 2-5](ch02.xhtml#ch02fig05).
    This way, Festi keeps track of all the malicious plug-ins loaded in memory.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig05.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-5: Layout of the array of pointers to `PLUGIN_INTERFACE` structures*'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-1](ch02.xhtml#ch02list01) shows the layout of the `PLUGIN_INTERFACE`
    structure.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-1](ch02.xhtml#ch02list01)显示了`PLUGIN_INTERFACE`结构的布局。'
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 2-1: Defining the `PLUGIN_INTERFACE` structure*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-1：定义`PLUGIN_INTERFACE`结构*'
- en: The first two routines, `Initialize` and `Release`, are intended for plug-in
    initialization and termination, respectively. The following two routines, `GetVersionInfo_1`
    and `GetVersionInfo_2`, are used to obtain version information for the plug-in
    in question.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个例程，`Initialize`和`Release`，分别用于插件的初始化和终止。接下来的两个例程，`GetVersionInfo_1`和`GetVersionInfo_2`，用于获取当前插件的版本信息。
- en: The routines `WriteIntoTcpStream` and `ReadFromTcpStream` are used to exchange
    data between the plug-in and the C&C server. When Festi transmits data to the
    C&C server, it runs through the array of pointers to the plug-in interfaces and
    executes the `WriteIntoTcpStream` routine of each registered plug-in, passing
    a pointer to a TCP stream object as a parameter. The TCP stream object implements
    the functionality of the network communication interface.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteIntoTcpStream`和`ReadFromTcpStream`例程用于在插件与C&C服务器之间交换数据。当Festi向C&C服务器传输数据时，它会遍历指向插件接口的指针数组，并执行每个已注册插件的`WriteIntoTcpStream`例程，将指向TCP流对象的指针作为参数传递。TCP流对象实现了网络通信接口的功能。'
- en: On receiving data from the C&C server, the bot executes the plug-ins’ `ReadFromTcpStream`
    routine, so that the registered plug-ins can get parameters and plug-in-specific
    configuration information from the network stream. As a result, every loaded plug-in
    can communicate with the C&C server independently of all other plug-ins, which
    means plug-ins can be developed independently of one another, increasing the efficiency
    of their development and the stability of the architecture.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收到来自C&C服务器的数据时，机器人执行插件的`ReadFromTcpStream`例程，以便已注册的插件能够从网络流中获取参数和插件特定的配置信息。因此，每个加载的插件可以独立于其他插件与C&C服务器进行通信，这意味着插件可以独立开发，从而提高开发效率和架构的稳定性。
- en: '***Built-in Plug-ins***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***内置插件***'
- en: 'Upon installation, the main malicious kernel-mode driver implements two built-in
    plug-ins: the *configuration information manager* and the *bot plug-in manager*.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 安装时，主要的恶意内核模式驱动程序实现了两个内置插件：*配置信息管理器*和*机器人插件管理器*。
- en: '**Configuration Information Manager**'
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**配置信息管理器**'
- en: The configuration information manager plug-in is responsible for requesting
    configuration information and downloading plug-ins from the C&C server. This simple
    plug-in periodically connects to the C&C server to download the data. The delay
    between two consecutive requests is specified by the C&C server itself, likely
    to avoid static patterns that security software can use to detect infections.
    We describe the network communication protocol between the bot and the C&C server
    in “[The Festi Network Communication Protocol](ch02.xhtml#ch02lev1sec3)” on [page
    26](ch02.xhtml#page_26).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 配置信息管理器插件负责请求配置信息并从C&C服务器下载插件。这个简单的插件定期连接到C&C服务器以下载数据。两次连续请求之间的延迟由C&C服务器本身指定，可能是为了避免安全软件用来检测感染的静态模式。我们在“[Festi网络通信协议](ch02.xhtml#ch02lev1sec3)”中描述了机器人与C&C服务器之间的网络通信协议，详见[第26页](ch02.xhtml#page_26)。
- en: '**Bot Plug-in Manager**'
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**机器人插件管理器**'
- en: The bot plug-in manager is responsible for maintaining the array of downloaded
    plug-ins. It receives remote commands from the C&C server and loads and unloads
    specific plug-ins, delivered in compressed form, onto the system. Each plug-in
    has a default entry point—`DriverEntry`—and exports the two routines `CreateModule`
    and `DeleteModule`, as shown in [Figure 2-6](ch02.xhtml#ch02fig06).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人插件管理器负责维护已下载插件的数组。它接收来自C&C服务器的远程命令，并加载和卸载特定的插件，这些插件以压缩形式传送到系统中。每个插件都有一个默认的入口点—`DriverEntry`—并导出两个例程`CreateModule`和`DeleteModule`，如[图
    2-6](ch02.xhtml#ch02fig06)所示。
- en: '![image](../images/02fig06.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig06.jpg)'
- en: '*Figure 2-6: Export Address table of a Festi plug-in*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-6：Festi插件的导出地址表*'
- en: The `CreateModule` routine is executed upon plug-in initialization and returns
    a pointer to the `PLUGIN_INTERFACE` structure, as described back in [Listing 2-1](ch02.xhtml#ch02list01).
    It takes as a parameter a pointer to several interfaces provided by the main module,
    such as the memory manager and network interface.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateModule`例程在插件初始化时执行，并返回指向`PLUGIN_INTERFACE`结构的指针，如[列表 2-1](ch02.xhtml#ch02list01)中所述。它以指向由主模块提供的几个接口的指针作为参数，例如内存管理器和网络接口。'
- en: The `DeleteModule` routine is executed when the plug-in is unloaded and frees
    all the previously allocated resources. [Figure 2-7](ch02.xhtml#ch02fig07) shows
    the plug-in manager’s algorithm for loading the plug-in.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当插件被卸载时，`DeleteModule`例程会被执行，释放之前分配的所有资源。[图 2-7](ch02.xhtml#ch02fig07)展示了插件管理器加载插件的算法。
- en: '![image](../images/02fig07.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig07.jpg)'
- en: '*Figure 2-7: Plug-in manager algorithm*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-7：插件管理器算法*'
- en: The malware first decompresses the plug-in into the memory buffer and then maps
    it into the kernel-mode address space as a PE image. The plug-in manager initializes
    the Import Address table (IAT) and relocates it to the mapped image. In this algorithm,
    Festi also emulates a typical operating system’s runtime loader and dynamic linker
    of OS modules.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件首先将插件解压到内存缓冲区中，然后将其映射到内核模式地址空间作为 PE 镜像。插件管理器初始化导入地址表（IAT）并将其重定位到映射的镜像中。在这个算法中，Festi
    还模拟了典型操作系统的运行时加载器和操作系统模块的动态链接器。
- en: Depending on whether the plug-in is being loaded or unloaded, the plug-in manager
    executes either the `CreateModule` or `DeleteModule` routine. If the plug-in is
    being loaded, the plug-in manager obtains the plug-in’s ID and version information,
    then registers it to the `PLUGIN_INTERFACE` structures.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 根据插件是加载还是卸载，插件管理器执行`CreateModule`或`DeleteModule`例程。如果插件正在加载，插件管理器获取插件的 ID 和版本信息，然后将其注册到`PLUGIN_INTERFACE`结构中。
- en: If the plug-in is being unloaded, the malware releases all memory previously
    allocated to the plug-in image.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果插件正在卸载，恶意软件会释放之前分配给插件镜像的所有内存。
- en: '***Anti–Virtual Machine Techniques***'
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***反虚拟机技术***'
- en: Festi has techniques for detecting whether it is running inside a VMware virtual
    machine in order to evade sandboxes and automated malware analysis environments.
    It attempts to obtain the version of any existent VMWare software by executing
    the code shown in [Listing 2-2](ch02.xhtml#ch02list02).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Festi 有检测其是否在 VMware 虚拟机中运行的技术，以规避沙盒和自动化恶意软件分析环境。它尝试通过执行[列表 2-2](ch02.xhtml#ch02list02)中的代码获取任何现有的
    VMWare 软件版本。
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 2-2: Obtaining the VMWare software version*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 2-2：获取 VMWare 软件版本*'
- en: Festi checks the `ebx` register, which will contain the value `VMX` if the code
    is being executed in a VMware virtual environment and `0` if not.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Festi 检查`ebx`寄存器，如果代码在 VMware 虚拟环境中执行，寄存器的值为`VMX`，否则为`0`。
- en: Interestingly, if Festi detects the presence of a virtual environment, it doesn’t
    immediately terminate execution but proceeds as if it were being executed on the
    physical computer. When the malware requests plug-ins from the C&C server, it
    submits certain information that reveals whether it’s being executed in the virtual
    environment; if it is, the C&C server may not return any plug-ins.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果 Festi 检测到虚拟环境的存在，它不会立即终止执行，而是像在物理计算机上执行一样继续。当恶意软件从 C&C 服务器请求插件时，它提交某些信息，揭示它是否在虚拟环境中执行；如果是，C&C
    服务器可能不会返回任何插件。
- en: 'This is likely a technique for evading dynamic analysis: Festi doesn’t terminate
    communication with the C&C server in an effort to trick the automatic analysis
    system into thinking Festi hasn’t noticed it, while in fact the C&C server is
    aware of being monitored and so won’t provide any commands or plug-ins. It’s common
    for malware to terminate execution once it detects that it’s running under a debugger
    or in a sandbox environment in order to avoid revealing the configuration information
    and payload modules.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一种规避动态分析的技术：Festi 不终止与 C&C 服务器的通信，试图欺骗自动分析系统，使其认为 Festi 没有察觉到自己被监控，而实际上
    C&C 服务器已经意识到自己正在被监控，因此不会提供任何命令或插件。恶意软件通常会在检测到它在调试器或沙盒环境中运行时终止执行，以避免泄露配置信息和有效载荷模块。
- en: 'However, malware researchers are savvy to this behavior: if the malware promptly
    terminates without performing any malicious activity, it can draw the attention
    of an analyst, who will likely then perform a deeper analysis to find out why
    it didn’t work, eventually discovering the data and code the malware is trying
    to conceal. By not terminating its execution when a sandbox is detected, Festi
    attempts to avoid these consequences, but it does instruct its C&C to not provide
    the sandbox with malicious modules and configuration data.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Festi also checks for the presence of network traffic monitoring software on
    the system, which may indicate that the malware has been executed in a malware
    analysis and monitoring environment. Festi looks for the kernel-mode driver *npf.sys*
    (network packet filter). This driver belongs to the Windows packet capture library,
    WinPcap, which is frequently used by network monitoring software like Wireshark
    to gain access to the data link network layer. The presence of the *npf.sys* driver
    indicates that there are network monitoring tools installed on the system, meaning
    it is unsafe for the malware.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '**WINPCAP**'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The *Windows packet capture library* (WinPcap) allows applications to capture
    and transmit network packets, bypassing the protocol stack. It provides functionality
    for kernel-level network packet filtering and monitoring. This library is used
    extensively as a filtering engine by many open source and commercial network tools,
    like protocol analyzers, network monitors, network intrusion detection systems,
    and sniffers, including widely known tools such as Wireshark, Nmap, Snort, and
    ntop.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '***Antidebugging Techniques***'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Festi also checks for the presence of a kernel debugger in the system by examining
    the `KdDebuggerEnabled` variable exported from the operating system kernel image.
    If a system debugger is attached to the operating system, this variable contains
    the value `TRUE`; otherwise, it contains `FALSE`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Festi actively counteracts the system debugger by periodically zeroing the debugging
    registers `dr0` through `dr3`. These registers are used to store addresses for
    breakpoints, and removing the hardware breakpoints hinders the debugging process.
    The code for clearing the debugging registers is shown in [Listing 2-3](ch02.xhtml#ch02list03).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 2-3: Clearing debugging registers in Festi code*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: The highlighted `writedr` instructions perform write operations on the debugging
    registers. As you can see, Festi writes zeros to these registers before executing
    the `_ProtoHandler` routine, which is responsible for handling the communication
    protocol between the malware and C&C servers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '***The Method for Hiding the Malicious Driver on Disk***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To protect and conceal the image of the malicious kernel-mode driver stored
    on the hard drive, Festi hooks the filesystem driver so that it can intercept
    and modify all requests sent to the filesystem driver to exclude evidence of its
    presence.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: A simplified version of the routine for installing the hook is shown in [Listing
    2-4](ch02.xhtml#ch02list04).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 安装钩子的简化版例程见[清单2-4](ch02.xhtml#ch02list04)。
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 2-4: Hooking the filesystem device driver stack*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单2-4：挂钩文件系统设备驱动程序堆栈*'
- en: The malware first tries to obtain a handle to the special system file `SystemRoot`,
    which corresponds to the Windows installation directory ➊. Then, by executing
    the `ObReferenceObjectByHandle` system routine ➋, Festi obtains a pointer to the
    `FILE_OBJECT` that corresponds to the handle for `SystemRoot`. The `FILE_OBJECT`
    is a special data structure used by the operating system to manage access to device
    objects and so contains a pointer to the related device object. In our case, since
    we opened a handle for `SystemRoot`, the `DEVICE_OBJECT` is related to the operating
    system filesystem driver. The malware obtains the pointer to the `DEVICE_OBJECT`
    by executing the `IoGetRelatedDeviceObject` system routine ➌, then creates a new
    device object and attaches it to the acquired device object pointer by calling
    `IoAttachDeviceToDeviceStack` ➍, as shown in the layout of the filesystem device
    stack in [Figure 2-8](ch02.xhtml#ch02fig08). Festi’s malicious device object is
    located on top of the stack, meaning the I/O requests intended for the filesystem
    are rerouted to the malware. This allows Festi to conceal itself by altering request
    and return data to and from the filesystem driver.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件首先尝试获取指向特殊系统文件`SystemRoot`的句柄，该文件对应于Windows安装目录 ➊。然后，通过执行`ObReferenceObjectByHandle`系统例程
    ➋，Festi获得指向与`SystemRoot`句柄对应的`FILE_OBJECT`的指针。`FILE_OBJECT`是操作系统用于管理设备对象访问的特殊数据结构，因此它包含指向相关设备对象的指针。在我们的案例中，由于我们打开了`SystemRoot`的句柄，`DEVICE_OBJECT`与操作系统的文件系统驱动程序相关联。恶意软件通过执行`IoGetRelatedDeviceObject`系统例程
    ➌来获取指向`DEVICE_OBJECT`的指针，然后通过调用`IoAttachDeviceToDeviceStack` ➍将新设备对象附加到获取的设备对象指针上，如[图2-8](ch02.xhtml#ch02fig08)中所示的文件系统设备堆栈布局。Festi的恶意设备对象位于堆栈的顶部，这意味着针对文件系统的I/O请求会被重定向到恶意软件。这使得Festi能够通过修改与文件系统驱动程序的请求和返回数据来隐藏自己。
- en: '![image](../images/02fig08.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/02fig08.jpg)'
- en: '*Figure 2-8: Layout of the filesystem device stack hooked by Festi*'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-8：Festi挂钩的文件系统设备堆栈布局*'
- en: At the very bottom of [Figure 2-8](ch02.xhtml#ch02fig08), you can see the filesystem
    driver object and the corresponding device object that handles OS filesystem requests.
    Some additional filesystem filters might be attached here too. Toward the top
    of the figure, you can see the Festi driver attached to the filesystem device
    stack.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图2-8](ch02.xhtml#ch02fig08)的最底部，您可以看到文件系统驱动程序对象以及处理操作系统文件系统请求的相应设备对象。这里可能还附加了一些额外的文件系统过滤器。朝图形的顶部，您可以看到Festi驱动程序附加到文件系统设备堆栈。
- en: 'This design uses and closely follows the Windows stacked I/O driver design,
    reproducing the design pattern of the native OS. By now, you probably see the
    trend: the rootkit aims to blend with the OS cleanly and reliably, emulating winning
    OS design patterns for its own modules. In fact, you can learn a lot about OS
    internals from analyzing aspects of rootkits, such as Festi’s handling of input/output
    requests.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 该设计使用并严格遵循Windows堆栈式I/O驱动程序设计，重现了本地操作系统的设计模式。到现在，您可能已经看到了趋势：rootkit旨在与操作系统紧密集成，可靠地模仿成功的操作系统设计模式，为其模块提供支持。事实上，通过分析rootkit的各个方面（如Festi处理输入/输出请求的方式），您可以学到很多操作系统内部的知识。
- en: In Windows, a filesystem I/O request is represented as an IRP, which goes through
    the stack from top to bottom. Every driver in the stack can observe and modify
    the request or returned data. This means that, as shown in [Figure 2-8](ch02.xhtml#ch02fig08),
    Festi can modify IRP requests addressed to the filesystem driver and any corresponding
    returned data.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，文件系统I/O请求以IRP的形式表示，该请求从上到下经过堆栈。堆栈中的每个驱动程序都可以观察和修改请求或返回的数据。这意味着，如[图2-8](ch02.xhtml#ch02fig08)所示，Festi可以修改针对文件系统驱动程序的IRP请求以及任何相应的返回数据。
- en: Festi monitors the IRPs using the `IRP_MJ_DIRECTORY_CONTROL` request code, used
    to query the contents of the directory, watching for queries related to where
    the malware’s kernel-mode driver is located. If it detects such a request, Festi
    modifies the returned data from the filesystem driver to exclude any entry corresponding
    to the malicious driver file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Festi通过`IRP_MJ_DIRECTORY_CONTROL`请求代码监视IRP，该代码用于查询目录的内容，监视与恶意软件内核模式驱动程序所在位置相关的查询。如果它检测到此类请求，Festi会修改文件系统驱动程序返回的数据，以排除任何与恶意驱动程序文件对应的条目。
- en: '***The Method for Protecting the Festi Registry Key***'
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***保护Festi注册表键的方法***'
- en: Festi also hides a registry key corresponding to the registered kernel-mode
    driver using a similar method. Located in *HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services*,
    the registry key contains Festi’s driver type and the path to the driver’s image
    on the filesystem. This makes it vulnerable to detection by security software,
    so Festi must hide the key.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: To do so, Festi first hooks the `ZwEnumerateKey`, a system service that queries
    information on a specified registry key and returns all of its subkeys, by modifying
    the *System Service Descriptor Table (SSDT)*, a special data structure in the
    operating system kernel that contains addresses of the system service handlers.
    Festi replaces the address of the original `ZwEnumerateKey` handler with the address
    of the hook.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '**WINDOWS KERNEL PATCH PROTECTION**'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth mentioning that this hooking approach—modifying SSDT—works only on
    32-bit Microsoft Windows operating systems. As mentioned in [Chapter 1](ch01.xhtml#ch01),
    the 64-bit editions of Windows implement *Kernel Patch Protection* (also known
    as PatchGuard) technology to prevent software from patching certain system structures,
    including SSDT. If PatchGuard detects a modification of any of the monitored data
    structures, it crashes the system.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The `ZwEnumerateKey` hook monitors requests addressed to the *HKLM\System\CurrentControlSet\Service*
    registry key, which contains subkeys related to kernel-mode drivers installed
    on the system, including the Festi driver. Festi modifies the list of subkeys
    in the hook to exclude the entry corresponding to its driver. Any software that
    relies on `ZwEnumerateKey` to obtain the list of installed kernel-mode drivers
    will not notice the presence of Festi’s malicious driver.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: If the registry is discovered by security software and removed during shutdown,
    Festi is also capable of replacing the registry key. In this case, Festi first
    executes the system routine `IoRegisterShutdownNotification` in order to receive
    shutdown notifications when the system is turned off. It checks the shutdown notification
    handler to see if the malicious driver and the corresponding registry key are
    present in the system, and if they’re not (that is, if they’ve been removed),
    it restores them, guaranteeing that it will persist through reboot.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '**The Festi Network Communication Protocol**'
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To communicate with C&C servers and perform its malicious activities, Festi
    employs a custom network communication protocol that it must protect against eavesdropping.
    In the course of our investigation of the Festi botnet,^([2](footnotes.xhtml#ch02fn2))
    we obtained a list of C&C servers it communicates with and found that while some
    focused on sending spam and others performed DDoS attacks, both types implemented
    a single communication protocol. The Festi communication protocol consists of
    two phases: the initialization phase, when it obtains C&C IP addresses, and the
    work phase, when it requests a job description from C&C.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '***Initialization Phase***'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: During the initialization phase, the malware obtains the IP addresses of the
    C&C server, whose domain names are stored in the bot’s binary. What’s interesting
    about this process is that the malware manually resolves the C&C IP address from
    the C&C server domain names. Specifically, it constructs a DNS request packet
    to resolve the C&C server domain name and sends the packet to one of two hosts,
    8.8.8.8 or 8.8.4.4 at port 53, both of which are Google DNS servers. In reply,
    Festi receives an IP address it can use in subsequent communication.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Manually resolving domain names makes the botnet more resilient to takedown
    attempts. If Festi had to rely on a local ISP’s DNS servers for resolving domain
    names, it would be possible for the ISP to block access to the C&C servers by
    modifying DNS information on them—say, if a law enforcement agency issued a warrant
    to block those domain names. By manually crafting DNS requests and sending them
    to Google servers, however, the malware bypasses an ISP’s DNS infrastructure and
    makes a takedown more difficult.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '***Work Phase***'
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The work phase is when Festi requests information from the C&C server on what
    tasks it is to perform. Communication with the C&C servers is performed over the
    TCP protocol. The layout of the network packet request sent to the C&C server,
    shown in [Figure 2-9](ch02.xhtml#ch02fig09), consists of a message header and
    an array of plug-in-specific data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig09.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-9: Layout of the network packet sent to the C&C server*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'The message header is generated by the configuration manager plug-in and contains
    the following information:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Festi version information
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether a system debugger is present
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether virtualization software (VMWare) is present
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether network traffic monitoring software (WinPcap) is present
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operating system version information
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The plug-in-specific data consists of an array of *tag-value-term* entries:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**Tag** A 16-bit integer specifying a type of value that follows the tag'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '**Value** Specific data in the form of a byte, word, dword, null-terminated
    string, or binary array'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '**Term** The terminating word, 0xABDC, signifying the end of the entry'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: The tag-value-term scheme provides a convenient way for malware to serialize
    plug-in-specific data into a network request to the C&C server.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The data is obfuscated with a simple encryption algorithm before being sent
    over the network. The Python implementation of the encryption algorithm is shown
    in [Listing 2-5](ch02.xhtml#ch02list05).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 2-5: Python implementation of the network encryption algorithm*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The malware uses a rolling XOR algorithm with a fixed 4-byte key ➊.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '**Bypassing Security and Forensics Software**'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to communicate over the network with C&C servers, send spam, and perform
    DDoS attacks while eluding security software, Festi relies on a TCP/IP stack implemented
    in kernel mode in Windows.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: To send and receive packets, the malware opens a handle to the *\Device\Tcp*
    or *\Device\Udp* devices depending on the protocol type being used, employing
    a rather interesting technique to acquire the handle without drawing the attention
    of security software. In designing this technique, Festi’s authors again demonstrated
    a superb understanding of Windows system internals.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to control access to the network on the host, some security software
    monitors access to these devices by intercepting `IRP_MJ_CREATE` requests, which
    are sent to the transport driver when someone tries to open a handle to communicate
    with the device object. This allows the security software to determine which process
    is trying to communicate over the network. Generally speaking, the most common
    ways for security software to monitor access to the device objects are:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Hooking the `ZwCreateFile` system service handler to intercept all attempts
    to open the devices
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching to *\Device\Tcp* or *\Device\Udp* in order to intercept all IRP requests
    sent
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Festi cleverly bypasses both techniques to establish a connection with a remote
    host over the network.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: First, instead of using the system implementation of the `ZwCreateFile` system
    service, Festi implements its own system service with almost the same functionality
    as the original one. [Figure 2-10](ch02.xhtml#ch02fig10) shows the custom implementation
    of the `ZwCreateFile` routine.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig10.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-10: Custom implementation of `ZwCreateFile` routine*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: You can see that Festi manually creates a file object to communicate with the
    device being opened and sends an `IRP_MJ_CREATE` request directly to the transport
    driver. Thus, all the devices attached to *\Device\Tcp* or *\Device\Udp* will
    miss the request, and the operation goes unnoticed by security software, as illustrated
    in [Figure 2-11](ch02.xhtml#ch02fig11).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: On the left side of the figure, you can see how an IRP is normally processed.
    The IRP packet goes through the complete driver stack, and all the drivers hooked
    within it—including the security software—receive the IRP packet and inspect its
    contents. The right side of the figure shows how Festi instead sends the IRP packet
    directly to the target driver, bypassing all the intermediate ones.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig11.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-11: Bypassing network monitoring security software*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Festi sidesteps the second security software technique just as deftly. To send
    a request directly to *\Device\Tcp* or *\Device\Udp*, the malware requires pointers
    to the corresponding device objects. The fragment of code responsible for this
    maneuver is presented in [Listing 2-6](ch02.xhtml#ch02list06).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 2-6: Implementing the network monitoring security software bypassing
    technique*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Festi obtains a pointer to the *tcpip.sys* driver object by executing the `ObReferenceObjectByName`
    routine ➊, an undocumented system routine, and passing as a parameter a pointer
    to a Unicode string with the target driver’s name. Then the malware iterates through
    the list of device objects ➋ corresponding to the driver object and compares its
    names with *\Device\Tcp* ➌ and *\Device\Udp* ➍.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: When the malware obtains a handle for the opened device in this way, it uses
    the handle to send and receive data over the network. Though Festi is able to
    avoid security software, it’s possible to see packets it sends by using network
    traffic filters operating at a lower level (for instance, at the Network Driver
    Interface Specification, or NDIS, level) than Festi.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '**The Domain Generation Algorithm for C&C Failure**'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another of Festi’s remarkable features is its implementation of a domain name
    generation algorithm (DGA), used as a fallback mechanism when the C&C servers’
    domain names in the bot’s configuration data are unreachable. This can happen,
    for instance, if a law enforcement agency takes down the domain names of Festi
    C&C servers and the malware is unable to download plug-ins and commands. The algorithm
    takes the current date as input and outputs a domain name.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 2-2](ch02.xhtml#ch02tab02) lists the DGA-based domain names for a Festi
    sample. As you can see, all the generated domain names are pseudorandom, which
    is a characteristic of DGA-generated domain names.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 2-2:** List of DGA Domain Names Generated by Festi'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '| **Date** | **DGA domain name** |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| 07/11/2012 | *fzcbihskf.com* |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| 08/11/2012 | *pzcaihszf.com* |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: '| 09/11/2012 | *dzcxifsff.com* |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
- en: '| 10/11/2012 | *azcgnfsmf.com* |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
- en: '| 11/11/2012 | *bzcfnfsif.com* |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
- en: Implementing DGA functionality makes the botnet resilient to takedown attempts.
    Even if law enforcement managed to disable the primary C&C server domains, the
    botnet master could still regain control of the botnet by falling back on DGA.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '**Malicious Functionality**'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we’ve covered the rootkit functionality, let’s look at the malicious
    plug-ins downloaded from the C&C servers. In the course of our investigation,
    we obtained a sample of these plug-ins and have identified three types:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '*BotSpam.sys* for sending spam emails'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*BotDos.sys* for performing DDoS attacks'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*BotSocks.sys* to provide proxy services'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We found that different C&C servers tend to provide different types of plug-ins:
    some C&C servers provide only bots with spam plug-ins while others deal only in
    DDoS plug-ins, indicating that the malicious functionality of the malware depends
    on the C&C servers it reports to. The Festi botnet is not a monolith but rather
    comprises subbotnets dedicated to different targets.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '***The Spam Module***'
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *BotSpam.sys* plug-in is responsible for sending junk emails. The C&C server
    sends it a spam template and a list of recipient email addresses. [Figure 2-12](ch02.xhtml#ch02fig12)
    illustrates the workflow for the spam plug-ins.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/02fig12.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-12: Workflow diagram of Festi spam plug-in*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: First, the plug-in initiates an encrypted connection with its C&C server to
    download a list of email addresses with sender parameters and the actual spam
    templates. It then distributes the spam letters to the recipients. Meanwhile,
    the malware reports the status to the C&C server and requests updates for the
    email list and spam templates.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The plug-in then checks the status of sent emails by scanning responses from
    an SMTP server for specific strings that signify problems—for instance, if there
    is no recipient with the specified address, an email wasn’t received, or an email
    was classified as junk. If any of these strings is found in the responses from
    the SMTP server, the plug-in gracefully terminates its session with the SMTP server
    and fetches the next address in the list. This precautionary step helps the malware
    to avoid an SMTP server blacklisting the infected machine’s IP address as a spam
    sender and preventing the malware from sending any more spam.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '***The DDoS Engine***'
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *BotDos.sys* plug-in allows the bot to perform DDoS attacks against specified
    hosts. The plug-in supports several types of DDoS attacks against remote hosts,
    covering a variety of architectures and hosts with different software installed.
    The types of attacks depend on the configuration data received from the C&C and
    include TCP flood, UDP flood, DNS flood, and HTTP flood attacks.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '**TCP Flood**'
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In the case of TCP flooding, the bot initiates a large number of connections
    to a port on the target machine. Every time Festi connects to a target port on
    a server, the server allocates resources to handle the incoming connection. Soon
    the server runs out of resources and stops responding to clients.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The default port is the HTTP port, port 80, but this can be changed with corresponding
    configuration information from the C&C server, allowing the malware to attack
    HTTP servers that listen on ports other than 80.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '**UDP Flood**'
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In a UDP flood, the bot sends UDP packets of randomly generated lengths, filled
    with random data. The length of a packet can be anywhere from 256 to 1,024 bytes.
    The target port is also randomly generated and is therefore unlikely to be open.
    As a result, the attack causes the target host to generate an enormous number
    of ICMP Destination Unreachable packets in reply, and the target machine becomes
    unavailable.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '**DNS Flood**'
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The bot is also able to perform DNS flood attacks by sending high volumes of
    UDP packets to port 53 (DNS service) on the target host. The packets contain requests
    to resolve a randomly generated domain name in the *.com* domain zone.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP Flood**'
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In HTTP flood attacks against web servers, the bot’s binary contains many different
    user-agent strings, which are used to create a large number of HTTP sessions with
    the web server, overloading the remote host. [Listing 2-7](ch02.xhtml#ch02list07)
    contains the code for assembling the HTTP request that’s sent.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 2-7: Fragment of Festi DDoS plug-in assembling an HTTP request*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: At ➊ the code generates a value that’s then used at ➋ as an index in the array
    of user-agent strings.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '***Festi Proxy Plug-in***'
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *BotSocks.sys* plug-in provides remote proxy service to the attacker by
    implementing the SOCKS server over the TCP and UDP protocols. The SOCKS server
    establishes a network connection to another target server on behalf of a client,
    then routes all the traffic back and forth between the client and the target server.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: As a result a Festi-infected machine becomes a proxy server that allows attackers
    to connect to remote servers through the infected machine. Cybercriminals may
    use such a service for anonymization—that is, to conceal the attacker’s IP address.
    Since the connection happens via the infected host, the remote server can see
    the victim’s IP address but not that of the attacker.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Festi’s *BotSocks.sys* plug-in doesn’t use any reverse-connect proxy mechanisms
    to bypass NAT (Network Address Translation), which enables multiple computers
    in the network to share a single externally visible IP address. Once the malware
    has loaded the plug-in, it opens a network port and starts listening for incoming
    connections. The port number is chosen at random in a range from 4000 to 65536\.
    The plug-in sends the port number it’s listening on to the C&C server so that
    an attacker could establish a network connection with the victim computer. The
    NAT would normally prevent such incoming connections (unless port forwarding is
    configured for the target port).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: The *BotSocks.sys* plug-in also attempts to bypass the Windows firewall, which
    may otherwise prevent the port from being opened. The plug-in modifies the registry
    key *SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\DomainProfile\GloballyOpenPorts\List*,
    which contains a list of ports that may be opened in the Windows firewall profile.
    The malware adds two subkeys in this registry key to enable incoming TCP and UDP
    connections from any destination accordingly.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '**SOCKS**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '*Socket Secure (SOCKS)* is an internet protocol that exchanges network packets
    between a client and server through a proxy server. A SOCKS server proxies TCP
    connections from a SOCKS client to an arbitrary IP address and provides a means
    for UDP packets to be forwarded. The SOCKS protocol is often used by cybercriminals
    as a circumvention tool that allows traffic to bypass internet filtering to access
    content that’s otherwise blocked.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You should now have a complete picture of what the Festi rootkit is and what
    it can do. Festi is an interesting piece of malware with well-designed architecture
    and carefully crafted functionality. Every technical aspect of the malware accords
    with its design principles: be stealthy and be resilient to automated analysis,
    monitoring systems, and forensic analysis.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: The volatile malicious plug-ins downloaded from C&C servers don’t leave any
    trace on the hard drive of the infected machine. Using encryption to protect the
    network communication protocol that connects it with C&C servers makes it hard
    to detect Festi in the network traffic, and advanced usage of kernel-mode network
    sockets allows Festi to bypass certain Host Intrusion Prevention Systems (HIPS)
    and personal firewalls.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'The bot eludes security software by implementing rootkit functionality that
    hides its main module and the corresponding registry key in the system. These
    methods were effective against security software at the height of Festi’s popularity,
    but they also constitute one of its major flaws: it targets 32-bit systems only.
    The 64-bit editions of the Windows operating systems implement modern security
    features, such as PatchGuard, that render Festi’s intrusive arsenal ineffective.
    The 64-bit versions also require kernel-mode drivers to have a valid digital signature,
    which is obviously not an easy option for malicious software. As mentioned in
    [Chapter 1](ch01.xhtml#ch01), the solution malware developers came up with to
    circumvent this limitation was to implement bootkit technology, which we’ll cover
    in detail in [Part 2](part02.xhtml#part02).'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
