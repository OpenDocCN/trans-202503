<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch15">&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch15">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_231" aria-label=" Page 231. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">ADDING OAUTH</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/Drop-image.jpg" alt=""/>&#13;
</figure>&#13;
<p class="INTRO">In this chapter, you’ll add OAuth authentication to the Food Finder app, giving users the opportunity to log in with their GitHub accounts. You’ll also implement the wish list 		page to which authenticated users can add and remove locations, as well as the button component needed to accomplish this. Lastly, you’ll learn how to protect your GraphQL mutations from unauthenticated users.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-86"/><samp class="SANS_Futura_Std_Bold_B_11">Adding OAuth with next-auth</samp></h3>&#13;
<p class="TNI">Developers usually use third-party libraries or SDKs to implement OAuth. For the Food Finder application, we’ll use the <i>next-auth</i> package from Auth.js, which comes with an extensive set of preconfigured templates that allow us to connect to an OAuth service easily. These templates are called <i>providers</i>, and we’ll use one of them: the GitHub provider, which adds a Log In with GitHub <span role="doc-pagebreak" epub:type="pagebreak" id="pg_232" aria-label=" Page 232. "/>button to our app. For a refresher on the OAuth authentication process, return to <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h4 class="H2" id="sec2"><span id="h2-167"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a GitHub OAuth App</samp></h4>&#13;
<p class="TNI">First we need to create an OAuth application using GitHub. This should give us the client ID and client secret that the Food Finder application needs to connect to GitHub. If you don’t already have a GitHub account, create one now at <a href="https://github.com"><i>https://<wbr/>github<wbr/>.com</i></a>, then log in. Navigate to <a href="https://github.com/settings/developers"><i>https://<wbr/>github<wbr/>.com<wbr/>/settings<wbr/>/developers</i></a> and create a new OAuth app in the OAuth Apps section. Enter the Food Finder app’s details in the resulting form, which should look similar to <a href="chapter15.xhtml#fig15-1">Figure 15-1</a>.</p>&#13;
&#13;
<figure class="IMG"><img class="img1" id="fig15-1" src="../images/Figure15-1.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 15-1: The GitHub user interface for adding a new OAuth application</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Enter <b>Food Finder</b> as the name, set the home page URL to <b>http://localhost:3000/</b>, and set the authorization callback URL to <b>http://localhost:3000/api/auth/callback/github</b>. After registering the application, GitHub should show us the client ID and let us generate a client secret.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h4 class="H2" id="sec3"><span id="h2-168"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding the Client Credentials</samp></h4>&#13;
<p class="TNI">Now copy these credentials as <samp class="SANS_TheSansMonoCd_W5Regular_11">GITHUB_CLIENT_ID</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GITHUB_CLIENT_SECRET</samp> to the <i>env.local</i> file in the application’s code root folder. This file looks like this:</p>&#13;
&#13;
<pre class="pre-252"><code>MONGO_URI=mongodb://backend:27017/foodfinder&#13;
GITHUB_CLIENT_ID=<var>ADD_YOUR_CLIENT_ID_HERE</var>&#13;
GITHUB_CLIENT_SECRET=<var>ADD_YOUR_CLIENT_SECRET_HERE</var>&#13;
</code></pre>&#13;
<p class="TX">Fill in the placeholders with your credentials.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h4 class="H2" id="sec4"><span id="h2-169"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_233" aria-label=" Page 233. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Installing next-auth</samp></h4>&#13;
<p class="TNI">To add Auth.js’s OAuth SDK for <i>next-auth</i> to the Food Finder app and configure it to connect to the provider, run the following:</p>&#13;
&#13;
<pre class="pre-253"><code>$ <b>docker exec -it foodfinder_application npm install next-auth</b></code></pre>&#13;
<p class="TX">By default, this SDK uses encrypted JWTs to store and attach session information to API requests. The library automatically handles the encryption and decryption as long as we provide it with a secret. To add such a secret, open the <i>env.local</i> file and add the following line to the end:</p>&#13;
&#13;
<pre class="pre-254"><code>NEXTAUTH_SECRET=78f6cc4bf633b1102f4ca4d72602c60f</code></pre>&#13;
<p class="TX">Use any secret you’d like. The string used here was randomly generated with <i>OpenSSL</i> at <i><a href="https://www.usemodernfullstack.dev/api/v1/generate-secret">https://www.usemodernfullstack.dev/api/v1/generate-secret</a></i>, and you should use a fresh one for each application.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h4 class="H2" id="sec5"><span id="h2-170"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Authentication Callback</samp></h4>&#13;
<p class="TNI">Now we’ll develop the <i>api/auth</i> route for the authorization callback URL we supplied to GitHub when registering the OAuth application. Create the <i>auth</i> folder in the <i>pages/api</i> directory containing the file <i>[...nextauth].ts</i>. The ... in the filename tells the Next.js router that this is a catch all, meaning it handles all API calls to endpoints below <i>/auth</i>; for example, <i>auth/signin</i> or <i>auth/callback/github</i>. Add the code from <a href="chapter15.xhtml#Lis15-1">Listing 15-1</a> to the file.</p>&#13;
<span id="Lis15-1"/>&#13;
<pre class="pre-255"><code>import GithubProvider from "next-auth/providers/github";&#13;
import {NextApiRequest, NextApiResponse} from "next";&#13;
import NextAuth from "next-auth";&#13;
import {createHash} from "crypto";&#13;
&#13;
const createUserId = (base: string): string =&gt; {&#13;
    return createHash("sha256").update(base).digest("hex");&#13;
};&#13;
&#13;
export default async function auth(req: NextApiRequest, res: NextApiResponse) {&#13;
    return await NextAuth(req, res, {&#13;
        providers: [&#13;
            GithubProvider({&#13;
                clientId: process.env.GITHUB_CLIENT_ID || " ",&#13;
                clientSecret: process.env.GITHUB_CLIENT_SECRET || " ",&#13;
            }),&#13;
&#13;
        ],&#13;
        callbacks: {&#13;
            async jwt({token}) {&#13;
                if (token?.email &amp;&amp; !token.fdlst_private_userId) {&#13;
                    token.fdlst_private_userId = createUserId(token.email);&#13;
                }&#13;
                return token;&#13;
            },&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_234" aria-label=" Page 234. "/>            async session({session}) {&#13;
                if (&#13;
                    session?.user?.email &amp;&amp;&#13;
                    !session?.user.fdlst_private_userId&#13;
                ) {&#13;
                    session.user.fdlst_private_userId = createUserId(&#13;
                        session?.user?.email&#13;
                    );&#13;
                }&#13;
                return session;&#13;
            },&#13;
        },&#13;
    });&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 15-1: The</span> <span class="Futura_Std_Book_11">pages/api/auth/[...nextauth].ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We import our dependencies, including the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">GithubProvider</samp> and the default <samp class="SANS_TheSansMonoCd_W5Regular_11">crypto</samp> module. Then we create a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">createUserId</samp> function, which takes a string as an argument and calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">crypto</samp> module’s <samp class="SANS_TheSansMonoCd_W5Regular_11">createHash</samp> function to return the hashed user ID from this string.</p>&#13;
<p class="TX">Next, we create and export the default asynchronous <samp class="SANS_TheSansMonoCd_W5Regular_11">auth</samp> function. To do so, we initialize the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextAuth</samp> module and add the <samp class="SANS_TheSansMonoCd_W5Regular_11">GithubProvider</samp> to the <samp class="SANS_TheSansMonoCd_W5Regular_11">providers</samp> array. We configure it to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">clientId</samp> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">clientSecret</samp> we stored in the environment variables.</p>&#13;
<p class="TX">Since we want to keep our application as simple as possible, we’ll keep it stateless; hence, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">jwt</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">session</samp> callbacks, which <i>next-auth</i> uses every time it creates a new session or JWT internally. In the callback, we calculate the hashed user ID from the user’s email with our <samp class="SANS_TheSansMonoCd_W5Regular_11">createId</samp> function (if it’s not already available in the current token or session object). Finally, we store it in a private claim.</p>&#13;
<p class="TX">We’ve just created a new property, <samp class="SANS_TheSansMonoCd_W5Regular_11">fdlst_private_userId</samp>, on the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> object in the <i>next-auth</i> session. As expected, TSC warns us that this property doesn’t exist on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Session</samp> type. We need to augment the type’s interface by adjusting the <i>customs.d.ts</i> file in our application’s root directory to match <a href="chapter15.xhtml#Lis15-2">Listing 15-2</a>.</p>&#13;
<span id="Lis15-2"/>&#13;
<pre class="pre-256"><code>import mongoose from "mongoose";&#13;
<b>import {DefaultSession} from "next-auth";</b>&#13;
&#13;
declare global {&#13;
    var mongoose: mongoose;&#13;
}&#13;
&#13;
<b>declare module "next-auth" {</b>&#13;
<b>    interface Session {</b>&#13;
<b>        user: {</b>&#13;
<b>            fdlst_private_userId: string;</b>&#13;
<b>        } &amp; DefaultSession["user"];</b>&#13;
<b>    }</b>&#13;
<b>}</b>&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 15-2: The updated</span> <span class="Futura_Std_Book_11">customs.d.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file with the augmented</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Session</samp> <span class="Futura_Std_Book_Oblique_BI_11">interface</span></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_235" aria-label=" Page 235. "/>In the updated code, we import the <i>next-auth</i> package’s <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultSession</samp>, which defines the default session object, and then create and redeclare the <samp class="SANS_TheSansMonoCd_W5Regular_11">Session</samp> interface’s <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> object with the new <samp class="SANS_TheSansMonoCd_W5Regular_11">fdlst_private_userId</samp> property. Because TypeScript overwrites the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> object, we explicitly add it from the <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultSession</samp> object. In other words, we add our new <samp class="SANS_TheSansMonoCd_W5Regular_11">fdlst_private_userId</samp> property to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Session</samp> interface.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h4 class="H2" id="sec6"><span id="h2-171"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Sharing the Session Across Pages and Components</samp></h4>&#13;
<p class="TNI">With the callback URL set up, we need to ensure that a user’s session is shared among all Next.js pages and React components. We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">useContext</samp> hook discussed in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, which <i>next-auth</i> provides for us. In the <i>pages/_app .tsx</i> file, wrap the application in a <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionProvider</samp>, as shown in <a href="chapter15.xhtml#Lis15-3">Listing 15-3</a>.</p>&#13;
<span id="Lis15-3"/>&#13;
<pre class="pre-257"><code>import "../styles/globals.css";&#13;
import "../styles/layout.css";&#13;
import type {AppProps} from "next/app";&#13;
import Layout from "components/layout";&#13;
<b>import {SessionProvider} from "next-auth/react";</b>&#13;
&#13;
export default function App({&#13;
    Component, <b>pageProps: {session, ...pageProps}</b>}: AppProps) {&#13;
    return (&#13;
<b>        &lt;SessionProvider session={session}&gt;</b>&#13;
            &lt;Layout&gt;&#13;
                &lt;Component {...pageProps} /&gt;&#13;
            &lt;/Layout&gt;&#13;
<b>        &lt;/SessionProvider&gt;</b>&#13;
    );&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 15-3: The modified</span> <span class="Futura_Std_Book_11">pages/_app.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionProvider</samp> from the <i>next-auth</i> package and enhance the <samp class="SANS_TheSansMonoCd_W5Regular_11">pageProps</samp> with the <samp class="SANS_TheSansMonoCd_W5Regular_11">session</samp> object. We store the current <samp class="SANS_TheSansMonoCd_W5Regular_11">session</samp> in the provider’s <samp class="SANS_TheSansMonoCd_W5Regular_11">session</samp> attribute, making it available throughout the Next.js application.</p>&#13;
<p class="TX">Before we can access the session in the frontend and middleware, we need to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">auth-element</samp> with the Sign In button, which will allow users to log in.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h3 class="H1" id="sec7"><span id="h1-87"/><samp class="SANS_Futura_Std_Bold_B_11">The Generic Button Component</samp></h3>&#13;
<p class="TNI">It’s time to implement the generic button component we mentioned earlier. Technically, this component will be a generic <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp> element that we’ll style to look like a button, with a few variations. It will serve as the Sign In/Sign Out button in the <samp class="SANS_TheSansMonoCd_W5Regular_11">auth-element</samp> and the Add To/Remove From button in the location detail component. Create a new folder, <i>button</i>, in the <i>components</i> folder, adding an <i>index.module.css</i> file with the code in <a href="chapter15.xhtml#Lis15-4">Listing 15-4</a>, as well as an <i>index.tsx</i> file.</p>&#13;
<span id="Lis15-4"/>&#13;
<pre class="pre-258"><code>.root {&#13;
    align-items: center;&#13;
    border-radius: 5px;&#13;
    color: #1d1f21;&#13;
    cursor: pointer;&#13;
    display: inline-flex;&#13;
    font-weight: 500;&#13;
    height: 35px;&#13;
    letter-spacing: 0;&#13;
    margin: 0;&#13;
    overflow: hidden;&#13;
    place-content: flex-start;&#13;
    position: relative;&#13;
    white-space: nowrap;&#13;
}&#13;
&#13;
.root &gt; a,&#13;
.root &gt; span {&#13;
    padding: 0 1rem;&#13;
    white-space: nowrap;&#13;
}&#13;
&#13;
.root {&#13;
    transition: border-color 0.25s ease-in, background-color 0.25s ease-in,&#13;
        color 0.25s ease-in;&#13;
    will-change: border-color, background-color, color;&#13;
}&#13;
&#13;
.root.default,&#13;
.root.default:link,&#13;
.root.default:visited {&#13;
    background-color: transparent;&#13;
    border: 1px solid transparent;&#13;
    color: #1d1f21;&#13;
}&#13;
&#13;
.root.default:hover,&#13;
.root.default:active {&#13;
    background-color: transparent;&#13;
    border: 1px solid #dbd8e3;&#13;
    color: #1d1f21;&#13;
}&#13;
&#13;
.root.blue,&#13;
.root.blue:link,&#13;
.root.blue:visited {&#13;
    background-color: rgba(0, 118, 255, 0.9);&#13;
    border: 1px solid rgba(0, 118, 255, 0.9);&#13;
    color: #fff;&#13;
    text-decoration: none;&#13;
}&#13;
&#13;
.root.blue:hover,&#13;
.root.blue:active {&#13;
    background-color: transparent;&#13;
    border: 1px solid #1d1f21;&#13;
    color: #1d1f21;&#13;
    text-decoration: none;&#13;
}&#13;
&#13;
.root.outline,&#13;
.root.outline:link,&#13;
.root.outline:visited {&#13;
    background-color: transparent;&#13;
    border: 1px solid #dbd8e3;&#13;
    color: #1d1f21;&#13;
    text-decoration: none;&#13;
}&#13;
&#13;
.root.outline:hover,&#13;
.root.outline:active {&#13;
    background-color: transparent;&#13;
    border: 1px solid rgba(0, 118, 255, 0.9);&#13;
    color: rgba(0, 118, 255, 0.9);&#13;
    text-decoration: none;&#13;
}&#13;
&#13;
.root.disabled,&#13;
.root.disabled:link,&#13;
.root.disabled:visited {&#13;
    background-color: transparent;&#13;
    border: 1px solid #dbd8e3;&#13;
    color: #dbd8e3;&#13;
    text-decoration: none;&#13;
}&#13;
&#13;
.root.disabled:hover,&#13;
.root.disabled:active {&#13;
    background-color: transparent;&#13;
    border: 1px solid #dbd8e3;&#13;
    color: #dbd8e3;&#13;
    text-decoration: none;&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 15-4: The</span> <span class="Futura_Std_Book_11">components/button/index.module.css</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We add styles for each of the button variations we’d like to create. All are 35 pixels tall and have rounded corners. We define a default style, a variation with a blue background and white color, and an outlined version whose background is white. In addition, we define styles to use for deactivated buttons.</p>&#13;
<p class="TX">With the styles in place, we can write code for the component. Copy the contents of <a href="chapter15.xhtml#Lis15-5">Listing 15-5</a> into the component’s <i>index.tsx</i> file.</p>&#13;
<span id="Lis15-5"/>&#13;
<pre class="pre-259"><code>import React from "react";&#13;
import styles from "./index.module.css";&#13;
&#13;
interface PropsInterface {&#13;
    disabled?: boolean;&#13;
    children?: React.ReactNode;&#13;
    variant?: "blue" | "outline";&#13;
    clickHandler?: () =&gt; any;&#13;
}&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_238" aria-label=" Page 238. "/>const Button = (props: PropsInterface): JSX.Element =&gt; {&#13;
    const {children, variant, disabled, clickHandler} = props;&#13;
&#13;
    const renderContent = (children: React.ReactNode) =&gt; {&#13;
        if (disabled) {&#13;
            return (&#13;
                &lt;span className={styles.span}&gt;&#13;
                    {children}&#13;
                &lt;/span&gt;&#13;
            );&#13;
        } else {&#13;
            return (&#13;
                &lt;span className={styles.span} onClick={clickHandler}&gt;&#13;
                    {children}&#13;
                &lt;/span&gt;&#13;
            );&#13;
        }&#13;
    };&#13;
&#13;
    return (&#13;
        &lt;div&#13;
            className={[&#13;
                styles.root,&#13;
                disabled ? styles.disabled : " ",&#13;
                styles[variant || "default"],&#13;
            ].join(" ")}&#13;
        &gt;&#13;
            {renderContent(children)}&#13;
        &lt;/div&gt;&#13;
    );&#13;
};&#13;
&#13;
export default Button;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 15-5: The</span> <span class="Futura_Std_Book_11">components/button/index.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">After importing the dependencies, we define the interface for the component’s <samp class="SANS_TheSansMonoCd_W5Regular_11">prop</samp> argument. We also define the <samp class="SANS_TheSansMonoCd_W5Regular_11">Button</samp> component as a function that returns a JSX element and then use object-destructuring syntax to split the <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> object into constants representing the object’s key-value pairs. We define the internal <samp class="SANS_TheSansMonoCd_W5Regular_11">renderContent</samp> function with one argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp>, typed as a <samp class="SANS_TheSansMonoCd_W5Regular_11">ReactNode</samp> and rendered wrapped in a span element. Depending on the state of the <samp class="SANS_TheSansMonoCd_W5Regular_11">disabled</samp> property, we also add the click handler from the <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> object. The component itself returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp> that we styled to look like a button.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H1" id="sec8"><span id="h1-88"/><samp class="SANS_Futura_Std_Bold_B_11">The AuthElement Component</samp></h3>&#13;
<p class="TNI">Although we’ve added the <i>next-auth</i> package to the project, created the OAuth API route, and configured our OAuth provider, we still can’t access session information, as there is no Sign In button. Let’s create this <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthElement</samp> component and then add it to the header. This component uses our default <span role="doc-pagebreak" epub:type="pagebreak" id="pg_239" aria-label=" Page 239. "/>button component, and as soon as the user is logged in, it displays their full name, as well as a link to their wish list.</p>&#13;
<p class="TX">Create the folder <i>auth-element</i> in the <i>components/header</i> directory and then add the <i>index.module.css</i> file with the code in <a href="chapter15.xhtml#Lis15-6">Listing 15-6</a>.</p>&#13;
<span id="Lis15-6"/>&#13;
<pre class="pre-260"><code>.root {&#13;
    align-items: center;&#13;
    display: flex;&#13;
    justify-content: space-between;&#13;
    margin: 0;&#13;
    padding: 1rem 0;&#13;
    width: auto;&#13;
}&#13;
&#13;
.root &gt; * {&#13;
    margin: 0 0 0 2rem;&#13;
}&#13;
&#13;
.name {&#13;
    margin: 1rem 0 0 0;&#13;
}&#13;
&#13;
@media (min-width: 600px) {&#13;
    .name {&#13;
        margin: 0 0 0 1rem;&#13;
    }&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 15-6: The</span> <span class="Futura_Std_Book_11">components/header/auth-element/index.module.css</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We define a set of basic styles for the component, using a flexbox and margins to align them vertically, and change their layout for smaller screens.</p>&#13;
<p class="TX">To write the component itself, add an <i>index.tsx</i> file to the <i>auth-element</i> folder and enter the code from <a href="chapter15.xhtml#Lis15-7">Listing 15-7</a> into it.</p>&#13;
<span id="Lis15-7"/>&#13;
<pre class="pre-261"><code>import Link from "next/link";&#13;
import {signIn, signOut, useSession} from "next-auth/react";&#13;
import Button from "components/button";&#13;
import styles from "./index.module.css";&#13;
&#13;
const AuthElement = (): JSX.Element =&gt; {&#13;
    const {data: session, status} = useSession();&#13;
&#13;
    return (&#13;
        &lt;&gt;&#13;
            {status === "authenticated" (&#13;
                &lt;span className={styles.name}&gt;&#13;
                    Hi &lt;b&gt;{session?.user?.name}&lt;/b&gt;&#13;
                &lt;/span&gt;&#13;
            )}&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_240" aria-label=" Page 240. "/>            &lt;nav className={styles.root}&gt;&#13;
                {status === "authenticated" &amp;&amp; (&#13;
                    &lt;&gt;&#13;
                        &lt;Button variant="outline"&gt;&#13;
                            &lt;Link&#13;
href={`/list/${session?.user.fdlst_private_userId}`}&#13;
                            &gt;&#13;
                                Your wish list&#13;
                            &lt;/Link&gt;&#13;
                        &lt;/Button&gt;&#13;
&#13;
                        &lt;Button variant="blue" clickHandler={() =&gt; signOut()}&gt;&#13;
                            Sign out&#13;
                        &lt;/Button&gt;&#13;
                    &lt;/&gt;&#13;
                )}&#13;
                {status == "unauthenticated" &amp;&amp; (&#13;
                    &lt;&gt;&#13;
                        &lt;Button variant="blue" clickHandler={() =&gt; signIn()}&gt;&#13;
                            Sign in&#13;
                        &lt;/Button&gt;&#13;
                    &lt;/&gt;&#13;
                )}&#13;
            &lt;/nav&gt;&#13;
        &lt;/&gt;&#13;
    );&#13;
};&#13;
export default AuthElement;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 15-7: The</span> <span class="Futura_Std_Book_11">components/header/auth-element/index.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">The most notable imports are the <samp class="SANS_TheSansMonoCd_W5Regular_11">signIn</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">signOut</samp> functions and the <samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp> hook from <i>next-auth</i>. The latter enables us to access session information easily, whereas the two functions trigger the sign-in flow or terminate the session.</p>&#13;
<p class="TX">We then define the <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthElement</samp> component and retrieve the <samp class="SANS_TheSansMonoCd_W5Regular_11">session data</samp> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">session status</samp> from the <samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp> hook. We need both of these to construct the JSX element we return from the component. On the client side, we can access the session information directly via the <samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp> hook. On the server side, though, we’ll need to access it through the JWT, because the session information is part of the API request’s HTTP cookies.</p>&#13;
<p class="TX">When the session’s status is authenticated, we render the user’s name from the session data and add the Your Wish List and Sign Out buttons to the navigation’s <samp class="SANS_TheSansMonoCd_W5Regular_11">nav</samp> element. Otherwise, we add the Sign In button to start the OAuth flow. For all of those, we use the generic button component and the <samp class="SANS_TheSansMonoCd_W5Regular_11">signIn</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">signOut</samp> functions we imported from the <i>next-auth</i> module, both of which handle the OAuth flow automatically.</p>&#13;
<p class="TX">We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp> element to link to the user’s wish list. (This is another Next.js page we’ll implement in a moment.) The wish list is available at the dynamic route <i>/list/:userId</i>, which uses the user ID we created by hashing the user’s email address and storing it in <samp class="SANS_TheSansMonoCd_W5Regular_11">fdlst_private_userId</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H1" id="sec9"><span id="h1-89"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_241" aria-label=" Page 241. "/><samp class="SANS_Futura_Std_Bold_B_11">Adding the AuthElement Component to the Header</samp></h3>&#13;
<p class="TNI">Now we have to add the new component to the header. Open the <i>index.tsx</i> file in the <i>components/header</i> directory and adjust it so that it matches <a href="chapter15.xhtml#Lis15-8">Listing 15-8</a>.</p>&#13;
<span id="Lis15-8"/>&#13;
<pre class="pre-262"><code>import styles from "./index.module.css";&#13;
import Logo from "components/header/logo";&#13;
<b>import AuthElement from "components/header/auth-element";</b>&#13;
const Header = (): JSX.Element =&gt; {&#13;
    return (&#13;
        &lt;header className={styles.root}&gt;&#13;
            &lt;div className="<b>layout-grid</b>"&gt;&#13;
                &lt;Logo /&gt;&#13;
<b>                &lt;AuthElement /&gt;</b>&#13;
            &lt;/div&gt;&#13;
        &lt;/header&gt;&#13;
    );&#13;
};&#13;
&#13;
export default Header;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 15-8: The modified</span> <span class="Futura_Std_Book_11">components/header/index.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">The update is simple; we import the <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthElement</samp> component and add it next to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Logo</samp> inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">header</samp>.</p>&#13;
<p class="TX">Test the OAuth workflow to see our session management in practice. When you open <i>http://localhost:3000</i>, the Sign In button should be in the header, as in <a href="chapter15.xhtml#fig15-2">Figure 15-2</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig15-2" src="../images/Figure15-2.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 15-2: The header in a logged-out state with the Sign In button</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_242" aria-label=" Page 242. "/>Let’s log in using OAuth. Click the <b>Sign In</b> button, and <i>next-auth</i> should redirect you to the login screen, where you can select to sign in with the configured OAuth providers to use (<a href="chapter15.xhtml#fig15-3">Figure 15-3</a>).</p>&#13;
<figure class="IMG"><img class="img1" id="fig15-3" src="../images/Figure15-3.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 15-3: OAuth requires us to choose a provider.</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Click the button to log in. OAuth should redirect you to the application, where the <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthElement</samp> renders your name and new buttons based on the session information. The screen should look similar to <a href="chapter15.xhtml#fig15-4">Figure 15-4</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig15-4" src="../images/Figure15-4.jpg" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 15-4: The header in the logged-in state with the session information</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_243" aria-label=" Page 243. "/>The header element has changed according to the session’s state. We display the current user’s name received from the OAuth provider, the link to their public wish list, and the Sign Out button.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<h3 class="H1" id="sec10"><span id="h1-90"/><samp class="SANS_Futura_Std_Bold_B_11">The Wish List Next.js Page</samp></h3>&#13;
<p class="TNI">The wish list button in the header should link to a wish list page at the dynamic URL <i>list/:userId</i>. This regular Next.js page should display all locations whose <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp> property contains the user ID specified in the dynamic URL. It will look quite similar to the start page, and we can build it out of existing components.</p>&#13;
<p class="TX">To create the page’s route, create the <i>list</i> folder with the <i>[userId].tsx</i> file in the <i>pages</i> directory. Then add the code from <a href="chapter15.xhtml#Lis15-9">Listing 15-9</a> to this <i>.tsx</i> file.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_244" aria-label=" Page 244. "/>&#13;
<span id="Lis15-9"/>&#13;
<pre class="pre-263"><code>import type {&#13;
    GetServerSideProps,&#13;
    GetServerSidePropsContext,&#13;
    NextPage,&#13;
    PreviewData,&#13;
    InferGetServerSidePropsType,&#13;
} from "next";&#13;
import Head from "next/head";&#13;
import {ParsedUrlQuery} from "querystring";&#13;
&#13;
import dbConnect from "middleware/db-connect";&#13;
import {onUserWishlist} from "mongoose/locations/services";&#13;
import {LocationType} from "mongoose/locations/schema";&#13;
import LocationsList from "components/locations-list";&#13;
&#13;
import {useSession} from "next-auth/react";&#13;
&#13;
const List: NextPage = (&#13;
    props: InferGetServerSidePropsType&lt;typeof getServerSideProps&gt;&#13;
) =&gt; {&#13;
    const locations: LocationType[] = JSON.parse(props.data?.locations);&#13;
    const userId: string | undefined = props.data?.userId;&#13;
    const {data: session} = useSession();&#13;
    let title = `The Food Finder- A personal wish list`;&#13;
    let isCurrentUsers =&#13;
        userId &amp;&amp; session?.user.fdlst_private_userId === userId;&#13;
    return (&#13;
        &lt;div&gt;&#13;
            &lt;Head&gt;&#13;
                &lt;title&gt;{title}&lt;/title&gt;&#13;
                content={`The Food Finder. A personal wish list.`}&#13;
            &lt;/Head&gt;&#13;
            &lt;h1&gt;&#13;
                {isCurrentUsers ? " Your " : " A "}&#13;
                wish list!&#13;
            &lt;/h1&gt;&#13;
            {isCurrentUsers &amp;&amp; locations?.length === 0 &amp;&amp; (&#13;
                &lt;&gt;&#13;
                    &lt;h2&gt;Your list is currently empty! :(&lt;/h2&gt;&#13;
                    &lt;p&gt;Start adding locations to your wish list!&lt;/p&gt;&#13;
                &lt;/&gt;&#13;
            )}&#13;
            &lt;LocationsList locations={locations} /&gt;&#13;
        &lt;/div&gt;&#13;
    );&#13;
};&#13;
&#13;
export const getServerSideProps: GetServerSideProps = async (&#13;
    context: GetServerSidePropsContext&lt;ParsedUrlQuery, PreviewData&gt;&#13;
) =&gt; {&#13;
    let {userId} = context.query;&#13;
    let locations: LocationType[] | [] = [];&#13;
    try {&#13;
        await dbConnect();&#13;
        locations = await onUserWishlist(userId as string);&#13;
    } catch (err: any) {}&#13;
    return {&#13;
        // the props will be received by the page component&#13;
        props: {&#13;
            data: {locations: JSON.stringify(locations), userId: userId},&#13;
        },&#13;
    };&#13;
};&#13;
export default List;&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 15-9: The</span> <span class="Futura_Std_Book_11">pages/list/[userId].tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">Although we want the wish list page to look similar to the start page, we use SSR, with <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp>, as we did for the location detail page. The wish list page is highly dynamic; hence, we need to regenerate the HTML on each request.</p>&#13;
<p class="TX">Another approach would be to use client-side rendering, then request the user’s locations through the GraphQL API in a <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> hook. However, this would cause the user to see a loading screen each time they opened the wish list page. We can avoid this inferior user experience altogether with SSR.</p>&#13;
<p class="TX">In the server-side part of the page’s code, we first extract the URL parameter, <samp class="SANS_TheSansMonoCd_W5Regular_11">userId</samp>, from the context’s query object. We use the user’s ID and the <samp class="SANS_TheSansMonoCd_W5Regular_11">onUsersWishlist</samp> service to get all locations for the user’s wish list. If there is an error, we simply continue instead of redirecting to the <i>404</i> error page, rendering an empty list.</p>&#13;
<p class="TX">We then pass the locations array and the user’s ID to the Next.js page, where we extract the locations as usual, as well as the <samp class="SANS_TheSansMonoCd_W5Regular_11">userId</samp>. We compare the user ID from the URL with the user ID in the current session. If they match, we know that the currently logged-in user has visited their own wish list and adjust the user interface accordingly.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h3 class="H1" id="sec11"><span id="h1-91"/><samp class="SANS_Futura_Std_Bold_B_11">Adding the Button to the Location Detail Component</samp></h3>&#13;
<p class="TNI">We can now visit the wish list page, but it will always be empty. We haven’t yet provided users with a way to add items to it. To change this, we’ll place <span role="doc-pagebreak" epub:type="pagebreak" id="pg_245" aria-label=" Page 245. "/>a button in the location details component that lets users add or remove a particular location. We’ll use the generic button component and session information. Open the <i>index.ts</i> file in the <i>components/location-details.tsx</i> directory and modify the code to match <a href="chapter15.xhtml#Lis15-10">Listing 15-10</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_246" aria-label=" Page 246. "/>&#13;
<span id="Lis15-10"/>&#13;
<pre class="pre-264"><code>import {LocationType} from "mongoose/locations/schema";&#13;
import styles from "./index.module.css";&#13;
&#13;
<b>import {useSession} from "next-auth/react";</b>&#13;
<b>import {useEffect, useState} from "react";</b>&#13;
<b>import Button from "components/button";</b>&#13;
&#13;
interface PropsInterface {&#13;
    location: LocationType;&#13;
}&#13;
&#13;
<b>interface WishlistInterface {</b>&#13;
<b>    locationId: string;</b>&#13;
<b>    userId: string;</b>&#13;
<b>}</b>&#13;
&#13;
const LocationDetail = (props: PropsInterface): JSX.Element =&gt; {&#13;
    let location: LocationType = props.location;&#13;
&#13;
    <b>const {data: session} = useSession();</b>&#13;
<b>    const [onWishlist, setOnWishlist] = useState&lt;Boolean</b><b>&gt;(false);</b>&#13;
<b>    const [loading, setLoading] = useState&lt;Boolean&gt;(false);</b>&#13;
&#13;
<b>  </b>  <b>useEffect(() =&gt; {</b>&#13;
<b>        let userId = session?.user.fdlst_private_userId;</b>&#13;
<b>        setOnWishlist(</b>&#13;
<b>            userId &amp;&amp; location.on_wishlist.includes(userId) ? true : false</b>&#13;
<b>        );</b>&#13;
<b>    }, [session]);</b>&#13;
&#13;
    <b>const wishlistAction = (props: WishlistInterface) =&gt; {</b>&#13;
&#13;
<b>        const {locationId, userId} = props;</b>&#13;
&#13;
<b>        if (loading) {return false;}</b>&#13;
<b>        setLoading(true);</b>&#13;
&#13;
<b>        let action = !onWishlist ? "addWishlist" : "removeWishlist";</b>&#13;
&#13;
<b>      </b>  <b>fetch("/api/graphql", {</b>&#13;
<b>            method: "POST",</b>&#13;
<b>            headers: {</b>&#13;
<b>                "Content-Type": "application/json",</b>&#13;
<b>            },</b>&#13;
<b>            body: JSON.stringify({</b>&#13;
                <b>query: `mutation wishlist {</b>&#13;
<b>                    ${action}(</b>&#13;
<b>                        location_id: "${locationId}",</b>&#13;
<b>                        user_id: "${userId}"</b>&#13;
<b>                    ) {</b>&#13;
<b>                        on_wishlist</b>&#13;
<b>                    }</b>&#13;
<b>                }`,</b>&#13;
<b>            }),</b>&#13;
<b>        })</b>&#13;
<b>        .then((result) =&gt; {</b>&#13;
<b>            if (result.status === 200) {</b>&#13;
<b>                setOnWishlist(action === "addWishlist" ? true : false);</b>&#13;
<b>            }</b>&#13;
<b>        })</b>&#13;
<b>        .finally(() =&gt; {</b>&#13;
<b>            setLoading(false);</b>&#13;
<b>        });</b>&#13;
<b>    };</b>&#13;
&#13;
    return (&#13;
        &lt;div&gt;&#13;
            {location &amp;&amp; (&#13;
                &lt;ul className={styles.root}&gt;&#13;
                    &lt;li&gt;&#13;
                        &lt;b&gt;Address: &lt;/b&gt;&#13;
                        {location.address}&#13;
                    &lt;/li&gt;&#13;
                    &lt;li&gt;&#13;
                        &lt;b&gt;Zipcode: &lt;/b&gt;&#13;
                        {location.zipcode}&#13;
                    &lt;/li&gt;&#13;
                    &lt;li&gt;&#13;
                        &lt;b&gt;Borough: &lt;/b&gt;&#13;
                        {location.borough}&#13;
                    &lt;/li&gt;&#13;
                    &lt;li&gt;&#13;
                        &lt;b&gt;Cuisine: &lt;/b&gt;&#13;
                        {location.cuisine}&#13;
                    &lt;/li&gt;&#13;
                    &lt;li&gt;&#13;
                        &lt;b&gt;Grade: &lt;/b&gt;&#13;
                        {location.grade}&#13;
                    &lt;/li&gt;&#13;
                &lt;/ul&gt;&#13;
            )}&#13;
&#13;
            <b>{session?.user.fdlst_private_userId &amp;&amp; (</b>&#13;
<b>                &lt;Button</b>&#13;
<b>                    variant={!onWishlist ? "outline" : "blue"}</b>&#13;
<b>                    disabled={loading ? true : false}</b>&#13;
<b>                    clickHandler={() =&gt;</b>&#13;
<b>                        wishlistAction({</b>&#13;
<b>                            locationId: session?.user.fdlst_private_userId,</b>&#13;
<b>                            userId: session?.user?.userId,</b>&#13;
<b>                        })</b>&#13;
<b>                    }</b>&#13;
<b>                &gt;</b>&#13;
<b>                    {onWishlist &amp;&amp; &lt;&gt;Remove from your Wishlist&lt;/&gt;}</b>&#13;
<b>                    {!onWishlist &amp;&amp; &lt;&gt;Add to your Wishlist&lt;/&gt;}</b>&#13;
<b>                &lt;/Button&gt;</b>&#13;
<b>            )}</b>&#13;
&#13;
        &lt;/div&gt;&#13;
    );&#13;
};&#13;
export default LocationDetail;&#13;
</code></pre>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_247" aria-label=" Page 247. "/>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 15-10: The modified</span> <span class="Futura_Std_Book_11">components/location-details/index.tsx</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">First we import <samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">next-auth</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> from React, and the generic <samp class="SANS_TheSansMonoCd_W5Regular_11">Button</samp> component. Then we define <samp class="SANS_TheSansMonoCd_W5Regular_11">WishlistInterface</samp>, the interface for the <samp class="SANS_TheSansMonoCd_W5Regular_11">wishlistAction</samp> function we’ll implement in a bit.</p>&#13;
<p class="TX">Inside the component, we get the <samp class="SANS_TheSansMonoCd_W5Regular_11">session</samp> from the <samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp> hook, then create the <samp class="SANS_TheSansMonoCd_W5Regular_11">onWishlist</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">loading</samp> state variables with <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> as Boolean values. We use the first state variable to specify whether a location is currently on the user’s wish list, then update the user interface accordingly. We calculate the initial state in the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp> hook based on the location’s <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp> property. As soon as we’ve successfully added or removed the location to or from the wish list, we update the state variable and the button’s text.</p>&#13;
<p class="TX">We implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">wishlistAction</samp> function to update the <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp> property. First we deconstruct the argument object and then check the <samp class="SANS_TheSansMonoCd_W5Regular_11">loading</samp> state to see if there is currently a running request. If so, we exit the function. Otherwise, we set the loading state to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> to block the user interface, calculate the action for the GraphQL mutations, and use it to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">wishlist</samp> mutation. After successfully modifying the document in the database, we update the <samp class="SANS_TheSansMonoCd_W5Regular_11">onWishlist</samp> state and unblock the user interface.</p>&#13;
<p class="TX">We check the current session to see if the user is logged in. If so, we render the <samp class="SANS_TheSansMonoCd_W5Regular_11">Button</samp> component and set the <samp class="SANS_TheSansMonoCd_W5Regular_11">disabled</samp> and class name attributes based on the loading state, as well as an on-click event. With each click of the button, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">wishlistAction</samp> function with the current location ID and user ID as arguments. Finally, we set the button’s text based on the <samp class="SANS_TheSansMonoCd_W5Regular_11">onWishlist</samp> state, either adding the current location to the wish list or removing it.</p>&#13;
<p class="TX">Try adding and removing a few locations to the wish list before moving on. Check that the button’s text changes accordingly and that a list of locations similar to the one on the start page appears on the wish list page.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<h3 class="H1" id="sec12"><span id="h1-92"/><samp class="SANS_Futura_Std_Bold_B_11">Securing the GraphQL Mutations</samp></h3>&#13;
<p class="TNI">There is one more thing we have to do to wrap up the application: secure the GraphQL API. While the queries should be publicly available, the mutations should be accessible only to logged-in users, who should be able to add or remove only their own user ID for the <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp> property.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_248" aria-label=" Page 248. "/>But if you test the API with the <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp> command, you’ll see that, currently, everyone can access the API. Note that you must enter the values supplied to the <samp class="SANS_TheSansMonoCd_W5Regular_11">-d</samp> flag on a single line, or the server might return an error:</p>&#13;
&#13;
<pre class="pre-265"><code>$ <b>curl -v \</b>&#13;
<b>    -X POST \</b>&#13;
<b>    -H "Accept: application/json" \</b>&#13;
<b>    -H "Content-Type: application/json" \</b>&#13;
<b>    -d '{"query":"mutation wishlist {removeWishlist(location_id: \"12340\",</b>&#13;
<b> user_id: \"exampleid\") {on_wishlist}}"}' \</b>&#13;
<b>    http://localhost:3000/api/graphql</b>&#13;
&#13;
&lt; HTTP/1.1 200 OK&#13;
&lt;&#13;
{"data":{"removeWishlist":{"on_wishlist":[]}}}&#13;
</code></pre>&#13;
<p class="TX">As a test, we send a simple mutation to remove the location with the ID 12340 from a nonexistent user’s wish list. (The mutation won’t work, which is fine; we just want to verify whether the API is accessible to the public.) The command receives a <i>200</i> response and the expected JSON, proving that the mutations are public.</p>&#13;
<p class="TX">Let’s implement an <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp> to protect our mutations. A <i>guard</i> is a pattern that checks a condition and then throws an error if it isn’t met, and an <i>auth guard</i> protects a route or an API from unauthorized access.</p>&#13;
<p class="TX">We begin by creating the file <i>auth-guards.ts</i> in the <i>middleware</i> folder and adding the code in <a href="chapter15.xhtml#Lis15-11">Listing 15-11</a>.</p>&#13;
<span id="Lis15-11"/>&#13;
<pre class="pre-266"><code>import {GraphQLError} from "graphql/error";&#13;
import {JWT} from "next-auth/jwt";&#13;
&#13;
interface paramInterface {&#13;
    user_id: string;&#13;
    location_id: string;&#13;
}&#13;
interface contextInterface {&#13;
    token: JWT;&#13;
}&#13;
&#13;
export const authGuard = (&#13;
    param: paramInterface,&#13;
    context: contextInterface&#13;
): boolean | Error =&gt; {&#13;
&#13;
 <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> if (!context || !context.token || !context.token.fdlst_private_userId) {&#13;
        return new GraphQLError("User is not authenticated", {&#13;
            extensions: {&#13;
                http: {status: 500},&#13;
                code: "UNAUTHENTICATED",&#13;
            },&#13;
        });&#13;
    }&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_249" aria-label=" Page 249. "/> <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> if (context?.token?.fdlst_private_userId !== param.user_id) {&#13;
        return new GraphQLError("User is not authorized", {&#13;
            extensions: {&#13;
                http: {status: 500},&#13;
                code: "UNAUTHORIZED",&#13;
            },&#13;
        });&#13;
    }&#13;
    return true;&#13;
};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 15-11: The</span> <span class="Futura_Std_Book_11">middleware/auth-guards.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file</span></p>&#13;
<p class="TX">We also import <samp class="SANS_TheSansMonoCd_W5Regular_11">JWT</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">next-auth</samp> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphQLError</samp> constructor from <samp class="SANS_TheSansMonoCd_W5Regular_11">graphql</samp>. We’ll use the latter to create the error objects returned to the user if authentication fails. Next, we define our interfaces for the <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp> function’s arguments and export the function itself.</p>&#13;
<p class="TX">We’ll call the auth guard from the mutation resolver with two parameters: an object with the user ID and the location ID, for which we defined the <samp class="SANS_TheSansMonoCd_W5Regular_11">paramInterface</samp>, and the context object with the token, the <samp class="SANS_TheSansMonoCd_W5Regular_11">contextInterface</samp>. The auth guard returns either a Boolean indicating that authentication succeeded or an error. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp> function, we verify that every access to our mutation has a token with a private claim <span class="AnnotationCode" aria-label="annotation1">❶</span> and that the user ID in the private claim matches the user ID we pass to the mutation <span class="AnnotationCode" aria-label="annotation2">❷</span>. In other words, we verify that a logged-in user has made the API request and that they’re modifying their own wish list.</p>&#13;
<p class="TX">If the checks fail, we create an error with a message and code. In addition, we set the HTTP status code to <i>500</i>. Remember that unlike REST APIs, which rely on an extensive list of precise HTTP status codes to communicate with the caller, a GraphQL API usually uses either <i>200</i> or <i>500</i> as the status code for errors. Broadly speaking, we send a <i>500</i> status code when GraphQL can’t execute the query at all and <i>200</i> when the query can be executed. In both cases, the GraphQL API should include precise information about what error occurred.</p>&#13;
<p class="TX">Now we must pass the user’s OAuth token to the resolvers, which will then pass it to the auth guard. To do so, we’ll use the context function we implemented in the <samp class="SANS_TheSansMonoCd_W5Regular_11">startServerAndCreateNextHandler</samp> function, found in the <i>pages/api/graphql.ts</i> file. Open the file and adjust it to match the code in <a href="chapter15.xhtml#Lis15-12">Listing 15-12</a>.</p>&#13;
<span id="Lis15-12"/>&#13;
<pre class="pre-267"><code>import {ApolloServer, BaseContext} from "@apollo/server";&#13;
import {startServerAndCreateNextHandler} from "@as-integrations/next";&#13;
&#13;
import {resolvers} from "graphql/resolvers";&#13;
import {typeDefs} from "graphql/schema";&#13;
import dbConnect from "middleware/db-connect";&#13;
&#13;
import {NextApiHandler, NextApiRequest, NextApiResponse} from "next";&#13;
&#13;
<b>import {getToken} from "next-auth/jwt";</b>&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_250" aria-label=" Page 250. "/>const server = new ApolloServer&lt;BaseContext&gt;({&#13;
    resolvers,&#13;
    typeDefs,&#13;
});&#13;
&#13;
const handler = startServerAndCreateNextHandler(server, {&#13;
    context: async (<b>req:</b> <b>NextApiRequest</b>) =&gt; {&#13;
        <b>const token = await getToken({req});</b>&#13;
        return {<b>token</b>};&#13;
    },&#13;
});&#13;
&#13;
const allowCors =&#13;
    (fn: NextApiHandler) =&gt;&#13;
    async (req: NextApiRequest, res: NextApiResponse) =&gt; {&#13;
        res.setHeader("Allow", "POST");&#13;
        res.setHeader("Access-Control-Allow-Origin", "*");&#13;
        res.setHeader("Access-Control-Allow-Methods", "POST");&#13;
        res.setHeader("Access-Control-Allow-Headers", "*");&#13;
        res.setHeader("Access-Control-Allow-Credentials", "true");&#13;
&#13;
        if (req.method === "OPTIONS") {&#13;
            res.status(200).end();&#13;
        }&#13;
        return await fn(req, res);&#13;
    };&#13;
&#13;
const connectDB =&#13;
    (fn: NextApiHandler) =&gt;&#13;
    async (req: NextApiRequest, res: NextApiResponse) =&gt; {&#13;
        await dbConnect();&#13;
        return await fn(req, res);&#13;
    };&#13;
&#13;
export default connectDB(allowCors(handler));&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 15-12: The modified</span> <span class="Futura_Std_Book_11">pages/api/graphql.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file with the JWT token</span></p>&#13;
<p class="TX">Unlike on the client side, where we can access the session information directly via the <samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp> hook, here we need to access it through the JWT on the server side. This is because the session information is part of the API request’s HTTP cookies on the server instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionProvider</samp>’s shared session state, and we need to extract it from the request. To do so, we import the <samp class="SANS_TheSansMonoCd_W5Regular_11">getToken</samp> function from the <i>next-auth</i> <samp class="SANS_TheSansMonoCd_W5Regular_11">jwt</samp> module. Then we pass the request object we receive from the <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> function to call <samp class="SANS_TheSansMonoCd_W5Regular_11">getToken</samp> and await the decoded JWT. Next, we return the token from the <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> function so that we can access the token in the resolver functions.</p>&#13;
<p class="TX">Finally, let’s use the token to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp> to our resolvers to protect them from unauthenticated and unauthorized access. Open the <i>graphql/locations/mutations.ts</i> file and update it with the code from <a href="chapter15.xhtml#Lis15-13">Listing 15-13</a>.</p>&#13;
<span id="Lis15-13"/>&#13;
<pre class="pre-268"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_251" aria-label=" Page 251. "/>import {updateWishlist} from "mongoose/locations/services";&#13;
<b>import {authGuard} from "middleware/auth-guard";</b>&#13;
<b>import {JWT} from "next-auth/jwt";</b>&#13;
&#13;
interface UpdateWishlistInterface {&#13;
    user_id: string;&#13;
    location_id: string;&#13;
}&#13;
&#13;
<b>interface contextInterface {</b>&#13;
<b>    token: JWT;</b>&#13;
<b>}</b>&#13;
&#13;
export const locationMutations = {&#13;
    removeWishlist: async (&#13;
        _: any,&#13;
        param: UpdateWishlistInterface,&#13;
        <b>context: contextInterface</b>&#13;
    ) =&gt; {&#13;
&#13;
<b>        const guard = authGuard(param, context);</b>&#13;
<b>        if (guard !== true) {return guard;}</b>&#13;
&#13;
        return await updateWishlist(param.location_id, param.user_id, "remove");&#13;
    },&#13;
&#13;
    addWishlist: async (&#13;
        _: any,&#13;
        param: UpdateWishlistInterface,&#13;
        <b>context: contextInterface</b>&#13;
    ) =&gt; {&#13;
&#13;
<b>        const guard = authGuard(param, context);</b>&#13;
<b>        if (guard !== true) {return guard;}</b>&#13;
&#13;
        return await updateWishlist(param.location_id, param.user_id, "add");&#13;
    },&#13;
};&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 15-13: The</span> <span class="Futura_Std_Book_11">graphql/locations/mutations.ts</span> <span class="Futura_Std_Book_Oblique_BI_11">file with the added</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">authGuard</samp></p>&#13;
<p class="TX">We define a new interface for the context and update the context parameter to contain the JWT. Next, we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp> function to our mutations and follow the guard pattern by returning the error immediately instead of proceeding with the code.</p>&#13;
<p class="TX">To test the <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp> functionality, run <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp> again. The command line output should look similar to <a href="chapter15.xhtml#Lis15-14">Listing 15-14</a>.</p>&#13;
<span id="Lis15-14"/>&#13;
<pre class="pre-269"><code>$ <b>curl -v \</b>&#13;
<b>    -X POST \</b>&#13;
<b>    -H "Accept: application/json" \</b>&#13;
<b>    -H "Content-Type: application/json" \</b>&#13;
<b>    -d '{"query":"mutation wishlist {removeWishlist(location_id: \"12340\",</b>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_252" aria-label=" Page 252. "/><b>  user_id: \"exampleid\") {on_wishlist}}"}' \</b>&#13;
<b>  http://localhost:3000/api/graphql</b>&#13;
&#13;
&lt; HTTP/1.1 500 Internal Server Error&#13;
&lt;&#13;
{&#13;
    "errors":[&#13;
        {&#13;
            "message":"User is not authenticated",&#13;
            "locations": [{"line":1,"column":20}],&#13;
            "path": ["removeWishlist"],&#13;
            "extensions": {"code":"UNAUTHENTICATED","data":null}&#13;
        }&#13;
    ]&#13;
}&#13;
</code></pre>&#13;
<p class="__FIG"><span class="Futura_Std_Book_Oblique_BI_11">Listing 15-14: The</span> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">curl</samp> <span class="Futura_Std_Book_Oblique_BI_11">command to test our API</span></p>&#13;
<p class="TX">Unlike the previous <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp> call, the GraphQL API now responds with <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/1.1 500 Internal Server Error</samp> and an extensive error message, which we defined when we created the <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphQLError</samp> in the <i>auth-guards.ts</i> file.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h3 class="H1" id="sec13"><span id="h1-93"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>&#13;
<p class="TNI">We’ve successfully added an OAuth authentication flow to the Food Finder application. Now the user can log in with their GitHub account. Once logged in, they can maintain their personal public wish list. In addition, we’ve protected the GraphQL mutations, meaning they are no longer available to anyone; instead, only logged-in users can access them. In the final chapter, we’ll add automated tests to evaluate the application using Jest.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>