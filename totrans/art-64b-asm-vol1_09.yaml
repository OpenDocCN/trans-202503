- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Low-Level Control Structures
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter discusses how to convert high-level–language control structures
    into assembly language control statements. The examples up to this point have
    created assembly control structures in an ad hoc manner. Now it’s time to formalize
    how to control the operation of your assembly language programs. By the time you
    finish this chapter, you should be able to convert HLL control structures into
    assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: Control structures in assembly language consist of conditional branches and
    indirect jumps. This chapter discusses those instructions and how to emulate HLL
    control structures (such as `if/else`, `switch`, and loop statements). This chapter
    also discusses labels (the targets of conditional branches and jump statements)
    as well as the scope of labels in an assembly language source file.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1 Statement Labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before discussing jump instructions and how to emulate control structures using
    them, an in-depth discussion of assembly language statement labels is necessary.
    In an assembly language program, *labels* stand in as symbolic names for addresses.
    It is far more convenient to refer to a position in your code by using a name
    such as `LoopEntry` rather than a numeric address such as 0AF1C002345B7901Eh.
    For this reason, assembly language low-level control structures make extensive
    use of labels within source code (see “Brief Detour: An Introduction to Control
    Transfer Instructions” in Chapter 2).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do three things with (code) labels: transfer control to a label via
    a (conditional or unconditional) jump instruction, call a label via the `call`
    instruction, and take the address of a label. Taking the address of a label is
    useful when you want to indirectly transfer control to that address at a later
    point in your program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sequence demonstrates two ways to take the address of a
    label in your program (using the `lea` instruction and using the `offset` operator):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Because addresses are 64-bit quantities, you’ll typically load an address into
    a 64-bit general-purpose register by using the `lea` instruction. Because that
    instruction uses a 32-bit relative displacement from the current instruction,
    the instruction encoding is significantly shorter than the `mov` instruction (which
    encodes a full 8-byte constant in addition to the opcode bytes).
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.1 Using Local Symbols in Procedures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Statement labels you define within a `proc`/`endp` procedure are *local* to
    that procedure, in the sense of *lexical* *scope*: the statement label is visible
    only within that procedure; you cannot refer to that statement label outside the
    procedure. [Listing 7-1](#listing7-1) demonstrates that you cannot refer to a
    symbol inside another procedure (note that this program will not assemble because
    of this error).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-1: Demonstration of lexically scoped symbols'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command to assemble this file (and the corresponding diagnostic message)
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you really want to access a statement (or any other) label outside a procedure,
    you can use the `option` directive to turn off local scope within a section of
    your program, as noted in Chapter 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first form tells MASM to stop making symbols (inside `proc`/`endp`) local
    to the procedure containing them. The second form restores the lexical scoping
    of symbols in procedures. Therefore, using these two directives, you can turn
    scoping on or off for various sections of your source file (including as little
    as a single statement, if you like). [Listing 7-2](#listing7-2) demonstrates how
    to use the `option` directive to make a single symbol global outside the procedure
    containing it (note that this program still has compile errors).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-2: The `option scoped` and `option noscoped` directives'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command (and diagnostic output) for [Listing 7-2](#listing7-2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from MASM’s output, the `notLocal` symbol (appearing after the
    `option noscoped` directive) did not generate an undefined symbol error. However,
    the `localStmtLbl` and `isLocal` symbols, which are local to `hasLocalLbl`, are
    undefined outside that procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 7.1.2 Initializing Arrays with Label Addresses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MASM also allows you to initialize quad-word variables with the addresses of
    statement labels. However, labels that appear in the initialization portions of
    variable declarations have some restrictions. The most important restriction is
    that the symbol must be in the same lexical scope as the data declaration attempting
    to use it. So, either the `qword` directive must appear inside the same procedure
    as the statement label, or you must use the `option noscoped` directive to make
    the symbol(s) global to the procedure. [Listing 7-3](#listing7-3) demonstrates
    these two ways to initialize a `qword` variable with statement label addresses.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-3: Initializing qword variables with the address of statement labels'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you compile [Listing 7-3](#listing7-3) with the following command, you’ll
    get no assembly errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the *listing7-3.lst* output file that MASM produces, you can
    see that MASM properly initializes the qword declarations with the (section-relative/relocatable)
    offsets of the statement labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Transferring control to a statement label inside a procedure is generally considered
    bad programming practice. Unless you have a good reason to do so, you probably
    shouldn’t.
  prefs: []
  type: TYPE_NORMAL
- en: As addresses on the x86-64 are 64-bit quantities, you will typically use the
    `qword` directive (as in the previous examples) to initialize a data object with
    the address of a statement label. However, if your program is (always going to
    be) smaller than 2GB, and you set the `LARGEADDRESSAWARE:NO` flag (using *sbuild.bat*),
    you can get away with using `dword` data declarations to hold the address of a
    label. Of course, as this book has pointed out many times, using 32-bit addresses
    in your 64-bit programs can lead to problems if you ever exceed 2GB of storage
    for your program.
  prefs: []
  type: TYPE_NORMAL
- en: 7.2 Unconditional Transfer of Control (jmp)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `jmp` (*jump*) instruction unconditionally transfers control to another
    point in the program. This instruction has three forms: a direct jump and two
    indirect jumps. These take the following forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first instruction is a *direct jump*, which you’ve seen in various sample
    programs up to this point. For direct jumps, you normally specify the target address
    by using a statement label. The label appears either on the same line as an executable
    machine instruction or by itself on a line preceding an executable machine instruction.
    The direct jump is completely equivalent to a `goto` statement in a high-level
    language.^([1](#c07-footnote-1))
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 7.2.1 Register-Indirect Jumps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second form of the `jmp` instruction given earlier—`jmp` `reg`64—is a *register-**indirect
    jump* instruction that transfers control to the instruction whose address appears
    in the specified 64-bit general-purpose register. To use this form of the `jmp`
    instruction, you must load a 64-bit register with the address of a machine instruction
    prior to the execution of the `jmp`. When several paths, each loading the register
    with a different address, converge on the same `jmp` instruction, control transfers
    to an appropriate location determined by the path up to that point.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-4](#listing7-4) reads a string of characters from the user that
    contain an integer value. It uses the C Standard Library function `strtol()` to
    convert that string to a binary integer value. The `strtol()` function doesn’t
    do the greatest job of reporting an error, so this program tests the return results
    to verify a correct input and uses register-indirect jumps to transfer control
    to different code paths based on the result.'
  prefs: []
  type: TYPE_NORMAL
- en: The first part of [Listing 7-4](#listing7-4) contains constants, variables,
    external declarations, and the (usual) `getTitle()` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The next section of [Listing 7-4](#listing7-4) is the `strToInt()` function,
    a wrapper around the C Standard Library `strtol()` function that does a more thorough
    job of handling erroneous inputs from the user. See the comments for the function’s
    return values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The final section of [Listing 7-4](#listing7-4) is the main program. This is
    the part of code most interesting to us. It loads the RBX register with the address
    of code to execute based on the `strToInt()` return results. The `strToInt()`
    function returns one of the following states (see the comments in the previous
    code for an explanation):'
  prefs: []
  type: TYPE_NORMAL
- en: Valid input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Illegal characters at the beginning of the string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Illegal characters at the end of the string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Range error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program then transfers control to different sections of `asmMain()` based
    on the value held in RBX (which specifies the type of result `strToInt()` returns).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-4: Using register-indirect `jmp` instructions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and a sample run of the program in [Listing 7-4](#listing7-4):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 7.2.2 Memory-Indirect Jumps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The third form of the `jmp` instruction is a *memory-indirect* *jump*, which
    fetches the quad-word value from the memory location and jumps to that address.
    This is similar to the register-indirect `jmp` except the address appears in a
    memory location rather than in a register.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-5](#listing7-5) demonstrates a rather trivial use of this form of
    the `jmp` instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-5: Using memory-indirect `jmp` instructions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and output for [Listing 7-5](#listing7-5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that you can easily crash your system if you execute an indirect jump with
    an invalid pointer value.
  prefs: []
  type: TYPE_NORMAL
- en: 7.3 Conditional Jump Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although Chapter 2 provided an overview of the conditional jump instructions,
    repeating that discussion and expanding upon it here is worthwhile as conditional
    jumps are the principal tool for creating control structures in assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the unconditional `jmp` instruction, the conditional jump instructions
    do not provide an indirect form. They only allow a branch to a statement label
    in your program.
  prefs: []
  type: TYPE_NORMAL
- en: Intel’s documentation defines various synonyms or instruction aliases for many
    conditional jump instructions. Tables 7-1, 7-2, and 7-3 list all the aliases for
    a particular instruction, as well as the opposite branches. You’ll soon see the
    purpose of the opposite branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 7-1: `j``cc` Instructions That Test Flags'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Description** | **Condition** | **Aliases** | **Opposite**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `jc` | Jump if carry | Carry = 1 | `jb`, `jnae` | `jnc` |'
  prefs: []
  type: TYPE_TB
- en: '| `jnc` | Jump if no carry | Carry = 0 | `jnb`, `jae` | `jc` |'
  prefs: []
  type: TYPE_TB
- en: '| `jz` | Jump if zero | Zero = 1 | `je` | `jnz` |'
  prefs: []
  type: TYPE_TB
- en: '| `jnz` | Jump if not zero | Zero = 0 | `jne` | `jz` |'
  prefs: []
  type: TYPE_TB
- en: '| `js` | Jump if sign | Sign = 1 |  | `jns` |'
  prefs: []
  type: TYPE_TB
- en: '| `jns` | Jump if no sign | Sign = 0 |  | `js` |'
  prefs: []
  type: TYPE_TB
- en: '| `jo` | Jump if overflow | Overflow = 1 |  | `jno` |'
  prefs: []
  type: TYPE_TB
- en: '| `jno` | Jump if no overflow | Overflow = 0 |  | `jo` |'
  prefs: []
  type: TYPE_TB
- en: '| `jp` | Jump if parity | Parity = 1 | `jpe` | `jnp` |'
  prefs: []
  type: TYPE_TB
- en: '| `jpe` | Jump if parity even | Parity = 1 | `jp` | `jpo` |'
  prefs: []
  type: TYPE_TB
- en: '| `jnp` | Jump if no parity | Parity = 0 | `jpo` | `jp` |'
  prefs: []
  type: TYPE_TB
- en: '| `jpo` | Jump if parity odd | Parity = 0 | `jnp` | `jpe` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7-2: `j``cc` Instructions for Unsigned Comparisons'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Description** | **Condition** | **Aliases** | **Opposite**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ja` | Jump if above (`>`) | Carry = 0, Zero = 0 | `jnbe` | `jna` |'
  prefs: []
  type: TYPE_TB
- en: '| `jnbe` | Jump if not below or equal (not `≤`) | Carry = 0, Zero = 0 | `ja`
    | `jbe` |'
  prefs: []
  type: TYPE_TB
- en: '| `jae` | Jump if above or equal (`≥`) | Carry = 0 | `jnc`, `jnb` | `jnae`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `jnb` | Jump if not below (not `<`) | Carry = 0 | `jnc`, `jae` | `jb` |'
  prefs: []
  type: TYPE_TB
- en: '| `jb` | Jump if below (`<`) | Carry = 1 | `jc`, `jnae` | `jnb` |'
  prefs: []
  type: TYPE_TB
- en: '| `jnae` | Jump if not above or equal (not `≥`) | Carry = 1 | `jc`, `jb` |
    `jae` |'
  prefs: []
  type: TYPE_TB
- en: '| `jbe` | Jump if below or equal (`≤`) | Carry = 1 or Zero = 1 | `jna` | `jnbe`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `jna` | Jump if not above (not `>`) | Carry = 1 or Zero = 1 | `jbe` | `ja`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `je` | Jump if equal (`=`) | Zero = 1 | `jz` | `jne` |'
  prefs: []
  type: TYPE_TB
- en: '| `jne` | Jump if not equal (`≠`) | Zero = 0 | `jnz` | `je` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7-3: `j``cc` Instructions for Signed Comparisons'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Description** | **Condition** | **Aliases** | **Opposite**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `jg` | Jump if greater (`>`) | Sign = Overflow or Zero = 0 | `jnle` | `jng`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `jnle` | Jump if not less than or equal (not `≤`) | Sign = Overflow or Zero
    = 0 | `jg` | `jle` |'
  prefs: []
  type: TYPE_TB
- en: '| `jge` | Jump if greater than or equal (`≥`) | Sign = Overflow | `jnl` | `jnge`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `jnl` | Jump if not less than (not `<`) | Sign = Overflow | `jge` | `jl`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `jl` | Jump if less than (`<`) | Sign `≠` Overflow | `jnge` | `jnl` |'
  prefs: []
  type: TYPE_TB
- en: '| `jnge` | Jump if not greater or equal (not `≥`) | Sign `≠` Overflow | `jl`
    | `jge` |'
  prefs: []
  type: TYPE_TB
- en: '| `jle` | Jump if less than or equal (`≤`) | Sign `≠` Oveflow or Zero = 1 |
    `jng` | `jnle` |'
  prefs: []
  type: TYPE_TB
- en: '| `jng` | Jump if not greater than (not `>`) | Sign `≠` Overflow or Zero =
    1 | `jle` | `jg` |'
  prefs: []
  type: TYPE_TB
- en: '| `je` | Jump if equal (`=`) | Zero = 1 | `jz` | `jne` |'
  prefs: []
  type: TYPE_TB
- en: '| `jne` | Jump if not equal (`≠`) | Zero = 0 | `jnz` | `je` |'
  prefs: []
  type: TYPE_TB
- en: 'In many instances, you will need to generate the opposite of a specific branch
    instruction (examples appear later in this section). With only two exceptions,
    the *opposite branch (N/No N)* rule describes how to generate an opposite branch:'
  prefs: []
  type: TYPE_NORMAL
- en: If the second letter of the `j``cc` instruction is not an `n`, insert an `n`
    after the `j`. For example, `je` becomes `jne`, and `jl` becomes `jnl`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the second letter of the `j``cc` instruction is an `n`, remove that `n` from
    the instruction. For example, `jng` becomes `jg`, and `jne` becomes `je`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two exceptions to this rule are `jpe` (*jump if parity is even*) and `jpo`
    (*jump if parity is odd*).^([2](#c07-footnote-2)) However, you can use the aliases
    `jp` and `jnp` as synonyms for `jpe` and `jpo`, and the N/No N rule applies to
    `jp` and `jnp`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The x86-64 conditional jump instructions give you the ability to split program
    flow into one of two paths depending on a certain condition. Suppose you want
    to increment the AX register if BX is equal to CX. You can accomplish this with
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Instead of checking for equality directly and branching to code to handle that
    condition, the common approach is to use the opposite branch to skip over the
    instructions you want to execute if the condition is true. That is, if BX is *not*
    equal to CX, jump over the increment instruction. Always use the opposite branch
    (N/No N) rule given earlier to select the opposite branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the conditional jump instructions to synthesize loops. For
    example, the following code sequence reads a sequence of characters from the user
    and stores each character in successive elements of an array until the user presses
    enter (newline):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The conditional jump instructions only test the x86-64 flags; they do not affect
    any of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'From an efficiency point of view, it’s important to note that each conditional
    jump has two machine code encodings: a 2-byte form and a 6-byte form.'
  prefs: []
  type: TYPE_NORMAL
- en: The 2-byte form consists of the `j``cc` opcode followed by a 1-byte PC-relative
    displacement. The 1-byte displacement allows the instruction to transfer control
    to a target instruction within about ±127 bytes around the current instruction.
    Given that the average x86-64 instruction is probably 4 to 5 bytes long, the 2-byte
    form of `j``cc` is capable of branching to a target instruction within about 20
    to 25 instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Because a range of 20 to 25 instructions is insufficient for all conditional
    jumps, the x86-64 provides a second (6-byte) form with a 2-byte opcode and a 4-byte
    displacement. The 6-byte form gives you the ability to jump to an instruction
    within approximately ±2GB of the current instruction, which is probably sufficient
    for any reasonable program out there.
  prefs: []
  type: TYPE_NORMAL
- en: If you have the opportunity to branch to a nearby label rather than one that
    is far away (and still achieve the same result), branching to the nearby label
    will make your code shorter and possibly faster.
  prefs: []
  type: TYPE_NORMAL
- en: 7.4 Trampolines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the rare case you need to branch to a location beyond the range of the 6-byte
    `j``cc` instructions, you can use an instruction sequence such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The opposite conditional branch transfers control to the normal *fall-though
    point* in the code (the code you’d normally fall through to if the condition is
    false). If the condition is true, control transfers to a memory-indirect jump
    that jumps to the original target location via a 64-bit pointer.
  prefs: []
  type: TYPE_NORMAL
- en: This sequence is known as a *trampoline*, because a program jumps to this point
    to jump even further in the program (much like how jumping on a trampoline lets
    you jump higher and higher). Trampolines are useful for call and unconditional
    jump instructions that use the PC-relative addressing mode (and, thus, are limited
    to a ±2GB range around the current instruction).
  prefs: []
  type: TYPE_NORMAL
- en: You’ll rarely use trampolines to transfer to another location within your program.
    However, trampolines are useful when transferring control to a dynamically linked
    library or OS subroutine that could be far away in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 7.5 Conditional Move Instructions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes all you need to do after a comparison or other conditional test is
    to load a value into a register (and, conversely, not load that value if the test
    or comparison fails). Because branches can be somewhat expensive to execute, the
    x86-64 CPUs support a set of conditional move instructions, `cmov``cc`. These
    instructions appear in Tables 7-4, 7-5, and 7-6; the generic syntax for these
    instructions is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The destination is always a general-purpose register (16, 32, or 64 bits). You
    can use these instructions only to load a register from memory or copy data from
    one register to another; you cannot use them to conditionally store data to memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 7-4: `cmov``cc` Instructions That Test Flags'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Description** | **Condition** | **Aliases** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovc` | Move if carry | Carry = 1 | `cmovb`, `cmovnae` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovnc` | Move if no carry | Carry = 0 | `cmovnb`, `cmovae` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovz` | Move if zero | Zero = 1 | `cmove` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovnz` | Move if not zero | Zero = 0 | `cmovne` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovs` | Move if sign | Sign = 1 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovns` | Move if no sign | Sign = 0 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovo` | Move if overflow | Overflow = 1 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovno` | Move if no overflow | Overflow = 0 |  |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovp` | Move if parity | Parity = 1 | `cmovpe` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovpe` | Move if parity even | Parity = 1 | `cmovp` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovnp` | Move if no parity | Parity = 0 | `cmovpo` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovpo` | Move if parity odd | Parity = 0 | `cmovnp` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7-5: `cmov``cc` Instructions for Unsigned Comparisons'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Description** | **Condition** | **Aliases** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cmova` | Move if above (`>`) | Carry = 0, Zero = 0 | `cmovnbe` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovnbe` | Move if not below or equal (not `≤`) | Carry = 0, Zero = 0 |
    `cmova` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovae` | Move if above or equal (`≥`) | Carry = 0 | `cmovnc`, `cmovnb`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovnb` | Move if not below (not `<`) | Carry = 0 | `cmovnc`, `cmovae` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovb` | Move if below (`<`) | Carry = 1 | `cmovc`, `cmovnae` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovnae` | Move if not above or equal (not `≥`) | Carry = 1 | `cmovc`, `cmovb`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovbe` | Move if below or equal (`≤`) | Carry = 1 or Zero = 1 | `cmovna`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovna` | Move if not above (not `>`) | Carry = 1 or Zero = 1 | `cmovbe`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `cmove` | Move if equal (`=`) | Zero = 1 | `cmovz` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovne` | Move if not equal (`≠`) | Zero = 0 | `cmovnz` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 7-6: `cmov``cc` Instructions for Signed Comparisons'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Description** | **Condition** | **Aliases** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovg` | Move if greater (`>`) | Sign = Overflow or Zero = 0 | `cmovnle`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovnle` | Move if not less than or equal (not `≤`) | Sign = Overflow or
    Zero = 0 | `cmovg` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovge` | Move if greater than or equal (`≥`) | Sign = Overflow | `cmovnl`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovnl` | Move if not less than (not `<`) | Sign = Overflow | `cmovge` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovl` | Move if less than (`<`) | Sign != Overflow | `cmovnge` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovnge` | Move if not greater or equal (not `≥`) | Sign != Overflow | `cmovl`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovle` | Move if less than or equal (`≤`) | Sign != Overflow or Zero =
    1 | `cmovng` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovng` | Move if not greater than (not `>`) | Sign != Overflow or Zero
    = 1 | `cmovle` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmove` | Move if equal (`=`) | Zero = 1 | `cmovz` |'
  prefs: []
  type: TYPE_TB
- en: '| `cmovne` | Move if not equal (`≠`) | Zero = 0 | `cmovnz` |'
  prefs: []
  type: TYPE_TB
- en: In addition, a set of conditional floating-point move instructions (`fcmov``cc`)
    will move data between ST0 and one of the other FPU registers on the FPU stack.
    Sadly, these instructions aren’t all that useful in modern programs. See the Intel
    documentation for more details if you’re interested in using them.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6 Implementing Common Control Structures in Assembly Language
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This section shows you how to implement decisions, loops, and other control
    constructs using pure assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.1 Decisions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In its most basic form, a *decision* is a branch within the code that switches
    between two possible execution paths based on a certain condition. Normally (though
    not always), conditional instruction sequences are implemented with the conditional
    jump instructions. Conditional instructions correspond to the `if/then/endif`
    statement in an HLL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To convert this to assembly language, you must write statements that evaluate
    the `expression` and then branch around the `statements` if the result is false.
    For example, if you had the C statements
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'you could translate this to assembly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, conditional statements may be broken into three basic categories:
    `if` statements, `switch`/`case` statements, and indirect jumps. The following
    sections describe these program structures, how to use them, and how to write
    them in assembly language.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.2 if/then/else Sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most common conditional statements are the `if/then/endif` and `if/then/else/endif`
    statements. These two statements take the form shown in [Figure 7-1](#figure7-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f07001](image_fi/501089c07/f07001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1: `if``/``then``/``else``/``endif` and `if``/``then``/``endif` statement
    flow'
  prefs: []
  type: TYPE_NORMAL
- en: The `if/then/endif` statement is just a special case of the `if/then/else/endif`
    statement (with an empty `else` block). The basic implementation of an `if/then/else/endif`
    statement in x86-64 assembly language looks something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: where `j``cc` represents a conditional jump instruction.
  prefs: []
  type: TYPE_NORMAL
- en: For example, to convert the C/C++ statement
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'to assembly language, you could use the following x86-64 code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'For simple expressions like `(a == b)`, generating the proper code for an `if/then/else/endif`
    statement is almost trivial. Should the expression become more complex, the code
    complexity increases as well. Consider the following C/C++ `if` statement presented
    earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert complex `if` statements such as this one, break it into a sequence
    of three `if` statements as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This conversion comes from the following C/C++ equivalences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: is equivalent to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: is equivalent to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In assembly language, the former `if` statement becomes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Probably the biggest problem with complex conditional statements in assembly
    language is trying to figure out what you’ve done after you’ve written the code.
    High-level language expressions are much easier to read and comprehend. Well-written
    comments are essential for clear assembly language implementations of `if/then/else/endif`
    statements. An elegant implementation of the preceding example follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Admittedly, this goes overboard for such a simple example. The following would
    probably suffice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: However, as your `if` statements become complex, the density (and quality) of
    your comments becomes more and more important.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.3 Complex if Statements Using Complete Boolean Evaluation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Many Boolean expressions involve conjunction (`and`) or disjunction (`or`)
    operations. This section describes how to convert such Boolean expressions into
    assembly language. We can do this in two ways: using *complete Boolean evaluation*
    or using *short-circuit Boolean evaluation*. This section discusses complete Boolean
    evaluation. The next section discusses short-circuit Boolean evaluation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversion via complete Boolean evaluation is almost identical to converting
    arithmetic expressions into assembly language, as covered in Chapter 6. However,
    for Boolean evaluation, you do not need to store the result in a variable; once
    the evaluation of the expression is complete, you check whether you have a false
    (0) or true (1, or nonzero) result to take whatever action the Boolean expression
    dictates. Usually, the last logical instruction (`and`/`or`) sets the zero flag
    if the result is false and clears the zero flag if the result is true, so you
    don’t have to explicitly test for the result. Consider the following `if` statement
    and its conversion to assembly language using complete Boolean evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This code computes a Boolean result in the BL register and then, at the end
    of the computation, tests this value to see whether it contains true or false.
    If the result is false, this sequence skips over the code associated with `Stmt1`.
    The important thing to note in this example is that the program will execute every
    instruction that computes this Boolean result (up to the `je` instruction).
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.4 Short-Circuit Boolean Evaluation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are willing to expend a little more effort, you can usually convert a
    Boolean expression to a much shorter and faster sequence of assembly language
    instructions by using *short-circuit Boolean evaluation*. This approach attempts
    to determine whether an expression is true or false by executing only some of
    the instructions that would compute the complete expression.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the expression `a && b`. Once we determine that `a` is false, there
    is no need to evaluate `b` because there is no way the expression can be true.
    If `b` represents a complex subexpression rather than a single Boolean variable,
    it should be clear that evaluating only `a` is more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a concrete example, consider the subexpression `((x < y) && (z > t))` from
    the previous section. Once you determine that `x` is not less than `y`, there
    is no need to check whether `z` is greater than `t` because the expression will
    be false regardless of `z`’s and `t`’s values. The following code fragment shows
    how you can implement short-circuit Boolean evaluation for this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The code skips any further testing once it determines that `x` is not less than
    `y`. Of course, if `x` is less than `y`, the program has to test `z` to see if
    it is greater than `t`; if not, the program skips over the `then` clause. Only
    if the program satisfies both conditions does the code fall through to the `then`
    clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the logical `or` operation, the technique is similar. If the first subexpression
    evaluates to true, there is no need to test the second operand. Whatever the second
    operand’s value is at that point, the full expression still evaluates to true.
    The following example demonstrates the use of short-circuit evaluation with disjunction
    (`or`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the conjunction and disjunction operators are commutative, you can
    evaluate the left or right operand first if it is more convenient to do so.^([3](#c07-footnote-3))
    As one last example in this section, consider the full Boolean expression from
    the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The code in this example evaluates `a != b` first, because it is shorter and
    faster,^([4](#c07-footnote-4)) and the remaining subexpression last. This is a
    common technique assembly language programmers use to write better code.^([5](#c07-footnote-5))
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.5 Short-Circuit vs. Complete Boolean Evaluation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When using complete Boolean evaluation, every statement in the sequence for
    that expression will execute; short-circuit Boolean evaluation, on the other hand,
    may not require the execution of every statement associated with the Boolean expression.
    As you’ve seen in the previous two sections, code based on short-circuit evaluation
    is usually shorter and faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, short-circuit Boolean evaluation may not produce the correct result
    in some cases. Given an expression with *side effects*, short-circuit Boolean
    evaluation will produce a different result than complete Boolean evaluation. Consider
    the following C/C++ example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Using complete Boolean evaluation, you might generate the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Using short-circuit Boolean evaluation, you might generate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice a subtle but important difference between these two conversions: if
    `x` is equal to `y`, the first version still *increments* `z` *and compares it
    to 0* before it executes the code associated with `Stmt`; the short-circuit version,
    on the other hand, skips the code that increments `z` if it turns out that `x`
    is equal to `y`. Therefore, the behavior of these two code fragments is different
    if `x` is equal to `y`.'
  prefs: []
  type: TYPE_NORMAL
- en: Neither implementation is particularly wrong; depending on the circumstances,
    you may or may not want the code to increment `z` if `x` is equal to `y`. However,
    it is important to realize that these two schemes produce different results, so
    you can choose an appropriate implementation if the effect of this code on `z`
    matters to your program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many programs take advantage of short-circuit Boolean evaluation and rely on
    the program not evaluating certain components of the expression. The following
    C/C++ code fragment demonstrates perhaps the most common example that requires
    short-circuit Boolean evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If it turns out that `pntr` is `NULL`, the expression is false, and there is
    no need to evaluate the remainder of the expression. This statement relies on
    short-circuit Boolean evaluation for correct operation. Were C/C++ to use complete
    Boolean evaluation, the second half of the expression would attempt to dereference
    a `NULL` pointer, when `pntr` is `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the translation of this statement using complete Boolean evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If `pntr` contains `NULL (0)`, this program will attempt to access the data
    at location 0 in memory via the `mov al, [rax]` instruction. Under most operating
    systems, this will cause a memory access fault (general protection fault).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider the short-circuit Boolean conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the problem with dereferencing the `NULL` pointer doesn’t exist.
    If `pntr` contains `NULL`, this code skips over the statements that attempt to
    access the memory address `pntr` contains.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.6 Efficient Implementation of if Statements in Assembly Language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Encoding `if` statements efficiently in assembly language takes a bit more thought
    than simply choosing short-circuit evaluation over complete Boolean evaluation.
    To write code that executes as quickly as possible in assembly language, you must
    carefully analyze the situation and generate the code appropriately. The following
    paragraphs provide suggestions you can apply to your programs to improve their
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.6.1 Know Your Data!
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Programmers often mistakenly assume that data is random. In reality, data is
    rarely random, and if you know the types of values that your program commonly
    uses, you can write better code. To see how, consider the following C/C++ statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Because C/C++ uses short-circuit evaluation, this code will test whether `a`
    is equal to `b`. If so, it will test whether `c` is less than `d`. If you expect
    `a` to be equal to `b` most of the time but don’t expect `c` to be less than `d`
    most of the time, this statement will execute slower than it should. Consider
    the following MASM implementation of this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, if `a` is equal to `b` most of the time and `c` is not less
    than `d` most of the time, you will have to execute all six instructions nearly
    every time in order to determine that the expression is false. Now consider the
    following implementation that takes advantage of this knowledge and the fact that
    the `&&` operator is commutative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The code first checks whether `c` is less than `d`. If most of the time `c`
    is less than `d`, this code determines that it has to skip to the label `DontIncI`
    after executing only three instructions in the typical case (compared with six
    instructions in the previous example).
  prefs: []
  type: TYPE_NORMAL
- en: 'This fact is much more obvious in assembly language than in a high-level language,
    one of the main reasons assembly programs are often faster than their HLL counterparts:
    optimizations are more obvious in assembly language than in a high-level language.
    Of course, the key here is to understand the behavior of your data so you can
    make intelligent decisions such as the preceding one.'
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.6.2 Rearranging Expressions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Even if your data is random (or you can’t determine how the input values will
    affect your decisions), rearranging the terms in your expressions may still be
    beneficial. Some calculations take far longer to compute than others. For example,
    the `div` instruction is much slower than a simple `cmp` instruction. Therefore,
    if you have a statement like the following, you may want to rearrange the expression
    so that the `cmp` comes first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Converted to assembly code, this `if` statement becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The `idiv` instruction is expensive (often 50 to 100 times slower than most
    of the other instructions in this example). Unless it is 50 to 100 times more
    likely that the remainder is 0 rather than `x` is equal to `y`, it would be better
    to do the comparison first and the remainder calculation afterward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Because the `&&` and `||` operators are not commutative when short-circuit evaluation
    occurs, do consider such transformations carefully when making them. This example
    works fine because there are no side effects or possible exceptions being shielded
    by the reordered evaluation of the `&&` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.6.3 Destructuring Your Code
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Structured code is sometimes less efficient than unstructured code because it
    introduces code duplication or extra branches that might not be present in unstructured
    code.^([6](#c07-footnote-6)) Most of the time, this is tolerable because unstructured
    code is difficult to read and maintain; sacrificing some performance in exchange
    for maintainable code is often acceptable. In certain instances, however, you
    may need all the performance you can get and might choose to compromise the readability
    of your code.
  prefs: []
  type: TYPE_NORMAL
- en: Taking previously written structured code and rewriting it in an unstructured
    fashion to improve performance is known as *destructuring code*. The difference
    between unstructured code and destructured code is that unstructured code was
    written that way in the first place; destructured code started out as structured
    code and was purposefully written in an unstructured fashion to make it more efficient.
    Pure unstructured code is usually hard to read and maintain. Destructured code
    isn’t quite as bad because you limit the damage (unstructuring the code) to only
    those sections where it is absolutely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: One classic way to destructure code is to use *code movement* (physically moving
    sections of code elsewhere in the program) to move code that your program rarely
    uses out of the way of code that executes most of the time. Code movement can
    improve the efficiency of a program in two ways.
  prefs: []
  type: TYPE_NORMAL
- en: First, a branch that is taken is more expensive (time-consuming) than a branch
    that is not taken.^([7](#c07-footnote-7)) If you move the rarely used code to
    another spot in the program and branch to it on the rare occasion the branch is
    taken, most of the time you will fall straight through to the code that executes
    most frequently.
  prefs: []
  type: TYPE_NORMAL
- en: Second, sequential machine instructions consume cache storage. If you move rarely
    executed statements out of the normal code stream to another section of the program
    (that is rarely loaded into cache), this will improve the cache performance of
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following pseudo C/C++ statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In normal code, we don’t expect errors to be frequent. Therefore, you would
    normally expect the `then` section of the preceding `if` to execute far more often
    than the `else` clause. The preceding code could translate into the following
    assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If the expression is false, this code falls through to the normal statements
    and then jumps over the error-handling statements. Instructions that transfer
    control from one point in your program to another (for example, `jmp` instructions)
    tend to be slow. It is much faster to execute a sequential set of instructions
    rather than jump all over the place in your program. Unfortunately, the preceding
    code doesn’t allow this.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to rectify this problem is to move the `else` clause of the code somewhere
    else in your program. You could rewrite the code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'At some other point in your program (typically after a `jmp` instruction),
    you would insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The program isn’t any shorter. The `jmp` you removed from the original sequence
    winds up at the end of the `else` clause. However, because the `else` clause rarely
    executes, moving the `jmp` instruction from the `then` clause (which executes
    frequently) to the `else` clause is a big performance win because the `then` clause
    executes using only straight-line code. This technique is surprisingly effective
    in many time-critical code segments.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.6.4 Calculation Rather Than Branching
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On many processors in the x86-64 family, branches (jumps) are expensive compared
    to many other instructions. For this reason, it is sometimes better to execute
    more instructions in a sequence than fewer instructions that involve branching.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the simple assignment `eax = abs(eax)`. Unfortunately,
    no x86-64 instruction computes the absolute value of an integer. The obvious way
    to handle this is with an instruction sequence that uses a conditional jump to
    skip over the `neg` instruction (which creates a positive value in EAX if EAX
    was negative):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider the following sequence that will also do the job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This code will invert all the bits in EAX and then add 1 to EAX if EAX was negative
    prior to the sequence; that is, it negates the value in EAX. If EAX was zero or
    positive, this code does not change the value in EAX.
  prefs: []
  type: TYPE_NORMAL
- en: 'Though this sequence takes four instructions rather than the three that the
    previous example requires, there are no transfer-of-control instructions, so it
    may execute faster on many CPUs in the x86-64 family. Of course, if you use the
    `cmovns` instruction presented earlier, this can be done with the following three
    instructions (with no transfer of control):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This demonstrates why it’s good to know the instruction set!
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.7 switch/case Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The C/C++ `switch` statement takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: When this statement executes, it checks the value of the `expression` against
    the constants `const1` to `constn`. If it finds a match, the corresponding statements
    execute.
  prefs: []
  type: TYPE_NORMAL
- en: C/C++ places a few restrictions on the `switch` statement. First, the `switch`
    statement allows only an integer expression (or something whose underlying type
    can be an integer). Second, all the constants in the `case` clauses must be unique.
    The reason for these restrictions will become clear in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.7.1 switch Statement Semantics
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Most introductory programming texts introduce the `switch/case` statement by
    explaining it as a sequence of `if/then/elseif/else/endif` statements. They might
    claim that the following two pieces of C/C++ code are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: While semantically these two code segments may be the same, their implementation
    is usually different. Whereas the `if/then/elseif/else/endif` chain does a comparison
    for each conditional statement in the sequence, the `switch` statement normally
    uses an indirect jump to transfer control to any one of several statements with
    a single computation.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.7.2 if/else Implementation of switch
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `switch` (and `if/else/elseif`) statements could be written in assembly
    language with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Probably the only thing worth noting about this code is that it takes longer
    to determine the last case than it does to determine whether the first case executes.
    This is because the `if/else/elseif` version implements a *linear search* through
    the case values, checking them one at a time from first to last until it finds
    a match.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.7.3 Indirect Jump switch Implementation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A faster implementation of the `switch` statement is possible using an *indirect
    jump table*. This implementation uses the switch expression as an index into a
    table of addresses; each address points at the target case’s code to execute.
    Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: To begin with, a `switch` statement requires that you create an array of pointers
    with each element containing the address of a statement label in your code (those
    labels must be attached to the sequence of instructions to execute for each case
    in the `switch` statement). In the preceding example, the `JmpTbl` array, initialized
    with the address of the statement labels `Stmt0`, `Stmt1`, and `Stmt2`, serves
    this purpose. I’ve placed this array in the procedure itself because the labels
    are local to the procedure. Note, however, that you must place the array in a
    location that will never be executed as code (such as immediately after a `jmp`
    instruction, as in this example).
  prefs: []
  type: TYPE_NORMAL
- en: The program loads the RAX register with `i`’s value (assuming `i` is a 32-bit
    integer, the `mov` instruction zero-extends EAX into RAX), then uses this value
    as an index into the `JmpTbl` array (RCX holds the base address of the `JmpTbl`
    array) and transfers control to the 8-byte address found at the specified location.
    For example, if RAX contains 0, the `jmp [rcx][rax * 8]` instruction will fetch
    the quad word at address `JmpTbl+0` (RAX × 8 = 0). Because the first quad word
    in the table contains the address of `Stmt0`, the `jmp` instruction transfers
    control to the first instruction following the `Stmt0` label. Likewise, if `i`
    (and therefore, RAX) contains 1, then the indirect `jmp` instruction fetches the
    quad word at offset 8 from the table and transfers control to the first instruction
    following the `Stmt1` label (because the address of `Stmt1` appears at offset
    8 in the table). Finally, if `i` / RAX contains 2, then this code fragment transfers
    control to the statements following the `Stmt2` label because it appears at offset
    16 in the `JmpTbl` table.
  prefs: []
  type: TYPE_NORMAL
- en: As you add more (consecutive) cases, the jump table implementation becomes more
    efficient (in terms of both space and speed) than the `if/elseif` form. Except
    for simple cases, the `switch` statement is almost always faster, and usually
    by a large margin. As long as the `case` values are consecutive, the `switch`
    statement version is usually smaller as well.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.7.4 Noncontiguous Jump Table Entries and Range Limiting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What happens if you need to include nonconsecutive `case` labels or cannot be
    sure that the `switch` value doesn’t go out of range? With the C/C++ `switch`
    statement, such an occurrence will transfer control to the first statement after
    the `switch` statement (or to a `default` case, if one is present in the switch).
  prefs: []
  type: TYPE_NORMAL
- en: However, this doesn’t happen in the preceding example. If variable `i` does
    not contain 0, 1, or 2, executing the previous code produces undefined results.
    For example, if `i` contains 5 when you execute the code, the indirect `jmp` instruction
    will fetch the qword at offset 40 (5 × 8) in `JmpTbl` and transfer control to
    that address. Unfortunately, `JmpTbl` doesn’t have six entries, so the program
    will fetch the value of the sixth quad word following `JmpTbl` and use that as
    the target address, which will often crash your program or transfer control to
    an unexpected location.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to place a few instructions before the indirect `jmp` to verify
    that the `switch` selection value is within a reasonable range. In the previous
    example, we’d probably want to verify that `i`’s value is in the range 0 to 2
    before executing the `jmp` instruction. If `i`’s value is outside this range,
    the program should simply jump to the `endcase` label (this corresponds to dropping
    down to the first statement after the entire `switch` statement). The following
    code provides this modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the preceding example handles the problem of selection values being
    outside the range 0 to 2, it still suffers from a couple of severe restrictions:'
  prefs: []
  type: TYPE_NORMAL
- en: The cases must start with the value 0\. That is, the minimum `case` constant
    has to be 0 in this example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The case values must be contiguous.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solving the first problem is easy, and you deal with it in two steps. First,
    you compare the case selection value against a lower and upper bound before determining
    if the case value is legal. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This code adds a pair of extra instructions, `cmp` and `jb`, to test the selection
    value to ensure it is in the range 5 to 7\. If not, control drops down to the
    `EndCase` label; otherwise, control transfers via the indirect `jmp` instruction.
    Unfortunately, as the comments point out, this code is broken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider what happens if variable `i` contains the value 5: the code will verify
    that 5 is in the range 5 to 7 and then will fetch the dword at offset 40 (5 ×
    8) and jump to that address. As before, however, this loads 8 bytes outside the
    bounds of the table and does not transfer control to a defined location. One solution
    is to subtract the smallest case selection value from EAX before executing the
    `jmp` instruction, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: By subtracting 5 from the value in EAX, we force EAX to take on the value 0,
    1, or 2 prior to the `jmp` instruction. Therefore, case-selection value 5 jumps
    to `Stmt5`, case-selection value 6 transfers control to `Stmt6`, and case-selection
    value 7 jumps to `Stmt7`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To improve this code, you can eliminate the `sub` instruction by merging it
    into the `jmp` instruction’s address expression. The following code does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The C/C++ `switch` statement provides a `default` clause that executes if the
    case-selection value doesn’t match any of the case values. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Implementing the equivalent of the `default` clause in pure assembly language
    is easy. Just use a different target label in the `jb` and `ja` instructions at
    the beginning of the code. The following example implements a MASM `switch` statement
    similar to the preceding one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The second restriction noted earlier, (that is, the case values need to be
    contiguous) is easy to handle by inserting extra entries into the jump table.
    Consider the following C/C++ `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The minimum switch value is 1, and the maximum value is 8\. Therefore, the code
    before the indirect `jmp` instruction needs to compare the value in `i` against
    1 and 8\. If the value is between 1 and 8, it’s still possible that `i` might
    not contain a legal case-selection value. However, because the `jmp` instruction
    indexes into a table of quad words using the case-selection table, the table must
    have eight quad-word entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle the values between 1 and 8 that are not case-selection values, simply
    put the statement label of the `default` clause (or the label specifying the first
    instruction after the `endswitch` if there is no `default` clause) in each of
    the jump table entries that don’t have a corresponding `case` clause. The following
    code demonstrates this technique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 7.6.7.5 Sparse Jump Tables
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The current implementation of the `switch` statement has a problem. If the
    `case` values contain nonconsecutive entries that are widely spaced, the jump
    table could become exceedingly large. The following `switch` statement would generate
    an extremely large code file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'In this situation, your program will be much smaller if you implement the `switch`
    statement with a sequence of `if` statements rather than using an indirect jump
    statement. However, keep one thing in mind: the size of the jump table does not
    normally affect the execution speed of the program. If the jump table contains
    two entries or two thousand, the `switch` statement will execute the multiway
    branch in a constant amount of time. The `if` statement implementation requires
    a linearly increasing amount of time for each `case` label appearing in the `case`
    statement.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Probably the biggest advantage to using assembly language over an HLL like
    Pascal or C/C++ is that you get to choose the actual implementation of statements
    like `switch`. In some instances, you can implement a `switch` statement as a
    sequence of `if/then/elseif` statements, or you can implement it as a jump table,
    or you can use a hybrid of the two:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'That could become the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are willing to live with programs that cannot exceed 2GB in size (and
    use the `LARGEADDRESSAWARE:NO` command line option), you can improve the implementation
    of the `switch` statement and save one instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This code removed the `lea rcx, JmpTbl` instruction and replaced `jmp [rcx][rax
    * 8 – 5 * 8]` with `jmp JmpTbl[rax * 8 – 5 * 8]`. This is a small improvement,
    but an improvement nonetheless (this sequence not only is one instruction shorter
    but also uses one less register). Of course, constantly be aware of the danger
    of writing 64-bit programs that are not large-address aware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some `switch` statements have sparse cases but with groups of contiguous cases
    within the overall set of cases. Consider the following C/C++ `switch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'You can convert a `switch` statement that consists of widely separated groups
    of (nearly) contiguous cases to assembly language code using one jump table implementation
    for each contiguous group, and you can then use compare instructions to determine
    which jump table instruction sequence to execute. Here’s one possible implementation
    of the previous C/C++ code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This code sequence combines groups 0 to 2 and 10 to 11 into a single group (requiring
    seven additional jump table entries) in order to save having to write an additional
    jump table sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, for a set of cases this simple, it’s probably easier to just use
    compare-and-branch sequences. This example was simplified a bit just to make a
    point.
  prefs: []
  type: TYPE_NORMAL
- en: 7.6.7.6 Other switch Statement Alternatives
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What happens if the cases are too sparse to do anything but compare the expression’s
    value case by case? Is the code doomed to being translated into the equivalent
    of an `if/elseif/else/endif` sequence? Not necessarily. However, before we consider
    other alternatives, it’s important to mention that not all `if/elseif/else/endif`
    sequences are created equal. Look back at the previous example. A straightforward
    implementation might have been something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Instead, the former implementation first tests against the value 100 and branches
    based on the comparison being less than (cases 0 to 11) or greater than (cases
    1000 to 1001), effectively creating a small *binary search* that reduces the number
    of comparisons. It’s hard to see the savings in the HLL code, but in assembly
    code you can count the number of instructions that would be executed in the best
    and worst cases and see an improvement over the standard linear search approach
    of simply comparing the values in the cases in the order they appear in the `switch`
    statement.^([8](#c07-footnote-8))
  prefs: []
  type: TYPE_NORMAL
- en: If your cases are too sparse (no meaningful groups at all), such as the 1, 10,
    100, 1000, 10,000 example given earlier in this chapter, you’re not going to be
    able to (reasonably) implement the `switch` statement by using a jump table. Rather
    than devolving into a straight linear search (which can be slow), a better solution
    is to sort your cases and test them using a binary search.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a binary search, you first compare the expression value against the middle
    case value. If it’s less than the middle value, you repeat the search on the first
    half of the list of values; if it’s greater than the middle value, you repeat
    the test on the second half of the values; if it’s equal, obviously you drop into
    the code to handle that test. Here’s the binary search version of the 1, 10, 100,
    . . . example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The techniques presented in this section have many possible alternatives. For
    example, one common solution is to create a table containing a set of records
    (structures), with each record entry a two-tuple containing a case value and a
    jump address. Rather than having a long sequence of compare instructions, a short
    loop can sequence through all the table elements, searching for the case value
    and transferring control to the corresponding jump address if there is a match.
    This scheme is slower than the other techniques in this section but can be much
    shorter than the traditional `if/elseif/else/endif` implementation.^([9](#c07-footnote-9))
  prefs: []
  type: TYPE_NORMAL
- en: 'Note, by the way, that the `defaultCase` label often appears in several `j``cc`
    instructions in a (non-jump-table) `switch` implementation. Since the conditional
    jump instructions have two encodings, a 2-byte form and a 6-byte form, you should
    try to place the `defaultCase` near these conditional jumps so you can use the
    short form of the instruction as much as possible. Although the examples in this
    section have typically put the jump tables (which consume a large number of bytes)
    immediately after their corresponding indirect jump, you could move these tables
    elsewhere in the procedure to help keep the conditional jump instructions short.
    Here’s the earlier 1, 10, 100, . . . example coded with this in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 7.7 State Machines and Indirect Jumps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another control structure commonly found in assembly language programs is the
    *state machine*. A state machine uses a *state variable* to control program flow.
    The FORTRAN programming language provides this capability with the assigned `goto`
    statement. Certain variants of C (for example, GNU’s GCC from the Free Software
    Foundation) provide similar features. In assembly language, the indirect jump
    can implement state machines.
  prefs: []
  type: TYPE_NORMAL
- en: So what is a state machine? In basic terms, it is a piece of code that keeps
    track of its execution history by entering and leaving certain *states*. For the
    purposes of this chapter, we’ll just assume that a state machine is a piece of
    code that (somehow) remembers the history of its execution (its *state*) and executes
    sections of code based on that history.
  prefs: []
  type: TYPE_NORMAL
- en: In a real sense, all programs are state machines. The CPU registers and values
    in memory constitute the state of that machine. However, we’ll use a much more
    constrained view. Indeed, for most purposes, only a single variable (or the value
    in the RIP register) will denote the current state.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s consider a concrete example. Suppose you have a procedure and want
    to perform one operation the first time you call it, a different operation the
    second time you call it, yet something else the third time you call it, and then
    something new again on the fourth call. After the fourth call, it repeats these
    four operations in order.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose you want the procedure to add EAX and EBX the first time,
    subtract them on the second call, multiply them on the third, and divide them
    on the fourth. You could implement this procedure as shown in [Listing 7-6](#listing7-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-6: A state machine example'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and program output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Technically, this procedure is not the state machine. Instead, the variable
    `state` and the `cmp/jne` instructions constitute the state machine. The procedure
    is little more than a `switch` statement implemented via the `if/then/elseif`
    construct. The only unique thing is that it remembers how many times it has been
    called^([10](#c07-footnote-10)) and behaves differently depending upon the number
    of calls.
  prefs: []
  type: TYPE_NORMAL
- en: While this is a *correct* implementation of the desired state machine, it is
    not particularly efficient. The astute reader, of course, would recognize that
    this code could be made a little faster using an actual `switch` statement rather
    than the `if/then/elseif/endif` implementation. However, an even better solution
    exists.
  prefs: []
  type: TYPE_NORMAL
- en: It’s common to use an indirect jump to implement a state machine in assembly
    language. Rather than having a `state` variable that contains a value like 0,
    1, 2, or 3, we could load the `state` variable with the *address* of the code
    to execute upon entry into the procedure. By simply jumping to that address, the
    state machine could save the tests needed to select the proper code fragment.
    Consider the implementation in [Listing 7-7](#listing7-7) using the indirect jump.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-7: A state machine using an indirect jump'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the build command and program output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The `jmp` instruction at the beginning of the `StateMachine` procedure transfers
    control to the location pointed at by the `state` variable. The first time you
    call `StateMachine`, it points at the `State0` label. Thereafter, each subsection
    of code sets the `state` variable to point at the appropriate successor code.
  prefs: []
  type: TYPE_NORMAL
- en: 7.8 Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Loops* represent the final basic control structure (sequences, decisions,
    and loops) that make up a typical program. As with so many other structures in
    assembly language, you’ll find yourself using loops in places you’ve never dreamed
    of using loops.'
  prefs: []
  type: TYPE_NORMAL
- en: Most HLLs have implied loop structures hidden away. For example, consider the
    BASIC statement `if A$ = B$ then 100`. This `if` statement compares two strings
    and jumps to statement 100 if they are equal. In assembly language, you would
    need to write a loop to compare each character in `A$` to the corresponding character
    in `B$` and then jump to statement 100 if and only if all the characters matched.^([11](#c07-footnote-11))
  prefs: []
  type: TYPE_NORMAL
- en: 'Program loops consist of three components: an optional *initialization component*,
    an optional *loop-termination test*, and the *body* of the loop. The order in
    which you assemble these components can dramatically affect the loop’s operation.
    Three permutations of these components appear frequently in programs: `while`
    loops, `repeat/until` loops (`do/while` in C/C++), and infinite loops (for example,
    `for(;;)` in C/C++).'
  prefs: []
  type: TYPE_NORMAL
- en: 7.8.1 while Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most general loop is the `while` loop. In C/C++, it takes the following
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: In the `while` loop, the termination test appears at the beginning of the loop.
    As a direct consequence of the position of the termination test, the body of the
    loop may never execute if the Boolean expression is always false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following C/C++ `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The `i = 0;` statement is the initialization code for this loop. `i` is a loop-control
    variable, because it controls the execution of the body of the loop. `i < 100`
    is the loop-termination condition: the loop will not terminate as long as `i`
    is less than 100\. The single statement `++i;` (*increment i*) is the loop body
    that executes on each loop iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A C/C++ `while` loop can be easily synthesized using `if` and `goto` statements.
    For example, you may replace the previous C `while` loop with the following C
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'More generally, you can construct any `while` loop as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, you can use the techniques from earlier in this chapter to convert
    `if` statements to assembly language and add a single `jmp` instruction to produce
    a `while` loop. The example in this section translates to the following pure x86-64
    assembly code:^([12](#c07-footnote-12))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 7.8.2 repeat/until Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `repeat/until` (`do/while`) loop tests for the termination condition at
    the end of the loop rather than at the beginning. In Pascal, the `repeat/until`
    loop takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'This is comparable to the following C/C++ `do/while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: This sequence executes the initialization code, then executes the loop body,
    and finally tests a condition to see whether the loop should repeat. If the Boolean
    expression evaluates to false, the loop repeats; otherwise, the loop terminates.
    The two things you should note about the `repeat/until` loop are that the termination
    test appears at the end of the loop and, as a direct consequence, the loop body
    always executes at least once.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the `while` loop, the `repeat/until` loop can be synthesized with an `if`
    statement and a `jmp`. You could use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on the material presented in the previous sections, you can easily synthesize
    `repeat/until` loops in assembly language. The following is a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 7.8.3 forever/endfor Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If `while` loops test for termination at the beginning of the loop and `repeat/until/do/while`
    loops check for termination at the end of the loop, the only place left to test
    for termination is in the middle of the loop. The C/C++ high-level `for(;;)` loop,
    combined with the `break` statement, provides this capability. The C/C++ infinite
    loop takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no explicit termination condition. Unless otherwise provided, the
    `for(;;)` construct forms an infinite loop. A `break` statement usually handles
    loop termination. Consider the following C++ code that employs a `for(;;)` construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting a `for`(ever) loop to pure assembly language is easy. All you need
    is a label and a `jmp` instruction. The `break` statement in this example is also
    nothing more than a `jmp` instruction (or conditional jump). The pure assembly
    language version of the preceding code looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 7.8.4 for Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The standard `for` loop is a special form of the `while` loop that repeats the
    loop body a specific number of times (this is known as a *definite* loop). In
    C/C++, the `for` loop takes the form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'which is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Traditionally, programs use the `for` loop to process arrays and other objects
    accessed in sequential order. We normally initialize a loop-control variable with
    the initialization statement and then use the loop-control variable as an index
    into the array (or other data type). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert this to pure assembly language, begin by translating the `for` loop
    into an equivalent `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, using the techniques from “while Loops” on page 433, translate the code
    into pure assembly language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 7.8.5 The break and continue Statements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C/C++ `break` and `continue` statements both translate into a single `jmp`
    instruction. The `break` instruction exits the loop that immediately contains
    the `break` statement; the `continue` statement restarts the loop that contains
    the `continue` statement.
  prefs: []
  type: TYPE_NORMAL
- en: To convert a `break` statement to pure assembly language, just emit a `goto/jmp`
    instruction that transfers control to the first statement following the `end`
    of the loop to exit. You can do this by placing a label after the loop body and
    jumping to that label. The following code fragments demonstrate this technique
    for the various loops.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: In pure assembly language, convert the appropriate control structures to assembly
    and replace the `goto` with a `jmp` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: The `continue` statement is slightly more complex than the `break` statement.
    The implementation is still a single `jmp` instruction; however, the target label
    doesn’t wind up going in the same spot for each of the different loops. Figures
    7-2, 7-3, 7-4, and 7-5 show where the `continue` statement transfers control for
    each of the loops.
  prefs: []
  type: TYPE_NORMAL
- en: '![f07002](image_fi/501089c07/f07002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-2: `continue` destination for the `for(;;)` loop'
  prefs: []
  type: TYPE_NORMAL
- en: '![f07003](image_fi/501089c07/f07003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-3: `continue` destination and the `while` loop'
  prefs: []
  type: TYPE_NORMAL
- en: '![f07004](image_fi/501089c07/f07004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-4: `continue` destination and the `for` loop'
  prefs: []
  type: TYPE_NORMAL
- en: '![f07005](image_fi/501089c07/f07005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-5: `continue` destination and the `repeat``/``until` loop'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code fragments demonstrate how to convert the `continue` statement
    into an appropriate `jmp` instruction for each of these loop types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`for(;;)/continue/endfor`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '**`while/continue/endwhile`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '**`for/continue/endfor`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '**`repeat/continue/until`**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 7.8.6 Register Usage and Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given that the x86-64 accesses registers more efficiently than memory locations,
    registers are the ideal spot to place loop-control variables (especially for small
    loops). However, registers are a limited resource; there are only 16 general-purpose
    registers (and some, such as RSP and RBP, are reserved for special purposes).
    Compared with memory, you cannot place much data in the registers, despite them
    being more efficient to use than memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loops present a special challenge for registers. Registers are perfect for
    loop-control variables because they’re efficient to manipulate and can serve as
    indexes into arrays and other data structures (a common use for loop-control variables).
    However, the limited availability of registers often creates problems when using
    registers in this fashion. Consider the following code that will not work properly
    because it attempts to reuse a register (CX) that is already in use (leading to
    the corruption of the outer loop’s loop-control variable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The intent here, of course, was to create a set of nested loops; that is, one
    loop inside another. The inner loop (`loop2`) should repeat four times for each
    of the eight executions of the outer loop (`loop1`). Unfortunately, both loops
    use the same register as a loop-control variable. Therefore, this will form an
    infinite loop. Because CX is always 0 upon encountering the second `dec` instruction,
    control will always transfer to the `loop1` label (because decrementing 0 produces
    a nonzero result). The solution here is to save and restore the CX register or
    to use a different register in place of CX for the outer loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Register corruption is one of the primary sources of bugs in loops in assembly
    language programs, so always keep an eye out for this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9 Loop Performance Improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because loops are the primary source of performance problems within a program,
    they are the place to look when attempting to speed up your software. While a
    treatise on how to write efficient programs is beyond the scope of this chapter,
    you should be aware of the following concepts when designing loops in your programs.
    They’re all aimed at removing unnecessary instructions from your loops in order
    to reduce the time it takes to execute a single iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9.1 Moving the Termination Condition to the End of a Loop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following flow graphs for the three types of loops presented earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `repeat/until` loop is the simplest of the bunch. This
    is reflected in the assembly language implementation of these loops. Consider
    the following `repeat/until` and `while` loops that are semantically identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Testing for the termination condition at the end of the loop allows us to remove
    a `jmp` instruction from the loop, which can be significant if the loop is nested
    inside other loops. Given the definition of the loop, you can easily see that
    the loop will execute exactly 20 times, which suggests that the conversion to
    a `repeat/until` loop is trivial and always possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, it’s not always quite this easy. Consider the following C code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'In this particular example, we haven’t the slightest idea what ESI contains
    upon entry into the loop. Therefore, we cannot assume that the loop body will
    execute at least once. So, we must test for loop termination before executing
    the body of the loop. The test can be placed at the end of the loop with the inclusion
    of a single `jmp` instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Although the code is as long as the original `while` loop, the `jmp` instruction
    executes only once rather than on each repetition of the loop. However, the slight
    gain in efficiency is obtained via a slight loss in readability (so be sure to
    comment it). The second code sequence is closer to spaghetti code than the original
    implementation. Such is often the price of a small performance gain. Therefore,
    you should carefully analyze your code to ensure that the performance boost is
    worth the loss of clarity.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9.2 Executing the Loop Backward
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because of the nature of the flags on the x86-64, loops that repeat from some
    number down to (or up to) 0 are more efficient than loops that execute from 0
    to another value. Compare the following C/C++ `for` loop and the comparable assembly
    language code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider another loop that also has eight iterations but runs its loop-control
    variable from 8 down to 1 rather than 1 up to 8, thereby saving a comparison on
    each repetition of the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Saving the execution time of the `cmp` instruction on each iteration of the
    loop may result in faster code. Unfortunately, you cannot force all loops to run
    backward. However, with a little effort and some coercion, you should be able
    to write many `for` loops so that they operate backward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding example worked out well because the loop ran from 8 down to 1\.
    The loop terminated when the loop-control variable became 0\. What happens if
    you need to execute the loop when the loop-control variable goes to 0? For example,
    suppose that the preceding loop needed to range from 7 down to 0\. As long as
    the lower bound is non-negative, you can substitute the `jns` instruction in place
    of the `jnz` instruction in the earlier code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: This loop will repeat eight times, with `j` taking on the values 7 to 0\. When
    it decrements 0 to –1, it sets the sign flag and the loop terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that some values may look positive but are actually negative. If
    the loop-control variable is a byte, values in the range 128 to 255 are negative
    in the two’s complement system. Therefore, initializing the loop-control variable
    with any 8-bit value in the range 129 to 255 (or, of course, 0) terminates the
    loop after a single execution. This can get you into trouble if you’re not careful.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9.3 Using Loop-Invariant Computations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *loop-invariant computation* is a calculation that appears within a loop
    that always yields the same result. You needn’t do such computations inside the
    loop. You can compute them outside the loop and reference the value of the computations
    inside the loop. The following C code demonstrates an invariant computation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Because `j` never changes throughout the execution of this loop, the subexpression
    `j - 2` can be computed outside the loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Although we’ve eliminated a single instruction by computing the subexpression
    `j - 2` outside the loop, there is still an invariant component to this calculation:
    adding `j - 2` to `i` *n* times. Because this invariant component executes *n*
    times in the loop, we can translate the previous code to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'This translates to the following assembly code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: For this particular loop, you can actually compute the result without using
    a loop at all (a formula corresponds to the preceding iterative calculation).
    Still, this simple example demonstrates how to eliminate loop-invariant calculations
    from a loop.
  prefs: []
  type: TYPE_NORMAL
- en: 7.9.4 Unraveling Loops
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For small loops—those whose body is only a few statements—the overhead required
    to process a loop may constitute a significant percentage of the total processing
    time. For example, look at the following Pascal code and its associated x86-64
    assembly language code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Four instructions execute on each repetition of the loop. Only one instruction
    is doing the desired operation (moving a 0 into an element of `A). The remaining
    three instructions control the loop. Therefore, it takes 16 instructions to do
    the operation logically required by 4.`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
