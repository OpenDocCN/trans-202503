- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Low-Level Control Structures
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 低级控制结构
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: This chapter discusses how to convert high-level–language control structures
    into assembly language control statements. The examples up to this point have
    created assembly control structures in an ad hoc manner. Now it’s time to formalize
    how to control the operation of your assembly language programs. By the time you
    finish this chapter, you should be able to convert HLL control structures into
    assembly language.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论如何将高级语言（HLL）控制结构转换为汇编语言控制语句。到目前为止的示例采用了临时创建的方式构建汇编控制结构。现在是时候正式化如何控制汇编语言程序的操作了。完成本章后，你应该能够将HLL控制结构转换为汇编语言。
- en: Control structures in assembly language consist of conditional branches and
    indirect jumps. This chapter discusses those instructions and how to emulate HLL
    control structures (such as `if/else`, `switch`, and loop statements). This chapter
    also discusses labels (the targets of conditional branches and jump statements)
    as well as the scope of labels in an assembly language source file.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言中的控制结构由条件分支和间接跳转组成。本章讨论了这些指令，以及如何模拟HLL控制结构（如`if/else`、`switch`和循环语句）。本章还讨论了标签（条件分支和跳转语句的目标）以及汇编语言源文件中标签的作用域。
- en: 7.1 Statement Labels
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 语句标签
- en: 'Before discussing jump instructions and how to emulate control structures using
    them, an in-depth discussion of assembly language statement labels is necessary.
    In an assembly language program, *labels* stand in as symbolic names for addresses.
    It is far more convenient to refer to a position in your code by using a name
    such as `LoopEntry` rather than a numeric address such as 0AF1C002345B7901Eh.
    For this reason, assembly language low-level control structures make extensive
    use of labels within source code (see “Brief Detour: An Introduction to Control
    Transfer Instructions” in Chapter 2).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论跳转指令以及如何使用它们模拟控制结构之前，有必要深入讨论汇编语言中的语句标签。在汇编语言程序中，*标签*充当地址的符号名称。使用像`LoopEntry`这样的名称引用代码中的某个位置比使用像0AF1C002345B7901Eh这样的数字地址更为方便。因此，汇编语言的低级控制结构在源代码中大量使用标签（参见第2章的“简短绕道：控制转移指令介绍”）。
- en: 'You can do three things with (code) labels: transfer control to a label via
    a (conditional or unconditional) jump instruction, call a label via the `call`
    instruction, and take the address of a label. Taking the address of a label is
    useful when you want to indirectly transfer control to that address at a later
    point in your program.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对（代码）标签做三件事：通过（条件或无条件）跳转指令将控制转移到标签，使用`call`指令调用标签，以及获取标签的地址。当你想稍后在程序中间接地将控制转移到该地址时，获取标签的地址非常有用。
- en: 'The following code sequence demonstrates two ways to take the address of a
    label in your program (using the `lea` instruction and using the `offset` operator):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码序列演示了在程序中获取标签地址的两种方式（使用`lea`指令和使用`offset`操作符）：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Because addresses are 64-bit quantities, you’ll typically load an address into
    a 64-bit general-purpose register by using the `lea` instruction. Because that
    instruction uses a 32-bit relative displacement from the current instruction,
    the instruction encoding is significantly shorter than the `mov` instruction (which
    encodes a full 8-byte constant in addition to the opcode bytes).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因为地址是64位的量，你通常会使用`lea`指令将地址加载到64位通用寄存器中。由于该指令使用当前指令的32位相对偏移量，因此指令编码比`mov`指令短得多（`mov`指令需要编码一个完整的8字节常量以及操作码字节）。
- en: 7.1.1 Using Local Symbols in Procedures
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.1 在过程中的使用局部符号
- en: 'Statement labels you define within a `proc`/`endp` procedure are *local* to
    that procedure, in the sense of *lexical* *scope*: the statement label is visible
    only within that procedure; you cannot refer to that statement label outside the
    procedure. [Listing 7-1](#listing7-1) demonstrates that you cannot refer to a
    symbol inside another procedure (note that this program will not assemble because
    of this error).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在`proc`/`endp`过程内定义的语句标签是*局部*的，从*词法* *作用域*的角度来看：该语句标签仅在该过程内可见；你不能在过程外引用该语句标签。[列表
    7-1](#listing7-1)展示了你不能在另一个过程内引用符号（注意，由于此错误，该程序无法汇编）。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 7-1: Demonstration of lexically scoped symbols'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-1：词法作用域符号的演示
- en: 'The command to assemble this file (and the corresponding diagnostic message)
    is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编此文件的命令（及相应的诊断消息）如下所示：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you really want to access a statement (or any other) label outside a procedure,
    you can use the `option` directive to turn off local scope within a section of
    your program, as noted in Chapter 5:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想在过程外部访问某个语句（或其他）标签，你可以使用`option`指令来关闭程序某一部分的局部作用域，正如第5章所述：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first form tells MASM to stop making symbols (inside `proc`/`endp`) local
    to the procedure containing them. The second form restores the lexical scoping
    of symbols in procedures. Therefore, using these two directives, you can turn
    scoping on or off for various sections of your source file (including as little
    as a single statement, if you like). [Listing 7-2](#listing7-2) demonstrates how
    to use the `option` directive to make a single symbol global outside the procedure
    containing it (note that this program still has compile errors).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种形式告诉MASM停止将符号（在`proc`/`endp`之间）限制为包含它们的过程的局部符号。第二种形式恢复了过程中的符号词法作用域。因此，使用这两个指令，你可以为源文件的各个部分打开或关闭作用域（如果你愿意，也可以只为单个语句设置作用域）。[Listing
    7-2](#listing7-2)演示了如何使用`option`指令使单个符号在包含它的过程外部变为全局符号（注意，这个程序仍然存在编译错误）。
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 7-2: The `option scoped` and `option noscoped` directives'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 7-2：`option scoped`和`option noscoped`指令
- en: 'Here’s the build command (and diagnostic output) for [Listing 7-2](#listing7-2):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是[Listing 7-2](#listing7-2)的构建命令（和诊断输出）：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see from MASM’s output, the `notLocal` symbol (appearing after the
    `option noscoped` directive) did not generate an undefined symbol error. However,
    the `localStmtLbl` and `isLocal` symbols, which are local to `hasLocalLbl`, are
    undefined outside that procedure.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从MASM的输出中看到的，`notLocal`符号（出现在`option noscoped`指令之后）并未生成未定义符号错误。然而，`localStmtLbl`和`isLocal`符号，它们是`hasLocalLbl`过程的局部符号，在该过程外部是未定义的。
- en: 7.1.2 Initializing Arrays with Label Addresses
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1.2 使用标签地址初始化数组
- en: MASM also allows you to initialize quad-word variables with the addresses of
    statement labels. However, labels that appear in the initialization portions of
    variable declarations have some restrictions. The most important restriction is
    that the symbol must be in the same lexical scope as the data declaration attempting
    to use it. So, either the `qword` directive must appear inside the same procedure
    as the statement label, or you must use the `option noscoped` directive to make
    the symbol(s) global to the procedure. [Listing 7-3](#listing7-3) demonstrates
    these two ways to initialize a `qword` variable with statement label addresses.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: MASM还允许你通过语句标签的地址来初始化四字（quad-word）变量。然而，在变量声明的初始化部分出现的标签有一些限制。最重要的限制是符号必须与尝试使用它的数据声明位于相同的词法作用域中。因此，要么`qword`指令必须出现在与语句标签相同的过程内，要么你必须使用`option
    noscoped`指令来使符号在过程内成为全局符号。[Listing 7-3](#listing7-3)展示了这两种初始化`qword`变量并将其与语句标签地址关联的方式。
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 7-3: Initializing qword variables with the address of statement labels'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 7-3：使用语句标签地址初始化四字变量
- en: 'If you compile [Listing 7-3](#listing7-3) with the following command, you’ll
    get no assembly errors:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用以下命令编译[Listing 7-3](#listing7-3)，你将不会得到任何汇编错误：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you look at the *listing7-3.lst* output file that MASM produces, you can
    see that MASM properly initializes the qword declarations with the (section-relative/relocatable)
    offsets of the statement labels:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看MASM生成的*listing7-3.lst*输出文件，你会看到MASM正确地用语句标签的（相对于段/可重定位的）偏移量初始化了四字声明：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Transferring control to a statement label inside a procedure is generally considered
    bad programming practice. Unless you have a good reason to do so, you probably
    shouldn’t.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将控制转移到过程内部的语句标签通常被认为是不好的编程实践。除非你有充分的理由这样做，否则你可能不应该这么做。
- en: As addresses on the x86-64 are 64-bit quantities, you will typically use the
    `qword` directive (as in the previous examples) to initialize a data object with
    the address of a statement label. However, if your program is (always going to
    be) smaller than 2GB, and you set the `LARGEADDRESSAWARE:NO` flag (using *sbuild.bat*),
    you can get away with using `dword` data declarations to hold the address of a
    label. Of course, as this book has pointed out many times, using 32-bit addresses
    in your 64-bit programs can lead to problems if you ever exceed 2GB of storage
    for your program.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于x86-64上的地址是64位量，你通常会使用`qword`指令（如前面示例所示）来用语句标签的地址初始化数据对象。然而，如果你的程序（总是会是）小于2GB，并且你设置了`LARGEADDRESSAWARE:NO`标志（使用*sbuild.bat*），你可以使用`dword`数据声明来存放标签的地址。当然，正如本书多次提到的那样，在64位程序中使用32位地址，如果你的程序超出2GB存储空间时，可能会导致问题。
- en: 7.2 Unconditional Transfer of Control (jmp)
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 无条件控制转移（jmp）
- en: 'The `jmp` (*jump*) instruction unconditionally transfers control to another
    point in the program. This instruction has three forms: a direct jump and two
    indirect jumps. These take the following forms:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`jmp`（*跳转*）指令无条件地将控制转移到程序中的另一个位置。此指令有三种形式：直接跳转和两种间接跳转。它们的形式如下：'
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first instruction is a *direct jump*, which you’ve seen in various sample
    programs up to this point. For direct jumps, you normally specify the target address
    by using a statement label. The label appears either on the same line as an executable
    machine instruction or by itself on a line preceding an executable machine instruction.
    The direct jump is completely equivalent to a `goto` statement in a high-level
    language.^([1](#c07-footnote-1))
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条指令是一个*直接跳转*，你在之前的各种示例程序中已经见过这种跳转。对于直接跳转，通常通过使用语句标签来指定目标地址。标签要么出现在与可执行机器指令相同的行上，要么单独出现在可执行机器指令前的一行上。直接跳转完全等同于高级语言中的`goto`语句。^([1](#c07-footnote-1))
- en: 'Here’s an example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 7.2.1 Register-Indirect Jumps
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.1 寄存器间接跳转
- en: The second form of the `jmp` instruction given earlier—`jmp` `reg`64—is a *register-**indirect
    jump* instruction that transfers control to the instruction whose address appears
    in the specified 64-bit general-purpose register. To use this form of the `jmp`
    instruction, you must load a 64-bit register with the address of a machine instruction
    prior to the execution of the `jmp`. When several paths, each loading the register
    with a different address, converge on the same `jmp` instruction, control transfers
    to an appropriate location determined by the path up to that point.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 前面给出的第二种`jmp`指令形式——`jmp` `reg`64——是一种*寄存器间接跳转*指令，它将控制转移到指定的64位通用寄存器中存储的地址处的指令。要使用这种形式的`jmp`指令，必须在执行`jmp`之前将一个64位寄存器加载为机器指令的地址。当多个路径分别将寄存器加载不同地址时，控制将转移到由该路径到目前为止确定的适当位置。
- en: '[Listing 7-4](#listing7-4) reads a string of characters from the user that
    contain an integer value. It uses the C Standard Library function `strtol()` to
    convert that string to a binary integer value. The `strtol()` function doesn’t
    do the greatest job of reporting an error, so this program tests the return results
    to verify a correct input and uses register-indirect jumps to transfer control
    to different code paths based on the result.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-4](#listing7-4) 从用户处读取一个包含整数值的字符串。它使用 C 标准库函数`strtol()`将该字符串转换为二进制整数值。`strtol()`函数在报告错误时并不十分出色，因此该程序测试返回结果以验证输入是否正确，并使用寄存器间接跳转根据结果将控制转移到不同的代码路径。'
- en: The first part of [Listing 7-4](#listing7-4) contains constants, variables,
    external declarations, and the (usual) `getTitle()` function.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-4](#listing7-4)的第一部分包含常量、变量、外部声明和（通常的）`getTitle()`函数。'
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The next section of [Listing 7-4](#listing7-4) is the `strToInt()` function,
    a wrapper around the C Standard Library `strtol()` function that does a more thorough
    job of handling erroneous inputs from the user. See the comments for the function’s
    return values.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-4](#listing7-4)的下一部分是`strToInt()`函数，它是 C 标准库`strtol()`函数的封装器，更加彻底地处理用户输入的错误。请参阅函数的返回值注释。'
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The final section of [Listing 7-4](#listing7-4) is the main program. This is
    the part of code most interesting to us. It loads the RBX register with the address
    of code to execute based on the `strToInt()` return results. The `strToInt()`
    function returns one of the following states (see the comments in the previous
    code for an explanation):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-4](#listing7-4)的最后一部分是主程序。这是我们最感兴趣的代码部分。它将 RBX 寄存器加载为基于`strToInt()`返回结果执行的代码地址。`strToInt()`函数返回以下几种状态中的一种（有关解释，请参见前面代码中的注释）：'
- en: Valid input
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效输入
- en: Illegal characters at the beginning of the string
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串开头存在非法字符
- en: Illegal characters at the end of the string
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串末尾存在非法字符
- en: Range error
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围错误
- en: The program then transfers control to different sections of `asmMain()` based
    on the value held in RBX (which specifies the type of result `strToInt()` returns).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 程序然后根据 RBX 中保存的值（指定`strToInt()`返回结果的类型）将控制转移到`asmMain()`的不同部分。
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 7-4: Using register-indirect `jmp` instructions'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-4：使用寄存器间接`jmp`指令
- en: 'Here’s the build command and a sample run of the program in [Listing 7-4](#listing7-4):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是[清单 7-4](#listing7-4)中的构建命令和程序示例运行：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 7.2.2 Memory-Indirect Jumps
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2.2 内存间接跳转
- en: The third form of the `jmp` instruction is a *memory-indirect* *jump*, which
    fetches the quad-word value from the memory location and jumps to that address.
    This is similar to the register-indirect `jmp` except the address appears in a
    memory location rather than in a register.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`jmp` 指令的第三种形式是 *内存间接* *跳转*，它从内存位置获取四字节值并跳转到该地址。这类似于寄存器间接 `jmp`，只不过地址出现在内存位置，而不是寄存器中。'
- en: '[Listing 7-5](#listing7-5) demonstrates a rather trivial use of this form of
    the `jmp` instruction.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-5](#listing7-5) 演示了这种形式的 `jmp` 指令的一种相当简单的使用方法。'
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 7-5: Using memory-indirect `jmp` instructions'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 7-5: 使用内存间接 `jmp` 指令'
- en: 'Here’s the build command and output for [Listing 7-5](#listing7-5):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 [列表 7-5](#listing7-5) 的构建命令和输出：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that you can easily crash your system if you execute an indirect jump with
    an invalid pointer value.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你执行带有无效指针值的间接跳转，系统可能会崩溃。
- en: 7.3 Conditional Jump Instructions
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 条件跳转指令
- en: Although Chapter 2 provided an overview of the conditional jump instructions,
    repeating that discussion and expanding upon it here is worthwhile as conditional
    jumps are the principal tool for creating control structures in assembly language.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管第二章已经概述了条件跳转指令，但在这里重复讨论并扩展这一内容是值得的，因为条件跳转是创建汇编语言控制结构的主要工具。
- en: Unlike the unconditional `jmp` instruction, the conditional jump instructions
    do not provide an indirect form. They only allow a branch to a statement label
    in your program.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与无条件 `jmp` 指令不同，条件跳转指令没有间接形式。它们仅允许跳转到程序中的语句标签。
- en: Intel’s documentation defines various synonyms or instruction aliases for many
    conditional jump instructions. Tables 7-1, 7-2, and 7-3 list all the aliases for
    a particular instruction, as well as the opposite branches. You’ll soon see the
    purpose of the opposite branches.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔的文档为许多条件跳转指令定义了各种同义词或指令别名。表 7-1、7-2 和 7-3 列出了每个指令的所有别名，以及相对分支。你很快就会看到反向分支的用途。
- en: 'Table 7-1: `j``cc` Instructions That Test Flags'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '表 7-1: `j``cc` 测试标志的指令'
- en: '| **Instruction** | **Description** | **Condition** | **Aliases** | **Opposite**
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** | **条件** | **别名** | **反向** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `jc` | Jump if carry | Carry = 1 | `jb`, `jnae` | `jnc` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `jc` | 如果有进位则跳转 | 进位 = 1 | `jb`, `jnae` | `jnc` |'
- en: '| `jnc` | Jump if no carry | Carry = 0 | `jnb`, `jae` | `jc` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `jnc` | 如果没有进位则跳转 | 进位 = 0 | `jnb`, `jae` | `jc` |'
- en: '| `jz` | Jump if zero | Zero = 1 | `je` | `jnz` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `jz` | 如果为零则跳转 | 零 = 1 | `je` | `jnz` |'
- en: '| `jnz` | Jump if not zero | Zero = 0 | `jne` | `jz` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `jnz` | 如果不为零则跳转 | 零 = 0 | `jne` | `jz` |'
- en: '| `js` | Jump if sign | Sign = 1 |  | `jns` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `js` | 如果符号则跳转 | 符号 = 1 |  | `jns` |'
- en: '| `jns` | Jump if no sign | Sign = 0 |  | `js` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `jns` | 如果没有符号则跳转 | 符号 = 0 |  | `js` |'
- en: '| `jo` | Jump if overflow | Overflow = 1 |  | `jno` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `jo` | 如果溢出则跳转 | 溢出 = 1 |  | `jno` |'
- en: '| `jno` | Jump if no overflow | Overflow = 0 |  | `jo` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `jno` | 如果没有溢出则跳转 | 溢出 = 0 |  | `jo` |'
- en: '| `jp` | Jump if parity | Parity = 1 | `jpe` | `jnp` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `jp` | 如果有奇偶性则跳转 | 奇偶性 = 1 | `jpe` | `jnp` |'
- en: '| `jpe` | Jump if parity even | Parity = 1 | `jp` | `jpo` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `jpe` | 如果奇偶性为偶则跳转 | 奇偶性 = 1 | `jp` | `jpo` |'
- en: '| `jnp` | Jump if no parity | Parity = 0 | `jpo` | `jp` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `jnp` | 如果无奇偶性则跳转 | 奇偶性 = 0 | `jpo` | `jp` |'
- en: '| `jpo` | Jump if parity odd | Parity = 0 | `jnp` | `jpe` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `jpo` | 如果奇偶性为奇则跳转 | 奇偶性 = 0 | `jnp` | `jpe` |'
- en: 'Table 7-2: `j``cc` Instructions for Unsigned Comparisons'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '表 7-2: `j``cc` 无符号比较指令'
- en: '| **Instruction** | **Description** | **Condition** | **Aliases** | **Opposite**
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** | **条件** | **别名** | **反向** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `ja` | Jump if above (`>`) | Carry = 0, Zero = 0 | `jnbe` | `jna` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `ja` | 如果大于（`>`）则跳转 | 进位 = 0, 零 = 0 | `jnbe` | `jna` |'
- en: '| `jnbe` | Jump if not below or equal (not `≤`) | Carry = 0, Zero = 0 | `ja`
    | `jbe` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `jnbe` | 如果不小于或等于（不是 `≤`）则跳转 | 进位 = 0, 零 = 0 | `ja` | `jbe` |'
- en: '| `jae` | Jump if above or equal (`≥`) | Carry = 0 | `jnc`, `jnb` | `jnae`
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `jae` | 如果大于或等于（`≥`）则跳转 | 进位 = 0 | `jnc`, `jnb` | `jnae` |'
- en: '| `jnb` | Jump if not below (not `<`) | Carry = 0 | `jnc`, `jae` | `jb` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `jnb` | 如果不小于（不是 `<`）则跳转 | 进位 = 0 | `jnc`, `jae` | `jb` |'
- en: '| `jb` | Jump if below (`<`) | Carry = 1 | `jc`, `jnae` | `jnb` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `jb` | 如果小于（`<`）则跳转 | 进位 = 1 | `jc`, `jnae` | `jnb` |'
- en: '| `jnae` | Jump if not above or equal (not `≥`) | Carry = 1 | `jc`, `jb` |
    `jae` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `jnae` | 如果不大于或等于（不是 `≥`）则跳转 | 进位 = 1 | `jc`, `jb` | `jae` |'
- en: '| `jbe` | Jump if below or equal (`≤`) | Carry = 1 or Zero = 1 | `jna` | `jnbe`
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `jbe` | 如果小于或等于（`≤`）则跳转 | 进位 = 1 或 零 = 1 | `jna` | `jnbe` |'
- en: '| `jna` | Jump if not above (not `>`) | Carry = 1 or Zero = 1 | `jbe` | `ja`
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `jna` | 如果不大于（不是 `>`）则跳转 | 进位 = 1 或 零 = 1 | `jbe` | `ja` |'
- en: '| `je` | Jump if equal (`=`) | Zero = 1 | `jz` | `jne` |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `je` | 如果相等（`=`）则跳转 | 零 = 1 | `jz` | `jne` |'
- en: '| `jne` | Jump if not equal (`≠`) | Zero = 0 | `jnz` | `je` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `jne` | 如果不相等（`≠`）则跳转 | 零 = 0 | `jnz` | `je` |'
- en: 'Table 7-3: `j``cc` Instructions for Signed Comparisons'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-3：`j``cc` 有符号比较指令
- en: '| **Instruction** | **Description** | **Condition** | **Aliases** | **Opposite**
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** | **条件** | **别名** | **相反** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `jg` | Jump if greater (`>`) | Sign = Overflow or Zero = 0 | `jnle` | `jng`
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `jg` | 如果大于（`>`）则跳转 | 符号 = 溢出或零 = 0 | `jnle` | `jng` |'
- en: '| `jnle` | Jump if not less than or equal (not `≤`) | Sign = Overflow or Zero
    = 0 | `jg` | `jle` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `jnle` | 如果不小于或等于（不是 `≤`）则跳转 | 符号 = 溢出或零 = 0 | `jg` | `jle` |'
- en: '| `jge` | Jump if greater than or equal (`≥`) | Sign = Overflow | `jnl` | `jnge`
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `jge` | 如果大于或等于（`≥`）则跳转 | 符号 = 溢出 | `jnl` | `jnge` |'
- en: '| `jnl` | Jump if not less than (not `<`) | Sign = Overflow | `jge` | `jl`
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `jnl` | 如果不小于（不是 `<`）则跳转 | 符号 = 溢出 | `jge` | `jl` |'
- en: '| `jl` | Jump if less than (`<`) | Sign `≠` Overflow | `jnge` | `jnl` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `jl` | 如果小于（`<`）则跳转 | 符号 `≠` 溢出 | `jnge` | `jnl` |'
- en: '| `jnge` | Jump if not greater or equal (not `≥`) | Sign `≠` Overflow | `jl`
    | `jge` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `jnge` | 如果不大于或等于（不是 `≥`）则跳转 | 符号 `≠` 溢出 | `jl` | `jge` |'
- en: '| `jle` | Jump if less than or equal (`≤`) | Sign `≠` Oveflow or Zero = 1 |
    `jng` | `jnle` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `jle` | 如果小于或等于（`≤`）则跳转 | 符号 `≠` 溢出或零 = 1 | `jng` | `jnle` |'
- en: '| `jng` | Jump if not greater than (not `>`) | Sign `≠` Overflow or Zero =
    1 | `jle` | `jg` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `jng` | 如果不大于（不是 `>`）则跳转 | 符号 `≠` 溢出或零 = 1 | `jle` | `jg` |'
- en: '| `je` | Jump if equal (`=`) | Zero = 1 | `jz` | `jne` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `je` | 如果相等（`=`）则跳转 | 零 = 1 | `jz` | `jne` |'
- en: '| `jne` | Jump if not equal (`≠`) | Zero = 0 | `jnz` | `je` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `jne` | 如果不相等（`≠`）则跳转 | 零 = 0 | `jnz` | `je` |'
- en: 'In many instances, you will need to generate the opposite of a specific branch
    instruction (examples appear later in this section). With only two exceptions,
    the *opposite branch (N/No N)* rule describes how to generate an opposite branch:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你需要生成特定分支指令的相反分支（该部分稍后的例子中会出现）。除了两个例外外，*相反分支（N/No N）* 规则描述了如何生成相反分支：
- en: If the second letter of the `j``cc` instruction is not an `n`, insert an `n`
    after the `j`. For example, `je` becomes `jne`, and `jl` becomes `jnl`.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `j``cc` 指令的第二个字母不是 `n`，则在 `j` 后面插入一个 `n`。例如，`je` 变成 `jne`，`jl` 变成 `jnl`。
- en: If the second letter of the `j``cc` instruction is an `n`, remove that `n` from
    the instruction. For example, `jng` becomes `jg`, and `jne` becomes `je`.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `j``cc` 指令的第二个字母是 `n`，则从指令中去掉该 `n`。例如，`jng` 变成 `jg`，`jne` 变成 `je`。
- en: The two exceptions to this rule are `jpe` (*jump if parity is even*) and `jpo`
    (*jump if parity is odd*).^([2](#c07-footnote-2)) However, you can use the aliases
    `jp` and `jnp` as synonyms for `jpe` and `jpo`, and the N/No N rule applies to
    `jp` and `jnp`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 该规则的两个例外是 `jpe`（*如果奇偶校验为偶*）和 `jpo`（*如果奇偶校验为奇*）。^([2](#c07-footnote-2)) 但是，你可以使用别名
    `jp` 和 `jnp` 来分别表示 `jpe` 和 `jpo`，并且 N/No N 规则适用于 `jp` 和 `jnp`。
- en: 'The x86-64 conditional jump instructions give you the ability to split program
    flow into one of two paths depending on a certain condition. Suppose you want
    to increment the AX register if BX is equal to CX. You can accomplish this with
    the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64 条件跳转指令使你能够根据特定条件将程序流程分为两条路径。假设你想在 BX 等于 CX 时递增 AX 寄存器。你可以使用以下代码来实现：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Instead of checking for equality directly and branching to code to handle that
    condition, the common approach is to use the opposite branch to skip over the
    instructions you want to execute if the condition is true. That is, if BX is *not*
    equal to CX, jump over the increment instruction. Always use the opposite branch
    (N/No N) rule given earlier to select the opposite branch.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不是直接检查相等并跳转到处理该条件的代码，常见的方法是使用相反的分支跳过你想在条件为真时执行的指令。也就是说，如果 BX *不* 等于 CX，则跳过递增指令。始终使用前面提到的相反分支（N/No
    N）规则来选择相反分支。
- en: 'You can also use the conditional jump instructions to synthesize loops. For
    example, the following code sequence reads a sequence of characters from the user
    and stores each character in successive elements of an array until the user presses
    enter (newline):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用条件跳转指令来合成循环。例如，以下代码序列从用户读取一串字符，并将每个字符依次存储到数组的元素中，直到用户按下回车键（换行）为止：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The conditional jump instructions only test the x86-64 flags; they do not affect
    any of them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 条件跳转指令仅测试 x86-64 标志；它们不会影响任何标志。
- en: 'From an efficiency point of view, it’s important to note that each conditional
    jump has two machine code encodings: a 2-byte form and a 6-byte form.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从效率的角度来看，需要注意的是，每个条件跳转都有两种机器代码编码方式：一种是2字节形式，另一种是6字节形式。
- en: The 2-byte form consists of the `j``cc` opcode followed by a 1-byte PC-relative
    displacement. The 1-byte displacement allows the instruction to transfer control
    to a target instruction within about ±127 bytes around the current instruction.
    Given that the average x86-64 instruction is probably 4 to 5 bytes long, the 2-byte
    form of `j``cc` is capable of branching to a target instruction within about 20
    to 25 instructions.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 2字节形式由`j``cc`操作码和一个1字节的相对PC偏移组成。1字节偏移允许指令将控制权转移到当前指令大约±127字节范围内的目标指令。考虑到平均x86-64指令可能是4到5字节长，`j``cc`的2字节形式能够在大约20到25条指令范围内跳转到目标指令。
- en: Because a range of 20 to 25 instructions is insufficient for all conditional
    jumps, the x86-64 provides a second (6-byte) form with a 2-byte opcode and a 4-byte
    displacement. The 6-byte form gives you the ability to jump to an instruction
    within approximately ±2GB of the current instruction, which is probably sufficient
    for any reasonable program out there.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因为20到25条指令的范围对于所有条件跳转来说都不够，x86-64提供了第二种（6字节）形式，包含2字节操作码和4字节偏移。6字节形式使你能够跳转到当前指令大约±2GB范围内的指令，这对于任何合理的程序来说大多足够了。
- en: If you have the opportunity to branch to a nearby label rather than one that
    is far away (and still achieve the same result), branching to the nearby label
    will make your code shorter and possibly faster.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有机会跳转到一个较近的标签，而不是远距离跳转（并且仍然能达到相同的结果），跳转到较近的标签将使你的代码更短，可能更快。
- en: 7.4 Trampolines
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 跳板
- en: 'In the rare case you need to branch to a location beyond the range of the 6-byte
    `j``cc` instructions, you can use an instruction sequence such as the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，如果需要跳转到超出6字节`j``cc`指令范围的位置，可以使用如下的指令序列：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The opposite conditional branch transfers control to the normal *fall-though
    point* in the code (the code you’d normally fall through to if the condition is
    false). If the condition is true, control transfers to a memory-indirect jump
    that jumps to the original target location via a 64-bit pointer.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的条件分支将控制权转移到代码中的正常*继续点*（即在条件为假时通常会继续执行的代码）。如果条件为真，控制权将转移到一个内存间接跳转，该跳转通过64位指针跳转到原始目标位置。
- en: This sequence is known as a *trampoline*, because a program jumps to this point
    to jump even further in the program (much like how jumping on a trampoline lets
    you jump higher and higher). Trampolines are useful for call and unconditional
    jump instructions that use the PC-relative addressing mode (and, thus, are limited
    to a ±2GB range around the current instruction).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 该序列被称为*跳板*，因为程序跳到这一点，再进一步跳到程序中的其他位置（就像跳床一样，可以让你跳得越来越高）。跳板对于使用PC相对寻址模式的调用和无条件跳转指令非常有用（因此，它们的范围仅限于当前指令的±2GB范围）。
- en: You’ll rarely use trampolines to transfer to another location within your program.
    However, trampolines are useful when transferring control to a dynamically linked
    library or OS subroutine that could be far away in memory.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你很少会使用跳板将控制转移到程序中的另一个位置。然而，当将控制转移到动态链接库或操作系统子程序时，跳板非常有用，因为这些可能在内存中距离较远。
- en: 7.5 Conditional Move Instructions
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 条件移动指令
- en: 'Sometimes all you need to do after a comparison or other conditional test is
    to load a value into a register (and, conversely, not load that value if the test
    or comparison fails). Because branches can be somewhat expensive to execute, the
    x86-64 CPUs support a set of conditional move instructions, `cmov``cc`. These
    instructions appear in Tables 7-4, 7-5, and 7-6; the generic syntax for these
    instructions is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在比较或其他条件测试之后，你所需要做的只是将一个值加载到寄存器中（相反，如果测试或比较失败，则不加载该值）。因为分支指令的执行可能比较昂贵，x86-64
    CPU支持一组条件移动指令，`cmov``cc`。这些指令出现在表7-4、7-5和7-6中；这些指令的通用语法如下：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The destination is always a general-purpose register (16, 32, or 64 bits). You
    can use these instructions only to load a register from memory or copy data from
    one register to another; you cannot use them to conditionally store data to memory.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 目标始终是一个通用寄存器（16、32或64位）。你只能使用这些指令从内存加载数据到寄存器，或者将数据从一个寄存器复制到另一个寄存器；不能用它们来有条件地将数据存储到内存。
- en: 'Table 7-4: `cmov``cc` Instructions That Test Flags'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 表7-4：`cmov``cc` 测试标志的指令
- en: '| **Instruction** | **Description** | **Condition** | **Aliases** |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** | **条件** | **别名** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `cmovc` | Move if carry | Carry = 1 | `cmovb`, `cmovnae` |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `cmovc` | 如果有进位，则移动 | 进位 = 1 | `cmovb`，`cmovnae` |'
- en: '| `cmovnc` | Move if no carry | Carry = 0 | `cmovnb`, `cmovae` |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `cmovnc` | 如果无进位，则移动 | 进位 = 0 | `cmovnb`，`cmovae` |'
- en: '| `cmovz` | Move if zero | Zero = 1 | `cmove` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `cmovz` | 如果为零，则移动 | 零标志 = 1 | `cmove` |'
- en: '| `cmovnz` | Move if not zero | Zero = 0 | `cmovne` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `cmovnz` | 如果不为零，则移动 | 零标志 = 0 | `cmovne` |'
- en: '| `cmovs` | Move if sign | Sign = 1 |  |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `cmovs` | 如果有符号标志，则移动 | 符号 = 1 |  |'
- en: '| `cmovns` | Move if no sign | Sign = 0 |  |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `cmovns` | 如果无符号标志，则移动 | 符号 = 0 |  |'
- en: '| `cmovo` | Move if overflow | Overflow = 1 |  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `cmovo` | 如果溢出，则移动 | 溢出 = 1 |  |'
- en: '| `cmovno` | Move if no overflow | Overflow = 0 |  |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `cmovno` | 如果无溢出，则移动 | 溢出 = 0 |  |'
- en: '| `cmovp` | Move if parity | Parity = 1 | `cmovpe` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `cmovp` | 如果有奇偶校验，则移动 | 奇偶校验 = 1 | `cmovpe` |'
- en: '| `cmovpe` | Move if parity even | Parity = 1 | `cmovp` |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `cmovpe` | 如果奇偶校验为偶，则移动 | 奇偶校验 = 1 | `cmovp` |'
- en: '| `cmovnp` | Move if no parity | Parity = 0 | `cmovpo` |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `cmovnp` | 如果无奇偶校验，则移动 | 奇偶校验 = 0 | `cmovpo` |'
- en: '| `cmovpo` | Move if parity odd | Parity = 0 | `cmovnp` |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `cmovpo` | 如果奇偶校验为奇，则移动 | 奇偶校验 = 0 | `cmovnp` |'
- en: 'Table 7-5: `cmov``cc` Instructions for Unsigned Comparisons'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '表 7-5: `cmov``cc` 指令用于无符号比较'
- en: '| **Instruction** | **Description** | **Condition** | **Aliases** |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** | **条件** | **别名** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `cmova` | Move if above (`>`) | Carry = 0, Zero = 0 | `cmovnbe` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `cmova` | 如果大于（`>`），则移动 | 进位 = 0，零标志 = 0 | `cmovnbe` |'
- en: '| `cmovnbe` | Move if not below or equal (not `≤`) | Carry = 0, Zero = 0 |
    `cmova` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `cmovnbe` | 如果不小于或等于（非`≤`），则移动 | 进位 = 0，零标志 = 0 | `cmova` |'
- en: '| `cmovae` | Move if above or equal (`≥`) | Carry = 0 | `cmovnc`, `cmovnb`
    |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `cmovae` | 如果大于或等于（`≥`），则移动 | 进位 = 0 | `cmovnc`，`cmovnb` |'
- en: '| `cmovnb` | Move if not below (not `<`) | Carry = 0 | `cmovnc`, `cmovae` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `cmovnb` | 如果不小于（非`<`），则移动 | 进位 = 0 | `cmovnc`，`cmovae` |'
- en: '| `cmovb` | Move if below (`<`) | Carry = 1 | `cmovc`, `cmovnae` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `cmovb` | 如果小于（`<`），则移动 | 进位 = 1 | `cmovc`，`cmovnae` |'
- en: '| `cmovnae` | Move if not above or equal (not `≥`) | Carry = 1 | `cmovc`, `cmovb`
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `cmovnae` | 如果不大于或等于（非`≥`），则移动 | 进位 = 1 | `cmovc`，`cmovb` |'
- en: '| `cmovbe` | Move if below or equal (`≤`) | Carry = 1 or Zero = 1 | `cmovna`
    |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `cmovbe` | 如果小于或等于（`≤`），则移动 | 进位 = 1 或 零标志 = 1 | `cmovna` |'
- en: '| `cmovna` | Move if not above (not `>`) | Carry = 1 or Zero = 1 | `cmovbe`
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `cmovna` | 如果不大于（非`>`），则移动 | 进位 = 1 或 零标志 = 1 | `cmovbe` |'
- en: '| `cmove` | Move if equal (`=`) | Zero = 1 | `cmovz` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `cmove` | 如果相等（`=`），则移动 | 零标志 = 1 | `cmovz` |'
- en: '| `cmovne` | Move if not equal (`≠`) | Zero = 0 | `cmovnz` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `cmovne` | 如果不相等（`≠`），则移动 | 零标志 = 0 | `cmovnz` |'
- en: 'Table 7-6: `cmov``cc` Instructions for Signed Comparisons'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '表 7-6: `cmov``cc` 指令用于有符号比较'
- en: '| **Instruction** | **Description** | **Condition** | **Aliases** |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **描述** | **条件** | **别名** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `cmovg` | Move if greater (`>`) | Sign = Overflow or Zero = 0 | `cmovnle`
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `cmovg` | 如果大于（`>`），则移动 | 符号 = 溢出 或 零标志 = 0 | `cmovnle` |'
- en: '| `cmovnle` | Move if not less than or equal (not `≤`) | Sign = Overflow or
    Zero = 0 | `cmovg` |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `cmovnle` | 如果不小于或等于（非`≤`），则移动 | 符号 = 溢出 或 零标志 = 0 | `cmovg` |'
- en: '| `cmovge` | Move if greater than or equal (`≥`) | Sign = Overflow | `cmovnl`
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `cmovge` | 如果大于或等于（`≥`），则移动 | 符号 = 溢出 | `cmovnl` |'
- en: '| `cmovnl` | Move if not less than (not `<`) | Sign = Overflow | `cmovge` |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `cmovnl` | 如果不小于（非`<`），则移动 | 符号 = 溢出 | `cmovge` |'
- en: '| `cmovl` | Move if less than (`<`) | Sign != Overflow | `cmovnge` |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `cmovl` | 如果小于（`<`），则移动 | 符号 ≠ 溢出 | `cmovnge` |'
- en: '| `cmovnge` | Move if not greater or equal (not `≥`) | Sign != Overflow | `cmovl`
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `cmovnge` | 如果不大于或等于（非`≥`），则移动 | 符号 ≠ 溢出 | `cmovl` |'
- en: '| `cmovle` | Move if less than or equal (`≤`) | Sign != Overflow or Zero =
    1 | `cmovng` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `cmovle` | 如果小于或等于（`≤`），则移动 | 符号 ≠ 溢出 或 零标志 = 1 | `cmovng` |'
- en: '| `cmovng` | Move if not greater than (not `>`) | Sign != Overflow or Zero
    = 1 | `cmovle` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `cmovng` | 如果不大于（非`>`），则移动 | 符号 ≠ 溢出 或 零标志 = 1 | `cmovle` |'
- en: '| `cmove` | Move if equal (`=`) | Zero = 1 | `cmovz` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `cmove` | 如果相等（`=`），则移动 | 零标志 = 1 | `cmovz` |'
- en: '| `cmovne` | Move if not equal (`≠`) | Zero = 0 | `cmovnz` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `cmovne` | 如果不相等（`≠`），则移动 | 零标志 = 0 | `cmovnz` |'
- en: In addition, a set of conditional floating-point move instructions (`fcmov``cc`)
    will move data between ST0 and one of the other FPU registers on the FPU stack.
    Sadly, these instructions aren’t all that useful in modern programs. See the Intel
    documentation for more details if you’re interested in using them.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一组条件浮点移动指令（`fcmov``cc`）将会在 FPU 堆栈中将数据在 ST0 和其他 FPU 寄存器之间移动。不幸的是，这些指令在现代程序中并不是特别有用。如果你有兴趣使用它们，可以查看
    Intel 文档获取更多细节。
- en: 7.6 Implementing Common Control Structures in Assembly Language
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 在汇编语言中实现常见控制结构
- en: This section shows you how to implement decisions, loops, and other control
    constructs using pure assembly language.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了如何使用纯汇编语言实现决策、循环和其他控制结构。
- en: 7.6.1 Decisions
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.1 决策
- en: 'In its most basic form, a *decision* is a branch within the code that switches
    between two possible execution paths based on a certain condition. Normally (though
    not always), conditional instruction sequences are implemented with the conditional
    jump instructions. Conditional instructions correspond to the `if/then/endif`
    statement in an HLL:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的形式中，*决策*是代码中的一个分支，根据某个条件在两个可能的执行路径之间切换。通常（尽管并非总是如此），条件指令序列是通过条件跳转指令来实现的。条件指令对应于高级语言中的`if/then/endif`语句：
- en: '[PRE21]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To convert this to assembly language, you must write statements that evaluate
    the `expression` and then branch around the `statements` if the result is false.
    For example, if you had the C statements
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其转换为汇编语言，你必须编写评估`expression`的语句，然后在结果为假时跳过`statements`。例如，如果你有如下C语句：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'you could translate this to assembly as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将其转换为汇编语言，如下所示：
- en: '[PRE23]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In general, conditional statements may be broken into three basic categories:
    `if` statements, `switch`/`case` statements, and indirect jumps. The following
    sections describe these program structures, how to use them, and how to write
    them in assembly language.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，条件语句可以分为三大类：`if`语句、`switch`/`case`语句和间接跳转。以下章节将描述这些程序结构、如何使用它们以及如何在汇编语言中编写它们。
- en: 7.6.2 if/then/else Sequences
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.2 `if/then/else`序列
- en: The most common conditional statements are the `if/then/endif` and `if/then/else/endif`
    statements. These two statements take the form shown in [Figure 7-1](#figure7-1).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的条件语句是`if/then/endif`和`if/then/else/endif`语句。这两种语句的形式如[图7-1](#figure7-1)所示。
- en: '![f07001](image_fi/501089c07/f07001.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![f07001](image_fi/501089c07/f07001.png)'
- en: 'Figure 7-1: `if``/``then``/``else``/``endif` and `if``/``then``/``endif` statement
    flow'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-1：`if``/``then``/``else``/``endif`和`if``/``then``/``endif`语句流程
- en: The `if/then/endif` statement is just a special case of the `if/then/else/endif`
    statement (with an empty `else` block). The basic implementation of an `if/then/else/endif`
    statement in x86-64 assembly language looks something like
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`if/then/endif`语句只是`if/then/else/endif`语句的一种特殊情况（没有`else`块）。`if/then/else/endif`语句的基本实现形式如下所示（在x86-64汇编语言中）：'
- en: '[PRE24]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: where `j``cc` represents a conditional jump instruction.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`j``cc`表示条件跳转指令。
- en: For example, to convert the C/C++ statement
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要转换C/C++语句
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'to assembly language, you could use the following x86-64 code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为汇编语言时，你可以使用以下x86-64代码：
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For simple expressions like `(a == b)`, generating the proper code for an `if/then/else/endif`
    statement is almost trivial. Should the expression become more complex, the code
    complexity increases as well. Consider the following C/C++ `if` statement presented
    earlier:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像`(a == b)`这样的简单表达式，生成一个`if/then/else/endif`语句的适当代码几乎是微不足道的。如果表达式变得更复杂，代码的复杂性也会增加。考虑之前提到的这个C/C++
    `if`语句：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To convert complex `if` statements such as this one, break it into a sequence
    of three `if` statements as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要转换像这样的复杂`if`语句，可以将其分解为三个`if`语句，形式如下：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This conversion comes from the following C/C++ equivalences:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换来自以下C/C++等价物：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: is equivalent to
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: and
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: is equivalent to
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In assembly language, the former `if` statement becomes
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，前者的`if`语句变成了
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Probably the biggest problem with complex conditional statements in assembly
    language is trying to figure out what you’ve done after you’ve written the code.
    High-level language expressions are much easier to read and comprehend. Well-written
    comments are essential for clear assembly language implementations of `if/then/else/endif`
    statements. An elegant implementation of the preceding example follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言中复杂条件语句最大的难题可能是，在编写完代码后，试图弄清楚自己做了什么。高级语言的表达式要容易阅读和理解得多。写得好的注释对于清晰的汇编语言实现`if/then/else/endif`语句至关重要。下面是前一个例子的优雅实现：
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Admittedly, this goes overboard for such a simple example. The following would
    probably suffice:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 诚然，对于这么简单的例子来说，这样做有些过头。下面的写法可能已经足够：
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: However, as your `if` statements become complex, the density (and quality) of
    your comments becomes more and more important.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你的`if`语句变得复杂时，你的注释的密度（和质量）变得越来越重要。
- en: 7.6.3 Complex if Statements Using Complete Boolean Evaluation
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.3 使用完整布尔运算的复杂if语句
- en: 'Many Boolean expressions involve conjunction (`and`) or disjunction (`or`)
    operations. This section describes how to convert such Boolean expressions into
    assembly language. We can do this in two ways: using *complete Boolean evaluation*
    or using *short-circuit Boolean evaluation*. This section discusses complete Boolean
    evaluation. The next section discusses short-circuit Boolean evaluation.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 许多布尔表达式涉及合取（`and`）或析取（`or`）操作。本节描述了如何将这些布尔表达式转换为汇编语言。我们可以通过两种方式来实现：使用*完整布尔评估*或使用*短路布尔评估*。本节讨论了完整布尔评估，下一节将讨论短路布尔评估。
- en: 'Conversion via complete Boolean evaluation is almost identical to converting
    arithmetic expressions into assembly language, as covered in Chapter 6. However,
    for Boolean evaluation, you do not need to store the result in a variable; once
    the evaluation of the expression is complete, you check whether you have a false
    (0) or true (1, or nonzero) result to take whatever action the Boolean expression
    dictates. Usually, the last logical instruction (`and`/`or`) sets the zero flag
    if the result is false and clears the zero flag if the result is true, so you
    don’t have to explicitly test for the result. Consider the following `if` statement
    and its conversion to assembly language using complete Boolean evaluation:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完整布尔评估的转换与将算术表达式转换为汇编语言几乎相同，如第6章所述。然而，对于布尔评估，你不需要将结果存储在变量中；一旦表达式的评估完成，你只需检查结果是`false`（0）还是`true`（1，或者非零），然后根据布尔表达式的要求采取相应的行动。通常，最后一条逻辑指令（`and`/`or`）会在结果为`false`时设置零标志，而在结果为`true`时清除零标志，因此你不必显式地测试结果。考虑以下`if`语句及其通过完整布尔评估转换为汇编语言的过程：
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This code computes a Boolean result in the BL register and then, at the end
    of the computation, tests this value to see whether it contains true or false.
    If the result is false, this sequence skips over the code associated with `Stmt1`.
    The important thing to note in this example is that the program will execute every
    instruction that computes this Boolean result (up to the `je` instruction).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码在BL寄存器中计算一个布尔结果，然后在计算结束时测试该值，看它是否包含`true`或`false`。如果结果为`false`，则该序列会跳过与`Stmt1`相关的代码。在这个例子中，重要的是要注意，程序会执行计算布尔结果的每一条指令（直到`je`指令）。
- en: 7.6.4 Short-Circuit Boolean Evaluation
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.4 短路布尔评估
- en: If you are willing to expend a little more effort, you can usually convert a
    Boolean expression to a much shorter and faster sequence of assembly language
    instructions by using *short-circuit Boolean evaluation*. This approach attempts
    to determine whether an expression is true or false by executing only some of
    the instructions that would compute the complete expression.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意付出更多的努力，通常可以通过使用*短路布尔评估*将布尔表达式转换为更简短、更快速的汇编语言指令序列。该方法试图通过执行部分指令来确定一个表达式是`true`还是`false`，这些指令是计算完整表达式所需的指令的一部分。
- en: Consider the expression `a && b`. Once we determine that `a` is false, there
    is no need to evaluate `b` because there is no way the expression can be true.
    If `b` represents a complex subexpression rather than a single Boolean variable,
    it should be clear that evaluating only `a` is more efficient.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑表达式`a && b`。一旦我们确定`a`为`false`，就无需再评估`b`，因为这个表达式不可能为`true`。如果`b`表示一个复杂的子表达式而不是单一的布尔变量，那么仅评估`a`显然更高效。
- en: 'As a concrete example, consider the subexpression `((x < y) && (z > t))` from
    the previous section. Once you determine that `x` is not less than `y`, there
    is no need to check whether `z` is greater than `t` because the expression will
    be false regardless of `z`’s and `t`’s values. The following code fragment shows
    how you can implement short-circuit Boolean evaluation for this expression:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个具体的例子，考虑上一节中的子表达式`((x < y) && (z > t))`。一旦确定`x`不小于`y`，就无需检查`z`是否大于`t`，因为无论`z`和`t`的值如何，表达式都会为`false`。以下代码片段展示了如何实现该表达式的短路布尔评估：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The code skips any further testing once it determines that `x` is not less than
    `y`. Of course, if `x` is less than `y`, the program has to test `z` to see if
    it is greater than `t`; if not, the program skips over the `then` clause. Only
    if the program satisfies both conditions does the code fall through to the `then`
    clause.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 代码一旦确定`x`不小于`y`，就会跳过后续的测试。当然，如果`x`小于`y`，程序必须测试`z`是否大于`t`；如果不是，程序会跳过`then`语句。只有当程序满足两个条件时，代码才会继续执行`then`语句。
- en: 'For the logical `or` operation, the technique is similar. If the first subexpression
    evaluates to true, there is no need to test the second operand. Whatever the second
    operand’s value is at that point, the full expression still evaluates to true.
    The following example demonstrates the use of short-circuit evaluation with disjunction
    (`or`):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于逻辑`or`操作，方法类似。如果第一个子表达式计算结果为真，则不需要测试第二个操作数。无论此时第二个操作数的值为何，完整的表达式仍然为真。以下示例演示了如何使用短路求值与析取（`or`）结合：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Because the conjunction and disjunction operators are commutative, you can
    evaluate the left or right operand first if it is more convenient to do so.^([3](#c07-footnote-3))
    As one last example in this section, consider the full Boolean expression from
    the previous section:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因为连接词和析取词运算符是可交换的，所以如果更方便，你可以先计算左操作数或右操作数。^([3](#c07-footnote-3)) 作为本节中的最后一个例子，考虑前一节中的完整布尔表达式：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The code in this example evaluates `a != b` first, because it is shorter and
    faster,^([4](#c07-footnote-4)) and the remaining subexpression last. This is a
    common technique assembly language programmers use to write better code.^([5](#c07-footnote-5))
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中的代码首先评估`a != b`，因为它更短且更快，^([4](#c07-footnote-4)) 而最后评估剩余的子表达式。这是汇编语言程序员用来编写更高效代码的常见技术。^([5](#c07-footnote-5))
- en: 7.6.5 Short-Circuit vs. Complete Boolean Evaluation
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.5 短路与完全布尔求值
- en: When using complete Boolean evaluation, every statement in the sequence for
    that expression will execute; short-circuit Boolean evaluation, on the other hand,
    may not require the execution of every statement associated with the Boolean expression.
    As you’ve seen in the previous two sections, code based on short-circuit evaluation
    is usually shorter and faster.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完全布尔求值时，表达式中每个语句都会执行；而短路布尔求值则可能不需要执行与布尔表达式相关的每个语句。如你在前两节中所见，基于短路求值的代码通常更短且更快。
- en: 'However, short-circuit Boolean evaluation may not produce the correct result
    in some cases. Given an expression with *side effects*, short-circuit Boolean
    evaluation will produce a different result than complete Boolean evaluation. Consider
    the following C/C++ example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，短路布尔求值可能不会产生正确的结果。如果表达式中包含*副作用*，短路布尔求值会产生与完全布尔求值不同的结果。考虑以下C/C++示例：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Using complete Boolean evaluation, you might generate the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用完全布尔求值时，你可能会生成以下代码：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Using short-circuit Boolean evaluation, you might generate this:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用短路布尔求值时，你可能会生成如下代码：
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Notice a subtle but important difference between these two conversions: if
    `x` is equal to `y`, the first version still *increments* `z` *and compares it
    to 0* before it executes the code associated with `Stmt`; the short-circuit version,
    on the other hand, skips the code that increments `z` if it turns out that `x`
    is equal to `y`. Therefore, the behavior of these two code fragments is different
    if `x` is equal to `y`.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这两种转换之间一个微妙但重要的区别：如果`x`等于`y`，第一个版本仍然会在执行与`Stmt`相关的代码之前，*递增*`z`并*将其与0进行比较*；而短路版本则会跳过递增`z`的代码，前提是`x`等于`y`。因此，如果`x`等于`y`，这两段代码的行为是不同的。
- en: Neither implementation is particularly wrong; depending on the circumstances,
    you may or may not want the code to increment `z` if `x` is equal to `y`. However,
    it is important to realize that these two schemes produce different results, so
    you can choose an appropriate implementation if the effect of this code on `z`
    matters to your program.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种实现并没有什么特别错误的地方；根据具体情况，你可能希望或不希望代码在`x`等于`y`时递增`z`。然而，重要的是要意识到这两种方案会产生不同的结果，因此，如果代码对`z`的影响对你的程序很重要，你可以选择合适的实现方式。
- en: 'Many programs take advantage of short-circuit Boolean evaluation and rely on
    the program not evaluating certain components of the expression. The following
    C/C++ code fragment demonstrates perhaps the most common example that requires
    short-circuit Boolean evaluation:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序利用短路布尔求值，并依赖程序不对表达式的某些部分进行求值。以下C/C++代码片段演示了可能最常见的需要短路布尔求值的例子：
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If it turns out that `pntr` is `NULL`, the expression is false, and there is
    no need to evaluate the remainder of the expression. This statement relies on
    short-circuit Boolean evaluation for correct operation. Were C/C++ to use complete
    Boolean evaluation, the second half of the expression would attempt to dereference
    a `NULL` pointer, when `pntr` is `NULL`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`pntr`的值为`NULL`，则表达式为假，且无需评估表达式的其余部分。这个语句依赖于短路布尔评估来正确执行。如果C/C++使用完整的布尔评估，表达式的后半部分将尝试解除引用一个`NULL`指针，而此时`pntr`为`NULL`。
- en: 'Consider the translation of this statement using complete Boolean evaluation:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑使用完整布尔评估来翻译这条语句：
- en: '[PRE44]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If `pntr` contains `NULL (0)`, this program will attempt to access the data
    at location 0 in memory via the `mov al, [rax]` instruction. Under most operating
    systems, this will cause a memory access fault (general protection fault).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`pntr`包含`NULL (0)`，该程序将通过`mov al, [rax]`指令尝试访问内存位置0的数据。在大多数操作系统中，这将导致内存访问错误（一般保护错误）。
- en: 'Now consider the short-circuit Boolean conversion:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑短路布尔转换：
- en: '[PRE45]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In this example, the problem with dereferencing the `NULL` pointer doesn’t exist.
    If `pntr` contains `NULL`, this code skips over the statements that attempt to
    access the memory address `pntr` contains.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，解除引用`NULL`指针的问题并不存在。如果`pntr`为`NULL`，这段代码会跳过尝试访问`pntr`所指向的内存地址的语句。
- en: 7.6.6 Efficient Implementation of if Statements in Assembly Language
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.6 汇编语言中`if`语句的高效实现
- en: Encoding `if` statements efficiently in assembly language takes a bit more thought
    than simply choosing short-circuit evaluation over complete Boolean evaluation.
    To write code that executes as quickly as possible in assembly language, you must
    carefully analyze the situation and generate the code appropriately. The following
    paragraphs provide suggestions you can apply to your programs to improve their
    performance.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中高效地编码`if`语句需要比简单地选择短路评估或完整布尔评估更多的思考。为了在汇编语言中编写尽可能快速的代码，你必须仔细分析情况并适当生成代码。以下段落提供了一些建议，你可以将它们应用到程序中以提高性能。
- en: 7.6.6.1 Know Your Data!
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.6.1 了解你的数据！
- en: 'Programmers often mistakenly assume that data is random. In reality, data is
    rarely random, and if you know the types of values that your program commonly
    uses, you can write better code. To see how, consider the following C/C++ statement:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员常常错误地认为数据是随机的。实际上，数据很少是随机的，如果你了解程序常用的值类型，你可以编写更好的代码。为了更好理解，考虑以下C/C++语句：
- en: '[PRE46]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Because C/C++ uses short-circuit evaluation, this code will test whether `a`
    is equal to `b`. If so, it will test whether `c` is less than `d`. If you expect
    `a` to be equal to `b` most of the time but don’t expect `c` to be less than `d`
    most of the time, this statement will execute slower than it should. Consider
    the following MASM implementation of this code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C/C++使用短路评估，该代码会先测试`a`是否等于`b`。如果是，它会测试`c`是否小于`d`。如果你预计`a`大多数情况下等于`b`，但不预计`c`大多数情况下小于`d`，那么这条语句的执行会比应该的慢。考虑以下MASM实现的代码：
- en: '[PRE47]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can see, if `a` is equal to `b` most of the time and `c` is not less
    than `d` most of the time, you will have to execute all six instructions nearly
    every time in order to determine that the expression is false. Now consider the
    following implementation that takes advantage of this knowledge and the fact that
    the `&&` operator is commutative:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，如果`a`大多数时间等于`b`，且`c`大多数时间不小于`d`，你将不得不几乎每次执行所有六条指令，以确定表达式为假。现在考虑以下实现，它利用了这些知识，以及`&&`运算符是可交换的事实：
- en: '[PRE48]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The code first checks whether `c` is less than `d`. If most of the time `c`
    is less than `d`, this code determines that it has to skip to the label `DontIncI`
    after executing only three instructions in the typical case (compared with six
    instructions in the previous example).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先检查`c`是否小于`d`。如果大多数情况下`c`小于`d`，则该代码会在典型情况下只执行三条指令后跳过到标签`DontIncI`（相比于前面例子中的六条指令）。
- en: 'This fact is much more obvious in assembly language than in a high-level language,
    one of the main reasons assembly programs are often faster than their HLL counterparts:
    optimizations are more obvious in assembly language than in a high-level language.
    Of course, the key here is to understand the behavior of your data so you can
    make intelligent decisions such as the preceding one.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这个事实在汇编语言中比在高级语言中更加明显，这也是汇编程序通常比其高级语言（HLL）对应程序更快的主要原因之一：优化在汇编语言中比在高级语言中更为明显。当然，关键在于理解数据的行为，这样你才能做出像前述那样的明智决策。
- en: 7.6.6.2 Rearranging Expressions
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.6.2 重新排列表达式
- en: 'Even if your data is random (or you can’t determine how the input values will
    affect your decisions), rearranging the terms in your expressions may still be
    beneficial. Some calculations take far longer to compute than others. For example,
    the `div` instruction is much slower than a simple `cmp` instruction. Therefore,
    if you have a statement like the following, you may want to rearrange the expression
    so that the `cmp` comes first:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的数据是随机的（或者你无法确定输入值如何影响你的决策），重新排列表达式中的项仍然可能是有益的。一些计算比其他计算要慢得多。例如，`div` 指令比简单的
    `cmp` 指令要慢得多。因此，如果你有如下语句，你可能想要重新排列表达式，使得 `cmp` 先执行：
- en: '[PRE49]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Converted to assembly code, this `if` statement becomes the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为汇编代码后，这条 `if` 语句变成了以下内容：
- en: '[PRE50]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `idiv` instruction is expensive (often 50 to 100 times slower than most
    of the other instructions in this example). Unless it is 50 to 100 times more
    likely that the remainder is 0 rather than `x` is equal to `y`, it would be better
    to do the comparison first and the remainder calculation afterward:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`idiv` 指令的开销很大（通常比这个例子中大多数其他指令慢50到100倍）。除非余数为0的可能性比 `x` 等于 `y` 的可能性大50到100倍，否则最好先做比较，再进行余数计算：'
- en: '[PRE51]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Because the `&&` and `||` operators are not commutative when short-circuit evaluation
    occurs, do consider such transformations carefully when making them. This example
    works fine because there are no side effects or possible exceptions being shielded
    by the reordered evaluation of the `&&` operator.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `&&` 和 `||` 运算符在短路求值发生时并不是交换律的，所以在进行此类变换时请谨慎考虑。这个例子可以正常工作，因为没有副作用或可能的异常被重新排列的
    `&&` 运算符的求值方式所掩盖。
- en: 7.6.6.3 Destructuring Your Code
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.6.3 解构你的代码
- en: Structured code is sometimes less efficient than unstructured code because it
    introduces code duplication or extra branches that might not be present in unstructured
    code.^([6](#c07-footnote-6)) Most of the time, this is tolerable because unstructured
    code is difficult to read and maintain; sacrificing some performance in exchange
    for maintainable code is often acceptable. In certain instances, however, you
    may need all the performance you can get and might choose to compromise the readability
    of your code.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化代码有时比非结构化代码效率低，因为它引入了代码重复或额外的分支，而这些在非结构化代码中可能是不存在的。^([6](#c07-footnote-6))
    大多数情况下，这是可以接受的，因为非结构化代码难以阅读和维护；为了可维护的代码牺牲一些性能通常是可以接受的。然而，在某些情况下，你可能需要尽可能高的性能，可能会选择牺牲代码的可读性。
- en: Taking previously written structured code and rewriting it in an unstructured
    fashion to improve performance is known as *destructuring code*. The difference
    between unstructured code and destructured code is that unstructured code was
    written that way in the first place; destructured code started out as structured
    code and was purposefully written in an unstructured fashion to make it more efficient.
    Pure unstructured code is usually hard to read and maintain. Destructured code
    isn’t quite as bad because you limit the damage (unstructuring the code) to only
    those sections where it is absolutely necessary.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 将以前写的结构化代码重写为非结构化代码以提高性能被称为 *解构代码*。非结构化代码和解构代码的区别在于，非结构化代码一开始就是以那种方式编写的；而解构代码起初是结构化代码，并有意以非结构化的方式重写，以提高效率。纯粹的非结构化代码通常难以阅读和维护。解构代码则不那么糟糕，因为你仅将解构（非结构化代码）限制在那些绝对必要的部分。
- en: One classic way to destructure code is to use *code movement* (physically moving
    sections of code elsewhere in the program) to move code that your program rarely
    uses out of the way of code that executes most of the time. Code movement can
    improve the efficiency of a program in two ways.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 解构代码的一种经典方法是使用 *代码移动*（将代码片段物理地移到程序的其他地方），把程序很少使用的代码移到经常执行的代码之外。代码移动可以通过两种方式提高程序效率。
- en: First, a branch that is taken is more expensive (time-consuming) than a branch
    that is not taken.^([7](#c07-footnote-7)) If you move the rarely used code to
    another spot in the program and branch to it on the rare occasion the branch is
    taken, most of the time you will fall straight through to the code that executes
    most frequently.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，采取分支比不采取分支更昂贵（耗时）。^([7](#c07-footnote-7))如果你将不常用的代码移动到程序的另一个位置，并在少数情况下分支到它，大部分时间你将直接执行频繁执行的代码。
- en: Second, sequential machine instructions consume cache storage. If you move rarely
    executed statements out of the normal code stream to another section of the program
    (that is rarely loaded into cache), this will improve the cache performance of
    the system.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，顺序的机器指令会消耗缓存存储。如果你将不常执行的语句从正常的代码流中移到程序的其他部分（这些部分很少加载到缓存中），这将提高系统的缓存性能。
- en: 'For example, consider the following pseudo C/C++ statement:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下伪C/C++语句：
- en: '[PRE52]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In normal code, we don’t expect errors to be frequent. Therefore, you would
    normally expect the `then` section of the preceding `if` to execute far more often
    than the `else` clause. The preceding code could translate into the following
    assembly code:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通代码中，我们通常不期望错误频繁发生。因此，你通常会期望前面的`if`语句的`then`部分比`else`语句执行得更频繁。前面的代码可以转化为以下的汇编代码：
- en: '[PRE53]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If the expression is false, this code falls through to the normal statements
    and then jumps over the error-handling statements. Instructions that transfer
    control from one point in your program to another (for example, `jmp` instructions)
    tend to be slow. It is much faster to execute a sequential set of instructions
    rather than jump all over the place in your program. Unfortunately, the preceding
    code doesn’t allow this.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式为假，则这段代码会直接跳到正常语句，并跳过错误处理语句。那些将控制权从程序的一个点转移到另一个点的指令（例如，`jmp`指令）往往很慢。执行一系列顺序指令要比在程序中到处跳转要快得多。不幸的是，前面的代码并不允许这样做。
- en: 'One way to rectify this problem is to move the `else` clause of the code somewhere
    else in your program. You could rewrite the code as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的一种方法是将代码中的`else`语句移到程序的其他位置。你可以将代码重写如下：
- en: '[PRE54]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'At some other point in your program (typically after a `jmp` instruction),
    you would insert the following code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序的其他地方（通常在`jmp`指令之后），你会插入以下代码：
- en: '[PRE55]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The program isn’t any shorter. The `jmp` you removed from the original sequence
    winds up at the end of the `else` clause. However, because the `else` clause rarely
    executes, moving the `jmp` instruction from the `then` clause (which executes
    frequently) to the `else` clause is a big performance win because the `then` clause
    executes using only straight-line code. This technique is surprisingly effective
    in many time-critical code segments.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 程序并没有变得更短。你从原始序列中移除的`jmp`指令最终会到达`else`语句的末尾。然而，由于`else`语句很少执行，移动`jmp`指令从频繁执行的`then`语句到`else`语句会带来巨大的性能提升，因为`then`语句只通过直线代码执行。在许多时间关键的代码段中，这个技巧出奇的有效。
- en: 7.6.6.4 Calculation Rather Than Branching
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.6.4 计算而非分支
- en: On many processors in the x86-64 family, branches (jumps) are expensive compared
    to many other instructions. For this reason, it is sometimes better to execute
    more instructions in a sequence than fewer instructions that involve branching.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在x86-64系列的许多处理器中，分支（跳转）相比许多其他指令来说是昂贵的。因此，有时执行更多指令的顺序比执行少量涉及分支的指令要更好。
- en: 'For example, consider the simple assignment `eax = abs(eax)`. Unfortunately,
    no x86-64 instruction computes the absolute value of an integer. The obvious way
    to handle this is with an instruction sequence that uses a conditional jump to
    skip over the `neg` instruction (which creates a positive value in EAX if EAX
    was negative):'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑简单的赋值`eax = abs(eax)`。不幸的是，没有x86-64指令可以计算整数的绝对值。处理这个问题的显而易见的方法是使用一组指令，通过条件跳转来跳过`neg`指令（如果EAX为负，则该指令将EAX变为正值）：
- en: '[PRE56]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now consider the following sequence that will also do the job:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑以下的代码序列，这也能完成任务：
- en: '[PRE57]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This code will invert all the bits in EAX and then add 1 to EAX if EAX was negative
    prior to the sequence; that is, it negates the value in EAX. If EAX was zero or
    positive, this code does not change the value in EAX.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会将EAX中的所有位反转，然后在EAX为负之前加1；也就是说，它会将EAX中的值取反。如果EAX为零或正数，这段代码不会改变EAX中的值。
- en: 'Though this sequence takes four instructions rather than the three that the
    previous example requires, there are no transfer-of-control instructions, so it
    may execute faster on many CPUs in the x86-64 family. Of course, if you use the
    `cmovns` instruction presented earlier, this can be done with the following three
    instructions (with no transfer of control):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这一序列需要四条指令，而不是前面例子所需的三条指令，但它没有控制转移指令，因此在许多x86-64架构的CPU上执行可能更快。当然，如果你使用之前介绍过的`cmovns`指令，使用以下三条指令也能实现（且没有控制转移）：
- en: '[PRE58]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This demonstrates why it’s good to know the instruction set!
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这也证明了为什么了解指令集很重要！
- en: 7.6.7 switch/case Statements
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.7 `switch/case`语句
- en: 'The C/C++ `switch` statement takes the following form:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++的`switch`语句具有以下形式：
- en: '[PRE59]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: When this statement executes, it checks the value of the `expression` against
    the constants `const1` to `constn`. If it finds a match, the corresponding statements
    execute.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当该语句执行时，它会将`expression`的值与常量`const1`到`constn`进行比较。如果找到匹配的常量，相应的语句将执行。
- en: C/C++ places a few restrictions on the `switch` statement. First, the `switch`
    statement allows only an integer expression (or something whose underlying type
    can be an integer). Second, all the constants in the `case` clauses must be unique.
    The reason for these restrictions will become clear in a moment.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++对`switch`语句有一些限制。首先，`switch`语句只允许整数表达式（或者可以转化为整数的类型）。其次，`case`子句中的所有常量必须是唯一的。稍后这些限制的原因会变得清晰。
- en: 7.6.7.1 switch Statement Semantics
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.7.1 `switch`语句语义
- en: 'Most introductory programming texts introduce the `switch/case` statement by
    explaining it as a sequence of `if/then/elseif/else/endif` statements. They might
    claim that the following two pieces of C/C++ code are equivalent:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数入门编程教材通过将`switch/case`语句解释为一系列`if/then/elseif/else/endif`语句来介绍它。它们可能会声称以下两段C/C++代码是等效的：
- en: '[PRE60]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: While semantically these two code segments may be the same, their implementation
    is usually different. Whereas the `if/then/elseif/else/endif` chain does a comparison
    for each conditional statement in the sequence, the `switch` statement normally
    uses an indirect jump to transfer control to any one of several statements with
    a single computation.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在语义上这两段代码可能是相同的，但它们的实现通常是不同的。`if/then/elseif/else/endif`链会对序列中的每个条件语句进行比较，而`switch`语句通常使用间接跳转来通过一次计算将控制权转移到多个语句中的任何一个。
- en: 7.6.7.2 if/else Implementation of switch
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.7.2 `if/else`实现`switch`
- en: 'The `switch` (and `if/else/elseif`) statements could be written in assembly
    language with the following code:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`（以及`if/else/elseif`）语句可以用以下汇编语言代码编写：'
- en: '[PRE61]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Probably the only thing worth noting about this code is that it takes longer
    to determine the last case than it does to determine whether the first case executes.
    This is because the `if/else/elseif` version implements a *linear search* through
    the case values, checking them one at a time from first to last until it finds
    a match.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要注意的唯一一件事是，确定最后一个`case`所需的时间比确定第一个`case`是否执行的时间要长。这是因为`if/else/elseif`版本实现了*线性搜索*，逐个检查从第一个到最后一个`case`值，直到找到匹配项。
- en: 7.6.7.3 Indirect Jump switch Implementation
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.7.3 间接跳转`switch`实现
- en: 'A faster implementation of the `switch` statement is possible using an *indirect
    jump table*. This implementation uses the switch expression as an index into a
    table of addresses; each address points at the target case’s code to execute.
    Consider the following example:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用*间接跳转表*来实现更快的`switch`语句。该实现将`switch`表达式作为索引，指向一个地址表；每个地址指向要执行的目标`case`的代码。考虑以下示例：
- en: '[PRE62]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: To begin with, a `switch` statement requires that you create an array of pointers
    with each element containing the address of a statement label in your code (those
    labels must be attached to the sequence of instructions to execute for each case
    in the `switch` statement). In the preceding example, the `JmpTbl` array, initialized
    with the address of the statement labels `Stmt0`, `Stmt1`, and `Stmt2`, serves
    this purpose. I’ve placed this array in the procedure itself because the labels
    are local to the procedure. Note, however, that you must place the array in a
    location that will never be executed as code (such as immediately after a `jmp`
    instruction, as in this example).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`switch`语句要求你创建一个指针数组，每个元素包含代码中一个语句标签的地址（这些标签必须附加到每个`switch`语句中对应`case`的执行指令序列上）。在前面的示例中，初始化了指向语句标签`Stmt0`、`Stmt1`和`Stmt2`地址的`JmpTbl`数组，起到了这个作用。我将这个数组放在了过程内部，因为这些标签是过程的局部标签。不过，请注意，你必须将数组放置在一个永远不会作为代码执行的地方（比如紧跟在`jmp`指令之后，如本例所示）。
- en: The program loads the RAX register with `i`’s value (assuming `i` is a 32-bit
    integer, the `mov` instruction zero-extends EAX into RAX), then uses this value
    as an index into the `JmpTbl` array (RCX holds the base address of the `JmpTbl`
    array) and transfers control to the 8-byte address found at the specified location.
    For example, if RAX contains 0, the `jmp [rcx][rax * 8]` instruction will fetch
    the quad word at address `JmpTbl+0` (RAX × 8 = 0). Because the first quad word
    in the table contains the address of `Stmt0`, the `jmp` instruction transfers
    control to the first instruction following the `Stmt0` label. Likewise, if `i`
    (and therefore, RAX) contains 1, then the indirect `jmp` instruction fetches the
    quad word at offset 8 from the table and transfers control to the first instruction
    following the `Stmt1` label (because the address of `Stmt1` appears at offset
    8 in the table). Finally, if `i` / RAX contains 2, then this code fragment transfers
    control to the statements following the `Stmt2` label because it appears at offset
    16 in the `JmpTbl` table.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将`i`的值加载到RAX寄存器中（假设`i`是32位整数，`mov`指令会将EAX零扩展到RAX），然后使用这个值作为`JmpTbl`数组的索引（RCX保存`JmpTbl`数组的基址），并将控制权转移到指定位置找到的8字节地址。例如，如果RAX包含0，`jmp
    [rcx][rax * 8]`指令将从地址`JmpTbl+0`处取出四字数据（RAX × 8 = 0）。因为表中的第一个四字数据包含了`Stmt0`的地址，所以`jmp`指令将控制权转移到`Stmt0`标签后面的第一条指令。同样，如果`i`（因此RAX）包含1，那么间接的`jmp`指令将从表中偏移量为8的位置取出四字数据，并将控制权转移到`Stmt1`标签后面的第一条指令（因为`Stmt1`的地址出现在表的偏移量8的位置）。最后，如果`i`/RAX包含2，那么这段代码将控制权转移到`Stmt2`标签后面的语句，因为它出现在`JmpTbl`表中的偏移量16处。
- en: As you add more (consecutive) cases, the jump table implementation becomes more
    efficient (in terms of both space and speed) than the `if/elseif` form. Except
    for simple cases, the `switch` statement is almost always faster, and usually
    by a large margin. As long as the `case` values are consecutive, the `switch`
    statement version is usually smaller as well.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 随着更多（连续的）`case`的增加，跳转表的实现比`if/elseif`形式更高效（无论是在空间还是速度上）。除了简单的情况外，`switch`语句几乎总是更快，通常差距较大。只要`case`值是连续的，`switch`语句版本通常也更小。
- en: 7.6.7.4 Noncontiguous Jump Table Entries and Range Limiting
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.7.4 非连续跳转表条目与范围限制
- en: What happens if you need to include nonconsecutive `case` labels or cannot be
    sure that the `switch` value doesn’t go out of range? With the C/C++ `switch`
    statement, such an occurrence will transfer control to the first statement after
    the `switch` statement (or to a `default` case, if one is present in the switch).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要包括不连续的`case`标签，或者不能确定`switch`的值是否超出范围，会发生什么呢？在C/C++的`switch`语句中，这种情况会将控制权转移到`switch`语句后面的第一条语句（或者转移到`default`语句，如果`switch`中有`default`语句的话）。
- en: However, this doesn’t happen in the preceding example. If variable `i` does
    not contain 0, 1, or 2, executing the previous code produces undefined results.
    For example, if `i` contains 5 when you execute the code, the indirect `jmp` instruction
    will fetch the qword at offset 40 (5 × 8) in `JmpTbl` and transfer control to
    that address. Unfortunately, `JmpTbl` doesn’t have six entries, so the program
    will fetch the value of the sixth quad word following `JmpTbl` and use that as
    the target address, which will often crash your program or transfer control to
    an unexpected location.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在前面的示例中并不会发生这种情况。如果变量`i`不包含0、1或2，执行前面的代码会产生未定义的结果。例如，如果`i`的值为5，当你执行代码时，间接的`jmp`指令会获取`JmpTbl`中偏移量40（5
    × 8）处的qword，并将控制转移到该地址。不幸的是，`JmpTbl`没有六个条目，因此程序将获取`JmpTbl`后面第六个quad word的值，并将其用作目标地址，这通常会导致程序崩溃或将控制转移到一个意外的位置。
- en: 'The solution is to place a few instructions before the indirect `jmp` to verify
    that the `switch` selection value is within a reasonable range. In the previous
    example, we’d probably want to verify that `i`’s value is in the range 0 to 2
    before executing the `jmp` instruction. If `i`’s value is outside this range,
    the program should simply jump to the `endcase` label (this corresponds to dropping
    down to the first statement after the entire `switch` statement). The following
    code provides this modification:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在间接`jmp`指令之前放置一些指令，验证`switch`选择值是否在合理范围内。在前面的例子中，我们可能希望在执行`jmp`指令之前验证`i`的值是否在0到2的范围内。如果`i`的值超出这个范围，程序应该直接跳转到`endcase`标签（这对应于跳到整个`switch`语句后的第一条语句）。以下代码提供了这种修改：
- en: '[PRE63]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Although the preceding example handles the problem of selection values being
    outside the range 0 to 2, it still suffers from a couple of severe restrictions:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的示例解决了选择值超出0到2范围的问题，但它仍然有几个严重的限制：
- en: The cases must start with the value 0\. That is, the minimum `case` constant
    has to be 0 in this example.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各case的值必须从0开始。也就是说，在这个示例中，最小的`case`常量必须是0。
- en: The case values must be contiguous.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各case的值必须是连续的。
- en: 'Solving the first problem is easy, and you deal with it in two steps. First,
    you compare the case selection value against a lower and upper bound before determining
    if the case value is legal. For example:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 解决第一个问题很简单，可以分两步来处理。首先，在确定case值是否合法之前，你需要将case选择值与下限和上限进行比较。例如：
- en: '[PRE64]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This code adds a pair of extra instructions, `cmp` and `jb`, to test the selection
    value to ensure it is in the range 5 to 7\. If not, control drops down to the
    `EndCase` label; otherwise, control transfers via the indirect `jmp` instruction.
    Unfortunately, as the comments point out, this code is broken.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码添加了一对额外的指令`cmp`和`jb`，用于测试选择值是否在5到7的范围内。如果不在此范围，控制将跳转到`EndCase`标签；否则，控制将通过间接的`jmp`指令转移。不幸的是，正如注释所指出的，这段代码是有问题的。
- en: 'Consider what happens if variable `i` contains the value 5: the code will verify
    that 5 is in the range 5 to 7 and then will fetch the dword at offset 40 (5 ×
    8) and jump to that address. As before, however, this loads 8 bytes outside the
    bounds of the table and does not transfer control to a defined location. One solution
    is to subtract the smallest case selection value from EAX before executing the
    `jmp` instruction, as shown in the following example:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 假设变量`i`的值为5：代码会验证5是否在5到7的范围内，然后获取偏移量40（5 × 8）处的dword，并跳转到该地址。然而，像之前一样，这会加载表格边界之外的8个字节，并且不会将控制转移到一个已定义的位置。一种解决方案是在执行`jmp`指令之前，从EAX中减去最小的case选择值，如下例所示：
- en: '[PRE65]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: By subtracting 5 from the value in EAX, we force EAX to take on the value 0,
    1, or 2 prior to the `jmp` instruction. Therefore, case-selection value 5 jumps
    to `Stmt5`, case-selection value 6 transfers control to `Stmt6`, and case-selection
    value 7 jumps to `Stmt7`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从EAX的值中减去5，我们强制EAX在`jmp`指令之前取0、1或2。因此，选择值为5时跳转到`Stmt5`，选择值为6时转移控制到`Stmt6`，选择值为7时跳转到`Stmt7`。
- en: 'To improve this code, you can eliminate the `sub` instruction by merging it
    into the `jmp` instruction’s address expression. The following code does this:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改进这段代码，你可以通过将`sub`指令合并到`jmp`指令的地址表达式中来消除`sub`指令。以下代码实现了这一点：
- en: '[PRE66]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The C/C++ `switch` statement provides a `default` clause that executes if the
    case-selection value doesn’t match any of the case values. For example:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: C/C++的`switch`语句提供了一个`default`子句，当选择的值与任何case值不匹配时会执行。例如：
- en: '[PRE67]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Implementing the equivalent of the `default` clause in pure assembly language
    is easy. Just use a different target label in the `jb` and `ja` instructions at
    the beginning of the code. The following example implements a MASM `switch` statement
    similar to the preceding one:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯汇编语言中实现`default`子句的等价物是很容易的。只需在代码开头的`jb`和`ja`指令中使用不同的目标标签。以下示例实现了类似前面示例的MASM
    `switch`语句：
- en: '[PRE68]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The second restriction noted earlier, (that is, the case values need to be
    contiguous) is easy to handle by inserting extra entries into the jump table.
    Consider the following C/C++ `switch` statement:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的第二个限制（即`case`值需要是连续的）很容易通过在跳转表中插入额外的条目来处理。考虑以下C/C++ `switch`语句：
- en: '[PRE69]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The minimum switch value is 1, and the maximum value is 8\. Therefore, the code
    before the indirect `jmp` instruction needs to compare the value in `i` against
    1 and 8\. If the value is between 1 and 8, it’s still possible that `i` might
    not contain a legal case-selection value. However, because the `jmp` instruction
    indexes into a table of quad words using the case-selection table, the table must
    have eight quad-word entries.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 最小的`switch`值是1，最大值是8。因此，在间接`jmp`指令之前的代码需要将`i`中的值与1和8进行比较。如果值介于1和8之间，仍然可能`i`不包含合法的`case`选择值。然而，由于`jmp`指令使用`case`选择表对四字节表进行索引，表必须有八个四字节条目。
- en: 'To handle the values between 1 and 8 that are not case-selection values, simply
    put the statement label of the `default` clause (or the label specifying the first
    instruction after the `endswitch` if there is no `default` clause) in each of
    the jump table entries that don’t have a corresponding `case` clause. The following
    code demonstrates this technique:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理1到8之间不是`case`选择值的值，只需将`default`子句的语句标签（或者如果没有`default`子句，则指定`endswitch`后第一条指令的标签）放入跳转表中每个没有对应`case`子句的条目中。以下代码演示了这一技术：
- en: '[PRE70]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 7.6.7.5 Sparse Jump Tables
  id: totrans-341
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.7.5 稀疏跳转表
- en: 'The current implementation of the `switch` statement has a problem. If the
    `case` values contain nonconsecutive entries that are widely spaced, the jump
    table could become exceedingly large. The following `switch` statement would generate
    an extremely large code file:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当前`switch`语句的实现存在一个问题。如果`case`值包含不连续的、相隔很远的条目，跳转表可能会变得极其庞大。以下`switch`语句将生成一个非常大的代码文件：
- en: '[PRE71]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In this situation, your program will be much smaller if you implement the `switch`
    statement with a sequence of `if` statements rather than using an indirect jump
    statement. However, keep one thing in mind: the size of the jump table does not
    normally affect the execution speed of the program. If the jump table contains
    two entries or two thousand, the `switch` statement will execute the multiway
    branch in a constant amount of time. The `if` statement implementation requires
    a linearly increasing amount of time for each `case` label appearing in the `case`
    statement.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果你使用一系列`if`语句来实现`switch`语句，而不是使用间接跳转语句，程序的体积将会更小。然而，要记住一点：跳转表的大小通常不会影响程序的执行速度。如果跳转表包含两个条目或两千个条目，`switch`语句将在一个固定的时间内执行多分支操作。`if`语句的实现则要求每个出现在`case`语句中的`case`标签都需要线性增长的时间。
- en: 'Probably the biggest advantage to using assembly language over an HLL like
    Pascal or C/C++ is that you get to choose the actual implementation of statements
    like `switch`. In some instances, you can implement a `switch` statement as a
    sequence of `if/then/elseif` statements, or you can implement it as a jump table,
    or you can use a hybrid of the two:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 使用汇编语言相对于像Pascal或C/C++这样的高级语言（HLL）最大的优势之一是你可以选择诸如`switch`语句的实际实现方式。在某些情况下，你可以将`switch`语句实现为一系列`if/then/elseif`语句，或者将其实现为一个跳转表，或者使用这两者的混合方式：
- en: '[PRE72]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'That could become the following:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以变成如下：
- en: '[PRE73]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If you are willing to live with programs that cannot exceed 2GB in size (and
    use the `LARGEADDRESSAWARE:NO` command line option), you can improve the implementation
    of the `switch` statement and save one instruction:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意接受程序大小不超过2GB（并使用`LARGEADDRESSAWARE:NO`命令行选项），你可以改进`switch`语句的实现，并节省一条指令：
- en: '[PRE74]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This code removed the `lea rcx, JmpTbl` instruction and replaced `jmp [rcx][rax
    * 8 – 5 * 8]` with `jmp JmpTbl[rax * 8 – 5 * 8]`. This is a small improvement,
    but an improvement nonetheless (this sequence not only is one instruction shorter
    but also uses one less register). Of course, constantly be aware of the danger
    of writing 64-bit programs that are not large-address aware.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码移除了`lea rcx, JmpTbl`指令，并将`jmp [rcx][rax * 8 – 5 * 8]`替换为`jmp JmpTbl[rax
    * 8 – 5 * 8]`。这是一个小的改进，但仍然是一个改进（这个序列不仅少了一条指令，还减少了一个寄存器的使用）。当然，始终要注意编写不具备大地址意识的64位程序的危险。
- en: 'Some `switch` statements have sparse cases but with groups of contiguous cases
    within the overall set of cases. Consider the following C/C++ `switch` statement:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 一些`switch`语句具有稀疏的情况，但在整个情况集内有一些连续的情况组。考虑以下的C/C++ `switch`语句：
- en: '[PRE75]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You can convert a `switch` statement that consists of widely separated groups
    of (nearly) contiguous cases to assembly language code using one jump table implementation
    for each contiguous group, and you can then use compare instructions to determine
    which jump table instruction sequence to execute. Here’s one possible implementation
    of the previous C/C++ code:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将一个由广泛分隔的（几乎）连续的情况组组成的`switch`语句转换为汇编语言代码，为每个连续组实现一个跳转表，然后使用比较指令来确定执行哪个跳转表指令序列。下面是前面C/C++代码的一种可能实现：
- en: '[PRE76]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This code sequence combines groups 0 to 2 and 10 to 11 into a single group (requiring
    seven additional jump table entries) in order to save having to write an additional
    jump table sequence.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码序列将组0到2和组10到11合并为一个单一的组（需要七个额外的跳转表条目），以避免写入额外的跳转表序列。
- en: Of course, for a set of cases this simple, it’s probably easier to just use
    compare-and-branch sequences. This example was simplified a bit just to make a
    point.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对于这样一组简单的情况，可能直接使用比较-分支序列更为容易。这个例子被简化了一些，仅仅是为了说明一个观点。
- en: 7.6.7.6 Other switch Statement Alternatives
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.6.7.6 其他`switch`语句替代方案
- en: 'What happens if the cases are too sparse to do anything but compare the expression’s
    value case by case? Is the code doomed to being translated into the equivalent
    of an `if/elseif/else/endif` sequence? Not necessarily. However, before we consider
    other alternatives, it’s important to mention that not all `if/elseif/else/endif`
    sequences are created equal. Look back at the previous example. A straightforward
    implementation might have been something like this:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些情况过于稀疏，除了逐个比较表达式的值外什么都做不了，会发生什么？代码是否注定要被转换成等效的`if/elseif/else/endif`序列？不一定。然而，在我们考虑其他替代方案之前，必须提到并非所有的`if/elseif/else/endif`序列都是一样的。回顾一下前面的例子。一个直接的实现可能是这样的：
- en: '[PRE77]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Instead, the former implementation first tests against the value 100 and branches
    based on the comparison being less than (cases 0 to 11) or greater than (cases
    1000 to 1001), effectively creating a small *binary search* that reduces the number
    of comparisons. It’s hard to see the savings in the HLL code, but in assembly
    code you can count the number of instructions that would be executed in the best
    and worst cases and see an improvement over the standard linear search approach
    of simply comparing the values in the cases in the order they appear in the `switch`
    statement.^([8](#c07-footnote-8))
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，前面的实现首先测试值为100，并根据比较结果（小于时为组0到11，大于时为组1000到1001）进行分支，从而有效地创建了一个小的*二分查找*，减少了比较的次数。在高级语言代码中很难看出节省了多少，但在汇编代码中，你可以计算出在最佳和最差情况下执行的指令数量，并看到比标准线性查找方法（仅仅按照`switch`语句中出现的顺序比较值）有所改进。^([8](#c07-footnote-8))
- en: If your cases are too sparse (no meaningful groups at all), such as the 1, 10,
    100, 1000, 10,000 example given earlier in this chapter, you’re not going to be
    able to (reasonably) implement the `switch` statement by using a jump table. Rather
    than devolving into a straight linear search (which can be slow), a better solution
    is to sort your cases and test them using a binary search.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的情况过于稀疏（完全没有有意义的分组），比如前面章节中给出的1、10、100、1000、10000的例子，你将无法（合理地）使用跳转表来实现`switch`语句。与其直接退化为线性查找（这可能很慢），更好的解决方案是对你的情况进行排序，并使用二分查找来测试它们。
- en: 'With a binary search, you first compare the expression value against the middle
    case value. If it’s less than the middle value, you repeat the search on the first
    half of the list of values; if it’s greater than the middle value, you repeat
    the test on the second half of the values; if it’s equal, obviously you drop into
    the code to handle that test. Here’s the binary search version of the 1, 10, 100,
    . . . example:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二分查找时，你首先将表达式值与中间值进行比较。如果它小于中间值，你将在值列表的前半部分重复查找；如果它大于中间值，你将在值列表的后半部分重复查找；如果它相等，显然你会进入代码处理该测试。以下是1、10、100、……示例的二分查找版本：
- en: '[PRE78]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The techniques presented in this section have many possible alternatives. For
    example, one common solution is to create a table containing a set of records
    (structures), with each record entry a two-tuple containing a case value and a
    jump address. Rather than having a long sequence of compare instructions, a short
    loop can sequence through all the table elements, searching for the case value
    and transferring control to the corresponding jump address if there is a match.
    This scheme is slower than the other techniques in this section but can be much
    shorter than the traditional `if/elseif/else/endif` implementation.^([9](#c07-footnote-9))
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中展示的技术有许多可能的替代方案。例如，一个常见的解决方案是创建一个包含记录（结构体）集合的表，每个记录条目是一个包含案例值和跳转地址的二元组。与其有一长串的比较指令，不如用一个简短的循环遍历所有表元素，寻找匹配的案例值并将控制转移到相应的跳转地址。这个方案比本节中的其他技术慢，但比传统的`if/elseif/else/endif`实现要短得多。^([9](#c07-footnote-9))
- en: 'Note, by the way, that the `defaultCase` label often appears in several `j``cc`
    instructions in a (non-jump-table) `switch` implementation. Since the conditional
    jump instructions have two encodings, a 2-byte form and a 6-byte form, you should
    try to place the `defaultCase` near these conditional jumps so you can use the
    short form of the instruction as much as possible. Although the examples in this
    section have typically put the jump tables (which consume a large number of bytes)
    immediately after their corresponding indirect jump, you could move these tables
    elsewhere in the procedure to help keep the conditional jump instructions short.
    Here’s the earlier 1, 10, 100, . . . example coded with this in mind:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，`defaultCase`标签通常出现在（非跳转表）`switch`实现中的多个`j``cc`指令中。由于条件跳转指令有两种编码形式：一种是2字节格式，另一种是6字节格式，因此你应该尽量将`defaultCase`放置在这些条件跳转附近，以便尽可能使用短格式的指令。尽管本节中的示例通常将跳转表（它们消耗大量字节）紧跟在相应的间接跳转之后，但你可以将这些表移到程序的其他位置，以帮助保持条件跳转指令的简短。以下是考虑到这一点的早期1、10、100、……示例的代码：
- en: '[PRE79]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 7.7 State Machines and Indirect Jumps
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7 状态机与间接跳转
- en: Another control structure commonly found in assembly language programs is the
    *state machine*. A state machine uses a *state variable* to control program flow.
    The FORTRAN programming language provides this capability with the assigned `goto`
    statement. Certain variants of C (for example, GNU’s GCC from the Free Software
    Foundation) provide similar features. In assembly language, the indirect jump
    can implement state machines.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种在汇编语言程序中常见的控制结构是*状态机*。状态机使用*状态变量*来控制程序流程。FORTRAN编程语言通过分配的`goto`语句提供了这一功能。C语言的某些变种（例如，GNU的自由软件基金会的GCC）也提供了类似的功能。在汇编语言中，间接跳转可以实现状态机。
- en: So what is a state machine? In basic terms, it is a piece of code that keeps
    track of its execution history by entering and leaving certain *states*. For the
    purposes of this chapter, we’ll just assume that a state machine is a piece of
    code that (somehow) remembers the history of its execution (its *state*) and executes
    sections of code based on that history.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么是状态机呢？简单来说，它是一段代码，通过进入和离开特定的*状态*来跟踪其执行历史。为了本章的目的，我们可以假设状态机是一段（某种方式下）记住其执行历史（其*状态*）并根据该历史执行代码段的代码。
- en: In a real sense, all programs are state machines. The CPU registers and values
    in memory constitute the state of that machine. However, we’ll use a much more
    constrained view. Indeed, for most purposes, only a single variable (or the value
    in the RIP register) will denote the current state.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际意义上讲，所有程序都是状态机。CPU寄存器和内存中的值构成了该机器的状态。然而，我们将采用一个更加有限的视角。实际上，对于大多数目的来说，只有一个变量（或RIP寄存器中的值）表示当前状态。
- en: Now let’s consider a concrete example. Suppose you have a procedure and want
    to perform one operation the first time you call it, a different operation the
    second time you call it, yet something else the third time you call it, and then
    something new again on the fourth call. After the fourth call, it repeats these
    four operations in order.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一个具体的例子。假设你有一个过程，并且希望在第一次调用时执行一个操作，第二次调用时执行不同的操作，第三次调用时执行另一个操作，然后在第四次调用时再执行一个新的操作。在第四次调用后，它按顺序重复这四个操作。
- en: For example, suppose you want the procedure to add EAX and EBX the first time,
    subtract them on the second call, multiply them on the third, and divide them
    on the fourth. You could implement this procedure as shown in [Listing 7-6](#listing7-6).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你希望在第一次调用时将 EAX 和 EBX 相加，在第二次调用时将它们相减，在第三次调用时将它们相乘，在第四次调用时将它们相除。你可以按照[Listing
    7-6](#listing7-6)中所示的方式实现这个过程。
- en: '[PRE80]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Listing 7-6: A state machine example'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-6: 一个状态机示例'
- en: 'Here’s the build command and program output:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建命令和程序输出：
- en: '[PRE81]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Technically, this procedure is not the state machine. Instead, the variable
    `state` and the `cmp/jne` instructions constitute the state machine. The procedure
    is little more than a `switch` statement implemented via the `if/then/elseif`
    construct. The only unique thing is that it remembers how many times it has been
    called^([10](#c07-footnote-10)) and behaves differently depending upon the number
    of calls.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，这个过程本身并不是状态机。相反，变量`state`和`cmp/jne`指令构成了状态机。这个过程不过是通过`if/then/elseif`结构实现的一个`switch`语句。唯一不同的是它记住了被调用的次数^([10](#c07-footnote-10))，并根据调用次数表现得不同。
- en: While this is a *correct* implementation of the desired state machine, it is
    not particularly efficient. The astute reader, of course, would recognize that
    this code could be made a little faster using an actual `switch` statement rather
    than the `if/then/elseif/endif` implementation. However, an even better solution
    exists.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个*正确的*状态机实现，但效率并不高。敏锐的读者当然会意识到，通过使用实际的`switch`语句，而不是`if/then/elseif/endif`结构，这段代码可以稍微加速。然而，实际上还有更好的解决方案。
- en: It’s common to use an indirect jump to implement a state machine in assembly
    language. Rather than having a `state` variable that contains a value like 0,
    1, 2, or 3, we could load the `state` variable with the *address* of the code
    to execute upon entry into the procedure. By simply jumping to that address, the
    state machine could save the tests needed to select the proper code fragment.
    Consider the implementation in [Listing 7-7](#listing7-7) using the indirect jump.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，常见的做法是使用间接跳转来实现状态机。我们可以让`state`变量存储要在进入过程时执行的代码的*地址*，而不是包含像 0、1、2 或 3
    这样的值。通过简单地跳转到该地址，状态机可以省去选择适当代码片段所需的测试。请参考[Listing 7-7](#listing7-7)中使用间接跳转的实现。
- en: '[PRE82]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Listing 7-7: A state machine using an indirect jump'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 7-7: 使用间接跳转的状态机'
- en: 'Here’s the build command and program output:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建命令和程序输出：
- en: '[PRE83]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `jmp` instruction at the beginning of the `StateMachine` procedure transfers
    control to the location pointed at by the `state` variable. The first time you
    call `StateMachine`, it points at the `State0` label. Thereafter, each subsection
    of code sets the `state` variable to point at the appropriate successor code.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`StateMachine`过程开始时的`jmp`指令将控制转移到由`state`变量指向的位置。第一次调用`StateMachine`时，它指向`State0`标签。此后，每个代码子段都将`state`变量设置为指向适当的后续代码。'
- en: 7.8 Loops
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8 循环
- en: '*Loops* represent the final basic control structure (sequences, decisions,
    and loops) that make up a typical program. As with so many other structures in
    assembly language, you’ll find yourself using loops in places you’ve never dreamed
    of using loops.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '*循环*表示构成典型程序的最终基本控制结构（顺序、决策和循环）。与汇编语言中的许多其他结构一样，你会发现自己在一些从未想过的地方使用循环。'
- en: Most HLLs have implied loop structures hidden away. For example, consider the
    BASIC statement `if A$ = B$ then 100`. This `if` statement compares two strings
    and jumps to statement 100 if they are equal. In assembly language, you would
    need to write a loop to compare each character in `A$` to the corresponding character
    in `B$` and then jump to statement 100 if and only if all the characters matched.^([11](#c07-footnote-11))
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数高级语言（HLL）都有隐式的循环结构。例如，考虑 BASIC 语句`if A$ = B$ then 100`。该`if`语句比较两个字符串，如果它们相等，则跳转到语句
    100。在汇编语言中，你需要写一个循环，逐个字符地将`A$`中的字符与`B$`中的对应字符进行比较，只有当所有字符匹配时，才跳转到语句 100。^([11](#c07-footnote-11))
- en: 'Program loops consist of three components: an optional *initialization component*,
    an optional *loop-termination test*, and the *body* of the loop. The order in
    which you assemble these components can dramatically affect the loop’s operation.
    Three permutations of these components appear frequently in programs: `while`
    loops, `repeat/until` loops (`do/while` in C/C++), and infinite loops (for example,
    `for(;;)` in C/C++).'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 程序循环由三个组件组成：可选的*初始化组件*、可选的*循环终止测试*和*循环体*。组装这些组件的顺序可以显著影响循环的操作。程序中常见的三种组件排列是：`while`
    循环、`repeat/until` 循环（在 C/C++ 中为 `do/while`）和无限循环（例如 C/C++ 中的 `for(;;)`）。
- en: 7.8.1 while Loops
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.8.1 while 循环
- en: 'The most general loop is the `while` loop. In C/C++, it takes the following
    form:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 最通用的循环是 `while` 循环。在 C/C++ 中，它具有以下形式：
- en: '[PRE84]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In the `while` loop, the termination test appears at the beginning of the loop.
    As a direct consequence of the position of the termination test, the body of the
    loop may never execute if the Boolean expression is always false.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `while` 循环中，终止测试出现在循环开始时。由于终止测试的位置，循环体可能永远不会执行，如果布尔表达式始终为假。
- en: 'Consider the following C/C++ `while` loop:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下 C/C++ `while` 循环：
- en: '[PRE85]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `i = 0;` statement is the initialization code for this loop. `i` is a loop-control
    variable, because it controls the execution of the body of the loop. `i < 100`
    is the loop-termination condition: the loop will not terminate as long as `i`
    is less than 100\. The single statement `++i;` (*increment i*) is the loop body
    that executes on each loop iteration.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`i = 0;` 语句是该循环的初始化代码。`i` 是一个循环控制变量，因为它控制循环体的执行。`i < 100` 是循环终止条件：只要 `i` 小于
    100，循环就不会终止。单一语句 `++i;`（*递增 i*）是循环体，它在每次循环迭代时执行。'
- en: 'A C/C++ `while` loop can be easily synthesized using `if` and `goto` statements.
    For example, you may replace the previous C `while` loop with the following C
    code:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 C/C++ `while` 循环可以通过 `if` 和 `goto` 语句轻松合成。例如，你可以用以下 C 代码替换之前的 C `while` 循环：
- en: '[PRE86]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'More generally, you can construct any `while` loop as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，你可以按照以下方式构建任何 `while` 循环：
- en: '[PRE87]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Therefore, you can use the techniques from earlier in this chapter to convert
    `if` statements to assembly language and add a single `jmp` instruction to produce
    a `while` loop. The example in this section translates to the following pure x86-64
    assembly code:^([12](#c07-footnote-12))
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以使用本章前面的技术将 `if` 语句转换为汇编语言，并添加一个 `jmp` 指令来生成 `while` 循环。本节中的示例翻译为以下纯 x86-64
    汇编代码：^([12](#c07-footnote-12))
- en: '[PRE88]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 7.8.2 repeat/until Loops
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.8.2 repeat/until 循环
- en: 'The `repeat/until` (`do/while`) loop tests for the termination condition at
    the end of the loop rather than at the beginning. In Pascal, the `repeat/until`
    loop takes the following form:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`repeat/until`（`do/while`）循环在循环结束时测试终止条件，而不是在循环开始时。在 Pascal 中，`repeat/until`
    循环具有以下形式：'
- en: '[PRE89]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This is comparable to the following C/C++ `do/while` loop:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这与以下 C/C++ `do/while` 循环类似：
- en: '[PRE90]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This sequence executes the initialization code, then executes the loop body,
    and finally tests a condition to see whether the loop should repeat. If the Boolean
    expression evaluates to false, the loop repeats; otherwise, the loop terminates.
    The two things you should note about the `repeat/until` loop are that the termination
    test appears at the end of the loop and, as a direct consequence, the loop body
    always executes at least once.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 该序列首先执行初始化代码，然后执行循环体，最后测试一个条件来判断是否需要重复循环。如果布尔表达式为假，则循环重复；否则，循环终止。你需要注意 `repeat/until`
    循环的两点：终止测试出现在循环的末尾，并且因此，循环体总是至少执行一次。
- en: 'Like the `while` loop, the `repeat/until` loop can be synthesized with an `if`
    statement and a `jmp`. You could use the following:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `while` 循环一样，`repeat/until` 循环也可以通过 `if` 语句和 `jmp` 指令合成。你可以使用以下代码：
- en: '[PRE91]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Based on the material presented in the previous sections, you can easily synthesize
    `repeat/until` loops in assembly language. The following is a simple example:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面章节中介绍的内容，你可以轻松地在汇编语言中合成 `repeat/until` 循环。以下是一个简单的示例：
- en: '[PRE92]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 7.8.3 forever/endfor Loops
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.8.3 forever/endfor 循环
- en: 'If `while` loops test for termination at the beginning of the loop and `repeat/until/do/while`
    loops check for termination at the end of the loop, the only place left to test
    for termination is in the middle of the loop. The C/C++ high-level `for(;;)` loop,
    combined with the `break` statement, provides this capability. The C/C++ infinite
    loop takes the following form:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'There is no explicit termination condition. Unless otherwise provided, the
    `for(;;)` construct forms an infinite loop. A `break` statement usually handles
    loop termination. Consider the following C++ code that employs a `for(;;)` construct:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Converting a `for`(ever) loop to pure assembly language is easy. All you need
    is a label and a `jmp` instruction. The `break` statement in this example is also
    nothing more than a `jmp` instruction (or conditional jump). The pure assembly
    language version of the preceding code looks something like the following:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 7.8.4 for Loops
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The standard `for` loop is a special form of the `while` loop that repeats the
    loop body a specific number of times (this is known as a *definite* loop). In
    C/C++, the `for` loop takes the form
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'which is equivalent to the following:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Traditionally, programs use the `for` loop to process arrays and other objects
    accessed in sequential order. We normally initialize a loop-control variable with
    the initialization statement and then use the loop-control variable as an index
    into the array (or other data type). For example:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'To convert this to pure assembly language, begin by translating the `for` loop
    into an equivalent `while` loop:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Now, using the techniques from “while Loops” on page 433, translate the code
    into pure assembly language:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 7.8.5 The break and continue Statements
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C/C++ `break` and `continue` statements both translate into a single `jmp`
    instruction. The `break` instruction exits the loop that immediately contains
    the `break` statement; the `continue` statement restarts the loop that contains
    the `continue` statement.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: To convert a `break` statement to pure assembly language, just emit a `goto/jmp`
    instruction that transfers control to the first statement following the `end`
    of the loop to exit. You can do this by placing a label after the loop body and
    jumping to that label. The following code fragments demonstrate this technique
    for the various loops.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: In pure assembly language, convert the appropriate control structures to assembly
    and replace the `goto` with a `jmp` instruction.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: The `continue` statement is slightly more complex than the `break` statement.
    The implementation is still a single `jmp` instruction; however, the target label
    doesn’t wind up going in the same spot for each of the different loops. Figures
    7-2, 7-3, 7-4, and 7-5 show where the `continue` statement transfers control for
    each of the loops.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '![f07002](image_fi/501089c07/f07002.png)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-2: `continue` destination for the `for(;;)` loop'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: '![f07003](image_fi/501089c07/f07003.png)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-3: `continue` destination and the `while` loop'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '![f07004](image_fi/501089c07/f07004.png)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-4: `continue` destination and the `for` loop'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '![f07005](image_fi/501089c07/f07005.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-5: `continue` destination and the `repeat``/``until` loop'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code fragments demonstrate how to convert the `continue` statement
    into an appropriate `jmp` instruction for each of these loop types:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '**`for(;;)/continue/endfor`**'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '**`while/continue/endwhile`**'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '**`for/continue/endfor`**'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '**`repeat/continue/until`**'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 7.8.6 Register Usage and Loops
  id: totrans-454
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Given that the x86-64 accesses registers more efficiently than memory locations,
    registers are the ideal spot to place loop-control variables (especially for small
    loops). However, registers are a limited resource; there are only 16 general-purpose
    registers (and some, such as RSP and RBP, are reserved for special purposes).
    Compared with memory, you cannot place much data in the registers, despite them
    being more efficient to use than memory.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: 'Loops present a special challenge for registers. Registers are perfect for
    loop-control variables because they’re efficient to manipulate and can serve as
    indexes into arrays and other data structures (a common use for loop-control variables).
    However, the limited availability of registers often creates problems when using
    registers in this fashion. Consider the following code that will not work properly
    because it attempts to reuse a register (CX) that is already in use (leading to
    the corruption of the outer loop’s loop-control variable):'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The intent here, of course, was to create a set of nested loops; that is, one
    loop inside another. The inner loop (`loop2`) should repeat four times for each
    of the eight executions of the outer loop (`loop1`). Unfortunately, both loops
    use the same register as a loop-control variable. Therefore, this will form an
    infinite loop. Because CX is always 0 upon encountering the second `dec` instruction,
    control will always transfer to the `loop1` label (because decrementing 0 produces
    a nonzero result). The solution here is to save and restore the CX register or
    to use a different register in place of CX for the outer loop:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Register corruption is one of the primary sources of bugs in loops in assembly
    language programs, so always keep an eye out for this problem.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: 7.9 Loop Performance Improvements
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because loops are the primary source of performance problems within a program,
    they are the place to look when attempting to speed up your software. While a
    treatise on how to write efficient programs is beyond the scope of this chapter,
    you should be aware of the following concepts when designing loops in your programs.
    They’re all aimed at removing unnecessary instructions from your loops in order
    to reduce the time it takes to execute a single iteration of the loop.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: 7.9.1 Moving the Termination Condition to the End of a Loop
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following flow graphs for the three types of loops presented earlier:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'As you can see, the `repeat/until` loop is the simplest of the bunch. This
    is reflected in the assembly language implementation of these loops. Consider
    the following `repeat/until` and `while` loops that are semantically identical:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`repeat/until`循环是其中最简单的。这在这些循环的汇编语言实现中得到了体现。考虑以下语义上完全相同的`repeat/until`和`while`循环：
- en: '[PRE109]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Testing for the termination condition at the end of the loop allows us to remove
    a `jmp` instruction from the loop, which can be significant if the loop is nested
    inside other loops. Given the definition of the loop, you can easily see that
    the loop will execute exactly 20 times, which suggests that the conversion to
    a `repeat/until` loop is trivial and always possible.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环末尾测试终止条件可以让我们从循环中移除`jmp`指令，这在循环嵌套在其他循环中时尤为重要。根据循环的定义，你可以很容易地看到该循环将执行恰好20次，这表明转换为`repeat/until`循环是微不足道的并且总是可行的。
- en: 'Unfortunately, it’s not always quite this easy. Consider the following C code:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，情况并不总是这么简单。考虑以下C代码：
- en: '[PRE110]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'In this particular example, we haven’t the slightest idea what ESI contains
    upon entry into the loop. Therefore, we cannot assume that the loop body will
    execute at least once. So, we must test for loop termination before executing
    the body of the loop. The test can be placed at the end of the loop with the inclusion
    of a single `jmp` instruction:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，我们在进入循环时完全不知道ESI寄存器包含什么。因此，我们不能假设循环体至少会执行一次。所以，在执行循环体之前，我们必须测试循环终止条件。可以在循环末尾通过加入一个`jmp`指令来进行测试：
- en: '[PRE111]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Although the code is as long as the original `while` loop, the `jmp` instruction
    executes only once rather than on each repetition of the loop. However, the slight
    gain in efficiency is obtained via a slight loss in readability (so be sure to
    comment it). The second code sequence is closer to spaghetti code than the original
    implementation. Such is often the price of a small performance gain. Therefore,
    you should carefully analyze your code to ensure that the performance boost is
    worth the loss of clarity.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管代码与原始的`while`循环一样长，但`jmp`指令只执行一次，而不是在每次循环重复时执行。然而，这种效率的轻微提升是通过轻微的可读性损失来实现的（因此一定要加上注释）。第二段代码比原始实现更接近“意大利面条代码”。这种小小的性能提升常常以牺牲清晰度为代价。因此，你应该仔细分析代码，确保性能提升值得放弃清晰度。
- en: 7.9.2 Executing the Loop Backward
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.9.2 执行反向循环
- en: 'Because of the nature of the flags on the x86-64, loops that repeat from some
    number down to (or up to) 0 are more efficient than loops that execute from 0
    to another value. Compare the following C/C++ `for` loop and the comparable assembly
    language code:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 由于x86-64的标志位特性，从某个数值递减到（或递增到）0的循环比从0到另一个值的循环效率更高。比较以下C/C++的`for`循环与相应的汇编语言代码：
- en: '[PRE112]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Now consider another loop that also has eight iterations but runs its loop-control
    variable from 8 down to 1 rather than 1 up to 8, thereby saving a comparison on
    each repetition of the loop:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑另一个循环，它也有八次迭代，但它将循环控制变量从8递减到1，而不是从1递增到8，从而节省了每次循环重复时的比较操作：
- en: '[PRE113]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Saving the execution time of the `cmp` instruction on each iteration of the
    loop may result in faster code. Unfortunately, you cannot force all loops to run
    backward. However, with a little effort and some coercion, you should be able
    to write many `for` loops so that they operate backward.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 节省每次迭代中`cmp`指令的执行时间可能会使代码运行更快。不幸的是，你无法强制所有循环都反向运行。然而，通过一些努力和技巧，你应该能够编写许多`for`循环，使它们反向操作。
- en: 'The preceding example worked out well because the loop ran from 8 down to 1\.
    The loop terminated when the loop-control variable became 0\. What happens if
    you need to execute the loop when the loop-control variable goes to 0? For example,
    suppose that the preceding loop needed to range from 7 down to 0\. As long as
    the lower bound is non-negative, you can substitute the `jns` instruction in place
    of the `jnz` instruction in the earlier code:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 上述例子之所以有效，是因为循环从8递减到1。当循环控制变量变为0时，循环终止。如果你需要在循环控制变量变为0时执行循环会发生什么？例如，假设前面的循环需要从7递减到0。只要下限是非负的，你可以将早期代码中的`jnz`指令替换为`jns`指令：
- en: '[PRE114]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: This loop will repeat eight times, with `j` taking on the values 7 to 0\. When
    it decrements 0 to –1, it sets the sign flag and the loop terminates.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 该循环将重复八次，`j`的值从7递减到0。当它将0递减到-1时，它会设置标志位并终止循环。
- en: Keep in mind that some values may look positive but are actually negative. If
    the loop-control variable is a byte, values in the range 128 to 255 are negative
    in the two’s complement system. Therefore, initializing the loop-control variable
    with any 8-bit value in the range 129 to 255 (or, of course, 0) terminates the
    loop after a single execution. This can get you into trouble if you’re not careful.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: 7.9.3 Using Loop-Invariant Computations
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *loop-invariant computation* is a calculation that appears within a loop
    that always yields the same result. You needn’t do such computations inside the
    loop. You can compute them outside the loop and reference the value of the computations
    inside the loop. The following C code demonstrates an invariant computation:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Because `j` never changes throughout the execution of this loop, the subexpression
    `j - 2` can be computed outside the loop:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Although we’ve eliminated a single instruction by computing the subexpression
    `j - 2` outside the loop, there is still an invariant component to this calculation:
    adding `j - 2` to `i` *n* times. Because this invariant component executes *n*
    times in the loop, we can translate the previous code to the following:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'This translates to the following assembly code:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: For this particular loop, you can actually compute the result without using
    a loop at all (a formula corresponds to the preceding iterative calculation).
    Still, this simple example demonstrates how to eliminate loop-invariant calculations
    from a loop.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: 7.9.4 Unraveling Loops
  id: totrans-494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For small loops—those whose body is only a few statements—the overhead required
    to process a loop may constitute a significant percentage of the total processing
    time. For example, look at the following Pascal code and its associated x86-64
    assembly language code:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Four instructions execute on each repetition of the loop. Only one instruction
    is doing the desired operation (moving a 0 into an element of `A). The remaining
    three instructions control the loop. Therefore, it takes 16 instructions to do
    the operation logically required by 4.`
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
