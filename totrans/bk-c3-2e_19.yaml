- en: '**19**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**THE FUTURE OF CSS**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this final chapter, we’ll look at some more experimental CSS3 features. As
    you’ll see, these features range from ones that greatly extend your ability to
    lay out pages (to rival those of printed magazines) to ones that bring you powerful
    methods and functions found in other programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: I must state up front that these features have limited implementation and, as
    I write this, are defined in modules that have yet to complete the W3C recommendation
    cycle; these two facts mean that the future of the features in this chapter is
    uncertain. Because these features are in such a state of flux, I’ll discuss each
    briefly, without the level of detail used throughout the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: '**Shapes**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One limitation of CSS is that all elements are rectangular. Even if you use
    rounded corners or clip an element (as discussed in [Chapter 18](ch18.html#ch18)),
    the underlying box is still rectangular. So, for example, content floated around
    a rounded or clipped element will follow the rectangular outline of the element’s
    bounding box, as you can see in [Figure 19-1](ch19.html#ch19fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f19-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-1: Although the element here has rounded corners, content floated
    around it follows its rectangular bounding box.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The CSS Shapes Module (*[http://www.w3.org/TR/css-shapes/](http://www.w3.org/TR/css-shapes/)*)
    addresses this problem by allowing you to apply geometrical shapes to elements,
    so inline content can flow around the outline of these shapes, rather than the
    original bounding box. The `shape-outside` property defines the shape to be applied
    to an element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `*shape-function*` value can be any of the functions allowed on the `clip-shape`
    property (introduced in “[Clipping](ch18.html#ch18leve1sec253)” on [page 235](ch18.html#page_235)):
    `inset()`, `circle()`, `ellipse()`, or `polygon()`. For example, this code creates
    a circle with a radius of 100px and a center at the top left of the element it’s
    applied to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: When this element is floated, any inline content around it wraps around the
    outline of the circle, as shown in [Figure 19-2](ch19.html#ch19fig2).
  prefs: []
  type: TYPE_NORMAL
- en: Note the shape applies only to the element’s float outline; the background color,
    images, and borders will still respect the element’s box. As you can see in [Figure
    19-3](ch19.html#ch19fig3), I’ve removed the `border-radius` value from the floated
    element, and the text overlaps the element’s box. To avoid this problem, you could
    consider using a clip path (see “Clipping” on [page 235](ch18.html#page_235))
    that matches the defined shape.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f19-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-2: An element with a CSS Shape applied. Content flows around the
    defined circular outline rather than the bounding box.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f19-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-3: Without a matching* `*border-radius*` *value, floated text overlaps
    the background color of the shaped element.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create extra space between the edge of the float shape and the content flowing
    around it, you can use the `shape-margin` property. This property accepts any
    length value. For example, this code adds an extra 0.5em around the shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that, unlike the `margin` property, you can only add a single margin value
    that applies evenly to all sides of the shape.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exclusions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of this writing, in order to have content flow around an element you must
    make the element float. The drawback is that an element can only be floated to
    the left or right; you can neither position it in the middle of text nor do you
    have much fine control.
  prefs: []
  type: TYPE_NORMAL
- en: The CSS Exclusions Module (*[http://www.w3.org/TR/css3-exclusions/](http://www.w3.org/TR/css3-exclusions/)*)
    addresses this problem. CSS Exclusions defines a way to flow text around any element,
    regardless of whether the element itself is floated. [Figure 19-4](ch19.html#ch19fig4)
    shows an element positioned over some text. In the example on the left, the element
    doesn’t interact with the text, but on the right, it acts as an *exclusion element*—it
    behaves as if it was floated, and the text flows around it on both sides.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f19-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-4: On the left, an element is positioned above text; on the right,
    a floating exclusion element has text flowing around it.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You create an exclusion element with the `wrap-flow` property, which accepts
    a single keyword value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `*flow-direction*` keyword sets the sides of the element around which any
    inline content flows. You can control the flow with one of several values; each
    of these is shown in [Figure 19-5](ch19.html#ch19fig5):'
  prefs: []
  type: TYPE_NORMAL
- en: • The `clear` value means content will not flow around either side of the exclusion
    element (A).
  prefs: []
  type: TYPE_NORMAL
- en: • The `both` value flows inline content around both sides (B).
  prefs: []
  type: TYPE_NORMAL
- en: • The `start` value means inline content flows around the left side of the element
    (if the writing direction of the document or element is left-to-right), leaving
    the right side empty (C).
  prefs: []
  type: TYPE_NORMAL
- en: '• The `end` value does the opposite of `start`: Inline content flows around
    the right side of the element, leaving the left side empty (D).'
  prefs: []
  type: TYPE_NORMAL
- en: The `minimum` and `maximum` keywords flow content around the side of an element
    with either the lesser or greater (respectively) distance between the side and
    the nearest side of its containing element. Using the examples in [Figure 19-5](ch19.html#ch19fig5),
    `maximum` would be equivalent to `start` (C) and `minimum` to `end` (D).
  prefs: []
  type: TYPE_NORMAL
- en: The default keyword value is `auto`, which means no exclusion will be created—the
    content flows beneath the element, as shown on the left in [Figure 19-4](ch19.html#ch19fig4).
  prefs: []
  type: TYPE_NORMAL
- en: As I write this, Internet Explorer 10 and 11 support CSS Exclusions, using the
    `-ms-wrap-flow` property and without the `minimum` keyword value.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f19-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-5: Content flows around an exclusion element based on the use of
    various keyword values.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Regions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Chapter 7](ch07.html#ch07) explained CSS columns, the method of flowing content
    across multiple sequential columns. The CSS Regions Module (*[http://dev.w3.org/csswg/css-regions/](http://dev.w3.org/csswg/css-regions/)*)
    extends this idea, allowing content to flow into multiple regions, which aren’t
    required to be consecutive in layout order, and regardless of their position on
    the page. Think of a long magazine article that continues across multiple, though
    not necessarily sequential, pages.'
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS Regions makes this possible by defining an area of content and assigning
    it a unique identifier, known as a *named flow*, with the `flow-into` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this identifier has been assigned, the content of element `*E*` can flow
    into multiple regions. To do this, use the named flow as the value of the `flow-from`
    property; for example, if you wanted to flow the contents of `*foo*` into the
    elements `*F*` and `*G*`, this is the code you’d use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The content of `*E*` flows into `*F*` first because it’s listed first in the
    code. If the content overflows `*F*`, the overflow goes into `*G.*` [Figure 19-6](ch19.html#ch19fig6)
    shows content flowed into three independent areas. (I’ve added background shading
    to make each area easier to identify.)
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](graphics/f19-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 19-6: Text flows into the first box, overflows into the second box,
    and then overflows into the third.*'
  prefs: []
  type: TYPE_NORMAL
- en: The elements `*F*` and `*G*` can be placed anywhere on the page; they do not
    need to be contiguous (though you should, of course, make it easy for the user
    to follow the visual flow of the content).
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing CSS Regions is implemented in Safari 6.1 and above, using
    the `-webkit-` prefix. CSS Regions is also in Internet Explorer 10 and 11, using
    the `-ms-` prefix and with the added proviso that the element from which the content
    flows must be an `iframe`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Variables**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Almost every programming language can define *variables*—symbolic names to which
    you can assign values and that can be referenced or updated later. Part of the
    reason for the wild popularity of CSS preprocessors such as Sass is that they
    allow the use of variables in CSS. This popularity has led directly to the creation
    of *custom properties*—a limited variable-like feature in the native CSS language.
    These are introduced in the CSS Custom Properties for Cascading Variables Module
    (*[http://www.w3.org/TR/css-variables-1/](http://www.w3.org/TR/css-variables-1/)*).
  prefs: []
  type: TYPE_NORMAL
- en: 'You define a custom property in three steps: by setting its *scope* (the range
    of values to which it can be applied), creating a unique identifier, and then
    assigning that identifier a value. Here’s how that looks in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Leaving aside ➊ for now, look at ➋, where I’ve defined the custom property using
    the unique identifier `*--fooColor*`. (CSS variable names must be a string of
    characters with no spaces and prefixed with a double hyphen to avoid conflict
    with other defined values.) I’ve assigned the color value `#f00` to the custom
    property, but any valid CSS property value is permitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the custom property has been defined and given a value, you can use it
    as the value of any other property. The value assigned to the custom property
    is used as the value of the property that refers to it by using the unique identifier
    as an argument in the `var()` function. For example, to call this value on a `border-color`
    and `color`, you write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the value of the custom property `*--fooColor*` (namely `#f00`) will
    be used as the value of the `border-color` and `color` properties of `*E*`. Of
    course, the value of the custom property must be valid when applied to the property
    that refers to it: there would be no point in using a color value for the `width`
    property. If you do use an invalid custom property in a rule, the rule will be
    ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s return to ➊ in the code shown earlier. This line sets the scope
    of the variable. In my example, the scope is the `:root` selector, which means
    the variable has *global scope* that can be applied to any element, regardless
    of its position in the DOM. If you prefer the custom property only be valid when
    applied to a subset of elements, you can limit this scope. For the custom property
    to be valid only when applied to `h1` elements, for example, you set its scope
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Having restricted the scope in this way, a reference to the custom property
    from any `h1` selector displays it with the `color` value `#f00`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'But if you refer to the custom property from an element outside the scope,
    like an `h2`, the custom property is unknown, so the following rule will be ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As of this writing, custom properties are available in Firefox 31 and above
    and are implemented in Chrome behind a flag, but they may not be enabled as there
    are certain performance concerns. As such, custom properties face an uncertain
    future.
  prefs: []
  type: TYPE_NORMAL
- en: '**Feature Queries**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Media queries, introduced in [Chapter 2](ch02.html#ch02), have transformed
    our ability to make sites work responsively across many different screen sizes
    and resolutions. Their power is partly due to their logical simplicity: If the
    conditions of the query are met, the rules defined within the query’s declaration
    block are applied. This idea is developed further in the CSS Conditional Rules
    Module (*[http://www.w3.org/TR/css3-conditional/](http://www.w3.org/TR/css3-conditional/)*),
    which extends queries not only to use conditions based on device/UA properties
    such as dimension and resolution, but also to allow the definition of CSS rules
    that only apply if a particular CSS feature is supported.'
  prefs: []
  type: TYPE_NORMAL
- en: These new conditional rules, known as *feature queries*, are defined with the
    new `@supports` rule. The `@supports` syntax is similar to `@media`, except it
    requires a CSS property-value pair (or pairs) as an argument. If the browser supports
    the property-value pair, the defined rules are applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to test if a browser supports Flexbox, the conditions of the test
    are that it recognizes the `display` property with a value of `flex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In a modern browser that has implemented Flexbox (and `@supports`, of course),
    the property-value pair is recognized, and the rules in the curly brackets are
    applied. Older browsers without Flexbox support won’t recognize that combination
    of property and value and will skip the rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with media queries, you can use logical operators—`and`, `or`, and `not`—with
    feature queries. For example, to see if a browser supports both Flexbox and Transitions,
    you use `and`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If a property has multiple implementations using vendor prefixes and you want
    to test that the browser has any one of those implementations, you use `or`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'And to see if a browser doesn’t support a particular property, you use `not`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As of this writing, the `@supports` rule is implemented in Chrome and Firefox
    and listed as “In Development” for Internet Explorer. Webkit has implemented it
    experimentally, but as of this writing it is not listed for release in Safari
    8\. In these browsers, rules inside the `@supports` declaration block will be
    ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '**Device Adaptation**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One critical part of implementing responsive design with media queries is the
    ability to set viewport properties, using the viewport meta tag (see “[Device
    Width and Height](ch02.html#ch02leve1sec18)” on [page 15](ch02.html#page_15)).
    Unfortunately, the viewport meta tag is not without its problems—not least of
    which is that the initial implementation was undocumented, meaning other browser
    vendors had to reverse-engineer it, leading to small interoperability issues.
    The CSS Device Adaptation Module (*[http://www.w3.org/TR/css-device-adapt/](http://www.w3.org/TR/css-device-adapt/)*)
    attempts to address these interoperability problems by translating the viewport
    meta tag properties into native CSS, and documenting and standardizing features
    as well as adding new ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Device Adaptation Module reimplements the viewport meta tag with a new
    at-rule, `@viewport`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `@viewport` rule accepts numerous property-value pairs or *viewport descriptors*,
    which set the parameters of the viewport. Some of these descriptors are existing
    CSS properties, whereas others are unique to `@viewport`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In many cases, these descriptors are not the same as the arguments used in
    the viewport meta tag, but they perform the same role. For example, to set the
    width equal to the device width in the meta tag, you write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To perform the same operation with the `@viewport` rule, you use the `width`
    property, with a value of `100vw`—the full viewport width (the vw unit was discussed
    in [Chapter 16](ch16.html#ch16)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The best part of the `@viewport` rule is you can combine it with media queries,
    creating custom viewports for different device configurations. For example, you
    can set the width equal to the device width only on small screens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As of this writing, the `@viewport` rule is implemented in Internet Explorer
    10 and 11 as the `@-ms-viewport` rule. It’s also implemented in Chrome, although
    not currently enabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sticky Positioning**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A fairly common web design pattern is to make elements *sticky* so they stick
    to the top or bottom of the viewport as the page is scrolled. Stickiness has usually
    been accomplished by setting the `fixed` value on the `position` property using
    scroll events in JavaScript, but CSS3’s Positioned Layout Module (*[http://dev.w3.org/csswg/css-position-3/](http://dev.w3.org/csswg/css-position-3/)*)
    introduces a native `sticky` value for the `position` property to do the same
    thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sticky positioning is a kind of hybrid of relative and fixed positioning. An
    element’s position is relative until it reaches a *sticky threshold* value, which
    is a preset scroll position of the viewport. For example, in the following listing,
    element `*E*` becomes sticky when the viewport scrolls down 20px from the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As of this writing, sticky positioning is in Safari from 6.1, with the value
    `-webkit-sticky`, and unprefixed in Firefox. Chrome is expected to implement sticky
    positioning, and it is listed as “Under Consideration” in Internet Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: '**And Much, Much More**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CSS is a living standard, undergoing constant development, whether driven by
    the W3C, browser vendors, interested parties like Adobe, or the web development
    community. In addition to the new features discussed in this chapter, many more
    exciting CSS developments are being proposed, debated, and developed. Some of
    these include, but are not limited to, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: • The ability to set different shapes for corners and allow clipped or partial
    lines for borders
  prefs: []
  type: TYPE_NORMAL
- en: • The ability to apply the position keywords from Flexbox ([Chapter 15](ch15.html#ch15))
    to any element, causing big changes in the way elements are positioned
  prefs: []
  type: TYPE_NORMAL
- en: • Color functions that allow colors to be tinted or shaded easily and that provide
    easier grayscale manipulation
  prefs: []
  type: TYPE_NORMAL
- en: • Extending the idea of custom properties to include custom selectors or functions
  prefs: []
  type: TYPE_NORMAL
- en: • Grids based on lines of text, which are designed to allow better placement
    of elements in content with a vertical rhythm
  prefs: []
  type: TYPE_NORMAL
- en: • Image values including sprites and fallbacks, and ones that can use elements
    as backgrounds
  prefs: []
  type: TYPE_NORMAL
- en: These features are mostly still at the theoretical stage, but they should give
    you some insight into the level of thinking that’s going into the future of CSS.
    And such is the rapid rate of change in the web industry, that within a few months
    of reading this, doubtless many more novelties will have been proposed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CSS is clearly evolving. From its humble beginnings as a way to provide simple
    decoration to text documents, CSS is moving toward a future where it becomes almost
    a language in itself, capable of adapting to the many devices that we will use
    to access the Web in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve learned in my years of working with and writing and talking about CSS
    that change comes from unexpected directions. Certain seemingly useful modules
    or properties will remain unimplemented for many reasons—whether because of business
    decisions, resources, or just plain politics. And change is driven by different
    sources: from the W3C and browser vendors to companies like Adobe that want to
    shape the web in their own image to the development community that builds tools
    to meet the demands of web development. You just never know where the next big
    shift will come from.'
  prefs: []
  type: TYPE_NORMAL
- en: I haven’t covered everything in the CSS3 modules in this book, but I hope I’ve
    covered enough to at least make you curious about some of the new technologies
    you can start using today, as well as what lies on the horizon for CSS. I urge
    you to stay connected to the conversation that surrounds styling elements for
    the Web, to download preview releases of browsers, to create your own experiments,
    and to let the browser makers and the W3C know the results of your experiments.
    CSS3 has (mostly) been molded around the desires of web developers, and your opinions
    and feedback are vital.
  prefs: []
  type: TYPE_NORMAL
- en: '**Future CSS: Browser Support**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '|  | **Chrome** | **Firefox** | **Safari** | **IE** |'
  prefs: []
  type: TYPE_TB
- en: '| Shapes | Yes | No | Safari 8^([*](ch19.html#footnote45a)) | No |'
  prefs: []
  type: TYPE_TB
- en: '| Exclusions | No | No | No | IE10^([†](ch19.html#footnote46a)) |'
  prefs: []
  type: TYPE_TB
- en: '| Regions | No | No | Yes[*](ch19.html#footnote45a) | IE10^([‡](ch19.html#footnote47a))
    |'
  prefs: []
  type: TYPE_TB
- en: '| Variables | No | Yes | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| Feature queries | Yes | Yes | No | No^([§](ch19.html#footnote48a)) |'
  prefs: []
  type: TYPE_TB
- en: '| Device adaptation | No^([&#124;&#124;](ch19.html#footnote49a)) | No | No
    | IE10^([†](ch19.html#footnote46a)) |'
  prefs: []
  type: TYPE_TB
- en: '| Sticky positioning | No | Yes | Yes[*](ch19.html#footnote45a) | No |'
  prefs: []
  type: TYPE_TB
- en: '[*](ch19.html#footnote_45a) With vendor prefix'
  prefs: []
  type: TYPE_NORMAL
- en: '[†](ch19.html#footnote_46a) With vendor prefix; no support for minimum value'
  prefs: []
  type: TYPE_NORMAL
- en: '[‡](ch19.html#footnote_47a) With vendor prefix; only an iframe can be used
    as the content source'
  prefs: []
  type: TYPE_NORMAL
- en: '[§](ch19.html#footnote_48a) Currently listed as “in development”'
  prefs: []
  type: TYPE_NORMAL
- en: '[||](ch19.html#footnote_49a) Implemented, but disabled by default'
  prefs: []
  type: TYPE_NORMAL
