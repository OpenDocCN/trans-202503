- en: '## **6'
  prefs: []
  type: TYPE_NORMAL
- en: MEMORY AND CLOCK SIGNALS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the previous chapters we saw how digital logic gates can be combined to
    produce useful combinational logic circuits where the output is a function of
    the inputs. In this chapter, we look at sequential logic circuits. These circuits
    have memory, the ability to store a record of the past. We cover some specific
    kinds of memory devices: latches and flip-flops. We also learn about clock signals,
    which are a way to synchronize multiple circuit components.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sequential Logic Circuits and Memory**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s now examine a type of digital circuit known as a *sequential logic circuit*.
    A sequential logic circuit’s output depends not only on its present set of inputs,
    but also on past inputs to the circuit. In other words, a sequential logic circuit
    has some knowledge of its own previous history or state. Digital devices store
    a record of past state in what is known as *memory*, a component that allows for
    storage and retrieval of binary data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a simple example of sequential logic: a coin-operated vending
    machine. A vending machine has at least two inputs: a coin slot and a vend button.
    For simplicity, let’s assume that the vending machine only vends one type of item
    and that item costs one coin. The vend button doesn’t do anything unless a coin
    has been inserted. If the vending machine were based on *combinational logic*,
    where the state is determined by present inputs only, then a coin would have to
    be inserted at the same instant that the vend button is pressed.'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, that’s not how vending machines work! They have memory that tracks
    whether a coin has been inserted. When we press the vend button, the sequential
    logic in the vending machine checks its memory to see if a coin was previously
    inserted. If so, the machine dispenses an item. We’ll build on this sequential
    logic example later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sequential logic is possible because of memory. Memory stores binary data,
    and its capacity for storage is measured in bits or bytes. Modern computing devices
    such as smartphones usually have at least 1GB of memory. That’s over 8 billion
    bits! Let’s begin with something a little simpler: a memory device with 1 bit
    of memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The SR Latch**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A *latch* is a type of memory device that remembers one bit. The *SR latch*
    has two inputs: S (for set) and R (for reset), and an output called Q, the single
    bit that’s “remembered.” When S is set to 1, output Q becomes 1 too. When S goes
    to 0, Q remains equal to 1, because the latch remembers this previous input. This
    is the essence of memory—the component remembers a previous input, even if that
    input changes. When R is set to 1, this is an indicator to reset/clear the memory
    bit, so output Q becomes 0\. Q will remain 0 even if R goes back to 0.'
  prefs: []
  type: TYPE_NORMAL
- en: We summarize the behavior of an SR latch in [Table 6-1](ch06.xhtml#ch6tab1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-1:** Operation of an SR Latch'
  prefs: []
  type: TYPE_NORMAL
- en: '| **S** | **R** | **Q (output)** | **Operation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | Maintain previous value | Hold |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | 0 | Reset |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | 1 | Set |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | X | Invalid |'
  prefs: []
  type: TYPE_TB
- en: By design, setting S to 1 and R to 1 at the same time is an invalid input, and
    the value of Q in this scenario is undefined. In practice, attempting this causes
    Q to go to 1 or 0, but we can’t reliably say which. Besides, it doesn’t make sense
    to try to set and reset the latch at the same time. The circuit diagram symbol
    for an SR latch is shown in [Figure 6-1](ch06.xhtml#ch6fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-1: The circuit diagram symbol for an SR latch*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 6-1](ch06.xhtml#ch6fig1) there’s an additional output: Q. Read this
    as “complement of Q,” “NOT Q,” or “inversion of Q.” It’s simply the opposite of
    Q. When Q is 1, Q is 0, and vice-versa. It can be useful to have both Q and Q
    available, and as you’ll see, the design of such a circuit lends itself to including
    this output without extra effort.'
  prefs: []
  type: TYPE_NORMAL
- en: We can implement an SR latch fairly simply using only two NOR gates and some
    wires. That said, understanding how the design works takes some thought. Consider
    the circuit shown in [Figure 6-2](ch06.xhtml#ch6fig2), which is an implementation
    of an SR latch.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-2: SR latch implemented with cross-coupled NOR gates*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 6-2](ch06.xhtml#ch6fig2), we have two NOR gates in what is known
    as a *cross-coupled configuration*. As a reminder, a NOR gate only outputs a 1
    if both inputs are 0; otherwise, it outputs a 0\. The output from N1 feeds into
    N2’s input, and the output from N2 feeds into N1’s input. The inputs are S and
    R. The outputs are Q and Q. Let’s examine how the circuit works by activating
    and clearing various inputs, examining the outputs as we go. Assume that initially
    S is 0, and R is 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-3: SR latch, initial state*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initial state (S = 0, R = 1)**'
  prefs: []
  type: TYPE_NORMAL
- en: R = 1, so the output of N2 is 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The output of N2 is fed into N1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: S = 0, so the output of N1 is 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initially Q = 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Summary: when R goes high, the output goes low (see [Figure 6-3](ch06.xhtml#ch6fig3)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-4: SR latch, inputs low*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Next, clear all inputs (S = 0, R = 0)**'
  prefs: []
  type: TYPE_NORMAL
- en: R goes to 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The other input to N2 is still 1, so the output of N2 is still 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Therefore, Q still equals 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Summary: the circuit remembered the previous output state (see [Figure 6-4](ch06.xhtml#ch6fig4)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-5: SR latch, S goes high*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Next, activate the S input (S = 1, R = 0)**'
  prefs: []
  type: TYPE_NORMAL
- en: S goes to 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This causes the output of N1 to go to 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The inputs to N2 are now 0 and 0, so the output of N2 is 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Therefore, Q now equals 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Summary: setting S high causes the output to go high (see [Figure 6-5](ch06.xhtml#ch6fig5)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-6: SR latch, S goes low*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Finally, clear all inputs again (S = 0, R = 0)**'
  prefs: []
  type: TYPE_NORMAL
- en: S goes to 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The other input to N1 is still 1, so the output of N1 is still 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The inputs to N2 are unchanged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Therefore, Q still equals 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Summary: the circuit remembered the previous output state (see [Figure 6-6](ch06.xhtml#ch6fig6)).'
  prefs: []
  type: TYPE_NORMAL
- en: Putting all of that together, we’ve just described the desired behavior of an
    SR latch, as previously summarized in [Table 6-1](ch06.xhtml#ch6tab1). When S
    (set) is 1, the output, Q, goes to 1 and stays at 1 even when S goes back to 0\.
    When R (reset) is 1, the output, Q, goes to 0 and stays at 0 even when R goes
    back to 0\. In this way, the circuit remembers either a 1 or 0, so we have a device
    with 1 bit of memory! Even though there are two outputs (Q and Q), both are just
    different representations of the same saved bit. Remember, setting both S = 1
    and R = 1 at the same time is an invalid input.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the behavior of the SR latch, we’ve looked at how the circuit
    behaves when the inputs are held high and then set low. However, S and R typically
    just need to be “pulsed.” When the circuit is at rest, both S and R are low. When
    we want to change its state, we have no reason to hold S or R high for long; we
    just need to quickly set it high and then back to low—a simple pulse of the input.
  prefs: []
  type: TYPE_NORMAL
- en: '**UNIVERSAL LOGIC GATES**'
  prefs: []
  type: TYPE_NORMAL
- en: We just demonstrated how an SR latch can be constructed with NOR gates. In fact,
    NOR gates can be used to create any other logic circuit, not just the SR latch.
    The NOR gate is known as a *universal logic gate*; it can be used to implement
    any logical function. The same is true of NAND.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve investigated the internal design of an SR latch, we can optionally
    go back to using the symbol in [Figure 6-1](ch06.xhtml#ch6fig1) to represent an
    SR latch. When we do this, we no longer need to concern ourselves with the internals
    of a latch. This is another example of encapsulation! We take a design and put
    it in a “black box,” which makes it easier to use that design without worrying
    about the internal details. I find it helpful to think of the SR latch in simple
    terms: it’s a 1-bit memory device that has a state Q of either 1 or 0\. The S
    input sets Q to 1, and the R input resets Q to 0.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Please see [Project #6](ch06.xhtml#proj6) on [page 104](ch06.xhtml#page_104),
    where you can build an SR latch*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the SR Latch in a Circuit**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have a basic memory device, the SR latch, let’s use it in an example
    circuit. Let’s return to our vending machine example and design a vending machine
    circuit that uses a latch. The circuit has the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The circuit has two inputs: a COIN button and a VEND button. Pressing COIN
    represents inserting a coin. Pressing VEND causes the machine to vend an item
    (the circuit will just turn on an LED to represent vending an item).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The circuit has two LED outputs: COIN LED and VEND LED. COIN LED lights when
    a coin has been inserted. VEND LED lights to indicate that an item is being vended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The machine won’t vend an item unless a coin has been first inserted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For simplicity, assume only one coin can be inserted. Inserting additional coins
    does not change the state of the circuit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normally after a vending operation occurs, we’d expect the circuit to reset
    itself and go back to the “no coin” state. However, for simplicity of design,
    we’ll skip the automatic reset in favor of a manual reset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At a conceptual level, our vending circuit will be implemented as shown in [Figure
    6-7](ch06.xhtml#ch6fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-7: Conceptual vending machine circuit with manual reset*'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through [Figure 6-7](ch06.xhtml#ch6fig7). When you press the COIN
    button, the COIN memory device (an SR latch) stores the fact that a coin was inserted.
    The memory device then outputs a 1, indicating that a coin has been inserted,
    and the COIN LED lights up. When you press the VEND button, if a coin was previously
    inserted, the AND gate outputs 1, and the VEND LED lights. On the other hand,
    if you press the VEND button without previously inserting a coin, nothing happens.
    To clear the COIN LED and reset the device, you must manually set the Reset input
    to 1.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Please see [Project #7](ch06.xhtml#proj7) on [page 105](ch06.xhtml#page_105),
    where you can build the vending machine circuit just described*.'
  prefs: []
  type: TYPE_NORMAL
- en: This basic vending machine circuit demonstrates a practical use of memory in
    a circuit. Since our circuit design includes a memory element, the VEND button
    can behave differently based on whether a coin was inserted in the past. However,
    once the COIN bit is set in memory, it stays set until the circuit is manually
    reset. That’s not ideal, so let’s update our circuit so that it resets automatically
    after a vend operation occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Once the machine vends an item, we expect the COIN bit to be set back to 0,
    since the action of vending “uses” the coin. In other words, vending should also
    cause the coin memory to reset. To implement this logic, we can connect the output
    of the AND gate to the memory reset, as shown in [Figure 6-8](ch06.xhtml#ch6fig8).
    That way, when the VEND LED turns on, the COIN memory resets.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-8: Conceptual vending machine circuit with automatic reset*'
  prefs: []
  type: TYPE_NORMAL
- en: The system shown in [Figure 6-8](ch06.xhtml#ch6fig8) will reset the circuit
    during vending, but there’s a problem with this design. Can you spot it? The problem
    may not be obvious. If you completed the last project, you may want to try this
    type of reset on the circuit you just built. Connect a wire from the output of
    the AND gate to the R input in the SR latch, press COIN, then press VEND. Spoilers
    ahead, so don’t read on until you’ve given this a try, either mentally or on a
    breadboard!
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that although the reset works as expected, it happens so quickly
    that the VEND LED immediately turns off, or more likely, the VEND LED never comes
    on. Here we have an example of a design that technically works but works so quickly
    that the user of the device can’t see what happened. This is a fairly common problem
    in user interface design. The devices and programs we build often operate so quickly
    that we must deliberately slow things down a bit so that the user can keep up.
    In this case, a solution would be to introduce a delay on the reset line so that
    the VEND LED has time to light up for a second or two before the reset occurs.
    This is shown in [Figure 6-9](ch06.xhtml#ch6fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-9: Conceptual vending machine circuit with automatic delayed reset*'
  prefs: []
  type: TYPE_NORMAL
- en: How can we go about adding a delay? One approach is to use a capacitor. A *capacitor*
    is an electrical component that stores energy. It has two terminals. When current
    flows to the capacitor, the capacitor charges. The measure of a capacitor’s ability
    to store electric charge is called *capacitance*, which is measured in *farads*.
    One farad is a very large value, so we typically rate capacitors in *microfarads*,
    abbreviated *μF*.
  prefs: []
  type: TYPE_NORMAL
- en: When the capacitor is not charged, it acts like a short circuit. Once the capacitor
    is charged, it acts like an open circuit. The time it takes to charge or discharge
    a capacitor is controlled by the capacitor’s capacitance value and resistance
    in the circuit. Larger capacitance and resistance values result in a capacitor
    taking longer to charge. So we can use a capacitor and resistor to introduce a
    delay in our circuit caused by the time it takes the capacitor to charge.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Please see [Project #8](ch06.xhtml#proj8) on [page 107](ch06.xhtml#page_107),
    where you can add a delayed reset to your vending machine circuit*.'
  prefs: []
  type: TYPE_NORMAL
- en: So far in this chapter we’ve restricted our exploration of memory to single-bit
    devices. Although 1 bit of memory has limited applicability, in [Chapter 7](ch07.xhtml)
    we’ll see how we can use sets of single-bit memory cells together to represent
    larger amounts of data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Clock Signals**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As circuits become more complex, we often need to keep the various elements
    synchronized so that they all change state at the same time. We may have to do
    this for circuits with multiple memory devices, where we’d like to ensure that
    all the stored bits can be set at the same time. This is especially true when
    we need to consider sets of bits together. We can synchronize multiple circuit
    components with a clock signal. A *clock signal*, or just a *clock*, alternates
    its voltage level between high and low. Typically, the signal alternates on a
    regular cadence, where the signal is high half the time and low the other half.
    We call this type of signal a *square wave*. [Figure 6-10](ch06.xhtml#ch6fig10)
    shows a 5V square wave clock signal graphed over time.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-10: A 5V square wave clock signal*'
  prefs: []
  type: TYPE_NORMAL
- en: A single iteration of the voltage rising and falling is a *pulse*. A complete
    oscillation from low to high and back to low (or the reverse) is a *cycle*. We
    measure the *frequency* of the clock signal in cycles per second, or *hertz (Hz)*.
    In [Figure 6-11](ch06.xhtml#ch6fig11), the frequency of the clock signal shown
    is 2Hz, because the signal completes two full oscillations in one second.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-11: A 2Hz clock signal*'
  prefs: []
  type: TYPE_NORMAL
- en: When a circuit uses a clock, all components that need to be synchronized are
    connected to the clock. Each component is designed to allow state changes only
    when a clock pulse occurs. Clock-driven components typically trigger state changes
    on either the rising edge or the falling edge of the pulse. A component that changes
    state on the rising pulse edge is known as *positive edge–triggered*, and a component
    that changes state on the falling pulse edge is known as *negative edge–triggered*.
    [Figure 6-12](ch06.xhtml#ch6fig12) provides an example of a rising and falling
    edge.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-12: Pulse edges illustrated*'
  prefs: []
  type: TYPE_NORMAL
- en: The graphics in this book illustrate pulse edges as vertical lines; this implies
    an instantaneous change from low to high or vice versa. In practice, however,
    it takes time to change states, but for the purposes of our discussion, let’s
    imagine the state change happening instantaneously.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Please see [Project #9](ch06.xhtml#proj9) on [page 109](ch06.xhtml#page_109),
    where you can use your SR latch as a manual clock*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**JK Flip-Flops**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A 1-bit memory device that uses a clock is a *flip-flop*. There’s some overlap
    in usage of the terms *latch* and *flip-flop*, but here we use *latch* to mean
    memory devices without a clock, and *flip-flop* to mean clocked memory devices.
    You may see the terms used interchangeably or with different connotations elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine a specific clocked memory device, the *JK flip-flop*. The JK
    flip-flop is a conceptual extension of the SR latch, so let’s compare the two.
    The SR latch has input S to set the memory bit and input R to reset the memory
    bit; similarly, the JK flip-flop has input J to set and input K to reset. The
    SR latch immediately changes state when S or R is set high, but the JK flip-flop
    only changes state on a clock pulse. The JK flip-flop also adds an additional
    feature: when both J and K are set high, the output toggles a single time from
    low to high or high to low. This is summarized in [Table 6-2](ch06.xhtml#ch6tab2).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-2:** Comparison of SR Latch and JK Flip-Flop'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **SR latch** | **JK flip-flop** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Changes state** | Immediately when S or R goes high | Only on clock pulse
    if J or K are high |'
  prefs: []
  type: TYPE_TB
- en: '| **Set** | S = 1 | J = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **Reset** | R = 1 | K = 1 |'
  prefs: []
  type: TYPE_TB
- en: '| **Toggle** | Not applicable | J = 1 and K = 1 |'
  prefs: []
  type: TYPE_TB
- en: When representing a JK flip-flop in a diagram, the symbols shown in [Figure
    6-13](ch06.xhtml#ch6fig13) can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-13: JK flip-flops, positive edge–triggered (left), negative edge–triggered
    (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-13](ch06.xhtml#ch6fig13) shows two versions of the JK flip-flop.
    The one on the left is positive edge–triggered, meaning it changes state on the
    rising edge of the clock pulse. On the right, we have the symbol for a negative
    edge–triggered JK flip-flop (note the circle on the CLK input); it changes state
    on the falling edge of the clock pulse. The two devices behave identically otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: So a JK flip-flop is a 1-bit memory device that only changes state when it receives
    a clock pulse. It’s quite similar to an SR latch, except that a clock controls
    its state changes, and it has the ability to toggle its value. [Table 6-3](ch06.xhtml#ch6tab3)
    summarizes the behavior of the JK flip-flop.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-3:** Summary of the Functionality of a JK Flip-Flop'
  prefs: []
  type: TYPE_NORMAL
- en: '| **J** | **K** | **Clock** | **Q (output)** | **Operation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | Pulse | Maintain previous value | Hold |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 1 | Pulse | 0 | Reset |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 0 | Pulse | 1 | Set |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 1 | Pulse | Inverse of previous value | Toggle |'
  prefs: []
  type: TYPE_TB
- en: We won’t go through a step-by-step walkthrough of the JK flip-flop as we did
    for the SR latch. Instead, the best way to understand a JK flip-flop is to work
    with one directly.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Please see [Project #10](ch06.xhtml#proj10) on [page 111](ch06.xhtml#page_111),
    where you can go hands-on with a JK flip-flop*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**T Flip-Flops**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connecting J and K and treating them as a single input creates a flip-flop
    that only does one of two things on a clock pulse: it either toggles or maintains
    its value. To see why this is the case, review [Table 6-3](ch06.xhtml#ch6tab3)
    and note the behavior when both J and K are 0 or both J and K are 1\. Connecting
    J and K is a commonly used technique, and a flip-flop that behaves in this way
    is a *T flip-flop*. [Figure 6-14](ch06.xhtml#ch6fig14) shows the symbol for a
    T flip-flop on the right.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-14: A JK flip-flop with J and K connected is known as a T flip-flop*.'
  prefs: []
  type: TYPE_NORMAL
- en: So a T flip-flop simply toggles its value on clock pulse, when T is 1\. [Table
    6-4](ch06.xhtml#ch6tab4) summarizes the behavior of the T flip-flop.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-4:** Summary of the Functionality of a T Flip-Flop'
  prefs: []
  type: TYPE_NORMAL
- en: '| **T** | **Clock** | **Q** | **Operation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Pulse | Maintain previous value | Hold |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Pulse | Inverse of previous value | Toggle |'
  prefs: []
  type: TYPE_TB
- en: '**Using a Clock in a 3-Bit Counter**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To illustrate the use of a clock in a circuit, let’s build a 3-bit counter—a
    circuit that counts from 0 to 7 in binary. This circuit has three memory elements,
    each representing one bit of a 3-bit number. The circuit takes a clock input,
    and when a clock pulse occurs, the 3-bit number increments (increases by 1). Since
    all the bits represent a single number, it’s important that we synchronize their
    state changes with a clock. Let’s use T flip-flops to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: First, see [Table 6-5](ch06.xhtml#ch6tab5) as a review of counting in binary
    using a 3-bit number.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-5:** Counting in Binary with 3 Bits'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Binary** | **Decimal** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 000 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 001 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 010 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 011 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 100 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 101 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 110 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 111 | 7 |'
  prefs: []
  type: TYPE_TB
- en: '[Table 6-5](ch06.xhtml#ch6tab5) presents our 3-bit number as a single value
    on each row. Let’s now assign each of the bits to memory elements labeled Q0,
    Q1, and Q2\. Q0 is the least significant bit and Q2 is the most significant bit,
    as shown in [Table 6-6](ch06.xhtml#ch6tab6).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 6-6:** Counting in Binary, Each Bit Assigned to a Separate Memory Element'
  prefs: []
  type: TYPE_NORMAL
- en: '| **All 3 bits** | **Q2** | **Q1** | **Q0** | **Decimal** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 000 | 0 | 0 | 0 | 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 001 | 0 | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 010 | 0 | 1 | 0 | 2 |'
  prefs: []
  type: TYPE_TB
- en: '| 011 | 0 | 1 | 1 | 3 |'
  prefs: []
  type: TYPE_TB
- en: '| 100 | 1 | 0 | 0 | 4 |'
  prefs: []
  type: TYPE_TB
- en: '| 101 | 1 | 0 | 1 | 5 |'
  prefs: []
  type: TYPE_TB
- en: '| 110 | 1 | 1 | 0 | 6 |'
  prefs: []
  type: TYPE_TB
- en: '| 111 | 1 | 1 | 1 | 7 |'
  prefs: []
  type: TYPE_TB
- en: If we look at the Q columns in [Table 6-6](ch06.xhtml#ch6tab6) individually,
    we can see a pattern emerge. As we count, Q0 toggles every time. Q1 toggles when
    Q0 was previously 1\. Q2 toggles when both Q1 and Q0 were previously 1\. In other
    words, apart from Q0, each bit toggles on the next count when all the preceding
    bits are 1\. T flip-flops are perfect for implementing this counter, since toggling
    is what they do! Let’s look at how we can build a circuit to do this, shown in
    [Figure 6-15](ch06.xhtml#ch6fig15).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-15: A 3-bit counter built from T flip-flops*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 6-15](ch06.xhtml#ch6fig15), all three T flip-flops use the same clock
    signal, so they are synchronized. T0 is connected to 5V, so Q0 toggles every time
    the clock pulses. T1 is connected to Q0, so a clock pulse causes Q1 to toggle
    only when Q0 is high. T2 is connected to Q0 AND Q1, so Q2 only toggles on a clock
    pulse when Q0 and Q1 are both high.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Please see [Project #11](ch06.xhtml#proj11) on [page 113](ch06.xhtml#page_113),
    where you can build your very own 3-bit counter*.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider how we might use such a counter in conjunction with the vending machine
    circuit we designed earlier. Instead of simply tracking whether a coin is inserted
    or not, we can track the count of coins inserted, at least up to seven coins!
    For a vending machine counter to be useful, it also needs to be able to count
    down, since vending an item should decrease the coin count. I won’t cover the
    specifics of how to add a counter to the vending circuit here, but feel free to
    experiment on your own. Designs for counter circuits that count up and down are
    available online, or you can use an up/down counter IC like the 74191.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve constructed a counter from T flip-flops, which was built from JK flip-flops,
    which are digital logic circuits based on transistors! This again demonstrates
    how encapsulation allows us to build complex systems, hiding the details along
    the way.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we covered sequential logic circuits and clock signals. You
    learned that unlike combinational logic circuits, sequential circuits have memory,
    a record of past state. You learned about the SR latch, a simple single-bit memory
    device. We saw how synchronizing multiple circuit components, including memory
    devices, can be accomplished with a clock signal, an electrical signal that alternates
    its voltage level between high and low. A clocked single-bit memory device is
    known as a flip-flop, which allows for state changes to only occur in synchronization
    with the clock signal. You learned how JK flip-flops work, how T flip-flops can
    be constructed from JK flip-flops, and finally how a clock and T flip-flops can
    be used together to create a 3-bit counter.
  prefs: []
  type: TYPE_NORMAL
- en: Memory and clocks are key components of modern computing devices, and in the
    next chapter, we’ll see how they play a role in today’s computers. There you’ll
    learn about computer hardware—memory, processor, and I/O.
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT #6: CONSTRUCT AN SR LATCH USING NOR GATES**'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll build an SR latch on a breadboard. You’ll connect output
    Q to an LED to easily observe the state. You should test setting S and R high
    and low and observe the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this project, you’ll need the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current-limiting resistor to use with your LED (approximately 220Ω)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7402 IC (contains four NOR gates)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5-volt power supply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two 470Ω resistors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two switches or pushbuttons that fit a breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional: An additional 220Ω resistor and another LED'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a reminder, see the sections “Buying Electronic Components” on [page 333](appb.xhtml#page_333)
    and “Powering Digital Circuits” on [page 336](appb.xhtml#page_336) if you need
    help on those topics. Also, review [Project #4](ch04.xhtml#proj4) on [page 68](ch04.xhtml#page_68)
    for a reminder about how to use buttons/switches with pull-down resistors. Connect
    your components as shown in [Figure 6-16](ch06.xhtml#ch6fig16) to build an SR
    latch. Note that the NOR gates are arranged differently within the 7402 IC as
    compared to the layout of gates in other ICs like the 7408 (AND gates) and the
    7432 (OR gates), so be sure to use the right pins for inputs and outputs.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-16: Wiring diagram for an SR latch built from a 7402 IC*'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve constructed the SR latch circuit as shown in [Figure 6-16](ch06.xhtml#ch6fig16),
    connect S and R to buttons (or switches) with pull-down resistors, as shown in
    [Figure 6-17](ch06.xhtml#ch6fig17). This allows you to easily set the value of
    S or R just by pressing a button.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-17: Using buttons and pull-down resistors to control inputs S and
    R*'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have connected your buttons to the SR latch, try setting S or R to
    high or low by pressing and releasing the button. Observe the results. Does Q
    turn on when you press S and stay on even after you release S? Does Q turn off
    when you press R and stay off even after you release R? If you want to also see
    the value of Q, which should always be the opposite of Q, just connect another
    220Ω resistor and another LED to pins 1 and 6 of the IC.
  prefs: []
  type: TYPE_NORMAL
- en: When you initially apply power, the output will be in an unpredictable state.
    That is, the circuit may start up with either Q = 0 or Q = 1\. Or maybe your circuit
    reliably starts up with Q as a certain value. The reason for this unpredictability
    is that this design leads to a *race condition*. If S = 0 and R = 0 when power
    is applied, both N1 and N2 try to output a 1\. One of them does this slightly
    faster (thus, a *race*). If N1 outputs a 1 first, N2 goes low and Q is 0\. If
    N2 outputs a 1 first, N1 goes low and Q is 1\. This can be addressed by holding
    the R button down during startup (to force Q = 0) and then releasing the R button
    after startup.
  prefs: []
  type: TYPE_NORMAL
- en: Keep this circuit around, we’ll use it in the next project.
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT #7: CONSTRUCT A BASIC VENDING MACHINE CIRCUIT**'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll build the vending machine circuit described earlier
    in this chapter. You can reuse your SR latch from the last project as the memory
    unit. Be sure to use current limiting resistors on your LEDs and pull-down resistors
    for your button inputs. Test the circuit to make sure it works as expected. To
    reset the circuit, press the R button on the SR latch.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this project, you’ll need the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The 7402 SR latch on a breadboard you constructed in [Project #6](ch06.xhtml#proj6)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An additional LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An additional current-limiting resistor to use with your LED (approximately
    220Ω)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7408 IC (contains four AND gates)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An additional pushbutton or switch that will fit a breadboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An additional pull-down resistor to use with your button (approximately 470Ω)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a reminder, see the sections “Buying Electronic Components” on [page 333](appb.xhtml#page_333)
    and “Powering Digital Circuits” on [page 336](appb.xhtml#page_336) if you need
    help on these topics.
  prefs: []
  type: TYPE_NORMAL
- en: In the circuit diagram shown in [Figure 6-18](ch06.xhtml#ch6fig18), the IC pin
    numbers are indicated in boxes. Although they are not shown in the diagram, be
    sure to connect both the 7402 and the 7408 chips to 5V and ground (pins 14 and
    7, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-18: Wiring diagram for a basic vending machine circuit*'
  prefs: []
  type: TYPE_NORMAL
- en: The bottom portion of [Figure 6-18](ch06.xhtml#ch6fig18) is the circuit you
    built in the previous project. The only difference is that now the S button represents
    the COIN button and the output Q LED now represents the COIN indicator LED. To
    build the full circuit, you only need to add the top portion of the circuit and
    connect the two parts together as shown.
  prefs: []
  type: TYPE_NORMAL
- en: Once your circuit is built, you should see that when you press the COIN button,
    the COIN LED lights. Pressing the VEND button should cause the VEND button to
    light, but only if the COIN LED is already lit. Press the RESET button to reset
    the circuit.
  prefs: []
  type: TYPE_NORMAL
- en: Keep this circuit around, we’ll use it in the next project.
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT #8: ADD A DELAYED RESET TO THE VENDING MACHINE CIRCUIT**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this project, you’ll add a delayed reset to the vending machine circuit
    from [Project #7](ch06.xhtml#proj7). You’ll need the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The vending machine circuit you constructed in [Project #7](ch06.xhtml#proj7)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.7kΩ resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 220μF electrolytic capacitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are multiple types of capacitors; a discussion of the various types is
    outside the scope of this book. For this project, you’ll use an *electrolytic
    capacitor* ([Figure 6-19](ch06.xhtml#ch6fig19)). When connecting your capacitor,
    note that electrolytic capacitors are polarized, meaning one pin is negative and
    one is positive. Look for a negative sign or arrow indicating the negative terminal.
    Sometimes the negative terminal is shorter. In [Figure 6-21](ch06.xhtml#ch6fig21),
    the negative terminal should connect to ground.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-19: An electrolytic capacitor. The shorter pin with a stripe/arrow
    is the negative pin.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-20](ch06.xhtml#ch6fig20) shows circuit diagram symbols for capacitors.
    On the left is the symbol for a nonpolarized capacitor. In the middle and on the
    right are symbols used to represent polarized capacitors. Both polarized symbols
    provide a means of identifying the positive and negative terminals of the capacitor.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-20: Circuit diagram symbols for capacitors*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-21](ch06.xhtml#ch6fig21) shows how you can add the capacitor-based
    delayed reset to the vending machine circuit, replacing the manual reset. Keep
    reading past the figure for more details on how to build this circuit.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-21: Wiring diagram for a vending machine circuit with delayed reset*'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you still have a manual reset switch or button connected to R (pin 5 on
    the 7402 chip), be sure to disconnect it, as its presence will interfere with
    the delayed reset operation. In [Figure 6-21](ch06.xhtml#ch6fig21), note how the
    VEND output of our circuit (pin 3 on the 7408 chip), which goes high when vending
    occurs, is connected to the latch’s reset input through a new delay component.
    This new component consists of a resistor and capacitor that, together, introduce
    a delay of about 1 second to the reset. Let’s walk through what happens here:'
  prefs: []
  type: TYPE_NORMAL
- en: When a vend operation occurs, the output from the 7408 AND gate goes high.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The uncharged capacitor initially acts like a short circuit to ground, and the
    reset R to the latch is kept low, so no reset occurs at first.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since no reset has happened yet, the VEND LED has an opportunity to light.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the VEND button is held down, the AND output stays high, and the capacitor
    begins to charge.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After about 1 second, the capacitor is sufficiently charged and acts like an
    open circuit, effectively removing the connection to ground.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reset input R to the latch goes high, and a reset occurs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A few things to note about this design:'
  prefs: []
  type: TYPE_NORMAL
- en: The VEND button must be held down to give the capacitor time to charge.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The circuit still may start with the COIN LED already on. Just hold VEND to
    reset. This could be addressed with a power-on reset circuit, but that’s outside
    the scope of this project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If adding the reset component causes the entire vending circuit to do nothing,
    the R input is likely stuck at a high voltage. Check the voltage on pin 5 of the
    7402 to see if it is high (anything above 0.8V) when it should be low. If you
    run into this problem, double-check the values of the 4.7kΩ resistor and the 220μF
    capacitor. Also check your wiring; a loose connection or a jumper wire in the
    wrong row can throw things off.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I chose the capacitance and resistance values because they produce a delay of
    about 1 second. You could use other values. However, changing these values runs
    the risk of causing the voltage at the R input to be too high when it should be
    low, as just noted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your completed circuit should look something like the circuit shown in [Figure
    6-22](ch06.xhtml#ch6fig22), although your specific layout will probably vary.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-22: Vending machine circuit with delayed reset on a breadboard*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I recommend that you keep the SR latch part of your circuit intact, as you’ll
    use it again in the following projects. You can remove the other components from
    the board, but keep the portion from [Project #6](ch06.xhtml#proj6). Or you can
    just build another SR latch when you need to.'
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT #9: USING A LATCH AS A MANUAL CLOCK**'
  prefs: []
  type: TYPE_NORMAL
- en: You’re going to need a clock signal for the projects later in the chapter. In
    this project, you’ll configure your previously constructed SR latch as a manual
    clock.
  prefs: []
  type: TYPE_NORMAL
- en: As you learned earlier, a clock input needs to alternate between high voltage
    and low voltage. You could try to implement a clock by moving a wire between ground
    and 5V. That would certainly cause the voltage to alternate, but not in the way
    you want. When you were moving the wire, some of the time the wire wouldn’t be
    connected to anything. During those moments, the voltage on the input clock pin
    would “float,” and you’d get unpredictable behavior in your circuit. That’s not
    a good option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or you could add an oscillator that would automatically generate pulses on
    a regular cadence, say one pulse every second. That’s how clocks typically work
    in the real world. A common IC is designed for this purpose: the 555 timer. However,
    for the upcoming exercises you need to be able to carefully observe state changes
    in your circuits, so what you really need is a *manual* clock, that is, a clock
    that only goes high or low when you tell it to. In a sense, such a manual clock
    isn’t even really a clock, because it won’t alternate states on a regular cadence.
    That said, whether it’s technically a clock or not isn’t terribly relevant—we
    need a device you can use to manually trigger state changes.'
  prefs: []
  type: TYPE_NORMAL
- en: You may be tempted to try using a regular pushbutton and a pull-down resistor
    as a clock, as shown in [Figure 6-23](ch06.xhtml#ch6fig23). After all, pressing
    the button makes the voltage go high, and releasing the button makes the voltage
    go low.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-23: Simple switch with pull-down resistor as a CLK input (this won''t
    work very well)*'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the design in [Figure 6-23](ch06.xhtml#ch6fig23) actually makes
    a very poor manual clock. The problem is that mechanical buttons and switches
    tend to “bounce.” Internally the switch has metal contacts that connect when the
    switch is closed. The act of closing the switch results in an initial connection
    between the contacts, but then the contacts separate and come back together, sometimes
    multiple times, before the switch finally settles into a closed state. The same
    thing happens when the switch is opened, except in reverse. A simple button press
    or flip of a switch results in the voltage jumping high and low multiple times.
    This is called *switch bounce*, illustrated in [Figure 6-24](ch06.xhtml#ch6fig24).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-24: Switch bounce, not what we want in a clock*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Debounce circuits* are hardware options for removing bounce. One such debounce
    circuit is based on an SR latch, which conveniently, you have already constructed!
    If you connect S and R to switches, those inputs to the latch still bounce, but
    the output of the latch (Q) holds its value, as shown in [Figure 6-25](ch06.xhtml#ch6fig25).
    This is an effective way of removing switch bounce.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-25: An SR latch produces a clean output even when its inputs bounce.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use an SR latch as a clock, press S to set the clock signal high, and then
    press R to set the clock signal low. Just don’t press both buttons at the same
    time! You can use the SR latch you constructed in [Project #6](ch06.xhtml#proj6)
    as a clock. If you previously removed the reset button/switch from pin 5 as part
    of [Project #8](ch06.xhtml#proj8), connect it again. The complete SR latch as
    a manual clock should be wired as shown in [Figure 6-26](ch06.xhtml#ch6fig26).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-26: A debounced manual clock created from two buttons/switches and
    an SR latch*'
  prefs: []
  type: TYPE_NORMAL
- en: Press S to set the clock pulse high, and press R to set the clock pulse low.
    Now you have a manual clock you can use in the following projects.
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT #10: TEST A JK FLIP-FLOP**'
  prefs: []
  type: TYPE_NORMAL
- en: Although you could build a JK flip-flop from other gates, it is conveniently
    sold as an integrated circuit, so you can save yourself some trouble. The 7473
    chip contains two negative edge–triggered JK flip-flops. In this project, you’ll
    use this integrated circuit to test the functionality of a single JK flip-flop.
    You’ll try setting J and K either high or low, and then send a clock pulse through
    the circuit. Connect an LED to the output Q to easily see the state change.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this project, you’ll need the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SR latch configured as a clock (discussed in [Project #9](ch06.xhtml#proj9))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7473 IC (contains two JK flip-flops)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LED
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Current-limiting resistor to use with your LED (approximately 220Ω)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a reminder, see “Buying Electronic Components” on [page 333](appb.xhtml#page_333)
    and “Powering Digital Circuits” on [page 336](appb.xhtml#page_336) if you need
    help on those topics. [Figure 6-27](ch06.xhtml#ch6fig27) shows the pinout diagram
    for the 7473 IC.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-27: Pinout for the 7473 IC*'
  prefs: []
  type: TYPE_NORMAL
- en: The 7473 IC contains two JK flip-flops as shown in [Figure 6-27](ch06.xhtml#ch6fig27).
    Note that the voltage and ground connections aren’t in the “usual” locations and
    instead are pins 4 and 11, respectively. Also, note that the CLK (clock) inputs
    are marked with a circle, indicating that this circuit is negative edge–triggered;
    you should expect the state to change when the clock pulse falls. Since you’re
    using an SR latch for your manual clock, this means you’ll see the JK state change
    when you press the SR latch’s R input button.
  prefs: []
  type: TYPE_NORMAL
- en: 'An additional input for each JK flip-flop wasn’t mentioned in the chapter:
    CLR. When this pin is set low, the flip-flop clears the saved bit (Q = 0). CLR
    is asynchronous, meaning it doesn’t wait on the clock pulse. The line shown above
    CLR means it is *active low*, meaning the saved bit is cleared when the input
    is set low. CLR is also sometimes called Reset or R, not to be confused with the
    R input of our SR latch. Connect the JK flip-flop’s CLR input (pin 2) to 5V to
    keep your flip-flop from resetting. For testing a single flip-flop, you can connect
    the chip as shown in [Figure 6-28](ch06.xhtml#ch6fig28).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-28: A simple JK test circuit*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using your previously built SR latch as a clock, connect the SR latch’s output
    Q (pins 3 and 4 on the 7402) to the clock input of the 7473 (pin 1). Now, try
    setting inputs J (pin 14) and K (pin 3) on the 7473 to 5V or ground. You should
    see that doing so has no effect on the JK flip-flop’s output LED until the clock
    transitions from high to low. Reminder: pulse the SR latch clock by first pressing
    S and then pressing R to set the clock signal high and then low. Flip back to
    [Table 6-3](ch06.xhtml#ch6tab3) to see the expected functionality of a JK flip-flop
    and ensure that your circuit works as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep this circuit intact for the next project.
  prefs: []
  type: TYPE_NORMAL
- en: '**PROJECT #11: CONSTRUCT A 3-BIT COUNTER**'
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll build the 3-bit counter described earlier in this chapter.
    Connect the Q outputs to LEDs to easily observe the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this project, you’ll need the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The circuit constructed in [Project #10](ch06.xhtml#proj10) (including the
    manual clock from [Project #9](ch06.xhtml#proj9))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An additional 7473 IC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 7408 IC (contains four AND gates)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 47kΩ resistor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10μF electrolytic capacitor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An additional button or switch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumper wires
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two additional LEDs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two additional current-limiting resistors to use with your LEDs (approximately
    220Ω each)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connect everything as shown in [Figure 6-29](ch06.xhtml#ch6fig29). Pin numbers
    on ICs are shown in boxes.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-29: A 3-bit counter built from T flip-flops, pin numbers shown*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the pin connections shown in [Figure 6-29](ch06.xhtml#ch6fig29),
    be sure to make the following connections:'
  prefs: []
  type: TYPE_NORMAL
- en: Both 7473 ICs need pins 4 and 11 connected to 5V and ground, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The 7408 should have pin 7 connected to ground and pin 14 to 5V.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Q0, Q1, and Q2 should connect to LEDs through 220Ω resistors so you can see
    the bits update.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The manual clock output (pins 3 and 4 on the 7402) should be connected to CLK
    on all three flip-flops (pins 1 and 5 on the first 7473, and pin 1 on the second
    7473).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This circuit starts up in an unpredictable state. You can correct this manually
    by resetting all three flip-flops, but that’s tedious. Instead, add a *power-on
    reset* circuit that ensures the flip-flops all start with their output = 0\. Each
    flip-flop in the 7473 package has a CLR input, which when held low, resets the
    flip-flop, regardless of the state of the clock. You want CLR to go low on startup
    for a brief time and then go high and stay there. This ensures that the counter
    starts at zero when powered on. For good measure, you can also add a COUNTER RESET
    button that manually resets the counter when pressed. This reset capability is
    shown in [Figure 6-30](ch06.xhtml#ch6fig30).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig6-30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-30: Power-on reset circuit for 3-bit binary counter*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When power is initially applied to the circuit shown in [Figure 6-30](ch06.xhtml#ch6fig30),
    the capacitor acts like a short circuit, and CLR is held low, setting the circuit
    to its initial state. Once the capacitor is charged, it acts like an open circuit,
    CLR goes high, and the circuit is ready to use. The COUNTER RESET button or switch,
    when pushed, also causes CLR to go low and reset the circuit. This circuit needs
    to be connected to CLR inputs: pins 2 and 6 on the first 7473 chip, and pin 2
    and the second 7473 chip. In [Project #10](ch06.xhtml#proj10), pin 2 on the first
    7473 was connected to 5V; be sure to disconnect it before you hook up the power-on
    reset circuit. Remember to orient the terminals of your electrolytic capacitor
    correctly—the negative terminal should connect to ground.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the power-on reset in place, the circuit should start with your counter
    at 000\. Sending a clock pulse to the circuit should cause the counter to increment
    by 1 when the clock edge falls. Reminder: pulse the SR latch clock by pressing
    S to set the clock signal high and pressing R to set the clock signal low. Test
    counting from 000 to 111 and ensure the counter works as expected.'
  prefs: []
  type: TYPE_NORMAL
