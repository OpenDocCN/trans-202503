- en: '## **6'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '## **6**'
- en: MEMORY AND CLOCK SIGNALS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存与时钟信号**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: 'In the previous chapters we saw how digital logic gates can be combined to
    produce useful combinational logic circuits where the output is a function of
    the inputs. In this chapter, we look at sequential logic circuits. These circuits
    have memory, the ability to store a record of the past. We cover some specific
    kinds of memory devices: latches and flip-flops. We also learn about clock signals,
    which are a way to synchronize multiple circuit components.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们看到如何将数字逻辑门组合起来，产生有用的组合逻辑电路，其中输出是输入的函数。在本章中，我们将讨论时序逻辑电路。这些电路具有内存，可以存储过去的记录。我们将介绍一些特定类型的内存设备：锁存器和触发器。我们还将了解时钟信号，这是一种同步多个电路组件的方法。
- en: '**Sequential Logic Circuits and Memory**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**时序逻辑电路与内存**'
- en: Let’s now examine a type of digital circuit known as a *sequential logic circuit*.
    A sequential logic circuit’s output depends not only on its present set of inputs,
    but also on past inputs to the circuit. In other words, a sequential logic circuit
    has some knowledge of its own previous history or state. Digital devices store
    a record of past state in what is known as *memory*, a component that allows for
    storage and retrieval of binary data.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来研究一种数字电路，称为*时序逻辑电路*。时序逻辑电路的输出不仅取决于当前的输入集，还取决于电路的过去输入。换句话说，时序逻辑电路对自身的历史或状态有一定的记忆。数字设备通过一种叫做*内存*的组件来存储过去的状态，这个组件允许存储和检索二进制数据。
- en: 'Let’s consider a simple example of sequential logic: a coin-operated vending
    machine. A vending machine has at least two inputs: a coin slot and a vend button.
    For simplicity, let’s assume that the vending machine only vends one type of item
    and that item costs one coin. The vend button doesn’t do anything unless a coin
    has been inserted. If the vending machine were based on *combinational logic*,
    where the state is determined by present inputs only, then a coin would have to
    be inserted at the same instant that the vend button is pressed.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的时序逻辑示例：一个投币式自动售货机。自动售货机至少有两个输入：一个投币口和一个售货按钮。为了简化起见，假设自动售货机只售卖一种商品，并且该商品的价格是一个硬币。售货按钮只有在投币后才会起作用。如果自动售货机是基于*组合逻辑*的，那么状态仅由当前输入决定，那么投币必须在按下售货按钮的同时完成。
- en: Fortunately, that’s not how vending machines work! They have memory that tracks
    whether a coin has been inserted. When we press the vend button, the sequential
    logic in the vending machine checks its memory to see if a coin was previously
    inserted. If so, the machine dispenses an item. We’ll build on this sequential
    logic example later in the chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，自动售货机并不是这样工作的！它们有内存，可以记录是否已插入硬币。当我们按下售货按钮时，自动售货机中的时序逻辑会检查其内存，看是否之前已插入硬币。如果是，机器就会发放商品。我们将在本章后面进一步探讨这个时序逻辑示例。
- en: 'Sequential logic is possible because of memory. Memory stores binary data,
    and its capacity for storage is measured in bits or bytes. Modern computing devices
    such as smartphones usually have at least 1GB of memory. That’s over 8 billion
    bits! Let’s begin with something a little simpler: a memory device with 1 bit
    of memory.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 时序逻辑之所以可能，是因为有了内存。内存存储二进制数据，并且其存储容量以位或字节为单位来衡量。现代计算设备，如智能手机，通常至少有 1GB 的内存。那可是超过
    80 亿位！让我们从一个简单的设备开始：一个只有 1 位内存的存储设备。
- en: '**The SR Latch**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**SR 锁存器**'
- en: 'A *latch* is a type of memory device that remembers one bit. The *SR latch*
    has two inputs: S (for set) and R (for reset), and an output called Q, the single
    bit that’s “remembered.” When S is set to 1, output Q becomes 1 too. When S goes
    to 0, Q remains equal to 1, because the latch remembers this previous input. This
    is the essence of memory—the component remembers a previous input, even if that
    input changes. When R is set to 1, this is an indicator to reset/clear the memory
    bit, so output Q becomes 0\. Q will remain 0 even if R goes back to 0.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*锁存器*是一种记住 1 位的内存设备。*SR 锁存器*有两个输入：S（设定）和 R（复位），以及一个输出 Q，表示“记住”的单个位。当 S 设置为
    1 时，输出 Q 也变为 1。当 S 变为 0 时，Q 保持为 1，因为锁存器记住了这个之前的输入。这就是内存的本质——组件记住了一个先前的输入，即使该输入发生变化。当
    R 设置为 1 时，这是一个复位/清除内存位的指示，因此输出 Q 变为 0。即使 R 返回到 0，Q 也会保持为 0。'
- en: We summarize the behavior of an SR latch in [Table 6-1](ch06.xhtml#ch6tab1).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[表 6-1](ch06.xhtml#ch6tab1)中总结了 SR 锁存器的行为。
- en: '**Table 6-1:** Operation of an SR Latch'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-1：** SR 锁存器的操作'
- en: '| **S** | **R** | **Q (output)** | **Operation** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **S** | **R** | **Q (输出)** | **操作** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | 0 | Maintain previous value | Hold |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 保持先前值 | 保持 |'
- en: '| 0 | 1 | 0 | Reset |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 0 | 重置 |'
- en: '| 1 | 0 | 1 | Set |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 | 设置 |'
- en: '| 1 | 1 | X | Invalid |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | X | 无效 |'
- en: By design, setting S to 1 and R to 1 at the same time is an invalid input, and
    the value of Q in this scenario is undefined. In practice, attempting this causes
    Q to go to 1 or 0, but we can’t reliably say which. Besides, it doesn’t make sense
    to try to set and reset the latch at the same time. The circuit diagram symbol
    for an SR latch is shown in [Figure 6-1](ch06.xhtml#ch6fig1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 根据设计，同时将S和R都设置为1是一个无效输入，在这种情况下Q的值是未定义的。实际上，尝试这样做会导致Q变为1或0，但我们无法可靠地说出是哪一个。而且，试图同时设置和重置触发器是没有意义的。SR触发器的电路符号见[图6-1](ch06.xhtml#ch6fig1)。
- en: '![image](../images/fig6-1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-1.jpg)'
- en: '*Figure 6-1: The circuit diagram symbol for an SR latch*'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-1：SR触发器的电路符号*'
- en: 'In [Figure 6-1](ch06.xhtml#ch6fig1) there’s an additional output: Q. Read this
    as “complement of Q,” “NOT Q,” or “inversion of Q.” It’s simply the opposite of
    Q. When Q is 1, Q is 0, and vice-versa. It can be useful to have both Q and Q
    available, and as you’ll see, the design of such a circuit lends itself to including
    this output without extra effort.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6-1](ch06.xhtml#ch6fig1)中，有一个额外的输出：Q。将其理解为“Q的补码”，“非Q”，或“Q的反转”。它只是Q的相反值。当Q为1时，Q为0，反之亦然。拥有Q和Q两个输出是很有用的，正如你将看到的，这种电路的设计本身就适合包括这个输出，且无需额外努力。
- en: We can implement an SR latch fairly simply using only two NOR gates and some
    wires. That said, understanding how the design works takes some thought. Consider
    the circuit shown in [Figure 6-2](ch06.xhtml#ch6fig2), which is an implementation
    of an SR latch.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过仅使用两个NOR门和一些电线简单实现SR触发器。也就是说，理解设计的工作原理需要一些思考。考虑[图6-2](ch06.xhtml#ch6fig2)所示的电路，它是SR触发器的实现。
- en: '![image](../images/fig6-2.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-2.jpg)'
- en: '*Figure 6-2: SR latch implemented with cross-coupled NOR gates*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-2：通过交叉耦合的NOR门实现的SR触发器*'
- en: In [Figure 6-2](ch06.xhtml#ch6fig2), we have two NOR gates in what is known
    as a *cross-coupled configuration*. As a reminder, a NOR gate only outputs a 1
    if both inputs are 0; otherwise, it outputs a 0\. The output from N1 feeds into
    N2’s input, and the output from N2 feeds into N1’s input. The inputs are S and
    R. The outputs are Q and Q. Let’s examine how the circuit works by activating
    and clearing various inputs, examining the outputs as we go. Assume that initially
    S is 0, and R is 1.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图6-2](ch06.xhtml#ch6fig2)中，我们有两个NOR门，采用的是*交叉耦合配置*。提醒一下，NOR门只有在两个输入都是0时才输出1；否则，它输出0。N1的输出送入N2的输入，而N2的输出送入N1的输入。输入是S和R，输出是Q和Q。让我们通过激活和清除各种输入来检查电路如何工作，并在过程中检查输出。假设最初S为0，R为1。
- en: '![image](../images/fig6-3.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-3.jpg)'
- en: '*Figure 6-3: SR latch, initial state*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-3：SR触发器，初始状态*'
- en: '**Initial state (S = 0, R = 1)**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始状态 (S = 0, R = 1)**'
- en: R = 1, so the output of N2 is 0.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: R = 1，因此N2的输出为0。
- en: The output of N2 is fed into N1.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: N2的输出送入N1。
- en: S = 0, so the output of N1 is 1.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: S = 0，因此N1的输出为1。
- en: Initially Q = 0.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始时，Q = 0。
- en: 'Summary: when R goes high, the output goes low (see [Figure 6-3](ch06.xhtml#ch6fig3)).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 总结：当R变高时，输出变低（见[图6-3](ch06.xhtml#ch6fig3)）。
- en: '![image](../images/fig6-4.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-4.jpg)'
- en: '*Figure 6-4: SR latch, inputs low*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：SR触发器，输入为低*'
- en: '**Next, clear all inputs (S = 0, R = 0)**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**接下来，清除所有输入 (S = 0, R = 0)**'
- en: R goes to 0.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: R变为0。
- en: The other input to N2 is still 1, so the output of N2 is still 0.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: N2的另一个输入仍然是1，因此N2的输出仍然是0。
- en: Therefore, Q still equals 0.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，Q仍然等于0。
- en: 'Summary: the circuit remembered the previous output state (see [Figure 6-4](ch06.xhtml#ch6fig4)).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总结：电路记住了之前的输出状态（见[图6-4](ch06.xhtml#ch6fig4)）。
- en: '![image](../images/fig6-5.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-5.jpg)'
- en: '*Figure 6-5: SR latch, S goes high*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：SR触发器，S变高*'
- en: '**Next, activate the S input (S = 1, R = 0)**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**接下来，激活S输入 (S = 1, R = 0)**'
- en: S goes to 1.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: S变为1。
- en: This causes the output of N1 to go to 0.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这导致N1的输出为0。
- en: The inputs to N2 are now 0 and 0, so the output of N2 is 1.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: N2的输入现在是0和0，因此N2的输出为1。
- en: Therefore, Q now equals 1.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，Q现在等于1。
- en: 'Summary: setting S high causes the output to go high (see [Figure 6-5](ch06.xhtml#ch6fig5)).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 总结：将S设置为高会导致输出为高（见[图6-5](ch06.xhtml#ch6fig5)）。
- en: '![image](../images/fig6-6.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-6.jpg)'
- en: '*Figure 6-6: SR latch, S goes low*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-6：SR触发器，S变低*'
- en: '**Finally, clear all inputs again (S = 0, R = 0)**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**最后，再次清除所有输入 (S = 0, R = 0)**'
- en: S goes to 0.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: S变为0。
- en: The other input to N1 is still 1, so the output of N1 is still 0.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: N1的另一个输入仍然是1，因此N1的输出仍然是0。
- en: The inputs to N2 are unchanged.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: N2的输入没有改变。
- en: Therefore, Q still equals 1.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，Q仍然等于1。
- en: 'Summary: the circuit remembered the previous output state (see [Figure 6-6](ch06.xhtml#ch6fig6)).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 总结：电路记住了之前的输出状态（见[图6-6](ch06.xhtml#ch6fig6)）。
- en: Putting all of that together, we’ve just described the desired behavior of an
    SR latch, as previously summarized in [Table 6-1](ch06.xhtml#ch6tab1). When S
    (set) is 1, the output, Q, goes to 1 and stays at 1 even when S goes back to 0\.
    When R (reset) is 1, the output, Q, goes to 0 and stays at 0 even when R goes
    back to 0\. In this way, the circuit remembers either a 1 or 0, so we have a device
    with 1 bit of memory! Even though there are two outputs (Q and Q), both are just
    different representations of the same saved bit. Remember, setting both S = 1
    and R = 1 at the same time is an invalid input.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些信息整合起来，我们刚刚描述了SR锁存器的预期行为，如[表6-1](ch06.xhtml#ch6tab1)中之前总结的。当S（设置）为1时，输出Q为1，并且即使S返回为0，Q也会保持为1。当R（重置）为1时，输出Q为0，并且即使R返回为0，Q也会保持为0。通过这种方式，电路记住了1或0，因此我们有一个1位内存的设备！尽管有两个输出（Q和Q），它们只是同一存储位的不同表示。记住，同时将S
    = 1和R = 1设置为输入是无效的。
- en: To understand the behavior of the SR latch, we’ve looked at how the circuit
    behaves when the inputs are held high and then set low. However, S and R typically
    just need to be “pulsed.” When the circuit is at rest, both S and R are low. When
    we want to change its state, we have no reason to hold S or R high for long; we
    just need to quickly set it high and then back to low—a simple pulse of the input.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解SR锁存器的行为，我们已经看过了当输入保持为高电平再变为低电平时电路的表现。然而，S和R通常只需要“脉冲”一下。当电路处于静止状态时，S和R都为低电平。当我们想改变其状态时，不需要长时间保持S或R为高电平；我们只需要快速将其设置为高电平，再返回低电平——一个简单的输入脉冲。
- en: '**UNIVERSAL LOGIC GATES**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用逻辑门**'
- en: We just demonstrated how an SR latch can be constructed with NOR gates. In fact,
    NOR gates can be used to create any other logic circuit, not just the SR latch.
    The NOR gate is known as a *universal logic gate*; it can be used to implement
    any logical function. The same is true of NAND.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚展示了如何使用NOR门构建SR锁存器。事实上，NOR门可以用来创建任何其他逻辑电路，而不仅仅是SR锁存器。NOR门被称为*通用逻辑门*；它可以用来实现任何逻辑功能。NAND门也是如此。
- en: 'Now that we’ve investigated the internal design of an SR latch, we can optionally
    go back to using the symbol in [Figure 6-1](ch06.xhtml#ch6fig1) to represent an
    SR latch. When we do this, we no longer need to concern ourselves with the internals
    of a latch. This is another example of encapsulation! We take a design and put
    it in a “black box,” which makes it easier to use that design without worrying
    about the internal details. I find it helpful to think of the SR latch in simple
    terms: it’s a 1-bit memory device that has a state Q of either 1 or 0\. The S
    input sets Q to 1, and the R input resets Q to 0.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经研究了SR锁存器的内部设计，我们可以选择回到使用[图6-1](ch06.xhtml#ch6fig1)中的符号来表示SR锁存器。当我们这样做时，我们不再需要关心锁存器的内部结构。这是封装的另一个例子！我们将一个设计放入“黑盒子”中，这使得使用该设计变得更简单，而无需担心内部细节。我发现将SR锁存器简单地理解为一个1位内存设备是很有帮助的：它有一个Q状态，值为1或0。S输入将Q设置为1，R输入将Q重置为0。
- en: '**NOTE**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #6](ch06.xhtml#proj6) on [page 104](ch06.xhtml#page_104),
    where you can build an SR latch*.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[项目 #6](ch06.xhtml#proj6)（在[第104页](ch06.xhtml#page_104)上），您可以在那里构建一个SR锁存器*。'
- en: '**Using the SR Latch in a Circuit**'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在电路中使用SR锁存器**'
- en: 'Now that we have a basic memory device, the SR latch, let’s use it in an example
    circuit. Let’s return to our vending machine example and design a vending machine
    circuit that uses a latch. The circuit has the following requirements:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个基本的存储设备——SR锁存器，让我们在一个示例电路中使用它。让我们回到自动售货机的例子，设计一个使用锁存器的自动售货机电路。该电路有以下要求：
- en: 'The circuit has two inputs: a COIN button and a VEND button. Pressing COIN
    represents inserting a coin. Pressing VEND causes the machine to vend an item
    (the circuit will just turn on an LED to represent vending an item).'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电路有两个输入：一个COIN按钮和一个VEND按钮。按下COIN表示插入硬币，按下VEND则使机器售出物品（电路将点亮一个LED表示物品正在售出）。
- en: 'The circuit has two LED outputs: COIN LED and VEND LED. COIN LED lights when
    a coin has been inserted. VEND LED lights to indicate that an item is being vended.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电路有两个LED输出：COIN LED和VEND LED。插入硬币时，COIN LED亮起；VEND LED亮起表示物品正在售出。
- en: The machine won’t vend an item unless a coin has been first inserted.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器在插入硬币之前不会售出物品。
- en: For simplicity, assume only one coin can be inserted. Inserting additional coins
    does not change the state of the circuit.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了简单起见，假设每次只能投入一枚硬币。投入额外的硬币不会改变电路的状态。
- en: Normally after a vending operation occurs, we’d expect the circuit to reset
    itself and go back to the “no coin” state. However, for simplicity of design,
    we’ll skip the automatic reset in favor of a manual reset.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，在完成售货操作后，我们期望电路能够重置，并恢复到“无硬币”状态。然而，为了简化设计，我们将跳过自动重置，而采用手动重置。
- en: At a conceptual level, our vending circuit will be implemented as shown in [Figure
    6-7](ch06.xhtml#ch6fig7).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，我们的自动售货机电路将按[图6-7](ch06.xhtml#ch6fig7)所示实现。
- en: '![image](../images/fig6-7.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-7.jpg)'
- en: '*Figure 6-7: Conceptual vending machine circuit with manual reset*'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-7：概念性的自动售货机电路，带手动重置*'
- en: Let’s walk through [Figure 6-7](ch06.xhtml#ch6fig7). When you press the COIN
    button, the COIN memory device (an SR latch) stores the fact that a coin was inserted.
    The memory device then outputs a 1, indicating that a coin has been inserted,
    and the COIN LED lights up. When you press the VEND button, if a coin was previously
    inserted, the AND gate outputs 1, and the VEND LED lights. On the other hand,
    if you press the VEND button without previously inserting a coin, nothing happens.
    To clear the COIN LED and reset the device, you must manually set the Reset input
    to 1.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来一步步解析[图6-7](ch06.xhtml#ch6fig7)。当你按下COIN按钮时，COIN存储器（一个SR触发器）会记录硬币已被投放的事实。然后，存储器输出1，表示硬币已被投放，COIN
    LED亮起。当你按下VEND按钮时，如果之前已经投放了硬币，与门的输出为1，VEND LED亮起。另一方面，如果你在没有投币的情况下按下VEND按钮，什么也不会发生。要清除COIN
    LED并重置设备，你必须手动将Reset输入设置为1。
- en: '**NOTE**'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #7](ch06.xhtml#proj7) on [page 105](ch06.xhtml#page_105),
    where you can build the vending machine circuit just described*.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参阅[项目 #7](ch06.xhtml#proj7)在[第105页](ch06.xhtml#page_105)，您可以在此处构建刚刚描述的自动售货机电路*。'
- en: This basic vending machine circuit demonstrates a practical use of memory in
    a circuit. Since our circuit design includes a memory element, the VEND button
    can behave differently based on whether a coin was inserted in the past. However,
    once the COIN bit is set in memory, it stays set until the circuit is manually
    reset. That’s not ideal, so let’s update our circuit so that it resets automatically
    after a vend operation occurs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本的自动售货机电路展示了在电路中实际使用存储器的应用。由于我们的电路设计包括一个存储元件，因此VEND按钮的行为会根据是否曾投放过硬币而有所不同。然而，一旦COIN位在存储器中被设置，它将一直保持直到电路被手动重置。这并不理想，因此我们将更新电路，使其在售货操作完成后自动重置。
- en: Once the machine vends an item, we expect the COIN bit to be set back to 0,
    since the action of vending “uses” the coin. In other words, vending should also
    cause the coin memory to reset. To implement this logic, we can connect the output
    of the AND gate to the memory reset, as shown in [Figure 6-8](ch06.xhtml#ch6fig8).
    That way, when the VEND LED turns on, the COIN memory resets.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦机器完成售货操作，我们期望COIN位被重置为0，因为售货的行为“消耗”了硬币。换句话说，售货操作也应该导致硬币存储器的重置。为了实现这一逻辑，我们可以将与门的输出连接到存储器重置，如[图6-8](ch06.xhtml#ch6fig8)所示。这样，当VEND
    LED亮起时，COIN存储器会被重置。
- en: '![image](../images/fig6-8.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-8.jpg)'
- en: '*Figure 6-8: Conceptual vending machine circuit with automatic reset*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-8：概念性的自动售货机电路，带自动重置*'
- en: The system shown in [Figure 6-8](ch06.xhtml#ch6fig8) will reset the circuit
    during vending, but there’s a problem with this design. Can you spot it? The problem
    may not be obvious. If you completed the last project, you may want to try this
    type of reset on the circuit you just built. Connect a wire from the output of
    the AND gate to the R input in the SR latch, press COIN, then press VEND. Spoilers
    ahead, so don’t read on until you’ve given this a try, either mentally or on a
    breadboard!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图6-8](ch06.xhtml#ch6fig8)所示的系统将在售货过程中重置电路，但此设计存在一个问题。你能找出来吗？问题可能并不显而易见。如果你完成了上一个项目，可能想在刚刚构建的电路上尝试这种重置方式。将一根电线从与门的输出端连接到SR触发器的R输入端，按下COIN按钮，再按下VEND按钮。以下有剧透，除非你已经在脑中或在面包板上试过，否则请不要继续阅读！
- en: The problem is that although the reset works as expected, it happens so quickly
    that the VEND LED immediately turns off, or more likely, the VEND LED never comes
    on. Here we have an example of a design that technically works but works so quickly
    that the user of the device can’t see what happened. This is a fairly common problem
    in user interface design. The devices and programs we build often operate so quickly
    that we must deliberately slow things down a bit so that the user can keep up.
    In this case, a solution would be to introduce a delay on the reset line so that
    the VEND LED has time to light up for a second or two before the reset occurs.
    This is shown in [Figure 6-9](ch06.xhtml#ch6fig9).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，虽然复位按预期工作，但它发生得非常迅速，以至于VEND LED立即熄灭，或者更可能是，VEND LED根本没有亮起。在这里，我们有一个技术上可行但执行过快的设计例子，以至于设备的用户无法看到发生了什么。这在用户界面设计中是一个相当常见的问题。我们构建的设备和程序通常运行得太快，以至于必须故意减慢一些速度，以便用户能跟得上。在这种情况下，一种解决方案是在线路上引入延迟，使得VEND
    LED能够在复位发生之前点亮一到两秒钟。这在[图6-9](ch06.xhtml#ch6fig9)中展示了出来。
- en: '![image](../images/fig6-9.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-9.jpg)'
- en: '*Figure 6-9: Conceptual vending machine circuit with automatic delayed reset*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-9：概念性自动售货机电路与自动延迟复位*'
- en: How can we go about adding a delay? One approach is to use a capacitor. A *capacitor*
    is an electrical component that stores energy. It has two terminals. When current
    flows to the capacitor, the capacitor charges. The measure of a capacitor’s ability
    to store electric charge is called *capacitance*, which is measured in *farads*.
    One farad is a very large value, so we typically rate capacitors in *microfarads*,
    abbreviated *μF*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何添加延迟呢？一种方法是使用电容器。*电容器*是一种储存能量的电气元件。它有两个端子。当电流流向电容器时，电容器充电。电容器储存电荷的能力叫做*电容*，其单位是*法拉*（farads）。1法拉是一个非常大的数值，所以我们通常用*微法*（μF）来表示电容器的容量。
- en: When the capacitor is not charged, it acts like a short circuit. Once the capacitor
    is charged, it acts like an open circuit. The time it takes to charge or discharge
    a capacitor is controlled by the capacitor’s capacitance value and resistance
    in the circuit. Larger capacitance and resistance values result in a capacitor
    taking longer to charge. So we can use a capacitor and resistor to introduce a
    delay in our circuit caused by the time it takes the capacitor to charge.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当电容器没有充电时，它就像是一个短路。一旦电容器充电，它就像是一个开路。电容器充电或放电的时间由电容器的电容值和电路中的电阻决定。更大的电容和电阻值会导致电容器需要更长时间才能充电。所以我们可以使用电容器和电阻器来引入电路中的延迟，这是由于电容器充电所需的时间。
- en: '**NOTE**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #8](ch06.xhtml#proj8) on [page 107](ch06.xhtml#page_107),
    where you can add a delayed reset to your vending machine circuit*.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[项目 #8](ch06.xhtml#proj8)在[第107页](ch06.xhtml#page_107)，在这里你可以为自动售货机电路添加延迟复位功能*。'
- en: So far in this chapter we’ve restricted our exploration of memory to single-bit
    devices. Although 1 bit of memory has limited applicability, in [Chapter 7](ch07.xhtml)
    we’ll see how we can use sets of single-bit memory cells together to represent
    larger amounts of data.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中我们只探讨了单比特设备的存储。虽然1比特的内存适用性有限，但在[第7章](ch07.xhtml)中，我们将看到如何利用多个单比特内存单元结合起来表示更多的数据。
- en: '**Clock Signals**'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**时钟信号**'
- en: As circuits become more complex, we often need to keep the various elements
    synchronized so that they all change state at the same time. We may have to do
    this for circuits with multiple memory devices, where we’d like to ensure that
    all the stored bits can be set at the same time. This is especially true when
    we need to consider sets of bits together. We can synchronize multiple circuit
    components with a clock signal. A *clock signal*, or just a *clock*, alternates
    its voltage level between high and low. Typically, the signal alternates on a
    regular cadence, where the signal is high half the time and low the other half.
    We call this type of signal a *square wave*. [Figure 6-10](ch06.xhtml#ch6fig10)
    shows a 5V square wave clock signal graphed over time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 随着电路变得更加复杂，我们通常需要保持各种元素同步，以确保它们能同时改变状态。对于具有多个内存设备的电路，我们可能需要确保所有存储的比特可以同时设置。特别是在我们需要一起考虑一组比特时，这一点尤为重要。我们可以用时钟信号来同步多个电路组件。*时钟信号*，简称*时钟*，其电压水平在高低之间交替。通常，信号按照规则的节奏交替，其中信号的一半时间是高电平，另一半时间是低电平。我们称这种类型的信号为*方波*。[图6-10](ch06.xhtml#ch6fig10)展示了一个5V的方波时钟信号在时间上的图像。
- en: '![image](../images/fig6-10.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-10.jpg)'
- en: '*Figure 6-10: A 5V square wave clock signal*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-10：一个5V方波时钟信号*'
- en: A single iteration of the voltage rising and falling is a *pulse*. A complete
    oscillation from low to high and back to low (or the reverse) is a *cycle*. We
    measure the *frequency* of the clock signal in cycles per second, or *hertz (Hz)*.
    In [Figure 6-11](ch06.xhtml#ch6fig11), the frequency of the clock signal shown
    is 2Hz, because the signal completes two full oscillations in one second.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 电压上升和下降的单次迭代叫做一个*脉冲*。从低到高再回到低（或反之）的完整振荡叫做一个*周期*。我们用每秒钟的周期数来衡量时钟信号的*频率*，单位是*赫兹（Hz）*。在[图6-11](ch06.xhtml#ch6fig11)中，显示的时钟信号频率是2Hz，因为该信号在一秒钟内完成了两次完整的振荡。
- en: '![image](../images/fig6-11.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-11.jpg)'
- en: '*Figure 6-11: A 2Hz clock signal*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-11：2Hz时钟信号*'
- en: When a circuit uses a clock, all components that need to be synchronized are
    connected to the clock. Each component is designed to allow state changes only
    when a clock pulse occurs. Clock-driven components typically trigger state changes
    on either the rising edge or the falling edge of the pulse. A component that changes
    state on the rising pulse edge is known as *positive edge–triggered*, and a component
    that changes state on the falling pulse edge is known as *negative edge–triggered*.
    [Figure 6-12](ch06.xhtml#ch6fig12) provides an example of a rising and falling
    edge.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当电路使用时钟时，所有需要同步的组件都连接到时钟。每个组件的设计都允许仅在时钟脉冲发生时才进行状态变化。时钟驱动的组件通常会在脉冲的上升沿或下降沿触发状态变化。一个在上升脉冲边缘变化状态的组件称为*正沿触发*，而一个在下降脉冲边缘变化状态的组件称为*负沿触发*。[图6-12](ch06.xhtml#ch6fig12)提供了一个上升沿和下降沿的例子。
- en: '![image](../images/fig6-12.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-12.jpg)'
- en: '*Figure 6-12: Pulse edges illustrated*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-12：脉冲边缘示意图*'
- en: The graphics in this book illustrate pulse edges as vertical lines; this implies
    an instantaneous change from low to high or vice versa. In practice, however,
    it takes time to change states, but for the purposes of our discussion, let’s
    imagine the state change happening instantaneously.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的图形将脉冲边缘表示为垂直线；这意味着从低到高或反之的瞬时变化。然而，实际上，状态的变化是需要时间的，但为了简化讨论，我们假设状态变化是瞬时发生的。
- en: '**NOTE**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #9](ch06.xhtml#proj9) on [page 109](ch06.xhtml#page_109),
    where you can use your SR latch as a manual clock*.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参阅[项目#9](ch06.xhtml#proj9)在[第109页](ch06.xhtml#page_109)，你可以将你的SR触发器用作手动时钟。*'
- en: '**JK Flip-Flops**'
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**JK触发器**'
- en: A 1-bit memory device that uses a clock is a *flip-flop*. There’s some overlap
    in usage of the terms *latch* and *flip-flop*, but here we use *latch* to mean
    memory devices without a clock, and *flip-flop* to mean clocked memory devices.
    You may see the terms used interchangeably or with different connotations elsewhere.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用时钟的1位存储设备叫做*触发器*。术语*latch*和*触发器*有时会有些重叠，但在这里我们使用*latch*来指没有时钟的存储设备，使用*触发器*来指带时钟的存储设备。你可能会看到这些术语在其他地方互换使用或有不同的含义。
- en: 'Let’s examine a specific clocked memory device, the *JK flip-flop*. The JK
    flip-flop is a conceptual extension of the SR latch, so let’s compare the two.
    The SR latch has input S to set the memory bit and input R to reset the memory
    bit; similarly, the JK flip-flop has input J to set and input K to reset. The
    SR latch immediately changes state when S or R is set high, but the JK flip-flop
    only changes state on a clock pulse. The JK flip-flop also adds an additional
    feature: when both J and K are set high, the output toggles a single time from
    low to high or high to low. This is summarized in [Table 6-2](ch06.xhtml#ch6tab2).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一个特定的时钟记忆设备——*JK触发器*。JK触发器是SR触发器的概念性扩展，因此我们可以将它们进行比较。SR触发器有输入S来设置存储位，输入R来重置存储位；类似地，JK触发器有输入J来设置，输入K来重置。SR触发器在S或R被设为高电平时立即改变状态，而JK触发器只有在时钟脉冲时才会改变状态。JK触发器还增加了一个附加功能：当J和K都设为高电平时，输出会在低到高或高到低之间切换一次。这一点在[表6-2](ch06.xhtml#ch6tab2)中做了总结。
- en: '**Table 6-2:** Comparison of SR Latch and JK Flip-Flop'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**表6-2：** SR触发器与JK触发器的比较'
- en: '|  | **SR latch** | **JK flip-flop** |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|  | **SR触发器** | **JK触发器** |'
- en: '| --- | --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Changes state** | Immediately when S or R goes high | Only on clock pulse
    if J or K are high |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **状态变化** | 当S或R为高时立即改变 | 只有在时钟脉冲时，J或K为高时才改变 |'
- en: '| **Set** | S = 1 | J = 1 |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| **设置** | S = 1 | J = 1 |'
- en: '| **Reset** | R = 1 | K = 1 |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| **重置** | R = 1 | K = 1 |'
- en: '| **Toggle** | Not applicable | J = 1 and K = 1 |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **切换** | 不适用 | J = 1且K = 1 |'
- en: When representing a JK flip-flop in a diagram, the symbols shown in [Figure
    6-13](ch06.xhtml#ch6fig13) can be used.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在图示中表示JK触发器时，可以使用[图6-13](ch06.xhtml#ch6fig13)中的符号。
- en: '![image](../images/fig6-13.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-13.jpg)'
- en: '*Figure 6-13: JK flip-flops, positive edge–triggered (left), negative edge–triggered
    (right)*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-13：JK 翻转触发器，正边缘触发（左），负边缘触发（右）*'
- en: '[Figure 6-13](ch06.xhtml#ch6fig13) shows two versions of the JK flip-flop.
    The one on the left is positive edge–triggered, meaning it changes state on the
    rising edge of the clock pulse. On the right, we have the symbol for a negative
    edge–triggered JK flip-flop (note the circle on the CLK input); it changes state
    on the falling edge of the clock pulse. The two devices behave identically otherwise.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-13](ch06.xhtml#ch6fig13) 显示了两种版本的 JK 翻转触发器。左侧的是正边缘触发式，意味着它在时钟脉冲的上升沿发生状态变化。右侧的是负边缘触发式的
    JK 翻转触发器（注意 CLK 输入上的圆圈）；它在时钟脉冲的下降沿发生状态变化。除此之外，这两个设备的行为完全相同。'
- en: So a JK flip-flop is a 1-bit memory device that only changes state when it receives
    a clock pulse. It’s quite similar to an SR latch, except that a clock controls
    its state changes, and it has the ability to toggle its value. [Table 6-3](ch06.xhtml#ch6tab3)
    summarizes the behavior of the JK flip-flop.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，JK 翻转触发器是一个 1 位存储设备，只有在接收到时钟脉冲时才会改变状态。它与 SR 锁存器非常相似，唯一的区别是它的状态变化由时钟控制，并且能够切换其值。[表
    6-3](ch06.xhtml#ch6tab3) 总结了 JK 翻转触发器的行为。
- en: '**Table 6-3:** Summary of the Functionality of a JK Flip-Flop'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-3：** JK 翻转触发器功能总结'
- en: '| **J** | **K** | **Clock** | **Q (output)** | **Operation** |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| **J** | **K** | **时钟** | **Q（输出）** | **操作** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 0 | 0 | Pulse | Maintain previous value | Hold |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 脉冲 | 保持先前值 | 保持 |'
- en: '| 0 | 1 | Pulse | 0 | Reset |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 脉冲 | 0 | 复位 |'
- en: '| 1 | 0 | Pulse | 1 | Set |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 脉冲 | 1 | 置位 |'
- en: '| 1 | 1 | Pulse | Inverse of previous value | Toggle |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 脉冲 | 上一个值的反向 | 切换 |'
- en: We won’t go through a step-by-step walkthrough of the JK flip-flop as we did
    for the SR latch. Instead, the best way to understand a JK flip-flop is to work
    with one directly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会像在 SR 锁存器中那样逐步讲解 JK 翻转触发器。相反，理解 JK 翻转触发器的最佳方法是直接操作它。
- en: '**NOTE**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Please see [Project #10](ch06.xhtml#proj10) on [page 111](ch06.xhtml#page_111),
    where you can go hands-on with a JK flip-flop*.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[项目 #10](ch06.xhtml#proj10)，该项目位于[第 111 页](ch06.xhtml#page_111)，你可以在其中动手操作
    JK 翻转触发器*。'
- en: '**T Flip-Flops**'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**T 翻转触发器**'
- en: 'Connecting J and K and treating them as a single input creates a flip-flop
    that only does one of two things on a clock pulse: it either toggles or maintains
    its value. To see why this is the case, review [Table 6-3](ch06.xhtml#ch6tab3)
    and note the behavior when both J and K are 0 or both J and K are 1\. Connecting
    J and K is a commonly used technique, and a flip-flop that behaves in this way
    is a *T flip-flop*. [Figure 6-14](ch06.xhtml#ch6fig14) shows the symbol for a
    T flip-flop on the right.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 将 J 和 K 连接并将其视为一个输入，创建一个在时钟脉冲到来时只执行两种操作之一的翻转触发器：它要么切换，要么保持其值。要理解为什么会这样，请查看[表
    6-3](ch06.xhtml#ch6tab3)，并注意当 J 和 K 都为 0 或者都为 1 时的行为。将 J 和 K 连接是一种常用的技术，具有这种行为的翻转触发器叫做
    *T 翻转触发器*。[图 6-14](ch06.xhtml#ch6fig14) 显示了 T 翻转触发器的符号。
- en: '![image](../images/fig6-14.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-14.jpg)'
- en: '*Figure 6-14: A JK flip-flop with J and K connected is known as a T flip-flop*.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-14：J 和 K 连接的 JK 翻转触发器被称为 T 翻转触发器*。'
- en: So a T flip-flop simply toggles its value on clock pulse, when T is 1\. [Table
    6-4](ch06.xhtml#ch6tab4) summarizes the behavior of the T flip-flop.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，T 翻转触发器只会在时钟脉冲时切换其值，当 T 为 1 时。[表 6-4](ch06.xhtml#ch6tab4) 总结了 T 翻转触发器的行为。
- en: '**Table 6-4:** Summary of the Functionality of a T Flip-Flop'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-4：** T 翻转触发器功能总结'
- en: '| **T** | **Clock** | **Q** | **Operation** |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **T** | **时钟** | **Q** | **操作** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 0 | Pulse | Maintain previous value | Hold |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 脉冲 | 保持先前值 | 保持 |'
- en: '| 1 | Pulse | Inverse of previous value | Toggle |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 脉冲 | 上一个值的反向 | 切换 |'
- en: '**Using a Clock in a 3-Bit Counter**'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**在 3 位计数器中使用时钟**'
- en: To illustrate the use of a clock in a circuit, let’s build a 3-bit counter—a
    circuit that counts from 0 to 7 in binary. This circuit has three memory elements,
    each representing one bit of a 3-bit number. The circuit takes a clock input,
    and when a clock pulse occurs, the 3-bit number increments (increases by 1). Since
    all the bits represent a single number, it’s important that we synchronize their
    state changes with a clock. Let’s use T flip-flops to accomplish this.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明时钟在电路中的应用，让我们构建一个 3 位计数器——一个二进制从 0 到 7 计数的电路。这个电路有三个存储元件，每个元件代表一个 3 位数字的一位。电路接受时钟输入，当时钟脉冲发生时，3
    位数字会递增（增加 1）。由于所有位都代表一个数字，因此重要的是我们要使它们的状态变化与时钟同步。让我们使用 T 翻转触发器来实现这一点。
- en: First, see [Table 6-5](ch06.xhtml#ch6tab5) as a review of counting in binary
    using a 3-bit number.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，查看[表 6-5](ch06.xhtml#ch6tab5)，复习一下如何使用 3 位数字进行二进制计数。
- en: '**Table 6-5:** Counting in Binary with 3 Bits'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-5：** 使用 3 位进行二进制计数'
- en: '| **Binary** | **Decimal** |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **二进制** | **十进制** |'
- en: '| --- | --- |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 000 | 0 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 000 | 0 |'
- en: '| 001 | 1 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 001 | 1 |'
- en: '| 010 | 2 |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 010 | 2 |'
- en: '| 011 | 3 |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 011 | 3 |'
- en: '| 100 | 4 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 4 |'
- en: '| 101 | 5 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 101 | 5 |'
- en: '| 110 | 6 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 110 | 6 |'
- en: '| 111 | 7 |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 111 | 7 |'
- en: '[Table 6-5](ch06.xhtml#ch6tab5) presents our 3-bit number as a single value
    on each row. Let’s now assign each of the bits to memory elements labeled Q0,
    Q1, and Q2\. Q0 is the least significant bit and Q2 is the most significant bit,
    as shown in [Table 6-6](ch06.xhtml#ch6tab6).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 6-5](ch06.xhtml#ch6tab5)将我们的 3 位数字作为每一行的单一值展示。现在，我们将每一位分配给标记为 Q0、Q1 和 Q2
    的内存元素。Q0 是最不重要的位，Q2 是最重要的位，如[表 6-6](ch06.xhtml#ch6tab6)所示。'
- en: '**Table 6-6:** Counting in Binary, Each Bit Assigned to a Separate Memory Element'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 6-6：** 二进制计数，每一位分配给一个单独的内存元素'
- en: '| **All 3 bits** | **Q2** | **Q1** | **Q0** | **Decimal** |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **所有 3 位** | **Q2** | **Q1** | **Q0** | **十进制** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| 000 | 0 | 0 | 0 | 0 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 000 | 0 | 0 | 0 | 0 |'
- en: '| 001 | 0 | 0 | 1 | 1 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 001 | 0 | 0 | 1 | 1 |'
- en: '| 010 | 0 | 1 | 0 | 2 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 010 | 0 | 1 | 0 | 2 |'
- en: '| 011 | 0 | 1 | 1 | 3 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 011 | 0 | 1 | 1 | 3 |'
- en: '| 100 | 1 | 0 | 0 | 4 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 100 | 1 | 0 | 0 | 4 |'
- en: '| 101 | 1 | 0 | 1 | 5 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 101 | 1 | 0 | 1 | 5 |'
- en: '| 110 | 1 | 1 | 0 | 6 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 110 | 1 | 1 | 0 | 6 |'
- en: '| 111 | 1 | 1 | 1 | 7 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 111 | 1 | 1 | 1 | 7 |'
- en: If we look at the Q columns in [Table 6-6](ch06.xhtml#ch6tab6) individually,
    we can see a pattern emerge. As we count, Q0 toggles every time. Q1 toggles when
    Q0 was previously 1\. Q2 toggles when both Q1 and Q0 were previously 1\. In other
    words, apart from Q0, each bit toggles on the next count when all the preceding
    bits are 1\. T flip-flops are perfect for implementing this counter, since toggling
    is what they do! Let’s look at how we can build a circuit to do this, shown in
    [Figure 6-15](ch06.xhtml#ch6fig15).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们单独查看[表 6-6](ch06.xhtml#ch6tab6)中的 Q 列，就能看到一个模式。当我们计数时，Q0 每次都会切换。当 Q0 之前是
    1 时，Q1 才会切换。当 Q0 和 Q1 都是 1 时，Q2 才会切换。换句话说，除了 Q0，每一位在下一个计数时会在前面的所有位为 1 时切换。T 触发器非常适合实现这个计数器，因为它们正是用于切换的！让我们看看如何构建一个电路来实现这个功能，如[图
    6-15](ch06.xhtml#ch6fig15)所示。
- en: '![image](../images/fig6-15.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-15.jpg)'
- en: '*Figure 6-15: A 3-bit counter built from T flip-flops*'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-15：由 T 触发器构建的 3 位计数器*'
- en: In [Figure 6-15](ch06.xhtml#ch6fig15), all three T flip-flops use the same clock
    signal, so they are synchronized. T0 is connected to 5V, so Q0 toggles every time
    the clock pulses. T1 is connected to Q0, so a clock pulse causes Q1 to toggle
    only when Q0 is high. T2 is connected to Q0 AND Q1, so Q2 only toggles on a clock
    pulse when Q0 and Q1 are both high.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 6-15](ch06.xhtml#ch6fig15)中，所有三个 T 触发器使用相同的时钟信号，因此它们是同步的。T0 连接到 5V，因此 Q0
    每次时钟脉冲时都会切换。T1 连接到 Q0，因此只有当 Q0 为高电平时，时钟脉冲才会使 Q1 切换。T2 连接到 Q0 和 Q1，因此当 Q0 和 Q1
    都为高电平时，时钟脉冲才会使 Q2 切换。
- en: '**NOTE**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**注**'
- en: '*Please see [Project #11](ch06.xhtml#proj11) on [page 113](ch06.xhtml#page_113),
    where you can build your very own 3-bit counter*.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*请参见[项目 #11](ch06.xhtml#proj11)以及[第 113 页](ch06.xhtml#page_113)，在这里你可以构建你自己的
    3 位计数器*。'
- en: Consider how we might use such a counter in conjunction with the vending machine
    circuit we designed earlier. Instead of simply tracking whether a coin is inserted
    or not, we can track the count of coins inserted, at least up to seven coins!
    For a vending machine counter to be useful, it also needs to be able to count
    down, since vending an item should decrease the coin count. I won’t cover the
    specifics of how to add a counter to the vending circuit here, but feel free to
    experiment on your own. Designs for counter circuits that count up and down are
    available online, or you can use an up/down counter IC like the 74191.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 想一想我们如何将这样的计数器与我们之前设计的自动售货机电路结合使用。我们可以不单纯地跟踪是否投币，而是跟踪投币的数量，至少可以跟踪到七个硬币！为了使自动售货机计数器有用，它还需要能够进行倒计数，因为售卖商品应该减少硬币数量。这里我不会详细讲解如何将计数器添加到自动售货机电路中，但你可以自己进行实验。网上有计数器电路的设计，可以进行加法和减法计数，或者你可以使用像
    74191 这样的加/减计数器 IC。
- en: We’ve constructed a counter from T flip-flops, which was built from JK flip-flops,
    which are digital logic circuits based on transistors! This again demonstrates
    how encapsulation allows us to build complex systems, hiding the details along
    the way.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从 T 触发器构建了一个计数器，而 T 触发器又是由 JK 触发器构建的，JK 触发器是基于晶体管的数字逻辑电路！这再次展示了封装如何使我们能够构建复杂的系统，同时隐藏细节。
- en: '**Summary**'
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we covered sequential logic circuits and clock signals. You
    learned that unlike combinational logic circuits, sequential circuits have memory,
    a record of past state. You learned about the SR latch, a simple single-bit memory
    device. We saw how synchronizing multiple circuit components, including memory
    devices, can be accomplished with a clock signal, an electrical signal that alternates
    its voltage level between high and low. A clocked single-bit memory device is
    known as a flip-flop, which allows for state changes to only occur in synchronization
    with the clock signal. You learned how JK flip-flops work, how T flip-flops can
    be constructed from JK flip-flops, and finally how a clock and T flip-flops can
    be used together to create a 3-bit counter.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容介绍了顺序逻辑电路和时钟信号。你了解了与组合逻辑电路不同，顺序电路具有记忆功能，能记录过去的状态。你学习了SR锁存器，一种简单的单比特存储设备。我们看到如何通过时钟信号同步多个电路组件，包括存储设备，时钟信号是一种电气信号，其电压水平在高和低之间交替变化。一个带时钟的单比特存储设备被称为触发器，它使状态变化只在与时钟信号同步时发生。你了解了JK触发器的工作原理，如何通过JK触发器构建T触发器，最后，如何将时钟和T触发器结合使用来创建一个3位计数器。
- en: Memory and clocks are key components of modern computing devices, and in the
    next chapter, we’ll see how they play a role in today’s computers. There you’ll
    learn about computer hardware—memory, processor, and I/O.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 内存和时钟是现代计算设备的关键组件，在下一章中，我们将看到它们如何在今天的计算机中发挥作用。在那里，你将学习到计算机硬件——内存、处理器和I/O。
- en: '**PROJECT #6: CONSTRUCT AN SR LATCH USING NOR GATES**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #6：使用NOR门构建SR锁存器**'
- en: In this project, you’ll build an SR latch on a breadboard. You’ll connect output
    Q to an LED to easily observe the state. You should test setting S and R high
    and low and observe the output.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，你将在面包板上构建一个SR锁存器。你将输出Q连接到一个LED，以便轻松观察状态。你应测试将S和R设置为高或低，并观察输出。
- en: 'For this project, you’ll need the following components:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目需要以下组件：
- en: Breadboard
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面包板
- en: LED
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED
- en: Current-limiting resistor to use with your LED (approximately 220Ω)
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于LED的限流电阻（约220Ω）
- en: Jumper wires
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: 7402 IC (contains four NOR gates)
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7402 IC（包含四个NOR门）
- en: 5-volt power supply
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5伏电源
- en: Two 470Ω resistors
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个470Ω电阻
- en: Two switches or pushbuttons that fit a breadboard
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个适合面包板的开关或按键
- en: 'Optional: An additional 220Ω resistor and another LED'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选：一个额外的220Ω电阻和另一个LED
- en: 'As a reminder, see the sections “Buying Electronic Components” on [page 333](appb.xhtml#page_333)
    and “Powering Digital Circuits” on [page 336](appb.xhtml#page_336) if you need
    help on those topics. Also, review [Project #4](ch04.xhtml#proj4) on [page 68](ch04.xhtml#page_68)
    for a reminder about how to use buttons/switches with pull-down resistors. Connect
    your components as shown in [Figure 6-16](ch06.xhtml#ch6fig16) to build an SR
    latch. Note that the NOR gates are arranged differently within the 7402 IC as
    compared to the layout of gates in other ICs like the 7408 (AND gates) and the
    7432 (OR gates), so be sure to use the right pins for inputs and outputs.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '提醒一下，如果你需要关于这些主题的帮助，可以参考[第333页](appb.xhtml#page_333)的“购买电子元件”和[第336页](appb.xhtml#page_336)的“为数字电路供电”部分。同时，复习[第68页](ch04.xhtml#page_68)的[项目
    #4](ch04.xhtml#proj4)，提醒你如何使用带下拉电阻的按钮/开关。按照[图6-16](ch06.xhtml#ch6fig16)所示连接组件，构建SR锁存器。请注意，7402
    IC内的NOR门布局与其他IC（如7408（与门）和7432（或门））中的门布局不同，因此务必使用正确的引脚连接输入和输出。'
- en: '![image](../images/fig6-16.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-16.jpg)'
- en: '*Figure 6-16: Wiring diagram for an SR latch built from a 7402 IC*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-16：由7402 IC构建的SR锁存器接线图*'
- en: Once you’ve constructed the SR latch circuit as shown in [Figure 6-16](ch06.xhtml#ch6fig16),
    connect S and R to buttons (or switches) with pull-down resistors, as shown in
    [Figure 6-17](ch06.xhtml#ch6fig17). This allows you to easily set the value of
    S or R just by pressing a button.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在你按照[图6-16](ch06.xhtml#ch6fig16)所示构建SR锁存器电路后，将S和R连接到带有下拉电阻的按钮（或开关），如[图6-17](ch06.xhtml#ch6fig17)所示。这使得你可以通过按下按钮轻松设置S或R的值。
- en: '![image](../images/fig6-17.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-17.jpg)'
- en: '*Figure 6-17: Using buttons and pull-down resistors to control inputs S and
    R*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-17：使用按钮和下拉电阻控制输入S和R*'
- en: Once you have connected your buttons to the SR latch, try setting S or R to
    high or low by pressing and releasing the button. Observe the results. Does Q
    turn on when you press S and stay on even after you release S? Does Q turn off
    when you press R and stay off even after you release R? If you want to also see
    the value of Q, which should always be the opposite of Q, just connect another
    220Ω resistor and another LED to pins 1 and 6 of the IC.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 连接按钮到SR锁存器后，尝试通过按下和释放按钮将S或R设置为高电平或低电平。观察结果。当您按下S时，Q是否打开并在释放S后保持打开？当您按下R时，Q是否关闭并在释放R后保持关闭？如果您想要查看Q的值，它应该始终与Q相反，只需将另一个220Ω电阻器和LED连接到IC的引脚1和6。
- en: When you initially apply power, the output will be in an unpredictable state.
    That is, the circuit may start up with either Q = 0 or Q = 1\. Or maybe your circuit
    reliably starts up with Q as a certain value. The reason for this unpredictability
    is that this design leads to a *race condition*. If S = 0 and R = 0 when power
    is applied, both N1 and N2 try to output a 1\. One of them does this slightly
    faster (thus, a *race*). If N1 outputs a 1 first, N2 goes low and Q is 0\. If
    N2 outputs a 1 first, N1 goes low and Q is 1\. This can be addressed by holding
    the R button down during startup (to force Q = 0) and then releasing the R button
    after startup.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当您初始应用电源时，输出将处于不可预测状态。也就是说，电路可能以Q = 0或Q = 1的任一值启动。或者，您的电路可靠地以某个特定值的Q启动。这种不可预测性的原因是这种设计导致了*竞争条件*。如果S
    = 0并且R = 0在应用电源时，N1和N2都试图输出1。其中一个稍快地做到了这一点（因此是*竞赛*）。如果N1首先输出1，N2变低，Q为0。如果N2首先输出1，N1变低，Q为1。可以通过在启动期间按住R按钮（以强制Q
    = 0）然后在启动后释放R按钮来解决此问题。
- en: Keep this circuit around, we’ll use it in the next project.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 保留此电路，我们将在下一个项目中使用它。
- en: '**PROJECT #7: CONSTRUCT A BASIC VENDING MACHINE CIRCUIT**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目＃7：构建基本自动售货机电路**'
- en: In this project, you’ll build the vending machine circuit described earlier
    in this chapter. You can reuse your SR latch from the last project as the memory
    unit. Be sure to use current limiting resistors on your LEDs and pull-down resistors
    for your button inputs. Test the circuit to make sure it works as expected. To
    reset the circuit, press the R button on the SR latch.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，您将构建本章前述的自动售货机电路。您可以重复使用上一个项目中的SR锁存器作为存储单元。确保在LED上使用限流电阻器，并为按钮输入使用下拉电阻器。测试电路以确保其按预期工作。要重置电路，请按SR锁存器上的R按钮。
- en: 'For this project, you’ll need the following components:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，您将需要以下组件：
- en: 'The 7402 SR latch on a breadboard you constructed in [Project #6](ch06.xhtml#proj6)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您构建的面包板上的7402 SR锁存器，见[项目＃6](ch06.xhtml#proj6)
- en: An additional LED
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个额外的LED
- en: An additional current-limiting resistor to use with your LED (approximately
    220Ω)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用额外的限流电阻器来与您的LED一起使用（约为220Ω）
- en: Jumper wires
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接线
- en: 7408 IC (contains four AND gates)
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7408 IC（包含四个与门）
- en: An additional pushbutton or switch that will fit a breadboard
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适合面包板的额外按钮或开关
- en: An additional pull-down resistor to use with your button (approximately 470Ω)
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用额外的下拉电阻器来与您的按钮一起使用（约为470Ω）
- en: As a reminder, see the sections “Buying Electronic Components” on [page 333](appb.xhtml#page_333)
    and “Powering Digital Circuits” on [page 336](appb.xhtml#page_336) if you need
    help on these topics.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒，请参阅章节“购买电子元件”在[第333页](appb.xhtml#page_333)和“供电数字电路”在[第336页](appb.xhtml#page_336)如果您需要帮助这些主题。
- en: In the circuit diagram shown in [Figure 6-18](ch06.xhtml#ch6fig18), the IC pin
    numbers are indicated in boxes. Although they are not shown in the diagram, be
    sure to connect both the 7402 and the 7408 chips to 5V and ground (pins 14 and
    7, respectively).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示于[图6-18](ch06.xhtml#ch6fig18)中的电路图中，IC引脚号码显示在方框中。虽然它们在图表中未显示，但确保将7402和7408芯片都连接到5V和地（分别是引脚14和7）。
- en: '![image](../images/fig6-18.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig6-18.jpg)'
- en: '*Figure 6-18: Wiring diagram for a basic vending machine circuit*'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-18：基本自动售货机电路的接线图*'
- en: The bottom portion of [Figure 6-18](ch06.xhtml#ch6fig18) is the circuit you
    built in the previous project. The only difference is that now the S button represents
    the COIN button and the output Q LED now represents the COIN indicator LED. To
    build the full circuit, you only need to add the top portion of the circuit and
    connect the two parts together as shown.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-18](ch06.xhtml#ch6fig18)的底部部分是您在上一个项目中构建的电路。唯一的区别是现在S按钮代表硬币按钮，而输出Q LED现在代表硬币指示LED。要构建完整的电路，您只需添加电路的顶部部分并将两部分连接如图所示。'
- en: Once your circuit is built, you should see that when you press the COIN button,
    the COIN LED lights. Pressing the VEND button should cause the VEND button to
    light, but only if the COIN LED is already lit. Press the RESET button to reset
    the circuit.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦电路搭建完成，你应该能看到，当你按下COIN按钮时，COIN LED灯会亮起。按下VEND按钮时，VEND LED灯应亮起，但仅当COIN LED灯已经亮起时才会如此。按下RESET按钮以重置电路。
- en: Keep this circuit around, we’ll use it in the next project.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 保留这个电路，我们将在下一个项目中使用它。
- en: '**PROJECT #8: ADD A DELAYED RESET TO THE VENDING MACHINE CIRCUIT**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #8：为自动售货机电路添加延迟复位**'
- en: 'In this project, you’ll add a delayed reset to the vending machine circuit
    from [Project #7](ch06.xhtml#proj7). You’ll need the following components:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个项目中，你将为[项目 #7](ch06.xhtml#proj7)中的自动售货机电路添加一个延迟复位。你将需要以下组件：'
- en: 'The vending machine circuit you constructed in [Project #7](ch06.xhtml#proj7)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '你在[项目 #7](ch06.xhtml#proj7)中构建的自动售货机电路'
- en: 4.7kΩ resistor
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4.7kΩ电阻
- en: 220μF electrolytic capacitor
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 220μF电解电容器
- en: Jumper wires
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: There are multiple types of capacitors; a discussion of the various types is
    outside the scope of this book. For this project, you’ll use an *electrolytic
    capacitor* ([Figure 6-19](ch06.xhtml#ch6fig19)). When connecting your capacitor,
    note that electrolytic capacitors are polarized, meaning one pin is negative and
    one is positive. Look for a negative sign or arrow indicating the negative terminal.
    Sometimes the negative terminal is shorter. In [Figure 6-21](ch06.xhtml#ch6fig21),
    the negative terminal should connect to ground.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 电容器有多种类型，关于各种类型的讨论超出了本书的范围。对于这个项目，你将使用*电解电容器*（[图6-19](ch06.xhtml#ch6fig19)）。连接电容器时，请注意电解电容器是有极性的，这意味着一根引脚是负极，另一根是正极。寻找标示负极的负号或箭头。有时，负极端子较短。在[图6-21](ch06.xhtml#ch6fig21)中，负极端应连接到地。
- en: '![image](../images/fig6-19.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-19.jpg)'
- en: '*Figure 6-19: An electrolytic capacitor. The shorter pin with a stripe/arrow
    is the negative pin.*'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-19：一个电解电容器。带有条纹/箭头的较短引脚是负极引脚。*'
- en: '[Figure 6-20](ch06.xhtml#ch6fig20) shows circuit diagram symbols for capacitors.
    On the left is the symbol for a nonpolarized capacitor. In the middle and on the
    right are symbols used to represent polarized capacitors. Both polarized symbols
    provide a means of identifying the positive and negative terminals of the capacitor.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-20](ch06.xhtml#ch6fig20)展示了电容器的电路符号。左侧是非极性电容器的符号。中间和右侧是用于表示极性电容器的符号。两个极性符号都提供了一种识别电容器正负端的方法。'
- en: '![image](../images/fig6-20.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-20.jpg)'
- en: '*Figure 6-20: Circuit diagram symbols for capacitors*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-20：电容器的电路符号*'
- en: '[Figure 6-21](ch06.xhtml#ch6fig21) shows how you can add the capacitor-based
    delayed reset to the vending machine circuit, replacing the manual reset. Keep
    reading past the figure for more details on how to build this circuit.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6-21](ch06.xhtml#ch6fig21)展示了如何将基于电容的延迟复位添加到自动售货机电路中，替代手动复位。继续阅读图示后面的内容，了解如何构建这个电路的更多细节。'
- en: '![image](../images/fig6-21.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-21.jpg)'
- en: '*Figure 6-21: Wiring diagram for a vending machine circuit with delayed reset*'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-21：带延迟复位的自动售货机电路接线图*'
- en: 'If you still have a manual reset switch or button connected to R (pin 5 on
    the 7402 chip), be sure to disconnect it, as its presence will interfere with
    the delayed reset operation. In [Figure 6-21](ch06.xhtml#ch6fig21), note how the
    VEND output of our circuit (pin 3 on the 7408 chip), which goes high when vending
    occurs, is connected to the latch’s reset input through a new delay component.
    This new component consists of a resistor and capacitor that, together, introduce
    a delay of about 1 second to the reset. Let’s walk through what happens here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然有手动复位开关或按钮连接到R（7402芯片的第5引脚），请务必断开它，因为它的存在会干扰延迟复位的操作。在[图6-21](ch06.xhtml#ch6fig21)中，请注意我们的电路的VEND输出（7408芯片的第3引脚），当发生售货操作时会变高，并通过一个新的延迟组件连接到锁存器的复位输入。这个新组件由一个电阻和电容器组成，它们共同引入约1秒的延迟来进行复位。接下来让我们看看这里发生了什么：
- en: When a vend operation occurs, the output from the 7408 AND gate goes high.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发生售货操作时，7408与门的输出会变高。
- en: The uncharged capacitor initially acts like a short circuit to ground, and the
    reset R to the latch is kept low, so no reset occurs at first.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始时，未充电的电容器表现得像是一个接地的短路，复位R到锁存器的电平保持低，因此最初不会发生复位。
- en: Since no reset has happened yet, the VEND LED has an opportunity to light.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于复位尚未发生，VEND LED有机会亮起。
- en: If the VEND button is held down, the AND output stays high, and the capacitor
    begins to charge.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果按住VEND按钮，AND输出保持高电平，电容开始充电。
- en: After about 1 second, the capacitor is sufficiently charged and acts like an
    open circuit, effectively removing the connection to ground.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 经过大约1秒钟后，电容就充足了，表现得像一个开路，从而有效地断开了与地的连接。
- en: The reset input R to the latch goes high, and a reset occurs.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 触发器的重置输入R变为高电平，重置发生。
- en: 'A few things to note about this design:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个设计有几点需要注意：
- en: The VEND button must be held down to give the capacitor time to charge.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须按住VEND按钮，以便电容有时间充电。
- en: The circuit still may start with the COIN LED already on. Just hold VEND to
    reset. This could be addressed with a power-on reset circuit, but that’s outside
    the scope of this project.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电路可能仍然会在COIN LED已经亮起的情况下启动。只需按住VEND按钮进行重置。这可以通过电源开启重置电路来解决，但这超出了本项目的范围。
- en: If adding the reset component causes the entire vending circuit to do nothing,
    the R input is likely stuck at a high voltage. Check the voltage on pin 5 of the
    7402 to see if it is high (anything above 0.8V) when it should be low. If you
    run into this problem, double-check the values of the 4.7kΩ resistor and the 220μF
    capacitor. Also check your wiring; a loose connection or a jumper wire in the
    wrong row can throw things off.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果添加重置组件导致整个售货机电路无法工作，可能是R输入被卡在高电压状态。检查7402芯片第5脚的电压，看看当它应该是低电压时，是否过高（高于0.8V）。如果遇到这个问题，请再次检查4.7kΩ电阻和220μF电容的数值。还要检查接线，松动的连接或错误排位的跳线可能会导致问题。
- en: I chose the capacitance and resistance values because they produce a delay of
    about 1 second. You could use other values. However, changing these values runs
    the risk of causing the voltage at the R input to be too high when it should be
    low, as just noted.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我选择了电容和电阻的数值，因为它们能产生大约1秒的延时。你可以使用其他数值。然而，改变这些数值可能会导致R输入的电压过高，正如前面提到的那样。
- en: Your completed circuit should look something like the circuit shown in [Figure
    6-22](ch06.xhtml#ch6fig22), although your specific layout will probably vary.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你完成的电路应该与[图 6-22](ch06.xhtml#ch6fig22)所示的电路相似，尽管你的具体布局可能会有所不同。
- en: '![image](../images/fig6-22.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-22.jpg)'
- en: '*Figure 6-22: Vending machine circuit with delayed reset on a breadboard*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-22：面包板上的带延时重置的售货机电路*'
- en: 'I recommend that you keep the SR latch part of your circuit intact, as you’ll
    use it again in the following projects. You can remove the other components from
    the board, but keep the portion from [Project #6](ch06.xhtml#proj6). Or you can
    just build another SR latch when you need to.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '我建议你保留电路中的SR触发器部分，因为你将在接下来的项目中再次使用它。你可以移除电路板上的其他组件，但请保留[项目 #6](ch06.xhtml#proj6)部分。或者，当需要时，你也可以重新构建一个SR触发器。'
- en: '**PROJECT #9: USING A LATCH AS A MANUAL CLOCK**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #9：使用触发器作为手动时钟**'
- en: You’re going to need a clock signal for the projects later in the chapter. In
    this project, you’ll configure your previously constructed SR latch as a manual
    clock.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要一个时钟信号来进行本章后面的项目。在这个项目中，你将把之前构建的SR触发器配置为手动时钟。
- en: As you learned earlier, a clock input needs to alternate between high voltage
    and low voltage. You could try to implement a clock by moving a wire between ground
    and 5V. That would certainly cause the voltage to alternate, but not in the way
    you want. When you were moving the wire, some of the time the wire wouldn’t be
    connected to anything. During those moments, the voltage on the input clock pin
    would “float,” and you’d get unpredictable behavior in your circuit. That’s not
    a good option.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你之前学到的，时钟输入需要在高电压和低电压之间交替。你可以尝试通过将一根线在地和5V之间移动来实现时钟。这样当然能使电压交替变化，但并不是你想要的那种方式。当你移动电线时，有时电线并没有连接到任何地方。在这些时刻，时钟输入引脚上的电压会“漂浮”，并且电路行为会变得不可预测。这不是一个好的选择。
- en: 'Or you could add an oscillator that would automatically generate pulses on
    a regular cadence, say one pulse every second. That’s how clocks typically work
    in the real world. A common IC is designed for this purpose: the 555 timer. However,
    for the upcoming exercises you need to be able to carefully observe state changes
    in your circuits, so what you really need is a *manual* clock, that is, a clock
    that only goes high or low when you tell it to. In a sense, such a manual clock
    isn’t even really a clock, because it won’t alternate states on a regular cadence.
    That said, whether it’s technically a clock or not isn’t terribly relevant—we
    need a device you can use to manually trigger state changes.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以添加一个振荡器，自动生成有规律的脉冲，比如每秒一个脉冲。这就是现实世界中时钟的典型工作方式。一种常见的集成电路专门用于这个目的：555定时器。然而，在接下来的练习中，你需要仔细观察电路中的状态变化，因此你真正需要的是一个*手动*时钟，也就是说，只有在你指示时它才会变高或变低。从某种意义上说，这种手动时钟甚至不算真正的时钟，因为它不会按规律交替状态。话虽如此，无论它是否技术上算作时钟都不是特别重要——我们需要一个可以用来手动触发状态变化的设备。
- en: You may be tempted to try using a regular pushbutton and a pull-down resistor
    as a clock, as shown in [Figure 6-23](ch06.xhtml#ch6fig23). After all, pressing
    the button makes the voltage go high, and releasing the button makes the voltage
    go low.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想尝试使用普通的按键和下拉电阻作为时钟，如[图6-23](ch06.xhtml#ch6fig23)所示。毕竟，按下按钮会使电压变高，松开按钮会使电压变低。
- en: '![image](../images/fig6-23.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-23.jpg)'
- en: '*Figure 6-23: Simple switch with pull-down resistor as a CLK input (this won''t
    work very well)*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-23：带下拉电阻的简单开关作为时钟输入（这个方法效果不好）*'
- en: Unfortunately, the design in [Figure 6-23](ch06.xhtml#ch6fig23) actually makes
    a very poor manual clock. The problem is that mechanical buttons and switches
    tend to “bounce.” Internally the switch has metal contacts that connect when the
    switch is closed. The act of closing the switch results in an initial connection
    between the contacts, but then the contacts separate and come back together, sometimes
    multiple times, before the switch finally settles into a closed state. The same
    thing happens when the switch is opened, except in reverse. A simple button press
    or flip of a switch results in the voltage jumping high and low multiple times.
    This is called *switch bounce*, illustrated in [Figure 6-24](ch06.xhtml#ch6fig24).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，[图6-23](ch06.xhtml#ch6fig23)中的设计实际上并不是一个好的手动时钟。问题在于，机械按钮和开关往往会“抖动”。开关内部有金属接点，在开关闭合时会连接。关闭开关时，接点会首次连接，但随后接点会分开并再次接触，有时会多次发生，直到开关最终稳定在关闭状态。当开关打开时，也会发生类似的情况，只是方向相反。简单的按钮按下或开关翻转会导致电压多次上下跳动。这种现象叫做*开关抖动*，如[图6-24](ch06.xhtml#ch6fig24)所示。
- en: '![image](../images/fig6-24.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-24.jpg)'
- en: '*Figure 6-24: Switch bounce, not what we want in a clock*'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-24：开关抖动，这不是我们在时钟中想要的效果*'
- en: '*Debounce circuits* are hardware options for removing bounce. One such debounce
    circuit is based on an SR latch, which conveniently, you have already constructed!
    If you connect S and R to switches, those inputs to the latch still bounce, but
    the output of the latch (Q) holds its value, as shown in [Figure 6-25](ch06.xhtml#ch6fig25).
    This is an effective way of removing switch bounce.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*去抖电路*是去除抖动的硬件选项。一个这样的去抖电路基于SR锁存器，而巧合的是，你已经构建了一个！如果你将S和R连接到开关，这些输入到锁存器仍然会抖动，但锁存器的输出（Q）会保持其值，如[图6-25](ch06.xhtml#ch6fig25)所示。这是一种有效去除开关抖动的方法。'
- en: '![image](../images/fig6-25.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-25.jpg)'
- en: '*Figure 6-25: An SR latch produces a clean output even when its inputs bounce.*'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-25：即使输入发生抖动，SR锁存器也能输出干净的信号。*'
- en: 'To use an SR latch as a clock, press S to set the clock signal high, and then
    press R to set the clock signal low. Just don’t press both buttons at the same
    time! You can use the SR latch you constructed in [Project #6](ch06.xhtml#proj6)
    as a clock. If you previously removed the reset button/switch from pin 5 as part
    of [Project #8](ch06.xhtml#proj8), connect it again. The complete SR latch as
    a manual clock should be wired as shown in [Figure 6-26](ch06.xhtml#ch6fig26).'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用SR锁存器作为时钟，按下S将时钟信号设为高电平，然后按下R将时钟信号设为低电平。只要不要同时按下两个按钮！你可以使用在[项目#6](ch06.xhtml#proj6)中构建的SR锁存器作为时钟。如果你之前在[项目#8](ch06.xhtml#proj8)中将复位按钮/开关从引脚5中移除，重新连接它。完整的SR锁存器作为手动时钟应该按[图6-26](ch06.xhtml#ch6fig26)所示进行布线。
- en: '![image](../images/fig6-26.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-26.jpg)'
- en: '*Figure 6-26: A debounced manual clock created from two buttons/switches and
    an SR latch*'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-26：由两个按钮/开关和SR锁存器组成的去抖动手动时钟*'
- en: Press S to set the clock pulse high, and press R to set the clock pulse low.
    Now you have a manual clock you can use in the following projects.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 按下S键将时钟脉冲设置为高电平，按下R键将时钟脉冲设置为低电平。现在你有了一个可以在以下项目中使用的手动时钟。
- en: '**PROJECT #10: TEST A JK FLIP-FLOP**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目 #10：测试一个JK触发器**'
- en: Although you could build a JK flip-flop from other gates, it is conveniently
    sold as an integrated circuit, so you can save yourself some trouble. The 7473
    chip contains two negative edge–triggered JK flip-flops. In this project, you’ll
    use this integrated circuit to test the functionality of a single JK flip-flop.
    You’ll try setting J and K either high or low, and then send a clock pulse through
    the circuit. Connect an LED to the output Q to easily see the state change.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以用其他门电路构建JK触发器，但它作为集成电路出售，非常方便，这样可以省去一些麻烦。7473芯片包含两个负边沿触发的JK触发器。在这个项目中，你将使用这个集成电路来测试单个JK触发器的功能。你将尝试将J和K设置为高或低，然后通过电路发送时钟脉冲。将LED连接到输出Q，便于观察状态变化。
- en: 'For this project, you’ll need the following components:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，你将需要以下组件：
- en: 'The SR latch configured as a clock (discussed in [Project #9](ch06.xhtml#proj9))'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '将SR锁存器配置为时钟（在[项目 #9](ch06.xhtml#proj9)中讨论）'
- en: 7473 IC (contains two JK flip-flops)
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7473集成电路（包含两个JK触发器）
- en: Jumper wires
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: LED
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED
- en: Current-limiting resistor to use with your LED (approximately 220Ω)
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于LED的限流电阻（约220Ω）
- en: As a reminder, see “Buying Electronic Components” on [page 333](appb.xhtml#page_333)
    and “Powering Digital Circuits” on [page 336](appb.xhtml#page_336) if you need
    help on those topics. [Figure 6-27](ch06.xhtml#ch6fig27) shows the pinout diagram
    for the 7473 IC.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒一下，如果你在这些话题上需要帮助，请参考[第333页](appb.xhtml#page_333)的“购买电子元件”和[第336页](appb.xhtml#page_336)的“为数字电路供电”。[图6-27](ch06.xhtml#ch6fig27)显示了7473集成电路的引脚图。
- en: '![image](../images/fig6-27.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-27.jpg)'
- en: '*Figure 6-27: Pinout for the 7473 IC*'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-27：7473集成电路的引脚图*'
- en: The 7473 IC contains two JK flip-flops as shown in [Figure 6-27](ch06.xhtml#ch6fig27).
    Note that the voltage and ground connections aren’t in the “usual” locations and
    instead are pins 4 and 11, respectively. Also, note that the CLK (clock) inputs
    are marked with a circle, indicating that this circuit is negative edge–triggered;
    you should expect the state to change when the clock pulse falls. Since you’re
    using an SR latch for your manual clock, this means you’ll see the JK state change
    when you press the SR latch’s R input button.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 7473集成电路包含两个JK触发器，如[图6-27](ch06.xhtml#ch6fig27)所示。注意电压和接地连接不在“常规”位置，而是分别在引脚4和引脚11。同时，注意CLK（时钟）输入用圆圈标记，表示该电路是负边沿触发的；你应该预期当时钟脉冲下降时，状态会发生变化。由于你使用SR锁存器作为手动时钟，这意味着当你按下SR锁存器的R输入按钮时，你会看到JK状态变化。
- en: 'An additional input for each JK flip-flop wasn’t mentioned in the chapter:
    CLR. When this pin is set low, the flip-flop clears the saved bit (Q = 0). CLR
    is asynchronous, meaning it doesn’t wait on the clock pulse. The line shown above
    CLR means it is *active low*, meaning the saved bit is cleared when the input
    is set low. CLR is also sometimes called Reset or R, not to be confused with the
    R input of our SR latch. Connect the JK flip-flop’s CLR input (pin 2) to 5V to
    keep your flip-flop from resetting. For testing a single flip-flop, you can connect
    the chip as shown in [Figure 6-28](ch06.xhtml#ch6fig28).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 章节中没有提到每个JK触发器的额外输入：CLR。当这个引脚被设置为低电平时，触发器会清除保存的位（Q = 0）。CLR是异步的，这意味着它不依赖时钟脉冲。上面显示的CLR线表示它是*低有效*的，这意味着当输入被设置为低电平时，保存的位会被清除。CLR有时也叫做复位（Reset）或R，不能与我们SR锁存器的R输入混淆。将JK触发器的CLR输入（引脚2）连接到5V，以防止触发器复位。为了测试单个触发器，你可以按[图6-28](ch06.xhtml#ch6fig28)所示连接芯片。
- en: '![image](../images/fig6-28.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-28.jpg)'
- en: '*Figure 6-28: A simple JK test circuit*'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-28：一个简单的JK测试电路*'
- en: 'Using your previously built SR latch as a clock, connect the SR latch’s output
    Q (pins 3 and 4 on the 7402) to the clock input of the 7473 (pin 1). Now, try
    setting inputs J (pin 14) and K (pin 3) on the 7473 to 5V or ground. You should
    see that doing so has no effect on the JK flip-flop’s output LED until the clock
    transitions from high to low. Reminder: pulse the SR latch clock by first pressing
    S and then pressing R to set the clock signal high and then low. Flip back to
    [Table 6-3](ch06.xhtml#ch6tab3) to see the expected functionality of a JK flip-flop
    and ensure that your circuit works as expected.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你之前构建的SR锁存器作为时钟，将SR锁存器的输出Q（7402上的引脚3和引脚4）连接到7473的时钟输入（引脚1）。现在，尝试将7473上的输入J（引脚14）和K（引脚3）设置为5V或接地。你会看到，直到时钟从高电平过渡到低电平之前，这样做对JK触发器的输出LED没有任何影响。提示：通过先按下S再按下R来为SR锁存器时钟提供脉冲信号，使时钟信号从高电平变为低电平。返回查看[表6-3](ch06.xhtml#ch6tab3)，查看JK触发器的预期功能，并确保你的电路按预期工作。
- en: Keep this circuit intact for the next project.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 保持该电路不变，用于下一个项目。
- en: '**PROJECT #11: CONSTRUCT A 3-BIT COUNTER**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目#11：构建一个3位计数器**'
- en: In this project, you’ll build the 3-bit counter described earlier in this chapter.
    Connect the Q outputs to LEDs to easily observe the output.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本项目中，你将构建本章前面描述的3位计数器。将Q输出连接到LED，以便轻松观察输出。
- en: 'For this project, you’ll need the following components:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本项目，你将需要以下组件：
- en: 'The circuit constructed in [Project #10](ch06.xhtml#proj10) (including the
    manual clock from [Project #9](ch06.xhtml#proj9))'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[项目#10](ch06.xhtml#proj10)中构建的电路（包括来自[项目#9](ch06.xhtml#proj9)的手动时钟）
- en: An additional 7473 IC
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个额外的7473集成电路
- en: 7408 IC (contains four AND gates)
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7408集成电路（包含四个与门）
- en: 47kΩ resistor
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 47kΩ电阻
- en: 10μF electrolytic capacitor
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 10μF电解电容
- en: An additional button or switch
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个额外的按钮或开关
- en: Jumper wires
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳线
- en: Two additional LEDs
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个额外的LED
- en: Two additional current-limiting resistors to use with your LEDs (approximately
    220Ω each)
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个额外的限流电阻，用于LED（每个大约220Ω）
- en: Connect everything as shown in [Figure 6-29](ch06.xhtml#ch6fig29). Pin numbers
    on ICs are shown in boxes.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 按照[图6-29](ch06.xhtml#ch6fig29)中的示意图连接所有部件。集成电路的引脚编号显示在框内。
- en: '![image](../images/fig6-29.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-29.jpg)'
- en: '*Figure 6-29: A 3-bit counter built from T flip-flops, pin numbers shown*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-29：由T触发器构建的3位计数器，显示引脚编号*'
- en: 'In addition to the pin connections shown in [Figure 6-29](ch06.xhtml#ch6fig29),
    be sure to make the following connections:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[图6-29](ch06.xhtml#ch6fig29)中显示的引脚连接外，请确保还要做以下连接：
- en: Both 7473 ICs need pins 4 and 11 connected to 5V and ground, respectively.
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个7473集成电路的引脚4和引脚11分别需要连接到5V和接地。
- en: The 7408 should have pin 7 connected to ground and pin 14 to 5V.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7408的引脚7应连接到接地，引脚14应连接到5V。
- en: Q0, Q1, and Q2 should connect to LEDs through 220Ω resistors so you can see
    the bits update.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Q0、Q1和Q2应该通过220Ω电阻连接到LED，以便你可以看到比特的更新。
- en: The manual clock output (pins 3 and 4 on the 7402) should be connected to CLK
    on all three flip-flops (pins 1 and 5 on the first 7473, and pin 1 on the second
    7473).
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动时钟输出（7402上的引脚3和引脚4）应连接到所有三个触发器的CLK（第一个7473的引脚1和5，第二个7473的引脚1）。
- en: This circuit starts up in an unpredictable state. You can correct this manually
    by resetting all three flip-flops, but that’s tedious. Instead, add a *power-on
    reset* circuit that ensures the flip-flops all start with their output = 0\. Each
    flip-flop in the 7473 package has a CLR input, which when held low, resets the
    flip-flop, regardless of the state of the clock. You want CLR to go low on startup
    for a brief time and then go high and stay there. This ensures that the counter
    starts at zero when powered on. For good measure, you can also add a COUNTER RESET
    button that manually resets the counter when pressed. This reset capability is
    shown in [Figure 6-30](ch06.xhtml#ch6fig30).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 该电路以不可预测的状态启动。你可以通过手动重置所有三个触发器来纠正这一点，但这很繁琐。相反，可以添加一个*上电复位*电路，确保所有触发器在输出 = 0时启动。每个7473集成电路中的触发器都有一个CLR输入，当该输入为低电平时，会重置触发器，无论时钟状态如何。你希望CLR在启动时短暂地变为低电平，然后变为高电平并保持在那里。这样可以确保计数器在上电时从零开始。为了更好地控制，你还可以添加一个计数器复位按钮，当按下时手动重置计数器。该复位功能如[图6-30](ch06.xhtml#ch6fig30)所示。
- en: '![image](../images/fig6-30.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig6-30.jpg)'
- en: '*Figure 6-30: Power-on reset circuit for 3-bit binary counter*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-30：3位二进制计数器的上电复位电路*'
- en: 'When power is initially applied to the circuit shown in [Figure 6-30](ch06.xhtml#ch6fig30),
    the capacitor acts like a short circuit, and CLR is held low, setting the circuit
    to its initial state. Once the capacitor is charged, it acts like an open circuit,
    CLR goes high, and the circuit is ready to use. The COUNTER RESET button or switch,
    when pushed, also causes CLR to go low and reset the circuit. This circuit needs
    to be connected to CLR inputs: pins 2 and 6 on the first 7473 chip, and pin 2
    and the second 7473 chip. In [Project #10](ch06.xhtml#proj10), pin 2 on the first
    7473 was connected to 5V; be sure to disconnect it before you hook up the power-on
    reset circuit. Remember to orient the terminals of your electrolytic capacitor
    correctly—the negative terminal should connect to ground.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '当电源最初施加到[图 6-30](ch06.xhtml#ch6fig30)所示的电路时，电容器表现得像一个短路，CLR保持低电平，将电路设置为初始状态。一旦电容器充电完成，它就像一个开路，CLR变为高电平，电路准备好使用。当按下计数器重置按钮或开关时，CLR也会变为低电平，电路被重置。此电路需要连接到CLR输入：第一个7473芯片的2脚和6脚，以及第二个7473芯片的2脚。在[项目
    #10](ch06.xhtml#proj10)中，第一个7473的2脚连接到5V；在连接上电复位电路之前，一定要先将其断开。记得正确放置电解电容器的引脚——负极应连接到地。'
- en: 'With the power-on reset in place, the circuit should start with your counter
    at 000\. Sending a clock pulse to the circuit should cause the counter to increment
    by 1 when the clock edge falls. Reminder: pulse the SR latch clock by pressing
    S to set the clock signal high and pressing R to set the clock signal low. Test
    counting from 000 to 111 and ensure the counter works as expected.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好电源复位后，电路应以计数器从000开始。向电路发送时钟脉冲应导致计数器在时钟边沿下降时增加1。提醒：通过按下S设置时钟信号为高电平，按下R设置时钟信号为低电平，来脉冲SR锁存器的时钟。测试计数从000到111，并确保计数器按预期工作。
