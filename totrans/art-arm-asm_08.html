<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch6">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_293" aria-label="293"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch6">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">6</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">ARITHMETIC</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="378" height="378"/>&#13;
</figure>&#13;
<p class="ChapterIntro">This chapter discusses arithmetic computation in assembly language, including floating-point arithmetic on the ARM processor and architectural support for real arithmetic. By the end of this chapter, you should be able to translate arithmetic expressions and assignment statements from HLLs like Pascal, Swift, and C/C++ into ARM assembly language. You’ll learn to pass floating-point values as parameters to procedures and return real values as function results.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-77"/><span class="SANS_Futura_Std_Bold_B_11">6.1 Additional ARM Arithmetic Instructions</span></h3>&#13;
<p class="TNI1">Before learning to encode arithmetic expressions in assembly language, you should learn the rest of the arithmetic instructions in the ARM instruction <span role="doc-pagebreak" epub:type="pagebreak" id="pg_294" aria-label="294"/>set. Previous chapters have covered most of the arithmetic and logical instructions, so this section covers the remaining few.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h2-104"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.1.1 Multiplication</span></h4>&#13;
<p class="TNI1"><span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span> provided a brief introduction to multiplication with the <span class="SANS_TheSansMonoCd_W5Regular_11">mul</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">madd</span> instructions. As a reminder, those instructions are as follows:</p>&#13;
<pre id="pre-423"><code>mul   X<var>d</var>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>       // X<var>d</var> = X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> * X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>&#13;
madd  X<var>d</var>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">3</span>  // X<var>d</var> = X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> * X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> + X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">3</span></code></pre>&#13;
<p class="TX">As long as overflow doesn’t occur, these instructions produce correct results for both unsigned and signed multiplications.</p>&#13;
<p class="TX">These instructions multiply two 64-bit integers and produce a 64-bit result. The multiplication of two <i>n</i>-bit numbers can actually produce a 2 × <i>n</i>–bit result, meaning that multiplying two 64-bit registers could produce up to a 128-bit result. These instructions ignore any overflow and keep only the LO 64 bits of the product (<span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span> discusses how to produce a full 128-bit result, if you require that).</p>&#13;
<p class="TX">You can also specify 32-bit registers for these two instructions:</p>&#13;
<pre id="pre-424"><code>mul   W<var>d</var>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>       // W<var>d</var> = W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> * W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>&#13;
madd  W<var>d</var>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">3</span>  // W<var>d</var> = W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> * W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> + W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">3</span></code></pre>&#13;
<p class="TX">These instructions produce 32-bit results, ignoring any overflow. There are two additional multiplication instructions: multiply and subtract, and multiply and negate:</p>&#13;
<pre id="pre-425"><code>msub  W<var>d</var>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">3</span>   // W<var>d</var> = W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> * W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> - W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">3</span>&#13;
msub  X<var>d</var>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">3</span>   // X<var>d</var> = X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> * X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> + X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">3</span>&#13;
mneg  W<var>d</var>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>        // W<var>d</var> = -(W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> * W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>)&#13;
mneg  X<var>d</var>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>        // X<var>d</var> = -(X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> * X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>)</code></pre>&#13;
<p class="TX">As with the previous instructions, these multiplications ignore any overflow beyond 32 or 64 bits.</p>&#13;
<p class="TX">The ARM does not provide multiplication instructions that affect the condition code flags. These instructions have no <span class="SANS_TheSansMonoCd_W5Regular_11">s</span>-suffix versions.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h2-105"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.1.2 Division and Modulo</span></h4>&#13;
<p class="TNI1">The ARM64 CPU provides only two division instructions:</p>&#13;
<pre id="pre-426"><code>sdiv  X<var>d</var>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>  // X<var>d</var> = X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> / X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2 </span>(signed division)&#13;
udiv  X<var>d</var>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>  // X<var>d</var> = X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> / X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2 </span>(unsigned division)</code></pre>&#13;
<p class="TX">Unlike with multiplication, you must use separate instructions for signed and unsigned integer values.</p>&#13;
<p class="TX">Division has two special cases that you must consider: division by 0 and dividing the smallest negative number by –1 (which would, mathematically, produce an overflow). A division by 0 produces 0 as the result, with no <span role="doc-pagebreak" epub:type="pagebreak" id="pg_295" aria-label="295"/>indication of the problem. A signed division (<span class="SANS_TheSansMonoCd_W5Regular_11">sdiv</span>) of 0x8000000000000000 (the smallest 64-bit negative number) by 0xFFFFFFFFFFFFFFFF (–1) will produce the result 0x8000000000000000, also without indication of an error. You’ll get similar results for the 32-bit division: 0x80000000 / 0xFFFFFFFF. You must explicitly test for these operands before the division to catch these errors.</p>&#13;
<p class="TX">There’s no single instruction to compute the remainder after a division operation on the ARM64 CPU. You can compute the remainder by combining a division and a multiplication operation:</p>&#13;
<pre id="pre-427"><code>mod(x0, x1) = x0 - (x0 / x1) * x1</code></pre>&#13;
<p class="TX">Alternatively, you can compute the same result by using the following two instructions:</p>&#13;
<pre id="pre-428"><code>udiv x2, x0, x1&#13;
msub x3, x2, x1, x0</code></pre>&#13;
<p class="TX">After this sequence, X2 and X3 hold the following values</p>&#13;
<pre id="pre-429"><code>x2 = x0 / x1&#13;
x3 = x0 % x1  // % is C modulo (remainder) operator.</code></pre>&#13;
<p class="Continued1">thus providing the modulo in X3.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-106"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.1.3 cmp Revisited</span></h4>&#13;
<p class="TNI1">As noted in section 2.10.4, <span class="Xref">“</span><span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="Xref">and Corresponding Conditional Branches,”</span> on <span class="Xref"><a href="chapter2.xhtml#pg_78">page 78</a></span>, the <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instruction updates the ARM’s flags according to the result of the subtraction operation (<span class="SANS_TheSansMonoCd_W5Regular_11">LeftOperand - RightOperand</span>). Based on the way the ARM sets the flags, you can read this instruction as “compare <span class="SANS_TheSansMonoCd_W5Regular_11">LeftOperand</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">RightOperand</span>.” You can test the result of the comparison by using conditional branch instructions (see <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span> for the conditional branches or <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span> for more on control structure implementations).</p>&#13;
<p class="TX">A good place to start when exploring <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> is to look at exactly how it affects the flags. Consider the following <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instruction:</p>&#13;
<pre id="pre-430"><code>cmp w0, w1</code></pre>&#13;
<p class="TX">This instruction performs the computation W0 – W1 and sets the flags depending on the result of the computation. The flags are set as follows:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><b>Z</b>    The zero flag is set if and only if W0 = W1. This is the only time W0 – W1 produces a zero result. Hence, you can use the zero flag to test for equality or inequality.</p>&#13;
<p class="RunInPara"><b>N</b>    The negative (sign) flag is set to 1 if the result is negative. You might think this flag would be set if W0 is less than W1, but this isn’t always the case. If W0 = 0x7FFFFFFFh and W1 = –1 (0xFFFFFFFF), then subtracting W1 from W0 produces 0x80000000, which is negative (so <span role="doc-pagebreak" epub:type="pagebreak" id="pg_296" aria-label="296"/>the negative flag will be set). For signed comparisons, at least, the negative flag doesn’t contain the proper status. For unsigned operands, consider W0 = 0xFFFFFFFF and W1 = 1. Here, W0 is greater than W1, but their difference is 0xFFFFFFFEh, which is still negative. As it turns out, the negative flag and the overflow flag, taken together, can be used for comparing two signed values.</p>&#13;
<p class="RunInPara"><b>V</b>    The overflow flag is set after a <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> operation if the difference of W0 and W1 produces a signed overflow or underflow. As mentioned previously, the sign and overflow flags are both used when performing signed comparisons.</p>&#13;
<p class="RunInPara"><b>C</b>    The carry flag is set after a <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> operation if subtracting W1 from W0 requires a borrow (unsigned overflow or underflow). This occurs only when W0 is less than W1, where W0 and W1 are both unsigned values.</p>&#13;
</div>&#13;
<p class="TX"><a href="chapter6.xhtml#tab6-1">Table 6-1</a> shows how the <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instruction affects the flags after comparing to unsigned or signed values.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab6-1"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 6-1:</span></span> <span class="SANS_Futura_Std_Book_11">Condition Code Settings After</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Flag</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Unsigned result</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Signed result</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Zero (Z)</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Equality/inequality</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Equality/inequality</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Carry (C)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Left ≥ right (C = 1)<br/>Left &lt; right (C = 0)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">No meaning</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Overflow (V)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">No meaning</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">See discussion in this section</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Sign (N)</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">No meaning</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">See discussion in this section</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Given that the <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instruction sets the flags in this fashion, you can test the comparison of the two signed operands with the following flags:</p>&#13;
<pre id="pre-431"><code>cmp <var>Left</var>, <var>Right</var></code></pre>&#13;
<p class="TX">For signed comparisons, the N and V flags, taken together, have the following meanings:</p>&#13;
<ul class="ul">&#13;
<li class="BL">If [N != V], then <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Left</span> &lt; <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Right</span> for a signed comparison.</li>&#13;
<li class="BL">If [N == V], then <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Left</span> ≥ <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Right</span> for a signed comparison.</li>&#13;
</ul>&#13;
<p class="TX">To understand why these flags are set in this manner, consider the 32-bit examples in <a href="chapter6.xhtml#tab6-2">Table 6-2</a>. The values easily sign-extend to 64 bits, and the results are the same.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab6-2"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 6-2:</span></span> <span class="SANS_Futura_Std_Book_11">Sign and Overflow Flag Settings After Subtraction (32-Bit Values)</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Left</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Minus</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Right</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">N</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">V</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0xFFFFFFFF (–1)</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">–</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0xFFFFFFFE (–2)</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x80000000 (–2 billion+)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">–</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x000000001</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0xFFFFFFFE (–2)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">–</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0xFFFFFFFF (–1)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0x7FFFFFFF (2 billion+)</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">–</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0xFFFFFFFF (–1)</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_297" aria-label="297"/>Remember, the <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> operation is really a subtraction; therefore, the first example in <a href="chapter6.xhtml#tab6-2">Table 6-2</a> computes (–1) – (–2), which is +1. The result is positive, and an overflow did not occur, so both the N and V flags are 0. Because (N == V), <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Left</span> is greater than or equal to <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Right</span>.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instruction would compute (–2,147,483,648) – (+1), which is (–2,147,483,649), in the second example. Because a 32-bit signed integer cannot represent this value, the value wraps around to 0x7FFFFFFF (+2,147,483,647) and sets the overflow flag. The result is positive (at least as a 32-bit value), so the CPU clears the negative flag. Because (N == V) here, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Left</span> is less than <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Right</span>.</p>&#13;
<p class="TX">In the third example, <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> computes (–2) – (–1), which produces (–1). No overflow occurred, so the V is 0; the result is negative, so N is 1. Because (N != V), <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Left</span> is less than <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Right</span>.</p>&#13;
<p class="TX">In the final example, <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> computes (+2,147,483,647) – (–1). This produces (+2,147,483,648), setting the overflow flag. Furthermore, the value wraps around to 0x80000000 (−2,147,483,648), so the negative flag is set as well. Because (N == V) is 0, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Left</span> is greater than or equal to <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">Right</span>.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">cmn</span> (compare negative) instruction compares its first source operand against a negated second operand; like <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span>, it sets the flags and ignores the result. It is also, like <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span>, an alias for a different instruction, <span class="SANS_TheSansMonoCd_W5Regular_11">add</span>:</p>&#13;
<pre id="pre-432"><code>add wzr, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>&#13;
add xzr, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span></code></pre>&#13;
<p class="TX">This is because <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> is equivalent to a <span class="SANS_TheSansMonoCd_W5Regular_11">sub</span> instruction, using WZR/XZR as the destination register; when comparing a negated value, you get the expression left – (–right), which is mathematically equivalent to left + right.</p>&#13;
<p class="TX">Using <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> as a synonym for <span class="SANS_TheSansMonoCd_W5Regular_11">cmn</span> has one issue: <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> doesn’t set the carry flag properly if the second (right) operand is 0. As a result, you cannot use the unsigned condition codes (<span class="SANS_TheSansMonoCd_W5Regular_11">hs</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">hi</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">lo</span>) after a <span class="SANS_TheSansMonoCd_W5Regular_11">cmn</span> instruction if there is any possibility that the right operand is 0. This shouldn’t generally be a problem because, by definition, you are using <span class="SANS_TheSansMonoCd_W5Regular_11">cmn</span> to compare signed values and you should be using signed conditionals after the use of the instruction.</p>&#13;
<p class="TX">Arguably the main reason for the existence of <span class="SANS_TheSansMonoCd_W5Regular_11">cmn</span> is that Operand2 immediate values must be in the range 0 to 4,095. You cannot compare a register against a negative immediate value by using the <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instruction. The <span class="SANS_TheSansMonoCd_W5Regular_11">cmn</span> instruction is also limited to constants in the range 0 to 4,095, but it will negate the immediate value before the comparison, allowing negative constants in the range –1 to –4,095 (–0 is still 0).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-107"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.1.4 Conditional Instructions</span></h4>&#13;
<p class="TNI1">In the original, 32-bit ARM architecture, most of the data manipulation instructions were conditional. You could execute an instruction, such as <span class="SANS_TheSansMonoCd_W5Regular_11">add</span>, conditionally, based on PSTATE condition code flag settings. Alas, the 4 bits required to test the 16 possible conditions (same as the conditional branch instructions) were needed for other encodings in 64-bit mode. Nevertheless, condition instruction execution is useful, so the ARM64 kept a few of the more commonly used condition instructions.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_298" aria-label="298"/>The first condition instruction is <span class="SANS_TheSansMonoCd_W5Regular_11">csel</span> (conditional select)</p>&#13;
<pre id="pre-433"><code>csel W<var>d</var>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>, <var>cond</var>  // if(<var>cond</var>) then W<var>d</var> = W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> else W<var>d</var> = W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> &#13;
csel X<var>d</var>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>, <var>cond</var>  // if(<var>cond</var>) then X<var>d</var> = X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> else X<var>d</var> = X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> </code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cond</span> is one of the following condition specifications</p>&#13;
<pre id="pre-434"><code>cs, cc, eq, ne, mi, pl, vs, vc, hs, hi, ls, lo, gt, ge, lt, le </code></pre>&#13;
<p class="Continued1">which have the same meanings as for the conditional branch instructions.</p>&#13;
<p class="TX">The <i>aoaa.inc</i> include file provides definitions for the following opposite conditions:</p>&#13;
<pre id="pre-435"><code>nhs, nhi, nls, nlo, ngt, nge, nlt, nle </code></pre>&#13;
<p class="Continued1">These are synonyms for <span class="SANS_TheSansMonoCd_W5Regular_11">lo</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">hi</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">hs</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">le</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">lt</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">ge</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">gt</span>, respectively.</p>&#13;
<p class="TX">As its name suggests, the <span class="SANS_TheSansMonoCd_W5Regular_11">csel</span> instruction selects one of the two source operands to copy into the destination register, based on the current flag settings. For example, the following instruction</p>&#13;
<pre id="pre-436"><code>csel x0, x1, x2, eq </code></pre>&#13;
<p class="Continued1">copies X1 into X0 if the zero flag is set; otherwise, it copies X2 into X0.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">csinc</span> instruction allows for a conditional select (if true condition) or increment (if false condition) operation:</p>&#13;
<pre id="pre-437"><code>csinc W<var>d</var>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>, <var>cond</var>  // if(<var>cond</var>) then W<var>d</var> = W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> else W<var>d</var> = W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> + 1 &#13;
csinc X<var>d</var>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>, <var>cond</var>  // if(<var>cond</var>) then X<var>d</var> = X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> else X<var>d</var> = X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> + 1 </code></pre>&#13;
<p class="TX">Using the predefined macro <span class="SANS_TheSansMonoCd_W5Regular_11">cinc</span> is sometimes more convenient:</p>&#13;
<pre id="pre-438"><code>cinc W<var>d</var>, W<var>s1</var>, <var>cond</var>  // csinc  W<var>d</var>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, invert(<var>cond</var>) &#13;
cinc X<var>d</var>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, <var>cond</var>  // csinc  X<var>d</var>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, invert(<var>cond</var>) </code></pre>&#13;
<p class="TX">That is, <span class="SANS_TheSansMonoCd_W5Regular_11">cinc</span> increments and copies the source into the destination if the condition is true; otherwise, it just copies the source without incrementing it. Of course, the source and destination registers can be the same if you simply want to conditionally increment a specific register. Note that the conditions for the <span class="SANS_TheSansMonoCd_W5Regular_11">cinc</span> macros are reversed from the <span class="SANS_TheSansMonoCd_W5Regular_11">csinc</span> instruction.</p>&#13;
<p class="TX">The next two conditional instructions are <span class="SANS_TheSansMonoCd_W5Regular_11">csinv</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">csneg</span>, which conditionally invert or negate values:</p>&#13;
<pre id="pre-439"><code>csinv W<var>d</var>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>, <var>cond</var>  // if(<var>cond)</var> then W<var>d</var> = W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span><var> </var>else W<var>d</var> = not W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> &#13;
csinv X<var>d</var>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>, <var>cond</var>  // if(<var>cond)</var> then X<var>d</var> = X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> else X<var>d</var> = not X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> &#13;
csneg W<var>d</var>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>, <var>cond</var>  // if(<var>cond)</var> then W<var>d</var> = W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> else W<var>d</var> = -W<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> &#13;
csneg X<var>d</var>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>, X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>, <var>cond</var>  // if(<var>cond)</var> then X<var>d</var> = X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> else X<var>d</var> = -X<var>s</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> </code></pre>&#13;
<p class="TX">There are also <span class="SANS_TheSansMonoCd_W5Regular_11">cinv</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">cneg</span> macros that take only a single source operand (like <span class="SANS_TheSansMonoCd_W5Regular_11">cinc</span>). The <span class="SANS_TheSansMonoCd_W5Regular_11">cset</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">csetm</span> macros are variants of <span class="SANS_TheSansMonoCd_W5Regular_11">csinc</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">cinv</span>:</p>&#13;
<pre id="pre-440"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_299" aria-label="299"/>cset  Wd, <var>cond</var>  // if(<var>cond</var>) then W<var>d</var> = 1 else W<var>d</var> = 0 &#13;
cset  X<var>d</var>, <var>cond</var>  // if(<var>cond</var>) then X<var>d</var> = 1 else X<var>d</var> = 0 &#13;
csetm W<var>d</var>, <var>cond</var>  // if(<var>cond</var>) then W<var>d</var> = -1 else W<var>d</var> = 0 &#13;
csetm X<var>d</var>, <var>cond</var>  // if(<var>cond</var>) then X<var>d</var> = -1 else X<var>d</var> = 0 </code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">cset</span> macro is equivalent to <span class="SANS_TheSansMonoCd_W5Regular_11">cinc</span> with WZR or XZR as both source operands, and <span class="SANS_TheSansMonoCd_W5Regular_11">csetm</span> is equivalent to <span class="SANS_TheSansMonoCd_W5Regular_11">cinv</span> with WZR or XZR as the source operands. These macros are useful for setting a register to a Boolean value (either true/–1 or false/0) based on the condition codes.</p>&#13;
<p class="TX">Finally, the ARM also supports two conditional compare instructions, <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">ccmn</span> (conditional compare negative), each with a few forms:</p>&#13;
<pre id="pre-441"><code>ccmp  W<var>d</var>, W<var>s</var>, #<var>nzcv4</var>, <var>cond</var> &#13;
ccmp  X<var>d</var>, X<var>s</var>, #<var>nzcv4</var>, <var>cond</var> &#13;
ccmp  W<var>d</var>, #imm5, #<var>nzcv4</var>, <var>cond</var> &#13;
ccmp  X<var>d</var>, #imm5, #<var>nzcv4</var>, <var>cond</var> &#13;
ccmn  W<var>d</var>, W<var>s</var>, #<var>nzcv4</var>, <var>cond</var> &#13;
ccmn  X<var>d</var>, X<var>s</var>, #<var>nzcv4</var>, <var>cond</var> &#13;
ccmn  W<var>d</var>, #imm5, #<var>nzcv4</var>, <var>cond</var> &#13;
ccmp  X<var>d</var>, #imm5, #<var>nzcv4</var>, <var>cond</var> </code></pre>&#13;
<p class="TX">Whereas <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> compares by subtracting the second operand from the first, <span class="SANS_TheSansMonoCd_W5Regular_11">ccmn</span> compares by adding the second operand to the first. These instructions test the provided condition (<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cond</span>). If it is false, these instructions copy the 4-bit immediate value <span class="SANS_TheSansMonoCd_W5Regular_11">#</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">nzcv4</span> directly into the condition codes (bit 3 to N, bit 2 to Z, bit 1 to C, and bit 0 to V).</p>&#13;
<p class="TX">If the condition specified by <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cond</span> is true, these instructions compare the destination register to the source operand (register or 5-bit unsigned immediate value) and set the condition code bits based on the comparison. As you’ll see later in this chapter, the conditional comparisons are useful for evaluating complex Boolean expressions.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h3 class="H1" id="sec6"><span id="h1-78"/><span class="SANS_Futura_Std_Bold_B_11">6.2 Memory Variables vs. Registers</span></h3>&#13;
<p class="TNI1">Before jumping into converting arithmetic expressions into assembly language statements, let’s also wrap up the discussion of variables from the last five chapters. As I’ve pointed out many times, the ARM is based on a load/store architecture. The ARM has been blessed with many general-purpose registers that you can use in lieu of memory locations for your more commonly used variables. With careful planning, you should be able to keep most of your often-used variables in registers.</p>&#13;
<p class="TX">Consider the following C/C++ statement and its conversion to ARM assembly language:</p>&#13;
<pre id="pre-442"><code>x = y * z;&#13;
&#13;
// Conversion to ARM assembly if x, y, and z are 32-bit&#13;
// memory variables in the .data section:&#13;
&#13;
lea  x0, y     // Remember, lea expands to two instructions.&#13;
ldr  w0, [x0]&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_300" aria-label="300"/>lea  x1, z&#13;
ldr  w1, [x1]&#13;
mul  w0, w0, w1&#13;
lea  x1, x&#13;
str  w0, [x1]</code></pre>&#13;
<p class="TX">If you keep <span class="SANS_TheSansMonoCd_W5Regular_11">x</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">z</span> in registers W19, W20, and W21, respectively, the translation of that expression into assembly language would be</p>&#13;
<pre id="pre-443"><code>mul x19, x20, x21</code></pre>&#13;
<p class="Continued1">which is one-tenth the size and much faster than the conversion just given.</p>&#13;
<p class="TX">On RISC CPUs like the ARM, it’s a much better idea to keep variables in registers rather than in memory. Your job as an assembly language programmer is to carefully choose the variables you keep in registers versus the (less often used) values you will have to maintain in memory. You can do this by counting the number of times you access a variable during execution and keep the most-frequently accessed variables in registers, leaving the least-frequently accessed variables in memory.</p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h2-108"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.2.1 Volatile vs. Nonvolatile Register Usage</span></h4>&#13;
<p class="TNI1">If you are adhering to the ARM ABI in your assembly code, you must also be cognizant of the difference between volatile and nonvolatile registers in your procedures. Using nonvolatile registers has a cost: if you modify a nonvolatile register’s value, you must preserve the register’s original value within a procedure. This generally involves allocating storage in the procedure’s activation record, storing the nonvolatile register’s value on entry to the procedure, and restoring the register’s value before returning.</p>&#13;
<p class="TX">Using volatile registers means you’re spared the expense and storage required to preserve them. However, volatile registers may have their contents disturbed if you make calls to other procedures, which aren’t known to explicitly preserve the volatile registers. Because it is the caller’s responsibility to preserve any volatile register contents across other function calls, you may as well use a nonvolatile register (assuming one is available) if you’re making calls to other functions within your procedures.</p>&#13;
<p class="TX">This assumes, of course, that the functions you’re calling adhere to the ARM ABI conventions. If, for example, you’re calling assembly language functions that preserve all register values they modify, you don’t have to worry about preserving those registers, even if the ARM ABI considers them volatile.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h4 class="H2" id="sec8"><span id="h2-109"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.2.2 Global vs. Local Variables</span></h4>&#13;
<p class="TNI1">If you have to use memory—because you don’t have sufficient register resources available or because you have a large data structure to manipulate that won’t fit in registers—you can locate the variables you must <span role="doc-pagebreak" epub:type="pagebreak" id="pg_301" aria-label="301"/>maintain in memory. You can put them in either a global, static data section (such as <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span>, and so on) or in an activation record you’ve created for your current procedure.</p>&#13;
<p class="TX">When you learned to program in an HLL, you were probably taught to avoid using global variables in your programs. That advice applies even more in ARM assembly language, especially when programming under macOS. Under macOS, as you’ve seen many times, accessing global data is more expensive than accessing local data in an activation record. To fetch a 32-bit variable from global (<span class="SANS_TheSansMonoCd_W5Regular_11">.data</span>) memory requires code such as the following:</p>&#13;
<pre id="pre-444"><code>lea x0, globalVariable // Remember, this is two instructions.&#13;
ldr w0, [x0]</code></pre>&#13;
<p class="TX">Fetching data from a local variable takes only a single instruction (assuming the variable’s offset into the activation record is relatively small):</p>&#13;
<pre id="pre-445"><code>ldr w0, [fp, #localVariable]</code></pre>&#13;
<p class="TX">That means accessing local variables takes one-third the number of instructions it takes to access global variables.</p>&#13;
<p class="TX">Of course, if you’re running under Linux and don’t need your assembly code to run under macOS as well, you can also access global variables by using a single instruction and the PC-relative addressing mode:</p>&#13;
<pre id="pre-446"><code>ldr w0, globalVariable</code></pre>&#13;
<p class="TX">Just keep in mind that the data must sit within ±1MB of this instruction. Blowing past this limit is pretty easy when writing larger applications.</p>&#13;
<p class="TX">Local variables are not without their own limitations. In general, the activation record has a limit of about ±256 bytes of storage, a little more if you can use the scaled-indirect-plus-offset addressing mode with half-word, word, and double-word variables. Fortunately, you’ll rarely surpass that number of bytes of scalar (non-array/nonstructure) variables in a single procedure. If you do require more space, you’ll have to compute the effective address of the variable within the activation record, which winds up taking as many instructions as accessing global variables.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-110"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.2.3 Easy Access to Global Variables</span></h4>&#13;
<p class="TNI1">To make it just as easy to access global variables in a <span class="SANS_TheSansMonoCd_W5Regular_11">.data</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">.bss</span> section as it is to access local variables within an activation record, you can create a static activation record. Local variables are easy to access because you use the indirect-plus-offset (or scaled indirect-plus-offset) addressing mode to index off the FP register. What if you had the equivalent of FP pointing into a static data section? Although the ARM doesn’t provide an SB (static base) register, nothing is stopping you from creating your own:</p>&#13;
<pre id="pre-447"><code>#define SB X28</code></pre>&#13;
<p class="Continued1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_302" aria-label="302"/>I chose to use X28 in this example, since it’s a nonvolatile register in the ARM ABI and is right below the FP (X29) register.</p>&#13;
<p class="TX">Listing 6-1 demonstrates using the SB register (X28) to efficiently access global variables.</p>&#13;
<pre id="pre-448"><code>// Listing6-1.S&#13;
//&#13;
// Demonstrate using X28 as a "static base"&#13;
// register to conveniently access global&#13;
// variables.&#13;
&#13;
        #include    "aoaa.inc"&#13;
&#13;
#define sb X28          // Use X28 for SB register.&#13;
&#13;
// Declaration of global variables:&#13;
&#13;
        struct  globals_t&#13;
        word    g1&#13;
        dword   g2&#13;
        hword   g3&#13;
        byte    g4,128&#13;
        ends    globals_t&#13;
&#13;
        .data&#13;
&#13;
        globals_t globals       // Global variables go here.&#13;
&#13;
        .text&#13;
        .pool&#13;
ttlStr: wastr  "Listing 6-1"&#13;
&#13;
        proc    getTitle, public&#13;
        lea     x0, ttlStr&#13;
        ret&#13;
        endp    getTitle&#13;
&#13;
        proc    asmMain, public&#13;
&#13;
        locals  am&#13;
        dword   saveSB             // Save X28 here.&#13;
        byte    stackSpace, 64     // Generic stack space&#13;
        endl    am&#13;
&#13;
        enter   am.size            // Reserve space for locals.&#13;
        str     sb, [fp, #saveSB]  // Preserve SB register.&#13;
        lea     sb, globals        // Initialize with address.&#13;
&#13;
        mov     w0, #55            // Just demonstrate the&#13;
        str     w0, [sb, #g1]      // use of the static&#13;
        add     x0, x0, #44        // base record in the&#13;
        str     x0, [sb, #g2]      // .data section.&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_303" aria-label="303"/>        and     w0, w0, #0xff&#13;
        strh    w0, [sb, #g3]&#13;
&#13;
        ldr     sb, [fp, #saveSB]  // Restore SB register.&#13;
        leave                      // Return to caller.&#13;
        endp    asmMain</code></pre>&#13;
<p class="TX">Keep in mind that the <span class="SANS_TheSansMonoCd_W5Regular_11">[sb, #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">offset</span>] addressing mode is limited to ±256 bytes (or up to 1KB when using the scaled indirect-plus-offset modes), so it’s best to keep nonscalar (composite) variables outside the static record.</p>&#13;
<p class="TX">As written, the <span class="SANS_TheSansMonoCd_W5Regular_11">globals</span> record in Listing 6-1 provides access to only 256 bytes of storage (because all the <span class="SANS_TheSansMonoCd_W5Regular_11">struct</span> field offsets are positive or 0). The following declaration starts the offsets at –256, providing an additional 256 bytes of storage in the static record:</p>&#13;
<pre id="pre-449"><code>struct  globals_t, -256&#13;
word    g1&#13;
dword   g2&#13;
hword   g3&#13;
byte    g4,128&#13;
ends    globals_t</code></pre>&#13;
<p class="TX">However, if you do this, you must adjust the value you load into SB appropriately, as shown here</p>&#13;
<pre id="pre-450"><code>lea sb, globals+256  // Initialize with address.</code></pre>&#13;
<p class="Continued1">so that SB will point into the correct place in the <span class="SANS_TheSansMonoCd_W5Regular_11">globals_t</span> structure.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h3 class="H1" id="sec10"><span id="h1-79"/><span class="SANS_Futura_Std_Bold_B_11">6.3 Arithmetic Expressions</span></h3>&#13;
<p class="TNI1">The biggest shock to beginners facing assembly language for the first time will likely be the lack of familiar arithmetic expressions. Arithmetic expressions in most HLLs look similar to their algebraic equivalents. For example, in C you could write the following algebraic-like statement:</p>&#13;
<pre id="pre-451"><code>x = y * z;</code></pre>&#13;
<p class="TX">In assembly language, you’ll need several statements to accomplish this same task if these variables are sitting in memory locations (assume they’re local variables):</p>&#13;
<pre id="pre-452"><code>ldr w0, [fp, #y]&#13;
ldr w1, [fp, #z]&#13;
mul w0, w0, w1&#13;
str w0, [fp, #x]&#13;
&#13;
// If you can keep x, y, and z in registers:&#13;
&#13;
mul x0, x1, x2  // Assume x = X0, y = X1, and z = X2.</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_304" aria-label="304"/>Obviously, the HLL version is much easier to type, read, and understand. Although a lot of typing is involved, converting an arithmetic expression into assembly language isn’t difficult. By attacking the problem in steps, the same way you would solve the problem by hand, you can easily break any arithmetic expression into an equivalent sequence of assembly language statements.</p>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-111"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.3.1 Simple Assignments</span></h4>&#13;
<p class="TNI1">The easiest expressions to convert to assembly language are <i>simple assignments</i>, which copy a single value into a variable and take one of two forms:</p>&#13;
<pre id="pre-453"><code><var>variable</var> = <var>constant</var></code></pre>&#13;
<p class="Continued1">or</p>&#13;
<pre id="pre-454"><code><var>var1</var> = <var>var2</var></code></pre>&#13;
<p class="TX">If your variables are sitting in registers, converting these statements to assembly language is simple:</p>&#13;
<pre id="pre-455"><code>mov <var>variable</var>, #<var>constant</var>  // Assumption: constant fits in 16 bits.&#13;
mov <var>var1</var>, <var>var2</var></code></pre>&#13;
<p class="TX">This <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction copies the source constant or register into the destination register.</p>&#13;
<p class="TX">If the constant is too large, you’ll either have to use the <span class="SANS_TheSansMonoCd_W5Regular_11">movk</span> sequence (see section 2.20.2, <span class="Xref">“</span><span class="SANS_TheSansMonoCd_W5Regular_11">movk</span><span class="Xref">,” on <a href="chapter2.xhtml#pg_112">page 112</a></span>) or the constant form of <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span>:</p>&#13;
<pre id="pre-456"><code>ldr <var>register</var>, =<var>constant</var></code></pre>&#13;
<p class="TX">If the source variable is in memory, you must use the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction to fetch the data from memory, as shown in the following examples:</p>&#13;
<pre id="pre-457"><code>ldr <var>register</var>, [fp, #<var>offset</var>]  // Assuming a local variable&#13;
ldr <var>register</var>, [sb, #<var>offset</var>]  // Assuming variable is in static record&#13;
&#13;
lea <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">64</span>, <var>GlobalVariable</var>     // Global variable in arbitrary memory&#13;
ldr <var>register</var>, [<var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">64</span>]</code></pre>&#13;
<p class="TX">If the destination is a memory variable, you must first load the source variable or constant into a register (if it isn’t already in a register) and use the <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> instruction to store the value into the memory variable:</p>&#13;
<pre id="pre-458"><code>str <var>register</var>, [fp, #<var>offset</var>]&#13;
str <var>register</var>, [sb, #<var>offset</var>]&#13;
&#13;
lea <var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">64</span>, <var>GlobalVariable</var>&#13;
str <var>register</var>, [<var>reg</var><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">64</span>]</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_305" aria-label="305"/>Clearly, the most efficient code occurs when both variables are in a register or the destination is a register and the source value is a small constant, in which case a single <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction suffices.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-112"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.3.2 Simple Expressions</span></h4>&#13;
<p class="TNI1">The next level of complexity is a <i>simple expression</i>, which takes the form</p>&#13;
<pre id="pre-459"><code><var>var1</var> = <var>term1 op term2</var>;</code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">var1</span> is a variable, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">term1</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">term2</span> are variables or constants, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">op</span> is an arithmetic operator (addition, subtraction, multiplication, and so on). Most expressions take this form. It should come as no surprise, then, that the ARM architecture was optimized for just this type of expression.</p>&#13;
<p class="TX">Assuming <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">var1</span>, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">term1</span>, and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">term2</span> are all in registers, a typical conversion for this type of expression takes the form</p>&#13;
<pre id="pre-460"><code><var>op</var>  <var>var1</var>, <var>term1</var>, <var>term2</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">op</span> is the mnemonic that corresponds to the specified operation (for example, + is <span class="SANS_TheSansMonoCd_W5Regular_11">add</span>, – is <span class="SANS_TheSansMonoCd_W5Regular_11">sub</span>, and so forth).</p>&#13;
<p class="TX">Note that the simple expression</p>&#13;
<pre id="pre-461"><code><var>var1</var> = <var>const1</var> op <var>const2</var>;</code></pre>&#13;
<p class="Continued1">is easily handled with a compile-time expression and a single <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span> instruction. For example, to compute</p>&#13;
<pre id="pre-462"><code><var>var1</var> = 5 + 3;</code></pre>&#13;
<p class="Continued1">you would use the single instruction:</p>&#13;
<pre id="pre-463"><code>mov <var>var1</var>, #5 + 3</code></pre>&#13;
<p class="TX">If <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">term2</span> is a (small enough) constant, you can typically use an instruction of the following form:</p>&#13;
<pre id="pre-464"><code><var>op</var>  <var>var1</var>, <var>term1</var>, #<var>constant</var></code></pre>&#13;
<p class="TX">Exceptions exist, however. Certain instructions, such as <span class="SANS_TheSansMonoCd_W5Regular_11">mul</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">udiv</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">sdiv</span>, do not allow immediate operands. In such cases, you’ll need to use the two instructions</p>&#13;
<pre id="pre-465"><code><var>mov someReg</var>, #<var>constant</var>&#13;
<var>op</var>  <var>var1</var>, <var>term1</var>, <var>someReg</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">someReg</span> is an available temporary register.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_306" aria-label="306"/>If <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">term1</span> is a constant and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">term2</span> is a register, you can get away with simply swapping the two source operands in the instruction for commutative operations. For example</p>&#13;
<pre id="pre-466"><code>x0 = 25 + x1;</code></pre>&#13;
<p class="Continued1">becomes this:</p>&#13;
<pre id="pre-467"><code>add x0, x1, #25</code></pre>&#13;
<p class="TX">For noncommutative operations, such as subtraction and division, this scheme doesn’t work. You may have to load the constant into a register prior to the operation.</p>&#13;
<p class="TX">Of course, if the constant is too large (generally 12 bits for arithmetic instructions), you’ll have to first load that constant into a register by using the <span class="SANS_TheSansMonoCd_W5Regular_11">mov</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">movk</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instructions.</p>&#13;
<p class="TX">If your terms are memory variables rather than registers (or constants), you will need to use the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction to move the memory variable(s) into register(s) prior to the operation. Likewise, if the destination variable is in memory, you will have to use a <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> instruction to store the value after the operation is complete. For example</p>&#13;
<pre id="pre-468"><code>x = y + z;  // x, y, and z are all 32-bit memory variables.</code></pre>&#13;
<p class="Continued1">becomes this:</p>&#13;
<pre id="pre-469"><code>ldr w0, [fp, #y]   // Assuming y is a local variable&#13;
ldr w1, [sb, #z]   // Assuming z is in the static base record&#13;
add w2, w0, w1&#13;
lea x3, globalVar  // Assuming globalVar is a global variable&#13;
str w2, [x3]       // in the .data section</code></pre>&#13;
<p class="TX">Here are some examples of common simple expressions (assume <span class="SANS_TheSansMonoCd_W5Regular_11">x</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">z</span> are in W0, W1, and W2):</p>&#13;
<pre id="pre-470"><code>// x = y + z;  // Signed or unsigned&#13;
&#13;
          add w0, w1, w2&#13;
&#13;
// x = y - z;  // Signed or unsigned&#13;
&#13;
          sub w0, w1, w2&#13;
&#13;
// x = y * z;  // Signed or unsigned&#13;
&#13;
          mul w0, w1, w2&#13;
&#13;
// x = y / z;  // Unsigned div&#13;
&#13;
          udiv w0, w1, w2&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_307" aria-label="307"/>// x = y / z;  // Signed div&#13;
&#13;
          sdiv w0, w1, w2&#13;
&#13;
// x = y % z;  // Unsigned remainder&#13;
&#13;
          udiv  x0, x1, x2&#13;
          msub  x0, x0, x2, x1&#13;
&#13;
// x = y % z;  // Signed remainder&#13;
&#13;
          sdiv  x0, x1, x2&#13;
          msub  x0, x0, x2, x1</code></pre>&#13;
<p class="TX">If any of the operands are memory variables, you will first have to load them into registers by using the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction. If any operands are constants, follow the guidelines from the previous section.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
&#13;
<h4 class="H2" id="sec13"><span id="h2-113"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.3.3 Complex Expressions</span></h4>&#13;
<p class="TNI1">A <i>complex expression</i> is any arithmetic expression involving more than two terms and one operator. Such expressions are commonly found in programs written in an HLL. Complex expressions may include parentheses to override operator precedence, function calls, array accesses, and so on. This section outlines the rules for converting such expressions.</p>&#13;
<p class="TX">Complex expressions that are easy to convert to assembly language involve three terms and two operators. Here’s an example:</p>&#13;
<pre id="pre-471"><code>w = w - y - z;</code></pre>&#13;
<p class="TX">Clearly, the straightforward assembly language conversion of this statement requires two <span class="SANS_TheSansMonoCd_W5Regular_11">sub</span> instructions. However, even with an expression as simple as this, the conversion is not trivial. You can convert the preceding statement into assembly language in two ways (assume <span class="SANS_TheSansMonoCd_W5Regular_11">w</span> is in W0, <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> is in W1, and <span class="SANS_TheSansMonoCd_W5Regular_11">z</span> is in W2):</p>&#13;
<pre id="pre-472"><code>sub w0, w0, w1&#13;
sub w0, w0, w2</code></pre>&#13;
<p class="Continued1">or</p>&#13;
<pre id="pre-473"><code>sub w3, w1, w2&#13;
sub w0, w0, w3</code></pre>&#13;
<p class="TX">Both methods can produce different results, with the first conversion largely adhering to C language semantics. The problem is associativity. The second sequence in the preceding example computes <span class="SANS_TheSansMonoCd_W5Regular_11">w = w - (y - z)</span>, which is not the same as <span class="SANS_TheSansMonoCd_W5Regular_11">w = (w - y) - z</span>. The placement of the parentheses around the subexpressions can affect the result.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_308" aria-label="308"/><i>Precedence</i>, the order in which operations occur, is another issue. Consider this expression:</p>&#13;
<pre id="pre-474"><code>x = w * y + z;</code></pre>&#13;
<p class="TX">Once again, you can evaluate this expression in one of two ways:</p>&#13;
<pre id="pre-475"><code>x = (w * y) + z;</code></pre>&#13;
<p class="Continued1">or</p>&#13;
<pre id="pre-476"><code>x = w * (y + z);</code></pre>&#13;
<p class="TX">By now, you’re probably thinking that this explanation is crazy—everyone knows the correct way to evaluate these expressions is to use the former form. However, this isn’t always correct. The APL programming language, for example, evaluates expressions solely from right to left and does not give one operator precedence over another. The “correct” method depends entirely on how you define precedence in your arithmetic system.</p>&#13;
<p class="TX">Consider this expression:</p>&#13;
<pre id="pre-477"><code>x <var>op1</var> y <var>op2</var> z</code></pre>&#13;
<p class="TX">If <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">op1</span> takes precedence over <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">op2</span>, this evaluates to <span class="SANS_TheSansMonoCd_W5Regular_11">(x</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">op1</span> <span class="SANS_TheSansMonoCd_W5Regular_11">y)</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">op2</span> <span class="SANS_TheSansMonoCd_W5Regular_11">z</span><i>.</i> Otherwise, if <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">op2</span> takes precedence over <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">op1</span>, the expression evaluates to <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">op1</span> <span class="SANS_TheSansMonoCd_W5Regular_11">(y</span> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">op2</span> <span class="SANS_TheSansMonoCd_W5Regular_11">z)</span>. Depending on the operators and operands involved, these two computations could produce different results.</p>&#13;
<p class="TX">Most HLLs use a fixed set of precedence rules to describe the order of evaluation in an expression involving two or more different operators. Such programming languages usually compute multiplication and division before addition and subtraction. Those that support exponentiation (for example, FORTRAN and BASIC) usually compute that before multiplication and division. These rules are intuitive because most people learn them before high school.</p>&#13;
<p class="TX">When converting expressions into assembly language, you must be sure to compute the subexpression with the highest precedence first. The following example demonstrates this technique (assuming multiplication has higher precedence than addition):</p>&#13;
<pre id="pre-478"><code>// w = x + y * z;  // Assume w = W0, x = W1, y = W2, and z = W3.&#13;
&#13;
mul w4, w2, w3  // W4 = W2 * W3&#13;
add w0, w1, w4  // W0 = W1 + (W2 * W3)</code></pre>&#13;
<p class="TX">If two operators appearing within an expression have the same precedence, use the associativity rules to determine the order of evaluation. Most operators are <i>left-associative</i>, meaning that they evaluate from left to right. Addition, subtraction, multiplication, and division are all left-associative. A <i>right-associative</i> operator evaluates from right to left. The exponentiation <span role="doc-pagebreak" epub:type="pagebreak" id="pg_309" aria-label="309"/>operator in FORTRAN is a good example of a right-associative operator. For instance:</p>&#13;
<pre id="pre-479"><code>2**2**3</code></pre>&#13;
<p class="Continued1">is equal to</p>&#13;
<pre id="pre-480"><code>2**(2**3)</code></pre>&#13;
<p class="Continued1">not</p>&#13;
<pre id="pre-481"><code>(2**2)**3</code></pre>&#13;
<p class="TX">The precedence and associativity rules determine the order of evaluation. Indirectly, these rules tell you where to place parentheses in an expression to determine the order of evaluation. Of course, you can always use parentheses to override the default precedence and associativity. However, the ultimate point is that your assembly code must complete certain operations before others to correctly compute the value of a given expression. The following examples demonstrate this principle:</p>&#13;
<pre id="pre-482"><code>// w = x - y - z  // Assume w = W0, x = W1, y = W2, and z = W3.&#13;
&#13;
sub  w0, w1, w2  // Evaluate from left to right.&#13;
sub  w0, w0, w3  // W0 = (x - y) - z&#13;
&#13;
// w = x + y * z&#13;
&#13;
mul  w0, w2, w3  // Must compute y * z first.&#13;
add  w0, w0, w1  // W0 = (W2 * W3) + W1  (commutative)</code></pre>&#13;
<p class="Continued1">or, even better</p>&#13;
<pre id="pre-483"><code>madd w0, w2, w3, w1  // W0 = (W2 * W3) + W1&#13;
&#13;
// w = x / y - z&#13;
&#13;
sdiv w0, w1, w2  // Division has highest precedence.&#13;
sub  w0, w0, w3  // W0 = (W1 / W2) - W3&#13;
&#13;
// w = x * y * z&#13;
&#13;
mul  w0, w1, w2  // Commutative, so order doesn't matter.&#13;
mul  w0, w0, w3</code></pre>&#13;
<p class="TX">The associativity rule has one exception: if an expression involves multiplication and division, it is generally better to perform the multiplication first. For example, given an expression of the form</p>&#13;
<pre id="pre-484"><code>w = x / y * z;  // Note: this is (x / y) * z, not x / (y * z).</code></pre>&#13;
<p class="Continued1"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_310" aria-label="310"/>it is usually better to compute <span class="SANS_TheSansMonoCd_W5Regular_11">x * z</span> and then divide the result by <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>, rather than dividing <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> by <span class="SANS_TheSansMonoCd_W5Regular_11">y</span> and multiplying the quotient by <span class="SANS_TheSansMonoCd_W5Regular_11">z</span>. Doing the multiplication first increases the accuracy of the computation. Remember, (integer) division often produces an inexact result. For example, if you compute 5 / 2, you will get the value 2, not 2.5. Computing (5 / 2) × 3 produces 6. However, computing (5 × 3) / 2 gives you the value 7, which is a little closer to the real quotient (7.5).</p>&#13;
<p class="TX">Therefore, if you encounter an expression of the form</p>&#13;
<pre id="pre-485"><code>w = x / y * z;  // Assume w = W0, x = W1, y = W2, and z = W3.</code></pre>&#13;
<p class="Continued1">you can usually convert it to the following assembly code:</p>&#13;
<pre id="pre-486"><code>mul  w0, w1, w3   // w = x * z&#13;
sdiv w0, w0, w2   // w = (x * z) / y</code></pre>&#13;
<p class="TX">If the multiplication will likely produce an overflow, computing the division operation first may be better.</p>&#13;
<p class="TX">If the algorithm you’re encoding depends on the truncation effect of the division operation, you cannot use this trick to improve the algorithm. The moral of the story is that you should always make sure you fully understand any expression you are converting to assembly language. If the semantics dictate that you must perform the division first, do so.</p>&#13;
<p class="TX">Consider the following statement:</p>&#13;
<pre id="pre-487"><code>w = x - y * z;  // Assume w = W0, x = W1, y = W2, and z = W3.</code></pre>&#13;
<p class="TX">Because subtraction is not commutative, you cannot compute <span class="SANS_TheSansMonoCd_W5Regular_11">y * x</span> and then subtract <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> from this result. Rather than use a straightforward multiplication-and-subtraction sequence, you’ll have to use a temporary register to hold the product. For example, the following two instructions use W4 as a temporary:</p>&#13;
<pre id="pre-488"><code>mul  w4, w2, w3  // temp = y * z&#13;
sub  w0, w1, w4  // w = x - (y * z)</code></pre>&#13;
<p class="TX">As your expressions increase in complexity, the need for temporaries grows. Consider the following C statement:</p>&#13;
<pre id="pre-489"><code>w = (a + bb) * (y + z);</code></pre>&#13;
<p class="TX">Following the normal rules of algebraic evaluation, compute the subexpressions inside the parentheses first (that is, the two subexpressions with the highest precedence) and set their values aside. When you’ve computed the values for both subexpressions, you can compute their product. One way to deal with a complex expression like this is to reduce it to a sequence of simple expressions whose results wind up in temporary variables. For example, you can convert the preceding single expression into the following sequence:</p>&#13;
<pre id="pre-490"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_311" aria-label="311"/>temp1 = a + bb;&#13;
temp2 = y + z;&#13;
w = temp1 * temp2;</code></pre>&#13;
<p class="TX">Since converting simple expressions to assembly language is easy, it’s now a snap to compute the former complex expression in assembly, as shown in the following code:</p>&#13;
<pre id="pre-491"><code>// Assume w = W0, y = W1, z = W2, a = W3, and bb = W4.&#13;
&#13;
add  w5, w3, w4  // temp1 (W5) = a + bb&#13;
add  w6, w1, w2  // temp2 (W6) = y + z&#13;
mul  w0, w5, w6  // w = temp1 * temp2</code></pre>&#13;
<p class="TX">Here’s yet another example of a complex arithmetic conversion:</p>&#13;
<pre id="pre-492"><code>x = (y + z) * (a - bb) / 10;</code></pre>&#13;
<p class="TX">You can convert this to a set of four simple expressions:</p>&#13;
<pre id="pre-493"><code>temp1 = (y + z)&#13;
temp2 = (a - bb)&#13;
temp1 = temp1 * temp2&#13;
x = temp1 / 10</code></pre>&#13;
<p class="TX">You can convert these four expressions into the following assembly language statements:</p>&#13;
<pre id="pre-494"><code>// Assume x = W0, y = W1, z = W2, a = W3, and bb = W4.&#13;
&#13;
add  w5, w1, w2  // temp1 (W5) = y + z&#13;
sub  w6, w3, w4  // temp2 (W6) = a - bb&#13;
mul  w5, w5, w6  // temp1 = temp1 * temp2&#13;
mov  w6, #10     // Need a temp to hold constant 10.&#13;
sdiv w0, w5, w6  // x = temp1 / 10</code></pre>&#13;
<p class="TX">Most important, make sure you keep temporary values in registers for efficiency. Use memory locations to hold temporaries only if you’ve run out of registers.</p>&#13;
<p class="TX">In short, as you’ve seen, converting a complex expression to assembly language is a little different from solving the expression by hand. Instead of computing the result at each stage of the computation, you write the assembly code that computes the result.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
&#13;
<h4 class="H2" id="sec14"><span id="h2-114"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.3.4 Commutative Operators</span></h4>&#13;
<p class="TNI1">If <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">op</span> represents an operator, that operator is <i>commutative</i> if the following relationship is always true:</p>&#13;
<pre id="pre-495"><code>(A <var>op</var> B) = (B <var>op</var> A)</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_312" aria-label="312"/>As you learned in the previous section, commutative operators are easy to translate because the order of their operands is immaterial, which lets you rearrange a computation, often making it easier or more efficient. Often, rearranging a computation allows you to use fewer temporary variables. Whenever you encounter a commutative operator in an expression, check whether you can use a better sequence to improve the size or speed of your code.</p>&#13;
<p class="TX"><a href="chapter6.xhtml#tab6-3">Table 6-3</a> lists the commutative operators typically found in HLLs.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab6-3"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 6-3:</span></span> <span class="SANS_Futura_Std_Book_11">Commutative Dyadic (Two-Operand) Operators</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Pascal</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">C/C++ and similar</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">+</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">+</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Addition</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">*</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">*</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Multiplication</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">and</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</span> <span class="SANS_Futura_Std_Book_11">or</span> <span class="SANS_TheSansMonoCd_W5Regular_11">&amp;</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Logical or bitwise AND</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">or</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">||</span> <span class="SANS_Futura_Std_Book_11">or</span> <span class="SANS_TheSansMonoCd_W5Regular_11">|</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Logical or bitwise OR</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">xor</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">^</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Logical or bitwise exclusive-OR</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">=</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">==</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Equality</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&lt;&gt;</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">!=</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Inequality</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><a href="chapter6.xhtml#tab6-4">Table 6-4</a> lists many of the noncommutative operators.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab6-4"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 6-4:</span></span> <span class="SANS_Futura_Std_Book_11">Noncommutative Dyadic Operators</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Pascal</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">C/C++ and similar</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">-</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">-</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Subtraction</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">/</span> <span class="SANS_Futura_Std_Book_11">or</span> <span class="SANS_TheSansMonoCd_W5Regular_11">div</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">/</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Division</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">mod</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">%</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Remainder (modulo)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&lt;</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&lt;</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Less than</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&lt;=</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&lt;=</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Less than or equal</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&gt;</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&gt;</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Greater than</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&gt;=</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&gt;=</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Greater than or equal</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">If you encounter any other operator types, check the associated HLL definition for the operators to determine whether they are commutative or noncommutative and determine their precedence and associativity.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1" id="sec15"><span id="h1-80"/><span class="SANS_Futura_Std_Bold_B_11">6.4 Logical Expressions</span></h3>&#13;
<p class="TNI1">Consider the following logical (Boolean) expression from a C/C++ program:</p>&#13;
<pre id="pre-496"><code>bb = ((x == y) &amp;&amp; (a &lt;= c)) || ((z - a) != 5);</code></pre>&#13;
<p class="Continued1">Here, <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span> is a Boolean variable, and the remaining variables are all integers.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_313" aria-label="313"/>Though it takes only a single bit to represent a Boolean value, most assembly language programmers allocate a whole byte or even a word to represent Boolean variables. Most programmers (and, indeed, some programming languages like C) choose 0 to represent <i>false</i> and anything else to represent <i>true</i>. Some people prefer to represent true and false with 1 and 0, respectively, and not allow any other values. Others select all 1 bits (0xFFFF_FFFF_FFFF_FFFF, 0xFFFF_FFFF, 0xFFFF, or 0xFF) for true and 0 for false. You could also use a positive value for true and a negative value for false.</p>&#13;
<p class="TX">All these mechanisms have their advantages and drawbacks. Using only 0 and 1 to represent false and true offers two big advantages. First, the <span class="SANS_TheSansMonoCd_W5Regular_11">cset</span> instruction produces this result, so this scheme is compatible with that instruction. Second, the ARM logical instructions (<span class="SANS_TheSansMonoCd_W5Regular_11">and</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">orr</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">eor</span>, and, to a lesser extent, <span class="SANS_TheSansMonoCd_W5Regular_11">mvn</span>) operate on these values exactly as you would expect. If you have two Boolean variables <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span>, the following instructions perform the basic logical operations on these two variables:</p>&#13;
<pre id="pre-497"><code>// d = a AND bb;  // Assume d = W0, a = W1, and bb = W2.&#13;
&#13;
and w0, w1, w2&#13;
&#13;
// d = a || bb;&#13;
&#13;
orr w0, w1, w2&#13;
&#13;
// d = a XOR bb;&#13;
&#13;
eor w0, w1, w2&#13;
&#13;
// bb = NOT a;&#13;
//&#13;
// (NOT 0) does not equal 1.&#13;
// The AND instruction corrects this problem.&#13;
&#13;
mvn w2, w1&#13;
and w2, w2, #1&#13;
&#13;
// Here's an alternative solution (for NOT) using EOR:&#13;
&#13;
eor w2, w1, #1  // Inverts bit 0</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">mvn</span> instruction will not properly compute logical negation. The bitwise NOT of 0 is 0xFF (assuming a byte value), and the bitwise NOT of 1 is 0FEh. Neither result is 0 or 1. However, ANDing the result with 1 gives you the proper result. You can implement the NOT operation more efficiently by using the <span class="SANS_TheSansMonoCd_W5Regular_11">eor</span> instruction (as shown in the last <span class="SANS_TheSansMonoCd_W5Regular_11">eor</span> example just given) because it affects only the LO bit.</p>&#13;
<p class="TX">Using 0 for false and anything else for true has a lot of subtle advantages. The test for true or false is often implicit in the execution of any logical instruction. However, this mechanism has a major downside: you <span role="doc-pagebreak" epub:type="pagebreak" id="pg_314" aria-label="314"/>cannot always use the ARM <span class="SANS_TheSansMonoCd_W5Regular_11">and</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">orr</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">eor</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">mvn</span> instructions to implement the Boolean operations of the same name. Consider the two values 0x55 and 0xAA. They’re both nonzero, so they both represent the value true. However, if you logically AND 0x55 and 0xAA together using the ARM <span class="SANS_TheSansMonoCd_W5Regular_11">and</span> instruction, the result is 0. True AND true should produce true, not false. Although you can account for situations like this, it usually requires a few extra instructions and is somewhat less efficient when computing Boolean operations.</p>&#13;
<p class="TX">A system that uses nonzero values to represent true and 0 to represent false is an <i>arithmetic logical system</i>. A system that uses two distinct values like 0 and 1 to represent false and true is called a <i>Boolean logical system</i>, or simply a Boolean system. You can use either system as convenient. Consider this Boolean expression:</p>&#13;
<pre id="pre-498"><code>bb = ((x == y) and (a &lt;= d)) || ((z - a) != 5);</code></pre>&#13;
<p class="TX">The resulting simple expressions might be as follows:</p>&#13;
<pre id="pre-499"><code>// Assume bb = W0, x = W1, y = W2, a = W3, d = W4, and z = W5.&#13;
&#13;
cmp  w1, w2&#13;
cset w6, eq      // temp1 (W6) = x == y&#13;
&#13;
cmp  w3, w4&#13;
cset w7, le      // temp2 (W7) = a &lt;= d&#13;
and  w6, w6, w7  // temp1 = (x == y) &amp;&amp; (a &lt;= d)&#13;
&#13;
sub  w7, w5, w3  // temp2 = z - a&#13;
cmp  w7, #5&#13;
cset w7, ne      // temp2 = (z - a) != 5&#13;
&#13;
orr  w0, w6, w7  // W0 = temp1 || temp2</code></pre>&#13;
<p class="TX">When working with Boolean expressions, don’t forget that you might be able to optimize your code by simplifying it with algebraic transformations. In <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>, you’ll also see how to use control flow to calculate a Boolean result, which can be a bit more efficient than using the methods taught by the examples in this section.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
&#13;
<h3 class="H1" id="sec16"><span id="h1-81"/><span class="SANS_Futura_Std_Bold_B_11">6.5 Conditional Comparisons and Boolean Expressions</span></h3>&#13;
<p class="TNI1">The conditional comparison instruction, <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span>, is quite useful for encoding complex Boolean expressions in assembly language. Consider the following Boolean expression:</p>&#13;
<pre id="pre-500"><code>bb = (x == y) &amp;&amp; (a &lt;= d)</code></pre>&#13;
<p class="TX">Using the logic from the previous section, you could translate this into the following assembly language code:</p>&#13;
<pre id="pre-501"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_315" aria-label="315"/>// Assume bb = W0, x = W1, y = W2, a = W3, and d = W4.&#13;
&#13;
cmp  w1, w2&#13;
cset w5, eq   // temp1 (W5) = x == y&#13;
&#13;
cmp  w3, w4&#13;
cset w6, le   // temp2 (W6) = a &lt;= d&#13;
and  w0, w5, w6   // bb = (x == y) &amp;&amp; (a &lt;= d)</code></pre>&#13;
<p class="TX">By using the conditional comparison instruction, you can keep the temporary values in the condition code flags to shorten your code:</p>&#13;
<pre id="pre-502"><code>cmp  w1, w2&#13;
ccmp w3, w4, #0, eq&#13;
cset w0, le</code></pre>&#13;
<p class="TX">The first <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instruction sets the Z flag if <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> is equal to <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>. If that condition is false, the whole logical expression must return false. If it’s true, this code has to test whether <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> is less than or equal to <span class="SANS_TheSansMonoCd_W5Regular_11">d</span>.</p>&#13;
<p class="TX">Assuming that <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> does not equal <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>, the Z flag will be clear after the first <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instruction. In that case, the <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction will not compare W3 (<span class="SANS_TheSansMonoCd_W5Regular_11">a</span>) to W4 (<span class="SANS_TheSansMonoCd_W5Regular_11">d</span>) but will load the flags with 0b0000 instead (because the <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction compares only the first two operands if the condition, <span class="SANS_TheSansMonoCd_W5Regular_11">eq</span>, is true; at this point, it is not). Because all the flags are clear (meaning N == V and Z != 1), the <span class="SANS_TheSansMonoCd_W5Regular_11">le</span> condition for the <span class="SANS_TheSansMonoCd_W5Regular_11">cset</span> is false; therefore, that instruction will store a 0 into W0 (<span class="SANS_TheSansMonoCd_W5Regular_11">bb</span>), exactly what you want.</p>&#13;
<p class="TX">On the other hand, if <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> is equal to <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>, the <span class="SANS_TheSansMonoCd_W5Regular_11">eq</span> condition for the <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction will be true and will compare the value of W3 (<span class="SANS_TheSansMonoCd_W5Regular_11">a</span>) to W4 (<span class="SANS_TheSansMonoCd_W5Regular_11">d</span>). If <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> is less than or equal to <span class="SANS_TheSansMonoCd_W5Regular_11">d</span>, the N, V, and Z flags will be set in such a way that the <span class="SANS_TheSansMonoCd_W5Regular_11">cset</span> instruction moves a 1 into W0. Otherwise, <span class="SANS_TheSansMonoCd_W5Regular_11">cset</span> will move a 0 into W0, which is again exactly what you want. This sequence with only three instructions does the work of the earlier sequence with five instructions, a huge win.</p>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
&#13;
<h4 class="H2" id="sec17"><span id="h2-115"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.5.1 Implementing Conjunction Using ccmp</span></h4>&#13;
<p class="TNI1">Consider this C/C++ logical expression:</p>&#13;
<pre id="pre-503"><code>(a <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> bb) &amp;&amp; (c <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> d)</code></pre>&#13;
<p class="TX">In general, to convert this expression containing the logical conjunction operator (<span class="SANS_TheSansMonoCd_W5Regular_11">&amp;&amp;</span>) into ARM assembly using conditional comparison instructions, you would use the following five steps:</p>&#13;
<div class="top">&#13;
<p class="ListNumber">  1.  Compare the operands on the left-hand side of the conjunction operator, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> (see <a href="chapter6.xhtml#tab6-5">Table 6-5</a>).</p>&#13;
<p class="ListNumber">  2.  Immediately after the first comparison, execute a <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction, supplying <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> as the conditional field.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_316" aria-label="316"/>&#13;
<p class="ListNumber">  3.  Choose the corresponding <span class="SANS_TheSansMonoCd_W5Regular_11">#</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">nzcv</span> encoding from the opposite column in <a href="chapter6.xhtml#tab6-5">Table 6-5</a> to match <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>. The full <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction should be:</p>&#13;
</div>&#13;
<pre id="pre-504"><code>ccmp c, d, #<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">nzcv</span><span class="TheSansMonoCd_W5Regular_SUB">op</span>, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span></code></pre>&#13;
<div class="top">&#13;
<p class="ListNumber">  4.  The last instruction in the sequence should test <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>, as in the following example:</p>&#13;
</div>&#13;
<pre id="pre-505"><code>cset x0, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span></code></pre>&#13;
<div class="top">&#13;
<p class="ListNumber">  5.  If <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> fails, the <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction will set the flags to the <span class="SANS_TheSansMonoCd_W5Regular_11">#</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">nzcv</span><span class="SANS_TheSansMonoCd_W5Regular_SUB_11">op</span> value and not compare <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> against <span class="SANS_TheSansMonoCd_W5Regular_11">d</span>. Since you want the Boolean expression to yield false in this situation, choose an <span class="SANS_TheSansMonoCd_W5Regular_11">#</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">nzcv</span><span class="SANS_TheSansMonoCd_W5Regular_SUB_11">op</span> value that is the opposite of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> so that the following test (for example, <span class="SANS_TheSansMonoCd_W5Regular_11">cset</span>) produces a false result. If <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> is true upon executing the <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction, <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> will compare <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> and set the flags.</p>&#13;
</div>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab6-5"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 6-5:</span></span> <span class="SANS_Futura_Std_Book_11">Conditional Operators, Opposites, and NZCV Settings</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">C/C++</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Operator</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_TheSansMonoCd_W7Bold_11">#</span><span class="SANS_TheSansMonoCd_W7Bold_Italic_11">nzcv</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Opposite</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_TheSansMonoCd_W7Bold_11">#</span><span class="SANS_TheSansMonoCd_W7Bold_Italic_11">nzcv</span><span class="SANS_TheSansMonoCd_W7Bold_SUB_11">op</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">==</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">eq</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0100</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ne</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0000</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">!=</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ne</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0000</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">eq</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0100</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&gt;</span> <span class="SANS_Futura_Std_Book_11">(unsigned)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">hi</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0010</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ls</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0100</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&gt;=</span> <span class="SANS_Futura_Std_Book_11">(unsigned)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">hs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0110</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">lo</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0000</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&lt;</span> <span class="SANS_Futura_Std_Book_11">(unsigned)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">lo</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0000</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">hs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0110</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&lt;=</span> <span class="SANS_Futura_Std_Book_11">(unsigned)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ls</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0100</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">hi</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0010</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&gt;</span> <span class="SANS_Futura_Std_Book_11">(signed)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">gt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0000</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">le</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0101</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&gt;=</span> <span class="SANS_Futura_Std_Book_11">(signed)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ge</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0100</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">lt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0001</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&lt;</span> <span class="SANS_Futura_Std_Book_11">(signed)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">lt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0001</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ge</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0100</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">&lt;=</span> <span class="SANS_Futura_Std_Book_11">(signed)</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">le</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0101</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">gt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0000</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Same as</span> <span class="SANS_TheSansMonoCd_W5Regular_11">hs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">cs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0010</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">cc</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0000</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Same as</span> <span class="SANS_TheSansMonoCd_W5Regular_11">lo</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">cc</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0000</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">cs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0010</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">N/A</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">vs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0001</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">vc</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0000</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">N/A</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">vc</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0000</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">vs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0001</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">N/A</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">mi</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b1000</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">pl</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0000</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">N/A</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">pl</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0000</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">mi</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b1000</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Because keeping the flag settings for the third <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> operand straight in your mind is difficult and error-prone, the <i>aoaa.inc</i> include file contains several defines to make it easy to choose these values, as well as some defines for opposite conditions. <a href="chapter6.xhtml#tab6-6">Table 6-6</a> lists these defines and their values.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_317" aria-label="317"/>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab6-6"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 6-6:</span></span> <span class="SANS_Futura_Std_Book_11">NZCV Constant Defines</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Condition</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Define</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Value</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">eq</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">cceq</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0100 (nZcv)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ne</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccne</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0000 (nzcv)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">hi</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">cchi</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0010 (nzCv)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">hs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">cchs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0110 (nZCv)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">lo</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">cclo</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0000 (nzcv)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ls</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccls</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0100 (nZcv)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">gt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccgt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0000 (nzcv)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ge</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccge</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0100 (nZcv)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">lt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">cclt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0001 (nzcV)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">le</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccle</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0101 (nZcV)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">cs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">cccs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0010 (nzCv)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">cc</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">cccc</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0000 (nzcv)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">vs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccvs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0001 (nzcV)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">vc</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccvc</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0000 (nzcV)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">mi</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccmi</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b1000 (Nzcv)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">pl</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccpl</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0b0000 (nzcv)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><a href="chapter6.xhtml#tab6-7">Table 6-7</a> lists some common antonyms (opposite conditions).</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab6-7"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 6-7:</span></span> <span class="SANS_Futura_Std_Book_11">NZCV Antonym Constants</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Condition</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Define</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Same as</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Not</span> <span class="SANS_TheSansMonoCd_W5Regular_11">hi</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccnhi</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccls</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Not</span> <span class="SANS_TheSansMonoCd_W5Regular_11">hs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccnhs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">cclo</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Not</span> <span class="SANS_TheSansMonoCd_W5Regular_11">lo</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccnlo</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">cchs</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Not</span> <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccnls</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">cchi</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Not</span> <span class="SANS_TheSansMonoCd_W5Regular_11">gt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccngt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccle</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Not</span> <span class="SANS_TheSansMonoCd_W5Regular_11">ge</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccnge</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">cclt</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Not</span> <span class="SANS_TheSansMonoCd_W5Regular_11">lt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccnlt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccge</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Not</span> <span class="SANS_TheSansMonoCd_W5Regular_11">le</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccnle</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ccgt</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Using these symbols instead of constants for the immediate <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction operand can make your code easier to read and understand.</p>&#13;
<p class="TX">Sometimes specifying the opposite condition in one of the conditional instructions can create confusion. It’s easy to think that the opposite of “less than” is “greater than” when it’s actually “greater than or equal,” for example. To help reduce this confusion, the <i>aoaa.inc</i> include file also provides defines for several opposite conditions, as listed in <a href="chapter6.xhtml#tab6-8">Table 6-8</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_318" aria-label="318"/>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab6-8"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 6-8:</span></span> <span class="SANS_Futura_Std_Book_11">Opposite Condition Defines</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Condition</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Opposite define</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">lo</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">nlo</span> <span class="SANS_Futura_Std_Book_11">(same as</span> <span class="SANS_TheSansMonoCd_W5Regular_11">hs</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ls</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">nls</span> <span class="SANS_Futura_Std_Book_11">(same as</span> <span class="SANS_TheSansMonoCd_W5Regular_11">hi</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">hi</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">nhi</span> <span class="SANS_Futura_Std_Book_11">(same as</span> <span class="SANS_TheSansMonoCd_W5Regular_11">ls</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">hs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">nhs</span> <span class="SANS_Futura_Std_Book_11">(same as</span> <span class="SANS_TheSansMonoCd_W5Regular_11">lo</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">gt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ngt</span> <span class="SANS_Futura_Std_Book_11">(same as</span> <span class="SANS_TheSansMonoCd_W5Regular_11">le</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">ge</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">nge</span> <span class="SANS_Futura_Std_Book_11">(same as</span> <span class="SANS_TheSansMonoCd_W5Regular_11">lt</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">lt</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">nlt</span> <span class="SANS_Futura_Std_Book_11">(same as</span> <span class="SANS_TheSansMonoCd_W5Regular_11">ge</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">le</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">nle</span> <span class="SANS_Futura_Std_Book_11">(same as</span> <span class="SANS_TheSansMonoCd_W5Regular_11">gt</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">By using the <i>aoaa.inc</i> definitions, you can make your code easier to read and understand.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
&#13;
<h4 class="H2" id="sec18"><span id="h2-116"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.5.2 Implementing Disjunction Using ccmp</span></h4>&#13;
<p class="TNI1">The conditional comparison can also be used to simulate disjunction (logical OR). Consider the following expression:</p>&#13;
<pre id="pre-506"><code>bb = (x == y) || (a &lt;= d)</code></pre>&#13;
<p class="TX">Here’s the translation of this expression to assembly language:</p>&#13;
<pre id="pre-507"><code>cmp  w1, w2&#13;
ccmp w3, w4, #0b0100, ne  // 0b0100 is .Z.. or use #cceq&#13;
cset w0, le               // or #ccle</code></pre>&#13;
<p class="TX">Notice how the conditional compare instruction tests for the not equal condition. If <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> is equal to <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>, you don’t need to do this comparison. In that case, the <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction will load 0b0100 into the condition codes, which sets Z to 1 and clears all the other flags. When the <span class="SANS_TheSansMonoCd_W5Regular_11">cset</span> instruction tests for less than or equal, the equal condition (Z = 1) exists, setting W0 (<span class="SANS_TheSansMonoCd_W5Regular_11">bb</span>) to 1. Comparing <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> plays no role in the computation of <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span>’s value.</p>&#13;
<p class="TX">If <span class="SANS_TheSansMonoCd_W5Regular_11">x</span> does not equal <span class="SANS_TheSansMonoCd_W5Regular_11">y</span>, the <span class="SANS_TheSansMonoCd_W5Regular_11">ne</span> condition will exist when the program executes the <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction. Therefore, <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> will compare <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> and set the condition code bits on the basis of that comparison. At that point, the <span class="SANS_TheSansMonoCd_W5Regular_11">cset</span> instruction will set <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span>’s value based on the comparison of <span class="SANS_TheSansMonoCd_W5Regular_11">a</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">d</span>.</p>&#13;
<p class="TX">The following algorithm describes how to convert an expression containing disjunction into ARM assembly language using a conditional comparison:</p>&#13;
<pre id="pre-508"><code>(a <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> bb) || (c <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> d)</code></pre>&#13;
<p class="Continued1">Here are the four steps to follow for this conversion:</p>&#13;
<div class="top">&#13;
<p class="ListNumber">  1.  Compare the operands on the left-hand side of the disjunction operator (operator is <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_319" aria-label="319"/>&#13;
<p class="ListNumber">  2.  Immediately after the first <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> instruction, execute a <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction, supplying the opposite of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> as the conditional field (return to <a href="chapter6.xhtml#tab6-5">Table 6-5</a> to find the opposite conditions).</p>&#13;
<p class="ListNumber">  3.  Choose the corresponding <span class="SANS_TheSansMonoCd_W5Regular_11">#nzcv</span> encoding from the regular column in <a href="chapter6.xhtml#tab6-5">Table 6-5</a> to match <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>. The full <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction should be as follows:</p>&#13;
</div>&#13;
<pre id="pre-509"><code>ccmp c, d, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">#nzcv</span>, opposite(<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">1</span>)</code></pre>&#13;
<div class="top">&#13;
<p class="ListNumber">  4.  The last instruction in the sequence should test <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">2</span>. For example:</p>&#13;
</div>&#13;
<pre id="pre-510"><code>cset x0, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="TheSansMonoCd_W5Regular_Italic_SUB_11">2</span></code></pre>&#13;
<p class="TX">If <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> succeeds, the <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction will set the flags to the #<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">nzcv</span><span class="SANS_TheSansMonoCd_W5Regular_SUB_11">op</span> value and not compare <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> against <span class="SANS_TheSansMonoCd_W5Regular_11">d</span>, because you’ve chosen the opposite of <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> for the <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> condition. As you want the Boolean expression to yield true in this situation, choose an #<span class="SANS_TheSansMonoCd_W5Regular_Italic_11">nzcv</span><span class="SANS_TheSansMonoCd_W5Regular_SUB_11">op</span> value that is the same as <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">2</span> so that the following test (for example, <span class="SANS_TheSansMonoCd_W5Regular_11">cset</span>) produces a true result. If <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cc</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_SUB_11">1</span> is false upon executing the <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction, <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> will compare <span class="SANS_TheSansMonoCd_W5Regular_11">c</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">d</span> and set the flags appropriate for the following test.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
&#13;
<h4 class="H2" id="sec19"><span id="h2-117"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.5.3 Handling Complex Boolean Expressions</span></h4>&#13;
<p class="TNI1">You can extend the Boolean expressions by adding additional <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instructions to the sequence. Just keep in mind that, at least in C/C++, conjunction has higher precedence than disjunction, so you must modify your order of evaluation to handle conjunction first when expressions contain both operators.</p>&#13;
<p class="TX">Also note that the <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> scheme uses <i>complete Boolean evaluation</i> (meaning it evaluates every subterm of the Boolean expression), whereas the C++ programming language uses <i>short-circuit Boolean evaluation</i> (which may not compute all subterms). <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span> covers these two forms in greater detail, but for now, just know that the two forms may produce different results.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
&#13;
<h3 class="H1" id="sec20"><span id="h1-82"/><span class="SANS_Futura_Std_Bold_B_11">6.6 Machine and Arithmetic Idioms</span></h3>&#13;
<p class="TNI1">An <i>idiom</i> is an idiosyncrasy (a peculiarity). Several arithmetic operations and ARM instructions have idiosyncrasies that you can take advantage of when writing assembly language code. Some people refer to the use of machine and arithmetic idioms as <i>tricky programming</i> that you should always avoid in well-written programs. While it is wise to avoid tricks just for the sake of tricks, many machine and arithmetic idioms are well known and commonly found in assembly language programs. This section provides an overview of the idioms you’ll see most often.</p>&#13;
<section epub:type="division" aria-labelledby="sec21">&#13;
&#13;
<h4 class="H2" id="sec21"><span id="h2-118"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.6.1 Multiplying Without mul</span></h4>&#13;
<p class="TNI1">When multiplying by a constant, you can sometimes write equivalent code by using shifts, additions, and subtractions in place of multiplication <span role="doc-pagebreak" epub:type="pagebreak" id="pg_320" aria-label="320"/>instructions. Although performance differs little between using a <span class="SANS_TheSansMonoCd_W5Regular_11">mul</span> instruction and other arithmetic instructions, some addressing mode variants involving shifts can spare you an extra multiply instruction.</p>&#13;
<p class="TX">Remember, a <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span> instruction computes the same result as multiplying the specified operand by 2. Shifting to the left two bit positions multiplies the operand by 4. Shifting to the left three bit positions multiplies the operand by 8. In general, shifting an operand to the left <i>n</i> bits multiplies it by 2<i><sup>n</sup></i>. You can multiply any value by a constant by using a series of shifts and additions or shifts and subtractions. For example, to multiply the W0 register by 10, you need only multiply it by 8 and then add 2 times the original value. That is, 10 × W0 = 8 × W0 + 2 × W0. Use the following code to accomplish this:</p>&#13;
<pre id="pre-511"><code>lsl w0, w0, #1          // W0 = W0 * 2&#13;
add w0, w0, w0, lsl #2  // W0 = (W0 * 2) + (W0 * 8)</code></pre>&#13;
<p class="Continued1">The first instruction multiplies W0 by 2, so when the second instruction shifts W0 2 bits to the left, it’s actually shifting the original W0 value to the left by 3 bits.</p>&#13;
<p class="TX">Looking at the instruction timings, you’ll see that the multiply instruction executes at the same speed as the <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">add</span> instructions, so this second sequence isn’t faster. However, if you have to load the constant 10 into a register to do the multiplication by 10, this sequence is no slower. If you’ve already done the shift as part of another calculation, this sequence could turn out to be faster.</p>&#13;
<p class="TX">You can also use subtraction with shifts to perform a multiplication operation. Consider the following multiplication by 7:</p>&#13;
<pre id="pre-512"><code>sub w0, w0, w0, lsl #3  // Actually computes W0 * (-7)&#13;
neg w0, w0              // Fix sign.</code></pre>&#13;
<p class="TX">Beginning assembly language programmers commonly make the error of subtracting or adding 1 or 2 rather than W0 × 1 or W0 × 2. The following does not compute W0 × 7:</p>&#13;
<pre id="pre-513"><code>lsl w0, w0, #3&#13;
sub w0, w0, #1</code></pre>&#13;
<p class="TX">Rather, this code computes (8 × W0) – 1, which is entirely different (unless, of course, W0 = 1). Beware of this pitfall when using shifts, additions, and subtractions to perform multiplication operations.</p>&#13;
<p class="TX">The Operand2 addressing mode variations, particularly those involving <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span>, are quite useful for combining shifts along with other arithmetic operations. For example, consider the following pair of instructions:</p>&#13;
<pre id="pre-514"><code>lsl w0, w0, #3&#13;
add w1, w1, w0</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_321" aria-label="321"/>You can easily replace this by a single instruction:</p>&#13;
<pre id="pre-515"><code>add w1, w1, w0, lsl #3</code></pre>&#13;
<p class="TX">Because RISC CPUs, such as the ARM, tend to execute most instructions in a single CPU clock cycle, using <i>strength-reduction optimizations</i> like substituting shifts and adds for multiplication rarely pays off. Generally, a single shift instruction (for a multiplication by a power of 2) may produce better results than <span class="SANS_TheSansMonoCd_W5Regular_11">mul</span>; beyond that, it’s unlikely to improve the speed, unless you need those shifts and adds for other calculations.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec22">&#13;
&#13;
<h4 class="H2" id="sec22"><span id="h2-119"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.6.2 Dividing Without sdiv or udiv</span></h4>&#13;
<p class="TNI1">Just as the <span class="SANS_TheSansMonoCd_W5Regular_11">lsl</span> instruction is useful for simulating a multiplication by a power of 2, the <span class="SANS_TheSansMonoCd_W5Regular_11">lsr</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">asr</span> instructions can simulate a division by a power of 2. Unfortunately, you cannot easily use shifts, additions, and subtractions to perform division by an arbitrary constant. Therefore, this trick is useful only when dividing by powers of 2. Also, don’t forget that the <span class="SANS_TheSansMonoCd_W5Regular_11">asr</span> instruction rounds toward negative infinity, unlike the <span class="SANS_TheSansMonoCd_W5Regular_11">sdiv</span> instruction, which rounds toward 0.</p>&#13;
<p class="TX">On the ARM64 CPU, the division instructions tend to take about twice as long as other instructions to execute. Therefore, if you can simulate a division by a power of 2 by using a single shift-right instruction, your code will run a little faster. You can also divide by a value by multiplying by its reciprocal. This is usually faster than division, since the multiply instruction is faster than the divide instruction.</p>&#13;
<p class="TX">To multiply by a reciprocal when dealing with integers, you must cheat. If you want to multiply by 1/10, there is no way you can load the value 1/10 into an ARM integer register prior to performing the multiplication. It won’t work to multiply 1/10 by 10, perform the multiplication, and divide the result by 10 to get the final result. In fact, this would make performance worse, because you’re now doing a multiplication by 10 as well as a division by 10. However, suppose you multiply 1/10 by 65,536 (6,554), perform the multiplication, and then divide by 65,536. Consider the following code that divides W0 by 10:</p>&#13;
<pre id="pre-516"><code>mov w1, #6554&#13;
mul w0, w0, w1&#13;
lsr w0, w0, #16  // Division by 65,536</code></pre>&#13;
<p class="TX">This code leaves W0 / 10 in the W0 register. To understand how this works, consider what happens when you use the <span class="SANS_TheSansMonoCd_W5Regular_11">mul</span> instruction to multiply W0 by 65,536 (0x1_0000). This moves the LO half word of W0 into the HO half word and sets the LO half word to 0 (a multiplication by 0x1_0000 is equivalent to a shift left by 16 bits). Multiplying by 6,554 (65,536 divided by 10) puts W0 divided by 10 into the HO half word of the W0 register.</p>&#13;
<p class="TX">Multiplying by a reciprocal works well only when dividing by a constant, such as 10. While you could coerce the calculation with multiple instructions to divide a register by a nonconstant value, the <span class="SANS_TheSansMonoCd_W5Regular_11">udiv</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">sdiv</span> instructions <span role="doc-pagebreak" epub:type="pagebreak" id="pg_322" aria-label="322"/>would certainly be faster by that point; it’s questionable whether multiplying by a reciprocal is faster than a division.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec23">&#13;
&#13;
<h4 class="H2" id="sec23"><span id="h2-120"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.6.3 Implementing Modulo-N Counters with AND</span></h4>&#13;
<p class="TNI1">To implement a counter variable that counts up to 2<i><sup>n</sup></i> – 1 and then resets to 0, use the following code</p>&#13;
<pre id="pre-517"><code>add w0, w0, #1&#13;
and w0, w0, #<var>nBits</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">nBits</span> is a binary value containing <i>n</i> bits of 1s right-justified in the number. For example, to create a counter that cycles from 0 to 15 (2<sup>4</sup> – 1), you could use the following:</p>&#13;
<pre id="pre-518"><code>add w0, w0, #1&#13;
and w0, w0, #0b1111</code></pre>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec24">&#13;
&#13;
<h4 class="H2" id="sec24"><span id="h2-121"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.6.4 Avoiding Needlessly Complex Machine Idioms</span></h4>&#13;
<p class="TNI1">The machine idioms you’ve just learned work well to improve performance on older complex instruction set computers (CISCs) that typically take a varying number of CPU clock cycles to execute each instruction. Complex instructions like division can take upward of 50 clock cycles on an x86 CPU, for example. RISC CPUs, such as the ARM, try to execute instructions in one clock cycle. While the ARM doesn’t always achieve this (<span class="SANS_TheSansMonoCd_W5Regular_11">sdiv</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">udiv</span> are a little slower, for example), the additional time required doesn’t justify replacing the instruction with a long sequence of other instructions.</p>&#13;
<p class="TX">Using machine idioms makes your code harder to read and understand. If using a machine idiom offers no clear performance benefit, stick with using easier-to-understand code. Those who work on your project afterward (including yourself, in the future) will thank you.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec25">&#13;
&#13;
<h3 class="H1" id="sec25"><span id="h1-83"/><span class="SANS_Futura_Std_Bold_B_11">6.7 Floating-Point and Finite-Precision Arithmetic</span></h3>&#13;
<p class="TNI1">Before discussing how the ARM CPU implements floating-point arithmetic, it is worthwhile to first describe the mathematical theory behind floating-point arithmetic and the problems you will encounter when using it. This section presents a simplified model to explain floating-point arithmetic and why you cannot apply standard algebraic rules to calculations involving it.</p>&#13;
<section epub:type="division" aria-labelledby="sec26">&#13;
&#13;
<h4 class="H2" id="sec26"><span id="h2-122"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.7.1 Basic Floating-Point Terminology</span></h4>&#13;
<p class="TNI1">Integer arithmetic does not let you represent fractional numeric values. Therefore, modern CPUs support an approximation of <i>real</i> arithmetic: <i>floating-point arithmetic</i>. To represent real numbers, most floating-point formats employ scientific notation and use a certain number of bits to represent a mantissa and a smaller number of bits to represent an exponent.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_323" aria-label="323"/>For example, in the number 3.456e+12, the mantissa consists of 3.456, and the exponent digits are 12. Because the number of bits is fixed in computer-based representations, computers can represent only a certain number of digits (known as <i>significant digits</i>) in the mantissa. For example, if a floating-point representation could handle only three significant digits, then the fourth digit in 3.456e+12 (the 6) could not be accurately represented with that format, as three significant digits can represent only 3.45e+12 or 3.46e+12 correctly.</p>&#13;
<p class="TX">Because computer-based floating-point representations also use a finite number of bits to represent the exponent, that exponent also has a limited range of values, approximately ranging from 10 <sup>± 38</sup> for the single-precision format to about 10 <sup>± 308</sup> for the double-precision format. This is known as the <i>dynamic range</i> of the value. Denormalized numbers (which I’ll define shortly) can represent values as small as ±4.94066 × 10<sup>–324</sup>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec27">&#13;
&#13;
<h4 class="H2" id="sec27"><span id="h2-123"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.7.2 Limited-Precision Arithmetic and Accuracy</span></h4>&#13;
<p class="TNI1">A big problem with floating-point arithmetic is that it does not follow the standard rules of algebra. Normal algebraic rules apply only to <i>infinite-precision</i> arithmetic. Therefore, if you translate an algebraic formula into code, that code might produce different results from what you would (mathematically) expect. This can introduce defects in your software.</p>&#13;
<p class="TX">Consider the simple statement <i>x</i> = <i>x</i> + 1, where <i>x</i> is an integer. On any modern computer, this statement follows the normal rules of algebra <i>as long as overflow does not occur.</i> That is, this statement is valid only for certain values of <i>x</i> (<i>minint</i> ≤ <i>x</i> &lt; <i>maxint</i>). Most programmers do not have a problem with this because they are well aware that integers in a program do not follow the standard algebraic rules (for example, 5 / 2 does not equal 2.5).</p>&#13;
<p class="TX">Integers do not follow the standard rules of algebra because the computer represents them with a finite number of bits. You cannot represent any of the (integer) values above the maximum integer or below the minimum integer. Floating-point values suffer from this same problem, only worse. After all, integers are a subset of real numbers. Therefore, the floating-point values must represent the same infinite set of integers. However, an infinite number of real values exist between any two integer values. In addition to having to limit your values between a maximum and minimum range, you cannot represent all the values between any pair of integers either.</p>&#13;
<p class="TX">To demonstrate the impact of limited-precision arithmetic, this chapter adopts a simplified decimal floating-point format for our examples. This format provides a mantissa with three significant digits and a decimal exponent with two digits. The mantissa and exponents are both signed values, as shown in <a href="chapter6.xhtml#fig6-1">Figure 6-1</a>.</p>&#13;
<figure class="IMG"><img class="img4" id="fig6-1" src="../images/Figure6-1.jpg" alt="" width="481" height="67"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 6-1: A floating-point format</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_324" aria-label="324"/>When adding and subtracting two numbers in scientific notation, you must adjust the two values so that their exponents are the same. Multiplication and division don’t require the exponents to be the same; instead, the exponent after a multiplication is the sum of the two operand exponents, and the exponent after a division is the difference of the dividend and divisor’s exponents.</p>&#13;
<p class="TX">For example, when adding 1.2e1 and 4.5e0, you must adjust the values so that they have the same exponent. One way to do this is to convert 4.5e0 to 0.45e1 and then add, producing 1.65e1. Because the computation and result require only three significant digits, you can compute the correct result via the representation shown in <a href="chapter6.xhtml#fig6-1">Figure 6-1</a>.</p>&#13;
<p class="TX">However, suppose you want to add the two values 1.23e1 and 4.56e0. Although both values can be represented using the three-significant-digit format, the computation and result do not fit into three significant digits. That is, 1.23e1 + 0.456e1 requires four digits of precision in order to compute the correct result of 1.686, so you must either <i>round</i> or <i>truncate</i> the result to three significant digits. Rounding generally produces the most accurate result, so round the result to obtain 1.69e1.</p>&#13;
<p class="TX">In fact, the rounding does not occur after adding the two values together (that is, producing the sum 1.686e1 and then rounding this to 1.69e1), but rather when converting 4.56e0 to 0.456e1, because four digits of precision are required to maintain the value 0.456e1. Therefore, during the conversion, you have to round 0.456e1 to 0.46e1 so that the result fits into three significant digits. The sum of 1.23e1 and 0.46e1 then produces the final rounded sum of 1.69e1.</p>&#13;
<p class="TX">As you can see, the lack of <i>precision</i> (the number of digits or bits maintained in a computation) affects the <i>accuracy</i> (the correctness of the computation). In the addition/subtraction example, you could round the result because you maintained four significant digits <i>during</i> the calculation (specifically, when converting 4.56e0 to 0.456e1). If your floating-point calculation had been limited to three significant digits during computation, you would have had to truncate the last digit of the smaller number, obtaining 0.45e1 and producing a sum of 1.68e1, a value that is even less accurate.</p>&#13;
<p class="TX">To improve the accuracy of floating-point calculations, it is useful to maintain one or more extra digits for use during the calculation, such as the extra digit used to convert 4.56e0 to 0.456e1. Extra digits available during a computation are known as <i>guard digits</i> (or <i>guard bits</i> in the case of a binary format). They greatly enhance accuracy during a long chain of computations.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec28">&#13;
&#13;
<h4 class="H2" id="sec28"><span id="h2-124"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.7.3 Errors in Floating-Point Calculations</span></h4>&#13;
<p class="TNI1">In a sequence of floating-point operations, errors can accumulate and greatly affect the computation itself. For example, suppose you were to add 1.23e3 to 1.00e0. Adjusting the numbers so their exponents are the same before the addition produces 1.23e3 + 0.001e3. The sum of these two values, even after rounding, is 1.23e3. This might seem perfectly reasonable; <span role="doc-pagebreak" epub:type="pagebreak" id="pg_325" aria-label="325"/>after all, you can maintain only three significant digits, so adding in a small value shouldn’t affect the result at all.</p>&#13;
<p class="TX">However, suppose you were to add 1.00e0 to 1.23e3 <i>ten times</i> (though not in the same calculation, where guard digits could maintain the fourth digit during the calculation). The first time you add 1.00e0 to 1.23e3, you get 1.23e3. You get this same result the second, third, fourth ... and tenth times you add 1.00e0 to 1.23e3. On the other hand, had you added 1.00e0 to itself 10 times, then added the result (1.00e1) to 1.23e3, you would have gotten a different result, 1.24e3. Keep in mind this important guideline for limited-precision arithmetic:</p>&#13;
<blockquote>&#13;
<p class="ExtractPara">When performing complex operations, watch the order of evaluation, as it can affect the accuracy of the result.</p>&#13;
</blockquote>&#13;
<p class="TX">You’ll get more accurate results if the relative magnitudes (the exponents) are close to one another when adding and subtracting floating-point values. If you’re performing a chain calculation involving addition and subtraction, attempt to group the values appropriately.</p>&#13;
<p class="TX">When computing addition and subtraction, you can also wind up with <i>false precision</i>. Consider the computation 1.23e0 – 1.22e0, which produces 0.01e0. Although the result is mathematically equivalent to 1.00e – 2, this latter form suggests that the last two digits are exactly 0. Unfortunately, you have only a single significant digit at this time (remember, the original result was 0.01e0, and those two leading 0s were significant digits). Indeed, some floating-point unit (FPU) or software packages might actually insert random digits (or bits) into the LO positions. This highlights a second important rule concerning limited-precision arithmetic:</p>&#13;
<blockquote>&#13;
<p class="ExtractPara">When subtracting two numbers with the same signs (or adding two numbers with different signs), be aware that the result may contain high-order significant digits (bits) that are 0. This reduces the number of significant digits (bits) by a like amount in the final result. If possible, try to arrange your calculations to avoid this.</p>&#13;
</blockquote>&#13;
<p class="TX">By themselves, multiplication and division do not produce particularly poor results. However, they tend to multiply any error that already exists in a value. For example, if you multiply 1.23e0 by 2 when you should be multiplying 1.24e0 by 2, the result is even less accurate. This leads to a third important rule for working with limited-precision arithmetic:</p>&#13;
<blockquote>&#13;
<p class="ExtractPara">When performing a chain of calculations involving addition, subtraction, multiplication, and division, try to perform the multiplication and division operations first.</p>&#13;
</blockquote>&#13;
<p class="TX">Often, by applying normal algebraic transformations, you can arrange a calculation so the multiply and divide operations occur first. For example, suppose you want to compute <i>x</i> <span class="SANS_TheSansMonoCd_W5Regular_11">* (</span><i>y</i> <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> <i>z</i><span class="SANS_TheSansMonoCd_W5Regular_11">)</span>. Normally, you would add <i>y</i> and <i>z</i> together and multiply their sum by <i>x</i>. However, your results will be a little more accurate if you transform <i>x</i> <span class="SANS_TheSansMonoCd_W5Regular_11">* (</span><i>y</i> <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> <i>z</i><span class="SANS_TheSansMonoCd_W5Regular_11">)</span> to get <i>x</i> <span class="SANS_TheSansMonoCd_W5Regular_11">*</span> <i>y</i> <span class="SANS_TheSansMonoCd_W5Regular_11">+</span> <i>x</i> <span class="SANS_TheSansMonoCd_W5Regular_11">*</span> z and compute the result by performing the multiplications first. Of course, the drawback <span role="doc-pagebreak" epub:type="pagebreak" id="pg_326" aria-label="326"/>is that you must now perform two multiplications rather than one, so the result may be slower.</p>&#13;
<p class="TX">Multiplication and division have their own problems. When multiplying two very large or very small numbers, it is quite possible for <i>overflow</i> or <i>underflow</i> to occur. The same situation occurs when dividing a small number by a large number, or dividing a large number by a small (fractional) number. This brings us to a fourth rule to follow when multiplying or dividing values:</p>&#13;
<blockquote>&#13;
<p class="ExtractPara">When multiplying and dividing sets of numbers, try to arrange the multiplications so that they multiply large and small numbers together; likewise, try to divide numbers that have the same relative magnitudes.</p>&#13;
</blockquote>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec29">&#13;
&#13;
<h4 class="H2" id="sec29"><span id="h2-125"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.7.4 Floating-Point Value Comparisons</span></h4>&#13;
<p class="TNI1">Given the inaccuracies present in any computation (including converting an input string to a floating-point value), you should <i>never</i> compare two floating-point values to see if they are equal. In a binary floating-point format, different computations that produce the same (mathematical) result may differ in their least significant bits. For example, 1.31e0 + 1.69e0 should produce 3.00e0. Likewise, 1.50e0 + 1.50e0 should also produce 3.00e0. However, if you were to compare (1.31e0 + 1.69e0) against (1.50e0 + 1.50e0), you might find out that these sums are <i>not</i> equal to each other.</p>&#13;
<p class="TX">The test for equality succeeds if and only if all bits (or digits) in the two operands are exactly the same. Because this is not necessarily true after two different floating-point computations that should produce the same result, a straight test for equality may not work. Instead, use the following test:</p>&#13;
<pre id="pre-519"><code>if <var>Value1</var> &gt;= (<var>Value2</var> - <var>error</var>) and <var>Value1</var> &lt;= (<var>Value2</var> + <var>error</var>) then ...</code></pre>&#13;
<p class="TX">Another common way to handle this same comparison is to use a statement of this form:</p>&#13;
<pre id="pre-520"><code>if abs(<var>Value1</var> - <var>Value2</var>) &lt;= <var>error</var> then ...</code></pre>&#13;
<p class="TX">In these statements, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">error</span> should be a value slightly greater than the largest amount of error that will creep into your computations. The exact value will depend on the particular floating-point format you use. In short, follow this final rule:</p>&#13;
<blockquote>&#13;
<p class="ExtractPara">When comparing two floating-point numbers, always compare one value to see whether it is in the range given by the second value plus or minus a small error value.</p>&#13;
</blockquote>&#13;
<p class="TX">Many other little problems can occur when using floating-point values. This book points out only some of the major problems and will make you aware that you cannot treat floating-point arithmetic like real arithmetic because of the inaccuracies present in limited-precision arithmetic. A good text on numerical analysis or even scientific computing can help fill in the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_327" aria-label="327"/>details. If you plan to work with floating-point arithmetic in any language, take the time to study the effects of limited-precision arithmetic on your computations (see section 6.13, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="chapter6.xhtml#pg_352">page 352</a></span>).</p>&#13;
<p class="TX">Now that you’ve seen the theory behind floating-point arithmetic, we’ll review the ARM’s implementation of floating-point.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec30">&#13;
&#13;
<h3 class="H1" id="sec30"><span id="h1-84"/><span class="SANS_Futura_Std_Bold_B_11">6.8 Floating-Point Arithmetic on the ARM</span></h3>&#13;
<p class="TNI1">When the ARM CPU was first designed, floating-point arithmetic was among the set of “complex” instructions that RISC CPUs avoided. Those who required floating-point arithmetic were forced to implement it in software. As time passed, it became clear that high-performance systems required fast floating-point arithmetic, so it was added to the ARM’s instruction set.</p>&#13;
<p class="TX">The ARM64 supports the IEEE single- and double-precision floating-point formats (see section 2.13, <span class="Xref">“IEEE Floating-Point Formats,”</span> on <span class="Xref"><a href="chapter2.xhtml#pg_93">page 93</a></span>), as well as a 16-bit half-precision floating-point format that appeared in later revisions of the IEEE standard. To support floating-point arithmetic, the ARM provides an extra set of registers and augments the instruction set with suitable floating-point instructions. Originally, these types of instructions were handled by coprocessors—separate chips that handled floating-point instructions (while the main CPU handled integer operations). In the ARM64 architecture, the FPU is built into the main CPU’s integrated circuit.</p>&#13;
<p class="TX">The following subsections introduce the floating-point register set, the floating-point status register, and the floating-point control register. These are the programmer-visible components of the floating-point hardware on the ARM CPU.</p>&#13;
<section epub:type="division" aria-labelledby="sec31">&#13;
&#13;
<h4 class="H2" id="sec31"><span id="h2-126"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.8.1 Neon Registers</span></h4>&#13;
<p class="TNI1">To support floating-point arithmetic, the ARM64 provides a second set of 32 registers specifically tailored to hold floating-point and other values. These are known as the <i>Neon registers</i> because, in addition to supporting scalar floating-point (FP) arithmetic, they also support vector arithmetic using the Neon instruction set extensions, covered in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>.</p>&#13;
<p class="TX">The 32 main FP/Neon registers are 128 bits each. Just as the general-purpose registers are divided into two sets based on their size (W<i>n</i> and X<i>n</i>), the FP/Neon registers are broken into five groups based on their size:</p>&#13;
<div class="top">&#13;
<p class="RunInPara20"><b>V0 to V31</b>    The 128-bit <i>vector</i> registers (for Neon instructions), also referenced as Q0 to Q31, the qword registers. The V<i>n</i> names support special syntax for vector operations.</p>&#13;
<p class="RunInPara20"><b>D0 to D31</b>    The 64-bit <i>double-precision</i> floating-point registers.</p>&#13;
<p class="RunInPara20"><b>S0 to S31</b>     The 32-bit <i>single-precision</i> floating-point registers.</p>&#13;
<p class="RunInPara20"><b>H0 to H31</b>    The 16-bit <i>half-precision</i> floating-point registers.</p>&#13;
<p class="RunInPara20"><b>B0 to B31</b>    The 8-bit <i>byte</i> registers.</p>&#13;
</div>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_328" aria-label="328"/>In addition to the 32 main registers, this set includes two special-purpose floating-point registers: the floating-point status register (FPSR) and the floating-point control register (FPCR), shown in <a href="chapter6.xhtml#fig6-2">Figure 6-2</a>. You’ll learn more about these registers in the following subsections.</p>&#13;
<figure class="IMG"><img class="img7" id="fig6-2" src="../images/Figure6-2.jpg" alt="" width="629" height="1641"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 6-2: The FP/Neon registers</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The B<i>n</i>, H<i>n</i>, S<i>n</i>, D<i>n</i>, and V<i>n</i> registers overlay one another, as shown in <a href="chapter6.xhtml#fig6-3">Figure 6-3</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_329" aria-label="329"/>&#13;
<figure class="IMG"><img class="img7" id="fig6-3" src="../images/Figure6-3.jpg" alt="" width="1006" height="268"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 6-3: The FP/Neon register overlays</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">For historical reasons, the even-numbered single-precision registers (S0, S2, ..., S30) are mapped to bits 0 through 31 in D0 through D15, and the odd-numbered single-precision registers are mapped to bits 32 through 64. No S<i>n</i> registers are mapped to D16 through D31 (see <a href="chapter6.xhtml#fig6-4">Figure 6-4</a>).</p>&#13;
<figure class="IMG"><img class="img7" id="fig6-4" src="../images/Figure6-4.jpg" alt="" width="619" height="1483"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 6-4: How S</span><span class="SANS_Futura_Std_Book_11">n</span> <span class="SANS_Futura_Std_Book_Oblique_11">registers overlay D</span><span class="SANS_Futura_Std_Book_11">n</span> <span class="SANS_Futura_Std_Book_Oblique_11">registers</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The following sections concentrate mainly on the D<i>n</i> and S<i>n</i> register sets. This book doesn’t discuss half-precision floating-point arithmetic in <span role="doc-pagebreak" epub:type="pagebreak" id="pg_330" aria-label="330"/>depth, as it’s used mainly by graphics processing units (GPUs) and certain graphics routines. The floating-point hardware doesn’t actually work with half-precision values—it only allows you to convert between half- and single- or double-precision values.</p>&#13;
<p class="TX">Most of the ARM floating-point instructions operate on the D<i>n</i> or S<i>n</i> registers. This chapter collectively refers to these registers as F<i>n</i>, meaning you can substitute any double- or single-precision register for F<i>n</i>. I will also note exceptions as needed. Vector registers (V<i>n</i>) are the subject of <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec32">&#13;
&#13;
<h4 class="H2" id="sec32"><span id="h2-127"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.8.2 Control Register</span></h4>&#13;
<p class="TNI1">The <i>floating-point control register (FPCR)</i> specifies how certain floating-point operations take place. Although this register is 32 bits, only 6 bits are used, as you can see in <a href="chapter6.xhtml#fig6-5">Figure 6-5</a>.</p>&#13;
<figure class="IMG"><img class="img1" id="fig6-5" src="../images/Figure6-5.jpg" alt="" width="1645" height="309"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 6-5: The FPCR layout</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="chapter6.xhtml#tab6-9">Table 6-9</a> describes the meaning of each of these bits.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab6-9"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 6-9:</span></span> <span class="SANS_Futura_Std_Book_11">FPCR Bits</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Bit(s)</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Name</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">19</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">FZ16</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Flush-to-zero mode for half-precision arithmetic. 0 = disabled, 1 = enabled. This replaces denormalized values with 0. The result may not be as precise, but the instructions may execute faster.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">22, 23</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Rmode</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Rounding mode: 00 = round to nearest, 01 = round to +infinity, 10 = round to –infinity, 11 = truncate (round toward 0).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">24</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">FZ</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Flush-to-zero mode for single- and double-precision arithmetic.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">25</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">DN</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Default NaN (not a number) mode. 0 = disable default NaN mode, 1 = enable. When disabled, NaNs propagate through arithmetic operations; when enabled, invalid operations return the default NaN.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">26</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">AHP</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Alternate half-precision bit. Enables (1) alternate half-precision mode or (0) IEEE half-precision mode.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">For the most part, you’ll leave all these bits set to 0. Setting Rmode to 0b11 is a reasonable change when you want to truncate rather than round a floating-point calculation.</p>&#13;
<p class="TX">To manipulate the FPCR register, use the <span class="SANS_TheSansMonoCd_W5Regular_11">mrs</span> (move system to register) and <span class="SANS_TheSansMonoCd_W5Regular_11">msr</span> (move register to system) instructions, specifying FPCR as the system register:</p>&#13;
<pre id="pre-521"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_331" aria-label="331"/>mrs  X<var>n</var>, FPCR  // Copies FPCR to X<var>n</var>&#13;
msr  FPCR, X<var>n</var>  // Copies X<var>n</var> to FPCR</code></pre>&#13;
<p class="TX">For example, to clear all the (defined) bits in the FPCR, you’d use the following instructions:</p>&#13;
<pre id="pre-522"><code>mrs  x0,   fpcr&#13;
mov  x1,   #0xffff          // Load 0xf836ffff into X1, which is&#13;
movk x1,   #0xf836, lsl #16 // not a valid logical instr immediate value.&#13;
and  x0,   x0, x1           // Must put it in a register.&#13;
msr  fpcr, x0</code></pre>&#13;
<p class="TX">Set the rounding mode to truncate with the following instructions:</p>&#13;
<pre id="pre-523"><code>mrs  x0, fpcr&#13;
orr  x0, x0, #0x00c00000 // Is valid logical instr immediate value&#13;
msr  fpcr, x0</code></pre>&#13;
<p class="TX">The default FPCR settings are unknown on a warm reset, so you should always initialize this register before performing floating-point operations.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec33">&#13;
&#13;
<h4 class="H2" id="sec33"><span id="h2-128"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.8.3 Status Register</span></h4>&#13;
<p class="TNI1">The FPSR holds status information about ARM floating-point hardware. Reading this register provides the current floating-point status, while writing to it allows you to clear exception conditions. Although this is a 32-bit register, only 11 bits are defined and, in fact, only 7 of those are used in 64-bit mode (see <a href="chapter6.xhtml#fig6-6">Figure 6-6</a>).</p>&#13;
<figure class="IMG"><img class="img1" id="fig6-6" src="../images/Figure6-6.jpg" alt="" width="1330" height="111"/>&#13;
<figcaption><p class="CAP"><span class="SANS_Futura_Std_Book_Oblique_11">Figure 6-6: The FPSR layout</span></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><a href="chapter6.xhtml#tab6-10">Table 6-10</a> describes the purpose of each of the bits in the FPSR.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_332" aria-label="332"/>&#13;
&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab6-10"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 6-10:</span></span> <span class="SANS_Futura_Std_Book_11">FPSR Bits</span></p>&#13;
</caption>&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Bit(s)</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Name</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Definition</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">IOC</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Invalid operation cumulative flag. This bit is set when the result of an operation has no mathematical value or cannot be represented.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">DZC</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Division by zero cumulative flag. This bit is set when a division by zero occurs.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">2</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">OFC</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Overflow cumulative flag. This bit is set when a floating-point operation causes an overflow situation.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">3</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">UFC</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Underflow cumulative flag. This bit is set when underflow occurs during an arithmetic operation.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">4</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">IXC</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Inexact cumulative flag. This bit is set (often!) when a floating-point operation produces an inexact result.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">7</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">IDC</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Input denormal cumulative flag. This bit is set when a denormalized input operand is replaced in the computation by a zero.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">27</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">QC</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Saturation cumulative flag. This flag is set when a saturation instruction clips a value. See <a href="chapter11.xhtml">Chapter 11</a> for a discussion of the saturating instructions.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">28–31</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">N, C, Z, V</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">These flags are used only in 32-bit mode. In 64-bit mode, the floating-point comparisons and other instructions directly set the N, Z, C, and V flags in the PSTATE register.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">You can read and write the FPSR with the <span class="SANS_TheSansMonoCd_W5Regular_11">mrs</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">msr</span> instructions, using FPSR as the system register name. Read the FPSR to determine if any floating-point exceptions have occurred, and write the FPSR to clear the exception bits (by writing 0s to the affected bits in the register). For example the following code clears the Invalid Operation Cumulative flag in the FPSR:</p>&#13;
<pre id="pre-524"><code>mrs  x0, FPSR&#13;
and  x0, x0, #-2  // Clear IOC bit (-2 is 0xFFFF...FE).&#13;
msr  FPSR, x0</code></pre>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec34">&#13;
&#13;
<h3 class="H1" id="sec34"><span id="h1-85"/><span class="SANS_Futura_Std_Bold_B_11">6.9 Floating-Point Instructions</span></h3>&#13;
<p class="TNI1">The FPU adds many instructions to the ARM instruction set. I will classify these as data movement instructions, conversions, arithmetic instructions, comparisons, and miscellaneous instructions. This section describes each instruction in these categories.</p>&#13;
<section epub:type="division" aria-labelledby="sec35">&#13;
&#13;
<h4 class="H2" id="sec35"><span id="h2-129"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.9.1 FPU Data Movement Instructions</span></h4>&#13;
<p class="TNI1">The <i>data movement instructions</i> transfer data between the internal FPU registers and memory. The instructions in this category are <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">ldur</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">str</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">stur</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">ldp</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">ldnp</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">stp</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">stnp</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">fmov</span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec36">&#13;
&#13;
<h5 class="H3" id="sec36"><span class="SANS_Futura_Std_Bold_Condensed_B_11">6.9.1.1 ldr/ldur and str/stur</span></h5>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> instructions load one of the FPU registers from a memory location, using the normal memory addressing modes. The <span class="SANS_TheSansMonoCd_W5Regular_11">ldur</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">stur</span> instructions force an unscaled load or store operation, for cases where the assembler might choose a scaled indirect-plus-offset mode. Generally, rather than using <span class="SANS_TheSansMonoCd_W5Regular_11">ldur</span>/<span class="SANS_TheSansMonoCd_W5Regular_11">stur</span>, you’d let the assembler pick the appropriate underlying machine coding for you.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_333" aria-label="333"/>You can specify any of the FPU register names when using this instruction. For example, the following code loads the specified floating-point registers from memory:</p>&#13;
<pre id="pre-525"><code>ldr q0, [x0]  // Loads 128 bits from memory&#13;
ldr d0, [x0]  // Loads 64 bits from memory&#13;
ldr s0, [x0]  // Loads 32 bits from memory&#13;
ldr b0, [x0]  // Loads 8 bits from memory</code></pre>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec37">&#13;
&#13;
<h5 class="H3" id="sec37"><span class="SANS_Futura_Std_Bold_Condensed_B_11">6.9.1.2 ldp/ldnp and stp/stnp</span></h5>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">ldp</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">stp</span> instructions work similarly to their integer counterparts with floating-point registers: they load or store a pair of registers at a time. These instructions do not support the H<i>n</i> or B<i>n</i> registers; you can load only word, dword, or qword FPU registers using these instructions.</p>&#13;
<p class="TX">The following examples demonstrate loading 256, 128, and 64 bits from memory:</p>&#13;
<pre id="pre-526"><code>ldp q0, q1, [x0]  // Loads 256 bits from memory&#13;
ldp d0, d1, [x0]  // Loads 128 bits from memory&#13;
ldp s0, s1, [x0]  // Loads 64 bits from memory</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">ldnp</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">stnp</span> instructions do nontemporal loads and stores. This informs the CPU that you don’t intend to access the specified memory location again in the near future, so the CPU won’t copy the data into its cache (a convenient example of what you can do in assembly and not in an HLL). This can improve performance by helping to prevent a situation known as <i>thrashing</i>, in which the CPU constantly moves data in and out of the cache memory.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec38">&#13;
&#13;
<h5 class="H3" id="sec38"><span class="SANS_Futura_Std_Bold_Condensed_B_11">6.9.1.3 fmov</span></h5>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">fmov</span> instruction transfers data between two like-sized floating-point registers (where both registers are either 32 or 64 bits), or between a 32- or 64-bit general-purpose (GP) register and a like-sized floating-point register. Here is the allowable syntax for this instruction:</p>&#13;
<pre id="pre-527"><code>fmov S<var>d</var>, S<var>n</var>  // Move data between two 32-bit FP registers.&#13;
fmov D<var>d</var>, D<var>n</var>  // Move data between two 64-bit FP registers.&#13;
fmov S<var>d</var>, W<var>n</var>  // Move data from a 32-bit GP to an FP register.&#13;
fmov W<var>d</var>,<var> </var>S<var>n</var>  // Move data from a 32-bit FP to a GP register.&#13;
fmov D<var>d</var>, X<var>n</var>  // Move data from a 64-bit GP to an FP register.&#13;
fmov X<var>d</var>,<var> </var>D<var>n</var>  // Move data from a 64-bit FP to a GP register.</code></pre>&#13;
<p class="TX">Moving a general-purpose register into a floating-point register does not convert an integer value in the GP register to a floating-point value; such an <span class="SANS_TheSansMonoCd_W5Regular_11">fmov</span> operation assumes that the GP register contains the bit pattern for a floating-point number. Likewise, moving a floating-point register into a general-purpose register does not convert the floating-point value into an integer.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec39">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_334" aria-label="334"/>&#13;
<h5 class="H3" id="sec39"><span class="SANS_Futura_Std_Bold_Condensed_B_11">6.9.1.4 fmov with Immediate Operand</span></h5>&#13;
<p class="TNI1">The ARM provides an <span class="SANS_TheSansMonoCd_W5Regular_11">fmov</span> instruction that allows a very limited immediate operand. The syntax is as follows</p>&#13;
<pre id="pre-528"><code>fmov S<var>d</var>, #<var>fimm</var>&#13;
fmov D<var>d</var>, #<var>fimm</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">fimm</span> is a floating-point constant from a very small set of possible values. The allowable values are ±<i>n</i> / 16 × 2<i><sup>m</sup></i>, where 16 ≤ <i>n</i> ≤ 31 and –3 ≤ <i>m</i> ≤ 4. This means you can represent values such as 1.0 or –2.0 but cannot represent 1.2345e5.</p>&#13;
<p class="TX">You cannot represent the value 0.0 with this immediate form. However, you can load 0.0 into a floating-point register by using one of the following two instructions:</p>&#13;
<pre id="pre-529"><code>fmov S<var>d</var>, wzr&#13;
fmov D<var>d</var>, xzr</code></pre>&#13;
<p class="TX">If you want to load an arbitrary floating-point constant into a register, you will have to stick that constant into a memory location, using the <span class="SANS_TheSansMonoCd_W5Regular_11">.single</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">.double</span> directive, and load the register from that location. Unfortunately, the <span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> instruction doesn’t accept floating-point immediate operands:</p>&#13;
<pre id="pre-530"><code>ldr d0, =10.0   // Generates an error</code></pre>&#13;
<p class="TX">Fortunately, the PC-relative addressing mode does work, so you can access memory locations you’ve initialized in your <span class="SANS_TheSansMonoCd_W5Regular_11">.text</span> section (preferably in the <span class="SANS_TheSansMonoCd_W5Regular_11">.pool</span> area), as the following example demonstrates:</p>&#13;
<pre id="pre-531"><code>        .code&#13;
        .pool&#13;
fp10:   .double 10.0&#13;
         .&#13;
         .&#13;
         .&#13;
        ldr     d0, fp10</code></pre>&#13;
<p class="TX">By adding the <span class="SANS_TheSansMonoCd_W5Regular_11">.pool</span> directive, Gas can embed other assembler-generated constants in this area too.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec40">&#13;
&#13;
<h4 class="H2" id="sec40"><span id="h2-130"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.9.2 FPU Arithmetic Instructions</span></h4>&#13;
<p class="TNI1">The ARM CPU provides a large set of floating-point instructions that operate on single-precision and double-precision floating-point values. As for the integer operations, most of these instructions require three (floating-point) register operands: a destination, a left source, and a right source.</p>&#13;
<p class="TX"><a href="chapter6.xhtml#tab6-11">Table 6-11</a> lists the syntax for the arithmetic instructions. In this table, <span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">a</span> represent floating-point registers and can be S<i>n</i> or D<i>n</i> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_335" aria-label="335"/>(<i>n</i> = 0 to 31), depending on the precision of the instruction. For a given instruction, all registers must be the same size (32 or 64 bits).</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab6-11"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 6-11:</span></span> <span class="SANS_Futura_Std_Book_11">Floating-Point Arithmetic Instructions</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Instruction</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Operands</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fadd</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">F</span><span class="SANS_Futura_Std_Book_Oblique_11">d</span> <span class="SANS_Futura_Std_Book_11">= F</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span> <span class="SANS_Futura_Std_Book_11">+ F</span><span class="SANS_Futura_Std_Book_Oblique_11">m</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fsub</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">F</span><span class="SANS_Futura_Std_Book_Oblique_11">d</span> <span class="SANS_Futura_Std_Book_11">= F</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span> <span class="SANS_Futura_Std_Book_11">– F</span><span class="SANS_Futura_Std_Book_Oblique_11">m</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fmul</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">F</span><span class="SANS_Futura_Std_Book_Oblique_11">d</span> <span class="SANS_Futura_Std_Book_11">= F</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span> <span class="SANS_Futura_Std_Book_11">× F</span><span class="SANS_Futura_Std_Book_Oblique_11">m</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fnmul</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">F</span><span class="SANS_Futura_Std_Book_Oblique_11">d</span> <span class="SANS_Futura_Std_Book_11">= –(F</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span> <span class="SANS_Futura_Std_Book_11">× F</span><span class="SANS_Futura_Std_Book_Oblique_11">m</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fmadd</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">a</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">F</span><span class="SANS_Futura_Std_Book_Oblique_11">d</span> <span class="SANS_Futura_Std_Book_11">= Fa + F</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span> <span class="SANS_Futura_Std_Book_11">× F</span><span class="SANS_Futura_Std_Book_Oblique_11">m</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fmsub</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">a</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">F</span><span class="SANS_Futura_Std_Book_Oblique_11">d</span> <span class="SANS_Futura_Std_Book_11">= Fa – F</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span> <span class="SANS_Futura_Std_Book_11">× F</span><span class="SANS_Futura_Std_Book_Oblique_11">m</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fnmadd</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">a</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">F</span><span class="SANS_Futura_Std_Book_Oblique_11">d</span> <span class="SANS_Futura_Std_Book_11">= –(F</span><span class="SANS_Futura_Std_Book_Oblique_11">a</span> <span class="SANS_Futura_Std_Book_11">+ F</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span> <span class="SANS_Futura_Std_Book_11">× F</span><span class="SANS_Futura_Std_Book_Oblique_11">m</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fnmsub</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">a</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">F</span><span class="SANS_Futura_Std_Book_Oblique_11">d</span> <span class="SANS_Futura_Std_Book_11">= –(F</span><span class="SANS_Futura_Std_Book_Oblique_11">a</span> <span class="SANS_Futura_Std_Book_11">– F</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span> <span class="SANS_Futura_Std_Book_11">× F</span><span class="SANS_Futura_Std_Book_Oblique_11">m</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fdiv</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">F</span><span class="SANS_Futura_Std_Book_Oblique_11">d</span> <span class="SANS_Futura_Std_Book_11">= F</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span> <span class="SANS_Futura_Std_Book_11">/ F</span><span class="SANS_Futura_Std_Book_Oblique_11">m</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fmax</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">F</span><span class="SANS_Futura_Std_Book_Oblique_11">d</span> <span class="SANS_Futura_Std_Book_11">= max(F</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">, F</span><span class="SANS_Futura_Std_Book_Oblique_11">m</span><span class="SANS_Futura_Std_Book_11">), NaN if either operand is NaN</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fmaxnm</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">F</span><span class="SANS_Futura_Std_Book_Oblique_11">d</span> <span class="SANS_Futura_Std_Book_11">= max(F</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">, F</span><span class="SANS_Futura_Std_Book_Oblique_11">m</span><span class="SANS_Futura_Std_Book_11">), number if other operand is (quiet) NaN</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fmin</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">F</span><span class="SANS_Futura_Std_Book_Oblique_11">d</span> <span class="SANS_Futura_Std_Book_11">= min(F</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">, F</span><span class="SANS_Futura_Std_Book_Oblique_11">m</span><span class="SANS_Futura_Std_Book_11">), NaN if either operand is NaN</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fminnm</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">F</span><span class="SANS_Futura_Std_Book_Oblique_11">d</span> <span class="SANS_Futura_Std_Book_11">= min(F</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">, F</span><span class="SANS_Futura_Std_Book_Oblique_11">m</span><span class="SANS_Futura_Std_Book_11">), number if other operand is (quiet) NaN</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fabs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">F</span><span class="SANS_Futura_Std_Book_Oblique_11">d</span> <span class="SANS_Futura_Std_Book_11">= fabs(F</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">), absolute value</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fneg</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">F</span><span class="SANS_Futura_Std_Book_Oblique_11">d</span> <span class="SANS_Futura_Std_Book_11">= –F</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fsqrt</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span><span class="SANS_TheSansMonoCd_W5Regular_11">, F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">F</span><span class="SANS_Futura_Std_Book_Oblique_11">d</span> <span class="SANS_Futura_Std_Book_11">= sqrt(F</span><span class="SANS_Futura_Std_Book_Oblique_11">n</span><span class="SANS_Futura_Std_Book_11">)</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Many operations can raise an exception of one sort or another. For example, <span class="SANS_TheSansMonoCd_W5Regular_11">fdiv</span> can set the DZC flag in the FPSR if a division by 0 occurs. Some operations, such as <span class="SANS_TheSansMonoCd_W5Regular_11">fsqrt</span>, can produce an invalid result—for example, when trying to take the square root of a negative number. After a sequence of floating-point instructions, check the FPSR to see if the result obtained is valid. The FPSR bits are sticky and will remain set once an exception occurs; this allows you to check for an error at the end of a chain of calculations, rather than after each floating-point instruction.</p>&#13;
<aside class="box" aria-label="box-21">&#13;
<p class="BH" id="box-21"><span class="SANS_Dogma_OT_Bold_B_11">SIGNALING VS. QUIET NANS</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">NaNs come in two varieties: signaling and quiet. When a</span> <span class="SANS_Futura_Std_Book_Oblique_11">quiet NaN</span> <span class="SANS_Futura_Std_Book_11">occurs, the operations set the result to NaN (a special floating-point value; see section 2.14.1, “Nonnumeric Values,” on <a href="chapter2.xhtml#pg_97">page 97</a>). Any further operations quietly propagate this value throughout the calculation so that the final result remains NaN.</span></p>&#13;
<p class="BTX"><span class="SANS_Futura_Std_Book_Oblique_11">Signaling NaNs</span><span class="SANS_Futura_Std_Book_11">, on the other hand, can raise an exception when the bad calculation occurs. This functionality can be enabled or disabled with the DN bit (bit 25) in the FPCR.</span></p>&#13;
<p class="BoxBodyLast"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_336" aria-label="336"/><span class="SANS_Futura_Std_Book_11">When exceptions are enabled, the CPU invokes a special trap handler anytime an exception occurs. When disabled, the CPU will set only the status bits and pass NaNs through the calculation as an indication that an exception happened. The exception handler is generally provided by the OS and enabled via OS system calls; writing an exception handler to deal with this situation is beyond the scope of this book. Fortunately, exception processing is normally turned off by default, and you must explicitly test for exceptions by reading the FPSR.</span></p>&#13;
</aside>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec41">&#13;
&#13;
<h4 class="H2" id="sec41"><span id="h2-131"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.9.3 Floating-Point Comparisons</span></h4>&#13;
<p class="TNI1">The ARM provides a floating-point compare and a conditional compare instruction. Both have a couple of forms</p>&#13;
<pre id="pre-532"><code>fcmp   F<var>d</var>, F<var>s</var> &#13;
fcmpe  F<var>d</var>, F<var>s</var> &#13;
fcmp   F<var>d</var>, #0.0 &#13;
fcmpe  F<var>d</var>, #0.0 &#13;
&#13;
fccmp  F<var>d</var>, F<var>s</var>, #<var>nzcv</var>, <var>cond</var> &#13;
fccmpe F<var>d</var>, F<var>s</var>, #<var>nzcv</var>, <var>cond</var> </code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">nzcv</span> and <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">cond</span> have the same meanings they did with the <span class="SANS_TheSansMonoCd_W5Regular_11">ccmp</span> instruction.</p>&#13;
<p class="TX">The instructions with the <span class="SANS_TheSansMonoCd_W5Regular_11">e</span> suffix raise an exception if either operand is NaN during the comparison. Dealing with exceptions raised by these instructions is beyond the scope of this book, so subsequent example code uses just the forms without the <span class="SANS_TheSansMonoCd_W5Regular_11">e</span> suffix.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">fcmp</span> instruction will compare an FPU register against either another FPU register or the immediate constant <span class="SANS_TheSansMonoCd_W5Regular_11">0.0</span>. If you need to compare against any other floating-point constant, you’ll have to first load that into a register. Note that <span class="SANS_TheSansMonoCd_W5Regular_11">fccmp</span> doesn’t provide a form that allows a comparison against <span class="SANS_TheSansMonoCd_W5Regular_11">0.0</span> (although you can copy XZR or WZR into another FPU register and compare against that).</p>&#13;
<section epub:type="division" aria-labelledby="sec42">&#13;
&#13;
<h5 class="H3" id="sec42"><span class="SANS_Futura_Std_Bold_Condensed_B_11">6.9.3.1 Comparison Logic</span></h5>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">fcmp</span> instruction sets the (PSR, not FPSR) condition code bits N, Z, C, and V in response to the comparison, allowing you to use the conditional branches and other conditional instructions to test the result of the comparison. However, the behavior of the settings is a bit different from integer comparisons. First of all, there aren’t unsigned and signed comparisons (floating-point values are always signed); second, floating-point comparisons can be unordered.</p>&#13;
<p class="TX"><i>Unordered comparisons</i> occur when one or both of two values you’re comparing are NaN, since two values are incomparable under those <span role="doc-pagebreak" epub:type="pagebreak" id="pg_337" aria-label="337"/>circumstances. At best, you can say they are not equal to each other; it’s safer simply to say the result is unordered and leave it at that. Generally, if the result of a comparison is unordered, something is seriously wrong and you’ll want to take corrective action.</p>&#13;
<p class="TX">One way to avoid this issue is to use the <span class="SANS_TheSansMonoCd_W5Regular_11">fcmpe</span> form, which can generate an exception, and leave it up to the exception handler to deal with unordered values. However, as noted earlier, dealing with those exceptions is beyond the scope of this book, so I recommend sticking with <span class="SANS_TheSansMonoCd_W5Regular_11">fcmp</span>.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">fcmp</span> instruction sets the N, Z, V, and C flags in such a way that you can test them for ordered and unordered results after a comparison. The good news is that you can handle unordered and ordered comparisons by using normal conditional branch and other instructions. The bad news is that the <span class="SANS_TheSansMonoCd_W5Regular_11">fcmp</span> results slightly change the definition of those conditional branch instructions. <a href="chapter6.xhtml#tab6-12">Table 6-12</a> describes how <span class="SANS_TheSansMonoCd_W5Regular_11">fcmp</span> sets the flags.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab6-12"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 6-12:</span></span> <span class="SANS_Futura_Std_Book_11">Flags Set by</span> <span class="SANS_TheSansMonoCd_W5Regular_11">fcmp</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Condition</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Meaning</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">EQ</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Equal</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">NE</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Not equal, or unordered</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">GE</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Greater than or equal</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">LT</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Less than, or unordered</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">GT</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Greater than</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">LE</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Less than or equal, or unordered</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">HI</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Greater than, or unordered</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">HS/CS</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Greater than or equal, or unordered</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">LO/CC</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Less than</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">LS</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Less than or equal</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">MI</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Less than</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">PL</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Greater than or equal, or unordered</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">VS</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Unordered</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">VC</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Ordered</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Two points in <a href="chapter6.xhtml#tab6-12">Table 6-12</a> are easy to miss:</p>&#13;
<ul class="ul">&#13;
<li class="BL">The <span class="SANS_TheSansMonoCd_W5Regular_11">fcmp</span> instruction sets the V flag if the comparison is unordered.</li>&#13;
<li class="BL">Both signed and unsigned tests are used for floating-point comparisons, which are intrinsically signed values.</li>&#13;
</ul>&#13;
<p class="TX">You’ll notice that GE and GT are ordered comparisons, while LE and LT handle unordered comparisons. Likewise, LS and LO are ordered comparisons, while HI and HS also handle unordered comparisons. At first glance, this might seem weird; why not make one set (signed or unsigned) ordered and the other set unordered?</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_338" aria-label="338"/>However, you want the two opposite tests (for example, LE and GT, or LT and GE) to handle all possible outcomes. One of the outcomes is unordered. Therefore, one of the opposite comparisons needs to handle unordered so that the two tests in each pair provide total coverage of the conditionals (the same logic applies to HI-LS and HS-LO). You can always test the overflow flag (V) to see whether a comparison is ordered or unordered.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec43">&#13;
&#13;
<h5 class="H3" id="sec43"><span class="SANS_Futura_Std_Bold_Condensed_B_11">6.9.3.2 Conditional Comparisons</span></h5>&#13;
<p class="TNI1">The conditional floating-point comparison instruction, <span class="SANS_TheSansMonoCd_W5Regular_11">fccmp</span>, is the floating-point analog to the integer conditional comparison instruction. You can use it to reduce complex Boolean expressions involving conjunction (AND) and disjunction (OR), as noted earlier (see section 6.5, <span class="Xref">“Conditional Comparisons and Boolean Expressions,”</span> on <span class="Xref"><a href="chapter6.xhtml#pg_314">page 314</a></span>).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec44">&#13;
&#13;
<h5 class="H3" id="sec44"><span class="SANS_Futura_Std_Bold_Condensed_B_11">6.9.3.3 Comparison for Equality</span></h5>&#13;
<p class="TNI1">As discussed in section 6.7, <span class="Xref">“Floating-Point and Finite-Precision Arithmetic,”</span> on <span class="Xref"><a href="chapter6.xhtml#pg_322">page 322</a></span>, you should be very careful about comparing two floating-point values (especially for equality). Minor inaccuracies in two calculations that would produce the same result using infinite-precision real arithmetic may yield different results when using limited-precision floating-point arithmetic. If you want to compare two values for equality, compute their difference and determine whether the absolute value of their difference is within an acceptable error range.</p>&#13;
<p class="TX">The real question is how to determine an acceptable range for the error. Because the difference between these (presumably equal) floating-point values will manifest itself in the LO bits of the mantissa, the error value should be something corresponding to a 1 bit in one of those positions.</p>&#13;
<p class="TX">Listing 6-2 demonstrates how to calculate this error value.</p>&#13;
<pre id="pre-533"><code>// Listing6-2.S &#13;
//&#13;
// Demonstrate comparing two floating-point &#13;
// values for equality by using a difference &#13;
// and error range comparison. &#13;
&#13;
        #include    "aoaa.inc"&#13;
&#13;
// The following bit mask will keep the &#13;
// exponent bits in a 64-bit double-precision &#13;
// floating-point value. It zeros out the &#13;
// remaining sign and mantissa bits. &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> maskFP  =       0x7FF0000000000000 &#13;
&#13;
// bits is the number of bits you want to &#13;
// mask out at the bottom of the mantissa. &#13;
// It must be greater than 0: &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_339" aria-label="339"/><span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> bits    =       4 &#13;
bitMask =       (1 &lt;&lt; bits)-1 &#13;
&#13;
// expPosn is the position of the first &#13;
// exponent bit in the double-precision &#13;
// format: &#13;
&#13;
expPosn =       52 &#13;
&#13;
        .text &#13;
        .pool &#13;
ttlStr: wastr   "Listing 6-2"&#13;
fmtStr: wastr   "error for (%24.16e) = %e\n"&#13;
difMsg: wastr   "Difference:%e\n"&#13;
values: wastr   "Value1=%23.16e, Value2=%23.16e\n"&#13;
eqMsg:  wastr   "Value1 == Value2\n"&#13;
neMsg:  wastr   "Value1 != Value2\n"&#13;
&#13;
// When value2 is somewhere between &#13;
// 8e-323 and 9e-323, the &#13;
// comparison becomes not equal: &#13;
&#13;
value1: .double 1.0e-323 &#13;
value2: .double 9e-323 &#13;
&#13;
// Generic values to compare: &#13;
&#13;
// value1: .double   1.2345678901234567 &#13;
// value2: .double   1.234567890123456 &#13;
&#13;
// getTitle &#13;
//&#13;
// Return pointer to program title &#13;
// to the C++ code: &#13;
&#13;
        proc    getTitle, public &#13;
        lea     x0, ttlStr &#13;
        ret &#13;
        endp    getTitle &#13;
&#13;
// computeError &#13;
//&#13;
// Given a double-precision floating-point &#13;
// value in D0, this function computes an &#13;
// error range value for use in comparisons. &#13;
// If the difference between two FP values &#13;
// (one of which is the value passed in D0) &#13;
// is less than the error range value, you &#13;
// can consider the two values equal. &#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> proc    computeError &#13;
&#13;
        // Preserve all registers this code &#13;
        // modifies: &#13;
&#13;
        locals  ce &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_340" aria-label="340"/>        qword   ce.saveX01 &#13;
        byte    stack, 64 &#13;
        endl    ce &#13;
&#13;
        enter   ce.size &#13;
        stp     x0, x1, [fp, #ce.saveX01] &#13;
&#13;
        // Move the FP number into X0 so you can mask &#13;
        // bits: &#13;
&#13;
        fmov    x0, d0 &#13;
&#13;
        // Generate mask to extract exponent: &#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> and     x0, x0, #maskFP     // Extract exponent bits. &#13;
        lsr     x1, x0, #expPosn    // Put exponent in bits 0-10. &#13;
&#13;
        // We need to normalize the value, &#13;
        // if possible: &#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> cmp     x1, #(expPosn - bits - 1) &#13;
        blo     willBeDenormal &#13;
&#13;
        // If the result won't be a subnormal &#13;
        // (denormalized value), then set &#13;
        // the mantissa bits to all 0s &#13;
        // (plus the implied 1 bit) and &#13;
        // decrement the exponent to move &#13;
        // the "bits" position up to the &#13;
        // implied bit: &#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> sub     x1, x1, #expPosn-bits // Adjust exponent. &#13;
        lsl     x0, x1, #expPosn      // Put exponent back. &#13;
        b.al    allDone &#13;
&#13;
// If the result will be denormalized, handle that &#13;
// situation down here: &#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation7">❼</span> willBeDenormal: &#13;
        mov     x0, #bitMask &#13;
        lsl     x0, x0, x1  // Shift as much as you can. &#13;
&#13;
allDone: &#13;
        fmov    d0, x0      // Return in D0. &#13;
        ldp     x0, x1, [fp, #ce.saveX01] &#13;
        leave &#13;
        endp    computeError &#13;
&#13;
///////////////////////////////////////////////////////// &#13;
//&#13;
// Here's the asmMain procedure: &#13;
&#13;
        proc    asmMain, public &#13;
&#13;
        locals  am &#13;
        double  am.error &#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_341" aria-label="341"/>        double  am.diff &#13;
        byte    am.stackSpace, 64 &#13;
        endl    am &#13;
&#13;
        enter   am.size &#13;
&#13;
// Display the values you're going to compare: &#13;
&#13;
        ldr     d0, value1 &#13;
        str     d0, [sp] &#13;
        ldr     d1, value2 &#13;
        str     d1, [sp, #8] &#13;
        lea     x0, values &#13;
        bl      printf &#13;
&#13;
// Compute the error value: &#13;
&#13;
        ldr     d0, value1 &#13;
        bl      computeError &#13;
        str     d0, [fp, #am.error] &#13;
&#13;
// Print the error value: &#13;
&#13;
        str     d0, [sp, #8] &#13;
        ldr     d1, value1 &#13;
        str     d1, [sp] &#13;
        lea     x0, fmtStr &#13;
        bl      printf &#13;
&#13;
// Compute the difference of the &#13;
// two values you're going to compare &#13;
// and print that difference: &#13;
&#13;
        ldr     d0, value1 &#13;
        ldr     d1, value2 &#13;
        fsub    d0, d0, d1 &#13;
        str     d0, [fp, #am.diff] &#13;
        str     d0, [sp] &#13;
        lea     x0, difMsg &#13;
        bl      printf &#13;
&#13;
// Compare the difference of the two &#13;
// numbers against the error range. &#13;
&#13;
        ldr     d1, [fp, #am.error] &#13;
        ldr     d0, [fp, #am.diff] &#13;
        fabs    d0, d0              // Must be abs(diff)! &#13;
        fcmp    d0, d1 &#13;
        ble     isEqual &#13;
&#13;
// Print whether you should &#13;
// treat these values as equal: &#13;
&#13;
        lea     x0, neMsg &#13;
        b.al    printIt &#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_342" aria-label="342"/>isEqual: &#13;
        lea     x0, eqMsg &#13;
printIt: &#13;
        bl      printf &#13;
&#13;
        leave                       // Return to caller. &#13;
        endp    asmMain </code></pre>&#13;
<p class="TX">The mask <span class="SANS_TheSansMonoCd_W5Regular_11">0x7FF0_0000_0000_0000</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, when ANDed with a double-precision floating-point value, will strip out the mantissa and sign bits, leaving the exponent in bit positions 52 to 62 (11-bit exponent).</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">bits</span> constant <span class="CodeAnnotation" aria-label="annotation2">❷</span> in this listing determines the number of LO bits in the mantissa that the code will eliminate when generating the error value (this is currently 4 bits, so the 4 LO bits of the mantissa become insignificant, but in most cases it should be 2 to 3 bits for single-precision and 3 to 4 bits for double-precision comparisons). Once the <span class="SANS_TheSansMonoCd_W5Regular_11">computeError</span> function generates the error value, the main program uses that error to compare a couple of floating-point numbers and report whether they should be treated as equal (their difference is less than the error value) or not equal (their difference is greater). The <span class="SANS_TheSansMonoCd_W5Regular_11">bitMask</span> value is just a string of 1 bits (<span class="SANS_TheSansMonoCd_W5Regular_11">4</span> in Listing 6-2).</p>&#13;
<p class="TX">The procedure <span class="SANS_TheSansMonoCd_W5Regular_11">computeError</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span> is passed a floating-point value in D0. This function computes an error value for that floating-point number such that if it is compared with a second number, their difference will be less than the error value if they should be considered equal. This function returns the error value in the D0 register.</p>&#13;
<p class="TX">To compute the error value, <span class="SANS_TheSansMonoCd_W5Regular_11">computeError</span> begins by shifting the exponent down to bits 0 to 10 so that it is easier to work with <span class="CodeAnnotation" aria-label="annotation4">❹</span>. If the exponent is less than 52 – 5 bits, the error value will turn out to be a subnormal (denormalized) number. The code determines whether the error value will be normalized or subnormal <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">If the result will be a normalized number, the code generates the error value by 52 bits (47 if <span class="SANS_TheSansMonoCd_W5Regular_11">bits</span> is 4) and then shifts the exponent back into its proper location <span class="CodeAnnotation" aria-label="annotation6">❻</span>. The mantissa and sign bits will all be 0; however, the implied bit for double-precision numbers will be 1, because the exponent is not 0.</p>&#13;
<p class="TX">If the error value will turn out to be subnormal, the code sets the exponent to 0, denoting a denormalized value, and shifts the <span class="SANS_TheSansMonoCd_W5Regular_11">bitMask</span> value to the left the number of bit positions specified by the exponent minus the <span class="SANS_TheSansMonoCd_W5Regular_11">bits</span> value <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for Listing 6-2:</p>&#13;
<pre id="pre-534"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build Listing6-2</span> &#13;
$<span class="SANS_TheSansMonoCd_W7Bold_11"> ./Listing6-2</span> &#13;
Calling Listing6-2: &#13;
Value1 = 9.8813129168249309e-324, Value2 = 8.8931816251424378e-323 &#13;
error for (7.4109846876186982e-323) = 9.881313e-324 &#13;
Difference:-7.905050e-323 &#13;
Value1 != Value2 &#13;
Listing6-2 terminated </code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_343" aria-label="343"/>This demonstrates that the difference between <span class="SANS_TheSansMonoCd_W5Regular_11">Value1</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">Value2</span> is definitely outside the error range allowed for this comparison.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec45">&#13;
&#13;
<h5 class="H3" id="sec45"><span class="SANS_Futura_Std_Bold_Condensed_B_11">6.9.3.4 Conditional Select Instruction</span></h5>&#13;
<p class="TNI1">Although the ARM does not support all the conditional instructions present in the integer instruction set, it does support the most often used conditional instruction: conditional select, or <span class="SANS_TheSansMonoCd_W5Regular_11">fcsel</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">fcsel</span> instruction has the following syntax:</p>&#13;
<pre id="pre-535"><code>fcsel F<var>d</var>, F<var>t</var>, F<var>f</var>, <var>cond</var></code></pre>&#13;
<p class="TX">This instruction will test the condition and copy <span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">t</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span> if the condition is true, or it will copy <span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">f</span> to <span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span> if the condition is false.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec46">&#13;
&#13;
<h4 class="H2" id="sec46"><span id="h2-132"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">6.9.4 Floating-Point Conversion Instructions</span></h4>&#13;
<p class="TNI1">The ARM instruction set includes a wide variety of instructions that convert between various floating-point formats and between signed/unsigned integers and floating-point formats. Certain CPUs even support conversions between floating-point and fixed-point formats. This section describes these conversions.</p>&#13;
<section epub:type="division" aria-labelledby="sec47">&#13;
&#13;
<h5 class="H3" id="sec47"><span class="SANS_Futura_Std_Bold_Condensed_B_11">6.9.4.1 fcvt</span></h5>&#13;
<p class="TNI1">The <span class="SANS_TheSansMonoCd_W5Regular_11">fcvt</span> instruction converts between the three supported floating-point formats (half-, single-, and double-precision). This is one of the few instructions that supports the H<i>n</i> registers (<span class="SANS_TheSansMonoCd_W5Regular_11">ldr</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">str</span> are the others). The syntax for this instruction is the following:</p>&#13;
<pre id="pre-536"><code>fcvt H<var>d</var>, S<var>s</var>&#13;
fcvt H<var>d</var>, D<var>s</var>&#13;
fcvt S<var>d</var>, H<var>s</var>&#13;
fcvt S<var>d</var>, D<var>s</var>&#13;
fcvt D<var>d</var>, H<var>s</var>&#13;
fcvt D<var>d</var>, S<var>s</var></code></pre>&#13;
<p class="TX">These instructions convert their source operand to the type of the destination operand and copy the converted data into that operand. Of course, not all conversions can happen without error—be aware that converting a larger-size format to a smaller-size format can produce underflow and underflow exceptions. You might want to consider checking the FPSR after such an operation:</p>&#13;
<pre id="pre-537"><code>fcvt s0, d1&#13;
mrs  x0, FPSR&#13;
mov  w1, #0x8c&#13;
ands w0, w0, w1  // UFC, OFC, and IDC bits&#13;
bne  badCvt</code></pre>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_344" aria-label="344"/>This code demonstrates checking the UFC, OFC, and IDC bits to see if an error occurred after the conversion.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec48">&#13;
&#13;
<h5 class="H3" id="sec48"><span class="SANS_Futura_Std_Bold_Condensed_B_11">6.9.4.2 Conversion Between Floating-Point and Integer</span></h5>&#13;
<p class="TNI1">The instructions in <a href="chapter6.xhtml#tab6-13">Table 6-13</a> convert between various floating-point (single- and double-precision) and integer formats. The syntax for these instructions is as follows</p>&#13;
<pre id="pre-538"><code>fcvt{<var>m</var>}{s|u} R<var>d</var>, F<var>n</var></code></pre>&#13;
<p class="Continued1">where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span> is <span class="SANS_TheSansMonoCd_W5Regular_11">a</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">m</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">n</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">p</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">z</span> that specifies a rounding mode (see <a href="chapter6.xhtml#tab6-13">Table 6-13</a>, where FP = floating-point, SI = signed integer, and UI = unsigned integer). <span class="SANS_TheSansMonoCd_W5Regular_11">F</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">n</span> represents any single- or double-precision floating-point register, and <span class="SANS_TheSansMonoCd_W5Regular_11">R</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">d</span> represents any general-purpose register (W<i>d</i> or X<i>d</i>).</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab6-13"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 6-13:</span></span> <span class="SANS_Futura_Std_Book_11">The</span> <span class="SANS_TheSansMonoCd_W5Regular_11">fcvt{</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span><span class="SANS_TheSansMonoCd_W5Regular_11">}{s|u}</span> <span class="SANS_Futura_Std_Book_11">Conversion Instructions</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Instruction</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fcvtas</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Convert FP to SI; round away from 0.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fcvtau</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Convert FP to UI; round away from 0.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fcvtms</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Convert FP to SI; round toward –infinity (floor function).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fcvtmu</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Convert FP to UI; round toward –infinity (floor function).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fcvtns</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Convert FP to SI; round to even (standard IEEE rounding).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fcvtnu</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Convert FP to UI; round to even (standard IEEE rounding).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fcvtps</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Convert FP to SI; round toward +infinity (ceil function).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fcvtpu</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Convert FP to UI; round toward +infinity (ceil function).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fcvtzs</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Convert FP to SI; round toward 0 (truncation).</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">fcvtzu</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Convert FP to SI; round toward 0 (truncation).</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">In addition to converting floating-point values to integers, the ARM provides two instructions that convert integers to floating-point values:</p>&#13;
<pre id="pre-539"><code>scvtf F<var>d</var>, R<var>d</var>  // Same register meanings as for fcv*&#13;
ucvtf F<var>d</var>, R<var>d</var>  // instructions</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">scvtf</span> instruction converts a signed integer to a floating-point value, and the <span class="SANS_TheSansMonoCd_W5Regular_11">ucvtf</span> instruction converts an unsigned integer to floating-point. Note that some integer values cannot be exactly represented by a single- or double-precision value. For example, a double-precision floating-point value has a 56-bit mantissa, so it cannot precisely represent all 64-bit integers.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec49">&#13;
&#13;
<h5 class="H3" id="sec49"><span class="SANS_Futura_Std_Bold_Condensed_B_11">6.9.4.3 Fixed-Point Conversions</span></h5>&#13;
<p class="TNI1">Some 64-bit ARM CPUs support conversion between a fixed-point binary value and a floating-point value. These instructions take the following forms:</p>&#13;
<pre id="pre-540"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_345" aria-label="345"/>fcvtzs R<var>d</var>, F<var>s</var>, #<var>bits</var>&#13;
fcvtzu R<var>d</var>, F<var>s</var>, #<var>bits</var>&#13;
scvtf  F<var>d</var>, R<var>s</var>, #<var>bits</var>&#13;
ucvtf  F<var>d</var>, F<var>s</var>, #<var>bits</var></code></pre>&#13;
<p class="TX">Here, <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">bits</span> is the number of bits to the right of the binary point in the general-purpose register. It is a constant from 0 to one less than the size of the general-purpose register. For example, in a 64-bit register, a value of 32 would provide you with 32 bits to the left and right of the binary point in the fixed-point number.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec50">&#13;
&#13;
<h5 class="H3" id="sec50"><span class="SANS_Futura_Std_Bold_Condensed_B_11">6.9.4.4 Rounding</span></h5>&#13;
<p class="TNI1">The ARM provides several floating-point rounding instructions. They are similar in nature to the floating-point-to-integer conversion insofar as they round a real number to an integral value. However, these instructions produce not binary integer values but rather floating-point results that just happen to be integer numbers (or, rather, the floating-point representation of those integer numbers).</p>&#13;
<p class="TX">These instructions all take a pair of floating-point registers as operands. Both registers must be the same size (single- or double-precision). The generic syntax is as follows:</p>&#13;
<pre id="pre-541"><code>frint{<var>m</var>} F<var>d</var>, F<var>s</var>  // Both registers must be S<var>n</var> or D<var>n</var>.</code></pre>&#13;
<p class="TX">The instruction descriptions appear in <a href="chapter6.xhtml#tab6-14">Table 6-14</a>.</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab6-14"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 6-14:</span></span> <span class="SANS_Futura_Std_Book_11">The</span> <span class="SANS_TheSansMonoCd_W5Regular_11">frint{</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">m</span><span class="SANS_TheSansMonoCd_W5Regular_11">}</span> <span class="SANS_Futura_Std_Book_11">Instructions</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Instruction</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Description</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">frinta</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Round away from 0.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">frinti</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Round using the Rmode setting in the FPCR.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">frintm</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Round toward –infinity.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">frintn</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Normal rounding, exactly 0.5 rounds to nearest even value.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">frintp</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Round toward +infinity.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">frintx</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Round using FPCR mode; raise an exception if value was not originally an integer.</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">frintz</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">Round toward 0.</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX">Now that you’ve reviewed the floating-point conversion instructions, I’ll show you how to use floating-point instructions in code that interfaces with other programs.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec51">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_346" aria-label="346"/>&#13;
<h3 class="H1" id="sec51"><span id="h1-86"/><span class="SANS_Futura_Std_Bold_B_11">6.10 The ARM ABI and Floating-Point Registers</span></h3>&#13;
<p class="TNI1">The ARM ABI considers V0 through V7 and V16 through V31 to be volatile. The caller must preserve these registers across procedure calls if it requires that they retain their values across a call.</p>&#13;
<p class="TX">Registers V8 through V15 are nonvolatile. A callee must preserve these registers within a procedure if it modifies their values. Of course, the advantage of these registers is that once a procedure preserves them (for its caller), it does not have to worry about modification to these registers by any functions it calls.</p>&#13;
<p class="TX">Callers pass the first eight floating-point parameters in registers to a procedure. When passing a combination of integer and floating-point parameters, the caller passes the non-floating-point parameters in the general- purpose registers (X0 to X7) and the floating-point arguments in the floating-point registers. If the number of floating-point parameters exceeds eight, the caller passes the floating-point parameters on the stack.</p>&#13;
<p class="TX">Parameters are assigned the next available register, not a register number based on the parameter’s position in the parameter list. Consider the following C function prototype:</p>&#13;
<pre id="pre-542"><code>void p&#13;
(&#13;
    int i,&#13;
    double d,&#13;
    int j,&#13;
    int k,&#13;
    double e,&#13;
    int l,&#13;
    double f,&#13;
    double g,&#13;
    double h&#13;
);</code></pre>&#13;
<p class="TX">The ARM ABI would associate the registers in <a href="chapter6.xhtml#tab6-15">Table 6-15</a> with these formal parameters:</p>&#13;
<table class="Basic-Table">&#13;
<caption><p class="TT" id="tab6-15"><span class="Heavy"><span class="SANS_Futura_Std_Heavy_11">Table 6-15:</span></span> <span class="SANS_Futura_Std_Book_11">Parameter Assignments to Registers</span></p>&#13;
</caption>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Register</span></p></th>&#13;
<th class="TCH" scope="col"><p class="TableHeader"><span class="SANS_Futura_Std_Heavy_11">Parameter</span></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X0</span></p></td>&#13;
<td class="TBF"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">i</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">D0</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">d</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">j</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X2</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">k</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">D1</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">e</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">X3</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">l</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">D2</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">f</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TB"><p class="TB1"><span class="SANS_Futura_Std_Book_11">D3</span></p></td>&#13;
<td class="TB"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">g</span></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_Futura_Std_Book_11">D4</span></p></td>&#13;
<td class="TBL"><p class="TB1"><span class="SANS_TheSansMonoCd_W5Regular_11">h</span></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_347" aria-label="347"/>If a function passes a floating-point parameter by reference, the address of that floating-point value is passed in the next available general-purpose register (no floating-point registers for pass-by-reference parameters).</p>&#13;
<p class="TX">If a function returns a floating-point result, it returns that value in D0 (or S0, if the language supports returning single-precision floats as function return results). See <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span> for details on returning vectors (multiple floating-point values) as function results (hint: V0). If a function returns an array of floating-point values, the caller must allocate storage for that array and pass a pointer to that array in X8. The function will store the results into that storage before returning.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec52">&#13;
&#13;
<h3 class="H1" id="sec52"><span id="h1-87"/><span class="SANS_Futura_Std_Bold_B_11">6.11 Using C Standard Library Math Functions</span></h3>&#13;
<p class="TNI1">Although the ARM instruction set provides a set of machine instructions that compute basic arithmetic operations, it does not have instructions for computing complex mathematical functions such as sine, cosine, and tangent. You could (with the appropriate knowledge) write these functions yourself in assembly language, but a much simpler solution is available: call functions that are already written for you. In particular, the C stdlib contains many useful mathematical functions you can use. This section describes how to call several of them.</p>&#13;
<p class="TX">As a sample program that demonstrates passing floating-point values to functions, Listing 6-3 makes calls to various C stdlib <span class="SANS_TheSansMonoCd_W5Regular_11">&lt;math.h&gt;</span> functions (specifically <span class="SANS_TheSansMonoCd_W5Regular_11">sin()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">cos()</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">tan()</span>). Each of these functions accepts a double-precision parameter and returns a double-precision result.</p>&#13;
<pre id="pre-543"><code>// Listing6-3.S&#13;
//&#13;
// Demonstrates calling various C stdlib&#13;
// math functions&#13;
&#13;
#include    "aoaa.inc"&#13;
&#13;
        .text&#13;
        .extern sin  // C stdlib functions&#13;
        .extern cos  // this program calls&#13;
        .extern tan&#13;
&#13;
        .pool&#13;
ttlStr: wastr   "Listing 6-3"&#13;
&#13;
// Format strings for each of the outputs:&#13;
&#13;
piStr:  wastr   "%s(pi) = %20.14e\n"&#13;
pi2Str: wastr   "%s(pi/2) = %20.14e\n"&#13;
pi4Str: wastr   "%s(pi/4) = %20.14e\n"&#13;
pi8Str: wastr   "%s(pi/8) = %20.14e\n\n"&#13;
&#13;
// Function names (printed as %s argument&#13;
// in the format strings):&#13;
&#13;
sinStr: wastr   "sin"&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_348" aria-label="348"/>cosStr: wastr   "cos"&#13;
tanStr: wastr   "tan"&#13;
&#13;
// Sample values to print for each&#13;
// of the functions:&#13;
&#13;
pi:     .double 3.141592653588979&#13;
pi2:    .double 1.5707963267949&#13;
pi4:    .double 0.7853981639745&#13;
pi8:    .double 0.39269908169872&#13;
&#13;
// getTitle&#13;
//&#13;
// Return pointer to program title&#13;
// to the C++ code.&#13;
&#13;
        proc    getTitle, public&#13;
        lea     x0, ttlStr&#13;
        ret&#13;
        endp    getTitle&#13;
&#13;
// Trampolines to the C stdlib math functions.&#13;
// These are necessary because lea can't take&#13;
// the address of a function that could be&#13;
// very far away (as the dynamic libraries&#13;
// probably are).&#13;
//&#13;
// Note: Must use real "b" instruction here&#13;
// rather than "b.al" because external&#13;
// functions are likely out of range.&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> proc    sinVeneer&#13;
        b       sin&#13;
        endp    sinVeneer&#13;
&#13;
        proc    cosVeneer&#13;
        b       cos&#13;
        endp    cosVeneer&#13;
&#13;
        proc    tanVeneer&#13;
        b       tan&#13;
        endp    tanVeneer&#13;
&#13;
// doPi(char *X0, func X1)&#13;
//&#13;
// X0-  Contains the address of a function&#13;
//      that accepts a single double and&#13;
//      returns a double result.&#13;
// X1-  Contains the address of a string&#13;
//      specifying the function name.&#13;
//&#13;
// This function calls the specified function&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_349" aria-label="349"/>// passing PI divided by 1, 2, 4, and 8 and&#13;
// then prints the result that comes back.&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> proc    doPi&#13;
&#13;
        locals  dp&#13;
        dword   dp.saveX1&#13;
        dword   dp.saveX0&#13;
        dword   dp.saveX19&#13;
        byte    dp.stackSpace, 64&#13;
        endl    dp&#13;
&#13;
        // Set up activation record and save register values:&#13;
&#13;
        enter   dp.size&#13;
        stp     x0, x1, [fp, #dp.saveX0]  // X1 -&gt; saveX1, too&#13;
        str     x19, [fp, #dp.saveX19]    // Preserve nonvolatile.&#13;
&#13;
        mov     x19, x0                   // Keep address in nonvolatile.&#13;
&#13;
        // Call the function for various values&#13;
        // of pi/n:&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> ldr     d0, pi&#13;
        blr     x19           // Call function.&#13;
        mstr    d0, [sp, #8]  // Save func result as parm.&#13;
        ldr     x1, [fp, #dp.saveX1]&#13;
        mstr    x1, [sp]&#13;
        lea     x0, piStr&#13;
        bl      printf&#13;
&#13;
        ldr     d0, pi2&#13;
        blr     x19             // Call function.&#13;
        mstr    d0, [sp, #8]&#13;
        lea     x0, piStr&#13;
        ldr     x1, [fp, #dp.saveX1]&#13;
        mstr    x1, [sp]&#13;
        lea     x0, pi2Str&#13;
        bl      printf&#13;
&#13;
        ldr     d0, pi4&#13;
        blr     x19             // Call function.&#13;
        mstr    d0, [sp, #8]&#13;
        lea     x0, piStr&#13;
        ldr     x1, [fp, #dp.saveX1]&#13;
        mstr    x1, [sp]&#13;
        lea     x0, pi4Str&#13;
        bl      printf&#13;
&#13;
        ldr     d0, pi8&#13;
        blr     x19             // Call function.&#13;
        mstr    d0, [sp, #8]&#13;
        lea     x0, piStr&#13;
        ldr     x1, [fp, #dp.saveX1]&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_350" aria-label="350"/>        mstr    x1, [sp]&#13;
        lea     x0, pi8Str&#13;
        bl      printf&#13;
&#13;
        // Restore nonvolatile register&#13;
        // and return:&#13;
&#13;
        ldr     x19, [fp, #dp.saveX19]&#13;
        leave&#13;
        endp    doPi&#13;
&#13;
/////////////////////////////////////////////////////////&#13;
//&#13;
// Here's the asmMain procedure:&#13;
&#13;
        proc    asmMain, public&#13;
        enter   64              // Generic entry&#13;
&#13;
        // Load X0 with the address&#13;
        // of the veneer (trampoline) function&#13;
        // that calls the C stdlib math function,&#13;
        // load X1 with the function's name,&#13;
        // then call doPi to call the function&#13;
        // and print the results:&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> lea     x0, sinVeneer   // SIN(x) output&#13;
        lea     x1, sinStr&#13;
        bl      doPi&#13;
&#13;
        lea     x0, cosVeneer   // COS(x) output&#13;
        lea     x1, cosStr&#13;
        bl      doPi&#13;
&#13;
        lea     x0, tanVeneer   // TAN(x) output&#13;
        lea     x1, tanStr&#13;
        bl      doPi&#13;
&#13;
        leave                   // Return to C/C++ code.&#13;
        endp    asmMain</code></pre>&#13;
<p class="TX">This program calls the <span class="SANS_TheSansMonoCd_W5Regular_11">sin()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">cos()</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">tan()</span> functions indirectly—the address of the particular function is passed as a parameter to the <span class="SANS_TheSansMonoCd_W5Regular_11">doPi</span> procedure. Unfortunately, macOS’s PIE functionality prevents you from taking the address of such a function by using the <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span> macro, because there is no telling where the OS will load the dynamically linked (shared) library at runtime; it could be farther away than the ±4GB allowed by <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span>. Therefore, this code creates trampolines for these functions that the OS can patch to transfer control to wherever the functions are sitting in memory <span class="CodeAnnotation" aria-label="annotation1">❶</span>. These trampolines are necessary only for macOS; though they will work with Linux code, Linux allows you to take the address of the C stdlib functions with <span class="SANS_TheSansMonoCd_W5Regular_11">lea</span>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_351" aria-label="351"/>The <span class="SANS_TheSansMonoCd_W5Regular_11">doPi</span> function <span class="CodeAnnotation" aria-label="annotation2">❷</span> saves the values of X0, X1, and X19 in the activation record. Preserving X19 is necessary because this is a nonvolatile register. Saving X0 and X1 is necessary because the procedure needs their values across calls to <span class="SANS_TheSansMonoCd_W5Regular_11">printf()</span>, and these registers are volatile.</p>&#13;
<p class="TX">The body of the <span class="SANS_TheSansMonoCd_W5Regular_11">doPi</span> calls the appropriate function (<span class="SANS_TheSansMonoCd_W5Regular_11">sin()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">cos()</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">tan()</span>) four times with the values <span class="greek"><span xml:lang="el" lang="el">π</span></span>, <span class="greek"><span xml:lang="el" lang="el">π</span></span>/2, <span class="greek"><span xml:lang="el" lang="el">π</span></span>/4, and <span class="greek"><span xml:lang="el" lang="el">π</span></span>/8, and it then displays the result these functions return <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Note how <span class="SANS_TheSansMonoCd_W5Regular_11">doPi</span> calls the function indirectly by using the <span class="SANS_TheSansMonoCd_W5Regular_11">blr</span> instruction—the address of the function was originally passed to <span class="SANS_TheSansMonoCd_W5Regular_11">doPi</span> in the X0 register.</p>&#13;
<p class="TX">The main procedure loads the address of the trampoline (veneer) function into X0, along with a string pointer, and calls <span class="SANS_TheSansMonoCd_W5Regular_11">doPi</span> to compute the values and print the results <span class="CodeAnnotation" aria-label="annotation4">❹</span>. (Trampolines and veneers are explained further in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>.) Loading the address of the trampoline functions into X0 is necessary only under macOS; with Linux, you can load the address of the <span class="SANS_TheSansMonoCd_W5Regular_11">sin()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">cos()</span>, or <span class="SANS_TheSansMonoCd_W5Regular_11">tan()</span> function directly and spare the minor inefficiency of having to jump through the trampoline function.</p>&#13;
<p class="TX">Here’s the <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and sample output for Listing 6-3:</p>&#13;
<pre id="pre-544"><code>$ <span class="SANS_TheSansMonoCd_W7Bold_11">./build -math Listing6-3</span>&#13;
$ <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing6-3</span>&#13;
Calling Listing6-3:&#13;
sin(pi) = 8.14137986335080e-13&#13;
sin(pi/2) = 1.00000000000000e+00&#13;
sin(pi/4) = 7.07106781594585e-01&#13;
sin(pi/8) = 3.82683432365086e-01&#13;
&#13;
cos(pi) = -1.00000000000000e+00&#13;
cos(pi/2) = -3.49148133884313e-15&#13;
cos(pi/4) = 7.07106780778510e-01&#13;
cos(pi/8) = 9.23879532511288e-01&#13;
&#13;
tan(pi) = -8.14137986335080e-13&#13;
tan(pi/2) = -2.86411383293069e+14&#13;
tan(pi/4) = 1.00000000115410e+00&#13;
tan(pi/8) = 4.14213562373090e-01&#13;
&#13;
Listing6-3 terminated</code></pre>&#13;
<p class="TX">You’ll notice one difference between this <span class="SANS_TheSansMonoCd_W5Regular_11">build</span> command and most of the others in the book: the <span class="SANS_TheSansMonoCd_W5Regular_11">-math</span> argument. This tells Linux to link in the C stdlib math library functions (macOS automatically links this in). Without the <span class="SANS_TheSansMonoCd_W5Regular_11">-math</span> option, you’ll get a linker error when you try to build the program.</p>&#13;
<p class="TX">The C stdlib contains many double-precision functions you might find useful. Check them out online for more details. Many of these functions are unnecessary in assembly language, as they correspond to one or two machine instructions. Nevertheless, the library contains complex functions that you wouldn’t want to write yourself.</p>&#13;
<p class="TX">You may find various functions online that purport to be faster than those in the C stdlib. Be careful about using them because they tend to be <span role="doc-pagebreak" epub:type="pagebreak" id="pg_352" aria-label="352"/>notoriously inaccurate. Unless you’re well grounded in numerical analysis, don’t try to write these functions yourself.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec53">&#13;
&#13;
<h3 class="H1" id="sec53"><span id="h1-88"/><span class="SANS_Futura_Std_Bold_B_11">6.12 Moving On</span></h3>&#13;
<p class="TNI1">This chapter covered a lot of material: the remaining arithmetic instructions (including multiplication, division, and remainder, as well as <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> and the various conditional instructions), maintaining variables in registers rather than memory locations, and the proper use of volatile and nonvolatile registers. It also discussed creating structures to provide efficient access to global variables, converting arithmetic and logical expressions (integer and floating-point) to their machine instruction equivalents, and calling functions written in C/C++.</p>&#13;
<p class="TX">Armed with this information, you can now convert arithmetic expressions in an HLL such as C/C++ to ARM assembly language. The only basic skill missing from your programming repertoire is a good understanding of control structures in assembly language, which you’ll learn in the next chapter.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec54">&#13;
&#13;
<h3 class="H1" id="sec54"><span id="h1-89"/><span class="SANS_Futura_Std_Bold_B_11">6.13 For More Information</span></h3>&#13;
<ul class="ul">&#13;
<li class="BL">My book <i>Write Great Code</i>, Volume 1 (No Starch Press, 2020), includes sections on the cache and thrashing.</li>&#13;
<li class="BL">Reference Wikipedia for details on fixed-point arithmetic: <i><a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic">https://<wbr/>en<wbr/>.wikipedia<wbr/>.org<wbr/>/wiki<wbr/>/Fixed<wbr/>-point<wbr/>_arithmetic</a></i>.</li>&#13;
<li class="BL">You can learn more about limited-precision arithmetic from the following resources:&#13;
<ul class="ul">&#13;
<li class="ListBulletSub">A Central Connecticut State University tutorial in the form of an interactive questionnaire: <i><a href="https://chortle.ccsu.edu/assemblytutorial/Chapter-29/ass29_10.html">https://<wbr/>chortle<wbr/>.ccsu<wbr/>.edu<wbr/>/assemblytutorial<wbr/>/Chapter<wbr/>-29<wbr/>/ass29<wbr/>_10<wbr/>.html</a></i>.</li>&#13;
<li class="ListBulletSub">Python documentation on the topic: <i><a href="https://docs.python.org/3/tutorial/floatingpoint.html">https://<wbr/>docs<wbr/>.python<wbr/>.org<wbr/>/3<wbr/>/tutorial<wbr/>/floatingpoint<wbr/>.html</a></i>.</li></ul></li>&#13;
<li class="BL">For more information on writing better code using floating-point arithmetic, see the following post on the Society of Actuaries website: <i><a href="https://www.soa.org/news-and-publications/newsletters/compact/2014/may/com-2014-iss51/losing-my-precision-tips-for-handling-tricky-floating-point-arithmetic">https://<wbr/>www<wbr/>.soa<wbr/>.org<wbr/>/news<wbr/>-and<wbr/>-publications<wbr/>/newsletters<wbr/>/compact<wbr/>/2014<wbr/>/may<wbr/>/com<wbr/>-2014<wbr/>-iss51<wbr/>/losing<wbr/>-my<wbr/>-precision<wbr/>-tips<wbr/>-for<wbr/>-handling<wbr/>-tricky<wbr/>-floating<wbr/>-point<wbr/>-arithmetic</a></i>.</li>&#13;
<li class="BL">Wikipedia documents the C stdlib math functions at <i><a href="https://en.wikipedia.org/wiki/C_mathematical_functions">https://<wbr/>en<wbr/>.wikipedia<wbr/>.org<wbr/>/wiki<wbr/>/C<wbr/>_mathematical<wbr/>_functions</a></i>.</li>&#13;
<li class="BL">If you insist on writing your own transcendental functions, you might try to locate a copy of the following book (long out of print), the “bible” of transcendental functions: <i>Computer Approximations,</i> by John F. Hart, E.W. Cheney, and Charles L. Lawson (Krieger Publishing, 1978).</li>&#13;
</ul>&#13;
<aside class="box" aria-label="box-22">&#13;
<p class="BH" id="box-22"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_353" aria-label="353"/><span class="SANS_Dogma_OT_Bold_B_11">TEST YOURSELF</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  1.  How does the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">instruction affect the zero flag?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  2.  How does the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">instruction affect the carry flag, with respect to an unsigned comparison?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  3.  How does the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">cmp</span> <span class="SANS_Futura_Std_Book_11">instruction affect the negative and overflow flags, with respect to a signed comparison?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  4.  Convert the following expressions to assembly language (assume all variables are signed 32-bit integers):</span></p>&#13;
<pre id="pre-545"><code>x = x + y&#13;
x = y - z&#13;
x = y * z&#13;
x = y + z * t&#13;
x = (y + z) * t&#13;
x = -((x * y) / z)&#13;
x = (y == z) &amp;&amp; (t != 0)</code></pre>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  5.  Compute the following expressions without using a</span> <span class="SANS_TheSansMonoCd_W5Regular_11">mul</span> <span class="SANS_Futura_Std_Book_11">instruction (assume all variables are signed 32-bit integers):</span></p>&#13;
<pre id="pre-546"><code>x = x * 2&#13;
x = y * 5&#13;
x = y * 8</code></pre>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  6.  Compute the following expressions without using a</span> <span class="SANS_TheSansMonoCd_W5Regular_11">udiv</span> <span class="SANS_Futura_Std_Book_11">or</span> <span class="SANS_TheSansMonoCd_W5Regular_11">sdiv</span> <span class="SANS_Futura_Std_Book_11">instruction (assume all variables are unsigned 64-bit integers):</span></p>&#13;
<pre id="pre-547"><code>x = x / 2&#13;
x = y / 8&#13;
x = z / 10</code></pre>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  7.  Convert the following expressions to assembly language (assume all variables are double-precision floating-point values):</span></p>&#13;
<pre id="pre-548"><code>x = x + y&#13;
x = y - z&#13;
x = y * z&#13;
x = y + z * t&#13;
x = (y + z) * t&#13;
x = -((x * y) / z)</code></pre>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  8.  Convert the following expressions to assembly language by using floating-point instructions. Assume</span> <span class="SANS_TheSansMonoCd_W5Regular_11">bb</span> <span class="SANS_Futura_Std_Book_11">is a 1-byte Boolean variable and</span> <span class="SANS_TheSansMonoCd_W5Regular_11">x</span><span class="SANS_Futura_Std_Book_11">,</span> <span class="SANS_TheSansMonoCd_W5Regular_11">y</span><span class="SANS_Futura_Std_Book_11">, and</span> <span class="SANS_TheSansMonoCd_W5Regular_11">z</span> <span class="SANS_Futura_Std_Book_11">are</span> <span class="SANS_TheSansMonoCd_W5Regular_11">.double</span> <span class="SANS_Futura_Std_Book_11">floating-point variables:</span></p>&#13;
<pre id="pre-549"><code>bb = x &lt; y&#13;
bb = x &gt;= y &amp;&amp; x &lt; z</code></pre>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>