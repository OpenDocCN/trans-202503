["```\n#define _BSD_SOURCE             /* Or: #define _SVID_SOURCE */\n#include <unistd.h>\n\nint `brk`(void **end_data_segment*);\n```", "```\nvoid *`sbrk`(intptr_t *`increment`*);\n```", "```\n#include <stdlib.h>\n\nvoid *`malloc`(size_t *size*);\n```", "```\n#include <stdlib.h>\n\nvoid `free`(void **ptr*);\n```", "```\n`memalloc/free_and_sbrk.c`\n\n#include \"tlpi_hdr.h\"\n#define MAX_ALLOCS 1000000\n\nint\nmain(int argc, char *argv[])\n{\n    char *ptr[MAX_ALLOCS];\n    int freeStep, freeMin, freeMax, blockSize, numAllocs, j;\n\n    printf(\"\\n\");\n\n    if (argc < 3 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s num-allocs block-size [step [min [max]]]\\n\", argv[0]);\n\n    numAllocs = getInt(argv[1], GN_GT_0, \"num-allocs\");\n    if (numAllocs > MAX_ALLOCS)\n        cmdLineErr(\"num-allocs > %d\\n\", MAX_ALLOCS);\n\n    blockSize = getInt(argv[2], GN_GT_0 | GN_ANY_BASE, \"block-size\");\n\n    freeStep = (argc > 3) ? getInt(argv[3], GN_GT_0, \"step\") : 1;\n    freeMin =  (argc > 4) ? getInt(argv[4], GN_GT_0, \"min\") : 1;\n    freeMax =  (argc > 5) ? getInt(argv[5], GN_GT_0, \"max\") : numAllocs;\n\n    if (freeMax > numAllocs)\n        cmdLineErr(\"free-max > num-allocs\\n\");\n\n    printf(\"Initial program break:          %10p\\n\", sbrk(0));\n\n    printf(\"Allocating %d*%d bytes\\n\", numAllocs, blockSize);\n    for (j = 0; j < numAllocs; j++) {\n        ptr[j] = malloc(blockSize);\n\n        if (ptr[j] == NULL)\n            errExit(\"malloc\");\n    }\n\n    printf(\"Program break is now:           %10p\\n\", sbrk(0));\n\n    printf(\"Freeing blocks from %d to %d in steps of %d\\n\",\n                freeMin, freeMax, freeStep);\n    for (j = freeMin - 1; j < freeMax; j += freeStep)\n        free(ptr[j]);\n\n    printf(\"After free(), program break is: %10p\\n\", sbrk(0));\n\n    exit(EXIT_SUCCESS);\n}\n     `memalloc/free_and_sbrk.c`\n```", "```\n$ `./free_and_sbrk 1000 10240 2`\n```", "```\nInitial program break:           0x804a6bc\nAllocating 1000*10240 bytes\nProgram break is now:            0x8a13000\nFreeing blocks from 1 to 1000 in steps of 2\nAfter free(), program break is:  0x8a13000\n```", "```\n$ `./free_and_sbrk 1000 10240 1 1 999`\n\nInitial program break:           0x804a6bc\nAllocating 1000*10240 bytes\nProgram break is now:            0x8a13000\nFreeing blocks from 1 to 999 in steps of 1\nAfter free(), program break is:  0x8a13000\n```", "```\n$ `./free_and_sbrk 1000 10240 1 500 1000`\n\nInitial program break:           0x804a6bc\nAllocating 1000*10240 bytes\nProgram break is now:            0x8a13000\nFreeing blocks from 500 to 1000 in steps of 1\nAfter free(), program break is:  0x852b000\n```", "```\n#include <stdlib.h>\n\nvoid *`calloc`(size_t *numitems*, size_t *size*);\n```", "```\nstruct { /* Some field definitions */ } myStruct;\nstruct myStruct *p;\n\np = calloc(1000, sizeof(struct myStruct));\nif (p == NULL)\n    errExit(\"calloc\");\n```", "```\n#include <stdlib.h>\n\nvoid *`realloc`(void **ptr*, size_t *size*);\n```", "```\nnptr = realloc(ptr, newsize);\nif (nptr == NULL) {\n    /* Handle error */\n} else {                /* realloc() succeeded */\n    ptr = nptr;\n}\n```", "```\n#include <malloc.h>\n\nvoid *`memalign`(size_t *boundary*, size_t *size*);\n```", "```\n#include <stdlib.h>\n\nint `posix_memalign`(void ***memptr*, size_t *alignment*, size_t *size*);\n```", "```\nint s;\nvoid *memptr;\n\ns = posix_memalign(&memptr, 1024 * sizeof(void *), 65536);\nif (s != 0)\n    /* Handle error */\n```", "```\n#include <alloca.h>\n\nvoid *`alloca`(size_t *size*);\n```", "```\nfunc(x, alloca(size), z);           /* WRONG! */\n```", "```\nvoid *y;\n\ny = alloca(size);\nfunc(x, y, z);\n```"]