<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_65"/><strong><span class="big">7</span></strong><br/><strong>CROSS-SITE SCRIPTING ATTACKS</strong></h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="image" width="190" height="190"/></div>&#13;
<p class="noindent">In the previous chapter, you saw how attackers can inject code into web servers to compromise websites. If your web server is secure, a hacker’s next best injection target is the web browser. Browsers obediently execute any JavaScript code that appears in a web page, so if an attacker can find a way to inject malicious JavaScript into a user’s browser while the user views your website, that user is in for a bad time. We call this type of code injection a <em>cross-site scripting (XSS) attack</em>.</p>&#13;
<p class="indent">JavaScript can read or modify any part of a web page, so there’s a lot an attacker can do with cross-site scripting vulnerabilities. They can steal login credentials or other sensitive information like credit card numbers as the user types them in. If JavaScript can read the HTTP session information, they can hijack a user’s session entirely, allowing them to log in as that user remotely. (You’ll learn more about session hijacking in <a href="ch10.xhtml#ch10">Chapter 10</a>).</p>&#13;
<p class="indent">Cross-site scripting is a remarkably common type of attack, and the dangers it poses are clear. This chapter presents the three most common types of cross-site scripting attacks and explains how to protect against them.</p>&#13;
<h3 class="h3" id="ch00lev1sec91"><span epub:type="pagebreak" id="page_66"/><strong>Stored Cross-Site Scripting Attacks</strong></h3>&#13;
<p class="noindent">Websites routinely generate and render HTML using information stored in a database. Retail websites will store product information in a database, and social media sites will store user conversations. Websites will take content from the database according to the URL the user has navigated to, and interpolate it into the page to produce the finished HTML.</p>&#13;
<p class="indent">Any page content coming from the database is a potential attack vector for hackers. Attackers will attempt to inject JavaScript code into the database so that the web server will write out the JavaScript when it renders HTML. We call this type of attack a <em>stored cross-site scripting</em> attack: the JavaScript is written to the database, but executed in the browser when an unsuspecting victim views a particular page on the site.</p>&#13;
<p class="indent">Malicious JavaScript can be planted in a database by using the SQL injection method described in <a href="ch06.xhtml#ch06">Chapter 6</a>, but attackers will more commonly insert malicious code through legitimate avenues. For instance, if a website allows users to post comments, the site will store the comment text in a database and display it back to other users who view the same comment thread. In this scenario, an easy way for a hacker to perform a cross-site scripting attack is to write a comment containing a <code>&lt;script&gt;</code> tag to the database. If the website fails to construct HTML securely, the <code>&lt;script&gt;</code> tag will get written out whenever the page is rendered to other users, and the JavaScript will be executed in the victim’s browser.</p>&#13;
<p class="indent">Let’s look at a concrete example. Imagine you run a popular website for people who like to bake, <em>https://breddit.com</em>. Your site encourages users to participate in discussion threads about bread-related topics. While using the online forum for discussion, the users themselves contribute most of the site’s content. When a user adds a post, your website records it to the database and shows it to other users participating in the same thread. This is a perfect opportunity for an attacker to inject some JavaScript through a comment, as shown in <a href="ch07.xhtml#ch7fig1">Figure 7-1</a>.</p>&#13;
<div class="image"><img src="Images/07fig01.jpg" alt="image" width="1178" height="670"/></div>&#13;
<p class="figcap"><a id="ch7fig1"/><em>Figure 7-1: An attacker injects JavaScript through a comment.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_67"/>If your website doesn’t escape the injected script when it renders the HTML (as we’ll discuss in the following section), the next user to view the thread will have the attacker’s <code>&lt;script&gt;</code> tag written out to their browser and executed, as shown in <a href="ch07.xhtml#ch7fig2">Figure 7-2</a>.</p>&#13;
<div class="image"><img src="Images/07fig02.jpg" alt="image" width="1173" height="755"/></div>&#13;
<p class="figcap"><a id="ch7fig2"/><em>Figure 7-2: An attacker’s <span class="codeitalic">&lt;script&gt;</span> tag is written out to the victim’s browser and executed.</em></p>&#13;
<p class="indent">A rogue <code>alert()</code> dialog is more of an annoyance than a genuine threat, but attackers typically start with this approach to check whether cross-site scripting attacks are possible. If an attacker can call the <code>alert()</code> function, they can escalate to more dangerous attacks, like stealing other users’ sessions, or redirecting victims to harmful sites. The baking community would never feel safe online again!</p>&#13;
<p class="indent">Comment threads aren’t the only place that can exhibit this type of vulnerability. <em>Any</em> user-controlled content is a potential avenue of attack that you need to secure. Attackers have performed cross-site scripting attacks by injecting malicious script tags into usernames, profile pages, and online reviews, for example. Let’s look at a couple of straightforward protections you should implement.</p>&#13;
<h4 class="h4" id="ch00lev1sec92"><strong><em>Mitigation 1: Escape HTML Characters</em></strong></h4>&#13;
<p class="noindent">To prevent stored cross-site scripting attacks, you need to escape all dynamic content coming from a datastore so that the browser knows to treat it as the <em>content</em> of HTML tags, as opposed to raw HTML. <em>Escaping</em> content in the browser means replacing control characters in the HTML with their corresponding <em>entity encoding</em>, as illustrated in <a href="ch07.xhtml#ch7tab01">Table 7-1</a>.</p>&#13;
<p class="tabcap"><span epub:type="pagebreak" id="page_68"/><a id="ch7tab01"/><strong>Table 7-1:</strong> Entity Encodings of HTML Control Characters</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-h"><p class="noindent-th"><strong>Character</strong></p></td>&#13;
<td style="vertical-align: top;" class="table-h"><p class="noindent-th"><strong>Entity encoding</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="noindent-th"><code>"</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="noindent-th"><code>&amp;quot;</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="tableth"><p class="noindent-th"><code>&amp;</code></p></td>&#13;
<td style="vertical-align: top;" class="tableth"><p class="noindent-th"><code>&amp;amp;</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="noindent-th"><code>'</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="noindent-th"><code>&amp;apos;</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="tableth"><p class="noindent-th"><code>&lt;</code></p></td>&#13;
<td style="vertical-align: top;" class="tableth"><p class="noindent-th"><code>&amp;lt;</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="noindent-th"><code>&gt;</code></p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="noindent-th"><code>&amp;gt;</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Any character that has special meaning in HTML, like the <code>&lt;</code> and <code>&gt;</code> characters that denote the start and end of tags, has a corresponding safe entity encoding. Browsers that encounter <em>entity encodings</em> recognize them as escaped characters, and render them visually as the appropriate character, but, crucially, won’t treat them as HTML tags. <a href="ch07.xhtml#ch7list1">Listing 7-1</a> shows how a secure website will write out the comment entered by the attack in <a href="ch07.xhtml#ch7fig1">Figure 7-1</a>. The bolded text represents characters that could be used to construct HTML tags.</p>&#13;
<pre>&lt;div class="comment"&gt;<br/>  <span class="codestrong1">&amp;lt;</span>script<span class="codestrong1">&amp;gt;</span>alert(<span class="codestrong1">&amp;quot;</span>HAXXED<span class="codestrong1">&amp;quot;</span>)<span class="codestrong1">&amp;lt;</span>/script<span class="codestrong1">&amp;gt;</span><br/>&lt;/div&gt;</pre>&#13;
<p class="caption"><a id="ch7list1"/><em>Listing 7-1: This attempted XSS attack has been defused.</em></p>&#13;
<p class="indent">The conversion of escaped characters to unescaped characters happens <em>after</em> the browser has constructed the DOM for the page, so the browser will <em>not</em> execute the <code>&lt;script&gt;</code> tag. Escaping HTML control characters in this fashion closes the door on most cross-site scripting attacks.</p>&#13;
<p class="indent">Since cross-site scripting is such a common vulnerability, modern web frameworks tend to escape dynamic content by default. Templates, in particular, typically escape interpolated values without being asked. The syntax for interpolating a variable in an <em>Embedded Ruby (ERB)</em> template looks like <a href="ch07.xhtml#ch7list2">Listing 7-2</a>.</p>&#13;
<pre>&lt;div class="comment"&gt;<br/>  <span class="codestrong1">&lt;%=</span> comment <span class="codestrong1">%&gt;</span><br/>&lt;/div&gt;</pre>&#13;
<p class="caption"><a id="ch7list2"/><em>Listing 7-2: Implicit escaping of dynamic content in an Embedded Ruby template</em></p>&#13;
<p class="indent">The ERB templating engine will automatically escape sensitive characters via the <code>&lt;%= comment %&gt;</code> syntax when dynamic content is evaluated.</p>&#13;
<p class="indent">In order to write raw, unescaped HTML (and hence be vulnerable to XSS attacks), ERB templates require an explicit call to the <code>raw</code> function, as shown in <a href="ch07.xhtml#ch7list3">Listing 7-3</a>.</p>&#13;
<pre>&lt;div class="comment"&gt;<br/>  &lt;%= <span class="codestrong1">raw</span> comment %&gt;<br/>&lt;/div&gt;</pre>&#13;
<p class="caption"><a id="ch7list3"/><em>Listing 7-3: The syntax to allow raw injection of HTML in Embedded Ruby templates</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_69"/>All secure templating languages follow the same design principle: the templating engine implicitly escapes dynamic content unless the developer explicitly chooses to construct raw HTML. Make sure you understand how escaping works in your templates, and check that dynamic content is securely escaped during code reviews! In particular, if you have helper functions or methods that construct raw HTML for injection into templates, check to see that an attacker can’t abuse their inputs to commit cross-site scripting attacks.</p>&#13;
<h4 class="h4" id="ch00lev1sec93"><strong><em>Mitigation 2: Implement a Content Security Policy</em></strong></h4>&#13;
<p class="noindent">Modern browsers allow websites to set a <em>content security policy</em>, which you can use to lock down JavaScript execution on your site. Cross-site scripting attacks rely on an attacker being able to run malicious scripts on a victim’s web page, usually by injecting <code>&lt;script&gt;</code> tags somewhere within the <code>&lt;html&gt;</code> tag of a page, also known as <em>inline</em> JavaScript. The example hack illustrated in <a href="ch07.xhtml#ch7fig2">Figure 7-2</a> uses inline JavaScript, written out as the text of a comment.</p>&#13;
<p class="indent">By setting a content security policy in your HTTP response headers, you can tell the browser to <em>never</em> execute inline JavaScript. The browser will execute JavaScript on your page only if it is imported via a <code>src</code> attribute in the <code>&lt;script&gt;</code> tag. A typical content security policy header will look like <a href="ch07.xhtml#ch7list4">Listing 7-4</a>. This policy specifies that scripts can be imported from the same domain (<code>'self'</code>), or the <em>apis.google.com</em> domain, but inline JavaScript should not be executed.</p>&#13;
<pre>Content-Security-Policy: script-src 'self' https://apis.google.com</pre>&#13;
<p class="caption"><a id="ch7list4"/><em>Listing 7-4: A content security policy set in an HTTP response header</em></p>&#13;
<p class="indent">You can also set your site’s content security policy in a <code>&lt;meta&gt;</code> tag in the <code>&lt;head&gt;</code> element of the HTML of your web pages, as shown in <a href="ch07.xhtml#ch7list5">Listing 7-5</a>.</p>&#13;
<pre>&lt;meta http-equiv="Content-Security-Policy" content="script-src 'self' https://apis.google.com"&gt;</pre>&#13;
<p class="caption"><a id="ch7list5"/><em>Listing 7-5: The equivalent content security policy set in a <span class="codeitalic">&lt;head&gt;</span> element of the HTML document</em></p>&#13;
<p class="indent">By whitelisting the domains from which your browser loads scripts, you implicitly state that inline JavaScript isn’t allowed. In this example content security policy, the browser will load JavaScript only from the domains <em>apis.google.com</em> and whatever the domain of the site is—for example, <em><a href="http://breddit.com">breddit.com</a></em>. To permit inline JavaScript, the policy would have to include the keyword <code>unsafe-inline</code>.</p>&#13;
<p class="indent">Preventing the execution of inline JavaScript is a great security measure, but it means you’ll have to move any inline JavaScript your site currently implements into separate imports. In other words, <code>&lt;script&gt;</code> tags on a page have to reference JavaScript in a separate file via a <code>src</code> attribute, rather than writing the JavaScript between the start and end tags.</p>&#13;
<p class="indent">This separation of JavaScript into external files is the preferred approach in web development, since it makes for a more organized codebase. Inline <span epub:type="pagebreak" id="page_70"/>script tags are considered bad practice in modern web development, so banning inline JavaScript actually forces your development team into good habits. Nevertheless, inline script tags are common in older, legacy sites. Indeed, it may take some time to refactor your templates to remove all inline JavaScript tags.</p>&#13;
<p class="indent">To help with this refactoring, consider using content security policy <em>violation reports</em>. If you add a <code>report-uri</code> directive to your content security policy header, as shown in <a href="ch07.xhtml#ch7list6">Listing 7-6</a>, the browser will notify you of any policy violations, rather than preventing JavaScript from executing.</p>&#13;
<pre>Content-Security-Policy-Report-Only: script-src 'self'; report-uri https://example.com/csr-reports</pre>&#13;
<p class="caption"><a id="ch7list6"/><em>Listing 7-6: A content security policy that instructs the browser to report any content security violations to</em> https://example.com/csr-reports</p>&#13;
<p class="indent">If you collect all these violation reports in a log file, your development team should be able to see all the pages they need to rewrite in order to meet the restrictions imposed by the proposed content security policy.</p>&#13;
<p class="indent">You should set a content security policy in addition to escaping HTML, since it’ll protect your users effectively! It’s difficult for an attacker to find an instance of unescaped content <em>and</em> to smuggle a malicious script onto your whitelisted domains. We call using multiple layers of defense for the same vulnerability defense in depth, as you learned in <a href="ch06.xhtml#ch06">Chapter 6</a>; this will be a theme throughout this book.</p>&#13;
<h3 class="h3" id="ch00lev1sec94"><strong>Reflected Cross-Site Scripting Attacks</strong></h3>&#13;
<p class="noindent">Rogue JavaScript in the database isn’t the only vector for cross-site scripting attacks. If your site takes part of an HTTP request and displays it back in a rendered web page, your rendering code needs to protect against attacks that inject malicious JavaScript via the HTTP request. We call this type of attack a <em>reflected cross-site scripting</em> attack.</p>&#13;
<p class="indent">Virtually all websites display some part of HTTP requests in rendered HTML. Consider the Google search page: if you perform a search for “cats,” Google passes the search term as part of the HTTP in the URL: <em><a href="https://www.google.com/search?q=cats">https://www.google.com/search?q=cats</a></em>. The search term <code>cats</code> displays in the search box above the search results.</p>&#13;
<p class="indent">Now, if Google were a less secure company, it’d be possible to replace the <em>cats</em> parameter in the URL with malicious JavaScript, and have that JavaScript code execute whenever anybody opens that URL in their browser. An attacker could email the URL as a link to a victim, or trick a user into visiting the URL by adding it to a comment. This is the essence of a <em>reflected</em> cross-site scripting attack: an attacker sends the malicious code in the HTML request, and then the server reflects it back.</p>&#13;
<p class="indent">Thankfully, Google employs more than a few security experts, so if you attempt to insert <code>&lt;script&gt;</code> tags into its search results, the server won’t execute the JavaScript. In the past, hackers <em>have</em> discovered reflected <span epub:type="pagebreak" id="page_71"/>cross-site scripting vulnerabilities in the Google Apps admin interface found at <em><a href="https://admin.google.com">https://admin.google.com</a></em>, so it goes to show that even big companies get caught out. If you want any chance of keeping your users safe, you need to protect against this attack vector.</p>&#13;
<h4 class="h4" id="ch00lev1sec95"><strong><em>Mitigation: Escape Dynamic Content from HTTP Requests</em></strong></h4>&#13;
<p class="noindent">You mitigate reflected cross-site scripting vulnerabilities the same way you mitigate stored cross-site scripting vulnerabilities: by escaping control characters in dynamic content that the website interpolates into HTML pages. Whether dynamic content comes from the backend database or the HTTP request, you need to escape it in the same way.</p>&#13;
<p class="indent">Thankfully, template languages typically apply escaping to <em>all</em> interpolated variables, whether the templates load them from the database or pull them from the HTTP request. However, your development team still needs to be aware of the risk of injection via HTTP requests when auditing code. Code reviews often overlook reflected cross-site scripting vulnerabilities because developers are too busy looking for stored cross-site scripting vulnerabilities.</p>&#13;
<p class="indent">Common target areas for reflected cross-site scripting attacks are search pages and error pages, since they usually display parts of the query string back to the user. Make sure your team understands the risks and knows how to spot the vulnerability when reviewing code changes. Stored cross-site scripting attacks tend to be more harmful, because a single malicious piece of JavaScript injected into your database table can attack your users over and over again. But reflected attacks are more common, since they’re easier to implement.</p>&#13;
<p class="indent">Before we close this chapter, let’s look at one more type of cross-site scripting attack.</p>&#13;
<h3 class="h3" id="ch00lev1sec96"><strong>DOM-Based Cross-Site Scripting Attacks</strong></h3>&#13;
<p class="noindent">Defusing most cross-site scripting attacks means inspecting and securing server-side code; however, the increasing popularity of rich frameworks for client-side code has led to the rise of <em>DOM-based cross-site scripting</em>, whereby attackers smuggle malicious JavaScript into a user’s web page via the URI fragment.</p>&#13;
<p class="indent">To understand these attacks, you first need to understand how URI fragments operate. Let’s start with a reminder of how <em>URLs (universal resource locators)</em>, the addresses shown in the browser bar, are structured. A typical URL looks like <a href="ch07.xhtml#ch7fig3">Figure 7-3</a>.</p>&#13;
<div class="image"><img src="Images/07fig03.jpg" alt="image" width="1036" height="171"/></div>&#13;
<p class="figcap"><a id="ch7fig3"/><em>Figure 7-3: The sections of a typical URL</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_72"/>The URI fragment is the optional part of the URL after the <em>#</em> sign. Browsers use <em>URI fragments</em> for <em>intra-page</em> navigation—if an HTML tag on the page has an <code>id</code> attribute matching the URI fragment, the browser scrolls to that tag after opening the page. For instance, if you load the URL <em><a href="https://en.wikipedia.org/wiki/Cat#Grooming">https://en.wikipedia.org/wiki/Cat#Grooming</a></em> in a browser, the browser opens the web page and then scrolls to the Grooming section of the Wikipedia page about cats. It behaves this way because the heading tag for that section looks something like <a href="ch07.xhtml#ch7list7">Listing 7-7</a>.</p>&#13;
<pre>&lt;h3 id="Grooming"&gt;Grooming&lt;/h3&gt;</pre>&#13;
<p class="caption"><a id="ch7list7"/><em>Listing 7-7: An HTML tag corresponding to the URI fragment</em> #Grooming</p>&#13;
<p class="indent">With this helpful built-in browser behavior, Wikipedia lets users link directly to sections within a page, so that you and your roommate can finally settle that contentious argument about cat grooming.</p>&#13;
<p class="indent"><em>Single-page apps</em> also often use URI fragments to record and reload state in an intuitive fashion. These types of apps, written in JavaScript frameworks like Angular, Vue.js, and React, are actually JavaScript-heavy web pages that seek to avoid the rendering <em>blink</em> that occurs when the browser reloads a web page.</p>&#13;
<p class="indent">One potential way to avoid this rendering blink is designing the whole app to load under a static URL that never changes, because changing the URL in the browser bar is typically what causes a web page to reload. However, if a user refreshes a browser for an unchanging URL, the browser resets the web page to its initial state, losing any information about what the user was doing previously.</p>&#13;
<p class="indent">Many single-page apps overcome this by using the URI fragment to keep state over browser refreshes. You’ll commonly see web pages implement <em>infinite scrolling</em>: a list of images dynamically loads in as the user scrolls down the page. The URI fragment updates with an indication of how far the user has scrolled down. Then, even if the browser refreshes, the JavaScript code can interpret the content of the URI fragment, and load in the relevant number of images as the page refreshes.</p>&#13;
<p class="indent">By design, browsers don’t send URI fragments to the server when the browser renders the page. When a browser receives a URL with a URI fragment, it makes a note of the fragment, strips it from the URL, and sends the stripped URL to the web server. Any JavaScript executed on the page can read the URI fragment, and the browser will write the full URL to the browser history, or to a bookmark, if the user bookmarks the page.</p>&#13;
<p class="indent">Unfortunately, this means that URI fragments aren’t available to any server-side code—securing server-side code <em>can’t</em> mitigate DOM-based XSS attacks. Client-side JavaScript code that interprets and uses URI fragments needs to be careful about how it interprets the content of those fragments. If the content is unescaped and written directly into the DOM of the web page, an attacker can smuggle malicious JavaScript through this channel. An attacker can craft a URL with some malicious JavaScript in the URI fragment, and then trick a user into visiting that URL to launch the cross-site scripting attack.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_73"/>DOM-based cross-site scripting is a relatively new form of attack, but is particularly dangerous because the injection of code happens completely on the client side, and can’t be detected by examining web server logs! This means you need to be keenly aware of the vulnerability when doing code reviews, and know how to mitigate it.</p>&#13;
<h4 class="h4" id="ch00lev1sec97"><strong><em>Mitigation: Escaping Dynamic Content from URI Fragments</em></strong></h4>&#13;
<p class="noindent">Any JavaScript code executing in the browser that takes part of the URI fragment and constructs HTML is prone to DOM-based cross-site scripting attacks. This means you need to take care to <em>escape</em> anything taken from a URI fragment before interpolating that value in HTML with the client-side code, just as you would with server-side code.</p>&#13;
<p class="indent">The authors of modern JavaScript templating frameworks are fully aware of the risks posed by URI fragments and discourage the construction of raw HTML in code. For instance, the syntax to write unescaped HTML in the React framework requires the developer to call the function <code>dangerouslySetInnerHTML</code>, as shown in <a href="ch07.xhtml#ch7list8">Listing 7-8</a>.</p>&#13;
<pre>function writeSomeHTML () {<br/>  return {__html: 'First &amp;middot; Second'};<br/>}<br/>function MyComponent() {<br/>  return &lt;div <span class="codestrong1">dangerouslySetInnerHTML</span>={writeSomeHTML()} /&gt;;<br/>}</pre>&#13;
<p class="caption"><a id="ch7list8"/><em>Listing 7-8: Dangerously setting raw HTML from text in the React framework</em></p>&#13;
<p class="indent">Consider switching to a modern JavaScript framework if your client-side JavaScript code is complex. It should make the codebase more manageable and security considerations much more apparent. And as always, be sure to set an appropriate content security policy.</p>&#13;
<h3 class="h3" id="ch00lev1sec98"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you learned about cross-site scripting attacks, whereby an attacker injects JavaScript into the pages of your site when users view them. Attackers usually inject malicious JavaScript into dynamic content that comes from a database, from the HTTP request, or from the URI fragment. You can defeat cross-site scripting attacks by escaping any HTML control characters in dynamic content, and by setting a content security policy that prevents the execution of inline JavaScript.</p>&#13;
<p class="indent">In the next chapter, you’ll look at another method that attackers can use to prey on the users of your website: cross-site request forgery.<span epub:type="pagebreak" id="page_74"/></p>&#13;
</div>



  </body></html>