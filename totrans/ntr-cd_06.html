<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2s" id="ch05"><span epub:type="pagebreak" id="page_213"/><strong><span class="big">5</span> <span class="float">Autonomous Agents</span></strong></h2>&#13;
<p class="bq"><em>Life is a journey, not a destination.</em></p>&#13;
<p class="att">—Ralph Waldo Emerson</p>&#13;
<div class="image"><img src="../images/pg253_Image_364.jpg" alt="Image" width="1125" height="633"/></div>&#13;
<p class="caption"><strong>Mo’i fish (photo courtesy of the US National Oceanic and Atmospheric Administration)</strong></p>&#13;
<p class="noindent7">Six-finger threadfins (<em>Polydactylus sexfilis</em>), also known as fish of kings, or <em>mo</em>’<em>i</em>, in Hawaiian, are shown swimming in a shoal. The mo’i fish held a special status for Hawaiian royalty and were raised in dedicated ponds to ensure their population growth and prevent their extinction. The fish display a delicate and coordinated dance in their collective movement, with each individual mo’i subtly influencing and being influenced by its neighboring fish.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_214"/>So far, I’ve been demonstrating inanimate objects, lifeless shapes sitting on the canvas that flop around when affected by forces in their environment. But this is <em>The <strong>Nature</strong> of Code</em>. What if I could breathe life into those shapes? What if those shapes could live by their own rules? Can shapes have hopes and dreams and fears? These sorts of questions are the domain of this chapter. They’re what separate unthinking objects from something much more interesting: autonomous agents.</p>&#13;
<h3 class="h3" id="ch00lev1sec49"><strong>Forces from Within</strong></h3>&#13;
<p class="noindent">An <strong>autonomous agent</strong> is an entity that makes its own choices about how to act in its environment, without any influence from a leader or global plan. In this book, <em>acting</em> typically means moving. For example, instead of simulating a particle that’s passively drawn toward or repelled by another shape because of a force like gravity, I’d now like to design an entity that has the ability—or even the “desire”—to make decisions about its movements. It could <em>decide</em> to move toward or away from a target, like a moth drawn to a flame or a small fish evading a predator.</p>&#13;
<p class="noindent">The switch from inanimate objects to autonomous agents is a significant conceptual leap, but the codebase will barely change. The desire for an autonomous agent to move is just another force, like the force of gravity or the force of the wind. It’s just that now the force is coming <em>from within</em>.</p>&#13;
<p class="noindent">Here are three key components of autonomous agents to keep in mind as I build this chapter’s examples:</p>&#13;
<ul class="bullet">&#13;
<li class="noindent"><strong>An autonomous agent has a limited ability to perceive its environment.</strong> It makes sense that a living, breathing being should be aware of its environment. However, this awareness doesn’t refer to just the external environment but also to the agent’s internal state—its position, velocity, and potentially other properties or even simulated emotions. Throughout the chapter, I’ll explore ways agents can take their own state into account when making decisions. I’ll also cover programming techniques for objects to store references to other objects and therefore “perceive” their surroundings. It’s important to consider the word <em>limited</em> here. Are you designing an all-knowing circle that flies around a canvas, aware of everything else in that canvas? Or are you creating a shape that can examine other shapes only within 15 pixels of itself? Of course, there’s no right answer to this question; it all depends on what you want. I’ll explore several possibilities throughout this chapter, but in general, limitations are good for creating a simulation that feels more “natural.” An insect, for example, may be aware of only the sights and smells that immediately surround it. To model a real-world creature, you could study the exact science of these limitations. Luckily, I can just make stuff up and try it out.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_215"/><strong>An autonomous agent processes the information from its environment and calculates an action.</strong> This will be the easy part, as the action is a force. The environment might tell the agent that there’s a big, scary-looking shark swimming right at it, and the action will be a powerful force in the opposite direction.</li>&#13;
<li class="noindent"><strong>An autonomous agent has no leader.</strong> This third principle is something I care a little less about, depending on the context. For example, if you’re designing a system for which it makes sense to have a leader barking commands at various entities, then that’s what you’ll want to implement. Nevertheless, many of the chapter’s examples will have no leader for an important reason: toward the end of this chapter, I’ll examine group behaviors and look at designing collections of autonomous agents that exhibit the properties of <strong>complex systems</strong>. These are intelligent and structured group dynamics that emerge not from a leader, but from the local interactions of the elements themselves.</li>&#13;
</ul>&#13;
<p class="noindent">I could start my exploration of autonomous agents in many places. Artificial simulations of ant and termite colonies are fantastic demonstrations of systems of agents, for example. For more on this topic, I encourage you to read <em>Turtles, Termites, and Traffic Jams</em> by Mitchel Resnick (Bradford Books, 1997). However, I want to begin by examining agent behaviors that build on the work in the first four chapters of this book: modeling motion with vectors and forces. And so I’ll return to the book’s ever-changing hero class—once <span class="literal">Walker</span>, then <span class="literal">Mover</span>, then <span class="literal">Particle</span>—and give it yet another incarnation.</p>&#13;
<h3 class="h3" id="ch00lev1sec50"><strong>Vehicles and Steering</strong></h3>&#13;
<p class="noindent">In the late 1980s, computer scientist Craig Reynolds (<em><a href="https://www.red3d.com/cwr">https://www.red3d.com/cwr</a></em>) developed algorithmic <strong>steering</strong> behaviors for animated characters. These behaviors allowed individual elements to navigate their digital environments in a lifelike manner, with strategies for fleeing, wandering, arriving, pursuing, evading, and more. Later, in his 1999 paper “Steering Behaviors for Autonomous Characters,” Reynolds uses the word <em>vehicle</em> to describe his autonomous agents. I’ll follow suit, calling my autonomous agent class <span class="literal">Vehicle</span>:</p>&#13;
<div class="imagel"><img src="../images/pg255_Image_364a.jpg" alt="Image" width="1139" height="323"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_216"/>Like the <span class="literal">Mover</span> and <span class="literal">Particle</span> classes before it, the <span class="literal">Vehicle</span> class’s motion is controlled through its position, velocity, and acceleration vectors. This will make the steering behaviors of a single autonomous agent straightforward to implement. Yet by building a system of multiple vehicles that steer themselves according to simple, locally based rules, surprising levels of complexity emerge. The most famous example is Reynolds’s boids model for flocking or swarming behavior, which I’ll demonstrate in <a href="ch05.xhtml#ch5ex11">Example 5.11</a>.</p>&#13;
<div class="box">&#13;
<p class="box-title"><img class="inline" src="../images/zoom.jpg" alt="Image" width="24" height="31"/> <strong>Why Vehicles?</strong></p>&#13;
<p class="noindent">In his book <em>Vehicles: Experiments in Synthetic Psychology</em> (Bradford Books, 1986), Italian neuroscientist and cyberneticist Valentino Braitenberg describes a series of hypothetical vehicles with simple internal structures, writing, “This is an exercise in fictional science, or science fiction, if you like that better.” Braitenberg argues that his extraordinarily simple mechanical vehicles manifest behaviors such as fear, aggression, love, foresight, and optimism. Reynolds took his inspiration from Braitenberg, and I’ll take mine from Reynolds.</p>&#13;
</div>&#13;
<p class="noindent">Reynolds describes the motion of <em>idealized</em> vehicles—idealized because he wasn’t concerned with their actual engineering, but rather started with the assumption that they work and respond to the rules defined. These vehicles have three layers:</p>&#13;
<ol class="order">&#13;
<li class="noindent"><strong>Action selection:</strong> A vehicle has a goal (or goals) and can choose an action (or a combination of actions) based on that goal. This is essentially where I left off in the discussion of autonomous agents. The vehicle takes a look at its environment and <em>selects</em> an action based on a desire: “I see a zombie marching toward me. Since I don’t want my brains to be eaten, I’m going to flee from the zombie.” The goal is to keep one’s brains, and the action is to flee. Reynolds’s paper describes many goals and associated actions, such as seeking a target, avoiding an obstacle, and following a path. In a moment, I’ll start building out these examples with p5.js code.</li>&#13;
<li class="noindent"><strong>Steering:</strong> Once an action has been selected, the vehicle has to calculate its next move. That next move will be a force—more specifically, a steering force. Luckily, Reynolds has developed a simple steering force formula that I’ll use throughout the examples in this chapter: <strong>steering force = desired velocity – current velocity</strong>. I’ll get into the details of this formula and why it works so effectively in the next section.</li>&#13;
<li class="noindent"><strong>Locomotion:</strong> For the most part, I’m going to ignore this third layer. In the case of fleeing from zombies, the locomotion could be described as “left foot, right foot, left foot, right foot, as fast as you can.” In a canvas, however, a rectangle, circle, or triangle’s actual movement across a window is irrelevant, given that the motion is all an illusion in the first place. This isn’t to say that you should ignore locomotion entirely, however. You’ll find great value in thinking about the locomotive design of your vehicle and how you choose to animate it. The examples in this chapter will remain visually bare; a good <span epub:type="pagebreak" id="page_217"/>exercise would be to elaborate on the animation style. For example, could you add spinning wheels, oscillating paddles, or shuffling legs?</li>&#13;
</ol>&#13;
<p class="noindent">Ultimately, the most important layer for you to consider is the first one, action selection. What are the elements of your system, and what are their goals? In this chapter, I’m going to cover a series of steering behaviors (that is, actions): seeking, fleeing, following a path, following a flow field, flocking with your neighbors, and so on. As I’ve said in other chapters, however, the point isn’t that you should use these exact behaviors in all your projects. Rather, the point is to show you <em>how</em> to model a steering behavior—<em>any</em> steering behavior—in code, and to provide a foundation for designing and developing your own vehicles with new and exciting goals and behaviors.</p>&#13;
<p class="noindent">What’s more, even though the examples in this chapter are highly literal (follow that pixel!), you should allow yourself to think more abstractly (like Braitenberg). What would it mean for your vehicle to have “love” as its goal or “fear” as its driving force? Finally (and I’ll address this in “Combining Behaviors” on <a href="ch05.xhtml#ch00lev2sec36">page 265</a>), you won’t get very far by developing simulations with only one action. Yes, the first example’s action will be to seek a target. But by being creative—by making these steering behaviors <em>your own</em>—it will all come down to mixing and matching multiple actions within the same vehicle. View the coming examples not as singular behaviors to be emulated, but as pieces of a larger puzzle that you’ll eventually assemble.</p>&#13;
<h4 class="h4" id="ch00lev2sec29"><strong>The Steering Force</strong></h4>&#13;
<p class="noindent">What exactly is a steering force? To answer, consider the following scenario: a vehicle with a current velocity is seeking a target. For fun, let’s think of the vehicle as a bug-like creature that desires to savor a delicious strawberry, as in <a href="ch05.xhtml#ch5fig1">Figure 5.1</a>.</p>&#13;
<div class="image"><img id="ch5fig1" src="../images/pg257_Image_365.jpg" alt="Image" width="910" height="280"/></div>&#13;
<p class="figcap">Figure 5.1: A vehicle with a velocity and a target</p>&#13;
<p class="noindent">The vehicle’s goal and subsequent action is to seek the target. Thinking back to <a href="ch02.xhtml#ch02">Chapter 2</a>, you might begin by making the target an attractor and applying a gravitational force that pulls the vehicle to the target. This would be a perfectly reasonable solution, but conceptually it’s not what I’m looking for here.</p>&#13;
<p class="noindent">I don’t want to simply calculate a force that pushes the vehicle toward its target; rather, I want to ask the vehicle to make an intelligent decision to steer toward the target based on its perception of its <span epub:type="pagebreak" id="page_218"/>own state (its speed and the direction in which it’s currently moving) and its environment (the location of the target). The vehicle should consider how it desires to move (a vector pointing to the target), compare that goal with how it’s currently moving (its velocity), and apply a force accordingly. That’s exactly what Reynolds’s steering force formula says:</p>&#13;
<p class="hang">steering force = desired velocity − current velocity</p>&#13;
<p class="noindent">Or, as you might write in p5.js:</p>&#13;
<pre class="pre">let steer = p5.Vector.sub(desired, velocity);</pre>&#13;
<p class="noindent">The <em>current</em> velocity isn’t a problem: the <span class="literal">Vehicle</span> class already has a variable for that. However, the <em>desired</em> velocity has to be calculated. Take a look at <a href="ch05.xhtml#ch5fig2">Figure 5.2</a>. If the vehicle’s goal is defined as <em>seeking the target</em>, then its desired velocity is a vector that points from its current position to the target position.</p>&#13;
<div class="image"><img id="ch5fig2" src="../images/pg258_Image_366.jpg" alt="Image" width="909" height="283"/></div>&#13;
<p class="figcap">Figure 5.2: The vehicle’s desired velocity points from its position to the target. (The desired vector should point from the vehicle’s center to the target’s center but is shortened for illustration purposes.)</p>&#13;
<p class="noindent">Assuming a <span class="literal">p5.Vector</span> called <span class="literal">target</span> defining the target’s position, I then have this:</p>&#13;
<pre class="pre">let desired = p5.Vector.sub(target, position);</pre>&#13;
<p class="noindent">There’s more to the story, however. What if it is a high-resolution canvas and the target is thousands of pixels away? Sure, the vehicle might desire to teleport itself instantly to the target position with a massive velocity, but this won’t make for an effective animation. I’ll restate the desire as follows:</p>&#13;
<div class="exe">&#13;
<p class="noindent"><em>The vehicle desires to move toward the target at the maximum possible speed</em>.</p>&#13;
</div>&#13;
<p class="noindent">In other words, the <span class="literal">desired</span> vector should point from the vehicle’s current position to the target position, with a magnitude equal to the maximum speed of the vehicle, as shown in <a href="ch05.xhtml#ch5fig3">Figure 5.3</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_219"/><img id="ch5fig3" src="../images/pg259_Image_367.jpg" alt="Image" width="923" height="308"/></div>&#13;
<p class="figcap">Figure 5.3: The magnitude of the vehicle’s desired velocity is <em>max speed</em>.</p>&#13;
<p class="noindent">The concept of maximum speed was introduced in <a href="ch01.xhtml#ch01">Chapter 1</a> to ensure that a mover’s speed remained within a reasonable range. However, I didn’t always use it in the subsequent chapters. In <a href="ch02.xhtml#ch02">Chapter 2</a>, other forces such as friction and drag kept the speed in check, while in <a href="ch03.xhtml#ch03">Chapter 3</a>, oscillation was caused by opposing forces that kept the speed limited. In this chapter, maximum speed is a key parameter for controlling the behavior of a steering agent, so I’ll include it in all the examples.</p>&#13;
<p class="noindent">While I encourage you to consider how other forces such as friction and drag could be combined with steering behaviors, I’m going to focus only on steering forces for the time being. As such, I can include the concept of maximum speed as a limiting factor in the force calculation. First, I need to add a property to the <span class="literal">Vehicle</span> class setting the maximum speed:</p>&#13;
<div class="imagel"><img src="../images/pg259_Image_368.jpg" alt="Image" width="1139" height="287"/></div>&#13;
<p class="noindent">Then, in the desired velocity calculation, I’ll scale according to maximum speed:</p>&#13;
<pre class="pre">let desired = p5.Vector.sub(target, this.position);&#13;
desired.setMag(this.maxspeed);</pre>&#13;
<p class="noindent">Putting this all together, I can now write a method called <span class="literal">seek()</span> that receives a <span class="literal">p5.Vector</span> target and calculates a steering force toward that target:</p>&#13;
<div class="imagel"><img src="../images/pg259_Image_369.jpg" alt="Image" width="1125" height="377"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_220"/>Notice that I finish the method by passing the steering force into <span class="literal">applyForce()</span>. This assumes that the code is built on top of the foundation I developed in <a href="ch02.xhtml#ch02">Chapter 2</a>.</p>&#13;
<p class="noindent">To see why Reynolds’s steering formula works so well, take a look at <a href="ch05.xhtml#ch5fig4">Figure 5.4</a>. It shows what the steering force looks like relative to the vehicle and target positions.</p>&#13;
<div class="image"><img id="ch5fig4" src="../images/pg260_Image_371.jpg" alt="Image" width="913" height="358"/></div>&#13;
<p class="figcap">Figure 5.4: The vehicle applies a steering force equal to its desired velocity minus its current velocity.</p>&#13;
<p class="noindent">This force looks quite different from gravitational attraction. Remember one of the principles of autonomous agents: an autonomous agent has a <em>limited</em> ability to perceive its environment, including its own state. Here’s that ability, subtly but powerfully embedded into Reynolds’s steering formula. In the case of gravitational attraction, the force pulling an object toward another is the same regardless of how that object is moving. But here, the vehicle is actively aware of its own velocity, and its steering force compensates accordingly. This adds a lifelike quality to the simulation, as the way in which the vehicle moves toward the target depends on its own understanding of its current motion.</p>&#13;
<p class="noindent">In all this excitement, I’ve missed one last step. What sort of vehicle is this? Is it a super-sleek race car with amazing handling? Or a large city bus that needs a lot of advance notice to turn? A graceful panda or a lumbering elephant? The example code, as it stands, has no feature to account for this variation in steering ability. For that, I need to limit the magnitude of the steering force. I’ll call this limit the maximum force (or <span class="literal">maxforce</span> for short):</p>&#13;
<div class="imagel"><img src="../images/pg260_Image_372.jpg" alt="Image" width="1138" height="349"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_221"/>Now I just need to impose that limit before applying the steering force:</p>&#13;
<div class="imagel"><img src="../images/pg261_Image_374.jpg" alt="Image" width="1139" height="323"/></div>&#13;
<p class="noindent">Limiting the steering force brings up an important point: the goal isn’t to get the vehicle to the target as fast as possible. If it were, I would just say, “Set position equal to target,” and the vehicle would instantly teleport to that location! Instead, as Reynolds puts it, the goal is to move the vehicle in a “lifelike and improvisational manner.”</p>&#13;
<p class="noindent">I’m trying to make the vehicle appear to be steering its way to the target, so it’s up to me to play with the forces and variables of the system to simulate a given behavior. For example, a large maximum steering force would result in a very different path than a small one (see <a href="ch05.xhtml#ch5fig5">Figure 5.5</a>). One isn’t inherently better or worse than the other; it depends on the desired effect. (And of course, these values need not be fixed and could change based on other conditions. Perhaps a vehicle has an <em>energy</em> property: the higher the energy, the better it can steer.)</p>&#13;
<div class="image"><img id="ch5fig5" src="../images/pg261_Image_375.jpg" alt="Image" width="976" height="235"/></div>&#13;
<p class="figcap">Figure 5.5: The path for a stronger maximum force (left) versus a weaker one (right)</p>&#13;
<p class="noindent">Here’s the full <span class="literal">Vehicle</span> class, incorporating the rest of the elements from the <a href="ch02.xhtml#ch02">Chapter 2</a> <span class="literal">Mover</span> class.</p>&#13;
<div class="imagela" id="ch5ex1"><span epub:type="pagebreak" id="page_222"/><img src="../images/pg262_Image_376.jpg" alt="Image" width="1125" height="2115"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_223"/>Note that, unlike the circles used to represent movers and particles in previous chapters, the <span class="literal">Vehicle</span> object is drawn as a triangle, defined as three custom vertices set with <span class="literal">beginShape()</span> and <span class="literal">endShape()</span>. This allows the vehicle to be represented in a way that indicates its direction, determined using the <span class="literal">heading()</span> method, as demonstrated in <a href="ch03.xhtml#ch03">Chapter 3</a>.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe1"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.1</strong></p>&#13;
<p class="noindent">Implement a <em>fleeing</em> steering behavior (the desired velocity is the same as <em>seek</em>, but pointed in the opposite direction).</p>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe2"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.2</strong></p>&#13;
<p class="noindent">Create a sketch in which a vehicle’s maximum force and maximum speed don’t remain constant but vary according to environmental factors.</p>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe3"><span epub:type="pagebreak" id="page_224"/><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.3</strong></p>&#13;
<p class="noindent">Implement a seeking behavior with a moving target, often referred to as <em>pursuit</em>. In this case, your desired vector won’t point toward the object’s current position, but rather its future position as extrapolated from its current velocity. You’ll see this ability for a vehicle to “predict the future” in later examples. The solution is covered in the “Pursue &amp; Evade” video on the Coding Train website (<em><a href="https://thecodingtrain.com/pursuit">https://thecodingtrain.com/pursuit</a></em>).</p>&#13;
<div class="imagel"><img src="../images/pg264_Image_378.jpg" alt="Image" width="1044" height="439"/></div>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev2sec30"><strong>The Arrive Behavior</strong></h4>&#13;
<p class="noindent">After working for a bit with the seeking behavior, you’re probably asking yourself, “What if I want the vehicle to slow down as it approaches the target?” Before I can even begin to answer this question, I should explain why the seek behavior causes the vehicle to fly past the target in the first place, forcing it to turn around and go back. Consider the brain of a seeking vehicle. What is it thinking at each frame of the animation?</p>&#13;
<ul class="bullet">&#13;
<li class="noindent">I want to go as fast as possible toward the target.</li>&#13;
<li class="noindent">I want to go as fast as possible toward the target.</li>&#13;
<li class="noindent">I want to go as fast as possible toward the target.</li>&#13;
<li class="noindent">I want to go as fast as possible toward the target.</li>&#13;
<li class="noindent">I want to go as fast as possible toward the target.</li>&#13;
<li class="noindent">and so on . . .</li>&#13;
</ul>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_225"/>The vehicle is so gosh darn excited about getting to the target that it doesn’t bother to make any intelligent decisions about its speed. No matter the distance to the target, it always wants to go as fast as possible. When the vehicle is very close, it will therefore end up overshooting the target (see <a href="ch05.xhtml#ch5fig6">Figure 5.6</a>, top).</p>&#13;
<div class="image"><img id="ch5fig6" src="../images/pg265_Image_379.jpg" alt="Image" width="234" height="341"/></div>&#13;
<p class="figcap">Figure 5.6: The top vehicle has a desired velocity at maximum speed and will overshoot the target. The bottom vehicle illustrates scaling the desired velocity according to the distance from the target. (While I encourage you to continue thinking about the vehicle as a cute, bug-like creature, from this point it’s drawn as a triangle to keep things simple.)</p>&#13;
<p class="noindent">In some cases, this is the desired behavior. (Consider a puppy going after its favorite toy: it’s not slowing down, no matter how close it gets!) However, in many other cases (a car pulling into a parking spot, a bee landing on a flower), the vehicle’s thought process needs to consider its speed relative to the distance from its target (see <a href="ch05.xhtml#ch5fig6">Figure 5.6</a>, bottom). For example:</p>&#13;
<ul class="bullet">&#13;
<li class="noindent">I’m very far away. I want to go as fast as possible toward the target.</li>&#13;
<li class="noindent">I’m somewhat far away. I still want to go as fast as possible toward the target.</li>&#13;
<li class="noindent">I’m getting close. I want to go more slowly toward the target.</li>&#13;
<li class="noindent">I’m almost there. I want to go very slowly toward the target.</li>&#13;
<li class="noindent">I’m there. I want to stop!</li>&#13;
</ul>&#13;
<p class="noindent">How can you implement this <em>arriving</em> behavior in code? Think back to the <span class="literal">seek()</span> method. Which part of the code sets the magnitude of the desired velocity?</p>&#13;
<pre class="pre">   let desired = p5.Vector.sub(target, this.position);&#13;
   desired.setMag(this.maxspeed);</pre>&#13;
<p class="noindent">This always sets the magnitude of the <span class="literal">desired</span> vector to <span class="literal">maxspeed</span>, as in <a href="ch05.xhtml#ch5fig7">Figure 5.7</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_226"/><img id="ch5fig7" src="../images/pg266_Image_380.jpg" alt="Image" width="771" height="388"/></div>&#13;
<p class="figcap">Figure 5.7: The vehicles have a desired velocity with a magnitude set to maximum speed, regardless of their relative distance to the target.</p>&#13;
<p class="noindent">What if instead the desired velocity’s magnitude were equal to half the distance?</p>&#13;
<pre class="pre">   let desired = p5.Vector.sub(target, this.position);&#13;
   desired.mult(0.5);</pre>&#13;
<p class="noindent">I’d still want to limit the magnitude of <span class="literal">desired</span> to no more than the maximum speed, to keep vehicles that are very far away from going ridiculously fast (<a href="ch05.xhtml#ch5fig8">Figure 5.8</a>).</p>&#13;
<div class="image"><img id="ch5fig8" src="../images/pg266_Image_381.jpg" alt="Image" width="771" height="347"/></div>&#13;
<p class="figcap">Figure 5.8: The magnitude of each vehicle’s desired velocity is equal to half the distance to the target. In the case of the leftmost vehicle, the velocity is constrained to the maximum speed.</p>&#13;
<p class="noindent">While this change nicely demonstrates the goal of tying the desired speed to the distance from the target, it’s not a particularly good solution. After all, 10 pixels away is rather close, and a desired speed of 5 is rather large. Something like a desired velocity with a magnitude equal to 5 percent of the distance might work better:</p>&#13;
<pre class="pre">  let desired = p5.Vector.sub(target, this.position);&#13;
  desired.mult(0.05);</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_227"/>Reynolds describes an even more sophisticated approach. Imagine a circle around the target with a given radius <em>r</em>. If the vehicle is within that circle, it gradually slows down—from the maximum speed at the very edge of the circle to zero speed at the target (<a href="ch05.xhtml#ch5fig9">Figure 5.9</a>).</p>&#13;
<div class="image"><img id="ch5fig9" src="../images/pg267_Image_382.jpg" alt="Image" width="884" height="659"/></div>&#13;
<p class="figcap">Figure 5.9: Outside the circle, the magnitude of a vehicle’s desired velocity is set to the maximum speed. As vehicles enter the circle and approach the target, their desired velocity magnitude decreases.</p>&#13;
<p class="noindent">In other words, if the distance from the target is less than <em>r</em>, the desired speed ranges from 0 to the maximum speed mapped according to that distance.</p>&#13;
<div class="imagel" id="ch5ex2"><img src="../images/pg267_Image_383.jpg" alt="Image" width="1125" height="1186"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_228"/>The arrive behavior is a great demonstration of an autonomous agent’s perception of the environment—including its own state. This model differs from the inanimate forces of <a href="ch02.xhtml#ch02">Chapter 2</a>: a celestial body attracted to another body doesn’t know it is experiencing gravity, whereas a cheetah chasing its prey knows it’s chasing.</p>&#13;
<p class="noindent">The key is in the way the forces are calculated. For instance, in the gravitational attraction sketch (<a href="ch02.xhtml#ch2ex6">Example 2.6</a>), the force always points directly from the object to the target—the exact direction of the desired velocity. Here, by contrast, the vehicle perceives its distance to the target and adjusts its desired speed accordingly, slowing as it gets closer. The force on the vehicle itself is therefore based not just on the desired velocity but also on the desired velocity <em>relative to its current velocity</em>. The vehicle accounts for its own state as part of its assessment of the environment.</p>&#13;
<p class="noindent">Put another way, the magic of Reynolds’s <em>desired minus velocity</em> equation is that it essentially makes the steering force a manifestation of the current velocity’s <em>error</em>: “I’m supposed to be going this fast in this direction, but I’m actually going this fast in another direction. My error is the difference between where I want to go and where I’m currently going.” Sometimes this can lead to seemingly unexpected results, as in <a href="ch05.xhtml#ch5fig10">Figure 5.10</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_229"/><img id="ch5fig10" src="../images/pg269_Image_385.jpg" alt="Image" width="873" height="255"/></div>&#13;
<p class="figcap">Figure 5.10: A vehicle moving toward its target faster than its desired velocity will result in a steering force pointing away from the target.</p>&#13;
<p class="noindent">In this example of the arrive behavior, the vehicle is moving too fast toward the target. The steering force, or error, tells it to slow down by actually pointing in the opposite direction, away from the target. By contrast, with gravitational attraction, you would never have a force pointing away from the target, no matter how close the target is. Taking the error and applying it as a steering force results in more dynamic, lifelike simulations.</p>&#13;
<h4 class="h4" id="ch00lev2sec31"><strong>Your Own Behaviors</strong></h4>&#13;
<p class="noindent">The first two examples I’ve covered—seek and arrive—boil down to calculating a single vector for each behavior: the <em>desired</em> velocity. In fact, every single one of Reynolds’s steering behaviors follows this same pattern. In this chapter, I’m going to walk through more of Reynolds’s behaviors—flow-field following, path following, and flocking. First, however, I want to emphasize again that these are <em>examples</em>—demonstrations of common steering behaviors that are useful in procedural animation. They aren’t the be-all and end-all of what <em>you</em> can do. As long as you can come up with a vector that describes a vehicle’s <em>desired</em> velocity, you’ve created your own steering behavior.</p>&#13;
<p class="noindent">For example, let’s see how Reynolds defines the desired velocity for his wandering behavior:</p>&#13;
<div class="blockquote">&#13;
<p class="noindent"><em>Wandering is a type of random steering which has some long-term order: the steering direction on one frame is related to the steering direction on the next frame. This produces more interesting motion than, for example, simply generating a random steering direction each frame.</em></p>&#13;
</div>&#13;
<p class="noindent">For Reynolds, the goal of wandering isn’t random motion, but rather a sense of moving in one direction for a little while, wandering off in the next direction for a little bit, and so on. <a href="ch05.xhtml#ch5fig11">Figure 5.11</a> illustrates how Reynolds calculates a target to seek in order to achieve such an effect.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_230"/><img id="ch5fig11" src="../images/pg270_Image_386.jpg" alt="Image" width="789" height="661"/></div>&#13;
<p class="figcap">Figure 5.11: The wandering steering behavior is calculated as seeking a target that moves randomly along the perimeter of a circle projected in front of the vehicle.</p>&#13;
<p class="noindent">First, the vehicle predicts its future position as a fixed distance in front of it (in the direction of its current velocity). Then it draws a circle with radius <em>r</em> centered on that position and picks a random point along the circumference of the circle. That point, which moves randomly around the circle for each frame of animation, is the vehicle’s target, so its desired velocity points in that direction.</p>&#13;
<p class="noindent">Sounds absurd, right? Or, at the very least, a bit arbitrary. In fact, this is a clever and thoughtful solution—it uses randomness to drive a vehicle’s steering, but constrains that randomness along the path of a circle to keep the vehicle’s movement from appearing jittery and, well, totally random.</p>&#13;
<p class="noindent">The seemingly random and arbitrary nature of this solution should drive home the point I’m trying to make: these are <em>made-up</em> behaviors, even if they’re inspired by real-life motion. You can just as easily concoct another elaborate scenario to compute a desired velocity. And you should!</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe4"><span epub:type="pagebreak" id="page_231"/><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.4</strong></p>&#13;
<p class="noindent">Write the code for Reynolds’s wandering behavior. Use polar coordinates to calculate the vehicle’s target along a circular path.</p>&#13;
<div class="imagel"><img src="../images/pg271_Image_387.jpg" alt="Image" width="1044" height="439"/></div>&#13;
</div>&#13;
<p class="noindent">To give another example, say I want to create a steering behavior called <em>stay within walls</em>. To define the desired velocity, I’ll make a rule: if a vehicle comes within a distance <em>d</em> of a wall, that vehicle desires to move at maximum speed in the opposite direction of the wall (see <a href="ch05.xhtml#ch5fig12">Figure 5.12</a>).</p>&#13;
<div class="image"><img id="ch5fig12" src="../images/pg271_Image_388.jpg" alt="Image" width="787" height="651"/></div>&#13;
<p class="figcap">Figure 5.12: The desired velocity points away from the wall if the vehicle gets too close.</p>&#13;
<p class="noindent">If I define the walls of the space as the edges of a canvas and an <span class="literal">offset</span> distance equal to 25, I can write the code for this with a series of <span class="literal">if</span> statements.</p>&#13;
<div class="imagel" id="ch5ex3"><span epub:type="pagebreak" id="page_232"/><img src="../images/pg272_Image_389.jpg" alt="Image" width="1126" height="1293"/></div>&#13;
<p class="noindent">In this <span class="literal">boundaries()</span> method, you might be wondering why I set the <span class="literal">desired</span> velocity to <span class="literal">null</span> at the outset. Why not just set <span class="literal">desired</span> to a vector of 0? Remember, the steering force equals the desired velocity minus the current velocity! If the vehicle desires to move at 0 velocity, the resulting force would slow the vehicle to a stop. By initializing <span class="literal">desired</span> to <span class="literal">null</span> and checking that it’s non-null before applying the steering force, the vehicle won’t be affected at all when it’s comfortably away from the edges of the canvas.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe5"><span epub:type="pagebreak" id="page_233"/><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.5</strong></p>&#13;
<p class="noindent">Come up with your own arbitrary scheme for calculating a desired velocity.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec51"><strong>Flow Fields</strong></h3>&#13;
<p class="noindent">Another one of Reynolds’s steering behaviors is <strong>flow-field following</strong>. But what is a flow field? Think of the canvas as a grid (<a href="ch05.xhtml#ch5fig13">Figure 5.13</a>). In each cell of the grid lives an arrow pointing in a certain direction—you know, a vector. As a vehicle moves around the canvas, it asks, “Hey, what arrow is beneath me? That’s my desired velocity!”</p>&#13;
<div class="image"><img id="ch5fig13" src="../images/pg273_Image_390.jpg" alt="Image" width="1004" height="571"/></div>&#13;
<p class="figcap">Figure 5.13: A 2D grid full of unit vectors pointing in random directions</p>&#13;
<p class="noindent">Reynolds’s own flow-field example involves the vehicle looking ahead to its future position and following the vector at that spot. For simplicity’s sake, however, I’ll instead have the vehicle follow the vector at its current position.</p>&#13;
<p class="noindent">Before I can write the additional code for the <span class="literal">Vehicle</span> class to follow a flow field, I first need a class that describes the flow field. Since a flow field is essentially a grid of vectors, a 2D array is a convenient data structure to represent it, as I can reference each element with two indices, the cell’s column and row in the grid. If you aren’t familiar with 2D arrays, I suggest reviewing my video tutorial on “2D Arrays in JavaScript” (<em><a href="https://thecodingtrain.com/2d-array">https://thecodingtrain.com/2d-array</a></em>).</p>&#13;
<div class="imageiL"><img src="../images/pg273_Image_391.jpg" alt="Image" width="1138" height="449"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_234"/>How should I fill in the missing values? Let’s say I have a canvas that’s 200 pixels wide by 200 pixels high. In theory, I could make a flow field that has a vector for every single pixel, meaning 40,000 vectors total (200 × 200). This isn’t a terribly unreasonable number, but in this context, one vector per pixel is overkill. I can easily get by with, say, one vector every 10 pixels (20 × 20 = 400). My <span class="literal">resolution</span> variable sets the size of each cell in pixels. Then I can calculate the number of columns and rows based on the size of the canvas divided by the resolution:</p>&#13;
<div class="imagel"><img src="../images/pg274_Image_393.jpg" alt="Image" width="1125" height="453"/></div>&#13;
<p class="noindent">Now that I’ve set up the data structure for the flow field, it’s time to compute the flow field’s vectors. How do I do that? However I want! Perhaps I’d like every vector in the flow field pointing to the right (<a href="ch05.xhtml#ch5fig14">Figure 5.14</a>).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_235"/><img id="ch5fig14" src="../images/pg275_Image_394.jpg" alt="Image" width="1125" height="331"/></div>&#13;
<p class="figcap">Figure 5.14: A flow field with all vectors pointing to the right</p>&#13;
<p class="noindent">For that, I can just set each vector to <span class="literal">(1, 0)</span>.</p>&#13;
<div class="imagel"><img src="../images/pg275_Image_395.jpg" alt="Image" width="1125" height="245"/></div>&#13;
<p class="noindent">Maybe I’d prefer the vectors to point in random directions (<a href="ch05.xhtml#ch5fig15">Figure 5.15</a>).</p>&#13;
<div class="image"><img id="ch5fig15" src="../images/pg275_Image_396.jpg" alt="Image" width="1125" height="338"/></div>&#13;
<p class="figcap">Figure 5.15: A flow field with vectors pointing in random directions</p>&#13;
<p class="noindent">Easy. Just use the <span class="literal">p5.Vector</span> class’s <span class="literal">random2D()</span> method to assign each vector:</p>&#13;
<div class="imagel"><img src="../images/pg275_Image_397.jpg" alt="Image" width="1125" height="203"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_236"/>What about using 2D Perlin noise (<a href="ch05.xhtml#ch5fig16">Figure 5.16</a>)?</p>&#13;
<div class="image"><img id="ch5fig16" src="../images/pg276_Image_398.jpg" alt="Image" width="1125" height="338"/></div>&#13;
<p class="figcap">Figure 5.16: A flow field calculated with Perlin noise</p>&#13;
<p class="noindent">Just map each noise value to an angle from 0 to 2π and create a vector from that angle:</p>&#13;
<div class="imagel"><img src="../images/pg276_Image_399.jpg" alt="Image" width="1125" height="384"/></div>&#13;
<p class="noindent">Now I’m getting somewhere. Calculating the direction of the vectors by using Perlin noise is a great way to simulate a variety of natural effects, such as irregular gusts of wind or the meandering path of a river. I’ll note, however, that this noise mapping generates a field that prefers flowing left. Since Perlin noise has a Gaussian-like distribution, angles near π are more likely to be selected. For <a href="ch05.xhtml#ch5fig16">Figure 5.16</a>, I used a range of 0 to 4π to counteract this tendency, similarly to the way I applied 4π in <a href="ch04.xhtml#ch04">Chapter 4</a> to represent a range of angles for spinning confetti particles. Ultimately, of course, there’s no one correct way to calculate the vectors of a flow field; it’s up to you to decide what you’re looking to simulate.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe6"><span epub:type="pagebreak" id="page_237"/><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.6</strong></p>&#13;
<p class="noindent">Write the code to calculate a flow field so that the vectors swirl in circles around the center of the canvas.</p>&#13;
<div class="imagel"><img src="../images/pg277_Image_400.jpg" alt="Image" width="1039" height="314"/></div>&#13;
<pre class="pre">let x = <span class="wight">i * width / cols</span>;&#13;
let y = <span class="wight">j * height / rows</span>;&#13;
flowfield[i][j] = createVector(<span class="wight">width / 2 - x</span>, <span class="wight">height / 2 - y</span>);&#13;
flowfield[i][j].<span class="wight">rotate(PI / 2)</span>;</pre>&#13;
</div>&#13;
<p class="noindent">Now that I have a 2D array storing the flow-field vectors, I need a way for the vehicle to look up its desired velocity. For that, I simply divide the vehicle’s x- and y-position by the resolution of the grid. This gives me the indices of the desired vector in the 2D array. For example, if the resolution is 10 and the vehicle is at (100, 50), I’ll want to look up column 10 and row 5:</p>&#13;
<pre class="pre">let column = floor(this.position.x / this.resolution);&#13;
let row = floor(this.position.y / this.resolution);</pre>&#13;
<p class="noindent">Because a vehicle could theoretically wander off the p5.js canvas, employing the <span class="literal">constrain()</span> function helps ensure that I don’t look outside the bounds of the flow-field array. Here’s a method called <span class="literal">lookup()</span>, which I’ll add to the <span class="literal">FlowField</span> class, that receives a vector (the position of the vehicle) and returns the corresponding flow-field vector for that position:</p>&#13;
<div class="imagel"><img src="../images/pg277_Image_401.jpg" alt="Image" width="1125" height="292"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_238"/>Before moving on to the <span class="literal">Vehicle</span> class, let’s look at the <span class="literal">FlowField</span> class code all together, this time using Perlin noise to compute the vector directions:</p>&#13;
<div class="imagel"><img src="../images/pg278_Image_402.jpg" alt="Image" width="1125" height="1273"/></div>&#13;
<p class="noindent">Now let’s assume there’s a <span class="literal">FlowField</span> object called <span class="literal">flow</span>. Using that object’s <span class="literal">lookup()</span> method, a vehicle can then retrieve a desired velocity from the flow field and use Reynolds’s steering formula to calculate a force.</p>&#13;
<div class="imagel" id="ch5ex4"><span epub:type="pagebreak" id="page_239"/><img src="../images/pg279_Image_403.jpg" alt="Image" width="1126" height="768"/></div>&#13;
<p class="noindent">Notice that <span class="literal">lookup()</span> is a method of the <span class="literal">FlowField</span> class, rather than of <span class="literal">Vehicle</span>. While you certainly could place <span class="literal">lookup()</span> within the <span class="literal">Vehicle</span> class instead, from my perspective, placing it in <span class="literal">FlowField</span> aligns best with the OOP principle of encapsulation. The lookup task, which retrieves a vector based on a position from the flow field, is inherently tied to the data of the <span class="literal">FlowField</span> object.</p>&#13;
<p class="noindent">You may also notice some familiar elements from <a href="ch04.xhtml#ch04">Chapter 4</a>, such as the use of an array of vehicles. Although the vehicles here operate independently, this is a great first step toward thinking about the group behaviors that I’ll introduce later in this chapter.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe7"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.7</strong></p>&#13;
<p class="noindent">Adapt the flow-field example so the vectors change over time. (Hint: Try using the third dimension of Perlin noise!)</p>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe8"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.8</strong></p>&#13;
<p class="noindent">Can you create a flow field from an image? For example, try having the vectors point from dark to light colors (or vice versa).</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec52"><span epub:type="pagebreak" id="page_240"/><strong>Path Following</strong></h3>&#13;
<p class="noindent">The next steering behavior formulated by Reynolds that I’d like to explore is path following. But let me quickly clarify something first: the behavior here is path <em>following</em>, not path <em>finding</em>. Pathfinding refers to an algorithm that solves for the shortest distance between two points, often in a maze. With <strong>path following</strong>, a predefined route, or path, already exists, and the vehicle simply tries to follow it.</p>&#13;
<p class="noindent">In this section, I will work through the algorithm, including the corresponding mathematics and code. However, before doing so, it’s important to cover a key concept in vector math that I skipped over in <a href="ch01.xhtml#ch01">Chapter 1</a>: <strong>the dot product</strong>. I haven’t needed it yet, but it’s necessary here and likely will prove quite useful for you beyond just this example.</p>&#13;
<h4 class="h4" id="ch00lev2sec32"><strong>The Dot Product</strong></h4>&#13;
<p class="noindent">Remember all the vector math covered in <a href="ch01.xhtml#ch01">Chapter 1</a>? Add, subtract, multiply, and divide? <a href="ch05.xhtml#ch5fig17">Figure 5.17</a> has a recap of some of these operations.</p>&#13;
<div class="image"><img id="ch5fig17" src="../images/pg280_Image_404.jpg" alt="Image" width="909" height="381"/></div>&#13;
<p class="figcap">Figure 5.17: Adding vectors and multiplying a vector by a scalar</p>&#13;
<p class="noindent">Notice that multiplication involves multiplying a vector by a scalar value. This makes sense; when you want a vector to be twice as large (but facing the same direction), multiply it by 2. When you want it to be half the size, multiply it by 0.5. However, several other <em>multiplication-like</em> operations involve a pair of vectors that are useful in certain scenarios—the dot product, the cross product, and something called the Hadamard product. For now, I’m going to focus on the dot product.</p>&#13;
<p class="noindent">Assume vectors <img class="inline" src="../images/pg280_Image_405.jpg" alt="Image" width="12" height="17"/> and <img class="inline" src="../images/pg280_Image_406.jpg" alt="Image" width="12" height="16"/>:</p>&#13;
<div class="imagei"><img src="../images/pg280_Image_407.jpg" alt="Image" width="103" height="69"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_241"/>The formula for the dot product (represented by the · character) is as follows:</p>&#13;
<div class="imagei"><img src="../images/pg281_Image_408.jpg" alt="Image" width="250" height="26"/></div>&#13;
<p class="noindent">Crucially, the result of the dot product is a scalar value (a single number) and not a vector, even though the inputs are two vectors. For example, say you have these two vectors:</p>&#13;
<div class="imagei"><img src="../images/pg281_Image_409.jpg" alt="Image" width="100" height="67"/></div>&#13;
<p class="noindent">Their dot product is shown here:</p>&#13;
<div class="imagei"><img src="../images/pg281_Image_410.jpg" alt="Image" width="403" height="25"/></div>&#13;
<p class="noindent">In p5.js, this translates to the following:</p>&#13;
<div class="imagel"><img src="../images/pg281_Image_411.jpg" alt="Image" width="1125" height="181"/></div>&#13;
<p class="noindent">If you look in the guts of the <span class="literal">p5.Vector</span> source code, you’ll find a pretty simple implementation of this <span class="literal">dot()</span> method:</p>&#13;
<div class="imagel"><img src="../images/pg281_Image_412.jpg" alt="Image" width="1125" height="131"/></div>&#13;
<p class="noindent">This formula is simple enough, but why is the dot product necessary, and when is it useful in coding? Well, one of the more common uses of the dot product is to find the angle between two vectors. In fact, the dot product can also be expressed as shown here:</p>&#13;
<div class="imagei"><img src="../images/pg281_Image_413.jpg" alt="Image" width="249" height="25"/></div>&#13;
<p class="noindent">In other words, the dot product of <img class="inline" src="../images/pg281_Image_414.jpg" alt="Image" width="12" height="17"/> and <img class="inline" src="../images/pg281_Image_415.jpg" alt="Image" width="12" height="16"/> is equal to the magnitude of <img class="inline" src="../images/pg281_Image_414.jpg" alt="Image" width="12" height="17"/> times the magnitude of <img class="inline" src="../images/pg281_Image_415.jpg" alt="Image" width="12" height="16"/> times the cosine of theta (with theta being the angle between the two vectors <img class="inline" src="../images/pg281_Image_414.jpg" alt="Image" width="12" height="17"/> and <img class="inline" src="../images/pg281_Image_415.jpg" alt="Image" width="12" height="16"/>).</p>&#13;
<p class="noindent">The two dot-product formulas can be derived from each other with trigonometry (<em><a href="https://mathworld.wolfram.com/DotProduct.html">https://mathworld.wolfram.com/DotProduct.html</a></em>), but I’m happy not to follow that path and instead just operate on the following assumption:</p>&#13;
<div class="imagei"><img src="../images/pg281_Image_416.jpg" alt="Image" width="380" height="25"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_242"/>This works since both sides of the equation equal <img class="inline" src="../images/pg282_Image_417.jpg" alt="Image" width="38" height="17"/>. What does that assumption do for me? Say I have two vectors <img class="inline" src="../images/pg281_Image_414.jpg" alt="Image" width="12" height="17"/> and <img class="inline" src="../images/pg281_Image_415.jpg" alt="Image" width="12" height="16"/>:</p>&#13;
<div class="imagei"><img src="../images/pg282_Image_418.jpg" alt="Image" width="101" height="67"/></div>&#13;
<p class="noindent">In this scenario, I know the components of the vectors but don’t know the angle <em>θ</em> between them (see <a href="ch05.xhtml#ch5fig18">Figure 5.18</a>). Using the dot-product formula, I can solve for the cosine of <em>θ</em>:</p>&#13;
<div class="imagei"><img src="../images/pg282_Image_419.jpg" alt="Image" width="261" height="52"/></div>&#13;
<div class="image"><img id="ch5fig18" src="../images/pg282_Image_422.jpg" alt="Image" width="531" height="335"/></div>&#13;
<p class="figcap">Figure 5.18: The angle between two vectors <img class="inline" src="../images/pg282_Image_423.jpg" alt="Image" width="14" height="17"/> and <img class="inline" src="../images/pg282_Image_424.jpg" alt="Image" width="13" height="17"/></p>&#13;
<p class="noindent">To solve for <em>θ</em>, I can take the inverse cosine, or arccosine ( <span class="literal">acos</span> in p5.js ), of the right side of the equation:</p>&#13;
<div class="imagei"><img src="../images/pg282_Image_420.jpg" alt="Image" width="305" height="61"/></div>&#13;
<p class="noindent">I’ll do the math now with actual numbers:</p>&#13;
<div class="imagei"><img src="../images/pg282_Image_421.jpg" alt="Image" width="296" height="233"/></div>&#13;
<p class="noindent">Here’s the p5.js version:</p>&#13;
<pre class="pre">let a = createVector(10, 2);&#13;
let b = createVector(4, -3);&#13;
let angle = acos(a.dot(b) / (a.mag() * b.mag()));</pre>&#13;
<p class="noindent">Turns out, if you again dig into the guts of the p5.js source code, you’ll find a method called <span class="literal">angleBetween</span> that implements this exact algorithm.</p>&#13;
<pre class="pre"><span epub:type="pagebreak" id="page_243"/>  angleBetween(v) {&#13;
    let dot = this.dot(v);&#13;
    let angle = Math.acos(dot / (this.mag() * v.mag()));&#13;
    return angle;&#13;
  }</pre>&#13;
<p class="noindent">Sure, I could have told you about this <span class="literal">angleBetween()</span> method to begin with, but understanding the dot product in detail will better prepare you for the upcoming path-following examples and help you see how the dot product fits into a concept called <em>scalar projection</em>.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe9"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.9</strong></p>&#13;
<p class="noindent">Create a sketch that shows the angle between two vectors.</p>&#13;
<div class="imagel"><img src="../images/pg283_Image_425.jpg" alt="Image" width="1044" height="439"/></div>&#13;
</div>&#13;
<p class="noindent">There are a couple of things to note about dot products:</p>&#13;
<ul class="bullet">&#13;
<li class="noindent">If two vectors (<img class="inline" src="../images/pg281_Image_414.jpg" alt="Image" width="12" height="17"/> and <img class="inline" src="../images/pg281_Image_415.jpg" alt="Image" width="12" height="16"/>) are orthogonal (that is, perpendicular), their dot product (<img class="inline" src="../images/pg282_Image_417.jpg" alt="Image" width="38" height="17"/>) is equal to 0.</li>&#13;
<li class="noindent">If two vectors are unit vectors, their dot product is equal to the cosine of the angle between them. In other words, <img class="inline" src="../images/pg283_Image_427.jpg" alt="Image" width="124" height="25"/> if <img class="inline" src="../images/pg281_Image_414.jpg" alt="Image" width="12" height="17"/> and <img class="inline" src="../images/pg281_Image_415.jpg" alt="Image" width="12" height="16"/> are of length 1.</li>&#13;
</ul>&#13;
<p class="noindent">Now that I’ve covered the fundamentals of the dot product, I can return to Reynolds’s path-following algorithm.</p>&#13;
<h4 class="h4" id="ch00lev2sec33"><strong>Simple Path Following</strong></h4>&#13;
<p class="noindent"><a href="ch05.xhtml#ch5fig19">Figure 5.19</a> depicts all the ingredients of the path-following behavior. A lot of components are at play here beyond just a vehicle and target, so take some time to review the full diagram. I’ll then slowly unpack the algorithm piece by piece.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_244"/><img id="ch5fig19" src="../images/pg284_Image_428.jpg" alt="Image" width="1125" height="626"/></div>&#13;
<p class="figcap">Figure 5.19: Path following requires a path, a vehicle, a future position, a <em>normal</em> to the path, and a target.</p>&#13;
<p class="noindent">First, what do I mean by a <em>path</em>? Many techniques can be used to implement a path, but one simple way is to define a path as a series of connected points, as in <a href="ch05.xhtml#ch5fig20">Figure 5.20</a>.</p>&#13;
<div class="image"><img id="ch5fig20" src="../images/pg284_Image_429.jpg" alt="Image" width="1053" height="366"/></div>&#13;
<p class="figcap">Figure 5.20: A path is a sequence of connected points.</p>&#13;
<p class="noindent">The simplest version of this path would be a line between two points (<a href="ch05.xhtml#ch5fig21">Figure 5.21</a>).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_245"/><img id="ch5fig21" src="../images/pg285_Image_430.jpg" alt="Image" width="829" height="283"/></div>&#13;
<p class="figcap">Figure 5.21: A path with a start, end, and radius</p>&#13;
<p class="noindent">I’m also going to consider a path to have a <em>radius</em>. If the path is a road, the radius is the road’s width. With a smaller radius, vehicles have to follow the path more closely; a wider radius allows them to stray a bit more to either side of the path.</p>&#13;
<p class="noindent">Now I’ll put this into a class.</p>&#13;
<div class="imagel" id="ch5ex5"><img src="../images/pg285_Image_431.jpg" alt="Image" width="1125" height="1116"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_246"/>Now, assume that a vehicle is outside the path’s radius, moving with a velocity, as in <a href="ch05.xhtml#ch5fig22">Figure 5.22</a>.</p>&#13;
<div class="image"><img id="ch5fig22" src="../images/pg286_Image_433.jpg" alt="Image" width="829" height="327"/></div>&#13;
<p class="figcap">Figure 5.22: Adding a vehicle moving off and away from the path</p>&#13;
<p class="noindent">The first step is to predict (assuming a constant velocity) where that vehicle will be in the future:</p>&#13;
<div class="imagel"><img src="../images/pg286_Image_434.jpg" alt="Image" width="1125" height="237"/></div>&#13;
<p class="noindent">Once I have that position, it’s time to determine the distance from that predicted position to the path. If it’s very far away, the vehicle has strayed from the path and needs to steer back toward it. If the vehicle is on the path, all is well and the vehicle can continue on its way.</p>&#13;
<p class="noindent">Essentially, I need to calculate the distance between a point (the future position) and a line (the path). That distance is defined as the length of the <strong>normal</strong>, a vector that extends from the point to the line and is perpendicular to the line (<a href="ch05.xhtml#ch5fig23">Figure 5.23</a>).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_247"/><img id="ch5fig23" src="../images/pg287_Image_435.jpg" alt="Image" width="828" height="414"/></div>&#13;
<p class="figcap">Figure 5.23: The normal is a vector that extends from the future position to the path and is perpendicular to the path.</p>&#13;
<p class="noindent">How do I find the normal? First, I can define a vector (call it <img class="inline" src="../images/pg281_Image_414.jpg" alt="Image" width="12" height="17"/>) that extends from the path’s starting point to the vehicle’s future position:</p>&#13;
<pre class="pre">let a = p5.Vector.sub(future, path.start);</pre>&#13;
<p class="noindent">Next, I can define a vector (call it <img class="inline" src="../images/pg281_Image_415.jpg" alt="Image" width="12" height="16"/>) that points from the start of the path to the end:</p>&#13;
<pre class="pre">let b = p5.Vector.sub(path.end, path.start);</pre>&#13;
<p class="noindent">Now, with a little trigonometry (the <em>cah</em> in <em>sohcahtoa</em>), I can calculate the distance from the path’s start to the normal point. As shown in <a href="ch05.xhtml#ch5fig24">Figure 5.24</a>, it’s <img class="inline" src="../images/pg287_Image_436.jpg" alt="Image" width="112" height="25"/>.</p>&#13;
<div class="image"><img id="ch5fig24" src="../images/pg287_Image_437.jpg" alt="Image" width="827" height="415"/></div>&#13;
<p class="figcap">Figure 5.24: The distance from the start of the path to the normal is <img class="inline" src="../images/pg287_Image_438.jpg" alt="Image" width="97" height="22"/>.</p>&#13;
<p class="noindent">If I only knew <em>θ</em>, I could find that normal point with the code shown next.</p>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_248"/><img src="../images/pg288_Image_439.jpg" alt="Image" width="1125" height="262"/></div>&#13;
<p class="noindent">Luckily, if the dot product has taught me anything, it’s that given two vectors, I can calculate the angle between those vectors!</p>&#13;
<div class="imagel"><img src="../images/pg288_Image_440.jpg" alt="Image" width="1125" height="193"/></div>&#13;
<p class="noindent">While this code will work, I can make one more simplification. Looking again, you’ll see that the magnitude for vector <img class="inline" src="../images/pg281_Image_415.jpg" alt="Image" width="12" height="16"/> is set to <span class="literal">a.mag() * cos(theta)</span>, which is the code translation of the following:</p>&#13;
<div class="imagei"><img src="../images/pg288_Image_441.jpg" alt="Image" width="111" height="25"/></div>&#13;
<p class="noindent">And, recall this:</p>&#13;
<div class="imagei"><img src="../images/pg288_Image_442.jpg" alt="Image" width="248" height="25"/></div>&#13;
<p class="noindent">Now, what if <img class="inline" src="../images/pg280_Image_406.jpg" alt="Image" width="12" height="16"/> is a unit vector of length 1? Then you have this:</p>&#13;
<div class="imagei"><img src="../images/pg288_Image_443.jpg" alt="Image" width="220" height="25"/></div>&#13;
<p class="noindent">Or, more simply:</p>&#13;
<div class="imagei"><img src="../images/pg288_Image_444.jpg" alt="Image" width="185" height="25"/></div>&#13;
<p class="noindent">When <img class="inline" src="../images/pg281_Image_415.jpg" alt="Image" width="12" height="16"/> is a unit vector, <img class="inline" src="../images/pg288_Image_445.jpg" alt="Image" width="115" height="25"/> is the same as the dot product of <img class="inline" src="../images/pg281_Image_414.jpg" alt="Image" width="12" height="17"/> and <img class="inline" src="../images/pg281_Image_415.jpg" alt="Image" width="12" height="16"/>. Turning <span class="literal">b</span> into a unit vector is as simple as calling <span class="literal">normalize()</span>. I can therefore bypass calculating <span class="literal">theta</span> with <span class="literal">angleBetween()</span> and simplify the code as follows:</p>&#13;
<div class="imagel"><img src="../images/pg288_Image_446.jpg" alt="Image" width="1125" height="239"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_249"/>This process of scaling <img class="inline" src="../images/pg281_Image_415.jpg" alt="Image" width="12" height="16"/> according to the normal point is commonly known as <strong>scalar projection</strong>. We say that <img class="inline" src="../images/pg289_Image_447.jpg" alt="Image" width="112" height="25"/> <em>is the scalar projection of</em> <img class="inline" src="../images/pg281_Image_414.jpg" alt="Image" width="12" height="17"/> <em>onto</em> <img class="inline" src="../images/pg281_Image_415.jpg" alt="Image" width="12" height="16"/>, as in <a href="ch05.xhtml#ch5fig25">Figure 5.25</a>.</p>&#13;
<div class="image"><img id="ch5fig25" src="../images/pg289_Image_448.jpg" alt="Image" width="521" height="439"/></div>&#13;
<p class="figcap">Figure 5.25: The scalar projection of <img class="inline" src="../images/pg282_Image_423.jpg" alt="Image" width="14" height="17"/> onto <img class="inline" src="../images/pg282_Image_424.jpg" alt="Image" width="13" height="17"/> is equal to <img class="inline" src="../images/pg289_Image_449.jpg" alt="Image" width="97" height="22"/>.</p>&#13;
<p class="noindent">Once I have the normal point along the path, the next step is to decide whether and how the vehicle should steer toward the path. Reynolds’s algorithm states that the vehicle should steer toward the path only if it’s in danger of straying beyond the path—that is, if the distance between the normal point and the predicted future position is greater than the path’s radius. This is illustrated in <a href="ch05.xhtml#ch5fig26">Figure 5.26</a>.</p>&#13;
<div class="image"><img id="ch5fig26" src="../images/pg289_Image_450.jpg" alt="Image" width="858" height="295"/></div>&#13;
<p class="figcap">Figure 5.26: A vehicle with a future position on the path (top) and one that’s outside the path (bottom)</p>&#13;
<p class="noindent">I can encode that logic with a simple <span class="literal">if</span> statement and use my earlier <span class="literal">seek()</span> method to steer the vehicle when necessary.</p>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_250"/><img src="../images/pg290_Image_451.jpg" alt="Image" width="1125" height="270"/></div>&#13;
<p class="noindent">But what’s the target that the path follower is seeking? Reynolds’s algorithm involves picking a point ahead of the normal on the path. Since I know the vector that defines the path (<img class="inline" src="../images/pg281_Image_415.jpg" alt="Image" width="12" height="16"/>), I can implement this point ahead by adding a vector that points in <img class="inline" src="../images/pg281_Image_415.jpg" alt="Image" width="12" height="16"/>’s direction to the vector representing the normal point, as in <a href="ch05.xhtml#ch5fig27">Figure 5.27</a>.</p>&#13;
<div class="image"><img id="ch5fig27" src="../images/pg290_Image_452.jpg" alt="Image" width="865" height="471"/></div>&#13;
<p class="figcap">Figure 5.27: The target is 25 pixels (an arbitrary choice) ahead of the normal point along the path.</p>&#13;
<p class="noindent">I’ll arbitrarily say the target should be 25 pixels ahead of the normal:</p>&#13;
<div class="imagel"><img src="../images/pg290_Image_453.jpg" alt="Image" width="1125" height="320"/></div>&#13;
<p class="noindent">Putting it all together, here’s the path-following method in the <span class="literal">Vehicle</span> class.</p>&#13;
<div class="imagel" id="ch5ex6"><span epub:type="pagebreak" id="page_251"/><img src="../images/pg291_Image_454.jpg" alt="Image" width="1126" height="1104"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_252"/>Notice that instead of using all that dot-product and scalar projection code to find the normal point, I call the <span class="literal">getNormalPoint()</span> function. In cases like this, it’s useful to break out the code that performs a specific task (finding a normal point) into a function that can be called when required. The function takes three vector arguments (see <a href="ch05.xhtml#ch5fig28">Figure 5.28</a>): the first defines a point <em>p</em> in Cartesian space (the vehicle’s future position), and the second and third define a line segment between two points <em>a</em> and <em>b</em> (the path).</p>&#13;
<div class="image"><img id="ch5fig28" src="../images/pg292_Image_455.jpg" alt="Image" width="509" height="417"/></div>&#13;
<p class="figcap">Figure 5.28: The elements of the <span class="literal">getNormalPoint()</span> function: <span class="literal">position</span>, <span class="literal">a</span>, and <span class="literal">b</span></p>&#13;
<div class="imagel"><img src="../images/pg292_Image_456.jpg" alt="Image" width="1125" height="369"/></div>&#13;
<p class="noindent">What do I have so far? I have a <span class="literal">Path</span> class that defines a path as a line between two points. I have a <span class="literal">Vehicle</span> class with a method to follow the path (using steering to seek a target along the path). In all, this makes for a decent example, and yet it’s pretty darn limiting. What’s missing?</p>&#13;
<p class="noindent">Take a deep breath. You’re almost there.</p>&#13;
<h4 class="h4" id="ch00lev2sec34"><strong>Path Following with Multiple Segments</strong></h4>&#13;
<p class="noindent">What if I want a vehicle to follow a more complex path than just a single straight line? Perhaps a curved path that moves in a variety of directions, as in <a href="ch05.xhtml#ch5fig29">Figure 5.29</a>?</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_253"/><img id="ch5fig29" src="../images/pg293_Image_457.jpg" alt="Image" width="841" height="241"/></div>&#13;
<p class="figcap">Figure 5.29: A more complex path</p>&#13;
<p class="noindent">Maybe I’m being a little too ambitious. I <em>could</em> investigate algorithms for following a curved path, but I’m much less likely to end up needing a cool compress on my forehead if I stick with straight line segments, like those in <a href="ch05.xhtml#ch5fig30">Figure 5.30</a>. I could always still <em>draw</em> the path as a curve, but it’s best to approximate it behind the scenes with simplified geometric forms for the necessary calculations.</p>&#13;
<div class="image"><img id="ch5fig30" src="../images/pg293_Image_458.jpg" alt="Image" width="844" height="256"/></div>&#13;
<p class="figcap">Figure 5.30: The same curved path, but approximated as connected line segments</p>&#13;
<p class="noindent">If I made path following work with one line segment, how do I make it work with a series of connected line segments? The key is in the way I find the target point along the path.</p>&#13;
<p class="noindent">To find the target with just one line segment, I had to compute the normal to that line segment. Now that I have a series of line segments, I also have a series of normal points to be computed—one for each segment (see <a href="ch05.xhtml#ch5fig31">Figure 5.31</a>). Which one does the vehicle choose? The solution Reynolds proposed is to pick the normal point that is (a) closest and (b) on the path.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_254"/><img id="ch5fig31" src="../images/pg294_Image_459.jpg" alt="Image" width="901" height="578"/></div>&#13;
<p class="figcap">Figure 5.31: Finding the closest normal point along a series of connected line segments</p>&#13;
<p class="noindent">If you have a point and an infinitely long line, you’ll always have a normal point that touches the line. But if you have a point and a finite line segment, you won’t necessarily find a normal that’s on the line segment. If this happens for any of the segments, I can disqualify those normals. Once I’m left with just those normals that are on the path (only two in <a href="ch05.xhtml#ch5fig31">Figure 5.31</a>), I pick the one that’s shortest.</p>&#13;
<p class="noindent">To write the code for this, I’ll expand the <span class="literal">Path</span> class to have an array of points (rather than just the start and end).</p>&#13;
<div class="imagel" id="ch5ex7"><img src="../images/pg294_Image_460.jpg" alt="Image" width="1125" height="1588"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_255"/>Now that the <span class="literal">Path</span> class has been updated, it’s the vehicle’s turn to learn how to accommodate multiple line segments. All it did before was find the normal for one line. Using a loop, it can find the normals for all the segments:</p>&#13;
<div class="imagel"><img src="../images/pg295_Image_462.jpg" alt="Image" width="1139" height="203"/></div>&#13;
<p class="noindent">The next step is to test whether the normal point is actually between points <span class="literal">a</span> and <span class="literal">b</span>. Since I know the path goes from left to right in this example, I can test whether the <span class="literal">x</span> component of <span class="literal">normalPoint</span> is outside the <span class="literal">x</span> components of <span class="literal">a</span> and <span class="literal">b</span>.</p>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_256"/><img src="../images/pg296_Image_463.jpg" alt="Image" width="1138" height="204"/></div>&#13;
<p class="noindent">If the normal point is not within the line segment, I’ll just pretend the end point of that line segment is the normal. (You might also try the beginning point, depending on the particulars of your path.) This will ensure that the vehicle always stays on the path, even if it strays beyond the bounds of the line segments.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe10"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.10</strong></p>&#13;
<p class="noindent">A more general-purpose way to test whether the normal point lies on the segment is to sum the distances between <span class="literal">normalPoint</span> and <span class="literal">a</span> and <span class="literal">b</span>. If the result is greater than the length of the line segment, the normal is outside the segment. Can you write this algorithm with p5.js?</p>&#13;
</div>&#13;
<p class="noindent">Finally, I need to find the closest normal point to the vehicle. To accomplish this, I can start with a very high “world record” distance and iterate through each normal point to see if it beats (is less than) the record. Each time a normal point beats the record, the world record is updated, and the winning point is stored in a variable named <span class="literal">target</span>. At the end of the loop, <span class="literal">target</span> will hold the closest normal point.</p>&#13;
<div class="imagel" id="ch5ex8"><img src="../images/pg296_Image_464.jpg" alt="Image" width="1125" height="1253"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_257"/>You may have noticed the use of <span class="literal">Infinity</span> to initialize <span class="literal">worldRecord</span>. In JavaScript, <span class="literal">Infinity</span> is a special numeric value that represents, well, infinity. It works in this case because I need a starting value that will always be higher than any plausible distance calculated in the code. The first calculated distance will always set a new world record, against which all the others will be compared.</p>&#13;
<p class="noindent">I also want to highlight the hardcoded value of <span class="literal">25</span>, which sets the distance ahead on the path from the normal for the target. Reynolds indicates that this value should be dynamic and calculated based on the vehicle’s distance to the path and its speed. Give this a try and see how it improves the accuracy or responsiveness of the path-following behavior!</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe11"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.11</strong></p>&#13;
<p class="noindent">Create a path that changes over time. Can the points that define the path have their own steering behaviors?</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec53"><strong>Complex Systems</strong></h3>&#13;
<p class="noindent">I said the purpose of this chapter is to breathe life into the things that move around p5.js canvases. You’ve come a long way by learning to write the code for an autonomous agent and playing with examples of that agent’s individual behaviors. But this is no place to stop. Yes, a vehicle is a simulated being that makes decisions about how to seek and flow and follow. But what is a life led alone, without the love and support of others?</p>&#13;
<p class="noindent">And so, as a logical next step, I’ll take the work I’ve done developing behaviors for individual autonomous agents and apply it to simulations that involve <em>many</em> autonomous agents operating in parallel—agents that have an ability to perceive not only their physical environment but also the actions of their fellow agents, and then act accordingly. In other words, I want to create complex systems with p5.js.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_258"/>A <strong>complex system</strong> is typically defined as a system that’s more than the sum of its parts. While the individual elements of the system may be incredibly simple and easily understood, the behavior of the system as a whole can be highly complex, intelligent, and difficult to predict.</p>&#13;
<p class="noindent">Think, for example, about a tiny, crawling ant—one single ant. An ant is an autonomous agent; it can perceive its environment (using antennae to gather information about the direction and strength of chemical signals) and make decisions about how to move based on those signals. But can a single ant acting alone build a nest, gather food, or defend its queen? An ant is a simple unit that can perceive only its immediate environment. A <em>colony</em> of ants, however, is a sophisticated, complex system, a superorganism of components that work together to accomplish difficult, complicated goals.</p>&#13;
<p class="noindent">Here are three key principles that will guide my work with complex systems:</p>&#13;
<ul class="bullet">&#13;
<li class="noindent"><strong>Simple units have short-range relationships.</strong> This is what I’ve been building all along: vehicles that have a limited perception of their environment.</li>&#13;
<li class="noindent"><strong>Simple units operate in parallel.</strong> For every cycle through the <span class="literal">draw()</span> loop, each unit will calculate its own steering forces. This will create the appearance of all the units working in parallel.</li>&#13;
<li class="noindent"><strong>Systems as a whole exhibit emergent phenomena.</strong> Complex behaviors, patterns, and intelligence can emerge from the interactions among simple units. This phenomenon occurs in nature, such as in ant colonies, migration patterns, earthquakes, and snowflakes. The question is whether the same results can be achieved in a p5.js sketch.</li>&#13;
</ul>&#13;
<p class="noindent">Beyond these core principles, three additional qualities of complex systems will help frame the discussion, as well as provide guidelines for features to include in a software simulation. It’s important to acknowledge that this is a fuzzy set of characteristics, and not all complex systems have all of them:</p>&#13;
<ul class="bullet">&#13;
<li class="noindent"><strong>Nonlinearity:</strong> This aspect of complex systems is often casually referred to as the <em>butterfly effect</em>, coined by mathematician and meteorologist Edward Norton Lorenz, a pioneer in the study of chaos theory. In 1961, Lorenz was running a computer weather simulation for the second time and, perhaps to save a little time, typed in a starting value of 0.506 instead of 0.506127. The end result was completely different from the first result of the simulation. Stated more evocatively, the theory is that a single butterfly flapping its wings on the other side of the world could cause a massive weather shift and ruin your weekend at the beach. It’s called <em>nonlinear</em> because there isn’t a linear relationship between a change in initial conditions and a change in outcome. A small change in initial conditions can have a massive effect on the outcome. Nonlinear systems are a superset of chaotic systems. In <a href="ch07.xhtml#ch07">Chapter 7</a>, you’ll see how even in a system of many 0s and 1s, if you change just one bit, the result will be completely different.</li>&#13;
<li class="noindent"><strong>Competition and cooperation:</strong> One ingredient that often makes a complex system tick is the presence of both competition and cooperation among the elements. The <span epub:type="pagebreak" id="page_259"/>upcoming flocking system will have three rules: alignment, cohesion, and separation. Alignment and cohesion will ask the elements to “cooperate” by trying to stay together and move together. Separation, however, will ask the elements to “compete” for space. When the time comes, try taking out just the cooperation or just the competition, and you’ll see how the system loses its complexity. Competition and cooperation are found together in living complex systems, but not in nonliving complex systems like the weather.</li>&#13;
<li class="noindent"><strong>Feedback:</strong> Complex systems often include a loop that feeds the output of the system back into the system to influence its behavior in a positive or negative direction. Let’s say you decide to take public transportation to work each day because it’s the most reliable and cost-effective solution, and you’re put off by the traffic congestion and environmental impact of driving. You aren’t alone; others turn to public transportation too. The system grows more efficient and attractive, serving more people with the same resources, and meanwhile, vehicle traffic is reduced. Over time, however, the system may struggle to accommodate the rising demand, leading to overcrowding, delays, and increased fares to fund infrastructure improvements. As a result, you and others start to switch back to driving, thereby increasing traffic congestion once again and reducing public transport’s efficiency. As traffic worsens, the funds from increased fares are (hopefully) used to improve public transport infrastructure, making it more appealing once again. In this way, the cost and efficiency of public transportation are both the input of the system (determining whether you choose to use it or not) and the output (the degree of traffic congestion and subsequent cost and efficiency). Economic models are just one example of a human complex system. Others include fads and trends, elections, crowds, and traffic flow.</li>&#13;
</ul>&#13;
<p class="noindent">Complexity will serve as a key theme for much of the remainder of the book. In this section, I’ll begin by introducing an additional feature to the <span class="literal">Vehicle</span> class: the ability to perceive neighboring vehicles. This enhancement will pave the way for a culminating example of a complex system in which the interplay of simple individual behaviors results in an emergent behavior: flocking.</p>&#13;
<h4 class="h4" id="ch00lev2sec35"><strong>Implementing Group Behaviors (or: Let’s Not Run Into Each Other)</strong></h4>&#13;
<p class="noindent">Managing a group of objects is certainly not a new concept. You’ve seen this before—in <a href="ch04.xhtml#ch04">Chapter 4</a>, where I developed the <span class="literal">Emitter</span> class to represent an overall particle system. There, I used an array to store a list of individual particles. I’ll start with the same technique here and store <span class="literal">Vehicle</span> objects in an array:</p>&#13;
<div class="imagel"><img src="../images/pg299_Image_466.jpg" alt="Image" width="1125" height="336"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_260"/>Now, when it comes time to manipulate all the vehicles in <span class="literal">draw()</span>, I can loop through the array and call the necessary methods:</p>&#13;
<pre class="pre">function draw() {&#13;
  for (let vehicle of vehicles) {&#13;
    vehicle.update();&#13;
    vehicle.show();&#13;
  }&#13;
}</pre>&#13;
<p class="noindent">Maybe I want to add a behavior, a force to be applied to all the vehicles. This could be seeking the mouse:</p>&#13;
<pre class="pre">    vehicle.seek(mouseX, mouseY);</pre>&#13;
<p class="noindent">But that’s an <em>individual</em> behavior, and I’ve already spent the bulk of this chapter worrying about individual behaviors. You’re here because you want to apply a <em>group</em> behavior. I’ll begin with <strong>separation</strong>, a behavior that commands, “Avoid colliding with your neighbors!”</p>&#13;
<pre class="pre">    vehicle.separate();</pre>&#13;
<p class="noindent">That looks good but is not quite right. What’s missing? In the case of <span class="literal">seek()</span>, I said, “Seek <span class="literal">mouseX</span> and <span class="literal">mouseY</span>.” In the case of <span class="literal">separate()</span>, I’m saying, “Separate from <em>everyone else</em>.” Who is everyone else? It’s the list of all the other vehicles:</p>&#13;
<pre class="pre">    vehicle.separate(vehicles);</pre>&#13;
<p class="noindent">This is the big leap beyond what you saw before with particle systems. Instead of each element (particle or vehicle) operating on its own, I’m now saying, “Hey you, that vehicle there! When it comes time for you to operate, you need to operate with an awareness of everyone else. So I’m going to go ahead and pass you the list of everyone else.”</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_261"/>Putting together what I’ve done so far, here are the <span class="literal">setup()</span> and <span class="literal">draw()</span> functions for a sketch that exhibits group behavior:</p>&#13;
<div class="imagel"><img src="../images/pg301_Image_468.jpg" alt="Image" width="1125" height="859"/></div>&#13;
<div class="image"><img id="ch5fig32" src="../images/pg301_Image_469.jpg" alt="Image" width="339" height="55"/></div>&#13;
<p class="figcap">Figure 5.32: The desired velocity for separation (equivalent to fleeing) is a vector that points in the opposite direction of a target.</p>&#13;
<p class="noindent">Of course, this is just the beginning. The real work happens inside the <span class="literal">separate()</span> method. Reynolds defines the separation behavior as “steer to avoid crowding.” In other words, if a given vehicle is too close to you, steer away from that vehicle. Sound familiar? Remember the seek behavior, steering a vehicle toward a target? Reverse that force and you have the flee behavior, which is what should be applied here to achieve separation (see <a href="ch05.xhtml#ch5fig32">Figure 5.32</a>).</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_262"/>But what if more than one vehicle is too close? In that case, I’ll define separation as the average of all the vectors pointing away from any close vehicles (<a href="ch05.xhtml#ch5fig33">Figure 5.33</a>).</p>&#13;
<div class="image"><img id="ch5fig33" src="../images/pg302_Image_470.jpg" alt="Image" width="307" height="282"/></div>&#13;
<p class="figcap">Figure 5.33: Desired velocity for separation is the average of multiple fleeing desired velocities.</p>&#13;
<p class="noindent">How do I turn that into code? Remember, I’m writing a method called <span class="literal">separate()</span> that receives an array of <span class="literal">Vehicle</span> objects as an argument:</p>&#13;
<pre class="pre">separate(vehicles) {&#13;
&#13;
}</pre>&#13;
<p class="noindent">Inside this method, I’ll loop through all the vehicles and see if any are too close:</p>&#13;
<div class="imagel"><img src="../images/pg302_Image_471.jpg" alt="Image" width="1125" height="379"/></div>&#13;
<p class="noindent">Notice that I’m checking not only whether the distance is less than a desired separation but also whether <span class="literal">this</span> is not equal to <span class="literal">other</span>. This is a key element. Remember, all the vehicles are in the array; without this extra check, the vehicle will attempt to flee from itself!</p>&#13;
<p class="noindent">If the vehicles are too close, I compute a vector that points away from the offending vehicle:</p>&#13;
<div class="imagel"><img src="../images/pg302_Image_472.jpg" alt="Image" width="1125" height="167"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_263"/>This isn’t enough. I have a fleeing vector now, but what I really need is the average of the fleeing vectors for all the vehicles that are too close. How do I compute an average? Add up all the vectors and divide by the total:</p>&#13;
<div class="imagel"><img src="../images/pg303_Image_473.jpg" alt="Image" width="1125" height="782"/></div>&#13;
<p class="noindent">Once I have the average vector (stored in the variable <span class="literal">sum</span>), that vector can be scaled to the maximum speed and become the desired velocity—the vehicle <em>desires</em> to move in that direction at maximum speed! (In fact, I really don’t have to divide by <span class="literal">count</span> anymore since the magnitude is set manually.) And once I have the desired velocity, it’s the same old Reynolds story—steering equals desired minus velocity:</p>&#13;
<div class="imagel"><img src="../images/pg303_Image_474.jpg" alt="Image" width="1125" height="293"/></div>&#13;
<p class="noindent">The following example shows the method in its entirety.</p>&#13;
<div class="imagel" id="ch5ex9"><span epub:type="pagebreak" id="page_264"/><img src="../images/pg304_Image_475.jpg" alt="Image" width="1126" height="1460"/></div>&#13;
<p class="noindent">The <span class="literal">separate()</span> method includes two extra improvements. First, the desired separation now depends on the size of the vehicle, as opposed to an arbitrary constant. This way, the separation behavior <span epub:type="pagebreak" id="page_265"/>adapts dynamically to the individual characteristics of the vehicles. Second, the magnitude of the vector pointing away from a neighboring vehicle is set to be inversely proportional to the distance. This means that the closer the neighbor, the more the vehicle wants to flee, and vice versa.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe12"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.12</strong></p>&#13;
<p class="noindent">Create a <span class="literal">cohere()</span> method that follows the opposite logic of <span class="literal">separate()</span>: if a vehicle is beyond a certain distance, steer toward that vehicle. This will keep the group together. (In a moment, I’ll look at what happens when both cohesion and separation play out together in the same simulation.)</p>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe13"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.13</strong></p>&#13;
<p class="noindent">Add the separation force to path following to create a simulation of Reynolds’s group path following.</p>&#13;
<div class="imagel"><img src="../images/pg305_Image_476.jpg" alt="Image" width="1044" height="439"/></div>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev2sec36"><strong>Combining Behaviors</strong></h4>&#13;
<p class="noindent">The most exciting and intriguing group behaviors come from mixing and matching multiple steering forces. After all, how could I even begin to simulate emergence in a complex system through a sketch that has only one rule?</p>&#13;
<p class="noindent">When multiple steering forces are at play, I need a mechanism for managing them all. You may be thinking, “This is nothing new. We juggle multiple forces all the time.” You would be right. In fact, this technique appeared as early as <a href="ch02.xhtml#ch02">Chapter 2</a>:</p>&#13;
<pre class="pre">  let wind = createVector(0.001, 0);&#13;
  let gravity = createVector(0, 0.1);&#13;
  mover.applyForce(wind);&#13;
  mover.applyForce(gravity);</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_266"/>Here, a <span class="literal">Mover</span> object responds to two forces. This all works nicely because of the way the <span class="literal">Mover</span> class was designed to accumulate the force vectors into its acceleration vector. In this chapter, however, the forces stem from the internal desires of the movers (now called <em>vehicles</em>). And those desires can be weighted so that some hold more sway than others. For example, consider a sketch in which all vehicles have two desires:</p>&#13;
<ul class="bullet">&#13;
<li class="noindent">Seek the mouse position.</li>&#13;
<li class="noindent">Separate from any vehicles that are too close.</li>&#13;
</ul>&#13;
<p class="noindent">Imagine the vehicles represent a school of fish. Although the fish want to avoid colliding with one another, their primary concern is seeking out a food source (the mouse). Being able to adjust the weights of the two steering forces is crucial to achieving this effect.</p>&#13;
<p class="noindent">To begin, I’ll add a method called <span class="literal">applyBehaviors()</span> to the <span class="literal">Vehicle</span> class to manage all the behaviors:</p>&#13;
<pre class="pre">applyBehaviors(vehicles) {&#13;
  this.separate(vehicles);&#13;
  this.seek(createVector(mouseX, mouseY));&#13;
}</pre>&#13;
<p class="noindent">Here, a single method takes care of calling the other methods that apply the forces—<span class="literal">separate()</span> and <span class="literal">seek()</span>. I could start mucking around within those methods to adjust the strength of the forces they’re calculating, but it might be easier to instead ask those methods to simply calculate and return the forces. Then I can adjust the forces’ strength and apply them to the vehicle’s acceleration within <span class="literal">applyBehaviors()</span>:</p>&#13;
<div class="imagel"><img src="../images/pg306_Image_477.jpg" alt="Image" width="1125" height="253"/></div>&#13;
<p class="noindent">Here’s how this new approach changes the <span class="literal">seek()</span> method:</p>&#13;
<div class="imagel"><img src="../images/pg306_Image_478.jpg" alt="Image" width="1126" height="405"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_267"/>This change is subtle but incredibly important: it allows the strength of these forces to be weighted all in one place.</p>&#13;
<div class="imagel" id="ch5ex10"><img src="../images/pg307_Image_480.jpg" alt="Image" width="1126" height="890"/></div>&#13;
<p class="noindent">In this code, I use <span class="literal">mult()</span> to adjust the forces. By multiplying each force vector by a factor, its magnitude is scaled accordingly. These factors (in this case, 1.5 for <span class="literal">separate</span> and 0.5 for <span class="literal">seek</span>) represent the weight assigned to each force. However, the weights don’t have to be constants. Think about how they might vary dynamically based on conditions within the environment or properties of the vehicle. For example, what if the <span class="literal">seek</span> weight increases when the vehicle detects food nearby (imagine the vehicle as a creature with a <span class="literal">hunger</span> property) or the <span class="literal">separate</span> weight becomes larger if the vehicle enters a crowded area? This flexibility in adjusting the weights allows for more sophisticated and nuanced behaviors to emerge.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe14"><span epub:type="pagebreak" id="page_268"/><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.14</strong></p>&#13;
<p class="noindent">Modify <a href="ch05.xhtml#ch5ex10">Example 5.10</a> so that the behavior weights change over time. For example, what if the weights were calculated according to a sine wave or Perlin noise? Or what if some vehicles are more concerned with seeking and others are more concerned with separating? Can you introduce other steering behaviors as well?</p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev2sec37"><strong>Flocking</strong></h4>&#13;
<p class="noindent"><strong>Flocking</strong> is a group animal behavior found in many living creatures, such as birds, fish, and insects. In 1986, Reynolds created a computer simulation of flocking behavior and documented the algorithm in his paper “Flocks, Herds, and Schools: A Distributed Behavioral Model.” Re-creating this simulation in p5.js will bring together all the concepts in this chapter:</p>&#13;
<ol class="order">&#13;
<li class="noindent">I will use the steering force formula (steer = desired – velocity) to implement the rules of flocking.</li>&#13;
<li class="noindent">These steering forces will be group behaviors and will require each vehicle to perceive all the other vehicles.</li>&#13;
<li class="noindent">I will combine and weight multiple forces.</li>&#13;
<li class="noindent">The result will be a complex system—intelligent group behavior will emerge from the simple rules of flocking without the presence of a centralized system or leader.</li>&#13;
</ol>&#13;
<p class="noindent">The good news is, I’ve already demonstrated items 1 through 3 in this chapter, so this section can just be about putting it all together and seeing the result.</p>&#13;
<p class="noindent">Before I begin, I should mention that I’m going to change the name of the <span class="literal">Vehicle</span> class (yet again). Reynolds uses the term <em>boid</em> (a made-up word that refers to a birdlike object) to describe the elements of a flocking system. I’ll do the same.</p>&#13;
<p class="noindent">Three rules govern flocking:</p>&#13;
<ul class="bullet">&#13;
<li class="noindent"><strong>Separation</strong> (aka avoidance): Steer to avoid colliding with your neighbors.</li>&#13;
<li class="noindent"><strong>Alignment</strong> (aka copy): Steer in the same direction as your neighbors.</li>&#13;
<li class="noindent"><strong>Cohesion</strong> (aka center): Steer toward the center of your neighbors (stay with the group).</li>&#13;
</ul>&#13;
<p class="noindent"><a href="ch05.xhtml#ch5fig34">Figure 5.34</a> illustrates these rules.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_269"/><img id="ch5fig34" src="../images/pg309_Image_481.jpg" alt="Image" width="885" height="324"/></div>&#13;
<p class="figcap">Figure 5.34: The three rules of flocking: separation, alignment, and cohesion. The example vehicle and desired velocity are bold.</p>&#13;
<p class="noindent">Just as with <a href="ch05.xhtml#ch5ex10">Example 5.10</a>, in which I combined separation and seeking, I want the <span class="literal">Boid</span> objects to have a single method that manages all three behaviors. I’ll call it <span class="literal">flock()</span>:</p>&#13;
<div class="imagel"><img src="../images/pg309_Image_482.jpg" alt="Image" width="1125" height="426"/></div>&#13;
<p class="noindent">Now, it’s just a matter of implementing the three rules. I applied separation already; it’s identical to the previous example. Instead, I’ll focus on alignment, or steering in the same direction as the neighboring boids. As with all other steering behaviors, I have to express this concept as a desire: the boid’s desired velocity is the average velocity of its neighbors. The algorithm is therefore to calculate the average velocity of all the other boids and set that to the desired velocity:</p>&#13;
<div class="imagel"><img src="../images/pg309_Image_483.jpg" alt="Image" width="1125" height="474"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_270"/>This is pretty good but is missing one rather crucial detail. One of the key principles behind complex systems like flocking is that the elements (in this case, boids) have <em>short-range</em> relationships. Thinking about ants again, it’s easy to imagine an ant being able to sense its immediate environment, but less so an ant having an awareness of what another ant is doing hundreds of feet away. Indeed, the ants’ ability to manifest such complex collective behavior from only these neighboring relationships is what makes them so exciting in the first place.</p>&#13;
<p class="noindent">In the <span class="literal">align()</span> method, I’m currently taking the average velocity of <em>all</em> the boids, whereas I should really be looking at only the boids within a certain distance (see <a href="ch05.xhtml#ch5fig35">Figure 5.35</a>). That distance threshold can be variable, of course. You could design boids that can see only 20 pixels away or boids that can see 100 pixels away.</p>&#13;
<div class="image"><img id="ch5fig35" src="../images/pg310_Image_485.jpg" alt="Image" width="824" height="510"/></div>&#13;
<p class="figcap">Figure 5.35: The example vehicle (bold) interacts with only the vehicles within its neighborhood (the circle).</p>&#13;
<p class="noindent">I already applied similar logic when I implemented separation, calculating a force based only on other vehicles within a certain distance. Now I want to do the same for alignment (and eventually, cohesion):</p>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_271"/><img src="../images/pg311_Image_486.jpg" alt="Image" width="1125" height="821"/></div>&#13;
<p class="noindent">As with the <span class="literal">separate()</span> method, I’ve included the condition <span class="literal">this !== other</span> to ensure that a boid doesn’t consider itself when calculating the average velocity. It would probably work regardless, but having each boid constantly be influenced by its own velocity could lead to a feedback loop that would disrupt the overall behavior.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe15"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.15</strong></p>&#13;
<p class="noindent">Can you rewrite the <span class="literal">align()</span> method so that boids see only other boids that fall within a direct line of sight?</p>&#13;
<div class="imagel"><img src="../images/pg311_Image_487.jpg" alt="Image" width="476" height="301"/></div>&#13;
</div>&#13;
<p class="noindent">The code for cohesion is quite similar to that for alignment. The only difference is that instead of calculating the average <em>velocity</em> of the boid’s neighbors, I want to calculate the average <em>position</em> of the boid’s neighbors (and use that as a target to seek).</p>&#13;
<div class="imagel"><span epub:type="pagebreak" id="page_272"/><img src="../images/pg312_Image_488.jpg" alt="Image" width="1125" height="748"/></div>&#13;
<p class="noindent">It’s also worth taking the time to write a class called <span class="literal">Flock</span> that manages the whole group of boids. It will be virtually identical to the <span class="literal">ParticleSystem</span> class from <a href="ch04.xhtml#ch04">Chapter 4</a>, with only one tiny change: when I call <span class="literal">run()</span> on each <span class="literal">Boid</span> object (as I did to each <span class="literal">Particle</span> object), I’ll pass in a reference to the entire array of boids:</p>&#13;
<div class="imagel"><img src="../images/pg312_Image_489.jpg" alt="Image" width="1125" height="590"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_273"/>All that remains is to initialize the flock in <span class="literal">setup()</span> and run it in <span class="literal">draw()</span>.</p>&#13;
<div class="imagel" id="ch5ex11"><img src="../images/pg313_Image_490.jpg" alt="Image" width="1126" height="1104"/></div>&#13;
<p class="noindent">Just as with the particle systems from <a href="ch04.xhtml#ch04">Chapter 4</a>, you can see the elegance of OOP in simplifying the <span class="literal">setup()</span> and <span class="literal">draw()</span> functions.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe16"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.16</strong></p>&#13;
<p class="noindent">Combine flocking with other steering behaviors.</p>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe17"><span epub:type="pagebreak" id="page_274"/><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.17</strong></p>&#13;
<p class="noindent">In his book <em>The Computational Beauty of Nature</em> (Bradford Books, 2000), Gary Flake describes a fourth rule for flocking, <strong>view</strong>: “Move laterally away from any boid that blocks the view.” Have your boids follow this rule.</p>&#13;
<div class="imagel"><img src="../images/pg314_Image_491.jpg" alt="Image" width="467" height="363"/></div>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe18"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.18</strong></p>&#13;
<p class="noindent">Create a flocking simulation in which all the parameters (<em>separation weight</em>, <em>cohesion weight</em>, <em>alignment weight</em>, <em>maximum force</em>, <em>maximum speed</em>) change over time. They could be controlled by Perlin noise or by user interaction. (For example, you could use the p5.js <span class="literal">createSlider()</span> function to tie the values to slider positions that can be adjusted in real time.)</p>&#13;
</div>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe19"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.19</strong></p>&#13;
<p class="noindent">Visualize the flock in an entirely different way.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec54"><strong>Algorithmic Efficiency (or: Why Does My Sketch Run So Slowly?)</strong></h3>&#13;
<p class="noindent">Group behaviors are wonderful, but it’s with a heavy heart that I must admit that they can also be slow. In fact, the bigger the group, the slower the sketch can be. I’d love to hide this dark truth from you, because I’d like you to be happy and live a fulfilling and meaningful life, free from concerns about the efficiency of your code. But I’d also like to be able to sleep at night without worrying about your inevitable disappointment when you try to run your flocking simulation with too many boids.</p>&#13;
<p class="noindent">Usually, when I talk about p5.js sketches running slowly, it’s because drawing to the canvas can be slow—the more you draw, the slower your sketch runs. As you may recall from <a href="ch04.xhtml#ch04">Chapter 4</a>, switching to a different renderer like WebGL can sometimes alleviate this issue, allowing for faster drawing of larger particle systems. With something like a flocking simulation, however, the slowness derives from the algorithm. Computer scientists put this problem in terms of something called <strong>big</strong> <em>Ο</em> <strong>notation</strong>, where the <em>O</em> stands for <em>order</em>. This is shorthand for describing the efficiency of an algorithm: How many computational cycles does the algorithm require to complete?</p>&#13;
<p class="noindent">Consider a simple search problem. You have a basket containing 100 chocolate treats, only one of which is pure dark chocolate. That’s the one you want to eat. To find it, you pick the chocolates out of the basket one by one. You might be lucky and find it on the first try, but in the worst-case scenario, <span epub:type="pagebreak" id="page_275"/>you have to check all 100 before you find the dark chocolate. To find one thing in 100, you have to check 100 things (or to find one thing in <em>N</em> things, you have to check <em>N</em> times). The big <em>O</em> notation here is <em>O(N</em>). This, incidentally, is also the big <em>O</em> notation that describes a simple particle system. If you have <em>N</em> particles, you have to run and display those particles <em>N</em> times.</p>&#13;
<p class="noindent">Now, let’s think about a group behavior such as flocking. For every <span class="literal">Boid</span> object, you have to check the velocity and position of every other <span class="literal">Boid</span> object before you can calculate its steering force. Let’s say you have 100 boids. For boid 1, you need to check 100 boids; for boid 2, you need to check 100 boids; and so on. In all, for 100 boids, you need to perform 10,000 checks (100 × 100 = 10,000).</p>&#13;
<p class="noindent">You might be thinking, “No problem. Computers are fast. They can do 10,000 things pretty easily.” But what if there are 1,000 boids? Then you have this:</p>&#13;
<p class="hang">1,000 × 1,000 = 1,000,000 cycles</p>&#13;
<p class="noindent">This is getting rather slow but is still somewhat manageable. What about 10,000 elements?</p>&#13;
<p class="hang">10,000 × 10,000 = 100,000,000 cycles</p>&#13;
<p class="noindent">Now things are getting really slow. Really, really, really slow.</p>&#13;
<p class="noindent">Notice a pattern? As the number of elements increases by a factor of 10, the number of required cycles increases by a factor of 100. More broadly, as the number of elements increases by a factor of <em>N</em>, the cycles increase by a factor of <em>N</em> × <em>N</em>, or <em>N</em><sup>2</sup>. In big <em>O</em> notation, this is known as <em>O</em>(<em>N</em><sup>2</sup>).</p>&#13;
<p class="noindent">Perhaps you’re thinking, “No problem. With flocking, I need to consider only the boids that are close to the current boid. So even if I have 1,000 boids, I can just look at, say, the 5 closest boids to each one, and then I only have 5,000 cycles.” You pause for a moment and then start thinking, “So for each boid, I just need to check all the boids and find the 5 closest ones and I’m good!” See the catch-22? Even if you want to look at only the close ones, the only way to know what the close ones are would be to check all of them.</p>&#13;
<p class="noindent">Or is there another way?</p>&#13;
<h4 class="h4" id="ch00lev2sec38"><strong>Spatial Subdivisions</strong></h4>&#13;
<p class="noindent">In his 2000 paper “Interaction with Groups of Autonomous Characters” (<em><a href="https://www.red3d.com/cwr/papers/2000/pip.pdf">https://www.red3d.com/cwr/papers/2000/pip.pdf</a></em>), Reynolds (surprise, surprise) suggests a technique known as <strong>bin-lattice spatial subdivision</strong> (often called <em>binning</em> for short) for optimizing flocking algorithms and other group behaviors. This technique hinges on dividing the simulation space into a grid of smaller cells (or bins).</p>&#13;
<p class="noindent">To demonstrate, imagine the canvas is divided into a grid of 10 rows and 10 columns, for a total of 100 cells (10 × 10 = 100). And let’s say you have 2,000 boids—a number small enough for you to realistically want, but large enough to run too slowly (2,000 × 2,000 = 4,000,000 cycles). At any <span epub:type="pagebreak" id="page_276"/>given moment, each boid falls within a cell in the grid, as shown in <a href="ch05.xhtml#ch5fig36">Figure 5.36</a>. With 2,000 boids and 100 cells, on average there will be approximately 20 boids per cell (2,000 ÷ 100 = 20).</p>&#13;
<div class="image"><img id="ch5fig36" src="../images/pg316_Image_492.jpg" alt="Image" width="756" height="770"/></div>&#13;
<p class="figcap">Figure 5.36: A square canvas full of vehicles, subdivided into a grid of square cells</p>&#13;
<p class="noindent">Now say that in order to apply the flocking rules to a given boid, you need to look at only the other boids that are in that boid’s cell. With an average of 20 boids per cell, each cell would require 400 cycles (20 × 20 = 400), and with 100 cells, that’s 40,000 cycles total (400 × 100 = 40,000). That’s a massive savings of over 4,000,000 cycles!</p>&#13;
<p class="noindent">To implement the bin-lattice spatial subdivision algorithm in p5.js, I’ll need multiple arrays. The first array keeps track of all the boids, just as in the original flocking example:</p>&#13;
<pre class="pre">let boids = [];</pre>&#13;
<p class="noindent">The second is a 2D array (repurposing the code from <a href="ch05.xhtml#ch5ex4">Example 5.4</a>) representing the cells in the grid:</p>&#13;
<div class="imagel"><img src="../images/pg316_Image_493.jpg" alt="Image" width="1125" height="295"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_277"/>Each value in the 2D array is itself an array that will hold references to the <span class="literal">Boid</span> objects currently inside that cell in the grid. If you’re keeping score, that’s an array within an array within an array:</p>&#13;
<div class="imagel"><img src="../images/pg317_Image_495.jpg" alt="Image" width="1125" height="228"/></div>&#13;
<p class="noindent">Every cycle through <span class="literal">draw()</span>, the array for each grid cell is first cleared. Then each boid registers itself in the appropriate cell according to its position. This way, the boids’ cell assignments are updated as the boids move:</p>&#13;
<div class="imagel"><img src="../images/pg317_Image_496.jpg" alt="Image" width="1139" height="573"/></div>&#13;
<p class="noindent">Finally, when it comes time to have the boids check their neighbors, they can look at only those in their particular cell.</p>&#13;
<div class="imagel" id="ch5ex12"><span epub:type="pagebreak" id="page_278"/><img src="../images/pg318_Image_497.jpg" alt="Image" width="1126" height="910"/></div>&#13;
<p class="noindent">I’m covering only the basics of the bin-lattice algorithm here. In practice, each boid should also check the boids in the neighboring cells (above, below, left, right, and diagonals), as well as the boids in its own cell. (To find out how that’s done, see the full code on the book’s website.) Even with that extra checking, however, the algorithm is still much more efficient than checking every single boid.</p>&#13;
<p class="noindent">This approach still has flaws, however. For example, what if all the boids congregate in the corner and live in the same cell? Doesn’t that take me right back to checking all 2,000 against all 2,000? In fact, bin-lattice spatial subdivision is most effective when the elements are evenly distributed throughout the canvas. A data structure known as a <strong>quadtree</strong>, however, can handle unevenly distributed systems, preventing the worst-case scenario of all the boids crowding into a single cell.</p>&#13;
<p class="noindent">The quadtree expands the spatial subdivision strategy by dynamically adapting the grid according to the distribution of the boids. Instead of a fixed grid, a quadtree starts with a single large cell that encompasses the entire space. If too many boids are found within this cell, it splits into four smaller cells. This process can repeat for each new cell that gets too crowded, creating a flexible grid that provides finer resolution when and where it’s needed.</p>&#13;
<div class="imagel" id="ch5ex13"><span epub:type="pagebreak" id="page_279"/><img src="../images/pg319_Image_498.jpg" alt="Image" width="1126" height="488"/></div>&#13;
<p class="noindent">The quadtree data structure is key to the Barnes-Hut algorithm, which I referenced briefly when building an <em>n</em>-body simulation in <a href="ch02.xhtml#ch02">Chapter 2</a>. This method uses a quadtree to approximate groups of bodies into a single one when calculating gravitational forces. This drastically reduces the number of calculations needed, allowing simulations with large numbers of bodies to run more efficiently. You can learn more about building a quadtree and applying it to a flocking system as part of Coding Challenge #98 on the Coding Train website (<em><a href="https://thecodingtrain.com/quadtree">https://thecodingtrain.com/quadtree</a></em>).</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe20"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.20</strong></p>&#13;
<p class="noindent">Expand the bin-lattice spatial subdivision flocking sketch from <a href="ch05.xhtml#ch5ex12">Example 5.12</a> to use a quadtree.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev2sec39"><strong>More Optimization Tricks</strong></h4>&#13;
<p class="noindent">While I’m at it, here are a few more tips related to keeping your code in tip-top, speedy shape:</p>&#13;
<ul class="bullet">&#13;
<li class="noindent">Use the magnitude squared (or sometimes the distance squared).</li>&#13;
<li class="noindent">Calculate the sine and cosine lookup tables.</li>&#13;
<li class="noindent">Don’t make gazillions of unnecessary p5.Vector objects.</li>&#13;
</ul>&#13;
<p class="noindent">Each of these tips is detailed next.</p>&#13;
<h5 class="h5" id="ch00lev3sec1"><strong>Use the Magnitude Squared</strong></h5>&#13;
<p class="noindent">What is magnitude squared, and when should you use it? Think back to how the magnitude of a vector is calculated.</p>&#13;
<pre class="pre"><span epub:type="pagebreak" id="page_280"/>function mag() {&#13;
  return sqrt(x * x + y * y);&#13;
}</pre>&#13;
<p class="noindent">Magnitude requires the square-root operation. And so it should! After all, if you want the magnitude of a vector, you have to break out the Pythagorean theorem (we did this in <a href="ch01.xhtml#ch01">Chapter 1</a>). However, if you could somehow skip taking the square root, your code would run faster.</p>&#13;
<p class="noindent">Say you just want to know the <em>relative</em> magnitude of a vector <span class="literal">v</span>. For example, is the magnitude greater than 10?</p>&#13;
<pre class="pre">if (v.mag() &gt; 10) {&#13;
  /* Do something! */&#13;
}</pre>&#13;
<p class="noindent">Well, that is equivalent to saying the following:</p>&#13;
<pre class="pre">if (v.magSq() &gt; 100) {&#13;
  /* Do something! */&#13;
}</pre>&#13;
<p class="noindent">And how is magnitude squared calculated?</p>&#13;
<pre class="pre">function magSq() {&#13;
  return x * x + y * y;&#13;
}</pre>&#13;
<p class="noindent">It’s calculated the same as magnitude, but without the square root. In the case of a single vector, using <span class="literal">magSq()</span> rather than <span class="literal">mag()</span> will never significantly improve the performance of a p5.js sketch. However, if you’re computing the magnitude of thousands of vectors each time through <span class="literal">draw()</span>, working with the magnitude squared could help your code run a wee bit faster.</p>&#13;
<h5 class="h5" id="ch00lev3sec2"><strong>Calculate Sine and Cosine Lookup Tables</strong></h5>&#13;
<p class="noindent">Taking the square root isn’t the only mathematical function that’s slow to compute. Trig functions like sine, cosine, and tangent are also slow. If you just need an individual sine or cosine value here or there in your code, you’re never going to run into a problem. But what if you had something like this?</p>&#13;
<pre class="pre"><span epub:type="pagebreak" id="page_281"/>function draw() {&#13;
  for (let i = 0; i &lt; 10000; i++) {&#13;
    print(sin(PI));&#13;
  }&#13;
}</pre>&#13;
<p class="noindent">Sure, this is a totally ridiculous code snippet that you would never write. But it illustrates a certain point: if you’re calculating the sine of pi 10,000 times, why not just calculate it once, save that value, and refer to it whenever necessary?</p>&#13;
<p class="noindent">This is the principle behind sine and cosine <strong>lookup tables</strong>. Instead of calling the sine and cosine functions in your code whenever you need them, you can build an array that stores the results of sine and cosine at angles from 0 to 2π, and then just look up the precalculated values when you need them. For example, here are two arrays that store the sine and cosine values for every integer angle from 0 to 359 degrees. I’ll use <span class="literal">angleMode(DEGREES)</span> here to simplify the discussion, but the same technique can be applied with radians:</p>&#13;
<pre class="pre">angleMode(DEGREES);&#13;
let sinvalues = [];&#13;
let cosvalues = [];&#13;
for (let i = 0; i &lt; 360; i++) {&#13;
  sinvalues[i] = sin(i);&#13;
  cosvalues[i] = cos(i);&#13;
}</pre>&#13;
<p class="noindent">Now, what if you need to print the sine of pi (or 180 degrees)?</p>&#13;
<pre class="pre">let angle = 180;&#13;
for (let i = 0; i &lt; 10000; i++) {&#13;
  print(sinvalues[angle]);&#13;
}</pre>&#13;
<p class="noindent">The key here is that looking up a precalculated value from an array is incredibly fast compared to a complex operation like sine or cosine.</p>&#13;
<div class="imagel" id="ch5ex14"><span epub:type="pagebreak" id="page_282"/><img src="../images/pg322_Image_499.jpg" alt="Image" width="1126" height="488"/></div>&#13;
<p class="noindent">The code accompanying <a href="ch05.xhtml#ch5ex14">Example 5.14</a> enhances the initial snippets by incorporating variables for the lookup table’s precision, allowing it to store values at increments of less than 1 degree.</p>&#13;
<h5 class="h5" id="ch00lev3sec3"><strong>Don’t Make Gazillions of Unnecessary p5.Vector Objects</strong></h5>&#13;
<p class="noindent">In any sketch, every object you create occupies space in the computer’s memory. This might not be a concern with just a few objects, but when sketches generate many objects, especially in loops or over time, it can slow performance. Sometimes it turns out that not all the objects are really necessary.</p>&#13;
<p class="noindent">I have to admit, I’m perhaps the biggest culprit when it comes to creating excessive objects. In the interest of writing clear and understandable examples, I often choose to make extra <span class="literal">p5.Vector</span> objects when I absolutely don’t need to. For the most part, this isn’t a problem at all. But sometimes it can be. Take a look at this example:</p>&#13;
<pre class="pre">function draw() {&#13;
  for (let v of vehicles) {&#13;
    let mouse = createVector(mouseX, mouseY);&#13;
    v.seek(mouse);&#13;
  }&#13;
}</pre>&#13;
<p class="noindent">Say the <span class="literal">vehicles</span> array contains 1,000 vehicles. That means I’m also making 1,000 new <span class="literal">p5.Vector</span> objects for the mouse’s position every single time through <span class="literal">draw()</span>. On any standard laptop or desktop computer purchased in recent times, this sketch likely won’t register a complaint, run slowly, or have any problems. After all, modern computers have tons of RAM, and JavaScript will be able to handle making and disposing of 1,000 or so temporary objects without much of a problem.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_283"/>If, however, the number of objects grows larger (and it easily could), a problem will almost certainly arise. As such, you should look for ways to reduce the number of <span class="literal">p5.Vector</span> objects you make. In this case, here’s a simple fix:</p>&#13;
<pre class="pre">function draw() {&#13;
  let mouse = createVector(mouseX, mouseY);&#13;
  for (let v of vehicles) {&#13;
    v.seek(mouse);&#13;
  }&#13;
}</pre>&#13;
<p class="noindent">Now I’ve made just 1 vector instead of 1,000. Even better, I could turn the vector into a global variable and then just assign the <span class="literal">x</span> and <span class="literal">y</span> values within <span class="literal">draw()</span> with <span class="literal">set()</span>:</p>&#13;
<pre class="pre">let mouse;&#13;
&#13;
function setup() {&#13;
  mouse = createVector();&#13;
}&#13;
&#13;
function draw() {&#13;
  mouse.set(mouseX, mouseY);&#13;
  for (let v of vehicles) {&#13;
    v.seek(mouse);&#13;
  }&#13;
}</pre>&#13;
<p class="noindent">Now I never make a new <span class="literal">p5.Vector</span> object after the sketch starts; I just use the same one over the whole length of the sketch!</p>&#13;
<p class="noindent">Throughout the book’s examples, you’ll find lots of opportunities to reduce the number of temporary objects. (I told you, I’m a major offender.) For example, here’s a snippet from this chapter’s <span class="literal">seek()</span> method:</p>&#13;
<div class="imagel"><img src="../images/pg323_Image_500.jpg" alt="Image" width="1125" height="265"/></div>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_284"/>See how I’ve made two vector objects? First, I calculate the desired velocity vector, then the steering force. To be more efficient, I could rewrite this to create only one vector:</p>&#13;
<div class="imagel"><img src="../images/pg324_Image_501.jpg" alt="Image" width="1125" height="240"/></div>&#13;
<p class="noindent">I don’t actually need a second vector called <span class="literal">steer</span>. I can reuse the <span class="literal">desired</span> vector object and turn it into the steering force by subtracting <span class="literal">velocity</span>. I didn’t do this in my example because it makes the code more confusing to read. But in some cases, changes like this may improve efficiency.</p>&#13;
<div class="exe">&#13;
<p class="exe-title" id="ch5exe21"><img class="inline" src="../images/pencil.jpg" alt="Image" width="25" height="25"/> <strong>Exercise 5.21</strong></p>&#13;
<p class="noindent">Eliminate as many temporary <span class="literal">p5.Vector</span> objects from the flocking example as possible. Also use <span class="literal">magSq()</span> where possible.</p>&#13;
</div>&#13;
<div class="box">&#13;
<p class="box-title" id="ch05end1"><span epub:type="pagebreak" id="page_285"/><img class="inline" src="../images/bird.jpg" alt="Image" width="30" height="33"/> <strong>The Ecosystem Project</strong></p>&#13;
<p class="noindent">Use steering forces to drive the behavior of the creatures in your ecosystem. Here are some possibilities:</p>&#13;
<ul class="bullet">&#13;
<li class="noindent">Create schools or flocks of creatures.</li>&#13;
<li class="noindent">Use a seeking behavior for creatures to search for food (for chasing moving prey, consider <em>pursuit</em>).</li>&#13;
<li class="noindent">Use a flow field for the ecosystem environment. For example, how does your system behave if the creatures live in a flowing river?</li>&#13;
<li class="noindent">Build a creature with countless steering behaviors (as many as you can reasonably add). Think about ways to vary the weights of the behaviors so you can dial them up and down, mixing and matching on the fly. How are creatures’ initial weights set? What rules drive how the weights change over time?</li>&#13;
<li class="noindent">Complex systems can be nested. Can you design a single creature out of a flock of boids? And can you then make a flock of those creatures?</li>&#13;
<li class="noindent">Complex systems can have memory (and be adaptive). Can the history of your ecosystem affect the behavior in its current state? (This could be the driving force behind how the creatures adjust their steering force weights.)</li>&#13;
</ul>&#13;
<div class="imagel"><img src="../images/pg325_Image_502.jpg" alt="Image" width="1041" height="642"/><span epub:type="pagebreak" id="page_286"/></div>&#13;
</div>&#13;
</div>
</div>
</body></html>