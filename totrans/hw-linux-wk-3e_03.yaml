- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Devices
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设备
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: This chapter is a basic tour of the kernel-provided device infrastructure in
    a functioning Linux system. Throughout the history of Linux, there have been many
    changes to how the kernel presents devices to the user. We’ll begin by looking
    at the traditional system of device files to see how the kernel provides device
    configuration information through sysfs. Our goal is to be able to extract information
    about the devices on a system in order to understand a few rudimentary operations.
    Later chapters will cover interacting with specific kinds of devices in greater
    detail.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是对在一个正常运行的 Linux 系统中内核提供的设备基础设施的基本介绍。Linux 的历史中，内核向用户展示设备的方式经历了许多变化。我们将从传统的设备文件系统入手，看看内核如何通过
    sysfs 提供设备配置信息。我们的目标是能够提取系统中设备的信息，以理解一些基本的操作。后续章节将更详细地介绍与特定类型设备的交互。
- en: It’s important to understand how the kernel interacts with user space when presented
    with new devices. The udev system enables user-space programs to automatically
    configure and use new devices. You’ll see the basic workings of how the kernel
    sends a message to a user-space process through udev, as well as what the process
    does with it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 理解内核在遇到新设备时如何与用户空间交互非常重要。udev 系统使得用户空间程序能够自动配置并使用新设备。你将看到内核如何通过 udev 向用户空间进程发送消息，以及该进程如何处理这些消息。
- en: 3.1 Device Files
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 设备文件
- en: It’s easy to manipulate most devices on a Unix system because the kernel presents
    many of the device I/O interfaces to user processes as files. These *device files*
    are sometimes called *device nodes*. Aside from programmers using regular file
    operations to work with devices, some devices are also accessible to standard
    programs like `cat`, so you don’t have to be a programmer to use a device. However,
    there is a limit to what you can do with a file interface, so not all devices
    or device capabilities are accessible with standard file I/O.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix 系统中操作大多数设备非常容易，因为内核将许多设备 I/O 接口作为文件呈现给用户进程。这些 *设备文件* 有时也叫 *设备节点*。除了程序员使用常规文件操作与设备交互外，一些设备也可以被标准程序如
    `cat` 访问，所以你不必是程序员就可以使用设备。然而，通过文件接口能做的操作是有限的，因此并不是所有设备或设备功能都可以通过标准的文件 I/O 进行访问。
- en: Linux uses the same design for device files as do other Unix flavors. Device
    files are in the */dev* directory, and running `ls /dev` reveals quite a few files
    in */dev*. So how do you work with devices?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 使用与其他 Unix 系统一样的设备文件设计。设备文件位于 */dev* 目录中，运行 `ls /dev` 会显示 */dev* 中的很多文件。那么，如何与设备交互呢？
- en: 'To get started, consider this command:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，可以考虑以下命令：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Like any other command with redirected output, this sends some stuff from the
    standard output to a file. However, the file is */dev/null*, a device, so the
    kernel bypasses its usual file operations and uses a device driver on data written
    to this device. In the case of */dev/null*, the kernel simply accepts the input
    data and throws it away.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他重定向输出的命令一样，这会将标准输出的一些内容发送到一个文件中。然而，该文件是 */dev/null*，一个设备，因此内核绕过其常规文件操作，并使用设备驱动程序处理写入该设备的数据。在
    */dev/null* 的情况下，内核简单地接受输入数据并将其丢弃。
- en: 'To identify a device and view its permissions, use `ls -l`. Here are some examples:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别一个设备并查看其权限，可以使用 `ls -l`。以下是一些示例：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note the first character of each line (the first character of the file’s mode).
    If this character is `b`, `c`, `p`, or `s`, the file is a device. These letters
    stand for *block*, *character*, *pipe*, and *socket*, respectively:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意每行的第一个字符（文件模式的第一个字符）。如果这个字符是 `b`、`c`、`p` 或 `s`，那么该文件是一个设备。它们分别代表 *块设备*、*字符设备*、*管道*
    和 *套接字*：
- en: '**Block device**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**块设备**'
- en: Programs access data from a block device in fixed chunks. The *sda1* in the
    preceding example is a *disk device*, a type of block device. Disks can be easily
    split up into blocks of data. Because a block device’s total size is fixed and
    easy to index, processes have quick random access to any block in the device with
    the help of the kernel.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序从块设备中按固定块读取数据。前面的例子中的 *sda1* 是一个 *磁盘设备*，是一种块设备。磁盘可以很容易地分割成数据块。由于块设备的总大小是固定的且易于索引，进程可以借助内核快速随机访问设备中的任何一个块。
- en: '**Character device**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符设备**'
- en: Character devices work with data streams. You can only read characters from
    or write characters to character devices, as previously demonstrated with */dev/null*.
    Character devices don’t have a size; when you read from or write to one, the kernel
    usually performs a read or write operation on it. Printers directly attached to
    your computer are represented by character devices. It’s important to note that
    during character device interaction, the kernel cannot back up and reexamine the
    data stream after it has passed data to a device or process.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符设备与数据流一起工作。你只能从字符设备读取字符，或者将字符写入字符设备，正如之前在*/dev/null*中演示的那样。字符设备没有大小；当你从字符设备读取或写入时，内核通常会对其执行读取或写入操作。直接连接到计算机的打印机由字符设备表示。需要注意的是，在字符设备交互过程中，内核无法在将数据传递给设备或进程之后备份并重新检查数据流。
- en: '**Pipe device**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**管道设备**'
- en: '*Named pipes* are like character devices, with another process at the other
    end of the I/O stream instead of a kernel driver.'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*命名管道*就像字符设备，其I/O流的另一端是另一个进程，而不是内核驱动程序。'
- en: '**Socket device**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**套接字设备**'
- en: '*Sockets* are special-purpose interfaces that are frequently used for interprocess
    communication. They’re often found outside of the */dev* directory. Socket files
    represent Unix domain sockets; you’ll learn more about those in Chapter 10.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*套接字*是特殊用途的接口，通常用于进程间通信。它们经常出现在*/dev*目录之外。套接字文件表示Unix域套接字；你将在第10章中了解更多关于它们的信息。'
- en: In file listings from `ls -l` of block and character devices, the numbers before
    the dates are the *major* and *minor* device numbers that the kernel uses to identify
    the device. Similar devices usually have the same major number, such as *sda3*
    and *sdb1* (both of which are hard disk partitions).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ls -l`命令列出的块设备和字符设备的文件列表中，日期前面的数字是内核用来标识设备的*主设备号*和*次设备号*。类似的设备通常具有相同的主设备号，例如*sda3*和*sdb1*（它们都是硬盘分区）。
- en: 3.2 The sysfs Device Path
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 sysfs设备路径
- en: The traditional Unix */dev* directory is a convenient way for user processes
    to reference and interface with devices supported by the kernel, but it’s also
    a very simplistic scheme. The name of the device in */dev* tells you a little
    about the device, but usually not enough to be helpful. Another problem is that
    the kernel assigns devices in the order in which they are found, so a device may
    have a different name between reboots.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的Unix */dev*目录是用户进程引用和与内核支持的设备接口的便捷方式，但它也是一个非常简化的方案。*/dev*中的设备名称能告诉你一些关于设备的信息，但通常不足以帮助你。另一个问题是，内核按照设备找到的顺序分配设备，因此设备在重新启动后可能会有不同的名称。
- en: 'To provide a uniform view for attached devices based on their actual hardware
    attributes, the Linux kernel offers the *sysfs* interface through a system of
    files and directories. The base path for devices is */sys/devices*. For example,
    the SATA hard disk at */dev/sda* might have the following path in sysfs:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 为了根据附加设备的实际硬件属性提供统一的视图，Linux内核通过一个文件和目录系统提供*sysfs*接口。设备的基本路径是*/sys/devices*。例如，*/dev/sda*上的SATA硬盘在sysfs中可能具有以下路径：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see, this path is quite long compared with the */dev/sda* filename,
    which is also a directory. But you can’t really compare the two paths because
    they have different purposes. The */dev* file enables user processes to use the
    device, whereas the */sys/devices* path is used to view information and manage
    the device. If you list the contents of a device path such as the preceding one,
    you’ll see something like the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这条路径与*/dev/sda*文件名相比相当长，*/dev/sda*也是一个目录。但你不能真正比较这两条路径，因为它们有不同的用途。*/dev*文件使得用户进程可以使用设备，而*/sys/devices*路径用于查看信息和管理设备。如果你列出一个设备路径的内容，比如前面的路径，你会看到类似以下的内容：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The files and subdirectories here are meant to be read primarily by programs
    rather than humans, but you can get an idea of what they contain and represent
    by looking at an example such as the /*dev* file. Running `cat dev` in this directory
    displays the numbers `8:0`, which happen to be the major and minor device numbers
    of */dev/sda*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的文件和子目录主要是供程序读取的，而非人类，但你可以通过查看例如/*dev*文件来大致了解它们包含和表示的内容。在这个目录中运行`cat dev`命令会显示数字`8:0`，它恰好是*/dev/sda*的主设备号和次设备号。
- en: There are a few shortcuts in the */sys* directory. For example, */sys/block*
    should contain all of the block devices available on a system. However, those
    are just symbolic links; you’d run `ls -l /sys/block` to reveal the true sysfs
    paths.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 */sys* 目录中有一些快捷方式。例如，*/sys/block* 应该包含系统上所有的块设备。然而，这些只是符号链接；你可以运行 `ls -l /sys/block`
    来显示真实的 sysfs 路径。
- en: 'It can be difficult to find the sysfs location of a device in */dev*. Use the
    `udevadm` command as follows to show the path and several other interesting attributes:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 */dev* 中找到设备的 sysfs 位置可能很困难。使用 `udevadm` 命令如下所示，展示路径及其他几个有趣的属性：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You’ll find more details about `udevadm` and the entire udev system in Section
    3.5.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 3.5 节中找到关于 `udevadm` 和整个 udev 系统的更多细节。
- en: 3.3 dd and Devices
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 dd 和设备
- en: The program `dd` is extremely useful when you are working with block and character
    devices. Its sole function is to read from an input file or stream and write to
    an output file or stream, possibly doing some encoding conversion on the way.
    One particularly useful `dd` feature with respect to block devices is that you
    can process a chunk of data in the middle of a file, ignoring what comes before
    or after.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 程序 `dd` 在处理块设备和字符设备时非常有用。它的唯一功能是从输入文件或流中读取数据并写入输出文件或流中，可能会在过程中进行一些编码转换。关于块设备，`dd`
    的一个特别有用的功能是，你可以处理文件中间的一块数据，而忽略前后部分。
- en: '`dd` copies data in blocks of a fixed size. Here’s how to use `dd` with a character
    device, utilizing a few common options:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`dd` 以固定大小的块复制数据。以下是如何在字符设备上使用 `dd`，并使用一些常见选项：'
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the `dd` option format differs from the option formats of most
    other Unix commands; it’s based on an old IBM Job Control Language (JCL) style.
    Rather than use the dash (`-`) character to signal an option, you name an option
    and set its value with the equal (`=`) sign. The preceding example copies a single
    1,024-byte block from */dev/zero* (a continuous stream of zero bytes) to *new_file*.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`dd` 选项的格式与大多数其他 Unix 命令的选项格式不同；它基于旧版 IBM 作业控制语言（JCL）样式。不是使用破折号（`-`）字符表示选项，而是通过名称指定选项，并用等号（`=`）设置其值。前面的示例将一个
    1,024 字节的块从 */dev/zero*（一个连续的零字节流）复制到 *new_file*。
- en: 'These are the important `dd` options:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是重要的 `dd` 选项：
- en: '**`if=``file`** The input file. The default is the standard input.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`if=``file`** 输入文件。默认是标准输入。'
- en: '**`of=``file`** The output file. The default is the standard output.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`of=``file`** 输出文件。默认是标准输出。'
- en: '**`bs=``size`** The block size. `dd` reads and writes this many bytes of data
    at a time. To abbreviate large chunks of data, you can use `b` and `k` to signify
    512 and 1,024 bytes, respectively. Therefore, the preceding example could read
    `bs=1k` instead of `bs=1024`.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`bs=``size`** 块大小。`dd` 每次读取和写入这么多字节的数据。为了简化大块数据，你可以使用 `b` 和 `k` 来分别表示 512
    字节和 1,024 字节。因此，前面的示例可以写作 `bs=1k`，而不是 `bs=1024`。'
- en: '**`ibs=``size`, `obs=``size`** The input and output block sizes. If you can
    use the same block size for both input and output, use the `bs` option; if not,
    use `ibs` and `obs` for input and output, respectively.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`ibs=``size`, `obs=``size`** 输入和输出块大小。如果输入和输出使用相同的块大小，使用 `bs` 选项；如果不同，分别使用
    `ibs` 和 `obs` 来指定输入和输出的块大小。'
- en: '**`count=``num`** The total number of blocks to copy. When working with a huge
    file—or with a device that supplies an endless stream of data, such as */dev/zero*—you
    want `dd` to stop at a fixed point; otherwise, you could waste a lot of disk space,
    CPU time, or both. Use `count` with the `skip`parameter to copy a small piece
    from a large file or device.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`count=``num`** 要复制的块总数。当处理一个巨大文件或一个提供无穷数据流的设备时（例如 */dev/zero*），你希望 `dd`
    在一个固定位置停止；否则，你可能会浪费大量磁盘空间、CPU 时间，或两者。使用 `count` 配合 `skip` 参数来从大文件或设备中复制一小块数据。'
- en: '**`skip=``num`** Skip past the first `num` blocks in the input file or stream,
    and do not copy them to the output.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**`skip=``num`** 跳过输入文件或流中的前 `num` 块，并且不将它们复制到输出。'
- en: 3.4 Device Name Summary
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 设备名称总结
- en: 'It can sometimes be difficult to find the name of a device (for example, when
    partitioning a disk). Here are a few ways to find out what it is:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，找到设备的名称可能会很困难（例如，在对磁盘进行分区时）。以下是几种方法来查找设备名称：
- en: Query udevd using `udevadm` (see Section 3.5).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `udevadm` 查询 udevd（参见 3.5 节）。
- en: Look for the device in the */sys* directory.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 */sys* 目录中查找设备。
- en: Guess the name from the output of the `journalctl -k` command (which prints
    the kernel messages) or the kernel system log (see Section 7.1). This output might
    contain a description of the devices on your system.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 `journalctl -k` 命令的输出（它打印内核消息）或内核系统日志（参见第 7.1 节）中猜测设备名称。这个输出可能包含系统上设备的描述。
- en: For a disk device that is already visible to the system, you can check the output
    of the `mount` command.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于系统中已可见的磁盘设备，你可以查看 `mount` 命令的输出。
- en: Run `cat /proc/devices` to see the block and character devices for which your
    system currently has drivers. Each line consists of a number and name. The number
    is the major number of the device as described in Section 3.1. If you can guess
    the device from the name, look in */dev* for the character or block devices with
    the corresponding major number, and you’ve found the device files.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 `cat /proc/devices` 查看系统当前为哪些块设备和字符设备提供驱动。每一行由一个数字和一个名称组成。这个数字是设备的主设备号，如第
    3.1 节所描述的。如果你能从名称猜到设备，可以在 */dev* 中查找具有相应主设备号的字符设备或块设备，这样你就找到了设备文件。
- en: Among these methods, only the first is reliable, but it does require udev. If
    you get into a situation where udev is not available, try the other methods but
    keep in mind that the kernel might not have a device file for your hardware.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些方法中，只有第一种方法是可靠的，但它确实需要 udev。如果你遇到 udev 不可用的情况，可以尝试其他方法，但请记住，内核可能没有为你的硬件提供设备文件。
- en: The following sections list the most common Linux devices and their naming conventions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节列出了最常见的 Linux 设备及其命名规范。
- en: '3.4.1 Hard Disks: /dev/sd*'
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 硬盘：/dev/sd*
- en: Most hard disks attached to current Linux systems correspond to device names
    with an *sd* prefix, such as */dev/sda*, */dev/sdb*, and so on. These devices
    represent entire disks; the kernel makes separate device files, such as */dev/sda1*
    and */dev/sda2*, for the partitions on a disk.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 目前大多数连接到 Linux 系统的硬盘对应的设备名称带有 *sd* 前缀，例如 */dev/sda*、*/dev/sdb* 等。这些设备代表整个硬盘；内核会为硬盘上的每个分区创建单独的设备文件，如
    */dev/sda1* 和 */dev/sda2*。
- en: The naming convention requires a little explanation. The *sd* portion of the
    name stands for *SCSI disk*. *Small Computer System Interface (SCSI)* was originally
    developed as a hardware and protocol standard for communication between devices
    such as disks and other peripherals. Although traditional SCSI hardware isn’t
    used in most modern machines, the SCSI protocol is everywhere due to its adaptability.
    For example, USB storage devices use it to communicate. The story on SATA (Serial
    ATA, a common storage bus on PCs) disks is a little more complicated, but the
    Linux kernel still uses SCSI commands at a certain point when talking to them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 命名规范需要一些解释。名称中的 *sd* 部分代表 *SCSI 硬盘*。*小型计算机系统接口（SCSI）* 最初被开发为硬件和协议标准，用于在硬盘和其他外设之间进行通信。尽管大多数现代机器不再使用传统的
    SCSI 硬件，但由于其适应性，SCSI 协议无处不在。例如，USB 存储设备就使用它进行通信。关于 SATA（串行 ATA，一种常见的 PC 存储总线）硬盘的情况稍微复杂一些，但
    Linux 内核在与其通信时仍会使用 SCSI 命令。
- en: 'To list the SCSI devices on your system, use a utility that walks the device
    paths provided by sysfs. One of the most succinct tools is `lsscsi`. Here’s what
    you can expect when you run it:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出系统上的 SCSI 设备，可以使用一个遍历 sysfs 提供的设备路径的工具。最简洁的工具之一是 `lsscsi`。运行它时你可以期待看到以下输出：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The first column 1 identifies the address of the device on the system, the second
    2 describes what kind of device it is, and the last 3 indicates where to find
    the device file. Everything else is vendor information.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列 1 标识了设备在系统中的地址，第二列 2 描述了它是什么类型的设备，最后一列 3 指示了在哪里可以找到设备文件。其他内容是厂商信息。
- en: Linux assigns devices to device files in the order in which its drivers encounter
    the devices. So, in the previous example, the kernel found the disk first and
    the flash drive second.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 按照驱动程序遇到设备的顺序将设备分配给设备文件。因此，在之前的例子中，内核首先找到了硬盘，然后是闪存驱动器。
- en: 'Unfortunately, this device assignment scheme has traditionally caused problems
    when you are reconfiguring hardware. Say, for example, that you have a system
    with three disks: */dev/sda*, */dev/sdb*, and */dev/sdc*. If */dev/sdb* explodes
    and you must remove it so that the machine can work again, the former */dev/sdc*
    moves to */dev/sdb*, and there’s no longer a */dev/sdc*. If you were referring
    to the device names directly in the *fstab* file (see Section 4.2.8), you’d have
    to make some changes to that file in order to get things (mostly) back to normal.
    To solve this problem, many Linux systems use the Universally Unique Identifier
    (UUID; see Section 4.2.4) and/or the Logical Volume Manager (LVM) stable disk
    device mapping.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种设备分配方案通常在重新配置硬件时会引发问题。举个例子，假设你有一个系统，其中有三个磁盘：*/dev/sda*，*/dev/sdb* 和 */dev/sdc*。如果
    */dev/sdb* 硬盘损坏并且你必须将其移除以使机器恢复正常，那么原本的 */dev/sdc* 会变成 */dev/sdb*，此时不再有 */dev/sdc*。如果你直接在
    *fstab* 文件中引用了设备名称（参见第4.2.8节），你需要对该文件进行一些修改才能让系统恢复（基本）正常。为了解决这个问题，许多Linux系统使用了通用唯一标识符（UUID；参见第4.2.4节）和/或逻辑卷管理器（LVM）稳定的磁盘设备映射。
- en: This discussion has barely scratched the surface of how to use disks and other
    storage devices on Linux systems. See Chapter 4 for more information about using
    disks. Later in this chapter, we’ll examine how SCSI support works in the Linux
    kernel.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这次讨论仅仅触及了如何在Linux系统上使用磁盘和其他存储设备的皮毛。有关如何使用磁盘的更多信息，请参阅第4章。在本章稍后，我们将研究SCSI支持如何在Linux内核中工作。
- en: '3.4.2 Virtual Disks: /dev/xvd*, /dev/vd*'
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 虚拟磁盘：/dev/xvd*，/dev/vd*
- en: Some disk devices are optimized for virtual machines such as AWS instances and
    VirtualBox. The Xen virtualization system uses the */dev/xvd* prefix, and */dev/vd*
    is a similar type.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一些磁盘设备针对虚拟机进行了优化，例如AWS实例和VirtualBox。Xen虚拟化系统使用 */dev/xvd* 前缀，*/dev/vd* 是类似的类型。
- en: '3.4.3 Non-Volatile Memory Devices: /dev/nvme*'
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.3 非易失性存储设备：/dev/nvme*
- en: Some systems now use the Non-Volatile Memory Express (NVMe) interface to talk
    to some kinds of solid-state storage. In Linux, these devices show up at */dev/nvme**.
    You can use the `nvme list` command to get a listing of these devices on your
    system.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一些系统现在使用非易失性存储器快车（NVMe）接口来访问某些类型的固态存储。在Linux中，这些设备显示为 */dev/nvme**。你可以使用 `nvme
    list` 命令来列出系统中的这些设备。
- en: '3.4.4 Device Mapper: /dev/dm-*, /dev/mapper/*'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.4 设备映射器：/dev/dm-*，/dev/mapper/*
- en: A level up from disks and other direct block storage on some systems is the
    LVM, which uses a kernel system called the device mapper. If you see block devices
    starting with */dev/dm-* and symbolic links in */dev/mapper*, your system probably
    uses it. You’ll learn all about this in Chapter 4.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些系统中，磁盘和其他直接块存储之上的一层是LVM，它使用一种名为设备映射器（device mapper）的内核系统。如果你看到以 */dev/dm-*
    开头的块设备和在 */dev/mapper* 中的符号链接，那么你的系统可能在使用它。你将在第4章中学习到更多关于这个的内容。
- en: '3.4.5 CD and DVD Drives: /dev/sr*'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.5 光盘和DVD驱动器：/dev/sr*
- en: Linux recognizes most optical storage drives as the SCSI devices */dev/sr0*,
    */dev/sr1*, and so on. However, if the drive uses an older interface, it might
    show up as a PATA device, as discussed next. The */dev/sr** devices are read only,
    and they are used only for reading from discs. For the write and rewrite capabilities
    of optical devices, you’ll use the “generic” SCSI devices such as */dev/sg0*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Linux将大多数光学存储驱动器识别为SCSI设备 */dev/sr0*，*/dev/sr1* 等。然而，如果驱动器使用的是较旧的接口，它可能会显示为PATA设备，下面会进一步讨论。*/dev/sr**
    设备是只读的，仅用于从光盘读取数据。对于光学设备的写入和重写功能，你将使用“通用”SCSI设备，如 */dev/sg0*。
- en: '3.4.6 PATA Hard Disks: /dev/hd*'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.6 PATA硬盘：/dev/hd*
- en: PATA (Parallel ATA) is an older type of storage bus. The Linux block devices
    */dev/hda*, */dev/hdb*, */dev/hdc*, and */dev/hdd* are common on older versions
    of the Linux kernel and with older hardware. These are fixed assignments based
    on the device pairs on interfaces 0 and 1\. At times, you might find a SATA drive
    recognized as one of these disks. This means that the SATA drive is running in
    a compatibility mode, which hinders performance. Check your BIOS settings to see
    if you can switch the SATA controller to its native mode.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: PATA（并行ATA）是较旧的存储总线类型。Linux块设备 */dev/hda*，*/dev/hdb*，*/dev/hdc* 和 */dev/hdd*
    在较旧版本的Linux内核和老旧硬件上较为常见。这些是基于接口0和1上的设备对的固定分配。有时，你可能会发现一个SATA硬盘被识别为其中之一。这意味着SATA硬盘正处于兼容模式，这会影响性能。检查你的BIOS设置，看看是否可以将SATA控制器切换到本地模式。
- en: '3.4.7 Terminals: /dev/tty*, /dev/pts/*, and /dev/tty'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.7 终端：/dev/tty*，/dev/pts/* 和 /dev/tty
- en: '*Terminals* are devices for moving characters between a user process and an
    I/O device, usually for text output to a terminal screen. The terminal device
    interface goes back a long way, to the days when terminals were typewriter-based
    devices and many were attached to a single machine.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*终端*是用于在用户进程和输入输出设备之间传输字符的设备，通常用于将文本输出到终端屏幕。终端设备接口可以追溯到很久以前，当时终端是基于打字机的设备，许多终端连接到一台机器。'
- en: Most terminals are *pseudoterminal* devices, emulated terminals that understand
    the I/O features of real terminals. Rather than talk to a real piece of hardware,
    the kernel presents the I/O interface to a piece of software, such as the shell
    terminal window that you probably type most of your commands into.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数终端是*伪终端*设备，即模拟终端，能够理解真实终端的输入输出功能。与其直接与硬件交互，内核将输入输出接口提供给一个软件，例如你通常输入大部分命令的shell终端窗口。
- en: Two common terminal devices are */dev/tty1* (the first virtual console) and
    */dev/pts/0* (the first pseudoterminal device). The */dev/pts* directory itself
    is a dedicated filesystem.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 两种常见的终端设备是*/dev/tty1*（第一个虚拟控制台）和*/dev/pts/0*（第一个伪终端设备）。*/dev/pts*目录本身是一个专用的文件系统。
- en: The */dev/tty* device is the controlling terminal of the current process. If
    a program is currently reading from and writing to a terminal, this device is
    a synonym for that terminal. A process does not need to be attached to a terminal.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*/dev/tty*设备是当前进程的控制终端。如果一个程序当前正在读取和写入终端，这个设备就等同于该终端。一个进程不需要附加到终端。'
- en: Display Modes and Virtual Consoles
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显示模式和虚拟控制台
- en: 'Linux has two primary display modes: *text mode* and a graphical mode (Chapter
    14 introduces the windowing systems that use this mode). Although Linux systems
    traditionally booted in text mode, most distributions now use kernel parameters
    and interim graphical display mechanisms (bootsplashes such as plymouth) to completely
    hide text mode as the system is booting. In such cases, the system switches over
    to full graphics mode near the end of the boot process.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Linux有两种主要的显示模式：*文本模式*和图形模式（第14章介绍了使用此模式的窗口系统）。尽管Linux系统传统上在文本模式下启动，但现在大多数发行版使用内核参数和临时的图形显示机制（如plymouth引导画面）在系统启动时完全隐藏文本模式。在这种情况下，系统会在启动过程接近结束时切换到完全的图形模式。
- en: Linux supports *virtual consoles* to multiplex the display. Each virtual console
    may run in graphics or text mode. When in text mode, you can switch between consoles
    with an alt–function key combination—for example, alt-F1 takes you to */dev/tty1*,
    alt-F2 goes to */dev/tty2*, and so on. Many of these virtual consoles may be occupied
    by a `getty` process running a login prompt, as described in Section 7.4.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Linux支持*虚拟控制台*来多路复用显示。每个虚拟控制台可以运行图形模式或文本模式。在文本模式下，你可以通过alt–功能键组合在控制台之间切换——例如，alt-F1进入*/dev/tty1*，alt-F2进入*/dev/tty2*，依此类推。许多虚拟控制台可能被`getty`进程占用，运行登录提示，如第7.4节所述。
- en: A virtual console used in graphics mode is slightly different. Rather than getting
    a virtual console assignment from the init configuration, a graphical environment
    takes over a free virtual console unless directed to use a specific one. For example,
    if you have `getty` processes running on *tty1* and *tty2*, a new graphical environment
    takes over *tty3*. In addition, once in graphics mode, you must normally press
    a ctrl-alt–function key combination to switch to another virtual console instead
    of the simpler alt–function key combination.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在图形模式下使用的虚拟控制台略有不同。图形环境不会从init配置中获取虚拟控制台分配，而是会接管一个空闲的虚拟控制台，除非指定使用特定的控制台。例如，如果你在*tty1*和*tty2*上运行`getty`进程，一个新的图形环境会接管*tty3*。此外，一旦进入图形模式，通常需要按ctrl-alt–功能键组合才能切换到另一个虚拟控制台，而不是简单的alt–功能键组合。
- en: The upshot of all of this is that if you want to see your text console after
    your system boots, press ctrl-alt-F1\. To return to the graphical environment,
    press alt-F2, alt-F3, and so on, until you get to the graphical environment.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些的结果是，如果你想在系统启动后看到你的文本控制台，按下ctrl-alt-F1。要返回图形环境，按下alt-F2、alt-F3，以此类推，直到进入图形环境。
- en: 'If you run into trouble switching consoles due to a malfunctioning input mechanism
    or some other circumstance, you can try to force the system to change consoles
    with the `chvt` command. For example, to switch to *tty1*, run the following as
    root:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于输入机制故障或其他原因在切换控制台时遇到问题，你可以尝试使用`chvt`命令强制系统切换控制台。例如，要切换到*tty1*，以root身份运行以下命令：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '3.4.8 Serial Ports: /dev/ttyS*, /dev/ttyUSB*, /dev/ttyACM*'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.8 串行端口：/dev/ttyS*、/dev/ttyUSB*、/dev/ttyACM*
- en: Older RS-232 type and similar serial ports are represented as true terminal
    devices. You can’t do much on the command line with serial port devices because
    there are too many settings to worry about, such as baud rate and flow control,
    but you can use the `screen` command to connect to a terminal by adding the device
    path as an argument. You may need read and write permission to the device; sometimes
    you can do this by adding yourself to a particular group such as `dialout`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 较旧的 RS-232 类型和类似的串行端口被表示为真正的终端设备。你不能在命令行上对串行端口设备做太多操作，因为有太多设置需要关注，例如波特率和流控，但你可以使用
    `screen` 命令通过添加设备路径作为参数来连接到终端。你可能需要设备的读写权限；有时，你可以通过将自己添加到特定的组（例如 `dialout`）来实现这一点。
- en: The port known as COM1 on Windows is */dev/ttyS0*; COM2 is */dev/ttyS1*; and
    so on. Plug-in USB serial adapters show up with *USB* and *ACM* with the names
    */dev/ttyUSB0*, */dev/ttyACM0*, */dev/ttyUSB1*, */dev/ttyACM1*, and so on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上被称为 COM1 的端口是 */dev/ttyS0*；COM2 是 */dev/ttyS1*；依此类推。插入的 USB 串行适配器会显示为
    *USB* 和 *ACM*，其名称分别为 */dev/ttyUSB0*、*/dev/ttyACM0*、*/dev/ttyUSB1*、*/dev/ttyACM1*，以此类推。
- en: Some of the most interesting applications involving serial ports are microcontroller-based
    boards that you can plug into your Linux system for development and testing. For
    example, you can access the console and read-eval-print loop of CircuitPython
    boards through a USB serial interface. All you need to do is plug one in, look
    for the device (it’s usually */dev/ttyACM0*), and connect to it with `screen`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及串行端口的一些最有趣的应用是基于微控制器的开发板，你可以将它们插入到 Linux 系统中进行开发和测试。例如，你可以通过 USB 串行接口访问 CircuitPython
    开发板的控制台和读-评估-打印循环。你只需插入一个设备，查找该设备（通常是 */dev/ttyACM0*），然后使用 `screen` 连接到它。
- en: '3.4.9 Parallel Ports: /dev/lp0 and /dev/lp1'
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.9 并行端口：/dev/lp0 和 /dev/lp1
- en: 'Representing an interface type that has largely been replaced by USB and networks,
    the unidirectional parallel port devices */dev/lp0* and */dev/lp1* correspond
    to LPT1: and LPT2: in Windows. You can send files (such as a file to be printed)
    directly to a parallel port with the `cat` command, but you might need to give
    the printer an extra form feed or reset afterward. A print server such as CUPS
    is much better at handling interaction with a printer.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '代表一种已经被 USB 和网络取代的接口类型，单向并行端口设备 */dev/lp0* 和 */dev/lp1* 在 Windows 中对应 LPT1:
    和 LPT2:。你可以直接使用 `cat` 命令将文件（例如要打印的文件）发送到并行端口，但你可能需要在之后给打印机一个额外的换页符或重置。像 CUPS 这样的打印服务器更擅长处理与打印机的交互。'
- en: The bidirectional parallel ports are */dev/parport0* and */dev/parport1*.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 双向并行端口是 */dev/parport0* 和 */dev/parport1*。
- en: '3.4.10 Audio Devices: /dev/snd/*, /dev/dsp, /dev/audio, and More'
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.10 音频设备：/dev/snd/*、/dev/dsp、/dev/audio 等
- en: Linux has two sets of audio devices. There are separate devices for the Advanced
    Linux Sound Architecture (ALSA) system interface and the older Open Sound System
    (OSS). The ALSA devices are in the */dev/snd* directory, but it’s difficult to
    work with them directly. Linux systems that use ALSA support OSS backward-compatible
    devices if the OSS kernel support is currently loaded.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 有两套音频设备。一套是为高级 Linux 声音架构（ALSA）系统接口提供的设备，另一套是为较旧的开放声音系统（OSS）提供的设备。ALSA
    设备位于 */dev/snd* 目录中，但直接操作它们是比较困难的。使用 ALSA 的 Linux 系统如果当前加载了 OSS 内核支持，则可以支持 OSS
    向后兼容的设备。
- en: Some rudimentary operations are possible with the OSS *dsp* and *audio* devices.
    For example, the computer plays any WAV file that you send to */dev/dsp*. However,
    the hardware may not do what you expect due to frequency mismatches. Furthermore,
    on most systems, the device is often busy as soon as you log in.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OSS 的 *dsp* 和 *audio* 设备可以进行一些基本操作。例如，计算机可以播放你发送到 */dev/dsp* 的任何 WAV 文件。然而，由于频率不匹配，硬件可能无法按照预期工作。此外，在大多数系统上，设备通常会在你登录时变得繁忙。
- en: 3.4.11 Device File Creation
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.11 设备文件创建
- en: On any reasonably recent Linux system, you do not create your own device files;
    they’re created by devtmpfs and udev (see Section 3.5). However, it is instructive
    to see how to do so, and on a rare occasion, you might need to create a named
    pipe or a socket file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何相对较新的 Linux 系统上，你不需要自己创建设备文件；它们是由 devtmpfs 和 udev 创建的（参见第 3.5 节）。然而，了解如何进行操作是很有帮助的，偶尔你可能需要创建命名管道或套接字文件。
- en: 'The `mknod` command creates one device. You must know the device name as well
    as its major and minor numbers. For example, creating */dev/sda1* is a matter
    of using the following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`mknod` 命令用于创建一个设备。你必须知道设备名称以及其主次设备号。例如，创建 */dev/sda1* 就是使用以下命令：'
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `b 8 1` specifies a block device with a major number 8 and a minor number
    1\. For character or named pipe devices, use `c` or `p` instead of `b` (omit the
    major and minor numbers for named pipes).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`b 8 1` 表示一个主设备号为 8、次设备号为 1 的块设备。对于字符设备或命名管道设备，请使用 `c` 或 `p` 替代 `b`（命名管道省略主设备号和次设备号）。'
- en: In older versions of Unix and Linux, maintaining the */dev* directory was a
    challenge. With every significant kernel upgrade or driver addition, the kernel
    could support more kinds of devices, meaning that there would be a new set of
    major and minor numbers to be assigned to device filenames. To tackle this maintenance
    challenge, each system had a `MAKEDEV` program in */dev* to create groups of devices.
    When you upgraded your system, you would try to find an update to `MAKEDEV` and
    then run it in order to create new devices.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期版本的 Unix 和 Linux 中，维护 */dev* 目录是一个挑战。每次进行重大内核升级或添加驱动程序时，内核可能支持更多种类的设备，这意味着需要为设备文件名分配新的主设备号和次设备号。为了解决这个维护难题，每个系统都会在
    */dev* 中有一个 `MAKEDEV` 程序来创建设备组。当你升级系统时，会尝试找到 `MAKEDEV` 的更新版本，然后运行它来创建新设备。
- en: This static system became ungainly, so a replacement was in order. The first
    attempt to fix it was devfs, a kernel-space implementation of */dev* that contained
    all of the devices that the current kernel supported. However, there were a number
    of limitations, which led to the development of udev and devtmpfs.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个静态系统变得笨重，因此需要进行替换。修复它的第一个尝试是 devfs，这是 */dev* 的内核空间实现，包含了当前内核支持的所有设备。然而，它存在一些限制，这导致了
    udev 和 devtmpfs 的开发。
- en: 3.5 udev
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 udev
- en: 'We’ve already talked about how unnecessary complexity in the kernel is dangerous
    because you can too easily introduce system instability. Device file management
    is an example: you can create device files in user space, so why would you do
    this in the kernel? The Linux kernel can send notifications to a user-space process
    called udevd upon detecting a new device on the system (for example, when someone
    attaches a USB flash drive). This udevd process could examine the new device’s
    characteristics, create a device file, and then perform any device initialization.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过内核中不必要的复杂性是危险的，因为它很容易引发系统不稳定。设备文件管理就是一个例子：你可以在用户空间中创建设备文件，那为什么还要在内核中做这件事呢？当系统检测到新设备（例如，当有人插入
    USB 闪存驱动器）时，Linux 内核可以向一个名为 udevd 的用户空间进程发送通知。这个 udevd 进程可以检查新设备的特性，创建设备文件，并执行任何设备初始化。
- en: That was the theory. Unfortunately, there is a problem with this approach—device
    files are necessary early in the boot procedure, so udevd must also start early.
    But to create device files, udevd cannot depend on any devices that it is supposed
    to create, and it needs to perform its initial startup very quickly so that the
    rest of the system doesn’t get held up waiting for udevd to start.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是理论上的方法。不幸的是，这种方法有一个问题——设备文件在启动过程中非常必要，因此 udevd 也必须尽早启动。但是，为了创建设备文件，udevd
    不能依赖于它需要创建的任何设备，并且它需要非常快速地完成初始化启动，以便系统的其他部分不会因为等待 udevd 启动而被阻塞。
- en: 3.5.1 devtmpfs
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.1 devtmpfs
- en: The devtmpfs filesystem was developed in response to the problem of device availability
    during boot (see Section 4.2 for more details on filesystems). This filesystem
    is similar to the older devfs support, but simplified. The kernel creates device
    files as necessary, but it also notifies udevd that a new device is available.
    Upon receiving this signal, udevd does not create the device files, but it does
    perform device initialization along with setting permissions and notifying other
    processes that new devices are available. Additionally, it creates a number of
    symbolic links in */dev* to further identify devices. You can find examples in
    the directory */dev/disk/by-id*, where each attached disk has one or more entries.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: devtmpfs 文件系统是在启动过程中为了解决设备可用性问题而开发的（有关文件系统的更多细节，请参见第 4.2 节）。该文件系统类似于较旧的 devfs
    支持，但进行了简化。内核根据需要创建设备文件，但它还会通知 udevd 有新设备可用。接收到这个信号后，udevd 不会创建设备文件，但会执行设备初始化，并设置权限，同时通知其他进程新设备已经可用。此外，它还会在
    */dev* 目录下创建一些符号链接，以进一步标识设备。你可以在目录 */dev/disk/by-id* 中找到示例，其中每个附加的磁盘都有一个或多个条目。
- en: 'For example, consider the links for a typical disk (attached at */dev/sda*)
    and its partitions in */dev/disk/by-id*:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个典型磁盘（附加在 */dev/sda*）及其分区在 */dev/disk/by-id* 中的链接：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The udevd process names the links by interface type, and then by manufacturer
    and model information, serial number, and partition (if applicable).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: udevd 进程按接口类型命名链接，然后是制造商和型号信息、序列号，以及分区（如果适用）。
- en: But how does udevd know which symbolic links to create, and how does it create
    them? The next section describes how udevd does its work. However, you don’t need
    to know any of this or any of the other remaining material in this chapter to
    continue on with the book. In fact, if this is your first time looking at Linux
    devices, you’re highly encouraged to skip to the next chapter to start learning
    about how to use disks.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 但 udevd 如何知道创建哪些符号链接，并且它是如何创建这些符号链接的呢？下一节将描述 udevd 如何完成其工作。然而，你不需要了解这些内容或本章中剩余的其他内容来继续阅读本书。实际上，如果这是你第一次接触
    Linux 设备，强烈建议你跳到下一章开始学习如何使用磁盘。
- en: 3.5.2 udevd Operation and Configuration
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.2 udevd 操作和配置
- en: 'The udevd daemon operates as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: udevd 守护进程的操作如下：
- en: The kernel sends udevd a notification event, called a *uevent*, through an internal
    network link.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内核通过一个内部网络链接发送 udevd 一个通知事件，称为 *uevent*。
- en: udevd loads all of the attributes in the uevent.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: udevd 加载 uevent 中的所有属性。
- en: udevd parses its rules, filters and updates the uevent based on those rules,
    and takes actions or sets more attributes accordingly.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: udevd 解析其规则，基于这些规则过滤并更新 uevent，并根据需要执行操作或设置更多属性。
- en: 'An incoming uevent that udevd receives from the kernel might look like this
    (you’ll learn how to get this output with the `udevadm monitor --property` command
    in Section 3.5.4):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核接收到的 incoming uevent 可能看起来像这样（你将在 3.5.4 节学习如何通过 `udevadm monitor --property`
    命令获得这个输出）：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This particular event is a change to a device. After receiving the uevent, udevd
    knows the name of the device, the sysfs device path, and a number of other attributes
    associated with the properties; it is now ready to start processing rules.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定事件是设备的变化。在接收到 uevent 后，udevd 知道设备的名称、sysfs 设备路径以及与属性相关的其他多个属性；它现在准备开始处理规则。
- en: 'The rules files are in the */lib/udev/rules.d* and */etc/udev/rules.d* directories.
    The rules in */lib* are the defaults, and the rules in */etc* are overrides. A
    full explanation of the rules would be tedious, and you can learn much more from
    the udev(7) manual page, but here is some basic information about how udevd reads
    them:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 规则文件位于 * /lib/udev/rules.d* 和 * /etc/udev/rules.d* 目录中。* /lib* 中的规则是默认规则，* /etc*
    中的规则是覆盖规则。对于规则的详细解释会很繁琐，你可以从 udev(7) 手册页中了解更多，但这里是关于 udevd 如何读取规则的一些基本信息：
- en: udevd reads rules from start to finish of a rules file.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: udevd 从规则文件的开始到结束读取规则。
- en: After reading a rule and possibly executing its action, udevd continues reading
    the current rules file for more applicable rules.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在读取规则并可能执行其操作后，udevd 继续读取当前规则文件以寻找更多适用的规则。
- en: There are directives (such as `GOTO`) to skip over parts of rules files if necessary.
    These are usually placed at the top of a rules file to skip over the entire file
    if it’s irrelevant to a particular device that udevd is configuring.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一些指令（如 `GOTO`）如果需要，可以跳过规则文件的某些部分。这些通常放在规则文件的顶部，用来跳过整个文件，如果该文件与 udevd 正在配置的特定设备无关。
- en: 'Let’s look at the symbolic links from the */dev/sda* example in Section 3.5.1.
    Those links were defined by rules in */lib/udev/rules.d/60-persistent-storage.rules*.
    Inside, you’ll see the following lines:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下 3.5.1 节中 * /dev/sda* 示例的符号链接。这些链接是由 * /lib/udev/rules.d/60-persistent-storage.rules*
    中的规则定义的。里面，你会看到以下几行：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'These rules match ATA disks and optical media presented through the kernel’s
    SCSI subsystem (see Section 3.6). You can see that there are a few rules to catch
    different ways the devices may be represented, but the idea is that udevd will
    try to match a device starting with *sd* or *sr* but without a number (with the
    `KERNEL=="sd*[!0-9]|sr*"` expression), as well as a subsystem (`SUBSYSTEMS=="scsi"`),
    and, finally, some other attributes, depending on the type of device. If all of
    those conditional expressions are true in either of the rules, udevd moves to
    the next and final expression:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规则匹配通过内核的 SCSI 子系统（参见 3.6 节）呈现的 ATA 磁盘和光盘介质。你可以看到有一些规则捕获设备可能以不同方式表示的情况，但基本思想是
    udevd 会尝试匹配以 *sd* 或 *sr* 开头但没有数字（使用 `KERNEL=="sd*[!0-9]|sr*"` 表达式）的设备，以及一个子系统（`SUBSYSTEMS=="scsi"`），最后是一些其他属性，取决于设备的类型。如果这些条件表达式在任何规则中都为真，udevd
    会进入下一个和最终的表达式：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is not a conditional. Instead, it’s a directive to import variables from
    the */lib/udev/ata_id* command. If you have such a disk, try it yourself on the
    command line. It will look like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个条件，而是一个指令，用来从*/lib/udev/ata_id*命令导入变量。如果你有这样的磁盘，可以在命令行上试一试。它会像这样显示：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The import now sets the environment so that all of the variable names in this
    output are set to the values shown. For example, any rule that follows will now
    recognize `ENV{ID_TYPE}` as `disk`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 导入操作现在设置了环境，使得输出中所有变量名称的值都被设置为所示的值。例如，接下来的任何规则都会将`ENV{ID_TYPE}`识别为`disk`。
- en: 'In the two rules we’ve seen so far, of particular note is `ID_SERIAL`. In each
    rule, this conditional appears second:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看到的两个规则中，特别需要注意的是`ID_SERIAL`。在每个规则中，这个条件出现在第二位：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This expression evaluates to true if `ID_SERIAL` is not set. Therefore, if `ID_SERIAL`
    *is* set, the conditional is false, the entire current rule does not apply, and
    udevd moves to the next rule.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ID_SERIAL`未设置，则此表达式会评估为true。因此，如果`ID_SERIAL` *已* 设置，则条件为false，当前规则不适用，udevd会移动到下一个规则。
- en: Why is this here? The purpose of these two rules is to run `ata_id` to find
    the serial number of the disk device and then add these attributes to the current
    working copy of the uevent. You’ll find this general pattern in many udev rules.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这里会有这个？这两个规则的目的是运行`ata_id`来查找磁盘设备的序列号，然后将这些属性添加到当前工作中的uevent副本中。你会在许多udev规则中发现这种常见模式。
- en: 'With `ENV{ID_SERIAL}` set, udevd can now evaluate this rule later on in the
    rules file, which looks for any attached SCSI disks:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 设置了`ENV{ID_SERIAL}`后，udevd现在可以在规则文件中的后续规则中评估这个规则，这个规则会查找任何附加的SCSI磁盘：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can see that this rule requires `ENV{ID_SERIAL}` to be set, and it has
    one directive:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这个规则要求设置`ENV{ID_SERIAL}`，并且它有一个指令：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This directive tells udevd to add a symbolic link for the incoming device. So
    now you know where the device symbolic links came from!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令告诉udevd为传入的设备添加符号链接。所以现在你知道设备符号链接的来源了！
- en: You may be wondering how to tell a conditional expression from a directive.
    Conditionals are denoted by two equal signs (`==`) or a bang equal (`!=`), and
    directives by a single equal sign (`=`), a plus equal (`+=`), or a colon equal
    (`:=`).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道如何区分条件表达式和指令。条件表达式由两个等号（`==`）或一个叹号等号（`!=`）表示，指令由一个等号（`=`）、加等号（`+=`）或冒号等号（`:=`）表示。
- en: 3.5.3 udevadm
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.3 udevadm
- en: The `udevadm` program is an administration tool for udevd. You can reload udevd
    rules and trigger events, but perhaps the most powerful features of `udevadm`
    are the ability to search for and explore system devices and the ability to monitor
    uevents as udevd receives them from the kernel. The command syntax can be somewhat
    complicated, though. There are long and short forms for most options; we’ll use
    the long ones here.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`udevadm`程序是udevd的管理工具。你可以重新加载udevd规则并触发事件，但`udevadm`最强大的功能可能是能够搜索和探索系统设备，以及能够监控uevent，查看udevd如何从内核接收它们。不过，命令语法可能有点复杂。大多数选项有长格式和短格式；我们这里使用的是长格式。'
- en: 'Let’s start by examining a system device. Returning to the example in Section
    3.5.2, in order to look at all of the udev attributes used and generated in conjunction
    with the rules for a device such as */dev/sda*, run the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查一个系统设备开始。回到第3.5.2节中的示例，为了查看与设备如*/dev/sda*相关联的规则使用和生成的所有udev属性，请运行以下命令：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The prefix in each line indicates an attribute or other characteristic of the
    device. In this case, the `P:` at the top is the sysfs device path, the `N:` is
    the device node (that is, the name given to the */dev* file), `S`: indicates a
    symbolic link to the device node that udevd placed in */dev* according to its
    rules, and `E:` is additional device information extracted in the udevd rules.
    (There was far more output in this example than was necessary to show here; try
    the command for yourself to get a feel for what it does.)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每行前缀表示设备的某个属性或特征。在这个例子中，顶部的`P:`是sysfs设备路径，`N:`是设备节点（即分配给*/dev*文件的名称），`S:`表示udevd根据其规则放置在*/dev*中的设备节点符号链接，`E:`是udevd规则中提取的其他设备信息。（这个例子中的输出比实际需要展示的更多；你可以自己尝试一下这个命令，感受一下它的作用。）
- en: 3.5.4 Device Monitoring
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.4 设备监控
- en: 'To monitor uevents with `udevadm`, use the `monitor` command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`udevadm`监控uevent，可以使用`monitor`命令：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Output (for example, when you insert a flash media device) looks like this
    abbreviated sample:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 输出（例如，当你插入闪存设备时）如下所示的简短示例：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are two copies of each message in this output because the default behavior
    is to print both the incoming message from the kernel (marked with `KERNEL`) and
    the processing messages from udevd. To see only kernel events, add the `--kernel`
    option, and to see only udevd processing events, use `--udev`. To see the whole
    incoming uevent, including the attributes as shown in Section 3.5.2, use the `--property`
    option. The `--udev` and `--property` options together show the uevent after processing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also filter events by subsystem. For example, to see only kernel messages
    pertaining to changes in the SCSI subsystem, use this command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: For more on `udevadm`, see the udevadm(8) manual page.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: There’s much more to udev. For example, there’s a daemon called udisksd that
    listens for events in order to automatically attach disks and to notify other
    processes that new disks are available.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '3.6 In-Depth: SCSI and the Linux Kernel'
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at the SCSI support in the Linux kernel as
    a way to explore part of the Linux kernel architecture. You don’t need to know
    any of this information in order to use disks, so if you’re in a hurry to use
    one, move on to Chapter 4. In addition, the material here is more advanced and
    theoretical in nature that what you’ve seen so far, so if you want to stay hands-on,
    you should definitely skip to the next chapter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Let’s begin with a little background. The traditional SCSI hardware setup is
    a host adapter linked with a chain of devices over an SCSI bus, as shown in [Figure
    3-1](#figure3-1). The host adapter is attached to a computer. The host adapter
    and devices each have an SCSI ID, and there can be 8 or 16 IDs per bus, depending
    on the SCSI version. Some administrators might use the term *SCSI target* to refer
    to a device and its SCSI ID because one end of a session in the SCSI protocol
    is called the target.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![f03001](image_fi/500402c03/f03001.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-1: SCSI bus with host adapter and devices'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Any device can communicate with another through the SCSI command set in a peer-to-peer
    relationship. The computer is not directly attached to the device chain, so it
    must go through the host adapter in order to communicate with disks and other
    devices. Typically, the computer sends SCSI commands to the host adapter to relay
    to the devices, and the devices relay responses back through the host adapter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Newer versions of SCSI, such as Serial Attached SCSI (SAS),offer exceptional
    performance, but you probably won’t find true SCSI devices in most machines. You’ll
    more often encounter USB storage devices that use SCSI commands. In addition,
    devices supporting ATAPI (such as CD/DVD-ROM drives) use a version of the SCSI
    command set.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: SATA disks also appear on your system as SCSI devices, but they are slightly
    different because most of them communicate through a translation layer in the
    libata library (see Section 3.6.2). Some SATA controllers (especially high-performance
    RAID controllers) perform this translation in hardware.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'How does this all fit together? Consider the devices shown on the following
    system:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The numbers in square brackets are, from left to right, the SCSI host adapter
    number, the SCSI bus number, the device SCSI ID, and the LUN (logical unit number,
    a further subdivision of a device). In this example, there are four attached adapters
    (scsi0, scsi1, scsi2, and scsi3), each of which has a single bus (all with bus
    number 0), and just one device on each bus (all with target 0). The USB card reader
    at 2:0:0 has four logical units, though—one for each kind of flash card that can
    be inserted. The kernel has assigned a different device file to each logical unit.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Despite not being SCSI devices, NVMe devices can sometimes show up in the `lsscsi`
    output with an `N` as the adapter number.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-2](#figure3-2) illustrates the driver and interface hierarchy inside
    the kernel for this particular system configuration, from the individual device
    drivers up to the block drivers. It does not include the SCSI generic (*sg*) drivers.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: 'Although this is a large structure and may look overwhelming at first, the
    data flow in the figure is very linear. Let’s begin dissecting it by looking at
    the SCSI subsystem and its three layers of drivers:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The top layer handles operations for a class of device. For example, the *sd*
    (SCSI disk) driver is at this layer; it knows how to translate requests from the
    kernel block device interface into disk-specific commands in the SCSI protocol,
    and vice versa.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The middle layer moderates and routes the SCSI messages between the top and
    bottom layers, and keeps track of all of the SCSI buses and devices attached to
    the system.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The bottom layer handles hardware-specific actions. The drivers here send outgoing
    SCSI protocol messages to specific host adapters or hardware, and they extract
    incoming messages from the hardware. The reason for this separation from the top
    layer is that although SCSI messages are uniform for a device class (such as the
    disk class), different kinds of host adapters have varying procedures for sending
    the same messages.![f03002](image_fi/500402c03/f03002.png)
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 3-2: Linux SCSI subsystem schematic'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The top and bottom layers contain many different drivers, but it’s important
    to remember that, for any given device file on your system, the kernel (nearly
    always) uses one top-layer driver and one lower-layer driver. For the disk at
    */dev/sda* in our example, the kernel uses the *sd* top-layer driver and the ATA
    bridge lower-layer driver.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: There are times when you might use more than one upper-layer driver for one
    hardware device (see Section 3.6.3). For true hardware SCSI devices, such as a
    disk attached to an SCSI host adapter or a hardware RAID controller, the lower-layer
    drivers talk directly to the hardware below. However, for most hardware that you
    find attached to the SCSI subsystem, it’s a different story.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你可能会为一个硬件设备使用多个上层驱动程序（参见第3.6.3节）。对于真正的硬件SCSI设备，如连接到SCSI主机适配器或硬件RAID控制器的磁盘，底层驱动程序直接与硬件进行通信。然而，对于大多数附加到SCSI子系统的硬件情况则不同。
- en: 3.6.1 USB Storage and SCSI
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.1 USB存储与SCSI
- en: In order for the SCSI subsystem to talk to common USB storage hardware, as shown
    in [Figure 3-2](#figure3-2), the kernel needs more than just a lower-layer SCSI
    driver. A USB flash drive represented by */dev/sdf* understands SCSI commands,
    but to actually communicate with the drive, the kernel needs to know how to talk
    through the USB system.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使SCSI子系统能够与常见的USB存储硬件进行通信，如[图3-2](#figure3-2)所示，内核需要的不仅仅是一个底层SCSI驱动程序。一个由*/dev/sdf*表示的USB闪存驱动器能够理解SCSI命令，但为了实际与驱动器通信，内核需要知道如何通过USB系统进行通信。
- en: In the abstract, USB is quite similar to SCSI—it has device classes, buses,
    and host controllers. Therefore, it should be no surprise that the Linux kernel
    includes a three-layer USB subsystem that closely resembles the SCSI subsystem,
    with device-class drivers at the top, a bus management core in the middle, and
    host controller drivers at the bottom. Much as the SCSI subsystem passes SCSI
    commands between its components, the USB subsystem passes USB messages between
    its components. There’s even an `lsusb` command that is similar to `lsscsi`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 从抽象层次来看，USB与SCSI非常相似——它具有设备类别、总线和主机控制器。因此，Linux内核包括一个三层USB子系统，这一点也就不足为奇，它与SCSI子系统非常相似，设备类别驱动程序位于顶部，总线管理核心位于中间，主机控制器驱动程序位于底部。就像SCSI子系统在其各个组件之间传递SCSI命令一样，USB子系统在其各个组件之间传递USB消息。甚至还有一个`lsusb`命令，它与`lsscsi`类似。
- en: 'The part we’re really interested in here is the USB storage driver at the top.
    This driver acts as a translator. On one end, the driver speaks SCSI, and on the
    other, it speaks USB. Because the storage hardware includes SCSI commands inside
    its USB messages, the driver has a relatively easy job: it mostly repackages data.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里真正感兴趣的部分是最上层的USB存储驱动程序。这个驱动程序充当了翻译器。一端，它使用SCSI协议，另一端，它使用USB协议。由于存储硬件在其USB消息中包含SCSI命令，因此该驱动程序的工作相对简单：它主要负责重新打包数据。
- en: With both the SCSI and USB subsystems in place, you have almost everything you
    need to talk to the flash drive. The final missing link is the lower-layer driver
    in the SCSI subsystem because the USB storage driver is a part of the USB subsystem,
    not the SCSI subsystem. (For organizational reasons, the two subsystems should
    not share a driver.) To get the subsystems to talk to one another, a simple, lower-layer
    SCSI bridge driver connects to the USB subsystem’s storage driver.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在SCSI和USB子系统都就绪的情况下，你几乎拥有与闪存驱动器通信所需的所有东西。最终缺失的环节是SCSI子系统中的底层驱动程序，因为USB存储驱动程序属于USB子系统，而非SCSI子系统。（出于组织原因，这两个子系统不应共享驱动程序。）为了使这两个子系统能够互相通信，一个简单的底层SCSI桥接驱动程序连接到USB子系统的存储驱动程序。
- en: 3.6.2 SCSI and ATA
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.6.2 SCSI与ATA
- en: The SATA hard disk and optical drive shown in [Figure 3-2](#figure3-2) both
    use the same SATA interface. To connect the SATA-specific drivers of the kernel
    to the SCSI subsystem, the kernel employs a bridge driver, as with the USB drives,
    but with a different mechanism and additional complications. The optical drive
    speaks ATAPI, a version of SCSI commands encoded in the ATA protocol. However,
    the hard disk does not use ATAPI and does not encode any SCSI commands!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-2](#figure3-2)中所示的SATA硬盘和光驱都使用相同的SATA接口。为了将内核的SATA特定驱动程序与SCSI子系统连接，内核使用了桥接驱动程序，和USB驱动器一样，但采用了不同的机制，并增加了一些复杂性。光驱使用ATAPI，它是ATA协议中的一种SCSI命令编码版本。然而，硬盘不使用ATAPI，也不对SCSI命令进行任何编码！'
- en: The Linux kernel uses part of a library called libata to reconcile SATA (and
    ATA) drives with the SCSI subsystem. For the ATAPI-speaking optical drives, this
    is a relatively simple task of packaging and extracting SCSI commands into and
    from the ATA protocol. But for the hard disk, the task is much more complicated
    because the library must do a full command translation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核使用名为libata的库的一部分，将SATA（以及ATA）驱动与SCSI子系统对接。对于使用ATAPI协议的光驱，这是一个相对简单的任务——将SCSI命令打包到ATA协议中，或从ATA协议中提取SCSI命令。但对于硬盘来说，这个任务要复杂得多，因为该库必须进行完整的命令翻译。
- en: The job of the optical drive is similar to typing an English book into a computer.
    You don’t need to understand what the book is about in order to do this job, nor
    do you even need to understand English. But the task for the hard disk is more
    like reading a German book and typing it into the computer as an English translation.
    In this case, you need to understand both languages as well as the book’s content.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Despite this difficulty, libata performs this task and makes it possible to
    attach ATA/SATA interfaces and devices to the SCSI subsystem. (There are typically
    more drivers involved than just the one SATA host driver shown in [Figure 3-2](#figure3-2),
    but they’re not shown for the sake of simplicity.)
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 3.6.3 Generic SCSI Devices
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a user-space process communicates with the SCSI subsystem, it normally
    does so through the block device layer and/or another other kernel service that
    sits on top of an SCSI device class driver (like *sd* or *sr*). In other words,
    most user processes never need to know anything about SCSI devices or their commands.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: 'However, user processes can bypass device class drivers and give SCSI protocol
    commands directly to devices through their *generic devices*. For example, consider
    the system described in Section 3.6, but this time, take a look at what happens
    when you add the `-g` option to `lsscsi` in order to show the generic devices:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In addition to the usual block device file, each entry lists an SCSI generic
    device file in the last column 1. For example, the generic device for the optical
    drive at */dev/sr0* is */dev/sg1*.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Why would you want to use a generic device? The answer has to do with the complexity
    of code in the kernel. As tasks get more complicated, it’s better to leave them
    out of the kernel. Consider CD/DVD writing and reading. Reading an optical disc
    is a fairly simple operation, and there’s a specialized kernel driver for it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: However, writing an optical disc is significantly more difficult than reading,
    and no critical system services depend on the action of writing. There’s no reason
    to threaten kernel space with this activity. Therefore, to *write* to an optical
    disc in Linux, you run a user-space program that talks to a generic SCSI device,
    such as */dev/sg1.* This program might be a little more inefficient than a kernel
    driver, but it’s far easier to build and maintain.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 3.6.4 Multiple Access Methods for a Single Device
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The two points of access (*sr* and *sg*) for an optical drive from user space
    are illustrated for the Linux SCSI subsystem in [Figure 3-3](#figure3-3) (any
    drivers below the SCSI lower layer have been omitted). Process A reads from the
    drive using the *sr* driver, and process B writes to the drive with the *sg* driver.
    However, processes like these would not normally run simultaneously to access
    the same device.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '![f03003](image_fi/500402c03/f03003.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-3: Optical device driver schematic'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 3-3](#figure3-3), process A reads from the block device. But do user
    processes really read data this way? Normally, the answer is no, not directly.
    There are more layers on top of the block devices and even more points of access
    for hard disks, as you’ll learn in the next chapter.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 3-3](#figure3-3)中，进程A从块设备中读取数据。但是用户进程真的以这种方式读取数据吗？通常，答案是否定的，数据并非直接这样读取。块设备之上有更多层次，硬盘的访问点也更多，正如你将在下一章中学到的那样。
