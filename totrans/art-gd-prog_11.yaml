- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Measuring and Simulating Time
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sketch 86: Displaying a Clock'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Time in a computer program can mean many things. There is execution time, which
    is the number of CPU cycles used by a program to a particular point. There is
    process time, or the amount of time that a program has been active. There is real
    time, which is the time on your watch. We can also call that clock time. This
    sketch will acquire the clock time from the computer system and display it as
    the hands of a traditional clock.
  prefs: []
  type: TYPE_NORMAL
- en: 'Getting the time of day from Processing is easy. These are the basic functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hour()`: Returns the current hour in the day using a 24-hour clock.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`minute()`: Returns the number of minutes past the hour.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`second()`: Returns the number of seconds into the current minute.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The clock will be a circle, and there will be three linear indicators (hands):
    a second hand, a minute hand, and an hour hand. Since there are 60 seconds in
    a minute, the second hand will rotate about its center point by 360/60, or 6 degrees
    each second. The same is true of the minute hand; since there are 60 seconds per
    minute and 60 minutes in an hour, it rotates 6 degrees per minute. The origin
    for drawing the second hand is the clock’s center, but the other endpoint is not
    known, only the angle. If the length of the second hand is *r*, then the second
    point can be determined with trigonometry, as seen in [Figure 86-1](#figure86-1).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f086001](Images/f086001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 86-1: Determining the position of a clock hand'
  prefs: []
  type: TYPE_NORMAL
- en: 'The angle as defined by Processing is not the same as that for a clock. On
    a clock, vertical represents 0, whereas in Processing that is −90 degrees. Drawing
    the second hand with (`cx`, `cy`) as the center point and with a length of `r`
    would be done as follows, where the variable `s` is the number of seconds 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The same scheme works for the minute hand, which is shorter. The hour hand
    should be shorter still, and the `hour()` value is divided by 2 if it exceeds
    12\. Also, there are only 12 hours in the 360-degree cycle, not 60, so each hour
    amounts to 30 degrees. The hour hand moves continuously around the face and does
    not jump when the hour changes, so each minute that passes should move the hour
    hand a little bit; 30 degrees (1 hour) is 60 minutes, so each minute moves the
    hour hand by 0.5 degrees 2. This is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Sketch 87: Time Differences—Measuring Reaction Time'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Measuring the time between two events is the subject of this sketch: in particular,
    the time between a prompt by the computer and a response by the user, the reaction
    time. A typical (average) reaction time for a human is about 0.215 seconds. That
    is, between the time that a light goes on and the time that someone can press
    a button in response, an average of 215 milliseconds will pass.'
  prefs: []
  type: TYPE_NORMAL
- en: This sketch measures reaction time by having the user click the mouse as quickly
    as they can when the background changes from grey to green. The background then
    changes back to grey, and the cycle repeats five times. The program measures the
    time between the screen turning green and the mouse click using the `millis()`
    function, and it averages the five trials to get a more precise measurement.
  prefs: []
  type: TYPE_NORMAL
- en: We use `millis()` because the function used in the previous sketch to move the
    second hand, `second()`, only returns whole seconds. `millis()` returns the number
    of milliseconds (1/1,000 seconds) since the sketch started executing. On the face
    of it, that value does not seem to have much meaning, but it does mean that the
    time difference between two events can be measured pretty accurately. Simply call
    `millis()` 1 when the first event happens, save the value, call it again when
    the second event occurs 2, and subtract the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `millis()` function can be used for other purposes, not the least of which
    is to determine how long it takes for a particular loop or function to execute.
    This sort of measurement is important when a program takes too long and the programmer
    needs to find ways to speed it up. Measuring one call to a function would not
    likely work, because most functions execute too quickly to measure, even slow
    functions. Instead, we put a function to be tested within a loop and execute it
    many times. We divide the time required to execute the loop by the number of iterations
    to determine the time needed for a single execution. Here is how the function
    `get(12,100)` could be timed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The times obtained vary, so taking an average over many trials should give a
    more accurate result. Execution times may change depending on what other programs
    are executing at the same time or how many virtual memory page faults occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 88: M/M/1 Queue—Time in Simulations'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A single-server queuing system, or M/M/1 queuing system, is like a bank teller.
    Customers arrive at random times to the teller for service. The service requires
    some random amount of time, and then the customer departs. If the teller is busy
    with a customer when another one arrives, the new arrival waits in a queue or
    waiting line. When a departure occurs, the next customer in line is served; if
    there is no one in the queue, the teller (the server) becomes idle. This system
    resembles many that we see in real life: grocery checkouts, gas stations, waiting
    for a bus, even air traffic and ships arriving in a port.'
  prefs: []
  type: TYPE_NORMAL
- en: This sketch simulates one server and one queue, but it can be adapted to do
    more, and it calculates the average queue length. The value in doing a simulation
    of such a system is in finding out how long the queue becomes, how much time a
    client spends in the queue, what percentage of the time the server is busy, and
    so on. All of this concerns costs and wasted time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the real world, time is continuous, but on the computer, that is not possible.
    Instead, the time of the simulation takes on discrete values: time = 0, time =
    1.5, time = 3.99, and so on. When the simulation starts, we set the variable `time`
    to the time of the first arrival 1, and the time after that will be the time of
    the event being processed. This is known as a next event simulation: the current
    time in the simulation keeps jumping ahead to the time of the next event (arrival
    or departure) that occurs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrivals happen at random times according to a particular probability distribution.
    When an arrival happens, it (the customer) enters the queue for the service (teller).
    If there is no queue, it gets served immediately; otherwise it must wait. When
    it gets to the server (the teller), it will require some random amount of time
    to be served, and then it will leave. Here are the steps to handle each event:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Arrival** | **Departure** |'
  prefs: []
  type: TYPE_TB
- en: '| 1\. Place the arrival into the queue 2. | 1\. Remove the job from the queue
    3. |'
  prefs: []
  type: TYPE_TB
- en: '| 2\. Is the server busy? | 2\. Queue empty? |'
  prefs: []
  type: TYPE_TB
- en: '| 3\. If not, start the server. | 3\. If so, the server becomes idle. |'
  prefs: []
  type: TYPE_TB
- en: '| 4\. Schedule the next arrival. | 4\. If not, schedule a departure. |'
  prefs: []
  type: TYPE_TB
- en: The queue is an array holding numbers. Adding to the queue means placing a new
    value (the randomly generated service time for the job) at the end of the queue.
    When a value departs the queue, it means removing the first element and moving
    each consecutive value forward by one place. The function `into(t)` 5 inserts
    time `t` into the queue, whereas `out()` 6 removes the front element from the
    queue. The queue is empty (or the system is idle) if there is nothing in the queue
    4.
  prefs: []
  type: TYPE_NORMAL
- en: 'The statistical distribution of times between arrivals and departures is according
    to the negative exponential distribution. If the average time between arrivals
    is μ, then this will be the time of the next arrival in the simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: –μ * log(`random(1)`)
  prefs: []
  type: TYPE_NORMAL
- en: A similar situation exists for departures.
  prefs: []
  type: TYPE_NORMAL
