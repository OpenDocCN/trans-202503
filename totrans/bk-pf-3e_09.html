<html><head></head><body><section class="chapter" epub:type="chapter" id="loggingcomma_monitoringcomma_and_statist" title="Chapter&#xA0;9.&#xA0;Logging, Monitoring, and Statistics"><div class="titlepage"><div><div><h2 class="title">Chapter 9. Logging, Monitoring, and Statistics</h2></div></div></div><div class="mediaobject"><a id="med_id00017"/><img alt="Logging, Monitoring, and Statistics" src="httpatomoreillycomsourcenostarchimages2127149.png.jpg"/></div><p><a class="indexterm" id="iddle1446"/>Exercising control over a network—whether for your home networking needs or in a professional context—is likely to be a main objective for anyone who reads this book. One necessary element of keeping control is having access to all relevant information about what happens in your network. Fortunately for us, PF—like most components of Unix-like systems—is able to generate log data for network activity.</p><p>PF offers a wealth of options for setting the level of logging detail, processing log files, and extracting specific kinds of data. You can already do a lot with the tools that are in your base system, and several other tools are available via your package system to collect, study, and view log data in a number of useful ways. In this chapter, we take a closer look at PF logs in general and some of the tools you can use to extract and present information.</p><div class="sect1" title="PF Logs: The Basics"><div class="titlepage"><div><div><h2 class="title" id="pf_logs_the_basics" style="clear: both">PF Logs: The Basics</h2></div></div></div><p><a class="indexterm" id="iddle1448"/><a class="indexterm" id="iddle1463"/><a class="indexterm" id="iddle1656"/><a class="indexterm" id="iddle1954"/>The information that PF logs and the level of logging detail are up to you, as determined by your rule set. Basic logging is simple: For each rule that you want to log data for, add the <code class="literal">log</code> keyword. When you load the rule set with <code class="literal">log</code> added to one or more rules, any packet that starts a connection matching the logging rule (blocked, passed, or matched) is copied to a <code class="literal">pflog</code> device. <span class="emphasis"><em>The packet is logged as soon as it’s seen by PF and at the same time that the logging rule is evaluated.</em></span></p><div class="note" title="Note"><h3 class="title"><a id="ch09note01"/>Note</h3><p><span class="emphasis"><em>In complicated rule sets, a packet may go through several transformations due to <code class="literal">match</code> or <code class="literal">pass</code> rules, and criteria that matched a packet when it entered the host might not match after a transformation.</em></span></p></div><p>PF will also store certain additional data, such as the timestamp, interface, original source and destination IP addresses, whether the packet was blocked or passed, and the associated rule number from the loaded rule set.</p><p>PF log data is collected by the <code class="literal">pflogd</code> logging daemon, which starts by default when PF is enabled at system startup. The default location for storing the log data is <span class="emphasis"><em>/var/log/pflog</em></span>. The log is written in a binary format, usually called <span class="emphasis"><em>packet capture format (pcap)</em></span>, that’s intended to be read and processed by <code class="literal">tcpdump</code>. We’ll discuss additional tools to extract and display information from your log file later. The log file format is a well-documented and widely supported binary format.</p><p>To get started, here’s a basic log example. Start with the rules you want to log and add the <code class="literal">log</code> keyword:</p><a id="pro_id00320"/><pre class="programlisting">block log&#13;
pass log quick proto { tcp, udp } to port ssh</pre><p>Reload the rule set, and you should see the timestamp on your <span class="emphasis"><em>/var/log/ pflog</em></span> file change as the file starts growing. To see what’s being stored there, use <code class="literal">tcpdump</code> with the <code class="literal">-r</code> option to read the file.</p><p>If logging has been going on for a while, entering the following on a command line can produce large amounts of output:</p><a id="pro_id00321"/><pre class="programlisting">$ <span class="strong"><strong>sudo tcpdump -n -ttt -r /var/log/pflog</strong></span></pre><p>For example, the following are just the first lines from a file several screens long, with almost all lines long enough to wrap:</p><a id="pro_id00322"/><pre class="programlisting">$ <span class="strong"><strong>sudo tcpdump -n -ttt -r /var/log/pflog</strong></span>&#13;
tcpdump: WARNING: snaplen raised from 116 to 160&#13;
Sep 13 13:00:30.556038 rule 10/(match) pass in on epic0: 194.54.107.19.34834 &gt;&#13;
194.54.103.66.113: S 3097635127:3097635127(0) win 16384 &lt;mss 1460,nop,nop,sackOK,nop,wscale&#13;
0,[|tcp]&gt; (DF)&#13;
Sep 13 13:00:30.556063 rule 10/(match) pass out on fxp0: 194.54.107.19.34834 &gt;&#13;
194.54.103.66.113: S 3097635127:3097635127(0) win 16384 &lt;mss 1460,nop,nop,sackOK,nop,wscale&#13;
0,[|tcp]&gt; (DF)&#13;
Sep 13 13:01:07.796096 rule 10/(match) pass in on epic0: 194.54.107.19.29572 &gt;&#13;
194.54.103.66.113: S 2345499144:2345499144(0) win 16384 &lt;mss 1460,nop,nop,sackOK,nop,wscale&#13;
0,[|tcp]&gt; (DF)&#13;
Sep 13 13:01:07.796120 rule 10/(match) pass out on fxp0: 194.54.107.19.29572 &gt;&#13;
194.54.103.66.113: S 2345499144:2345499144(0) win 16384 &lt;mss 1460,nop,nop,sackOK,nop,wscale&#13;
0,[|tcp]&gt; (DF)&#13;
Sep 13 13:01:15.096643 rule 10/(match) pass in on epic0: 194.54.107.19.29774 &gt;&#13;
194.54.103.65.53: 49442 [1au][|domain]&#13;
Sep 13 13:01:15.607619 rule 12/(match) pass in on epic0: 194.54.107.19.29774 &gt;&#13;
194.54.107.18.53: 34932 [1au][|domain]</pre><p><a class="indexterm" id="iddle1205"/>The <code class="literal">tcpdump</code> program is very flexible, especially when it comes to output, and it offers a number of display choices. The format in this example follows from the options we fed to <code class="literal">tcpdump</code>. The program almost always displays the date and time the packet arrived (the <code class="literal">-ttt</code> option specifies this long format). Next, <code class="literal">tcpdump</code> lists the rule number in the loaded rule set, the interface on which the packet appeared, the source and target address and ports (the <code class="literal">-n</code> option tells <code class="literal">tcpdump</code> to display IP addresses, not hostnames), and the various packet properties.</p><div class="note" title="Note"><h3 class="title"><a id="ch09note02"/>Note</h3><p><span class="emphasis"><em>The rule numbers in your log files refer to the</em></span> loaded, in-memory <span class="emphasis"><em>rule set. Your rule set goes through some automatic steps during the loading process, such as macro expansion and optimizations, which make it likely that the rule number as stored in the logs will not quite match what you’d find by counting from the top of your</em></span> pf.conf <span class="emphasis"><em>file. If it isn’t immediately obvious to you which rule matched, use <code class="literal">pfctl -vvs rules</code> and study the output.</em></span></p></div><p>In our <code class="literal">tcpdump</code> output example, we see that the tenth rule (<code class="literal">rule 10</code>) in the loaded rule set seems to be a catchall that matches both IDENT requests and domain name lookups. This is the kind of output you’ll find invaluable when debugging, and it’s essential to have this kind of data available in order to stay on top of your network. With a little effort and careful reading of the <code class="literal">tcpdump</code> man pages, you should be able to extract useful information from your log data.</p><p>For a live display of the traffic you log, use <code class="literal">tcpdump</code> to read log information directly from the log device. To do so, use the <code class="literal">-i</code> option to specify which interface you want <code class="literal">tcpdump</code> to read from, as follows. (The <code class="literal">-l</code> option, which enables line buffering on the output, is useful if you want to look at what you’re capturing.)</p><a id="pro_id00323"/><pre class="programlisting">$ <span class="strong"><strong>sudo tcpdump -lnettti pflog0</strong></span>&#13;
Apr 29 22:07:36.097434 rule 16/(match) pass in on xl0: 85.19.150.98.53 &gt; 213.187.179.198.41101:&#13;
63267*- 1/0/2 (68)&#13;
Apr 29 22:07:36.097760 rule def/(match) pass out on em0: 213.187.179.198.22 &gt;&#13;
192.168.103.44.30827: P 1825500807:1825500883(76) ack 884130750 win 17520 [tos 0x10]&#13;
Apr 29 22:07:36.098386 rule def/(match) pass in on em0: 192.168.103.44.30827 &gt;&#13;
213.187.179.198.22: . ack 76 win 16308 (DF) [tos 0x10]&#13;
Apr 29 22:07:36.099544 rule 442/(match) pass in on xl0: 93.57.15.161.4487 &gt; 213.187.179.198.80:&#13;
P ack 3570451894 win 65535 &lt;nop,nop,timestamp 4170023961 0&gt;&#13;
Apr 29 22:07:36.108037 rule 25/(match) pass out on xl0: 213.187.179.198.25 &gt;&#13;
213.236.166.45.65106: P 2038177705:2038177719(14) ack 149019161 win 17424 (DF)&#13;
Apr 29 22:07:36.108240 rule def/(match) pass out on em0: 213.187.179.198.22 &gt;&#13;
192.168.103.44.30827: P 76:232(156) ack 1 win 17520 [tos 0x10]</pre><p><a class="indexterm" id="iddle1457"/><a class="indexterm" id="iddle1465"/><a class="indexterm" id="iddle1487"/><a class="indexterm" id="iddle1526"/><a class="indexterm" id="iddle1744"/><a class="indexterm" id="iddle1822"/>This sequence begins with a domain name lookup answer, followed by two packets from an open SSH connection, which tells us that the site’s administrator probably enabled <code class="literal">log (all)</code> on the matching rules (see <a class="xref" href="ch09.html#logging_all_packets_log_left_parenthesis" title="Logging All Packets: log (all)">Logging All Packets: log (all)</a>). The fourth packet belongs to a website connection, the fifth is part of an outgoing SMTP connection, and finally there’s another SSH packet. If you were to leave this command running, the displayed lines would eventually scroll off the top of your screen, but you could redirect the data to a file or to a separate program for further processing.</p><div class="note" title="Note"><h3 class="title"><a id="ch09note03"/>Note</h3><p><span class="emphasis"><em>Sometimes you’ll be interested mainly in traffic between specific hosts or in traffic matching specific criteria. For these cases, <code class="literal">tcpdump</code>’s filtering features can be useful. See <code class="literal">man tcpdump</code> for details.</em></span></p></div><div class="sect2" title="Logging the Packet’s Path Through Your Rule Set: log (matches)"><div class="titlepage"><div><div><h3 class="title" id="logging_the_packetapostrophes_path_throu">Logging the Packet’s Path Through Your Rule Set: log (matches)</h3></div></div></div><p>Early versions of the PF logging code didn’t feature an easy way to track all rules that a packet would match during rule-set traversal. This omission became more evident than before when <code class="literal">match</code> rules were introduced in OpenBSD 4.6 and PF users were offered a more convenient and slightly easier way to subject packets and connections to transformations, such as address rewriting. <code class="literal">match</code> rules allow you to perform actions on a packet or connection independently of the eventual <code class="literal">pass</code> or <code class="literal">block</code> decision. The specified actions—such as <code class="literal">nat-to</code>, <code class="literal">rdr-to</code>, and a few others—are performed immediately. This can lead to situations in which a packet has been transformed by a <code class="literal">match</code> rule and it no longer matches criteria in a filtering rule that appears later in the rule set that it otherwise would have matched if the transformation hadn’t already occurred. One fairly basic example is a <code class="literal">match</code> rule that applies <code class="literal">nat-to</code> on the external interface, placed before any <code class="literal">pass</code> rules in the rule set. Once the <code class="literal">nat-to</code> action has been applied, any filtering criteria that would have matched the packet’s original source address will no longer match the packet.</p><p>This greater versatility made some rule sets harder to debug (typically those with several <code class="literal">match</code> rules that perform transformations), and it became clear that a new logging option was needed.</p><p>The PF developers had been eyeing the logging code for a rewrite for some time, and by the time the logging system was rewritten for the OpenBSD 4.9 release, the restructured code made it easy to introduce the log option <code class="literal">matches</code> to help debug such rule sets and to help track a packet’s path through rule sets where several sets of <code class="literal">match</code> or <code class="literal">pass</code> rules could transform the packet.</p><p>Adding <code class="literal">log (matches)</code> to a rule forces the logging of all matched rules once a packet matches a rule containing a <code class="literal">log (matches)</code> clause. Once such a <a class="indexterm" id="iddle1444"/><a class="indexterm" id="iddle1447"/><a class="indexterm" id="iddle1515"/><a class="indexterm" id="iddle1551"/>match occurs, all subsequent rules will also be logged. As a result, you can use targeted <code class="literal">log (</code><span class="strong"><strong><code class="literal">matches</code></strong></span><code class="literal">)</code> statements to trace a packet’s path through your loaded rule set, making it much easier to untangle complicated rule sets.</p><p>For example, consider this simple rule set with NAT. The <code class="literal">log (matches)</code> rule is as follows:</p><a id="pro_id00324"/><pre class="programlisting">match in log (matches) on $int_if from $testhost tag localnet</pre><p>Our test host is a workstation in the local network with the IP address 192.168.103.44. When the test host looks up a website somewhere on the Internet, the logged information looks like this:</p><a id="pro_id00325"/><pre class="programlisting">Apr 29 21:08:24.386474 rule 3/(match) match in on em0: 192.168.103.44.14054 &gt; 81.93.163.115.80:&#13;
S 1381487359:1381487359(0) win 16384 &lt;mss 1460,nop,nop,sackOK,nop,wscale 3,nop,nop,timestamp&#13;
735353043[|tcp]&gt; (DF) ➊&#13;
Apr 29 21:08:24.386487 rule 11/(match) block in on em0: 192.168.103.44.14054 &gt;&#13;
81.93.163.115.80: S 1381487359:1381487359(0) win 16384 &lt;mss 1460,nop,nop,sackOK,nop,wscale&#13;
3,nop,nop,timestamp 735353043[|tcp]&gt; (DF) ➋&#13;
Apr 29 21:08:24.386497 rule 17/(match) pass in on em0: 192.168.103.44.14054 &gt; 81.93.163.115.80:&#13;
S 1381487359:1381487359(0) win 16384 &lt;mss 1460,nop,nop,sackOK,nop,wscale 3,nop,nop,timestamp&#13;
735353043[|tcp]&gt; (DF) ➌&#13;
Apr 29 21:08:24.386513 rule 17/(match) pass in on em0: 192.168.103.44.14054 &gt; 81.93.163.115.80:&#13;
S 1381487359:1381487359(0) win 16384 &lt;mss 1460,nop,nop,sackOK,nop,wscale 3,nop,nop,timestamp&#13;
735353043[|tcp]&gt; (DF)&#13;
Apr 29 21:08:24.386553 rule 5/(match) match out on xl0: 213.187.179.198.14054 &gt;&#13;
81.93.163.115.80: S 1381487359:1381487359(0) win 16384 &lt;mss 1460,nop,nop,sackOK,nop,wscale&#13;
3,nop,nop,timestamp 735353043[|tcp]&gt; (DF) ➍&#13;
Apr 29 21:08:24.386568 rule 16/(match) pass out on xl0: 213.187.179.198.14054 &gt;&#13;
81.93.163.115.80: S 1381487359:1381487359(0) win 16384 &lt;mss 1460,nop,nop,sackOK,nop,wscale&#13;
3,nop,nop,timestamp 735353043[|tcp]&gt; (DF) ➎</pre><p>The initial packet first matches <code class="literal">rule 3</code>, the <code class="literal">match log (matches)</code> rule quoted above the log fragment ➊. The next match is <code class="literal">rule 11</code> in our loaded rule set ➋, the initial <code class="literal">block all</code>, but the packet also matches <code class="literal">rule 17</code>, which lets it <code class="literal">pass in on em0</code> ➌. The next matching <code class="literal">rule 5</code> at ➍ is apparently a <code class="literal">match</code> rule that applies <code class="literal">nat-to</code> (note the changed source address). Finally, the packet passes <code class="literal">out on xl0</code> thanks to <code class="literal">rule 16</code> ➎, a matching <code class="literal">pass</code> rule.</p><p>This example really has only one transformation (the <code class="literal">nat-to</code>), but the <code class="literal">log (matches)</code> feature allows us to follow the connection’s initial packet through all matching rules in the rule set, including the source address substitution.</p></div><div class="sect2" title="Logging All Packets: log (all)"><div class="titlepage"><div><div><h3 class="title" id="logging_all_packets_log_left_parenthesis">Logging All Packets: log (all)</h3></div></div></div><p>For most debugging and lightweight monitoring purposes, logging the first packet in a connection provides enough information. However, sometimes you may want to log all packets that match certain rules. To do so, use the <code class="literal">(all)</code> logging option in the rules you want to monitor. After making this change to our minimal rule set, we have the following:</p><a id="pro_id00326"/><pre class="programlisting">block log (all)&#13;
pass log (all) quick proto tcp to port ssh keep state</pre><p><a class="indexterm" id="iddle1206"/><a class="indexterm" id="iddle1450"/><a class="indexterm" id="iddle1955"/>This option makes the logs quite a bit more verbose. To illustrate just how much more data <code class="literal">log (all)</code> generates, we’ll use the following rule set fragment, which passes domain name lookups and network time synchronizations:</p><a id="pro_id00327"/><pre class="programlisting">udp_services = "{ domain, ntp }"&#13;
pass log (all) inet proto udp to port $udp_services</pre><p>With these rules in place, here’s an example of what happens when a Russian name server sends a domain name request to a server in our network:</p><a id="pro_id00328"/><pre class="programlisting">$ <span class="strong"><strong>sudo tcpdump -lnttti pflog0 port domain</strong></span> &#13;
tcpdump: WARNING: snaplen raised from 116 to 160&#13;
tcpdump: listening on pflog0, link-type PFLOG&#13;
Sep 30 14:27:41.260190 212.5.66.14.53 &gt; 194.54.107.19.53:[|domain]&#13;
Sep 30 14:27:41.260253 212.5.66.14.53 &gt; 194.54.107.19.53:[|domain]&#13;
Sep 30 14:27:41.260267 212.5.66.14.53 &gt; 194.54.107.19.53:[|domain]&#13;
Sep 30 14:27:41.260638 194.54.107.19.53 &gt; 212.5.66.14.53:[|domain]&#13;
Sep 30 14:27:41.260798 194.54.107.19.53 &gt; 212.5.66.14.53:[|domain]&#13;
Sep 30 14:27:41.260923 194.54.107.19.53 &gt; 212.5.66.14.53:[|domain]</pre><p>We now have six entries instead of just one.</p><p>Even with all but <code class="literal">port domain</code> filtered out by <code class="literal">tcpdump</code>, adding <code class="literal">log (all)</code> to one or more rules considerably increases the amount of data in your logs. If you need to log all traffic but your gateway’s storage capacity is limited, you may find yourself shopping for additional storage, and the added I/O activity may in fact have a negative impact on performance. Also, recording and storing traffic logs with this level of detail is likely to have legal implications.</p><div class="sidebar"><a id="log_responsiblyexclamation_mark"/><div class="sidebar-title">Log Responsibly!</div><p>Creating logs of any kind could have surprising consequences, including some legal implications. Once you start storing log data generated by your network traffic, you’re creating a store of information about your users. There may be good technical and business reasons to store logs for extended periods, but logging just enough data and storing it for just the right amount of time can be a fine art.</p><p>You probably have some idea of the practical issues related to generating log data, such as arranging for sufficient storage to retain enough log data long enough to be useful. The legal implications will vary according to your location. Some countries and territories have specific requirements for handling log data, along with restrictions on how that data may be used and how long logs can be retained. Others require service providers to retain traffic logs for a specific period of time, in some cases with a requirement to deliver any such data to law enforcement upon request. Make sure you understand the legal issues before you build a logging infrastructure.</p></div></div><div class="sect2" title="Logging to Several pflog Interfaces"><div class="titlepage"><div><div><h3 class="title" id="logging_to_several_pflog_interfaces">Logging to Several pflog Interfaces</h3></div></div></div><p><a class="indexterm" id="iddle1130"/><a class="indexterm" id="iddle1363"/><a class="indexterm" id="iddle1458"/><a class="indexterm" id="iddle1460"/><a class="indexterm" id="iddle1464"/><a class="indexterm" id="iddle1657"/><a class="indexterm" id="iddle1874"/><a class="indexterm" id="iddle1923"/>Versions of PF newer than OpenBSD 4.1 make it possible to direct your log data to more than one <code class="literal">pflog</code> interface. In OpenBSD 4.1, the <code class="literal">pflog</code> interface became a <span class="emphasis"><em>cloneable</em></span> device, meaning that you can use <code class="literal">ifconfig</code> commands to create several <code class="literal">pflog</code> interfaces, in addition to the default <code class="literal">pflog0</code>. This makes it possible to record the log data for different parts of your rule set to separate <code class="literal">pflog</code> interfaces, and it makes it easier to process the resulting data separately if necessary.</p><p>Moving from the default single <code class="literal">pflog0</code> interface to several <code class="literal">pflog</code> interfaces requires some changes to your setup that are subtle but effective. To log to several interfaces, make sure that all the log interfaces your rule set uses are created. You don’t need to create the devices before the rule set is loaded; if your rule set logs to a nonexistent interface, the log data is simply discarded.</p><p>When tuning your setup to use several <code class="literal">pflog</code> interfaces, you’ll most likely add the required interfaces from the command line, like so:</p><a id="pro_id00329"/><pre class="programlisting">$ <span class="strong"><strong>sudo ifconfig create pflog1</strong></span></pre><p>Specify the log device when you add the <code class="literal">log</code> keyword to your rule set, as follows:</p><a id="pro_id00330"/><pre class="programlisting">pass log (to pflog1) proto tcp to $emailserver port $email&#13;
pass log (to pflog1) proto tcp from $emailserver to port smtp</pre><p>For a more permanent configuration on OpenBSD, create a <span class="emphasis"><em>hostname. pflog1</em></span> file containing only <code class="literal">up</code> and similar <span class="emphasis"><em>hostname.pflogN</em></span> files for any additional logging interfaces.</p><p>On FreeBSD, the configuration of the cloned <code class="literal">pflog</code> interfaces belongs in your <span class="emphasis"><em>rc.conf</em></span> file in the following form:</p><a id="pro_id00331"/><pre class="programlisting">ifconfig_pflog1="up"</pre><p>As of this writing, cloning <code class="literal">pflog</code> interfaces on NetBSD isn’t an option.</p><p>As you saw in <a class="xref" href="ch06.html" title="Chapter 6. Turning the Tables for Proactive Defense">Chapter 6</a>, directing log information for different parts of your rule set to separate interfaces makes it possible to feed different parts of the log data PF produces to separate applications. This makes it easier to have programs like <code class="literal">spamlogd</code> process only the relevant information, while you feed other parts of your PF log data to other log-processing programs.</p></div><div class="sect2" title="Logging to syslog, Local or Remote"><div class="titlepage"><div><div><h3 class="title" id="logging_to_syslogcomma_local_or_remote">Logging to syslog, Local or Remote</h3></div></div></div><p>One way to avoid storing PF log data on the gateway itself is to instruct your gateway to log to another machine. If you already have a centralized logging infrastructure in place, this is a fairly logical thing to do, even if PF’s ordinary logging mechanisms weren’t really designed with traditional <code class="literal">syslog</code>-style logging in mind.</p><p><a class="indexterm" id="iddle1179"/><a class="indexterm" id="iddle1212"/><a class="indexterm" id="iddle1558"/><a class="indexterm" id="iddle1658"/><a class="indexterm" id="iddle1956"/><a class="indexterm" id="iddle2008"/>As any old BSD hand will tell you, the traditional <code class="literal">syslog</code> system log facility is a bit naive about managing the data it receives over UDP from other hosts, with denial-of-service attacks involving full disks one frequently mentioned danger. There’s also the ever-present risk that log information will be lost under high load on either individual systems or the network. Therefore, consider setting up remote logging <span class="emphasis"><em>only</em></span> if all hosts involved communicate over a well-secured and properly dimensioned network. On most BSDs, <code class="literal">syslogd</code> isn’t set up by default to accept log data from other hosts. (See the <code class="literal">syslogd</code> man page for information about how to enable listening for log data from remote hosts if you plan to use remote <code class="literal">syslog</code> logging.)</p><p>If you’d still like to do your PF logging via <code class="literal">syslog</code>, the following is a short recipe for how to accomplish this. In ordinary PF setups, <code class="literal">pflogd</code> copies the log data to the log file. When you want to store the log data on a remote system, you should disable <code class="literal">pflog</code>’s data accumulation by changing daemon’s startup options in <span class="emphasis"><em>rc.conf.local</em></span> (on OpenBSD), like so:</p><a id="pro_id00332"/><pre class="programlisting">pflogd_flags="NO"</pre><p>On FreeBSD and NetBSD, change the <code class="literal">pflog_flats=</code> setting line in <span class="emphasis"><em>rc.conf.</em></span> Then kill the <code class="literal">pflogd</code> process. Next, make sure that the log data, now no longer collected by <code class="literal">pflogd</code>, is transmitted in a meaningful way to your log-processing system instead. This step has two parts: First, set up your system logger to transmit data to the log-processing system, and then use <code class="literal">tcpdump</code> with <code class="literal">logger</code> to convert the data and inject it into the <code class="literal">syslog</code> system.</p><p>To set up <code class="literal">syslogd</code> to process the data, choose your <span class="emphasis"><em>log facility</em></span>, <span class="emphasis"><em>log level</em></span>, and <span class="emphasis"><em>action</em></span> and put the resulting line in <span class="emphasis"><em>/etc/syslog.conf</em></span>. These concepts are very well explained in <code class="literal">man syslog.conf</code>, which is required reading if you want to understand system logs. The <span class="emphasis"><em>action</em></span> part is usually a file in a local file-system. For example, if you’ve already set up the system logger at <span class="emphasis"><em><code class="literal">loghost.example.com</code></em></span> to receive your data, choose log facility <code class="literal">local2</code> with log level <code class="literal">info</code> and enter this line:</p><a id="pro_id00333"/><pre class="programlisting">local2.info             @loghost.example.com</pre><p>Once you’ve made this change, restart <code class="literal">syslogd</code> to make it read the new settings.</p><p>Next, set <code class="literal">tcpdump</code> to convert the log data from the <code class="literal">pflog</code> device and feed it to <code class="literal">logger</code>, which will then send it to the system logger. Here, we reuse the <code class="literal">tcpdump</code> command from the basic examples earlier in this chapter, with some useful additions:</p><a id="pro_id00334"/><pre class="programlisting">$ <span class="strong"><strong>sudo nohup tcpdump -lnettti pflog0 | logger -t pf -p local2.info &amp;</strong></span></pre><p>The <code class="literal">nohup</code> command makes sure the process keeps running even if it doesn’t have a controlling terminal or it’s put in the background (as we do here with the trailing <code class="literal">&amp;</code>). The <code class="literal">-l</code> option to the <code class="literal">tcpdump</code> command specifies line-buffered output, which is useful for redirecting to other programs. <a class="indexterm" id="iddle1207"/><a class="indexterm" id="iddle1428"/><a class="indexterm" id="iddle1445"/><a class="indexterm" id="iddle1461"/><a class="indexterm" id="iddle1653"/>The <code class="literal">logger</code> option adds the tag <code class="literal">pf</code> to identify the PF data in the stream and specifies log priority with the <code class="literal">-p</code> option as <code class="literal">local2.info</code>. The result is logged to the file you specify on the logging host, with entries that will look something like this:</p><a id="pro_id00335"/><pre class="programlisting">pf: Sep 21 14:05:11.492590 rule 93/(match) pass in on ath0:&#13;
10.168.103.11.15842 &gt; 82.117.50.17.80: [|tcp] (DF)&#13;
pf: Sep 21 14:05:11.492648 rule 93/(match) pass out on xl0:&#13;
194.54.107.19.15842 &gt; 82.117.50.17.80: [|tcp] (DF)&#13;
pf: Sep 21 14:05:11.506289 rule 93/(match) pass in on ath0:&#13;
10.168.103.11.27984 &gt; 82.117.50.17.80: [|tcp] (DF)&#13;
pf: Sep 21 14:05:11.506330 rule 93/(match) pass out on xl0:&#13;
194.54.107.19.27984 &gt; 82.117.50.17.80: [|tcp] (DF)&#13;
pf: Sep 21 14:05:11.573561 rule 136/(match) pass in on ath0:&#13;
10.168.103.11.6430 &gt; 10.168.103.1.53:[|domain]&#13;
pf: Sep 21 14:05:11.574276 rule 136/(match) pass out on xl0:&#13;
194.54.107.19.26281 &gt; 209.62.178.21.53:[|domain]</pre><p>This log fragment shows mainly Web-browsing activities from a client in a NATed local network, as seen from the gateway’s perspective, with accompanying domain name lookups.</p></div><div class="sect2" title="Tracking Statistics for Each Rule with Labels"><div class="titlepage"><div><div><h3 class="title" id="tracking_statistics_for_each_rule_with_l">Tracking Statistics for Each Rule with Labels</h3></div></div></div><p>The sequential information you get from retrieving log data basically tracks packet movements over time. In other contexts, the sequence or history of connections is less important than aggregates, such as the number of packets or bytes that have matched a rule since the counters were last cleared.</p><p>At the end of <a class="xref" href="ch02.html" title="Chapter 2. PF Configuration Basics">Chapter 2</a>, you saw how to use <code class="literal">pfctl -s info</code> to view the global aggregate counters, along with other data. For a more detailed breakdown of the data, track traffic totals on a per-rule basis with a slightly different form of <code class="literal">pfctl</code> command, such as <code class="literal">pfctl -vs rules</code>, to display statistics along with the rule, as shown here:</p><a id="pro_id00336"/><pre class="programlisting">$ <span class="strong"><strong>pfctl -vs rules</strong></span>&#13;
pass inet proto tcp from any to 192.0.2.225 port = smtp flags S/SA keep state label "mail-in"&#13;
  [ Evaluations: 1664158 Packets: 1601986 Bytes: 763762591 States: 0 ]&#13;
  [ Inserted: uid 0 pid 24490 ]&#13;
pass inet proto tcp from 192.0.2.225 to any port = smtp flags S/SA keep state label "mail-out"&#13;
  [ Evaluations: 2814933 Packets: 2711211 Bytes: 492510664 States: 0 ]&#13;
  [ Inserted: uid 0 pid 24490 ]</pre><p>The format of this output is easy to read, and it’s obviously designed for contexts in which you want to get an idea of what’s going on at a glance. If you specify even more verbose output with <code class="literal">pfctl -vvs rules</code>, you’ll see essentially the same display, with rule numbers added. On the other hand, the output from this command isn’t very well suited for feeding to a script or other program for further processing. To extract these statistics and a few more items in a script-friendly format—and to make your own decisions about which rules are worth tracking)—use rule <span class="emphasis"><em>labels</em></span>.</p><p><a class="indexterm" id="iddle1479"/><a class="indexterm" id="iddle1646"/>Labels do more than identify rules for processing specific kinds of traffic; they also make it easier to extract the traffic statistics. By attaching labels to rules, you can store certain extra data about parts of your rule set. For example, you could use labeling to measure bandwidth use for accounting purposes.</p><p>In the following example, we attach the labels <code class="literal">mail-in</code> and <code class="literal">mail-out</code> to our <code class="literal">pass</code> rules for incoming and outgoing mail traffic, respectively.</p><a id="pro_id00337"/><pre class="programlisting">pass log proto { tcp, udp } to $emailserver port smtp label "mail-in"&#13;
pass log proto { tcp, udp } from $emailserver to port smtp label "mail-out"</pre><p>Once you’ve loaded the rule set with labels, check the data using <code class="literal">pfctl -vsl</code>:</p><a id="pro_id00338"/><pre class="programlisting">$ sudo pfctl -vsl&#13;
    ➊      ➋       ➌        ➍        ➎       ➏        ➐       ➑&#13;
mail-in 1664158 1601986 763762591 887895 682427415 714091 81335176&#13;
mail-out 2814933 2711211 492510664 1407278 239776267 1303933 252734397</pre><p>This output contains the following information:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>➊ The label</p></li><li class="listitem"><p>➋ The number of times the rule has been evaluated</p></li><li class="listitem"><p>➌ The total number of packets passed</p></li><li class="listitem"><p>➍ The total number of bytes passed</p></li><li class="listitem"><p>➎ The number of packets passed in</p></li><li class="listitem"><p>➏ The number of bytes passed in</p></li><li class="listitem"><p>➐ The number of packets passed out</p></li><li class="listitem"><p>➒ The number of bytes passed out</p></li></ol></div><p>The format of this list makes it very well suited for parsing by scripts and applications.</p><p>The labels accumulate data from the time the rule set is loaded until their counters are reset. And, in many contexts, it makes sense to set up a <code class="literal">cron</code> job that reads label values at fixed intervals and then puts those values into permanent storage.</p><p>If you choose to run the data collection at fixed intervals, consider collecting the data using <code class="literal">pfctl -vsl -z</code>. The <code class="literal">z</code> option resets the counters once <code class="literal">pfctl</code> has read them, with the result that your data collector will then fetch <span class="emphasis"><em>periodic data</em></span>, accumulated since the command or the script was last run.</p><div class="note" title="Note"><h3 class="title"><a id="ch09note04"/>Note</h3><p><span class="emphasis"><em>Rules with macros and lists expand to several distinct rules. If your rule set contains rules with lists and macros that have a label attached, the in-memory result will be a number of rules, each with a separate, identically named label attached to it. While this may lead to confusing <code class="literal">sudo pfctl -vsl</code> output, it shouldn’t be a problem as long as the application or script that receives the data can interpret the data correctly by adding up the totals for the identical labels.</em></span></p></div><p><a class="indexterm" id="iddle1452"/><a class="indexterm" id="iddle1902"/><a class="indexterm" id="iddle1926"/>If this type of data collection sounds useful to you, it’s also worth noting that recent PF versions offer the option of collecting traffic metadata as NetFlow or IPFIX data. See <a class="xref" href="ch09.html#collecting_netflow_data_with_pflowleft_p" title="Collecting NetFlow Data with pflow(4)">Collecting NetFlow Data with pflow(4)</a> for details.</p></div><div class="sect2" title="Additional Tools for PF Logs and Statistics"><div class="titlepage"><div><div><h3 class="title" id="additional_tools_for_pf_logs_and_statist">Additional Tools for PF Logs and Statistics</h3></div></div></div><p>One other important component of staying in control of your network is having the ability to keep an updated view of your system’s status. In this section, we’ll examine a selection of monitoring tools that you may find useful. All the tools presented here are available either in the base system or via the package system on OpenBSD and FreeBSD (and, with some exceptions, on NetBSD).</p></div><div class="sect2" title="Keeping an Eye on Things with systat"><div class="titlepage"><div><div><h3 class="title" id="keeping_an_eye_on_things_with_systat">Keeping an Eye on Things with systat</h3></div></div></div><p>If you’re interested in seeing an instant snapshot of the traffic passing through your systems right now, the <code class="literal">systat</code> program on OpenBSD offers several useful views. In <a class="xref" href="ch07.html" title="Chapter 7. Traffic Shaping with Queues and Priorities">Chapter 7</a>, we looked briefly at <code class="literal">systat queues</code> to see how traffic was assigned to queues in our traffic-shaping rule sets. Here, we’ll review some additional useful options.</p><p>The <code class="literal">systat</code> program is available on all BSD operating systems, in slightly different versions. On all systems, <code class="literal">systat</code> offers views of system statistics, with some minor variations in syntax and output. For example, the <code class="literal">queues</code> view is one of several <code class="literal">systat</code> views available in recent OpenBSD versions, but not in FreeBSD or NetBSD as of this writing.</p><p>For a more general view of the current state table than that offered by <code class="literal">queues</code>, try <code class="literal">systat states</code>, which gives a listing very similar to the <code class="literal">top(1)</code> process listing. Here’s an example of typical <code class="literal">systat states</code> output:</p><a id="pro_id00339"/><pre class="programlisting">   2 users     Load 0.24 0.28 0.27 (1-16 of 895)       Wed Apr 1 14:00:04 2015&#13;
&#13;
PR   D SRC                  DEST                 STATE    AGE   EXP  PKTS BYTES  RATE  PEAK   AVG RU G&#13;
udp  O 192.168.103.1:56729  192.168.103.9:12345   1:0   8340m    25  372K  542M  1492  4774  1137  *&#13;
tcp  I 10.168.103.15:47185  213.187.179.198:22    4:4   62377 86398  2954  613K 13264 23654    10  18&#13;
tcp  I 10.168.103.15:2796   213.187.179.198:22    4:4   62368 86219  4014  679K     0     0    11  18&#13;
tcp  I 10.168.103.15:15599  129.240.64.10:6667    4:4   61998 86375  9266  849K     0    58    14  *&#13;
tcp  O 213.187.179.198:1559 129.240.64.10:6667    4:4   61998 86375  9266  849K     0    58    14  * 1&#13;
tcp  I 10.168.103.15:8923   140.211.166.4:6667    4:4   61843 86385 15677 4794K     0   299    79  *&#13;
tcp  O 213.187.179.198:8923 140.211.166.4:6667    4:4   61843 86385 15677 4794K     0   299    79  * 1&#13;
tcp  I 10.168.103.15:47047  217.17.33.10:6667     4:4   61808 86385  7093  556K     0    88     9  *&#13;
tcp  O 213.187.179.198:4704 217.17.33.10:6667     4:4   61808 86385  7093  556K     0    88     9  * 1&#13;
tcp  I 10.168.103.15:30006  203.27.221.42:6667    4:4   61744 86375  6000  487K     0    49     8  *&#13;
tcp  O 213.187.179.198:3000 203.27.221.42:6667    4:4   61744 86375  6000  487K     0    49     8  * 1&#13;
tcp  I 10.168.103.15:31709  209.250.145.51:6667   4:4   61744 86385  6646  613K     0   114    10  *&#13;
tcp  O 213.187.179.198:3170 209.250.145.51:6667   4:4   61744 86385  6646  613K     0   114    10  * 1&#13;
tcp  I 192.168.103.254:5386 69.90.74.197:80       4:4   56718 29844    10  3282     0     0     0  *&#13;
tcp  O 213.187.179.198:5386 69.90.74.197:80       4:4   56718 29844    10  3282     0     0     0  * 1&#13;
tcp  I 10.168.103.15:33241  192.168.103.84:22     4:4   46916 82678  7555  897K     0     0    19  *</pre><p>If your states don’t fit on one screen, just page through the live display.</p><p>Similarly, <code class="literal">systat rules</code> displays a live view of packets, bytes, and other statistics for your loaded rule set, as in this example:</p><a id="pro_id00340"/><pre class="programlisting">2 users       Load 1.25 0.87 0.52  (1-16 of 239)        Fri Apr  3 14:01:59 2015&#13;
&#13;
RUL ANCHOR      A DIR L Q IF    PR   K   PKTS BYTES STATE MAX INFO&#13;
  0             M In                      26M   12G 4946K     all max-mss 1440&#13;
  1             M Out     nfe0          4853K 3162M 94858     inet from 10.0.0.0/8 to any queue(q_def&#13;
  2             M Out     nfe0          3318K 2430M 61672     inet from 192.168.103.0/24 to any queue&#13;
  3             M Out     nfe0  tcp     6404K 4341M  134K     from any to any port = www queue(q_web,&#13;
  4             M Out     nfe0  tcp     84298   43M  1594     from any to any port = https queue(q_we&#13;
  5             M Out     nfe0  tcp       502 34677    63     from any to any port = domain queue(q_d&#13;
  6             M Out     nfe0  udp      512K   64M  257K     from any to any port = domain queue(q_d&#13;
  7             M Out     nfe0  icmp       11  1008     3     all queue(q_dns, q_pri)&#13;
  8             B Any L                 14638 1346K     0     return all&#13;
  9             B Any  Q                   95  5628     0     return from &lt;bruteforce&gt; to any&#13;
 10             P Any                   1139K 1005M   757     all flags any&#13;
 11             P In   Q        tcp  K  18538 1350K   708     inet from any to any port = ftp&#13;
 12             P Out           tcp  K      0     0     0     inet from 127.0.0.1/32 to any port = ftp&#13;
 13             P Any                    1421  128K   134     all flags any&#13;
 14             P In L    egres tcp  K  1830K   87M 18933     inet from any to any port = smtp queue&#13;
 15             P In L    egres tcp  K     31  5240     2     from &lt;nospamd&gt; to any port = smtp</pre><p>The <code class="literal">systat rules</code> view is especially useful because it offers a live view into the fully parsed and loaded rule set. For example, if your rule set behaves oddly, the <code class="literal">rules</code> view can point you in the right direction and show you the flow of packets.</p><p>The <code class="literal">systat</code> program also offers a view that presents the same data you’d get via <code class="literal">pfctl -s status</code> on the command line. The following example shows part of the output of <code class="literal">systat pf</code>. The <code class="literal">systat pf</code> view offers more information than will fit on most screens, but you can page through the live display of the data.</p><a id="pro_id00341"/><pre class="programlisting">2 users    Load 0.34 0.64 0.47  (1-16 of 51)        Fri Apr  3 14:04:04 2015&#13;
&#13;
         TYPE NAME                          VALUE       RATE NOTES&#13;
           pf Status                      Enabled&#13;
           pf Since                     139:05:08&#13;
           pf Debug                           err&#13;
           pf Hostid                   0x82aea702&#13;
&#13;
         nfe0 Bytes In                 6217042900            IPv4&#13;
         nfe0 Bytes In                          0            IPv6&#13;
         nfe0 Bytes Out                5993394114            IPv4&#13;
         nfe0 Bytes Out                        64            IPv6&#13;
         nfe0 Packets In                 12782504            IPv4, Passed&#13;
         nfe0 Packets In                        0            IPv6, Passed&#13;
         nfe0 Packets In                    11096            IPv4, Blocked&#13;
         nfe0 Packets In                        0            IPv6, Blocked&#13;
         nfe0 Packets Out                12551463            IPv4, Passed&#13;
         nfe0 Packets Out                       1            IPv6, Passed&#13;
         nfe0 Packets Out                     167            IPv4, Blocked</pre><p><a class="indexterm" id="iddle1004"/><a class="indexterm" id="iddle1449"/><a class="indexterm" id="iddle1451"/><a class="indexterm" id="iddle1663"/><a class="indexterm" id="iddle1666"/><a class="indexterm" id="iddle1667"/><a class="indexterm" id="iddle1927"/>The <code class="literal">systat</code> program offers quite a few other views, including network-related ones, such as <code class="literal">netstat</code>, <code class="literal">vmstat</code> for virtual memory statistics, and <code class="literal">iostat</code> for input/output statistics by device. You can cycle through all <code class="literal">systat</code> views using the left and right cursor keys. (See <code class="literal">man systat</code> for full details.)</p></div><div class="sect2" title="Keeping an Eye on Things with pftop"><div class="titlepage"><div><div><h3 class="title" id="keeping_an_eye_on_things_with_pftop">Keeping an Eye on Things with pftop</h3></div></div></div><p>If your system doesn’t have a <code class="literal">systat</code> version with the PF-related views, you can still keep an eye on what’s passing into and out of your network in real time using Can Erkin Acar’s <code class="literal">pftop</code>. This command shows a running snapshot of your traffic. <code class="literal">pftop</code> isn’t included in the base system, but it’s available as a package—in ports on OpenBSD and FreeBSD as <span class="emphasis"><em>sysutils/pftop</em></span><sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch09fn01" id="ch09fn01">44</a>]</sup> and on NetBSD via <code class="literal">pkgsrc</code> as <span class="emphasis"><em>sysutils/pftop</em></span>. Here’s an example of its output:</p><a id="pro_id00342"/><pre class="programlisting">pfTop: Up State 1-17/771, View: default, Order: none, Cache: 10000                             14:05:42&#13;
&#13;
PR    DIR SRC                   DEST                           STATE            AGE   EXP   PKTS  BYTES&#13;
udp   Out 192.168.103.1:56729   192.168.103.9:12345        SINGLE:NO_TRAFFIC  8346m    22   373K   543M&#13;
tcp   In  10.168.103.15:47185   213.187.179.198:22    ESTABLISHED:ESTABLISHED 62715 86395   3232   667K&#13;
tcp   In  10.168.103.15:2796    213.187.179.198:22    ESTABLISHED:ESTABLISHED 62706 86369   4071   686K&#13;
tcp   In  10.168.103.15:15599   129.240.64.10:6667    ESTABLISHED:ESTABLISHED 62336 86379   9318   854K&#13;
tcp   Out 213.187.179.198:15599 129.240.64.10:6667    ESTABLISHED:ESTABLISHED 62336 86379   9318   854K&#13;
tcp   In  10.168.103.15:8923    140.211.166.4:6667    ESTABLISHED:ESTABLISHED 62181 86380  15755  4821K&#13;
tcp   Out 213.187.179.198:8923  140.211.166.4:6667    ESTABLISHED:ESTABLISHED 62181 86380  15755  4821K&#13;
tcp   In  10.168.103.15:47047   217.17.33.10:6667     ESTABLISHED:ESTABLISHED 62146 86379   7132   559K&#13;
tcp   Out 213.187.179.198:47047 217.17.33.10:6667     ESTABLISHED:ESTABLISHED 62146 86379   7132   559K&#13;
tcp   In  10.168.103.15:30006   203.27.221.42:6667    ESTABLISHED:ESTABLISHED 62082 86380   6034   489K&#13;
tcp   Out 213.187.179.198:30006 203.27.221.42:6667    ESTABLISHED:ESTABLISHED 62082 86380   6034   489K&#13;
tcp   In  10.168.103.15:31709   209.250.145.51:6667   ESTABLISHED:ESTABLISHED 62082 86379   6685   617K&#13;
tcp   Out 213.187.179.198:31709 209.250.145.51:6667   ESTABLISHED:ESTABLISHED 62082 86379   6685   617K&#13;
tcp   In  192.168.103.254:53863 69.90.74.197:80       ESTABLISHED:ESTABLISHED 57056 29506     10   3282&#13;
tcp   Out 213.187.179.198:53863 69.90.74.197:80       ESTABLISHED:ESTABLISHED 57056 29506     10   3282&#13;
tcp   In  10.168.103.15:33241   192.168.103.84:22     ESTABLISHED:ESTABLISHED 47254 82340   7555   897K&#13;
tcp   Out 10.168.103.15:33241   192.168.103.84:22     ESTABLISHED:ESTABLISHED 47254 82340   7555   897K</pre><p>You can use <code class="literal">pftop</code> to sort your connections by a number of different criteria, including by PF rule, volume, age, and source and destination addresses.</p></div><div class="sect2" title="Graphing Your Traffic with pfstat"><div class="titlepage"><div><div><h3 class="title" id="graphing_your_traffic_with_pfstat">Graphing Your Traffic with pfstat</h3></div></div></div><p>Once you have a system up and running and producing data, a graphical representation of traffic data is a useful way to view and analyze your data. One way to graph your PF data is with <code class="literal">pfstat</code>, a utility developed by Daniel Hartmeier to extract and present the statistical data that’s automatically generated by PF. The <code class="literal">pfstat</code> tool is available via the OpenBSD package system or as the port <span class="emphasis"><em>net/pfstat</em></span>, via the FreeBSD ports system as <span class="emphasis"><em>sysutils/pfstat</em></span>, and via NetBSD <code class="literal">pkgsrc</code> as <span class="emphasis"><em>sysutils/pfstat</em></span>.</p><p><a class="indexterm" id="iddle1903"/>The <code class="literal">pfstat</code> program collects the data you specify in the configuration file and presents that data as JPG or PNG graphics files. The data source can be either PF running on the local system via the <span class="emphasis"><em>/dev/pf</em></span> device or data collected from a remote computer running the companion <code class="literal">pfstatd</code> daemon.</p><p>To set up <code class="literal">pfstat</code>, you simply decide which parts of your PF data you want to graph and how, and then you write the configuration file and start <code class="literal">cron</code> jobs to collect the data and generate your graphs. The program comes with a well-annotated sample configuration file and a useful man page. The sample configuration is a useful starting point for writing your own configuration file. For example, the following <span class="emphasis"><em>pfstat.conf</em></span> fragment is very close to one you’ll find in the sample configuration:<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch09fn02" id="ch09fn02">45</a>]</sup></p><a id="pro_id00343"/><pre class="programlisting">collect 8 = global states inserts diff&#13;
collect 9 = global states removals diff&#13;
collect 10 = global states searches diff&#13;
&#13;
image "/var/www/users/peter/bsdly.net/pfstat-states.jpg" {&#13;
        from 1 days to now&#13;
        width 980 height 300&#13;
        left&#13;
                graph 8 "inserts" "states/s" color 0 192 0 filled,&#13;
                graph 9 "removals" "states/s" color 0 0 255&#13;
        right&#13;
                graph 10 "searches" "states/s" color 255 0 0&#13;
}</pre><p>The configuration here starts off with three <code class="literal">collect</code> statements, where each of the data series is assigned a unique numeric identifier. Here, we capture the number of insertions, removals, and searches in the state table. Next up is the <code class="literal">image</code> definition, which specifies the data that is to be graphed. The <code class="literal">from</code> line specifies the period to display (<code class="literal">from 1 days to now</code> means that only data collected during the last 24 hours is to be displayed). <code class="literal">width</code> and <code class="literal">height</code> specify the graph size measured in number of pixels in each direction. The <code class="literal">graph</code> statements specify how the data series are displayed as well as the graph legends. Collecting state insertions, removals, and searches once a minute and then graphing the data collected over one day produces a graph roughly like the one in <a class="xref" href="ch09.html#state_table_statisticscomma_24-hour_time" title="Figure 9-1. State table statistics, 24-hour time scale">Figure 9-1</a>.</p><div class="figure"><a id="state_table_statisticscomma_24-hour_time"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00018"/><img alt="State table statistics, 24-hour time scale" src="httpatomoreillycomsourcenostarchimages2127165.png.jpg"/></div></div><div class="figure-title">Figure 9-1. State table statistics, 24-hour time scale</div></div><p><a class="indexterm" id="iddle1664"/><a class="indexterm" id="iddle1904"/><a class="indexterm" id="iddle1914"/>The graph can be tweaked to provide a more detailed view of the same data. For example, to see the data for the last hour in a slightly higher resolution, change the period to <code class="literal">from 1 hours to now</code> and the dimensions to <code class="literal">width 600 height 300</code>. The result is something like the graph in <a class="xref" href="ch09.html#state_table_statisticscomma_1-hour_time" title="Figure 9-2. State table statistics, 1-hour time scale">Figure 9-2</a>.</p><div class="figure"><a id="state_table_statisticscomma_1-hour_time"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00019"/><img alt="State table statistics, 1-hour time scale" src="httpatomoreillycomsourcenostarchimages2127167.png"/></div></div><div class="figure-title">Figure 9-2. State table statistics, 1-hour time scale</div></div><p>The <code class="literal">pfstat</code> home page at <span class="emphasis"><em><a class="ulink" href="http://www.benzedrine.cx/pfstat.html" target="_top">http://www.benzedrine.cx/pfstat.html</a></em></span> contains several examples, with demonstrations in the form of live graphs of the data from the <span class="emphasis"><em>benzedrine.cx</em></span> domain’s gateways. By reading the examples and tapping your own knowledge of your traffic, you should be able to create <code class="literal">pfstat</code> configurations that are well suited to your site’s needs.</p><div class="note" title="Note"><h3 class="title"><a id="ch09note05"/>Note</h3><p><span class="emphasis"><em>In addition to <code class="literal">pfstat</code>, other system-monitoring packages offer at least some PF-monitoring features. One such package is the popular <code class="literal">symon</code> utility, which is usually configured with the <code class="literal">symon</code> data gatherer on all monitored systems and at least one host with <code class="literal">symux</code> and the optional <code class="literal">syweb</code> Web interface. Based on round-robin database tool (RRDtool), <code class="literal">symon</code> has a useful interface for recording PF data and offers a useful graphical interface for displaying PF statistics via the <code class="literal">syweb</code> Web interface. <code class="literal">symon</code> is available as a port or package on OpenBSD and FreeBSD as <code class="literal">sysutils/symon</code>, and the <code class="literal">syweb</code> Web interface is available as <code class="literal">www/syweb</code>.</em></span></p></div></div><div class="sect2" title="Collecting NetFlow Data with pflow(4)"><div class="titlepage"><div><div><h3 class="title" id="collecting_netflow_data_with_pflowleft_p">Collecting NetFlow Data with pflow(4)</h3></div></div></div><p><a class="indexterm" id="iddle1364"/><a class="indexterm" id="iddle1453"/><a class="indexterm" id="iddle1456"/><a class="indexterm" id="iddle1537"/><a class="indexterm" id="iddle1539"/><a class="indexterm" id="iddle1544"/><a class="indexterm" id="iddle1545"/><a class="indexterm" id="iddle1659"/><a class="indexterm" id="iddle1661"/><a class="indexterm" id="iddle1905"/><a class="indexterm" id="iddle1945"/><a class="indexterm" id="iddle1962"/><a class="indexterm" id="iddle2010"/><span class="emphasis"><em>NetFlow</em></span> is a network data collection and analysis method that has spawned many supporting tools for recording and analyzing data about TCP/IP connections. NetFlow originated at Cisco and over time has become an essential feature in various network equipment as a tool for network management and analysis.</p><p>The NetFlow data model defines a network <span class="emphasis"><em>flow</em></span> as a unidirectional sequence of packets with the same source and destination IP address and protocol. For example, a TCP connection will appear in NetFlow data as two flows: one in each direction.</p><p>PF data can be made available to NetFlow tools via the <code class="literal">pflow(4)</code> pseudo-interface that was introduced in OpenBSD 4.5 along with the <code class="literal">pflow</code> state option. Essentially, all the information you’d expect to find in a NetFlow-style flow record is easily derived from the data PF keeps in the state table, and the <code class="literal">pflow</code> interface offers a straightforward way to export PF state-table data in this processing-friendly and well-documented format. As with other logging, you enable NetFlow data collection in your PF rule set on a per-rule basis.</p><p>A complete NetFlow-based network-monitoring system consists of several distinct parts. The NetFlow data originates at one or more <span class="emphasis"><em>sensors</em></span> that generate data about network traffic. The sensors forward data about the flows to a <span class="emphasis"><em>collector</em></span>, which stores the data it receives. Finally, a <span class="emphasis"><em>reporting</em></span> or <span class="emphasis"><em>analysis</em></span> system lets you extract and process the data.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch09fn03" id="ch09fn03">46</a>]</sup></p><div class="sect3" title="Setting Up the NetFlow Sensor"><div class="titlepage"><div><div><h4 class="title" id="setting_up_the_netflow_sensor">Setting Up the NetFlow Sensor</h4></div></div></div><p>The NetFlow sensor requires two components: one or more configured <code class="literal">pflow(4)</code> devices and at least one <code class="literal">pass</code> rule in your rule set with the <code class="literal">pflow</code> state option enabled. The <code class="literal">pflow</code> interfaces are created with two required parameters: the flow source IP address and flow destination’s IP address and port. Here’s an example of the <code class="literal">ifconfig</code> command for the <span class="emphasis"><em>/etc/hostname.pflow0</em></span> file:</p><a id="pro_id00344"/><pre class="programlisting">flowsrc 192.0.2.1 flowdst 192.0.2.105:3001</pre><p>From the command line, use this command:</p><a id="pro_id00345"/><pre class="programlisting">$ <span class="strong"><strong>sudo ifconfig pflow0 create flowsrc 192.0.2.1 flowdst 192.0.2.105:3001</strong></span></pre><p>In both cases, this command sets up the host to send NetFlow data with a flow source address 192.0.2.1 to a collector that should listen for NetFlow data at 192.0.2.105, UDP port 3001.</p><div class="note" title="Note"><h3 class="title"><a id="ch09note06"/>Note</h3><p><span class="emphasis"><em>It’s possible to set up several <code class="literal">pflow</code> devices with separate flow destinations. It’s not currently possible, however, to specify on a per-rule basis which <code class="literal">pflow</code> device should receive the generated data.</em></span></p></div><p><a class="indexterm" id="iddle1090"/><a class="indexterm" id="iddle1255"/><a class="indexterm" id="iddle1257"/><a class="indexterm" id="iddle1454"/><a class="indexterm" id="iddle1541"/><a class="indexterm" id="iddle1542"/><a class="indexterm" id="iddle1543"/><a class="indexterm" id="iddle1556"/><a class="indexterm" id="iddle1660"/><a class="indexterm" id="iddle1894"/>After enabling the <code class="literal">pflow</code> device, specify in <span class="emphasis"><em>/etc/pf.conf</em></span> which <code class="literal">pass</code> rules should provide NetFlow data to the sensor. For example, if your main concern is to collect data on your clients’ email traffic to IPv4 hosts, this rule would set up the necessary sensor:</p><a id="pro_id00346"/><pre class="programlisting">pass out log inet proto tcp from &lt;client&gt; to port $email \&#13;
      label client-email keep state (pflow)</pre><p>When <code class="literal">pflow</code> was first introduced to PF, the immediate reaction from early adopters was that more likely than not, they’d want to add the <code class="literal">pflow</code> option to most <code class="literal">pass</code> rules in their rule sets. This led PF developer Henning Brauer to introduce another useful PF feature—the ability to set <span class="emphasis"><em>state defaults</em></span> that apply to all rules unless otherwise specified. For example, if you add the following line at the start of your rule set, all <code class="literal">pass</code> rules in the configuration will generate NetFlow data to be exported via the <code class="literal">pflow</code> device.</p><a id="pro_id00347"/><pre class="programlisting">set state-defaults pflow</pre><p>With at least one <code class="literal">pflow</code> device configured and at least one rule in your <span class="emphasis"><em>pf.conf</em></span> that generates data for export via the <code class="literal">pflow</code> device, you’re almost finished setting up the sensor. You may still need to add a rule, however, that allows the UDP data to flow from the IP address you specified as the flow data source to the collector’s IP address and target port at the flow destination. Once you’ve completed this last step, you should be ready to turn your attention to collecting the data for further processing.</p></div><div class="sect3" title="NetFlow Data Collecting, Reporting, and Analysis"><div class="titlepage"><div><div><h4 class="title" id="netflow_data_collectingcomma_reportingco">NetFlow Data Collecting, Reporting, and Analysis</h4></div></div></div><p>If your site has a NetFlow-based collection and analysis infrastructure in place, you may already have added the necessary configuration to feed the PF-originated data into the data collection and analysis system. If you haven’t yet set up a flow-analysis environment, there are a number of options available.</p><p>The OpenBSD packages system offers three NetFlow collector and analysis packages: <code class="literal">flow-tools</code>, <code class="literal">flowd</code>, and <code class="literal">nfdump</code>.<sup>[<a class="footnote" href="#ftn.ch09fn04" id="ch09fn04">47</a>]</sup> All three systems have a dedicated and competent developer and user community as well as various add-ons, including graphical Web interfaces. <code class="literal">flow-tools</code> is the main component in many sites’ flow-analysis setups. The <code class="literal">nfdump</code> fans point to the <code class="literal">nfsen</code> analysis package that integrates the <code class="literal">nfdump</code> tools in a powerful and flexible Web-based analysis frontend that will, among other things, display the command-line equivalent of your GUI selections. You’ll find the command-line display useful when you need to drill down further into the data than the selections in the GUI allow. You can copy the command displayed in the GUI and make any further adjustments you need on the <code class="literal">nfdump</code> command line in a shell session or script to extract the exact data you want.</p><div class="sidebar"><a id="choosing_a_collector"/><div class="sidebar-title">Choosing a Collector</div><p><a class="indexterm" id="iddle1256"/><a class="indexterm" id="iddle1292"/><a class="indexterm" id="iddle1508"/><a class="indexterm" id="iddle1538"/><a class="indexterm" id="iddle2017"/>The choice of collector is somewhat tied to the choice of analysis package. Perhaps because the collectors tend to store flow data in their own unique formats, most reporting and analysis backends are developed with a distinctive bias for one or the other collector.</p><p>Regardless of your choice of NetFlow collector, the familiar logging caveats apply: Detailed traffic log information will require storage. In the case of NetFlow, each flow will generate a record of fairly fixed size, and anecdotal evidence indicates that even modest collection profiles on busy sites can generate gigabytes of NetFlow data per day. The amount of storage you’ll need is directly proportional to the number of connections and how long you keep the original NetFlow data. Finally, recording and storing traffic logs with this level of detail is likely to have legal implications.</p><p>Collectors generally offer filtering features that let you discard data about specific hosts or networks or even discard some parts of the NetFlow records themselves, either globally or for data about specific hosts or networks.</p></div><p>To illustrate some basic NetFlow collection and how to extract a subset of the collected data for further analysis, we’ll use <code class="literal">flowd</code>, developed by long-time OpenBSD developer Damien Miller and available via the package systems (on OpenBSD as <span class="emphasis"><em>net/flowd</em></span> and on FreeBSD as <span class="emphasis"><em>net-mgmt/flowd</em></span>).</p><p>I’ve chosen to use <code class="literal">flowd</code> here mainly because it was developed to be small, simple, and secure. As you’ll see, <code class="literal">flowd</code> still manages to be quite useful and flexible. Flow data operations with other tools will differ in some details, but the underlying principles remain the same.</p><p>When compared to other NetFlow collector suites, <code class="literal">flowd</code> is very compact, with only two executable programs—the collector daemon <code class="literal">flowd</code> and the flow-filtering and presentation program <code class="literal">flowd-reader</code>—as well as the supporting library and controlling configuration file. The documentation is adequate, if a bit terse, and the sample <span class="emphasis"><em>/etc/flowd.conf</em></span> file contains a generous number of comments. Based on the man pages and the comments in the sample configuration file, it shouldn’t take you long to create a useful collector configuration.</p><p>After stripping out any comment lines—using <code class="literal">grep -v \# /etc/flowd.conf</code> or similar—a very basic <code class="literal">flowd</code> configuration could look like this:</p><a id="pro_id00348"/><pre class="programlisting">logfile "/var/log/flowd"&#13;
listen on 192.0.2.105:3001&#13;
flow source 192.0.2.1&#13;
store ALL</pre><p><a class="indexterm" id="iddle1946"/><a class="indexterm" id="iddle2011"/>While this configuration barely contains more information than the <code class="literal">pflow</code> interface’s configuration in the earlier description of setting up the sensor, it does include two important items:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>The <code class="literal">logfile</code> line tells us where the collected data is to be stored (and reveals that <code class="literal">flowd</code> tends to store all data in a single file).</p></li><li class="listitem"><p>The final line tells us that <code class="literal">flowd</code> will store all fields in the data it receives from the designated flow source.</p></li></ul></div><p>With this configuration in place, start up the <code class="literal">flowd</code> daemon, and almost immediately you should see the <span class="emphasis"><em>/var/log/flowd</em></span> file grow as network traffic passes through your gateway and flow records are collected. After a while, you should be able to look at the data using <code class="literal">flowd</code>’s companion program <code class="literal">flowd-reader</code>. For example, with all fields stored, the data for one name lookup from a host on the NATed local network looks like this in <code class="literal">flowd-reader</code>’s default view:</p><a id="pro_id00349"/><pre class="programlisting">$ <span class="strong"><strong>sudo flowd-reader /var/log/flowd</strong></span>&#13;
FLOW recv_time 2011-04-01T21:15:53.607179 proto 17 tcpflags 00 tos 00 agent&#13;
[213.187.179.198] src [192.0.2.254]:55108 dst [192.0.2.1]:53 packets 1 octets&#13;
62&#13;
FLOW recv_time 2011-04-01T21:15:53.607179 proto 17 tcpflags 00 tos 00 agent&#13;
[213.187.179.198] src [192.0.2.1]:53 dst [192.0.2.254]:55108 packets 1 octets&#13;
129</pre><p>Notice that the lookup generates two flows: one in each direction.</p><p>The first flow is identified mainly by the time it was received, followed by the protocol used (protocol 17 is UDP, as <span class="emphasis"><em>/etc/protocols</em></span> will tell you). The connection had both TCP and TOS flags unset, and the collector received the data from our gateway at 192.0.2.1. The flow’s source address was 192.0.2.254, source port 55108, and the destination address was 192.0.2.1, source port 53, conventionally the DNS port. The flow consisted of 1 packet with a payload of 62 octets. The return flow was received by the collector at the same time, and we see that this flow has the source and destination reversed, with a slightly larger payload of 129 octets. <code class="literal">flowd-reader</code>’s output format lends itself to parsing by regular expressions for postprocessing in reporting tools or plotting software.</p><p>You might think that this data is all anyone would ever want to know about any particular set of network flows, but it’s possible to extract even more detailed information. For example, using the <code class="literal">flowd-reader -v</code> option for verbose output, you might see something like this:</p><a id="pro_id00350"/><pre class="programlisting">FLOW recv_time 2011-04-01T21:15:53.607179 proto 17 tcpflags 00 tos 00&#13;
agent [213.187.179.198] src [192.0.2.254]:55108 dst [192.0.2.1]:53 gateway&#13;
[0.0.0.0] packets 1 octets 62 in_if 0 out_if 0 sys_uptime_ms 1w5d19m59s.000&#13;
time_sec 2011-04-01T21:15:53 time_nanosec 103798508 netflow ver 5 flow_start&#13;
1w5d19m24s.000 flow_finish 1w5d19m29s.000 src_AS 0 src_masklen 0 dst_AS 0&#13;
dst_masklen 0 engine_type 10752 engine_id 10752 seq 5184351 source 0 crc32&#13;
759adcbd&#13;
FLOW recv_time 2011-04-01T21:15:53.607179 proto 17 tcpflags 00 tos 00&#13;
agent [213.187.179.198] src [192.0.2.1]:53 dst [192.0.2.254]:55108 gateway&#13;
[0.0.0.0] packets 1 octets 129 in_if 0 out_if 0 sys_uptime_ms 1w5d19m59s.000&#13;
time_sec 2011-04-01T21:15:53 time_nanosec 103798508 netflow ver 5 flow_start&#13;
1w5d19m24s.000 flow_finish 1w5d19m29s.000 src_AS 0 src_masklen 0 dst_AS 0&#13;
dst_masklen 0 engine_type 10752 engine_id 10752 seq 5184351 source 0 crc32&#13;
f43cbb22</pre><p>The <code class="literal">gateway</code> field indicates that the sensor itself served as the gateway for this connection. You see a list of the interfaces involved (the <code class="literal">in_if</code> and <code class="literal">out_if</code> values), the sensor’s system uptime (<code class="literal">sys_uptime_ms</code>), and a host of other parameters—such as <code class="literal">AS</code> numbers (<code class="literal">src_AS</code> and <code class="literal">dst_AS</code>)—that may be useful for statistics or filtering purposes in various contexts. Once again, the output is ideally suited to filtering via regular expressions.</p><p>You don’t need to rely on external software for the initial filtering on the data you collect from your <code class="literal">pflow</code> sensor. <code class="literal">flowd</code> itself offers a range of filtering features that make it possible to store only the data you need. One approach is to put the filtering expressions in the <span class="emphasis"><em>flowd.conf</em></span>, as in the following example (with the comments stripped to save space):</p><a id="pro_id00351"/><pre class="programlisting">logfile "/var/log/flowd.compact"&#13;
listen on 192.0.2.105:3001&#13;
flow source 192.0.2.1&#13;
store SRC_ADDR&#13;
store DST_ADDR&#13;
store SRCDST_PORT&#13;
store PACKETS&#13;
store OCTETS&#13;
internalnet = "192.0.2.0/24"&#13;
unwired = "10.168.103.0/24"&#13;
discard src $internalnet&#13;
discard dst $internalnet&#13;
discard src $unwired&#13;
discard dst $unwired</pre><p>You can choose to store only certain fields in the flow records. For example, in configurations where there’s only one collector or agent, the <code class="literal">agent</code> field serves no useful purpose and doesn’t need to be stored. In this configuration, we choose to store only the source and destination address and port, the number of packets, and the number of octets.</p><p>You can limit the data you store even further. The macros <code class="literal">internalnet</code> and <code class="literal">unwired</code> expand to two NATed local networks, and the four <code class="literal">discard</code> lines following the macro definitions mean that <code class="literal">flowd</code> discards any data it receives about flows with either source or destination addresses in either of those local networks. The result is a more compact set of data, tailored to your specific needs, and you see only routable addresses and the address of the sensor gateway’s external interface:</p><a id="pro_id00352"/><pre class="programlisting">$ <span class="strong"><strong>sudo flowd-reader /var/log/flowd.compact | head</strong></span>&#13;
FLOW src [193.213.112.71]:38468 dst [192.0.2.1]:53 packets 1 octets 79&#13;
FLOW src [192.0.2.1]:53 dst [193.213.112.71]:38468 packets 1 octets 126&#13;
FLOW src [200.91.75.5]:33773 dst [192.0.2.1]:53 packets 1 octets 66&#13;
FLOW src [192.0.2.1]:53 dst [200.91.75.5]:33773 packets 1 octets 245&#13;
FLOW src [200.91.75.5]:3310 dst [192.0.2.1]:53 packets 1 octets 75&#13;
FLOW src [192.0.2.1]:53 dst [200.91.75.5]:3310 packets 1 octets 199&#13;
FLOW src [200.91.75.5]:2874 dst [192.0.2.1]:53 packets 1 octets 75&#13;
FLOW src [192.0.2.1]:53 dst [200.91.75.5]:2874 packets 1 octets 122&#13;
FLOW src [192.0.2.1]:15393 dst [158.37.91.134]:123 packets 1 octets 76&#13;
FLOW src [158.37.91.134]:123 dst [192.0.2.1]:15393 packets 1 octets 76</pre><p><a class="indexterm" id="iddle1339"/><a class="indexterm" id="iddle1947"/><a class="indexterm" id="iddle2018"/>Even with the verbose option, <code class="literal">flowd-reader</code>’s display reveals only what you explicitly specify in the filtering configuration:</p><a id="pro_id00353"/><pre class="programlisting">$ <span class="strong"><strong>sudo flowd-reader -v /var/log/flowd.compact | head</strong></span>&#13;
LOGFILE /var/log/flowd.compact&#13;
FLOW src [193.213.112.71]:38468 dst [192.0.2.1]:53 packets 1 octets 79&#13;
FLOW src [192.0.2.1]:53 dst [193.213.112.71]:38468 packets 1 octets 126&#13;
FLOW src [200.91.75.5]:33773 dst [192.0.2.1]:53 packets 1 octets 66&#13;
FLOW src [192.0.2.1]:53 dst [200.91.75.5]:33773 packets 1 octets 245&#13;
FLOW src [200.91.75.5]:3310 dst [192.0.2.1]:53 packets 1 octets 75&#13;
FLOW src [192.0.2.1]:53 dst [200.91.75.5]:3310 packets 1 octets 199&#13;
FLOW src [200.91.75.5]:2874 dst [192.0.2.1]:53 packets 1 octets 75&#13;
FLOW src [192.0.2.1]:53 dst [200.91.75.5]:2874 packets 1 octets 122&#13;
FLOW src [192.0.2.1]:15393 dst [158.37.91.134]:123 packets 1 octets 76</pre><p>Fortunately, <code class="literal">flowd</code> doesn’t force you to make all your filtering decisions when your collector receives the flow data from the sensor. Using the <code class="literal">-f</code> flag, you can specify a separate file with filtering statements to extract specific data from a larger set of collected flow data. For example, to see HTTP traffic to your Web server, you could write a filter that stores only flows with your Web server’s address and TCP port 80 as the destination or flows with your Web server and TCP port 80 as the source:</p><a id="pro_id00354"/><pre class="programlisting">webserver = 192.0.2.227&#13;
discard all&#13;
accept dst $webserver port 80 proto tcp&#13;
accept src $webserver port 80 proto tcp&#13;
store RECV_TIME&#13;
store SRC_ADDR&#13;
store DST_ADDR&#13;
store PACKETS&#13;
store OCTETS</pre><p>Assuming you stored the filter in <span class="emphasis"><em>towebserver.flowdfilter</em></span>, you could then extract traffic matching your filtering criteria from <span class="emphasis"><em>/var/log/flowd</em></span>, like this:</p><a id="pro_id00355"/><pre class="programlisting">$ <span class="strong"><strong>sudo flowd-reader -v -f towebserver.flowdfilter /var/log/flowd | tail</strong></span>&#13;
FLOW recv_time 2011-04-01T21:13:15.505524 src [89.250.115.174] dst&#13;
[192.0.2.227] packets 6 octets 414&#13;
FLOW recv_time 2011-04-01T21:13:15.505524 src [192.0.2.227] dst&#13;
[89.250.115.174] packets 4 octets 725&#13;
FLOW recv_time 2011-04-01T21:13:49.605833 src [216.99.96.53] dst [192.0.2.227]&#13;
packets 141 octets 7481&#13;
FLOW recv_time 2011-04-01T21:13:49.605833 src [192.0.2.227] dst [216.99.96.53]&#13;
packets 212 octets 308264&#13;
FLOW recv_time 2011-04-01T21:14:04.606002 src [91.121.94.14] dst [192.0.2.227]&#13;
packets 125 octets 6634&#13;
FLOW recv_time 2011-04-01T21:14:04.606002 src [192.0.2.227] dst [91.121.94.14]&#13;
packets 213 octets 308316&#13;
FLOW recv_time 2011-04-01T21:14:38.606384 src [207.46.199.44] dst&#13;
[192.0.2.227] packets 10 octets 642&#13;
FLOW recv_time 2011-04-01T21:14:38.606384 src [192.0.2.227] dst&#13;
[207.46.199.44] packets 13 octets 16438&#13;
FLOW recv_time 2011-04-01T21:15:14.606768 src [213.187.176.94] dst&#13;
[192.0.2.227] packets 141 octets 7469&#13;
FLOW recv_time 2011-04-01T21:15:14.606768 src [192.0.2.227] dst&#13;
[213.187.176.94] packets 213 octets 308278</pre><p><a class="indexterm" id="iddle1455"/><a class="indexterm" id="iddle1459"/><a class="indexterm" id="iddle1480"/><a class="indexterm" id="iddle1507"/><a class="indexterm" id="iddle1509"/><a class="indexterm" id="iddle1540"/><a class="indexterm" id="iddle1655"/><a class="indexterm" id="iddle1813"/><a class="indexterm" id="iddle1814"/><a class="indexterm" id="iddle1823"/><a class="indexterm" id="iddle1824"/><a class="indexterm" id="iddle1899"/>In addition to the filtering options demonstrated here, the <code class="literal">flowd</code> filtering functions take a number of other options. Some of those options will be familiar from other filtering contexts such as PF, including a range of network-oriented parameters; others are more oriented to extracting data on flows originating at specific dates or time periods and other storage-oriented parameters. The full story, as always, is found in <code class="literal">man flowd.conf</code>.</p><p>Once you’ve extracted the data you need, you have several tools available for processing and presenting your data.</p></div></div><div class="sect2" title="Collecting NetFlow Data with pfflowd"><div class="titlepage"><div><div><h3 class="title" id="collecting_netflow_data_with_pfflowd">Collecting NetFlow Data with pfflowd</h3></div></div></div><p>For systems that don’t support NetFlow data export via <code class="literal">pflow</code>, NetFlow support is available via the <code class="literal">pfflowd</code> package. As we already saw in the previous section, PF state table data maps very well to the NetFlow data model, and <code class="literal">pfflowd</code> is intended to record state changes from the local system’s <code class="literal">pfsync</code> device. Once enabled, <code class="literal">pfflowd</code> acts as a NetFlow sensor that converts <code class="literal">pfsync</code> data to NetFlow format for transmission to a NetFlow collector on the network.</p><p>The <code class="literal">pfflowd</code> tool was written and is maintained by Damien Miller and is available from <span class="emphasis"><em><a class="ulink" href="http://www.mindrot.org/projects/pfflowd/" target="_top">http://www.mindrot.org/projects/pfflowd/</a></em></span> as well as through the package systems on OpenBSD and FreeBSD as <span class="emphasis"><em>net/pfflowd</em></span>. The lack of <code class="literal">pfsync</code> support on NetBSD means that <code class="literal">pfflowd</code> isn’t available on that platform as of this writing.</p></div><div class="sect2" title="SNMP Tools and PF-Related SNMP MIBs"><div class="titlepage"><div><div><h3 class="title" id="snmp_tools_and_pf-related_snmp_mibs">SNMP Tools and PF-Related SNMP MIBs</h3></div></div></div><p><span class="emphasis"><em>Simple Network Management Protocol (SNMP)</em></span> was designed to let network administrators collect and monitor key data about how their systems run and change configurations on multiple network nodes from a centralized system.<sup>[<a class="footnote" epub:type="noteref" href="#ftn.ch09fn05" id="ch09fn05">48</a>]</sup> The SNMP protocol comes with a well-defined interface and a method for extending the <span class="emphasis"><em>management information base (MIB)</em></span>, which defines the managed devices and objects.</p><p><a class="indexterm" id="iddle1254"/><a class="indexterm" id="iddle1427"/><a class="indexterm" id="iddle1546"/>Both proprietary and open source network management and monitoring systems generally have SNMP support in one form or the other, and in some products, it’s a core feature. On the BSDs, SNMP support has generally come in the form of the <code class="literal">net-snmp</code> package, which provides the tools you need to retrieve SNMP data and to collect data for retrieval by management systems. The package is available on OpenBSD as <span class="emphasis"><em>net/net-snmp</em></span>, on FreeBSD as <span class="emphasis"><em>net-mgmt/net-snmp</em></span>, and on NetBSD as <span class="emphasis"><em>net/net-snmp</em></span>. OpenBSD’s <code class="literal">snmpd</code> (written mainly by Reyk Floeter) debuted as part of the base system in OpenBSD 4.3 and implements all required SNMP functionality. (See <code class="literal">man snmpd</code> and <code class="literal">man snmpd.conf</code> for details.)</p><p>There are MIBs to make PF data available to SNMP monitoring. Joel Knight maintains the MIBs for retrieving data on PF, CARP, and OpenBSD kernel sensors, and he offers them for download from <span class="emphasis"><em><a class="ulink" href="http://www.packetmischief.ca/openbsd/snmp/" target="_top">http://www.packetmischief.ca/openbsd/snmp/</a></em></span>. The site also offers patches to the <code class="literal">net-snmp</code> package to integrate the OpenBSD MIBs.</p><p>After installing the package and the extension, your SNMP-capable monitoring systems will be able to watch PF data in any detail you desire. (FreeBSD’s <code class="literal">bsnmpd</code> includes a PF module. See the <code class="literal">bsnmpd</code> man page for details.)</p></div></div><div class="sect1" title="Log Data as the Basis for Effective Debugging"><div class="titlepage"><div><div><h2 class="title" id="log_data_as_the_basis_for_effective_debu" style="clear: both">Log Data as the Basis for Effective Debugging</h2></div></div></div><p>In this chapter, we walked through the basics of collecting, displaying, and interpreting data about a running system with PF enabled. Knowing how to find and use information about how your system behaves is useful for several purposes.</p><p>Keeping track of the status of a running system is useful in itself, but the ability to read and interpret log data is even more essential when testing your setup. Another prime use for log data is to track the effect of changes you make in the configuration, such as when tuning your system to give optimal performance. In the next chapter, we’ll focus on checking your configuration and tuning it for optimal performance, based on log data and other observations.</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.ch09fn01"><p><sup>[<a class="para" href="#ch09fn01">44</a>] </sup>On OpenBSD, all <code class="literal">pftop</code> functionality is included in various <code class="literal">systat</code> views, as described in the previous section.</p></div><div class="footnote" epub:type="footnote" id="ftn.ch09fn02"><p><sup>[<a class="para" href="#ch09fn02">45</a>] </sup>The color values listed in the configuration example would give you a graph with red, blue, and green lines. For the print version of this book, we changed the colors to grayscale values: <code class="literal">0 192 0</code> became <code class="literal">105 105 105</code>, <code class="literal">0 0 255</code> became <code class="literal">192 192 192</code>, and <code class="literal">255 0 0</code> became <code class="literal">0 0 0</code>.</p></div><div class="footnote" epub:type="footnote" id="ftn.ch09fn03"><p><sup>[<a class="para" href="#ch09fn03">46</a>] </sup>For a more in-depth treatment of network analysis with NetFlow-based tools, see <span class="emphasis"><em>Network Flow Analysis</em></span> by Michael W. Lucas (No Starch Press, 2010).</p></div><div class="footnote" id="ftn.ch09fn04"><p><sup>[<a class="para" href="#ch09fn04">47</a>] </sup>The actively maintained project home pages for <code class="literal">flow-tools</code> and <code class="literal">nfdump</code> are <span class="emphasis"><em><a class="ulink" href="http://code.google.com/p/flow-tools/" target="_top">http://code.google.com/p/flow-tools/</a></em></span> and <span class="emphasis"><em><a class="ulink" href="http://nfdump.sourceforge.net/" target="_top">http://nfdump.sourceforge.net/</a></em></span>. (The older versions should still be available from <span class="emphasis"><em><a class="ulink" href="http://www.splintered.net/sw/flow-tools/" target="_top">http://www.splintered.net/sw/flow-tools/</a>.</em></span>) The <code class="literal">nfsen</code> Web frontend has a project page at <span class="emphasis"><em><a class="ulink" href="http://nfsen.sourceforge.net/" target="_top">http://nfsen.sourceforge.net/</a>.</em></span> For the latest information about <code class="literal">flowd</code>, visit <span class="emphasis"><em><a class="ulink" href="http://www.mindrot.org/flowd.html" target="_top">http://www.mindrot.org/flowd.html</a>.</em></span></p></div><div class="footnote" epub:type="footnote" id="ftn.ch09fn05"><p><sup>[<a class="para" href="#ch09fn05">48</a>] </sup>The protocol debuted with RFC 1067 in August 1988 and is now in its third major version as defined in RFCs 3411 through 3418.</p></div></div></section></body></html>