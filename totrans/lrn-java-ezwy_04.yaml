- en: '**4**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CREATING YOUR FIRST ANDROID APP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/circle.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To build the mobile version of the Hi-Lo guessing game app, we’re going to use
    Android Studio. If you didn’t set this up in [Chapter 1](ch1.xhtml#ch1), go back
    to “[Installing Android Studio for Mobile App Development](ch1.xhtml#toc_lev13)”
    on [page 8](ch1.xhtml#page_8) and set it up. As with the GUI version of the game,
    we’re going to create a user interface for the app, as shown in [Figure 4-1](ch4.xhtml#ch4fig1).
    The apps you’ve created so far could only be run on your desktop computer, but
    Android apps can run on any Android device, including phones, tablets, watches,
    TVs, and so on. If you don’t own an Android device, don’t worry—you can still
    code for Android, as the Android emulator that comes with Android Studio lets
    you simulate running a device.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0076-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-1: The guessing game will become a mobile app in this chapter. The
    app runs on a simulated Android phone (left) and on an actual Android tablet (right).*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-1](ch4.xhtml#ch4fig1) shows our app running on the Android emulator,
    simulating how the app looks on a Nexus 6P, and on an Android tablet. Both versions
    are running the same code—and, even more conveniently, we can reuse a lot of the
    Java code we built for the previous desktop versions because Android is built
    on Java!'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the emulator and the actual device look very similar, with some
    minor differences to account for the different screen sizes between the phone
    and the 7-inch tablet. In the same way that you can write a Java app for Windows
    and run it on macOS or Linux, you can write an Android mobile app in Java and
    run it on any of literally thousands of Android devices. Let’s get started building
    your first Android mobile app!
  prefs: []
  type: TYPE_NORMAL
- en: Starting a New Android Studio App Project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first time you start Android Studio, it may take a few minutes to update
    and run. When it starts, you’ll see a screen like the one shown in [Figure 4-2](ch4.xhtml#ch4fig2).
    Select the option labeled **Start a new Android Studio project**.
  prefs: []
  type: TYPE_NORMAL
- en: Name your new project *GuessingGame*, with no space. If you have a website,
    you can enter it in the Company Domain field, as shown in [Figure 4-3](ch4.xhtml#ch4fig3).
    Otherwise, leave the default example domain. Next, choose a project location.
    I’ve set up a folder called *AndroidProjects* to keep things organized, and you
    should do the same.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0077-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-2: Once Android Studio finishes setting up, choose* ***Start a new
    Android Studio project***.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0077-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-3: Name your new Android Studio project* GuessingGame, *with no space.*'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** after naming your project. Now you’ll have the opportunity to
    choose which Android version number your app should run on. The Android platform
    evolves rapidly as new devices and capabilities are developed, so we’ll need to
    pick a target. Fortunately, Android Studio is regularly updated with both the
    latest Android versions and information on how many devices still use the older
    versions. You’ll also need to select a *software development kit (SDK)* or *application
    program interface (API)* level when you choose which versions of Android to support.
    SDK and API levels include tools you’ll use to develop your app, but they’re tied
    to specific versions of Android. The Target Android Devices window, shown in [Figure
    4-4](ch4.xhtml#ch4fig4), allows you to choose a minimum SDK or API level for each
    app you develop.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0078-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-4: Choose the Minimum SDK level for the Android devices you’re developing
    for.*'
  prefs: []
  type: TYPE_NORMAL
- en: Choose **API 16 (Android 4.1, Jelly Bean)** as the minimum SDK for the guessing
    game app. Android Studio will tell you that this runs on more than 99 percent
    of active Android devices. Click **Next**.
  prefs: []
  type: TYPE_NORMAL
- en: The New Project wizard will ask you what kind of *activity* you want to add
    to your app. An activity is just something the user can do. Each activity usually
    has its own screen layout with a user interface, like the ones shown in [Figure
    4-5](ch4.xhtml#ch4fig5).
  prefs: []
  type: TYPE_NORMAL
- en: There are lots of choices for the main activity for an app, such as Google Maps,
    Login, Settings, Tabbed Activities, and more. The Basic Activity will give us
    a great foundation for the guessing game app, so choose that option and click
    **Next**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll use the default names provided by Android Studio on the following screen
    (shown in [Figure 4-6](ch4.xhtml#ch4fig6)): *MainActivity* for the activity name
    and *activity_main* for the layout name. The activity file contains the Java source
    code that runs the app. The layout is a separate file that contains the app interface.
    Click **Finish** to complete your app project setup.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0079-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-5: Choose Basic Activity as the basis for your app.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0079-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-6: Leave the default values for activity name and layout name.*'
  prefs: []
  type: TYPE_NORMAL
- en: The project may take a few moments to build, as Android Studio creates the project
    files and sets up the *GuessingGame* app project. After it finishes loading, Android
    Studio will open the project to a default view that looks like [Figure 4-7](ch4.xhtml#ch4fig7).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0080-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-7: The default project view in Android Studio, complete with a GUI
    mobile layout view*'
  prefs: []
  type: TYPE_NORMAL
- en: If your project doesn’t open with this screen, click the Project tab in the
    upper left, expand the *app* folder in the Project Explorer, expand the *res*
    (short for *resources*) folder, expand *layout*, and then double-click the *content_main.xml*
    file to see a view similar to [Figure 4-7](ch4.xhtml#ch4fig7).
  prefs: []
  type: TYPE_NORMAL
- en: Building the GUI Layout in Design View
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Android apps separate the layout from the app code (the activity), so this app
    will be a little different from the desktop app we wrote in [Chapter 3](ch3.xhtml#ch3).
    The layout isn’t described in Java but in *eXtensible Markup Language (XML)*.
    Fortunately, despite this difference, we can still use a drag-and-drop palette
    similar to Eclipse’s WindowBuilder Editor to design the GUI view. The main difference
    in Android Studio is that the components have been named with mobile apps in mind.
  prefs: []
  type: TYPE_NORMAL
- en: Like the WindowBuilder Editor, Android Studio has two tabs, one for the design
    view and one for the source code. Click the Design tab in the lower-left corner
    of the main window containing the *content_main.xml* file. You’ll see the design
    view shown in [Figure 4-8](ch4.xhtml#ch4fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0081-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-8: Android Studio has a design view similar to the WindowBuilder
    Editor in Eclipse.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-8](ch4.xhtml#ch4fig8) shows the four areas of the design view that
    we’ll be using the most: the Project Explorer pane ➊, the Palette pane ➋, the
    Preview pane ➌, and the Properties pane ➍.'
  prefs: []
  type: TYPE_NORMAL
- en: In the center of the Preview pane, you’ll see a label—known as a `TextView`
    in Android terminology—reading *Hello World!*. Click the label and press DELETE
    (or right-click and select **Delete** from the menu) to delete it from the Preview
    pane. Then, click the **Layouts** option in the Palette pane, select a **RelativeLayout**,
    and drag it either to the Preview pane or onto the ConstraintLayout (in [Figure
    4-8](ch4.xhtml#ch4fig8)) in the Component Tree listing just below the Palette
    pane. We’ll start with an empty RelativeLayout to build our guessing game GUI
    view.
  prefs: []
  type: TYPE_NORMAL
- en: In the Palette pane, under Widgets, select **TextView**. A `TextView` in Android
    is similar to a `JLabel` in the Swing toolkit, and *widgets* are what we call
    most of the GUI components in Android. We’ll drag and drop to place GUI components
    in the design preview.
  prefs: []
  type: TYPE_NORMAL
- en: Click the `TextView` widget and drag it over the white app background in the
    simulated Android phone, placing the widget near the top to serve as the title
    of your app.
  prefs: []
  type: TYPE_NORMAL
- en: After placing the title `TextView`, you’ll see options appear in the Properties
    pane on the right. If the pane doesn’t appear, click Properties in the upper-right
    corner of the Design tab to expand the Properties pane. Find the `text` property
    of the `TextView` widget you’ve just added. Change the text to `"``Your Name``'s
    Guessing Game"` and change the `textAppearance` property to **Large**. Then, drag
    the `TextView` to center it at the top of the screen as shown in [Figure 4-9](ch4.xhtml#ch4fig9).
    The gray dashed guideline helps with placement.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0082-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-9: Placing GUI widgets/components in Android Studio is very similar
    to the process in Eclipse.*'
  prefs: []
  type: TYPE_NORMAL
- en: To add the label prompting the user to enter a number between 1 and 100, place
    another `TextView` widget onto the design preview just a small distance below
    the title. Change the `textAppearance` property to **Medium** in the Properties
    pane on the right. Then, type `Enter a number between 1 and 100:` in the `text`
    property for the `TextView`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll place the text field, also known as an `EditText` in Android, for
    the user’s guess. Text fields are listed just below Widgets in the Palette pane.
    There are many types of text fields in Android, and each behaves differently depending
    on the needs of your app. For example, Plain Text is a simple text field, Password
    hides characters as they’re typed, Phone shows the numeric keypad and formats
    the input as a phone number, and E-mail shows a modified keyboard with the @ symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Choose a **Number** text field so the user can enter their guess from a numeric
    keyboard on their screen. Place this field just a little below the previous label.
    Then, place a Button widget an equal distance below the text field and change
    its `text` property to `"Guess!"`. Finally, place another `TextView` widget below
    the button, giving it a `text` property of `"Enter a number, then click Guess!"`.
    If you have trouble placing the widget the same distance below the button because
    you’re too close to the vertical center of the screen, place it lower or higher
    in the Properties pane under Layout_Margin (you may need to click **View all properties**
    and then click the gray arrow next to Layout_Margin to expand the margin properties),
    find **layout_marginTop**, and change the value to **30dp**. The finished GUI
    layout should look similar to [Figure 4-10](ch4.xhtml#ch4fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0083-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-10: The finished GUI layout for the Android guessing game app in
    design view*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll make one final change before naming the GUI components. Change the `width`
    property of the numeric text field, where the user enters their guess, to **75dp**;
    do so by clicking **View all properties** or the left-and-right arrow icon in
    the Properties pane. The original text field was too wide for a number-guessing
    game that uses only numbers between 1 and 100, so we’ve resized it to make it
    narrower.
  prefs: []
  type: TYPE_NORMAL
- en: With that small change, it’s time to start naming our GUI components so we’ll
    be able to find them easily in the Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Naming GUI Components in Android Studio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as we named GUI components in Eclipse, we’ll need to name the GUI elements
    in Android Studio so that we can access them from the code. But in Android Studio,
    the names of the GUI elements themselves won’t appear in the Java source code
    by default. Instead, we’ll have to connect these XML GUI components to the Java
    code by hand before we can use them in the code.
  prefs: []
  type: TYPE_NORMAL
- en: For now, though, we just need to change the `id` property of the number text
    field, the guess button, and the bottommost label to `txtGuess`, `btnGuess`, and
    `lblOutput`, respectively. If a pop-up message asks you to update usages, click
    **Yes**. We’ll use these names for consistency and convenience. [Figure 4-11](ch4.xhtml#ch4fig11)
    shows the renamed text field, button, and label.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0084-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-11: Rename the `EditText`, `Button`, and `TextView` components (circled)
    by changing their id properties to `txtGuess`, `btnGuess`, and `lblOutput`, respectively.*'
  prefs: []
  type: TYPE_NORMAL
- en: One last thing we should do before we start coding in Java is hide the small
    *floating action button (fab)* icon, shown in the bottom right of the design preview
    in [Figure 4-12](ch4.xhtml#ch4fig12). Your project may not show the fab icon,
    but if it does, double-click the *activity_main.xml* file in the Project Explorer
    pane ➊. Click the *activity_main.xml* tab above the design view ➋ and then click
    the fab icon ➌. Go to Properties and set the `visibility` property to **invisible**
    ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0084-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-12: Hide the fab icon by going to the* activity_main.xml *file, clicking
    the small envelope icon, and setting the* `*visibility*` *property to invisible.*'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve chosen to set the fab icon to invisible rather than delete it entirely,
    because you might want to use the floating action button to add new features to
    your app later on. The floating action button can share info from the app to Facebook,
    post a tweet in Twitter about how much you like the app, send an email to a friend
    about the app, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll wire up the GUI so that we can use it in Java to program the rest
    of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the GUI to Java in Android Studio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to connect the GUI to Java so we can write the code for the guessing
    game app. First, let’s open the Java source code file by looking in the Project
    Explorer pane, under *app* ▸ *src* ▸ *main* ▸ *java* ▸ *com.example.guessinggame*
    (or your package name) ▸ *MainActivity*. Double-click *MainActivity* to open the
    *MainActivity.java* source code file.
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed the *java* folder in the Project Explorer has another package
    or two, possibly labeled the same, but with *(test)* or *(androidTest)* after
    the package name. These packages are used for testing in larger applications,
    where engineers evaluate app quality, security, and functionality for software
    quality assurance. We won’t tackle quality assurance, but it’s a great way to
    get into the software development industry.
  prefs: []
  type: TYPE_NORMAL
- en: The Java source code inside the *MainActivity.java* file will look something
    like [Figure 4-13](ch4.xhtml#ch4fig13).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0085-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-13: The Java source code for the app is called* MainActivity.java
    *by default.*'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that in Android Studio, a package declaration appears at the very top
    of the file by default. Packages help us organize all the files needed in a more
    complex program, such as a mobile app. In this case, the package name is the company
    domain name from the Create New Project screen back in [Figure 4-3](ch4.xhtml#ch4fig3)
    on [page 77](ch4.xhtml#page_77), but in reverse order—notice the *com* comes first.
  prefs: []
  type: TYPE_NORMAL
- en: Several Android `import` statements follow the package declaration. These work
    just as they do for Java on the desktop, importing existing features and functionality
    into the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `public class MainActivity` code snippet may be slightly different
    for you depending on the minimum API level you chose for your app, but the overall
    code will be similar, and the app we’re writing will work across multiple API
    levels. First we’ll declare our variables to connect the GUI to the program. Click
    just inside the opening brace for the class, on the next line down, and add these
    lines to declare variables for the text field, button, and output label:'
  prefs: []
  type: TYPE_NORMAL
- en: public class MainActivity extends AppCompatActivity {
  prefs: []
  type: TYPE_NORMAL
- en: private EditText txtGuess;
  prefs: []
  type: TYPE_NORMAL
- en: private Button btnGuess;
  prefs: []
  type: TYPE_NORMAL
- en: private TextView lblOutput;
  prefs: []
  type: TYPE_NORMAL
- en: As you enter each new variable type, you may see a drop-down menu offering to
    import it (`android.widget.EditText`, for example). If you click the correct widget
    type to import, Android Studio will add the corresponding `import` statement for
    you. If you typed the three lines without clicking to accept the automatic imports,
    just click each widget type and then press ALT-ENTER (or OPTION-ENTER on macOS)
    to import any missing classes, as shown in [Figure 4-14](ch4.xhtml#ch4fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0086-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-14: Android Studio enables you to automatically import classes just
    as Eclipse did, either as you type or afterward with a simple key combination
    (**ALT**-**ENTER*, *or* *OPTION**-**ENTER* *on macOS).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following three `import` statements should now appear with the others near
    the top of your file:'
  prefs: []
  type: TYPE_NORMAL
- en: import android.widget.EditText;
  prefs: []
  type: TYPE_NORMAL
- en: import android.widget.Button;
  prefs: []
  type: TYPE_NORMAL
- en: import android.widget.TextView;
  prefs: []
  type: TYPE_NORMAL
- en: After declaring the three variables for the GUI widgets, we need to connect
    those variables to the XML components for each one. We’ll do this in the `onCreate()`
    method, shown at the bottom of [Figure 4-14](ch4.xhtml#ch4fig14), which is the
    function that runs when the app is loaded. Android Studio has automatically generated
    the code to begin this method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look inside the top two or three lines of the `onCreate()` method, and find
    this line:'
  prefs: []
  type: TYPE_NORMAL
- en: setContentView(R.layout.activity_main);
  prefs: []
  type: TYPE_NORMAL
- en: 'Right after that line, press ENTER a couple of times and type the following
    partial line of code to begin connecting the variable `txtGuess` to the `EditText`
    widget in the XML layout file:'
  prefs: []
  type: TYPE_NORMAL
- en: txtGuess = (EditText) findViewById(R.id.
  prefs: []
  type: TYPE_NORMAL
- en: The `findViewById()` function is how we connect GUI widgets in the XML layout
    to the variables we’ll use to represent them in the source code. The `R` inside
    that function refers to a special file called *R.java* that Android Studio generates
    to make it possible to connect resources. The `R` is short for *resources*, usually
    stored in the *res* folder in the project. As you begin to type the preceding
    line, you’ll see a pop-up menu like the one shown in [Figure 4-15](ch4.xhtml#ch4fig15).
    Find and double-click `txtGuess` in the drop-down list of options. If you don’t
    see the `txtGuess` option, go back to the design view for *content _main.xml*
    and make sure you gave the text field the `id` property of `txtGuess`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finish with the closing parenthesis followed by a semicolon, as shown in the
    following listing, and then set up the button and output label. The finished three
    lines of code inside your `onCreate()` method should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: protected void onCreate(Bundle savedInstanceState) {
  prefs: []
  type: TYPE_NORMAL
- en: super.onCreate(savedInstanceState);
  prefs: []
  type: TYPE_NORMAL
- en: setContentView(R.layout.*activity_main*);
  prefs: []
  type: TYPE_NORMAL
- en: txtGuess = (EditText) findViewById(R.id.*txtGuess*);
  prefs: []
  type: TYPE_NORMAL
- en: btnGuess = (Button) findViewById(R.id.*btnGuess*);
  prefs: []
  type: TYPE_NORMAL
- en: lblOutput = (TextView) findViewById(R.id.*lblOutput*);
  prefs: []
  type: TYPE_NORMAL
- en: If everything has been named correctly in the layout, these lines of code should
    connect the variables `txtGuess`, `btnGuess`, and `lblOutput` to the `EditText`,
    `Button`, and `TextView` components in the GUI layout. This is a good time to
    stop and save your project to capture the progress you’ve made so far.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0088-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-15: Android Studio helps us “wire up” the Java code to the GUI resources
    in the layout with helpful drop-down options.*'
  prefs: []
  type: TYPE_NORMAL
- en: Adding Methods to Check the Guess and Begin a New Game
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now, let’s work on writing the code for the `checkGuess()` function. We can
    begin writing the `checkGuess()` method just below the variable declarations for
    `txtGuess`, `btnGuess`, and `lblOutput` and just above the `onCreate()` method,
    as shown in [Figure 4-16](ch4.xhtml#ch4fig16).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to get the user’s guess from the GUI text field and store it
    in a `String` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: public class MainActivity extends AppCompatActivity {
  prefs: []
  type: TYPE_NORMAL
- en: private EditText txtGuess;
  prefs: []
  type: TYPE_NORMAL
- en: private Button btnGuess;
  prefs: []
  type: TYPE_NORMAL
- en: private TextView lblOutput;
  prefs: []
  type: TYPE_NORMAL
- en: public void checkGuess() {
  prefs: []
  type: TYPE_NORMAL
- en: String guessText = txtGuess.getText().toString();
  prefs: []
  type: TYPE_NORMAL
- en: The code to get the user’s guess from the text field looks almost the same as
    in the desktop version of the app, except for the additional`.toString()` method
    at the end. There is a separate `Text` class in Android and the text that is entered
    into a text field is a `Text` object, so we have to convert that object to a `String`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0089-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-16: Beginning to write the checkGuess() method in Java*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the rest of the `checkGuess()` method can be copied and pasted
    directly from the Eclipse desktop GUI version of the app from [Chapter 3](ch3.xhtml#ch3),
    with no changes! The complete `checkGuess()` method should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: public void checkGuess() {
  prefs: []
  type: TYPE_NORMAL
- en: ➊ String guessText = txtGuess.getText().toString();
  prefs: []
  type: TYPE_NORMAL
- en: String message = "";
  prefs: []
  type: TYPE_NORMAL
- en: ➋ try {
  prefs: []
  type: TYPE_NORMAL
- en: ➌ int guess = Integer.*parseInt*(guessText);
  prefs: []
  type: TYPE_NORMAL
- en: if (guess < theNumber)
  prefs: []
  type: TYPE_NORMAL
- en: message = guess + " is too low. Try again.";
  prefs: []
  type: TYPE_NORMAL
- en: else if (guess > theNumber)
  prefs: []
  type: TYPE_NORMAL
- en: message = guess + " is too high. Try again.";
  prefs: []
  type: TYPE_NORMAL
- en: else {
  prefs: []
  type: TYPE_NORMAL
- en: message = guess +
  prefs: []
  type: TYPE_NORMAL
- en: '" is correct. You win! Let''s play again!";'
  prefs: []
  type: TYPE_NORMAL
- en: newGame();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: ➍ } catch (Exception e) {
  prefs: []
  type: TYPE_NORMAL
- en: message = "Enter a whole number between 1 and 100.";
  prefs: []
  type: TYPE_NORMAL
- en: ➎ } finally {
  prefs: []
  type: TYPE_NORMAL
- en: lblOutput.setText(message);
  prefs: []
  type: TYPE_NORMAL
- en: txtGuess.requestFocus();
  prefs: []
  type: TYPE_NORMAL
- en: txtGuess.selectAll();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: One of the convenient features of Java is that we can reuse code across platforms.
    Just as we used code from the command line game to make the desktop game, we can
    use code from the desktop version in the Android version. Let’s review this code
    to understand how it will work in the Android app.
  prefs: []
  type: TYPE_NORMAL
- en: At ➊, we get the user’s guess from the text field and set up a string for the
    output message. At ➋, we begin a `try-catch-finally` statement to handle user
    input errors or exceptions. Inside the `try` block, at ➌, we parse the integer
    number of the user’s guess from the characters they enter. The rest of the `try`
    block contains the `if-else` statements that test whether the user guessed too
    high or too low, set the appropriate message, and start a new game. Next, the
    `catch` statement ➍ that tells the user to enter a whole number between 1 and
    100\. Then, the `finally` block ➎ sets the text on the `lblOutput` widget to the
    appropriate `message`, returns the cursor to the text field, and highlights the
    text to prepare for the user’s next guess.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that there are a couple of items underlined in red: `theNumber`
    and `newGame()`. This is because we haven’t defined them yet in this version of
    our app.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the `MainActivity` class, below the three GUI widget declarations,
    add a declaration for the secret number, `theNumber`:'
  prefs: []
  type: TYPE_NORMAL
- en: public class MainActivity extends AppCompatActivity {
  prefs: []
  type: TYPE_NORMAL
- en: private EditText txtGuess;
  prefs: []
  type: TYPE_NORMAL
- en: private Button btnGuess;
  prefs: []
  type: TYPE_NORMAL
- en: private TextView lblOutput;
  prefs: []
  type: TYPE_NORMAL
- en: private int theNumber;
  prefs: []
  type: TYPE_NORMAL
- en: This is the same code we used in the desktop game, because the Java code to
    create an integer is the same across the command line, desktop, and Android mobile
    versions of the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for the `newGame()` method is also the same as the desktop version.
    Add the `newGame()` method just before the `onCreate()` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: public void newGame() {
  prefs: []
  type: TYPE_NORMAL
- en: theNumber = (int)(Math.*random*() * 100 + 1);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: protected void onCreate(Bundle savedInstanceState) {
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new game in the Android app is just like doing so in the desktop
    app. We just set `theNumber` to a random integer from 1 to 100, using the `Math.random()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a call to `newGame()` inside the `onCreate()` method after the code
    that connects the three GUI components:'
  prefs: []
  type: TYPE_NORMAL
- en: protected void onCreate(Bundle savedInstanceState) {
  prefs: []
  type: TYPE_NORMAL
- en: super.onCreate(savedInstanceState);
  prefs: []
  type: TYPE_NORMAL
- en: setContentView(R.layout.*activity_main*);
  prefs: []
  type: TYPE_NORMAL
- en: txtGuess = (EditText) findViewById(R.id.*txtGuess*);
  prefs: []
  type: TYPE_NORMAL
- en: btnGuess = (Button) findViewById(R.id.*btnGuess*);
  prefs: []
  type: TYPE_NORMAL
- en: lblOutput = (TextView) findViewById(R.id.*lblOutput*);
  prefs: []
  type: TYPE_NORMAL
- en: newGame();
  prefs: []
  type: TYPE_NORMAL
- en: When the game starts up, the program will call the `newGame()` method and pick
    a random number for the user to guess. Now, we just need to handle the button
    click event and learn how to run the app on our own Android device or on the Android
    emulator.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Events in Android
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Eclipse, we were able to add an event listener to the guess button just by
    double-clicking it in the design view. Unfortunately, it’s not that easy in Android
    Studio, because the GUI layout is separate from the source code. Fortunately,
    Android Studio helps us add event listeners by providing *code completion* options,
    similar to the content assist feature in Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a listener for button clicks, begin typing the following partial line
    of code inside the `onCreate()` method on the next line after the call to `newGame()`:'
  prefs: []
  type: TYPE_NORMAL
- en: txtGuess = (EditText) findViewById(R.id.txtGuess);
  prefs: []
  type: TYPE_NORMAL
- en: btnGuess = (Button) findViewById(R.id.*btnGuess*);
  prefs: []
  type: TYPE_NORMAL
- en: lblOutput = (TextView) findViewById(R.id.*lblOutput*);
  prefs: []
  type: TYPE_NORMAL
- en: newGame();
  prefs: []
  type: TYPE_NORMAL
- en: btnGuess.setOn
  prefs: []
  type: TYPE_NORMAL
- en: Android Studio’s code completion feature will pop up with a list of code recommendations,
    as shown in [Figure 4-17](ch4.xhtml#ch4fig17). Choose `setOnClickListener()` from
    the list of options and double-click to add it to your program.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the parentheses for `btnGuess.setOnClickListener()`, type `new` and start
    typing `OnClickListener`. Android Studio’s code completion feature will display
    a list of options, as shown in [Figure 4-18](ch4.xhtml#ch4fig18).
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose `OnClickListener` from the list of options, and you’ll see Android Studio
    adds a few extra lines of code. Your event listener code for the `btnGuess` button
    should now look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: btnGuess.setOnClickListener(new View.OnClickListener() {
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public void onClick(View v) {
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: Look familiar? This is another example of an anonymous inner class. The desktop
    version also had an anonymous inner class, but it was named slightly differently.
    The two will work virtually identically. You may have noticed that Android inserts
    `@Override` in several places. This is called a *compiler directive*, and it tells
    the compiler that you’re implementing your own version of a method in the parent
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0092-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-17: Android Studio’s code completion feature suggests code as we
    type, similar to Eclipse’s content assist feature.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0092-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-18: Use the code completion feature to create a new OnClickListener
    to add to the button btnGuess.*'
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks the Guess! button, we need to check their guess against
    the secret number. Add `checkGuess();` inside the braces of the `onClick()` method.
  prefs: []
  type: TYPE_NORMAL
- en: public void onClick(View v) {
  prefs: []
  type: TYPE_NORMAL
- en: checkGuess();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'The guessing game mobile app is now ready for its first run. The fully functional
    code for this first version of the guessing game is shown here. Your version may
    differ slightly, perhaps with a couple of extra methods for handling menu items,
    but because we’re not using the menu, these have been removed for space (see [Chapter
    5](ch5.xhtml#ch5) to learn how to create options menus and settings):'
  prefs: []
  type: TYPE_NORMAL
- en: package com.brysonpayne.guessinggame;
  prefs: []
  type: TYPE_NORMAL
- en: import android.os.Bundle;
  prefs: []
  type: TYPE_NORMAL
- en: import android.support.design.widget.FloatingActionButton;
  prefs: []
  type: TYPE_NORMAL
- en: import android.support.design.widget.Snackbar;
  prefs: []
  type: TYPE_NORMAL
- en: import android.support.v7.app.AppCompatActivity;
  prefs: []
  type: TYPE_NORMAL
- en: import android.support.v7.widget.Toolbar;
  prefs: []
  type: TYPE_NORMAL
- en: import android.view.View;
  prefs: []
  type: TYPE_NORMAL
- en: import android.view.Menu;
  prefs: []
  type: TYPE_NORMAL
- en: import android.view.MenuItem;
  prefs: []
  type: TYPE_NORMAL
- en: import android.widget.EditText;
  prefs: []
  type: TYPE_NORMAL
- en: import android.widget.Button;
  prefs: []
  type: TYPE_NORMAL
- en: import android.widget.TextView;
  prefs: []
  type: TYPE_NORMAL
- en: import org.w3c.dom.Text;
  prefs: []
  type: TYPE_NORMAL
- en: public class MainActivity extends AppCompatActivity {
  prefs: []
  type: TYPE_NORMAL
- en: private EditText txtGuess;
  prefs: []
  type: TYPE_NORMAL
- en: private Button btnGuess;
  prefs: []
  type: TYPE_NORMAL
- en: private TextView lblOutput;
  prefs: []
  type: TYPE_NORMAL
- en: private int theNumber;
  prefs: []
  type: TYPE_NORMAL
- en: public void checkGuess() {
  prefs: []
  type: TYPE_NORMAL
- en: String guessText = txtGuess.getText().toString();
  prefs: []
  type: TYPE_NORMAL
- en: String message = "";
  prefs: []
  type: TYPE_NORMAL
- en: try {
  prefs: []
  type: TYPE_NORMAL
- en: int guess = Integer.*parseInt*(guessText);
  prefs: []
  type: TYPE_NORMAL
- en: if (guess < theNumber)
  prefs: []
  type: TYPE_NORMAL
- en: message = guess + " is too low. Try again.";
  prefs: []
  type: TYPE_NORMAL
- en: else if (guess > theNumber)
  prefs: []
  type: TYPE_NORMAL
- en: message = guess + " is too high. Try again.";
  prefs: []
  type: TYPE_NORMAL
- en: else {
  prefs: []
  type: TYPE_NORMAL
- en: message = guess +
  prefs: []
  type: TYPE_NORMAL
- en: '" is correct. You win! Let''s play again!";'
  prefs: []
  type: TYPE_NORMAL
- en: newGame();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (Exception e) {'
  prefs: []
  type: TYPE_NORMAL
- en: message = "Enter a whole number between 1 and 100.";
  prefs: []
  type: TYPE_NORMAL
- en: '} finally {'
  prefs: []
  type: TYPE_NORMAL
- en: lblOutput.setText(message);
  prefs: []
  type: TYPE_NORMAL
- en: txtGuess.requestFocus();
  prefs: []
  type: TYPE_NORMAL
- en: txtGuess.selectAll();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: public void newGame() {
  prefs: []
  type: TYPE_NORMAL
- en: theNumber = (int)(Math.*random*() * 100 + 1);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: protected void onCreate(Bundle savedInstanceState) {
  prefs: []
  type: TYPE_NORMAL
- en: super.onCreate(savedInstanceState);
  prefs: []
  type: TYPE_NORMAL
- en: setContentView(R.layout.*activity_main*);
  prefs: []
  type: TYPE_NORMAL
- en: txtGuess = (EditText) findViewById(R.id.*txtGuess*);
  prefs: []
  type: TYPE_NORMAL
- en: btnGuess = (Button) findViewById(R.id.*btnGuess*);
  prefs: []
  type: TYPE_NORMAL
- en: lblOutput = (TextView) findViewById(R.id.*lblOutput*);
  prefs: []
  type: TYPE_NORMAL
- en: newGame();
  prefs: []
  type: TYPE_NORMAL
- en: btnGuess.setOnClickListener(new View.OnClickListener() {
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public void onClick(View v) {
  prefs: []
  type: TYPE_NORMAL
- en: checkGuess();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: Toolbar toolbar = (Toolbar) findViewById(R.id.*toolbar*);
  prefs: []
  type: TYPE_NORMAL
- en: setSupportActionBar(toolbar);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: In the next two sections, you’ll learn how to run the app on the Android emulator
    and on real Android devices.
  prefs: []
  type: TYPE_NORMAL
- en: Running the App on the Android Emulator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we have a working version of the Java code to run the app, but we still
    need to test it. Unlike the command line and desktop apps, the mobile app can’t
    run on a PC by itself, because PCs don’t have the Android operating system. To
    run your app for testing, you’ll need either an Android device or an emulator
    that will simulate an Android device on your PC. In this section, we’ll create
    an Android virtual device for testing your apps.
  prefs: []
  type: TYPE_NORMAL
- en: While viewing the *MainActivity.java* file, press the run button or select the
    menu item **Run** ▸ **Run ‘app’**. A pop-up window will ask you to select a *deployment
    target*, which is a device you want to run the app on, as shown in [Figure 4-19](ch4.xhtml#ch4fig19).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0095-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-19: To run an Android app, you must choose a target device—either
    an emulator or an actual device.*'
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Create New Virtual Device** button to begin configuring a new *Android
    virtual device (AVD)*. Let’s begin by choosing the type of device, as shown in
    [Figure 4-20](ch4.xhtml#ch4fig20). Then click **Next**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0095-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-20: Choose a device to emulate.*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll select a Nexus 6P to start with, but feel free to test out other devices.
    If you decide to develop your own app for the Google Play Store, you’ll want to
    test it across a variety of screen sizes and device types, so you can try setting
    up several different emulators. But let’s start small for now with just one.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to select the system image, usually either x86 or ARM. We’ll be
    using an ARM image, so click the **Other Images** tab, as shown in [Figure 4-21](ch4.xhtml#ch4fig21).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0096-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-21: You can choose either an x86 or ARM emulator; ARM is slower but
    tends to work more consistently on different types of processors.*'
  prefs: []
  type: TYPE_NORMAL
- en: If the Android version, API level, or emulator you want is displayed in a gray
    font, click the **Download** link for the version you want.
  prefs: []
  type: TYPE_NORMAL
- en: Click **Next** when you’ve chosen the Android emulator you want. For now, let’s
    use the Nougat API 24 ARM Android 7.0 version with Google APIs. You’ll see a final
    screen asking you to verify your configuration, including any advanced settings
    changes you want to make. Let’s change the name of the AVD, the device you’re
    emulating, to *My Nexus 6P*, as shown in [Figure 4-22](ch4.xhtml#ch4fig22).
  prefs: []
  type: TYPE_NORMAL
- en: If you have trouble getting your emulator to run on an older computer or on
    a computer with less than 8 GB of RAM, click **Show Advanced Settings**, scroll
    down to Memory and Storage, and change the RAM amount to **768 MB**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0097-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-22: Name your new AVD.*'
  prefs: []
  type: TYPE_NORMAL
- en: Click **Finish**, and your new device will be created and saved to disk. Now
    it’s time to start the emulator and try out your device. You should see the Select
    Deployment Target window again, but this time, it shows *My Nexus 6P* as an available
    emulator. Now click **OK**, as shown in [Figure 4-23](ch4.xhtml#ch4fig23).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0097-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-23: Choose the emulator you just created as your deployment target.*'
  prefs: []
  type: TYPE_NORMAL
- en: After a few moments, you’ll see the message “Starting AVD,” followed by an emulator
    window that looks like an Android startup screen, as shown in [Figure 4-24](ch4.xhtml#ch4fig24).
    This could take *several* minutes the first time you run the emulator. When the
    emulator starts up, you might see a lock screen.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0098-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-24: The Android emulator booting up (left); the Android virtual device’s
    home screen (right)*'
  prefs: []
  type: TYPE_NORMAL
- en: If your emulator shows a lock screen, click the lock at the bottom of the screen
    and drag it up to unlock the virtual device, similar to swiping the lock upward
    on an actual Android phone. You might see a welcome screen or two, but feel free
    to click out of those until you reach the home screen, which is shown in [Figure
    4-24](ch4.xhtml#ch4fig24).
  prefs: []
  type: TYPE_NORMAL
- en: Now, go back to Android Studio and press the run button again. This time, you’ll
    see your AVD in the Select Deployment Target dialog (see [Figure 4-25](ch4.xhtml#ch4fig25)).
    Choose your device and click **OK**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0098-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-25: The emulator appears in the list of connected devices when running.*'
  prefs: []
  type: TYPE_NORMAL
- en: The project will build one more time, and then it will transfer the executable
    version of the app to the emulator. (You may be asked to update your Android SDK
    Tools the first time you run the emulator.) After a few minutes, you’ll see your
    guessing game app running on the emulator!
  prefs: []
  type: TYPE_NORMAL
- en: We’ve coded the full app, so you should be able to play the game right away
    on your emulator. Take a look at [Figure 4-26](ch4.xhtml#ch4fig26) to see what
    a round of the game might look like on the app.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0099-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-26: The guessing game app running on the emulator screen (left),
    after one guess (center), and after a winning guess (right).*'
  prefs: []
  type: TYPE_NORMAL
- en: It works just like the desktop app, but on an Android emulator. Use your keyboard
    to type a guess and your mouse to click the Guess! button. There are a couple
    more things we’ll do to improve the user experience, just like we did with the
    GUI desktop app, but our Android mobile app is fully functional!
  prefs: []
  type: TYPE_NORMAL
- en: Before we improve the UX, we’ll cover how to run the app on a real Android device.
    For now, leave your Android emulator open. You can minimize it when you’re not
    using it, but leave it running in the background while programming to avoid the
    long startup time.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you don’t have an Android device, you can skip to “[Improving the UX](ch3.xhtml#toc_lev55)”
    on [page 102](ch4.xhtml#page_102).*'
  prefs: []
  type: TYPE_NORMAL
- en: Running the App on a Real Android Device
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Running the app on a real Android device can take some time and preparation,
    but if you have a USB cable to connect your device to your computer, you’ll be
    up and running quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '*Preparing Your Device*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before you can deploy your own apps to your Android device, you have to enable
    Developer mode on the device. You’ll also need to change a couple of settings
    to allow you to develop and debug apps.
  prefs: []
  type: TYPE_NORMAL
- en: On your Android device, tap **Settings** and then scroll to the bottom of the
    Settings menu to find the About tablet, About phone, or About device section.
    At the bottom of the About screen, you’ll find the Build number entry. Tap the
    build number at least seven times to enable the secret Developer mode. Developer
    mode allows you to test the apps you develop on your own device. [Figure 4-27](ch4.xhtml#ch4fig27)
    shows the Settings menu (left) and the About menu (center) with Developer mode
    unlocked.
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve unlocked Developer mode, tap the back arrow in the upper-left corner
    of the About screen and open **Settings** ▸ **Developer options**. Make sure the
    Developer options are turned **On**, as shown in [Figure 4-27](ch4.xhtml#ch4fig27)
    (right). You should also turn on USB debugging.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0100-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-27: The Settings menu on an Android Nexus 7 tablet (left), the About
    menu (center), and the Developer options (right).*'
  prefs: []
  type: TYPE_NORMAL
- en: Now you’re ready to connect an Android phone, tablet, or other device to your
    computer and run your app.
  prefs: []
  type: TYPE_NORMAL
- en: '*Connecting Your Device*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To connect an Android device to your computer, you’ll need a USB cable, preferably
    the one that came with your phone or tablet. It should be a micro-USB cable, and
    it is often supplied as part of the charger for your device. Note that not all
    charger cables are fully functional USB cables—if your cable doesn’t work after
    you complete the following steps, try a different one.
  prefs: []
  type: TYPE_NORMAL
- en: Connect your device to your computer using the USB cable. After you plug in,
    the screen on your phone or tablet will show a window like the one in [Figure
    4-28](ch4.xhtml#ch4fig28) asking whether you want to allow USB debugging from
    the computer you just attached to. Tap **OK**. You can select the checkbox beside
    **Always allow from this computer** to prevent the pop-up next time you connect
    by USB to the same computer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0101-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-28: When you connect your Android device to your computer for the
    first time, it will ask whether you want to allow USB debugging.*'
  prefs: []
  type: TYPE_NORMAL
- en: Allowing USB debugging enables a couple of things. First, we’ll be able to transfer
    the apps we program right to the Android device by transferring an *Android package
    file (APK)*. This is usually much faster than running apps on an emulator, and
    it’s a better way to test how the apps will behave on a real device. Also, we’ll
    be able to debug apps using the USB connection, meaning we’ll get information
    back from the Android device to help us debug. This information will include errors
    and other log entries that we’ll be able to read in a console-like application
    (called *logcat* in Android Studio). This is similar to the console output we
    used to find bugs in our command line and desktop GUI Java apps.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve connected a real Android device to your computer, let’s see
    how to run the guessing game app on it!
  prefs: []
  type: TYPE_NORMAL
- en: '*Running the App on Your Device*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now we’re ready to try the app on the Android device. In Android Studio, press
    the run button or go to **Run** ▸ **Run ‘app’**. This time, the Select Deployment
    Target window will show *two* connected devices to choose from, as shown in [Figure
    4-29](ch4.xhtml#ch4fig29): your emulator (My Nexus 6P) and your real Android device.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0102-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-29: If you’ve unlocked Developer mode, enabled USB debugging, and
    connected your device successfully, you should be able to select your Android
    device to run your app.*'
  prefs: []
  type: TYPE_NORMAL
- en: Choose your real Android device this time and click **OK**. Android Studio may
    take a moment to build the application, but once it transfers the APK file to
    your device, you’ll see the guessing game app open right up on your tablet or
    phone. Play a round or two to verify that it works just as it did on the emulator
    (maybe even better, or at least faster). Very cool!
  prefs: []
  type: TYPE_NORMAL
- en: 'You may notice one important difference right away: the bottom part of the
    screen is covered by the numeric keypad, as shown in [Figure 4-30](ch4.xhtml#ch4fig30).'
  prefs: []
  type: TYPE_NORMAL
- en: When we placed the text field (`EditText`) for the user’s guess, we chose a
    Number text field for our input so the numeric keypad would show up. But since
    the emulator runs on a computer, which has its own keyboard, you probably didn’t
    see this when you ran your app earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re able to run Android apps on an Android phone, tablet, or other
    device, let’s make a few final improvements to the user experience for the guessing
    game app.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0102-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-30: The app runs on your own Android device and shows the numeric
    keypad by default.*'
  prefs: []
  type: TYPE_NORMAL
- en: Improving the UX
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The guessing game app works beautifully on both the Android emulator and on
    real Android devices, but there are a few UX items we can improve upon. First,
    we’ll center the user’s guess in the Number text field. Second, we’ll learn how
    to treat the ENTER key just like the Guess! button to make the app more intuitive
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: '*Centering the User’s Guess in the Text Field*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In Android Studio, open the *content_main.xml* layout file again. Select the
    text field, called `txtGuess`, by clicking it in the design preview. Under the
    Properties pane, find **textAlignment**. The `textAlignment` property in Android
    is similar to the `horizontalAlignment` property in the desktop GUI—it allows
    us to change the alignment of the text the user enters.
  prefs: []
  type: TYPE_NORMAL
- en: Click the center text alignment option, the icon that looks like centered text.
    If you want to test it in the design preview without running the app, scroll to
    find the `text` property and enter a value of `50`. The number should appear centered
    in the text field in the design preview pane. Be sure to delete the test value
    if you don’t want it to show up in the actual app.
  prefs: []
  type: TYPE_NORMAL
- en: '*Adding a Listener for the Enter Key*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s set up an event listener to handle the ENTER key the same way we handled
    a click on the Guess! button, with a call to `checkGuess()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the *MainActivity.java* source code file, scroll down to the `onCreate()`
    method, and find where we added an `onClickListener` to the button `btnGuess`.
    (You may need to *expand* the event listener code by clicking the + in the left
    margin beside `btnGuess.setOnClickListener()` to make it look like the code shown
    here.) Right below that, we can add an event listener to the text field `txtGuess`
    to handle action events such as pressing the ENTER key. The following code adds
    a listener to `txtGuess`:'
  prefs: []
  type: TYPE_NORMAL
- en: btnGuess.setOnClickListener(new View.OnClickListener() {
  prefs: []
  type: TYPE_NORMAL
- en: public void onClick(View v) {
  prefs: []
  type: TYPE_NORMAL
- en: checkGuess();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: txtGuess.setOnEditorActionListener(new TextView.OnEditorActionListener() {
  prefs: []
  type: TYPE_NORMAL
- en: '@Override'
  prefs: []
  type: TYPE_NORMAL
- en: public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
  prefs: []
  type: TYPE_NORMAL
- en: checkGuess();
  prefs: []
  type: TYPE_NORMAL
- en: ➊ return true;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: The *editor action* we’re listening for is when the user presses the ENTER key
    while typing in the text field. When that event happens, we want to check the
    guess the user entered.
  prefs: []
  type: TYPE_NORMAL
- en: We changed the `return` statement to return a value of `true` ➊ because we want
    to keep the keyboard on the screen so the user can enter their next guess. The
    `return` statement tells the text field whether the event handler code we’ve provided
    completed the event. By returning the value `true`, we’ve told Android that we’ve
    done everything that needs to be done to check the user’s guess. If we returned
    `false` here instead, Android would finish processing the ENTER key by removing
    the number keypad from the screen—as it does by default when you finish typing
    in a form on a web page. We don’t want the keypad to disappear after every guess,
    so we return `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Adding One More Finishing Touch*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Run the app a few times to test it, and you’ll see the ENTER key allows you
    to enter and check guesses quickly and efficiently. You’ll also see your guesses
    centered nicely in the text field. However, when you win, depending on the API
    version, screen size, or density of your device, you may see an alignment problem
    like the one shown in [Figure 4-31](ch4.xhtml#ch4fig31).
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that the `TextView` named `lblOutput` resizes to show the longer
    “You win! Let’s play again!” text, and some older APIs may not center this correctly.
    You can prevent this by expanding `lblOutput` to the full width of the screen
    in the design preview and by changing the `textAlignment` property to `center`.
    Now you have a complete guessing game app to play on your device and to share
    with friends! The final version 1.0 of the app is shown running on a Nexus 7,
    with Font settings at Large, in [Figure 4-32](ch4.xhtml#ch4fig32).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0104-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-31: If you notice misaligned text, you may need to expand and center
    the TextView `lblOutput`.*'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0104-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-32: Your finished version 1.0 of the mobile app, with all the user
    experience improvements in place*'
  prefs: []
  type: TYPE_NORMAL
- en: Wow! You’ve gone from a simple, text-based, command line number-guessing program,
    to a sophisticated GUI desktop game, to a fully featured mobile app that runs
    on real Android devices. Are you starting to see the power and flexibility of
    Java? And in [Chapter 5](ch5.xhtml#ch5), we’ll make the app even more professional
    with a settings menu and the ability to store user preferences!
  prefs: []
  type: TYPE_NORMAL
- en: What You Learned
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ve seen that much of the Java code used in a text-based and GUI desktop
    program can build the foundation of a modern mobile app, thanks to Java’s reusability
    across multiple platforms. We have also picked up several new mobile-specific
    skills in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: • Starting a new Android Studio app project
  prefs: []
  type: TYPE_NORMAL
- en: • Building the GUI layout in design view in Android Studio, including changing
    the properties of various elements in the Properties pane
  prefs: []
  type: TYPE_NORMAL
- en: • Naming GUI components in a layout for easy use in Java code
  prefs: []
  type: TYPE_NORMAL
- en: • Connecting the Android GUI layout elements to your Java code
  prefs: []
  type: TYPE_NORMAL
- en: • Adding your own methods, such as `checkGuess()` and `newGame()`, to an Android
    app
  prefs: []
  type: TYPE_NORMAL
- en: • Reusing Java code in an Android app
  prefs: []
  type: TYPE_NORMAL
- en: • Handling events in Android, including button clicks and keyboard/editor actions
    such as pressing the ENTER key
  prefs: []
  type: TYPE_NORMAL
- en: • Testing apps by running them on an Android virtual device using the Android
    emulator
  prefs: []
  type: TYPE_NORMAL
- en: • Running an app on an Android phone, tablet, or other device by enabling Developer
    mode and USB debugging
  prefs: []
  type: TYPE_NORMAL
- en: • Improving the user experience by changing widget properties and adding user-friendly
    finishing touches
  prefs: []
  type: TYPE_NORMAL
- en: Programming Challenges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try these programming challenge exercises to review and practice what you’ve
    learned and to expand your programming skills by trying something new. If you
    get stuck, visit *[https://www.nostarch.com/learnjava/](https://www.nostarch.com/learnjava/)*
    to download sample solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '*#1: “Toast”-ing to the Number of Tries*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the programming challenges for
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](ch3.xhtml#ch3), you changed the winning message to tell the user
    how many tries they took to win:'
  prefs: []
  type: TYPE_NORMAL
- en: 62 is correct! You win after 7 tries!
  prefs: []
  type: TYPE_NORMAL
- en: Let’s do something similar for the Android version, with a twist—or, should
    I say, a *Toast*? A Toast is an Android widget for creating pop-up message windows.
    Toast pop-ups are a convenient way to show a quick notice, such as an error or
    a note telling the user they’ve won the game. See the Toast message near the bottom
    of the screen in [Figure 4-33](ch4.xhtml#ch4fig33).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0106-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-33: A Toast message pops up on the screen to alert the user to important
    information.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a Toast message popup with the `Toast.makeText()` method. Here’s
    a sample to help you add a Toast pop-up to the `else` statement for winning the
    game:'
  prefs: []
  type: TYPE_NORMAL
- en: else {
  prefs: []
  type: TYPE_NORMAL
- en: message = guess +
  prefs: []
  type: TYPE_NORMAL
- en: '" is correct. You win after " + numberOfTries + " tries!";'
  prefs: []
  type: TYPE_NORMAL
- en: Toast.*makeText*(MainActivity.this, message,
  prefs: []
  type: TYPE_NORMAL
- en: Toast.*LENGTH_LONG*).show();
  prefs: []
  type: TYPE_NORMAL
- en: newGame();
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: The Toast message in this code will pop up over the `MainActivity` (our guessing
    game), displaying the `String` `message` for a few seconds thanks to `Toast.LENGTH_LONG`.
    There’s also a `Toast.LENGTH_SHORT`, but it pops up and disappears so quickly
    that it can be hard to read. The `.show()` method at the end does the important
    part, showing the Toast on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: As with the GUI desktop version, to accomplish this task, you’ll need to create
    a new variable at the top of your class (like `int numberOfTries = 0;`), add to
    the number of tries every time the `checkGuess()` method runs successfully, and
    change the output `message` to display the number of tries to the user when they
    win, both in a Toast pop-up and in the `lblOutput` field. After counting the number
    of tries, add the features you learned in [Chapter 3](ch3.xhtml#ch3) for running
    out of tries or losing. Give the user seven tries and tell them how many tries
    are left after each guess.
  prefs: []
  type: TYPE_NORMAL
- en: '*#2: Adding Visual Appeal*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Explore some of the more aesthetic properties of the GUI components in Android
    Studio, including background colors, foreground colors, fonts, `textSize`, and
    more. Move components in your guessing game app around to make the interface more
    visually appealing. For an example of one way you could customize your game, see
    [Figure 4-34](ch4.xhtml#ch4fig34).
  prefs: []
  type: TYPE_NORMAL
- en: You can even add a custom background image (add an image file to the *app* ▸
    *res* ▸ *drawable* folder and then select it as the `background` property for
    your layout or for a button or other component). Play with various settings—you
    can always undo by pressing CTRL-Z!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0107-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4-34: Changing the colors, fonts, text size, and arrangement of the
    components in your app can make it stand out!*'
  prefs: []
  type: TYPE_NORMAL
- en: '*#3: Creating a MadLibs Mobile App*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Look back at the *MadLibGUI.java* program you built in [Chapter 3](ch3.xhtml#ch3)
    (Programming Challenge #3 on [page 74](ch3.xhtml#page_74)). Now create a mobile
    version of your MadLibs app that prompts the user for several words in a GUI with
    labels and text fields, such as `txtBigAnimal`, `txtPastTenseVerb`, `txtSmallContainer`,
    and `txtFood`. Add a button that the user can press to generate their own MadLibs-style
    story. It may be a nice touch to include some default or initial text in each
    text field, just to give the user an idea of how the program works.'
  prefs: []
  type: TYPE_NORMAL
- en: When the user clicks the button, the program should display the completed MadLibs
    story in a `TextView` or in an `EditText` widget—the `EditText` makes it possible
    to copy and paste the user’s funny story if they wish to share it. Play with the
    colors, fonts, and layout until you’re happy with the result and then share your
    creation with a friend!
  prefs: []
  type: TYPE_NORMAL
- en: '**HINT**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To make a TextView or EditText show multiple lines, use the escape character
    sequence \n to insert a new line in the String message you display using the setText()
    method, like so: "Once upon a time... \n There was a buffalo princess \n who lived
    in a soup can." This quote will span three lines, separated by new lines wherever
    the \n escape sequence appears.*'
  prefs: []
  type: TYPE_NORMAL
