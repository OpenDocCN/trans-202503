<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch12">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_193" aria-label="193"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch12">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">12</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">STRONGLY CONNECTED COMPONENTS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" role="presentation" alt="" width="386" height="386"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Previous chapters used connected components on undirected graphs to answer questions like “Can we get to a given location from here?” or “Would removing this edge break the graph’s connectivity?” Such questions and the algorithms that answer them become more complex once we start thinking about <i>directionality</i>. When examining <i>reachability</i> on a directed graph, it is no longer enough to say, “We can get from A to B.” We need to understand whether we can get back to A and, if not, how that impacts travel through the graph.</p>&#13;
<p class="TX">This chapter explores the concept of <i>strongly connected components</i>, sets of nodes in a directed graph such that any node in the set is reachable from any other node in the set. These components help us understand the structure of the graph and how it can be traversed. We start by formally <span role="doc-pagebreak" epub:type="pagebreak" id="pg_194" aria-label="194"/>introducing the concept of strongly connected components and providing example code for checking whether a set of nodes is strongly connected. We describe a few real-world applications of strongly connected components, including modeling how computer programs get stuck on certain states and how information would flow through a social network, then examine an example algorithm for identifying a graph’s strongly connected components.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-150"/><samp class="SANS_Futura_Std_Bold_B_11">Defining Strongly Connected Components</samp></h3>&#13;
<p class="TNI1">The formal definition of a strongly connected component in a directed graph is a maximal set of nodes <i>V'</i> <span class="symbol">⊆</span> <i>V</i> such that for any two nodes <i>u</i> <span class="symbol">∈</span> <i>V'</i> and <i>v</i> <span class="symbol">∈</span> <i>V'</i>, there exists a path of directed edges from <i>u</i> to <i>v</i>. In other words, you can reach any node in the strongly connected component when starting from any other node in the same component. If every node in a directed graph is part of the same strongly connected component, we call the graph <i>strongly connected</i>.</p>&#13;
<p class="TX">We can visualize the importance of strongly connected components in the context of transportation networks. Let’s return to the magical labyrinth designed by an evil wizard, as introduced in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>. To thwart wandering adventurers, the wizard uses one-way doors to connect each of their labyrinth’s rooms, as shown in <a href="#fig12-1">Figure 12-1</a>. They thus give each path a predefined flow. For example, adventurers can use the door between rooms A and B to travel from A to B, but not the other way around.</p>&#13;
<figure class="IMG"><img id="fig12-1" class="img60" src="../images/f12001.jpg" alt="The graph has six nodes and directed edges (A, B), (B, C), (B, E), (C, F), (D, A), (E, D), and (E, F)." width="877" height="377"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-1: A graph modeling the one-way doors between six rooms</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">This approach succeeds beyond the wizard’s expectations. They had hoped simply to prevent adventurers from backtracking and surprising their minions from behind. Instead, they find that certain rooms become unreachable from other rooms. The labyrinth contains multiple strongly connected components: {A, B, D, E}, {C}, and {F}. Adventurers can wander from room A to B to E to D and back to A without running afoul of the doors. However, disaster strikes as soon as they need to leave that component. Adventurers who have ventured into room C soon find there is no path for them to return to rooms A, B, D, or E. As time goes on, adventurers are effectively funneled into room F, which allows the wizard to trap the adventurers in that room with a boss-level monster.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_195" aria-label="195"/>&#13;
<h4 class="H2" id="sec2"><span id="h-151"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Determining Which Nodes Are Mutually Reachable</samp></h4>&#13;
<p class="TNI1">The key aspect to understanding and building strongly connected components is determining which nodes are <i>mutually reachable</i>. Let’s start by reviewing what it means for node <i>v</i> to be reachable from node <i>u</i>. As noted in <span class="Xref">“Reachability”</span> in <span class="Xref"><a href="chapter3.xhtml">Chapter 3</a></span>, node <i>v</i> is reachable from node <i>u</i> only if there exists a sequence of (directed) edges forming a continuous path starting at node <i>u</i> and terminating at node <i>v</i>. Under this definition, every node is reachable from itself by using the empty set of edges; we can always get to where we already are by not moving.</p>&#13;
<p class="TX">We can define a helper function <samp class="SANS_TheSansMonoCd_W5Regular_11">get_reachable()</samp> that uses a breadth-first search to retrieve the set of all other nodes that are reachable in a directed graph <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> from a given starting index (<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>). We use a <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> data structure to track both the reachable nodes and the nodes seen during the current search, as shown in <a href="#list12-1">Listing 12-1</a>.</p>&#13;
<span id="list12-1"/>&#13;
<pre><code>def get_reachable(g: Graph, index: int) -&gt; set:  &#13;
    seen: set = set()&#13;
    pending: queue.Queue = queue.Queue()&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> seen.add(index)&#13;
    pending.put(index)&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> while not pending.empty():&#13;
        current_index: int = pending.get()&#13;
        current: Node = g.nodes[current_index]&#13;
        for edge in current.get_edge_list():&#13;
            neighbor: int = edge.to_node&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if neighbor not in seen:&#13;
                pending.put(neighbor)&#13;
                seen.add(neighbor)&#13;
&#13;
    return seen&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 12-1: Retrieving a set of node indices reachable from the given node</samp></p>&#13;
<p class="TX">The code starts by setting up the data structures: a set of seen and thus reachable nodes (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>) and a queue of future node indices to explore (<samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp>). Note that the use of the queue data structure requires us to include <samp class="SANS_TheSansMonoCd_W5Regular_11">import queue</samp> in the file. The code adds the initial node (<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>) to both its <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> set and its queue of node indices to explore <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">The code uses a breadth-first search to discover all other reachable nodes in the graph. While there are nodes to explore (and thus <samp class="SANS_TheSansMonoCd_W5Regular_11">pending</samp> is not empty) <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>, the code dequeues the next index, retrieves the node, and checks each of its neighbors using a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop. If the code has not previously encountered a neighbor, that neighbor’s index is added to both the queue and the <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> set <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. When the code runs out of nodes to explore, it returns the set of seen indices. This set includes every node that can be reached from <samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>.</p>&#13;
<p class="TX">The algorithm in <a href="#list12-1">Listing 12-1</a> operates like a methodical adventurer planning their trip through a magical labyrinth to which they have a map. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_196" aria-label="196"/>The adventurer maintains a list (queue) of rooms to evaluate, starting with just the entrance on the list. At each step, they take the top room from their list, cross it out, carefully locate it on their map, and check for adjacent rooms. They add any unexplored neighbors to the bottom of their list before drawing a tidy checkmark next to the room on the map. They then continue evaluating rooms, taking the top (or oldest) item on their list, until their list runs out.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h-152"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Determining Whether Nodes Are Strongly Connected</samp></h4>&#13;
<p class="TNI1">We can use the reachability function from <a href="#list12-1">Listing 12-1</a> to define a brute-force check as to whether a set of nodes, given by a list of indices (<samp class="SANS_TheSansMonoCd_W5Regular_11">inds</samp>), are strongly connected, as shown in the following code:</p>&#13;
<pre><code>def check_strongly_connected(g: Graph, inds: list) -&gt; bool: &#13;
    for i in inds:&#13;
        reachable = get_reachable(g, i)&#13;
        for other in inds:&#13;
            if other not in reachable:&#13;
                return False&#13;
    return True&#13;
</code></pre>&#13;
<p class="TX">This code uses a pair of nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops to check whether every node in the component is reachable from every other node. It starts at each node index in <samp class="SANS_TheSansMonoCd_W5Regular_11">inds</samp> and uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">get_reachable()</samp> helper function from <a href="#list12-1">Listing 12-1</a> to generate a set of reachable nodes. It then checks whether each index in <samp class="SANS_TheSansMonoCd_W5Regular_11">inds</samp> occurs in this reachable set. If any node is not reachable from any other, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. Otherwise, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.</p>&#13;
<p class="TX">Although the <samp class="SANS_TheSansMonoCd_W5Regular_11">check_strongly_connected()</samp> function is simple, consisting of just two loops and a helper search function, it is not an efficient approach. We introduce it here because it provides an easily understandable and intuitive overview of what is required for a set of nodes to be strongly connected. It is the computational equivalent of a hapless adventurer who begins a new exploration of the labyrinth from every possible room and records which destinations they reach. For a set of |<i>V</i> | nodes, the function needs to run |<i>V</i> | searches and then check the other |<i>V</i> | – 1 nodes against the resulting reachable set.</p>&#13;
<p class="TX">Worse, the <samp class="SANS_TheSansMonoCd_W5Regular_11">check_strongly_connected()</samp> function does not tell us whether nodes are missing from the strongly connected component. Remember that strongly connected components are <i>maximal</i> sets of nodes that are mutually reachable. The function tells us only whether each pair of nodes in the list is mutually reachable. It does not tell us what other nodes could be part of the set.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h3 class="H1" id="sec4"><span id="h-153"/><samp class="SANS_Futura_Std_Bold_B_11">Use Cases</samp></h3>&#13;
<p class="TNI1">Identifying strongly connected components in a graph is essential for understanding possible movement throughout the graph. This section provides some real-world applications for identifying strongly connected components: <span role="doc-pagebreak" epub:type="pagebreak" id="pg_197" aria-label="197"/>analyzing the flow of operations through a program, the flow of gossip through a network, and the ability to traverse a transportation network.</p>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h-154"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Modeling Computer Program States</samp></h4>&#13;
<p class="TNI1">We can model the states of a computer program as a directed graph. The startup state might be a single node with edges to states for loading initial data, initializing variables, and checking the network connection. For example, <a href="#fig12-2">Figure 12-2</a> shows a diagram of states in a video game. Individual states of the program represent processing user input and rendering the screen. The dotted line indicates the core game loop, which forms a strongly connected component where each state is reachable from each other state. However, states such as loading the initial data files or exiting the game are not part of this component; once you load the initial data files, the program never returns to that state.</p>&#13;
<figure class="IMG"><img id="fig12-2" class="img100" src="../images/f12002.jpg" alt="A graph with nine nodes representing program states. The middle of the graph has a loop consisting of the nodes “Process Input,” “Move characters,” “Check conditions,” and “Render Screen.”" width="1682" height="646"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-2: A toy video game modeled as a set of program states</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Computer programs may have multiple strongly connected components encapsulating different actions or logic. For example, a data analysis program might have one strongly connected component for batch processing data from a file and another to allow user interaction.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h-155"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding a Gossip Network</samp></h4>&#13;
<p class="TNI1">The ability to find a graph’s strongly connected components can help us determine how far information can spread in directed communication networks. For such a network, a strongly connected component would be a group of people such that if one person knows something, the whole group knows it. That is, information passes from any node in the group to every other node in that same group.</p>&#13;
<p class="TX">Consider the diagram of a social network in <a href="#fig12-3">Figure 12-3</a>, where each node represents an individual. An edge from node <i>u</i> to node <i>v</i> indicates that person <i>u</i> will tell person <i>v</i> an exciting rumor about the release of a new graph algorithms book. The lack of an edge indicates the lack of such <span role="doc-pagebreak" epub:type="pagebreak" id="pg_198" aria-label="198"/>communication. If any node shares a rumor, this information travels to all nodes that are reachable from the starting node.</p>&#13;
<figure class="IMG"><img id="fig12-3" class="img40" src="../images/f12003.jpg" alt="A graph with six nodes and directed edges (0, 1), (1, 4), (2, 5), (3, 4), (4, 0), (4, 3), (5, 2) and (5, 4)." width="502" height="273"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-3: A graph modeling a communication network</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Strongly connected components provide an insight into groups that fully share information. In <a href="#fig12-3">Figure 12-3</a>, nodes 0, 1, 3, and 4 form a strongly connected component. Any information that person 4 shares will eventually be learned by those other nodes in the group.</p>&#13;
<p class="TX">Remember that information can still flow between two nodes in different strongly connected components. In <a href="#fig12-3">Figure 12-3</a>, any information shared by node 5 will eventually make its way to node 0 by way of node 4. However, the inverse is not true. Since node 4 does not share information with node 5, both nodes 5 and 2 are cut off from the secrets originating from the graph’s left side. They will not learn about the upcoming graph algorithms book until it is officially announced.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h-156"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Planning a Travel Network</samp></h4>&#13;
<p class="TNI1">When planning out a real-world travel network, it’s essential to understand the strongly connected components involved. In the travel context, a strongly connected component is necessary for a traveler to make a round trip. If two locations are not in the same strongly connected component, such as the wizard’s dungeon with one-way doors, anyone traversing the network could get stuck in a subset of locations.</p>&#13;
<p class="TX">For example, in an airline network, any city <i>v</i> reachable from city <i>u</i> must be part of the same strongly connected component. Otherwise, both planes and passengers from the first component will get stuck in the second component. If an airline offers a set of flights from Toronto to Perth, they will need another set of flights that can return the planes and passengers to Toronto.</p>&#13;
<p class="TX">Note that it is not strictly necessary for the airline network to form a single connected component, as the airline can serve two disjoint markets with two different strongly connected components. Perhaps it operates a commuter network serving cities in Florida and a separate network for New England. However, each subnetwork must be strongly connected.</p>&#13;
<p class="TX">The same considerations apply when designing any travel network. It would be a disaster to have a section of the city with only incoming one-way roads. Commuters would drive into the section and be unable to leave. The area would soon fill with cars and persistent honking as desperate drivers tried to find any way out.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_199" aria-label="199"/>&#13;
<h3 class="H1" id="sec8"><span id="h-157"/><samp class="SANS_Futura_Std_Bold_B_11">Kosaraju-Sharir’s Algorithm</samp></h3>&#13;
<p class="TNI1"><i>Kosaraju-Sharir’s algorithm</i> (or just <i>Kosaraju’s algorithm</i>) is a practical, understandable, and visualizable algorithm for finding strongly connected components. In their book <i>Data Structures and Algorithms</i> (Addison-Wesley, 1983), Aho, Hopcroft, and Ullman describe the approach as being independently invented by computer scientists S. Rao Kosaraju and M. Sharir. This algorithm identifies strongly connected components by using a pair of depth-first searches along with an inverted graph.</p>&#13;
<p class="TX">Kosaraju-Sharir’s algorithm begins by performing a depth-first search of the graph that effectively asks, “What nodes can I reach from this starting node?” Throughout the search, it records the <i>finishing time</i> of each node. The finishing time, also called <i>post-order index</i>, is a counter that records the order in which a search finishes processing a node. The first node finished is given a time of 0, the second a time of 1, and so on. In our labyrinth example, this corresponds to the wizard walking the labyrinth’s rooms with a depth-first search—only proceeding through doors in the correct direction—and recording the final time they left each room.</p>&#13;
<p class="TX">Let’s return to the wizard inspecting their upgraded labyrinth shown in <a href="#fig12-1">Figure 12-1</a>. During the initial inspection, they disable the one-way door spells so they can roam their own dungeon freely. The wizard then starts their inspection at room A. They walk to B, then C, then F before hitting their first dead end. Since there is nowhere to go, F gets a finishing order of 0. The wizard backtracks to room C (whose door they kept open because they control the labyrinth), realizes there is nowhere new to go, and gives room C a finishing order of 1. It isn’t until they backtrack to B that they find a new path forward. This time they go to room E, then room D, as they need to explore that path before they can call room B finished. This search progresses by assigning finishing times as follows: F = 0, C = 1, D = 2, E = 3, B = 4, and A = 5. The ordering from this first search depends not only on the structure of the graph but also on the starting node chosen. If the wizard started their inspection at room D, they would finish that room last and get a finishing order of F = 0, C = 1, E = 2, B = 3, A = 4, and D = 5.</p>&#13;
<p class="TX">The second phase of the algorithm reverses the direction of the graph’s edges and runs another set of depth-first searches. By doing so, it effectively pivots from asking, “What nodes can I reach from this starting node?” to “Where can I start if I want to reach this node?” This corresponds to the wizard inspecting their labyrinth in the reverse direction of the one-way doors. At each room, they use a depth-first search that travels in the opposite direction of the one-way doors, allowing them to see which rooms lead to the current one.</p>&#13;
<p class="TX">To see this, consider the simple graph in <a href="#fig12-4">Figure 12-4(a)</a> and its reverse in <a href="#fig12-4">Figure 12-4(b)</a>. A depth-first search that starts from node 0 will find nodes reachable from node 0 (in this case, node 1). However, the same search on the reversed graph in <a href="#fig12-4">Figure 12-4(b)</a> will find nodes that could reach node 0 in the original graph (that is, node 2).</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_200" aria-label="200"/>&#13;
<figure class="IMG"><img id="fig12-4" class="img80" src="../images/f12004.jpg" alt="Two graphs with three nodes. In (A), the graph has directed edges (2, 0) and (0, 1). In (B), the graph has directed edges (1, 0) and (0, 2)." width="1107" height="146"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-4: A simple graph (a) and its reverse (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">By running the second search on the reversed graph and choosing our starting nodes by <i>decreasing</i> finishing order, Kosaraju-Sharir’s algorithm combines the two questions: “What nodes can I reach from this starting node?” and “Where can I start if I want to reach this node?” During the second phase, the algorithm starts a new search (on the reversed graph) from each previously unvisited node and records which nodes are newly visited. The set of nodes visited during each search makes up a strongly connected component in the graph.</p>&#13;
<p class="TX">Although Kosaraju-Sharir’s algorithm performs multiple depth-first searches, each node is visited at most two times: once in the original graph and once in the reversed graph. During each visit, the algorithm checks the current node’s outgoing edges exactly once, requiring time proportional to |<i>V</i> | + |<i>E</i>| for each search. Reversing the graph requires another iteration over all nodes and their outgoing edges, scaling proportional to |<i>V</i> | + |<i>E</i>|. The overall running time of the algorithm therefore scales as |<i>V</i> | + |<i>E</i>|.</p>&#13;
<p class="TX">The reasoning behind why this algorithm works is a bit complex, and a full proof is outside the scope of the book. The interested reader can find a good discussion of this in algorithmic texts such as <i>Data Structures and Algorithms</i> and Sedgewick and Wayne’s <i>Algorithms</i>, 4th edition (Addison-Wesley, 2011). For now, let’s examine how this algorithm builds off those in <span class="Xref"><a href="chapter4.xhtml">Chapters 4</a></span> and <span class="Xref"><a href="chapter11.xhtml">11</a></span> to solve a novel problem.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h-158"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Transposed Graphs</samp></h4>&#13;
<p class="TNI1">A core step of Kosaraju-Sharir’s algorithm is performing the depth-first search on a version of the graph with its edges reversed, known as a <i>transposed graph</i>. This term comes from the <i>matrix transpose operation</i>, which reverses each edge’s direction; we’ll discuss this in greater detail shortly.</p>&#13;
<p class="TX">For our adjacency list representation of a graph, we define a <samp class="SANS_TheSansMonoCd_W5Regular_11">make_transpose _graph()</samp> function that creates a transposed graph by iterating through each of the graph’s edges and adding the inverse edge to a new graph:</p>&#13;
<pre><code>def make_transpose_graph(g: Graph) -&gt; Graph:  &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> g2: Graph = Graph(g.num_nodes, undirected=g.undirected)&#13;
    for node in g.nodes:&#13;
        for edge in node.get_edge_list():&#13;
            g2.insert_edge(edge.to_node, edge.from_node, edge.weight)&#13;
    return g2&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">make_transpose_graph()</samp> code starts by creating an empty graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">g2</samp>) with the correct number of nodes and copying the original graph’s <samp class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp> setting <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. It then iterates through each node in the original graph and each of its edges. For each edge, the code adds an edge in the opposite direction to the new graph. The code finishes by returning the new graph.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_201" aria-label="201"/>We can picture this function in the context of our earlier labyrinth example by considering a change to the underlying environment. An apprentice evil wizard, looking for an accomplishment on which to base their reputation, decides to reverse the direction of <i>every</i> door in the labyrinth. They execute this audacious plan by starting with a fresh map, considering each door on the old map, and adding it to the new map with the inverse direction. Once every door has been processed, they submit it to their supervisor and await the inevitable praise.</p>&#13;
<p class="TX">Note that while the <samp class="SANS_TheSansMonoCd_W5Regular_11">make_transpose_graph()</samp> function technically supports undirected graphs by copying the original graph’s <samp class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp> setting, it is useful only for directed graphs. The transpose of an undirected graph will be equivalent to the original graph.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h-159"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp></h4>&#13;
<p class="TNI1">The code for Kosaraju-Sharir’s algorithm uses a helper function that implements the individual searches needed during each phase of the algorithm, performing a modified depth-first search over unseen nodes and adding each newly visited node to a given list in order of increasing finish time:</p>&#13;
<pre><code>def add_reachable(g: Graph, index: int, seen: list, reachable: list): &#13;
    seen[index] = True&#13;
    current = g.nodes[index]&#13;
&#13;
    for edge in current.get_edge_list():&#13;
        if not seen[edge.to_node]:&#13;
            add_reachable(g, edge.to_node, seen, reachable)&#13;
    reachable.append(index)&#13;
</code></pre>&#13;
<p class="TX">In addition to the graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>) and the current index (<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>), the function takes in a Boolean list (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>) indicating which nodes have been seen and a list of node indices representing the finish order (<samp class="SANS_TheSansMonoCd_W5Regular_11">reachable</samp>). The code starts by marking the current node index as seen and retrieving the node data structure. A single <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop iterates over the unseen neighbors and recursively explores them. When the search has finished processing a node, it adds that node to the end of the <samp class="SANS_TheSansMonoCd_W5Regular_11">reachable</samp> list. Since the node index is added at the end of the function, the final list will be sorted in order of increasing finish times once recursive exploration completes.</p>&#13;
<p class="TX">The code for the full Kosaraju-Sharir’s algorithm consists of iterating through the list of nodes twice and calling the helper functions on currently unvisited nodes:</p>&#13;
<pre><code>def kosaraju_sharir(g: Graph) -&gt; list: &#13;
    seen1: list = [False] * g.num_nodes&#13;
    finish_ordered: list = []&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> for ind in range(g.num_nodes):&#13;
        if not seen1[ind]:&#13;
            add_reachable(g, ind, seen1, finish_ordered)<span role="doc-pagebreak" epub:type="pagebreak" id="pg_202" aria-label="202"/>&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> gT: Graph = make_transpose_graph(g)&#13;
&#13;
    seen2: list = [False] * g.num_nodes&#13;
    components: list = []&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> while finish_ordered:&#13;
        start: int = finish_ordered.pop()&#13;
        if not seen2[start]:&#13;
            new_component: list = []&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> add_reachable(gT, start, seen2, new_component)&#13;
            components.append(new_component)&#13;
&#13;
    return components&#13;
</code></pre>&#13;
<p class="TX">The code starts by setting up the data structures for the first search: a Boolean list indicating whether each node has been seen (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen1</samp>) and a single list of the node indices ordered by <i>increasing</i> finish time (<samp class="SANS_TheSansMonoCd_W5Regular_11">finish_ordered</samp>). The <samp class="SANS_TheSansMonoCd_W5Regular_11">finish_ordered</samp> list is initially empty because no nodes have been visited. A <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop then performs the first phase of the algorithm by iterating through each node index and starting a depth-first search from any unvisited nodes <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. Since the code uses the same <samp class="SANS_TheSansMonoCd_W5Regular_11">finish_ordered</samp> list for each call, all the nodes are included in a single list.</p>&#13;
<p class="TX">The second phase starts by reversing the edges of the graph using the <samp class="SANS_TheSansMonoCd_W5Regular_11">make_transpose_graph()</samp> function <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. The code creates a new Boolean list to indicate which nodes it has seen during the second round of searches (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen2</samp>), then creates an empty list of components (<samp class="SANS_TheSansMonoCd_W5Regular_11">components</samp>). The <samp class="SANS_TheSansMonoCd_W5Regular_11">components</samp> list will be a list of lists where each entry contains a list of all node indices in that strongly connected component. A <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop iterates over the nodes in order of <i>decreasing</i> finish order <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>, achieving this ordering by treating the <samp class="SANS_TheSansMonoCd_W5Regular_11">finish_ordered</samp> list as a stack and popping off the last element during each iteration. The stack size shrinks by one and the code checks a new node index (<samp class="SANS_TheSansMonoCd_W5Regular_11">start</samp>) to see if it needs to start a search from that node.</p>&#13;
<p class="TX">Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">add_reachable()</samp> function, the code starts a new search from each unvisited node <span class="CodeAnnotationCode" aria-label="annotation4">❹</span>. Each time, it passes in a new empty result list (<samp class="SANS_TheSansMonoCd_W5Regular_11">new_component</samp>) to represent the current strongly connected component. The function fills the list with the node indices of the new strongly connected component. The code then appends the <samp class="SANS_TheSansMonoCd_W5Regular_11">new_component</samp> list to <samp class="SANS_TheSansMonoCd_W5Regular_11">components</samp>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h-160"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp></h4>&#13;
<p class="TNI1">Let’s examine how Kosaraju-Sharir’s algorithm behaves on the example graph shown in <a href="#fig12-5">Figure 12-5</a>.</p>&#13;
<figure class="IMG"><img id="fig12-5" class="img40" src="../images/f12005.jpg" alt="A graph with six nodes and directed edges (0, 2), (2, 3), (3, 0), (3, 5), (4, 5), and (5, 4)." width="502" height="294"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-5: A directed graph with six nodes</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_203" aria-label="203"/>The first stage of the algorithm is shown in <a href="#fig12-6">Figure 12-6</a> and considers the nodes in order of increasing node index. The algorithm runs a depth-first search starting from node 0 and computes the order in which each node finishes. Node 4 is at the end of a long dead end and thus finishes first. In contrast, node 0 does not finish until its depth-first search finds four other nodes. After the first depth-first search completes, node 1 is still unvisited, so the algorithm starts a new search there. The final ordering is 4, 5, 3, 2, 0, 1, as shown by the finish order indicated outside each node.</p>&#13;
<figure class="IMG"><img id="fig12-6" class="img40" src="../images/f12006.jpg" alt="The nodes in the graph are labeled node 0 = 4, node 1 = 5, node 2 = 3, node 3 = 2, node 4 = 0, and node 5 = 1." width="502" height="398"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-6: The first iteration of Kosaraju-Sharir’s algorithm produces an ordering of nodes.</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this phase of the algorithm, we start a new depth-first search from every unvisited node, as in the case of node 1. Nodes that are not reachable from node 0 are thus included in later depth-first searches and added to the end of the ordering.</p>&#13;
<p class="TX">In its second stage, Kosaraju-Sharir’s algorithm transposes the graph, uses a new array of unseen markers, and repeats this sequence of up to |<i>V</i> | depth-first searches. Instead of searching the nodes in arbitrary order, such as using increasing node index, the algorithm chooses the starting nodes using the inverse of the finish ordering from the first step: 1, 0, 2, 3, 5, 4. The last node to finish becomes the starting point for the first search. Each time the algorithm hits an unseen node during our outer loop, it starts a new depth-first search from that node. It adds all unseen nodes encountered during this depth-first search to the current component and marks them as seen.</p>&#13;
<p class="TX"><a href="#fig12-7">Figure 12-7</a> shows the three searches performed during the second stage on our example graph, starting from node 1 in <a href="#fig12-7">Figure 12-7(a)</a>, node 0 in <a href="#fig12-7">Figure 12-7(b)</a>, and finally node 5 in <a href="#fig12-7">Figure 12-7(c)</a>. Nodes circled with dashed lines indicate the nodes visited during each depth-first search, while gray nodes indicate the nodes with a <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> value set to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> by either the current search or a previous one.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_204" aria-label="204"/>&#13;
<figure class="IMG"><img id="fig12-7" class="img100" src="../images/f12007.jpg" alt="Three subfigures show different searches. In (A), node 1 is circled. In (B), nodes 0, 2, and 3 are circled. In (C), nodes 4 and 5 are circled." width="1182" height="829"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 12-7: The second stage of Kosaraju-Sharir’s algorithm</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">As shown in <a href="#fig12-6">Figure 12-6</a>, we only start searches at unseen nodes, and individual searches do not visit already seen nodes from previous searches.</p>&#13;
<p class="TX">The first depth-first search, shown in <a href="#fig12-7">Figure 12-7(a)</a>, starts at node 1. In <a href="#fig12-7">Figure 12-7(b)</a>, the depth-first search of the reversed graph starts at node 0 and progresses to node 3 and then node 2. At this point, it hits a dead end and backtracks. When the depth-first search returns to node 0, we know that we have visited all nodes that both could reach node 0 and are reachable from node 0 in the original graph. The third and final depth-first search is shown in <a href="#fig12-7">Figure 12-7(c)</a> and explores nodes 4 and 5.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h3 class="H1" id="sec12"><span id="h-161"/><samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp></h3>&#13;
<p class="TNI1">Strongly connected components provide insight into the subsets of nodes that are mutually reachable. The concepts in this chapter provide both a practical tool for thinking about real-world problems, such as transportation networks or gossip networks, and a foundation for thinking about the fundamental structure of a graph itself. For example, identifying the strongly connected components provides one mechanism for partitioning a large graph into meaningful subgraphs.</p>&#13;
<p class="TX">The algorithms presented in this chapter build off the basic depth-first search from <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span> to analyze reachability within graphs and construct strongly connected components. Kosaraju-Sharir’s algorithm provides both a practical and visualizable approach to finding connected components and shows how we can continue to adapt search algorithms to more complex problems.</p>&#13;
<p class="TX">Beyond the algorithm covered in this chapter, a variety of other approaches have been developed to find strongly connected components. For example, Robert Tarjan proposed an algorithm for this purpose that <span role="doc-pagebreak" epub:type="pagebreak" id="pg_205" aria-label="205"/>relies on just a single depth-first search, using the same principles as his algorithms discussed in <span class="Xref"><a href="chapter11.xhtml">Chapter 11</a></span>. As with all topics in this book, a rich variety of approaches with different trade-offs exist. The goal of this chapter is to provide a foundation for understanding and comparing these different approaches.</p>&#13;
<p class="TX">The next chapter discusses random walks through graphs, building on the concepts behind strongly connected components to examine how walks can get stuck in absorption states or wander around forever.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>