<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><section aria-labelledby="ch6" epub:type="chapter" role="doc-chapter">
<span aria-label="225" epub:type="pagebreak" id="pg_225" role="doc-pagebreak"/>
<hgroup>
<h2 class="title" id="ch6">
<span class="tpt"><span class="sans_dogma_ot_bold_b_">6</span></span>
<span class="ct"><span class="sans_dogma_ot_bold_b_">RECURSIVE FUNCTIONS</span> <span class="sans_dogma_ot_bold_b_">AND FRACTALS</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener1" height="380" src="../images/icon.jpg" width="381"/>
</figure>
<p class="chapterintro">Fractals are enchanting geometric shapes where the real meets the imaginary (imaginary numbers, that is). Repeating patterns keep emerging forever as we continue to zoom in on them. Mathematicians are still trying to define fractals precisely, but they agree on these key features: self-similarity (the way smaller parts of a fractal echo the whole) and the ability to scale ad infinitum.</p>
<p class="tx">In this chapter, we’ll use Kotlin to draw a variety of fractals and explore their enigmatic beauty. Our main goal will be to codify the mathematical logic embedded in the design of each fractal, re-create those fractals, and possibly discover new ones by playing with the design parameters.</p>
<section aria-labelledby="sec1" epub:type="division">
<span aria-label="226" epub:type="pagebreak" id="pg_226" role="doc-pagebreak"/>
<h3 class="h"><span id="sec1"/><span id="h1-39"/><span class="sans_futura_std_bold_b_">The Concept of Fractals</span></h3>
<p class="tni">The notion of fractals is full of dualisms and contradictions. Benoit Mandelbrot, considered the father of fractal geometry, coined the term <i class="calibre9">fractal</i> from the Latin word <i class="calibre9">fractus</i>, meaning fractured or broken, yet detailed images of fractals are hardly fractured, instead showing a continuous flow of intricate patterns. Well-known fractals such as the Julia set and the Mandelbrot set display extremely complex patterns, yet the equations that generate those patterns are very simple. The fact that a fractal map contains an infinite amount of information that can be condensed into a single equation is a major discovery of the 20th century, a wonder that reveals the hidden beauty of mathematics.</p>
<p class="tx">Fractals aren’t just exotic mathematical objects, however. They help us see the “geometry of nature,” a term popularized by Mandelbrot. Indeed, fractal patterns are abundant throughout nature, seen in snowflakes, the branching of trees, the human nervous and circulatory systems, coastlines, clouds, hurricanes, and the spiral shapes of galaxies. The theory of fractals also has found applications in the physical and biological sciences, engineering, and information technology and given birth to new areas of research, such as chaos theory and its application in studying complex dynamic systems.</p>
<p class="tx">Before we start coding, let’s review a simple fractal to explore a couple of its key features. <a href="chapter6.xhtml#fig6-1" class="calibre2">Figure 6-1</a> shows the Sierpi<span class="copyright_accent">ń</span>ski triangle, a geometric fractal named after the famous Polish mathematician Wac<span class="copyright_accent">ł</span>aw Sierpi<span class="copyright_accent">ń</span>ski, who created it in 1915. This fractal is constructed by repeatedly connecting the midpoints of the three sides of an equilateral triangle and all the resulting subtriangles.</p>
<figure class="img"><img alt="" class="img3" height="860" id="fig6-1" src="../images/Figure6-1.jpg" width="1016"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 6-1: The Sierpi</span><span class="sans_futura_std_book_oblique_">ń</span><span class="sans_futura_std_book_oblique_">ski triangle</span></p></figcaption>
</figure>
<p class="tx"><span aria-label="227" epub:type="pagebreak" id="pg_227" role="doc-pagebreak"/>The inherent beauty of this fractal derives from its self-similarity: look at any of the smaller triangles inside the outermost triangle and you’ll see a mini version of the original figure. Moreover, if we amplify or scale up one of the smaller triangles, we’ll find many more of the same inside it. For example, <a href="chapter6.xhtml#fig6-2" class="calibre2">Figure 6-2</a> shows a zoomed-in view of just the triangle formed by points A, D, and E from <a href="chapter6.xhtml#fig6-1" class="calibre2">Figure 6-1</a>. The result is the same as the original triangle.</p>
<figure class="img"><img alt="" class="img3" height="845" id="fig6-2" src="../images/Figure6-2.jpg" width="996"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 6-2: A zoomed-in section of the Sierpi</span><span class="sans_futura_std_book_oblique_">ń</span><span class="sans_futura_std_book_oblique_">ski triangle, illustrating the fractal’s ability to scale</span></p></figcaption>
</figure>
<p class="tx">No theoretical limit is placed on how deep we can go—even the smallest triangle from the original figure, when amplified, produces the same result. A fractal can scale up forever.</p>
<p class="tx">Fractals also have an interesting property called <i class="calibre9">fractal dimension</i>. Unlike familiar geometric objects such as lines, areas, and volumes that have one, two, and three dimensions, respectively, a fractal can have a fractional number of dimensions. The Sierpi<span class="copyright_accent">ń</span>ski triangle, for example, has 1.585 dimensions: it’s more than a one-dimensional line but less than a two-dimensional area. This is because it fits in a 2D plane but doesn’t completely fill the area that defines the fractal boundary. You can find a more formal and in-depth discussion of this topic in many of the excellent resources listed at the end of the chapter.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="h"><span id="sec2"/><span id="h1-40"/><span class="sans_futura_std_bold_b_">Recursive Functions</span></h3>
<p class="tni">The most efficient way to draw a self-similar pattern that can theoretically keep repeating itself forever is to use a <i class="calibre9">recursive function</i>. This is a function that continues to call itself from within its own function body until a stopping condition is met. Once we identify the basic building block of a fractal, <span aria-label="228" epub:type="pagebreak" id="pg_228" role="doc-pagebreak"/>we can write a function to draw that building block and then let the function repeatedly call itself, until the fractal pattern is sufficiently developed. In the sections that follow, we’ll use this approach to generate several well-known geometric fractals, including the Sierpi<span class="copyright_accent">ń</span>ski triangle, the Sierpi<span class="copyright_accent">ń</span>ski carpet, and a fractal tree. But first, let’s get a feel for how recursion works by writing a function to calculate the factorial of an arbitrary positive integer <i class="calibre9">n</i>.</p>
<p class="tx">The factorial of a number <i class="calibre9">n</i> is defined as:</p>
<p class="equation"><i class="calibre9">  n</i>! = <i class="calibre9">n</i> × (<i class="calibre9">n</i> – 1) × (<i class="calibre9">n</i> – 2) × ... × 3 × 2 × 1</p>
<p class="tni">In other words, <i class="calibre9">n</i>! equals the product of all integers from 1 to <i class="calibre9">n</i>. For example, 3! = 3 × 2 × 1 = 6, 4! = 4 × 3 × 2 × 1 = 24, and so on (by convention, 1! = 1). Thinking recursively, we can also define the factorial of <i class="calibre9">n</i> as the product of <i class="calibre9">n</i> and the factorial of the next smaller integer (<i class="calibre9">n</i> – 1):</p>
<p class="equation"><i class="calibre9">  n</i>! = <i class="calibre9">n</i> × (<i class="calibre9">n</i> – 1)!</p>
<p class="tx">Using this modified form of the equation, we can write a recursive function to calculate the factorial of <i class="calibre9">n</i>.</p>
<pre class="calibre10"><code class="calibre11">fun main() {
    // Find the factorial of a positive integer.
    val n = 5
    val factorial = getFactorial(n)
    println("The factorial of $n is: $factorial")
}

fun getFactorial(n: Int) : Int {
    if (n &lt;= 1) return 1
      <span aria-label="annotation1" class="code_codeannotation">❶</span> else return n * getFactorial(n - 1)
}</code></pre>
<p class="tx">Something interesting is happening here. The function <span class="sans_thesansmonocd_w5regular_">getFactorial(n)</span> calls itself from inside the function body <span aria-label="annotation1" class="codeannotation">❶</span> and thus kicks off a loop that runs until the most recent value of <span class="sans_thesansmonocd_w5regular_">n</span> equals <span class="sans_thesansmonocd_w5regular_">1</span>. At that point, the last call to the function returns <span class="sans_thesansmonocd_w5regular_">1</span> and the loop terminates, returning the value of the factorial.</p>
<p class="tx"><a href="chapter6.xhtml#tab6-1" class="calibre2">Table 6-1</a> shows how the key function parameters change at each iteration, leading to the factorial value in the end.</p>
<p class="tt" id="tab6-1"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 6-1:</span></span> <span class="sans_futura_std_book_">Anatomy of the Recursive Function</span> <span class="sans_thesansmonocd_w5regular_">getFactorial(n)</span> <span class="sans_futura_std_book_">for</span> <span class="sans_futura_std_book_oblique_">n</span> <span class="sans_futura_std_book_">= 5</span></p>
<table class="basic-table">
<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Iteration</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Argument (</span><span class="sans_thesansmonocd_w7bold_">n</span><span class="sans_futura_std_bold_b_">)</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Test (</span><span class="sans_thesansmonocd_w7bold_">n</span> <span class="sans_thesansmonocd_w7bold_">==</span> <span class="sans_thesansmonocd_w7bold_">1</span><span class="sans_futura_std_bold_b_">)</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Returned value</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tb1"><span class="sans_futura_std_book_">1</span></p></td>
<td class="tbf"><p class="tb1"><span class="sans_futura_std_book_">5</span></p></td>
<td class="tbf"><p class="tb1"><span class="sans_futura_std_book_">False</span></p></td>
<td class="tbf"><p class="tb1"><span class="sans_futura_std_book_">5 ×</span> <span class="sans_thesansmonocd_w5regular_">getFactorial(4)</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">2</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">4</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">False</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">5 × 4 ×</span> <span class="sans_thesansmonocd_w5regular_">getFactorial(3)</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">3</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">3</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">False</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">5 × 4 × 3 ×</span> <span class="sans_thesansmonocd_w5regular_">getFactorial(2)</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">4</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">2</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">False</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">5 × 4 × 3 × 2 ×</span> <span class="sans_thesansmonocd_w5regular_">getFactorial(1)</span></p></td>
</tr>
<tr class="calibre16">
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">5</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">1</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">True</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">5 × 4 × 3 × 2 × 1 = 120</span></p></td>
</tr>
</tbody>
</table>
<p class="tx"><span aria-label="229" epub:type="pagebreak" id="pg_229" role="doc-pagebreak"/>Notice that a recursive function is essentially a loop that keeps on calling itself. We must therefore provide a stopping condition (in this case, <span class="sans_thesansmonocd_w5regular_">n &lt;= 1</span>). Without one, the function will be trapped in an infinite loop.</p>
<p class="tx">It may not be obvious just yet, but recursive functions can make coding significantly simpler (the alternative would be to use complex nested loops). This becomes especially true when the recursive function needs to make multiple calls to itself, using different state variables. We’ll see this idea in the upcoming projects.</p>
<p class="tx"><i class="calibre9">Tail recursion</i> is a technique in which a recursive function implements tail call optimization (TCO). This allows the compiler to avoid consuming additional <i class="calibre9">stack space</i> (a region in memory that stores information in a last-in, first-out order) for each recursive call. Instead, the compiler reuses the same stack space for each call, which can help prevent stack overflow errors.</p>
<p class="tx">To use tail recursion in Kotlin, the recursive call must be the very last call of the method. This means that the function must return the result of the recursive call directly, without performing any additional operations on it.</p>
<p class="tx">Here’s an example of an alternative version of the code that calculates the factorial of a number by using tail recursion:</p>
<pre class="calibre10"><code class="calibre11">fun main() {
    val n = 5
    val factorial = getFactorial(n)
    println("The factorial of $n is: $factorial")
}

<span aria-label="annotation1" class="codeannotated_codeannotation">❶</span> tailrec fun getFactorial(n: Int, result: Int = 1): Int {
    return if (n &lt;= 1) {
        result
    } else {
        getFactorial(n - 1, n * result)
    }
}</code></pre>
<p class="tx">In this implementation, the <span class="sans_thesansmonocd_w5regular_">main()</span> function remains unchanged, but the <span class="sans_thesansmonocd_w5regular_">getFactorial()</span> function has been modified.</p>
<p class="tx">Notice how the <span class="sans_thesansmonocd_w5regular_">getFactorial()</span> function is defined with the <span class="sans_thesansmonocd_w5regular_">tailrec</span> keyword <span aria-label="annotation1" class="codeannotation">❶</span>, which indicates that it should be optimized for tail call recursion. The function takes two arguments: <span class="sans_thesansmonocd_w5regular_">n</span>, which is the number whose factorial will be calculated, and <span class="sans_thesansmonocd_w5regular_">result</span>, which is the current result of the calculation. If <span class="sans_thesansmonocd_w5regular_">n</span> is <span class="sans_thesansmonocd_w5regular_">0</span> or <span class="sans_thesansmonocd_w5regular_">1</span>, the function returns <span class="sans_thesansmonocd_w5regular_">result</span>. Otherwise, it calls itself recursively with <span class="sans_thesansmonocd_w5regular_">n - 1</span> as the new value of <span class="sans_thesansmonocd_w5regular_">n</span> and <span class="sans_thesansmonocd_w5regular_">n * result</span> as the new value of <span class="sans_thesansmonocd_w5regular_">result</span>. This continues until <span class="sans_thesansmonocd_w5regular_">n</span> is <span class="sans_thesansmonocd_w5regular_">0</span> or <span class="sans_thesansmonocd_w5regular_">1</span>, at which point the final result is returned.</p>
<p class="tx">For large numbers (<span class="sans_thesansmonocd_w5regular_">n</span>), this implementation not only saves memory but may also require less time to complete the computations.</p>
<p class="headaexercise" id="pre-22"><span class="sans_dogma_ot_bold_b_15-n">Project 22: The “Hello, World!” of Fractals</span></p>
<p class="tni">Our first foray into the world of fractals will be a simple one: we’ll write a recursive function to draw a series of concentric squares, each one smaller <span aria-label="230" epub:type="pagebreak" id="pg_230" role="doc-pagebreak"/>than and located symmetrically inside the previous one. We’ll visualize the fractal by using the canvas feature of JavaFX.</p>
<section aria-labelledby="sec3" epub:type="division">
<h4 class="h1"><span id="sec3"/><span id="h2-101"/><span class="sans_futura_std_bold_condensed_oblique_">The Strategy</span></h4>
<p class="tni">The JavaFX canvas allows us to draw a polygon based on the coordinates of its vertices. We need a way to calculate the four vertices of a square, given the x- and y-coordinates of one of the vertices and the length of any side (for a square, they’re all equal). We’ll use the scheme outlined in <a href="chapter6.xhtml#fig6-3" class="calibre2">Figure 6-3</a>. Keep in mind that the default origin (0, 0) of the canvas is located at the top-left corner.</p>
<figure class="img"><img alt="" class="img3" height="813" id="fig6-3" src="../images/Figure6-3.jpg" width="816"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 6-3: The strategy for drawing concentric squares</span></p></figcaption>
</figure>
<p class="tx">We’ll start by choosing the coordinates for the top-left vertex of the outermost square, <i class="calibre9">x</i> and <i class="calibre9">y</i>. Given those, calculating the square’s other coordinates is simply a matter of adding the side length <i class="calibre9">s</i> as appropriate. This gives us everything we need to draw the outermost square.</p>
<p class="tx">Next, we’ll call a recursive function to draw the inner square or squares by using the following function parameters: the x- and y-coordinates for the top-left vertex of the most recently drawn square; the side length of that square, <i class="calibre9">s</i>; and a shrinkage factor, <i class="calibre9">k</i> (a percentage setting how much smaller the sides of the next square should be). We’ll use this information to calculate <i class="calibre9">d</i> in <a href="chapter6.xhtml#fig6-3" class="calibre2">Figure 6-3</a>, the distance from the top of one square to the top of the next, as:</p>
<p class="equation"><i class="calibre9">  d</i> =  <i class="calibre9">ks/</i><span class="copyright_italic">2</span></p>
<p class="tx">That in turn will let us update the top-left coordinates and the side length of the next square as follows:</p>
<p class="equation"><i class="calibre9">  x</i> = <i class="calibre9">x</i> + <i class="calibre9">d</i></p>
<p class="equation"><i class="calibre9">  y</i> = <i class="calibre9">y</i> + <i class="calibre9">d</i></p>
<p class="equation"><i class="calibre9">  s</i> = <i class="calibre9">s</i> – <span class="copyright_italic">2</span><i class="calibre9">d</i></p>
<p class="tx"><span aria-label="231" epub:type="pagebreak" id="pg_231" role="doc-pagebreak"/>To prevent our recursive function from devolving into an infinite loop, we’ll provide a stopping condition in the form of a global constant limiting the number of iterations.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="h1"><span id="sec4"/><span id="h2-102"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">Following the steps we just discussed, we first create the required variables and draw the outer square.</p>
<pre class="calibre10"><code class="calibre11">val x = 50.0
val y = 50.0
val s = 400.0
<span aria-label="annotation1" class="codeannotated_codeannotation">❶</span> val k = 0.15   // Reduce the side by 15%.
gc.fill = Color.BLACK
<span aria-label="annotation2" class="codeannotated_codeannotation">❷</span> gc.strokePolygon(doubleArrayOf(x, x, x + s, x + s),
    doubleArrayOf(y, y + s, y + s, y), 4)

// Call the resursive function.
drawSquares(x, y, s, k, gc)</code></pre>
<p class="tx">This code places the top-left corner of the outer square at (50, 50) relative to the origin and sizes the square to 400×400. (The canvas itself is 500×500, as we’ll see later.) At each iteration, the sides of the inner square will be reduced by 15 percent <span aria-label="annotation1" class="codeannotation">❶</span>; feel free to play with this value. The squares will be drawn in black, as specified by <span class="sans_thesansmonocd_w5regular_">Color.BLACK</span>, on a white background (the default). Calling <span class="sans_thesansmonocd_w5regular_">gc.strokePolygon()</span> draws a square <span aria-label="annotation2" class="codeannotation">❷</span> (<span class="sans_thesansmonocd_w5regular_">gc</span> is the <span class="sans_thesansmonocd_w5regular_">GraphicsContext</span> object needed to draw to the canvas). This method requires that the coordinates of the vertices be passed in two separate <span class="sans_thesansmonocd_w5regular_">DoubleArray</span>s, one for the x-values and one for the y-values; the last parameter indicates the number of vertices—in this case, for a square, four.</p>
<p class="tx">Now let’s implement our recursive <span class="sans_thesansmonocd_w5regular_">drawSquares()</span> function.</p>
<pre class="calibre10"><code class="calibre11">fun drawSquares(_x: Double, _y: Double, _s: Double,
                k: Double, gc: GraphicsContext) {

    if (iter &lt;= ITER_MAX) {
        val d = 0.5 * k * _s
        val x = _x + d
        val y = _y + d
        val s = _s – 2 * d

        gc.strokePolygon(doubleArrayOf(x, x, x + s, x + s),
            doubleArrayOf(y, y + s, y + s, y), 4)

        iter += 1
      <span aria-label="annotation1" class="code_codeannotation">❶</span> drawSquares(x, y, s, k, gc)
    }
}</code></pre>
<p class="tx"><span aria-label="232" epub:type="pagebreak" id="pg_232" role="doc-pagebreak"/>The algorithm starts by checking the stopping condition: if <span class="sans_thesansmonocd_w5regular_">iter</span>, which has an initial value of <span class="sans_thesansmonocd_w5regular_">1</span> and is incremented by <span class="sans_thesansmonocd_w5regular_">1</span> per recursion, exceeds the maximum number of iterations set by <span class="sans_thesansmonocd_w5regular_">ITER_MAX</span>, then the loop will stop drawing squares on the canvas, and the program will terminate normally. Otherwise, we calculate a new set of parameters and proceed to draw another square. Notice that we used an underscore as a prefix for the x- and y-coordinates of the top-left vertex, as well as for the length of the side, while receiving parameter values. This naming convention allows us to use the same variable names inside the function as we did outside in the application class.</p>
<p class="tx">We then recursively call the <span class="sans_thesansmonocd_w5regular_">drawSquares()</span> function with the updated parameter values to draw the next inner square <span aria-label="annotation1" class="codeannotation">❶</span>. <a href="chapter6.xhtml#fig6-4" class="calibre2">Figure 6-4</a> shows the program output with an <span class="sans_thesansmonocd_w5regular_">ITER_MAX</span> value of <span class="sans_thesansmonocd_w5regular_">22</span>, which means that 22 squares are inside the outermost square.</p>
<figure class="img"><img alt="" class="img2" height="1000" id="fig6-4" src="../images/Figure6-4.jpg" width="1001"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 6-4: A simple fractal made from concentric, nonrotating squares</span></p></figcaption>
</figure>
<p class="tx">Our concentric squares are a simple example of a geometric fractal. It exhibits self-similarity in that if we removed a few of the outer squares, the resulting image, when scaled up, would look the same, even if we iterated many more times.</p>
<p class="tx">Here’s the complete code for the app, including the boilerplate JavaFX components adapted for Kotlin.</p>
<pre class="calibre10"><code class="calibre11">import javafx.application.Application
import javafx.geometry.Pos
import javafx.scene.Scene
<span aria-label="233" epub:type="pagebreak" id="pg_233" role="doc-pagebreak"/>import javafx.scene.canvas.Canvas
import javafx.scene.canvas.GraphicsContext
import javafx.scene.layout.FlowPane
import javafx.scene.paint.Color
import javafx.stage.Stage

// global variables
val ITER_MAX = 22
var iter = 1

// beginning of the Application class
class GeometricFractal : Application() {
    override fun start(stage: Stage) {

        val canvas = Canvas(600.0, 600.0)
        val gc = canvas.graphicsContext2D

        val rootNode = FlowPane()
        rootNode.alignment = Pos.CENTER
        rootNode.children.add(canvas)

        val scene = Scene(rootNode, 600.0, 600.0)
        stage.title = "Geometric Fractal"
        stage.scene = scene
        stage.show()

        // problem-specific code segment
        val x = 50.0
        val y = 50.0
        val s = 400.0
        val k = 0.15
        gc.fill = Color.BLACK

        gc.strokePolygon(doubleArrayOf(x, x, x + s, x + s),
            doubleArrayOf(y, y + s, y + s, y), 4)

        drawSquares(x, y, s, k, gc)
    }
}

fun main() {
    Application.launch(GeometricFractal::class.java)
}

fun drawSquares(_x: Double, _y: Double, _s: Double,
                k: Double, gc: GraphicsContext) {

    if (iter &lt;= ITER_MAX) {
        val d = 0.5 * _s * k
        val s = _s - 2 * d
        val x = _x + d
        val y = _y + d
        gc.strokePolygon(
            doubleArrayOf(x, x, x + s, x + s),
            doubleArrayOf(y, y + s, y + s, y), 4)

<span aria-label="234" epub:type="pagebreak" id="pg_234" role="doc-pagebreak"/>        // Update counter.
        iter += 1
        // recursive call
        drawSquares(x, y, s, k, gc)
    }
}</code></pre>
<p class="tx">By introducing minor variations to this code, you can create other, similar geometric fractals, such as concentric rectangles or circles. Before you attempt the practice exercise, I encourage you to experiment with these variations.</p>
<aside aria-label="box-32" class="box2">
<p class="boxtitle" id="box-32"><span class="sans_futura_std_bold_b_">EXERCISE</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">Modify your <a href="chapter6.xhtml#pre-22" class="calibre2">Project 22</a> code to make the fractal more interesting by drawing three squares during each iteration, rotating the second and the third by preset amounts (for example, 30 degrees and 60 degrees with respect to the y-axis). Here’s what the program output might look like:</span></p>
<figure class="img4"><img alt="" class="img3" height="1027" src="../images/pg234.jpg" width="1027"/></figure>
</aside>
<p class="headaexercise" id="pre-23"><span class="sans_dogma_ot_bold_b_15-n">Project 23: Draw the Sierpiński Triangle</span></p>
<p class="tni">For this project, we’ll draw the Sierpi<span class="copyright_accent">ń</span>ski triangle (see <a href="chapter6.xhtml#fig6-1" class="calibre2">Figure 6-1</a>) using an approach similar to <span><a href="chapter6.xhtml#pre-22" class="calibre2">Project 22</a></span>. First, we’ll identify the defining features of <span aria-label="235" epub:type="pagebreak" id="pg_235" role="doc-pagebreak"/>the fractal, including its geometric properties, and then write a recursive function to do most of the hard work. We’ll use the same JavaFX template we used for <a href="chapter6.xhtml#pre-22" class="calibre2">Project 22</a> to create the graphical output.</p>
<p class="tx">Recall that the Sierpi<span class="copyright_accent">ń</span>ski triangle is made by taking a triangle and joining the midpoints of its sides, producing three child triangles, then joining the midpoints of the child triangles’ sides, and so on, recursively, ad infinitum. Typically, the triangles are equilateral, meaning they have three equal sides and internal angles of 60 degrees. We’ll make use of these basic properties to come up with an efficient strategy for creating the fractal. However, working with equilateral triangles isn’t strictly required; you can use the steps outlined in this section to create an isosceles Sierpi<span class="copyright_accent">ń</span>ski triangle, with minor adjustments to the code.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="h1"><span id="sec5"/><span id="h2-103"/><span class="sans_futura_std_bold_condensed_oblique_">The Strategy</span></h4>
<p class="tni">To draw the Sierpi<span class="copyright_accent">ń</span>ski triangle, we need a few key parameters: the x- and y-coordinates of the parent (outermost) triangle’s top vertex, where the two inclined sides meet, and the parent triangle’s base (<i class="calibre9">b</i>) and height (<i class="calibre9">h</i>). <a href="chapter6.xhtml#fig6-5" class="calibre2">Figure 6-5</a> shows these parameters, including some additional ones for the child triangles that will be used in our code.</p>
<figure class="img"><img alt="" class="img1" height="813" id="fig6-5" src="../images/Figure6-5.jpg" width="1215"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 6-5: The strategy for drawing the Sierpi</span><span class="sans_futura_std_book_oblique_">ń</span><span class="sans_futura_std_book_oblique_">ski triangle</span></p></figcaption>
</figure>
<p class="tx">We’ll first draw the parent triangle, as we did for the concentric squares example. We’ll then call a recursive function to connect the midpoints of the triangle’s three sides, whose coordinates are calculated in terms of the parent triangle’s base, height, and top vertex. Since this creates three smaller child triangles (as opposed to one smaller square), the recursive function will have to call itself multiple times, once for each of the child triangles <span aria-label="annotation1" class="codeannotation">❶</span> <span aria-label="annotation2" class="codeannotation">❷</span> <span aria-label="annotation3" class="codeannotation">❸</span>. We’ll keep using recursion until a stopping condition is met.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<span aria-label="236" epub:type="pagebreak" id="pg_236" role="doc-pagebreak"/>
<h4 class="h1"><span id="sec6"/><span id="h2-104"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">We’ll discuss the code in three parts. First, we’ll import the required math functions and declare some global parameters and a data class (we’ll reuse the rest of the JavaFX-specific codes from <span><a href="chapter6.xhtml#pre-22" class="calibre2">Project 22</a></span>).</p>
<pre class="calibre10"><code class="calibre11">import kotlin.math.sin
import kotlin.math.PI
import kotlin.math.pow

// global parameters
val BASE = 500.0
val DEPTH = 7
val baseMin = BASE * ((0.5).pow(DEPTH))

data class Vertices(var p1: Double, var q1: Double,
                    var p2: Double, var q2: Double,
                    var p3: Double, var q3: Double)</code></pre>
<p class="tx">The first global parameter, <span class="sans_thesansmonocd_w5regular_">BASE</span>, represents the base of the parent (outer) triangle, which is set to 500. The second parameter, <span class="sans_thesansmonocd_w5regular_">DEPTH</span>, is the number of iterations (how many times inner triangles are drawn), but we use it only to calculate our real stopping condition, <span class="sans_thesansmonocd_w5regular_">baseMin</span>. This is the smallest base length of the inner triangles when we stop recursion. It’s more practical to think in terms of a minimum side length because how small an object we can draw is limited by the pixel size of the screen, as well as by our ability to see small objects. It wouldn’t make sense to let the recursion run an arbitrary number of times (say, 50 or 100 times) while creating a static image.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">baseMin</span> parameter is linked to the number of iterations <span class="sans_thesansmonocd_w5regular_">DEPTH</span> as:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mtext class="sans">baseMin</mtext><mo>=</mo><mtext class="sans">BASE</mtext><mo>×</mo><msup><mrow><mfenced><mrow><mfrac><mn>1</mn><mn>2</mn></mfrac></mrow></mfenced></mrow><mrow><mtext class="sans">DEPTH</mtext></mrow></msup></mrow></math></span>
<span class="mobi"><img alt="" class="img1" height="93" src="../images/pg236-1.jpg" width="1395"/></span></figure>
<p class="tni">This means <span class="sans_thesansmonocd_w5regular_">baseMin</span> decreases exponentially as <span class="sans_thesansmonocd_w5regular_">DEPTH</span> increases, which is why just 5 to 10 iterations can be adequate for bringing out the key features of simple geometric fractals. In this case, since we’re using a <span class="sans_thesansmonocd_w5regular_">DEPTH</span> value of <span class="sans_thesansmonocd_w5regular_">7</span> and a <span class="sans_thesansmonocd_w5regular_">BASE</span> of <span class="sans_thesansmonocd_w5regular_">500</span>, <span class="sans_thesansmonocd_w5regular_">baseMin</span> will be <span class="sans_thesansmonocd_w5regular_">3.906</span>.</p>
<p class="tx">We’ll use the data class <span class="sans_thesansmonocd_w5regular_">Vertices</span> to store and return the vertices of internal triangles, with the help of the <span class="sans_thesansmonocd_w5regular_">getVertices()</span> function (which we’ll discuss shortly).</p>
<p class="tx">Next, let’s have a look at the problem-specific code segment that defines and draws the parent triangle. The top vertex is set to (300.0, 50.0), and the base <i class="calibre9">b</i> and height <i class="calibre9">h</i> are set to be 500.0 and 500 sin(<i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>), respectively, where <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> is <span class="copyright_accent"><span lang="el" xml:lang="el">π</span></span>/3 radians (or 60 degrees).</p>
<pre class="calibre10"><code class="calibre11">// problem-specific component inside the application class
val b = BASE
val h = b * sin(PI / 3.0)
val x1 = 300.0
val y1 = 50.0

<span aria-label="237" epub:type="pagebreak" id="pg_237" role="doc-pagebreak"/>val x = doubleArrayOf(x1, x1 - b/2, x1 + b/2)
val y = doubleArrayOf(y1, y1 + h, y1 + h)
// Draw the outermost triangle.
gc.strokePolygon(x, y, 3)
// Call the recursive function.
drawTriangle(x1, y1, b, h, gc)</code></pre>
<p class="tx">We draw the parent triangle with a call to the <span class="sans_thesansmonocd_w5regular_">gc.strokePolygon()</span> function, passing the x- and y-coordinates of the three vertices and the number of vertices (in this case, three). We then make a single call to the recursive function <span class="sans_thesansmonocd_w5regular_">drawTriangle()</span> to generate the child triangles. Notice we’re following the same basic steps we used in <span><a href="chapter6.xhtml#pre-22" class="calibre2">Project 22</a></span> to draw the concentric squares.</p>
<p class="tx">Finally, we’ll define our recursive function to draw the inner triangles. We’ll also define a helper function for calculating the midpoints of a triangle.</p>
<pre class="calibre10"><code class="calibre11">fun drawTriangle(x1: Double, y1: Double, base: Double,
                 height: Double, gc: GraphicsContext) {

  <span aria-label="annotation1" class="code_codeannotation">❶</span> if (base &gt; baseMin) {
        val (p1, q1, p2, q2, p3, q3) =
            getVertices(x1, y1, base, height)

        val p = doubleArrayOf(p1, p2, p3)
        val q = doubleArrayOf(q1, q2, q3)
        gc.strokePolygon(p, q, 3)

        // recurse for nonempty child triangles
      <span aria-label="annotation2" class="code_codeannotation">❷</span> drawTriangle(x1, y1, base/2, height/2, gc)
      <span aria-label="annotation3" class="code_codeannotation">❸</span> drawTriangle(p1, q1, base/2, height/2, gc)
      <span aria-label="annotation4" class="code_codeannotation">❹</span> drawTriangle(p3, q3, base/2, height/2, gc)
    }
}

fun getVertices(x1: Double, y1: Double, base: Double, height: Double) =
                Vertices(x1 - base/4, y1 + height/2, x1, y1 + height,
                         x1 + base/4, y1 + height/2)</code></pre>
<p class="tx">Our <span class="sans_thesansmonocd_w5regular_">drawTriangle()</span> function follows a similar pattern to our <span class="sans_thesansmonocd_w5regular_">drawSquares()</span> function from <span><a href="chapter6.xhtml#pre-22" class="calibre2">Project 22</a></span>, but a couple of important differences exist. First, the stopping condition is now set with respect to <span class="sans_thesansmonocd_w5regular_">baseMin</span> <span aria-label="annotation1" class="codeannotation">❶</span> instead of the maximum number of iterations (we’ve already discussed why that is the case). Second, we make three separate recursive calls inside the <span class="sans_thesansmonocd_w5regular_">drawTriangle()</span> function (instead of a single recursive call as in the previous project) to make sure that all three child triangles generated at each step contribute to creating the final fractal image. To see how this works, have a look at <a href="chapter6.xhtml#fig6-6" class="calibre2">Figure 6-6</a>.</p>
<span aria-label="238" epub:type="pagebreak" id="pg_238" role="doc-pagebreak"/>
<figure class="img"><img alt="" class="img1" height="574" id="fig6-6" src="../images/Figure6-6.jpg" width="1682"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 6-6: Evolution of the Sierpi</span><span class="sans_futura_std_book_oblique_">ń</span><span class="sans_futura_std_book_oblique_">ski triangle with recursive calls (</span><span class="sans_futura_std_book_">n</span> <span class="sans_futura_std_book_oblique_">= 7)</span></p></figcaption>
</figure>
<p class="tx">If we made only the first recursive call <span aria-label="annotation2" class="codeannotation">❷</span> from inside the <span class="sans_thesansmonocd_w5regular_">drawTriangle()</span> function, the final figure will subdivide only the top child triangles, as shown on the left side of <a href="chapter6.xhtml#fig6-6" class="calibre2">Figure 6-6</a>. The center image shows what would happen if we made two recursive calls <span aria-label="annotation2" class="codeannotation">❷</span> <span aria-label="annotation3" class="codeannotation">❸</span>; now the top and left child triangles are subdivided. Finally, the image on the right is what we want—the complete Sierpi<span class="copyright_accent">ń</span>ski triangle, created by making three back-to-back recursive calls to the <span class="sans_thesansmonocd_w5regular_">drawTriangle()</span> function, <span aria-label="annotation2" class="codeannotation">❷</span> <span aria-label="annotation3" class="codeannotation">❸</span> <span aria-label="annotation4" class="codeannotation">❹</span>, with updated parameter values for the child triangles.</p>
<aside aria-label="box-33" class="box2">
<p class="boxtitle" id="box-33"><span class="sans_futura_std_bold_b_">EXERCISE</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">Taking a cue from <a href="chapter6.xhtml#pre-23" class="calibre2">Project 23</a>, develop a strategy and program for drawing the Sierpi</span><span class="sans_futura_std_book_">ń</span><span class="sans_futura_std_book_">ski carpet, shown here:</span></p>
<figure class="img4"><img alt="" class="img3" height="771" src="../images/pg238-1.jpg" width="771"/></figure>
<p class="box1"><span aria-label="239" epub:type="pagebreak" id="pg_239" role="doc-pagebreak"/><span class="sans_futura_std_book_">Hint: Start by noting the similarity with the Sierpi</span><span class="sans_futura_std_book_">ń</span><span class="sans_futura_std_book_">ski triangle. Instead of connecting midpoints of the sides, divide the parent square into nine equal child squares, and color the square at the center black. Continuing with the analogy, make eight recursive calls with updated parameters, one call for each of the unfilled child squares. (Instead of making eight separate calls, use a couple of nested</span> <span class="sans_thesansmonocd_w5regular_">for</span> <span class="sans_futura_std_book_">loops to make those calls more efficient.) As with the Sierpi</span><span class="sans_futura_std_book_">ń</span><span class="sans_futura_std_book_">ski triangle, the sides of the child squares will shrink exponentially as the number of iterations goes up. The image shown above was generated with</span> <span class="sans_futura_std_book_oblique_">n</span> <span class="sans_futura_std_book_">= 5.</span></p>
</aside>
<p class="headaexercise" id="pre-24"><span class="sans_dogma_ot_bold_b_15-n">Project 24: Create a Fractal Tree</span></p>
<p class="tni">As the final project on simple geometric fractals, we’ll draw a beautiful fractal tree. The tree will start as a single line (the trunk) that splits into two branches. Then each branch will itself split into two more branches, and so on.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h4 class="h1"><span id="sec7"/><span id="h2-105"/><span class="sans_futura_std_bold_condensed_oblique_">The Strategy</span></h4>
<p class="tni">The core strategy for this project is straightforward: draw a line, then recursively draw two more lines from the endpoint of that line, each at an angle relative to the parent line. <a href="chapter6.xhtml#fig6-7" class="calibre2">Figure 6-7</a> outlines the strategy and the features we’ll have to incorporate into the code.</p>
<figure class="img"><img alt="" class="img3" height="813" id="fig6-7" src="../images/Figure6-7.jpg" width="817"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 6-7: The strategy for drawing the fractal tree</span></p></figcaption>
</figure>
<p class="tx">First, we’ll choose a starting point (<i class="calibre9">x1</i>, <i class="calibre9">y1</i>) for the parent line, a length <i class="calibre9">l</i>, and <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>, the parent line’s angle with respect to the x-axis. Using <span aria-label="240" epub:type="pagebreak" id="pg_240" role="doc-pagebreak"/>trigonometry, we calculate the coordinates for the endpoint of the parent line (which is also the starting point of the two child lines) as <i class="calibre9">x1</i> + <i class="calibre9">l</i> cos(<i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>) and <i class="calibre9">y1</i> + <i class="calibre9">l</i> sin(<i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>). The child lines are shorter than the parent line (we’ll choose a shrinkage factor) and branch out from the parent line by some arbitrary angle <i class="calibre9"><span lang="el" xml:lang="el">φ</span></i>, such that the new lines will be drawn at angles (<i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> + <i class="calibre9"><span lang="el" xml:lang="el">φ</span></i>) and (<i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> – <i class="calibre9"><span lang="el" xml:lang="el">φ</span></i>) relative to the x-axis, respectively. Keep calculating endpoints, drawing new lines, and branching out until a stopping condition is met (for example, when the new branches become too small).</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="h1"><span id="sec8"/><span id="h2-106"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">In this example, we do not have any global variables or parameters, and the import block for math functions looks like this:</p>
<pre class="calibre10"><code class="calibre11">import kotlin.math.PI
import kotlin.math.sin
import kotlin.math.cos</code></pre>
<p class="tx">Hence, the first code snippet we’ll discuss covers the problem-specific parameter values within the application class and the call to the recursive function <span class="sans_thesansmonocd_w5regular_">drawTree()</span>.</p>
<pre class="calibre10"><code class="calibre11">val x = canvas.width / 2.0
val y = canvas.height - 100
val len = 55.0
val angle = -PI / 2
val phi = PI / 10

gc.stroke = Color.GRAY
drawTree(x, y, angle, len, phi, gc)</code></pre>
<p class="tx">We center the starting point of the parent line horizontally on the canvas and place it 100 pixels above the bottom (we’re assuming a canvas size of 600×600). The starting angle (<span class="sans_thesansmonocd_w5regular_">angle</span>) of –<span class="copyright_accent"><span lang="el" xml:lang="el">π</span></span>/2 draws the tree in an upright position. We set the branch-out angle of the child lines relative to the parent line, <i class="calibre9"><span lang="el" xml:lang="el">φ</span></i> (<span class="sans_thesansmonocd_w5regular_">phi</span>), to <span class="copyright_accent"><span lang="el" xml:lang="el">π</span></span>/10, which produces optimal branching for the given parameters. Unlike in our previous fractal projects, we haven’t drawn anything yet. This time, the parent line is drawn inside the recursive function, since it uses the same code as drawing the child lines. We’ll define that function next.</p>
<pre class="calibre10"><code class="calibre11">private fun drawTree(x1: Double, y1: Double, theta: Double,
                     len: Double, phi: Double,
                     gc: GraphicsContext) {

  <span aria-label="annotation1" class="code_codeannotation">❶</span> if (len &gt; 10) {
        val x2 = x1 + len * cos(theta)
        val y2 = y1 + len * sin(theta)
        gc.strokeLine(x1, y1, x2, y2)

      <span aria-label="annotation2" class="code_codeannotation">❷</span> drawTree(x2, y2, theta + phi, len - 4, phi, gc)
      <span aria-label="annotation3" class="code_codeannotation">❸</span> drawTree(x2, y2, theta - phi, len - 4, phi, gc)

<span aria-label="241" epub:type="pagebreak" id="pg_241" role="doc-pagebreak"/>    } else {
        gc.fill = Color.BLACK
        gc.fillOval(x1 - 2, y1 - 2, 4.0, 4.0)
    }
}</code></pre>
<p class="tx">The termination condition stops recursion when the <span class="sans_thesansmonocd_w5regular_">len</span> parameter passed into the function becomes less than or equal to <span class="sans_thesansmonocd_w5regular_">10</span> <span aria-label="annotation1" class="codeannotation">❶</span>. At each iteration, we calculate the endpoint of the current line and draw it with the <span class="sans_thesansmonocd_w5regular_">gc.strokeLine()</span> function. We then make two recursive calls <span aria-label="annotation2" class="codeannotation">❷</span> <span aria-label="annotation3" class="codeannotation">❸</span>, reducing the length of the child lines by four pixels (approximately 7 percent of the original parent line length). When the stopping condition is met, instead of terminating the <span class="sans_thesansmonocd_w5regular_">drawTree()</span> function immediately, the app draws small circles at the end of all final child lines. With a proper selection of colors, the result can resemble a blossoming cherry tree. The grayscale version of this tree is shown in <a href="chapter6.xhtml#fig6-8" class="calibre2">Figure 6-8</a>.</p>
<figure class="img"><img alt="" class="img3" height="572" id="fig6-8" src="../images/Figure6-8.jpg" width="865"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 6-8: A blossoming fractal tree</span></p></figcaption>
</figure>
<p class="tx">For all the fractal projects we’ve worked on so far, and for this project in particular, the parameter values you choose will have a significant effect on the final appearance of the image. If you copy the parameter values verbatim from the book’s code snippets, you’ll be able to reproduce the exact same figures presented in this chapter. However, there are numerous possible combinations of parameter values you could use. I encourage you to play with the parameters; who knows, you might discover a whole new fractal family that no one has seen yet!</p>
</section>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="h"><span id="sec9"/><span id="h1-41"/><span class="sans_futura_std_bold_b_">The L-System and Turtle Graphics</span></h3>
<p class="tni">Closely related to fractals is the <i class="calibre9">L-system</i>, a technique for generating complex strings of characters over a series of iterative steps. The characters are then interpreted as different geometric operations, such as drawing lines or turning left or right. The L-system was introduced by Aristid Lindenmayer, a Hungarian biologist, in 1968 to study the development of <span aria-label="242" epub:type="pagebreak" id="pg_242" role="doc-pagebreak"/>simple organisms and model plant morphology and growth. Lindenmayer proposed that plant development over time can be described by “natural” algorithms that are responsible for the geometric features seen in the arrangements of branches, leaves, petals, and flowers. (We’ll discuss several other nature-inspired algorithms in <span><a href="chapter8.xhtml" class="calibre2">Chapters 8</a></span> and <span><a href="chapter9.xhtml" class="calibre2">9</a></span>.) Another feature of plant growth (incorporated in the L-system) that researchers were quick to notice was the prevalence of self-similarity—the same pattern being replicated at different scales. No wonder the L-system was soon picked up by mathematicians and computer scientists to study and visualize the beautiful geometry of nature that Mandelbrot succinctly called fractals.</p>
<p class="tx">In this section, we’ll study the components of an L-system and develop our own L-system simulator in Kotlin. We’ll also learn about Turtle Graphics, a common computer programming model used for visualizing the shapes and patterns created by L-systems. Since Kotlin’s standard library doesn’t include a Turtle Graphics package, we’ll combine JavaFX canvas with Kotlin to create our own <span class="sans_thesansmonocd_w5regular_">Turtle</span> class.</p>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="h1"><span id="sec10"/><span id="h2-107"/><span class="sans_futura_std_bold_condensed_oblique_">Formalizing the L-System</span></h4>
<p class="tni">An L-system requires a few ingredients to generate a string of characters interpretable as geometric instructions for drawing fractal objects: an alphabet, an axiom, a set of rules, and a depth. The <i class="calibre9">alphabet</i> is the set of characters that are available for use in the string, each with an associated meaning. For example, <span class="sans_thesansmonocd_w5regular_">F</span> might signify drawing a line, <span class="sans_thesansmonocd_w5regular_">+</span> might signify turning right, and so on (we’ll define our full alphabet later). The <i class="calibre9">axiom</i> is an initial sequence of characters that the L-system starts from, and the <i class="calibre9">rules</i> establish techniques for transforming the axiom (or subsequent strings) over a series of iterations. When there are multiple rules, they’re applied in sequence, and the substrings created by each rule are concatenated in the same order to form the new string. The depth sets the number of iterations over which to apply the rules before you arrive at the final string. <a href="chapter6.xhtml#tab6-2" class="calibre2">Table 6-2</a> summarizes the components of an L-system.</p>
<p class="tt" id="tab6-2"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 6-2:</span></span> <span class="sans_futura_std_book_">L-System Components</span></p>
<table class="basic-table">
<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Feature</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Function</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Example</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Interpretation</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">Alphabet</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">A set of allowable characters</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">F</span><span class="sans_futura_std_book_">,</span> <span class="sans_thesansmonocd_w5regular_">G</span><span class="sans_futura_std_book_">,</span> <span class="sans_thesansmonocd_w5regular_">J</span><span class="sans_futura_std_book_">,</span> <span class="sans_thesansmonocd_w5regular_">+</span><span class="sans_futura_std_book_">,</span> <span class="sans_thesansmonocd_w5regular_">-</span><span class="sans_futura_std_book_">,</span> <span class="sans_thesansmonocd_w5regular_">[</span><span class="sans_thesansmonocd_w5regular_">,],</span> <span class="sans_thesansmonocd_w5regular_">X</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">See <a href="chapter6.xhtml#tab6-3" class="calibre2">Table 6-3</a>.</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Axiom</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">An initial set of characters to start off production (to apply the rules recursively)</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">F++F</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Move forward from the current position, turn right by a specified angle twice, and move forward again.</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Rules</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Directions on how to create a new string from a given axiom or string</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">F -&gt; F-F++F-F</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Replace every instance of</span> <span class="sans_thesansmonocd_w5regular_">F</span> <span class="sans_futura_std_book_">in a string with the set of characters that follow the arrow (</span><span class="sans_thesansmonocd_w5regular_">-&gt;</span><span class="sans_futura_std_book_">); add other characters not specified in the rule as is.</span></p></td>
</tr>
<tr class="calibre14">
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">Depth</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">The number of times the rules are applied (axiom is assumed to have a depth of zero)</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">5</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">Apply the rules five times before creating the corresponding figure.</span></p></td>
</tr>
</tbody>
</table>
<p class="tx"><span aria-label="243" epub:type="pagebreak" id="pg_243" role="doc-pagebreak"/>In addition to the components mentioned in <a href="chapter6.xhtml#tab6-2" class="calibre2">Table 6-2</a>, we need to set two other parameters: the length of the lines to be drawn (or the distance to jump over without drawing a line) and the angle of rotation. Typically, the length decreases with each iteration because the larger (outer) elements of a fractal are often drawn first, followed by finer (inner) elements. Reducing the length may also be required to limit the size of the final figure. The angle of rotation <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i> for a particular fractal remains constant throughout the process.</p>
<p class="tx">Let’s look at a simple example to illustrate how to use L-system notations and procedures: drawing a triangle. For this exercise, the L-system parameters and associated steps are outlined in <a href="chapter6.xhtml#fig6-9" class="calibre2">Figure 6-9</a>.</p>
<figure class="img"><img alt="" class="img3" height="813" id="fig6-9" src="../images/Figure6-9.jpg" width="968"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 6-9: The L-system for drawing an equilateral triangle</span></p></figcaption>
</figure>
<p class="tx">We start at (<i class="calibre9">x1</i>, <i class="calibre9">y1</i>) on the canvas, facing in the positive x-axis direction, at angle 0 relative to the x-axis. Our axiom is just a single character, <span class="sans_thesansmonocd_w5regular_">F</span>, and our rule, <span class="sans_thesansmonocd_w5regular_">F -&gt; F++F++F</span>, tells us that with each iteration we should replace any instance of the character <span class="sans_thesansmonocd_w5regular_">F</span> with the string <span class="sans_thesansmonocd_w5regular_">F++F++F</span>. After applying the rule for a depth of 1 (meaning apply the rule only once to the axiom before stopping), we have our final string: <span class="sans_thesansmonocd_w5regular_">F++F++F</span>.</p>
<p class="tx">We now follow this string of instructions: from our initial position, move forward (<span class="sans_thesansmonocd_w5regular_">F</span>) a specified length, <i class="calibre9">l</i>, to arrive at (<i class="calibre9">x2</i>, <i class="calibre9">y2</i>), then perform two right turns (<span class="sans_thesansmonocd_w5regular_">++</span>), each by a specified angle, <i class="calibre9"><span lang="el" xml:lang="el">θ</span></i>, and move forward (<span class="sans_thesansmonocd_w5regular_">F</span>) again to arrive at (<i class="calibre9">x3</i>, <i class="calibre9">y3</i>). Finally, take two more right turns (<span class="sans_thesansmonocd_w5regular_">++</span>) and move forward (<span class="sans_thesansmonocd_w5regular_">F</span>), which brings us back to the starting point and completes the triangle. Each time we move forward from one point to another, we trace the path (connect the two points) with a line.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h4 class="h1"><span id="sec11"/><span id="h2-108"/><span class="sans_futura_std_bold_condensed_oblique_">Drawing L-System Patterns with Turtle Graphics</span></h4>
<p class="tni">Turtle Graphics is a drawing system that imagines a turtle moving around a graphics window. The turtle has at least two properties: its location in terms <span aria-label="244" epub:type="pagebreak" id="pg_244" role="doc-pagebreak"/>of x- and y-coordinates and its orientation measured by an angle relative to the positive direction of the x-axis. The turtle drags around a pen. When the pen is down, it draws lines on the window as the turtle moves; when the pen is up, the turtle moves without tracing its path.</p>
<p class="tx">Turtle Graphics was originally part of an educational programming language called Logo, but the idea has also been implemented in other languages, including Python. It’s used to teach concepts related to programming and the movement and animation of simple objects in a graphics window. It can also be used creatively to teach Euclidian geometry and to generate interesting patterns through recursion. Perhaps the most well-known application of Turtle Graphics in research is for visualizing the strings of instructions created by L-systems of geometric fractals.</p>
<p class="tx">When a language has built-in support for Turtle Graphics, we only need to import the relevant package or class and make use of its methods or functions to move the turtle around and draw lines, shapes, and patterns. Since the Kotlin standard library doesn’t include a Turtle package, we’ll develop a simple <span class="sans_thesansmonocd_w5regular_">Turtle</span> class that will work seamlessly with the <span class="sans_thesansmonocd_w5regular_">Canvas</span> object of JavaFX and deliver the same functionality. The broader goal of this exercise is to build a minimalist L-system simulator capable of generating L-system strings of arbitrary depth and realizing them with the help of the <span class="sans_thesansmonocd_w5regular_">Turtle</span> class to produce well-known geometric fractals. <a href="chapter6.xhtml#tab6-3" class="calibre2">Table 6-3</a> shows the L-system notations (characters) we’ll work with and the corresponding <span class="sans_thesansmonocd_w5regular_">Turtle</span> class methods that we’ll need to implement.</p>
<p class="tt" id="tab6-3"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 6-3:</span></span> <span class="sans_futura_std_book_">L-System Characters and Turtle Graphics Methods</span></p>
<table class="basic-table">
<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Character(s)</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Desired action</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Turtle command</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">F</span><span class="sans_futura_std_book_">,</span> <span class="sans_thesansmonocd_w5regular_">G</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">Move the turtle forward, and draw a line to connect</span> <span class="sans_futura_std_book_">old and new positions. Though</span> <span class="sans_thesansmonocd_w5regular_">F</span> <span class="sans_futura_std_book_">and</span> <span class="sans_thesansmonocd_w5regular_">G</span> <span class="sans_futura_std_book_">have identi</span><span class="sans_futura_std_book_">cal</span> <span class="sans_futura_std_book_">actions, rules may not apply the same way</span> <span class="sans_futura_std_book_">to</span> <span class="sans_thesansmonocd_w5regular_">F</span> <span class="sans_futura_std_book_">and</span> <span class="sans_thesansmonocd_w5regular_">G</span><span class="sans_futura_std_book_">.</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">turtle.lineTo()</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">J</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Jump forward to a new position without drawing a line.</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">turtle.moveTo()</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">+</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Turn the turtle to the right by a specified angle.</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">turtle.turnRight()</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">-</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Turn the turtle to the left by a specified angle.</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">turtle.turnLeft()</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">[</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Push (save) the turtle’s current state (location, angle) to the stack.</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">turtle.push()</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">]</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Pull the last saved state from the stack (while also</span> <span class="sans_futura_std_book_">removing it from the stack) and set that as the turtle’s</span> <span class="sans_futura_std_book_">current state.</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">turtle.pop()</span></p></td>
</tr>
<tr class="calibre16">
<td class="tbl"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">X</span></p></td>
<td class="tbl"><p class="tableheader"><span class="sans_futura_std_book_">Do nothing. Skip to the next instruction.</span></p></td>
<td class="tbl"><p class="tableheader"><span class="sans_futura_std_book_">No turtle call</span></p></td>
</tr>
</tbody>
</table>
<p class="tx">While drawing complex shapes, the L-system strings may require the turtle to branch out in different directions from a base location. For this, the turtle needs to save its current state so it can later return to the base and choose another direction. The <span class="sans_thesansmonocd_w5regular_">push()</span> method helps with saving the current state, while the <span class="sans_thesansmonocd_w5regular_">pull()</span> method retrieves a saved state so that the turtle can start a new branch from there. These methods will rely on a <i class="calibre9">stack</i>, a <span aria-label="245" epub:type="pagebreak" id="pg_245" role="doc-pagebreak"/>data structure where the most recent item added is the first to be retrieved, commonly called last in, first out (LIFO). This way, the turtle will return to more recent states first, to complete subbranches, before returning to earlier saved states to start drawing new main branches.</p>
<p class="headaexercise" id="pre-25"><span class="sans_dogma_ot_bold_b_15-n">Project 25: Design an L-System Simulator</span></p>
<p class="tni">An L-system simulator is made up of several functions or classes that help interpret L-system rules, generate the final string of instructions, and draw the resulting image on a graphics window. Ideally, these components would be coded in a problem-independent manner, with some mechanism for the user to input the initial parameters for the L-system, perhaps through a file or at the command line. For simplicity’s sake, we’ll instead embed these parameters into the code itself, using values that will generate a snowflake pattern, but the rest of the code will be generic. All you’ll have to do is update these problem-specific parameters to simulate different L-system objects.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h4 class="h1"><span id="sec12"/><span id="h2-109"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">We’ll begin our L-system simulator code with some global declarations to keep our data organized, then define the problem-specific parameters for generating a particular L-system object. Next, we’ll declare some helper functions to generate the L-system string based on rules and draw the final L-system string on the canvas. We’ll also declare our <span class="sans_thesansmonocd_w5regular_">Turtle</span> class with methods for rendering the image and then tie everything together with an <span class="sans_thesansmonocd_w5regular_">LSystemApp</span> class.</p>
<section aria-labelledby="sec13" epub:type="division">
<h5 class="h2"><span id="sec13"/><span id="h3-45"/><span class="sans_futura_std_bold_b_">Global Declarations</span></h5>
<p class="tni">We’ll start by declaring two data classes to organize L-system data, plus a special array type to create the stack functionality required for the <span class="sans_thesansmonocd_w5regular_">push()</span> and <span class="sans_thesansmonocd_w5regular_">pull()</span> methods.</p>
<pre class="calibre10"><code class="calibre11">// global declarations
data class Rule(val key: String, val apply: String)
data class State(val x: Double, val y: Double, val angle: Double)
val stack = ArrayDeque&lt;State&gt;()</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">Rule</span> data class will define each L-system rule by using the <span class="sans_thesansmonocd_w5regular_">key</span> and <span class="sans_thesansmonocd_w5regular_">apply</span> members, both of type <span class="sans_thesansmonocd_w5regular_">String</span>. The <span class="sans_thesansmonocd_w5regular_">key</span> property will hold the character that will be replaced if present when a rule is applied, and the <span class="sans_thesansmonocd_w5regular_">apply</span> property will hold the string that will replace the <span class="sans_thesansmonocd_w5regular_">key</span>. For example, for a rule <span class="sans_thesansmonocd_w5regular_">F -&gt; F++F++F</span>, the values of <span class="sans_thesansmonocd_w5regular_">key</span> and <span class="sans_thesansmonocd_w5regular_">apply</span> would be <span class="sans_thesansmonocd_w5regular_">F</span> and <span class="sans_thesansmonocd_w5regular_">F++F++F</span>, respectively.</p>
<p class="tx">The second data class, <span class="sans_thesansmonocd_w5regular_">State</span>, saves the state of the turtle—specifically, its x- and y-coordinates and the direction it’s facing relative to the x-axis. Finally, <span class="sans_thesansmonocd_w5regular_">stack</span> is declared by using Kotlin’s <span class="sans_thesansmonocd_w5regular_">ArrayDeque</span> class, which implements a resizable (mutable) array of the deque (short for <i class="calibre9">double-ended queue</i>) data structure. This class has methods to facilitate the LIFO feature of the stack. The array’s members will be of our custom <span class="sans_thesansmonocd_w5regular_">State</span> data type.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<span aria-label="246" epub:type="pagebreak" id="pg_246" role="doc-pagebreak"/>
<h5 class="h2"><span id="sec14"/><span id="h3-46"/><span class="sans_futura_std_bold_b_">Problem Definition</span></h5>
<p class="tni">Next, we’ll declare the problem-specific parameters of an L-system, including its axiom and rules. The parameters we’re using here will generate a simple fractal pattern that looks like a snowflake. Feel free to replace them with parameters for other well-known L-systems or to experiment with your own.</p>
<pre class="calibre10"><code class="calibre11">// problem definition
<span aria-label="annotation1" class="codeannotated_codeannotation">❶</span> val axiom = "F++F++F"
<span aria-label="annotation2" class="codeannotated_codeannotation">❷</span> val rules: List&lt;Rule&gt; = listOf(
    Rule("F", "F-F++F-F"),
    // Rule(),
    // Rule()
    )

var line = 100.0     // in pixels
val scaling = .33    // shrinkage factor per iteration
val ANGLE = 60.0     // turning angle in degrees (fixed)
val depth = 5        // number of iterations

<span aria-label="annotation3" class="codeannotated_codeannotation">❸</span> val turtle = Turtle(150.0, 200.0, 0.0)

var finalString = ""</code></pre>
<p class="tx">First, we define the axiom, or starting string, for a snowflake fractal <span aria-label="annotation1" class="codeannotation">❶</span>. Earlier, we used this same string, <span class="sans_thesansmonocd_w5regular_">F++F++F</span>, to draw an equilateral triangle. We then create a list of type <span class="sans_thesansmonocd_w5regular_">Rule</span> called <span class="sans_thesansmonocd_w5regular_">rules</span>, where we keep all the rules pertaining to the L-system <span aria-label="annotation2" class="codeannotation">❷</span>. The snowflake requires only a single rule, but the comments inside <span class="sans_thesansmonocd_w5regular_">listOf()</span> show how to add more rules if needed. We set the initial value of <span class="sans_thesansmonocd_w5regular_">line</span> to 100 pixels based on a canvas size of 600×600, but the line length will shrink by one-third with each iteration. We also set the turning angle, <span class="sans_thesansmonocd_w5regular_">ANGLE</span>, to 60 degrees and the number of iterations, <span class="sans_thesansmonocd_w5regular_">depth</span>, to 5.</p>
<p class="tx">We only need to create a single instance of the <span class="sans_thesansmonocd_w5regular_">Turtle</span> class <span aria-label="annotation3" class="codeannotation">❸</span>. We set its initial position to (150.0, 200.0), with an initial angle of 0.0 (facing toward the positive x-direction). Notice that as the turtle begins to move, both its location and its orientation (angle) may change. Finally, we set <span class="sans_thesansmonocd_w5regular_">finalString</span> to an empty string at the start; its content will change after each iteration, and only the final value will be used to draw the fractal.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h5 class="h2"><span id="sec15"/><span id="h3-47"/><span class="sans_futura_std_bold_b_">The generate() Function</span></h5>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">generate()</span> function is a core component of the simulator. It executes the L-system rules for a given axiom and depth.</p>
<pre class="calibre10"><code class="calibre11">// function to generate final L-system string
fun generate() {
    var nextString = ""
  <span aria-label="annotation1" class="code_codeannotation">❶</span> for (letter in finalString) {
        var match = false
      <span aria-label="annotation2" class="code_codeannotation">❷</span> for (rule in rules) {
          <span aria-label="annotation3" class="code_codeannotation">❸</span> if (letter.toString() == rule.key) {
                match = true
<span aria-label="247" epub:type="pagebreak" id="pg_247" role="doc-pagebreak"/>                nextString += rule.apply
                break
            }
        }
      <span aria-label="annotation4" class="code_codeannotation">❹</span> if (!match) nextString += letter
    }
  <span aria-label="annotation5" class="code_codeannotation">❺</span> finalString = nextString
}</code></pre>
<p class="tx">We first declare an empty string called <span class="sans_thesansmonocd_w5regular_">nextString</span>, where we’ll save interim values of the final string. We then use two <span class="sans_thesansmonocd_w5regular_">for</span> loops to iterate one character at a time through the most recent version of <span class="sans_thesansmonocd_w5regular_">finalString</span> <span aria-label="annotation1" class="codeannotation">❶</span> and apply any relevant rules to that character <span aria-label="annotation2" class="codeannotation">❷</span>. The Boolean variable <span class="sans_thesansmonocd_w5regular_">match</span> tracks if a particular rule should be applied. When a selected character matches the <span class="sans_thesansmonocd_w5regular_">key</span> of the current rule <span aria-label="annotation3" class="codeannotation">❸</span>, we set <span class="sans_thesansmonocd_w5regular_">match</span> to <span class="sans_thesansmonocd_w5regular_">true</span> and add the replacement string specified by the <span class="sans_thesansmonocd_w5regular_">apply</span> element of the rule to <span class="sans_thesansmonocd_w5regular_">nextString</span>. This is followed by the <span class="sans_thesansmonocd_w5regular_">break</span> statement to break out of the inner <span class="sans_thesansmonocd_w5regular_">for</span> loop (only one rule will be applicable to a character for each iteration of the outer <span class="sans_thesansmonocd_w5regular_">for</span> loop). If none of the rules apply, we add the current character to <span class="sans_thesansmonocd_w5regular_">nextString</span> unchanged <span aria-label="annotation4" class="codeannotation">❹</span>. Once we’ve iterated over all the characters in <span class="sans_thesansmonocd_w5regular_">finalString</span>, we reset its value to <span class="sans_thesansmonocd_w5regular_">nextString</span> <span aria-label="annotation5" class="codeannotation">❺</span>.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h5 class="h2"><span id="sec16"/><span id="h3-48"/><span class="sans_futura_std_bold_b_">The draw() Function</span></h5>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">draw()</span> function draws the final image on the canvas by reading the characters in <span class="sans_thesansmonocd_w5regular_">finalString</span> and making corresponding calls to the methods of our <span class="sans_thesansmonocd_w5regular_">Turtle</span> class.</p>
<pre class="calibre10"><code class="calibre11">// function to draw per finalString instructions
fun draw(gc: GraphicsContext) {
  <span aria-label="annotation1" class="code_codeannotation">❶</span> for (letter in finalString) {
      <span aria-label="annotation2" class="code_codeannotation">❷</span> when (letter.toString()) {
            "F", "G" -&gt; turtle.lineTo(line, gc)
            "J" -&gt;      turtle.moveTo(line)
            "+" -&gt;      turtle.turnRight(ANGLE)
            "-" -&gt;      turtle.turnLeft(ANGLE)
            "[" -&gt;      turtle.push()
            "]" -&gt;      turtle.pop()
            "X" -&gt;      {/* do nothing */}
        }
    }
}</code></pre>
<p class="tx">We elegantly implement the drawing process inside a single <span class="sans_thesansmonocd_w5regular_">for</span> loop <span aria-label="annotation1" class="codeannotation">❶</span> and a compact <span class="sans_thesansmonocd_w5regular_">when</span> block <span aria-label="annotation2" class="codeannotation">❷</span>, which is much less verbose than a traditional multilevel <span class="sans_thesansmonocd_w5regular_">if...else</span> block. The <span class="sans_thesansmonocd_w5regular_">for</span> loop scans the characters of the variable <span class="sans_thesansmonocd_w5regular_">finalString</span> one at a time and passes them to the <span class="sans_thesansmonocd_w5regular_">when</span> block as <span class="sans_thesansmonocd_w5regular_">letter</span>. Next, we conduct a series of tests until a match is found with one of the possible L-system codes. Based on the match, we call the related <span class="sans_thesansmonocd_w5regular_">Turtle</span> method to draw or move on the canvas. For example, we match characters <span class="sans_thesansmonocd_w5regular_">F</span> and <span class="sans_thesansmonocd_w5regular_">G</span> to the <span class="sans_thesansmonocd_w5regular_">lineTo()</span> method and <span class="sans_thesansmonocd_w5regular_">J</span> to the <span class="sans_thesansmonocd_w5regular_">moveTo()</span> method. Notice that different method calls require different parameters, and the last three calls inside <span aria-label="248" epub:type="pagebreak" id="pg_248" role="doc-pagebreak"/>the <span class="sans_thesansmonocd_w5regular_">when</span> block don’t require any! We’ll see what happens when those methods are called next.</p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h5 class="h2"><span id="sec17"/><span id="h3-49"/><span class="sans_futura_std_bold_b_">The Turtle Class and Its Methods</span></h5>
<p class="tni">Now we’ll implement our <span class="sans_thesansmonocd_w5regular_">Turtle</span> class, where all the methods for carrying out the final drawing live. To keep the main body of our L-system application short and tidy, we’ll declare this class in a separate file called <i class="calibre9">Turtle.kt</i>. We begin the file here:</p>
<pre class="calibre10"><code class="calibre11">import javafx.scene.canvas.GraphicsContext
import kotlin.math.*

<span aria-label="annotation1" class="codeannotated_codeannotation">❶</span> class Turtle (var x: Double, var y: Double, angle: Double) {
    var angleRad = angle * PI /180
    <var class="calibre18">--snip--</var>
}</code></pre>
<p class="tx">The import block gives us access to the required JavaFX and Kotlin library components. The primary class constructor, which is part of the class header <span aria-label="annotation1" class="codeannotation">❶</span>, creates an instance of the <span class="sans_thesansmonocd_w5regular_">Turtle</span> class using three values: the turtle’s starting x- and y-coordinates and its initial orientation (angle of the turtle). We set the first two parameters as <span class="sans_thesansmonocd_w5regular_">var</span> because their values will be updated each time the turtle moves or changes its direction. We keep the third parameter <span class="sans_thesansmonocd_w5regular_">angle</span> as <span class="sans_thesansmonocd_w5regular_">val</span> (not explicitly declared but implied), which is used to define a mutable property, <span class="sans_thesansmonocd_w5regular_">angleRad</span>.</p>
<p class="tx">The rest of the class body defines the seven different methods that can be called to perform different <span class="sans_thesansmonocd_w5regular_">Turtle</span> object tasks. See <a href="chapter6.xhtml#tab6-3" class="calibre2">Table 6-3</a> for a summary of these methods and their corresponding L-system characters.</p>
<pre class="calibre10"><code class="calibre11">fun lineTo(line: Double, gc: GraphicsContext) {
    val xBegin = x
    val yBegin = y
    x += line * cos(angleRad)
    y += line * sin(angleRad)
    gc.strokeLine(xBegin, yBegin, x, y)
}

fun moveTo(line: Double) {
    x += line * cos(angleRad)
    y += line * sin(angleRad)
}

fun turnRight(delta: Double) {
    // origin @ bottom left
    angleRad += delta * PI /180
}

fun turnLeft(delta: Double) {
    // origin @ bottom left
    angleRad -= delta * PI /180
}

<span aria-label="249" epub:type="pagebreak" id="pg_249" role="doc-pagebreak"/>fun push() {
    stack.addLast(State(x, y, angleRad))
}

fun pop() {
    val (xPop, yPop, anglePop) = stack.removeLast()
    x = xPop
    y = yPop
    angleRad = anglePop
}

fun printTurtle() {
    print("x: ${round(x * 100) / 100.0}  y: ${round(y * 100) / 100.0}  ")
    println("angle: ${round((angleRad * 180 / PI) * 100) / 100.0} degrees")
}</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">lineTo()</span> method is the only one that actually draws anything on the canvas. It draws a straight line of length <span class="sans_thesansmonocd_w5regular_">line</span>, based on the same sine and cosine calculations we used to draw segments of the fractal tree in <span><a href="chapter6.xhtml#pre-24" class="calibre2">Project 24</a></span>. All the other methods either move the turtle without drawing a line, change its direction, or save or restore its state. The final method simply prints the current state of the turtle, which is useful for debugging purposes.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">push()</span> and <span class="sans_thesansmonocd_w5regular_">pop()</span> methods rely on methods of the <span class="sans_thesansmonocd_w5regular_">ArrayDeque</span> class, which we used to implement our stack. The <span class="sans_thesansmonocd_w5regular_">push()</span> method calls the <span class="sans_thesansmonocd_w5regular_">addLast()</span> function, while <span class="sans_thesansmonocd_w5regular_">pop()</span> calls the <span class="sans_thesansmonocd_w5regular_">removeLast()</span> function to add or remove an item to the end of the <span class="sans_thesansmonocd_w5regular_">stack</span> array, enforcing the LIFO rule. In both cases, we encapsulate the state information by using our custom <span class="sans_thesansmonocd_w5regular_">State</span> data class.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h5 class="h2"><span id="sec18"/><span id="h3-50"/><span class="sans_futura_std_bold_b_">The LSystemApp Class</span></h5>
<p class="tni">Finally, we’ll bring the different components of the L-system simulator together to form a complete application, organized around an <span class="sans_thesansmonocd_w5regular_">LSystemApp</span> class. The following listing shows the full body of this class, as well as the <span class="sans_thesansmonocd_w5regular_">main()</span> function. The listing also shows where all the other components we discussed earlier fit (except for the <span class="sans_thesansmonocd_w5regular_">Turtle</span> class, which is in a separate file).</p>
<pre class="calibre10"><code class="calibre11">// import statements
<var class="calibre18">--snip--</var>

// global declarations
<var class="calibre18">--snip--</var>

// problem definition
<var class="calibre18">--snip--</var>

// function to generate final L-system string
fun generate() {
<var class="calibre18">--snip--</var>
}

// function to draw per finalString instructions
fun draw(gc: GraphicsContext) {
<span aria-label="250" epub:type="pagebreak" id="pg_250" role="doc-pagebreak"/><var class="calibre18">--snip--</var>
}

// JavaFX-Kotlin Application class
class LSystemApp : Application() {
    override fun start(stage: Stage) {
        val canvas = Canvas(600.0, 600.0)

        val gc = canvas.graphicsContext2D
        // Move the origin to bottom left.
      <span aria-label="annotation1" class="code_codeannotation">❶</span> gc.translate(0.0, canvas.height)
        // Let positive y-axis point up.
      <span aria-label="annotation2" class="code_codeannotation">❷</span> gc.scale(1.0, -1.0)

        val pane = Pane()
        pane.children.add(canvas)
        val scene = Scene(pane, 600.0, 600.0)
        stage.title = "L-system Simulator"
        stage.scene = scene
        stage.show()

        // ---L-system-related code---
        finalString = axiom

      <span aria-label="annotation3" class="code_codeannotation">❸</span> if (depth &gt; 0) {
            for (i in 1..depth) {
                generate()
            }
          <span aria-label="annotation4" class="code_codeannotation">❹</span> line *= (scaling).pow(depth - 1.0)
        }
        draw(gc)
    }
}

fun main() {
    Application.launch(LSystemApp::class.java)
}</code></pre>
<p class="tx">Other than the <span class="sans_thesansmonocd_w5regular_">generate()</span> and <span class="sans_thesansmonocd_w5regular_">draw()</span> functions, much of the <span class="sans_thesansmonocd_w5regular_">LSystemApp</span> consists of the boilerplate JavaFX code. What’s different this time is the addition of a couple of extra lines that relocate the origin of the canvas to the bottom-left corner <span aria-label="annotation1" class="codeannotation">❶</span> and let the positive direction of the y-axis point upward <span aria-label="annotation2" class="codeannotation">❷</span>. These simple changes make testing previously published L-systems that provide axioms, rules, and initial conditions for many well-known fractals very convenient. Published L-system parameters are almost always based on the assumption that we draw the resulting fractals in the first quadrant of the coordinate system.</p>
<p class="tx">The code managing the L-system revolves around an <span class="sans_thesansmonocd_w5regular_">if</span> block that checks if <span class="sans_thesansmonocd_w5regular_">depth</span> is greater than <span class="sans_thesansmonocd_w5regular_">0</span> <span aria-label="annotation3" class="codeannotation">❸</span>. If not, we simply draw the axiom itself, without applying any rules. Otherwise, we call the <span class="sans_thesansmonocd_w5regular_">generate()</span> function <span class="sans_thesansmonocd_w5regular_">depth</span> times to apply the rules over the appropriate number of iterations. We then use the final content of <span class="sans_thesansmonocd_w5regular_">finalString</span> to draw the fractal. Notice that we set the length of the lines to be drawn based on <span class="sans_thesansmonocd_w5regular_">depth</span> <span aria-label="annotation4" class="codeannotation">❹</span>. This dynamic <span aria-label="251" epub:type="pagebreak" id="pg_251" role="doc-pagebreak"/>adjustment allows us to keep the size of the fractal limited to the size of the canvas. If you prefer to use a larger or smaller canvas size (we’re using 600×600), you may have to adjust the initial line length, as well as the initial position of the turtle.</p>
</section>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h4 class="h1"><span id="sec19"/><span id="h2-110"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">We’re now ready to put our brand-new L-system simulator to the test. Since we’ve already included problem-specific parameters for a snowflake fractal, we can run the simulator with different depths to see how the image gets more complex and manifests self-similar patterns as the depth increases. <a href="chapter6.xhtml#fig6-10" class="calibre2">Figure 6-10</a> shows the evolution of the snowflake for depths 1, 3, and 5.</p>
<figure class="img"><img alt="" class="img1" height="533" id="fig6-10" src="../images/Figure6-10.jpg" width="1543"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 6-10: The evolution of a snowflake, using the L-system simulator</span></p></figcaption>
</figure>
<p class="tx">Researchers have developed so many interesting L-systems over the years that you could spend days playing with those systems in your simulator and looking at the intriguing patterns they generate. For example, <a href="chapter6.xhtml#tab6-4" class="calibre2">Table 6-4</a> lists the L-system parameters necessary for creating three more fractals with different features. Some of these incorporate a wider range of symbols, and they all involve multiple rules.</p>
<p class="tt" id="tab6-4"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 6-4:</span></span> <span class="sans_futura_std_book_">Additional L-System Examples</span></p>
<table class="basic-table">
<thead class="calibre13">
<tr class="calibre14">
<th class="tch" rowspan="2" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Property</span></p></th>
<th class="tch" colspan="3" scope="colgroup"><p class="tableheaderc"><span class="sans_futura_std_bold_b_">Fractal name</span></p></th>
</tr>
<tr class="calibre14">
<th class="tch" scope="col"><p class="tb1"><span class="sans_futura_std_bold_b_">Sierpi</span><span class="sans_futura_std_bold_b_">ń</span><span class="sans_futura_std_bold_b_">ski triangle</span></p></th>
<th class="tch" scope="col"><p class="tb1"><span class="sans_futura_std_bold_b_">Pattern with rectangles</span></p></th>
<th class="tch" scope="col"><p class="tb1"><span class="sans_futura_std_bold_b_">Fractal plant</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">Axiom</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">F+G+G</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">F-F-F-F</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">X</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Rules</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">F -&gt; F+G-F-G+F G -&gt; GG</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">F -&gt; F-J+FF-F-FF-FJ-FF+J-FF+F+FF+FJ+FFF J -&gt; JJJJJJ</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">X -&gt; F+[[X]-X]-F[-FX]+X F -&gt; FF</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Line</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">+150.0</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">+15.0</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">+20.0</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Scaling</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">0.5</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">0.5</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">0.7</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Angle</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">120</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">90</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">25</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Depth</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">6</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">2</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">6</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Turtle</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">150.0, 200.0, 0.0</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">150.0, 450.0, 0.0</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">100.0, 50.0, 65.0</span></p></td>
</tr>
<tr class="calibre14">
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">Canvas</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">600.0×600.0</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">600.0×600.0</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">600.0×600.0</span></p></td>
</tr>
</tbody>
</table>
<p class="tx"><span aria-label="252" epub:type="pagebreak" id="pg_252" role="doc-pagebreak"/>The first set of parameters in <a href="chapter6.xhtml#tab6-4" class="calibre2">Table 6-4</a> will create the familiar Sierpi<span class="copyright_accent">ń</span>ski triangle. The second set, with a depth of only two, is for a geometric pattern that involves drawing multiple unconnected rectangles (see <a href="chapter6.xhtml#fig6-11" class="calibre2">Figure 6-11</a>, left). The third set is for a fractal plant, a popular object among fractal enthusiasts (see <a href="chapter6.xhtml#fig6-11" class="calibre2">Figure 6-11</a>, right). It involves a number of push and pull operations (<span class="sans_thesansmonocd_w5regular_">[</span>and]) to keep track of the plant’s various branches.</p>
<figure class="img"><img alt="" class="img1" height="616" id="fig6-11" src="../images/Figure6-11.jpg" width="1324"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 6-11: A rectangular pattern (left) and a fractal plant (right) generated by the L-system simulator</span></p></figcaption>
</figure>
<p class="tx">You can extend the basic L-system simulator we’ve developed in this section to generate 3D fractals, such as a space-filling Hilbert curve. Check out the resources listed at the end of this chapter to learn more about those advanced implementations. The primary benefit of the L-system simulator, however, is that it allows you to experiment with your own axioms and rules. Perhaps you’ll come up with a brand-new fractal that no one has seen before and name it after yourself!</p>
</section>
</section>
<section aria-labelledby="sec20" epub:type="division">
<h3 class="h"><span id="sec20"/><span id="h1-42"/><span class="sans_futura_std_bold_b_">The Mighty Mandelbrot Set</span></h3>
<p class="tni">No discussion of fractals would be complete without examining the Mandelbrot set, or M-set, and appreciating its complexity and beauty. The M-set differs from the other fractals we’ve discussed so far in two important ways. First, it’s a nonlinear fractal, meaning its building blocks are made up of pixels organized in complex patterns instead of only straight lines. Second, it’s mapped on a complex plane, so it requires us to use complex numbers.</p>
<p class="tx">The M-set hinges on the iterative properties of the deceptively simple quadratic function, shown in Equation 6.1.</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>f</mi><mtext> </mtext><mfenced><mi>z</mi></mfenced><mo>=</mo><msup><mi>z</mi><mn>2</mn></msup><mo>+</mo><mi>c</mi></mrow></math> (6.1)</span>
<span class="mobi"><img alt="" class="img1" height="44" src="../images/eq6-1.jpg" width="1387"/></span></figure>
<p class="tx">Here <i class="calibre9">c</i> is a constant. By “iterative properties,” I mean the way the value of <i class="calibre9">f</i>(<i class="calibre9">z</i>) changes if we start with some initial seed value for <i class="calibre9">z</i> and then <span aria-label="253" epub:type="pagebreak" id="pg_253" role="doc-pagebreak"/>recursively feed the value of the equation back into itself as the new <i class="calibre9">z</i> value. Equation 6.2 shows the recursive form of this function.</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msub><mi>z</mi><mi>n</mi></msub><mo>=</mo><msubsup><mi>z</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></msubsup><mo>+</mo><mi>c</mi></mrow></math> (6.2)</span>
<span class="mobi"><img alt="" class="img1" height="47" src="../images/eq6-2.jpg" width="1387"/></span></figure>
<p class="tx">The list of numbers generated by repeated iterations of Equation 6.2, given a particular seed value <i class="calibre9">z</i><sub class="calibre19">0</sub> and constant <i class="calibre9">c</i>, is known as the <i class="calibre9">orbit</i> of the function. <a href="chapter6.xhtml#tab6-5" class="calibre2">Table 6-5</a> shows the orbits for a few different (<i class="calibre9">z</i><sub class="calibre19">0</sub>, <i class="calibre9">c</i>) combinations.</p>
<p class="tt" id="tab6-5"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 6-5:</span></span> <span class="sans_futura_std_book_">Selected Orbits of Quadratic Function</span> <span class="sans_futura_std_book_oblique_">f</span><span class="sans_futura_std_book_">(</span><span class="sans_futura_std_book_oblique_">z</span><span class="sans_futura_std_book_">) =</span> <span class="sans_futura_std_book_oblique_">z</span><span class="sans_futura_std_book_sup_">2</span> <span class="sans_futura_std_book_">+</span> <span class="sans_futura_std_book_oblique_">c</span></p>
<table class="basic-table">
<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_condensed_oblique_">n</span><br class="calibre1"/><span class="sans_futura_std_bold_b_">(iteration)</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Case 1:</span><br class="calibre1"/><span class="sans_futura_std_bold_condensed_oblique_">z</span><span class="sans_futura_std_heavy_sub_">0</span> <span class="sans_futura_std_bold_b_">= 0,</span> <span class="sans_futura_std_bold_condensed_oblique_">c</span> <span class="sans_futura_std_bold_b_">= 1</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Case 2:</span><br class="calibre1"/><span class="sans_futura_std_bold_condensed_oblique_">z</span><span class="sans_futura_std_heavy_sub_">0</span> <span class="sans_futura_std_bold_b_">= 0,</span> <span class="sans_futura_std_bold_condensed_oblique_">c</span> <span class="sans_futura_std_bold_b_">= –1</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Case 3:</span><br class="calibre1"/><span class="sans_futura_std_bold_condensed_oblique_">z</span><span class="sans_futura_std_heavy_sub_">0</span> <span class="sans_futura_std_bold_b_">= 0,</span> <span class="sans_futura_std_bold_condensed_oblique_">c</span> <span class="sans_futura_std_bold_b_">= –0.65</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">1</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">1</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">–1</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">–0.65</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">2</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">2</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">0</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">–0.22749999</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">3</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">5</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">–1</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">–0.59824375</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">4</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">26</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">0</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">–0.29210441</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">5</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">677</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">–1</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">–0.56467501</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">6</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">458,330</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">0</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">–0.33114213</span></p></td>
</tr>
<tr class="calibre16">
<td class="tbl"><p class="tableheader"><span class="sans_futura_std_book_">7</span></p></td>
<td class="tbl"><p class="tableheader"><span class="sans_futura_std_book_">Very large number!</span></p></td>
<td class="tbl"><p class="tableheader"><span class="sans_futura_std_book_">–1</span></p></td>
<td class="tbl"><p class="tableheader"><span class="sans_futura_std_book_">–0.54034488</span></p></td>
</tr>
</tbody>
</table>
<p class="tx">Each case in <a href="chapter6.xhtml#tab6-5" class="calibre2">Table 6-5</a> uses a seed value of 0 but a different constant. Notice how minor variations in the value of the constant can set the orbit off on a completely different path. In general, the orbit will either diverge, meaning the function values will become increasingly large due to exponential growth (as in case 1), or remain bounded, such that the orbit values stay within a certain range. If the latter, several variations are possible:</p>
<ul class="ul">
<li class="listbullet">The orbit cycles through a fixed set of values (as in case 2, where the cycle has a period of 2).</li>
<li class="listbullet">The orbit converges toward a fixed value; in case 3, the function value converges to –0.4486 after approximately 100 iterations.</li>
<li class="listbullet">The orbit remains fixed on a single value (for example, when <span class="listbullet_italic">z</span><sub class="calibre19">0</sub> = 0 and <span class="listbullet_italic">c</span> = 0).</li>
<li class="listbullet">The orbit values remain bounded but behave chaotically, showing no apparent pattern.</li>
</ul>
<p class="tx">All this hidden complexity is governed by the constant <i class="calibre9">c</i> as it takes on different values. So far, however, we’ve used only real numbers as values of <i class="calibre9">c</i>. It’s time to introduce complex numbers into the mix—values of <i class="calibre9">c</i> that satisfy this equation:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mi>c</mi><mo>=</mo><mi>x</mi><mo>+</mo><mi>i</mi><mi>y</mi></mrow></math> (6.3)</span>
<span class="mobi"><img alt="" class="img1" height="40" src="../images/eq6-3.jpg" width="1387"/></span></figure>
<p class="tx">Here <i class="calibre9">x</i> and <i class="calibre9">y</i> are real numbers, and <i class="calibre9">i</i> is <span class="copyright_accent">√</span>–1. <a href="chapter6.xhtml#tab6-6" class="calibre2">Table 6-6</a> shows a few examples of our quadratic function using complex values of <i class="calibre9">c</i>.</p>
<span aria-label="254" epub:type="pagebreak" id="pg_254" role="doc-pagebreak"/>
<p class="tt" id="tab6-6"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 6-6:</span></span> <span class="sans_futura_std_book_">Selected Orbits of Quadratic Function</span> <span class="sans_futura_std_book_oblique_">f</span><span class="sans_futura_std_book_">(</span><span class="sans_futura_std_book_oblique_">z</span><span class="sans_futura_std_book_">) =</span> <span class="sans_futura_std_book_oblique_">z</span><span class="sans_futura_std_book_sup_">2</span> <span class="sans_futura_std_book_">+</span> <span class="sans_futura_std_book_oblique_">c</span><span class="sans_futura_std_book_">, Where</span> <span class="sans_futura_std_book_oblique_">c</span> <span class="sans_futura_std_book_">=</span> <span class="sans_futura_std_book_oblique_">x</span> <span class="sans_futura_std_book_">+</span> <span class="sans_futura_std_book_oblique_">iy</span></p>
<table class="basic-table">
<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_condensed_oblique_">n</span> <span class="sans_futura_std_bold_b_">(iteration)</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Case 1:</span> <span class="sans_futura_std_bold_condensed_oblique_">z</span><span class="sans_futura_std_heavy_sub_">0</span> <span class="sans_futura_std_bold_b_">= 0,</span> <span class="sans_futura_std_bold_condensed_oblique_">c</span> <span class="sans_futura_std_bold_b_">= 0 +</span> <span class="sans_futura_std_bold_condensed_oblique_">i</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Case 2:</span> <span class="sans_futura_std_bold_condensed_oblique_">z</span><span class="sans_futura_std_heavy_sub_">0</span> <span class="sans_futura_std_bold_b_">= 0,</span> <span class="sans_futura_std_bold_condensed_oblique_">c</span> <span class="sans_futura_std_bold_b_">= 0 + 2</span><span class="sans_futura_std_bold_condensed_oblique_">i</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">1</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_oblique_">i</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_futura_std_book_">2</span><span class="sans_futura_std_book_oblique_">i</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">2</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">–1 +</span> <span class="sans_futura_std_book_oblique_">i</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">–4 + 2</span><span class="sans_futura_std_book_oblique_">i</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">3</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">–</span><span class="sans_futura_std_book_oblique_">i</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">12 – 14</span><span class="sans_futura_std_book_oblique_">i</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">4</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">–1 +</span> <span class="sans_futura_std_book_oblique_">i</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">–52 – 334</span><span class="sans_futura_std_book_oblique_">i</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">5</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">–</span><span class="sans_futura_std_book_oblique_">i</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">–108,852 + 34,738</span><span class="sans_futura_std_book_oblique_">i</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">6</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">–1 +</span> <span class="sans_futura_std_book_oblique_">i</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_futura_std_book_">Far away from (0, 0)</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">7</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">–</span><span class="sans_futura_std_book_oblique_">i</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_futura_std_book_">Very far away from (0, 0)</span></p></td>
</tr>
<tr class="calibre14">
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">M-set membership</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">Member</span></p></td>
<td class="tbl"><p class="tb1"><span class="sans_futura_std_book_">Nonmember</span></p></td>
</tr>
</tbody>
</table>
<p class="tx">As with real values of <i class="calibre9">c</i>, complex values also produce two types of orbits: bounded (like case 1) or unbounded (like case 2). Given this, we’re now ready to define the Mandelbrot set as the set of all complex numbers <i class="calibre9">c</i> for which the corresponding orbit generated by recursive function <i class="calibre9">f</i>(<i class="calibre9">z</i>) = <i class="calibre9">z</i><sup class="calibre8">2</sup> + <i class="calibre9">c</i> remains bounded, given a seed of <i class="calibre9">z</i><sub class="calibre19">0</sub> = 0. Thus, looking at <a href="chapter6.xhtml#tab6-6" class="calibre2">Table 6-6</a>, <i class="calibre9">c</i> = 0 + <i class="calibre9">i</i> is a member of the Mandelbrot set, while <i class="calibre9">c</i> = 0 + 2<i class="calibre9">i</i> is not.</p>
<p class="tx">We visualize the Mandelbrot set by plotting the set’s members on a <i class="calibre9">complex plane</i>, a coordinate system where the x-axis represents the real component of a complex number (<i class="calibre9">x</i> in Equation 6.3) and the y-axis represents the imaginary component (<i class="calibre9">y</i> in Equation 6.3). Given these x- and y-values, the magnitude of the orbit of a complex number is calculated as:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mo>|</mo><mi>a</mi><mo>|</mo><mtext> </mtext><mo>=</mo><mtext> </mtext><msqrt><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow></msqrt></mrow></math> (6.4)</span>
<span class="mobi"><img alt="" class="img1" height="48" src="../images/eq6-4.jpg" width="1389"/></span></figure>
<p class="tx">When a complex number is plotted as a point on the complex plane, the magnitude of the orbit would be the distance of that point from the origin.</p>
<p class="headaexercise" id="pre-26"><span class="sans_dogma_ot_bold_b_15-n">Project 26: Code and Visualize the Mandelbrot Set</span></p>
<p class="tni">Let’s turn our attention to creating an app that will help us visualize the M-set. Our definition of the M-set provides some clues about what’s required: we need to find and plot the complex values of <i class="calibre9">c</i> that cause our quadratic function (Equation 6.1) to remain bounded as it iterates. However, we still need a few clarifications. First, what region of the complex plane should we investigate? It would help to know if the M-set members are clustered in a certain region or dispersed over a large area. Also, since the quadratic function can continue iterating ad infinitum, it isn’t clear when exactly we should conclude that an orbit is bounded or unbounded. We could limit ourselves to a certain number of iterations, consult the magnitude of the orbit as defined by Equation 6.4, or both.</p>
<p class="tx">Fortunately, researchers have already uncovered helpful facts about the M-set that we can draw on to make our search efficient and practical. First, from numerous plots of the M-set already created, we know that the search space can be limited to an area bounded by [–2.0, 1.0] along the real <span aria-label="255" epub:type="pagebreak" id="pg_255" role="doc-pagebreak"/>axis (x-axis) and [–1.5, 1.5] along the imaginary axis (y-axis). Second, it’s also known that the M-set is a closed set entirely contained inside a circle of radius 2 around the origin. This means that a complex number <i class="calibre9">c</i> can’t be a member of the set if |<i class="calibre9">z</i><span class="epub-i-sub">n</span>| &gt; 2 for any <i class="calibre9">n</i> &gt; 0. We’ll use this as a termination condition for the bounded/unbounded test. Otherwise, if we complete some threshold number of iterations (<span class="sans_thesansmonocd_w5regular_">iterMax</span>) without |<i class="calibre9">z</i><span class="epub-i-sub">n</span>| exceeding 2, we’ll consider <i class="calibre9">c</i> to be a member of the M-set.</p>
<p class="tx">We’ll set <span class="sans_thesansmonocd_w5regular_">iterMax</span> to <span class="sans_thesansmonocd_w5regular_">400</span> for a relatively clean image of the M-set, but I encourage you to experiment by setting <span class="sans_thesansmonocd_w5regular_">iterMax</span> lower or higher. In general, lower <span class="sans_thesansmonocd_w5regular_">iterMax</span> values will likely show more noise as well as various zones of convergence. As the number of iterations increases (the test condition becomes more stringent), the fractal boundary tends to become crisper.</p>
<section aria-labelledby="sec21" epub:type="division">
<h4 class="h1"><span id="sec21"/><span id="h2-111"/><span class="sans_futura_std_bold_condensed_oblique_">The Code</span></h4>
<p class="tni">Despite the sophisticated nature of the concept, the code for creating the M-set is relatively minimal. The app we’ll create will have the following features and functionalities:</p>
<ul class="ul">
<li class="listbullet">The problem definition (done through a small number of global variables)</li>
<li class="listbullet">The ability to iterate over the search space point by point</li>
<li class="listbullet">The ability to check M-set membership conditions for each of those points</li>
<li class="listbullet">The ability to draw the point on the canvas with a chosen color scheme</li>
</ul>
<p class="tx">In addition, we’ll need to adjust the scale of the image to ensure that the search space is properly mapped onto a canvas of a given size.</p>
<section aria-labelledby="sec22" epub:type="division">
<h5 class="h2"><span id="sec22"/><span id="h3-51"/><span class="sans_futura_std_bold_b_">Declaring Global Variables</span></h5>
<p class="tni">First, we’ll declare some global variables. This code segment defines the bounds for the real and imaginary axes, sets the canvas size, determines the search increment along the x- and y-axes, and limits the number of iterations for the quadratic function.</p>
<pre class="calibre10"><code class="calibre11">// problem definition and global parameters
val xMin = -2.0
val xMax = 1.0
val yMin = -1.5
val yMax = 1.5
val xRange = xMax - xMin
val yRange = yMax - yMin

val canvasW = 600.0
val canvasH = (canvasW / xRange) * yRange
val increment = 0.003
val iterMax = 400</code></pre>
<p class="tx"><span aria-label="256" epub:type="pagebreak" id="pg_256" role="doc-pagebreak"/>We set <span class="sans_thesansmonocd_w5regular_">xMin</span> and <span class="sans_thesansmonocd_w5regular_">xMax</span> as the lower and upper bounds for the real values of <i class="calibre9">c</i>; similarly, <span class="sans_thesansmonocd_w5regular_">yMin</span> and <span class="sans_thesansmonocd_w5regular_">yMax</span> are the lower and upper bounds for the imaginary part of <i class="calibre9">c</i>. The corresponding ranges (<span class="sans_thesansmonocd_w5regular_">xRange</span> and <span class="sans_thesansmonocd_w5regular_">yRange</span>) define a rectangular search space we’ll explore to find potential M-set members.</p>
<p class="tx">Next, we set the width of the canvas, <span class="sans_thesansmonocd_w5regular_">canvasW</span>, to 600 pixels and the height of the canvas, <span class="sans_thesansmonocd_w5regular_">canvasH</span>, to a value that will maintain the proportionality of the image (meaning that the M-set, when plotted, won’t look distorted). The benefit of this approach is that you only need to adjust <span class="sans_thesansmonocd_w5regular_">canvasW</span> if you want to create a larger or smaller image.</p>
<p class="tx">We set the last two parameters, <span class="sans_thesansmonocd_w5regular_">increment</span> and <span class="sans_thesansmonocd_w5regular_">iterMax</span>, to <span class="sans_thesansmonocd_w5regular_">0.003</span> and <span class="sans_thesansmonocd_w5regular_">400</span>, respectively. These values will determine the overall image quality. It’s possible to link the <span class="sans_thesansmonocd_w5regular_">increment</span> parameter to <span class="sans_thesansmonocd_w5regular_">canvasW</span> and have it automatically calculated—you’re welcome to try that out as a simple experiment.</p>
</section>
<section aria-labelledby="sec23" epub:type="division">
<h5 class="h2"><span id="sec23"/><span id="h3-52"/><span class="sans_futura_std_bold_b_">Finding and Drawing M-Set Members</span></h5>
<p class="tni">We’ll now declare a function to iterate over the search space, check whether a particular complex number <i class="calibre9">c</i> is within the M-set, and mark the corresponding points on the canvas by using a color scheme.</p>
<pre class="calibre10"><code class="calibre11">// function to iterate over the search space and draw
// nonmembers using a grayscale and members as black points

private fun drawMSet(gc: GraphicsContext) {
    var y = yMin
  <span aria-label="annotation1" class="code_codeannotation">❶</span> while (y &lt;= yMax) {
        var x = xMin
      <span aria-label="annotation2" class="code_codeannotation">❷</span> while (x &lt;= xMax) {
          <span aria-label="annotation3" class="code_codeannotation">❸</span> val cval = getConvergence(x, y)
          <span aria-label="annotation4" class="code_codeannotation">❹</span> val speed = cval.toDouble() / iterMax
            val factor = 1.0 - speed
            gc.fill = Color.color(factor, factor, factor)
          <span aria-label="annotation5" class="code_codeannotation">❺</span> gc.fillRect(canvasW * (x - xMin)/ xRange,
                canvasH * (y - yMin)/ yRange, 1.0, 1.0)
            x += increment
        }
        y += increment
    }
}</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">drawMSet()</span> function uses a nested pair of <span class="sans_thesansmonocd_w5regular_">while</span> loops to iterate over the search space. The outer loop <span aria-label="annotation1" class="codeannotation">❶</span> iterates along the y-axis, starting with the minimum <span class="sans_thesansmonocd_w5regular_">y</span> value, <span class="sans_thesansmonocd_w5regular_">yMin</span>, and ending when <span class="sans_thesansmonocd_w5regular_">y</span> reaches the upper bound, <span class="sans_thesansmonocd_w5regular_">yMax</span>, incrementing <span class="sans_thesansmonocd_w5regular_">y</span> by <span class="sans_thesansmonocd_w5regular_">increment</span> (which we set to <span class="sans_thesansmonocd_w5regular_">0.003</span>) each time. The inner <span class="sans_thesansmonocd_w5regular_">while</span> loop <span aria-label="annotation2" class="codeannotation">❷</span> does the same along the x-axis. With each iteration, we get an (<i class="calibre9">x, y</i>) pair representing a complex number (as defined by Equation 6.3), which we pass to the <span class="sans_thesansmonocd_w5regular_">getConvergence()</span> function <span aria-label="annotation3" class="codeannotation">❸</span> to check if that number belongs to the M-set (we’ll look at that function next).</p>
<p class="tx">Calling <span class="sans_thesansmonocd_w5regular_">getConvergence()</span> returns the number of iterations of the quadratic function it carried out. We divide this by <span class="sans_thesansmonocd_w5regular_">iterMax</span> to measure how <span aria-label="257" epub:type="pagebreak" id="pg_257" role="doc-pagebreak"/>quickly the convergence decision was made <span aria-label="annotation4" class="codeannotation">❹</span>. If this resulting value (<span class="sans_thesansmonocd_w5regular_">speed</span>) is <span class="sans_thesansmonocd_w5regular_">1</span>, the number of iterations must have been <span class="sans_thesansmonocd_w5regular_">iterMax</span>, indicating that the orbit of <i class="calibre9">c</i> remained bounded. Therefore, we’ll count this particular complex number as a member of the M-set. If <span class="sans_thesansmonocd_w5regular_">speed</span> is less than <span class="sans_thesansmonocd_w5regular_">1</span>, however, that would mean the orbit jumped outside the circle of radius 2 before reaching the maximum number of iterations, so we won’t consider that number to be an M-set member.</p>
<p class="tx">We subtract <span class="sans_thesansmonocd_w5regular_">speed</span> from <span class="sans_thesansmonocd_w5regular_">1</span> and use the result (<span class="sans_thesansmonocd_w5regular_">factor</span>) to set the color of the corresponding point on the canvas, according to a grayscale scheme where (1, 1, 1) means white and (0, 0, 0) means black. If the orbit diverged very quickly, <span class="sans_thesansmonocd_w5regular_">factor</span> will be close to <span class="sans_thesansmonocd_w5regular_">1</span>, so the point on the canvas representing this number will be marked with a white or nearly white pixel. Conversely, if the orbit diverged only after many more iterations (but before reaching the maximum allowed), <span class="sans_thesansmonocd_w5regular_">factor</span> will be closer to <span class="sans_thesansmonocd_w5regular_">0</span>, so the corresponding point would be marked with a darker pixel. Of course, if the orbit remains bounded, <span class="sans_thesansmonocd_w5regular_">factor</span> will be exactly <span class="sans_thesansmonocd_w5regular_">0</span>, and the corresponding point will be marked with a pure black pixel, signifying that the point belongs to the M-set.</p>
<p class="tx">Finally, we plot the number by mapping its (<i class="calibre9">x</i>, <i class="calibre9">y</i>) coordinate pair onto a pixel location on the canvas <span aria-label="annotation5" class="codeannotation">❺</span>, using the scaling factor illustrated in <a href="chapter6.xhtml#fig6-12" class="calibre2">Figure 6-12</a>.</p>
<figure class="img"><img alt="" class="img1" height="318" id="fig6-12" src="../images/Figure6-12.jpg" width="1134"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 6-12: Mapping the x-coordinate of</span> <span class="sans_futura_std_book_">c</span> <span class="sans_futura_std_book_oblique_">to the x-value of the pixel on the canvas</span></p></figcaption>
</figure>
<p class="tx">We’re using the proportionality rule to map the x-coordinate to a point on the canvas designated as <i class="calibre9">w</i>. We apply the same principle to the y-coordinate as well.</p>
</section>
<section aria-labelledby="sec24" epub:type="division">
<h5 class="h2"><span id="sec24"/><span id="h3-53"/><span class="sans_futura_std_bold_b_">Checking for Convergence</span></h5>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">getConvergence()</span> function takes in an (<i class="calibre9">x</i>, <i class="calibre9">y</i>) pair as arguments and checks if the corresponding complex number belongs to the M-set.</p>
<pre class="calibre10"><code class="calibre11">// function to check for membership in the M-set
private fun getConvergence(x: Double, y: Double): Int {
    var zx = 0.0
    var zy = 0.0
  <span aria-label="annotation1" class="code_codeannotation">❶</span> for (i in 1..iterMax) {
        val X = zx * zx – zy * zy + x
        val Y = 2 * zx * zy + y
      <span aria-label="annotation2" class="code_codeannotation">❷</span> if (X * X + Y * Y &gt; 4.0) return i
        zx = X
<span aria-label="258" epub:type="pagebreak" id="pg_258" role="doc-pagebreak"/>        zy = Y
    }
    return iterMax
}</code></pre>
<p class="tx">To follow the logic of the code, we need a bit of algebra. Recall from Equation 6.2 that the recursive form of our quadratic function is <i class="calibre9">z</i><span class="epub-i-sub">n</span> = <i class="calibre9">z</i><sup class="calibre8">2</sup><span class="epub-i-sub">n</span> <sub class="calibre19">– 1</sub> + <i class="calibre9">c</i>. For any value of <i class="calibre9">n</i> &gt; 1, <i class="calibre9">z</i><span class="epub-i-sub">n</span> <sub class="calibre19">– 1</sub> will be a complex number that can be expressed as:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msub><mi>z</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>z</mi><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mfenced><mrow><mi>i</mi><mtext> </mtext><mi>z</mi><msub><mi>y</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow></mfenced></mrow></math> (6.5)</span>
<span class="mobi"><img alt="" class="img1" height="43" src="../images/eq6-5.jpg" width="1389"/></span></figure>
<p class="tx">In Equation 6.5, <i class="calibre9">zx</i><span class="epub-i-sub">n</span> <sub class="calibre19">– 1</sub> is the real part of <i class="calibre9">z</i><span class="epub-i-sub">n</span> <sub class="calibre19">– 1</sub>, and <i class="calibre9">zy</i><span class="epub-i-sub">n</span> <sub class="calibre19">– 1</sub> is the complex part. We can now rewrite Equation 6.2 by using Equations 6.3 and 6.5. After simplification, we get:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msub><mi>z</mi><mi>n</mi></msub><mo>=</mo><mo stretchy="false">(</mo><mi>z</mi><msubsup><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></msubsup><mo>−</mo><mi>z</mi><msubsup><mi>y</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mn>2</mn></msubsup><mo>+</mo><mi>x</mi><mo stretchy="false">)</mo><mo>+</mo><mi>i</mi><mo stretchy="false">(</mo><mn>2</mn><mi>z</mi><msub><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mtext> </mtext><mi>z</mi><msub><mi>y</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></math> (6.6)</span>
<span class="mobi"><img alt="" class="img1" height="46" src="../images/eq6-6.jpg" width="1389"/></span></figure>
<p class="tni">Equation 6.6 can be further simplified as:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><msub><mi>z</mi><mi>n</mi></msub><mo>=</mo><mi>X</mi><mo>+</mo><mi>i</mi><mi>Y</mi></mrow></math> (6.7)</span>
<span class="mobi"><img alt="" class="img1" height="45" src="../images/eq6-7.jpg" width="1389"/></span></figure>
<p class="tni">where <i class="calibre9">X</i> = (<i class="calibre9">zx</i><sup class="calibre8">2</sup><span class="epub-i-sub">n</span> <sub class="calibre19">– 1</sub> – <i class="calibre9">zy</i><sup class="calibre8">2</sup><span class="epub-i-sub">n</span> <sub class="calibre19">– 1</sub> + <i class="calibre9">x</i>) and <i class="calibre9">Y</i> = (2<i class="calibre9">zx</i><span class="epub-i-sub">n</span> <sub class="calibre19">– 1</sub> <i class="calibre9">zy</i><span class="epub-i-sub">n</span> <sub class="calibre19">– 1</sub> + <i class="calibre9">y</i>).</p>
<p class="tx">Thinking back to Equation 6.4, we check if the magnitude of <i class="calibre9">z</i><span class="epub-i-sub">n</span> lies outside a circle of radius 2 by confirming whether:</p>
<figure class="img4"><span class="epub"><math alttext="Equation" display="inline"><mrow><mfenced close="|" open="|"><mrow><msub><mi>z</mi><mi>n</mi></msub></mrow></mfenced><mo>=</mo><msqrt><mrow><msup><mi>X</mi><mn>2</mn></msup><mo>+</mo><msup><mi>Y</mi><mn>2</mn></msup></mrow></msqrt><mo>&gt;</mo><mn>2</mn><mo>,</mo><mtext> </mtext><mtext>or</mtext><mtext> </mtext><msup><mi>X</mi><mn>2</mn></msup><mo>+</mo><msup><mi>Y</mi><mn>2</mn></msup><mo>&gt;</mo><mn>4</mn></mrow></math> (6.8)</span>
<span class="mobi"><img alt="" class="img1" height="50" src="../images/eq6-8.jpg" width="1389"/></span></figure>
<p class="tx">Returning to our code, we start by setting real and imaginary components <span class="sans_thesansmonocd_w5regular_">zx</span> and <span class="sans_thesansmonocd_w5regular_">zy</span> to <span class="sans_thesansmonocd_w5regular_">0</span>, the equivalent of setting seed value <i class="calibre9">z</i><sub class="calibre19">0</sub> to 0. Next, the <span class="sans_thesansmonocd_w5regular_">for</span> loop <span aria-label="annotation1" class="codeannotation">❶</span> iterates over Equation 6.7, calculating the values of <span class="sans_thesansmonocd_w5regular_">X</span> and <span class="sans_thesansmonocd_w5regular_">Y</span>. With each iteration, we check if the magnitude of <i class="calibre9">z</i><span class="epub-i-sub">n</span> exceeds <span class="sans_thesansmonocd_w5regular_">2</span> <span aria-label="annotation2" class="codeannotation">❷</span>, per Equation 6.8. If so, the complex number <i class="calibre9">c</i> represented by the (<i class="calibre9">x</i>, <i class="calibre9">y</i>) pair isn’t a member of the M-set, and we return the number of iterations it took to reach that conclusion. Otherwise, the iteration continues until we reach <span class="sans_thesansmonocd_w5regular_">iterMax</span>. If <i class="calibre9">z</i><span class="epub-i-sub">n</span> remains bounded the whole time, we return <span class="sans_thesansmonocd_w5regular_">iterMax</span> to indicate that the number is a member of the M-set.</p>
</section>
<section aria-labelledby="sec25" epub:type="division">
<h5 class="h2"><span id="sec25"/><span id="h3-54"/><span class="sans_futura_std_bold_b_">Bringing Everything Together</span></h5>
<p class="tni">Let’s take a look at how all these code segments fit together.</p>
<pre class="calibre10"><code class="calibre11">// import statements
<var class="calibre18">--snip--</var>

// problem definition and global declarations
<var class="calibre18">--snip--</var>

// function to iterate over the search space and draw
// nonmembers using a grayscale and members as black points
fun drawMSet(gc: GraphicsContext) {
<var class="calibre18">--snip--</var>
}

<span aria-label="259" epub:type="pagebreak" id="pg_259" role="doc-pagebreak"/>// function to check for membership in the M-set
fun getConvergence(x: Double, y: Double): Int {
<var class="calibre18">--snip--</var>
}

// Application class for drawing the M-set
class Mandelbrot : Application() {
    override fun start(stage: Stage) {
        val root = Pane()
        val canvas = Canvas(canvasW, canvasH)
        val gc = canvas.graphicsContext2D
        root.children.add(canvas)

        val scene = Scene(root, canvasW, canvasH)
        scene.fill = Color.WHITE
        stage.title = "Mandelbrot Set"
        stage.scene = scene
        stage.show()

        // Search for M-set members and draw them on the canvas.
<b class="calibre6">        </b>drawMSet(gc)
    }
}

// the main function to launch the application
fun main() {
    Application.launch(Mandelbrot::class.java)
}</code></pre>
<p class="tx">Other than our global declarations and our two function definitions, the only other problem-specific code is a single call to <span class="sans_thesansmonocd_w5regular_">drawMSet()</span> to create and draw a fractal. It’s remarkable that despite the M-set’s complexity, only a few lines of code are required to generate the fractal.</p>
</section>
</section>
<section aria-labelledby="sec26" epub:type="division">
<h4 class="h1"><span id="sec26"/><span id="h2-112"/><span class="sans_futura_std_bold_condensed_oblique_">The Result</span></h4>
<p class="tni">Let’s use our app to explore the Mandelbrot set, which remains one of the most enigmatic mathematical objects ever discovered. Given the parameter values we used in <span>“Declaring Global Variables”</span> on <span><a href="#pg_255" class="calibre2">page 255</a></span>, <a href="chapter6.xhtml#fig6-13" class="calibre2">Figure 6-13</a> shows the core M-set (the dark region) and some of its features.</p>
<span aria-label="260" epub:type="pagebreak" id="pg_260" role="doc-pagebreak"/>
<figure class="img"><img alt="" class="img1" height="584" id="fig6-13" src="../images/Figure6-13.jpg" width="1161"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 6-13: The Mandelbrot set</span></p></figcaption>
</figure>
<p class="tx">The central, heart-shaped part of the M-set is called the <i class="calibre9">cardioid</i>. The circular part to the left of the cardioid is called the main <i class="calibre9">bulb</i>. It’s a circle centered at (–1.0, 0.0), with a radius of 0.25. Numerous other bulbs are attached to the main bulb and the cardioid all around their boundaries, and those bulbs seem to have antennas or tentacles. When we zoom in on them, we notice intricate patterns and even smaller cardioid-like features with their own bulbs and tentacles. In other words, some features of the M-set are replicated again and again, no matter how small the scale is (even though the replication is not exact)—a defining feature of any fractal.</p>
<p class="tx">The finer patterns, visible after sufficient magnification, aren’t simple geometric shapes; instead, they’re beautifully intricate and detailed in nature. <a href="chapter6.xhtml#fig6-14" class="calibre2">Figure 6-14</a> shows magnified versions of two specific regions of interest, the <i class="calibre9">seahorse valley</i> and the <i class="calibre9">elephant valley</i>, as identified in <a href="chapter6.xhtml#fig6-13" class="calibre2">Figure 6-13</a>.</p>
<figure class="img"><img alt="" class="img1" height="669" id="fig6-14" src="../images/Figure6-14.jpg" width="1350"/>
<figcaption><p class="cap"><span class="sans_futura_std_book_oblique_">Figure 6-14: The seahorse valley (left) and the elephant valley (right)</span></p></figcaption>
</figure>
<p class="tx"><span aria-label="261" epub:type="pagebreak" id="pg_261" role="doc-pagebreak"/>You can generate both of these figures by changing the search region and using appropriate parameter values in your app, as summarized in <a href="chapter6.xhtml#tab6-7" class="calibre2">Table 6-7</a>.</p>
<p class="tt" id="tab6-7"><span class="sans_futura_std_bold_b_"><span class="sans_futura_std_bold_b_">Table 6-7:</span></span> <span class="sans_futura_std_book_">Search Region and Parameter Values for Select Regions of the M-set</span></p>
<table class="basic-table">
<thead class="calibre13">
<tr class="calibre14">
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Parameter</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Seahorse valley</span></p></th>
<th class="tch" scope="col"><p class="tableheader"><span class="sans_futura_std_bold_b_">Elephant valley</span></p></th>
</tr>
</thead>
<tbody class="calibre15">
<tr class="calibre16">
<td class="tbf"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">xMin</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">-0.8</span></p></td>
<td class="tbf"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">0.275</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">xMax</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">-0.7</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">0.325</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">yMin</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">-0.2</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">-0.05</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">yMax</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">-0.1</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">0.0</span></p></td>
</tr>
<tr class="calibre16">
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">canvasW</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">600</span></p></td>
<td class="tb"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">600</span></p></td>
</tr>
<tr class="calibre14">
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">increment</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">0.0001</span></p></td>
<td class="tb"><p class="tb1"><span class="sans_thesansmonocd_w5regular_">0.00005</span></p></td>
</tr>
<tr class="calibre16">
<td class="tbl"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">iterMax</span></p></td>
<td class="tbl"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">200</span></p></td>
<td class="tbl"><p class="tableheader"><span class="sans_thesansmonocd_w5regular_">200</span></p></td>
</tr>
</tbody>
</table>
<p class="tx">Enjoy exploring the M-set by using these parameters, or come up with your own parameter values and see what other features you can find.</p>
<aside aria-label="box-34" class="box2">
<p class="boxtitle" id="box-34"><span class="sans_futura_std_bold_b_">EXERCISE</span></p>
<p class="boxfirst"><span class="sans_futura_std_book_">Modify the code used for drawing the M-set to draw a Julia set, shown here:</span></p>
<figure class="img4"><img alt="" class="img2" height="696" src="../images/pg261.jpg" width="968"/></figure>
<p class="box1"><span class="sans_futura_std_book_">Julia sets are drawn using the same equation as the M-set (Equation 6.2), but instead of using (</span><span class="sans_futura_std_book_oblique_">x</span><span class="sans_futura_std_book_">,</span> <span class="sans_futura_std_book_oblique_">y</span><span class="sans_futura_std_book_">) pairs to set the value of</span> <span class="sans_futura_std_book_oblique_">c</span><span class="sans_futura_std_book_">, you use them to set the initial value of</span> <span class="sans_futura_std_book_oblique_">z</span><span class="sans_futura_std_book_">. That is,</span> <span class="sans_futura_std_book_oblique_">z</span><span class="sans_futura_std_book_sub_">0</span> <span class="sans_futura_std_book_">=</span> <span class="sans_futura_std_book_oblique_">x</span> <span class="sans_futura_std_book_">+</span> <span class="sans_futura_std_book_oblique_">iy</span> <span class="sans_futura_std_book_">for a given value of</span> <span class="sans_futura_std_book_oblique_">c</span><span class="sans_futura_std_book_">. For this exercise, use</span> <span class="sans_futura_std_book_oblique_">c</span> <span class="sans_futura_std_book_">= –0.4 + (</span><span class="sans_futura_std_book_oblique_">i</span> <span class="sans_futura_std_book_">× 0.6). Set</span> <span class="sans_thesansmonocd_w5regular_">canvas</span> <span class="sans_futura_std_book_">to</span> <span class="sans_thesansmonocd_w5regular_">800.0</span><span class="sans_futura_std_book_">,</span> <span class="sans_thesansmonocd_w5regular_">increment</span> <span class="sans_futura_std_book_">to</span> <span class="sans_thesansmonocd_w5regular_">0.0025</span><span class="sans_futura_std_book_">, and</span> <span class="sans_thesansmonocd_w5regular_">iterMax</span> <span aria-label="262" epub:type="pagebreak" id="pg_262" role="doc-pagebreak"/><span class="sans_futura_std_book_">to</span> <span class="sans_thesansmonocd_w5regular_">200</span><span class="sans_futura_std_book_">. The search space boundaries along the x- and y-axes should be (–2, 2) and (–1,5, 1.5), respectively.</span></p>
<p class="box1"><span class="sans_futura_std_book_">Hint: You’ll need to change the</span> <span class="sans_thesansmonocd_w5regular_">getConvergence()</span> <span class="sans_futura_std_book_">function. Additionally, to ensure that the plot is created in the first quadrant of the coordinate system, you’ll need to add two lines of code to handle the graphics (as we did for the L-system simulator):</span></p>
<pre class="calibre10"><code class="calibre11">gc.translate(0.0, canvas.height)
gc.scale(1.0, -1.0)</code></pre>
</aside>
</section>
</section>
<section aria-labelledby="sec27" epub:type="division">
<h3 class="h"><span id="sec27"/><span id="h1-43"/><span class="sans_futura_std_bold_b_">Summary</span></h3>
<p class="tni">In this chapter, you used Kotlin to explore the enigmatic beauty of fractals. You learned how to design recursive functions to help draw simple geometric fractals, and you developed an L-system simulator to generate intricate self-similar patterns based on strings of instructions and a few transformation rules. Finally, you created an application for visualizing the famous Mandelbrot set.</p>
<p class="tx">No matter what the mathematical properties of a fractal are, you now have the tools to put together a few lines of code in Kotlin and JavaFX to render it. We’ve barely scratched the surface of fractal geometry, however. In particular, you have a lot to learn about the M-set that’s beyond the scope of this book. If this chapter has aroused your interest in fractals, I encourage you to check out the listed resources for further reading.</p>
</section>
<section aria-labelledby="sec28" epub:type="division">
<h3 class="h"><span id="sec28"/><span id="h1-44"/><span class="sans_futura_std_bold_b_">Resources</span></h3>
<p class="reference">Devaney, Robert L. <i class="calibre9">An Introduction to Chaotic Dynamical Systems</i>. 3rd ed. Boca Raton, FL: CRC Press, 2022.</p>
<p class="reference">Feldman, David P. <i class="calibre9">Chaos and Fractals: An Elementary Introduction</i>. Oxford, UK: Oxford University Press, 2012.</p>
<p class="reference">Flake, Gary William. <i class="calibre9">The Computational Beauty of Nature: Computer Explorations of Fractals, Chaos, Complex Systems, and Adaptation</i>. Cambridge, MA: MIT Press, 2000.</p>
<p class="reference">Mandelbrot, Benoit B. <i class="calibre9">The Fractal Geometry of Nature</i>. San Francisco: W. H. Freeman &amp; Co., 1982.</p>
<p class="reference">Ponce Campuzano, Juan Carlos. “The Mandelbrot Set.” <i class="calibre9">Complex Analysis</i>. 2019. Accessed June 15, 2024. <i class="calibre9"><a href="https://complex-analysis.com/content/mandelbrot_set.xhtml" class="calibre2">https://complex-analysis.com/content/mandelbrot_set.xhtml</a></i>.</p>
<p class="reference"><span aria-label="263" epub:type="pagebreak" id="pg_263" role="doc-pagebreak"/>Prusinkiewicz, Przemyslaw, and Aristid Lindenmayer. <i class="calibre9">The Algorithmic Beauty of Plants</i>. Electronic version, 2004. Accessed June 15, 2024. <i class="calibre9"><a href="http://algorithmicbotany.org/papers/abop/abop.pdf" class="calibre2">http://<wbr/>algorithmicbotany<wbr/>.org<wbr/>/papers<wbr/>/abop<wbr/>/abop<wbr/>.pdf</a></i>.</p>
<p class="reference">Prusinkiewicz, Przemyslaw, Aristid Lindenmayer, and F. David Fracchia. “Synthesis of Space-Filling Curves on the Square Grid.” In <i class="calibre9">Fractals in the Fundamental and Applied Sciences</i>, edited by Heinz-Otto Peitgen, Jos<span class="copyright_accent">é</span> Marques Henriques, and Lu<span class="copyright_accent">í</span>s Filipe Penedo, 334–366. North-Holland: Elsevier, 1991.</p>
<p class="reference">Weisstein, Eric W. “Mandelbrot Set.” Wolfram MathWorld. Accessed June 15, 2024. <i class="calibre9"><a href="https://mathworld.wolfram.com/MandelbrotSet.xhtml" class="calibre2">https://mathworld.wolfram.com/MandelbrotSet.xhtml</a></i>.</p>
</section>
</section>
</div></body></html>