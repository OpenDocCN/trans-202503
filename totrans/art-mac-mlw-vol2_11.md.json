["```\nes_mute_path(es_client_t* _Nonnull client, const char* _Nonnull path,\nes_mute_path_type_t type); \n```", "```\ntypedef enum {\n    ES_MUTE_PATH_TYPE_PREFIX,\n    ES_MUTE_PATH_TYPE_LITERAL,\n    ES_MUTE_PATH_TYPE_TARGET_PREFIX,\n    ES_MUTE_PATH_TYPE_TARGET_LITERAL\n} es_mute_path_type_t; \n```", "```\n❶ #define MDS_STORE \"/System/Library/Frameworks/CoreServices.framework/Versions/\nA/Frameworks/Metadata.framework/Versions/A/Support/mds_stores\"\n\n❷ es_mute_path(client, MDS_STORE, ES_MUTE_PATH_TYPE_LITERAL); \n```", "```\n❶ char tmpDirectory[PATH_MAX] = {0};\nrealpath([NSTemporaryDirectory() UTF8String], tmpDirectory);\n\n❷ es_mute_path(client, tmpDirectory, ES_MUTE_PATH_TYPE_TARGET_PREFIX); \n```", "```\n# **ESPlayground.app/Contents/MacOS/ESPlayground -mute**\n\nES Playground\nExecuting 'mute' logic\n\n**muted process:** /System/Library/Frameworks/\nCoreServices.framework/Versions/A/Frameworks/Metadata.framework/Versions/A/Support/mds_stores\n\n**muted directory:** /private/var/folders/zz/zyxvpxvq6csfxvn_n0000000000000/T\n\nevent: ES_EVENT_TYPE_NOTIFY_OPEN\nprocess: /System/Library/CoreServices/Spotlight.app/Contents/MacOS/Spotlight\nfile path: /System/Applications/Calculator.app/Contents/MacOS/Calculator\n\nevent: ES_EVENT_TYPE_NOTIFY_CLOSE\nprocess: /System/Library/CoreServices/Spotlight.app/Contents/MacOS/Spotlight\nfile path: /System/Applications/Calculator.app/Contents/MacOS/Calculator\n\nevent: ES_EVENT_TYPE_NOTIFY_OPEN\nprocess: /System/Applications/Calculator.app/Contents/MacOS/Calculator\nfile path: / \n```", "```\n# **FileMonitor.app/Contents/MacOS/FileMonitor -pretty**\n{\n  \"event\" : \"ES_EVENT_TYPE_NOTIFY_OPEN\",\n  \"file\" : {\n    \"destination\" : \"/private/var/folders/zz/zyxvpxvq6csfxvn_n0000000000000/T\",\n    \"process\" : {\n      \"pid\" : 540,\n      \"name\" : \"mds_stores\",\n      \"path\" : \"/System/Library/Frameworks/CoreServices.framework/\n      Versions/A/Frameworks/Metadata.framework/Versions/A/Support/mds_stores\"\n    }\n  }\n  ...\n} \n```", "```\nes_return_t\nes_mute_process(es_client_t* _Nonnull client, const audit_token_t* _Nonnull audit_token); \n```", "```\nNSData* auditToken = getAuditToken(getpid());\n\nes_mute_process(client, auditToken.bytes); \n```", "```\nes_return_t es_mute_process_events(es_client_t* _Nonnull client, const audit_token_t*\n_Nonnull audit_token, const es_event_type_t* _Nonnull events, size_t event_count); \n```", "```\nclass Browsers:\ndef __init__(self, decrypter: object) -> object:\n    ...\n    self.cookies_path = []\n    self.extension_path = []\n    ...\n    self.cookies = []\n    self.decryption_keys = decrypter\n    self.appdata = '/Users/*/Library/Application Support'\n    self.browsers = {...\n        'google-chrome':self.appdata + '/Google/Chrome/',\n        ...\n        'brave':self.appdata + '/BraveSoftware/Brave-Browser/',\n        ...\n    }\n    ...\ndef browser_db(self, data, content_type):\n    ...\n    else:\n        if content_type == 'cookies':\n           sql = 'select name,encrypted_value,host_key,path,is_secure,..., from cookies'\n           keys = ['name', 'encrypted_value', 'host_key', 'path',..., 'expires_utc']\n    ...\n    if __name__ == '__main__':\n        decrypted = {}\n        browsers = Browsers()\n        paths = browsers.browser_data() \n```", "```\nes_return_t es_invert_muting(es_client_t* _Nonnull client, es_mute_inversion_type_t mute_type);\n```", "```\ntypedef enum {\n    ES_MUTE_INVERSION_TYPE_PROCESS,\n    ES_MUTE_INVERSION_TYPE_PATH,\n    ES_MUTE_INVERSION_TYPE_TARGET_PATH,\n    ES_MUTE_INVERSION_TYPE_LAST\n} es_mute_inversion_type_t; \n```", "```\nNSString* consoleUser =\n(__bridge_transfer NSString*)SCDynamicStoreCopyConsoleUser(NULL, NULL, NULL); ❶\n\nNSString* docsDirectory =\n[NSHomeDirectoryForUser(consoleUser) stringByAppendingPathComponent:@\"Documents\"];\n\nes_client_t* client = NULL;\nes_event_type_t events[] = {ES_EVENT_TYPE_NOTIFY_OPEN};\n\nes_new_client(&client, ^(es_client_t* client, const es_message_t* message) {\n    // Add code here to handle delivered events.\n});\n\nes_unmute_all_target_paths(client); ❷\nes_invert_muting(client, ES_MUTE_INVERSION_TYPE_TARGET_PATH); ❸\nes_mute_path(client, docsDirectory.UTF8String, ES_MUTE_PATH_TYPE_TARGET_PREFIX); ❹\n\nes_subscribe(client, events, sizeof(events)/sizeof(events[0])); \n```", "```\nes_new_client(&client, ^(es_client_t* client, const es_message_t* message) {\n  ❶ es_string_token_t* procPath = &message->process->executable->path;\n  ❷ es_string_token_t* filePath = &message->event.open.file->path;\n\n  ❸ printf(\"event: ES_EVENT_TYPE_NOTIFY_OPEN\\n\");\n    printf(\"process: %.*s\\n\", (int)procPath->length, procPath->data);\n    printf(\"file path: %.*s\\n\", (int)filePath->length, filePath->data);\n\n}); \n```", "```\n# **ESPlayground.app/Contents/MacOS/ESPlayground -muteinvert**\n\nES Playground\nExecuting 'mute inversion' logic\nunmuted all (default) paths\nmute (inverted) /Users/Patrick/Documents\n\nevent: ES_EVENT_TYPE_NOTIFY_OPEN\nprocess: /System/Library/CoreServices/Finder.app/Contents/MacOS/Finder\nfile path: /Users/Patrick/Documents\n\nevent: ES_EVENT_TYPE_NOTIFY_OPEN\nprocess: /bin/ls\nfile path: /Users/Patrick/Documents \n```", "```\nes_client_t* client = NULL;\n❶ es_event_type_t events[] = {ES_EVENT_TYPE_AUTH_EXEC};\n\nes_new_client(&client, ^(es_client_t* client, const es_message_t* message) {\n    // Add logic to allow or block processes.\n});\n\nes_subscribe(client, events, sizeof(events)/sizeof(events[0])); \n```", "```\nes_respond_result_t es_respond_auth_result(es_client_t* _Nonnull client,\nconst es_message_t* _Nonnull message, es_auth_result_t result, bool cache); \n```", "```\nes_client_t* client = NULL;\nes_event_type_t events[] = {ES_EVENT_TYPE_AUTH_EXEC};\n\nes_new_client(&client, ^(es_client_t* client, const es_message_t* message) {\n  ❶ es_process_t* process = message->event.exec.target;\n  ❷ es_string_token_t* procPath = &process->executable->path;\n printf(\"\\nevent: ES_EVENT_TYPE_AUTH_EXEC\\n\");\n    printf(\"process: %.*s\\n\", (int)procPath->length, procPath->data);\n\n  ❸ es_respond_auth_result(client, message, ES_AUTH_RESULT_ALLOW, false);\n\n});\n\nes_subscribe(client, events, sizeof(events)/sizeof(events[0])); \n```", "```\n# **ESPlayground.app/Contents/MacOS/ESPlayground -authorization**\n\nES Playground\nExecuting 'authorization' logic\n\nevent: ES_EVENT_TYPE_AUTH_EXEC\nprocess: /System/Applications/Calculator.app/Contents/MacOS/Calculator \n```", "```\nException Type:      EXC_CRASH (SIGKILL)\nException Codes:     0x0000000000000000, 0x0000000000000000\nTermination Reason:  Namespace ENDPOINTSECURITY, Code 2 EndpointSecurity client\nterminated because it failed to respond to a message before its deadline \n```", "```\n❶ dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);\n❷ uint64_t deadline = message->deadline - mach_absolute_time();\n\n❸ dispatch_async(dispatch_get_global_queue(QOS_CLASS_DEFAULT, 0), ^{\n  ❹ if(0 != dispatch_semaphore_wait(semaphore,\n    dispatch_time(DISPATCH_TIME_NOW, machTimeToNanoseconds(deadline)\n    - (1 * NSEC_PER_SEC)))) {\n      ❺ es_respond_auth_result(client, message, ES_AUTH_RESULT_ALLOW, false);\n  }\n}); \n```", "```\nuint64_t MachTimeToNanoseconds(uint64_t machTime) {\n    uint64_t nanoseconds = 0;\n    static mach_timebase_info_data_t sTimebase;\n    if (sTimebase.denom == 0)\n        (void)mach_timebase_info(&sTimebase);\n\n    nanoseconds = ((machTime * sTimebase.numer) / sTimebase.denom);\n    return nanoseconds;\n} \n```", "```\n#import <dlfcn.h>\nBOOL isTranslocated(NSString* path) {\n    BOOL isTranslocated = NO;\n    void* handle = dlopen(\n    \"/System/Library/Frameworks/Security.framework/Security\", RTLD_LAZY); ❶\n\n    BOOL (*SecTranslocateIsTranslocatedURL)(CFURLRef path, bool* isTranslocated,\n    CFErrorRef* __nullable error) = dlsym(handle,\"SecTranslocateIsTranslocatedURL\"); ❷\n\n    SecTranslocateIsTranslocatedURL((__bridge CFURLRef)([NSURL fileURLWithPath:path]),\n    &isTranslocated, NULL); ❸\n\n    return isTranslocated;\n} \n```", "```\n-(BOOL)block:(Event*)event {\n    BOOL blocked = NO;\n\n    if(YES != (blocked = [self respond:event action:ES_AUTH_RESULT_DENY])) {\n        os_log_error(logHandle, \"ERROR: failed to block %{public}@\", event.process.name);\n    }\n\n    return blocked;\n} \n```", "```\n-(BOOL)respond:(Event*)event action:(es_auth_result_t)action {\n    ...\n    result = es_respond_auth_result(event.esClient, event.esMessage, action, true);\n    ...\n} \n```", "```\n% **log stream**\nbackgroundtaskmanagementd: registerLaunchItem: result=no error, new item\ndisposition=[enabled, allowed, visible, not notified],\nidentifier=com.apple.softwareupdate,\nurl=file:///Users/User/Library/LaunchAgents/com.apple.softwareupdate.plist\nbackgroundtaskmanagementd: **should post advisory=false** for uid=501, id=\n6ED3BEBC-8D60-45ED-8BCC-E0163A8AA806, item=softwareupdate \n```", "```\nes_client_t* client = NULL;\nes_event_type_t events[] = {ES_EVENT_TYPE_AUTH_SIGNAL};\n\nes_new_client(&client, ^(es_client_t* client, const es_message_t* message) {\n    int signal = message->event.signal.sig; ❶\n    es_process_t* sourceProcess = message->process; ❷\n    es_process_t* targetProcess = message->event.signal.target; ❸\n\n // Add code to check if signal is a SIGSTOP or SIGKILL being sent to a process\n    // involved in showing user notification alerts.\n\n});\n\nes_subscribe(client, events, sizeof(events)/sizeof(events[0])); \n```", "```\nif((signal == SIGSTOP) || (signal == SIGKILL)) {\n    pid_t targetPID = audit_token_to_pid(targetProcess->audit_token);\n\n    if((targetPID == btmAgentPID) || (targetPID == notificationCenterPID)) {\n        es_respond_auth_result(client, message, ES_AUTH_RESULT_DENY, false);\n    }\n} \n```", "```\n% **pgrep BackgroundTaskManagementAgent**\n590\n\n% **kill -SIGSTOP 590**\nkill: kill 590 failed: operation not permitted \n```", "```\nNSString* consoleUser =\n(__bridge_transfer NSString*)SCDynamicStoreCopyConsoleUser(NULL, NULL, NULL);\n\nNSString* homeDirectory = NSHomeDirectoryForUser(consoleUser);\n\nes_client_t* client = NULL;\nes_event_type_t events[] = {ES_EVENT_TYPE_AUTH_OPEN, ES_EVENT_TYPE_AUTH_UNLINK}; ❶\n\nes_new_client(&client, ^(es_client_t* client, const es_message_t* message) {\n    // Add code here to implement logic to examine process and respond to event.\n});\n\nes_unmute_all_target_paths(client); ❷\nes_invert_muting(client, ES_MUTE_INVERSION_TYPE_TARGET_PATH);\nes_mute_path(client, homeDirectory.UTF8String, ES_MUTE_PATH_TYPE_TARGET_PREFIX); ❸\n\nes_subscribe(client, events, sizeof(events)/sizeof(events[0])); \n```", "```\nes_new_client(&client, ^(es_client_t* client, const es_message_t* message) {\n    switch(message->event_type) {\n        case ES_EVENT_TYPE_AUTH_OPEN:\n            es_respond_flags_result(client, message, UINT32_MAX, false); ❶\n            break;\n        case ES_EVENT_TYPE_AUTH_UNLINK:\n            es_respond_auth_result(client, message, ES_AUTH_RESULT_ALLOW, false); ❷\n            break;\n        ...\n    }\n}); \n```", "```\nes_new_client(&client, ^(es_client_t* client, const es_message_t* message) {\n    switch(message->event_type) {\n        case ES_EVENT_TYPE_AUTH_OPEN:\n            es_respond_flags_result(client, message, 0, false); ❶\n            break;\n        case ES_EVENT_TYPE_AUTH_UNLINK:\n es_respond_auth_result(client, message, ES_AUTH_RESULT_DENY, false); ❷\n            break;\n        ...\n    }\n\n}); \n```", "```\nes_new_client(&client, ^(es_client_t* client, const es_message_t* message) {\n    es_string_token_t* filePath = NULL;\n    es_string_token_t* procPath = &message->process->executable->path; ❶\n\n    switch(message->event_type) {\n        case ES_EVENT_TYPE_AUTH_OPEN:\n            filePath = &message->event.open.file->path; ❷\n            es_respond_flags_result(client, message, 0, false);\n            break;\n        case ES_EVENT_TYPE_AUTH_UNLINK:\n            filePath = &message->event.unlink.target->path; ❸\n            es_respond_auth_result(client, message, ES_AUTH_RESULT_DENY, false);\n            break;\n        ...\n    }\n}); \n```", "```\nes_new_client(&client, ^(es_client_t* client, const es_message_t* message) {\n    es_string_token_t* filePath = NULL;\n    es_string_token_t* procPath = &message->process->executable->path;\n\n    BOOL isTrusted = ((YES == message->process->is_platform_binary) ||\n    (YES == isNotarized(message->process)));\n\n    switch(message->event_type) {\n        case ES_EVENT_TYPE_AUTH_OPEN:\n            filePath = &message->event.open.file->path;\n            printf(\"\\nevent: ES_EVENT_TYPE_AUTH_OPEN\\n\");\n            printf(\"responsible process: %.*s\\n\", (int)procPath->length, procPath->data);\n            printf(\"target file path: %.*s\\n\", (int)filePath->length, filePath->data);\n            if(YES == isTrusted) {\n                printf(\"process is trusted, so will allow event\\n\");\n                es_respond_flags_result(client, message, UINT32_MAX, false);\n            } else {\n                printf(\"process is *not* trusted, so will deny event\\n\");\n                es_respond_flags_result(client, message, 0, false);\n            }\n            break;\n\n        case ES_EVENT_TYPE_AUTH_UNLINK:\n            filePath = &message->event.unlink.target->path;\n            printf(\"\\nevent: ES_EVENT_TYPE_AUTH_UNLINK\\n\");\n            printf(\"responsible process: %.*s\\n\", (int)procPath->length, procPath->data);\n            printf(\"target file path: %.*s\\n\", (int)filePath->length, filePath->data);\n            if(YES == isTrusted) {\n                printf(\"process is trusted, so will allow event\\n\");\n                es_respond_auth_result(client, message, ES_AUTH_RESULT_ALLOW, false);\n            } else {\n                printf(\"process is *not* trusted, so will deny event\\n\");\n                es_respond_auth_result(client, message, ES_AUTH_RESULT_DENY, false);\n            }\n            break;\n        ...\n    }\n}); \n```", "```\n# **ESPlayground.app/Contents/MacOS/ESPlayground -protect**\n\nES Playground\nExecuting 'protect' logic\nprotecting directory: /Users/Patrick\n\nevent: ES_EVENT_TYPE_AUTH_OPEN\nresponsible process: /bin/ls\ntarget file path: /Users/Patrick\nprocess is trusted, so will allow event\n\nevent: ES_EVENT_TYPE_AUTH_UNLINK\nresponsible process: /bin/rm\ntarget file path: /Users/Patrick/Documents/deleteMe.doc\nprocess is trusted, so will allow event \n```", "```\n# **ESPlayground.app/Contents/MacOS/ESPlayground -protect**\n\nES Playground\nExecuting 'protect' logic\nprotecting directory: /Users/User\n\nevent: ES_EVENT_TYPE_AUTH_OPEN\nresponsible process: /Users/User/Library/Final_Presentation.app/Contents/MacOS/usrnode\ntarget file path: /Users/User/Documents\nprocess is *not* trusted, so will deny event \n```"]