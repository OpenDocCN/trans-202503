["```\n((0,' ','0','R',1),\n (1,' ',' ','R',2),\n (2,' ','1','R',3),\n (3,' ',' ','R',0))\n```", "```\n> python3 turing.py\nturing <prog> [<M> | <list>] [-t]\n\n  <prog> - program # [0,4]\n  <M>    - blank tape of size M\n  <list> - initial tape (list: 0,1,2=blank)\n  <-t>   - trace, if present\n\nprograms:\n    0: Turing's first example\n    1: change 0's to 1's\n    2: unary increment: 111 -> 1111\n    3: binary increment\n    4: unary subtraction: 11111 111 -> 5 - 3\n```", "```\n> python3 turing.py 0 20\nProgram complete: (state=0, tc=20) [0 1 0 1 0 1 0 1 0 1 ]\n\nProgram:\n     0, ' ' ==> '0', 'R',  1\n     1, ' ' ==> ' ', 'R',  2\n     2, ' ' ==> '1', 'R',  3\n     3, ' ' ==> ' ', 'R',  0\n```", "```\nclass TuringMachine:\n    def Step(self):\n        found = False\n     ➊ for p in self.prog:\n            if (p[0] == self.c) and (self.tape[self.tc] == p[1]):\n                found = True\n                break\n        if (not found):\n            raise ValueError(\"No match found for current state: \n                (%d,'%s')\" % (self.c,self.tape[self.tc]))\n     ➋ w,m,c = p[2:]\n        if (w != ''):\n            self.tape[self.tc] = w\n        if (m == 'R'):\n            self.tc += 1\n        elif (m == 'L'):\n            self.tc -= 1\n        self.c = c\n\n ➌ def Done(self):\n        if (self.c == -1) or (self.tc < 0) or (self.tc == self.M):\n            return True  # end state or fell off the tape\n        return False ➍ def Run(self):\n        while (not self.Done()):\n            if (self.trace):\n                s = \"\".join(self.tape)\n                t = \" \"*self.tc + \"^\"\n                print(\"%s, (state=%d, tc=%d)\" % (s,self.c,self.tc))            \n                print(\"%s\" % t)\n                _ = input(\"?\")\n                if (_.lower() == \"q\"):\n                    quit()\n            self.Step()\n\n    def Result(self):\n        --snip--\n\n➎ def __init__(self, prog, tape=None, M=100, trace=False):\n        if (tape is None):\n            self.tape = [' ']*M\n            self.M = M\n        else:\n            tape.append(' ')  # extra blank added\n            self.tape = tape\n            self.M = len(tape)\n\n        self.c = 0          # start in state 0\n        self.tc = 0         # start at position 0\n        self.prog = prog    # state table, i.e. the program\n        self.trace = trace  # trace or not\n```", "```\n((0,'0','1','R', 0),\n (0,'1','1','R',-1),\n (0,' ',' ','L',-1)),\n```", "```\n> python3 turing.py 1 [0,0,0,0,0]\n\nProgram complete: (state=-1, tc=4)\n\n[11111 ]\n\n> python3 turing.py 1 [0,0,0,0,0,1,1] Program complete: (state=-1, tc=6)\n\n[1111111 ]\n\n> python3 turing.py 1 [0,0,0,0,0,2,1]\n\nProgram complete: (state=-1, tc=4)\n\n[11111 1 ]\n```", "```\n((0,'1','1','R', 0),\n (0,'0','1','L',-1),\n (0,' ','1','L',-1)),\n```", "```\n> python3 turing.py 2 [1,1,1] -t\n\n111 , (state=0, tc=0)\n^\n?\n111 , (state=0, tc=1)\n ^\n?\n111 , (state=0, tc=2)\n  ^\n?\n111 , (state=0, tc=3) ^\n?\n\nProgram complete: (state=-1, tc=2)\n\n[1111]\n```", "```\n((0,' ',' ','L', 1),\n (0,'0','0','R', 0),\n (0,'1','1','R', 0),\n (1,' ','1','R', 2),\n (1,'0','1','L', 2),\n (1,'1','0','L', 1),\n (2,' ',' ','L',-1),\n (2,'0','0','R', 2),\n (2,'1','1','R', 2)),\n```", "```\n> python3 turing.py 3 [1,0,1,1] -t\n```", "```\n> python3 turing.py 4 [1,1,1,1,1,2,1,1,1] -t\n```", "```\n> python3 turing.py 5 [0,1,0,1,1,0,1,1]\n\nProgram complete: (state=-1, tc=7)\n\n[10100101 ]\n```"]