<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch01"><span epub:type="pagebreak" id="page_9"/><strong>1 Basics of Memory Extraction</strong></h2>&#13;
<p class="noindent">Before we jump into exploits that extract firmware from locked microcontrollers, let’s take a chapter to consider the basics. Let’s briefly race through many of the methods that might work, then in later chapters we will learn those same attacks in detail.</p>&#13;
<p class="indent">First, it’s important to collect all of the available documentation on the chip, its debugging mechanism, and its bootloaders.</p>&#13;
<p class="indent">For publicly documented chips, you’ll want the datasheet, the family guide, a few reference designs, and a working cross compiler. Only by first understanding how the chip would be programmed in a factory will you find the bug that dumps the firmware out.</p>&#13;
<p class="indent">Perhaps I should back up a little and explain these terms. A datasheet is a short description of the chip, usually less than a hundred pages and describing what you need to build a circuit board for it. Family guides go by different names: programmer’s guide, integration guide, user’s guide, or whatever the vendor feels like that week. They usually describe a whole family of related parts, and they’ll refer you to still more documentation. Reference designs are schematics, source code, and CAD files that chip vendors encourage engineers to copy as a way to get their chips into finished products.</p>&#13;
<p class="indent">For undocumented and unlabeled chips, you’ll have to make do with what few scraps you can acquire, such as designs for related chips or leaked documentation from developers. With a little luck, these clues will lead to something useful. When reverse engineering the Tytera MD380’s proprietary radio chip, <span epub:type="pagebreak" id="page_10"/>labeled as HR C5000, a confidential developer’s guide in Chinese was found through <span class="literal">DocIn.com</span>.<sup><a id="ch1fn_1" href="footnotes.xhtml#ch1fn1">1</a></sup> Reverse engineering a modern Tamagotchi toy, Natalie Silvanovich sorted through dozens and dozens of die bonding photographs to identify that an unlabeled microcontroller was a General Plus GPLB52X, for which datasheets could then be found.<sup><a id="ch1fn_2" href="footnotes.xhtml#ch1fn2">2</a></sup> While the RF430TAL152 RFID chip in the Freestyle Libre glucose monitor is undocumented, the publicly documented RF430FRL152 is nearly identical except for minor details, such as its ROM contents.<sup><a id="ch1fn_3" href="footnotes.xhtml#ch1fn3">3</a></sup></p>&#13;
<p class="indent">It is tempting to jump straight to attacking a chip, without first using the chip as a developer, but you’ll notice that nearly every exploit in this book begins with an understanding of the target’s nuances. For any new chip, take the time to draw out its memory map, to explore an unlocked chip with a debugger, and to really understand how the chip is used. If at all possible, don’t skip the step of compiling and running Hello World on your target!</p>&#13;
<h3 class="h3" id="ch00lev1sec1"><strong>JTAG</strong></h3>&#13;
<p class="noindent">For debugging and failure analysis, most chips implement some variant of the JTAG protocol in hardware. The classic variant uses four signal wires: TDI, TDO, TCK, and TMS. A fifth signal, TRST, is sometimes included, and multiple two-wire variants exist for easier routing, such as cJTAG, single wire debug (SWD), and spy-bi-wire.</p>&#13;
<p class="indent">These wires all have a purpose. TDI and TDO are serial input and output signals, clocked by the TCK signal. TMS selects <span epub:type="pagebreak" id="page_11"/>the mode, letting the debugger move the target state machine between different registers. All of these details are abstracted away by the debugger hardware and software, and you needn’t dive into them until you need to write your own.</p>&#13;
<p class="indent">If you’re lucky, you have an unlocked chip and can dump the chip by simply connecting a JTAG adapter and using a debugger to export the full range of flash memory to disk. Developers often leave devices unlocked for failure analysis reasons, so that they can more easily improve the manufacturing yield and keep the assembly line running. Some devices don’t even support locking, and those are always easy to read!</p>&#13;
<p class="indent">If you’re less lucky, the JTAG port will be fully or partially disabled to prevent readout, configured by a fuse or a nonvolatile memory flag.</p>&#13;
<p class="indent">Full JTAG locks are often bypassed by some form of fault injection, in which the electrical, photovoltaic, or electromagnetic requirements of the chip are briefly violated to bypass a protection mechanism. For example, the full lock on many of the STM32 chips can be degraded to a partial lock by a supply voltage glitch after reset.<sup><a id="ch1fn_4" href="footnotes.xhtml#ch1fn4">4</a></sup> Many MSP430 chips fall from their full lock to an unlocked state if hit by a camera flash.<sup><a id="ch1fn_5" href="footnotes.xhtml#ch1fn5">5</a></sup></p>&#13;
<p class="indent">Partial JTAG locks are a little trickier, if only because they are so diverse. Generally, a partial lock allows some form of debugging for failure analysis purposes, while applying restrictions to flash memory. The STM32F0’s partial protection disconnects flash from the data bus after JTAG connects, but it does so a few clock cycles too late, so that you can dump memory by repeatedly reconnecting to extract a single 32-bit word.<sup><a id="ch1fn_6" href="footnotes.xhtml#ch1fn6">6</a></sup> Similarly, the partial protection of the STM32F1 can be broken by realizing <span epub:type="pagebreak" id="page_12"/>that interrupt handlers are fetched through the instruction bus, so that by relocating the table with the vector table offset register (VTOR), one might fire interrupts while single stepping and observing registers in order to leak words from flash memory.<sup><a id="ch1fn_7" href="footnotes.xhtml#ch1fn7">7</a></sup></p>&#13;
<h3 class="h3" id="ch00lev1sec2"><strong>ROM Bootloaders</strong></h3>&#13;
<p class="noindent">Many microcontrollers ship with a mask ROM. The contents and format for these vary dramatically, but when present, they’ll usually contain at least a bootloader and perhaps also some convenience functions, much like an old IBM PC’s BIOS. The bits of these ROMs come from a lithography mask at the time of manufacturing, and often you can photograph them to see and decode these bits.</p>&#13;
<p class="indent">Just like the application code that we’re trying to extract from flash memory, the ROM code can be decompiled and reverse engineered. An exploitable bug in this code can be difficult or impossible to patch, leading to firmware dumps from entire families of chips.</p>&#13;
<p class="indent">The STM32F2 and STM32F4 ROMs, for a specific example, contain three bootloaders, allowing the chips to boot from USB, Serial and CAN bus. These three bootloaders contain three different re-implementations of the partial JTAG lock functionality, and a software bug in the USB device firmware update (DFU) bootloader allows code to be executed from an arbitrary address, which can in turn dump all of a locked device’s firmware.<sup><a id="ch1fn_8" href="footnotes.xhtml#ch1fn8">8</a></sup></p>&#13;
<p class="indent">In very high volume chips, you might find custom ROM images. These won’t match the ones of the consumer model of the chip, but they are often forked from that same code, which can give <span epub:type="pagebreak" id="page_13"/>you clues to their contents before a successful dump.<sup><a id="ch1fn_9" href="footnotes.xhtml#ch1fn9">9</a></sup> Because the bits of the ROM are sometimes visible under a microscope, we can read these bits out visually with a bit of patience and software assistance.<sup><a id="ch1fn_10" href="footnotes.xhtml#ch1fn10">10</a></sup></p>&#13;
<h3 class="h3" id="ch00lev1sec3"><strong>Flash Bootloaders</strong></h3>&#13;
<p class="noindent">We’ve already discussed bootloaders in ROM, which come from the chip manufacturer, but many device manufacturers will add their own bootloader, either written from scratch or forked from a reference design.</p>&#13;
<p class="indent">The Tytera MD380, for example, is a two-way radio whose firmware was dumped and then patched to add new features for the ham radio community. Its STM32F405 includes the ROM bootloader mentioned above, but also a second flash bootloader, with a custom variant of the DFU protocol. The flash bootloader allows the SPI flash chip of the radio to be read and written in cleartext, while the internal flash region can only be written, and only with encrypted firmware updates. An uninitialized pointer in this bootloader allows the first 48kB of memory to be dumped, containing the bootloader.</p>&#13;
<p class="indent">By patching this bootloader to leave the chip unlocked, cleartext firmware can be freely extracted with JTAG!<sup><a id="ch1fn_11" href="footnotes.xhtml#ch1fn11">11</a></sup></p>&#13;
<p class="indent">Whatever your target and whatever your technique, the goal is to get code out of a protected chip. With the right techniques and a good understanding of how the protection works, almost any chip will fall to a dedicated reverse engineer.<span epub:type="pagebreak" id="page_14"/></p>&#13;
</div>
</div>
</body></html>