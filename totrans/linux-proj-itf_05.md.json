["```\n*from* `fileio/bad_exclusive_open.c`\nfd = open(argv[1], O_WRONLY);       /* Open 1: check if file exists */\n    if (fd != -1) {                     /* Open succeeded */\n        printf(\"[PID %ld] File \\\"%s\\\" already exists\\n\",\n                (long) getpid(), argv[1]);\n        close(fd);\n    } else {\n        if (errno != ENOENT) {          /* Failed for unexpected reason */\n            errExit(\"open\");\n        } else {\n            /* WINDOW FOR FAILURE */\n            fd = open(argv[1], O_WRONLY | O_CREAT, S_IRUSR | S_IWUSR);\n            if (fd == -1)\n                errExit(\"open\");\n\n            printf(\"[PID %ld] Created file \\\"%s\\\" exclusively\\n\",\n                    (long) getpid(), argv[1]);          /* MAY NOT BE TRUE! */\n        }\n    }\n      *from* `fileio/bad_exclusive_open.c`\n```", "```\nprintf(\"[PID %ld] File \\\"%s\\\" doesn't exist yet\\n\", (long) getpid(), argv[1]);\nif (argc > 2) {                 /* Delay between check and create */\n    sleep(5);                   /* Suspend execution for 5 seconds */\n    printf(\"[PID %ld] Done sleeping\\n\", (long) getpid());\n}\n```", "```\n$ `./bad_exclusive_open tfile sleep &`\n[PID 3317] File \"tfile\" doesn't exist yet\n[1] 3317\n$ `./bad_exclusive_open tfile`\n[PID 3318] File \"tfile\" doesn't exist yet\n[PID 3318] Created file \"tfile\" exclusively\n$ [PID 3317] Done sleeping\n[PID 3317] Created file \"tfile\" exclusively                 *Not true*\n```", "```\nif (lseek(fd, 0, SEEK_END) == -1)\n    errExit(\"lseek\");\nif (write(fd, buf, len) != len)\n    fatal(\"Partial/failed write\");\n```", "```\n#include <fcntl.h>\n\nint `fcntl`(int *fd*, int *cmd*, ...);\n```", "```\nint flags, accessMode;\n\nflags = fcntl(fd, F_GETFL);         /* Third argument is not required */\nif (flags == -1)\n    errExit(\"fcntl\");\n```", "```\nif (flags & O_SYNC)\n    printf(\"writes are synchronized\\n\");\n```", "```\naccessMode = flags & O_ACCMODE;\nif (accessMode == O_WRONLY || accessMode == O_RDWR)\n    printf(\"file is writable\\n\");\n```", "```\nint flags;\n\nflags = fcntl(fd, F_GETFL);\nif (flags == -1)\n    errExit(\"fcntl\");\nflags |= O_APPEND;\nif (fcntl(fd, F_SETFL, flags) == -1)\n    errExit(\"fcntl\");\n```", "```\n$ `./myscript > results.log 2>&1`\n```", "```\n$ `./myscript 2>&1 | less`\n```", "```\n#include <unistd.h>\n\nint `dup`(int *oldfd*);\n```", "```\nnewfd = dup(1);\n```", "```\nclose(2);               /* Frees file descriptor 2 */\nnewfd = dup(1);         /* Should reuse file descriptor 2 */\n```", "```\n#include <unistd.h>\n\nint `dup2`(int *oldfd*, int *newfd*);\n```", "```\ndup2(1, 2);\n```", "```\nnewfd = fcntl(oldfd, F_DUPFD, startfd);\n```", "```\n#define _GNU_SOURCE\n#include <unistd.h>\n\nint `dup3`(int *oldfd*, int *newfd*, int *flags*);\n```", "```\n#include <unistd.h>\n\nssize_t `pread`(int *fd*, void **buf*, size_t *count*, off_t *offset*);\n```", "```\nssize_t `pwrite`(int *fd*, const void **buf*, size_t *count*, off_t *offset*);\n```", "```\noff_t orig;\n\norig = lseek(fd, 0, SEEK_CUR);    /* Save current offset */\nlseek(fd, offset, SEEK_SET);\ns = read(fd, buf, len);\nlseek(fd, orig, SEEK_SET);        /* Restore original file offset */\n```", "```\n#include <sys/uio.h>\n\nssize_t `readv`(int *fd*, const struct iovec **iov*, int *iovcnt*);\n```", "```\nssize_t `writev`(int *fd*, const struct iovec **iov*, int *iovcnt*);\n```", "```\nstruct iovec {\n    void  *iov_base;        /* Start address of buffer */\n    size_t iov_len;         /* Number of bytes to transfer to/from buffer */\n};\n```", "```\n`fileio/t_readv.c`\n#include <sys/stat.h>\n#include <sys/uio.h>\n#include <fcntl.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int fd;\n    struct iovec iov[3];\n    struct stat myStruct;       /* First buffer */\n    int x;                      /* Second buffer */\n#define STR_SIZE 100\n    char str[STR_SIZE];         /* Third buffer */\n    ssize_t numRead, totRequired;\n\n    if (argc != 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s file\\n\", argv[0]);\n\n    fd = open(argv[1], O_RDONLY);\n    if (fd == -1)\n        errExit(\"open\");\n\n    totRequired = 0;\n\n    iov[0].iov_base = &myStruct;\n    iov[0].iov_len = sizeof(struct stat);\n    totRequired += iov[0].iov_len;\n\n    iov[1].iov_base = &x;\n    iov[1].iov_len = sizeof(x);\n    totRequired += iov[1].iov_len;\n\n    iov[2].iov_base = str;\n    iov[2].iov_len = STR_SIZE;\n    totRequired += iov[2].iov_len;\n\n    numRead = readv(fd, iov, 3);\n    if (numRead == -1)\n        errExit(\"readv\");\n\n    if (numRead < totRequired)\n        printf(\"Read fewer bytes than requested\\n\");\n\n    printf(\"total bytes requested: %ld; bytes read: %ld\\n\",\n            (long) totRequired, (long) numRead);\n    exit(EXIT_SUCCESS);\n}\n     `fileio/t_readv.c`\n```", "```\n#define _BSD_SOURCE\n#include <sys/uio.h>\n\nssize_t `preadv`(int *fd*, const struct iovec **iov*, int *iovcnt*, off_t *offset*);\n```", "```\nssize_t `pwritev`(int *fd*, const struct iovec **iov*, int *iovcnt*, off_t *offset*);\n```", "```\n#include <unistd.h>\n\nint `truncate`(const char **pathname*, off_t *length*);\nint `ftruncate`(int *fd*, off_t *length*);\n```", "```\nfd = open64(name, O_CREAT | O_RDWR, mode);\nif (fd == -1)\n    errExit(\"open\");\n```", "```\n$ `./large_file x 10111222333`\n$ `ls -l x`                                   *Check size of resulting file*\n-rw-------    1 mtk      users    10111222337 Mar  4 13:34 x\n```", "```\n`fileio/large_file.c`\n#define _LARGEFILE64_SOURCE\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int fd;\n    off64_t off;\n\n    if (argc != 3 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s pathname offset\\n\", argv[0]);\n\n    fd = open64(argv[1], O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n    if (fd == -1)\n        errExit(\"open64\");\n\n    off = atoll(argv[2]);\n    if (lseek64(fd, off, SEEK_SET) == -1)\n        errExit(\"lseek64\");\n\n    if (write(fd, \"test\", 4) == -1)\n        errExit(\"write\");\n    exit(EXIT_SUCCESS);\n}\n      `fileio/large_file.c`\n```", "```\n$ `cc -D_FILE_OFFSET_BITS=64 prog.c`\n```", "```\n#define _FILE_OFFSET_BITS 64\n```", "```\n#define _FILE_OFFSET_BITS 64\n\noff_t offset;           /* Will be 64 bits, the size of 'long long' */\n\n/* Other code assigning a value to 'offset' */\n\nprintf(\"offset=%lld\\n\", (long long) offset);\n```", "```\nfd = open(\"/dev/fd/1\", O_WRONLY);\nfd = dup(1);                        /* Duplicate standard output */\n```", "```\n$ `ls | diff - oldfilelist`\n```", "```\n$ `ls | diff /dev/fd/0 oldfilelist`\n```", "```\n#include <stdlib.h>\n\nint `mkstemp`(char **template*);\n```", "```\nint fd;\nchar template[] = \"/tmp/somestringXXXXXX\";\n\nfd = mkstemp(template);\nif (fd == -1)\n    errExit(\"mkstemp\");\nprintf(\"Generated filename was: %s\\n\", template);\nunlink(template);     /* Name disappears immediately, but the file\n                         is removed only after close() */\n\n/* Use file I/O system calls - read(), write(), and so on */\n\nif (close(fd) == -1)\n    errExit(\"close\");\n```", "```\n#include <stdio.h>\n\nFILE *`tmpfile`(void);\n```", "```\n    $ `atomic_append` *`filename num-bytes`* [*`x`*]\n    ```", "```\n    $ `atomic_append f1 1000000 & atomic_append f1 1000000`\n    ```", "```\n    $ `atomic_append f2 1000000 x & atomic_append f2 1000000 x`\n    ```", "```\n    fd1 = open(file, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);\n    fd2 = dup(fd1);\n    fd3 = open(file, O_RDWR);\n    write(fd1, \"Hello,\", 6);\n    write(fd2, \" world\", 6);\n    lseek(fd2, 0, SEEK_SET);\n    write(fd1, \"HELLO,\", 6);\n    write(fd3, \"Gidday\", 6);\n    ```"]