- en: '**6'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UML CLASS DIAGRAMS**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/com.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter describes *class diagrams*, one of the more important diagramming
    tools in UML. Class diagrams are the basis for defining data types, data structures,
    and operations on that data in programs. In turn, they’re the basis for *object-oriented
    analysis (OOA)* and *object-oriented design (OOD)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.1 Object-Oriented Analysis and Design in UML**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The creators of UML wanted a formal system for designing object-oriented software
    to replace the structured programming formalisms available at the time (1990s).
    Here we’ll discuss how to represent classes (data types) and objects (instance
    variables of data types) in UML.
  prefs: []
  type: TYPE_NORMAL
- en: The most complete form of a class diagram in UML is shown in [Figure 6-1](ch06.xhtml#ch6fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-1: A complete class diagram*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Attributes* correspond to data field members of a class (that is, variables
    and constants); they represent information internal to the class.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Operations* correspond to the activities that represent the class’s behavior.
    Operations include methods, functions, procedures, and other things we normally
    identify as code.'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you don’t need to list all the attributes and operations when referencing
    a class diagram (or there might not even be any attributes or operations). In
    such situations, you can instead draw a partial class diagram, shown in [Figure
    6-2](ch06.xhtml#ch6fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-2: Partial class diagrams*'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that attributes or operations are missing from a partial class diagram
    doesn’t imply that they don’t exist; it just means that it’s not necessary in
    the current context to add them to the diagram. The designer might be leaving
    it up to the coder to fill them in during coding; or perhaps the complete class
    diagram appears elsewhere, and the current diagram contains only information of
    interest.
  prefs: []
  type: TYPE_NORMAL
- en: In its simplest form, UML represents classes with a simple rectangle containing
    the name of the class, as shown in [Figure 6-3](ch06.xhtml#ch6fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-3: A simple class diagram*'
  prefs: []
  type: TYPE_NORMAL
- en: Again, this doesn’t imply that the class contains no attributes or operations
    (which wouldn’t make sense); it just means that those items are not of interest
    in the current diagram.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.2 Visibility in a Class Diagram**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'UML defines four types of class member *visibility* (all taken from C++ and
    Java, although other languages, such as Swift, also support them): public, private,
    protected, and package. We’ll discuss each in turn.'
  prefs: []
  type: TYPE_NORMAL
- en: '***6.2.1 Public Class Visibility***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A public class member is visible to all classes and code, inside and outside
    the class containing the public item. In well-designed object-oriented systems,
    public items are almost always operations (methods, functions, procedures, and
    so forth) and form the class’s interface to the world outside the class. Although
    you can also make attributes public, doing so often defeats one of the primary
    benefits of object-oriented programming: *encapsulation*, or the ability to hide
    values and activities inside a class from the outside world.'
  prefs: []
  type: TYPE_NORMAL
- en: In UML we preface public attributes and operations with the plus sign (`+`),
    as shown in [Figure 6-4](ch06.xhtml#ch6fig4). The set of public attributes and
    operations provides the class’s *public interface*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-4: Public attributes and operations*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This figure has a single public attribute, `maxSalinity_c`. The `_c` suffix
    is a convention I use to indicate that the field is a *constant* rather than a
    variable.^([1](ch19_footnote.xhtml#ch06fn1)) In good designs constants are usually
    the only public attributes in a class, because external code cannot change the
    value of a constant: it’s still visible (that is, not hidden or encapsulated),
    but it’s unchangeable. One of the main reasons for encapsulation is to prevent
    side effects that can occur when some external code changes an internal class
    attribute. Because external code cannot change a constant’s value, this immutability
    achieves the same result as encapsulation; therefore, object-oriented designers
    are willing to make certain class constants visible.^([2](ch19_footnote.xhtml#ch06fn2))'
  prefs: []
  type: TYPE_NORMAL
- en: 6.2.2 Private Class Visibility
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At the other end of the spectrum lies private visibility. Private attributes
    and operations are accessible only within that class: they’re hidden from other
    classes and code. Private attributes and operations are the embodiment of encapsulation.'
  prefs: []
  type: TYPE_NORMAL
- en: We use the minus sign (`-`) to denote private entities within a class diagram,
    as shown in [Figure 6-5](ch06.xhtml#ch6fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-5: Private attributes and operations*'
  prefs: []
  type: TYPE_NORMAL
- en: You should use private visibility for any attribute or operation that doesn’t
    absolutely require some other form of visibility, and strive to ensure that all
    attributes (data fields in the class) are private members of the class. If outside
    code needs to access a data field, you can use public *accessor* functions (getters
    and setters) to provide access to the private class member. A *getter* function
    returns the value of a private field. A *setter* function stores a value into
    a private field.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re wondering why you should even bother using accessor functions (after
    all, it’s a whole lot easier to simply access the data field directly^([3](ch19_footnote.xhtml#ch06fn3))),
    consider this: a setter function can check the value you’re storing in an attribute
    to ensure it’s within range. Also, not all fields are independent of all other
    attributes in a class. For example, in a saltwater pool, the salinity, chlorine,
    and pH levels aren’t completely independent of one another: the pool contains
    an electrolysis cell that converts water and sodium chloride (salt) into sodium
    hydroxide and chlorine. This conversion reduces the salinity and increases the
    chlorine and pH levels. So rather than allowing some external code to arbitrarily
    change the salinity level, you might want to pass the change through a setter
    function that can decide whether to adjust other levels at the same time.'
  prefs: []
  type: TYPE_NORMAL
- en: '***6.2.3 Protected Class Visibility***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Although public and private visibility covers a large percentage of the visibility
    requirements, in some special situations, like inheritance, you’ll need to use
    something in between: protected visibility.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance, along with encapsulation and polymorphism, is one of the “big three”
    features of object-oriented programming. Inheritance allows one class to receive
    all the features from another class.
  prefs: []
  type: TYPE_NORMAL
- en: One problem with private visibility is that *you cannot access private fields
    within classes that inherit them*. Protected visibility, however, relaxes these
    restrictions to allow access by inheriting classes, but it doesn’t allow access
    to private fields outside the original class or its inheriting classes.
  prefs: []
  type: TYPE_NORMAL
- en: UML notation uses the hash symbol (`#`) to denote protected visibility, as shown
    in [Figure 6-6](ch06.xhtml#ch6fig6).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-6: Protected attributes and operations*'
  prefs: []
  type: TYPE_NORMAL
- en: '***6.2.4 Package Class Visibility***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Package visibility sits between private and protected and is largely a Java
    concept. Other languages have something similar, including Swift, C++, and C#,
    in which you can use namespaces to simulate package visibility, although the semantics
    aren’t quite the same.
  prefs: []
  type: TYPE_NORMAL
- en: Package-protected fields are visible among all classes in the same package.
    Classes outside the package (even if they inherit from the class containing the
    package-protected fields) cannot access items with package visibility.
  prefs: []
  type: TYPE_NORMAL
- en: We use the tilde (`~`) to denote package visibility, as shown in [Figure 6-7](ch06.xhtml#ch6fig7).
    [Chapter 8](ch08.xhtml) discusses UML package notation (that is, how to place
    several classes in the same package).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-7: Package attributes and operations*'
  prefs: []
  type: TYPE_NORMAL
- en: '***6.2.5 Unsupported Visibility Types***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: What happens if your programming language of choice doesn’t support the same
    visibility types that UML specifies? Well, the good news is that UML visibility
    is largely a spectrum, as shown in [Figure 6-8](ch06.xhtml#ch6fig8).^([4](ch19_footnote.xhtml#ch06fn4))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-8: Visibility spectrum*'
  prefs: []
  type: TYPE_NORMAL
- en: You can always substitute a more public visibility for a more private visibility
    if your programming language doesn’t support a specific visibility. For example,
    the High-Level Assembly (HLA) language supports only public fields; C++ only partially
    supports package visibility (using `friend` declarations or *namespaces*); and
    Swift supports an offshoot of package visibility—all private fields within an
    object are automatically visible to all classes declared in the same source file.
    One way to avoid abusing the extra visibility is to add some sort of visibility
    notation to the attribute or operation’s name in the class—for example, by prefacing
    protected names with `prot_` and then declaring them as public objects, as shown
    in [Figure 6-9](ch06.xhtml#ch6fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-9: Faking visibility restriction*'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.3 Class Attributes**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Attributes in a UML class (also known as *data fields* or simply *fields*) hold
    the data associated with an object. An attribute has a visibility and a name;
    it can also have a data type and an initial value, as shown in [Figure 6-10](ch06.xhtml#ch6fig10).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-10: Attributes*'
  prefs: []
  type: TYPE_NORMAL
- en: '***6.3.1 Attribute Visibility***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As discussed earlier, you specify the visibility of an attribute by prefixing
    its name with the `+`, `-`, `#`, or `~` symbols, which specify public, private,
    protected, and package visibility, respectively. See “[Visibility in a Class Diagram](ch06.xhtml#lev-6.2)”
    on [page 105](ch06.xhtml#page_105) for more details.
  prefs: []
  type: TYPE_NORMAL
- en: '***6.3.2 Attribute Derived Values***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most of the time, a class stores the value of an attribute as a variable or
    constant data field (a *base* value). However, some fields contain *derived* values
    rather than base values. The class calculates a derived value whenever some expression
    references that attribute. Some languages, like Swift, provide syntax for directly
    defining declared values; in other languages (such as C++), you’ll typically write
    getter and setter accessor functions to implement a derived value.
  prefs: []
  type: TYPE_NORMAL
- en: To create a derived attribute in UML, you immediately precede the attribute
    name (after the visibility symbol) with a forward slash (`/`), as shown in [Figure
    6-11](ch06.xhtml#ch6fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-11: A derived attribute*'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you use a derived attribute, somewhere you must define how to calculate
    it. [Figure 6-11](ch06.xhtml#ch6fig11) uses a comment for this purpose, although
    you could also use a *property string* (see “[Property Strings](ch06.xhtml#lev-6.3.8)”
    on [page 112](ch06.xhtml#page_112)).
  prefs: []
  type: TYPE_NORMAL
- en: '***6.3.3 Attribute Names***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The attribute name should work in whichever programming language(s) you use
    to implement the design. As much as possible, you should refrain from naming syntax
    or conventions that are specific to a programming language unless you’re requiring
    implementation in that language. As a general rule, the following conventions
    work well for UML attribute names:'
  prefs: []
  type: TYPE_NORMAL
- en: All names should begin with an (ASCII) alphabetic character (a–z or A–Z).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the first character, names should contain only ASCII alphabetic characters
    (a–z, A–Z), numeric digits (0–9), or underscores (_).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All names should be unique within the first six to eight characters (some compilers
    allow arbitrary-length names but keep only a prefix of them in the internal symbol
    table during compilation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Names should be shorter than some arbitrary length (we’ll use 32 characters
    here).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All names should be *case neutral*; that is, two separate names must contain
    at least one distinct character rather than just a difference in case. Also, all
    occurrences of a given name should be consistent with respect to alphabetic case.^([5](ch19_footnote.xhtml#ch06fn5))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*6.3.4 Attribute Data Types*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A UML object can optionally have an associated data type (see the examples in
    [Figure 6-10](ch06.xhtml#ch6fig10)). UML doesn’t require you to explicitly state
    the data type; if it’s absent, the assumption is that the reader can infer it
    from the attribute’s name or usage, or that the programmer will decide on a type
    while implementing the design.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use any type names you want for primitive data types and leave it up
    to the programmer to choose the appropriate or closest matching data type when
    writing the code. That being said, when working with generic data types most people
    choose C++ or Java type names (which makes sense, because UML’s design was largely
    based on these two languages). Common data types you’ll find attached to UML attributes
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`int`, `long`, `unsigned`, `unsigned long`, `short`, `unsigned short`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float`, `double`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`char`, `wchar`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string`, `wstring`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, any user-defined type names are perfectly valid as well. For example,
    if you’ve defined `uint16_t` to mean the same thing as `unsigned short` in your
    design, then using `uint16_t` as an attribute type is perfectly acceptable. In
    addition, any class objects you define in UML also make perfectly good data type
    names.
  prefs: []
  type: TYPE_NORMAL
- en: '***6.3.5 Operation Data Types (Return Values)***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can also associate a data type with an operation. Functions, for example,
    can return a value having some data type. To specify a return data type, follow
    the operation name (and parameter list) with a colon and the data type, as shown
    in [Figure 6-12](ch06.xhtml#ch6fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-12: Return types*'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss operations more in “Class Operations” on [page 112](ch06.xhtml#page_112).
  prefs: []
  type: TYPE_NORMAL
- en: '***6.3.6 Attribute Multiplicity***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some attributes could contain a collection (array or list) of data objects.
    In UML we denote multiplicity using square brackets `[]`, similar to array declarations
    in many high-level languages; see [Figure 6-13](ch06.xhtml#ch6fig13).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-13: Multiplicity*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the brackets, you specify an expression, which can be any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A numeric value (for example, `5`) indicating the number of elements in the
    collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A numeric range (for example, `1..5` or `0..7`) indicating the number of elements
    and valid suffix range for the collection of elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An asterisk (`*`) representing an arbitrary number of elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An asterisk-terminated range (for example, `0..*` or `1..*`) indicating an open-ended
    range of array elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this notation is absent, the multiplicity defaults to `[1]` (that is, a single
    data object).
  prefs: []
  type: TYPE_NORMAL
- en: '***6.3.7 Default Attribute Values***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To specify an initial value for an attribute, you use an equal sign (`=`) followed
    by an expression (with a type appropriate for the attribute). This typically follows
    the attribute’s multiplicity (if present) and/or type. But if the type can be
    inferred from the initial value, you can omit both it and the multiplicity. If
    the multiplicity is something other than `1`, you enclose a comma-separated list
    of initial values, one for each element, within a pair of braces. See [Figure
    6-14](ch06.xhtml#ch6fig14).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-14: Initial values*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the `numTempSensors` attribute is an `integer` type (which
    can be inferred by the initial value `2`), and `tempSensorSpan` is an array of
    `double`s with two elements (inferred by the number and types of values in the
    braces).
  prefs: []
  type: TYPE_NORMAL
- en: '***6.3.8 Property Strings***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: UML’s attribute syntax probably doesn’t cover every possible case for your attributes.
    UML provides the *property string* to handle outlier situations. To create a property
    string, you add text within braces at the end of the attribute that describes
    it, as shown in [Figure 6-15](ch06.xhtml#ch6fig15).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-15: Property strings*'
  prefs: []
  type: TYPE_NORMAL
- en: You can also use property strings to define other property types. Common examples
    include `{readOnly}`, `{unique}`, and `{static}`.^([6](ch19_footnote.xhtml#ch06fn6))
    Keep in mind that a property string is a catch-all field in the attribute. You
    can define any syntax you want inside the braces.
  prefs: []
  type: TYPE_NORMAL
- en: '***6.3.9 Attribute Syntax***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The formal syntax for an attribute looks as follows (note that optional items
    appear in braces, except quoted braces, which represent literal brace characters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**6.4 Class Operations**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Class operations are items within a class that perform actions. Generally, the
    operations represent the code in a class (but there can also be code associated
    with derived attributes, so having code is not exclusive to operations in a UML
    class).
  prefs: []
  type: TYPE_NORMAL
- en: 'UML class diagrams place attributes and operations into separate rectangles,
    though this is not what differentiates one from the other. (Consider [Figure 6-2](ch06.xhtml#ch6fig2):
    the partial class diagrams are ambiguous with respect to which class diagram contains
    only attributes and which contains only operations.) In UML we explicitly specify
    operations within a class diagram by following the operation’s name with a (possibly
    empty) parameter list surrounded by parentheses (refer to [Figure 6-4](ch06.xhtml#ch6fig4)
    for an example).'
  prefs: []
  type: TYPE_NORMAL
- en: As noted in “Operation Data Types (Return Values)” on [page 110](ch06.xhtml#page_110),
    you can also specify a return type for an operation by following the parameter
    list with a colon and a data type name. If the type is present, you definitely
    have a function; if it’s absent, you likely have a procedure (a *void function*).
  prefs: []
  type: TYPE_NORMAL
- en: What’s been missing in all the operation examples thus far is parameters. To
    specify parameters, you insert a comma-separated list of attributes within the
    parentheses immediately following the operation name, as shown in [Figure 6-16](ch06.xhtml#ch6fig16).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-16: Operation parameters*'
  prefs: []
  type: TYPE_NORMAL
- en: By default, parameters in a UML operation are *value* parameters, meaning they’re
    passed to the operation as an argument, and changes an operation makes to a value
    parameter do not affect the actual parameter the caller passes to the function.
    A value parameter is an *input parameter*.
  prefs: []
  type: TYPE_NORMAL
- en: 'UML also supports *output* parameters and *input/output* parameters. As their
    names suggest, output parameters return information from the operation to the
    calling code; input/output parameters pass information to and return data from
    an operation. UML uses the following syntax to denote input, output, and input/output
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Input parameters: `in` *paramName*`:`*paramType*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Output parameters: `out` *paramName*`:`*paramType*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Input/output parameters: `inout` *paramName*`:`*paramType*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default parameter-passing mechanism is input. If there’s nothing specified
    before the parameter name, UML assumes that it is an `in` parameter. [Figure 6-17](ch06.xhtml#ch6fig17)
    shows a simple example of an `inout` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-17: Parameter inout example*'
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, the list of items to sort is an input *and* an output parameter.
    On input, the `items` array contains the data to be sorted; on output, it contains
    the sorted items (an in-place sort).
  prefs: []
  type: TYPE_NORMAL
- en: UML tries to be as generic as possible. The `in`, `out`, and `inout` parameter-passing
    specifiers don’t necessarily imply pass by value or pass by reference. This implementation
    detail is left to, well, the actual implementation. From a design point of view,
    UML is specifying only the direction in which, not how, the data is transferred.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5 UML Class Relationships**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we’ll explore five different types of relationships between
    classes: dependency, association, aggregation, composition, and inheritance.'
  prefs: []
  type: TYPE_NORMAL
- en: Like visibility, class relationships fall along a spectrum (see [Figure 6-18](ch06.xhtml#ch6fig18)).
    This range is based on their *strength*, or the level and type of intercommunication
    between two classes.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-18: Class relationship spectrum*'
  prefs: []
  type: TYPE_NORMAL
- en: Strength ranges from *loosely coupled* to *tightly coupled*. When two classes
    are tightly coupled, any modifications to one class will likely affect the state
    of the other class. Loosely coupled classes are mostly independent of each other;
    changes to one are unlikely to affect the other.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss each type of class relationship in turn, from weakest to strongest.
  prefs: []
  type: TYPE_NORMAL
- en: '***6.5.1 Class Dependency Relationships***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Two classes are dependent on each other when objects of one class need to *briefly*
    work with objects of another class. In UML we use a dashed open-ended arrow to
    denote a dependency relationship, as shown in [Figure 6-19](ch06.xhtml#ch6fig19).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-19: Dependency relationship*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the `userInterface` and `poolMonitor` classes work together
    whenever a `userInterface` object wants to retrieve data to display (for example,
    when you pass a `poolMonitor` object to a `userInterface` method as a parameter).
    Other than that, the two classes (and objects of those classes) operate independently
    of each other.
  prefs: []
  type: TYPE_NORMAL
- en: '***6.5.2 Class Association Relationships***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An association relationship occurs when one class contains an attribute whose
    type is a second class. There are two ways to draw an association relationship
    in UML: inline attributes and association links. You’ve already seen inline attributes—they’re
    the normal attribute definitions you saw in “Attribute Syntax” on [page 112](ch06.xhtml#page_112)).
    The only requirement is that the type name must be some other class.'
  prefs: []
  type: TYPE_NORMAL
- en: The second way to specify a class association relationship is with an association
    *line* or *link*, as shown in [Figure 6-20](ch06.xhtml#ch6fig20).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-20: Association relationship*'
  prefs: []
  type: TYPE_NORMAL
- en: The *association name* is typically a verb phrase that describes the association,
    such as *has*, *owns*, *controls*, *is owned by*, and *is controlled by* (see
    [Figure 6-21](ch06.xhtml#ch6fig21)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-21: Association names*'
  prefs: []
  type: TYPE_NORMAL
- en: How can we tell from an association diagram which class is an attribute of the
    other? Notice the arrowhead immediately to the left or right of the association
    name. This provides the direction of the association; here, it shows that the
    `poolMonitor` has a `phClass`, rather than the reverse.
  prefs: []
  type: TYPE_NORMAL
- en: But while a meaningful association name and arrowhead verb phrase can give you
    a clue, there’s no guarantee that your intuition will be correct. Although it
    might seem counterintuitive, `pumpClass` in [Figure 6-21](ch06.xhtml#ch6fig21)
    could contain the `poolMonitor` object as an attribute, even though the `poolMonitor`
    class controls the `pumpClass` object. The UML solution is to apply *navigability*
    (see “[Navigability](ch06.xhtml#lev-6.5.5.9)” on [page 123](ch06.xhtml#page_123))
    by placing an open-ended arrow pointing at the class that is an attribute of the
    other class, as shown in [Figure 6-22](ch06.xhtml#ch6fig22).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-22: Association navigability*'
  prefs: []
  type: TYPE_NORMAL
- en: '***6.5.3 Class Aggregation Relationships***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An aggregation, a slightly more tightly coupled version of association, exists
    as a class that could be stand-alone but is part of a larger class. Most of the
    time, an aggregation relationship is a *controls* relationship; that is, a controlling
    class (the *aggregate* or *whole* class) controls a set of subservient objects
    or attributes (the *parts* classes). The aggregate class cannot exist without
    the parts classes; however, the parts classes can exist outside the context of
    the aggregate class (for example, a parts class could be associated with both
    the aggregate class and an additional class).
  prefs: []
  type: TYPE_NORMAL
- en: Aggregates act as *gatekeepers* to their parts attributes, ensuring that the
    parts’ methods are being called with appropriate (for example, range-checked)
    parameters and that the operating environment for those parts is consistent. The
    aggregate class can also check return values for consistency and handle exceptions
    and other issues raised by the parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you could have a `pHSensor` class that works well with a stand-alone
    pH meter and a `salinitySensor` class that works well with a stand-alone salinity
    (or conductivity) sensor. The `poolMonitor` class is not a stand-alone class:
    it needs both of these classes to do its job, even though they don’t need `poolMonitor`
    to do theirs. We model this relationship using an empty diamond symbol on the
    aggregate class (`poolMonitor`) and an association line leading to the parts classes
    (`pHSensor` and `salinitySensor`), as shown in [Figure 6-23](ch06.xhtml#ch6fig23).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-23: Aggregation relationship*'
  prefs: []
  type: TYPE_NORMAL
- en: The class with the open diamond end of the association line (that is, the aggregated
    class) always contains the attribute-associated class (the parts class) at the
    other end of the line.
  prefs: []
  type: TYPE_NORMAL
- en: The lifetimes of an aggregate object and its associated parts objects are not
    necessarily the same. You could create several parts objects and then attach them
    to an aggregate object. When the aggregate object finishes its task, it can be
    deallocated while the parts objects continue to solve other problems. In other
    words, from a low-level programming perspective, the system stores pointers to
    the parts objects in the aggregate object. When the system deallocates the storage
    for the aggregate object, the pointers might go away, but the objects they reference
    might persist (and could be pointed at by other aggregate objects in the system).
  prefs: []
  type: TYPE_NORMAL
- en: Why use an aggregate diagram? The code produced for an association and an aggregation
    will be identical. The difference is one of intent. In an aggregation diagram,
    the designer is saying that the parts objects or classes are under the control
    of the aggregate class or object. To return to our `poolMonitor` example, in the
    aggregation relationship, the `poolMonitor` is in complete charge—the `salinitySensor`
    and `pHSensor` objects are being controlled by it, and never the other way around.
    In an association relationship, however, the associated classes are *peers* rather
    than having a master/slave relationship; that is, both the `pHSensor` and `salinitySensor`
    could operate independently of the `poolMonitor`—and vice versa—sharing information
    only as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '***6.5.4 Class Composition Relationships***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In composition relationships, the smaller classes contained by the larger class
    are not stand-alone classes: they exist strictly to support the containing, or
    *composing*, class. Unlike with aggregates, composition parts can belong only
    to a single composition.'
  prefs: []
  type: TYPE_NORMAL
- en: The lifetimes of the composing object and the parts objects are the same. When
    you destroy the composing object, you also destroy the parts objects it contains.
    The composing object is responsible for allocating and deallocating storage associated
    with the parts.
  prefs: []
  type: TYPE_NORMAL
- en: We use a solid diamond to denote a composition relationship, as shown in [Figure
    6-24](ch06.xhtml#ch6fig24).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-24: Composition relationship*'
  prefs: []
  type: TYPE_NORMAL
- en: '***6.5.5 Relationship Features***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For dependency, association, aggregation, and composition relationships, UML
    supports these 10 features, some of which you’ve already seen:'
  prefs: []
  type: TYPE_NORMAL
- en: Attribute names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface specifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visibility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplicity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ordering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qualifiers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changeability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These features don’t apply to the inheritance relationship, which is why I haven’t
    yet described it. We’ll get to inheritance shortly in the section “[Class Inheritance
    Relationships](ch06.xhtml#lev-6.5.6)” on [page 125](ch06.xhtml#page_125), but
    first we’ll cover each of these relationship features.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For simplicity’s sake I use* association *to discuss each feature, but* dependency,
    aggregate, *and* composition *all equally apply.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5.5.1 Association and Attribute Names**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The association name attached to a link can tell you the type or ownership of
    the interaction, but it doesn’t tell you how the two classes refer to each other.
    The association link only provides a connection between the two class objects.
    Classes refer to each other using attribute and operation fields in the class
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: As you read in “Class Association Relationships” on [page 115](ch06.xhtml#page_115),
    the association diagram is effectively an alternative to the inline syntax for
    incorporating an attribute or operation name within a class. The two diagrams
    in [Figure 6-25](ch06.xhtml#ch6fig25) are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-25: Shorthand (top) and longhand (bottom) association relationship
    diagrams*'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 6-25](ch06.xhtml#ch6fig25), the shorthand version is missing the
    attribute or operation name (`pHSensor` in this example) and the visibility (`-`,
    or private), but you can supply these missing pieces by attaching the attribute
    name to the association link nearest the object that will hold the object reference
    data field, as shown in [Figure 6-26](ch06.xhtml#ch6fig26).
  prefs: []
  type: TYPE_NORMAL
- en: Like the inline syntax, an attribute name consists of an attribute or operation
    name with a visibility symbol prefix (`-`, `~`, `#`, or `+`). The visibility symbol
    must be present because it differentiates an attribute name from a role (described
    next).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-26: Attribute name*'
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to combine the association and attribute names, as shown in
    [Figure 6-27](ch06.xhtml#ch6fig27).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-27: Combining association and attribute names*'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5.5.2 Roles**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In [Figure 6-27](ch06.xhtml#ch6fig27), it isn’t entirely clear what the two
    classes are doing. The `poolMonitor` class has a `pHSensor` field that connects
    to the `pHClass`, but otherwise the diagram doesn’t explain what’s going on. *Roles*,
    which typically appear at both ends of the association link, provide this missing
    description.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the `poolMonitor` class or object generally reads the pH value
    from a pH sensor device (encapsulated in `pHClass`). Conversely, the `pHClass`
    class or object can supply pH readings. You can describe these two activities
    (reading pH and supplying a pH value) using roles in UML. [Figure 6-28](ch06.xhtml#ch6fig28)
    shows an example of these roles.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-28: Roles*'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5.5.3 Interface Specifiers**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An *interface* is a set of operations expected from certain classes. It’s similar
    to a class except there are no objects instantiated from it. Classes that adhere
    to an interface are guaranteed to provide all the operations present in it (and
    provide methods for those operations). If you’re a C++ programmer, you can think
    of an interface as an abstract base class containing only abstract member functions.
    Java, C#, and Swift have their own special syntax for defining interfaces (also
    known as *protocols*).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Interface specifiers are supported in UML 1.*x *but have been dropped from
    UML 2.0\. I describe them in this chapter because you might encounter them, but
    you shouldn’t use them in new UML documents because they’re deprecated.*'
  prefs: []
  type: TYPE_NORMAL
- en: If a class implements an interface, it’s effectively inheriting all the operations
    from that interface. That is, if an interface provides operations A, B, and C,
    and some class implements that interface, that class must also provide operations
    A, B, and C (and provide concrete implementations of these operations). There
    are two distinct ways to specify an interface—with *stereotype* or *ball* notation,
    as shown in [Figure 6-29](ch06.xhtml#ch6fig29).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-29: Interface syntax: stereotype (top) and ball (bottom) notation*'
  prefs: []
  type: TYPE_NORMAL
- en: To show that a class implements a given interface, you draw a dashed line with
    a hollow arrowhead from the class to the interface diagram, as shown in [Figure
    6-30](ch06.xhtml#ch6fig30).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-30: Interface implementation diagram*'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5.5.4 Visibility**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Visibility applies to attribute names in an association link. As noted earlier,
    all attribute names must be prefixed with a symbol (`-`, `~`, `#`, or `+`) that
    specifies their visibility (private, package, protected, or public, respectively).
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5.5.5 Multiplicity**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The section “[Attribute Multiplicity](ch06.xhtml#lev-6.3.6)” on [page 111](ch06.xhtml#page_111)
    described multiplicity for inline attributes. You can also include multiplicity
    in association diagrams by specifying multiplicity values at either or both ends
    of an association link (see [Figure 6-31](ch06.xhtml#ch6fig31)). Place multiplicity
    values above or below the link and closest to the class or object to which they
    apply. If a multiplicity value is not provided, it defaults to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-31: Multiplicity on an association link*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-31](ch06.xhtml#ch6fig31) indicates that there is a single `poolMonitor`
    object, and it can have one or more associated `pHSensor`s (there could be, for
    example, separate pH sensors in the spa and in the swimming pool proper).'
  prefs: []
  type: TYPE_NORMAL
- en: This example shows a *one-to-many* relationship. It’s also possible to have
    *many-to-one* and even *many-to-many* relationships in these diagrams. For example,
    [Figure 6-32](ch06.xhtml#ch6fig32) shows a many-to-many relationship between `poolMonitor`
    and `pHClass` classes or objects (if you’re having a hard time visualizing how
    this would work, consider a water park that has multiple pools with multiple pH
    meters).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-32: Many-to-many relationship*'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5.5.6 Ordering**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: UML provides the `{ordered}` constraint, which you can attach to any association
    that has a multiplicity other than `1` (see [Figure 6-33](ch06.xhtml#ch6fig33)).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-33: An ordered association*'
  prefs: []
  type: TYPE_NORMAL
- en: When appearing by itself, the `{ordered}` constraint doesn’t specify how to
    order the list of items, only that they *are* ordered. The type of ordering must
    be handled by the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5.5.7 Constraints**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A constraint is application-specific text within braces that you attach to an
    association link. Although UML has some predefined constraints (like the `{ordered}`
    constraint just mentioned), you usually create your own to provide some application-defined
    control over the association link. You can even specify multiple constraints by
    separating them with commas within the braces. For example, the singular `{ordered}`
    constraint in [Figure 6-33](ch06.xhtml#ch6fig33) doesn’t describe how to sort
    the temperature history information. You can specify the ordering by adding another
    constraint to the diagram, such as `sorted by date/time`, as shown in [Figure
    6-34](ch06.xhtml#ch6fig34).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-34: A custom constraint*'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5.5.8 Qualifiers**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A qualifier informs the implementer that a specified association requires fast
    access, typically using a key or index value. For example, suppose the temperature
    recording mechanism in [Figure 6-34](ch06.xhtml#ch6fig34) records the pool temperature
    every minute. Over the span of a week, the history object will accumulate 10,080
    readings; over a year, it will accumulate more than 3.6 million readings. To extract
    one reading per day (say, the temperature at noon) over the past year, you have
    to scan through nearly 4 million readings to produce 365 or 366 readings. That
    could be computationally intensive and create some performance issues, particularly
    for real-time systems (which the pool monitor system is likely to be). We could
    instead give each reading a unique index value so we can extract only those we
    need.
  prefs: []
  type: TYPE_NORMAL
- en: To create a UML qualifier, you place some qualification (usually an attribute
    name in the qualifying class or object) in a rectangle at one end of the association
    link, as shown in [Figure 6-35](ch06.xhtml#ch6fig35).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-35: A qualifier example*'
  prefs: []
  type: TYPE_NORMAL
- en: The unique qualifier requires all `tempHistoryClass` objects to have unique
    dates and times; that is, no two readings can have the same date and time value.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-35](ch06.xhtml#ch6fig35) suggests that the system will maintain a
    special mechanism that lets us directly select a single `tempHistoryClass` object
    based on its `date_time` value. This is similar to a key in a database table.^([7](ch19_footnote.xhtml#ch06fn7))'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the multiplicity values are both `1` because the dates and
    times are all unique, and the `date_time` qualifier will pick a specific date,
    for which there can be only one associated record. (Technically, there could be
    zero matches; however, the diagram doesn’t allow for that, so there must be a
    matching object.)
  prefs: []
  type: TYPE_NORMAL
- en: The multiplicity could be something other than `1` if the `date_time` key is
    not unique among the history objects. For example, if you want to generate a report
    with all the temperatures recorded at noon, you could specify that as shown in
    [Figure 6-36](ch06.xhtml#ch6fig36).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-36: A qualifier set example*'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming you have a year’s worth of readings in the `tempHistoryClass` object,
    you’ll get a set of 365/366 readings, all on different dates but at the same time
    (noon in this example).
  prefs: []
  type: TYPE_NORMAL
- en: One detail to keep in mind is that you can have multiple association diagrams
    that describe variants of the same association. For example, it’s not unreasonable
    to find [Figures 6-34](ch06.xhtml#ch6fig34), [6-35](ch06.xhtml#ch6fig35), and
    [6-36](ch06.xhtml#ch6fig36) in the same set of UML documents. [Figure 6-34](ch06.xhtml#ch6fig34)
    describes the generic association between the `poolMonitor` class or object and
    the `tempHistoryClass` object. [Figure 6-35](ch06.xhtml#ch6fig35) might describe
    a search operation where you’re searching for a specific temperature; this operation
    might be so common that you want to generate some sort of associative array (that
    is, a hash table) to improve its performance. Likewise, [Figure 6-36](ch06.xhtml#ch6fig36)
    suggests that you want another fast lookup table to speed up collecting a set
    of readings recorded at noon. Each diagram exists in its own context; they don’t
    conflict with one another.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5.5.9 Navigability**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In “Attribute Names” on [page 109](ch06.xhtml#page_109), I introduced the concept
    of adding attribute names to an association link. The suggestion was to place
    the name close to the class or object that contains the attribute (that is, that
    refers to the other class or object at the end of the association link). Although
    implicitly specifying the communication direction and attribute ownership this
    way works well for most simple diagrams, it can become confusing as your UML diagrams
    become more complex. The UML navigability feature remedies this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Navigability specifies the direction of information flow in a diagram (that
    is, how the data navigates through the system). By default, association links
    are navigable in both directions. This means that a class/object at one end of
    the link can access data fields or methods at the other end. It’s possible, however,
    to specify that information flows in only one direction along the association
    link.
  prefs: []
  type: TYPE_NORMAL
- en: 'To indicate navigability, place an arrowhead at the end of an association link
    to specify the direction of communication flow (you don’t need to place arrowheads
    on both ends of an association link to specify bidirectional communication). For
    example, in [Figure 6-37](ch06.xhtml#ch6fig37), the communication flows from the
    `poolMonitor` class or object to the `pHClass` class or object. This direction
    tells you two things: the `pHSensor` attribute is a member of the `poolMonitor`
    class or object, and the `pHClass` has no attributes that let it reference anything
    inside `poolMonitor`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-37: Navigability*'
  prefs: []
  type: TYPE_NORMAL
- en: 'UML 2.*x* added a new symbol to explicitly indicate that communication doesn’t
    occur in a given direction: you place a small × on the association link near the
    side forbidding communication (see [Figure 6-38](ch06.xhtml#ch6fig38)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-38: Explicit non-navigability*'
  prefs: []
  type: TYPE_NORMAL
- en: I think this clutters the diagram and makes it harder to read, so I stick with
    the default specification. You can decide for yourself which option to use.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5.5.10 Changeability**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The UML changeability feature allows you to specify whether a particular data
    set can be modified after its creation. In the history recording example from
    [Figure 6-34](ch06.xhtml#ch6fig34), once a temperature is recorded in the history
    database, you don’t want the system or a user to edit or delete that value. You
    can achieve this by adding the `{frozen}` constraint to the association link,
    as shown in [Figure 6-39](ch06.xhtml#ch6fig39).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-39: A {frozen} example*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have a better understanding of the features of the first four
    relationship types, let’s turn to the final type: inheritance.'
  prefs: []
  type: TYPE_NORMAL
- en: '***6.5.6 Class Inheritance Relationships***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The inheritance relationship (also known as the *generalization relationship*
    in UML) is the strongest, or most tightly coupled, form of class relationships.
    Any change you make to a base class’s fields will have an immediate and dramatic
    effect on the child (inheriting) classes or objects.^([8](ch19_footnote.xhtml#ch06fn8))
    Inheritance is a considerably different relationship than dependency, association,
    aggregation, or composition. These other relationships describe how one class
    or object uses another class or object; inheritance describes how one class *includes*
    everything from another class.
  prefs: []
  type: TYPE_NORMAL
- en: For inheritance we use a line with a hollow arrowhead at one end. The arrowhead
    points at the base class (the general item), and the other end of the line connects
    to the inheriting (derived) class, as shown in [Figure 6-40](ch06.xhtml#ch6fig40).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-40: Inheritance*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, `spaMonitor` and `mainPoolMonitor` are *derived classes* that
    inherit all the fields of the base (ancestor) class `poolMonitor` (likely, these
    derived classes add new attributes and operations as well).
  prefs: []
  type: TYPE_NORMAL
- en: The inheritance relationship is not like dependency, association, aggregation,
    or composition in that features such as multiplicity, roles, and navigability
    don’t apply.
  prefs: []
  type: TYPE_NORMAL
- en: '**6.6 Objects**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ve seen two types of participants in all the diagrams thus far: *actors*
    and *classes*. Specifically, most items have been classes. However, from an object-oriented
    programming point of view, classes are merely data types, not actual data items
    that software can manipulate. An object is an instantiation of a class—the actual
    data object that maintains state within an application. In UML, you represent
    an object using a rectangle, just as you represent classes. The difference is
    that you specify an object name with its associated class name, and you underline
    the pair in the object diagram, as shown in [Figure 6-41](ch06.xhtml#ch6fig41).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-41: An object*'
  prefs: []
  type: TYPE_NORMAL
- en: '**6.7 For More Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Bremer, Michael. *The User Manual Manual: How to Research, Write, Test, Edit,
    and Produce a Software Manual*. Grass Valley, CA: UnTechnical Press, 1999\. A
    sample chapter is available at *[http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf](http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Larman, Craig. *Applying UML and Patterns: An Introduction to Object-Oriented
    Analysis and Design and Iterative Development*. 3rd ed. Upper Saddle River, NJ:
    Prentice Hall, 2004.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Miles, Russ, and Kim Hamilton. *Learning UML 2.0: A Pragmatic Introduction
    to UML*. Sebastopol, CA: O’Reilly Media, 2003.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pender, Tom. *UML Bible*. Indianapolis: Wiley, 2003.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pilone, Dan, and Neil Pitman. *UML 2.0 in a Nutshell: A Desktop Quick Reference*.
    2nd ed. Sebastopol, CA: O’Reilly Media, 2005.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Roff, Jason T. *UML: A Beginner’s Guide*. Berkeley, CA: McGraw-Hill Education,
    2003.'
  prefs: []
  type: TYPE_NORMAL
- en: Tutorials Point. “UML Tutorial.” *[https://www.tutorialspoint.com/uml/](https://www.tutorialspoint.com/uml/)*.
  prefs: []
  type: TYPE_NORMAL
