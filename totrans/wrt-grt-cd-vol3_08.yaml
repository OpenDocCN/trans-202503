- en: '**6'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**6'
- en: UML CLASS DIAGRAMS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: UML 类图**
- en: '![Image](Images/com.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/com.jpg)'
- en: This chapter describes *class diagrams*, one of the more important diagramming
    tools in UML. Class diagrams are the basis for defining data types, data structures,
    and operations on that data in programs. In turn, they’re the basis for *object-oriented
    analysis (OOA)* and *object-oriented design (OOD)*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了*类图*，这是 UML 中一个非常重要的图示工具。类图是定义程序中数据类型、数据结构和对数据进行操作的基础。反过来，它们也是*面向对象分析 (OOA)*
    和*面向对象设计 (OOD)*的基础。
- en: '**6.1 Object-Oriented Analysis and Design in UML**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.1 UML中的面向对象分析与设计**'
- en: The creators of UML wanted a formal system for designing object-oriented software
    to replace the structured programming formalisms available at the time (1990s).
    Here we’ll discuss how to represent classes (data types) and objects (instance
    variables of data types) in UML.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: UML 的创建者希望有一个正式的系统来设计面向对象的软件，以取代当时（1990年代）可用的结构化编程形式。在这里，我们将讨论如何在 UML 中表示类（数据类型）和对象（数据类型的实例变量）。
- en: The most complete form of a class diagram in UML is shown in [Figure 6-1](ch06.xhtml#ch6fig1).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: UML 中最完整的类图形式见[图 6-1](ch06.xhtml#ch6fig1)。
- en: '![image](Images/fig6-1.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-1.jpg)'
- en: '*Figure 6-1: A complete class diagram*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-1：完整的类图*'
- en: '*Attributes* correspond to data field members of a class (that is, variables
    and constants); they represent information internal to the class.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*属性* 对应于类的数据字段成员（即变量和常量）；它们代表类内部的信息。'
- en: '*Operations* correspond to the activities that represent the class’s behavior.
    Operations include methods, functions, procedures, and other things we normally
    identify as code.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作* 对应于表示类行为的活动。操作包括方法、函数、过程以及我们通常认作代码的其他内容。'
- en: Sometimes, you don’t need to list all the attributes and operations when referencing
    a class diagram (or there might not even be any attributes or operations). In
    such situations, you can instead draw a partial class diagram, shown in [Figure
    6-2](ch06.xhtml#ch6fig2).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，引用类图时不需要列出所有的属性和操作（或者根本没有属性和操作）。在这种情况下，你可以绘制部分类图，如[图 6-2](ch06.xhtml#ch6fig2)所示。
- en: '![image](Images/fig6-2.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-2.jpg)'
- en: '*Figure 6-2: Partial class diagrams*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-2：部分类图*'
- en: The fact that attributes or operations are missing from a partial class diagram
    doesn’t imply that they don’t exist; it just means that it’s not necessary in
    the current context to add them to the diagram. The designer might be leaving
    it up to the coder to fill them in during coding; or perhaps the complete class
    diagram appears elsewhere, and the current diagram contains only information of
    interest.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 部分类图中缺少属性或操作并不意味着它们不存在；这只是表示在当前上下文中没有必要将它们添加到图中。设计者可能会让编码者在编码时自行补充这些内容；或者可能完整的类图在其他地方出现，而当前图中只包含感兴趣的信息。
- en: In its simplest form, UML represents classes with a simple rectangle containing
    the name of the class, as shown in [Figure 6-3](ch06.xhtml#ch6fig3).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的形式中，UML 使用一个简单的矩形表示类，矩形内包含类的名称，如[图 6-3](ch06.xhtml#ch6fig3)所示。
- en: '![image](Images/fig6-3.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-3.jpg)'
- en: '*Figure 6-3: A simple class diagram*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-3：一个简单的类图*'
- en: Again, this doesn’t imply that the class contains no attributes or operations
    (which wouldn’t make sense); it just means that those items are not of interest
    in the current diagram.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这并不意味着该类没有属性或操作（那样的话就没有意义）；这只是表示这些项目在当前图中不重要。
- en: '**6.2 Visibility in a Class Diagram**'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.2 类图中的可见性**'
- en: 'UML defines four types of class member *visibility* (all taken from C++ and
    Java, although other languages, such as Swift, also support them): public, private,
    protected, and package. We’ll discuss each in turn.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: UML 定义了四种类成员的*可见性*（这些都来自 C++ 和 Java，尽管其他语言，如 Swift，也支持它们）：public（公共）、private（私有）、protected（受保护）和
    package（包）。我们将逐一讨论每种可见性。
- en: '***6.2.1 Public Class Visibility***'
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.2.1 公共类可见性***'
- en: 'A public class member is visible to all classes and code, inside and outside
    the class containing the public item. In well-designed object-oriented systems,
    public items are almost always operations (methods, functions, procedures, and
    so forth) and form the class’s interface to the world outside the class. Although
    you can also make attributes public, doing so often defeats one of the primary
    benefits of object-oriented programming: *encapsulation*, or the ability to hide
    values and activities inside a class from the outside world.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 公有类成员对所有类和代码都是可见的，既可以在包含该公有项的类内部访问，也可以在外部访问。在设计良好的面向对象系统中，公有项几乎总是操作（方法、函数、过程等），并构成类对外部世界的接口。尽管你也可以将属性设置为公有，但这样做往往会破坏面向对象编程的主要好处之一：*封装性*，即能够将类内部的值和活动隐藏起来，防止外界访问。
- en: In UML we preface public attributes and operations with the plus sign (`+`),
    as shown in [Figure 6-4](ch06.xhtml#ch6fig4). The set of public attributes and
    operations provides the class’s *public interface*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在UML中，我们使用加号（`+`）作为公有属性和操作的前缀，如[图6-4](ch06.xhtml#ch6fig4)所示。公有属性和操作的集合提供了类的*公有接口*。
- en: '![image](Images/fig6-4.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-4.jpg)'
- en: '*Figure 6-4: Public attributes and operations*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-4：公有属性和操作*'
- en: 'This figure has a single public attribute, `maxSalinity_c`. The `_c` suffix
    is a convention I use to indicate that the field is a *constant* rather than a
    variable.^([1](ch19_footnote.xhtml#ch06fn1)) In good designs constants are usually
    the only public attributes in a class, because external code cannot change the
    value of a constant: it’s still visible (that is, not hidden or encapsulated),
    but it’s unchangeable. One of the main reasons for encapsulation is to prevent
    side effects that can occur when some external code changes an internal class
    attribute. Because external code cannot change a constant’s value, this immutability
    achieves the same result as encapsulation; therefore, object-oriented designers
    are willing to make certain class constants visible.^([2](ch19_footnote.xhtml#ch06fn2))'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 该图包含一个公有属性，`maxSalinity_c`。`_c`后缀是我用来表示该字段是*常量*而非变量的约定。^([1](ch19_footnote.xhtml#ch06fn1))
    在良好的设计中，常量通常是类中唯一的公有属性，因为外部代码不能更改常量的值：它仍然可见（即没有被隐藏或封装），但不可更改。封装的主要原因之一是防止外部代码更改内部类属性时产生副作用。由于外部代码不能更改常量的值，这种不可变性实现了与封装相同的效果；因此，面向对象的设计者愿意使某些类常量可见。^([2](ch19_footnote.xhtml#ch06fn2))
- en: 6.2.2 Private Class Visibility
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.2 私有类可见性
- en: 'At the other end of the spectrum lies private visibility. Private attributes
    and operations are accessible only within that class: they’re hidden from other
    classes and code. Private attributes and operations are the embodiment of encapsulation.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一端是私有可见性。私有属性和操作仅在该类内部可访问：它们对其他类和代码隐藏。私有属性和操作是封装性的体现。
- en: We use the minus sign (`-`) to denote private entities within a class diagram,
    as shown in [Figure 6-5](ch06.xhtml#ch6fig5).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用减号（`-`）表示类图中的私有实体，如[图6-5](ch06.xhtml#ch6fig5)所示。
- en: '![image](Images/fig6-5.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-5.jpg)'
- en: '*Figure 6-5: Private attributes and operations*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-5：私有属性和操作*'
- en: You should use private visibility for any attribute or operation that doesn’t
    absolutely require some other form of visibility, and strive to ensure that all
    attributes (data fields in the class) are private members of the class. If outside
    code needs to access a data field, you can use public *accessor* functions (getters
    and setters) to provide access to the private class member. A *getter* function
    returns the value of a private field. A *setter* function stores a value into
    a private field.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该对任何不绝对需要其他可见性形式的属性或操作使用私有可见性，并力求确保所有属性（类中的数据字段）都是类的私有成员。如果外部代码需要访问数据字段，你可以使用公有的*访问器*函数（获取器和设置器）来提供对私有类成员的访问。*获取器*函数返回私有字段的值。*设置器*函数将一个值存储到私有字段中。
- en: 'If you’re wondering why you should even bother using accessor functions (after
    all, it’s a whole lot easier to simply access the data field directly^([3](ch19_footnote.xhtml#ch06fn3))),
    consider this: a setter function can check the value you’re storing in an attribute
    to ensure it’s within range. Also, not all fields are independent of all other
    attributes in a class. For example, in a saltwater pool, the salinity, chlorine,
    and pH levels aren’t completely independent of one another: the pool contains
    an electrolysis cell that converts water and sodium chloride (salt) into sodium
    hydroxide and chlorine. This conversion reduces the salinity and increases the
    chlorine and pH levels. So rather than allowing some external code to arbitrarily
    change the salinity level, you might want to pass the change through a setter
    function that can decide whether to adjust other levels at the same time.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想，为什么还要使用访问器函数（毕竟，直接访问数据字段不是更简单吗？^([3](ch19_footnote.xhtml#ch06fn3))），请考虑以下情况：setter
    函数可以检查你存储在属性中的值，确保它在范围内。另外，并非所有字段都独立于类中的其他属性。例如，在盐水游泳池中，盐度、氯含量和 pH 值并不是完全独立的：泳池中有一个电解池，将水和氯化钠（盐）转化为氢氧化钠和氯气。这一转化过程会降低盐度，同时提高氯含量和
    pH 值。因此，与其让外部代码任意修改盐度值，你可能希望通过 setter 函数传递该修改，以便它可以决定是否同时调整其他水平。
- en: '***6.2.3 Protected Class Visibility***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.2.3 受保护类可见性***'
- en: 'Although public and private visibility covers a large percentage of the visibility
    requirements, in some special situations, like inheritance, you’ll need to use
    something in between: protected visibility.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管公有和私有可见性涵盖了大部分可见性需求，但在某些特殊情况下，如继承，你需要使用介于两者之间的可见性：受保护可见性。
- en: Inheritance, along with encapsulation and polymorphism, is one of the “big three”
    features of object-oriented programming. Inheritance allows one class to receive
    all the features from another class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 继承与封装和多态一起，是面向对象编程的“三大特性”之一。继承允许一个类接收另一个类的所有特性。
- en: One problem with private visibility is that *you cannot access private fields
    within classes that inherit them*. Protected visibility, however, relaxes these
    restrictions to allow access by inheriting classes, but it doesn’t allow access
    to private fields outside the original class or its inheriting classes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 私有可见性的问题在于*你不能在继承它们的类中访问私有字段*。然而，受保护可见性放宽了这些限制，允许继承类访问，但不允许类外部或其继承类访问私有字段。
- en: UML notation uses the hash symbol (`#`) to denote protected visibility, as shown
    in [Figure 6-6](ch06.xhtml#ch6fig6).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: UML 注记使用井号（`#`）来表示受保护的可见性，如[图 6-6](ch06.xhtml#ch6fig6)所示。
- en: '![image](Images/fig6-6.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-6.jpg)'
- en: '*Figure 6-6: Protected attributes and operations*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-6：受保护的属性和操作*'
- en: '***6.2.4 Package Class Visibility***'
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.2.4 包类可见性***'
- en: Package visibility sits between private and protected and is largely a Java
    concept. Other languages have something similar, including Swift, C++, and C#,
    in which you can use namespaces to simulate package visibility, although the semantics
    aren’t quite the same.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 包可见性位于私有和受保护之间，主要是 Java 的概念。其他语言也有类似的东西，包括 Swift、C++ 和 C#，你可以使用命名空间来模拟包可见性，尽管语义上并不完全相同。
- en: Package-protected fields are visible among all classes in the same package.
    Classes outside the package (even if they inherit from the class containing the
    package-protected fields) cannot access items with package visibility.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 包保护字段在同一包中的所有类之间是可见的。包外的类（即使它们继承了包含包保护字段的类）不能访问具有包可见性的项。
- en: We use the tilde (`~`) to denote package visibility, as shown in [Figure 6-7](ch06.xhtml#ch6fig7).
    [Chapter 8](ch08.xhtml) discusses UML package notation (that is, how to place
    several classes in the same package).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用波浪号（`~`）来表示包可见性，如[图 6-7](ch06.xhtml#ch6fig7)所示。[第 8 章](ch08.xhtml)讨论了 UML
    包注记（即如何将多个类放置在同一个包中）。
- en: '![image](Images/fig6-7.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-7.jpg)'
- en: '*Figure 6-7: Package attributes and operations*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6-7：包属性和操作*'
- en: '***6.2.5 Unsupported Visibility Types***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.2.5 不支持的可见性类型***'
- en: What happens if your programming language of choice doesn’t support the same
    visibility types that UML specifies? Well, the good news is that UML visibility
    is largely a spectrum, as shown in [Figure 6-8](ch06.xhtml#ch6fig8).^([4](ch19_footnote.xhtml#ch06fn4))
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择的编程语言不支持 UML 指定的相同可见性类型，会发生什么呢？好消息是，UML 可见性在很大程度上是一个范围，如[图 6-8](ch06.xhtml#ch6fig8)所示。^([4](ch19_footnote.xhtml#ch06fn4))
- en: '![image](Images/fig6-8.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-8.jpg)'
- en: '*Figure 6-8: Visibility spectrum*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: You can always substitute a more public visibility for a more private visibility
    if your programming language doesn’t support a specific visibility. For example,
    the High-Level Assembly (HLA) language supports only public fields; C++ only partially
    supports package visibility (using `friend` declarations or *namespaces*); and
    Swift supports an offshoot of package visibility—all private fields within an
    object are automatically visible to all classes declared in the same source file.
    One way to avoid abusing the extra visibility is to add some sort of visibility
    notation to the attribute or operation’s name in the class—for example, by prefacing
    protected names with `prot_` and then declaring them as public objects, as shown
    in [Figure 6-9](ch06.xhtml#ch6fig9).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-9.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-9: Faking visibility restriction*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '**6.3 Class Attributes**'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Attributes in a UML class (also known as *data fields* or simply *fields*) hold
    the data associated with an object. An attribute has a visibility and a name;
    it can also have a data type and an initial value, as shown in [Figure 6-10](ch06.xhtml#ch6fig10).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-10.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-10: Attributes*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '***6.3.1 Attribute Visibility***'
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As discussed earlier, you specify the visibility of an attribute by prefixing
    its name with the `+`, `-`, `#`, or `~` symbols, which specify public, private,
    protected, and package visibility, respectively. See “[Visibility in a Class Diagram](ch06.xhtml#lev-6.2)”
    on [page 105](ch06.xhtml#page_105) for more details.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '***6.3.2 Attribute Derived Values***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most of the time, a class stores the value of an attribute as a variable or
    constant data field (a *base* value). However, some fields contain *derived* values
    rather than base values. The class calculates a derived value whenever some expression
    references that attribute. Some languages, like Swift, provide syntax for directly
    defining declared values; in other languages (such as C++), you’ll typically write
    getter and setter accessor functions to implement a derived value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: To create a derived attribute in UML, you immediately precede the attribute
    name (after the visibility symbol) with a forward slash (`/`), as shown in [Figure
    6-11](ch06.xhtml#ch6fig11).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-11.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-11: A derived attribute*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you use a derived attribute, somewhere you must define how to calculate
    it. [Figure 6-11](ch06.xhtml#ch6fig11) uses a comment for this purpose, although
    you could also use a *property string* (see “[Property Strings](ch06.xhtml#lev-6.3.8)”
    on [page 112](ch06.xhtml#page_112)).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '***6.3.3 Attribute Names***'
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The attribute name should work in whichever programming language(s) you use
    to implement the design. As much as possible, you should refrain from naming syntax
    or conventions that are specific to a programming language unless you’re requiring
    implementation in that language. As a general rule, the following conventions
    work well for UML attribute names:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 属性名称应该适用于你用来实现设计的任何编程语言。尽量避免使用特定编程语言的语法或约定，除非要求使用该语言来实现。通常，以下约定适用于UML属性名称：
- en: All names should begin with an (ASCII) alphabetic character (a–z or A–Z).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有名称应以一个（ASCII）字母字符（a–z或A–Z）开头。
- en: After the first character, names should contain only ASCII alphabetic characters
    (a–z, A–Z), numeric digits (0–9), or underscores (_).
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一个字符之后，名称应仅包含ASCII字母字符（a–z, A–Z）、数字（0–9）或下划线（_）。
- en: All names should be unique within the first six to eight characters (some compilers
    allow arbitrary-length names but keep only a prefix of them in the internal symbol
    table during compilation).
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有名称的前六到八个字符应当是唯一的（某些编译器允许任意长度的名称，但在编译过程中仅在内部符号表中保留其前缀）。
- en: Names should be shorter than some arbitrary length (we’ll use 32 characters
    here).
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称应该短于某个任意长度（这里我们使用32个字符）。
- en: All names should be *case neutral*; that is, two separate names must contain
    at least one distinct character rather than just a difference in case. Also, all
    occurrences of a given name should be consistent with respect to alphabetic case.^([5](ch19_footnote.xhtml#ch06fn5))
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有名称应当是*不区分大小写*的；也就是说，两个不同的名称必须包含至少一个不同的字符，而不仅仅是大小写的差异。此外，给定名称的所有出现应该在字母大小写方面保持一致。^([5](ch19_footnote.xhtml#ch06fn5))
- en: '*6.3.4 Attribute Data Types*'
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*6.3.4 属性数据类型*'
- en: A UML object can optionally have an associated data type (see the examples in
    [Figure 6-10](ch06.xhtml#ch6fig10)). UML doesn’t require you to explicitly state
    the data type; if it’s absent, the assumption is that the reader can infer it
    from the attribute’s name or usage, or that the programmer will decide on a type
    while implementing the design.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: UML对象可以选择性地关联一个数据类型（参见[图6-10](ch06.xhtml#ch6fig10)中的示例）。UML并不要求你明确声明数据类型；如果缺少数据类型，假设读者可以从属性的名称或用法中推断出数据类型，或者程序员在实现设计时决定数据类型。
- en: 'You can use any type names you want for primitive data types and leave it up
    to the programmer to choose the appropriate or closest matching data type when
    writing the code. That being said, when working with generic data types most people
    choose C++ or Java type names (which makes sense, because UML’s design was largely
    based on these two languages). Common data types you’ll find attached to UML attributes
    include:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为原始数据类型使用任何类型名称，并让程序员在编写代码时选择适当的或最匹配的数据类型。也就是说，在使用通用数据类型时，大多数人选择C++或Java的类型名称（这很有道理，因为UML的设计在很大程度上是基于这两种语言的）。你会在UML属性中看到的常见数据类型包括：
- en: '`int`, `long`, `unsigned`, `unsigned long`, `short`, `unsigned short`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`, `long`, `unsigned`, `unsigned long`, `short`, `unsigned short`'
- en: '`float`, `double`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`, `double`'
- en: '`char`, `wchar`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`char`, `wchar`'
- en: '`string`, `wstring`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string`, `wstring`'
- en: Of course, any user-defined type names are perfectly valid as well. For example,
    if you’ve defined `uint16_t` to mean the same thing as `unsigned short` in your
    design, then using `uint16_t` as an attribute type is perfectly acceptable. In
    addition, any class objects you define in UML also make perfectly good data type
    names.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，任何用户定义的类型名称也是完全有效的。例如，如果你在设计中将`uint16_t`定义为与`unsigned short`相同的含义，那么将`uint16_t`作为属性类型是完全可以接受的。此外，你在UML中定义的任何类对象也都可以作为有效的数据类型名称。
- en: '***6.3.5 Operation Data Types (Return Values)***'
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.3.5 操作数据类型（返回值）***'
- en: You can also associate a data type with an operation. Functions, for example,
    can return a value having some data type. To specify a return data type, follow
    the operation name (and parameter list) with a colon and the data type, as shown
    in [Figure 6-12](ch06.xhtml#ch6fig12).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将数据类型与操作关联。例如，函数可以返回某种数据类型的值。为了指定返回数据类型，可以在操作名称（和参数列表）后跟一个冒号和数据类型，如[图6-12](ch06.xhtml#ch6fig12)所示。
- en: '![image](Images/fig6-12.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-12.jpg)'
- en: '*Figure 6-12: Return types*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-12：返回类型*'
- en: We’ll discuss operations more in “Class Operations” on [page 112](ch06.xhtml#page_112).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在“类操作”一节中进一步讨论操作，[第112页](ch06.xhtml#page_112)。
- en: '***6.3.6 Attribute Multiplicity***'
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.3.6 属性多重性***'
- en: Some attributes could contain a collection (array or list) of data objects.
    In UML we denote multiplicity using square brackets `[]`, similar to array declarations
    in many high-level languages; see [Figure 6-13](ch06.xhtml#ch6fig13).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性可能包含数据对象的集合（数组或列表）。在UML中，我们使用方括号`[]`表示基数，类似于许多高级语言中的数组声明；见[图6-13](ch06.xhtml#ch6fig13)。
- en: '![image](Images/fig6-13.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-13.jpg)'
- en: '*Figure 6-13: Multiplicity*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-13：基数*'
- en: 'Within the brackets, you specify an expression, which can be any of the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在方括号内，您可以指定一个表达式，可以是以下任意内容：
- en: A numeric value (for example, `5`) indicating the number of elements in the
    collection
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数字值（例如，`5`）表示集合中元素的数量
- en: A numeric range (for example, `1..5` or `0..7`) indicating the number of elements
    and valid suffix range for the collection of elements
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数字范围（例如，`1..5`或`0..7`），表示集合元素的数量和有效的后缀范围
- en: An asterisk (`*`) representing an arbitrary number of elements
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个星号（`*`）表示任意数量的元素
- en: An asterisk-terminated range (for example, `0..*` or `1..*`) indicating an open-ended
    range of array elements
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个星号终止的范围（例如，`0..*`或`1..*`），表示一个开放的数组元素范围
- en: If this notation is absent, the multiplicity defaults to `[1]` (that is, a single
    data object).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有这个符号，基数默认为`[1]`（即单个数据对象）。
- en: '***6.3.7 Default Attribute Values***'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.3.7 默认属性值***'
- en: To specify an initial value for an attribute, you use an equal sign (`=`) followed
    by an expression (with a type appropriate for the attribute). This typically follows
    the attribute’s multiplicity (if present) and/or type. But if the type can be
    inferred from the initial value, you can omit both it and the multiplicity. If
    the multiplicity is something other than `1`, you enclose a comma-separated list
    of initial values, one for each element, within a pair of braces. See [Figure
    6-14](ch06.xhtml#ch6fig14).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要为属性指定初始值，使用等号（`=`）后跟一个表达式（类型应适合该属性）。这通常跟随属性的基数（如果存在）和/或类型。但如果类型可以从初始值推断出来，则可以省略类型和基数。如果基数不是`1`，则在大括号内包含一个逗号分隔的初始值列表，每个元素一个。见[图6-14](ch06.xhtml#ch6fig14)。
- en: '![image](Images/fig6-14.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-14.jpg)'
- en: '*Figure 6-14: Initial values*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-14：初始值*'
- en: In this example, the `numTempSensors` attribute is an `integer` type (which
    can be inferred by the initial value `2`), and `tempSensorSpan` is an array of
    `double`s with two elements (inferred by the number and types of values in the
    braces).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`numTempSensors`属性是`integer`类型（可以从初始值`2`推断出来），而`tempSensorSpan`是一个包含两个元素的`double`数组（通过大括号中的数量和类型的值来推断）。
- en: '***6.3.8 Property Strings***'
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.3.8 属性字符串***'
- en: UML’s attribute syntax probably doesn’t cover every possible case for your attributes.
    UML provides the *property string* to handle outlier situations. To create a property
    string, you add text within braces at the end of the attribute that describes
    it, as shown in [Figure 6-15](ch06.xhtml#ch6fig15).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: UML的属性语法可能无法覆盖所有可能的属性情况。UML提供了*属性字符串*来处理特殊情况。要创建一个属性字符串，您需要在属性末尾添加描述它的文本，并将其放在大括号内，如[图6-15](ch06.xhtml#ch6fig15)所示。
- en: '![image](Images/fig6-15.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-15.jpg)'
- en: '*Figure 6-15: Property strings*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-15：属性字符串*'
- en: You can also use property strings to define other property types. Common examples
    include `{readOnly}`, `{unique}`, and `{static}`.^([6](ch19_footnote.xhtml#ch06fn6))
    Keep in mind that a property string is a catch-all field in the attribute. You
    can define any syntax you want inside the braces.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用属性字符串来定义其他属性类型。常见的例子包括`{readOnly}`、`{unique}`和`{static}`。^([6](ch19_footnote.xhtml#ch06fn6))
    请记住，属性字符串是属性中的一个通用字段。您可以在大括号内定义任何语法。
- en: '***6.3.9 Attribute Syntax***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.3.9 属性语法***'
- en: 'The formal syntax for an attribute looks as follows (note that optional items
    appear in braces, except quoted braces, which represent literal brace characters):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的正式语法如下所示（注意，选项项出现在大括号中，除了引用的大括号，它们表示字面上的大括号字符）：
- en: '[PRE0]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**6.4 Class Operations**'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**6.4 类操作**'
- en: Class operations are items within a class that perform actions. Generally, the
    operations represent the code in a class (but there can also be code associated
    with derived attributes, so having code is not exclusive to operations in a UML
    class).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 类操作是类中的项目，执行某些操作。通常，操作代表类中的代码（但也可能有与派生属性相关联的代码，因此代码不仅限于UML类中的操作）。
- en: 'UML class diagrams place attributes and operations into separate rectangles,
    though this is not what differentiates one from the other. (Consider [Figure 6-2](ch06.xhtml#ch6fig2):
    the partial class diagrams are ambiguous with respect to which class diagram contains
    only attributes and which contains only operations.) In UML we explicitly specify
    operations within a class diagram by following the operation’s name with a (possibly
    empty) parameter list surrounded by parentheses (refer to [Figure 6-4](ch06.xhtml#ch6fig4)
    for an example).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: As noted in “Operation Data Types (Return Values)” on [page 110](ch06.xhtml#page_110),
    you can also specify a return type for an operation by following the parameter
    list with a colon and a data type name. If the type is present, you definitely
    have a function; if it’s absent, you likely have a procedure (a *void function*).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: What’s been missing in all the operation examples thus far is parameters. To
    specify parameters, you insert a comma-separated list of attributes within the
    parentheses immediately following the operation name, as shown in [Figure 6-16](ch06.xhtml#ch6fig16).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-16.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-16: Operation parameters*'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: By default, parameters in a UML operation are *value* parameters, meaning they’re
    passed to the operation as an argument, and changes an operation makes to a value
    parameter do not affect the actual parameter the caller passes to the function.
    A value parameter is an *input parameter*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'UML also supports *output* parameters and *input/output* parameters. As their
    names suggest, output parameters return information from the operation to the
    calling code; input/output parameters pass information to and return data from
    an operation. UML uses the following syntax to denote input, output, and input/output
    parameters:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Input parameters: `in` *paramName*`:`*paramType*'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Output parameters: `out` *paramName*`:`*paramType*'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Input/output parameters: `inout` *paramName*`:`*paramType*'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default parameter-passing mechanism is input. If there’s nothing specified
    before the parameter name, UML assumes that it is an `in` parameter. [Figure 6-17](ch06.xhtml#ch6fig17)
    shows a simple example of an `inout` parameter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-17.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-17: Parameter inout example*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, the list of items to sort is an input *and* an output parameter.
    On input, the `items` array contains the data to be sorted; on output, it contains
    the sorted items (an in-place sort).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: UML tries to be as generic as possible. The `in`, `out`, and `inout` parameter-passing
    specifiers don’t necessarily imply pass by value or pass by reference. This implementation
    detail is left to, well, the actual implementation. From a design point of view,
    UML is specifying only the direction in which, not how, the data is transferred.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5 UML Class Relationships**'
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we’ll explore five different types of relationships between
    classes: dependency, association, aggregation, composition, and inheritance.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Like visibility, class relationships fall along a spectrum (see [Figure 6-18](ch06.xhtml#ch6fig18)).
    This range is based on their *strength*, or the level and type of intercommunication
    between two classes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于可见性，类之间的关系沿着一个光谱分布（见[图6-18](ch06.xhtml#ch6fig18)）。这个范围是基于它们的*强度*，即两个类之间的相互通信的级别和类型。
- en: '![image](Images/fig6-18.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-18.jpg)'
- en: '*Figure 6-18: Class relationship spectrum*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-18：类关系光谱*'
- en: Strength ranges from *loosely coupled* to *tightly coupled*. When two classes
    are tightly coupled, any modifications to one class will likely affect the state
    of the other class. Loosely coupled classes are mostly independent of each other;
    changes to one are unlikely to affect the other.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 强度范围从*松散耦合*到*紧密耦合*。当两个类是紧密耦合时，对一个类的任何修改很可能会影响到另一个类的状态。松散耦合的类通常相互独立；对一个类的修改不太可能影响到另一个类。
- en: We’ll discuss each type of class relationship in turn, from weakest to strongest.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依次讨论每种类型的类关系，从最弱到最强。
- en: '***6.5.1 Class Dependency Relationships***'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.5.1 类依赖关系***'
- en: Two classes are dependent on each other when objects of one class need to *briefly*
    work with objects of another class. In UML we use a dashed open-ended arrow to
    denote a dependency relationship, as shown in [Figure 6-19](ch06.xhtml#ch6fig19).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类的对象需要与另一个类的对象*短暂*合作时，这两个类就形成了依赖关系。在UML中，我们使用一个虚线开口箭头来表示依赖关系，如[图6-19](ch06.xhtml#ch6fig19)所示。
- en: '![image](Images/fig6-19.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-19.jpg)'
- en: '*Figure 6-19: Dependency relationship*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-19：依赖关系*'
- en: In this example, the `userInterface` and `poolMonitor` classes work together
    whenever a `userInterface` object wants to retrieve data to display (for example,
    when you pass a `poolMonitor` object to a `userInterface` method as a parameter).
    Other than that, the two classes (and objects of those classes) operate independently
    of each other.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每当`userInterface`对象想要检索数据进行显示时（例如，当你将`poolMonitor`对象作为参数传递给`userInterface`方法时），`userInterface`和`poolMonitor`类就会协同工作。除此之外，两个类（以及这些类的对象）相互独立操作。
- en: '***6.5.2 Class Association Relationships***'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***6.5.2 类关联关系***'
- en: 'An association relationship occurs when one class contains an attribute whose
    type is a second class. There are two ways to draw an association relationship
    in UML: inline attributes and association links. You’ve already seen inline attributes—they’re
    the normal attribute definitions you saw in “Attribute Syntax” on [page 112](ch06.xhtml#page_112)).
    The only requirement is that the type name must be some other class.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 关联关系发生在一个类包含一个属性，而该属性的类型是另一个类时。UML中有两种表示关联关系的方式：内联属性和关联链接。你已经见过内联属性——它们是你在[第112页](ch06.xhtml#page_112)的“属性语法”中看到的常规属性定义。唯一的要求是类型名称必须是其他类。
- en: The second way to specify a class association relationship is with an association
    *line* or *link*, as shown in [Figure 6-20](ch06.xhtml#ch6fig20).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 指定类关联关系的第二种方式是通过关联*线*或*链接*，如[图6-20](ch06.xhtml#ch6fig20)所示。
- en: '![image](Images/fig6-20.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-20.jpg)'
- en: '*Figure 6-20: Association relationship*'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-20：关联关系*'
- en: The *association name* is typically a verb phrase that describes the association,
    such as *has*, *owns*, *controls*, *is owned by*, and *is controlled by* (see
    [Figure 6-21](ch06.xhtml#ch6fig21)).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*关联名称*通常是一个动词短语，描述关联关系，如*拥有*、*控制*、*由…拥有*、*由…控制*（见[图6-21](ch06.xhtml#ch6fig21)）。'
- en: '![image](Images/fig6-21.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/fig6-21.jpg)'
- en: '*Figure 6-21: Association names*'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '*图6-21：关联名称*'
- en: How can we tell from an association diagram which class is an attribute of the
    other? Notice the arrowhead immediately to the left or right of the association
    name. This provides the direction of the association; here, it shows that the
    `poolMonitor` has a `phClass`, rather than the reverse.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何从关联图中判断哪个类是另一个类的属性呢？注意关联名称左侧或右侧的箭头头部。这指示了关联的方向；在这里，它表明`poolMonitor`有一个`phClass`，而不是反过来。
- en: But while a meaningful association name and arrowhead verb phrase can give you
    a clue, there’s no guarantee that your intuition will be correct. Although it
    might seem counterintuitive, `pumpClass` in [Figure 6-21](ch06.xhtml#ch6fig21)
    could contain the `poolMonitor` object as an attribute, even though the `poolMonitor`
    class controls the `pumpClass` object. The UML solution is to apply *navigability*
    (see “[Navigability](ch06.xhtml#lev-6.5.5.9)” on [page 123](ch06.xhtml#page_123))
    by placing an open-ended arrow pointing at the class that is an attribute of the
    other class, as shown in [Figure 6-22](ch06.xhtml#ch6fig22).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-22.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-22: Association navigability*'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '***6.5.3 Class Aggregation Relationships***'
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An aggregation, a slightly more tightly coupled version of association, exists
    as a class that could be stand-alone but is part of a larger class. Most of the
    time, an aggregation relationship is a *controls* relationship; that is, a controlling
    class (the *aggregate* or *whole* class) controls a set of subservient objects
    or attributes (the *parts* classes). The aggregate class cannot exist without
    the parts classes; however, the parts classes can exist outside the context of
    the aggregate class (for example, a parts class could be associated with both
    the aggregate class and an additional class).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Aggregates act as *gatekeepers* to their parts attributes, ensuring that the
    parts’ methods are being called with appropriate (for example, range-checked)
    parameters and that the operating environment for those parts is consistent. The
    aggregate class can also check return values for consistency and handle exceptions
    and other issues raised by the parts.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you could have a `pHSensor` class that works well with a stand-alone
    pH meter and a `salinitySensor` class that works well with a stand-alone salinity
    (or conductivity) sensor. The `poolMonitor` class is not a stand-alone class:
    it needs both of these classes to do its job, even though they don’t need `poolMonitor`
    to do theirs. We model this relationship using an empty diamond symbol on the
    aggregate class (`poolMonitor`) and an association line leading to the parts classes
    (`pHSensor` and `salinitySensor`), as shown in [Figure 6-23](ch06.xhtml#ch6fig23).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-23.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-23: Aggregation relationship*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The class with the open diamond end of the association line (that is, the aggregated
    class) always contains the attribute-associated class (the parts class) at the
    other end of the line.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The lifetimes of an aggregate object and its associated parts objects are not
    necessarily the same. You could create several parts objects and then attach them
    to an aggregate object. When the aggregate object finishes its task, it can be
    deallocated while the parts objects continue to solve other problems. In other
    words, from a low-level programming perspective, the system stores pointers to
    the parts objects in the aggregate object. When the system deallocates the storage
    for the aggregate object, the pointers might go away, but the objects they reference
    might persist (and could be pointed at by other aggregate objects in the system).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Why use an aggregate diagram? The code produced for an association and an aggregation
    will be identical. The difference is one of intent. In an aggregation diagram,
    the designer is saying that the parts objects or classes are under the control
    of the aggregate class or object. To return to our `poolMonitor` example, in the
    aggregation relationship, the `poolMonitor` is in complete charge—the `salinitySensor`
    and `pHSensor` objects are being controlled by it, and never the other way around.
    In an association relationship, however, the associated classes are *peers* rather
    than having a master/slave relationship; that is, both the `pHSensor` and `salinitySensor`
    could operate independently of the `poolMonitor`—and vice versa—sharing information
    only as necessary.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '***6.5.4 Class Composition Relationships***'
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In composition relationships, the smaller classes contained by the larger class
    are not stand-alone classes: they exist strictly to support the containing, or
    *composing*, class. Unlike with aggregates, composition parts can belong only
    to a single composition.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The lifetimes of the composing object and the parts objects are the same. When
    you destroy the composing object, you also destroy the parts objects it contains.
    The composing object is responsible for allocating and deallocating storage associated
    with the parts.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: We use a solid diamond to denote a composition relationship, as shown in [Figure
    6-24](ch06.xhtml#ch6fig24).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-24.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-24: Composition relationship*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '***6.5.5 Relationship Features***'
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For dependency, association, aggregation, and composition relationships, UML
    supports these 10 features, some of which you’ve already seen:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Attribute names
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Roles
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface specifiers
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visibility
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiplicity
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ordering
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constraints
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Qualifiers
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigability
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changeability
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These features don’t apply to the inheritance relationship, which is why I haven’t
    yet described it. We’ll get to inheritance shortly in the section “[Class Inheritance
    Relationships](ch06.xhtml#lev-6.5.6)” on [page 125](ch06.xhtml#page_125), but
    first we’ll cover each of these relationship features.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '*For simplicity’s sake I use* association *to discuss each feature, but* dependency,
    aggregate, *and* composition *all equally apply.*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5.5.1 Association and Attribute Names**'
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The association name attached to a link can tell you the type or ownership of
    the interaction, but it doesn’t tell you how the two classes refer to each other.
    The association link only provides a connection between the two class objects.
    Classes refer to each other using attribute and operation fields in the class
    definition.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: As you read in “Class Association Relationships” on [page 115](ch06.xhtml#page_115),
    the association diagram is effectively an alternative to the inline syntax for
    incorporating an attribute or operation name within a class. The two diagrams
    in [Figure 6-25](ch06.xhtml#ch6fig25) are equivalent.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-25.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-25: Shorthand (top) and longhand (bottom) association relationship
    diagrams*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 6-25](ch06.xhtml#ch6fig25), the shorthand version is missing the
    attribute or operation name (`pHSensor` in this example) and the visibility (`-`,
    or private), but you can supply these missing pieces by attaching the attribute
    name to the association link nearest the object that will hold the object reference
    data field, as shown in [Figure 6-26](ch06.xhtml#ch6fig26).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Like the inline syntax, an attribute name consists of an attribute or operation
    name with a visibility symbol prefix (`-`, `~`, `#`, or `+`). The visibility symbol
    must be present because it differentiates an attribute name from a role (described
    next).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-26.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-26: Attribute name*'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to combine the association and attribute names, as shown in
    [Figure 6-27](ch06.xhtml#ch6fig27).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-27.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-27: Combining association and attribute names*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5.5.2 Roles**'
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In [Figure 6-27](ch06.xhtml#ch6fig27), it isn’t entirely clear what the two
    classes are doing. The `poolMonitor` class has a `pHSensor` field that connects
    to the `pHClass`, but otherwise the diagram doesn’t explain what’s going on. *Roles*,
    which typically appear at both ends of the association link, provide this missing
    description.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the `poolMonitor` class or object generally reads the pH value
    from a pH sensor device (encapsulated in `pHClass`). Conversely, the `pHClass`
    class or object can supply pH readings. You can describe these two activities
    (reading pH and supplying a pH value) using roles in UML. [Figure 6-28](ch06.xhtml#ch6fig28)
    shows an example of these roles.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-28.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-28: Roles*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5.5.3 Interface Specifiers**'
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: An *interface* is a set of operations expected from certain classes. It’s similar
    to a class except there are no objects instantiated from it. Classes that adhere
    to an interface are guaranteed to provide all the operations present in it (and
    provide methods for those operations). If you’re a C++ programmer, you can think
    of an interface as an abstract base class containing only abstract member functions.
    Java, C#, and Swift have their own special syntax for defining interfaces (also
    known as *protocols*).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '*Interface specifiers are supported in UML 1.*x *but have been dropped from
    UML 2.0\. I describe them in this chapter because you might encounter them, but
    you shouldn’t use them in new UML documents because they’re deprecated.*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: If a class implements an interface, it’s effectively inheriting all the operations
    from that interface. That is, if an interface provides operations A, B, and C,
    and some class implements that interface, that class must also provide operations
    A, B, and C (and provide concrete implementations of these operations). There
    are two distinct ways to specify an interface—with *stereotype* or *ball* notation,
    as shown in [Figure 6-29](ch06.xhtml#ch6fig29).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-29.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-29: Interface syntax: stereotype (top) and ball (bottom) notation*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: To show that a class implements a given interface, you draw a dashed line with
    a hollow arrowhead from the class to the interface diagram, as shown in [Figure
    6-30](ch06.xhtml#ch6fig30).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-30.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-30: Interface implementation diagram*'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5.5.4 Visibility**'
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Visibility applies to attribute names in an association link. As noted earlier,
    all attribute names must be prefixed with a symbol (`-`, `~`, `#`, or `+`) that
    specifies their visibility (private, package, protected, or public, respectively).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5.5.5 Multiplicity**'
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The section “[Attribute Multiplicity](ch06.xhtml#lev-6.3.6)” on [page 111](ch06.xhtml#page_111)
    described multiplicity for inline attributes. You can also include multiplicity
    in association diagrams by specifying multiplicity values at either or both ends
    of an association link (see [Figure 6-31](ch06.xhtml#ch6fig31)). Place multiplicity
    values above or below the link and closest to the class or object to which they
    apply. If a multiplicity value is not provided, it defaults to `1`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-31.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-31: Multiplicity on an association link*'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-31](ch06.xhtml#ch6fig31) indicates that there is a single `poolMonitor`
    object, and it can have one or more associated `pHSensor`s (there could be, for
    example, separate pH sensors in the spa and in the swimming pool proper).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: This example shows a *one-to-many* relationship. It’s also possible to have
    *many-to-one* and even *many-to-many* relationships in these diagrams. For example,
    [Figure 6-32](ch06.xhtml#ch6fig32) shows a many-to-many relationship between `poolMonitor`
    and `pHClass` classes or objects (if you’re having a hard time visualizing how
    this would work, consider a water park that has multiple pools with multiple pH
    meters).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-32.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-32: Many-to-many relationship*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5.5.6 Ordering**'
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: UML provides the `{ordered}` constraint, which you can attach to any association
    that has a multiplicity other than `1` (see [Figure 6-33](ch06.xhtml#ch6fig33)).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-33.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-33: An ordered association*'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: When appearing by itself, the `{ordered}` constraint doesn’t specify how to
    order the list of items, only that they *are* ordered. The type of ordering must
    be handled by the implementation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5.5.7 Constraints**'
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A constraint is application-specific text within braces that you attach to an
    association link. Although UML has some predefined constraints (like the `{ordered}`
    constraint just mentioned), you usually create your own to provide some application-defined
    control over the association link. You can even specify multiple constraints by
    separating them with commas within the braces. For example, the singular `{ordered}`
    constraint in [Figure 6-33](ch06.xhtml#ch6fig33) doesn’t describe how to sort
    the temperature history information. You can specify the ordering by adding another
    constraint to the diagram, such as `sorted by date/time`, as shown in [Figure
    6-34](ch06.xhtml#ch6fig34).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-34.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-34: A custom constraint*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5.5.8 Qualifiers**'
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A qualifier informs the implementer that a specified association requires fast
    access, typically using a key or index value. For example, suppose the temperature
    recording mechanism in [Figure 6-34](ch06.xhtml#ch6fig34) records the pool temperature
    every minute. Over the span of a week, the history object will accumulate 10,080
    readings; over a year, it will accumulate more than 3.6 million readings. To extract
    one reading per day (say, the temperature at noon) over the past year, you have
    to scan through nearly 4 million readings to produce 365 or 366 readings. That
    could be computationally intensive and create some performance issues, particularly
    for real-time systems (which the pool monitor system is likely to be). We could
    instead give each reading a unique index value so we can extract only those we
    need.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: To create a UML qualifier, you place some qualification (usually an attribute
    name in the qualifying class or object) in a rectangle at one end of the association
    link, as shown in [Figure 6-35](ch06.xhtml#ch6fig35).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-35.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-35: A qualifier example*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: The unique qualifier requires all `tempHistoryClass` objects to have unique
    dates and times; that is, no two readings can have the same date and time value.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-35](ch06.xhtml#ch6fig35) suggests that the system will maintain a
    special mechanism that lets us directly select a single `tempHistoryClass` object
    based on its `date_time` value. This is similar to a key in a database table.^([7](ch19_footnote.xhtml#ch06fn7))'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the multiplicity values are both `1` because the dates and
    times are all unique, and the `date_time` qualifier will pick a specific date,
    for which there can be only one associated record. (Technically, there could be
    zero matches; however, the diagram doesn’t allow for that, so there must be a
    matching object.)
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: The multiplicity could be something other than `1` if the `date_time` key is
    not unique among the history objects. For example, if you want to generate a report
    with all the temperatures recorded at noon, you could specify that as shown in
    [Figure 6-36](ch06.xhtml#ch6fig36).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-36.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-36: A qualifier set example*'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Assuming you have a year’s worth of readings in the `tempHistoryClass` object,
    you’ll get a set of 365/366 readings, all on different dates but at the same time
    (noon in this example).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: One detail to keep in mind is that you can have multiple association diagrams
    that describe variants of the same association. For example, it’s not unreasonable
    to find [Figures 6-34](ch06.xhtml#ch6fig34), [6-35](ch06.xhtml#ch6fig35), and
    [6-36](ch06.xhtml#ch6fig36) in the same set of UML documents. [Figure 6-34](ch06.xhtml#ch6fig34)
    describes the generic association between the `poolMonitor` class or object and
    the `tempHistoryClass` object. [Figure 6-35](ch06.xhtml#ch6fig35) might describe
    a search operation where you’re searching for a specific temperature; this operation
    might be so common that you want to generate some sort of associative array (that
    is, a hash table) to improve its performance. Likewise, [Figure 6-36](ch06.xhtml#ch6fig36)
    suggests that you want another fast lookup table to speed up collecting a set
    of readings recorded at noon. Each diagram exists in its own context; they don’t
    conflict with one another.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5.5.9 Navigability**'
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: In “Attribute Names” on [page 109](ch06.xhtml#page_109), I introduced the concept
    of adding attribute names to an association link. The suggestion was to place
    the name close to the class or object that contains the attribute (that is, that
    refers to the other class or object at the end of the association link). Although
    implicitly specifying the communication direction and attribute ownership this
    way works well for most simple diagrams, it can become confusing as your UML diagrams
    become more complex. The UML navigability feature remedies this problem.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Navigability specifies the direction of information flow in a diagram (that
    is, how the data navigates through the system). By default, association links
    are navigable in both directions. This means that a class/object at one end of
    the link can access data fields or methods at the other end. It’s possible, however,
    to specify that information flows in only one direction along the association
    link.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: 'To indicate navigability, place an arrowhead at the end of an association link
    to specify the direction of communication flow (you don’t need to place arrowheads
    on both ends of an association link to specify bidirectional communication). For
    example, in [Figure 6-37](ch06.xhtml#ch6fig37), the communication flows from the
    `poolMonitor` class or object to the `pHClass` class or object. This direction
    tells you two things: the `pHSensor` attribute is a member of the `poolMonitor`
    class or object, and the `pHClass` has no attributes that let it reference anything
    inside `poolMonitor`.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-37.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-37: Navigability*'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'UML 2.*x* added a new symbol to explicitly indicate that communication doesn’t
    occur in a given direction: you place a small × on the association link near the
    side forbidding communication (see [Figure 6-38](ch06.xhtml#ch6fig38)).'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-38.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-38: Explicit non-navigability*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: I think this clutters the diagram and makes it harder to read, so I stick with
    the default specification. You can decide for yourself which option to use.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '**6.5.5.10 Changeability**'
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The UML changeability feature allows you to specify whether a particular data
    set can be modified after its creation. In the history recording example from
    [Figure 6-34](ch06.xhtml#ch6fig34), once a temperature is recorded in the history
    database, you don’t want the system or a user to edit or delete that value. You
    can achieve this by adding the `{frozen}` constraint to the association link,
    as shown in [Figure 6-39](ch06.xhtml#ch6fig39).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-39.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-39: A {frozen} example*'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have a better understanding of the features of the first four
    relationship types, let’s turn to the final type: inheritance.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '***6.5.6 Class Inheritance Relationships***'
  id: totrans-254
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The inheritance relationship (also known as the *generalization relationship*
    in UML) is the strongest, or most tightly coupled, form of class relationships.
    Any change you make to a base class’s fields will have an immediate and dramatic
    effect on the child (inheriting) classes or objects.^([8](ch19_footnote.xhtml#ch06fn8))
    Inheritance is a considerably different relationship than dependency, association,
    aggregation, or composition. These other relationships describe how one class
    or object uses another class or object; inheritance describes how one class *includes*
    everything from another class.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: For inheritance we use a line with a hollow arrowhead at one end. The arrowhead
    points at the base class (the general item), and the other end of the line connects
    to the inheriting (derived) class, as shown in [Figure 6-40](ch06.xhtml#ch6fig40).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-40.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-40: Inheritance*'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: In this example, `spaMonitor` and `mainPoolMonitor` are *derived classes* that
    inherit all the fields of the base (ancestor) class `poolMonitor` (likely, these
    derived classes add new attributes and operations as well).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The inheritance relationship is not like dependency, association, aggregation,
    or composition in that features such as multiplicity, roles, and navigability
    don’t apply.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '**6.6 Objects**'
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You’ve seen two types of participants in all the diagrams thus far: *actors*
    and *classes*. Specifically, most items have been classes. However, from an object-oriented
    programming point of view, classes are merely data types, not actual data items
    that software can manipulate. An object is an instantiation of a class—the actual
    data object that maintains state within an application. In UML, you represent
    an object using a rectangle, just as you represent classes. The difference is
    that you specify an object name with its associated class name, and you underline
    the pair in the object diagram, as shown in [Figure 6-41](ch06.xhtml#ch6fig41).'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/fig6-41.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6-41: An object*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '**6.7 For More Information**'
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Bremer, Michael. *The User Manual Manual: How to Research, Write, Test, Edit,
    and Produce a Software Manual*. Grass Valley, CA: UnTechnical Press, 1999\. A
    sample chapter is available at *[http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf](http://www.untechnicalpress.com/Downloads/UMM%20sample%20doc.pdf)*.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Larman, Craig. *Applying UML and Patterns: An Introduction to Object-Oriented
    Analysis and Design and Iterative Development*. 3rd ed. Upper Saddle River, NJ:
    Prentice Hall, 2004.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Miles, Russ, and Kim Hamilton. *Learning UML 2.0: A Pragmatic Introduction
    to UML*. Sebastopol, CA: O’Reilly Media, 2003.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Pender, Tom. *UML Bible*. Indianapolis: Wiley, 2003.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Pilone, Dan, and Neil Pitman. *UML 2.0 in a Nutshell: A Desktop Quick Reference*.
    2nd ed. Sebastopol, CA: O’Reilly Media, 2005.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Roff, Jason T. *UML: A Beginner’s Guide*. Berkeley, CA: McGraw-Hill Education,
    2003.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Tutorials Point. “UML Tutorial.” *[https://www.tutorialspoint.com/uml/](https://www.tutorialspoint.com/uml/)*.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
