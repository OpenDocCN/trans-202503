- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">TESTING
    YOUR CODE WITH SIMULATION</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
- en: There are two ways to find the bugs that will inevitably arise in an FPGA design.
    The first is to program the FPGA, run it, and see what happens. This is called
    finding bugs *on hardware*. The other way is to use a computer to inject test
    cases into your FPGA code to see how the code responds *before* you actually program
    the FPGA. This is called finding bugs *in simulation*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: For very simple projects, such as the ones we’ve explored so far in this book,
    jumping straight to programming the FPGA without any kind of simulation may be
    a reasonable approach (and it’s the one we’ve taken up to this point). However,
    as your FPGA designs grow more complicated, finding bugs on hardware becomes incredibly
    difficult. In nearly all cases, it’s significantly easier to find bugs in simulation.
    After thoroughly simulating and debugging a design, there’s nothing more satisfying
    than finally programming your FPGA and having everything work perfectly the first
    time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn how simulation works and see why it’s an essential
    step in the FPGA design process. We’ll explore a free simulator tool and I’ll
    introduce the testbench to show how you can write test code to stress your design.
    You’ll try out these concepts by adding a debounce circuit to the LED-toggling
    project from the previous chapter (Project #3) and simulating the design. Finally,
    we’ll take a look at verification, which is a more formal and rigorous process
    for testing out FPGA and ASIC designs.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why Simulation Matters</samp>
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simulation is important because your FPGA is essentially a black box, as shown
    in [Figure 5-1](#fig5-1). When you program the FPGA, you’re able to change the
    inputs and see how the outputs respond, but you’re unable to see the details of
    what’s going on inside the box itself. You can’t follow the individual variables
    and data signals as they flow inside your FPGA.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-1.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: What’s in the box?</samp>'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: If something goes wrong inside that black box (and it will), and the output
    isn’t what you expect, figuring out the problem is very difficult. The solution
    is to use a computer to simulate the inner workings of the black box in a way
    you can follow. Simulation effectively opens up the black box of your FPGA so
    you can see what’s going on inside.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me give you an example of how useful this can be. In a past job, I had
    a coworker who was trying to fix a problem with his FPGA design. For some reason
    the data was getting mixed up inside the FPGA. He spent weeks using oscilloscopes
    and logic analyzers to send data off the FPGA so he could try to find where the
    issue was coming from. At one point I asked him if he had simulated the design
    at all. He had not: he didn’t have any experience with simulation and didn’t feel
    he could take the time out to learn. I checked his code out of revision control
    and put together a simulation for it, and within a few hours had found the problem.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Simulating your design allows you to stress it to see how it reacts. In this
    case, I was able to re-create the exact failure in simulation and fix the issue
    very quickly. Ironically, in the time my coworker had spent attempting to debug
    the problem on hardware, he could easily have learned how to do the simulation
    himself. It’s an even more attractive option when you consider that once you know
    how simulation works, you can use that knowledge again and again.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">FPGA Simulation Tools</samp>
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several popular FPGA simulation tools available. FPGA build tools
    often have a simulation tool bundled with them, in one large downloadable package;
    FPGA companies know that their designers want to run simulations, and they want
    to make it easy to do that. These tools are usually free and convenient, but they
    can be many gigabytes in size and their complexity can be overwhelming for beginners.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative solution to the large FPGA tools is to use a standalone simulator.
    The benefit to this is that if you switch from Intel (Altera) to AMD (Xilinx),
    for example, you don’t need to learn a whole new tool; your simulator can stay
    the same. There are two popular standalone simulation tools that I generally recommend:
    ModelSim and EDA Playground. ModelSim is probably the most popular commercial
    simulator. It can be downloaded and installed on Windows and Linux. A full license
    is expensive, costing around $2,000, but a free version with limited features
    is available.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: EDA Playground, by contrast, is a freely available web-based simulator. I recommend
    using it when you’re first learning about FPGA design for a few reasons. First,
    it’s free. Second, since it’s web-based, there’s no download required. Finally,
    EDA Playground allows you to share your code with others via a web link. For the
    purposes of this book, we’ll focus on this tool.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: To get started with EDA Playground, first navigate to [*https://<wbr>edaplayground<wbr>.com*](https://edaplayground.com).
    To run simulations and save your progress, you’ll need to create an account and
    log in. Once you do so, you should see a screen like the one in [Figure 5-2](#fig5-2).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-2.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-2: The EDA Playground
    main screen</samp>'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Notice that there are two main code windows. The window on the right, titled
    *design.sv*, is where the FPGA design code you want to test goes. This code is
    typically called the *unit under test (UUT)* or *device under test (DUT)*. The
    window on the left, called *testbench.sv*, is where you write *testbenches*, code
    that will exercise your FPGA design during simulation. We’ll discuss how testbenches
    work in the next section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: By default, EDA Playground is configured for SystemVerilog/Verilog designs,
    which is why the two window labels have *.sv* (SystemVerilog) file extensions.
    If you wish to reconfigure EDA Playground for VHDL, select **VHDL** in the drop-down
    menu under Testbench + Design on the left side of the window.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Before you can run code in EDA Playground, you’ll need to select a simulator
    tool. This is the actual product that will run your code. You can play around
    with different tools listed in the drop-down menu under Tools & Simulators to
    see if you prefer one over another. In general, I find that they behave similarly,
    though some are exclusively for Verilog or VHDL. I’ve had good luck using Mentor
    Questa or Aldec Riviera.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Another neat feature of EDA Playground is the Examples section of the toolbar.
    Here, you can explore sample testbenches that have been made freely available.
    You can see how they work and modify them for your own experiments, and perhaps
    gain some insights into clever ways to write your own code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Testbench</samp>
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The purpose of a testbench is to exercise your UUT in a simulation environment
    so you can analyze it and see if it’s behaving as expected. The testbench code
    instantiates the UUT. As you can see in [Figure 5-3](#fig5-3), the testbench provides
    all the required inputs to the UUT and monitors all the outputs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-3.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-3: A testbench exercises
    a UUT so you can analyze it.</samp>'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: If your UUT has a clock as an input, for example, the testbench will need to
    generate that clock and feed it in to the UUT. Similarly, if there’s a data interface
    into your UUT, the testbench will likely need to generate some sample data to
    supply to that interface. The testbench monitors all the outputs from the UUT,
    allowing it to see how the UUT responds to the input data. During the simulation,
    you’ll also be able to dive into the UUT itself to see how all of its internal
    signals are behaving in response to the testbench’s inputs. You can monitor every
    element of your design—every register, clock, wire, memory, and so on—and make
    sure they’re all behaving as intended.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing a Testbench</samp>
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take a look at a simple example by writing a testbench for the AND gate
    project from [Chapter 3](chapter3.xhtml) (Project #2). First, to review, here’s
    the original project code that we want to test:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Enter the module or entity’s code into the *design.sv* or *design.vhd* window
    on the right side of EDA Playground. To test the code completely, we want to exercise
    it to make sure that the output behaves as intended with all possible input combinations.
    In this case, the total range of input combinations is pretty small: since there
    are two inputs, there are just four possible combinations to test in order to
    fully exercise the UUT. We’ll create a testbench in Verilog and VHDL to instantiate
    the UUT and test it by passing in each of the four input combinations. Enter the
    following code into the *testbench.sv* or *testbench.vhd* window in EDA Playground:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块或实体的代码输入到EDA Playground右侧的*design.sv*或*design.vhd*窗口中。为了完全测试代码，我们需要对其进行操作，确保输出在所有可能的输入组合下表现如预期。在这种情况下，输入组合的总范围相当小：由于有两个输入，因此只需要测试四种可能的组合，就能完全验证UUT的功能。我们将分别在Verilog和VHDL中创建测试平台，以实例化UUT并通过传入每种输入组合来进行测试。将以下代码输入到EDA
    Playground中的*testbench.sv*或*testbench.vhd*窗口中：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, notice that this is the first time we’ve seen a Verilog module or VHDL
    entity that has no inputs or outputs declared ❶. This is because this testbench
    doesn’t connect to any external signals; as you saw earlier, in [Figure 5-3](#fig5-3),
    the testbench itself provides the inputs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，这是我们第一次看到没有声明任何输入或输出的Verilog模块或VHDL实体❶。这是因为该测试平台没有连接任何外部信号；正如你在[图5-3](#fig5-3)中看到的，测试平台本身提供输入。
- en: Inside the module/entity, we instantiate the UUT ❷. We connect the inputs of
    the UUT to <samp class="SANS_TheSansMonoCd_W5Regular_11">r_In1</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_In2</samp>, signals that we declare
    in the testbench. These signals will be the stimuli provided to see how the UUT
    responds. We’ll be monitoring the output, <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Out</samp>,
    to see how it reacts to changing inputs. I like to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">w_</samp>
    prefix on signal names to represent wires, or interconnections within the FPGA.
    Remember, we want to make sure the AND gate is working as expected.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块/实体内部，我们实例化了UUT ❷。我们将UUT的输入连接到在测试平台中声明的<samp class="SANS_TheSansMonoCd_W5Regular_11">r_In1</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_In2</samp>信号。这些信号将作为刺激输入，用于观察UUT的响应。我们将监控输出<samp
    class="SANS_TheSansMonoCd_W5Regular_11">w_Out</samp>，以查看它如何响应变化的输入。我喜欢在信号名上使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">w_</samp>前缀，表示FPGA内的电线或互连。记住，我们需要确保与门按预期工作。
- en: We start driving the stimuli (inputs) within an <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>
    block in Verilog or a <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block in VHDL ❸. This block will start at the beginning of the simulation and
    will execute from top to bottom in sequence. We send each of the four possible
    input combinations to the UUT, one after the other. Using delay statements, we
    add a 10 ns pause between each input combination to allow time for the simulation
    to update the <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Out</samp> signal
    after each change. In Verilog we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">#10</samp>
    delay feature, and in VHDL we use <samp class="SANS_TheSansMonoCd_W5Regular_11">wait
    for 10 ns;</samp>. As you’ll see later in this chapter, these time-based delays—indeed,
    any reference to the passage of time—are non-synthesizable, meaning they would
    not work on an actual FPGA; however, they work perfectly well in simulation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始在Verilog中的<samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>块或VHDL中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块内驱动刺激（输入）。这个块会在仿真开始时执行，并按顺序从上到下执行。我们将逐一将四种可能的输入组合发送到UUT。使用延时语句，我们在每个输入组合之间添加10纳秒的暂停，以便仿真有时间在每次变化后更新<samp
    class="SANS_TheSansMonoCd_W5Regular_11">w_Out</samp>信号。在Verilog中，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">#10</samp>延时特性，在VHDL中则使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wait for 10 ns;</samp>。正如你将在本章稍后看到的，这些基于时间的延时——事实上，任何关于时间流逝的引用——都是不可综合的，意味着它们在实际FPGA上无法工作；然而，在仿真中它们可以完美运行。
- en: In the Verilog version, note that EDA Playground requires the <samp class="SANS_TheSansMonoCd_W5Regular_11">$dumpfile</samp>
    directive ❹. This allows the simulator to generate waveforms, which we’ll cover
    in the next section. This line isn’t required in VHDL.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Verilog版本中，请注意EDA Playground需要<samp class="SANS_TheSansMonoCd_W5Regular_11">$dumpfile</samp>指令❹。这使得模拟器能够生成波形，我们将在下一节进行讲解。VHDL中不需要此行代码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running a Testbench
    and Viewing Waveforms</samp>
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">运行测试平台并查看波形</samp>
- en: Running a testbench generates *waveforms*, or visual representations of the
    signals in your test environment, showing you how they change over time. Waveforms
    are a powerful tool for investigating failures in an FPGA design during simulation;
    the more you work with FPGAs, the more time you’ll spend staring at waveforms.
    EDA Playground makes examining waveforms easy with its built-in waveform viewer,
    EPWave.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试平台会生成*波形*，即测试环境中信号的可视化表示，展示信号如何随时间变化。波形是用于检查FPGA设计在仿真过程中失败的强大工具；你与FPGA打交道的时间越长，越会花时间盯着波形看。EDA
    Playground通过内置的波形查看器EPWave使得查看波形变得更加简便。
- en: Let’s run our AND gate testbench and view the resulting waveform in EPWave.
    First, check the **Open EPWave After Run** checkbox in the Tools & Simulators
    section of the toolbar on the left side of the EDA Playground window. If you’re
    using VHDL, you will need to specify which entity is the top of your design. To
    do that, enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">And_Gate_TB</samp>
    in the Top Entity dialog. Then choose a simulator tool from the drop-down menu
    and hit **Run**. [Figure 5-4](#fig5-4) shows the resulting waveform.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行与门测试平台，并在EPWave中查看结果波形。首先，在EDA Playground窗口左侧的工具和仿真器部分勾选**运行后打开EPWave**复选框。如果你使用的是VHDL，你需要指定设计的顶层实体。为此，在“顶层实体”对话框中输入<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">And_Gate_TB</samp>。然后从下拉菜单中选择一个仿真器工具并点击**运行**。[图5-4](#fig5-4)显示了生成的波形。
- en: '![](../images/Figure5-4.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-4: The AND gate testbench
    waveform output</samp>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图5-4：与与门测试平台波形输出</samp>
- en: Here we see all the signals that exist in the design, and we can note the time
    in nanoseconds when each signal changes from high to low or low to high. The top
    three signals (<samp class="SANS_TheSansMonoCd_W5Regular_11">r_In1</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_In2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Out</samp>)
    are the testbench signals. The bottom three (<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>)
    are in the UUT. Since we wired the testbench and UUT signals together when we
    instantiated the UUT, the corresponding testbench/UUT signals look the same. For
    example, <samp class="SANS_TheSansMonoCd_W5Regular_11">r_In1</samp> has the same
    waveform as <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>. Note
    that if the UUT had other internal signals that weren’t brought out of the module,
    you would be able to see waveforms for those as well, and they wouldn’t have a
    corresponding testbench signal.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到设计中所有的信号，并且可以记录下每个信号从高到低或从低到高变化时的时间，单位为纳秒。顶部的三个信号（<samp class="SANS_TheSansMonoCd_W5Regular_11">r_In1</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_In2</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">w_Out</samp>）是测试平台信号。底部的三个信号（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_2</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>）则位于被测单元（UUT）中。由于我们在实例化UUT时将测试平台和UUT信号连接在一起，因此对应的测试平台/UUT信号是相同的。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_In1</samp>的波形与<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>相同。注意，如果UUT中有其他内部信号没有从模块中引出，你也可以看到这些信号的波形，而且它们不会有对应的测试平台信号。
- en: Looking at the waveform, we can see that the UUT is working as expected. The
    AND gate output (<samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Out</samp>) is high only when
    both inputs are also high. When only one input is high, or when both inputs are
    low, the output is low. As you examine the waveform, take a look back at the testbench
    code and notice how the changes in the waveform correspond to the statements in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block. In the code, for example, both inputs start out low, and then <samp class="SANS_TheSansMonoCd_W5Regular_11">r_In2</samp>
    goes high after a 10 ns pause. Looking at the 10 ns mark in the waveform, you
    can see that this is where <samp class="SANS_TheSansMonoCd_W5Regular_11">r_In2</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_2</samp> change from
    low to high.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Although this was a simple example, it illustrates the power of the testbench
    to simulate your FPGA design and let you see everything that is happening. You
    can monitor all the interactions within the design, and if a signal isn’t behaving
    as expected, you can investigate why that is, modify your code, and run the testbench
    again to generate a new waveform. Often when debugging issues, I’ll rerun simulations
    dozens of times until my design is behaving as desired.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: In this case, since we were testing a single basic module, we were able to evaluate
    everything using a single testbench file. For more complicated simulations, however,
    testbenches can contain many different files that all work together to simulate,
    monitor, and check your design to make sure it’s behaving as intended.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see how testbenches work in more detail in our next project, where we’ll
    write a testbench and simulate the FPGA design prior to programming the hardware.
    This will help you gain confidence that your code is working, and it will allow
    you to identify and fix any bugs early in the process. The project also illustrates
    how the concept of time works on an FPGA, so even if you don’t have an FPGA to
    program, I recommend reading through this section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #4: Debouncing a Switch</samp>'
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 4](chapter4.xhtml), we programmed an FPGA to toggle an LED at the
    push of a button. However, there was a problem: pushing the button didn’t consistently
    toggle the state of the LED. This is because any physical switch, including a
    push-button or toggle switch, is subject to *bouncing*, or rapid signal fluctuations
    that occur when the switch is toggled or flipped. Bouncing happens when the metal
    contacts inside the switch come together and move apart quickly before they have
    time to settle into the stable state. [Figure 5-5](#fig5-5) illustrates how this
    affects the switch’s output signal.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-5.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-5: Bouncing in a mechanical
    switch</samp>'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-5: 机械开关中的抖动</samp>'
- en: If you didn’t know about bouncing, you would probably expect the switch to behave
    like the top half of [Figure 5-5](#fig5-5). The button is pressed, and the output
    immediately goes from low to high. However, in the real world bouncing creates
    glitches in the output signal, which show up as rapid low-to-high-to-low transitions
    of the output signal, before it finally stays high. Again, this is due to the
    mechanical switch contacts quickly coming together and moving apart before settling
    into a stable output state.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不了解抖动，你可能会期待开关表现得像[图 5-5](#fig5-5)的上半部分。按钮被按下时，输出立即从低变高。然而，在现实世界中，抖动会在输出信号中产生毛刺，这表现为输出信号的快速低到高再到低的过渡，直到它最终保持高电平。这再次是因为机械开关接触点在快速接合和分开后，才稳定在一个稳定的输出状态。
- en: The code in our LED toggling project was looking for a single falling edge to
    indicate the press and release of the button, but due to the bouncing, the FPGA
    was seeing many falling edges per press/release. If it saw an odd number of falling
    edges during the bouncing of the switch, then the LED toggled successfully. If
    it saw an even number of falling edges, however, the LED didn’t appear to change
    state, since each pair of falling edges effectively canceled each other out.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在LED切换项目中的代码是寻找一个单一的下降沿来指示按钮的按下和释放，但由于抖动，FPGA在每次按下/释放时都会看到多个下降沿。如果在抖动过程中看到了奇数个下降沿，那么LED就成功切换。如果看到的是偶数个下降沿，LED则没有改变状态，因为每对下降沿实际上是相互抵消的。
- en: The number of bounces on a switch is somewhat random, so pushing the switch
    enough times got the LED to toggle successfully. Still, it would be better if
    the LED toggled as expected each time the switch is pressed and released. To make
    this happen, we need to add a *debounce filter* to the switch. That is, we need
    to program the FPGA to ignore the bounces. [Figure 5-6](#fig5-6) illustrates how
    this will work.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 开关上的抖动次数是有些随机的，因此按下开关足够多次，LED才会成功切换。然而，如果每次按下和释放开关时，LED都能按预期切换，那将更好。为了实现这一点，我们需要在开关上添加一个*去抖动滤波器*。也就是说，我们需要编程FPGA来忽略抖动。[图
    5-6](#fig5-6)展示了这将如何工作。
- en: '![](../images/Figure5-6.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-6: The Project #4
    block diagram</samp>'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-6: 项目 #4 块图</samp>'
- en: We’ll add a debounce filter to the code from the previous project to ensure
    that a single press of the button only toggles the LED once. The signal from the
    switch will pass through the debounce filter before going on to the LED-toggling
    logic we wrote in the last chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会在前一个项目的代码中加入一个去抖动滤波器，以确保按钮的单次按下只切换一次LED。来自开关的信号将通过去抖动滤波器，然后再传递给我们在上一章中编写的LED切换逻辑。
- en: We create a debounce filter by making sure that the input from the switch is
    stable for some amount of time before allowing the output driving the LED to change.
    We therefore need to have some concept of how much time has passed in our FPGA.
    However, introducing the notion of time into an FPGA design raises some interesting
    challenges.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过确保来自开关的输入在允许驱动LED输出发生变化之前保持稳定一段时间来创建去抖动滤波器。因此，我们需要在FPGA中有某种关于时间流逝的概念。然而，将时间引入FPGA设计带来了一些有趣的挑战。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Measuring Time on
    an FPGA</samp>
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">在FPGA上测量时间</samp>
- en: Time doesn’t exist inherently in an FPGA. The FPGA doesn’t automatically know
    if it’s Saturday at 11:00 AM, or how to wait for 100 ms, for example. To be sure,
    there are parts of Verilog and VHDL code that refer to time. For example, we already
    saw how to use <samp class="SANS_TheSansMonoCd_W5Regular_11">#10</samp> in Verilog
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">wait for 10 ns;</samp> in VHDL
    to add 10 ns delays to our AND gate testbench. To give another example, in Verilog
    you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">$time</samp> to get
    the current time, while in VHDL the reserved word <samp class="SANS_TheSansMonoCd_W5Regular_11">now</samp>
    gets a timestamp of the current time. However, while features like these will
    work perfectly well in simulation, they will 100 percent not work on your FPGA.
    They *aren’t synthesizable*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: We’ve already talked about synthesis a few times. It’s the part of the build
    process where the FPGA tool turns your Verilog or VHDL code into flip-flops, LUTs,
    and other components. Unfortunately, synthesis tools can’t synthesize anything
    relating to time. It’s just not possible. As a result, language constructs like
    <samp class="SANS_TheSansMonoCd_W5Regular_11">$time</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">now</samp>
    are simply ignored or will create errors during synthesis. In [Chapter 7](chapter7.xhtml),
    we’ll look more closely at what features of VHDL and Verilog aren’t able to be
    synthesized in an FPGA. For now, take it for granted that we can’t use some of
    these built-in features relating to time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: If time doesn’t exist in an FPGA, how can you keep track of how much time has
    passed for the purposes of debouncing a switch or one of the many other time-related
    tasks you may wish your FPGA to perform? The answer is to *count clock cycles*.
    If you know how many clock cycles have occurred, and you know the period of the
    clock, you’ll know how much time has elapsed. Let’s walk through an example.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you have a clock that oscillates at 25 MHz, and that the clock’s period—the
    duration of a single cycle—is 40 ns. Given these specifications, how many clock
    cycles would it take for 400 ns to elapse? Answer: 10\. And for 4,000 ns to elapse?
    Answer: 100\. Simply divide the amount of time you want to wait by the period
    of the clock to get the number of clock cycles you need to count before that amount
    of time has elapsed. This technique is going to be critical in our debounce project.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Code</samp>
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s look at how to implement the debounce filter. We’ll start with the top-level
    module, which instantiates and links together two lower-level modules, one for
    debouncing the switch and the other for toggling the LED:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code matches the block diagram in [Figure 5-6](#fig5-6). At the highest
    level we have <samp class="SANS_TheSansMonoCd_W5Regular_11">Debounce_Project_Top</samp>,
    which instantiates two other modules. The first is the new debounce filter ❶,
    which we’ll examine next. The second is the <samp class="SANS_TheSansMonoCd_W5Regular_11">LED_Toggle_Project</samp>
    module that we created in the previous chapter ❸. It’s worth taking a minute to
    follow the signals here. We can see the input signal <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>
    going into the debounce filter. Out of that comes <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Debounced_Switch</samp>,
    which is the debounced version of this input. This is passed into the <samp class="SANS_TheSansMonoCd_W5Regular_11">LED_Toggle
    _Project</samp> module. The output of that module is <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>,
    which will be connected to the LED pin on your development board. Note that indicating
    the direction of your signals via their names, as we do here with the <samp class="SANS_TheSansMonoCd_W5Regular_11">i_</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_</samp> prefixes, becomes
    very helpful as your designs get larger and incorporate more signals.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to highlight the value of creating reusable modules when writing
    FPGA code. Rather than writing all the project’s code from scratch, here we’re
    able to reuse the <samp class="SANS_TheSansMonoCd_W5Regular_11">LED_Toggle_Project</samp>
    module from the previous chapter and improve its functionality by interfacing
    it with another module. Another way to make modules reusable is to incorporate
    Verilog *parameters* or VHDL *generics*. These are variables within a module that
    you can override from higher-level code. We do this when we instantiate the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Debounce_Filter</samp> module. Specifically,
    we override the module’s parameter/generic called <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT</samp>
    with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">250000</samp> ❷.
    As you’ll see later, this value sets the number of clock cycles to wait while
    debouncing the switch. Coding it as a parameter/generic makes it easy to modify
    the value. In general, parameters (in Verilog) and generics (in VHDL) are a very
    useful way to keep code portable. They let you change the behavior of a module
    without having to actually modify the module’s file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now examine the code of the debounce filter module:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The overall purpose of this module is to remove any bounces or glitches in the
    input (<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Bouncy</samp>) and create
    a stable output (<samp class="SANS_TheSansMonoCd_W5Regular_11">o_Debounced)</samp>.
    To do this, we check if the input and output are different. If they are, we know
    the input is changing, but we don’t want to immediately update the output, since
    the switch might still be bouncing. Instead, we want to make sure that the input
    is stable for a long enough period of time before updating the output. Because
    the FPGA has no inherent concept of time, we implement the delay by counting clock
    cycles.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: Let’s say we want the input to be stable for 10 ms before we update the output.
    We need to count up to some number of clock cycles that represents 10 ms (or 10
    million nanoseconds) of time passed. The Go Board, for example, has a clock period
    of 40 ns, so in this case we divide 10 million by 40 to get a delay of 250,000
    clock cycles. This is the value we used for the <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT</samp>
    parameter/generic in the top-level module <samp class="SANS_TheSansMonoCd_W5Regular_11">Debounce_Project_Top</samp>.
    If your development board has a different clock period, you’ll need to change
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT</samp> accordingly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'The code used to create our clock cycle counter ❶ differs between the Verilog
    and VHDL versions. In Verilog, we use a common trick: the <samp class="SANS_TheSansMonoCd_W5Regular_11">$clog2()</samp>
    built-in function (short for ceiling log base 2) determines the log[2] of the
    number of clock cycles we want to count, rounded up. This tells us the number
    of binary digits needed to implement the counter. Thanks to the <samp class="SANS_TheSansMonoCd_W5Regular_11">$clog2()</samp>
    function, we can dynamically size the <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp>
    register based on the input parameter, so if the input parameter changes (because
    your clock has a different period, or because you want to extend the wait time),
    the code will see this and synthesize <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp>
    to be as wide as it needs to be. This is better than hardcoding <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp>
    to some arbitrary limit, which could break when the code is reused.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: With VHDL, we’re able to achieve the same dynamic sizing in a simpler way, using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">range</samp> keyword. This not
    only will size the variable correctly, but has an added benefit of creating a
    warning in your simulation if the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp>
    ever goes beyond the integer range limit. The fact that the simulator can provide
    these types of warnings when running your testbench is another great reason for
    using simulations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: We implement the debounce filter using a series of <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements that are evaluated at each clock cycle. First we handle the case where
    the input is different from the output (meaning the input is changing) but <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp> is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT-1</samp>
    ❷. This means we haven’t yet waited the desired amount of time for the switch
    to stop bouncing, so we increment our clock cycle counter by 1\. In this <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, we’re effectively
    waiting for some amount of time to pass to ensure the input is stable, before
    updating the output value.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Next we handle the case where the counter has reached its limit, so we know
    that we’ve waited the full 10 ms (or whatever length of time <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE
    _LIMIT</samp> corresponds to) ❸. At this point, we can register the current value
    of the input (<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Bouncy</samp>) to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_State</samp>, whose value is in
    turn assigned to the output (<samp class="SANS_TheSansMonoCd_W5Regular_11">o_Debounced</samp>)
    ❺. We also reset the counter to 0 to prepare for the next event. Finally, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> statement ❹ covers situations
    where the input and output have the same state. In this case, we reset the counter,
    since we have nothing to debounce here and we want our debounce filter to always
    be ready for the next event.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Testbench
    and Simulation</samp>
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we’ll create a testbench to exercise our project and make sure it works
    as expected. Recall that the testbench is what will instantiate our unit under
    test and simulate its inputs, while monitoring its outputs. In this case, we want
    the testbench to simulate the unstable input from a bouncing switch so we can
    confirm that the debounce filter is delaying the output until the switch has settled
    into a stable state. Here’s the code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Unlike our AND gate testbench, this testbench must provide a clock signal to
    the UUT, along with the other inputs. We create the clock signal with a simple
    trick ❶: we repeatedly invert a signal after a fixed amount of time to generate
    a 50 percent duty cycle signal that will toggle for the duration of the testbench
    execution. The signal inverts every 2 ns, for a clock period of 4 ns per cycle.
    This is much faster than the actual clock period on a typical FPGA development
    board, but for the purposes of this simulation, that’s okay.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'When we instantiate the UUT ❷, we override <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT</samp>
    with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>. This means
    our debounce filter will only look for four clock cycles of stability before it
    deems the output debounced. In a real FPGA, this would be a very short amount
    of time (less than 1 microsecond), probably not long enough to actually fix the
    problem. However, keep in mind the purpose of this testbench: we want to make
    sure that our FPGA logic works as intended. That logic is functionally the same
    whether we’re waiting 4 clock cycles or 250,000 clock cycles. Using the much smaller
    number will make for a quicker simulation and an easier-to-evaluate waveform,
    while still giving us realistic feedback about whether or not the design works.
    Shortening counters is a handy trick to remember for large designs: a simulation
    of such a design could take many minutes to run, but using smaller limits for
    counters will make the simulation run faster, allowing you to debug your code
    more quickly. Once your design is fully debugged and verified, you can update
    the simulation with your actual expected counter lengths to validate your actual
    design. This means you’ll only have to endure the longer simulation time once,
    after any issues with the code have already been resolved using the shortened
    simulation.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Next, we start to provide stimulus to the UUT ❸. With synchronous designs, we
    want to ensure that our input signals to the UUT are synchronous to the clock.
    We therefore set up the code to change the stimulus on the rising edge of the
    testbench clock. Otherwise, we might be introducing strange timing effects that
    would not exist in a real FPGA design. (Remember that all of the flip-flops in
    your UUT will be using the rising edge of the clock, so your testbench stimulus
    should also be reacting to the rising edge of the clock.)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: When the test starts, the input is low. After a short time, the input goes high
    for a single clock cycle ❹, then low again ❺, to simulate a bouncing-induced glitch.
    We want to make sure that the debounced output of this module doesn’t react to
    this glitch. Later in the test, we drive the input back high again and leave it
    there ❻. This time we want the output to match the input, but only after the debounce
    filter has counted out four clock cycles.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: After running this testbench code in EDA Playground (or whichever simulator
    you prefer), you should get a waveform that looks something like that shown in
    [Figure 5-7](#fig5-7).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure5-7.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-7: The debounce simulation
    waveform</samp>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: The waveform shows that the output <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Debounced</samp>
    stays low when <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Bouncy</samp> goes
    high for only one clock cycle. Then, toward the end of the simulation, we see
    the output go high to match the input, but only after the input has been high
    for four clock cycles. The debounce filter works!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: While the testbench we wrote is better than no test at all, it could certainly
    be improved. For example, we don’t check what happens when the input goes low
    again, to make sure the output responds correctly. Additionally, we might want
    to check that a higher <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT</samp>
    value than <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> doesn’t cause
    any issues. Setting up multiple tests to stress the bulk of your design, and in
    particular any corner cases, is good test design practice.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building and Programming
    the FPGA</samp>
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Having simulated the design, we now have some confidence that if we were to
    go ahead and program the FPGA, it would likely work as intended. Let’s try it
    out! Create a new project inside iCEcube2, and add the following modules to the
    project: <samp class="SANS_TheSansMonoCd_W5Regular_11">Debounce_Filter</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Debounce_Project_Top</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LED_Toggle_Project</samp>. Make
    sure that you’ve also included the clock constraints file, as well as the physical
    constraints file.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'When everything’s ready, build the project. Then double-check for errors, and
    check your utilization reports. The synthesis report after building the FPGA will
    look something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'From this report, we can see that we’re using more LUTs and flip-flops than
    we did for Project #3. This makes sense; the debounce filter accounts for these
    extra resources. Still, the FPGA has plenty of resources to spare.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and program your FPGA, then try pushing the button to turn the LED
    on and off. You should notice that the LED is now toggling consistently with each
    press of the button. We’ve successfully filtered out the bounces from the switch.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'As you’ve seen in this project, simulations are invaluable for building confidence
    in a design and debugging issues in your Verilog and VHDL. However, even in this
    relatively simple example, you may have noticed a drawback: examining waveforms
    to determine if a design is working can be tedious, especially if you have to
    keep changing the design and rerunning the simulation. It would be much more convenient
    if the testbench could simply tell you whether the simulation has worked, without
    you having to study the waveform. As we’ll explore next, it’s possible to write
    testbenches that offer exactly this capability.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Self-Checking Testbenches</samp>
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *self-checking testbench* is a testbench that you program to verify your UUT
    is working as intended, without having to manually inspect the output. The self-checking
    testbench will run a series of steps and let you know if any have failed, at which
    point you can inspect the failure and fix it. This saves you from having to visually
    examine the waveforms generated during simulation to determine whether your design
    has worked as expected. It takes a bit more effort to set up your testbench to
    be self-checking, but it’s almost always worth the time spent.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: When setting up a self-checking testbench, your goal is to inject many different
    test cases into your UUT, then monitor the outputs and check, or *assert*, that
    they are what you expect. *Assertions* are statements about what value a signal
    will have at a particular moment in the simulation, and they’re probably the most
    critical part of a self-checking testbench. Often, a self-checking testbench will
    have hundreds of assertions, with each one imparting a little more confidence
    that the design is correct.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Self-checking testbenches are particularly useful if you’re adding a new feature
    to some old code. It might be something that you haven’t looked at in years, and
    suddenly you need to try to remember (or learn, if someone else wrote it) how
    it works. From experience, I can tell you that starting with a testbench that
    has many checks is a huge benefit. You’ll be able to open the simulation, see
    all of the assertions in the self-checking testbench, and make sure everything
    in the old code still works. Then you can add your new code and add new tests
    for it. Once all the old *and* new tests are passing, you can have high confidence
    that your new code is performing as expected—and equally importantly, that *you
    haven’t broken any old code*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how self-checking testbenches work, let’s return to the simple
    testbench we wrote for our AND gate project earlier in the chapter. The following
    Verilog and VHDL code takes the original testbench we wrote and adds some assertion
    checks within it. These assertions will automatically run to verify that the actual
    output is in the expected state. The new code is shown in bold:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this excerpt from the testbench, we’ve added two checks. We use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> keyword ❶ to first confirm
    that the output is low when both inputs are low, then that it’s low when one input
    is low and the other is high. The <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>
    keyword only exists in SystemVerilog, not regular Verilog. This is an example
    of how SystemVerilog has improved features for testbenches. VHDL, meanwhile, has
    <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> built into it, and
    the severity can be <samp class="SANS_TheSansMonoCd_W5Regular_11">note</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">warning</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">failure</samp>,
    depending on the level of assertion that you want to check for. Each has a different
    escalation, so you can filter them out in your report. In this case, we’ve chosen
    <samp class="SANS_TheSansMonoCd_W5Regular_11">failure</samp>, since we definitely
    wouldn’t want an AND gate output high when the inputs are low.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'If this assertion evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>,
    then the simulation moves on. However, if something goes wrong and the assertion
    fails, you’ll see output printed to the screen. In Verilog, you’d see something
    like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In VHDL, here is what the failure message would look like:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is very helpful! Not only do we know that the testbench failed, but we
    know that it failed exactly 10 ns into the simulation, which allows us to immediately
    locate the failure in the waveform viewer. We also know the exact line of code
    that caused the failure: line 20 in Verilog or line 22 in VHDL. These pieces of
    information make it easier to investigate the problem, understand the cause, and
    fix it. I recommend adding assertions into your tests wherever possible.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The self-checking testbench is an area where SystemVerilog really shines. Many
    of the added features beyond what regular Verilog offers are geared toward writing
    better testbenches. For example, SystemVerilog provides the ability for you to
    verify sequences of events. This can be handy for analyzing interactions between
    different signals, to make sure they happen correctly (that is, first one thing
    happens, then on the next clock cycle, another thing happens). SystemVerilog also
    provides classes, allowing you to use object-oriented programming techniques to
    streamline your testbench code. Other SystemVerilog features allow you to randomly
    inject data into your designs, making your tests much more comprehensive and robust.
    The details of these features are beyond the scope of this book, but as you start
    writing more testbenches—particularly self-checking testbenches—I encourage you
    to learn more about SystemVerilog.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Initial Signal Conditions</samp>
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, if a signal isn’t assigned an initial condition, then it will show
    up in an unknown state when you start a simulation. This is often represented
    by a red signal and an X in the waveform viewer. The simulator is telling you
    that it doesn’t know how to treat the signal when the testbench is first running.
    Should it be a 0 or a 1? The simulator doesn’t know.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: There are two methods for assigning a default state to your signals, so that
    they start in a known state. One method is to use resets. As we discussed back
    in [Chapter 4](chapter4.xhtml), a reset assigns an initial default value to a
    flip-flop. Driving the reset input at the start of a simulation will set the signals
    to known states to begin the test. This will work for all signals that are assigned
    a reset condition.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The other way we can set signals to an initial state is to use the initialization
    feature in both Verilog and VHDL. This is particularly useful for simulation purposes.
    It’s as simple as assigning a signal to a value after it’s created. In Verilog,
    for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">reg r_State</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1''b0;</samp>
    initializes the <samp class="SANS_TheSansMonoCd_W5Regular_11">r_State</samp> signal
    to 0\. In VHDL, <samp class="SANS_TheSansMonoCd_W5Regular_11">signal r_State :
    std_logic :=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">''0'';</samp>
    does the same. You can use any state that the signal can validly be set to as
    an initialization value.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Initial signal assignments are only synthesizable for some FPGAs, since not
    all FPGAs can load an initial state into their flip-flops when they boot up after
    being programmed. Because this feature isn’t available for all FPGAs, I generally
    don’t recommend relying on it. A better, more portable solution is to use resets
    to set signals to some default value. Resets are widely supported across all FPGA
    manufacturers, so your code will be more portable if you need to change FPGAs.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">On-FPGA Debugging</samp>
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Early in this chapter, I told you that once you’re on hardware, you’re looking
    at a black box. You can see inputs and outputs, but you can’t see what’s going
    on internally. This isn’t entirely true. There *is* a way to do some limited on-FPGA
    debugging. However, this method has significant drawbacks and should only be used
    sparingly, if at all.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: On-FPGA debugging is achieved by adding a *logic analyzer*, a tool that shows
    the state (high or low) of many digital signals at once, inside your FPGA. This
    allows you to monitor the FPGA’s internal signals in real time. By looking at
    these signals, you can debug issues and see where data isn’t behaving as expected.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the major FPGA companies has a unique product within its suite of tools
    that creates a logic analyzer inside the FPGA. AMD has a feature called Integrated
    Logic Analyzer (ILA), Intel has Signal Tap, and Lattice has Reveal. They all work
    basically the same way: they take part of your FPGA’s resources and turn those
    resources into a logic analyzer. You run your FPGA code, the logic analyzer “sniffs”
    the data, and the results are presented on your computer screen so you can debug
    your design.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: There are several problems with this process, however. The first issue is that
    it’s extremely time-consuming. If you want to add a logic analyzer to your FPGA,
    you need to rebuild and reprogram the entire design. You also need to decide ahead
    of time what signals you’re interested in monitoring with the logic analyzer,
    as you likely won’t have enough resources on your FPGA to look at everything.
    If you want to change what you’re looking at while the FPGA is running, too bad!
    You’ll have to rebuild the entire FPGA from scratch and start the process all
    over again. A simulation, on the other hand, can easily see the state of *all*
    the signals on your FPGA; you don’t have to pick and choose.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: An additional problem with on-FPGA debugging is that adding a logic analyzer
    is basically throwaway effort. Once you find and fix your one problem, you don’t
    need the debug tool anymore. In fact, since it uses your FPGA’s resources (which
    are a limited commodity), you may not want to keep it in your design. You can
    save and rerun a simulation, but a logic analyzer is a one-and-done debugging
    effort.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The final and perhaps worst problem is that when you add a logic analyzer to
    your FPGA, you’re changing the FPGA’s design, which can have unintended consequences.
    Issues that are subject to small timing variations might be fixed by the very
    act of adding the logic analyzer, or new issues might be created. If you’re trying
    to use the logic analyzer to debug a race condition inside your FPGA, for example,
    the design changes that result from adding in the logic analyzer might actually
    make the race condition go away. Scientists refer to this as the *observer effect*,
    where a phenomenon is changed by the act of investigating it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t to say that these on-FPGA debuggers are entirely useless. They’re
    helpful when you’re trying to investigate a situation that’s difficult to simulate.
    For example, say some external interface to your FPGA is causing problems, but
    those problems are only occurring on your hardware while the simulation is working
    fine. At that point you might want to fire up a logic analyzer and try to see
    why your simulation is different from real life. Once you figure it out, you should
    strive to make your simulation as realistic as possible, adding to it the failure
    mode that you identified with the real-world test.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: These tools have saved me a couple of times in my career, but in general I try
    to avoid them if possible.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Verification</samp>
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Verification* is the process of ensuring that an FPGA or ASIC design is working
    as intended. It’s an exhaustive process that goes well beyond writing a few testbenches
    and running a simulation—so much so that there are people called verification
    engineers who perform verification full time. The complete details of how verification
    works are beyond the scope of this book. In fact, there are entire books dedicated
    to the subject. This section simply introduces the topic so you’re aware of the
    key role verification can play in real-world FPGA and ASIC design.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Consider a device like a DVD player. What happens if a DVD is playing, then
    the user pauses playback, ejects the DVD, and presses the fast-forward button?
    Does the code handle that sequence of events correctly? Or does the unexpected
    fast-forward command lock up the processor in a strange state? The verification
    engineer must test all of these corner cases to ensure the design won’t make a
    mistake in handling some strange situation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Back in [Chapter 1](chapter1.xhtml), I mentioned that making an ASIC is an incredibly
    expensive and time-consuming process. Once the ASIC is fabricated at the foundry,
    you have to cut a big check. If there are critical bugs in the design and the
    ASIC doesn’t work as intended, then you’ve just lost all that money, and you’ll
    need to rerun the ASIC fabrication process again. It’s the job of a verification
    engineer to ensure the design is correct up front, since finding and fixing bugs
    later is incredibly expensive.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Squashing bugs is great, but that’s only half the benefit. Another major goal
    of verification is to ensure the design is performing as intended. If you’re handed
    a specification of how an ASIC is supposed to perform, there might be ambiguities
    or missing information. Usually, one or more designers will design to the specification,
    and one or more separate verification engineers will simultaneously verify that
    the design is meeting the specification. If any discrepancies arise, the two teams
    can get together and update the specification so that everyone is clear on the
    intent.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Most verification engineers take advantage of the extra features built into
    SystemVerilog to thoroughly test a design. Self-checking testbenches are absolutely
    a must. It’s helpful to exercise the design randomly as well, so there are blocks
    of code that can inject random test cases into the design and ensure it’s working
    as intended.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Verifying code like this is no small feat. Often it’s more expensive and time-consuming
    to verify a design is working correctly than to create the design itself! For
    this reason, unlike with ASICs, not many FPGA designs go through a dedicated verification
    process. In most cases, it’s just too expensive. Remember that FPGA stands for
    *field programmable* gate array, so if a few bugs are allowed to slip through,
    the device can always be updated in the field, or in the hands of a customer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Usually, only FPGA designs that demand very high reliability or simply cannot
    be updated in the field go through verification. For example, some FPGAs are *one-time
    programmable (OTP)*, meaning they can only be programmed once; afterward, the
    functionality is locked in and cannot be changed. Some applications in outer space
    utilize these OTP FPGAs, since they’re more resistant to radiation. Additionally,
    OTP FPGAs are considered less susceptible to reverse engineering, so they’re preferable
    for high-security applications. OTP FPGA designs often require verification; however,
    this isn’t the norm for typical FPGA designs.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, testbenches are sufficient to find bugs in the FPGA design,
    but for ASICs or FPGAs that require it, verification is critically important.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this chapter, you’ve learned about simulating your FPGA code and seen how
    running simulations is time well spent. In contrast to debugging on hardware,
    simulation lets you visualize all the signals in your design, observe how they
    interact, and create stimuli to stress your code and see how it responds. You
    practiced writing testbenches, or code that instantiates your UUT, injects it
    with sample input, and monitors the output. You saw how looking at the waveforms
    generated during simulation is a great way to see if your design is working, but
    better still is adding tests that make your testbench self-checking. Less debugging
    on hardware, more beautiful simulations: that’s what makes a happy FPGA designer.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
