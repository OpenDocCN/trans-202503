- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">TESTING
    YOUR CODE WITH SIMULATION</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">5</samp> <samp class="SANS_Dogma_OT_Bold_B_11">使用仿真测试你的代码</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: There are two ways to find the bugs that will inevitably arise in an FPGA design.
    The first is to program the FPGA, run it, and see what happens. This is called
    finding bugs *on hardware*. The other way is to use a computer to inject test
    cases into your FPGA code to see how the code responds *before* you actually program
    the FPGA. This is called finding bugs *in simulation*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以找到FPGA设计中不可避免出现的错误。第一种方法是编程FPGA，运行它，看看发生了什么。这被称为在*硬件*上找错。另一种方法是使用计算机将测试用例注入到FPGA代码中，看看代码在你实际编程FPGA之前如何响应。这被称为在*仿真*中找错。
- en: For very simple projects, such as the ones we’ve explored so far in this book,
    jumping straight to programming the FPGA without any kind of simulation may be
    a reasonable approach (and it’s the one we’ve taken up to this point). However,
    as your FPGA designs grow more complicated, finding bugs on hardware becomes incredibly
    difficult. In nearly all cases, it’s significantly easier to find bugs in simulation.
    After thoroughly simulating and debugging a design, there’s nothing more satisfying
    than finally programming your FPGA and having everything work perfectly the first
    time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常简单的项目，比如本书到目前为止我们所探索的项目，直接跳过任何形式的仿真，直接编程FPGA可能是一个合理的方式（这也是我们到目前为止所采取的方式）。然而，随着FPGA设计的复杂度增加，发现硬件中的错误变得极其困难。在几乎所有情况下，在仿真中发现错误要容易得多。在彻底仿真和调试设计之后，没有什么比最终编程FPGA并且第一次就让一切工作完美更令人满足的了。
- en: 'In this chapter, you’ll learn how simulation works and see why it’s an essential
    step in the FPGA design process. We’ll explore a free simulator tool and I’ll
    introduce the testbench to show how you can write test code to stress your design.
    You’ll try out these concepts by adding a debounce circuit to the LED-toggling
    project from the previous chapter (Project #3) and simulating the design. Finally,
    we’ll take a look at verification, which is a more formal and rigorous process
    for testing out FPGA and ASIC designs.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你将学习仿真是如何工作的，并了解它为何是FPGA设计过程中的一个重要步骤。我们将探索一个免费的仿真工具，并且我将介绍测试平台，展示如何编写测试代码来测试你的设计。你将通过为前一章中的LED切换项目（项目#3）添加去抖电路并仿真设计来实践这些概念。最后，我们将看看验证，这是一种更正式和严格的FPGA和ASIC设计测试过程。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why Simulation Matters</samp>
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">为什么仿真很重要</samp>
- en: Simulation is important because your FPGA is essentially a black box, as shown
    in [Figure 5-1](#fig5-1). When you program the FPGA, you’re able to change the
    inputs and see how the outputs respond, but you’re unable to see the details of
    what’s going on inside the box itself. You can’t follow the individual variables
    and data signals as they flow inside your FPGA.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 仿真很重要，因为你的FPGA本质上是一个黑箱，正如[图5-1](#fig5-1)所示。当你编程FPGA时，你能够更改输入并查看输出如何响应，但你无法看到箱子内部发生的具体细节。你不能追踪各个变量和数据信号在FPGA内部的流动。
- en: '![](../images/Figure5-1.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-1.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-1: What’s in the box?</samp>'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-1: 箱子里有什么？</samp>'
- en: If something goes wrong inside that black box (and it will), and the output
    isn’t what you expect, figuring out the problem is very difficult. The solution
    is to use a computer to simulate the inner workings of the black box in a way
    you can follow. Simulation effectively opens up the black box of your FPGA so
    you can see what’s going on inside.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果黑箱内部出了问题（而且它一定会出现问题），并且输出结果与预期不符，找出问题所在是非常困难的。解决方案是使用计算机仿真黑箱的内部工作原理，以一种你可以理解的方式来查看。仿真有效地打开了FPGA的黑箱，让你能够看到内部发生了什么。
- en: 'Let me give you an example of how useful this can be. In a past job, I had
    a coworker who was trying to fix a problem with his FPGA design. For some reason
    the data was getting mixed up inside the FPGA. He spent weeks using oscilloscopes
    and logic analyzers to send data off the FPGA so he could try to find where the
    issue was coming from. At one point I asked him if he had simulated the design
    at all. He had not: he didn’t have any experience with simulation and didn’t feel
    he could take the time out to learn. I checked his code out of revision control
    and put together a simulation for it, and within a few hours had found the problem.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你一个这个工具有多么有用的例子。在我过去的一份工作中，有一个同事在尝试修复他FPGA设计中的一个问题。由于某种原因，数据在FPGA内部被混淆了。他花了几个星期用示波器和逻辑分析仪将数据从FPGA中送出，以便查找问题的根源。有一次，我问他是否做过仿真设计。他没有做过：他没有仿真经验，也觉得自己没有时间去学习。我从版本控制中取出了他的代码，并为其制作了仿真模型，在几个小时内找出了问题。
- en: Simulating your design allows you to stress it to see how it reacts. In this
    case, I was able to re-create the exact failure in simulation and fix the issue
    very quickly. Ironically, in the time my coworker had spent attempting to debug
    the problem on hardware, he could easily have learned how to do the simulation
    himself. It’s an even more attractive option when you consider that once you know
    how simulation works, you can use that knowledge again and again.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 仿真你的设计能够对其进行压力测试，看看它的反应。在这种情况下，我能够在仿真中重新创建出相同的故障，并迅速修复问题。具有讽刺意味的是，我的同事在硬件上调试问题时所花费的时间，他完全可以花时间学习如何进行仿真。考虑到一旦掌握了仿真原理，你可以反复使用这一技能，这无疑是一个更具吸引力的选择。
- en: <samp class="SANS_Futura_Std_Bold_B_11">FPGA Simulation Tools</samp>
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">FPGA仿真工具</samp>
- en: There are several popular FPGA simulation tools available. FPGA build tools
    often have a simulation tool bundled with them, in one large downloadable package;
    FPGA companies know that their designers want to run simulations, and they want
    to make it easy to do that. These tools are usually free and convenient, but they
    can be many gigabytes in size and their complexity can be overwhelming for beginners.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 有几款流行的FPGA仿真工具可供选择。FPGA构建工具通常会捆绑一个仿真工具，作为一个大型可下载的包提供；FPGA公司知道他们的设计师需要运行仿真，因此他们希望简化这一过程。这些工具通常是免费的且方便使用，但它们的文件大小可能有好几个GB，而且对初学者来说，工具的复杂性可能会让人不知所措。
- en: 'An alternative solution to the large FPGA tools is to use a standalone simulator.
    The benefit to this is that if you switch from Intel (Altera) to AMD (Xilinx),
    for example, you don’t need to learn a whole new tool; your simulator can stay
    the same. There are two popular standalone simulation tools that I generally recommend:
    ModelSim and EDA Playground. ModelSim is probably the most popular commercial
    simulator. It can be downloaded and installed on Windows and Linux. A full license
    is expensive, costing around $2,000, but a free version with limited features
    is available.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 针对大型FPGA工具的另一种解决方案是使用独立的仿真器。这样做的好处是，如果你从Intel（Altera）切换到AMD（Xilinx），例如，你不需要学习一个全新的工具；你的仿真器可以保持不变。我通常推荐两款流行的独立仿真工具：ModelSim和EDA
    Playground。ModelSim可能是最流行的商业仿真器。它可以在Windows和Linux上下载并安装。完整版许可证很贵，价格大约为2000美元，但有一个功能有限的免费版本。
- en: EDA Playground, by contrast, is a freely available web-based simulator. I recommend
    using it when you’re first learning about FPGA design for a few reasons. First,
    it’s free. Second, since it’s web-based, there’s no download required. Finally,
    EDA Playground allows you to share your code with others via a web link. For the
    purposes of this book, we’ll focus on this tool.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，EDA Playground 是一个免费提供的基于Web的仿真工具。我推荐在你刚开始学习FPGA设计时使用它，原因有几个。首先，它是免费的。其次，由于它是基于Web的，因此无需下载。最后，EDA
    Playground允许你通过网页链接与他人共享代码。对于本书的目的，我们将重点介绍这个工具。
- en: To get started with EDA Playground, first navigate to [*https://<wbr>edaplayground<wbr>.com*](https://edaplayground.com).
    To run simulations and save your progress, you’ll need to create an account and
    log in. Once you do so, you should see a screen like the one in [Figure 5-2](#fig5-2).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用EDA Playground，首先访问 [*https://<wbr>edaplayground<wbr>.com*](https://edaplayground.com)。要运行仿真并保存进度，你需要创建一个账户并登录。登录后，你应该会看到像[图5-2](#fig5-2)所示的界面。
- en: '![](../images/Figure5-2.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-2.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-2: The EDA Playground
    main screen</samp>'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图5-2：EDA Playground主界面</samp>
- en: Notice that there are two main code windows. The window on the right, titled
    *design.sv*, is where the FPGA design code you want to test goes. This code is
    typically called the *unit under test (UUT)* or *device under test (DUT)*. The
    window on the left, called *testbench.sv*, is where you write *testbenches*, code
    that will exercise your FPGA design during simulation. We’ll discuss how testbenches
    work in the next section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有两个主要的代码窗口。右侧窗口，标题为*design.sv*，是你要测试的 FPGA 设计代码所在的地方。这个代码通常被称为*被测试单元（UUT）*或*被测试设备（DUT）*。左侧窗口，称为*testbench.sv*，是你编写*测试平台*的地方，测试平台代码将在仿真过程中对你的
    FPGA 设计进行操作。我们将在下一节讨论测试平台的工作原理。
- en: By default, EDA Playground is configured for SystemVerilog/Verilog designs,
    which is why the two window labels have *.sv* (SystemVerilog) file extensions.
    If you wish to reconfigure EDA Playground for VHDL, select **VHDL** in the drop-down
    menu under Testbench + Design on the left side of the window.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，EDA Playground 配置为 SystemVerilog/Verilog 设计，这就是为什么两个窗口标签有 *.sv*（SystemVerilog）文件扩展名的原因。如果你希望将
    EDA Playground 配置为 VHDL，请在窗口左侧的 Testbench + Design 下拉菜单中选择**VHDL**。
- en: Before you can run code in EDA Playground, you’ll need to select a simulator
    tool. This is the actual product that will run your code. You can play around
    with different tools listed in the drop-down menu under Tools & Simulators to
    see if you prefer one over another. In general, I find that they behave similarly,
    though some are exclusively for Verilog or VHDL. I’ve had good luck using Mentor
    Questa or Aldec Riviera.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以在 EDA Playground 中运行代码之前，你需要选择一个仿真工具。这是实际运行你代码的产品。你可以在“工具和仿真器”下拉菜单中尝试不同的工具，看看是否更喜欢其中的某一个。通常，我发现它们的行为非常相似，尽管有些工具是专门为
    Verilog 或 VHDL 设计的。我使用 Mentor Questa 或 Aldec Riviera 取得过不错的成果。
- en: Another neat feature of EDA Playground is the Examples section of the toolbar.
    Here, you can explore sample testbenches that have been made freely available.
    You can see how they work and modify them for your own experiments, and perhaps
    gain some insights into clever ways to write your own code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: EDA Playground 的另一个有趣功能是工具栏中的示例部分。在这里，你可以查看一些免费的示例测试平台。你可以了解它们的工作原理并修改它们用于自己的实验，或许还能获得一些写自己代码的巧妙思路。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Testbench</samp>
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">测试平台</samp>
- en: The purpose of a testbench is to exercise your UUT in a simulation environment
    so you can analyze it and see if it’s behaving as expected. The testbench code
    instantiates the UUT. As you can see in [Figure 5-3](#fig5-3), the testbench provides
    all the required inputs to the UUT and monitors all the outputs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 测试平台的目的是在仿真环境中对你的 UUT 进行操作，以便你可以分析它并查看它是否按预期工作。测试平台代码实例化了 UUT。如[图 5-3](#fig5-3)所示，测试平台提供了所有必需的输入给
    UUT，并监控所有的输出。
- en: '![](../images/Figure5-3.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-3.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-3: A testbench exercises
    a UUT so you can analyze it.</samp>'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-3：测试平台对 UUT 进行操作，以便你进行分析。</samp>
- en: If your UUT has a clock as an input, for example, the testbench will need to
    generate that clock and feed it in to the UUT. Similarly, if there’s a data interface
    into your UUT, the testbench will likely need to generate some sample data to
    supply to that interface. The testbench monitors all the outputs from the UUT,
    allowing it to see how the UUT responds to the input data. During the simulation,
    you’ll also be able to dive into the UUT itself to see how all of its internal
    signals are behaving in response to the testbench’s inputs. You can monitor every
    element of your design—every register, clock, wire, memory, and so on—and make
    sure they’re all behaving as intended.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的被测试单元（UUT）有一个时钟作为输入，例如，测试平台将需要生成该时钟并将其馈送到UUT中。类似地，如果UUT有数据接口，测试平台可能需要生成一些样本数据并将其提供给该接口。测试平台会监控UUT的所有输出，从而了解UUT如何响应输入数据。在仿真过程中，你还可以深入查看UUT本身，了解其所有内部信号如何响应测试平台的输入。你可以监控设计中的每个元素——每个寄存器、时钟、信号线、存储器等等——并确保它们按预期工作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing a Testbench</samp>
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">编写测试平台</samp>
- en: 'Let’s take a look at a simple example by writing a testbench for the AND gate
    project from [Chapter 3](chapter3.xhtml) (Project #2). First, to review, here’s
    the original project code that we want to test:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过为[第3章](chapter3.xhtml)（项目#2）中的与门项目编写一个测试平台来查看一个简单的例子。首先，回顾一下，这是我们要测试的原始项目代码：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Enter the module or entity’s code into the *design.sv* or *design.vhd* window
    on the right side of EDA Playground. To test the code completely, we want to exercise
    it to make sure that the output behaves as intended with all possible input combinations.
    In this case, the total range of input combinations is pretty small: since there
    are two inputs, there are just four possible combinations to test in order to
    fully exercise the UUT. We’ll create a testbench in Verilog and VHDL to instantiate
    the UUT and test it by passing in each of the four input combinations. Enter the
    following code into the *testbench.sv* or *testbench.vhd* window in EDA Playground:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块或实体的代码输入到EDA Playground右侧的*design.sv*或*design.vhd*窗口中。为了完全测试代码，我们需要对其进行操作，确保输出在所有可能的输入组合下表现如预期。在这种情况下，输入组合的总范围相当小：由于有两个输入，因此只需要测试四种可能的组合，就能完全验证UUT的功能。我们将分别在Verilog和VHDL中创建测试平台，以实例化UUT并通过传入每种输入组合来进行测试。将以下代码输入到EDA
    Playground中的*testbench.sv*或*testbench.vhd*窗口中：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, notice that this is the first time we’ve seen a Verilog module or VHDL
    entity that has no inputs or outputs declared ❶. This is because this testbench
    doesn’t connect to any external signals; as you saw earlier, in [Figure 5-3](#fig5-3),
    the testbench itself provides the inputs.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请注意，这是我们第一次看到没有声明任何输入或输出的Verilog模块或VHDL实体❶。这是因为该测试平台没有连接任何外部信号；正如你在[图5-3](#fig5-3)中看到的，测试平台本身提供输入。
- en: Inside the module/entity, we instantiate the UUT ❷. We connect the inputs of
    the UUT to <samp class="SANS_TheSansMonoCd_W5Regular_11">r_In1</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_In2</samp>, signals that we declare
    in the testbench. These signals will be the stimuli provided to see how the UUT
    responds. We’ll be monitoring the output, <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Out</samp>,
    to see how it reacts to changing inputs. I like to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">w_</samp>
    prefix on signal names to represent wires, or interconnections within the FPGA.
    Remember, we want to make sure the AND gate is working as expected.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块/实体内部，我们实例化了UUT ❷。我们将UUT的输入连接到在测试平台中声明的<samp class="SANS_TheSansMonoCd_W5Regular_11">r_In1</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_In2</samp>信号。这些信号将作为刺激输入，用于观察UUT的响应。我们将监控输出<samp
    class="SANS_TheSansMonoCd_W5Regular_11">w_Out</samp>，以查看它如何响应变化的输入。我喜欢在信号名上使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">w_</samp>前缀，表示FPGA内的电线或互连。记住，我们需要确保与门按预期工作。
- en: We start driving the stimuli (inputs) within an <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>
    block in Verilog or a <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block in VHDL ❸. This block will start at the beginning of the simulation and
    will execute from top to bottom in sequence. We send each of the four possible
    input combinations to the UUT, one after the other. Using delay statements, we
    add a 10 ns pause between each input combination to allow time for the simulation
    to update the <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Out</samp> signal
    after each change. In Verilog we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">#10</samp>
    delay feature, and in VHDL we use <samp class="SANS_TheSansMonoCd_W5Regular_11">wait
    for 10 ns;</samp>. As you’ll see later in this chapter, these time-based delays—indeed,
    any reference to the passage of time—are non-synthesizable, meaning they would
    not work on an actual FPGA; however, they work perfectly well in simulation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始在Verilog中的<samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp>块或VHDL中的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">process</samp>块内驱动刺激（输入）。这个块会在仿真开始时执行，并按顺序从上到下执行。我们将逐一将四种可能的输入组合发送到UUT。使用延时语句，我们在每个输入组合之间添加10纳秒的暂停，以便仿真有时间在每次变化后更新<samp
    class="SANS_TheSansMonoCd_W5Regular_11">w_Out</samp>信号。在Verilog中，我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">#10</samp>延时特性，在VHDL中则使用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">wait for 10 ns;</samp>。正如你将在本章稍后看到的，这些基于时间的延时——事实上，任何关于时间流逝的引用——都是不可综合的，意味着它们在实际FPGA上无法工作；然而，在仿真中它们可以完美运行。
- en: In the Verilog version, note that EDA Playground requires the <samp class="SANS_TheSansMonoCd_W5Regular_11">$dumpfile</samp>
    directive ❹. This allows the simulator to generate waveforms, which we’ll cover
    in the next section. This line isn’t required in VHDL.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Verilog版本中，请注意EDA Playground需要<samp class="SANS_TheSansMonoCd_W5Regular_11">$dumpfile</samp>指令❹。这使得模拟器能够生成波形，我们将在下一节进行讲解。VHDL中不需要此行代码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Running a Testbench
    and Viewing Waveforms</samp>
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">运行测试平台并查看波形</samp>
- en: Running a testbench generates *waveforms*, or visual representations of the
    signals in your test environment, showing you how they change over time. Waveforms
    are a powerful tool for investigating failures in an FPGA design during simulation;
    the more you work with FPGAs, the more time you’ll spend staring at waveforms.
    EDA Playground makes examining waveforms easy with its built-in waveform viewer,
    EPWave.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试平台会生成*波形*，即测试环境中信号的可视化表示，展示信号如何随时间变化。波形是用于检查FPGA设计在仿真过程中失败的强大工具；你与FPGA打交道的时间越长，越会花时间盯着波形看。EDA
    Playground通过内置的波形查看器EPWave使得查看波形变得更加简便。
- en: Let’s run our AND gate testbench and view the resulting waveform in EPWave.
    First, check the **Open EPWave After Run** checkbox in the Tools & Simulators
    section of the toolbar on the left side of the EDA Playground window. If you’re
    using VHDL, you will need to specify which entity is the top of your design. To
    do that, enter <samp class="SANS_TheSansMonoCd_W7Bold_B_11">And_Gate_TB</samp>
    in the Top Entity dialog. Then choose a simulator tool from the drop-down menu
    and hit **Run**. [Figure 5-4](#fig5-4) shows the resulting waveform.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行与门测试平台，并在EPWave中查看结果波形。首先，在EDA Playground窗口左侧的工具和仿真器部分勾选**运行后打开EPWave**复选框。如果你使用的是VHDL，你需要指定设计的顶层实体。为此，在“顶层实体”对话框中输入<samp
    class="SANS_TheSansMonoCd_W7Bold_B_11">And_Gate_TB</samp>。然后从下拉菜单中选择一个仿真器工具并点击**运行**。[图5-4](#fig5-4)显示了生成的波形。
- en: '![](../images/Figure5-4.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-4.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-4: The AND gate testbench
    waveform output</samp>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图5-4：与与门测试平台波形输出</samp>
- en: Here we see all the signals that exist in the design, and we can note the time
    in nanoseconds when each signal changes from high to low or low to high. The top
    three signals (<samp class="SANS_TheSansMonoCd_W5Regular_11">r_In1</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_In2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Out</samp>)
    are the testbench signals. The bottom three (<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>)
    are in the UUT. Since we wired the testbench and UUT signals together when we
    instantiated the UUT, the corresponding testbench/UUT signals look the same. For
    example, <samp class="SANS_TheSansMonoCd_W5Regular_11">r_In1</samp> has the same
    waveform as <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>. Note
    that if the UUT had other internal signals that weren’t brought out of the module,
    you would be able to see waveforms for those as well, and they wouldn’t have a
    corresponding testbench signal.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到设计中所有的信号，并且可以记录下每个信号从高到低或从低到高变化时的时间，单位为纳秒。顶部的三个信号（<samp class="SANS_TheSansMonoCd_W5Regular_11">r_In1</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_In2</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">w_Out</samp>）是测试平台信号。底部的三个信号（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_2</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>）则位于被测单元（UUT）中。由于我们在实例化UUT时将测试平台和UUT信号连接在一起，因此对应的测试平台/UUT信号是相同的。例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_In1</samp>的波形与<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>相同。注意，如果UUT中有其他内部信号没有从模块中引出，你也可以看到这些信号的波形，而且它们不会有对应的测试平台信号。
- en: Looking at the waveform, we can see that the UUT is working as expected. The
    AND gate output (<samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Out</samp>) is high only when
    both inputs are also high. When only one input is high, or when both inputs are
    low, the output is low. As you examine the waveform, take a look back at the testbench
    code and notice how the changes in the waveform correspond to the statements in
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">initial</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">process</samp>
    block. In the code, for example, both inputs start out low, and then <samp class="SANS_TheSansMonoCd_W5Regular_11">r_In2</samp>
    goes high after a 10 ns pause. Looking at the 10 ns mark in the waveform, you
    can see that this is where <samp class="SANS_TheSansMonoCd_W5Regular_11">r_In2</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_2</samp> change from
    low to high.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 从波形图中，我们可以看到UUT的工作情况符合预期。只有当两个输入都为高时，AND门的输出（<samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Out</samp>）才为高。当只有一个输入为高，或两个输入都为低时，输出为低。在检查波形时，回顾测试平台代码，注意波形中的变化是如何对应到<sub>initial</sub>或<sub>process</sub>块中的语句。例如，在代码中，两个输入一开始为低，之后<sub>r_In2</sub>在10
    ns后变为高。查看波形中的10 ns位置，你可以看到<sub>r_In2</sub>和<sub>i_Switch_2</sub>从低变为高。
- en: Although this was a simple example, it illustrates the power of the testbench
    to simulate your FPGA design and let you see everything that is happening. You
    can monitor all the interactions within the design, and if a signal isn’t behaving
    as expected, you can investigate why that is, modify your code, and run the testbench
    again to generate a new waveform. Often when debugging issues, I’ll rerun simulations
    dozens of times until my design is behaving as desired.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个简单的示例，但它展示了测试平台的强大功能，能够模拟你的FPGA设计并让你看到所有发生的事情。你可以监控设计中的所有交互，如果某个信号未按预期工作，你可以调查原因，修改代码，并重新运行测试平台生成新的波形。在调试问题时，我通常会重新运行数十次模拟，直到设计按预期工作为止。
- en: In this case, since we were testing a single basic module, we were able to evaluate
    everything using a single testbench file. For more complicated simulations, however,
    testbenches can contain many different files that all work together to simulate,
    monitor, and check your design to make sure it’s behaving as intended.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于我们只测试了一个基本模块，因此我们可以使用一个测试平台文件来评估所有内容。然而，对于更复杂的模拟，测试平台可能包含多个文件，这些文件协同工作，模拟、监视并检查你的设计，以确保它按预期工作。
- en: You’ll see how testbenches work in more detail in our next project, where we’ll
    write a testbench and simulate the FPGA design prior to programming the hardware.
    This will help you gain confidence that your code is working, and it will allow
    you to identify and fix any bugs early in the process. The project also illustrates
    how the concept of time works on an FPGA, so even if you don’t have an FPGA to
    program, I recommend reading through this section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个项目中，你将更详细地了解测试平台的工作原理，我们将在项目中编写一个测试平台，并在编程硬件之前模拟FPGA设计。这将帮助你确认代码是否正常工作，并允许你在过程早期发现并修复任何bug。该项目还展示了FPGA上时间概念的工作方式，即使你没有FPGA可以编程，我仍然建议阅读这一部分。
- en: '<samp class="SANS_Futura_Std_Heavy_B_21">Project #4: Debouncing a Switch</samp>'
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Heavy_B_21">项目#4：去抖动一个开关</samp>
- en: 'In [Chapter 4](chapter4.xhtml), we programmed an FPGA to toggle an LED at the
    push of a button. However, there was a problem: pushing the button didn’t consistently
    toggle the state of the LED. This is because any physical switch, including a
    push-button or toggle switch, is subject to *bouncing*, or rapid signal fluctuations
    that occur when the switch is toggled or flipped. Bouncing happens when the metal
    contacts inside the switch come together and move apart quickly before they have
    time to settle into the stable state. [Figure 5-5](#fig5-5) illustrates how this
    affects the switch’s output signal.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](chapter4.xhtml)中，我们编程了一个FPGA，使其在按下按钮时切换LED的状态。然而，存在一个问题：按下按钮并不能稳定地切换LED的状态。这是因为任何物理开关，包括按钮或切换开关，都容易受到*抖动*的影响，抖动是指当开关被切换或翻转时，信号发生快速波动。抖动发生在开关内部的金属触点快速接触后又迅速分开，未能及时稳定到稳定状态。[图5-5](#fig5-5)展示了这一过程如何影响开关的输出信号。
- en: '![](../images/Figure5-5.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-5.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-5: Bouncing in a mechanical
    switch</samp>'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-5: 机械开关中的抖动</samp>'
- en: If you didn’t know about bouncing, you would probably expect the switch to behave
    like the top half of [Figure 5-5](#fig5-5). The button is pressed, and the output
    immediately goes from low to high. However, in the real world bouncing creates
    glitches in the output signal, which show up as rapid low-to-high-to-low transitions
    of the output signal, before it finally stays high. Again, this is due to the
    mechanical switch contacts quickly coming together and moving apart before settling
    into a stable output state.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不了解抖动，你可能会期待开关表现得像[图 5-5](#fig5-5)的上半部分。按钮被按下时，输出立即从低变高。然而，在现实世界中，抖动会在输出信号中产生毛刺，这表现为输出信号的快速低到高再到低的过渡，直到它最终保持高电平。这再次是因为机械开关接触点在快速接合和分开后，才稳定在一个稳定的输出状态。
- en: The code in our LED toggling project was looking for a single falling edge to
    indicate the press and release of the button, but due to the bouncing, the FPGA
    was seeing many falling edges per press/release. If it saw an odd number of falling
    edges during the bouncing of the switch, then the LED toggled successfully. If
    it saw an even number of falling edges, however, the LED didn’t appear to change
    state, since each pair of falling edges effectively canceled each other out.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在LED切换项目中的代码是寻找一个单一的下降沿来指示按钮的按下和释放，但由于抖动，FPGA在每次按下/释放时都会看到多个下降沿。如果在抖动过程中看到了奇数个下降沿，那么LED就成功切换。如果看到的是偶数个下降沿，LED则没有改变状态，因为每对下降沿实际上是相互抵消的。
- en: The number of bounces on a switch is somewhat random, so pushing the switch
    enough times got the LED to toggle successfully. Still, it would be better if
    the LED toggled as expected each time the switch is pressed and released. To make
    this happen, we need to add a *debounce filter* to the switch. That is, we need
    to program the FPGA to ignore the bounces. [Figure 5-6](#fig5-6) illustrates how
    this will work.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 开关上的抖动次数是有些随机的，因此按下开关足够多次，LED才会成功切换。然而，如果每次按下和释放开关时，LED都能按预期切换，那将更好。为了实现这一点，我们需要在开关上添加一个*去抖动滤波器*。也就是说，我们需要编程FPGA来忽略抖动。[图
    5-6](#fig5-6)展示了这将如何工作。
- en: '![](../images/Figure5-6.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-6.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-6: The Project #4
    block diagram</samp>'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 5-6: 项目 #4 块图</samp>'
- en: We’ll add a debounce filter to the code from the previous project to ensure
    that a single press of the button only toggles the LED once. The signal from the
    switch will pass through the debounce filter before going on to the LED-toggling
    logic we wrote in the last chapter.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会在前一个项目的代码中加入一个去抖动滤波器，以确保按钮的单次按下只切换一次LED。来自开关的信号将通过去抖动滤波器，然后再传递给我们在上一章中编写的LED切换逻辑。
- en: We create a debounce filter by making sure that the input from the switch is
    stable for some amount of time before allowing the output driving the LED to change.
    We therefore need to have some concept of how much time has passed in our FPGA.
    However, introducing the notion of time into an FPGA design raises some interesting
    challenges.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过确保来自开关的输入在允许驱动LED输出发生变化之前保持稳定一段时间来创建去抖动滤波器。因此，我们需要在FPGA中有某种关于时间流逝的概念。然而，将时间引入FPGA设计带来了一些有趣的挑战。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Measuring Time on
    an FPGA</samp>
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">在FPGA上测量时间</samp>
- en: Time doesn’t exist inherently in an FPGA. The FPGA doesn’t automatically know
    if it’s Saturday at 11:00 AM, or how to wait for 100 ms, for example. To be sure,
    there are parts of Verilog and VHDL code that refer to time. For example, we already
    saw how to use <samp class="SANS_TheSansMonoCd_W5Regular_11">#10</samp> in Verilog
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">wait for 10 ns;</samp> in VHDL
    to add 10 ns delays to our AND gate testbench. To give another example, in Verilog
    you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">$time</samp> to get
    the current time, while in VHDL the reserved word <samp class="SANS_TheSansMonoCd_W5Regular_11">now</samp>
    gets a timestamp of the current time. However, while features like these will
    work perfectly well in simulation, they will 100 percent not work on your FPGA.
    They *aren’t synthesizable*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 时间在 FPGA 中本身并不存在。FPGA 不会自动知道现在是否是星期六上午 11:00，或者如何等待 100 毫秒，例如。确实，Verilog 和 VHDL
    代码中有些部分是与时间相关的。例如，我们已经看到如何在 Verilog 中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">#10</samp>
    或在 VHDL 中使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">wait for 10 ns;</samp>
    来给我们的与门测试平台添加 10 ns 的延迟。再举个例子，在 Verilog 中，你可以使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">$time</samp>
    来获取当前时间，而在 VHDL 中，保留字 <samp class="SANS_TheSansMonoCd_W5Regular_11">now</samp>
    会获取当前时间的时间戳。然而，像这些特性在仿真中可以正常工作，但它们 100% 无法在你的 FPGA 上运行。它们是*无法综合的*。
- en: We’ve already talked about synthesis a few times. It’s the part of the build
    process where the FPGA tool turns your Verilog or VHDL code into flip-flops, LUTs,
    and other components. Unfortunately, synthesis tools can’t synthesize anything
    relating to time. It’s just not possible. As a result, language constructs like
    <samp class="SANS_TheSansMonoCd_W5Regular_11">$time</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">now</samp>
    are simply ignored or will create errors during synthesis. In [Chapter 7](chapter7.xhtml),
    we’ll look more closely at what features of VHDL and Verilog aren’t able to be
    synthesized in an FPGA. For now, take it for granted that we can’t use some of
    these built-in features relating to time.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论过几次综合。综合是构建过程中，FPGA 工具将你的 Verilog 或 VHDL 代码转化为触发器、查找表（LUT）和其他组件的部分。不幸的是，综合工具无法综合任何与时间相关的内容。这是无法实现的。因此，像
    <samp class="SANS_TheSansMonoCd_W5Regular_11">$time</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">now</samp>
    这样的语言构造将被简单地忽略，或者在综合过程中产生错误。在[第七章](chapter7.xhtml)中，我们将更详细地了解哪些 VHDL 和 Verilog
    特性无法在 FPGA 上综合。目前，先接受这样一个事实：我们无法使用与时间相关的某些内建特性。
- en: If time doesn’t exist in an FPGA, how can you keep track of how much time has
    passed for the purposes of debouncing a switch or one of the many other time-related
    tasks you may wish your FPGA to perform? The answer is to *count clock cycles*.
    If you know how many clock cycles have occurred, and you know the period of the
    clock, you’ll know how much time has elapsed. Let’s walk through an example.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果时间在 FPGA 中不存在，如何追踪已过去的时间，以便执行去抖动开关或其他许多与你希望 FPGA 执行的时间相关的任务呢？答案是*计算时钟周期*。如果你知道已经发生了多少个时钟周期，并且你知道时钟的周期，就能知道已经过去了多少时间。让我们通过一个例子来演示。
- en: 'Say you have a clock that oscillates at 25 MHz, and that the clock’s period—the
    duration of a single cycle—is 40 ns. Given these specifications, how many clock
    cycles would it take for 400 ns to elapse? Answer: 10\. And for 4,000 ns to elapse?
    Answer: 100\. Simply divide the amount of time you want to wait by the period
    of the clock to get the number of clock cycles you need to count before that amount
    of time has elapsed. This technique is going to be critical in our debounce project.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个时钟，它的频率为 25 MHz，时钟的周期——即单个周期的持续时间——是 40 ns。根据这些规格，经过 400 ns 需要多少个时钟周期？答案：10。那经过
    4,000 ns 需要多少个时钟周期？答案：100。只需将你想要等待的时间除以时钟的周期，就能得到在该时间过去之前需要计数的时钟周期数。这项技术将在我们的去抖动项目中至关重要。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Writing the Code</samp>
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">编写代码</samp>
- en: 'Let’s look at how to implement the debounce filter. We’ll start with the top-level
    module, which instantiates and links together two lower-level modules, one for
    debouncing the switch and the other for toggling the LED:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何实现去抖动滤波器。我们将从顶层模块开始，它实例化并连接两个低层模块，一个用于去抖动开关，另一个用于切换 LED：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code matches the block diagram in [Figure 5-6](#fig5-6). At the highest
    level we have <samp class="SANS_TheSansMonoCd_W5Regular_11">Debounce_Project_Top</samp>,
    which instantiates two other modules. The first is the new debounce filter ❶,
    which we’ll examine next. The second is the <samp class="SANS_TheSansMonoCd_W5Regular_11">LED_Toggle_Project</samp>
    module that we created in the previous chapter ❸. It’s worth taking a minute to
    follow the signals here. We can see the input signal <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>
    going into the debounce filter. Out of that comes <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Debounced_Switch</samp>,
    which is the debounced version of this input. This is passed into the <samp class="SANS_TheSansMonoCd_W5Regular_11">LED_Toggle
    _Project</samp> module. The output of that module is <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>,
    which will be connected to the LED pin on your development board. Note that indicating
    the direction of your signals via their names, as we do here with the <samp class="SANS_TheSansMonoCd_W5Regular_11">i_</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">o_</samp> prefixes, becomes
    very helpful as your designs get larger and incorporate more signals.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与[图 5-6](#fig5-6)中的框图相匹配。在最高层，我们有 <samp class="SANS_TheSansMonoCd_W5Regular_11">Debounce_Project_Top</samp>，它实例化了两个其他模块。第一个是新的去抖动滤波器
    ❶，我们将在下文中检查它。第二个是我们在上一章创建的 <samp class="SANS_TheSansMonoCd_W5Regular_11">LED_Toggle_Project</samp>
    模块 ❸。值得花点时间跟踪这里的信号。我们可以看到输入信号 <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Switch_1</samp>
    进入去抖动滤波器。从中输出 <samp class="SANS_TheSansMonoCd_W5Regular_11">w_Debounced_Switch</samp>，这是该输入的去抖动版本。这个信号被传入
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LED_Toggle_Project</samp> 模块。该模块的输出是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">o_LED_1</samp>，它将连接到你开发板上的 LED 引脚。请注意，通过信号的名称来指示信号的方向，如我们在这里使用的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">i_</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">o_</samp>
    前缀，在设计变得更大且包含更多信号时非常有帮助。
- en: It’s important to highlight the value of creating reusable modules when writing
    FPGA code. Rather than writing all the project’s code from scratch, here we’re
    able to reuse the <samp class="SANS_TheSansMonoCd_W5Regular_11">LED_Toggle_Project</samp>
    module from the previous chapter and improve its functionality by interfacing
    it with another module. Another way to make modules reusable is to incorporate
    Verilog *parameters* or VHDL *generics*. These are variables within a module that
    you can override from higher-level code. We do this when we instantiate the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Debounce_Filter</samp> module. Specifically,
    we override the module’s parameter/generic called <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT</samp>
    with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">250000</samp> ❷.
    As you’ll see later, this value sets the number of clock cycles to wait while
    debouncing the switch. Coding it as a parameter/generic makes it easy to modify
    the value. In general, parameters (in Verilog) and generics (in VHDL) are a very
    useful way to keep code portable. They let you change the behavior of a module
    without having to actually modify the module’s file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 FPGA 代码时，创建可重用模块的价值非常重要。与其从头开始编写所有项目的代码，不如在这里复用上一章的 <samp class="SANS_TheSansMonoCd_W5Regular_11">LED_Toggle_Project</samp>
    模块，并通过与另一个模块接口来改进其功能。另一个使模块可重用的方法是将 Verilog 的 *参数* 或 VHDL 的 *泛型* 纳入模块中。这些是模块中的变量，可以通过更高层的代码覆盖它们。当我们实例化
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Debounce_Filter</samp> 模块时，就会这样做。具体来说，我们用值
    <samp class="SANS_TheSansMonoCd_W5Regular_11">250000</samp> ❷ 来覆盖模块的参数/泛型 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT</samp>。正如你稍后会看到的，这个值设置了去抖动开关时需要等待的时钟周期数。将其编码为参数/泛型使得修改该值变得容易。通常，Verilog
    中的参数和 VHDL 中的泛型是保持代码可移植的非常有用的方法。它们让你可以改变模块的行为，而无需实际修改模块的文件。
- en: 'Let’s now examine the code of the debounce filter module:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看去抖动滤波模块的代码：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The overall purpose of this module is to remove any bounces or glitches in the
    input (<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Bouncy</samp>) and create
    a stable output (<samp class="SANS_TheSansMonoCd_W5Regular_11">o_Debounced)</samp>.
    To do this, we check if the input and output are different. If they are, we know
    the input is changing, but we don’t want to immediately update the output, since
    the switch might still be bouncing. Instead, we want to make sure that the input
    is stable for a long enough period of time before updating the output. Because
    the FPGA has no inherent concept of time, we implement the delay by counting clock
    cycles.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块的整体目的是去除输入(<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Bouncy</samp>)中的任何抖动或故障，并产生一个稳定的输出(<samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_Debounced</samp>)。为了做到这一点，我们检查输入和输出是否不同。如果不同，我们知道输入正在变化，但我们不希望立即更新输出，因为开关可能还在抖动。相反，我们希望确保输入在更新输出之前已经稳定了一段足够长的时间。由于FPGA没有固有的时间概念，我们通过计数时钟周期来实现延迟。
- en: Let’s say we want the input to be stable for 10 ms before we update the output.
    We need to count up to some number of clock cycles that represents 10 ms (or 10
    million nanoseconds) of time passed. The Go Board, for example, has a clock period
    of 40 ns, so in this case we divide 10 million by 40 to get a delay of 250,000
    clock cycles. This is the value we used for the <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT</samp>
    parameter/generic in the top-level module <samp class="SANS_TheSansMonoCd_W5Regular_11">Debounce_Project_Top</samp>.
    If your development board has a different clock period, you’ll need to change
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT</samp> accordingly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望输入在更新输出之前稳定10毫秒。我们需要计算出一个表示经过10毫秒（或1000万纳秒）时间的时钟周期数。例如，Go板的时钟周期为40纳秒，所以在这种情况下，我们将1000万除以40，得到250,000个时钟周期的延迟。这就是我们在顶层模块<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Debounce_Project_Top</samp>中使用的< samp
    class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT</samp>参数/通用项的值。如果你的开发板有不同的时钟周期，你需要相应地调整<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT</samp>。
- en: 'The code used to create our clock cycle counter ❶ differs between the Verilog
    and VHDL versions. In Verilog, we use a common trick: the <samp class="SANS_TheSansMonoCd_W5Regular_11">$clog2()</samp>
    built-in function (short for ceiling log base 2) determines the log[2] of the
    number of clock cycles we want to count, rounded up. This tells us the number
    of binary digits needed to implement the counter. Thanks to the <samp class="SANS_TheSansMonoCd_W5Regular_11">$clog2()</samp>
    function, we can dynamically size the <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp>
    register based on the input parameter, so if the input parameter changes (because
    your clock has a different period, or because you want to extend the wait time),
    the code will see this and synthesize <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp>
    to be as wide as it needs to be. This is better than hardcoding <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp>
    to some arbitrary limit, which could break when the code is reused.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建我们时钟周期计数器❶的代码在Verilog和VHDL版本之间有所不同。在Verilog中，我们使用一种常见的技巧：内建函数<samp class="SANS_TheSansMonoCd_W5Regular_11">$clog2()</samp>（表示向上取整的以2为底的对数）计算我们想要计数的时钟周期数量的对数[2]，并向上取整。这告诉我们实现计数器所需的二进制位数。得益于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">$clog2()</samp>函数，我们可以根据输入参数动态调整<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp>寄存器的大小，因此如果输入参数发生变化（因为你的时钟周期不同，或者因为你想要延长等待时间），代码将会自动适应并合成出合适大小的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp>。这比将<samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp>硬编码为某个任意限制要好得多，因为在代码重用时，硬编码可能会导致问题。
- en: With VHDL, we’re able to achieve the same dynamic sizing in a simpler way, using
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">range</samp> keyword. This not
    only will size the variable correctly, but has an added benefit of creating a
    warning in your simulation if the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp>
    ever goes beyond the integer range limit. The fact that the simulator can provide
    these types of warnings when running your testbench is another great reason for
    using simulations.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在VHDL中，我们能够以更简单的方式实现相同的动态大小调整，使用<samp class="SANS_TheSansMonoCd_W5Regular_11">range</samp>关键字。这不仅会正确地调整变量的大小，而且还会在模拟时产生警告，如果<samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp>的值超出了整数范围限制。模拟器能够在运行测试平台时提供这些类型的警告，这也是使用仿真的另一个重要原因。
- en: We implement the debounce filter using a series of <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements that are evaluated at each clock cycle. First we handle the case where
    the input is different from the output (meaning the input is changing) but <samp
    class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp> is less than <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT-1</samp>
    ❷. This means we haven’t yet waited the desired amount of time for the switch
    to stop bouncing, so we increment our clock cycle counter by 1\. In this <samp
    class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, we’re effectively
    waiting for some amount of time to pass to ensure the input is stable, before
    updating the output value.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过一系列在每个时钟周期评估的 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> 语句来实现去抖动滤波器。首先，我们处理输入与输出不同的情况（即输入发生变化），但
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_Count</samp> 小于 <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT-1</samp>
    ❷。这意味着我们还没有等待足够的时间，确保开关停止抖动，所以我们将时钟周期计数器加 1。在这个 <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    语句中，我们实际上是在等待一定的时间，以确保输入是稳定的，然后再更新输出值。
- en: Next we handle the case where the counter has reached its limit, so we know
    that we’ve waited the full 10 ms (or whatever length of time <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE
    _LIMIT</samp> corresponds to) ❸. At this point, we can register the current value
    of the input (<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Bouncy</samp>) to
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_State</samp>, whose value is in
    turn assigned to the output (<samp class="SANS_TheSansMonoCd_W5Regular_11">o_Debounced</samp>)
    ❺. We also reset the counter to 0 to prepare for the next event. Finally, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp> statement ❹ covers situations
    where the input and output have the same state. In this case, we reset the counter,
    since we have nothing to debounce here and we want our debounce filter to always
    be ready for the next event.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们处理计数器达到上限的情况，这样我们就知道我们已经等待了完整的 10 毫秒（或与 <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE
    _LIMIT</samp> 对应的时间长度）❸。此时，我们可以将输入的当前值（<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Bouncy</samp>）注册到
    <samp class="SANS_TheSansMonoCd_W5Regular_11">r_State</samp> 中，其值接着被赋给输出（<samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_Debounced</samp>）❺。我们还将计数器重置为 0，以便为下一个事件做准备。最后，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">else</samp> 语句 ❹ 处理输入和输出状态相同的情况。在这种情况下，我们重置计数器，因为没有需要去抖动的内容，并且我们希望我们的去抖动滤波器始终准备好处理下一个事件。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Testbench
    and Simulation</samp>
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建测试平台和仿真</samp>
- en: 'Now we’ll create a testbench to exercise our project and make sure it works
    as expected. Recall that the testbench is what will instantiate our unit under
    test and simulate its inputs, while monitoring its outputs. In this case, we want
    the testbench to simulate the unstable input from a bouncing switch so we can
    confirm that the debounce filter is delaying the output until the switch has settled
    into a stable state. Here’s the code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个测试平台来测试我们的项目，并确保它按预期工作。回想一下，测试平台将实例化我们需要测试的单元并模拟其输入，同时监控其输出。在这种情况下，我们希望测试平台模拟来自抖动开关的不稳定输入，以便确认去抖动滤波器在开关稳定后才会延迟输出。以下是代码：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Unlike our AND gate testbench, this testbench must provide a clock signal to
    the UUT, along with the other inputs. We create the clock signal with a simple
    trick ❶: we repeatedly invert a signal after a fixed amount of time to generate
    a 50 percent duty cycle signal that will toggle for the duration of the testbench
    execution. The signal inverts every 2 ns, for a clock period of 4 ns per cycle.
    This is much faster than the actual clock period on a typical FPGA development
    board, but for the purposes of this simulation, that’s okay.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的与门测试平台不同，这个测试平台必须向 UUT 提供一个时钟信号，以及其他输入。我们用一个简单的技巧来创建时钟信号❶：在固定的时间间隔后反转信号，以生成一个
    50% 占空比的信号，整个测试平台执行过程中信号会不断切换。该信号每 2 纳秒反转一次，每周期时钟周期为 4 纳秒。这个速度远远超过典型 FPGA 开发板的实际时钟周期，但对于此次模拟来说是可以的。
- en: 'When we instantiate the UUT ❷, we override <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT</samp>
    with the value <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>. This means
    our debounce filter will only look for four clock cycles of stability before it
    deems the output debounced. In a real FPGA, this would be a very short amount
    of time (less than 1 microsecond), probably not long enough to actually fix the
    problem. However, keep in mind the purpose of this testbench: we want to make
    sure that our FPGA logic works as intended. That logic is functionally the same
    whether we’re waiting 4 clock cycles or 250,000 clock cycles. Using the much smaller
    number will make for a quicker simulation and an easier-to-evaluate waveform,
    while still giving us realistic feedback about whether or not the design works.
    Shortening counters is a handy trick to remember for large designs: a simulation
    of such a design could take many minutes to run, but using smaller limits for
    counters will make the simulation run faster, allowing you to debug your code
    more quickly. Once your design is fully debugged and verified, you can update
    the simulation with your actual expected counter lengths to validate your actual
    design. This means you’ll only have to endure the longer simulation time once,
    after any issues with the code have already been resolved using the shortened
    simulation.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实例化UUT ❷时，我们将<samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT</samp>的值覆盖为<samp
    class="SANS_TheSansMonoCd_W5Regular_11">4</samp>。这意味着我们的去抖动滤波器在认为输出已去抖动之前，将仅检查四个时钟周期的稳定性。在真实的FPGA中，这段时间非常短（不到1微秒），可能不足以实际解决问题。然而，请记住这个测试平台的目的：我们希望确保FPGA逻辑按预期工作。无论我们等待4个时钟周期还是250,000个时钟周期，这些逻辑在功能上是相同的。使用较小的数字将使仿真更快速，且更容易评估波形，同时仍能提供关于设计是否有效的真实反馈。缩短计数器的值是处理大规模设计时的一个实用技巧：此类设计的仿真可能需要很多分钟才能完成，但使用较小的计数器限制将加速仿真，使你能够更快速地调试代码。一旦设计完全调试并验证完毕，你可以用实际的计数器长度更新仿真，以验证最终设计。这意味着，在任何代码问题通过缩短仿真时间解决后，你只需忍受一次较长的仿真时间。
- en: Next, we start to provide stimulus to the UUT ❸. With synchronous designs, we
    want to ensure that our input signals to the UUT are synchronous to the clock.
    We therefore set up the code to change the stimulus on the rising edge of the
    testbench clock. Otherwise, we might be introducing strange timing effects that
    would not exist in a real FPGA design. (Remember that all of the flip-flops in
    your UUT will be using the rising edge of the clock, so your testbench stimulus
    should also be reacting to the rising edge of the clock.)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始向UUT ❸提供刺激信号。在同步设计中，我们希望确保输入信号与时钟同步。因此，我们设置代码，在测试平台时钟的上升沿更改刺激信号。否则，我们可能会引入一些在真实FPGA设计中不存在的奇怪时序效应。（记住，UUT中的所有触发器都将使用时钟的上升沿，因此你的测试平台刺激信号也应当响应时钟的上升沿。）
- en: When the test starts, the input is low. After a short time, the input goes high
    for a single clock cycle ❹, then low again ❺, to simulate a bouncing-induced glitch.
    We want to make sure that the debounced output of this module doesn’t react to
    this glitch. Later in the test, we drive the input back high again and leave it
    there ❻. This time we want the output to match the input, but only after the debounce
    filter has counted out four clock cycles.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试开始时，输入为低电平。经过一段短时间后，输入变为高电平，持续一个时钟周期 ❹，然后再次变为低电平 ❺，以模拟因抖动引起的故障。我们希望确保该模块的去抖动输出不会对这个故障做出反应。在测试的后期，我们将输入再次拉高并保持高电平
    ❻。这时，我们希望输出与输入一致，但仅在去抖动滤波器完成四个时钟周期的计数后才会匹配。
- en: After running this testbench code in EDA Playground (or whichever simulator
    you prefer), you should get a waveform that looks something like that shown in
    [Figure 5-7](#fig5-7).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在EDA Playground（或任何你偏好的仿真器）中运行此测试平台代码后，你应该会得到一个类似于[图5-7](#fig5-7)所示的波形。
- en: '![](../images/Figure5-7.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure5-7.png)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 5-7: The debounce simulation
    waveform</samp>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图5-7：去抖动仿真波形</samp>
- en: The waveform shows that the output <samp class="SANS_TheSansMonoCd_W5Regular_11">o_Debounced</samp>
    stays low when <samp class="SANS_TheSansMonoCd_W5Regular_11">i_Bouncy</samp> goes
    high for only one clock cycle. Then, toward the end of the simulation, we see
    the output go high to match the input, but only after the input has been high
    for four clock cycles. The debounce filter works!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 波形显示，当<samp class="SANS_TheSansMonoCd_W5Regular_11">i_Bouncy</samp>仅在一个时钟周期内变高时，输出<samp
    class="SANS_TheSansMonoCd_W5Regular_11">o_Debounced</samp>保持低电平。然后，在模拟的后期，我们看到输出变为高电平，与输入匹配，但只有当输入保持高电平达到四个时钟周期后。去抖动滤波器工作正常！
- en: While the testbench we wrote is better than no test at all, it could certainly
    be improved. For example, we don’t check what happens when the input goes low
    again, to make sure the output responds correctly. Additionally, we might want
    to check that a higher <samp class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT</samp>
    value than <samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp> doesn’t cause
    any issues. Setting up multiple tests to stress the bulk of your design, and in
    particular any corner cases, is good test design practice.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们编写的测试平台比没有测试要好，但它肯定可以改进。例如，我们没有检查输入再次变低时的情况，以确保输出正确响应。此外，我们可能还需要检查更高的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">DEBOUNCE_LIMIT</samp>值（大于<samp class="SANS_TheSansMonoCd_W5Regular_11">4</samp>）是否会导致任何问题。设置多个测试用例来测试你设计的主要部分，尤其是任何极限情况，是良好的测试设计实践。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Building and Programming
    the FPGA</samp>
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">构建和编程FPGA</samp>
- en: 'Having simulated the design, we now have some confidence that if we were to
    go ahead and program the FPGA, it would likely work as intended. Let’s try it
    out! Create a new project inside iCEcube2, and add the following modules to the
    project: <samp class="SANS_TheSansMonoCd_W5Regular_11">Debounce_Filter</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Debounce_Project_Top</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">LED_Toggle_Project</samp>. Make
    sure that you’ve also included the clock constraints file, as well as the physical
    constraints file.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟设计后，我们现在有了一定的信心，如果继续编程FPGA，它很可能会按预期工作。让我们试试看！在iCEcube2中创建一个新项目，并将以下模块添加到项目中：<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Debounce_Filter</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Debounce_Project_Top</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">LED_Toggle_Project</samp>。确保你还包括了时钟约束文件以及物理约束文件。
- en: 'When everything’s ready, build the project. Then double-check for errors, and
    check your utilization reports. The synthesis report after building the FPGA will
    look something like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切准备就绪后，构建项目。然后再仔细检查是否有错误，并检查你的利用率报告。构建FPGA后的合成报告将类似于以下内容：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'From this report, we can see that we’re using more LUTs and flip-flops than
    we did for Project #3. This makes sense; the debounce filter accounts for these
    extra resources. Still, the FPGA has plenty of resources to spare.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从这份报告中，我们可以看到我们使用的LUT和触发器比第3号项目多。这是有道理的；去抖动滤波器需要这些额外的资源。尽管如此，FPGA仍然有充足的资源可供使用。
- en: Go ahead and program your FPGA, then try pushing the button to turn the LED
    on and off. You should notice that the LED is now toggling consistently with each
    press of the button. We’ve successfully filtered out the bounces from the switch.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编程你的FPGA，然后尝试按下按钮以开关LED。你应该会注意到，LED现在会随着每次按下按钮而稳定切换。我们已经成功地过滤掉了开关的抖动。
- en: 'As you’ve seen in this project, simulations are invaluable for building confidence
    in a design and debugging issues in your Verilog and VHDL. However, even in this
    relatively simple example, you may have noticed a drawback: examining waveforms
    to determine if a design is working can be tedious, especially if you have to
    keep changing the design and rerunning the simulation. It would be much more convenient
    if the testbench could simply tell you whether the simulation has worked, without
    you having to study the waveform. As we’ll explore next, it’s possible to write
    testbenches that offer exactly this capability.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在这个项目中所见，模拟对于建立设计信心和调试Verilog与VHDL中的问题是不可或缺的。然而，即使在这个相对简单的示例中，你可能也注意到一个缺点：查看波形以确定设计是否正常工作可能非常繁琐，尤其是当你需要不断修改设计并重新运行模拟时。如果测试平台能直接告诉你模拟是否成功，而无需你去分析波形，那将方便得多。正如我们接下来要探讨的，完全可以编写具备这种能力的测试平台。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Self-Checking Testbenches</samp>
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">自检测试平台</samp>
- en: A *self-checking testbench* is a testbench that you program to verify your UUT
    is working as intended, without having to manually inspect the output. The self-checking
    testbench will run a series of steps and let you know if any have failed, at which
    point you can inspect the failure and fix it. This saves you from having to visually
    examine the waveforms generated during simulation to determine whether your design
    has worked as expected. It takes a bit more effort to set up your testbench to
    be self-checking, but it’s almost always worth the time spent.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*自检测试平台*是一个你编程的测试平台，用来验证你的UUT是否按预期工作，而无需手动检查输出。自检测试平台将运行一系列步骤，并告知你是否有任何步骤失败，在这种情况下你可以检查故障并修复它。这可以避免你在仿真过程中需要视觉检查波形，以确定设计是否按预期工作。虽然设置自检测试平台需要更多的努力，但几乎总是值得花时间去做。
- en: When setting up a self-checking testbench, your goal is to inject many different
    test cases into your UUT, then monitor the outputs and check, or *assert*, that
    they are what you expect. *Assertions* are statements about what value a signal
    will have at a particular moment in the simulation, and they’re probably the most
    critical part of a self-checking testbench. Often, a self-checking testbench will
    have hundreds of assertions, with each one imparting a little more confidence
    that the design is correct.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 设置自检测试平台时，你的目标是向你的UUT注入许多不同的测试用例，然后监控输出并检查，或*断言*，它们是否符合你的预期。*断言*是在仿真过程中某一特定时刻信号值的声明，它们可能是自检测试平台中最关键的部分。通常，自检测试平台会包含数百个断言，每个断言都能为设计的正确性提供更多的信心。
- en: Self-checking testbenches are particularly useful if you’re adding a new feature
    to some old code. It might be something that you haven’t looked at in years, and
    suddenly you need to try to remember (or learn, if someone else wrote it) how
    it works. From experience, I can tell you that starting with a testbench that
    has many checks is a huge benefit. You’ll be able to open the simulation, see
    all of the assertions in the self-checking testbench, and make sure everything
    in the old code still works. Then you can add your new code and add new tests
    for it. Once all the old *and* new tests are passing, you can have high confidence
    that your new code is performing as expected—and equally importantly, that *you
    haven’t broken any old code*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 自检测试平台在你为旧代码添加新功能时特别有用。它可能是你几年没看过的东西，而突然间你需要尝试回忆（或者如果是别人写的，你需要学习）它是如何工作的。根据经验，我可以告诉你，开始时使用一个包含许多检查的测试平台是一个巨大的优势。你可以打开仿真，查看自检测试平台中的所有断言，并确保旧代码中的所有功能仍然有效。然后你可以添加新代码，并为其添加新的测试。一旦所有旧的*和*新的测试都通过，你就可以非常有信心地认为新代码按预期执行——同样重要的是，*你没有破坏任何旧代码*。
- en: 'To illustrate how self-checking testbenches work, let’s return to the simple
    testbench we wrote for our AND gate project earlier in the chapter. The following
    Verilog and VHDL code takes the original testbench we wrote and adds some assertion
    checks within it. These assertions will automatically run to verify that the actual
    output is in the expected state. The new code is shown in bold:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明自检测试平台是如何工作的，让我们回到本章前面我们为与门项目编写的简单测试平台。以下的Verilog和VHDL代码基于我们写的原始测试平台，并在其中添加了一些断言检查。这些断言将自动运行，以验证实际输出是否处于预期状态。新的代码以**粗体**显示：
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Verilog</samp>
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">VHDL</samp>
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this excerpt from the testbench, we’ve added two checks. We use the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> keyword ❶ to first confirm
    that the output is low when both inputs are low, then that it’s low when one input
    is low and the other is high. The <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>
    keyword only exists in SystemVerilog, not regular Verilog. This is an example
    of how SystemVerilog has improved features for testbenches. VHDL, meanwhile, has
    <samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp> built into it, and
    the severity can be <samp class="SANS_TheSansMonoCd_W5Regular_11">note</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">warning</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">failure</samp>,
    depending on the level of assertion that you want to check for. Each has a different
    escalation, so you can filter them out in your report. In this case, we’ve chosen
    <samp class="SANS_TheSansMonoCd_W5Regular_11">failure</samp>, since we definitely
    wouldn’t want an AND gate output high when the inputs are low.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段来自测试平台的摘录中，我们添加了两个检查。我们首先使用<samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>关键字
    ❶确认当两个输入都为低时，输出为低，然后确认当一个输入为低，另一个输入为高时，输出依然为低。<samp class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>关键字仅存在于SystemVerilog中，而在普通的Verilog中并没有。这个例子展示了SystemVerilog如何为测试平台提供了改进的功能。与此同时，VHDL中内建了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">assert</samp>，其严重性可以是<samp class="SANS_TheSansMonoCd_W5Regular_11">note</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">warning</samp>或<samp class="SANS_TheSansMonoCd_W5Regular_11">failure</samp>，具体取决于你希望检查的断言级别。每个级别有不同的升级方式，因此你可以在报告中进行过滤。在这种情况下，我们选择了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">failure</samp>，因为当输入为低时，我们肯定不希望AND门的输出为高。
- en: 'If this assertion evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>,
    then the simulation moves on. However, if something goes wrong and the assertion
    fails, you’ll see output printed to the screen. In Verilog, you’d see something
    like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个断言评估为<samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>，则仿真会继续进行。然而，如果发生了问题并且断言失败，你将看到屏幕上打印出的输出。在Verilog中，你会看到类似这样的内容：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In VHDL, here is what the failure message would look like:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在VHDL中，失败信息将如下所示：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is very helpful! Not only do we know that the testbench failed, but we
    know that it failed exactly 10 ns into the simulation, which allows us to immediately
    locate the failure in the waveform viewer. We also know the exact line of code
    that caused the failure: line 20 in Verilog or line 22 in VHDL. These pieces of
    information make it easier to investigate the problem, understand the cause, and
    fix it. I recommend adding assertions into your tests wherever possible.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有帮助！我们不仅知道测试平台失败了，而且知道它在仿真开始的第10ns时发生了失败，这使得我们可以立即在波形查看器中定位到失败位置。我们还知道导致失败的确切代码行：在Verilog中是第20行，VHDL中是第22行。这些信息使得我们更容易调查问题、理解原因并修复它。我建议在可能的情况下将断言添加到你的测试中。
- en: The self-checking testbench is an area where SystemVerilog really shines. Many
    of the added features beyond what regular Verilog offers are geared toward writing
    better testbenches. For example, SystemVerilog provides the ability for you to
    verify sequences of events. This can be handy for analyzing interactions between
    different signals, to make sure they happen correctly (that is, first one thing
    happens, then on the next clock cycle, another thing happens). SystemVerilog also
    provides classes, allowing you to use object-oriented programming techniques to
    streamline your testbench code. Other SystemVerilog features allow you to randomly
    inject data into your designs, making your tests much more comprehensive and robust.
    The details of these features are beyond the scope of this book, but as you start
    writing more testbenches—particularly self-checking testbenches—I encourage you
    to learn more about SystemVerilog.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 自检测试平台是SystemVerilog特别出色的一个方面。除了常规Verilog提供的功能，许多新增的特性都旨在编写更好的测试平台。例如，SystemVerilog提供了验证事件序列的功能。这对分析不同信号之间的交互非常有用，可以确保它们按正确顺序发生（也就是说，首先发生一件事，然后在下一个时钟周期发生另一件事）。SystemVerilog还提供了类，使你能够使用面向对象编程技术来简化测试平台代码。其他SystemVerilog功能允许你将数据随机注入到设计中，从而使测试变得更加全面和健壮。这些功能的详细内容超出了本书的范围，但当你开始编写更多的测试平台，特别是自检测试平台时，我鼓励你深入了解SystemVerilog。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Initial Signal Conditions</samp>
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">初始信号条件</samp>
- en: By default, if a signal isn’t assigned an initial condition, then it will show
    up in an unknown state when you start a simulation. This is often represented
    by a red signal and an X in the waveform viewer. The simulator is telling you
    that it doesn’t know how to treat the signal when the testbench is first running.
    Should it be a 0 or a 1? The simulator doesn’t know.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果信号没有赋予初始条件，那么在开始仿真时它将处于未知状态。通常，这会在波形查看器中通过红色信号和X标记表示。仿真器告诉你，在测试平台开始运行时，它不知道如何处理该信号。应该是0还是1？仿真器不知道。
- en: There are two methods for assigning a default state to your signals, so that
    they start in a known state. One method is to use resets. As we discussed back
    in [Chapter 4](chapter4.xhtml), a reset assigns an initial default value to a
    flip-flop. Driving the reset input at the start of a simulation will set the signals
    to known states to begin the test. This will work for all signals that are assigned
    a reset condition.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以将默认状态分配给信号，以便它们从已知状态开始。第一种方法是使用复位信号。正如我们在[第4章](chapter4.xhtml)中讨论的，复位信号为触发器分配一个初始默认值。在仿真开始时驱动复位输入将把信号设置为已知状态，从而开始测试。这适用于所有分配了复位条件的信号。
- en: 'The other way we can set signals to an initial state is to use the initialization
    feature in both Verilog and VHDL. This is particularly useful for simulation purposes.
    It’s as simple as assigning a signal to a value after it’s created. In Verilog,
    for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">reg r_State</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1''b0;</samp>
    initializes the <samp class="SANS_TheSansMonoCd_W5Regular_11">r_State</samp> signal
    to 0\. In VHDL, <samp class="SANS_TheSansMonoCd_W5Regular_11">signal r_State :
    std_logic :=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">''0'';</samp>
    does the same. You can use any state that the signal can validly be set to as
    an initialization value.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '另一种将信号设置为初始状态的方法是使用Verilog和VHDL中的初始化功能。这在仿真中尤其有用。它和为信号赋值一样简单。在Verilog中，例如，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">reg r_State</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">1''b0;</samp> 将< s <samp class="SANS_TheSansMonoCd_W5Regular_11">r_State</samp>信号初始化为0。在VHDL中，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">signal r_State : std_logic :=</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">''0'';</samp> 也可以达到相同效果。你可以使用信号可以合法设置的任何状态作为初始化值。'
- en: Initial signal assignments are only synthesizable for some FPGAs, since not
    all FPGAs can load an initial state into their flip-flops when they boot up after
    being programmed. Because this feature isn’t available for all FPGAs, I generally
    don’t recommend relying on it. A better, more portable solution is to use resets
    to set signals to some default value. Resets are widely supported across all FPGA
    manufacturers, so your code will be more portable if you need to change FPGAs.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 初始信号赋值仅在某些FPGA上可合成，因为并非所有FPGA在编程后启动时都能将初始状态加载到触发器中。由于并非所有FPGA都支持此功能，我通常不推荐依赖它。一种更好的、具有更好可移植性的解决方案是使用复位信号将信号设置为某个默认值。复位信号在所有FPGA制造商中广泛支持，因此如果你需要更换FPGA，代码会更加可移植。
- en: <samp class="SANS_Futura_Std_Bold_B_11">On-FPGA Debugging</samp>
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">FPGA上调试</samp>
- en: Early in this chapter, I told you that once you’re on hardware, you’re looking
    at a black box. You can see inputs and outputs, but you can’t see what’s going
    on internally. This isn’t entirely true. There *is* a way to do some limited on-FPGA
    debugging. However, this method has significant drawbacks and should only be used
    sparingly, if at all.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 本章早些时候，我告诉过你，一旦进入硬件，你就像是在看一个黑箱。你可以看到输入和输出，但看不清楚内部发生了什么。事实上，这并不完全正确。*确实*有一种方法可以进行有限的FPGA上调试。然而，这种方法有显著的缺点，应该仅在必要时使用。
- en: On-FPGA debugging is achieved by adding a *logic analyzer*, a tool that shows
    the state (high or low) of many digital signals at once, inside your FPGA. This
    allows you to monitor the FPGA’s internal signals in real time. By looking at
    these signals, you can debug issues and see where data isn’t behaving as expected.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在FPGA上调试是通过添加一个*逻辑分析仪*来实现的，逻辑分析仪是一种工具，能够同时显示多个数字信号的状态（高或低）。这可以让你实时监控FPGA的内部信号。通过查看这些信号，你可以调试问题，看到数据为何未按预期行为运行。
- en: 'Each of the major FPGA companies has a unique product within its suite of tools
    that creates a logic analyzer inside the FPGA. AMD has a feature called Integrated
    Logic Analyzer (ILA), Intel has Signal Tap, and Lattice has Reveal. They all work
    basically the same way: they take part of your FPGA’s resources and turn those
    resources into a logic analyzer. You run your FPGA code, the logic analyzer “sniffs”
    the data, and the results are presented on your computer screen so you can debug
    your design.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主要的 FPGA 公司在其工具套件中都有一个独特的产品，用于在 FPGA 内部创建逻辑分析仪。AMD 有一个叫做集成逻辑分析仪（ILA）的功能，Intel
    有 Signal Tap，Lattice 有 Reveal。它们的工作方式基本相同：它们将 FPGA 的一部分资源转化为逻辑分析仪。你运行 FPGA 代码，逻辑分析仪“嗅探”数据，然后将结果展示在你的计算机屏幕上，以便你调试设计。
- en: There are several problems with this process, however. The first issue is that
    it’s extremely time-consuming. If you want to add a logic analyzer to your FPGA,
    you need to rebuild and reprogram the entire design. You also need to decide ahead
    of time what signals you’re interested in monitoring with the logic analyzer,
    as you likely won’t have enough resources on your FPGA to look at everything.
    If you want to change what you’re looking at while the FPGA is running, too bad!
    You’ll have to rebuild the entire FPGA from scratch and start the process all
    over again. A simulation, on the other hand, can easily see the state of *all*
    the signals on your FPGA; you don’t have to pick and choose.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个过程存在几个问题。第一个问题是它非常耗时。如果你想在 FPGA 中添加逻辑分析仪，你需要重新构建并重新编程整个设计。你还需要提前决定你希望用逻辑分析仪监控哪些信号，因为你的
    FPGA 资源可能不足以查看所有内容。如果你想在 FPGA 正在运行时更改查看的内容，那就算了！你必须从头开始重新构建整个 FPGA，并重新开始整个过程。另一方面，模拟可以轻松地查看
    FPGA 上*所有*信号的状态；你不必挑选和选择。
- en: An additional problem with on-FPGA debugging is that adding a logic analyzer
    is basically throwaway effort. Once you find and fix your one problem, you don’t
    need the debug tool anymore. In fact, since it uses your FPGA’s resources (which
    are a limited commodity), you may not want to keep it in your design. You can
    save and rerun a simulation, but a logic analyzer is a one-and-done debugging
    effort.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: FPGA 上调试的另一个问题是，添加逻辑分析仪基本上是一次性的工作。一旦你找到并修复了一个问题，你就不再需要调试工具了。事实上，由于它使用 FPGA 的资源（而资源是有限的），你可能不希望将其保留在设计中。你可以保存并重新运行模拟，但逻辑分析仪是一次性调试工作。
- en: The final and perhaps worst problem is that when you add a logic analyzer to
    your FPGA, you’re changing the FPGA’s design, which can have unintended consequences.
    Issues that are subject to small timing variations might be fixed by the very
    act of adding the logic analyzer, or new issues might be created. If you’re trying
    to use the logic analyzer to debug a race condition inside your FPGA, for example,
    the design changes that result from adding in the logic analyzer might actually
    make the race condition go away. Scientists refer to this as the *observer effect*,
    where a phenomenon is changed by the act of investigating it.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个，可能也是最糟糕的问题是，当你在 FPGA 中添加逻辑分析仪时，你实际上是在改变 FPGA 的设计，这可能会带来意想不到的后果。那些可能受到小的时序变化影响的问题，可能会因为添加逻辑分析仪的动作而得到解决，或者可能会出现新的问题。例如，如果你正试图使用逻辑分析仪来调试
    FPGA 内部的竞态条件，添加逻辑分析仪所带来的设计变化可能会使竞态条件消失。科学家称之为*观察者效应*，即现象因调查行为而发生变化。
- en: This isn’t to say that these on-FPGA debuggers are entirely useless. They’re
    helpful when you’re trying to investigate a situation that’s difficult to simulate.
    For example, say some external interface to your FPGA is causing problems, but
    those problems are only occurring on your hardware while the simulation is working
    fine. At that point you might want to fire up a logic analyzer and try to see
    why your simulation is different from real life. Once you figure it out, you should
    strive to make your simulation as realistic as possible, adding to it the failure
    mode that you identified with the real-world test.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说这些在 FPGA 上的调试工具完全没有用。当你试图调查一个难以模拟的情况时，它们是有帮助的。例如，假设你的 FPGA 与某个外部接口存在问题，但这些问题只在硬件上出现，而模拟却正常。在这种情况下，你可能想启动一个逻辑分析仪，看看为什么你的模拟与现实不符。一旦弄明白了原因，你应该努力让模拟尽可能逼真，将通过真实世界测试识别到的故障模式加入其中。
- en: These tools have saved me a couple of times in my career, but in general I try
    to avoid them if possible.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具在我的职业生涯中救过我几次，但一般来说，我尽量避免使用它们。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Verification</samp>
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">验证</samp>
- en: '*Verification* is the process of ensuring that an FPGA or ASIC design is working
    as intended. It’s an exhaustive process that goes well beyond writing a few testbenches
    and running a simulation—so much so that there are people called verification
    engineers who perform verification full time. The complete details of how verification
    works are beyond the scope of this book. In fact, there are entire books dedicated
    to the subject. This section simply introduces the topic so you’re aware of the
    key role verification can play in real-world FPGA and ASIC design.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*验证*是确保FPGA或ASIC设计按预期工作的一种过程。这是一个全面的过程，远远超出仅仅编写几个测试平台和运行仿真的范围——以至于有些人专门从事验证工作，这些人被称为验证工程师。验证的具体细节超出了本书的范围。实际上，有整本书专门讲解这个主题。本节只是简要介绍这个话题，让你了解验证在现实世界中的FPGA和ASIC设计中可以发挥的重要作用。'
- en: Consider a device like a DVD player. What happens if a DVD is playing, then
    the user pauses playback, ejects the DVD, and presses the fast-forward button?
    Does the code handle that sequence of events correctly? Or does the unexpected
    fast-forward command lock up the processor in a strange state? The verification
    engineer must test all of these corner cases to ensure the design won’t make a
    mistake in handling some strange situation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 设想一个像DVD播放器这样的设备。如果DVD正在播放，然后用户暂停播放、弹出DVD，并按下快进按钮，会发生什么？代码是否正确处理了这一系列事件？或者，意外的快进指令是否让处理器陷入了一个奇怪的状态？验证工程师必须测试所有这些极端情况，确保设计不会在处理一些奇怪的情况时出错。
- en: Back in [Chapter 1](chapter1.xhtml), I mentioned that making an ASIC is an incredibly
    expensive and time-consuming process. Once the ASIC is fabricated at the foundry,
    you have to cut a big check. If there are critical bugs in the design and the
    ASIC doesn’t work as intended, then you’ve just lost all that money, and you’ll
    need to rerun the ASIC fabrication process again. It’s the job of a verification
    engineer to ensure the design is correct up front, since finding and fixing bugs
    later is incredibly expensive.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](chapter1.xhtml)中，我提到过制造ASIC是一个非常昂贵且耗时的过程。一旦ASIC在铸造厂完成制造，你就得付出一大笔费用。如果设计中有关键的错误，导致ASIC无法按预期工作，那么你就失去了所有的钱，而且还需要重新进行ASIC制造过程。验证工程师的工作就是确保设计在一开始就正确，因为事后发现并修复错误是非常昂贵的。
- en: Squashing bugs is great, but that’s only half the benefit. Another major goal
    of verification is to ensure the design is performing as intended. If you’re handed
    a specification of how an ASIC is supposed to perform, there might be ambiguities
    or missing information. Usually, one or more designers will design to the specification,
    and one or more separate verification engineers will simultaneously verify that
    the design is meeting the specification. If any discrepancies arise, the two teams
    can get together and update the specification so that everyone is clear on the
    intent.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 排除错误是很棒的，但这只是好处的一半。验证的另一个主要目标是确保设计按预期执行。如果你收到了一份关于ASIC性能的规格说明，可能会有一些模糊或缺失的信息。通常，一个或多个设计师会根据规格进行设计，而一个或多个独立的验证工程师会同时验证设计是否符合规格。如果出现任何不一致，两个团队可以聚在一起，更新规格，以便大家都能明确理解设计意图。
- en: Most verification engineers take advantage of the extra features built into
    SystemVerilog to thoroughly test a design. Self-checking testbenches are absolutely
    a must. It’s helpful to exercise the design randomly as well, so there are blocks
    of code that can inject random test cases into the design and ensure it’s working
    as intended.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数验证工程师会利用SystemVerilog内置的额外功能来彻底测试设计。自检查的测试平台是绝对必须的。随机测试设计也是非常有帮助的，因此有一些代码块可以将随机的测试用例注入到设计中，确保它按预期工作。
- en: Verifying code like this is no small feat. Often it’s more expensive and time-consuming
    to verify a design is working correctly than to create the design itself! For
    this reason, unlike with ASICs, not many FPGA designs go through a dedicated verification
    process. In most cases, it’s just too expensive. Remember that FPGA stands for
    *field programmable* gate array, so if a few bugs are allowed to slip through,
    the device can always be updated in the field, or in the hands of a customer.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的代码验证可不是小事。通常，验证设计是否正确工作比创建设计本身还要昂贵且耗时！因此，与ASIC不同，并不是所有FPGA设计都经过专门的验证过程。在大多数情况下，这实在是太昂贵了。记住，FPGA代表*现场可编程*门阵列，所以如果允许一些错误漏网，设备总是可以在现场或客户手中进行更新。
- en: Usually, only FPGA designs that demand very high reliability or simply cannot
    be updated in the field go through verification. For example, some FPGAs are *one-time
    programmable (OTP)*, meaning they can only be programmed once; afterward, the
    functionality is locked in and cannot be changed. Some applications in outer space
    utilize these OTP FPGAs, since they’re more resistant to radiation. Additionally,
    OTP FPGAs are considered less susceptible to reverse engineering, so they’re preferable
    for high-security applications. OTP FPGA designs often require verification; however,
    this isn’t the norm for typical FPGA designs.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，只有那些要求非常高可靠性或在现场无法更新的FPGA设计才会进行验证。例如，一些FPGA是*一次性可编程（OTP）*的，意味着它们只能编程一次；之后，功能被锁定且无法更改。一些外太空应用使用这些OTP
    FPGA，因为它们对辐射更具抵抗力。此外，OTP FPGA被认为不容易受到逆向工程的影响，因此它们更适用于高安全性的应用。OTP FPGA设计通常需要验证；然而，这对于典型的FPGA设计来说并不常见。
- en: For our purposes, testbenches are sufficient to find bugs in the FPGA design,
    but for ASICs or FPGAs that require it, verification is critically important.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，测试平台足以在FPGA设计中找到漏洞，但对于需要验证的ASIC或FPGA来说，验证至关重要。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: 'In this chapter, you’ve learned about simulating your FPGA code and seen how
    running simulations is time well spent. In contrast to debugging on hardware,
    simulation lets you visualize all the signals in your design, observe how they
    interact, and create stimuli to stress your code and see how it responds. You
    practiced writing testbenches, or code that instantiates your UUT, injects it
    with sample input, and monitors the output. You saw how looking at the waveforms
    generated during simulation is a great way to see if your design is working, but
    better still is adding tests that make your testbench self-checking. Less debugging
    on hardware, more beautiful simulations: that’s what makes a happy FPGA designer.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你了解了如何模拟你的FPGA代码，并看到运行模拟是非常值得的。与硬件调试相比，模拟让你能够可视化设计中的所有信号，观察它们如何相互作用，并创建刺激来测试你的代码并查看其响应。你练习了编写测试平台的代码，或者是实例化UUT、注入样本输入并监控输出的代码。你看到了通过观察模拟过程中生成的波形是一种很好的方法来检查设计是否正常工作，但更好的是添加自检测试，使你的测试平台能够自我验证。减少硬件调试，增加漂亮的模拟：这就是让FPGA设计师快乐的原因。
