["```\nmul   X`d`, X`s`1, X`s`2       // X`d` = X`s`1 * X`s`2\nmadd  X`d`, X`s`1, X`s`2, X`s`3  // X`d` = X`s`1 * X`s`2 + X`s`3\n```", "```\nmul   W`d`, W`s`1, W`s`2       // W`d` = W`s`1 * W`s`2\nmadd  W`d`, W`s`1, W`s`2, W`s`3  // W`d` = W`s`1 * W`s`2 + W`s`3\n```", "```\nmsub  W`d`, W`s`1, W`s`2, W`s`3   // W`d` = W`s`1 * W`s`2 - W`s`3\nmsub  X`d`, X`s`1, X`s`2, X`s`3   // X`d` = X`s`1 * X`s`2 + X`s`3\nmneg  W`d`, W`s`1, W`s`2        // W`d` = -(W`s`1 * W`s`2)\nmneg  X`d`, X`s`1, X`s`2        // X`d` = -(X`s`1 * X`s`2)\n```", "```\nsdiv  X`d`, X`s`1, X`s`2  // X`d` = X`s`1 / X`s`2 (signed division)\nudiv  X`d`, X`s`1, X`s`2  // X`d` = X`s`1 / X`s`2 (unsigned division)\n```", "```\nmod(x0, x1) = x0 - (x0 / x1) * x1\n```", "```\nudiv x2, x0, x1\nmsub x3, x2, x1, x0\n```", "```\nx2 = x0 / x1\nx3 = x0 % x1  // % is C modulo (remainder) operator.\n```", "```\ncmp w0, w1\n```", "```\ncmp `Left`, `Right`\n```", "```\nadd wzr, W`s`1, W`s`2\nadd xzr, X`s`1, X`s`2\n```", "```\ncsel W`d`, W`s`1, W`s`2, `cond`  // if(`cond`) then W`d` = W`s`1 else W`d` = W`s`2 \ncsel X`d`, X`s`1, X`s`2, `cond`  // if(`cond`) then X`d` = X`s`1 else X`d` = X`s`2 \n```", "```\ncs, cc, eq, ne, mi, pl, vs, vc, hs, hi, ls, lo, gt, ge, lt, le \n```", "```\nnhs, nhi, nls, nlo, ngt, nge, nlt, nle \n```", "```\ncsel x0, x1, x2, eq \n```", "```\ncsinc W`d`, W`s`1, W`s`2, `cond`  // if(`cond`) then W`d` = W`s`1 else W`d` = W`s`2 + 1 \ncsinc X`d`, X`s`1, X`s`2, `cond`  // if(`cond`) then X`d` = X`s`1 else X`d` = X`s`2 + 1 \n```", "```\ncinc W`d`, W`s1`, `cond`  // csinc  W`d`, W`s`1, W`s`1, invert(`cond`) \ncinc X`d`, X`s`1, `cond`  // csinc  X`d`, X`s`1, X`s`1, invert(`cond`) \n```", "```\ncsinv W`d`, W`s`1, W`s`2, `cond`  // if(`cond)` then W`d` = W`s`1  else W`d` = not W`s`2 \ncsinv X`d`, X`s`1, X`s`2, `cond`  // if(`cond)` then X`d` = X`s`1 else X`d` = not X`s`2 \ncsneg W`d`, W`s`1, W`s`2, `cond`  // if(`cond)` then W`d` = W`s`1 else W`d` = -W`s`2 \ncsneg X`d`, X`s`1, X`s`2, `cond`  // if(`cond)` then X`d` = X`s`1 else X`d` = -X`s`2 \n```", "```\ncset  Wd, `cond`  // if(`cond`) then W`d` = 1 else W`d` = 0 \ncset  X`d`, `cond`  // if(`cond`) then X`d` = 1 else X`d` = 0 \ncsetm W`d`, `cond`  // if(`cond`) then W`d` = -1 else W`d` = 0 \ncsetm X`d`, `cond`  // if(`cond`) then X`d` = -1 else X`d` = 0 \n```", "```\nccmp  W`d`, W`s`, #`nzcv4`, `cond` \nccmp  X`d`, X`s`, #`nzcv4`, `cond` \nccmp  W`d`, #imm5, #`nzcv4`, `cond` \nccmp  X`d`, #imm5, #`nzcv4`, `cond` \nccmn  W`d`, W`s`, #`nzcv4`, `cond` \nccmn  X`d`, X`s`, #`nzcv4`, `cond` \nccmn  W`d`, #imm5, #`nzcv4`, `cond` \nccmp  X`d`, #imm5, #`nzcv4`, `cond` \n```", "```\nx = y * z;\n\n// Conversion to ARM assembly if x, y, and z are 32-bit\n// memory variables in the .data section:\n\nlea  x0, y     // Remember, lea expands to two instructions.\nldr  w0, [x0]\nlea  x1, z\nldr  w1, [x1]\nmul  w0, w0, w1\nlea  x1, x\nstr  w0, [x1]\n```", "```\nmul x19, x20, x21\n```", "```\nlea x0, globalVariable // Remember, this is two instructions.\nldr w0, [x0]\n```", "```\nldr w0, [fp, #localVariable]\n```", "```\nldr w0, globalVariable\n```", "```\n#define SB X28\n```", "```\n// Listing6-1.S\n//\n// Demonstrate using X28 as a \"static base\"\n// register to conveniently access global\n// variables.\n\n        #include    \"aoaa.inc\"\n\n#define sb X28          // Use X28 for SB register.\n\n// Declaration of global variables:\n\n        struct  globals_t\n        word    g1\n        dword   g2\n        hword   g3\n        byte    g4,128\n        ends    globals_t\n\n        .data\n\n        globals_t globals       // Global variables go here.\n\n        .text\n        .pool\nttlStr: wastr  \"Listing 6-1\"\n\n        proc    getTitle, public\n        lea     x0, ttlStr\n        ret\n        endp    getTitle\n\n        proc    asmMain, public\n\n        locals  am\n        dword   saveSB             // Save X28 here.\n        byte    stackSpace, 64     // Generic stack space\n        endl    am\n\n        enter   am.size            // Reserve space for locals.\n        str     sb, [fp, #saveSB]  // Preserve SB register.\n        lea     sb, globals        // Initialize with address.\n\n        mov     w0, #55            // Just demonstrate the\n        str     w0, [sb, #g1]      // use of the static\n        add     x0, x0, #44        // base record in the\n        str     x0, [sb, #g2]      // .data section.\n and     w0, w0, #0xff\n        strh    w0, [sb, #g3]\n\n        ldr     sb, [fp, #saveSB]  // Restore SB register.\n        leave                      // Return to caller.\n        endp    asmMain\n```", "```\nstruct  globals_t, -256\nword    g1\ndword   g2\nhword   g3\nbyte    g4,128\nends    globals_t\n```", "```\nlea sb, globals+256  // Initialize with address.\n```", "```\nx = y * z;\n```", "```\nldr w0, [fp, #y]\nldr w1, [fp, #z]\nmul w0, w0, w1\nstr w0, [fp, #x]\n\n// If you can keep x, y, and z in registers:\n\nmul x0, x1, x2  // Assume x = X0, y = X1, and z = X2.\n```", "```\n`variable` = `constant`\n```", "```\n`var1` = `var2`\n```", "```\nmov `variable`, #`constant`  // Assumption: constant fits in 16 bits.\nmov `var1`, `var2`\n```", "```\nldr `register`, =`constant`\n```", "```\nldr `register`, [fp, #`offset`]  // Assuming a local variable\nldr `register`, [sb, #`offset`]  // Assuming variable is in static record\n\nlea `reg`64, `GlobalVariable`     // Global variable in arbitrary memory\nldr `register`, [`reg`64]\n```", "```\nstr `register`, [fp, #`offset`]\nstr `register`, [sb, #`offset`]\n\nlea `reg`64, `GlobalVariable`\nstr `register`, [`reg`64]\n```", "```\n`var1` = `term1 op term2`;\n```", "```\n`op`  `var1`, `term1`, `term2`\n```", "```\n`var1` = `const1` op `const2`;\n```", "```\n`var1` = 5 + 3;\n```", "```\nmov `var1`, #5 + 3\n```", "```\n`op`  `var1`, `term1`, #`constant`\n```", "```\n`mov someReg`, #`constant`\n`op`  `var1`, `term1`, `someReg`\n```", "```\nx0 = 25 + x1;\n```", "```\nadd x0, x1, #25\n```", "```\nx = y + z;  // x, y, and z are all 32-bit memory variables.\n```", "```\nldr w0, [fp, #y]   // Assuming y is a local variable\nldr w1, [sb, #z]   // Assuming z is in the static base record\nadd w2, w0, w1\nlea x3, globalVar  // Assuming globalVar is a global variable\nstr w2, [x3]       // in the .data section\n```", "```\n// x = y + z;  // Signed or unsigned\n\n          add w0, w1, w2\n\n// x = y - z;  // Signed or unsigned\n\n          sub w0, w1, w2\n\n// x = y * z;  // Signed or unsigned\n\n          mul w0, w1, w2\n\n// x = y / z;  // Unsigned div\n\n          udiv w0, w1, w2\n\n// x = y / z;  // Signed div\n\n          sdiv w0, w1, w2\n\n// x = y % z;  // Unsigned remainder\n\n          udiv  x0, x1, x2\n          msub  x0, x0, x2, x1\n\n// x = y % z;  // Signed remainder\n\n          sdiv  x0, x1, x2\n          msub  x0, x0, x2, x1\n```", "```\nw = w - y - z;\n```", "```\nsub w0, w0, w1\nsub w0, w0, w2\n```", "```\nsub w3, w1, w2\nsub w0, w0, w3\n```", "```\nx = w * y + z;\n```", "```\nx = (w * y) + z;\n```", "```\nx = w * (y + z);\n```", "```\nx `op1` y `op2` z\n```", "```\n// w = x + y * z;  // Assume w = W0, x = W1, y = W2, and z = W3.\n\nmul w4, w2, w3  // W4 = W2 * W3\nadd w0, w1, w4  // W0 = W1 + (W2 * W3)\n```", "```\n2**2**3\n```", "```\n2**(2**3)\n```", "```\n(2**2)**3\n```", "```\n// w = x - y - z  // Assume w = W0, x = W1, y = W2, and z = W3.\n\nsub  w0, w1, w2  // Evaluate from left to right.\nsub  w0, w0, w3  // W0 = (x - y) - z\n\n// w = x + y * z\n\nmul  w0, w2, w3  // Must compute y * z first.\nadd  w0, w0, w1  // W0 = (W2 * W3) + W1  (commutative)\n```", "```\nmadd w0, w2, w3, w1  // W0 = (W2 * W3) + W1\n\n// w = x / y - z\n\nsdiv w0, w1, w2  // Division has highest precedence.\nsub  w0, w0, w3  // W0 = (W1 / W2) - W3\n\n// w = x * y * z\n\nmul  w0, w1, w2  // Commutative, so order doesn't matter.\nmul  w0, w0, w3\n```", "```\nw = x / y * z;  // Note: this is (x / y) * z, not x / (y * z).\n```", "```\nw = x / y * z;  // Assume w = W0, x = W1, y = W2, and z = W3.\n```", "```\nmul  w0, w1, w3   // w = x * z\nsdiv w0, w0, w2   // w = (x * z) / y\n```", "```\nw = x - y * z;  // Assume w = W0, x = W1, y = W2, and z = W3.\n```", "```\nmul  w4, w2, w3  // temp = y * z\nsub  w0, w1, w4  // w = x - (y * z)\n```", "```\nw = (a + bb) * (y + z);\n```", "```\ntemp1 = a + bb;\ntemp2 = y + z;\nw = temp1 * temp2;\n```", "```\n// Assume w = W0, y = W1, z = W2, a = W3, and bb = W4.\n\nadd  w5, w3, w4  // temp1 (W5) = a + bb\nadd  w6, w1, w2  // temp2 (W6) = y + z\nmul  w0, w5, w6  // w = temp1 * temp2\n```", "```\nx = (y + z) * (a - bb) / 10;\n```", "```\ntemp1 = (y + z)\ntemp2 = (a - bb)\ntemp1 = temp1 * temp2\nx = temp1 / 10\n```", "```\n// Assume x = W0, y = W1, z = W2, a = W3, and bb = W4.\n\nadd  w5, w1, w2  // temp1 (W5) = y + z\nsub  w6, w3, w4  // temp2 (W6) = a - bb\nmul  w5, w5, w6  // temp1 = temp1 * temp2\nmov  w6, #10     // Need a temp to hold constant 10.\nsdiv w0, w5, w6  // x = temp1 / 10\n```", "```\n(A `op` B) = (B `op` A)\n```", "```\nbb = ((x == y) && (a <= c)) || ((z - a) != 5);\n```", "```\n// d = a AND bb;  // Assume d = W0, a = W1, and bb = W2.\n\nand w0, w1, w2\n\n// d = a || bb;\n\norr w0, w1, w2\n\n// d = a XOR bb;\n\neor w0, w1, w2\n\n// bb = NOT a;\n//\n// (NOT 0) does not equal 1.\n// The AND instruction corrects this problem.\n\nmvn w2, w1\nand w2, w2, #1\n\n// Here's an alternative solution (for NOT) using EOR:\n\neor w2, w1, #1  // Inverts bit 0\n```", "```\nbb = ((x == y) and (a <= d)) || ((z - a) != 5);\n```", "```\n// Assume bb = W0, x = W1, y = W2, a = W3, d = W4, and z = W5.\n\ncmp  w1, w2\ncset w6, eq      // temp1 (W6) = x == y\n\ncmp  w3, w4\ncset w7, le      // temp2 (W7) = a <= d\nand  w6, w6, w7  // temp1 = (x == y) && (a <= d)\n\nsub  w7, w5, w3  // temp2 = z - a\ncmp  w7, #5\ncset w7, ne      // temp2 = (z - a) != 5\n\norr  w0, w6, w7  // W0 = temp1 || temp2\n```", "```\nbb = (x == y) && (a <= d)\n```", "```\n// Assume bb = W0, x = W1, y = W2, a = W3, and d = W4.\n\ncmp  w1, w2\ncset w5, eq   // temp1 (W5) = x == y\n\ncmp  w3, w4\ncset w6, le   // temp2 (W6) = a <= d\nand  w0, w5, w6   // bb = (x == y) && (a <= d)\n```", "```\ncmp  w1, w2\nccmp w3, w4, #0, eq\ncset w0, le\n```", "```\n(a cc1 bb) && (c cc2 d)\n```", "```\nccmp c, d, #nzcvop, cc1\n```", "```\ncset x0, cc2\n```", "```\nbb = (x == y) || (a <= d)\n```", "```\ncmp  w1, w2\nccmp w3, w4, #0b0100, ne  // 0b0100 is .Z.. or use #cceq\ncset w0, le               // or #ccle\n```", "```\n(a cc1 bb) || (c cc2 d)\n```", "```\nccmp c, d, #nzcv, opposite(cc1)\n```", "```\ncset x0, cc2\n```", "```\nlsl w0, w0, #1          // W0 = W0 * 2\nadd w0, w0, w0, lsl #2  // W0 = (W0 * 2) + (W0 * 8)\n```", "```\nsub w0, w0, w0, lsl #3  // Actually computes W0 * (-7)\nneg w0, w0              // Fix sign.\n```", "```\nlsl w0, w0, #3\nsub w0, w0, #1\n```", "```\nlsl w0, w0, #3\nadd w1, w1, w0\n```", "```\nadd w1, w1, w0, lsl #3\n```", "```\nmov w1, #6554\nmul w0, w0, w1\nlsr w0, w0, #16  // Division by 65,536\n```", "```\nadd w0, w0, #1\nand w0, w0, #`nBits`\n```", "```\nadd w0, w0, #1\nand w0, w0, #0b1111\n```", "```\nif `Value1` >= (`Value2` - `error`) and `Value1` <= (`Value2` + `error`) then ...\n```", "```\nif abs(`Value1` - `Value2`) <= `error` then ...\n```", "```\nmrs  X`n`, FPCR  // Copies FPCR to X`n`\nmsr  FPCR, X`n`  // Copies X`n` to FPCR\n```", "```\nmrs  x0,   fpcr\nmov  x1,   #0xffff          // Load 0xf836ffff into X1, which is\nmovk x1,   #0xf836, lsl #16 // not a valid logical instr immediate value.\nand  x0,   x0, x1           // Must put it in a register.\nmsr  fpcr, x0\n```", "```\nmrs  x0, fpcr\norr  x0, x0, #0x00c00000 // Is valid logical instr immediate value\nmsr  fpcr, x0\n```", "```\nmrs  x0, FPSR\nand  x0, x0, #-2  // Clear IOC bit (-2 is 0xFFFF...FE).\nmsr  FPSR, x0\n```", "```\nldr q0, [x0]  // Loads 128 bits from memory\nldr d0, [x0]  // Loads 64 bits from memory\nldr s0, [x0]  // Loads 32 bits from memory\nldr b0, [x0]  // Loads 8 bits from memory\n```", "```\nldp q0, q1, [x0]  // Loads 256 bits from memory\nldp d0, d1, [x0]  // Loads 128 bits from memory\nldp s0, s1, [x0]  // Loads 64 bits from memory\n```", "```\nfmov S`d`, S`n`  // Move data between two 32-bit FP registers.\nfmov D`d`, D`n`  // Move data between two 64-bit FP registers.\nfmov S`d`, W`n`  // Move data from a 32-bit GP to an FP register.\nfmov W`d`,  S`n`  // Move data from a 32-bit FP to a GP register.\nfmov D`d`, X`n`  // Move data from a 64-bit GP to an FP register.\nfmov X`d`,  D`n`  // Move data from a 64-bit FP to a GP register.\n```", "```\nfmov S`d`, #`fimm`\nfmov D`d`, #`fimm`\n```", "```\nfmov S`d`, wzr\nfmov D`d`, xzr\n```", "```\nldr d0, =10.0   // Generates an error\n```", "```\n .code\n        .pool\nfp10:   .double 10.0\n         .\n         .\n         .\n        ldr     d0, fp10\n```", "```\nfcmp   F`d`, F`s` \nfcmpe  F`d`, F`s` \nfcmp   F`d`, #0.0 \nfcmpe  F`d`, #0.0 \n\nfccmp  F`d`, F`s`, #`nzcv`, `cond` \nfccmpe F`d`, F`s`, #`nzcv`, `cond` \n```", "```\n// Listing6-2.S \n//\n// Demonstrate comparing two floating-point \n// values for equality by using a difference \n// and error range comparison. \n\n        #include    \"aoaa.inc\"\n\n// The following bit mask will keep the \n// exponent bits in a 64-bit double-precision \n// floating-point value. It zeros out the \n// remaining sign and mantissa bits. \n\n❶ maskFP  =       0x7FF0000000000000 \n\n// bits is the number of bits you want to \n// mask out at the bottom of the mantissa. \n// It must be greater than 0: \n\n❷ bits    =       4 \nbitMask =       (1 << bits)-1 \n\n// expPosn is the position of the first \n// exponent bit in the double-precision \n// format: \n\nexpPosn =       52 \n\n        .text \n        .pool \nttlStr: wastr   \"Listing 6-2\"\nfmtStr: wastr   \"error for (%24.16e) = %e\\n\"\ndifMsg: wastr   \"Difference:%e\\n\"\nvalues: wastr   \"Value1=%23.16e, Value2=%23.16e\\n\"\neqMsg:  wastr   \"Value1 == Value2\\n\"\nneMsg:  wastr   \"Value1 != Value2\\n\"\n\n// When value2 is somewhere between \n// 8e-323 and 9e-323, the \n// comparison becomes not equal: \n\nvalue1: .double 1.0e-323 \nvalue2: .double 9e-323 \n\n// Generic values to compare: \n\n// value1: .double   1.2345678901234567 \n// value2: .double   1.234567890123456 \n\n// getTitle \n//\n// Return pointer to program title \n// to the C++ code: \n\n        proc    getTitle, public \n        lea     x0, ttlStr \n        ret \n        endp    getTitle \n\n// computeError \n//\n// Given a double-precision floating-point \n// value in D0, this function computes an \n// error range value for use in comparisons. \n// If the difference between two FP values \n// (one of which is the value passed in D0) \n// is less than the error range value, you \n// can consider the two values equal. \n\n      ❸ proc    computeError \n\n        // Preserve all registers this code \n        // modifies: \n\n        locals  ce \n qword   ce.saveX01 \n        byte    stack, 64 \n        endl    ce \n\n        enter   ce.size \n        stp     x0, x1, [fp, #ce.saveX01] \n\n        // Move the FP number into X0 so you can mask \n        // bits: \n\n        fmov    x0, d0 \n\n        // Generate mask to extract exponent: \n\n      ❹ and     x0, x0, #maskFP     // Extract exponent bits. \n        lsr     x1, x0, #expPosn    // Put exponent in bits 0-10\\. \n\n        // We need to normalize the value, \n        // if possible: \n\n      ❺ cmp     x1, #(expPosn - bits - 1) \n        blo     willBeDenormal \n\n        // If the result won't be a subnormal \n        // (denormalized value), then set \n        // the mantissa bits to all 0s \n        // (plus the implied 1 bit) and \n        // decrement the exponent to move \n        // the \"bits\" position up to the \n        // implied bit: \n\n      ❻ sub     x1, x1, #expPosn-bits // Adjust exponent. \n        lsl     x0, x1, #expPosn      // Put exponent back. \n        b.al    allDone \n\n// If the result will be denormalized, handle that \n// situation down here: \n\n❼ willBeDenormal: \n        mov     x0, #bitMask \n        lsl     x0, x0, x1  // Shift as much as you can. \n\nallDone: \n        fmov    d0, x0      // Return in D0\\. \n        ldp     x0, x1, [fp, #ce.saveX01] \n        leave \n        endp    computeError \n\n///////////////////////////////////////////////////////// \n//\n// Here's the asmMain procedure: \n\n        proc    asmMain, public \n\n        locals  am \n        double  am.error \n double  am.diff \n        byte    am.stackSpace, 64 \n        endl    am \n\n        enter   am.size \n\n// Display the values you're going to compare: \n\n        ldr     d0, value1 \n        str     d0, [sp] \n        ldr     d1, value2 \n        str     d1, [sp, #8] \n        lea     x0, values \n        bl      printf \n\n// Compute the error value: \n\n        ldr     d0, value1 \n        bl      computeError \n        str     d0, [fp, #am.error] \n\n// Print the error value: \n\n        str     d0, [sp, #8] \n        ldr     d1, value1 \n        str     d1, [sp] \n        lea     x0, fmtStr \n        bl      printf \n\n// Compute the difference of the \n// two values you're going to compare \n// and print that difference: \n\n        ldr     d0, value1 \n        ldr     d1, value2 \n        fsub    d0, d0, d1 \n        str     d0, [fp, #am.diff] \n        str     d0, [sp] \n        lea     x0, difMsg \n        bl      printf \n\n// Compare the difference of the two \n// numbers against the error range. \n\n        ldr     d1, [fp, #am.error] \n        ldr     d0, [fp, #am.diff] \n        fabs    d0, d0              // Must be abs(diff)! \n        fcmp    d0, d1 \n        ble     isEqual \n\n// Print whether you should \n// treat these values as equal: \n\n        lea     x0, neMsg \n        b.al    printIt \n\nisEqual: \n        lea     x0, eqMsg \nprintIt: \n        bl      printf \n\n        leave                       // Return to caller. \n        endp    asmMain \n```", "```\n$ ./build Listing6-2 \n$ ./Listing6-2 \nCalling Listing6-2: \nValue1 = 9.8813129168249309e-324, Value2 = 8.8931816251424378e-323 \nerror for (7.4109846876186982e-323) = 9.881313e-324 \nDifference:-7.905050e-323 \nValue1 != Value2 \nListing6-2 terminated \n```", "```\nfcsel F`d`, F`t`, F`f`, `cond`\n```", "```\nfcvt H`d`, S`s`\nfcvt H`d`, D`s`\nfcvt S`d`, H`s`\nfcvt S`d`, D`s`\nfcvt D`d`, H`s`\nfcvt D`d`, S`s`\n```", "```\nfcvt s0, d1\nmrs  x0, FPSR\nmov  w1, #0x8c\nands w0, w0, w1  // UFC, OFC, and IDC bits\nbne  badCvt\n```", "```\nfcvt{`m`}{s|u} R`d`, F`n`\n```", "```\nscvtf F`d`, R`d`  // Same register meanings as for fcv*\nucvtf F`d`, R`d`  // instructions\n```", "```\nfcvtzs R`d`, F`s`, #`bits`\nfcvtzu R`d`, F`s`, #`bits`\nscvtf  F`d`, R`s`, #`bits`\nucvtf  F`d`, F`s`, #`bits`\n```", "```\nfrint{`m`} F`d`, F`s`  // Both registers must be S`n` or D`n`.\n```", "```\nvoid p\n(\n    int i,\n    double d,\n    int j,\n    int k,\n    double e,\n    int l,\n    double f,\n    double g,\n    double h\n);\n```", "```\n// Listing6-3.S\n//\n// Demonstrates calling various C stdlib\n// math functions\n\n#include    \"aoaa.inc\"\n\n        .text\n        .extern sin  // C stdlib functions\n        .extern cos  // this program calls\n        .extern tan\n\n        .pool\nttlStr: wastr   \"Listing 6-3\"\n\n// Format strings for each of the outputs:\n\npiStr:  wastr   \"%s(pi) = %20.14e\\n\"\npi2Str: wastr   \"%s(pi/2) = %20.14e\\n\"\npi4Str: wastr   \"%s(pi/4) = %20.14e\\n\"\npi8Str: wastr   \"%s(pi/8) = %20.14e\\n\\n\"\n\n// Function names (printed as %s argument\n// in the format strings):\n\nsinStr: wastr   \"sin\"\ncosStr: wastr   \"cos\"\ntanStr: wastr   \"tan\"\n\n// Sample values to print for each\n// of the functions:\n\npi:     .double 3.141592653588979\npi2:    .double 1.5707963267949\npi4:    .double 0.7853981639745\npi8:    .double 0.39269908169872\n\n// getTitle\n//\n// Return pointer to program title\n// to the C++ code.\n\n        proc    getTitle, public\n        lea     x0, ttlStr\n        ret\n        endp    getTitle\n\n// Trampolines to the C stdlib math functions.\n// These are necessary because lea can't take\n// the address of a function that could be\n// very far away (as the dynamic libraries\n// probably are).\n//\n// Note: Must use real \"b\" instruction here\n// rather than \"b.al\" because external\n// functions are likely out of range.\n\n      ❶ proc    sinVeneer\n        b       sin\n        endp    sinVeneer\n\n        proc    cosVeneer\n        b       cos\n        endp    cosVeneer\n\n        proc    tanVeneer\n        b       tan\n        endp    tanVeneer\n\n// doPi(char *X0, func X1)\n//\n// X0-  Contains the address of a function\n//      that accepts a single double and\n//      returns a double result.\n// X1-  Contains the address of a string\n//      specifying the function name.\n//\n// This function calls the specified function\n// passing PI divided by 1, 2, 4, and 8 and\n// then prints the result that comes back.\n\n      ❷ proc    doPi\n\n        locals  dp\n        dword   dp.saveX1\n        dword   dp.saveX0\n        dword   dp.saveX19\n        byte    dp.stackSpace, 64\n        endl    dp\n\n        // Set up activation record and save register values:\n\n        enter   dp.size\n        stp     x0, x1, [fp, #dp.saveX0]  // X1 -> saveX1, too\n        str     x19, [fp, #dp.saveX19]    // Preserve nonvolatile.\n\n        mov     x19, x0                   // Keep address in nonvolatile.\n\n        // Call the function for various values\n        // of pi/n:\n\n      ❸ ldr     d0, pi\n        blr     x19           // Call function.\n        mstr    d0, [sp, #8]  // Save func result as parm.\n        ldr     x1, [fp, #dp.saveX1]\n        mstr    x1, [sp]\n        lea     x0, piStr\n        bl      printf\n\n        ldr     d0, pi2\n        blr     x19             // Call function.\n        mstr    d0, [sp, #8]\n        lea     x0, piStr\n        ldr     x1, [fp, #dp.saveX1]\n        mstr    x1, [sp]\n        lea     x0, pi2Str\n        bl      printf\n\n        ldr     d0, pi4\n        blr     x19             // Call function.\n        mstr    d0, [sp, #8]\n        lea     x0, piStr\n        ldr     x1, [fp, #dp.saveX1]\n        mstr    x1, [sp]\n        lea     x0, pi4Str\n        bl      printf\n\n        ldr     d0, pi8\n        blr     x19             // Call function.\n        mstr    d0, [sp, #8]\n        lea     x0, piStr\n        ldr     x1, [fp, #dp.saveX1]\n mstr    x1, [sp]\n        lea     x0, pi8Str\n        bl      printf\n\n        // Restore nonvolatile register\n        // and return:\n\n        ldr     x19, [fp, #dp.saveX19]\n        leave\n        endp    doPi\n\n/////////////////////////////////////////////////////////\n//\n// Here's the asmMain procedure:\n\n        proc    asmMain, public\n        enter   64              // Generic entry\n\n        // Load X0 with the address\n        // of the veneer (trampoline) function\n        // that calls the C stdlib math function,\n        // load X1 with the function's name,\n        // then call doPi to call the function\n        // and print the results:\n\n      ❹ lea     x0, sinVeneer   // SIN(x) output\n        lea     x1, sinStr\n        bl      doPi\n\n        lea     x0, cosVeneer   // COS(x) output\n        lea     x1, cosStr\n        bl      doPi\n\n        lea     x0, tanVeneer   // TAN(x) output\n        lea     x1, tanStr\n        bl      doPi\n\n        leave                   // Return to C/C++ code.\n        endp    asmMain\n```", "```\n$ ./build -math Listing6-3\n$ ./Listing6-3\nCalling Listing6-3:\nsin(pi) = 8.14137986335080e-13\nsin(pi/2) = 1.00000000000000e+00\nsin(pi/4) = 7.07106781594585e-01\nsin(pi/8) = 3.82683432365086e-01\n\ncos(pi) = -1.00000000000000e+00\ncos(pi/2) = -3.49148133884313e-15\ncos(pi/4) = 7.07106780778510e-01\ncos(pi/8) = 9.23879532511288e-01\n\ntan(pi) = -8.14137986335080e-13\ntan(pi/2) = -2.86411383293069e+14\ntan(pi/4) = 1.00000000115410e+00\ntan(pi/8) = 4.14213562373090e-01\n\nListing6-3 terminated\n```"]