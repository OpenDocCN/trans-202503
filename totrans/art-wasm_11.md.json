["```\nnpm install assemblyscript -g\n```", "```\n1 export function AddInts(2a: i32, 3b: i32 ): i32 {\n  4 return a + b;\n}\n```", "```\nasc as_add.ts -Oz -o as_add.wat\n```", "```\n(module\n  (type $i32_i32_=>_i32 (func (param i32 i32) (result i32)))\n  (memory $0 0)\n1 (export \"AddInts\" (func $as_add/AddInts))\n  (export \"memory\" (memory $0))\n2 (func $as_add/AddInts (param $0 i32) (param $1 i32) (result i32)\n  3 local.get $0\n  4 local.get $1\n  5 i32.add\n  )\n)\n```", "```\n1 declare function console_log( msg: string ):void;\n\n2 export function HelloWorld():void {\n3 console_log(\"hello world!\");\n}\n```", "```\nasc as_hello.ts -Oz -o as_hello.wat\n```", "```\n;; The comments were added by the author and not generated by asc 1\n(module\n  (type $none_=>_none (func))\n  (type $i32_=>_none (func (param i32)))\n ;; the declare command at the top of the AssemblyScript created an import\n ;; that imports the console_log function inside of the outer as_hello\n ;; object.  AssemblyScript requires its imports in the AssemblyScript file name\n ;; not including the .ts extension\n  (import \"as_hello\" \"console_log\" (func $as_hello/console_log (param i32))) 2\n ;; using a string automatically creates the memory expression\n  (memory $0 1) 3\n  ;; the data line below wraps because the line is too long\n ;; The \"hello world!\" string is preceded by a header and has a hex 00 byte in\n ;; between every letter in the string.  This is because AssemblyScript uses\n ;; the UTF-16 character set instead of ASCII as we did when we were manipulating\n ;; string data in WAT.\n  (data (i32.const 16) 4\n    \"\\18\\00\\00\\00\\01\\00\\00\\00\\01\\00\\00\\00\\18\\00\\00\\00h\\00e\\00l\\00l\\00o\\00 \\00w\\00o\\00r\\00l\\00d\\00!\")\n  (export \"memory\" (memory $0))\n ;; The module exports our function with the AssemblyScript name we gave it.\n  (export \"HelloWorld\" (func $as_hello/HelloWorld)) 5\n ;; the function name we gave AssemblyScript is prefixed by the name of our file\n ;; without the .ts extension\n  (func $as_hello/HelloWorld (; 1 ;) 6\n ;; 32 is the location in linear memory of the 'h' byte in \"hello world\"\n  i32.const 32 7\n ;; the console_log function is called passing in the location of \"hello world\"\n ;; in linear memory\n  call $as_hello/console_log 8\n  )\n)\n```", "```\nasc as_hello.ts -Oz -o as_hello.wasm\n```", "```\nconst fs = require('fs');\nconst bytes = fs.readFileSync(__dirname + '/as_hello.wasm');\n\n// The memory object is exported from AssemblyScript\n1 var memory = null;\n\nlet importObject = {\n```", "```\n2 as_hello: {\n // AssemblyScript passes a length prefixed string with a simple index\n 3 console_log: function (index) {\n // in case this is called before memory is set\n      if (memory == null) {\n        console.log('memory buffer is null');\n        return;\n      }\n\n    4 const len_index = index - 4;\n\n // must divide by 2 to get from bytes to 16-bit unicode characters\n    5 const len = new Uint32Array(memory.buffer, len_index, 4)[0];\n    6 const str_bytes = new Uint16Array(memory.buffer,\n        index, len);\n\n // decode the utf-16 byte array into a JS string\n    7 const log_string = new TextDecoder('utf-16').decode(str_bytes);\n      console.log(log_string);\n    }\n  },\n  env: {\n    abort: () => { } \n  }\n};\n\n(async () => {\n  let obj = await WebAssembly.instantiate(new Uint8Array(bytes),\n    importObject);\n\n // memory object exported from AssemblyScript\n8 memory = obj.instance.exports.memory;\n // call the HelloWorld function\n9  obj.instance.exports.HelloWorld();\n})();\n```", "```\nnpm install @assemblyscript/loader --save\n```", "```\n1 const loader = require(\"@assemblyscript/loader\");\nconst fs = require('fs');\n2 var module;\n\nconst importObject = {\n3 as_hello: {\n  4 console_log: (str_index) => {\n    5 console.log(module.exports.__getString(str_index));\n    }\n  }\n};\n\n(async () => {\n  let wasm = fs.readFileSync('as_hello.wasm');\n6 module = await loader.instantiate(wasm, importObject);\n7 module.exports.HelloWorld();\n})();\n```", "```\nhello world!\n```", "```\n1 export function cat( str1: string, str2: string ): string {\n2 return str1 + \"|\" + str2;\n}\n```", "```\nasc as_concat.ts --exportRuntime -Oz -o as_concat.wasm\n```", "```\nTypeError: alloc is not a function\n```", "```\nconst fs = require('fs');\nconst loader = require(\"@assemblyscript/loader\");\n\n(async () => {\n  let module = await loader.instantiate(fs.readFileSync('as_concat.wasm'));\n\n  //__newString, __getString functions require\n  //compile with --exportRuntime flag\n1 let first_str_index = module.exports.__newString(\"first string\");\n2 let second_str_index = module.exports.__newString(\"second string\");\n3 let cat_str_index = module.exports.cat(first_str_index,second_str_index);\n4 let cat_string = module.exports.__getString(cat_str_index);\n5 console.log(cat_string);\n})();\n```", "```\nnode as_concat.js\n```", "```\nfirst string|second string\n```", "```\n1 export class Vector2D {\n2 x: f32;\n3 y: f32;\n\n4 constructor(x: f32, y: f32) {\n    this.x = x;\n    this.y = y;\n  }\n\n5 Magnitude(): f32 {\n    return Mathf.sqrt(this.x * this.x + this.y * this.y);\n  }\n}\n```", "```\nasc vector.ts -o vector.wat\n```", "```\n...\n  (export \"memory\" (memory $0))\n  (export \"Vector2D\" (global $vector/Vector2D))\n1 (export \"Vector2D#get:x\" (func $vector/Vector2D#get:x))\n2 (export \"Vector2D#set:x\" (func $vector/Vector2D#set:x))\n3 (export \"Vector2D#get:y\" (func $vector/Vector2D#get:y))\n  (export \"Vector2D#set:y\" (func $vector/Vector2D#set:y))\n4 (export \"Vector2D#constructor\" (func $vector/Vector2D#constructor))\n5 (export \"Vector2D#Magnitude\" (func $vector/Vector2D#Magnitude))\n...\n```", "```\nexport class Vector2D {\n  1 private x: f32;\n  2 private y: f32;\n\n  constructor(x: f32, y: f32) {\n    this.x = x;\n    this.y = y;\n  }\n\n  Magnitude(): f32 {\n    return Mathf.sqrt(this.x * this.x + this.y * this.y);\n  }\n\n}\n```", "```\n...\n(export \"memory\" (memory $0))\n(export \"Vector2D\" (global $vector/Vector2D))\n(export \"Vector2D#constructor\" (func $vector/Vector2D#constructor))\n(export \"Vector2D#Magnitude\" (func $vector/Vector2D#Magnitude))\n...\n```", "```\nasc vector.ts -o vector.wasm\n```", "````` ```` and `fetch` instead of using `fs` to load the WebAssembly module from the filesystem and calling `WebAssembly.instantiate``` `.` `` ```` `````", "`````` ````` ````Create the file *vector.js* and add the code in [Listing 11-18](#listing11-18).    **vector.js**    ``` 1 const fs = require('fs');  2 (async () => { 3 let wasm = fs.readFileSync('vector.wasm'); 4 let obj = await WebAssembly.instantiate(wasm,{env:{abort:()=>{}}});  5 let Vector2D = {   6 init: function (x, y) {       return obj.instance.exports[\"Vector2D#constructor\"](0, x, y)     },   7 Magnitude: obj.instance.exports[\"Vector2D#Magnitude\"], }  8 let vec1_id = Vector2D.init(3, 4);   let vec2_id = Vector2D.init(4, 5);    console.log(`   9 vec1.magnitude=${Vector2D.Magnitude(vec1_id)}     vec2.magnitude=${Vector2D.Magnitude(vec2_id)}     `); })(); ```    Listing 11-18: Calling functions on the `Vector2D` AssemblyScript class    We use the `fs` 1 Node.js module to load 3 the binary WebAssembly data from a file inside an asynchronous IIFE 2. Once we have the binary data, we pass it to `WebAssembly.instantiate` 4, which returns a WebAssembly module object. We then create the JavaScript object `Vector2D` 5, which mirrors the functions inside the WebAssembly module.    We create an `init` 6 function that calls the WebAssembly module’s `Vector2D` `constructor`, passing in `0` as the first parameter. Passing this value to the `constructor` function allows some degree of choice of object placement in linear memory. We are passing `0`, which makes the constructor create a new object at the next available memory location.The function will then return the location in linear memory where it created this object. The `Magnitude` 7 attribute in `Vector2D` takes its value from `obj.instance.exports[\"Vector2D#Magnitude\"]`, which is a function in our WebAssembly module.    After defining the JavaScript `Vector2D` object, we call `Vector2D.init` 8 twice to create two `Vector2D` WebAssembly objects in linear memory, as well as return the linear memory address of these objects, which we use for method calls. We then call `Vector2D.Magnitude` twice inside a `console.log` template string. We pass in the vector ids (`vec1_id` and `vec2_id`) we saved in [Listing 11-18](#listing11-18), which tell the WebAssembly module which object it’s using. The `Magnitude` 9 function passes back the magnitude of the given vector, which the app logs to the console. Run this app using `node`:    ``` node vector.js ```    Here’s the result:    ``` vec1.magnitude=5 vec2.magnitude=6.4031243324279785 ```    The two values are the magnitude of our first vector where x = 3 and y = 4, and the magnitude of the second vector where x = 4 and y = 5\\.    Now that we know how to make calls into our AssemblyScript app directly, let’s look at how to use the AssemblyScript loader to make coding the JavaScript a little easier.    ### AssemblyScript Loader    Now we’ll modify our AssemblyScript code to use the AssemblyScript loader library. This will allow us to compare the methods of interfacing with an AssemblyScript module in terms of ease of use and performance. As mentioned previously, it’s important to understand when it’s possible to improve your application’s performance and how much effort that requires. This information helps you make decisions concerning the trade-off between development time and application performance.    Open *vector_loader.ts* and add the code in [Listing 11-19](#listing11-19) to use the AssemblyScript loader.    **vector_loader.ts**    ``` export class Vector2D { 1 x: f32; 2 y: f32;    constructor(x: f32, y: f32) {     this.x = x;     this.y = y;   }   Magnitude(): f32 {     return Mathf.sqrt(this.x * this.x + this.y * this.y);   }  3 add(vec2: Vector2D): Vector2D {     this.x += vec2.x;     this.y += vec2.y;     return this;   } } ```    Listing 11-19: Remove the private modifier from the `x` and `y` attributes    There are two changes to *vector.ts* that we will add into *vector_loader.ts*. First, we remove the `private` modifiers from the `x` 1 and `y` 2 attributes so we can access `x` and `y` from JavaScript. Second, we create an `add` 3 function that adds a second vector. This function allows us to add two vectors together. In [Listing 11-20](#listing11-20), we compile *vector_loader.ts* using `asc`.    ``` asc vector_loader.ts -o vector_loader.wasm ```    Listing 11-20: Compiling *vector.ts* to a WebAssembly file using `asc`    Next, we’ll create a new JavaScript file named *vector_loader.js* so we can run the new WebAssembly module. Add the code in [Listing 11-21](#listing11-21) to *vector_loader.js*.    **vector_loader.js**    ``` const fs = require('fs'); 1 const loader = require('@assemblyscript/loader');  (async () => {   let wasm = fs.readFileSync('vector_loader.wasm');  // instantiate the module using the loader 2 let module = await loader.instantiate(wasm);     // module.exports.Vector2D mirrors the AssemblyScript class. 3 let Vector2D = module.exports.Vector2D;  4 let vector1 = new Vector2D(3, 4);   let vector2 = new Vector2D(4, 5);  5 vector2.y += 10; 6 vector2.add(vector1);    console.log(`   7 vector1=(${vector1.x}, ${vector1.y})     vector2=(${vector2.x}, ${vector2.y})      vector1.magnitude=${vector1.Magnitude()}     vector2.magnitude=${vector2.Magnitude()}    `); })(); ```    Listing 11-21: Using the AssemblyScript loader in JavaScript    When using the loader, you can interact with AssemblyScript classes almost as if they’re JavaScript classes. There is a slight difference in that you call the demangled constructor function without using the JavaScript `new` operator, as you would do if these classes were created in JavaScript. However, once you’ve instantiated the object, you can interact with it as if it were written in JavaScript.    We first require the AssemblyScript `loader` 1. Rather than using the `WebAssembly.instantiate` function from the IIFE, we call the `loader.instantiate` 2 function, which returns a loader module. This module works a little differently than the WebAssembly module object returned by the `WebAssembly.instantiate` call. The AssemblyScript loader adds functionality that allows the JavaScript to work with high-level AssemblyScript objects, such as classes and strings.    We then call `loader.demangle`, passing it the module returned by `loader.instantiate`. The `demangle` function returns an object structure that provides us with functions we can use to instantiate objects from our WebAssembly module. We pull the `Vector2D` 3 function out of the object structure so we can use it as a constructor function for creating `Vector2D` objects in JavaScript. Note that we didn't use the `new` operator when instantiating `Vector2D` 4. However, the current loader version supports use of the `new` operator.    We use the `Vector2D` function to create a `vector1` and `vector2` object, passing in the `x` and `y` values for those vectors. We can now use these objects as regular JavaScript objects. The loader wires everything up for us. For example, we call `vector2.y += 10` 5 to increase the value of `vector2.y` by 10, and `vector2.add(vector1)` 6 calls the `add` function on the `vector2` object, passing in `vector1`. In our `console.log` 7 call, we can use values like `vector1.x` and `vector1.y`.    Run the JavaScript using `node`:    ``` node vector_loader.js ```    You should see the following output:    ```  vector1=(3, 4)     vector2=(7, 19)      vector1.magnitude=5     vector2.magnitude=20.248456954956055 ```    The AssemblyScript loader interface allows you to work with WebAssembly modules created in AssemblyScript almost as if they were classes, objects, and functions created in JavaScript. This creates an ergonomic experience that you might not have when you write your own interface with the WebAssembly module. If you have specific performance targets, you’ll need to perform additional testing to see whether the loader meets all your needs. In the next section, we’ll extend our AssemblyScript class through inheritance.    ### Extending Classes in AssemblyScript    OOP allows developers to extend a class by adding additional attributes or functionality to a base class. The syntax for extending classes in AssemblyScript is the same as it is in TypeScript. In [Listing 11-22](#listing11-22), we’ll extend the `Vector2D` class with a `Vector3D` class that will add an additional attribute `z`, which will represent a third dimension for our vector.    Open the *vector_loader.ts* file and add the code in [Listing 11-22](#listing11-22) after the `Vector2D` definition.    **vector_loader.ts**    ``` ... 1 export class Vector3D extends Vector2D { 2 z: f32;    constructor(x: f32, y: f32, z: f32) {   3 super(x, y);     this.z = z;   }  4 Magnitude(): f32 {     return Mathf.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);   }    add(vec3: Vector3D): Vector3D {   5 super.add(vec3);   6 this.z += vec3.z;     return this;   } } ```    Listing 11-22: Extending the `Vector2D` class using the `Vector3D` class    The new `Vector3D` 1 class keeps the original `x` and `y` attributes, and adds a third `z` 2 attribute for the third dimension. Its constructor calls `super` 3, which runs the constructor from the `Vector2D` class. It then sets the value of `this.z` to the `z` parameter passed into the constructor. We override the `Magnitude` 4 method from `Vector2D` so it takes the third dimension into account when calculating the magnitude of the vector. Then the `add` function calls the `Vector2D` class’s `add` function using `super.add` 5 and increases the value of `this.z` 6 using the `vec3` parameter’s `z` attribute value.    Now we can recompile our WebAssembly module using `asc`:    ``` asc vector_loader.ts -o vector_loader.wasm ```    Next, in [Listing 11-23](#listing11-23), we modify the *vector_loader.js* file to pull in the `Vector3D` class.    **vector_loader.js**    ```  const fs = require('fs');   const loader = require(\"@assemblyscript/loader\");    (async () => {     let wasm = fs.readFileSync('vector_loader.wasm');     let module = await loader.instantiate(wasm);  1let { Vector2D, Vector3D } = await loader.demangle(module).exports;      let vector1 = Vector2D(3, 4);     let vector2 = Vector2D(4, 5);   2let vector3 = Vector3D(5, 6, 7);      vector2.y += 10;     vector2.add(vector1);   3vector3.z++;      console.log(`     vector1=(${vector1.x}, ${vector1.y})     vector2=(${vector2.x}, ${vector2.y})   4vector3=(${vector3.x}, ${vector3.y}, ${vector3.z})      vector1.magnitude=${vector1.Magnitude()}     vector2.magnitude=${vector2.Magnitude()}   5vector3.magnitude=${vector3.Magnitude()}     `);   })(); ```    Listing 11-23: JavaScript using the AssemblyScript loader to load `Vector2D` and `Vector3D` classes    We modify the line that took the `Vector2D` function from the call to `demangle`, and change it to destructure 1 the result, creating a `Vector2D` and `Vector3D` function variable. We create an object `vector3` 2, using the function `Vector3D`, to which we pass `x`, `y`, and `z` values. We increment `vector3.z` 3 for no particular reason other than to show that we can do it. Inside the template string passed to `console.log`, we add a line that displays the `x`, `y`, and `z` 4 values in `vector3`, as well as the magnitude of `vector3` 5.    When you run this JavaScript from the command line using `node`, you get the output in [Listing 11-24](#listing11-24).    ```  vector1=(3, 4)   vector2=(7, 19)   vector3=(5, 6, 8)    vector1.magnitude=5   vector2.magnitude=20.248456954956055   vector3.magnitude=11.180339813232422 ```    Listing 11-24: Output from *vector_loader.js*    Now let’s look at how the performance of the loader compares to direct calls into the WebAssembly module.    ### Performance of Loader vs. Direct WebAssembly Calls    The AssemblyScript loader provides a more intuitive structure for interaction between the AssemblyScript module and our JavaScript. The final section of this chapter compares the loader with direct calls into the WebAssembly modules. To run this test, we don’t need to write any additional AssemblyScript. We’ll use the WebAssembly modules created earlier in this chapter, so we only need to create a new JavaScript file to call the existing modules. Create a new file named *vector_perform.js* and add the code in [Listing 11-25](#listing11-25).    **vector_perform.js**    ``` const fs = require('fs'); const loader = require(\"@assemblyscript/loader\");  (async () => {   let importObject = {     env: {       abort: () => { }     }   };   let wasm = fs.readFileSync('vector_loader.wasm');   let module = await loader.instantiate(wasm);   let obj = await WebAssembly.instantiate(wasm, importObject);   // This JavaScript class will have all the functions  // exported from AssemblyScript 1 let dVector2D = {  // the init function will call the constructor on Vector2D     init: function (x, y) {       return obj.instance.exports[\"Vector2D#constructor\"](0, x, y)     },     getX: obj.instance.exports[\"Vector2D#get:x\"],     setX: obj.instance.exports[\"Vector2D#set:x\"],     getY: obj.instance.exports[\"Vector2D#get:y\"],     setY: obj.instance.exports[\"Vector2D#set:y\"],     Magnitude: obj.instance.exports[\"Vector2D#Magnitude\"],     add: obj.instance.exports[\"Vector2D#add\"],   }   // This JavaScript class will have all the functions  // exported from AssemblyScript   let dVector3D = {  // the init function will call the constructor on Vector3D     init: function (x, y, z) {       return obj.instance.exports[\"Vector3D#constructor\"](0, x, y, z)     },     getX: obj.instance.exports[\"Vector3D#get:x\"],     setX: obj.instance.exports[\"Vector3D#set:x\"],     getY: obj.instance.exports[\"Vector3D#get:y\"],     setY: obj.instance.exports[\"Vector3D#set:y\"],     getZ: obj.instance.exports[\"Vector3D#get:z\"],     setZ: obj.instance.exports[\"Vector3D#set:z\"],     Magnitude: obj.instance.exports[\"Vector3D#Magnitude\"],     add: obj.instance.exports[\"Vector3D#add\"],   }  // prepare to log the time it takes to run functions directly 2 let start_time_direct = (new Date()).getTime();  3 let vec1_id = dVector2D.init(1, 2);  let vec2_id = dVector2D.init(3, 4);   let vec3_id = dVector3D.init(5, 6, 7);  4 for (let i = 0; i < 1_000_000; i++) {     dVector2D.add(vec1_id, vec2_id);     dVector3D.setX(vec3_id, dVector3D.getX(vec3_id) + 10);     dVector2D.setY(vec2_id, dVector2D.getY(vec2_id) + 1);     dVector2D.Magnitude(vec2_id);   } 5 console.log(\"direct time=\" + (new Date().getTime() - start_time_direct));  6 let { Vector2D, Vector3D } = await loader.demangle(module).exports;  7 let start_time_loader = (new Date()).getTime();  8 let vector1 = Vector2D(1, 2);   let vector2 = Vector2D(3, 4);   let vector3 = Vector3D(5, 6, 7);  9 for (i = 0; i < 1_000_000; i++) {     vector1.add(vector2);     vector3.x += 10;     vector2.y++;     vector2.Magnitude();   } a console.log(\"loader time=\" + (new Date().getTime() - start_time_loader));  })(); ```    Listing 11-25: Comparing loader function calls with direct function calls    Now we can see what it costs for us to use that pretty AssemblyScript loader syntax. This JavaScript creates an object to hold the direct calls to the `Vector2D` AssemblyScript class `dVector2D` 1 and one for the `Vector3D` class called `dVector3D`. We then set the variable `start_direct_time` 2 to the current time, which we’ll use to track the performance, and initialize 3 three vector objects. Two of the vector objects are `Vector2D` objects, and one is a `Vector3D` object.    After initializing the vectors, we loop one million times 4, making calls to those objects. We didn’t test every function, so this isn’t a perfect performance test. The goal is simply to get some numbers and see how they compare. As long as we make the same calls to the direct and loader versions, we should be able to get a reasonable comparison. We then use `console.log` 5 to log out the amount of time it took to initialize the vectors and run through the loop. This first loop tests the performance of the direct call to the WebAssembly module without using the AssemblyScript loader. Next, the code tests the performance of the module with the loader.    We use the `loader.demangle` 6 function to create the `Vector2D` and `Vector3D` factory functions. We then initialize `start_time_loader` 7 to the current time and call the `Vector2D` 8 and `Vector3D` functions to create three objects mirroring the code in the first loop 4 that tested the direct initialization calls. We loop one million times 9, executing the same functions as earlier, except through the loader. Finally, we `log` a the amount of time it took to execute the code using the loader.    Run *vector_perform.js* from the command line using `node`:    ``` node vector_perform.js ```    This is the output I received when I executed the file:    ``` direct time=74 loader time=153 ```    As you can see, the version using the loader took roughly twice as long to execute. The difference is even starker when we include the initialization calls in a loop. If you’re going to use the AssemblyScript loader, it’s best to structure your code to make as few calls as possible between the JavaScript and AssemblyScript.    ## Summary    In this chapter, you learned about the AssemblyScript high-level language, the AssemblyScript CLI, and the `asc` command you can use to compile AssemblyScript apps.    We created an `AddInts` function and a hello world app to show how writing an app in AssemblyScript compares to writing the same app in WAT. We compiled it to WAT format, looked through the code that the AssemblyScript compiler generated, and wrote a JavaScript app that ran the hello world app directly. While doing this, you learned how to use WAT to understand what the WebAssembly, created by the AssemblyScript compiler, is doing under the hood.    We then installed the AssemblyScript loader and used the JavaScript functions written by the AssemblyScript team to help us write the JavaScript code.    We discussed using strings in AssemblyScript, wrote a string concatenation app, and looked at how we must use additional flags with the `asc` compiler to allow `asc` to include additional WebAssembly libraries when compiling.    In the latter half of the chapter, we explored OOP in AssemblyScript. We created a class and looked at the exports from the WAT file it generated. We looked at `private` attributes and how they prevent AssemblyScript from exporting those attributes so they can’t be used by the embedding environment. We wrote JavaScript that allowed us to create the glue classes directly, and then used the AssemblyScript loader to create the glue code for us. We compared the performance of the direct and the loader methods. Finally, we extended our `Vector2D` class with a `Vector3D` class and discussed the differences between class inheritance in AssemblyScript and TypeScript.```` ````` ``````"]