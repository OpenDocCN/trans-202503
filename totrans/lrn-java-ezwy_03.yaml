- en: '**3**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: CREATING A GUI FOR OUR GUESSING GAME
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的猜数字游戏创建 GUI
- en: '![Image](../images/circle.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/circle.jpg)'
- en: In this chapter, we’ll create a GUI version of the Hi-Lo guessing game from
    [Chapter 2](ch2.xhtml#ch2), as shown in [Figure 3-1](ch3.xhtml#ch3fig1). When
    this version of the program runs, it presents a graphical, or visual, interface
    that users will interact with. The GUI version allows the user to play the game
    in a desktop window like the applications you use every day. It’s a professional,
    windowed app complete with a text field for the user’s guess, a button to submit
    the guess, and a label that tells the user if they’ve guessed too high, too low,
    or correctly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个来自 [第 2 章](ch2.xhtml#ch2) 的 Hi-Lo 猜数字游戏的 GUI 版本，如 [图 3-1](ch3.xhtml#ch3fig1)
    所示。当这个版本的程序运行时，它将呈现一个图形化或视觉化界面，用户将与之互动。GUI 版本允许用户在一个桌面窗口中玩游戏，就像你每天使用的应用程序一样。它是一个专业的窗口化应用，包含一个供用户输入猜测的文本框，一个提交猜测的按钮，以及一个标签，告诉用户他们的猜测是过高、过低还是正确。
- en: '![Image](../images/f0044-01.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0044-01.jpg)'
- en: '*Figure 3-1: A GUI version of the Hi-Lo guessing game running on Windows (left)
    and on macOS (right)*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：在 Windows（左）和 macOS（右）上运行的 Hi-Lo 猜数字游戏的 GUI 版本*'
- en: Best of all, the exact same Java source code produced both versions of the app
    in [Figure 3-1](ch3.xhtml#ch3fig1). With the GUI code we’ll write in this chapter,
    our game will be playable on Windows, macOS, and Linux!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最棒的是，完全相同的 Java 源代码生成了 [图 3-1](ch3.xhtml#ch3fig1) 中的两个版本的应用程序。通过本章我们编写的 GUI
    代码，我们的游戏将在 Windows、macOS 和 Linux 上均可运行！
- en: Practicing with JShell
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 JShell 中练习
- en: JShell works at the command line, accepting text commands and usually responding
    with text output. However, JShell also has access to the full set of Java libraries—prewritten
    packages of code—and isn’t limited to just text. Before we start programming our
    game, let’s create a simple GUI in JShell as practice.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JShell 在命令行中工作，接受文本命令并通常以文本输出响应。然而，JShell 还可以访问完整的 Java 库——预编写的代码包——并且不仅限于文本输出。在开始编写我们的游戏之前，先让我们在
    JShell 中创建一个简单的 GUI 作为练习。
- en: '*Creating a GUI in Four Lines of Code*'
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*四行代码创建 GUI*'
- en: 'We can create a simple GUI window with just four lines of code in JShell. Let’s
    take each statement one at a time. First, enter an `import` statement into JShell
    to import the `javax.swing.JFrame` class:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需四行代码就能在 JShell 中创建一个简单的 GUI 窗口。让我们逐条分析每一行代码。首先，输入一个 `import` 语句，将 `javax.swing.JFrame`
    类导入到 JShell 中：
- en: jshell> import javax.swing.JFrame
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: jshell> import javax.swing.JFrame
- en: 'The `JFrame` class we’ve just imported creates a frame or window using Java.
    Next, let’s create a frame using that class. Enter the following declaration to
    create a `JFrame` called `myFrame`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚导入的 `JFrame` 类使用 Java 创建一个框架或窗口。接下来，让我们使用该类创建一个框架。输入以下声明以创建一个名为 `myFrame`
    的 `JFrame`：
- en: jshell> JFrame myFrame = new JFrame("Hello!")
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: jshell> JFrame myFrame = new JFrame("Hello!")
- en: 'The `new` keyword creates a new object of the `JFrame` class—in this case,
    a GUI window that we’ll program to say `"Hello!"` in its title bar. JShell responds
    with a long line letting us know some of the default properties the window will
    have:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`new` 关键字创建一个 `JFrame` 类的新对象——在这个例子中，是一个我们将编程以在标题栏中显示 `"Hello!"` 的 GUI 窗口。JShell
    会响应并显示一行长文本，告诉我们窗口将拥有的一些默认属性：'
- en: myFrame ==> javax.swing.JFrame[frame1,0,0,0x0,invalid,hidden,layout=java.awt.BorderLayou
    ...
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: myFrame ==> javax.swing.JFrame[frame1,0,0,0x0,invalid,hidden,layout=java.awt.BorderLayou
    ...
- en: The information shown after the square bracket is a string representation of
    `myFrame` and its property values, like its size (`0x0`, which is 0 by 0 pixels)
    and whether it’s hidden or visible. Let’s change one of those properties by setting
    the size to something bigger than 0 by 0 pixels.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号后面显示的信息是 `myFrame` 的字符串表示以及它的属性值，如大小（`0x0`，即 0x0 像素）以及它是隐藏的还是可见的。让我们通过设置大小为大于
    0x0 像素来更改其中一个属性。
- en: 'The third line of code sets the size of the window in pixels by specifying
    a width and height for the frame:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 第三行代码通过指定框架的宽度和高度来设置窗口的像素大小：
- en: jshell> myFrame.setSize(300,200)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: jshell> myFrame.setSize(300,200)
- en: This tells Java to make the window 300 pixels wide and 200 pixels tall, big
    enough for us to see the window and title bar.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 Java 将窗口设置为 300 像素宽，200 像素高，足以让我们看到窗口和标题栏。
- en: 'Finally, let’s show the window on the screen by calling the `setVisible()`
    method:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过调用 `setVisible()` 方法将窗口显示在屏幕上：
- en: jshell> myFrame.setVisible(true)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: jshell> myFrame.setVisible(true)
- en: We use `setVisible(true)` to show a window and `setVisible(false)` to hide it.
    Since we’ve called `myFrame.setVisible(true)`, you should see your window appear
    on the screen, as shown in [Figure 3-2](ch3.xhtml#ch3fig2).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `setVisible(true)` 来显示窗口，使用 `setVisible(false)` 来隐藏窗口。由于我们调用了 `myFrame.setVisible(true)`，你应该能在屏幕上看到窗口，如[图
    3-2](ch3.xhtml#ch3fig2)所示。
- en: '![Image](../images/f0045-01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0045-01.jpg)'
- en: '*Figure 3-2: Our GUI window on Windows (left) and on macOS (right)*'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：我们的 GUI 窗口在 Windows（左）和 macOS（右）上的展示*'
- en: We’ve created a GUI window by entering just four snippets of code into JShell!
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只通过输入四个代码片段，就在 JShell 中创建了一个 GUI 窗口！
- en: '*Creating an Interactive GUI in 10 Lines of Code!*'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*在 10 行代码中创建互动式 GUI！*'
- en: I showed the previous example to my students at the university and to my sons
    at home, and both groups responded with something like “That’s really cool, but
    can you make the window *do* something?”
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我将之前的示例展示给了大学里的学生和家里的儿子们，他们的反应都类似：“这真的很酷，不过你能让窗口 *做* 一些事情吗？”
- en: Thankfully, the answer is yes. By adding just a few more lines of code, we can
    add a button to the window that prints something every time you click it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，答案是肯定的。只需再添加几行代码，我们就能在窗口中添加一个按钮，每次点击时打印出一些内容。
- en: 'Let’s begin with a fresh JShell. Clear your JShell history by entering `/reset`
    at the JShell prompt:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个新的 JShell 开始。通过在 JShell 提示符下输入 `/reset` 来清除你的 JShell 历史记录：
- en: jshell> /reset
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: jshell> /reset
- en: '|  Resetting state.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '|  重置状态。'
- en: 'Next, let’s use the built-in JShell editor to write a 10-line snippet of code
    to create an interactive GUI app that responds to your click. At the JShell prompt,
    enter `/edit` to open the JShell editor:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用内置的 JShell 编辑器编写一段 10 行代码，创建一个响应点击的互动式 GUI 应用。在 JShell 提示符下，输入 `/edit`
    来打开 JShell 编辑器：
- en: jshell> /edit
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: jshell> /edit
- en: The JShell Edit Pad, which is helpful when we want to write several lines of
    code at once or when we want to go back and edit a line we’ve typed earlier, appears
    with an empty window as shown in [Figure 3-3](ch3.xhtml#ch3fig3).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: JShell 编辑区对我们来说非常有用，尤其是在我们想要一次写多行代码，或者想要回去编辑之前输入的某行代码时，它会显示一个空窗口，如[图 3-3](ch3.xhtml#ch3fig3)所示。
- en: '![Image](../images/f0046-01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0046-01.jpg)'
- en: '*Figure 3-3: The JShell Edit Pad is a convenient editor for writing longer
    snippets of code.*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-3：JShell 编辑区是一个方便的编辑器，用于编写较长的代码片段。*'
- en: 'In this case, we want to type 10 lines of code that will create an interactive
    GUI window with a button that prints something when it’s clicked. Enter the following
    lines, being extra careful with your capitalization and adding a semicolon at
    the end of each complete statement to separate the multiple commands:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们希望输入 10 行代码，这些代码将创建一个互动式 GUI 窗口，包含一个按钮，点击时会打印出一些内容。输入以下代码时，请特别注意字母大小写，并在每条完整语句末尾加上分号，以便将多条命令分开：
- en: import javax.swing.*;
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.*;
- en: JFrame window = new JFrame("Bryson's Window");
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: JFrame window = new JFrame("Bryson 的窗口");
- en: ➊ JPanel panel = new JPanel();
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ JPanel panel = new JPanel();
- en: JButton button = new JButton(➋"Click me!");
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: JButton button = new JButton(➋"点击我！");
- en: ➌ panel.add(button);
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ panel.add(button);
- en: ➍ window.add(panel);
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ➍ window.add(panel);
- en: window.setSize(➎300,100);
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: window.setSize(➎300,100);
- en: ➏ button.addActionListener(e ->
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ button.addActionListener(e ->
- en: System.out.println("Ouch! You clicked me!"));
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("哎呀！你点击我了！"));
- en: ➐ window.setVisible(true);
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ➐ window.setVisible(true);
- en: First, we import all the Swing GUI classes, including `JFrame`, `JPanel`, and
    `JButton`. An asterisk (`*`) at the end of a Java library is called a *wildcard
    character* and means “include every class in this package.” Then, we create a
    `JFrame` just like we did in the previous example. At ➊, we create a panel inside
    the window. The panel will serve as a container for other GUI components like
    labels and buttons.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入所有的 Swing GUI 类，包括 `JFrame`、`JPanel` 和 `JButton`。Java 库名称后面的星号（`*`）叫做
    *通配符字符*，意味着“包括该包中的所有类”。然后，我们创建一个 `JFrame`，就像在前面的示例中那样。在 ➊ 处，我们在窗口内创建一个面板。这个面板将作为容器，包含其他
    GUI 组件，如标签和按钮。
- en: Next, we add a button with the text “Click me!” ➋ printed on it. At ➌, we add
    the button to our GUI panel, and then we add the panel to the window at ➍. Then,
    we set the size of the window to 300 pixels wide by 100 pixels high ➎, similar
    to the previous example.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个上面写着“点击我！”的按钮 ➋。在 ➌ 处，我们将按钮添加到 GUI 面板中，然后在 ➍ 处将面板添加到窗口中。然后，我们将窗口的大小设置为宽
    300 像素，高 100 像素 ➎，这与前面的示例类似。
- en: 'The lines at ➏ are where the magic happens: here we add an action listener
    to the “Click me!” button to respond every time the user clicks the button. The
    action listener will print `"Ouch! You clicked me!"` to the console whenever the
    user clicks the GUI button. We’ll use listeners like this one in the GUI apps
    we build in this book to make the programs interact with the user whenever the
    user performs an action.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ➏ 处的代码是“魔法发生”的地方：在这里，我们为“点击我！”按钮添加了一个动作监听器，使得每当用户点击按钮时，程序就会响应。每当用户点击 GUI 按钮时，动作监听器会将
    `"哎呀！你点击了我！"` 打印到控制台。我们将在本书中构建的 GUI 应用程序中使用类似的监听器，让程序在用户执行操作时与用户互动。
- en: Finally, we make the window visible ➐, and we’re ready to test the program by
    clicking the button.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将窗口设置为可见 ➐，然后准备好通过点击按钮来测试程序。
- en: When you’ve finished typing all 10 lines of code and double-checked them for
    accuracy, click the **Accept** button in JShell Edit Pad to accept the code and
    run it in JShell, as shown in [Figure 3-4](ch3.xhtml#ch3fig4).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入完所有 10 行代码并检查无误后，点击 JShell 编辑板中的 **接受** 按钮以接受代码并在 JShell 中运行它，如[图 3-4](ch3.xhtml#ch3fig4)所示。
- en: After accepting the code, click **Exit** to close the JShell Edit Pad. JShell
    will run the code snippet, and if you’ve typed everything correctly, you’ll see
    a small window pop up like the one in [Figure 3-5](ch3.xhtml#ch3fig5).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接受代码后，点击 **退出** 关闭 JShell 编辑板。JShell 会运行代码片段，如果你输入的代码正确，你将看到一个小窗口弹出，如[图 3-5](ch3.xhtml#ch3fig5)所示。
- en: '![Image](../images/f0047-01.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0047-01.jpg)'
- en: '*Figure 3-4: After typing all 10 lines of code into the JShell Edit Pad, click*
    ***Accept***.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-4：在 JShell 编辑板中输入所有 10 行代码后，点击* ***接受***。'
- en: '![Image](../images/f0047-02.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0047-02.jpg)'
- en: '*Figure 3-5: An interactive GUI window with a clickable button*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-5：一个带有可点击按钮的互动式 GUI 窗口*'
- en: 'Click the button labeled **Click me!** with your mouse, and you’ll see Java
    respond as follows in the JShell window:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 用鼠标点击标有 **点击我！** 的按钮，你会在 JShell 窗口中看到 Java 的回应如下：
- en: jshell> Ouch! You clicked me!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: jshell> 哎呀！你点击了我！
- en: Ouch! You clicked me!
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！你点击了我！
- en: Ouch! You clicked me!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！你点击了我！
- en: Ouch! You clicked me!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！你点击了我！
- en: 'If you close the small GUI window, all you have to do to get it back is repeat
    the last line that sets the window to visible. Press ENTER a couple of times after
    clicking back into the JShell command line window to get the prompt and cursor
    back and then enter the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你关闭了这个小 GUI 窗口，只需重复最后一行设置窗口可见的代码即可恢复它。点击进入 JShell 命令行窗口后按 ENTER 键几次，以便恢复提示符和光标，然后输入以下内容：
- en: jshell> window.setVisible(true)
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: jshell> window.setVisible(true)
- en: The window reappears when we set the visible property to `true`; if you close
    the window, the visible property becomes `false`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将窗口的可见属性设置为 `true` 时，窗口会重新出现；如果你关闭窗口，窗口的可见属性会变成 `false`。
- en: This 10-line snippet is cool enough, but now you’ll learn how to build a game
    with a GUI!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 10 行的代码片段很酷，但现在你将学习如何构建一个带有 GUI 的游戏！
- en: Setting Up the GUI App in Eclipse
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 Eclipse 中设置 GUI 应用程序
- en: If you still have the *HiLo* project open in Eclipse from [Chapter 2](ch2.xhtml#ch2),
    as in [Figure 3-6](ch3.xhtml#ch3fig6), close or minimize the editor window for
    any other Java files you may have been working on ➊. Also, collapse the *HiLo*
    project by clicking the small down arrow next to the *HiLo* folder in the Package
    Explorer on the left side ➋. This allows us to keep projects together in a single
    workspace without getting files mixed up.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然在 Eclipse 中打开着[第 2 章](ch2.xhtml#ch2)中的 *HiLo* 项目，如[图 3-6](ch3.xhtml#ch3fig6)所示，关闭或最小化你可能正在编辑的任何其他
    Java 文件的编辑窗口 ➊。同时，通过点击左侧 Package Explorer 中 *HiLo* 文件夹旁的小箭头，折叠 *HiLo* 项目 ➋。这样可以使我们在一个工作区内保持项目的整洁，不会把文件搞混。
- en: '![Image](../images/f0048-01.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0048-01.jpg)'
- en: '*Figure 3-6: Close any open files and collapse the* HiLo *project folder.*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-6：关闭任何打开的文件并折叠* HiLo *项目文件夹。*'
- en: From the Eclipse menu bar, go to **File** ▸ **New** ▸ **Java Project** and name
    the project *GuessingGame*. After you’ve typed in the project name, click the
    **Finish** button at the lower right. This creates the new project folder in which
    we’ll develop the GUI version of the guessing game.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Eclipse 菜单栏中，选择 **文件** ▸ **新建** ▸ **Java 项目**，并将项目命名为 *GuessingGame*。输入项目名称后，点击右下角的
    **完成** 按钮。这将创建一个新的项目文件夹，我们将在其中开发猜数字游戏的 GUI 版本。
- en: Expand the *GuessingGame* folder in the Package Explorer window and find the
    *src* folder. Right-click (or, on macOS, CONTROL-click) the *src* folder and select
    **New** ▸ **Class**. Name the new class `GuessingGame`. Be sure to use camel case,
    beginning with an uppercase *G* for the class name. Check the box next to the
    **public static void main(String[] args)** method stub. This adds the skeleton
    of a `main()` method so that we can run our app as a stand-alone program.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 展开*GuessingGame*文件夹，在Package Explorer窗口中找到*src*文件夹。右键点击（或在macOS上，CONTROL-点击）*src*文件夹并选择**New**
    ▸ **Class**。将新类命名为`GuessingGame`。确保使用驼峰命名法，类名以大写字母*G*开头。勾选**public static void
    main(String[] args)**方法的复选框。这将添加`main()`方法的骨架，使我们能够将应用程序作为独立程序运行。
- en: Before we finish, we’ll need to do one more step differently than in the command
    line app we built in [Chapter 2](ch2.xhtml#ch2). We’re going to change the superclass
    from the default `java.lang.Object` to the `javax.swing.JFrame` class, like the
    `JFrame` we used in JShell at the beginning of this chapter. A *superclass* or
    *parent class* in Java is a class that we extend in order to reuse code that’s
    already been written, which in this case is the code needed to build a graphical,
    windowed interface. The `JFrame` class in the `javax.swing` package is one way
    we can include GUI components in our own apps, so we’ll use `JFrame` to create
    a window and then customize a version of it to add some more features. Since the
    `JFrame` class is an extension of the `Object` superclass itself, we don’t need
    `java.lang.Object` because `JFrame` will *inherit* the `Object` superclass’s code.
    That means that `JFrame` will have all the features of the `Object` class, plus
    some. We’ll see how extensions work in a bit.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成之前，我们需要做一步与我们在[第2章](ch2.xhtml#ch2)构建的命令行应用不同的操作。我们将把父类从默认的`java.lang.Object`改为`javax.swing.JFrame`类，就像我们在本章开头的JShell中使用的`JFrame`一样。在Java中，*父类*或*超类*是我们扩展的类，以便重用已经编写的代码，在这种情况下是构建图形化窗口界面所需的代码。`javax.swing`包中的`JFrame`类是我们在自己的应用中包含GUI组件的一种方式，因此我们将使用`JFrame`来创建一个窗口，然后定制它以添加更多功能。由于`JFrame`类本身是`Object`超类的扩展，因此我们不需要`java.lang.Object`，因为`JFrame`将*继承*`Object`超类的代码。这意味着`JFrame`将具有`Object`类的所有功能，并且还有更多功能。我们稍后将看到扩展是如何工作的。
- en: '[Figure 3-7](ch3.xhtml#ch3fig7) shows these settings in the New Java Class
    dialog for our guessing game.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-7](ch3.xhtml#ch3fig7)显示了我们猜数字游戏的新Java类对话框中的这些设置。'
- en: '![Image](../images/f0049-01.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0049-01.jpg)'
- en: '*Figure 3-7: Be sure to change the superclass to javax.swing.JFrame to prepare
    for a GUI class.*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-7：确保将父类更改为javax.swing.JFrame，为GUI类做准备。*'
- en: 'Click **Finish** to see the following source code for *GuessingGame.java*:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**Finish**以查看以下`GuessingGame.java`的源代码：
- en: ➊ import javax.swing.JFrame;
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ import javax.swing.JFrame;
- en: public class GuessingGame ➋extends JFrame {
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: public class GuessingGame ➋extends JFrame {
- en: public static void main(String[] args) {
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: // TODO Auto-generated method stub
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: // TODO 自动生成的方法存根
- en: '}'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: On the first line, Eclipse has imported the `javax.swing.JFrame` class ➊ to
    allow our program to use the GUI capabilities of Swing’s set of packages. In the
    second line, we use a new coding superpower, the `extends` keyword ➋.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，Eclipse导入了`javax.swing.JFrame`类 ➊，以允许我们的程序使用Swing包集的GUI功能。在第二行，我们使用了一个新的编程超级能力——`extends`关键字
    ➋。
- en: In object-oriented programming, a parent class or superclass can have *child
    classes* that inherit all the methods and attributes contained in the parent class.
    Once we write a class that does something important that we plan to reuse, we
    can refer to that original class and *extend* it to add new functionality without
    changing the code in the parent class. In this case, a `JFrame` parent class has
    the ability to display text fields, labels, buttons, and other GUI components
    that we can customize and arrange for the new guessing game app.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，父类或超类可以有*子类*，这些子类继承父类中包含的所有方法和属性。一旦我们编写了一个做某些重要事情的类，并且计划重用它，我们可以引用那个原始类并*扩展*它，以添加新的功能，而不需要更改父类中的代码。在这种情况下，`JFrame`父类具有显示文本框、标签、按钮和其他GUI组件的能力，我们可以为新的猜数字游戏应用自定义和排列这些组件。
- en: The `JFrame` parent class we’re extending in this app will enable us to display
    a window with GUI elements like text fields, labels, and buttons by designing
    the GUI layout with the WindowBuilder Editor in Eclipse. Let’s see how the WindowBuilder
    Editor works next.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此应用中扩展的`JFrame`父类将使我们能够通过在Eclipse中的WindowBuilder编辑器中设计GUI布局，显示包含文本框、标签和按钮等GUI元素的窗口。接下来我们来看看WindowBuilder编辑器是如何工作的。
- en: GUI Design with Eclipse’s WindowBuilder Editor
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Eclipse 的 WindowBuilder 编辑器进行 GUI 设计
- en: The most popular Java IDEs include tools to help programmers build an attractive
    GUI in a design view, with a what-you-see-is-what-you-get (WYSIWYG) interface.
    WYSIWYG interfaces allow users to position design elements as they will look in
    the final product. For instance, Microsoft Word is a WYSIWYG interface, because
    it allows you to edit text as it will look in its final print form. In the same
    way, Java IDE tools like the WindowBuilder Editor allow programmers to place GUI
    components like text fields, labels, and buttons as they will look in the final
    windowed application, helping programmers deliver professional-looking GUI apps.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的 Java 集成开发环境（IDE）包括帮助程序员在设计视图中构建吸引人的 GUI 的工具，采用所见即所得（WYSIWYG）界面。所见即所得界面允许用户根据最终产品的外观定位设计元素。例如，Microsoft
    Word 就是一个所见即所得界面，因为它允许你编辑文本，显示最终打印形式的样子。同样，像 WindowBuilder 编辑器这样的 Java IDE 工具允许程序员将
    GUI 组件（如文本框、标签和按钮）放置在最终窗口化应用程序中，看起来像它们的最终样子，从而帮助程序员交付专业外观的 GUI 应用程序。
- en: To open the WindowBuilder Editor, right-click the *GuessingGame.java* file in
    the Package Explorer on the left and then select **Open With** ▸ **WindowBuilder
    Editor**. A new window that looks like a regular text editor will open. But, if
    you look at the lower-left corner of the window, you’ll see two new tabs, Source
    and Design. The Source tab is the plain text, source code view of your application.
    If you click the Design tab, you’ll see the design view shown in [Figure 3-8](ch3.xhtml#ch3fig8).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开 WindowBuilder 编辑器，在左侧的包资源管理器中右键点击 *GuessingGame.java* 文件，然后选择 **打开方式** ▸
    **WindowBuilder 编辑器**。一个看起来像普通文本编辑器的窗口将会打开。但如果你查看窗口的左下角，你会看到两个新的标签，源代码和设计。源代码标签是应用程序的纯文本源代码视图。如果点击设计标签，你会看到在[图
    3-8](ch3.xhtml#ch3fig8)中显示的设计视图。
- en: The WindowBuilder Editor appears only for GUI classes, such as `GuessingGame`,
    that extend `JFrame` or one of the other GUI superclasses. Notice that the preview
    window has a title bar with a Java icon on the left side and three buttons to
    minimize, maximize, and close the window. The preview window in [Figure 3-8](ch3.xhtml#ch3fig8)
    looks slightly different on Windows, macOS, and Linux. This window will be our
    playground for building a GUI guessing game that looks and feels like a real app.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: WindowBuilder 编辑器仅适用于像 `GuessingGame` 这样的 GUI 类，这些类扩展了 `JFrame` 或其他 GUI 超类。注意，预览窗口有一个标题栏，左侧有一个
    Java 图标，并且有三个按钮来最小化、最大化和关闭窗口。[图 3-8](ch3.xhtml#ch3fig8)中的预览窗口在 Windows、macOS 和
    Linux 上看起来略有不同。这个窗口将成为我们构建看起来和感觉像真实应用程序的 GUI 猜谜游戏的游乐场。
- en: '![Image](../images/f0050-01.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0050-01.jpg)'
- en: '*Figure 3-8: The WindowBuilder Editor’s Design tab makes it easy to build GUI
    windowed apps.*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-8：WindowBuilder 编辑器的设计标签让你轻松构建 GUI 窗口化应用程序。*'
- en: Designing the User Interface
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计用户界面
- en: Double-click the *GuessingGame.java* tab at the top of the WindowBuilder Editor
    to expand the WindowBuilder design view to fullscreen. This will create more room
    for designing the GUI layout. You can double-click the tab again to restore the
    normal Java perspective when you’re ready to get back to programming.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 双击 WindowBuilder 编辑器顶部的 *GuessingGame.java* 标签，将 WindowBuilder 设计视图展开为全屏模式。这样可以为设计
    GUI 布局提供更多空间。当你准备好返回编程时，可以再次双击标签恢复正常的 Java 视角。
- en: '*Setting GUI Properties in the Properties Pane*'
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*在属性面板中设置 GUI 属性*'
- en: We’ll use the Properties pane to start customizing the GUI window for our guessing
    game. The Properties pane can be found on the bottom left of the Design tab in
    the WindowBuilder Editor. As you can see in [Figure 3-9](ch3.xhtml#ch3fig9), if
    you click a component in the Components pane (on the left under Structure), the
    Properties pane immediately below it lists several properties and values we can
    view and edit for that component.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用属性面板开始定制我们猜谜游戏的 GUI 窗口。属性面板位于 WindowBuilder 编辑器中设计标签的左下方。如[图 3-9](ch3.xhtml#ch3fig9)所示，如果你点击组件面板（位于结构下方的左侧）中的一个组件，下面的属性面板会立即列出该组件的几个属性和值，我们可以查看和编辑这些属性。
- en: '![Image](../images/f0051-01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0051-01.jpg)'
- en: '*Figure 3-9: The Properties pane helps you customize the properties of each
    GUI component in your app.*'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-9：属性面板帮助你定制应用程序中每个 GUI 组件的属性。*'
- en: We’re going to build a customized GUI window for the guessing game app. First,
    let’s change the title property of this `JFrame`. In the Components pane, click
    **javax.swing.JFrame**, then scroll down in the Properties pane until you see
    the `title` property. Click in the empty box to the right of `title` and enter
    `Your Name``'s` `Hi-Lo Guessing Game`. (Replace the italicized text with your
    name; this is your app, after all!) After you enter the title text, press ENTER.
    The GUI preview on the right will automatically update to show *Your Name*’s Hi-Lo
    Guessing Game in the title bar.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为猜数字游戏应用程序构建一个自定义的 GUI 窗口。首先，让我们更改这个`JFrame`的标题属性。在组件窗格中点击**javax.swing.JFrame**，然后在属性窗格中向下滚动，直到看到`title`属性。点击`title`右侧的空框，输入`Your
    Name``'s` `Hi-Lo Guessing Game`。（将斜体文本替换为你的名字；毕竟这是你的应用程序！）输入标题文本后，按回车键。右侧的 GUI
    预览将自动更新，显示*Your Name*’s Hi-Lo Guessing Game 在标题栏中。
- en: With the title done, let’s set a few other properties to make the GUI look and
    behave like we want for the guessing game. Scroll up in the Properties pane to
    find `defaultCloseOperation` (it may just display part of the name like `defaultClose...`
    or something similar if the pane is too narrow). Click the box to the right of
    `defaultCloseOperation` and select **EXIT_ON _CLOSE** from the drop-down menu.
    This means that when you click the close window button on the title bar of this
    `JFrame`, you’ll exit the program. This is usually the default, but there might
    be times you want to close a window but not close the whole application—for example,
    in a save dialog or a pop-up window. For this single-window game, though, we want
    to exit the application when the main window closes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 标题设置完毕后，让我们设置其他几个属性，使 GUI 看起来和行为符合猜数字游戏的需求。在属性窗格中向上滚动，找到`defaultCloseOperation`（如果窗格太窄，可能只显示部分名称，如`defaultClose...`）。点击`defaultCloseOperation`右侧的框，选择**EXIT_ON_CLOSE**从下拉菜单中。这意味着，当你点击这个`JFrame`标题栏上的关闭窗口按钮时，你将退出程序。这通常是默认设置，但有时你可能希望关闭一个窗口而不是整个应用程序——例如，在保存对话框或弹出窗口中。但对于这个单窗口的游戏，我们希望当主窗口关闭时退出应用程序。
- en: Next, we’ll change the way GUI components are arranged inside the app window.
    Click the **getContentPane()** entry in the Components pane, just under `javax.swing.JFrame`.
    A *content pane* is the *interior* of the `JFrame`, where we’ll build the guessing
    game GUI layout. Now, find Layout in the Properties pane and click the down arrow
    in the right edge of the field. Select **Absolute Layout** from the drop-down
    list of values; this enables us to place GUI elements with pixel-perfect precision.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更改 GUI 组件在应用窗口中的排列方式。在组件窗格中点击**getContentPane()**条目，位于`javax.swing.JFrame`下方。*内容窗格*是`JFrame`的*内部*部分，我们将在这里构建猜数字游戏的
    GUI 布局。现在，在属性窗格中找到布局（Layout），并点击字段右边缘的下拉箭头。从下拉列表中选择**Absolute Layout**；这将使我们能够以像素精确度放置
    GUI 元素。
- en: '*Customizing GUI Components in the Palette Pane*'
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*自定义调色板窗格中的 GUI 组件*'
- en: Let’s start customizing our guessing game app. You can find the elements you’ll
    need for almost any GUI app in the Palette pane. The Palette pane can be found
    in the middle of the WindowBuilder Editor on the Design tab. Note that you can
    expand or collapse a pane by clicking the small arrow to the left of the pane’s
    title. Click the arrow once to collapse the pane. Click the arrow again to expand
    the pane. This can be handy when you need extra room for a large, complex GUI
    layout.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始自定义我们的猜数字游戏应用程序。你可以在调色板窗格中找到几乎所有 GUI 应用所需的元素。调色板窗格位于设计标签的 WindowBuilder
    编辑器中间。注意，你可以通过点击窗格标题左侧的小箭头来展开或折叠窗格。点击箭头一次以折叠窗格，再次点击箭头以展开窗格。当你需要更多空间来进行大而复杂的 GUI
    布局时，这会非常方便。
- en: In the Palette, scroll down until you see the Components section, as shown in
    [Figure 3-10](ch3.xhtml#ch3fig10).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在调色板中向下滚动，直到看到组件部分，如[图 3-10](ch3.xhtml#ch3fig10)所示。
- en: The Palette contains all the standard components you’re probably already familiar
    with, like labels (`JLabel`), text fields (`JTextField`), buttons (`JButton`),
    and checkboxes (`JCheckBox`). You might have noticed that GUI components in the
    `javax.swing` package all begin with an uppercase J, followed by the name of the
    component in camel case. This makes it easy to remember the class name for each
    of the GUI elements in an app that uses the Swing toolkit.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 调色板中包含了所有你可能已经熟悉的标准组件，如标签（`JLabel`）、文本框（`JTextField`）、按钮（`JButton`）和复选框（`JCheckBox`）。你可能注意到，`javax.swing`包中的
    GUI 组件名称都以大写字母 J 开头，后面跟着组件的驼峰式命名法名称。这使得记住每个 GUI 元素在使用 Swing 工具包的应用程序中的类名变得更加容易。
- en: Let’s place a label at the top of the GUI window that says *Your Name*’s Hi-Lo
    Guessing Game. Click **JLabel** under Components in the Palette. Then, mouse over
    the GUI preview on the right; you should see gridlines appear. By default, the
    WindowBuilder Editor provides these gridlines to help you place elements. Now,
    hover your mouse near the top center of the gray content pane (the interior of
    the `JFrame`) and click to place a `JLabel` in that spot.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GUI 窗口的顶部放置一个标签，显示 *Your Name* 的 Hi-Lo 猜数字游戏。点击组件面板中的 **JLabel**。然后，将鼠标移动到右侧的
    GUI 预览区域；你应该能看到网格线出现。默认情况下，WindowBuilder 编辑器提供了这些网格线，帮助你放置元素。现在，将鼠标悬停在灰色内容面板的顶部中心（即
    `JFrame` 的内部），并点击以将一个 `JLabel` 放置在该位置。
- en: '![Image](../images/f0052-01.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0052-01.jpg)'
- en: '*Figure 3-10: The Components section in the Palette pane is where we’ll find
    the most common GUI components.*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-10：组件面板中的组件部分是我们找到最常见的 GUI 组件的地方。*'
- en: When you first place the `JLabel`, you can edit the text in the label directly
    in the GUI preview. Type `Your Name``'s Hi-Lo Guessing Game` and press ENTER.
    If you want to change the text later, go to the `text` property of the `JLabel`
    in the Properties pane on the lower left and type in your text. At first, you’ll
    probably only see part of the text in the label, because the label is too small
    to show the full text. Click the label, and you’ll see small black resizing squares
    on each corner. Click the lower-left corner of the label and drag it to the left
    border of the content pane to stretch the label to the content pane’s left edge.
    Then, click the label’s lower-right corner and drag to resize it to the content
    pane’s right edge.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当你首次放置 `JLabel` 时，可以直接在 GUI 预览中编辑标签中的文本。输入 `Your Name`'s Hi-Lo Guessing Game`，然后按
    ENTER。如果你之后想更改文本，可以在属性面板的 `JLabel` 的 `text` 属性中输入新的文本。刚开始时，你可能只能看到标签中的一部分文本，因为标签太小，无法显示完整的文本。点击标签，你会看到每个角落上都有小黑色的调整框。点击标签的左下角，将其拖动到内容面板的左边缘，将标签拉伸到内容面板的左边缘。然后，点击标签的右下角并拖动，调整标签大小，直到它与内容面板的右边缘对齐。
- en: Now your full label text should fit inside the label at the top of the GUI preview.
    Next let’s make the label text centered and bold. First, find the `horizontalAlignment`
    property of the label in the Properties pane. Click the value and choose **CENTER**
    from the drop-down list. Next, find the `font` property of the label and click
    the three dots to the right of the `font` property’s value. A font chooser window
    will open, allowing you to choose a font, style, and size. I chose Tahoma, 15
    point, and Bold, as shown in [Figure 3-11](ch3.xhtml#ch3fig11). Note that you
    may have to resize your label to fit a larger font.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，整个标签文本应该能适应放置在 GUI 预览顶部的标签内。接下来，让我们将标签文本居中并加粗。首先，在属性面板中找到标签的 `horizontalAlignment`
    属性。点击其值，然后从下拉列表中选择 **CENTER**。接着，找到标签的 `font` 属性，点击 `font` 属性值右侧的三个点。会弹出一个字体选择窗口，允许你选择字体、样式和大小。我选择了
    Tahoma 字体，15 磅，粗体，如 [图 3-11](ch3.xhtml#ch3fig11) 所示。注意，你可能需要调整标签的大小，以适应较大的字体。
- en: '![Image](../images/f0053-01.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0053-01.jpg)'
- en: '*Figure 3-11: The first label, customized and in place, at the top of the content
    pane*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-11：第一个标签，已经自定义并放置在内容面板顶部。*'
- en: Let’s add a label for the first prompt a user will see in the game. Click **JLabel**
    in the Palette pane, then place the new label just above the middle of the content
    pane. Enter `Guess a number between 1 and 100:` as the text of the label. You’ll
    need to resize the label a little wider than the text for extra padding.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为用户在游戏中看到的第一个提示添加一个标签。点击组件面板中的 **JLabel**，然后将新标签放置在内容面板的中部上方。输入标签的文本为 `猜一个
    1 到 100 之间的数字：`。你需要稍微调整标签的宽度，使其比文本宽一些，以便有更多的填充空间。
- en: Just to the right of the label, let’s place a text field for the user to enter
    their guess. Click **JTextField** on the Palette and then drop the text field
    into place to the right of the label you just placed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在标签的右侧，我们放置一个文本框，供用户输入他们的猜测。点击组件面板中的 **JTextField**，然后将文本框放置在你刚刚放置的标签的右侧。
- en: Resize it so it’s just big enough to hold a three-digit number. Click the label
    again and change its `horizontalAlignment` property to **RIGHT** to bring the
    text closer to the text field, as shown in [Figure 3-12](ch3.xhtml#ch3fig12).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 调整标签的大小，使其刚好能够容纳一个三位数的数字。再次点击标签，将其 `horizontalAlignment` 属性更改为 **RIGHT**，以将文本靠近文本框，如
    [图 3-12](ch3.xhtml#ch3fig12) 所示。
- en: '![Image](../images/f0054-01.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0054-01.jpg)'
- en: '*Figure 3-12: The guessing game now has a label and text field for the user’s
    guess.*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-12：现在，猜数字游戏有了一个标签和一个文本框，供用户输入猜测。*'
- en: Next, let’s place a button the user can push to submit their guess. On the Palette,
    find and click **JButton**. Mouse over the middle of the GUI preview window and
    click to place the `JButton`. Change the text to `Guess!`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们放置一个按钮，用户可以点击它来提交他们的猜测。在调色板中，找到并点击**JButton**。将鼠标移到GUI预览窗口的中间，然后点击放置`JButton`。将文本更改为`Guess!`。
- en: Finally, place a `JLabel` below the button, give it the text `Enter a number
    above and click Guess!`, and resize the label to the full width of the `JFrame`.
    Then, change the `horizontalAlignment` to **CENTER**. Later, this label will also
    be where we tell users whether they guessed too high, too low, or correctly. The
    alignment of each component may not be perfect yet, but your GUI layout should
    look something like [Figure 3-13](ch3.xhtml#ch3fig13).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在按钮下方放置一个`JLabel`，设置文本为`Enter a number above and click Guess!`，并将标签的大小调整为`JFrame`的全宽。然后，将`horizontalAlignment`更改为**CENTER**。稍后，这个标签也将用于告知用户他们的猜测是太高、太低还是正确。各组件的对齐可能还不完美，但你的GUI布局应该类似于[图
    3-13](ch3.xhtml#ch3fig13)。
- en: '![Image](../images/f0054-02.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0054-02.jpg)'
- en: '*Figure 3-13: The GUI layout has all the components, just not perfectly aligned
    yet.*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-13：GUI布局包含了所有组件，只是尚未完全对齐。*'
- en: Now that we have all the GUI components on the screen, we’re ready to make a
    few tweaks to balance and center the layout. First, be sure to save your file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将所有GUI组件放置在屏幕上，准备对布局进行一些微调，以使其平衡并居中。首先，确保保存你的文件。
- en: '*Aligning GUI Elements*'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*对齐GUI元素*'
- en: So far, we’ve been positioning GUI components by eye, trying to space them correctly
    and center them as much as possible. However, when we run a program, we expect
    the layout to be “perfect.” Fortunately, Eclipse has built-in tools to help us
    align components.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在凭眼力定位GUI组件，尽力让它们正确间隔并尽量居中。然而，当我们运行程序时，我们期望布局是“完美的”。幸运的是，Eclipse内置了帮助我们对齐组件的工具。
- en: First, let’s distribute the four main elements evenly, spacing them the same
    distance apart vertically. Select the three labels and the button by clicking
    each one while holding down the SHIFT button. For now, don’t click the text field
    where the user enters their guess. You should see a small row of alignment tools
    appear above the GUI preview window. Mouse over each tool to see a tool tip that
    tells you what that button does. You may need to resize your Eclipse window if
    you don’t see all the tools at first.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将四个主要元素均匀分布，垂直间隔相等。按住SHIFT键，点击选择三个标签和按钮。暂时不要点击用户输入猜测的文本字段。你应该会看到一排对齐工具出现在GUI预览窗口上方。将鼠标悬停在每个工具上，可以看到工具提示，告诉你该按钮的功能。如果一开始你没有看到所有工具，可能需要调整Eclipse窗口的大小。
- en: Click the tool that looks like stacked buttons (the rightmost icon in [Figure
    3-14](ch3.xhtml#ch3fig14)). All four selected items should now be spaced an equal
    distance apart from top to bottom.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 点击看起来像是堆叠按钮的工具（[图 3-14](ch3.xhtml#ch3fig14)中的最右侧图标）。此时，所有四个选中的项目应该会均匀地垂直分布。
- en: Now select just the text field. Move it to realign it with the label prompting
    the user to guess a number. We didn’t include the text field originally because
    Eclipse would have distributed all five components evenly, separating the text
    field and its label from each other and creating five rows instead of four.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，选择仅文本字段。将它移动并重新对齐，以与提示用户猜数字的标签对齐。我们最初没有包含文本字段，因为Eclipse会均匀分配所有五个组件，导致文本字段和其标签彼此分开，产生五行而不是四行。
- en: '![Image](../images/f0055-01.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0055-01.jpg)'
- en: '*Figure 3-14: You can align and space components evenly using the tools above
    the GUI preview window.*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-14：你可以使用GUI预览窗口上方的工具对组件进行对齐并均匀分布。*'
- en: '**NOTE**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you ever mess up while aligning things (or doing anything else) in WindowBuilder,
    you can undo your previous action by pressing CTRL-Z or* ![Image](../images/symbol.jpg)*-Z.
    This is a great safety feature in the WindowBuilder Editor and lets you try new
    things without permanently messing up the layout.*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你在使用WindowBuilder时对齐出了问题（或者做了其他任何操作），可以通过按CTRL-Z或* ![Image](../images/symbol.jpg)*-Z来撤销上一个操作。这是WindowBuilder编辑器的一个非常实用的安全功能，可以让你尝试新的操作，而不必担心永久性破坏布局。*'
- en: Finally, click the button labeled **Guess!** and click the alignment button
    above the GUI preview (the one near the far right with the tool tip “Center horizontally
    in window”). You can center or adjust the other components as desired. If you
    want to move two or more components together, you can SHIFT-click to select both,
    then click and drag to move them.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，点击标有**Guess!**的按钮，并点击 GUI 预览上方的对齐按钮（靠右侧，工具提示为“在窗口中水平居中”）。你可以根据需要居中或调整其他组件的位置。如果你想一起移动两个或更多组件，可以按住
    SHIFT 键并点击选择它们，然后点击并拖动它们。
- en: When you’re happy with the layout, it’s time to prepare for coding by naming
    the components. Take a moment to save your changes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对布局感到满意时，就可以准备开始编程了，首先为组件命名。花一点时间保存你所做的更改。
- en: '*Naming GUI Components for Coding*'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*为编程命名 GUI 组件*'
- en: The user interface of the guessing game app is ready for the player. To make
    the app easier to work with, however, we need to make a few final tweaks over
    in the Java source code file, where we’ll be programming the rest of the game.
    We need to name each component so that we’ll know how to refer to it inside the
    source code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 猜数字游戏应用的用户界面已经为玩家准备好。然而，为了让应用更加易于操作，我们需要在 Java 源代码文件中进行一些最终调整，在那里我们将编程完成其余部分的游戏。我们需要为每个组件命名，这样在源代码中我们就可以轻松地引用它们。
- en: This step is sometimes called “wiring up,” because we’ll be connecting each
    GUI component needed in the program to variable names that we can access in the
    Java source code. Eclipse has been naming each GUI element for us as we’ve added
    them, but we’ll want to change those names. Select the text field where the user
    will enter their guess. If you look in the Properties pane, you’ll see the very
    top property is `Variable`. The variable name Eclipse has given your first text
    field by default is probably something like `textField`. Click the value field
    beside the `Variable` property and rename the variable for this text field to
    `txtGuess`, as shown in [Figure 3-15](ch3.xhtml#ch3fig15).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤有时被称为“接线”，因为我们将连接程序中需要的每个 GUI 组件到我们可以在 Java 源代码中访问的变量名。Eclipse 在我们添加组件时已经为每个
    GUI 元素命名，但我们需要修改这些名称。选择用户输入猜测的文本框。如果你查看属性面板，你会看到最顶部的属性是 `Variable`。Eclipse 默认为你第一个文本框指定的变量名可能是类似
    `textField` 的名称。点击 `Variable` 属性旁边的值字段，并将该文本框的变量名更改为 `txtGuess`，如[图 3-15](ch3.xhtml#ch3fig15)所示。
- en: '![Image](../images/f0055-02.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0055-02.jpg)'
- en: '*Figure 3-15: Rename the variables for each GUI element so we can use them
    easily in the Java source code.*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-15：为每个 GUI 元素重命名变量，以便我们可以在 Java 源代码中轻松使用它们。*'
- en: The name `txtGuess` will remind us that it’s a text field and that it stores
    the user’s guess. You’ll find that naming GUI components consistently and logically
    will help you code more quickly and efficiently, with fewer errors.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 名称`txtGuess`将提醒我们它是一个文本框，并且它用于存储用户的猜测。你会发现，给 GUI 组件命名时保持一致性和逻辑性会帮助你更快速、高效地编码，并减少错误。
- en: After you’ve renamed the text field, select the label at the bottom of the GUI
    window that reads “Enter a number above and click Guess!”. This is the label that
    will output information for the user to read, like `Too high`, `Too low`, or `You
    win!`, so let’s rename the variable `lblOutput`. This name will help us remember
    it’s a GUI label (`lbl`) and that it’s the one we want to use for output to display
    information to the user.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名文本框后，选择 GUI 窗口底部的标签，该标签显示“Enter a number above and click Guess!”。这个标签将输出供用户阅读的信息，比如
    `Too high`（太高）、`Too low`（太低）或 `You win!`（你赢了！）。因此，我们将该变量重命名为 `lblOutput`。这个名称将帮助我们记住它是一个
    GUI 标签（`lbl`），并且它是我们用来显示用户信息的输出标签。
- en: In the Source tab at the lower left of the WindowBuilder Editor window, you’ll
    see that Eclipse has been writing the Java source code to produce the GUI layout
    you’ve been designing ([Figure 3-16](ch3.xhtml#ch3fig16)).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 WindowBuilder 编辑器窗口的左下角的 Source 标签中，你会看到 Eclipse 已经开始为你设计的 GUI 布局编写 Java 源代码（见[图
    3-16](ch3.xhtml#ch3fig16)）。
- en: '![Image](../images/f0056-01.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/f0056-01.jpg)'
- en: '*Figure 3-16: Click the Source tab, and you’ll see Eclipse has coded the GUI
    components in Java for us.*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-16：点击“Source”标签页，你会看到 Eclipse 已经为我们用 Java 编写了 GUI 组件的代码。*'
- en: Notice that the new variable names you gave the text field (`txtGuess`) and
    output label (`lblOutput`) are both visible in the source code. Now is a good
    time to save the file with all the changes you’ve made so far.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你为文本框（`txtGuess`）和输出标签（`lblOutput`）所命名的新变量名称在源代码中是可见的。现在是时候保存文件，保存迄今为止所做的所有更改了。
- en: But before we start writing the code for the guessing game app, we’re going
    to make an adjustment to the source code.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写猜数字游戏应用的代码之前，我们需要对源代码进行一些调整。
- en: '*Connecting the GUI to Your Java Code*'
  id: totrans-146
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*将GUI连接到您的Java代码*'
- en: 'Scroll up to the top of the `GuessingGame` class, and you’ll see that Eclipse
    has declared the `JTextField txtGuess` right at the top of the `GuessingGame`
    class:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动到`GuessingGame`类的顶部，你会看到Eclipse已在`GuessingGame`类的顶部声明了`JTextField txtGuess`：
- en: public class GuessingGame extends JFrame {
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: public class GuessingGame extends JFrame {
- en: private JTextField txtGuess;
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: private JTextField txtGuess;
- en: Eclipse does this for text fields by default for a reason. Declaring text fields
    at the top level of the class makes it possible to access the text field (to see
    if the user’s guess is too high or too low, for example) from *anywhere* inside
    the class. Text fields are usually used in this way, so Eclipse declares a `private
    JTextField txtGuess` right at the top of the `GuessingGame` class instead of in
    a method or function further down in the class. The modifier `private` is used
    as an object-oriented programming *best practice* (a recommended way of doing
    things). Making something `private` keeps other classes from being able to see
    that part of the code. Since `txtGuess` is `private`, classes other than `GuessingGame`
    won’t be able to access it or accidentally change the `txtGuess` variable, which
    is what we want.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse默认会为文本框这样做，原因是显而易见的。将文本框声明在类的顶部使得可以从类的*任何位置*访问该文本框（例如查看用户的猜测是否过高或过低）。文本框通常是这样使用的，因此Eclipse在`GuessingGame`类的顶部声明了一个`private
    JTextField txtGuess`，而不是在类的其他方法或函数中声明。`private`修饰符作为面向对象编程的*最佳实践*（推荐的做法）被使用。将某些东西设置为`private`可以防止其他类看到该部分代码。由于`txtGuess`是`private`的，除`GuessingGame`外的其他类将无法访问它或意外更改`txtGuess`变量，这是我们想要的。
- en: 'In this guessing game app, we want to be able to access the value the user
    enters into the `txtGuess` text field, so it’s great that Eclipse has declared
    it at the top level of the class. We also want to access the label `lblOutput`
    to be able to change the text displayed to the user (when their guess is too high,
    too low, or correct). So we need to add one more declaration to the top of the
    class, right under the declaration of `txtGuess`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个猜数字游戏应用中，我们希望能够访问用户输入到`txtGuess`文本框中的值，所以Eclipse将它声明在类的顶部是很有帮助的。我们还希望访问标签`lblOutput`，以便能够更改显示给用户的文本（当他们的猜测太高、太低或正确时）。因此，我们需要在类的顶部，再加一个声明，紧接着`txtGuess`的声明：
- en: public class GuessingGame extends JFrame {
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: public class GuessingGame extends JFrame {
- en: private JTextField txtGuess;
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: private JTextField txtGuess;
- en: private JLabel lblOutput;
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: private JLabel lblOutput;
- en: This line of code declares `lblOutput` as a variable that refers to a `JLabel`
    object in the GUI layout for the app. We’ve chosen to make this object reference
    `private` to hide this data from outside programs, but we’ll still be able to
    use it throughout the `GuessingGame` class.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行代码声明了`lblOutput`作为一个变量，它指向应用程序GUI布局中的`JLabel`对象。我们选择将这个对象引用设置为`private`，以便将此数据隐藏在外部程序之外，但我们仍然可以在`GuessingGame`类中使用它。
- en: 'One final change is to correct the line where `lblOutput` was originally declared,
    down near the bottom of the class. Find the line that looks like this, further
    down in the code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个更改是修正`lblOutput`最初声明的位置，该位置在类的底部。找到代码中类似以下的行：
- en: JLabel lblOutput = new JLabel("Enter a number above and click Guess!");
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: JLabel lblOutput = new JLabel("请输入一个数字并点击猜测！");
- en: 'And change it to this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 并将其更改为：
- en: lblOutput = new JLabel("Enter a number above and click Guess!");
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: lblOutput = new JLabel("请输入一个数字并点击猜测！");
- en: Notice we’ve removed the additional `JLabel` declaration. If you leave this
    second `JLabel` declaration in the program, your app won’t work because you’ve
    already declared `lblOutput` to be of type `JLabel` at the top of your class.
    If you leave the second `JLabel` declaration, Java will think you mean to have
    *two* separate `JLabel` objects named `lblOutput`. By removing the second `JLabel`
    declaration, you’re telling Java to use the *one* `JLabel lblOutput` you’ve created
    at the top of the program and initialize it with a text value of `"Enter a number
    above and click Guess!"`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们已经移除了额外的`JLabel`声明。如果你在程序中保留第二个`JLabel`声明，应用程序将无法正常工作，因为你已经在类的顶部声明了`lblOutput`为`JLabel`类型。如果你保留第二个`JLabel`声明，Java会认为你打算有两个独立的名为`lblOutput`的`JLabel`对象。通过移除第二个`JLabel`声明，你是在告诉Java使用你在程序顶部创建的*唯一的*`JLabel
    lblOutput`，并用文本值`"请输入一个数字并点击猜测！"`初始化它。
- en: 'While we’re declaring variables at the top level of the `GuessingGame` class,
    let’s add one more important variable: `theNumber`. Remember in the text-based
    version of the game, this is what we named the secret, random number the user
    is trying to guess. Add a declaration for `theNumber` after `txtGuess` and `lblOutput`
    as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们声明`GuessingGame`类的顶层变量时，让我们再添加一个重要的变量：`theNumber`。记住，在基于文本的游戏版本中，这就是我们为用户要猜测的秘密随机数字命名的变量。请在`txtGuess`和`lblOutput`后面添加`theNumber`的声明，如下所示：
- en: public class GuessingGame extends JFrame {
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: public class GuessingGame extends JFrame {
- en: private JTextField txtGuess;
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: private JTextField txtGuess;
- en: private JLabel lblOutput;
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: private JLabel lblOutput;
- en: private int theNumber;
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: private int theNumber;
- en: Now that our variables are correctly declared at the top of the class, we’re
    ready to begin coding the GUI version of the guessing game app. In the next section,
    you’ll learn how we can get the user’s guess from the GUI text field and check
    to see if it’s too high or too low. We’ll also show the output text in the GUI
    label `lblOutput` to help the user make their next guess.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确地在类的顶部声明了变量，准备开始编写猜数字游戏应用程序的GUI版本代码。在接下来的部分中，你将学到如何从GUI文本框获取用户的猜测，并检查它是否过高或过低。我们还将显示GUI标签`lblOutput`中的输出文本，帮助用户做出下一个猜测。
- en: Adding a Method to Check the Player’s Guess
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一个方法来检查玩家的猜测
- en: Now that the GUI is wired to the Java source code with the private variables
    we added, `txtGuess` and `lblOutput`, we’ll begin coding the logic of the guessing
    game.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，GUI已经通过我们添加的私有变量`txtGuess`和`lblOutput`与Java源代码连接起来，我们将开始编写猜数字游戏的逻辑代码。
- en: 'Let’s write a method called `checkGuess()` near the top of the `GuessingGame`
    class. The signature, or skeleton, of this method will look like this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`GuessingGame`类的顶部写一个名为`checkGuess()`的方法。这个方法的签名，或者说框架，应该像这样：
- en: public class GuessingGame extends JFrame {
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: public class GuessingGame extends JFrame {
- en: private JTextField txtGuess;
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: private JTextField txtGuess;
- en: private JLabel lblOutput;
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: private JLabel lblOutput;
- en: private int theNumber;
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: private int theNumber;
- en: public void checkGuess() {
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: public void checkGuess() {
- en: '}'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Notice that the method is declared as `public`. Variables in a class are usually
    declared as `private`, but methods or functions that operate on those variables
    are usually declared as `public` so other classes can call on them. You can think
    of it like your checking account. Your balance is private and can only be accessed
    by you or the bank, but the function of making deposits is public (other people
    can deposit money into your account).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，方法被声明为`public`。类中的变量通常声明为`private`，但操作这些变量的方法或函数通常声明为`public`，这样其他类可以调用它们。你可以把它想象成你的支票账户。你的余额是私人信息，只有你或银行可以访问，但存款功能是公开的（其他人可以向你的账户存款）。
- en: The second term, `void`, tells Java that we’re not expecting a *return* value,
    which is a value that a function or method outputs, from this function. For example,
    a conversion calculator for Fahrenheit to Celsius called `convertFtoC()` could
    take a value representing a temperature in Fahrenheit and return a numeric value
    representing the converted temperature in Celsius. In this guessing game application,
    the `checkGuess()` method will not return information like this to the rest of
    the program. Instead, we’re going to program the app to display information to
    the user through the graphical user interface, so we use the `void` return type,
    which doesn’t return a value.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个术语`void`告诉Java我们不期望从这个函数返回一个*返回*值，即函数或方法输出的值。例如，一个将华氏温度转换为摄氏温度的转换计算器`convertFtoC()`可以接受一个表示华氏温度的值，并返回一个表示转换后摄氏温度的数值。在这个猜数字游戏应用程序中，`checkGuess()`方法不会将此类信息返回给程序的其他部分。相反，我们将编写程序，通过图形用户界面显示信息给用户，因此我们使用`void`返回类型，它不返回任何值。
- en: Finally, we’ve named the method `checkGuess()` and provided the opening and
    closing braces that will contain the code that tells the program how we want to
    check a user’s guess.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将方法命名为`checkGuess()`，并提供了包含代码的开闭大括号，代码将告诉程序我们如何检查用户的猜测。
- en: '*Getting Text from a JTextField*'
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*从JTextField获取文本*'
- en: 'Let’s start building the `checkGuess()` method, which will take the string
    the user enters and check it against the number to guess. Add this line between
    the two braces for the `checkGuess()` method:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建`checkGuess()`方法，该方法将获取用户输入的字符串，并与要猜测的数字进行比较。请在`checkGuess()`方法的两个大括号之间添加以下代码：
- en: public void checkGuess() {
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: public void checkGuess() {
- en: String guessText = txtGuess.getText();
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: String guessText = txtGuess.getText();
- en: '}'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: This line creates a new `String` variable called `guessText` that will hold
    the number the user enters into the GUI text field. To get the text the user entered,
    we’ll need to use the `getText()` method by calling `txtGuess.getText()` and storing
    the result in the new string variable called `guessText`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行创建了一个新的`String`变量，名为`guessText`，用于保存用户在GUI文本框中输入的数字。为了获取用户输入的文本，我们需要使用`getText()`方法，调用`txtGuess.getText()`并将结果存储在新的字符串变量`guessText`中。
- en: You may see a window pop up near where you’re typing when you add the dot operator
    (`.`) after `txtGuess`, as shown in [Figure 3-17](ch3.xhtml#ch3fig17).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在`txtGuess`后添加点操作符（`.`）时，你可能会看到一个窗口弹出，显示你正在输入的内容，如[图3-17](ch3.xhtml#ch3fig17)所示。
- en: '![Image](../images/f0059-01.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0059-01.jpg)'
- en: '*Figure 3-17: After you type txtGuess and the dot operator (*.*), you may see
    a helpful code recommendation window appear.*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-17：在你输入`txtGuess`和点操作符（*.*）后，可能会看到一个有用的代码推荐窗口弹出。*'
- en: This is known as a *content assist*—Eclipse is trying to help by suggesting
    lines of code to finish the statement you’re working on. This particular kind
    of content assist is also called a *code recommender*, because it recommends common
    code options, like methods in the current class or object. Code recommendation
    is one feature that makes Eclipse a powerful IDE for professional Java developers.
    It’s not only faster in most cases to select a code recommender suggestion, but
    doing so also helps prevent errors and makes coders more efficient as they develop
    complex applications.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为*内容助手*—Eclipse正试图通过建议代码行来帮助你完成当前的语句。这种特殊类型的内容助手也叫做*代码推荐器*，因为它推荐常见的代码选项，比如当前类或对象中的方法。代码推荐是使Eclipse成为一个强大IDE的功能之一，它对专业Java开发者尤其有用。在大多数情况下，选择代码推荐器的建议不仅更快，而且还能帮助防止错误，提高程序员在开发复杂应用时的效率。
- en: 'Now, we need to create a string to hold the message telling the user whether
    their guess was too high, too low, or correct. Let’s declare one additional string:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个字符串来保存告诉用户他们的猜测是过高、过低还是正确的信息。让我们再声明一个字符串：
- en: public void checkGuess() {
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: public void checkGuess() {
- en: String guessText = txtGuess.getText();
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: String guessText = txtGuess.getText();
- en: String message = "";
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: String message = "";
- en: '}'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: We don’t know yet whether the user’s guess is too high or too low, so we’ve
    initialized `message` to an empty string with a pair of double quotes (`""`).
    After we test the user’s guess against the random number, or `theNumber`, we’ll
    update this string with more information before we output it in the GUI label.
    To test the user’s guess, we’ll need to turn their text entry, currently stored
    in `guessText`, into numeric form so that we can compare it to `theNumber`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还不知道用户的猜测是过高还是过低，因此我们将`message`初始化为空字符串，使用一对双引号（`""`）。在我们将用户的猜测与随机数`theNumber`进行比较后，我们将更新这个字符串，添加更多信息，然后将其输出到GUI标签中。为了测试用户的猜测，我们需要将他们输入的文本（当前存储在`guessText`中）转换为数字形式，以便与`theNumber`进行比较。
- en: '*Converting Strings to Numbers*'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*将字符串转换为数字*'
- en: In the text-based version of this app we made in [Chapter 2](ch2.xhtml#ch2),
    we used a `Scanner` object to scan a number value from the keyboard text the user
    entered. A scanner could work in a GUI, but there’s a more compact way to do this
    that will work better for this version.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在[第2章](ch2.xhtml#ch2)中制作的基于文本的版本的这个应用中，我们使用了一个`Scanner`对象从用户输入的键盘文本中扫描数字值。扫描器可以在GUI中使用，但有一种更简洁的方法可以做到这一点，适用于这个版本。
- en: Just like the `Math` class had `Math.random()` so that we could generate a random
    number, there is also a class for working with integers, called `Integer`. The
    `Integer` class has several functions that are useful for working with whole numbers,
    including a method to look for integers in strings of text, `Integer.parseInt()`.
    Enter the following line below `String message = ""`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`Math`类有`Math.random()`可以生成随机数一样，`Integer`类也有多个函数用于处理整数，包括一个查找字符串中整数的方法`Integer.parseInt()`。在`String
    message = ""`下面输入以下代码行。
- en: public void checkGuess() {
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: public void checkGuess() {
- en: String guessText = txtGuess.getText();
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: String guessText = txtGuess.getText();
- en: String message = "";
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: String message = "";
- en: int guess = Integer.*parseInt*(guessText);
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: int guess = Integer.*parseInt*(guessText);
- en: '}'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: First, this line declares `guess` to be an integer variable. Then, it searches
    for, or *parses*, an integer from the text the user entered. For example, the
    string `"50"` will become the *number* `50`. Finally, it stores the number in
    the variable `guess`. We need the numeric version of the user’s guess in order
    to compare it to `theNumber`, using the comparison operators `<` and `>`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这一行声明了`guess`为一个整数变量。接着，它从用户输入的文本中搜索或*解析*出一个整数。例如，字符串`"50"`将变成*数字*`50`。最后，它将数字存储到变量`guess`中。我们需要用户猜测的数字版本，以便使用比较运算符`<`和`>`与`theNumber`进行比较。
- en: 'With the user’s guess stored in the variable `guess`, we’re ready to test it
    against the computer’s secret, random number `theNumber`. We haven’t actually
    programmed `theNumber` to hold a value yet, but we’ll do that soon. Comparing
    the guess with `theNumber` will look like it did in the text-based version of
    the game, except we won’t print to the console using `System.out.println()`. Instead,
    we’ll store output for the user in the string variable `message` that we created:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 有了存储在变量`guess`中的用户猜测，我们准备将其与计算机的秘密随机数字`theNumber`进行比较。我们还没有编程让`theNumber`保存一个值，但我们很快就会做这件事。比较猜测与`theNumber`的过程将与文本版本的游戏类似，只是我们不会使用`System.out.println()`打印到控制台。相反，我们会将输出存储到我们创建的字符串变量`message`中：
- en: String guessText = txtGuess.getText();
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: String guessText = txtGuess.getText();
- en: String message = "";
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: String message = "";
- en: int guess = Integer.*parseInt*(guessText);
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: int guess = Integer.*parseInt*(guessText);
- en: if (guess < theNumber)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: if (guess < theNumber)
- en: message = guess + " is too low. Try again.";
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: message = guess + " 太低了。再试一次。";
- en: else if (guess > theNumber)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: else if (guess > theNumber)
- en: message = guess + " is too high. Try again.";
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: message = guess + " 太高了。再试一次。";
- en: else
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: message = guess + " is correct. You win!";
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: message = guess + " 正确。你赢了！";
- en: '}'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'Notice the three `if-else` statements are virtually identical to those in the
    text-based version of the game, except that we’re storing the output `message`
    (too high, too low, or correct) in a variable instead of outputting it directly
    to the console window. We still need to show `message` to the user, so we’ll do
    that using the `lblOutput` GUI label. We’ll use the `setText()` method like so:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，三个`if-else`语句几乎与文本版游戏中的完全相同，唯一的区别是我们将输出`message`（太高、太低或正确）存储在变量中，而不是直接输出到控制台窗口。我们仍然需要将`message`展示给用户，因此我们将使用`lblOutput`
    GUI标签来做到这一点。我们将使用`setText()`方法，如下所示：
- en: else
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: message = guess + " is correct. You win!";
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: message = guess + " 正确。你赢了！";
- en: lblOutput.setText(message);
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: lblOutput.setText(message);
- en: '}'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: This command will show the output message to the user in the GUI window by changing
    the text property of the `JLabel` called `lblOutput` to the correct `String` variable
    `message` based on the user’s guess.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将在GUI窗口中通过将`JLabel`名为`lblOutput`的文本属性更改为正确的`String`变量`message`来显示输出消息，基于用户的猜测。
- en: 'Your completed `checkGuess()` code should look like the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 你的完整`checkGuess()`代码应该如下所示：
- en: public void checkGuess() {
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: public void checkGuess() {
- en: String guessText = txtGuess.getText();
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: String guessText = txtGuess.getText();
- en: String message = "";
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: String message = "";
- en: int guess = Integer.*parseInt*(guessText);
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: int guess = Integer.*parseInt*(guessText);
- en: if (guess < theNumber)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: if (guess < theNumber)
- en: message = guess + " is too low. Try again.";
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: message = guess + " 太低了。再试一次。";
- en: else if (guess > theNumber)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: else if (guess > theNumber)
- en: message = guess + " is too high. Try again.";
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: message = guess + " 太高了。再试一次。";
- en: else
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: message = guess + " is correct. You win!";
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: message = guess + " 正确。你赢了！";
- en: lblOutput.setText(message);
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: lblOutput.setText(message);
- en: '}'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Next, we need to write the code that assigns a random value to `theNumber`.
    We’ll use the `newGame()` method, because we want to have a new random number
    every time the user begins a new game.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要编写代码来为`theNumber`分配一个随机值。我们将使用`newGame()`方法，因为每次用户开始新游戏时，我们都想生成一个新的随机数。
- en: Starting a New Game
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开始一个新游戏
- en: We want to tell the computer to pick a new, secret, random number whenever a
    new round of the guessing game starts, so it makes sense to do this in a method
    in the `GuessingGame` class. By doing it this way, we’ll be able to call on the
    method every time the user wins and wants to play a new game.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在每次新一轮猜谜游戏开始时，计算机能选择一个新的、秘密的随机数字，所以在`GuessingGame`类中使用一个方法来实现这一点是有意义的。通过这种方式，我们可以在每次用户获胜并想要开始新游戏时调用该方法。
- en: 'The method signature of the `newGame()` method looks similar to the `checkGuess()`
    method. Place it just after the closing brace for `checkGuess()` and before `public
    GuessingGame()`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`newGame()`方法的签名看起来与`checkGuess()`方法相似。将其放置在`checkGuess()`方法的闭合括号后面，`public
    GuessingGame()`前面：'
- en: lblOutput.setText(message);
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: lblOutput.setText(message);
- en: '}'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void newGame() {
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: public void newGame() {
- en: '}'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public GuessingGame() {
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: public GuessingGame() {
- en: We’ll make this method `public` so that it can be called from an outside class.
    We also need to let Java know that just like the `checkGuess()` method, this method
    has no information that needs to be returned, so its return type is `void`. Finally,
    the method’s name is `newGame`, and it includes open and close parentheses, `()`.
    The method body is empty right now, with nothing between the braces, but we’ll
    address that next.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个方法设为`public`，这样它就可以从外部类中调用。我们还需要告诉Java，和`checkGuess()`方法一样，这个方法没有需要返回的信息，因此它的返回类型是`void`。最后，这个方法的名称是`newGame`，并且它包括一对圆括号`()`。目前方法体为空，括号之间没有内容，但我们接下来会解决这个问题。
- en: 'A new game in this app just means that we’re telling the computer to pick a
    new random number. The code to assign this random value to `theNumber` will look
    and function like it did in the text-based version of the game, except now we’re
    putting this code inside its own, separate method. So, the finished `newGame()`
    method should look like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，创建一个新游戏意味着我们告诉计算机选择一个新的随机数字。将这个随机值赋给`theNumber`的代码与文本版游戏中的代码相同，唯一的不同是现在我们将代码放入了一个独立的方法中。因此，完成后的`newGame()`方法应该如下所示：
- en: public void newGame() {
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: public void newGame() {
- en: theNumber = (int)(Math.*random*() * 100 + 1);
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: theNumber = (int)(Math.*random*() * 100 + 1);
- en: '}'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: That’s it! Now we have all the necessary pieces in place to build a functional
    guessing game app, so we just have to connect them to the GUI interface. Once
    the app can listen for user events so it can respond to the user clicking the
    “Guess!” button, we’ll be ready to run the game!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在我们已经将所有必要的部分都准备好来构建一个功能齐全的猜数字游戏应用程序，所以我们只需要将它们连接到GUI界面。只要应用程序能够监听用户事件并响应用户点击“猜测！”按钮，我们就可以准备运行游戏了！
- en: 'Listening for User Events: Click to Guess!'
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监听用户事件：点击进行猜测！
- en: The last step we need to complete before running the app is to connect the `btnGuess`
    button (labeled “Guess!”) with the function that checks the user’s guess, `checkGuess()`.
    With Java, we can use *event listeners* to do this. Event listeners are just code
    that tells the program to wait, or *listen*, for user interaction *events*, like
    button clicks, mouse movement, or keyboard entries.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行应用程序之前，我们需要完成的最后一步是将“猜测！”按钮（`btnGuess`）与检查用户猜测的函数`checkGuess()`连接起来。通过Java，我们可以使用*事件监听器*来完成这一任务。事件监听器只是告诉程序等待或*监听*用户交互的*事件*，如按钮点击、鼠标移动或键盘输入等。
- en: Go back to the GUI preview of the app by clicking on the Design tab. In the
    GUI preview window, find the “Guess!” button, as shown in [Figure 3-18](ch3.xhtml#ch3fig18),
    and double-click it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击“设计”标签，返回到应用程序的GUI预览界面。在GUI预览窗口中，找到“猜测！”按钮，如[图3-18](ch3.xhtml#ch3fig18)所示，并双击它。
- en: '![Image](../images/f0062-01.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0062-01.jpg)'
- en: '*Figure 3-18: In the Design view, double-click the “Guess!” button to add an
    event listener to the code.*'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-18：在设计视图中，双击“猜测！”按钮以将事件监听器添加到代码中。*'
- en: Double-clicking the “Guess!” button automatically opens the Source tab, where
    you’ll notice Eclipse has added new code. This new code is the skeleton of an
    event listener—in this case, an `ActionListener()` for the event that occurs when
    the user takes an action on the `JButton btnGuess`. In this case, the action is
    clicking the button.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 双击“猜测！”按钮会自动打开源代码标签，在那里你会看到Eclipse已经添加了新的代码。这个新代码是一个事件监听器的框架——在这种情况下，是一个处理用户在`JButton
    btnGuess`上执行操作时触发的事件的`ActionListener()`。在这里，操作是点击按钮。
- en: Eclipse has added everything except the action we want to perform when the user
    clicks the button. Let’s take a look at the event listener code Eclipse has created
    for us.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse已经添加了除我们希望在用户点击按钮时执行的操作之外的所有内容。让我们看看Eclipse为我们创建的事件监听器代码。
- en: JButton btnGuess = new JButton("Guess!");
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: JButton btnGuess = new JButton("Guess!");
- en: ➊ btnGuess.addActionListener(new ➋ActionListener() {
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ btnGuess.addActionListener(new ➋ActionListener() {
- en: ➌ public void actionPerformed(ActionEvent e) {
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ➌ public void actionPerformed(ActionEvent e) {
- en: '}'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: btnGuess.setBounds(172, 149, 89, 23);
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: btnGuess.setBounds(172, 149, 89, 23);
- en: getContentPane().add(btnGuess);
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: getContentPane().add(btnGuess);
- en: The event listener for an `ActionListener()`, the specific listener that handles
    button clicks, is connected to `btnGuess` with the `addActionListener()` method
    at ➊. The next couple of lines of code are all built inside the parentheses for
    the `addActionListener()` function.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActionListener()`事件监听器，专门处理按钮点击事件，通过`addActionListener()`方法与`btnGuess`按钮相连接，如图➊所示。接下来的几行代码都写在`addActionListener()`函数的括号内。'
- en: Inside the `addActionListener()` method, the first thing we see is the keyword
    `new`, letting us know that Eclipse is creating a new object of the `ActionListener`
    class at ➋. What makes this new object different from the ones we’ve seen in the
    past, though, is that it’s an *anonymous inner class*, meaning that it doesn’t
    have a variable that refers to it and it’s created entirely *inside* the `GuessingGame`
    class. Anonymous inner classes can help us code faster since we don’t need to
    build a completely separate class to handle short, quick events like a button
    click. Instead, we can insert the code for an event handler right where we create
    the button. In this case, the `ActionListener` will be listening for just a button
    click, so it’s a perfect candidate for an anonymous inner class.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在`addActionListener()`方法内部，首先看到的是关键字`new`，这让我们知道Eclipse正在创建一个新的`ActionListener`类的对象，位于➋处。然而，和我们以前见过的对象不同的是，这个新对象是一个*匿名内部类*，意味着它没有变量来引用它，并且完全在`GuessingGame`类内部创建。匿名内部类可以帮助我们更快地编写代码，因为我们不需要为处理像按钮点击这样的短小快速事件而创建一个完全独立的类。相反，我们可以直接在创建按钮的地方插入事件处理器代码。在这个例子中，`ActionListener`将仅监听按钮点击事件，所以它非常适合用作匿名内部类。
- en: 'Eclipse creates the skeleton for the anonymous inner class, but we still need
    to code the button’s behavior. This next section of code will go inside the braces
    of the `actionPerformed()` method at ➌. The `actionPerformed()` method is where
    we describe what we want the app to do when the user has clicked `btnGuess`. The
    method accepts an `ActionEvent` as an argument, which is the event, or user action,
    the listener is listening for. In this case we’ve named the `ActionEvent e`, but
    you can use any variable name you’d like. When the user enters a guess and clicks
    the “Guess!” button, that action is assigned to `e`, and we need to check their
    guess with the `checkGuess()` method we created earlier:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Eclipse创建了匿名内部类的框架，但我们仍然需要编写按钮的行为代码。接下来的代码将放入`actionPerformed()`方法的花括号内，位于➌处。`actionPerformed()`方法是我们描述当用户点击`btnGuess`时应用程序应该做什么的地方。该方法接受一个`ActionEvent`作为参数，这是监听器监听的事件或用户操作。在此情况下，我们将`ActionEvent
    e`命名为变量，但你可以使用任何你喜欢的变量名。当用户输入猜测并点击“猜测！”按钮时，该操作会被赋值给`e`，我们需要使用之前创建的`checkGuess()`方法来检查他们的猜测：
- en: btnGuess.addActionListener(new ActionListener() {
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: btnGuess.addActionListener(new ActionListener() {
- en: public void actionPerformed(ActionEvent e) {
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: public void actionPerformed(ActionEvent e) {
- en: checkGuess();
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: checkGuess();
- en: '}'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '});'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: Thanks to Eclipse, the only part we had to add was the `checkGuess();` command.
    The automatic code completion feature has saved us time and helped us avoid typographical
    errors.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Eclipse，我们唯一需要添加的是`checkGuess();`命令。自动代码补全功能帮助我们节省了时间，避免了拼写错误。
- en: With this section of code in place, now we just need to tell the app what to
    do on startup. Take a moment to save your work so far.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这一部分代码，现在我们只需要告诉应用程序在启动时应该做什么。花点时间保存到目前为止的工作。
- en: Setting Up the GUI Window
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置GUI窗口
- en: Before we run the game for the first time, we need to tell the program what
    to do to set up the GUI window. This includes building the GUI interface, starting
    a new game by calling the `newGame()` method, and setting the desired width and
    height dimensions of the window.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次运行游戏之前，我们需要告诉程序如何设置GUI窗口。这包括构建GUI界面，通过调用`newGame()`方法开始一个新游戏，以及设置窗口的所需宽度和高度。
- en: 'Inside the braces for the `main()` method near the bottom of the file, add
    the following lines of code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件底部`main()`方法的花括号内，添加以下代码行：
- en: public static void main(String[] args) {
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: ➊ GuessingGame theGame = new GuessingGame();
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: ➊ GuessingGame theGame = new GuessingGame();
- en: ➋ theGame.newGame();
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: ➋ theGame.newGame();
- en: '}'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: The line of code at ➊ creates a new `GuessingGame` called `theGame`. The line
    at ➋ will start the guessing game with a new random number.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: ➊处的这行代码创建了一个新的`GuessingGame`，名为`theGame`。➋处的代码将启动一个带有新随机数的猜数字游戏。
- en: Now, let’s give Java an idea of the size we want the window to be. For a GUI
    desktop app, we can specify the size of the frame for the app using the `setSize()`
    method, entering the width and height of the window we want to create.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们告诉Java我们希望窗口的大小。对于一个GUI桌面应用程序，我们可以使用`setSize()`方法指定应用程序窗口的大小，输入我们希望创建的窗口的宽度和高度。
- en: public static void main(String[] args) {
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: GuessingGame theGame = new GuessingGame();
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: GuessingGame theGame = new GuessingGame();
- en: theGame.newGame();
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: theGame.newGame();
- en: theGame.setSize(new Dimension(450,300));
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: theGame.setSize(new Dimension(450,300));
- en: The `setSize()` method requires a parameter of the `Dimension` type that’s built
    into the `java.awt` library (`.awt` is short for *abstract window toolkit*). The
    `new Dimension()` inside the parentheses for `setSize()` tells Java to create
    an object of type `Dimension` with width and height parameters of 450 pixels wide
    by 300 pixels tall. But we haven’t imported the `java.awt` library yet, which
    means Eclipse doesn’t know what `Dimension` refers to, so your Eclipse editor
    will tell you there’s an error with this statement by underlining the class name
    `Dimension` in red. If you click the word `Dimension` in the editor, Eclipse shows
    you a list of Quick Fix options, as shown in [Figure 3-19](ch3.xhtml#ch3fig19).
    (If you aren’t able to get the Quick Fix pop-up to display, press CTRL-1 or ![Image](../images/symbol.jpg)-1
    after placing your cursor in `Dimension`.)
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`setSize()`方法需要一个`Dimension`类型的参数，该类型内置在`java.awt`库中（`.awt`是*抽象窗口工具包*的缩写）。`setSize()`括号中的`new
    Dimension()`告诉Java创建一个`Dimension`类型的对象，宽度和高度参数分别为450像素宽和300像素高。但我们还没有导入`java.awt`库，这意味着Eclipse不知道`Dimension`指的是什么，所以你的Eclipse编辑器会通过用红色下划线标出类名`Dimension`来告诉你这里有错误。如果你在编辑器中点击`Dimension`，Eclipse会向你显示一系列快速修复选项，如[图3-19](ch3.xhtml#ch3fig19)所示。（如果你无法弹出快速修复选项，可以按CTRL-1或者![Image](../images/symbol.jpg)-1，光标放在`Dimension`上后再尝试。）'
- en: '![Image](../images/f0065-01.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0065-01.jpg)'
- en: '*Figure 3-19: Eclipse recommends Quick Fix options for the new code we’ve entered;
    choose the top option to import the correct class.*'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-19：Eclipse为我们输入的新代码推荐了快速修复选项；选择顶部选项以导入正确的类。*'
- en: We want to make use of the `Dimension` class that’s already provided in the
    `java.awt` package, so the topmost Quick Fix option, **Import 'Dimension' (java.awt)**,
    is the right one for this situation. Click it, and Eclipse will add `java.awt.Dimension`
    to the list of imported classes at the top of the file.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要使用`java.awt`包中已经提供的`Dimension`类，因此最上面的快速修复选项，**导入 'Dimension' (java.awt)**，是当前情况的正确选择。点击它，Eclipse会将`java.awt.Dimension`添加到文件顶部的导入类列表中。
- en: import javax.swing.JFrame;
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.JFrame;
- en: import javax.swing.JLabel;
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.JLabel;
- en: import javax.swing.SwingConstants;
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.SwingConstants;
- en: import java.awt.Dimension;
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: import java.awt.Dimension;
- en: import java.awt.Font;
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: import java.awt.Font;
- en: import javax.swing.JTextField;
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: import javax.swing.JTextField;
- en: 'Finally, add this line to the `main()` method to make the app visible on the
    screen:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`main()`方法中添加这一行代码，使应用程序在屏幕上可见：
- en: theGame.setSize(new Dimension(450,300));
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: theGame.setSize(new Dimension(450,300));
- en: theGame.setVisible(true);
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: theGame.setVisible(true);
- en: '}'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: This command calls the `setVisible()` method on the `GuessingGame` object `theGame`.
    Remember, `GuessingGame` extended the class `JFrame`, so `theGame` is also a *descendent*
    of the `JFrame` parent class. We want to set the visible property of the main
    `JFrame` holding the GUI version of the guessing game to `true`, which is a Boolean
    value.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令在`GuessingGame`对象`theGame`上调用了`setVisible()`方法。记住，`GuessingGame`继承了`JFrame`类，因此`theGame`也是`JFrame`父类的*子类*。我们希望将主`JFrame`（它承载了猜数字游戏的GUI版本）的可见性属性设置为`true`，这是一个布尔值。
- en: There are only two *Boolean values*, `true` and `false` (both spelled with all
    lowercase letters), and these are used in Boolean expressions. *Boolean expressions*
    are any set of arguments that can be evaluated to `true` or `false`. The `if`
    statements we used in the `checkGuess()` method, like the expression `(guess <
    theNumber)`, are just one example we’ve already seen. When we evaluate this expression
    and check whether `guess` is less than `theNumber`, the expression evaluates to
    either `true` (meaning `guess` is less than `theNumber`) or `false` (`guess` is
    not less than `theNumber`). The result of that Boolean expression determines whether
    the statement following the `if` statement will run.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 只有两个*布尔值*，`true`和`false`（都用全小写字母拼写），它们用于布尔表达式。*布尔表达式*是任何可以被评估为`true`或`false`的参数集合。我们在`checkGuess()`方法中使用的`if`语句，比如表达式`(guess
    < theNumber)`，就是我们已经看到的一个例子。当我们评估这个表达式并检查`guess`是否小于`theNumber`时，表达式的值要么为`true`（意味着`guess`小于`theNumber`），要么为`false`（`guess`不小于`theNumber`）。这个布尔表达式的结果决定了`if`语句后面的语句是否会执行。
- en: 'The complete `main()` method for the `GuessingGame` class is as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`GuessingGame`类的完整`main()`方法如下：'
- en: public static void main(String[] args) {
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: public static void main(String[] args) {
- en: GuessingGame theGame = new GuessingGame();
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: GuessingGame theGame = new GuessingGame();
- en: theGame.newGame();
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: theGame.newGame();
- en: theGame.setSize(new Dimension(450,300));
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: theGame.setSize(new Dimension(450,300));
- en: theGame.setVisible(true);
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: theGame.setVisible(true);
- en: '}'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Time to Play!
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏时间！
- en: With your code complete, now is a good time to save the *GuessingGame.java*
    file. Once you’ve done so, click the run button or select **Run** ▸ **Run** from
    the menu. The game window will appear.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码完成后，现在是时候保存*GuessingGame.java*文件了。保存后，点击运行按钮或从菜单中选择**Run** ▸ **Run**。游戏窗口将会出现。
- en: Try entering some guesses and see if the app works. While you’re playing the
    game, check each component to make sure it works. Make sure to test the “Guess!”
    button, the label at the bottom, and the text field. If you spot problems, go
    back and check your code. Pay attention to when or where the error occurs to narrow
    down the source. You’ll get better at finding errors as you learn to code. [Figure
    3-20](ch3.xhtml#ch3fig20) shows how the app might look when it’s working properly.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试输入一些猜测，看看应用程序是否正常工作。在你玩游戏的时候，检查每个组件，确保它们都能正常工作。一定要测试“猜测！”按钮、底部的标签和文本框。如果发现问题，回去检查你的代码。注意错误发生的时间或位置，以便缩小问题的来源。随着你学习编码，你会更擅长发现错误。[图
    3-20](ch3.xhtml#ch3fig20)展示了应用程序在正常工作时的样子。
- en: '![Image](../images/f0066-01.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0066-01.jpg)'
- en: '*Figure 3-20: The “Guess!” button works!*'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-20： “猜测！”按钮工作正常！*'
- en: When your game is playable all the way through, you’re ready to take the next
    step.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的游戏可以顺利进行到底时，你就准备好迈向下一步了。
- en: Right now, the game is playable, but only until you win. The current version
    of the app doesn’t have the code to tell Java to start a new game every time we
    win the current one.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，游戏是可以玩的，但只有在你赢得一局时。当前版本的应用程序没有代码告诉Java在我们赢得当前游戏后开始新游戏。
- en: First, let’s set it up so we can keep playing the game even after we win once,
    and then we’ll make a few tweaks to the user interface to provide a better user
    experience.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们设置一个机制，即使赢了一局，我们也可以继续玩游戏，然后我们会对用户界面进行一些调整，以提供更好的用户体验。
- en: Adding a Play Again Feature
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加重新游戏功能
- en: Just like we did in the first text-based version of the game, let’s add a play
    again feature. We created a `newGame()` method already, but we only called that
    method when setting up the game for its initial display in the `main()` method
    of the app.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在第一版文字游戏中做的那样，让我们添加一个重新游戏功能。我们已经创建了一个`newGame()`方法，但我们只在应用程序的`main()`方法中调用它来设置游戏的初始显示。
- en: We need to either change the GUI or change the app behavior. We could add a
    Play Again button for the user to click when they want to play another round,
    or we could just make the app automatically start a new game every time the user
    wins.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改GUI或改变应用程序的行为。我们可以添加一个重新游戏按钮，用户点击它来玩下一轮，或者我们可以让应用程序每次用户赢得一局时，自动开始新游戏。
- en: 'The benefit of adding a Play Again button is that it would be easy to understand
    from the user’s perspective. However, we wouldn’t want the Play Again button to
    be visible in the GUI window all the time, because it’s needed only when the user
    wins. One option would be to add a button but make it invisible while the game
    is running, having it become visible only when the user wins. In order to keep
    our game simple, we won’t do this here, but if you’re interested in trying it
    out, see Programming Challenge #2 on [page 73](ch3.xhtml#page_73).'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 添加重新游戏按钮的好处是，从用户的角度来看，它非常容易理解。然而，我们不希望重新游戏按钮在GUI窗口中一直可见，因为它只在用户获胜时才需要。一个选择是添加一个按钮，但在游戏进行时让它不可见，只有在用户获胜时才显示出来。为了保持游戏的简单性，我们这里不会实现这一点，但如果你有兴趣尝试，请参阅[第73页](ch3.xhtml#page_73)的编程挑战#2。
- en: 'Instead of adding a button, let’s change the app’s behavior so that a new number
    is picked automatically after the user wins the current round. This requires changing
    only one section of the program, the `else` statement that handles a guess matching
    the random number. If the user has won a round, a new round should begin automatically.
    This makes intuitive sense—no extra buttons, no decisions to make. If the player
    decides they’re done playing, they can simply close the window. We’ll add this
    behavior by changing the following lines:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算添加按钮，而是改变应用程序的行为，使得用户赢得当前回合后，系统自动选择一个新数字。这只需要修改程序中的一个部分，即处理用户猜测与随机数字匹配的`else`语句。如果用户赢得了当前回合，新的回合应该自动开始。这是合乎直觉的——不需要额外的按钮，也不需要做决定。如果玩家决定不再玩，他们可以简单地关闭窗口。我们将通过修改以下几行来实现这一行为：
- en: else
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: else
- en: message = guess + " is correct. You win!";
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: message = guess + " 是正确的，你赢了！";
- en: 'We’ll call `newGame()` to start a new game. To add the call to the `newGame()`
    method inside this `else` statement, we’ll group two statements (setting the variable
    `message` and calling `newGame()`) together as one block like so:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: else {
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: message = guess +
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '" is correct. You win! Let''s play again!";'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: newGame();
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: The braces group these two statements as a single block of code to be executed
    together whenever the `else` statement is selected as the correct program path.
    Without the braces, only the first line after the `else` statement would be executed,
    and the `newGame()` method would run after the `if-else` statements are evaluated.
    This would make the game change the secret number every time the user tried to
    guess.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that we added `Let's play again!` to the end of the message string.
    This lets the user know that they’re able to play again just by guessing and can
    expect the computer to pick a new number each round. Make these changes, save
    the program, and run it again to see the new version of the game!
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Improving the UX
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you play the game, you may notice a few elements of gameplay that could make
    the user interface even better. For example, if we could have the app accept a
    new guess either when the user clicks the “Guess!” button or when they press ENTER
    from the keyboard, that would provide a more natural and intuitive *user experience
    (UX)*.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: One other problem is that when we want to guess a new number, we have to highlight
    and select the old number (or, alternatively, press the DELETE or BACKSPACE key)
    to clear the previous guess. We also have to click back into the text field, because
    the focus switches to the “Guess!” button. To improve the user interface, we could
    have the cursor return to the text field after each guess and automatically highlight
    or delete the previous guess’s text so that the new guess replaces the old one.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Let’s tackle these two items now.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '*Allowing Users to Press Enter to Guess*'
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first improvement we’ll make is to allow the user to press ENTER
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: to submit their guess. First, go to the Design tab and right-click the “Guess!”
    button. In the pop-up menu, select **Add event handler** ▸ **action** ▸ **actionPerformed**.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Just like when we created an event handler for `btnGuess`, Eclipse will automatically
    add the code to create an action listener for `txtGuess`, as shown in the following
    code snippet. And, just like we did before, we’ll add the `checkGuess()` method
    inside the braces of the `actionPerformed()` portion of this code. The only action
    event we usually want to handle from inside a text field is the user pressing
    the ENTER key.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: txtGuess.addActionListener(new ActionListener() {
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: public void actionPerformed(ActionEvent e) {
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: checkGuess();
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: After you add this line, save the file and run it again. Now when we press the
    ENTER key, it activates the `checkGuess()` method. The “Guess!” button still works,
    so the user has their choice of interacting only by keyboard or with their mouse.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '*Automatically Removing Old Guesses*'
  id: totrans-347
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s solve the issue of having to click back into the text field to delete
    our old guesses. To address this, we’ll need to learn a couple of new methods
    for working with `JTextField` objects like `txtGuess`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: First we have to consider when we want text to be selected. For the guessing
    game, after the user’s guess is evaluated is probably the right time to enable
    the user to guess again. In the code, this would be at the end of the `checkGuess()`
    method, as we want it to occur after the user has made one guess and is ready
    to make another.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: So, we know we need to add code inside the end of the `checkGuess()` method
    to place the cursor back into the `txtGuess` text field and select the text from
    the user’s previous guess. But how do we know which commands would place the cursor
    in the text field and select all the text? This is a great time to use the content
    assist feature in Eclipse. Type the name of the object, `txtGuess`, followed by
    the dot operator (`.`), and Eclipse will display a list of available methods,
    as shown in [Figure 3-21](ch3.xhtml#ch3fig21).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0069-01.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-21: The content assist feature displays all the methods available
    for the JTextField txtGuess*.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see that there are dozens of methods available for working with `JTextField`s
    like `txtGuess`, but the one we’re looking for is `requestFocus()`. The documentation
    for this function says, “Requests that this Component gets the input focus.” The
    *focus* in this case is the cursor. This method will do exactly what we want and
    request that the cursor be placed back in the text field every time the user guesses
    again.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we want to select all the text from the user’s previous guess so that
    their new guess will replace the old one automatically. To select all the text
    in a text field, use the `selectAll()` method, which is also listed in Eclipse’s
    content assist feature suggestions. Add both these lines to the end of the `checkGuess()`
    method, right after the line for `lblOutput.setText(message);` and right before
    the closing brace:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: lblOutput.setText(message);
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: txtGuess.requestFocus();
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: txtGuess.selectAll();
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Now is a good time to save your application. When you try running the game again,
    you should feel a much smoother, more intuitive user experience. The guessing
    game finally has an elegant, easy-to-use GUI that provides a simple UX. Our game
    is easy to play, but a challenge to master. It’s just like the games that we play
    for fun, but we’ve built this one from scratch, using Java and the Swing toolkit
    for a professional appearance.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have a great app all around, except for one important thing: security.
    You may ask, “What? Security? I thought we were just building a fun GUI game!”
    And that’s true—the program works beautifully, but only as long as the user enters
    their numbers correctly.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: What happens if the user’s fingers slip and they press ENTER or click the “Guess!”
    button before they’ve typed their guess? What if they enter any noninteger text,
    like `blah`, as a guess? [Figure 3-22](ch3.xhtml#ch3fig22) shows what happens
    in Eclipse when the user enters bad input.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0070-01.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-22: Bad things happen when the user enters bad data, like blah, in
    the text field.*'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our console window is now filled with errors. The bad input
    resulted in an *exception*—an unexpected or faulty programming situation. The
    first line of output in [Figure 3-22](ch3.xhtml#ch3fig22) tells us there was a
    `NumberFormatException` because the string `"blah"` is not recognized as a number.
    You’ll need to learn how to handle exceptions in the programs you create.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Handling Bad User Input
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java provides a safe way of anticipating and dealing with exceptions, the bad
    things that can happen when a program runs. In addition to bad user input like
    we just discussed, exceptions can include missing files (a file gets deleted,
    or you remove a USB drive unexpectedly) or network problems (such as a missing
    connection or a bad server).
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: We call the code built for dealing with exceptions an *exception handler*. An
    exception handler deals with exceptional situations. But how do we know when an
    exception might occur? Do we have to predict everything bad that could happen
    when a program is running?
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Many of the situations in which errors could occur are particular types of events,
    like user input, file input/output, or network access. For example, think about
    the exceptions we listed previously. Bad user input could happen any time we ask
    the user for input of a certain type. A missing file could be a problem whenever
    we’re reading or writing files; for example, when viewing and saving pictures
    from a photo app. If we can anticipate possible exceptions and write exception
    handlers to deal with those exceptions, our code will be safer, more secure from
    malicious hackers who might want to crash your program by entering bad input,
    and more reliable.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the guessing game, the exception occurred when we asked the user
    for a number, but they entered text instead. Specifically, the exception was triggered
    when we tried to parse an integer out of a string that didn’t contain an integer.
    User input is a common source of exceptions, both accidental and intentional.
    An example of the latter is a hacker trying to break your program.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Java gives us a clean way of handling exceptions with the `try-catch` statement.
    The idea of a `try-catch` block is that we want the program to *try* to do something
    that we know might cause an exception and *catch*, or handle, the exception that
    might occur rather than allowing it to break the program. The `catch` block executes
    only when an exception happens.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: The last part of a `try-catch` is the optional `finally` block. In a `try-catch-finally`
    statement, the `finally` block will *always* execute if it’s provided, regardless
    of whether there’s an exception. If there’s no exception, the `finally` block
    will still run after the `try` block finishes. If an exception occurs, the `finally`
    block will run after the `catch` block has completed.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: 'The format of a `try-catch` typically looks something like this (don’t type
    this into your code; this is just an example of the format):'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: try {
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: // Something that could cause an exception, like getting bad input
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (Exception e) {'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: // Handle or recover from the exception, like asking for good input
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '} finally {'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: // Any wrap-up code; this will always run last, exception or not
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: Notice we group statements for each part of the `try-catch-finally` statement
    with braces, just like we do for `if-else` and loop statements. The `catch` part
    requires an `Exception` parameter; this can be a specific exception, like `NumberFormatException`,
    or we can use the base class `Exception`. This parameter will receive information
    about the `Exception`, like what line number the exception occurred on.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: To place the `try-catch-finally` blocks correctly in our game’s code, we need
    to think about where the exception might occur (and wrap that code inside a `try`
    block), what we want to do if there is an exception (and put that in a `catch`
    block), and what we want to do after either the `try` or `catch` block finishes
    (this part goes inside the `finally` block).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the user input problem occurred when we tried to parse an integer out
    of text the user entered, we want to wrap that code in a `try` block. Let’s put
    the `try` keyword and an opening brace right before the line that parses the integer
    out of the text:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: public void checkGuess() {
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: String guessText = txtGuess.getText();
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: String message = "";
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: try {
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: int guess = Integer.*parseInt*(guessText);
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: if (guess < theNumber)
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user didn’t enter a number, we can’t test for too high or too low, so
    the `try` clause will go all the way to the end of this pair of `if-else` statements.
    Place a closing brace for the `try` block after the closing brace for the `else`
    statement, as shown in the following listing. The `catch` keyword should go next.
    In this game, if a user enters bad input, we just want to ask them to enter a
    whole number between `1` and `100`. We can do that with the `message` string that
    gets displayed in `lblOutput` later. So, the `catch` block should look like this:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: else {
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: message = guess +
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '" is correct. You win! Let''s play again!";'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: newGame();
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '} catch (Exception e) {'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: message = "Enter a whole number between 1 and 100.";
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step we want to take, whether there was an exception or not, is to
    show the output message, request the focus for the text field, and select all
    the text to prepare for the next entry. These three statements will go into the
    `finally` block, after the closing brace of the `catch` statement we just added:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '} finally {'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: lblOutput.setText(message);
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: txtGuess.requestFocus();
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: txtGuess.selectAll();
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: public void newGame() {
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that the statements inside each of the `try-catch-finally` blocks
    are indented to make the code easier to read. Remember, there’s a shortcut in
    Eclipse that will automatically indent everything correctly after you’ve made
    any changes. Just select all the code, then go to **Source** ▸ **Correct Indentation**.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Save your app and run it a few times to test the user interface. Test a few
    nonintegers to make sure the exception handling works the way it’s supposed to.
    If you run into errors that prevent the file from compiling, check your braces.
    Whenever we add blocks around existing code, braces are the first place to check
    for errors. Once your `try-catch-finally` statements are in place, you’ve got
    a more reliable, more predictable, and safer version of the GUI guessing game
    app.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Safe programming isn’t just a nice touch—it’s often a critical part of writing
    good software. For our guessing game, the consequences of bad code don’t seem
    dire. But think about the code running on a medical device, a satellite, a car,
    an airplane, or the power grid that delivers electricity to your home and city.
    Secure code is vital to our safety and security. And even a small game or app
    running unsecure code on your smartphone could expose your data to hackers. Safe
    programming is always a smart practice.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: What You Learned
  id: totrans-409
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the GUI version of the guessing game app, we’ve grown our Java skills to
    include all the following:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: • Creating GUI windows by importing the `javax.swing` package
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: • Setting up a GUI app in Eclipse
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: • Designing a GUI with the WindowBuilder Editor
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: • Using the Properties pane to change GUI component properties
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: • Naming GUI components consistently for easy use in Java code
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: • Connecting GUI elements to Java variables and programming code
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: • Getting user text from a `JTextField` and using it in a program
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: • Listening for user events, like button clicks
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: • Improving the user experience, or UX, by testing the app with the user in
    mind
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: • Handling exceptions with `try-catch-finally`
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Programming Challenges
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try these challenges to review and practice what you’ve learned and to expand
    your programming skills by trying something new. If you get stuck, visit *[https://www.nostarch.com/learnjava/](https://www.nostarch.com/learnjava/)*
    for sample solutions.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '*#1: Showing Users How Many Tries They Took*'
  id: totrans-423
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Try changing the winning message to tell the user how many tries they took
    when they win, as in the following:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: 62 is correct! You win after 7 tries!
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: To accomplish this task, you’ll need to create a new variable (like `numberOfTries`)
    to store how many times the user guessed, add to the number of tries every time
    the `checkGuess()` method runs successfully, and display the number of tries to
    the user when they win.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative version, you could begin the game with seven or eight tries
    and then subtract a try every time the user guesses. When the last guess has been
    used, you could tell the user they lost, show them what the correct number was,
    and start a new game. Give it a shot!
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '*#2: Showing and Hiding a Play Again Button*'
  id: totrans-428
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we built the GUI for this chapter’s guessing game, we decided not to include
    a Play Again button because it would have cluttered the interface when it wasn’t
    in use and it would really only be needed at the end of the game. As it turns
    out, we can hide a GUI component with the `setVisible(false)` method. Then we
    can show it again with `setVisible(true)`, just as we did with our `JFrame`.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: First, we could add a Play Again button, called `btnPlayAgain`, to the GUI layout.
    In the code after the button is created, we could call `btnPlayAgain .setVisible(false)`
    to hide the button. In the winning `else` statement in `checkGuess()`, we could
    call `btnPlayAgain.setVisible(true)` to show the button instead of starting a
    new game. Once you’ve written that code, remember to double-click the button in
    the GUI preview to add an event listener, call `newGame()` in that listener, and
    then hide the button again.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'One important note before you start: unlike with the other button (`btnGuess`),
    you need to change the the `visible` property to hide and show the button from
    several places in the code. As with `txtGuess` and `lblOutput`, you’ll need to
    declare `private JButton btnPlayAgain` at the top of the class, but make sure
    not to redeclare the button in the code below it.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: When you get it working, the game should start with the Play Again button hidden,
    and the button should appear when you win the game. When you click the button,
    a new game will start, and the button will disappear again. Play the game with
    the button, and if you think of any other improvements for the UX, go ahead and
    try them!
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '*#3: Creating a GUI MadLib*'
  id: totrans-433
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Look back at the *MadLibs.java* program you built in [Chapter 2](ch2.xhtml#ch2)
    (Programming Challenge #3 on [page 41](ch2.xhtml#page_41)) and create a new *MadLibGUI.java*
    app that prompts the user for several words in a graphical user interface with
    labels and text fields, like `txtColor`, `txtPastTenseVerb`, `txtAdjective`, and
    `txtNoun`. Add a button that the user can press to generate a MadLibs-style story.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Explore and play around with several more properties of the GUI elements in
    the WindowBuilder Editor, including background colors, fonts, initial text values,
    and more. When the user clicks the button, the program should display the completed
    MadLibs story in a `JLabel` or a `JTextArea`, as shown in [Figure 3-23](ch3.xhtml#ch3fig23).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0074-01.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0074-01.jpg)'
- en: '*Figure 3-23: A GUI MadLibs app*'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-23：一个 GUI MadLibs 应用*'
