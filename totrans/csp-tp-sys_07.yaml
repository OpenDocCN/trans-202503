- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">VALUE
    TYPES AND POLYMORPHISM</samp>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">7</samp> <samp class="SANS_Dogma_OT_Bold_B_11">值类型与多态性</samp>
- en: '![](../images/opener-img.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener-img.png)'
- en: As an object-oriented programming (OOP) language, C# has good support for features
    that allow us to capture complex ideas and express them intuitively, such as classes,
    virtual methods, and inheritance. However, the language support for inheritance
    doesn’t extend to value types. Structs and record structs implicitly derive from
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp> class, which
    is derived directly from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>,
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种面向对象编程（OOP）语言，C# 对一些能够捕捉复杂思想并直观表达的特性提供了很好的支持，如类、虚方法和继承。然而，语言对继承的支持并未扩展到值类型。结构体和记录结构体隐式地继承自<samp
    class="SANS_TheSansMonoCd_W5Regular_11">ValueType</samp>类，而该类又直接继承自<samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>。
- en: but they can’t inherit any other type and can’t themselves be inherited; that
    is, structs and record structs are implicitly sealed. Inheritance is a central
    feature of OOP that enables us to treat a reference to a derived class as though
    it refers to the base class, overriding the base class’s properties and methods
    to have new behavior as needed. These features don’t apply to value types, but
    that doesn’t mean value types are inferior.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但它们不能继承任何其他类型，也不能被继承；也就是说，结构体和记录结构体隐式地是封闭的。继承是面向对象编程的核心特性之一，它使我们能够将对派生类的引用当作对基类的引用来使用，必要时通过覆盖基类的属性和方法来获得新的行为。这些特性不适用于值类型，但这并不意味着值类型就逊色。
- en: Using the term *polymorphism* interchangeably with *inheritance* is common,
    but polymorphism is a more general concept; it relates to writing code that works
    uniformly for a variety of types to reduce duplication. As this chapter discusses,
    inheritance is just one kind of polymorphism, and while there are sound technical
    and semantic reasons for why value types can’t employ inheritance relationships,
    they can take advantage of other kinds of polymorphism.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 常常将*多态性*与*继承*交替使用，但多态性是一个更为广泛的概念；它涉及编写适用于多种类型的统一代码，以减少重复。正如本章所讨论的，继承只是多态性的一种形式，尽管有技术性和语义上的充分理由表明值类型不能使用继承关系，但它们可以利用其他类型的多态性。
- en: 'We’ll explore the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探索以下内容：
- en: Why value types are sealed and why value-like types in general shouldn’t use
    inheritance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么值类型是封闭的，以及为什么一般来说类似值的类型不应使用继承
- en: How subtyping differs from subclassing and why it matters
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类型化与子类化的区别及其重要性
- en: What *type substitutability* means and how it relates to inheritance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*类型可替代性*是什么意思，它与继承有何关系'
- en: Where to use other kinds of polymorphism, rather than inheritance, to model
    relationships between objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模型化对象之间的关系时，何时使用其他类型的多态性，而非继承
- en: <samp class="SANS_Futura_Std_Bold_B_11">Why Value Types Are Sealed</samp>
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">为何值类型是封闭的</samp>
- en: 'The principal technical reason for prohibiting inheritance for structs, and
    by extension record structs, is that they have different lifetime and storage
    characteristics than reference types. The restriction is more than an arbitrary
    rule: it results directly from how value type variables behave in memory, and
    how that behavior differs from reference types.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 禁止结构体及扩展到记录结构体使用继承的主要技术原因是，它们的生命周期和存储特性与引用类型不同。这一限制并非随意规定，而是直接源于值类型变量在内存中的表现，以及与引用类型的区别。
- en: Inheritance between classes allows us to use a reference to a base class type
    to refer to an instance of a derived class, so the static, compile-time type of
    a reference variable isn’t necessarily the same as the dynamic, run-time instance
    type. This characteristic permits *virtual dispatch* for method calls—the mechanism
    whereby the appropriate method implementation will be called based on the actual
    type of the object at run time—and relies on the extra level of indirection afforded
    by references; therefore, inheritance is appropriate only for reference types.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 类之间的继承允许我们使用对基类类型的引用来引用派生类的实例，因此，引用变量的静态编译时类型不一定与动态运行时实例的类型相同。这一特性使得*虚拟调度*成为可能——即根据对象在运行时的实际类型调用适当的方法实现——并依赖于引用提供的额外间接层级；因此，继承仅适用于引用类型。
- en: Value type variables directly contain their data, so we can’t declare a variable
    as one type to represent an instance of a different type, other than via boxing.
    Inheriting from a struct thus makes no sense, and the compiler forbids it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型变量直接包含它们的数据，因此我们不能声明一个变量为某种类型来表示另一个类型的实例，除了通过装箱（boxing）方式。继承自结构体因此没有意义，编译器会禁止这种做法。
- en: Remember, though, that we can use classes to model value-like behavior. As you
    saw in [Chapter 6](chapter6.xhtml), <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    behaves like a value but is implemented as a reference type. The <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    type uses a value-based (rather than identity-based) equality comparison, is immutable,
    and has various other characteristics that identify it as a value. Being a class,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> could support virtual
    method dispatch, but we can’t derive from the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    class because it’s explicitly sealed. This means we can’t create our own augmented
    subclass of <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> any more
    than we could inherit from <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp>, or any other value
    type.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，我们可以使用类来模拟值类型行为。正如你在[第 6 章](chapter6.xhtml)中看到的，<samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    行为像值类型，但它是作为引用类型实现的。<samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    类型使用基于值的（而非基于标识的）相等性比较，是不可变的，并具有其他一些标识其为值类型的特征。作为一个类，<samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    可以支持虚方法调度，但我们不能从 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> 类派生，因为它被显式标记为密封类。这意味着我们不能像继承
    <samp class="SANS_TheSansMonoCd_W5Regular_11">DateTime</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">Guid</samp>
    或任何其他值类型一样，创建我们自己的增强版 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    子类。
- en: Like the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> class,
    records are reference types but have value-like equality behavior. Records can
    derive from other records and can also have virtual methods, so they seemingly
    unify the ideas of values and inheritance. However, using records is not that
    straightforward. We need to note the subtleties and avoid the pitfalls when using
    any inheritance, whether between classes or records.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 像 <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> 类一样，记录是引用类型，但具有类似值类型的相等性行为。记录可以从其他记录派生，并且可以拥有虚方法，因此它们似乎将值类型和继承的概念统一了。然而，使用记录并不是那么简单。我们需要注意细节，避免在使用任何继承时（无论是在类之间还是记录之间）掉进陷阱。
- en: When we allow our types to participate in inheritance relationships, we need
    to be mindful of what deriving from those types might entail. There’s a difference
    between *implementation* and *interface* inheritance. Inheriting an implementation
    presents some of the same difficulties as deriving from a value type. To explore
    why doing so is ill-advised, let’s look at a class with value-like characteristics
    and use implementation inheritance to demonstrate some of the problems that can
    result.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们允许我们的类型参与继承关系时，我们需要注意从这些类型派生可能带来的后果。*实现*继承和*接口*继承是有所区别的。继承实现会带来一些与继承值类型相似的困难。为了探讨为什么这样做不明智，我们来看一个具有值类型特征的类，并使用实现继承来展示可能导致的一些问题。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementation Inheritance</samp>
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">实现继承</samp>
- en: 'Anytime we inherit from a concrete class—that is, one that’s not fully abstract—we
    are, by definition, inheriting its implementation. [Listing 7-1](#list7-1) shows
    a simple inheritance relationship: a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    class derives from a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    base class and adds a new feature of its own.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们从一个具体类继承——即一个不是完全抽象的类——我们本质上是在继承它的实现。[列表 7-1](#list7-1) 展示了一个简单的继承关系：一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> 类从 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 基类继承，并添加了自己的新特性。
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-1: Creating a derived
    class, TranslucentColor, that inherits the implementation of Color</samp>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 7-1：创建一个派生类 TranslucentColor，它继承了
    Color 的实现</samp>
- en: This <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> class
    subclasses the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> class
    and inherits all of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s
    structural representation, along with its methods and properties. Both classes
    have automatic properties, which are each given a backing field of the same type
    as the property—<samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in this
    example—and every field of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    is inherited by <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Even if we’d used private fields in <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    and returned their values via the properties, those fields would be inherited
    by the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> class,
    although they’d still be accessible only via the inherited *public* properties.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation inherited by <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> depends on those
    private fields. An instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    requires its own copies of all the fields declared by its base class so that the
    properties inherited from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    work correctly. We can use <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s
    properties via a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    variable as if they were declared as members of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>,
    as shown here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this simple test, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>
    property of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    variable, which inherited that property from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
    We can also use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>
    property, which was declared as a member of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Using inheritance like this—to reuse the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>—is attractive,
    because it means that the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    type definition doesn’t duplicate <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s
    properties. By deriving from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> class
    gets those properties for free.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Both <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    look like good candidates to be value types because an equality comparison should
    compare each instance’s state. However, making value-based equality behave correctly
    in an inheritance hierarchy hides complexity that can easily result in undesirable
    behavior. To demonstrate that, let’s give <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> value
    semantics by following the recommendations from [Chapter 5](chapter5.xhtml) to
    override <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and its companions
    for both classes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    看起来是很好的值类型候选，因为相等比较应当比较每个实例的状态。然而，在继承层次结构中实现基于值的相等比较会隐藏一些复杂性，这可能会导致不希望出现的行为。为了证明这一点，让我们按照[第5章](chapter5.xhtml)的建议，为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    提供值语义，重写这两个类的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法及其相关方法。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Value-Based Equality
    for Classes</samp>
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">基于值的类相等性</samp>
- en: We begin with the base class, <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
    With the implementation in [Listing 7-2](#list7-2), we can compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances to see whether their properties are equal.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从基类 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 开始。在[清单7-2](#list7-2)中的实现下，我们可以比较两个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 实例，查看它们的属性是否相等。
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-2: Defining value
    equality in the base class, Color</samp>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单7-2：在基类Color中定义值相等性</samp>
- en: This implementation of equality follows common practice for implementing value-based
    equality for classes, including the guidelines given in the Microsoft documentation.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> class implements
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< Color></samp> interface,
    which requires an overload of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method specifically for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
    We use this overload to provide the full implementation, which we can call from
    any other method, including the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method overridden from the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    base class. Since we’ve overridden <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>,
    we also override <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>
    to ensure that two instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    produce the same hash code if they compare equal. Finally, we provide implementations
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> equality operators.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相等性实现遵循了类的值类型相等性实现的常见做法，包括微软文档中的相关指南。<samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    类实现了 <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< Color></samp> 接口，这要求为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 专门重载 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    方法。我们使用这个重载提供完整的实现，可以从任何其他方法中调用，包括从 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    基类重写的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法。由于我们已经重写了
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp>，我们还重写了 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>，以确保两个相等的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    实例生成相同的哈希值。最后，我们为 <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> 和 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">!=</samp> 相等操作符提供了实现。
- en: Let’s examine each step in detail.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细检查每个步骤。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Canonical Form of Equals</samp>
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Equals的规范形式</samp>
- en: First we have to override the virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method inherited from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>,
    as shown in [Listing 7-3](#list7-3). Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    is a class, by default <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    compares object identities, so we need to override that behavior to give <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> a value-based implementation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须重写从 <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> 继承的虚方法
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>，如 [Listing 7-3](#list7-3)
    中所示。由于 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 是一个类，默认情况下 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 比较的是对象的身份，因此我们需要重写该行为，以便为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 提供基于值的实现。
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-3: Overriding Equals</samp>'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-3: 重写 Equals</samp>'
- en: The override of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    must match the base-class signature. In this example, we declare the types within
    a nullable context, so we use <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp>
    as the parameter type for <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    indicating that we know the parameter could be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    and can handle that circumstance safely. Here we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp>
    operator to cast <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> in order to call the type-safe
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method. If <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>
    isn’t a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> or is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, the argument passed will
    be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, which is explicitly
    handled by the type-safe overload in [Listing 7-4](#list7-4).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 的重写必须与基类的签名匹配。在这个例子中，我们在一个可空的上下文中声明类型，因此我们将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> 作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    的参数类型，表示我们知道参数可能是 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，并且能够安全地处理这种情况。这里我们使用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">as</samp> 操作符将 <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>
    强制转换为 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>，以便调用类型安全的 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 方法。如果 <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>
    不是一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 或者是 <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，传入的参数将是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>，这将通过类型安全的重载在 [Listing
    7-4](#list7-4) 中显式处理。
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-4: Implementing IEquatable</samp><
    Color>'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-4: 实现 IEquatable</samp><
    Color>'
- en: The type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> implementation
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< Color></samp>
    interface takes a nullable <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    parameter. This overload will always be preferred over the method taking an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> parameter when we’re comparing
    two variables whose static type is <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>,
    including when we call it from the <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> methods.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 类型安全的 <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> 实现是 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< Color></samp> 接口的一部分，接受一个可空的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 参数。当我们比较两个静态类型为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> 的变量时，包含从 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    或 <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!=</samp>
    方法调用的情况，这个重载方法将优先于接受 <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp>
    参数的方法。
- en: One implication of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    being a reference type is that it’s possible for the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp>
    parameter to refer to the same instance as <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>.
    To handle this scenario, [Listing 7-4](#list7-4) casts both <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    to make it clear that we intend a reference comparison. While the cast we used
    in [Listing 7-3](#list7-3) from <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    to a more derived type is a relatively costly run-time conversion, the conversion
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> to its <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    base class is very efficient and allows the comparison to be made with the intrinsic
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ceq</samp> instruction introduced
    in [Chapter 5](chapter5.xhtml). One alternative would be to use <samp class="SANS_TheSansMonoCd_W5Regular_11">ReferenceEquals(this,
    other)</samp> here, making the reference-based comparison explicit.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Comparing the two variables to see whether they reference the same object is
    a simple but not mandatory optimization. The logical <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>
    operator short-circuits if its left-hand expression is true, so the rest of the
    comparisons are attempted only if <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> are references
    to different instances. Note that the order of comparisons in this code relies
    on operator precedence; the logical <samp class="SANS_TheSansMonoCd_W5Regular_11">AND</samp>
    operator (<samp class="SANS_TheSansMonoCd_W5Regular_11">&&</samp>) has a higher
    precedence than logical <samp class="SANS_TheSansMonoCd_W5Regular_11">OR</samp>
    (<samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp>), so the comparisons
    on the right side of <samp class="SANS_TheSansMonoCd_W5Regular_11">||</samp> all
    bind together as if they were explicitly grouped within a pair of parentheses.
    Although redundant, the extra parentheses don’t affect the behavior in any way,
    and some programmers prefer to add them to avoid having to remember the operator
    precedence rules.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Because <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is a reference
    type, the argument passed could be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    so we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">is not</samp> constant
    pattern to compare <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp>
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> and avoid the common
    trap of calling our own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method recursively.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> class is intentionally
    not sealed, so we also check that the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp>
    value is exactly the same type as <samp class="SANS_TheSansMonoCd_W5Regular_11">this</samp>
    by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp> method,
    defined on the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> base
    class. This method returns the run-time type of an instance, and the types won’t
    match if <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> is a reference
    to a more derived type such as <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
    Objects of different types don’t normally compare equal, even if their types are
    related by inheritance.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if the types match, we compare each property’s value in turn. If they
    all match, our <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>. We use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> rather than <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    here because all the properties of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    are simple <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> values. Built-in
    values such as these can be compared intrinsically, and much more compactly than
    calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    for each of them.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'To make comparing <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances natural, we also implement <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>, which both defer to the type-safe
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method, like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> operator will return
    the result of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> if the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">left</samp> parameter is not <samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>; otherwise, it returns <samp
    class="SANS_TheSansMonoCd_W5Regular_11">true</samp> if both the parameters are
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> operator returns the opposite
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> by inverting the comparisons.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Contract for Equality</samp>
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Implementing equality in a way that is self-consistent is critical. It would
    be a strange state of affairs if we had two references to the same instance of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> that did *not* compare
    equal, and stranger still if <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    could return <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> when comparing
    a value with itself. Equality has a contract similar to the one you saw for less-than
    comparisons in [Chapter 6](chapter6.xhtml). Namely, equality has the following
    characteristics:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '**Reflexive**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> is always <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '**Symmetric**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>, then <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp>.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '**Transitive**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: If <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> *and* <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>,
    then it follows that <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">z</samp>.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '**Safe**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> values are never
    equal to <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '**Stable**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: The result of <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp> doesn’t change as long
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>
    don’t change.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 7-5](#list7-5), we write some tests to prove that we’ve met the
    requirements of the equality contract.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*These tests are presented this way for emphasis, not to demonstrate a good
    style of assertion writing.*'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: The first test also ensures that we’re comparing the variables by value, not
    merely comparing references.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-5: Testing the contract
    for equality for Color</samp>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing a test for comparison stability is more difficult, so in [Listing 7-6](#list7-6)
    we test the opposite: that if one of the values changes, the instances are no
    longer equal.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-6: Testing that equality
    is stable</samp>'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s properties
    are immutable, we can change the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp>
    only by assigning it to a new instance. However, the effect is the same as if
    we had mutated one or more of the properties, because we have arranged for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances to be compared
    by value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'We have one other requirement for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method and its operator counterparts: they must never throw an exception. Our
    implementation has no danger of that, since we have already tested that it is
    safe with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Equality Behavior
    in Derived Classes</samp>
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is to implement equality for the derived <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    class, which, as we know, inherits all the methods and properties from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
    Since <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> is
    a value-like type, it should implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface for itself, substituting the <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>. As
    [Listing 7-7](#list7-7) shows, implementing <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    TranslucentColor></samp> is a little simpler than the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    base class, which already does most of the work.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-7: Behavior inheritance
    in the derived class, TranslucentColor</samp>'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: As with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> implementation,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> overrides
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(object?)</samp> method,
    converting the <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> parameter
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> in order
    to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(TranslucentColor?)</samp>
    method ❶. That method also checks whether we’re comparing two references to a
    single instance and ensures that the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp>
    parameter isn’t <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Since <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> already performs
    the check for identical references, the comparison with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>,
    and the type check, as well as comparing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>
    properties, we don’t need to duplicate those comparisons and can simply invoke
    the base class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    before finally comparing the <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>
    properties that are specific to <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
    Passing <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">base.Equals</samp>
    is fine because a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    reference will convert implicitly to its <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    base class type.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: We also give <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    its own implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp>, and they, too, follow the same
    pattern as in <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, except
    that they take two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    parameters ❷.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The contract for equality applies not only to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    but also to <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
    We can use a test similar to the one from [Listing 7-5](#list7-5) to ensure that
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> meets the
    contract’s requirements. [Listing 7-8](#list7-8) shows a variation on [Listing
    7-6](#list7-6)’s stability check for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    as we test that differences in the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    class’s <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> property value
    will cause instances of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    to compare unequal.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-8: Testing the equality
    contract for TranslucentColor</samp>'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instances differ only in their <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>
    property and correctly compare *not* equal. We might conclude, then, that all
    is right with the world—but we’d be wrong.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Equality Comparisons
    and Type Substitution</samp>
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve used a suite of tests to reassure us that the equality contract is intact
    for both <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> when we’re using
    variables whose dynamic (run-time) instance type is the same as their static (compile-time)
    variable type. However, the types might not always match. The compiler allows
    us to pass a reference to a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    anywhere a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> reference
    is required because <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    is a direct base class of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
    In other words, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type can be *substituted* by a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
    At run time, any <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> reference
    may, in fact, refer to a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instance.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the effect on equality of using a base class reference to a derived
    class instance, [Listing 7-9](#list7-9) explicitly uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    base class reference to declare two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    values that aren’t equal because their <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>
    properties differ.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-9: Testing equality
    from the base class</samp>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'This test fails: the <samp class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">crayon</samp> variables compare
    equal even though the instances have different values. It makes no difference
    whether we compare the variables with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp>
    or call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method;
    the outcome is the same.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The static types being compared are <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    variables, so what’s invoked here is the base class implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>,
    which in turn calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> knows nothing about
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> property of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>, so <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    determines equality by using only the <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>
    properties. Those properties are all identical, so according to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Equals</samp>,
    the two objects are equal.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Those are the mechanics that explain why our <samp class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">crayon</samp> variables incorrectly
    compare equal, but type substitution isn’t always so easy to spot, and its consequences
    are far-reaching.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Effects of Type Substitution</samp>
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We would rarely explicitly use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    reference for a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    object, but we can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    reference as an argument to a method with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    parameter. We can substitute a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    when a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is expected.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-10](#list7-10) shows that if we pass two references to <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    objects that differ only in their <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>
    values to a method with <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    parameters, those parameter variables compare equal within the method. If we pass
    the same two references to a method that takes <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    parameters, the values won’t compare equal even though they haven’t changed.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-10: Testing the stability
    promise</samp>'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: In the first assertion, the <samp class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">crayon</samp> references are
    automatically converted to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    references when we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaBase</samp>
    method because a reference to a derived class is implicitly convertible to a reference
    to any of its base classes. The call to <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    within <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaBase</samp> invokes
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s implementation, which
    incorrectly determines the parameter variables to be equal. The <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaDerived</samp>
    method calls <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor.Equals</samp>
    directly, which correctly reports that the parameter variables are not equal.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'The equality implementation for <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    isn’t stable: it can produce a different result for the same two instances depending
    on the static type of the variable used to refer to those instances, even when
    their underlying state remains unchanged.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Breach of Contract</samp>
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The behavior of the tests in [Listing 7-10](#list7-10) demonstrates that <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> breaks the promise
    of stability established by the contract for equality— namely, that the result
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> doesn’t change
    if the values being compared don’t change. When we compare two variables that
    have different values, they should compare not equal, and as long as no changes
    are made to either variable’s state, the result of the comparison shouldn’t change.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: One problem with our <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    implementation is that the type-specific overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> class isn’t
    virtual, and therefore it can’t be overridden in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
    The virtual version of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    which takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> parameter,
    isn’t considered in overload resolution because the overload with a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    parameter is a much better match, even when the run-time type is derived from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: To get the test in [Listing 7-9](#list7-9) to pass, we could make the type-specific
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method virtual in
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and add an override
    for it in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
    Another possibility would be to remove the implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    so that the only <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    would be virtual. We’d lose the facility for type-specific comparisons, with a
    small performance cost, but this option would address the problem of stability.
    However, either approach would be solving the wrong problem.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: The real underlying problem is that we’ve used inheritance inappropriately,
    not that our implementation of equality is incorrect. To fully appreciate why,
    we need to be clear on the difference between subclasses and subtypes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Inclusion Polymorphism and Subtyping</samp>
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We think of the classes, structs, records, and record structs we write as being
    user-defined types. By extension, then, it’s natural to think that the definition
    of a class is its type. That perception is partially true, but a more formal distinction
    between *type* and *class* exists.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: The polymorphism afforded by using inheritance is known as *inclusion* polymorphism.
    If we were to group all the objects in a system by type, each group of any specific
    type would *include* all the types that inherit from it, known as *subtypes*.
    In our example, the group for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type includes both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> types.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: An object’s type is a contract for its interface and describes the allowable
    operations on the object. The operations defined by a type are, therefore, valid
    for any subtypes in its group. Practically speaking, if we derive from a given
    type, all the operations that are valid for an object of the base type must be
    valid—and behave correctly—for an object of the derived type.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: In our example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    object is an instance of a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type as well as being a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
    This relationship means we can invoke any <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    operation on a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>,
    which in turn means we can pass a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instance to a method taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    parameter. As far as the compiler is concerned, a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    must be able to support all the operations of its base type, so it allows the
    substitution.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The type of an object establishes which operations a subtype must support, but
    it doesn’t specify any structural details or specific implementation. We’re free
    to implement the same interface in different ways, using various classes. However,
    while the contract for a type doesn’t mandate a specific implementation, it does
    define the expected behavior of any of its operations. When we inherit from a
    concrete class, we inherit its implementation, and this sets an expectation for
    that behavior. When implementing a type as a class or record, we must be mindful
    of the distinction between subtyping and subclassing, since we can inherit from
    reference types unless they’re explicitly sealed. For value types in C#, this
    isn’t an issue, because they’re implicitly sealed and so can’t have derived types.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: As noted earlier in this chapter, implementation and interface inheritance differ.
    In other words, simply inheriting from a class isn’t the same as actually respecting
    its behavioral characteristics. Code written in terms of the more general *type*,
    which defines the interface, may well depend on the specific characteristics of
    the *class*, which represents a particular implementation. If the derived class
    doesn’t respect the behavioral aspect of the type’s contract, when we use an instance
    of the derived class in code written for the base type, that code will very likely
    have unexpected behavior.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: When we inherit from a class, we inherit its behavior, characteristics, and
    expectations. A class that inherits from another concrete class is, then, a subclass,
    and only a true subtype if code using the base class *type* can use the derived
    class transparently with no change in observable behavior. When we inherit only
    the type, we have no implementation behavior to consider.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Mechanically speaking, we can substitute a reference to a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    where a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> is required
    because we can use a reference to the derived type as an argument to a method
    expecting the base type. However, as you’ve seen with the behavior of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>,
    using <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instances interchangeably is not really possible.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The lack of substitutability between <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> arises
    because <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    is a *subclass* but not a true *subtype* of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Working with Input
    and Output Types of Virtual Methods</samp>
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The difference between a subtype and a subclass has implications that go beyond
    how an inherited <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method
    is implemented. We can override any virtual method with an implementation that
    is appropriate for the derived class. If the observable effects, including any
    side effects, of calling the more derived method are identical to the effects
    of the base class, then the derived type is a good substitute for its base type—that
    is, the derived type is a proper subtype. Side effects might include writing to
    a file or to the screen, or perhaps updating the value of a variable visible outside
    the method. If a derived class does any of these things when its base class doesn’t,
    it’s not a true subtype.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: A method’s behavior includes what the method considers to be valid inputs and
    outputs—that is, what parameters a method accepts and what it may return—each
    of which directly affects the method caller. To illustrate, suppose we add a virtual
    method to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> class
    like the one in [Listing 7-11](#list7-11) to subtract one <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    value from another.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-11: Adding a virtual
    Subtract method to Color</samp>'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp> method
    is virtual, we can specialize its implementation in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    to handle subtraction appropriately for <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instances. Regardless of the actual algorithm used to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp>,
    its return value is the observable behavior of the method, as long as it has no
    side effects.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp> implementation
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> never returns a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference but the overridden
    version in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    might, then the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    method has a weaker behavioral contract than the base class method. Allowing the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> implementation
    to return a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> value requires
    extra checking in the calling code to avoid <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>-reference
    exceptions. The calling code, knowing only about the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    type, might reasonably expect only non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    values. The weaker requirements on the return type mean that <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    isn’t substitutable for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: A corresponding situation arises when we *strengthen* requirements on the parameters
    in an overridden method. If we insist on non-<samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    values in the derived type but the base class accepts <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    references, we break the contract established by the base class method. Once again,
    code written in terms of the base class has no notion of those requirements in
    derived classes and can easily violate them.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp> method shown
    in [Listing 7-11](#list7-11) mitigates both of these potential problems by using
    the nullable reference type feature available since C# v8.0\. The return type
    of the base <samp class="SANS_TheSansMonoCd_W5Regular_11">Subtract</samp> method
    is non-nullable, and the compiler will warn us if we override it with a method
    having a nullable reference type or if that method attempts to return a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp> reference. Similarly, the
    parameter to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Subtract</samp>
    method is a nullable reference, indicating that <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    is an acceptable argument. If we override the method with a non-nullable reference
    type, the compiler will warn us that the method signature doesn’t match the base
    declaration.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Note that if the base method returns a nullable reference and we override it
    to return a non-nullable reference, the compiler won’t give a warning. That is
    because in this case we’re strengthening the behavioral contract in the derived
    method, and it’s entirely reasonable for the more derived method to prohibit <samp
    class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, even if the base method allows
    it. The requirements on any code calling the method from a base type reference
    aren’t affected.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, the compiler is silent if the base method has a non-nullable parameter
    and we override it to allow a <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>
    reference to be passed to the derived method, because weakening the parameter’s
    contract in the more derived type is safe and reasonable. The change is visible
    only to code using the more derived type *directly* rather than via a base type
    reference.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Upholding a Type’s
    Contract</samp>
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our test for equality using base class references in [Listing 7-9](#list7-9)
    fails because the contract for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Equals</samp>
    isn’t properly fulfilled by the derived class. The expectations set out by <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> aren’t met by <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>,
    which imposes a new requirement on <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    because equality between <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instances must also compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>
    property. Our test fails as a direct result of our using implementation inheritance
    and expecting type substitutability, when in fact <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    isn’t substitutable for a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
    The implications of implementation inheritance apply to all inheritance relationships,
    not just when we’re modeling value semantics.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Upholding a type’s contract matters in practical ways. The behavior of an inherited
    method is part of that contract, and failing to uphold it can result in extremely
    hard-to-diagnose errors. If we fail to meet the *interface* contract of a base
    class—for instance, by using a different signature in an overridden method—the
    compiler will inform us with an error. However, the compiler can’t check that
    we’ve also kept the behavioral promises of a base class. Here we must use our
    own judgment, and that’s not necessarily as straightforward as it might seem.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: One rule of thumb is to avoid implementation inheritance whenever we use inheritance.
    The simplest way to be certain of that is to never derive from a class that has
    any concrete behavior—including abstract classes with any nonabstract methods.
    Types defined with the <samp class="SANS_TheSansMonoCd_W5Regular_11">interface</samp>
    keyword can’t have any implementation, and any class implementing an interface
    is a true subtype.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Another rule is that value types implemented as classes shouldn’t inherit from
    anything and should be sealed. In fact, this second rule arises as a result of
    the first: it makes little sense for a value type to be fully abstract, since
    a defining feature of value and value-like types is that we compare them according
    to the value they represent. It follows, then, that value types are concrete types.
    The built-in value-like class <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    leads the way with this advice, which is why <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    is intentionally a sealed class.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Similar to strings, records are reference types that have value semantics for
    the purpose of comparisons with <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    Unlike strings, records can inherit from other records, but just as when we derive
    from a concrete class, a derived record inherits all the base record’s behavior.
    Therefore, we must still take care to uphold the base record’s promises in a derived
    record; however, as with classes, doing so isn’t always as simple as it might
    seem. Even though records permit inheritance, they’re specifically intended to
    model value types, so the advice to seal value types applies equally to them.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Inheriting Record
    Types</samp>
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When compiled, a record type is a class with some compiler-generated methods,
    including everything required for value-based equality. Moreover, records defined
    using the positional syntax are immutable by default. Using records instead of
    classes for creating value-like types, then, saves us from having to write a lot
    of boilerplate code.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Records, unlike structs, can inherit from other records, although they can’t
    be part of an inheritance relationship with a class. We might therefore recast
    our <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    types as records, as in [Listing 7-12](#list7-12).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-12: Inheriting record
    types</samp>'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Here we define <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> as positional
    records with positional parameters that represent read-only properties with those
    names, and a constructor taking parameters of the same type. The inheritance syntax
    for records differs slightly from that for classes because we need to initialize
    the positional parameters in the base record. The <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    record derives from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    and passes its <samp class="SANS_TheSansMonoCd_W5Regular_11">Red</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Green</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Blue</samp>
    parameter values to the respective positional parameters of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: As we explored in [Chapter 5](chapter5.xhtml), the compiler generates the implementations
    of the constructor and properties for us, along with implementations for various
    overrides of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> and a
    few methods, including a value-based implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">GetHashCode</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>, and others. Equality
    comparisons between record variables compare the value of each property, so two
    record variables are equal if all their properties are equal.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: We can write our own implementation of the type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method created by the compiler if we wish. However, the implementation of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> provided by the compiler
    is specially crafted to take inheritance into account.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Records and the Equality Contract</samp>
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The contract for equality applies to records just as for any other type, and
    the code provided by the compiler ensures that every aspect of the contract is
    respected, including the stability of comparisons via base class references. The
    test in [Listing 7-13](#list7-13) differs from the test in [Listing 7-10](#list7-10)
    in that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> types are records
    rather than classes. Here we compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    record values with different <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>
    properties and assert that they compare unequal whether we compare them directly
    using their concrete type or indirectly via a base class reference.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-13: Equality between
    record types</samp>'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: This test passes, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">pencil</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">crayon</samp> variables compare
    not equal whichever method we call, <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaDerived</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaBase</samp>.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Because the compiler-generated implementation of equality pays particular attention
    to the equality contract, the variables compare not equal whether we use a base
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> record reference or
    the derived <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    reference. In particular, the type-safe implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color.Equals(Color)</samp>
    is virtual in a record implementation and is overridden in the derived <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    record. As mentioned, doing this for our class implementations would make the
    test behave correctly. With records, the compiler injects those implementations
    for us.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: We can override the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    methods ourselves, in which case the compiler won’t synthesize methods whose signature
    matches our own custom implementations. However, if we do so, we must pay the
    same attention to the equality contract as the compiler would in its generated
    version.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: In nonsealed records, the compiler creates a virtual property named <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>,
    which uses <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> to report
    the static (compile-time) type of its containing record. The implementation of
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    record shown in [Listing 7-14](#list7-14) is equivalent to the one generated by
    the compiler, although, as you saw in [Chapter 5](chapter5.xhtml), some implementation
    details differ.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-14: Using the equality
    contract in a nonsealed record</samp>'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: When one record derives from another, as <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    does from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, the compiler
    adds an override of <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>
    in the derived record to report its static type. The compiler-generated implementation
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> in the base class
    checks that the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>
    properties match for both objects. If they don’t, <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Notwithstanding the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>
    property, the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    follows the canonical form shown in [Listing 7-4](#list7-4). Since <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    derives from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">other</samp> parameter could refer to
    an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
    If we attempt to compare a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    record with a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> properties
    won’t match, and the objects will (correctly) compare not equal. Checking the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> property
    is analogous to our original <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    class in [Listing 7-4](#list7-4) checking that <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>
    returned the same type for both objects. Using the static type as <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>
    does has a slight benefit over <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>
    because <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> is evaluated
    at compile time, whereas <samp class="SANS_TheSansMonoCd_W5Regular_11">GetType</samp>
    is evaluated at run time.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> property
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">protected</samp> so that it can
    be overridden by the derived type, but it can’t be called publicly. As [Listing
    7-15](#list7-15) shows, the virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>
    property is overridden in the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    record to return the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-15: Overriding the
    equality contract in the TranslucentColor record</samp>'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> calls
    the base class implementation before comparing the local properties of each object,
    ensuring that the contract properties are always compared. Crucially, the virtual
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Color?)</samp> method is
    overridden in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    and casts its argument to a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>.
    If that cast fails, the argument passed will be <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
    When we compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instances using <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> reference
    variables, as when we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaBase</samp>
    method in [Listing 7-13](#list7-13), it’s this override of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    that’s executed via virtual dispatch.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: If we write our own <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method, it must also compare the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>
    properties because it rarely makes sense for instances of different types to compare
    equal.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp> property
    alone doesn’t solve the problem of comparing two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instances using <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> references.
    Our test in [Listing 7-13](#list7-13) passes because the compiler generates a
    virtual type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and overrides
    it in the derived record. When we call <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    on a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> variable, if the
    run-time instance is a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>,
    we call the more derived implementation. Note that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(TranslucentColor?)</samp>
    method is also virtual, because <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    can itself be inherited. A record deriving from <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    will have compiler-generated overrides of both <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(TranslucentColor?)</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Color?)</samp> alongside
    its own type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: However, equality isn’t the only implementation we can inherit from a class
    or a record. We can define our own virtual and nonvirtual methods for a record
    exactly as we do for a class.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Contracts Other Than Equality</samp>
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The behavioral contract established by a base class or record applies to all
    its methods, not just <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>.
    The compiler generates the right implementations to compare two record instances
    for equality, but we have to supply any other implementations for ourselves. One
    common interface implemented by value types is <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    T ></samp>, which, as you saw in [Chapter 6](chapter6.xhtml), allows us to sort
    collections of value types. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp> records in [Listing
    7-16](#list7-16) are related by inheritance, and each implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    T ></samp> interface by defining a <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-16: Sorting Area
    and Volume records with IComparable</samp>< T >'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will generate the code to implement <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> for both <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>, although we should
    keep in mind that <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    is comparing <samp class="SANS_TheSansMonoCd_W5Regular_11">double</samp> values
    in each case, leading to possible problems, as we discovered in [Chapter 5](chapter5.xhtml).
    However, the compiler doesn’t provide the implementation for <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    T ></samp>, so we must write our own. Here, we define the ordering for <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp>
    so that one object is less than another if its total area is smaller. Similarly,
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>, one is less than
    another if its total volume is smaller. We also add <samp class="SANS_TheSansMonoCd_W5Regular_11">operator<</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">operator></samp> for both <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Area</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>,
    implemented in terms of the <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    method.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: As we explored in [Chapter 6](chapter6.xhtml), ordering comparisons have their
    own contract, and the implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable<
    T ></samp> in [Listing 7-16](#list7-16) effectively suffer the same problems as
    our original implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> interface in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> classes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Although we’re using <samp class="SANS_TheSansMonoCd_W5Regular_11">record</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp> in the declarations,
    we’re still employing implementation inheritance. Subclassing is as much an issue
    for records as it is for classes. We can demonstrate this with a new test in the
    same vein as checking whether two <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instances compare not equal when their <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp>
    properties differ. In [Listing 7-17](#list7-17), two <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>
    instances differ only in their <samp class="SANS_TheSansMonoCd_W5Regular_11">Depth</samp>
    property, but we compare them with <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
    by using references to the base record type.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-17: Testing the contract
    for CompareTo in two Volume instances</samp>'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: This test *fails* because the static, compile-time types of the <samp class="SANS_TheSansMonoCd_W5Regular_11">door</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">window</samp> variables differ
    from their dynamic, run-time types. When we compare them using the base class
    static type, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Depth</samp> property
    of the derived record is ignored, giving an incorrect result.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: As with the compiler implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp>, we could make the implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    virtual in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp> record
    and override it in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>
    type. While doing so would address the immediate problem of this failing test,
    it wouldn’t solve every problem with our implementation. For example, when we
    compare an <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp> with a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>, what should <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    return? An equality comparison between instances that aren’t the same type simply
    returns <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>, but it’s not
    so straightforward for <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>.
    We might choose to compare any <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp>
    as less than any <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>,
    but that too may lead to confusion.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The question of whether an <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp>
    is less than a <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp> is
    not a meaningful one, but disallowing ordering comparisons for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp> types individually
    would be extremely prohibitive; it makes perfect sense to see if one <samp class="SANS_TheSansMonoCd_W5Regular_11">Area</samp>
    is less than another, and likewise for <samp class="SANS_TheSansMonoCd_W5Regular_11">Volume</samp>.
    We can arrange for <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp>
    to throw an exception if the objects being compared have different run-time types,
    but this will add complexity to the calling code and may surprise some users.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: This demonstrates first that records are not a “silver bullet,” and second—and
    more importantly—that we might still be trying to solve the wrong problem.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Avoiding Implementation
    Inheritance</samp>
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our problems with inheriting <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">CompareTo</samp> demonstrate
    why value types don’t make good base types, regardless of whether we use <samp
    class="SANS_TheSansMonoCd_W5Regular_11">class</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">record</samp>
    to define them.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: More generally, inheriting any implemented behavior makes it challenging to
    ensure that code written for the base type will work correctly if we substitute
    an inherited type. Even if we don’t override the base type’s methods, we can’t
    easily guarantee that those methods will work correctly for any derived type.
    While inheritance is a popular mechanism for reusing a base type’s implementation,
    fulfilling the base type behavioral contract in a derived type is often much more
    difficult than it appears.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: One way to ensure that one type can be substituted for another is to avoid implementation
    inheritance entirely. Remember, when we implement an interface, the implementing
    class is truly a subtype of the interface type; there’s no behavioral contract
    to consider because interfaces have no implementation. An interface type defines
    what an implementing type must be able to do but doesn’t prescribe any specific
    implementation. An interface, in effect, defines *only* a type, not a class.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: An interface type can be substituted by any implementing type, so we can use
    different implementations under different circumstances. Code that depends only
    on an interface type—whether as a parameter in a method or a field in a type—is
    completely decoupled from the way that interface is implemented. This means that
    interfaces are *seams*—customization points in our code where we can swap one
    implementation for another.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Code that’s written in terms of interface types rather than concrete implementations
    is more flexible because it doesn’t depend on a particular implementation. It’s
    also easier to test because we can switch out concrete implementations of an interface
    with our own *test double*, sometimes known as a *stub*, *fake*, or *mock object*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: It’s common to see interface types represent the controllers and services described
    in [Chapter 6](chapter6.xhtml), sometimes with several implementations. A specific
    concrete implementation may be selected at run time, perhaps according to configuration
    parameters or the run-time environment. However, code *using* the controller or
    service—frequently in the entity types—doesn’t need to change because its behavior
    depends only on the interface, not the specific concrete type. The controllers
    and services are also where we’re most likely to want a fake implementation during
    testing so that the testing doesn’t need access to an external or expensive resource,
    such as a real database.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: When value types implement one or more interfaces, it’s to define specific protocols,
    such as <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable< T ></samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IComparable< T ></samp>, rather
    than to allow client code to use different implementations. Value types, no matter
    the mechanism we use to implement them, should stand alone and be largely, if
    not wholly, independent of other types in an application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The advice to avoid implementation inheritance leads to the recommendation that
    records should *always* be sealed, because they’re specifically designed for modeling
    value types. Classes should also be sealed by default, whether or not we’re using
    them to model values, and inheritance enabled only when we have a specific design
    rationale for it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Although this advice might seem to limit the flexibility of our designs, we
    can use other ways to define relationships in our code without deriving new types
    from existing ones. Inheritance isn’t the only option for reusing the implementation
    of an existing type to extend its capabilities.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Containing Instead
    of Inheriting Types</samp>
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One way we can use the behavior of one concrete type to implement another is
    to simply *contain* (or *compose*) an instance of the type as a field or property.
    This is especially true when we need a value type, like <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>,
    that’s easily implemented in terms of a simpler type, like <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>,
    but without implying any type substitutability between them. While value types
    should generally be stand-alone, containing another value as a field is one exception
    that’s frequently beneficial.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: We implemented <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> as
    a class and then as a record so we could take advantage of inheritance. Modeling
    values with a <samp class="SANS_TheSansMonoCd_W5Regular_11">class</samp> is not
    unreasonable—and, as we know, records are specifically provided for that purpose.
    But if we contain a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> instead
    of deriving from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, using
    <samp class="SANS_TheSansMonoCd_W5Regular_11">struct</samp> to implement both
    types is much simpler. Using <samp class="SANS_TheSansMonoCd_W5Regular_11">record
    struct</samp> is even simpler still, as we do in [Listing 7-18](#list7-18), where
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> contains
    an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-18: Containing Color
    rather than inheriting from it</samp>'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the compiler provides the implementation for <samp class="SANS_TheSansMonoCd_W5Regular_11">IEquatable<
    T ></samp> for each type, leaving us to define just the properties and behavior
    for them. The <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    type contains a read-only <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instance, and we add a new constructor as a convenience for our users, who can
    either create a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    value to pass to <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>’s
    generated constructor or call our new constructor with each component part separately.
    We also mirror <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>’s properties
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> and forward
    them to the contained <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    value. We don’t get those properties for free, but they afford users of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> a much more natural
    interface, like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The alternative would force users to explicitly obtain the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    property in order to access its properties, like so:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Whether we use structs or define our value types with sealed records or classes,
    or record structs, testing our new types is much simpler to reason about now,
    as we don’t need to consider cases where <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instances are referred to by <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    references. That in itself is a large consideration because those tests will be
    not only easier to write but also easier to read by the next programmers who visit
    the code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Composing types isn’t a perfect match for the version that employed inheritance,
    because we can’t use a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instance as an argument to a method expecting a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
    As you’ve seen, sometimes that substitutability isn’t appropriate.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance isn’t the only form of polymorphism nor the only mechanism that
    exhibits type substitutability, but other approaches allow the compiler to inform
    us when we incorrectly substitute one type for another. Let’s take a look at some
    of them.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Parametric Polymorphism with Generics</samp>
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C# generics offer *parametric polymorphism*, a form of polymorphism that allows
    us to write code once that works for multiple types by using generic type parameters
    instead of actual types. This approach provides a common form and purpose for
    all the types that can be substituted for those parameters.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: This is most clearly demonstrated by the generic collection classes in the Standard
    Library, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">List< T ></samp>,
    where <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> is a generic parameter
    type that can be substituted by *any* run-time type, including any types we define
    ourselves. For example, in [Listing 7-19](#list7-19) we declare two <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    T ></samp> variables parameterized with different, unrelated types.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-19: Using a generic
    type</samp>'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Although the <samp class="SANS_TheSansMonoCd_W5Regular_11">List</samp> implementation’s
    behavior doesn’t change, a <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    Color></samp> is a distinct type from <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    string></samp>, and there’s no relationship between the two types. The generic
    <samp class="SANS_TheSansMonoCd_W5Regular_11">List< T ></samp> code is written
    in terms of the <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> generic
    parameter, and since <samp class="SANS_TheSansMonoCd_W5Regular_11">List< T ></samp>
    doesn’t need to know anything about the structural or behavioral characteristics
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, it can be used with
    any type.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: To put that another way, in the context of <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    T ></samp>, any type can be substituted for the <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    parameter without implying any subtype relationship. We have no behavioral contract
    to take into account, because <samp class="SANS_TheSansMonoCd_W5Regular_11">List<
    T ></samp> makes no assumptions about <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: If we need to be more selective about the types that are suitable for a generic
    parameter type in our own generic code, or if we require the generic code to use
    methods and properties beyond those provided by <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>,
    we can constrain the parameter to allow only types having specific behavior.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generic Constraints
    and Protocol Interfaces</samp>
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> is the base
    class of every type, generics can use its methods via a variable of type <samp
    class="SANS_TheSansMonoCd_W5Regular_11">T</samp>, but to access anything else,
    the compiler needs more information on what <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    can be. We provide that information through generic type constraints. One example
    is an interface constraint, which restricts <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    to a type that implements the specified interface, ensuring that all interface
    operations are legal for a variable of that generic type. Consider, for instance,
    the interface shown in [Listing 7-20](#list7-20).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-20: A contract interface</samp>'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The generic <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp>
    interface defines a single <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp>
    method for turning a string value into an object instance of type <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> parameter in <samp
    class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp> is unconstrained,
    so this interface can be implemented by any type. In [Listing 7-21](#list7-21),
    we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp> interface
    to constrain the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    parameter of the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    generic class.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-21: Constraining
    a type for its API</samp>'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> class has
    two generic parameters. The <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    parameter is constrained to the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T ></samp> interface in the <samp class="SANS_TheSansMonoCd_W5Regular_11">where</samp>
    clause following the type definition. <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    is constrained using the second generic parameter <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>,
    which also corresponds to the return type from the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    method, meaning that <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    can be substituted by an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    TResult ></samp>. The constructor for <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    takes a <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> parameter,
    so the argument passed must be an implementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T ></samp>, with the <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> substituted
    by the same type as the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>
    parameter for <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    constructor takes a sequence of string values to represent the input values, but
    in a real application, <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    might be obtaining its data from a database or more elaborate source.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The interface type constraint on the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    generic type parameter enables us to call <samp class="SANS_TheSansMonoCd_W5Regular_11">parser.Parse</samp>
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> method, which
    returns a sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>
    elements. Without the <samp class="SANS_TheSansMonoCd_W5Regular_11">where</samp>
    constraint for <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> method would fail to
    compile because <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> has
    no <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> method.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp> interface
    in [Listing 7-20](#list7-20) isn’t intended to be used as the type of a variable;
    rather, it’s a contract interface whose purpose is to describe the *protocol*
    for parsing a string into an object. We even use <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    as the type of a field in the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    class rather than declaring the field as <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T ></samp>.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The presence of the constraint on the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    generic parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    means that we can create a <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    only by providing an implementation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T ></samp> protocol. The constraint guarantees that whatever type is substituted
    for <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> at run time will
    have a <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> method whose
    signature matches the operation defined in the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T ></samp> interface.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Implementing the IParser<T>
    Protocol</samp>
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp> interface
    is itself generic, allowing an implementing type to specify the return type from
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> method. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> class in [Listing 7-22](#list7-22)
    implements <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< Color></samp>
    to convert a string to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    object. In this example, the input string represents each color component as a
    two-digit hexadecimal value, so the entire value is in the format <samp class="SANS_TheSansMonoCd_W5Regular_11">"RRGGBB"</samp>.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-22: Implementing
    a contract interface</samp>'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> method of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> class uses the
    range operator syntax, introduced in C# v8.0, on the <samp class="SANS_TheSansMonoCd_W5Regular_11">input</samp>
    parameter to split the string into three parts of two characters each. A range
    like <samp class="SANS_TheSansMonoCd_W5Regular_11">[begin..end]</samp>, also called
    a *slice*, specifies a substring from the <samp class="SANS_TheSansMonoCd_W5Regular_11">begin</samp>
    index up to but not including the <samp class="SANS_TheSansMonoCd_W5Regular_11">end</samp>
    index. Ranges can also be used with arrays to specify a subrange of the array.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp>
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*A* range *is a half-open interval of indices and would more properly be written
    [begin..end), but C# syntax doesn’t allow nonmatching brackets or parentheses.
    Be careful not to confuse this syntax with the Enumerable.Range method, which
    takes the starting index and a count of items to include as its parameters.*'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Parameterizing the DataAdapter
    Class</samp>
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> implements
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp> interface,
    we can use a <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> class,
    as shown in [Listing 7-23](#list7-23).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-23: Using the generic
    type</samp>'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: While the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> class
    itself is written in a polymorphic way (inasmuch as it works on any type implementing
    the required <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp>
    protocol), using it requires us to explicitly indicate the concrete type we’re
    substituting for both the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    parameter and the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>
    parameter type to be returned by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    method.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'This prevents us from accidentally using <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> parameter
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> along with
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> class like
    this:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp> class
    is specific to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> types
    because it implements the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    Color></samp> interface. The compiler will catch such transgressions and report
    an error:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> generic
    parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    is already implied by the concrete type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T ></samp> implementation we provide, as it must be the same type that’s returned
    by <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">.Parse</samp>. The type constraint we
    used for the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> generic
    parameter for <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    in [Listing 7-21](#list7-21) makes this relationship explicit:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Since we’ve gone to the trouble of ensuring that the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    class can work with any <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T ></samp> implementation, having to specify which implementation we mean seems
    superfluous. Instead, we can have the compiler deduce the correct type for the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp> parameter based on
    the actual type we use.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generic Method Parameters
    and Type Deduction</samp>
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although the compiler doesn’t infer the actual type for any parameters of a
    generic class, it may do so for a generic method if a generic parameter type is
    used in the method’s formal parameters. Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    type parameter is used only by the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter.Read</samp>
    method, we can move it from the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    class and add it instead to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    method, making <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> a generic
    method, as shown in [Listing 7-24](#list7-24).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-24: Defining DataAdapter.Read
    as a generic method</samp>'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> no longer
    needs a field to store a <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    object since it’s passed to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    method. The generic method still requires the interface constraint so that we
    can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp> method
    via the <samp class="SANS_TheSansMonoCd_W5Regular_11">parser</samp> variable,
    but we don’t need to specify the type of the parser argument when passing it;
    the compiler infers the type of <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    based on the argument we pass to <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>,
    as shown in [Listing 7-25](#list7-25).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-25: Parameter type
    inference</samp>'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: We mention the <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp>
    type just once, when we create an instance of it to pass to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    method. Compare this with [Listing 7-23](#list7-23), where we not only required
    an instance of <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp>
    but also needed to specify its type for the <samp class="SANS_TheSansMonoCd_W5Regular_11">TParser</samp>
    parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>.
    By taking advantage of the type inference afforded by a generic method, we avoid
    the redundant code.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parameterized Types</samp>
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We still need to specify <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    for the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> parameter
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> in [Listing
    7-25](#list7-25), even though <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>
    is used only by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    method. The compiler can only infer the real type of a generic parameter from
    the arguments we pass to a method, and <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>
    isn’t used as the type for any parameter in <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>.
    If a method has generic parameters, they must all be either explicitly specified
    or deduced from the arguments; the compiler won’t partially deduce the types just
    from available arguments.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: However, this is a benefit of the <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    class, because it ensures that the <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp>
    parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp>
    matches the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> parameter
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>. If we want
    a different type to stand in for <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>,
    we need a different parser implementation. In [Listing 7-26](#list7-26), we implement
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp> interface
    in a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> type
    and create a <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>
    for the new type.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-26: Parameterizing
    DataAdapter with a different type</samp>'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: We specify <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> to implement
    <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser< T ></samp> in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColorParser</samp> class, and
    we specify <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    as the type for the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>
    parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColorParser</samp>
    implementation uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorParser</samp>
    object to parse the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    portion of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    as a convenience, but otherwise it’s an entirely new type. Similarly, the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter< TranslucentColor></samp>
    type is unrelated to <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter<
    Color></samp>.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp> class is
    polymorphic according to the type we provide as an argument for its <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp>
    parameter because that type affects what the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    method returns. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp>
    method is itself polymorphic, as it has its own generic parameter. We need to
    write the <samp class="SANS_TheSansMonoCd_W5Regular_11">Read</samp> method only
    once, and it works for any type that implements <samp class="SANS_TheSansMonoCd_W5Regular_11">IParser<
    T ></samp>, where <samp class="SANS_TheSansMonoCd_W5Regular_11">T</samp> matches
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">TResult</samp> type of <samp
    class="SANS_TheSansMonoCd_W5Regular_11">DataAdapter</samp>.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: We can think of a generic method as representing multiple method overloads,
    each with different parameter types but all having an identical implementation.
    Even without generics, overloaded methods represent their own kind of polymorphism,
    known as *ad hoc polymorphism*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Ad Hoc Polymorphism with Overloading</samp>
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ad hoc polymorphism, or *method overloading*, is how we define a family of operations
    that have the same name but differ in the type or number of their parameters.
    The compiler selects the correct method overload based on the method name and
    the arguments we use to call it. Each method can have a different implementation,
    so the method *name* is polymorphic with respect to its parameters.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: You’ve seen a few examples of overloading instance methods in this and other
    chapters, where we’ve overridden the virtual <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method and then overloaded it with a type-safe implementation. The compiler will
    select the type-safe overload of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    if the static type of the argument matches the implementing type rather than being
    an <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> or another type.
    In a record struct, the compiler provides implementations for both methods, although
    we can provide our own type-safe <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    if we wish. [Listing 7-27](#list7-27) shows how using different arguments changes
    which method is called when the variables being compared are value types.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-27: Selecting method
    overloads</samp>'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: The first assertion, which compares the <samp class="SANS_TheSansMonoCd_W5Regular_11">plum</samp>
    variable with <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>, will
    call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method override
    with an <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp> parameter
    because <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> is a reference
    type, and <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp> will automatically
    convert to a reference parameter. In the second assertion, the method taking a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> as its parameter is
    a better match for the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp>
    argument because the types match exactly, so the type-specific overload is called.
    If <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> were a record instead
    of a record struct, both assertions would directly invoke the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals(Color)</samp>
    overload, since in that case <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    would be a reference type but a more specific one than <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>,
    making it a better conversion target for overload resolution when the argument
    is <samp class="SANS_TheSansMonoCd_W5Regular_11">null</samp>.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: When we call an overloaded instance method, the compiler identifies the candidate
    methods by using the static type of the variable used to invoke the method. The
    candidate methods may include extension methods with the same name if they’re
    in scope where the method is called. It’s always the invoking variable that determines
    how the list of possible overloads is selected, and the arguments passed determine
    the specific overload from that candidate list. In [Listing 7-28](#list7-28),
    we change the static type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">plum</samp>
    variable to be <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp> instead
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> before calling its
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-28: Argument type
    versus invoking type</samp>'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'The candidates for <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    are selected from the methods defined on <samp class="SANS_TheSansMonoCd_W5Regular_11">object</samp>
    because that’s the compile-time type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">plum</samp>
    variable. We have only one such method, which takes a parameter of <samp class="SANS_TheSansMonoCd_W5Regular_11">object?</samp>,
    so that’s automatically a match, even though the <samp class="SANS_TheSansMonoCd_W5Regular_11">other</samp>
    argument is a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">plum</samp> is still a reference
    to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> that has an overloaded
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> method taking a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> parameter. The same would
    be true if <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> were a reference
    type: the type-specific overload isn’t even considered during overload resolution
    because it’s not a member of the type of the variable used to call the method.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Static methods can be overloaded too, although the candidate overloads are identified
    from the type name used by the caller. In either case, from this list of candidates,
    called a *method group*, the compiler chooses the best match according to the
    arguments being passed.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: If no match is found—that is, the arguments aren’t implicitly convertible to
    any of the parameter types—or there are multiple equally good candidates with
    no single best match, our program fails to compile.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Symbolic Polymorphism
    with Overloaded Operators</samp>
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Overloading can be especially powerful in conjunction with custom operators.
    It’s common for value types to overload <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    to correspond with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    method. Not only is this more compact, but it also looks more natural to compare
    values with <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> than to compare
    them by calling a method.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to write our own operator implementations for structs, but the compiler
    provides <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> for records and record structs,
    making it convenient to compare two variables of the same type like this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We’re not permitted to alter the implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp>
    or <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">=</samp> synthesized by the compiler for
    records and record structs, but we can add overloads of them to accept different
    types, just as we can with other methods. For instance, in [Listing 7-29](#list7-29),
    we overload <samp class="SANS_TheSansMonoCd_W5Regular_11">operator==</samp> for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> to permit comparisons
    between a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> and an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">int</samp>.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-29: Overloading operators</samp>'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add a corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">operator</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">!</samp><samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp>
    for each overload (not shown here). These overloads are a convenience for users,
    who don’t need to explicitly construct <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances in order to compare them with their raw <samp class="SANS_TheSansMonoCd_W5Regular_11">RGB</samp>
    value and who can compare values like this:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Overloading operators isn’t essentially different from overloading other methods,
    but rather than using named methods, we’re overloading *symbols* to behave in
    a polymorphic way with our types. A good example of symbolic polymorphism is embodied
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> class, which
    defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> symbol to mean
    concatenation rather than addition. This is a widely accepted convention familiar
    to most programmers.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: We should be cautious of introducing our own operations that don’t follow the
    usual rules. Overloading methods, and especially operators, requires careful thought
    and a hefty dose of what we might call “good taste.” Families of methods overloaded
    for different types give the impression of type substitutability by giving one
    common name to an operation that may be implemented differently for each type.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'The <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp> class doesn’t,
    for example, allow us to add a number with a string, for the simple reason that
    the type of the result may be misinterpreted: should <samp class="SANS_TheSansMonoCd_W5Regular_11">"5"</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp>
    be the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">0.5</samp> <samp
    class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">"5"</samp>?
    The designers of the <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    class decided to disallow either use to avoid any potential confusion.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Generic Delegates
    for Polymorphism</samp>
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *delegate* is a type that represents a method with a specific signature—the
    type and number of parameters—and a delegate object can be constructed from different
    methods as long as the signature matches the delegate type. Delegates are a central
    feature of the LINQ libraries; for example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    method takes a delegate parameter to represent the method for transforming one
    element of a sequence into a different type. We most commonly see lambdas being
    used as the arguments for methods with delegate type parameters, as shown in [Listing
    7-30](#list7-30).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-30: Passing a lambda
    for a delegate parameter</samp>'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> is an extension
    method for <samp class="SANS_TheSansMonoCd_W5Regular_11">IEnumerable< T ></samp>,
    and here we call it via the <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp>
    variable, passing a lambda to represent a method taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    parameter, since that’s the element type of the <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp>
    sequence. The lambda is invoked for each element in the sequence and returns a
    hexadecimal representation of the value as a string formatted to <samp class="SANS_TheSansMonoCd_W5Regular_11">"RRGGBB"</samp>—the
    reverse operation of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Parse</samp>
    method defined in [Listing 7-22](#list7-22).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Inline lambdas like the one in [Listing 7-30](#list7-30) are convenient but
    generally lack the flexibility offered by method overloads. For example, if we
    change the element type of <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp>
    to be <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> instead
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, our code still
    compiles, and the lambda implementation will continue to work with the <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    type defined in [Listing 7-18](#list7-18), but the result won’t have the extra
    2 bytes for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> property.
    We have to write a new lambda for <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>,
    and if we need to support both <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> elements,
    we have to handle them separately.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: Overloaded methods are a perfect way to capture the common purpose we need while
    simultaneously enabling us to encapsulate the different implementations required.
    Consider the two static methods in [Listing 7-31](#list7-31).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-31: Overloaded methods
    for different types</samp>'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format(TranslucentColor)</samp>
    method’s implementation calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format(Color)</samp>
    overload—something we couldn’t do with separate anonymous lambda expressions.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Rather than passing a lambda as the argument for <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>,
    we can pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format</samp> method
    group, as shown in [Listing 7-32](#list7-32).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-32: A method group
    as an argument</samp>'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">Formatter.Format</samp>
    is the common name for two method overloads and represents a method group. The
    compiler selects the correct overload in the group based on the element type of
    the sequence used to call <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>.
    The delegate parameter for <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    is a generic delegate—that is, one that has its own generic type parameters. Like
    generic methods, the compiler will infer the actual types based on the arguments
    passed to the delegate.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">Formatter.Format</samp> method
    group is polymorphic according to the arguments that are passed by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    method internally. Here, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format(TranslucentColor)</samp>
    method from [Listing 7-31](#list7-31) is called because the element type of the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp> sequence is <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>. If we changed
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">colors</samp> variable to be
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">List< Color></samp> instead, the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp> method would call
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Format(Color)</samp>, but without
    us needing to change the <samp class="SANS_TheSansMonoCd_W5Regular_11">Select</samp>
    expression in any way.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Coercion Polymorphism Using Conversions</samp>
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ve seen, inheritance allows us to use a reference to an instance of one
    type when a different type is expected, as long as the first type inherits from
    the second type. A derived class is syntactically substitutable for its base class
    because there’s a natural implicit conversion from a specific type to any of its
    parent types.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: We can implement our own type conversions to mimic substitutability between
    two otherwise unrelated types. Casting—or *coercing*—a variable to a different
    type can be convenient, whether via implicit or explicit conversions, but doing
    so may mask problems beneath the surface. However, applied carefully, conversions
    between unrelated types can be an effective and concise way to express a design.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate some of the problems with implicit conversions that we haven’t
    yet explored, [Listing 7-33](#list7-33) implements an implicit conversion operator
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> to convert
    an instance to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-33: Implicit conversion
    operator</samp>'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'The conversion operator in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    is an *outward* conversion: we’re converting from an instance of the implementing
    type to something else. It will allow us to call a method expecting a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    value when we have a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    at hand, as we do when we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaColor</samp>
    method in [Listing 7-34](#list7-34).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-34: Implicit conversions
    in action</samp>'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Owing to the implicit conversion operator, the <samp class="SANS_TheSansMonoCd_W5Regular_11">red</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">blue</samp> variables are converted
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> instances when we
    pass them as arguments to the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualViaColor</samp>
    method. The conversion happens invisibly because the conversion operator is defined
    as <samp class="SANS_TheSansMonoCd_W5Regular_11">implicit</samp>.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: We could achieve the same effect by defining an inward conversion operator on
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type taking a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> parameter. The
    difference is merely about where we choose to define the operator. Since <samp
    class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> already depends
    on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> type, and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> otherwise has no knowledge
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>, the
    outward conversion defined in <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    makes better sense here.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: However, we must be careful with all conversions, especially implicit ones.
    As you saw in [Chapter 1](chapter1.xhtml), implicit conversions may hide complexity
    and can even lead to undesired behavior. A user-defined coercion is not quite
    the same as the implicit reference conversion from a derived type to its base
    type.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Widening vs. Narrowing
    Conversions</samp>
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> inherited
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, we could pass
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> reference
    to a method expecting a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>,
    but it was still a reference to the same instance of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>,
    and only a copy of the reference would be made. In [Listing 7-33](#list7-33),
    <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> are record structs and therefore
    value types. When we invoke the conversion operator of <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>,
    we’re simply creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instance, so the copy has lost some of the information specific to <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>—namely,
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Alpha</samp> property.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'A conversion from a derived class reference to a base class reference is a
    *widening* conversion. We can refer to a specific instance by using a more general
    (base) type, but no loss of information occurs. We’re still able to explicitly
    cast the base class reference back to the original derived instance, although
    that’s a relatively expensive run-time operation. Our implicit conversion from
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp> struct
    to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> via our own operator
    method is *narrowing*: neither type is really more specific or general than the
    other, and they’re independent values, but the act of conversion loses information.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: While we’ve replicated the behavior of converting from a derived class to a
    base class, it doesn’t give us the same flexibility. The converted value really
    *is* just a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, and we
    need other means of capturing the extra properties of a <samp class="SANS_TheSansMonoCd_W5Regular_11">TranslucentColor</samp>
    if we need to reinstate them.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Conversions aren’t appropriate for trying to replicate the characteristics of
    inheritance, but they can be useful for other scenarios.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">For Representation</samp>
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Conversions between unrelated types make more sense when the types have a common
    meaning with different representation. For instance, we might need to use an external
    API that uses the common <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    representation of the hexadecimal RGB value of colors. Changing a value’s representation
    is usually better implemented as an explicit rather than implicit conversion,
    as shown in [Listing 7-35](#list7-35). However, any conversions—whether explicit
    or implicit—require careful consideration of alternate approaches.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-35: Converting to
    a different type representation</samp>'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 7-36](#list7-36), we test the explicit conversion operator’s implementation
    by casting the <samp class="SANS_TheSansMonoCd_W5Regular_11">plum</samp> value
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in order to pass it
    as an argument for a method taking an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    parameter.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-36: Testing an explicit
    conversion</samp>'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'This local <samp class="SANS_TheSansMonoCd_W5Regular_11">Converted</samp> function
    takes an <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> parameter and,
    for the purposes of the test, simply returns its parameter value. Since the conversion
    operator is explicit, we must cast the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    value when we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Converted</samp>
    method; the compiler will complain if we try to use a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    value directly as an argument for <samp class="SANS_TheSansMonoCd_W5Regular_11">Converted</samp>.
    The compiler will also catch any unintentionally inappropriate expressions like
    this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If we had made the conversion operator implicit in <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>,
    this code would compile but would compare two <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    values, probably with unexpected results.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: The cast to <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> in [Listing
    7-36](#list7-36), while explicit and obvious in the code, doesn’t say much about
    the intention behind the conversion, which is implied to some extent by the use.
    We might consider replacing an explicit outward conversion like this with a method
    or property that more definitively describes the intent of the conversion, perhaps
    by calling it <samp class="SANS_TheSansMonoCd_W5Regular_11">ToWebColor</samp>.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Naming the conversion allows us to better express what we mean and why, making
    the code more self-documenting without being overly intrusive or syntax-heavy
    compared to an explicit cast. One frequently overlooked consequence of using a
    named property instead of a cast is that the property name is easier to search
    for, should we need to find everywhere it’s used.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">For Purpose</samp>
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Conversion operators, even implicit conversions, aren’t exclusively a bad choice.
    Conversions are commonly used to allow a value to be represented by unrelated
    types that support different operations, although the value itself has a common
    representation. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    is an immutable value type, but we might want to build up its value incrementally.
    A <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> has multiple properties,
    and sometimes setting them individually might be more convenient than setting
    them all at once in a constructor.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Rather than compromising the immutable nature of <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    by adding <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessors for
    its properties, we introduce a new companion type that looks very much like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, except that it allows its
    properties to be changed. When the values are in their final state, we can then
    materialize an instance of the mutable type into an immutable <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
    Key to this is that we can easily convert from the companion type to the target
    value type. [Listing 7-37](#list7-37) shows such a *mutable companion* type for
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> that allows an implicit
    conversion to the immutable target value.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-37: A mutable companion
    for Color</samp>'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp> type isn’t
    itself a value type; its sole purpose is to provide a kind of factory for <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> values.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Applications of the *Mutable Companion* pattern are fairly common, and we see
    it in the Standard Library with <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp>. The <samp
    class="SANS_TheSansMonoCd_W5Regular_11">string</samp> type is immutable, and when
    we need to build up a <samp class="SANS_TheSansMonoCd_W5Regular_11">string</samp>
    variable from several parts, using its mutable companion, <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp>,
    is efficient. When we’ve finished “building” the string, we turn it into its *immutable*
    state.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Unlike with <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp>,
    we must call the <samp class="SANS_TheSansMonoCd_W5Regular_11">ToString</samp>
    method of <samp class="SANS_TheSansMonoCd_W5Regular_11">StringBuilder</samp> to
    turn it into a string, but an implicit conversion can be used to good effect here.
    Since <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp> is implicitly
    convertible to a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>, we
    can call a method taking a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    parameter with a <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp>
    value, as we see in [Listing 7-38](#list7-38), where we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">RelativeLuminance</samp>
    method with both a <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> value.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 7-38: Converting a
    companion type</samp>'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: The implicit conversion operator we defined for <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp>
    in [Listing 7-37](#list7-37) permits us to pass the mutable <samp class="SANS_TheSansMonoCd_W5Regular_11">builder</samp>
    variable as an argument to any method that expects a <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>.
    Any code written for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp>
    instances won’t be expecting to be able to use the mutating properties of the
    companion class, so the conversion is safe and convenient.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">ColorBuilder</samp> can be
    substituted for <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> courtesy
    of the implicit conversion. No information is lost because the two types share
    a common representation; however, a narrowing of the interface occurs, because
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Color</samp> target type has
    no <samp class="SANS_TheSansMonoCd_W5Regular_11">set</samp> accessors for its
    properties.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Conversions represent a form of polymorphism, as we explicitly allow a variable
    of one type to be coerced to a variable of a different but unrelated type. Like
    parametric polymorphism using generics, and ad hoc polymorphism with overloading,
    coercion polymorphism is a compile-time activity, in contrast to the dynamic,
    run-time characteristic of inclusion polymorphism using inheritance. Inclusion
    polymorphism is a powerful tool, but because the type relationships are resolved
    at run time, the compiler can’t identify many of the errors that may occur. When
    we improperly use generics, overloading, or coercions, we can rely on the compiler
    to tell us about most errors in our code.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Trying to outsmart a compiler defeats much of the purpose of using one.*'
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Brian Kernighan and P.J. Plauger, *The Elements of Programming Style*
  id: totrans-332
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Asking how to make value types behave correctly when used polymorphically is
    the wrong question: polymorphism itself takes many forms! Combining value types
    and inheritance can cause hard-to-diagnose errors, but inheritance is only one
    kind of polymorphism. The dynamic nature of inclusion polymorphism with virtual
    dispatch brings an expectation of type substitutability and doesn’t sit well with
    value-based equality.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting one type from another imposes a responsibility on the derived type
    to respect the contract established by the base class. Failing to uphold that
    contract can lead to undesirable behavior. One type is genuinely substitutable
    for another only if they share the same behavioral contract, which is something
    the compiler can’t enforce. It’s up to us, the programmers, to judge whether inheritance
    is appropriate. In the case of structs, it’s not even permitted, freeing us from
    that particular responsibility.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: With records, we need to pay just as much attention to the base class contract
    as we do with classes. Although the compiler carefully crafts its implementation
    of equality to ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    behaves correctly for records, it doesn’t do the same for any of our own virtual
    and overridden methods in those types.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Records aren’t necessarily appropriate for everything, and as noted earlier,
    making <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp> “just work”
    for values using inheritance is an incomplete solution to the wrong problem. In
    particular, records are reference types and thus subject to garbage collection.
    The implementations of <samp class="SANS_TheSansMonoCd_W5Regular_11">Equals</samp>
    are all virtual, as is the <samp class="SANS_TheSansMonoCd_W5Regular_11">EqualityContract</samp>
    property, and they all carry an associated cost. Records are a very compact way
    of declaring immutable value-like types, but programming is more than the amount
    of typing required of us.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Value types do combine much better with the other ways of representing polymorphic
    behavior: coercion, overloading, and generic. These three forms of polymorphism
    are static in nature; that is, they are resolved by the compiler. Although type
    parameters in generic classes and methods are resolved at run time, we must still
    provide compile-time guarantees about which operations those parameters support.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: It can be tempting to use inheritance in order to reuse code from a base class.
    This is a bad idea because inheriting a class implies that the base class can
    be substituted by the inheriting class, but it can be difficult to ensure that
    the base class’s behavioral characteristics are properly met. We can still reuse
    another type’s implementation by containing an instance of the type and using
    the contained instance privately to implement our new type.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting from concrete types—that is, nonabstract classes—in general presents
    us with the challenges of respecting the contracts established by those base classes.
    When we override an abstract method or implement an interface, we don’t suffer
    from those issues because there is no base class implementation to respect. In
    those cases, we’re inheriting only the interface contract, which is much easier
    to uphold.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: The moral of the story is that if we always implement true interfaces or inherit
    from fully abstract classes, the problems we’ve encountered in this chapter will
    never cause us difficulties. Correspondingly, we should seal any class or record
    that models a value type and ensure that it has no user-defined base types. We
    can still write code that behaves polymorphically with the value types we use
    and create, but we should express it differently by employing generics, overloading
    methods, and permitting type conversions.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
