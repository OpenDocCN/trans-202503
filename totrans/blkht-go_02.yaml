- en: '2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '2'
- en: TCP, SCANNERS, AND PROXIES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: TCP、扫描器和代理
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: Let’s begin our practical application of Go with the *Transmission Control Protocol
    (TCP)*, the predominant standard for connection-oriented, reliable communications
    and the foundation of modern networking. TCP is everywhere, and it has well-documented
    libraries, code samples, and generally easy-to-understand packet flows. You must
    understand TCP to fully evaluate, analyze, query, and manipulate network traffic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实践 Go 的应用，使用 *传输控制协议（TCP）*，它是面向连接的、可靠通信的主要标准，也是现代网络的基础。TCP 无处不在，它有着完善的文档、代码示例和通常易于理解的数据包流。你必须理解
    TCP，才能全面评估、分析、查询和操作网络流量。
- en: As an attacker, you should understand how TCP works and be able to develop usable
    TCP constructs so that you can identify open/closed ports, recognize potentially
    errant results such as false-positives—for example, syn-flood protections—and
    bypass egress restrictions through port forwarding. In this chapter, you’ll learn
    basic TCP communications in Go; build a concurrent, properly throttled port scanner;
    create a TCP proxy that can be used for port forwarding; and re-create Netcat’s
    “gaping security hole” feature.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 作为攻击者，你应该理解 TCP 的工作原理，并能够开发可用的 TCP 构造，以便识别开放/关闭端口，识别潜在的错误结果，如误报——例如，syn-flood
    保护——并通过端口转发绕过出口限制。在本章中，你将学习 Go 中的基本 TCP 通信；构建一个并发的、适当限速的端口扫描器；创建一个可以用于端口转发的 TCP
    代理；并重现 Netcat 的“漏洞”特性。
- en: Entire textbooks have been written to discuss every nuance of TCP, including
    packet structure and flow, reliability, communication reassembly, and more. This
    level of detail is beyond the scope of this book. For more details, you should
    read *The TCP/IP Guide* by Charles M. Kozierok (No Starch Press, 2005).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有整本书专门讨论 TCP 的每个细节，包括数据包结构和流、可靠性、通信重组等。这样的细节超出了本书的范围。如需更多信息，建议阅读 Charles M.
    Kozierok 的 *TCP/IP 指南*（No Starch Press，2005）。
- en: Understanding the TCP Handshake
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 TCP 握手
- en: For those who need a refresher, let’s review the basics. [Figure 2-1](ch02.xhtml#ch2fig1)
    shows how TCP uses a handshake process when querying a port to determine whether
    the port is open, closed, or filtered.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些需要复习的人，让我们回顾一下基础知识。[图 2-1](ch02.xhtml#ch2fig1)展示了 TCP 在查询端口时使用握手过程，以确定端口是开放的、关闭的还是被过滤的。
- en: '![Image](Images/02fig01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/02fig01.jpg)'
- en: '*Figure 2-1: TCP handshake fundamentals*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：TCP 握手基础*'
- en: If the port is open, a three-way handshake takes place. First, the client sends
    a *syn packet*, which signals the beginning of a communication. The server then
    responds with a *syn-ack*, or acknowledgment of the syn packet it received, prompting
    the client to finish with an *ack*, or acknowledgment of the server’s response.
    The transfer of data can then occur. If the port is closed, the server responds
    with a *rst* packet instead of a syn-ack. If the traffic is being filtered by
    a firewall, the client will typically receive no response from the server.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果端口是开放的，则会进行三次握手。首先，客户端发送一个 *syn 数据包*，表示通信的开始。然后，服务器会用 *syn-ack* 响应，确认收到 syn
    数据包，并促使客户端发送 *ack*，即确认服务器的回应。数据传输可以开始。如果端口是关闭的，服务器会用 *rst* 数据包代替 syn-ack 响应。如果流量被防火墙过滤，客户端通常不会收到来自服务器的任何响应。
- en: These responses are important to understand when writing network-based tools.
    Correlating the output of your tools to these low-level packet flows will help
    you validate that you’ve properly established a network connection and troubleshoot
    potential problems. As you’ll see later in this chapter, you can easily introduce
    bugs into your code if you fail to allow full client-server TCP connection handshakes
    to complete, resulting in inaccurate or misleading results.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写基于网络的工具时，理解这些响应非常重要。将工具的输出与这些低层数据包流相关联将帮助你验证是否已正确建立网络连接，并排查潜在问题。正如你将在本章后面看到的那样，如果你未能完成完整的客户端-服务器
    TCP 连接握手，就容易在代码中引入 bug，从而导致不准确或误导的结果。
- en: Bypassing Firewalls with Port Forwarding
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过端口转发绕过防火墙
- en: People can configure firewalls to prevent a client from connecting to certain
    servers and ports, while allowing access to others. In some cases, you can circumvent
    these restrictions by using an intermediary system to proxy the connection around
    or through a firewall, a technique known as *port forwarding*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 人们可以配置防火墙以防止客户端连接到某些服务器和端口，同时允许访问其他服务器和端口。在某些情况下，你可以通过使用中介系统将连接代理绕过或穿越防火墙，从而规避这些限制，这种技术称为
    *端口转发*。
- en: Many enterprise networks restrict internal assets from establishing HTTP connections
    to malicious sites. For this example, imagine a nefarious site called *evil.com*.
    If an employee attempts to browse *evil.com* directly, a firewall blocks the request.
    However, should an employee own an external system that’s allowed through the
    firewall (for example, *[stacktitan.com](http://stacktitan.com)*), that employee
    can leverage the allowed domain to bounce connections to *evil.com*. [Figure 2-2](ch02.xhtml#ch2fig2)
    illustrates this concept.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/02fig02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: A TCP proxy*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: A client connects, through a firewall, to the destination host *[stacktitan.com](http://stacktitan.com)*.
    This host is configured to forward connections to the host *evil.com*. While a
    firewall forbids direct connections to *evil.com*, a configuration such as the
    one shown here could allow a client to circumvent this protection mechanism and
    access *evil.com*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: You can use port forwarding to exploit several restrictive network configurations.
    For example, you could forward traffic through a jump box to access a segmented
    network or access ports bound to restrictive interfaces.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Writing a TCP Scanner
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One effective way to conceptualize the interaction of TCP ports is by implementing
    a port scanner. By writing one, you’ll observe the steps that occur in a TCP handshake,
    along with the effects of encountered state changes, which allow you to determine
    whether a TCP port is available or whether it responds with a closed or filtered
    state.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve written a basic scanner, you’ll write one that’s faster. A port
    scanner may scan several ports by using a single contiguous method; however, this
    can become time-consuming when your goal is to scan all 65,535 ports. You’ll explore
    how to use concurrency to make an inefficient port scanner more suitable for larger
    port-scanning tasks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also be able to apply the concurrency patterns that you’ll learn in this
    section in many other scenarios, both in this book and beyond.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Testing for Port Availability
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first step in creating the port scanner is understanding how to initiate
    a connection from a client to a server. Throughout this example, you’ll be connecting
    to and scanning *[scanme.nmap.org](http://scanme.nmap.org)*, a service run by
    the Nmap project.^([1](footnote.xhtml#ch2fn1)) To do this, you’ll use Go’s `net`
    package: `net.Dial(`network`,` address string`)`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: The first argument is a string that identifies the kind of connection to initiate.
    This is because `Dial` isn’t just for TCP; it can be used for creating connections
    that use Unix sockets, UDP, and Layer 4 protocols that exist only in your head
    (the authors have been down this road, and suffice it to say, TCP is very good).
    There are a few strings you can provide, but for the sake of brevity, you’ll use
    the string `tcp`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The second argument tells `Dial(`network`,` address string`)` the host to which
    you wish to connect. Notice it’s a single string, not a `string` and an `int`.
    For IPv4/TCP connections, this string will take the form of `host:port`. For example,
    if you wanted to connect to *[scanme.nmap.org](http://scanme.nmap.org)* on TCP
    port 80, you would supply `scanme.nmap.org:80`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you know how to create a connection, but how will you know if the connection
    is successful? You’ll do this through error checking: `Dial(`network`,` address
    string`)` returns `Conn` and `error`, and `error` will be `nil` if the connection
    is successful. So, to verify your connection, you just check whether `error` equals
    `nil`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: You now have all the pieces needed to build a single port scanner, albeit an
    impolite one. [Listing 2-1](ch02.xhtml#ch2list1) shows how to put it together.
    (All the code listings at the root location of / exist under the provided github
    repo *[https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 2-1: A basic port scanner that scans only one port (*[/ch-2/dial/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/dial/main.go)*)*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Run this code. You should see `Connection successful`, provided you have access
    to the great information superhighway.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Performing Nonconcurrent Scanning
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Scanning a single port at a time isn’t useful, and it certainly isn’t efficient.
    TCP ports range from 1 to 65535; but for testing, let’s scan ports 1 to 1024\.
    To do this, you can use a `for` loop:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now you have an `int`, but remember, you need a string as the second argument
    to `Dial(`network`,` address string`)`. There are at least two ways to convert
    the integer into a string. One way is to use the string conversion package, `strconv`.
    The other way is to use `Sprintf(`format string, a ...interface`{}``)` from the
    `fmt` package, which (similar to its C sibling) returns a `string` generated from
    a format string.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file with the code in [Listing 2-2](ch02.xhtml#ch2list2) and ensure
    that both your loop and string generation work. Running this code should print
    1024 lines, but don’t feel obligated to count them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 2-2: Scanning 1024 ports of [scanme.nmap.org](http://scanme.nmap.org)
    (*[/ch-2/tcp-scanner-slow/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-slow/main.go)*)*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: All that’s left is to plug the address variable from the previous code example
    into `Dial(`network`,` address string`)`, and implement the same error checking
    from the previous section to test port availability. You should also add some
    logic to close the connection if it was successful; that way, connections aren’t
    left open. *FINishing* your connections is just polite. To do that, you’ll call
    `Close()` on `Conn`. [Listing 2-3](ch02.xhtml#ch2list3) shows the completed port
    scanner.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 2-3: The completed port scanner (*[/ch-2/tcp-scanner-slow/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-slow/main.go)*)*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-3：完成的端口扫描器 (*[/ch-2/tcp-scanner-slow/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-slow/main.go)*)*'
- en: Compile and execute this code to conduct a light scan against the target. You
    should see a couple of open ports.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并执行此代码，以对目标进行轻量级扫描。您应该会看到几个开放的端口。
- en: Performing Concurrent Scanning
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 执行并发扫描
- en: The previous scanner scanned multiple ports in a single go (pun intended). But
    your goal now is to scan multiple ports concurrently, which will make your port
    scanner faster. To do this, you’ll harness the power of goroutines. Go will let
    you create as many goroutines as your system can handle, bound only by available
    memory.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的扫描器一次性扫描多个端口（这是一种双关语）。但现在您的目标是并发扫描多个端口，这将使您的端口扫描器更快。为此，您将利用 goroutine 的强大功能。Go
    允许您根据系统的承载能力创建任意数量的 goroutine，唯一的限制是可用的内存。
- en: The “Too Fast” Scanner Version
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: “太快”扫描器版本
- en: The most naive way to create a port scanner that runs concurrently is to wrap
    the call to `Dial(`network`,` address string`)` in a goroutine. In the interest
    of learning from natural consequences, create a new file called *scan-too-fast.go*
    with the code in [Listing 2-4](ch02.xhtml#ch2list4) and execute it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个并发运行的端口扫描器最简单的方法是将 `Dial(`network`,` address string`)` 的调用封装在一个 goroutine
    中。为了从自然后果中学习，创建一个名为 *scan-too-fast.go* 的新文件，包含 [清单 2-4](ch02.xhtml#ch2list4) 中的代码并执行它。
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 2-4: A scanner that works too fast (*[/ch-2/tcp-scanner-too-fast/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-too-fast/main.go)*)*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-4：一个运行太快的扫描器 (*[/ch-2/tcp-scanner-too-fast/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-too-fast/main.go)*)*'
- en: 'Upon running this code, you should observe the program exiting almost immediately:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码后，您应该会看到程序几乎立即退出：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code you just ran launches a single goroutine per connection, and the main
    goroutine doesn’t know to wait for the connection to take place. Therefore, the
    code completes and exits as soon as the `for` loop finishes its iterations, which
    may be faster than the network exchange of packets between your code and the target
    ports. You may not get accurate results for ports whose packets were still in-flight.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚运行的代码为每个连接启动一个 goroutine，而主 goroutine 并不知道需要等待连接完成。因此，代码会在 `for` 循环完成其迭代后立即结束并退出，这可能比代码与目标端口之间的网络数据包交换还要快。对于那些数据包仍在传输中的端口，您可能无法获得准确的结果。
- en: 'There are a few ways to fix this. One is to use `WaitGroup` from the `sync`
    package, which is a thread-safe way to control concurrency. `WaitGroup` is a struct
    type and can be created like so:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决这个问题。一种方法是使用来自 `sync` 包的 `WaitGroup`，它是一种线程安全的方式来控制并发。`WaitGroup` 是一个结构体类型，可以像这样创建：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once you’ve created `WaitGroup`, you can call a few methods on the struct. The
    first is `Add(`int`)`, which increases an internal counter by the number provided.
    Next, `Done()` decrements the counter by one. Finally, `Wait()` blocks the execution
    of the goroutine in which it’s called, and will not allow further execution until
    the internal counter reaches zero. You can combine these calls to ensure that
    the main goroutine waits for all connections to finish.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了 `WaitGroup`，您可以在该结构体上调用几个方法。第一个是 `Add(`int`)`，它会根据提供的数字增加一个内部计数器。接下来，`Done()`
    会将计数器减一。最后，`Wait()` 会阻塞它所在 goroutine 的执行，并且在内部计数器为零之前不会允许继续执行。您可以将这些调用组合起来，确保主
    goroutine 等待所有连接完成。
- en: Synchronized Scanning Using WaitGroup
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 WaitGroup 进行同步扫描
- en: '[Listing 2-5](ch02.xhtml#ch2list5) shows the same port-scanning program with
    a different implementation of the goroutines.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-5](ch02.xhtml#ch2list5)展示了同一个端口扫描程序，但采用了不同的 goroutine 实现。'
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 2-5: A synchronized scanner that uses `WaitGroup` (*[/ch-2/tcp-scanner-wg-too-fast/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-wg-too-fast/main.go)*)*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-5：一个使用 `WaitGroup` 的同步扫描器 (*[/ch-2/tcp-scanner-wg-too-fast/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-wg-too-fast/main.go)*)*'
- en: This iteration of the code remains largely identical to our initial version.
    However, you’ve added code that explicitly tracks the remaining work. In this
    version of the program, you create `sync.WaitGroup` ❶, which acts as a synchronized
    counter. You increment this counter via `wg.Add(1)` each time you create a goroutine
    to scan a port ❷, and a deferred call to `wg.Done()` decrements the counter whenever
    one unit of work has been performed ❸. Your `main()` function calls `wg.Wait()`,
    which blocks until all the work has been done and your counter has returned to
    zero ❹.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: This version of the program is better, but still incorrect. If you run this
    multiple times against multiple hosts, you might see inconsistent results. Scanning
    an excessive number of hosts or ports simultaneously may cause network or system
    limitations to skew your results. Go ahead and change `1024` to 65535, and the
    destination server to your localhost 127.0.0.1 in your code. If you want, you
    can use Wireshark or tcpdump to see how fast those connections are opened.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Port Scanning Using a Worker Pool
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To avoid inconsistencies, you’ll use a pool of goroutines to manage the concurrent
    work being performed. Using a `for` loop, you’ll create a certain number of worker
    goroutines as a resource pool. Then, in your `main()` “thread,” you’ll use a channel
    to provide work.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: To start, create a new program that has 100 workers, consumes a channel of `int`,
    and prints them to the screen. You’ll still use `WaitGroup` to block execution.
    Create your initial code stub for a `main` function. Above it, write the function
    shown in [Listing 2-6](ch02.xhtml#ch2list6).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 2-6: A worker function for processing work*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'The `worker(int, *sync.WaitGroup)` function takes two arguments: a channel
    of type `int` and a pointer to a `WaitGroup`. The channel will be used to receive
    work, and the `WaitGroup` will be used to track when a single work item has been
    completed.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Now, add your `main()` function shown in [Listing 2-7](ch02.xhtml#ch2list7),
    which will manage the workload and provide work to your `worker(int, *sync.WaitGroup)`
    function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 2-7: A basic worker pool (*[/ch-2/tcp-sync-scanner/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-sync-scanner/main.go)*)*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: First, you create a channel by using `make()` ❷. A second parameter, an `int`
    value of `100`, is provided to `make()` here. This allows the channel to be *buffered*,
    which means you can send it an item without waiting for a receiver to read the
    item. Buffered channels are ideal for maintaining and tracking work for multiple
    producers and consumers. You’ve capped the channel at 100, meaning it can hold
    100 items before the sender will block. This is a slight performance increase,
    as it will allow all the workers to start immediately.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Next, you use a `for` loop ❸ to start the desired number of workers—in this
    case, 100\. In the `worker(int, *sync.WaitGroup)` function, you use `range` ❶
    to continuously receive from the `ports` channel, looping until the channel is
    closed. Notice that you aren’t doing any work yet in the worker—that’ll come shortly.
    Iterating over the ports sequentially in the `main()` function, you send a port
    on the `ports` channel ❹ to the worker. After all the work has been completed,
    you close the channel ❺.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you build and execute this program, you’ll see your numbers printed to
    the screen. You might notice something interesting here: the numbers are printed
    in no particular order. Welcome to the wonderful world of parallelism.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Multichannel Communication
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To complete the port scanner, you could plug in your code from earlier in the
    section, and it would work just fine. However, the printed ports would be unsorted,
    because the scanner wouldn’t check them in order. To solve this problem, you need
    to use a separate thread to pass the result of the port scan back to your main
    thread to order the ports before printing. Another benefit of this modification
    is that you can remove the dependency of a `WaitGroup` entirely, as you’ll have
    another method of tracking completion. For example, if you scan 1024 ports, you’re
    sending on the worker channel 1024 times, and you’ll need to send the result of
    that work back to the main thread 1024 times. Because the number of work units
    sent and the number of results received are the same, your program can know when
    to close the channels and subsequently shut down the workers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: This modification is demonstrated in [Listing 2-8](ch02.xhtml#ch2list8), which
    completes the port scanner.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 2-8: Port scanning with multiple channels (*[/ch-2/tcp-scanner-final/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-final/main.go)*)*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The `worker(ports, results chan int)` function has been modified to accept two
    channels ❶; the remaining logic is mostly the same, except that if the port is
    closed, you’ll send a zero ❷, and if it’s open, you’ll send the port ❸. Also,
    you create a separate channel to communicate the results from the worker to the
    main thread ❹. You then use a slice ❺ to store the results so you can sort them
    later. Next, you need to send to the workers in a separate goroutine ❻ because
    the result-gathering loop needs to start before more than 100 items of work can
    continue.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: The result-gathering loop ❼ receives on the `results` channel 1024 times. If
    the port doesn’t equal 0, it’s appended to the slice. After closing the channels,
    you’ll use `sort` ❽ to sort the slice of open ports. All that’s left is to loop
    over the slice and print the open ports to screen.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'There you have it: a highly efficient port scanner. Take some time to play
    around with the code—specifically, the number of workers. The higher the count,
    the faster your program should execute. But if you add too many workers, your
    results could become unreliable. When you’re writing tools for others to use,
    you’ll want to use a healthy default value that caters to reliability over speed.
    However, you should also allow users to provide the number of workers as an option.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: You could make a couple of improvements to this program. First, you’re sending
    on the `results` channel for every port scanned, and this isn’t necessary. The
    alternative requires code that is slightly more complex as it uses an additional
    channel not only to track the workers, but also to prevent a race condition by
    ensuring the completion of all gathered results. As this is an introductory chapter,
    we purposefully left this out; but don’t worry! We’ll introduce this pattern in
    [Chapter 3](ch03.xhtml#ch3). Second, you might want your scanner to be able to
    parse port-strings—for example, `80,443,8080,21-25`, like those that can be passed
    to Nmap. If you want to see an implementation of this, see [*https://github.com/blackhat-go/bhg/blob/master/ch-2/scanner-port-format/*](https://github.com/blackhat-go/bhg/blob/master/ch-2/scanner-port-format/).
    We’ll leave this as an exercise for you to explore.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Building a TCP Proxy
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can achieve all TCP-based communications by using Go’s built-in `net` package.
    The previous section focused primarily on using the `net` package from a client’s
    perspective, and this section will use it to create TCP servers and transfer data.
    You’ll begin this journey by building the requisite *echo server*—a server that
    merely echoes a given response back to a client—followed by two much more generally
    applicable programs: a TCP port forwarder and a re-creation of Netcat’s “gaping
    security hole” for remote command execution.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Using io.Reader and io.Writer
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To create the examples in this section, you need to use two significant types
    that are crucial to essentially all input/output (I/O) tasks, whether you’re using
    TCP, HTTP, a filesystem, or any other means: `io.Reader` and `io.Writer`. Part
    of Go’s built-in `io` package, these types act as the cornerstone to any data
    transmission, local or networked. These types are defined in Go’s documentation
    as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Both types are defined as interfaces, meaning they can’t be directly instantiated.
    Each type contains the definition of a single exported function: `Read` or `Write`.
    As explained in [Chapter 1](ch01.xhtml#ch1), you can think of these functions
    as abstract methods that must be implemented on a type for it to be considered
    a `Reader` or `Writer`. For example, the following contrived type fulfills this
    contract and can be used anywhere a `Reader` is accepted:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This same idea applies to the `Writer` interface:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s take this knowledge and create something semi-usable: a custom `Reader`
    and `Writer` that wraps stdin and stdout. The code for this is a little contrived
    since Go’s `os.Stdin` and `os.Stdout` types already act as `Reader` and `Writer`,
    but then you wouldn’t learn anything if you didn’t reinvent the wheel every now
    and again, would you?'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用这些知识创建一些半可用的东西：一个自定义的 `Reader` 和 `Writer`，它们封装了 stdin 和 stdout。这个代码有些牵强，因为
    Go 的 `os.Stdin` 和 `os.Stdout` 类型已经作为 `Reader` 和 `Writer` 使用，但如果你不时地重新发明轮子，你就什么也学不到，不是吗？
- en: '[Listing 2-9](ch02.xhtml#ch2list9) shows a full implementation, and an explanation
    follows.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-9](ch02.xhtml#ch2list9) 显示了完整的实现，接下来是解释。'
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 2-9: A `reader` and `writer` demonstration (*[/ch-2/io-example/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/io-example/main.go)*)*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-9：`reader` 和 `writer` 演示 (*[/ch-2/io-example/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/io-example/main.go)*)*'
- en: 'The code defines two custom types: `FooReader` ❶ and `FooWriter` ❹. On each
    type, you define a concrete implementation of the `Read([]byte)` function ❷ for
    `FooReader` and the `Write([]byte)` function ❺ for `FooWriter`. In this case,
    both functions are reading from stdin ❸ and writing to stdout ❻.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义了两种自定义类型：`FooReader` ❶ 和 `FooWriter` ❹。在每种类型上，您为 `FooReader` 定义了 `Read([]byte)`
    函数的具体实现 ❷，为 `FooWriter` 定义了 `Write([]byte)` 函数的具体实现 ❺。在本例中，两个函数都从 stdin 读取数据 ❸，并将数据写入
    stdout ❻。
- en: Note that the `Read` functions on both `FooReader` and `os.Stdin` return the
    length of data and any errors. The data itself is copied into the `byte` slice
    passed to the function. This is consistent with the `Reader` interface prototype
    definition provided earlier in this section. The `main()` function creates that
    slice (named `input`) ❼ and then proceeds to use it in calls to `FooReader.Read([]byte``)`
    ❽ and `FooReader.Write([]byte)` ❾.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`FooReader` 和 `os.Stdin` 上的 `Read` 函数返回数据的长度以及任何错误。数据本身会被复制到传递给函数的 `byte`
    切片中。这与本节前面提供的 `Reader` 接口原型定义是一致的。`main()` 函数创建了该切片（名为 `input`）❼，然后在调用 `FooReader.Read([]byte)`
    ❽ 和 `FooReader.Write([]byte)` ❾ 时使用它。
- en: 'A sample run of the program produces the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的示例运行结果如下：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Copying data from a `Reader` to a `Writer` is a fairly common pattern—so much
    so that Go’s `io` package contains a `Copy()` function that can be used to simplify
    the `main()` function. The function prototype is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Reader` 复制数据到 `Writer` 是一种相当常见的模式——以至于 Go 的 `io` 包中包含了一个 `Copy()` 函数，可以用来简化
    `main()` 函数。函数原型如下所示：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This convenience function allows you to achieve the same programmatic behavior
    as before, replacing your `main()` function with the code in [Listing 2-10](ch02.xhtml#ch2list10).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个便捷函数使您能够实现与之前相同的编程行为，将您的 `main()` 函数替换为 [清单 2-10](ch02.xhtml#ch2list10) 中的代码。
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 2-10: Using io.Copy (*[/ch-2/copy-example/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/copy-example/main.go)*)*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-10：使用 io.Copy (*[/ch-2/copy-example/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/copy-example/main.go)*)*'
- en: Notice that the explicit calls to `reader.Read([]byte)` and `writer.Write([]byte)`
    have been replaced with a single call to `io.Copy(writer, reader)` ❶. Under the
    covers, `io.Copy(writer, reader)` calls the `Read([]byte)` function on the provided
    reader, triggering the `FooReader` to read from stdin. Subsequently, `io.Copy(writer,
    reader)` calls the `Write([]byte)` function on the provided writer, resulting
    in a call to your `FooWriter`, which writes the data to stdout. Essentially, `io.Copy(writer,
    reader)` handles the sequential read-then-write process without all the petty
    details.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，显式调用 `reader.Read([]byte)` 和 `writer.Write([]byte)` 已经被一个对 `io.Copy(writer,
    reader)` 的调用所替代 ❶。在幕后，`io.Copy(writer, reader)` 会调用提供的 reader 上的 `Read([]byte)`
    函数，从而触发 `FooReader` 从 stdin 读取数据。随后，`io.Copy(writer, reader)` 会调用提供的 writer 上的
    `Write([]byte)` 函数，从而调用您的 `FooWriter`，并将数据写入 stdout。本质上，`io.Copy(writer, reader)`
    处理了顺序的读取然后写入过程，而无需处理所有的细节。
- en: This introductory section is by no means a comprehensive look at Go’s I/O and
    interfaces. Many convenience functions and custom readers and writers exist as
    part of the standard Go packages. In most cases, Go’s standard packages contain
    all the basic implementations to achieve the most common tasks. In the next section,
    let’s explore how to apply these fundamentals to TCP communications, eventually
    using the power vested in you to develop real-life, usable tools.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本介绍性部分绝不是 Go 的 I/O 和接口的全面概述。作为 Go 标准包的一部分，存在许多方便的函数和自定义的读取器与写入器。在大多数情况下，Go 的标准包包含了实现最常见任务的所有基本功能。在下一节中，我们将探讨如何将这些基础应用到
    TCP 通信中，并最终利用这些能力开发实际可用的工具。
- en: Creating the Echo Server
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As is customary for most languages, you’ll start by building an echo server
    to learn how to read and write data to and from a socket. To do this, you’ll use
    `net.Conn`, Go’s stream-oriented network connection, which we introduced when
    you built a port scanner. Based on Go’s documentation for the data type, `Conn`
    implements the `Read([]byte)` and `Write([]byte)` functions as defined for the
    `Reader` and `Writer` interfaces. Therefore, `Conn` is both a `Reader` and a `Writer`
    (yes, this is possible). This makes sense logically, as TCP connections are bidirectional
    and can be used to send (write) or receive (read) data.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: After creating an instance of `Conn`, you’ll be able to send and receive data
    over a TCP socket. However, a TCP server can’t simply manufacture a connection;
    a client must establish a connection. In Go, you can use `net.Listen``(`network`,`
    address string`)` to first open a TCP listener on a specific port. Once a client
    connects, the `Accept()` method creates and returns a `Conn` object that you can
    use for receiving and sending data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-11](ch02.xhtml#ch2list11) shows a complete example of a server implementation.
    We’ve included comments inline for clarity. Don’t worry about understanding the
    code in its entirety, as we’ll break it down momentarily.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 2-11: A basic echo server (*[/ch-2/echo-server/main.go](https://gihub.com/blackhat-go/bhg/blob/master/ch-2/echo-server/main.go)*)*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 2-11](ch02.xhtml#ch2list11) begins by defining a function named `echo(net.Conn)`,
    which accepts a `Conn` instance as a parameter. It behaves as a connection handler
    to perform all necessary I/O. The function loops indefinitely ❶, using a buffer
    to read ❷ and write ❸ data from and to the connection. The data is read into a
    variable named `b` and subsequently written back on the connection.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Now you need to set up a listener that will call your handler. As mentioned
    previously, a server can’t manufacture a connection but must instead listen for
    a client to connect. Therefore, a listener, defined as `tcp` bound to port 20080,
    is started on all interfaces by using the `net.Listen(`network`,` address string`)`
    function ❹.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Next, an infinite loop ❺ ensures that the server will continue to listen for
    connections even after one has been received. Within this loop, you call `listener.Accept()`
    ❻, a function that blocks execution as it awaits client connections. When a client
    connects, this function returns a `Conn` instance. Recall from earlier discussions
    in this section that `Conn` is both a `Reader` and a `Writer` (it implements the
    `Read([]byte)` and `Write([]byte)` interface methods).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Conn` instance is then passed to the `echo(net.Conn)` handler function
    ❼. This call is prefaced with the `go` keyword, making it a concurrent call so
    that other connections don’t block while waiting for the handler function to complete.
    This is likely overkill for such a simple server, but we’ve included it again
    to demonstrate the simplicity of Go’s concurrency pattern, in case it wasn’t already
    clear. At this point, you have two lightweight threads running concurrently:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The main thread loops back and blocks on `listener.Accept()` while it awaits
    another connection.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The handler goroutine, whose execution has been transferred to the `echo(net.Conn)`
    function, proceeds to run, processing the data.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following shows an example using Telnet as the connecting client:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The server produces the following standard output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Revolutionary, right? A server that repeats back to the client exactly what
    the client sent to the server. What a useful and exciting example! It’s quite
    a time to be alive.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Improving the Code by Creating a Buffered Listener
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The example in [Listing 2-11](ch02.xhtml#ch2list11) works perfectly fine but
    relies on fairly low-level function calls, buffer tracking, and iterative reads/writes.
    This is a somewhat tedious, error-prone process. Fortunately, Go contains other
    packages that can simplify this process and reduce the complexity of the code.
    Specifically, the `bufio` package wraps `Reader` and `Writer` to create a buffered
    I/O mechanism. The updated `echo(net.Conn)` function is detailed here, and an
    explanation of the changes follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: No longer are you directly calling the `Read([]byte)` and `Write([]byte)` functions
    on the `Conn` instance; instead, you’re initializing a new buffered `Reader` and
    `Writer` via `NewReader(`io.Reader`)` ❶ and `NewWriter(`io.Writer`)` ❸. These
    calls both take, as a parameter, an existing `Reader` and `Writer` (remember,
    the `Conn` type implements the necessary functions to be considered both a `Reader`
    and a `Writer`).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Both buffered instances contain complementary functions for reading and writing
    string data. `ReadString(`byte`)` ❷ takes a delimiter character used to denote
    how far to read, whereas `WriteString(`byte`)` ❹ writes the string to the socket.
    When writing data, you need to explicitly call `writer.Flush()` ❺ to flush write
    all the data to the underlying writer (in this case, a `Conn` instance).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Although the previous example simplifies the process by using buffered I/O,
    you can reframe it to use the `Copy(Writer, Reader)` convenience function. Recall
    that this function takes as input a destination `Writer` and a source `Reader`,
    simply copying from source to destination.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, you’ll pass the `conn` variable as both the source and destination
    because you’ll be echoing the contents back on the established connection:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You’ve explored the basics of I/O and applied it to TCP servers. Now it’s time
    to move on to more usable, relevant examples.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Proxying a TCP Client
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you have a solid foundation, you can take what you’ve learned up to
    this point and create a simple port forwarder to proxy a connection through an
    intermediary service or host. As mentioned earlier in this chapter, this is useful
    for trying to circumvent restrictive egress controls or to leverage a system to
    bypass network segmentation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Before laying out the code, consider this imaginary but realistic problem:
    Joe is an underperforming employee who works for ACME Inc. as a business analyst
    making a handsome salary based on slight exaggerations he included on his resume.
    (Did he really go to an Ivy League school? Joe, that’s not very ethical.) Joe’s
    lack of motivation is matched only by his love for cats—so much so that Joe installed
    cat cameras at home and hosted a site, *joescatcam.website*, through which he
    could remotely monitor the dander-filled fluff bags. One problem, though: ACME
    is onto Joe. They don’t like that he’s streaming his cat cam 24/7 in 4K ultra
    high-def, using valuable ACME network bandwidth. ACME has even blocked its employees
    from visiting Joe’s cat cam website.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Joe has an idea. “What if I set up a port-forwarder on an internet-based system
    I control,” Joe says, “and force the redirection of all traffic from that host
    to *joescatcam.website*?” Joe checks at work the following day and confirms he
    can access his personal website, hosted at the *joesproxy.com* domain. Joe skips
    his afternoon meetings, heads to a coffee shop, and quickly codes a solution to
    his problem. He’ll forward all traffic received at *http://joesproxy.com* to *http://joescatcam.website*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s Joe’s code, which he runs on the *joesproxy.com* server:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Start by examining Joe’s `handle(net.Conn)` function. Joe connects to *joescatcam.website*
    ❶ (recall that this unreachable host isn’t directly accessible from Joe’s corporate
    workstation). Joe then uses `Copy(Writer, Reader)` two separate times. The first
    instance ❸ ensures that data from the inbound connection is copied to the *joescatcam.website*
    connection. The second instance ❹ ensures that data read from *joescatcam.website*
    is written back to the connecting client’s connection. Because `Copy(Writer, Reader)`
    is a blocking function, and will continue to block execution until the network
    connection is closed, Joe wisely wraps his first call to `Copy(Writer, Reader)`
    in a new goroutine ❷. This ensures that execution within the `handle(net.Conn)`
    function continues, and the second `Copy(Writer, Reader)` call can be made.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'Joe’s proxy listens on port 80 and relays any traffic received from a connection
    to and from port 80 on *joescatcam.website.* Joe, that crazy and wasteful man,
    confirms that he can connect to *joescatcam.website* via *joesproxy.com* by connecting
    with `curl`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: At this point, Joe has done it. He’s living the dream, wasting ACME-sponsored
    time and network bandwidth while he watches his cats. Today, there will be cats!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Replicating Netcat for Command Execution
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this section, let’s replicate some of Netcat’s more interesting functionality—specifically,
    its gaping security hole.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '*Netcat* is the TCP/IP Swiss Army knife—essentially, a more flexible, scriptable
    version of Telnet. It contains a feature that allows stdin and stdout of any arbitrary
    program to be redirected over TCP, enabling an attacker to, for example, turn
    a single command execution vulnerability into operating system shell access. Consider
    the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This command creates a listening server on port 13337\. Any remote client that
    connects, perhaps via Telnet, would be able to execute arbitrary bash commands—hence
    the reason this is referred to as a *gaping security hole*. Netcat allows you
    to optionally include this feature during program compilation. (For good reason,
    most Netcat binaries you’ll find on standard Linux builds do *not* include this
    feature.) It’s dangerous enough that we’ll show you how to create it in Go!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: First, look at Go’s `os/exec` package. You’ll use that for running operating
    system commands. This package defines a type, `Cmd`, that contains necessary methods
    and properties to run commands and manipulate stdin and stdout. You’ll redirect
    stdin (a `Reader`) and stdout (a `Writer`) to a `Conn` instance (which is both
    a `Reader` and a `Writer`).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'When you receive a new connection, you can use the `Command(`name string`,`
    arg ...string`)` function from `os/exec` to create a new `Cmd` instance. This
    function takes as parameters the operating system command and any arguments. In
    this example, hardcode `/bin/sh` as the command and pass `-i` as an argument such
    that you’re in interactive mode, which allows you to manipulate stdin and stdout
    more reliably:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This creates an instance of `Cmd` but doesn’t yet execute the command. You
    have a couple of options for manipulating stdin and stdout. You could use `Copy(Writer,
    Reader)` as discussed previously, or directly assign `Reader` and `Writer` to
    `Cmd`. Let’s directly assign your `Conn` object to both `cmd.Stdin` and `cmd.Stdout`,
    like so:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With the setup of the command and the streams complete, you run the command
    by using `cmd.Run()`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This logic works perfectly fine on Linux systems. However, when tweaking and
    running the program on a Windows system, running `cmd.exe` instead of `/bin/bash`,
    you’ll find that the connecting client never receives the command output because
    of some Windows-specific handling of anonymous pipes. Here are two solutions for
    this problem.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: First, you can tweak the code to explicitly force the flushing of stdout to
    correct this nuance. Instead of assigning `Conn` directly to `cmd.Stdout`, you
    implement a custom `Writer` that wraps `bufio.Writer` (a buffered writer) and
    explicitly calls its `Flush` method to force the buffer to be flushed. Refer to
    the “Creating the Echo Server” on [page 35](ch02.xhtml#page_35) for an exemplary
    use of `bufio.Writer`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the definition of the custom writer, `Flusher`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `Flusher` type implements a `Write([]byte)` function ❶ that writes ❷ the
    data to the underlying buffered writer and then flushes ❸ the output.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'With the implementation of a custom writer, you can tweak the connection handler
    to instantiate and use this `Flusher` custom type for `cmd.Stdout`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This solution, while adequate, certainly isn’t elegant. Although working code
    is more important than elegant code, we’ll use this problem as an opportunity
    to introduce the `io.Pipe()` function, Go’s synchronous, in-memory pipe that can
    be used for connecting `Readers` and `Writers`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Using `PipeReader` and `PipeWriter` allows you to avoid having to explicitly
    flush the writer and synchronously connect stdout and the TCP connection. You
    will, yet again, rewrite the handler function:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The call to `io.Pipe()` ❶ creates both a reader and a writer that are synchronously
    connected—any data written to the writer (`wp` in this example) will be read by
    the reader (`rp`). So, you assign the writer to `cmd.Stdout` ❷ and then use `io.Copy(conn,
    rp)` ❸ to link the `PipeReader` to the TCP connection. You do this by using a
    goroutine to prevent the code from blocking. Any standard output from the command
    gets sent to the writer and then subsequently piped to the reader and out over
    the TCP connection. How’s that for elegant?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, you’ve successfully implemented Netcat’s gaping security hole from
    the perspective of a TCP listener awaiting a connection. You can use similar logic
    to implement the feature from the perspective of a connecting client redirecting
    stdout and stdin of a local binary to a remote listener. The precise details are
    left to you to determine, but would likely include the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Establish a connection to a remote listener via `net.Dial(`network`,` address
    string`)`.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initialize a `Cmd` via `exec.Command(`name string`,` arg ...string`)`.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirect `Stdin` and `Stdout` properties to utilize the `net.Conn` object.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the command.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, the listener should receive a connection. Any data sent to the
    client should be interpreted as stdin on the client, and any data received on
    the listener should be interpreted as stdout. The full code of this example is
    available at [*https://github.com/blackhat-go/bhg/blob/master/ch-2/netcat-exec/*](https://github.com/blackhat-go/bhg/blob/master/ch-2/netcat-exec/main.go)*main.go*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that you’ve explored practical applications and usage of Go as it relates
    to networking, I/O, and concurrency, let’s move on to creating usable HTTP clients.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
