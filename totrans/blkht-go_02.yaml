- en: '2'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '2'
- en: TCP, SCANNERS, AND PROXIES
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: TCP、扫描器和代理
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: Let’s begin our practical application of Go with the *Transmission Control Protocol
    (TCP)*, the predominant standard for connection-oriented, reliable communications
    and the foundation of modern networking. TCP is everywhere, and it has well-documented
    libraries, code samples, and generally easy-to-understand packet flows. You must
    understand TCP to fully evaluate, analyze, query, and manipulate network traffic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始实践 Go 的应用，使用 *传输控制协议（TCP）*，它是面向连接的、可靠通信的主要标准，也是现代网络的基础。TCP 无处不在，它有着完善的文档、代码示例和通常易于理解的数据包流。你必须理解
    TCP，才能全面评估、分析、查询和操作网络流量。
- en: As an attacker, you should understand how TCP works and be able to develop usable
    TCP constructs so that you can identify open/closed ports, recognize potentially
    errant results such as false-positives—for example, syn-flood protections—and
    bypass egress restrictions through port forwarding. In this chapter, you’ll learn
    basic TCP communications in Go; build a concurrent, properly throttled port scanner;
    create a TCP proxy that can be used for port forwarding; and re-create Netcat’s
    “gaping security hole” feature.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 作为攻击者，你应该理解 TCP 的工作原理，并能够开发可用的 TCP 构造，以便识别开放/关闭端口，识别潜在的错误结果，如误报——例如，syn-flood
    保护——并通过端口转发绕过出口限制。在本章中，你将学习 Go 中的基本 TCP 通信；构建一个并发的、适当限速的端口扫描器；创建一个可以用于端口转发的 TCP
    代理；并重现 Netcat 的“漏洞”特性。
- en: Entire textbooks have been written to discuss every nuance of TCP, including
    packet structure and flow, reliability, communication reassembly, and more. This
    level of detail is beyond the scope of this book. For more details, you should
    read *The TCP/IP Guide* by Charles M. Kozierok (No Starch Press, 2005).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有整本书专门讨论 TCP 的每个细节，包括数据包结构和流、可靠性、通信重组等。这样的细节超出了本书的范围。如需更多信息，建议阅读 Charles M.
    Kozierok 的 *TCP/IP 指南*（No Starch Press，2005）。
- en: Understanding the TCP Handshake
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解 TCP 握手
- en: For those who need a refresher, let’s review the basics. [Figure 2-1](ch02.xhtml#ch2fig1)
    shows how TCP uses a handshake process when querying a port to determine whether
    the port is open, closed, or filtered.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些需要复习的人，让我们回顾一下基础知识。[图 2-1](ch02.xhtml#ch2fig1)展示了 TCP 在查询端口时使用握手过程，以确定端口是开放的、关闭的还是被过滤的。
- en: '![Image](Images/02fig01.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/02fig01.jpg)'
- en: '*Figure 2-1: TCP handshake fundamentals*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 2-1：TCP 握手基础*'
- en: If the port is open, a three-way handshake takes place. First, the client sends
    a *syn packet*, which signals the beginning of a communication. The server then
    responds with a *syn-ack*, or acknowledgment of the syn packet it received, prompting
    the client to finish with an *ack*, or acknowledgment of the server’s response.
    The transfer of data can then occur. If the port is closed, the server responds
    with a *rst* packet instead of a syn-ack. If the traffic is being filtered by
    a firewall, the client will typically receive no response from the server.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果端口是开放的，则会进行三次握手。首先，客户端发送一个 *syn 数据包*，表示通信的开始。然后，服务器会用 *syn-ack* 响应，确认收到 syn
    数据包，并促使客户端发送 *ack*，即确认服务器的回应。数据传输可以开始。如果端口是关闭的，服务器会用 *rst* 数据包代替 syn-ack 响应。如果流量被防火墙过滤，客户端通常不会收到来自服务器的任何响应。
- en: These responses are important to understand when writing network-based tools.
    Correlating the output of your tools to these low-level packet flows will help
    you validate that you’ve properly established a network connection and troubleshoot
    potential problems. As you’ll see later in this chapter, you can easily introduce
    bugs into your code if you fail to allow full client-server TCP connection handshakes
    to complete, resulting in inaccurate or misleading results.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写基于网络的工具时，理解这些响应非常重要。将工具的输出与这些低层数据包流相关联将帮助你验证是否已正确建立网络连接，并排查潜在问题。正如你将在本章后面看到的那样，如果你未能完成完整的客户端-服务器
    TCP 连接握手，就容易在代码中引入 bug，从而导致不准确或误导的结果。
- en: Bypassing Firewalls with Port Forwarding
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过端口转发绕过防火墙
- en: People can configure firewalls to prevent a client from connecting to certain
    servers and ports, while allowing access to others. In some cases, you can circumvent
    these restrictions by using an intermediary system to proxy the connection around
    or through a firewall, a technique known as *port forwarding*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 人们可以配置防火墙以防止客户端连接到某些服务器和端口，同时允许访问其他服务器和端口。在某些情况下，你可以通过使用中介系统将连接代理绕过或穿越防火墙，从而规避这些限制，这种技术称为
    *端口转发*。
- en: Many enterprise networks restrict internal assets from establishing HTTP connections
    to malicious sites. For this example, imagine a nefarious site called *evil.com*.
    If an employee attempts to browse *evil.com* directly, a firewall blocks the request.
    However, should an employee own an external system that’s allowed through the
    firewall (for example, *[stacktitan.com](http://stacktitan.com)*), that employee
    can leverage the allowed domain to bounce connections to *evil.com*. [Figure 2-2](ch02.xhtml#ch2fig2)
    illustrates this concept.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 许多企业网络限制内部资产与恶意网站建立HTTP连接。以此为例，假设有一个恶意网站叫做 *evil.com*。如果某个员工尝试直接浏览 *evil.com*，防火墙会阻止该请求。然而，如果该员工拥有一个可以通过防火墙的外部系统（例如
    *[stacktitan.com](http://stacktitan.com)*），那么该员工可以利用允许的域名将连接转发到 *evil.com*。[图2-2](ch02.xhtml#ch2fig2)
    展示了这一概念。
- en: '![Image](Images/02fig02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/02fig02.jpg)'
- en: '*Figure 2-1: A TCP proxy*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2-1：TCP代理*'
- en: A client connects, through a firewall, to the destination host *[stacktitan.com](http://stacktitan.com)*.
    This host is configured to forward connections to the host *evil.com*. While a
    firewall forbids direct connections to *evil.com*, a configuration such as the
    one shown here could allow a client to circumvent this protection mechanism and
    access *evil.com*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端通过防火墙连接到目标主机 *[stacktitan.com](http://stacktitan.com)*。该主机配置为将连接转发到主机 *evil.com*。虽然防火墙禁止直接连接到
    *evil.com*，但像这里展示的配置可以允许客户端绕过这个保护机制，访问 *evil.com*。
- en: You can use port forwarding to exploit several restrictive network configurations.
    For example, you could forward traffic through a jump box to access a segmented
    network or access ports bound to restrictive interfaces.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用端口转发来利用多个受限的网络配置。例如，您可以通过跳板机转发流量，访问分段网络或访问绑定到受限接口的端口。
- en: Writing a TCP Scanner
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写一个TCP扫描器
- en: One effective way to conceptualize the interaction of TCP ports is by implementing
    a port scanner. By writing one, you’ll observe the steps that occur in a TCP handshake,
    along with the effects of encountered state changes, which allow you to determine
    whether a TCP port is available or whether it responds with a closed or filtered
    state.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一种有效的方式来概念化TCP端口的交互是实现一个端口扫描器。通过编写端口扫描器，您将观察到TCP握手中发生的步骤，以及遇到的状态变化的影响，从而帮助您确定TCP端口是否可用，或者它是否响应关闭或过滤状态。
- en: Once you’ve written a basic scanner, you’ll write one that’s faster. A port
    scanner may scan several ports by using a single contiguous method; however, this
    can become time-consuming when your goal is to scan all 65,535 ports. You’ll explore
    how to use concurrency to make an inefficient port scanner more suitable for larger
    port-scanning tasks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您编写了一个基本的扫描器，您将编写一个更快的扫描器。一个端口扫描器可以通过使用单一的连续方法来扫描多个端口；然而，当您的目标是扫描所有65,535个端口时，这可能会变得非常耗时。您将探索如何使用并发性，使一个低效的端口扫描器更适合执行更大的端口扫描任务。
- en: You’ll also be able to apply the concurrency patterns that you’ll learn in this
    section in many other scenarios, both in this book and beyond.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将本节中学到的并发模式应用于许多其他场景，无论是在本书中还是在其他地方。
- en: Testing for Port Availability
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试端口的可用性
- en: 'The first step in creating the port scanner is understanding how to initiate
    a connection from a client to a server. Throughout this example, you’ll be connecting
    to and scanning *[scanme.nmap.org](http://scanme.nmap.org)*, a service run by
    the Nmap project.^([1](footnote.xhtml#ch2fn1)) To do this, you’ll use Go’s `net`
    package: `net.Dial(`network`,` address string`)`.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建端口扫描器的第一步是理解如何从客户端发起到服务器的连接。在本例中，您将连接并扫描*Nmap项目*提供的服务 *[scanme.nmap.org](http://scanme.nmap.org)*。^([1](footnote.xhtml#ch2fn1))
    为此，您将使用Go的`net`包：`net.Dial(`network`,` address string`)`。
- en: The first argument is a string that identifies the kind of connection to initiate.
    This is because `Dial` isn’t just for TCP; it can be used for creating connections
    that use Unix sockets, UDP, and Layer 4 protocols that exist only in your head
    (the authors have been down this road, and suffice it to say, TCP is very good).
    There are a few strings you can provide, but for the sake of brevity, you’ll use
    the string `tcp`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是一个字符串，用来标识要发起的连接类型。因为`Dial`不仅仅用于TCP，它还可以用于创建使用Unix套接字、UDP以及只存在于你脑海中的第四层协议的连接（作者曾走过这条路，可以说，TCP非常好）。您可以提供几个字符串，但为了简洁起见，您将使用字符串`tcp`。
- en: The second argument tells `Dial(`network`,` address string`)` the host to which
    you wish to connect. Notice it’s a single string, not a `string` and an `int`.
    For IPv4/TCP connections, this string will take the form of `host:port`. For example,
    if you wanted to connect to *[scanme.nmap.org](http://scanme.nmap.org)* on TCP
    port 80, you would supply `scanme.nmap.org:80`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数告诉 `Dial(`network`,` address string`)` 你希望连接的主机。请注意，它是一个单一的字符串，而不是 `string`
    和 `int`。对于 IPv4/TCP 连接，这个字符串的格式应该是 `host:port`。例如，如果你想连接到 *[scanme.nmap.org](http://scanme.nmap.org)*
    上的 TCP 80 端口，你需要提供 `scanme.nmap.org:80`。
- en: 'Now you know how to create a connection, but how will you know if the connection
    is successful? You’ll do this through error checking: `Dial(`network`,` address
    string`)` returns `Conn` and `error`, and `error` will be `nil` if the connection
    is successful. So, to verify your connection, you just check whether `error` equals
    `nil`.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何创建连接，但如何知道连接是否成功呢？你可以通过错误检查来实现：`Dial(`network`,` address string`)` 会返回
    `Conn` 和 `error`，如果连接成功，`error` 将为 `nil`。因此，要验证连接是否成功，你只需检查 `error` 是否等于 `nil`。
- en: You now have all the pieces needed to build a single port scanner, albeit an
    impolite one. [Listing 2-1](ch02.xhtml#ch2list1) shows how to put it together.
    (All the code listings at the root location of / exist under the provided github
    repo *[https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经具备了构建一个单端口扫描器所需的所有元素，尽管它不太礼貌。[清单 2-1](ch02.xhtml#ch2list1) 显示了如何将它们组合在一起。（所有位于根目录的代码清单都可以在提供的
    GitHub 仓库 *[https://github.com/blackhat-go/bhg/](https://github.com/blackhat-go/bhg/)*
    中找到。）
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 2-1: A basic port scanner that scans only one port (*[/ch-2/dial/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/dial/main.go)*)*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-1：一个只扫描一个端口的基本端口扫描器 (*[/ch-2/dial/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/dial/main.go)*)*'
- en: Run this code. You should see `Connection successful`, provided you have access
    to the great information superhighway.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码。只要你能够访问互联网，你应该会看到 `连接成功`。
- en: Performing Nonconcurrent Scanning
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 执行非并发扫描
- en: 'Scanning a single port at a time isn’t useful, and it certainly isn’t efficient.
    TCP ports range from 1 to 65535; but for testing, let’s scan ports 1 to 1024\.
    To do this, you can use a `for` loop:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一次只扫描一个端口是没有意义的，当然也不高效。TCP端口范围从1到65535；但是为了测试，我们扫描1到1024的端口。为此，你可以使用 `for` 循环：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now you have an `int`, but remember, you need a string as the second argument
    to `Dial(`network`,` address string`)`. There are at least two ways to convert
    the integer into a string. One way is to use the string conversion package, `strconv`.
    The other way is to use `Sprintf(`format string, a ...interface`{}``)` from the
    `fmt` package, which (similar to its C sibling) returns a `string` generated from
    a format string.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了一个 `int` 类型的值，但记住，`Dial(`network`,` address string`)` 的第二个参数需要是一个字符串。将整数转换为字符串至少有两种方法。一种方法是使用字符串转换包
    `strconv`。另一种方法是使用 `fmt` 包中的 `Sprintf(`格式字符串，a ...interface`{}``)`，它（类似于 C 语言的实现）会返回从格式字符串生成的
    `string`。
- en: Create a new file with the code in [Listing 2-2](ch02.xhtml#ch2list2) and ensure
    that both your loop and string generation work. Running this code should print
    1024 lines, but don’t feel obligated to count them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的文件，并将代码放入[清单 2-2](ch02.xhtml#ch2list2)，确保你的循环和字符串生成都能正常工作。运行此代码应该会打印1024行，但无需强制计算这些行。
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 2-2: Scanning 1024 ports of [scanme.nmap.org](http://scanme.nmap.org)
    (*[/ch-2/tcp-scanner-slow/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-slow/main.go)*)*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-2：扫描 [scanme.nmap.org](http://scanme.nmap.org) 的1024个端口 (*[/ch-2/tcp-scanner-slow/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-slow/main.go)*)*'
- en: All that’s left is to plug the address variable from the previous code example
    into `Dial(`network`,` address string`)`, and implement the same error checking
    from the previous section to test port availability. You should also add some
    logic to close the connection if it was successful; that way, connections aren’t
    left open. *FINishing* your connections is just polite. To do that, you’ll call
    `Close()` on `Conn`. [Listing 2-3](ch02.xhtml#ch2list3) shows the completed port
    scanner.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是将前面代码示例中的地址变量传递给 `Dial(`network`,` address string`)`，并实现前一节中的相同错误检查来测试端口可用性。你还应该添加一些逻辑，如果连接成功，就关闭连接；这样就不会留下未关闭的连接。*结束*连接是非常礼貌的。要做到这一点，你需要在
    `Conn` 上调用 `Close()`。[清单 2-3](ch02.xhtml#ch2list3) 显示了完整的端口扫描器。
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 2-3: The completed port scanner (*[/ch-2/tcp-scanner-slow/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-slow/main.go)*)*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-3：完成的端口扫描器 (*[/ch-2/tcp-scanner-slow/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-slow/main.go)*)*'
- en: Compile and execute this code to conduct a light scan against the target. You
    should see a couple of open ports.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并执行此代码，以对目标进行轻量级扫描。您应该会看到几个开放的端口。
- en: Performing Concurrent Scanning
  id: totrans-43
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 执行并发扫描
- en: The previous scanner scanned multiple ports in a single go (pun intended). But
    your goal now is to scan multiple ports concurrently, which will make your port
    scanner faster. To do this, you’ll harness the power of goroutines. Go will let
    you create as many goroutines as your system can handle, bound only by available
    memory.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的扫描器一次性扫描多个端口（这是一种双关语）。但现在您的目标是并发扫描多个端口，这将使您的端口扫描器更快。为此，您将利用 goroutine 的强大功能。Go
    允许您根据系统的承载能力创建任意数量的 goroutine，唯一的限制是可用的内存。
- en: The “Too Fast” Scanner Version
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: “太快”扫描器版本
- en: The most naive way to create a port scanner that runs concurrently is to wrap
    the call to `Dial(`network`,` address string`)` in a goroutine. In the interest
    of learning from natural consequences, create a new file called *scan-too-fast.go*
    with the code in [Listing 2-4](ch02.xhtml#ch2list4) and execute it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个并发运行的端口扫描器最简单的方法是将 `Dial(`network`,` address string`)` 的调用封装在一个 goroutine
    中。为了从自然后果中学习，创建一个名为 *scan-too-fast.go* 的新文件，包含 [清单 2-4](ch02.xhtml#ch2list4) 中的代码并执行它。
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 2-4: A scanner that works too fast (*[/ch-2/tcp-scanner-too-fast/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-too-fast/main.go)*)*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-4：一个运行太快的扫描器 (*[/ch-2/tcp-scanner-too-fast/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-too-fast/main.go)*)*'
- en: 'Upon running this code, you should observe the program exiting almost immediately:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码后，您应该会看到程序几乎立即退出：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code you just ran launches a single goroutine per connection, and the main
    goroutine doesn’t know to wait for the connection to take place. Therefore, the
    code completes and exits as soon as the `for` loop finishes its iterations, which
    may be faster than the network exchange of packets between your code and the target
    ports. You may not get accurate results for ports whose packets were still in-flight.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚运行的代码为每个连接启动一个 goroutine，而主 goroutine 并不知道需要等待连接完成。因此，代码会在 `for` 循环完成其迭代后立即结束并退出，这可能比代码与目标端口之间的网络数据包交换还要快。对于那些数据包仍在传输中的端口，您可能无法获得准确的结果。
- en: 'There are a few ways to fix this. One is to use `WaitGroup` from the `sync`
    package, which is a thread-safe way to control concurrency. `WaitGroup` is a struct
    type and can be created like so:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决这个问题。一种方法是使用来自 `sync` 包的 `WaitGroup`，它是一种线程安全的方式来控制并发。`WaitGroup` 是一个结构体类型，可以像这样创建：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once you’ve created `WaitGroup`, you can call a few methods on the struct. The
    first is `Add(`int`)`, which increases an internal counter by the number provided.
    Next, `Done()` decrements the counter by one. Finally, `Wait()` blocks the execution
    of the goroutine in which it’s called, and will not allow further execution until
    the internal counter reaches zero. You can combine these calls to ensure that
    the main goroutine waits for all connections to finish.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了 `WaitGroup`，您可以在该结构体上调用几个方法。第一个是 `Add(`int`)`，它会根据提供的数字增加一个内部计数器。接下来，`Done()`
    会将计数器减一。最后，`Wait()` 会阻塞它所在 goroutine 的执行，并且在内部计数器为零之前不会允许继续执行。您可以将这些调用组合起来，确保主
    goroutine 等待所有连接完成。
- en: Synchronized Scanning Using WaitGroup
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 WaitGroup 进行同步扫描
- en: '[Listing 2-5](ch02.xhtml#ch2list5) shows the same port-scanning program with
    a different implementation of the goroutines.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-5](ch02.xhtml#ch2list5)展示了同一个端口扫描程序，但采用了不同的 goroutine 实现。'
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 2-5: A synchronized scanner that uses `WaitGroup` (*[/ch-2/tcp-scanner-wg-too-fast/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-wg-too-fast/main.go)*)*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-5：一个使用 `WaitGroup` 的同步扫描器 (*[/ch-2/tcp-scanner-wg-too-fast/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-wg-too-fast/main.go)*)*'
- en: This iteration of the code remains largely identical to our initial version.
    However, you’ve added code that explicitly tracks the remaining work. In this
    version of the program, you create `sync.WaitGroup` ❶, which acts as a synchronized
    counter. You increment this counter via `wg.Add(1)` each time you create a goroutine
    to scan a port ❷, and a deferred call to `wg.Done()` decrements the counter whenever
    one unit of work has been performed ❸. Your `main()` function calls `wg.Wait()`,
    which blocks until all the work has been done and your counter has returned to
    zero ❹.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这次的代码迭代基本上与最初的版本相同。不过，你添加了显式跟踪剩余工作的代码。在这个程序版本中，你创建了`sync.WaitGroup` ❶，它充当一个同步计数器。每当你创建一个goroutine来扫描端口时，使用`wg.Add(1)`增加计数器
    ❷，而通过延迟调用`wg.Done()`在每个工作项完成时减少计数器 ❸。你的`main()`函数调用`wg.Wait()`，它会阻塞，直到所有工作完成并且计数器归零
    ❹。
- en: This version of the program is better, but still incorrect. If you run this
    multiple times against multiple hosts, you might see inconsistent results. Scanning
    an excessive number of hosts or ports simultaneously may cause network or system
    limitations to skew your results. Go ahead and change `1024` to 65535, and the
    destination server to your localhost 127.0.0.1 in your code. If you want, you
    can use Wireshark or tcpdump to see how fast those connections are opened.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的程序更好，但仍然存在问题。如果你多次运行它，针对多个主机进行扫描，你可能会看到不一致的结果。过多的主机或端口同时扫描可能会导致网络或系统的限制影响结果。你可以将代码中的`1024`改为65535，并将目标服务器设置为本地地址127.0.0.1。如果你愿意，可以使用Wireshark或tcpdump来查看连接的开启速度。
- en: Port Scanning Using a Worker Pool
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用工作池进行端口扫描
- en: To avoid inconsistencies, you’ll use a pool of goroutines to manage the concurrent
    work being performed. Using a `for` loop, you’ll create a certain number of worker
    goroutines as a resource pool. Then, in your `main()` “thread,” you’ll use a channel
    to provide work.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免不一致，你将使用一池goroutines来管理正在执行的并发工作。通过使用`for`循环，你将创建一定数量的工作线程作为资源池。然后，在你的`main()`“线程”中，你将使用一个通道提供工作。
- en: To start, create a new program that has 100 workers, consumes a channel of `int`,
    and prints them to the screen. You’ll still use `WaitGroup` to block execution.
    Create your initial code stub for a `main` function. Above it, write the function
    shown in [Listing 2-6](ch02.xhtml#ch2list6).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的程序，其中包含100个工作线程，使用一个`int`类型的通道，并将数据打印到屏幕上。你仍然会使用`WaitGroup`来阻塞执行。为`main`函数创建初始的代码框架。在它的上方，编写[清单2-6](ch02.xhtml#ch2list6)中显示的函数。
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 2-6: A worker function for processing work*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单2-6：用于处理工作的工作函数*'
- en: 'The `worker(int, *sync.WaitGroup)` function takes two arguments: a channel
    of type `int` and a pointer to a `WaitGroup`. The channel will be used to receive
    work, and the `WaitGroup` will be used to track when a single work item has been
    completed.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`worker(int, *sync.WaitGroup)`函数接受两个参数：一个`int`类型的通道和一个指向`WaitGroup`的指针。该通道将用于接收工作，而`WaitGroup`将用于跟踪单个工作项是否已完成。'
- en: Now, add your `main()` function shown in [Listing 2-7](ch02.xhtml#ch2list7),
    which will manage the workload and provide work to your `worker(int, *sync.WaitGroup)`
    function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加你的`main()`函数，如[清单2-7](ch02.xhtml#ch2list7)中所示，它将管理工作负载并向`worker(int, *sync.WaitGroup)`函数提供工作。
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 2-7: A basic worker pool (*[/ch-2/tcp-sync-scanner/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-sync-scanner/main.go)*)*'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单2-7：一个基本的工作池 (*[/ch-2/tcp-sync-scanner/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-sync-scanner/main.go)*)*'
- en: First, you create a channel by using `make()` ❷. A second parameter, an `int`
    value of `100`, is provided to `make()` here. This allows the channel to be *buffered*,
    which means you can send it an item without waiting for a receiver to read the
    item. Buffered channels are ideal for maintaining and tracking work for multiple
    producers and consumers. You’ve capped the channel at 100, meaning it can hold
    100 items before the sender will block. This is a slight performance increase,
    as it will allow all the workers to start immediately.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你使用`make()`创建一个通道 ❷。第二个参数是`int`类型的值`100`，它被提供给`make()`。这使得通道成为*有缓冲的*，这意味着你可以向其中发送数据项，而无需等待接收者读取该数据项。有缓冲的通道非常适合用于维护和追踪多个生产者和消费者的工作。你将通道限制为100，这意味着它可以在发送者阻塞之前最多容纳100个项目。这会略微提高性能，因为它会让所有工作线程立即开始。
- en: Next, you use a `for` loop ❸ to start the desired number of workers—in this
    case, 100\. In the `worker(int, *sync.WaitGroup)` function, you use `range` ❶
    to continuously receive from the `ports` channel, looping until the channel is
    closed. Notice that you aren’t doing any work yet in the worker—that’ll come shortly.
    Iterating over the ports sequentially in the `main()` function, you send a port
    on the `ports` channel ❹ to the worker. After all the work has been completed,
    you close the channel ❺.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你使用`for`循环❸启动所需数量的工作线程——在这个例子中是100个。在`worker(int, *sync.WaitGroup)`函数中，你使用`range`❶不断地从`ports`通道接收数据，循环直到通道关闭。注意，此时你在工作线程中还没有做任何工作——这将在稍后完成。你在`main()`函数中顺序遍历端口，向`ports`通道❹发送端口信息到工作线程。所有工作完成后，你关闭通道❺。
- en: 'Once you build and execute this program, you’ll see your numbers printed to
    the screen. You might notice something interesting here: the numbers are printed
    in no particular order. Welcome to the wonderful world of parallelism.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你构建并执行这个程序，你将看到屏幕上打印出数字。你可能会注意到一些有趣的地方：这些数字并没有按特定顺序打印出来。欢迎来到并行处理的奇妙世界。
- en: Multichannel Communication
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 多通道通信
- en: To complete the port scanner, you could plug in your code from earlier in the
    section, and it would work just fine. However, the printed ports would be unsorted,
    because the scanner wouldn’t check them in order. To solve this problem, you need
    to use a separate thread to pass the result of the port scan back to your main
    thread to order the ports before printing. Another benefit of this modification
    is that you can remove the dependency of a `WaitGroup` entirely, as you’ll have
    another method of tracking completion. For example, if you scan 1024 ports, you’re
    sending on the worker channel 1024 times, and you’ll need to send the result of
    that work back to the main thread 1024 times. Because the number of work units
    sent and the number of results received are the same, your program can know when
    to close the channels and subsequently shut down the workers.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成端口扫描器，你可以插入你在本节前面写的代码，它将正常工作。然而，打印出来的端口将是无序的，因为扫描器不会按顺序检查它们。为了解决这个问题，你需要使用一个单独的线程将端口扫描的结果传回主线程，以便在打印之前对端口进行排序。这个修改的另一个好处是，你可以完全去除`WaitGroup`的依赖，因为你将有另一种方法来跟踪任务完成情况。例如，如果你扫描1024个端口，你将会向工作线程通道发送1024次数据，并且你需要将这些工作结果发送回主线程1024次。因为发送的工作单位数和接收的结果数是相同的，所以你的程序能够知道何时关闭通道并最终关闭工作线程。
- en: This modification is demonstrated in [Listing 2-8](ch02.xhtml#ch2list8), which
    completes the port scanner.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修改在[清单 2-8](ch02.xhtml#ch2list8)中进行了演示，它完成了端口扫描器的功能。
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 2-8: Port scanning with multiple channels (*[/ch-2/tcp-scanner-final/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-final/main.go)*)*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-8: 使用多个通道进行端口扫描 (*[/ch-2/tcp-scanner-final/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/tcp-scanner-final/main.go)*)*'
- en: The `worker(ports, results chan int)` function has been modified to accept two
    channels ❶; the remaining logic is mostly the same, except that if the port is
    closed, you’ll send a zero ❷, and if it’s open, you’ll send the port ❸. Also,
    you create a separate channel to communicate the results from the worker to the
    main thread ❹. You then use a slice ❺ to store the results so you can sort them
    later. Next, you need to send to the workers in a separate goroutine ❻ because
    the result-gathering loop needs to start before more than 100 items of work can
    continue.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`worker(ports, results chan int)`函数已被修改为接受两个通道❶；其余的逻辑大体相同，只是当端口关闭时，你会发送一个零❷，而如果端口是打开的，则会发送该端口❸。此外，你还创建了一个单独的通道来将结果从工作线程传递到主线程❹。然后，你使用一个切片❺来存储结果，以便稍后排序。接下来，你需要在一个单独的goroutine❻中发送数据到工作线程，因为结果收集循环需要在超过100项工作继续之前开始。'
- en: The result-gathering loop ❼ receives on the `results` channel 1024 times. If
    the port doesn’t equal 0, it’s appended to the slice. After closing the channels,
    you’ll use `sort` ❽ to sort the slice of open ports. All that’s left is to loop
    over the slice and print the open ports to screen.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 结果收集循环❼从`results`通道接收1024次。如果端口不等于0，它将被追加到切片中。关闭通道后，你将使用`sort`❽来对打开的端口切片进行排序。剩下的就是遍历切片并将打开的端口打印到屏幕上。
- en: 'There you have it: a highly efficient port scanner. Take some time to play
    around with the code—specifically, the number of workers. The higher the count,
    the faster your program should execute. But if you add too many workers, your
    results could become unreliable. When you’re writing tools for others to use,
    you’ll want to use a healthy default value that caters to reliability over speed.
    However, you should also allow users to provide the number of workers as an option.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样：一个高效的端口扫描器。花点时间玩玩代码——特别是工作进程的数量。数量越多，程序的执行速度应该越快。但是，如果你添加太多工作进程，结果可能会变得不可靠。当你为他人编写工具时，最好使用一个健康的默认值，优先考虑可靠性而非速度。然而，你也应该允许用户提供工作进程的数量作为选项。
- en: You could make a couple of improvements to this program. First, you’re sending
    on the `results` channel for every port scanned, and this isn’t necessary. The
    alternative requires code that is slightly more complex as it uses an additional
    channel not only to track the workers, but also to prevent a race condition by
    ensuring the completion of all gathered results. As this is an introductory chapter,
    we purposefully left this out; but don’t worry! We’ll introduce this pattern in
    [Chapter 3](ch03.xhtml#ch3). Second, you might want your scanner to be able to
    parse port-strings—for example, `80,443,8080,21-25`, like those that can be passed
    to Nmap. If you want to see an implementation of this, see [*https://github.com/blackhat-go/bhg/blob/master/ch-2/scanner-port-format/*](https://github.com/blackhat-go/bhg/blob/master/ch-2/scanner-port-format/).
    We’ll leave this as an exercise for you to explore.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以对这个程序做一些改进。首先，你在每扫描一个端口时都会通过`results`通道发送数据，而这并非必要。另一种方法需要稍微复杂一些的代码，它使用一个额外的通道，不仅用于追踪工作进程，还能通过确保所有结果完成来防止竞态条件。由于这是一个入门章节，我们故意将这一部分省略了；不过不用担心！我们将在[第3章](ch03.xhtml#ch3)介绍这一模式。其次，你可能希望扫描器能够解析端口字符串——例如，`80,443,8080,21-25`，像Nmap可以传递的那样。如果你想看到这个的实现，请参考
    [*https://github.com/blackhat-go/bhg/blob/master/ch-2/scanner-port-format/*](https://github.com/blackhat-go/bhg/blob/master/ch-2/scanner-port-format/)。我们将这部分留给你作为练习来探索。
- en: Building a TCP Proxy
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建 TCP 代理
- en: 'You can achieve all TCP-based communications by using Go’s built-in `net` package.
    The previous section focused primarily on using the `net` package from a client’s
    perspective, and this section will use it to create TCP servers and transfer data.
    You’ll begin this journey by building the requisite *echo server*—a server that
    merely echoes a given response back to a client—followed by two much more generally
    applicable programs: a TCP port forwarder and a re-creation of Netcat’s “gaping
    security hole” for remote command execution.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 Go 内建的 `net` 包来实现所有基于 TCP 的通信。上一节主要从客户端的角度使用 `net` 包，而本节将使用它来创建 TCP
    服务器并传输数据。你将从构建必需的*回声服务器*开始——一个只是简单地将给定响应返回给客户端的服务器——接着是两个更具普遍适用性的程序：一个 TCP 端口转发器和一个重新创建
    Netcat “安全漏洞”以执行远程命令的程序。
- en: Using io.Reader and io.Writer
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 io.Reader 和 io.Writer
- en: 'To create the examples in this section, you need to use two significant types
    that are crucial to essentially all input/output (I/O) tasks, whether you’re using
    TCP, HTTP, a filesystem, or any other means: `io.Reader` and `io.Writer`. Part
    of Go’s built-in `io` package, these types act as the cornerstone to any data
    transmission, local or networked. These types are defined in Go’s documentation
    as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建本节中的示例，你需要使用两个在所有输入/输出（I/O）任务中至关重要的类型，无论你是在使用 TCP、HTTP、文件系统，还是其他任何方式：`io.Reader`
    和 `io.Writer`。这两个类型是 Go 内建的 `io` 包的一部分，作为数据传输（无论是本地的还是网络的）基础。Go 文档中对这两个类型的定义如下：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Both types are defined as interfaces, meaning they can’t be directly instantiated.
    Each type contains the definition of a single exported function: `Read` or `Write`.
    As explained in [Chapter 1](ch01.xhtml#ch1), you can think of these functions
    as abstract methods that must be implemented on a type for it to be considered
    a `Reader` or `Writer`. For example, the following contrived type fulfills this
    contract and can be used anywhere a `Reader` is accepted:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种类型都被定义为接口，这意味着它们不能直接实例化。每种类型都包含一个导出函数的定义：`Read` 或 `Write`。正如在[第1章](ch01.xhtml#ch1)中解释的，你可以将这些函数看作是抽象方法，必须在类型中实现，才能让该类型被视为`Reader`或`Writer`。例如，下面这个人为构造的类型就满足这个契约，可以在任何接受`Reader`的地方使用：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This same idea applies to the `Writer` interface:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相同的思想适用于`Writer`接口：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let’s take this knowledge and create something semi-usable: a custom `Reader`
    and `Writer` that wraps stdin and stdout. The code for this is a little contrived
    since Go’s `os.Stdin` and `os.Stdout` types already act as `Reader` and `Writer`,
    but then you wouldn’t learn anything if you didn’t reinvent the wheel every now
    and again, would you?'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用这些知识创建一些半可用的东西：一个自定义的 `Reader` 和 `Writer`，它们封装了 stdin 和 stdout。这个代码有些牵强，因为
    Go 的 `os.Stdin` 和 `os.Stdout` 类型已经作为 `Reader` 和 `Writer` 使用，但如果你不时地重新发明轮子，你就什么也学不到，不是吗？
- en: '[Listing 2-9](ch02.xhtml#ch2list9) shows a full implementation, and an explanation
    follows.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-9](ch02.xhtml#ch2list9) 显示了完整的实现，接下来是解释。'
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 2-9: A `reader` and `writer` demonstration (*[/ch-2/io-example/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/io-example/main.go)*)*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-9：`reader` 和 `writer` 演示 (*[/ch-2/io-example/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/io-example/main.go)*)*'
- en: 'The code defines two custom types: `FooReader` ❶ and `FooWriter` ❹. On each
    type, you define a concrete implementation of the `Read([]byte)` function ❷ for
    `FooReader` and the `Write([]byte)` function ❺ for `FooWriter`. In this case,
    both functions are reading from stdin ❸ and writing to stdout ❻.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 代码定义了两种自定义类型：`FooReader` ❶ 和 `FooWriter` ❹。在每种类型上，您为 `FooReader` 定义了 `Read([]byte)`
    函数的具体实现 ❷，为 `FooWriter` 定义了 `Write([]byte)` 函数的具体实现 ❺。在本例中，两个函数都从 stdin 读取数据 ❸，并将数据写入
    stdout ❻。
- en: Note that the `Read` functions on both `FooReader` and `os.Stdin` return the
    length of data and any errors. The data itself is copied into the `byte` slice
    passed to the function. This is consistent with the `Reader` interface prototype
    definition provided earlier in this section. The `main()` function creates that
    slice (named `input`) ❼ and then proceeds to use it in calls to `FooReader.Read([]byte``)`
    ❽ and `FooReader.Write([]byte)` ❾.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`FooReader` 和 `os.Stdin` 上的 `Read` 函数返回数据的长度以及任何错误。数据本身会被复制到传递给函数的 `byte`
    切片中。这与本节前面提供的 `Reader` 接口原型定义是一致的。`main()` 函数创建了该切片（名为 `input`）❼，然后在调用 `FooReader.Read([]byte)`
    ❽ 和 `FooReader.Write([]byte)` ❾ 时使用它。
- en: 'A sample run of the program produces the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的示例运行结果如下：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Copying data from a `Reader` to a `Writer` is a fairly common pattern—so much
    so that Go’s `io` package contains a `Copy()` function that can be used to simplify
    the `main()` function. The function prototype is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Reader` 复制数据到 `Writer` 是一种相当常见的模式——以至于 Go 的 `io` 包中包含了一个 `Copy()` 函数，可以用来简化
    `main()` 函数。函数原型如下所示：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This convenience function allows you to achieve the same programmatic behavior
    as before, replacing your `main()` function with the code in [Listing 2-10](ch02.xhtml#ch2list10).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个便捷函数使您能够实现与之前相同的编程行为，将您的 `main()` 函数替换为 [清单 2-10](ch02.xhtml#ch2list10) 中的代码。
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 2-10: Using io.Copy (*[/ch-2/copy-example/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/copy-example/main.go)*)*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-10：使用 io.Copy (*[/ch-2/copy-example/main.go](https://github.com/blackhat-go/bhg/blob/master/ch-2/copy-example/main.go)*)*'
- en: Notice that the explicit calls to `reader.Read([]byte)` and `writer.Write([]byte)`
    have been replaced with a single call to `io.Copy(writer, reader)` ❶. Under the
    covers, `io.Copy(writer, reader)` calls the `Read([]byte)` function on the provided
    reader, triggering the `FooReader` to read from stdin. Subsequently, `io.Copy(writer,
    reader)` calls the `Write([]byte)` function on the provided writer, resulting
    in a call to your `FooWriter`, which writes the data to stdout. Essentially, `io.Copy(writer,
    reader)` handles the sequential read-then-write process without all the petty
    details.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，显式调用 `reader.Read([]byte)` 和 `writer.Write([]byte)` 已经被一个对 `io.Copy(writer,
    reader)` 的调用所替代 ❶。在幕后，`io.Copy(writer, reader)` 会调用提供的 reader 上的 `Read([]byte)`
    函数，从而触发 `FooReader` 从 stdin 读取数据。随后，`io.Copy(writer, reader)` 会调用提供的 writer 上的
    `Write([]byte)` 函数，从而调用您的 `FooWriter`，并将数据写入 stdout。本质上，`io.Copy(writer, reader)`
    处理了顺序的读取然后写入过程，而无需处理所有的细节。
- en: This introductory section is by no means a comprehensive look at Go’s I/O and
    interfaces. Many convenience functions and custom readers and writers exist as
    part of the standard Go packages. In most cases, Go’s standard packages contain
    all the basic implementations to achieve the most common tasks. In the next section,
    let’s explore how to apply these fundamentals to TCP communications, eventually
    using the power vested in you to develop real-life, usable tools.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本介绍性部分绝不是 Go 的 I/O 和接口的全面概述。作为 Go 标准包的一部分，存在许多方便的函数和自定义的读取器与写入器。在大多数情况下，Go 的标准包包含了实现最常见任务的所有基本功能。在下一节中，我们将探讨如何将这些基础应用到
    TCP 通信中，并最终利用这些能力开发实际可用的工具。
- en: Creating the Echo Server
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 Echo 服务器
- en: As is customary for most languages, you’ll start by building an echo server
    to learn how to read and write data to and from a socket. To do this, you’ll use
    `net.Conn`, Go’s stream-oriented network connection, which we introduced when
    you built a port scanner. Based on Go’s documentation for the data type, `Conn`
    implements the `Read([]byte)` and `Write([]byte)` functions as defined for the
    `Reader` and `Writer` interfaces. Therefore, `Conn` is both a `Reader` and a `Writer`
    (yes, this is possible). This makes sense logically, as TCP connections are bidirectional
    and can be used to send (write) or receive (read) data.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 像大多数语言一样，通常你会从构建一个回显服务器开始，学习如何读取和写入数据到套接字。为此，你将使用 Go 的流式网络连接 `net.Conn`，我们在构建端口扫描器时曾介绍过。根据
    Go 对数据类型的文档，`Conn` 实现了 `Read([]byte)` 和 `Write([]byte)` 函数，这些函数是为 `Reader` 和 `Writer`
    接口定义的。因此，`Conn` 既是一个 `Reader` 也是一个 `Writer`（是的，这是可能的）。这在逻辑上是合理的，因为 TCP 连接是双向的，可以用来发送（写入）或接收（读取）数据。
- en: After creating an instance of `Conn`, you’ll be able to send and receive data
    over a TCP socket. However, a TCP server can’t simply manufacture a connection;
    a client must establish a connection. In Go, you can use `net.Listen``(`network`,`
    address string`)` to first open a TCP listener on a specific port. Once a client
    connects, the `Accept()` method creates and returns a `Conn` object that you can
    use for receiving and sending data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了 `Conn` 实例后，你将能够通过 TCP 套接字发送和接收数据。然而，TCP 服务器不能简单地制造一个连接；必须由客户端来建立连接。在 Go
    中，你可以使用 `net.Listen(`network`, `address string`)` 来首先在特定端口上打开一个 TCP 监听器。一旦客户端连接，`Accept()`
    方法会创建并返回一个 `Conn` 对象，你可以用它来接收和发送数据。
- en: '[Listing 2-11](ch02.xhtml#ch2list11) shows a complete example of a server implementation.
    We’ve included comments inline for clarity. Don’t worry about understanding the
    code in its entirety, as we’ll break it down momentarily.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-11](ch02.xhtml#ch2list11) 显示了一个完整的服务器实现示例。我们已经在线内添加了注释以便理解。无需担心完全理解代码，因为我们稍后会详细解析。'
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 2-11: A basic echo server (*[/ch-2/echo-server/main.go](https://gihub.com/blackhat-go/bhg/blob/master/ch-2/echo-server/main.go)*)*'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2-11：一个基础的回显服务器 (*[/ch-2/echo-server/main.go](https://gihub.com/blackhat-go/bhg/blob/master/ch-2/echo-server/main.go)*)*'
- en: '[Listing 2-11](ch02.xhtml#ch2list11) begins by defining a function named `echo(net.Conn)`,
    which accepts a `Conn` instance as a parameter. It behaves as a connection handler
    to perform all necessary I/O. The function loops indefinitely ❶, using a buffer
    to read ❷ and write ❸ data from and to the connection. The data is read into a
    variable named `b` and subsequently written back on the connection.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-11](ch02.xhtml#ch2list11) 首先定义了一个名为 `echo(net.Conn)` 的函数，该函数接受一个 `Conn`
    实例作为参数。它充当连接处理程序，执行所有必要的 I/O 操作。该函数无限循环 ❶，使用缓冲区读取 ❷ 和写入 ❸ 数据到连接中。数据被读取到一个名为 `b`
    的变量中，并随后写回到连接上。'
- en: Now you need to set up a listener that will call your handler. As mentioned
    previously, a server can’t manufacture a connection but must instead listen for
    a client to connect. Therefore, a listener, defined as `tcp` bound to port 20080,
    is started on all interfaces by using the `net.Listen(`network`,` address string`)`
    function ❹.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要设置一个监听器来调用你的处理程序。如前所述，服务器不能制造连接，必须监听客户端连接。因此，通过使用 `net.Listen(`network`,
    `address string`)` 函数 ❹，在所有接口上启动一个绑定到 20080 端口的 `tcp` 监听器。
- en: Next, an infinite loop ❺ ensures that the server will continue to listen for
    connections even after one has been received. Within this loop, you call `listener.Accept()`
    ❻, a function that blocks execution as it awaits client connections. When a client
    connects, this function returns a `Conn` instance. Recall from earlier discussions
    in this section that `Conn` is both a `Reader` and a `Writer` (it implements the
    `Read([]byte)` and `Write([]byte)` interface methods).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，一个无限循环 ❺ 确保即使在接收到一个连接后，服务器仍会继续监听连接。在这个循环中，你会调用 `listener.Accept()` ❻，这是一个会阻塞执行的函数，直到等待客户端连接。当客户端连接时，该函数返回一个
    `Conn` 实例。回想一下我们在本节之前的讨论，`Conn` 既是一个 `Reader` 也是一个 `Writer`（它实现了 `Read([]byte)`
    和 `Write([]byte)` 接口方法）。
- en: 'The `Conn` instance is then passed to the `echo(net.Conn)` handler function
    ❼. This call is prefaced with the `go` keyword, making it a concurrent call so
    that other connections don’t block while waiting for the handler function to complete.
    This is likely overkill for such a simple server, but we’ve included it again
    to demonstrate the simplicity of Go’s concurrency pattern, in case it wasn’t already
    clear. At this point, you have two lightweight threads running concurrently:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Conn` 实例被传递给 `echo(net.Conn)` 处理程序函数 ❼。该调用前加上了 `go` 关键字，变成了并发调用，这样其他连接在等待处理程序函数完成时不会被阻塞。对于如此简单的服务器来说，这可能有些过度，但我们还是再次包含它，目的是展示
    Go 并发模式的简便性，以防之前没有说明清楚。此时，你有两个轻量级线程并发运行：
- en: The main thread loops back and blocks on `listener.Accept()` while it awaits
    another connection.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主线程会回到并阻塞在`listener.Accept()`上，等待另一个连接。
- en: The handler goroutine, whose execution has been transferred to the `echo(net.Conn)`
    function, proceeds to run, processing the data.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理程序 goroutine 的执行已转移到 `echo(net.Conn)` 函数，接下来开始运行，处理数据。
- en: 'The following shows an example using Telnet as the connecting client:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用 Telnet 作为连接客户端的示例：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The server produces the following standard output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器产生以下标准输出：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Revolutionary, right? A server that repeats back to the client exactly what
    the client sent to the server. What a useful and exciting example! It’s quite
    a time to be alive.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 革命性吧？一个服务器能够将客户端发送到服务器的内容完全回传给客户端。多么有用又令人兴奋的示例！现在真是活得好时光。
- en: Improving the Code by Creating a Buffered Listener
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过创建缓冲监听器改进代码
- en: 'The example in [Listing 2-11](ch02.xhtml#ch2list11) works perfectly fine but
    relies on fairly low-level function calls, buffer tracking, and iterative reads/writes.
    This is a somewhat tedious, error-prone process. Fortunately, Go contains other
    packages that can simplify this process and reduce the complexity of the code.
    Specifically, the `bufio` package wraps `Reader` and `Writer` to create a buffered
    I/O mechanism. The updated `echo(net.Conn)` function is detailed here, and an
    explanation of the changes follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[Listing 2-11](ch02.xhtml#ch2list11)中的示例完全可以正常工作，但它依赖于相当底层的函数调用、缓冲区跟踪和迭代读写。这是一个相当繁琐且容易出错的过程。幸运的是，Go
    还包含其他可以简化此过程并减少代码复杂性的包。具体来说，`bufio` 包将 `Reader` 和 `Writer` 封装在一起，创建了一个缓冲 I/O 机制。更新后的
    `echo(net.Conn)` 函数在此详细介绍，下面是对这些变化的解释：'
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: No longer are you directly calling the `Read([]byte)` and `Write([]byte)` functions
    on the `Conn` instance; instead, you’re initializing a new buffered `Reader` and
    `Writer` via `NewReader(`io.Reader`)` ❶ and `NewWriter(`io.Writer`)` ❸. These
    calls both take, as a parameter, an existing `Reader` and `Writer` (remember,
    the `Conn` type implements the necessary functions to be considered both a `Reader`
    and a `Writer`).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你不再直接调用 `Read([]byte)` 和 `Write([]byte)` 函数在 `Conn` 实例上；相反，你通过 `NewReader(io.Reader)`
    ❶ 和 `NewWriter(io.Writer)` ❸ 初始化一个新的缓冲 `Reader` 和 `Writer`。这两个调用都接受一个现有的 `Reader`
    和 `Writer` 作为参数（记住，`Conn` 类型实现了必要的函数，因此可以被视为既是 `Reader` 又是 `Writer`）。
- en: Both buffered instances contain complementary functions for reading and writing
    string data. `ReadString(`byte`)` ❷ takes a delimiter character used to denote
    how far to read, whereas `WriteString(`byte`)` ❹ writes the string to the socket.
    When writing data, you need to explicitly call `writer.Flush()` ❺ to flush write
    all the data to the underlying writer (in this case, a `Conn` instance).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 两个缓冲实例都包含用于读取和写入字符串数据的互补函数。`ReadString(byte)` ❷ 使用一个分隔符字符来表示读取到何处，而 `WriteString(byte)`
    ❹ 则将字符串写入套接字。写入数据时，你需要显式调用 `writer.Flush()` ❺ 来刷新并将所有数据写入到底层写入器（在此案例中为 `Conn`
    实例）。
- en: Although the previous example simplifies the process by using buffered I/O,
    you can reframe it to use the `Copy(Writer, Reader)` convenience function. Recall
    that this function takes as input a destination `Writer` and a source `Reader`,
    simply copying from source to destination.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前一个示例通过使用缓冲 I/O 简化了过程，但你可以重新构建它，使用 `Copy(Writer, Reader)` 便利函数。回想一下，这个函数接受目标
    `Writer` 和源 `Reader` 作为输入，简单地从源复制到目标。
- en: 'In this example, you’ll pass the `conn` variable as both the source and destination
    because you’ll be echoing the contents back on the established connection:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你会将 `conn` 变量作为源和目标传递，因为你将通过已建立的连接将内容回显：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You’ve explored the basics of I/O and applied it to TCP servers. Now it’s time
    to move on to more usable, relevant examples.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经探索了 I/O 的基础并将其应用于 TCP 服务器。现在是时候转向更实用、相关的示例了。
- en: Proxying a TCP Client
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代理 TCP 客户端
- en: Now that you have a solid foundation, you can take what you’ve learned up to
    this point and create a simple port forwarder to proxy a connection through an
    intermediary service or host. As mentioned earlier in this chapter, this is useful
    for trying to circumvent restrictive egress controls or to leverage a system to
    bypass network segmentation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经打下了坚实的基础，你可以将到目前为止学到的内容应用起来，创建一个简单的端口转发器，通过中介服务或主机代理连接。如本章前面提到的，这对于尝试绕过限制性出口控制或利用系统来绕过网络分段非常有用。
- en: 'Before laying out the code, consider this imaginary but realistic problem:
    Joe is an underperforming employee who works for ACME Inc. as a business analyst
    making a handsome salary based on slight exaggerations he included on his resume.
    (Did he really go to an Ivy League school? Joe, that’s not very ethical.) Joe’s
    lack of motivation is matched only by his love for cats—so much so that Joe installed
    cat cameras at home and hosted a site, *joescatcam.website*, through which he
    could remotely monitor the dander-filled fluff bags. One problem, though: ACME
    is onto Joe. They don’t like that he’s streaming his cat cam 24/7 in 4K ultra
    high-def, using valuable ACME network bandwidth. ACME has even blocked its employees
    from visiting Joe’s cat cam website.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示代码之前，先考虑一下这个假设但现实的问题：Joe 是一个表现不佳的员工，他在 ACME 公司担任业务分析师，凭借简历上稍微夸大的内容，拿着一份丰厚的薪水。（他真的去过常春藤盟校吗？Joe，这可不太道德。）Joe
    的动力不足，唯一能与之匹配的只有他对猫的热爱——以至于 Joe 在家里安装了猫咪监控摄像头，并通过网站 *joescatcam.website* 远程监控这些毛茸茸的家伙们。不过有一个问题：ACME
    已经注意到 Joe 了。他们不喜欢 Joe 24/7 使用宝贵的 ACME 网络带宽进行 4K 超高清猫咪直播。ACME 甚至封锁了员工访问 Joe 的猫咪直播网站。
- en: Joe has an idea. “What if I set up a port-forwarder on an internet-based system
    I control,” Joe says, “and force the redirection of all traffic from that host
    to *joescatcam.website*?” Joe checks at work the following day and confirms he
    can access his personal website, hosted at the *joesproxy.com* domain. Joe skips
    his afternoon meetings, heads to a coffee shop, and quickly codes a solution to
    his problem. He’ll forward all traffic received at *http://joesproxy.com* to *http://joescatcam.website*.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Joe 想到了一个主意。“如果我在一个我控制的基于互联网的系统上设置一个端口转发器，”Joe 说，“并强制将所有流量从那个主机重定向到 *joescatcam.website*
    呢？”第二天，Joe 在公司检查，确认他可以访问自己托管在 *joesproxy.com* 域名下的个人网站。Joe 跳过了下午的会议，去了咖啡店，迅速编写了解决问题的代码。他将会把所有接收到的流量从
    *http://joesproxy.com* 转发到 *http://joescatcam.website*。
- en: 'Here’s Joe’s code, which he runs on the *joesproxy.com* server:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Joe 在 *joesproxy.com* 服务器上运行的代码：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Start by examining Joe’s `handle(net.Conn)` function. Joe connects to *joescatcam.website*
    ❶ (recall that this unreachable host isn’t directly accessible from Joe’s corporate
    workstation). Joe then uses `Copy(Writer, Reader)` two separate times. The first
    instance ❸ ensures that data from the inbound connection is copied to the *joescatcam.website*
    connection. The second instance ❹ ensures that data read from *joescatcam.website*
    is written back to the connecting client’s connection. Because `Copy(Writer, Reader)`
    is a blocking function, and will continue to block execution until the network
    connection is closed, Joe wisely wraps his first call to `Copy(Writer, Reader)`
    in a new goroutine ❷. This ensures that execution within the `handle(net.Conn)`
    function continues, and the second `Copy(Writer, Reader)` call can be made.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先查看 Joe 的 `handle(net.Conn)` 函数。Joe 连接到 *joescatcam.website* ❶（回想一下，这个不可达的主机无法直接从
    Joe 的公司工作站访问）。接着，Joe 使用 `Copy(Writer, Reader)` 两次。第一次 ❸ 确保来自入站连接的数据被复制到 *joescatcam.website*
    连接。第二次 ❹ 确保从 *joescatcam.website* 读取的数据被写回到连接的客户端连接。由于 `Copy(Writer, Reader)`
    是一个阻塞函数，并且会一直阻塞直到网络连接关闭，Joe 明智地将对 `Copy(Writer, Reader)` 的第一次调用封装在一个新的 goroutine
    ❷ 中。这确保了 `handle(net.Conn)` 函数内的执行可以继续进行，并且第二次 `Copy(Writer, Reader)` 调用可以执行。
- en: 'Joe’s proxy listens on port 80 and relays any traffic received from a connection
    to and from port 80 on *joescatcam.website.* Joe, that crazy and wasteful man,
    confirms that he can connect to *joescatcam.website* via *joesproxy.com* by connecting
    with `curl`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Joe 的代理监听端口 80，并将从 *joescatcam.website* 上来回传输的任何流量转发过来。Joe，那位疯狂而浪费的人，确认他可以通过
    *joesproxy.com* 连接到 *joescatcam.website*，并使用 `curl` 命令进行连接：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: At this point, Joe has done it. He’s living the dream, wasting ACME-sponsored
    time and network bandwidth while he watches his cats. Today, there will be cats!
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，Joe 已经成功了。他正在过上梦想中的生活，浪费着 ACME 提供的时间和网络带宽，同时看着他的猫。今天，将会有猫咪！
- en: Replicating Netcat for Command Execution
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 模拟 Netcat 执行命令
- en: In this section, let’s replicate some of Netcat’s more interesting functionality—specifically,
    its gaping security hole.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将复制Netcat的一些有趣功能——特别是它的巨大安全漏洞。
- en: '*Netcat* is the TCP/IP Swiss Army knife—essentially, a more flexible, scriptable
    version of Telnet. It contains a feature that allows stdin and stdout of any arbitrary
    program to be redirected over TCP, enabling an attacker to, for example, turn
    a single command execution vulnerability into operating system shell access. Consider
    the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*Netcat*是TCP/IP的瑞士军刀——本质上是Telnet的更灵活、可编程的版本。它包含一个功能，可以将任何任意程序的stdin和stdout通过TCP重定向，使攻击者能够将单个命令执行漏洞转化为操作系统的shell访问。例如，考虑以下内容：'
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This command creates a listening server on port 13337\. Any remote client that
    connects, perhaps via Telnet, would be able to execute arbitrary bash commands—hence
    the reason this is referred to as a *gaping security hole*. Netcat allows you
    to optionally include this feature during program compilation. (For good reason,
    most Netcat binaries you’ll find on standard Linux builds do *not* include this
    feature.) It’s dangerous enough that we’ll show you how to create it in Go!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令在端口13337上创建一个监听服务器。任何通过Telnet等方式连接的远程客户端，都能够执行任意的bash命令——因此，这被称为*巨大的安全漏洞*。Netcat允许你在程序编译过程中可选地包含这个功能。（出于充分的理由，你在标准Linux构建的Netcat二进制文件中通常*不*会找到这个功能。）它足够危险，因此我们将展示如何在Go中创建它！
- en: First, look at Go’s `os/exec` package. You’ll use that for running operating
    system commands. This package defines a type, `Cmd`, that contains necessary methods
    and properties to run commands and manipulate stdin and stdout. You’ll redirect
    stdin (a `Reader`) and stdout (a `Writer`) to a `Conn` instance (which is both
    a `Reader` and a `Writer`).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，查看Go的`os/exec`包。你将使用它来运行操作系统命令。该包定义了一个类型`Cmd`，它包含执行命令和操作stdin和stdout所需的方法和属性。你将把stdin（一个`Reader`）和stdout（一个`Writer`）重定向到一个`Conn`实例（它既是`Reader`也是`Writer`）。
- en: 'When you receive a new connection, you can use the `Command(`name string`,`
    arg ...string`)` function from `os/exec` to create a new `Cmd` instance. This
    function takes as parameters the operating system command and any arguments. In
    this example, hardcode `/bin/sh` as the command and pass `-i` as an argument such
    that you’re in interactive mode, which allows you to manipulate stdin and stdout
    more reliably:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当你收到一个新连接时，可以使用`os/exec`中的`Command(name string, arg ...string)`函数来创建一个新的`Cmd`实例。此函数的参数为操作系统命令和任何参数。在这个例子中，将`/bin/sh`硬编码为命令，并传递`-i`作为参数，这样你就进入了交互模式，这使得你可以更可靠地操作stdin和stdout：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This creates an instance of `Cmd` but doesn’t yet execute the command. You
    have a couple of options for manipulating stdin and stdout. You could use `Copy(Writer,
    Reader)` as discussed previously, or directly assign `Reader` and `Writer` to
    `Cmd`. Let’s directly assign your `Conn` object to both `cmd.Stdin` and `cmd.Stdout`,
    like so:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个`Cmd`实例，但尚未执行命令。你有几种选择来操作stdin和stdout。你可以像之前讨论的那样使用`Copy(Writer, Reader)`，或者直接将`Reader`和`Writer`分配给`Cmd`。让我们直接将你的`Conn`对象分配给`cmd.Stdin`和`cmd.Stdout`，如下所示：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'With the setup of the command and the streams complete, you run the command
    by using `cmd.Run()`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 完成命令和流的设置后，你可以使用`cmd.Run()`来运行命令：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This logic works perfectly fine on Linux systems. However, when tweaking and
    running the program on a Windows system, running `cmd.exe` instead of `/bin/bash`,
    you’ll find that the connecting client never receives the command output because
    of some Windows-specific handling of anonymous pipes. Here are two solutions for
    this problem.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个逻辑在Linux系统上完全有效。然而，当你在Windows系统上调整和运行程序时，运行`cmd.exe`而不是`/bin/bash`，你会发现连接的客户端永远不会收到命令输出，因为Windows特有的匿名管道处理方式。以下是解决该问题的两种方法。
- en: First, you can tweak the code to explicitly force the flushing of stdout to
    correct this nuance. Instead of assigning `Conn` directly to `cmd.Stdout`, you
    implement a custom `Writer` that wraps `bufio.Writer` (a buffered writer) and
    explicitly calls its `Flush` method to force the buffer to be flushed. Refer to
    the “Creating the Echo Server” on [page 35](ch02.xhtml#page_35) for an exemplary
    use of `bufio.Writer`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以调整代码，明确强制刷新stdout来纠正这个细节。你可以通过实现一个自定义的`Writer`来代替直接将`Conn`分配给`cmd.Stdout`，该`Writer`包装了`bufio.Writer`（一个缓冲写入器），并明确调用其`Flush`方法来强制刷新缓冲区。有关`bufio.Writer`的示例用法，请参考[第35页](ch02.xhtml#page_35)中的“创建回显服务器”部分。
- en: 'Here’s the definition of the custom writer, `Flusher`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是自定义写入器`Flusher`的定义：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `Flusher` type implements a `Write([]byte)` function ❶ that writes ❷ the
    data to the underlying buffered writer and then flushes ❸ the output.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flusher`类型实现了一个`Write([]byte)`函数❶，它将数据写入到底层的缓冲写入器中，然后刷新❸输出。'
- en: 'With the implementation of a custom writer, you can tweak the connection handler
    to instantiate and use this `Flusher` custom type for `cmd.Stdout`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现一个自定义写入器，你可以调整连接处理器，以实例化并使用这个`Flusher`自定义类型来处理`cmd.Stdout`：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This solution, while adequate, certainly isn’t elegant. Although working code
    is more important than elegant code, we’ll use this problem as an opportunity
    to introduce the `io.Pipe()` function, Go’s synchronous, in-memory pipe that can
    be used for connecting `Readers` and `Writers`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案虽然足够，但并不优雅。虽然工作代码比优雅的代码更为重要，我们将利用这个问题作为机会来介绍`io.Pipe()`函数——Go语言的同步内存管道，可以用于连接`Readers`和`Writers`：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Using `PipeReader` and `PipeWriter` allows you to avoid having to explicitly
    flush the writer and synchronously connect stdout and the TCP connection. You
    will, yet again, rewrite the handler function:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PipeReader`和`PipeWriter`可以避免显式刷新写入器，并将标准输出与TCP连接同步连接。你将再次重写处理函数：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The call to `io.Pipe()` ❶ creates both a reader and a writer that are synchronously
    connected—any data written to the writer (`wp` in this example) will be read by
    the reader (`rp`). So, you assign the writer to `cmd.Stdout` ❷ and then use `io.Copy(conn,
    rp)` ❸ to link the `PipeReader` to the TCP connection. You do this by using a
    goroutine to prevent the code from blocking. Any standard output from the command
    gets sent to the writer and then subsequently piped to the reader and out over
    the TCP connection. How’s that for elegant?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对`io.Pipe()`的调用❶创建了一个同步连接的读取器和写入器——写入到写入器（本示例中的`wp`）的数据将被读取器（`rp`）读取。因此，你将写入器分配给`cmd.Stdout`❷，然后使用`io.Copy(conn,
    rp)`❸将`PipeReader`链接到TCP连接。通过使用goroutine来防止代码阻塞，你完成了这一操作。命令的任何标准输出都会发送到写入器，然后通过管道传输到读取器并通过TCP连接发送出去。这个实现够优雅吗？
- en: 'With that, you’ve successfully implemented Netcat’s gaping security hole from
    the perspective of a TCP listener awaiting a connection. You can use similar logic
    to implement the feature from the perspective of a connecting client redirecting
    stdout and stdin of a local binary to a remote listener. The precise details are
    left to you to determine, but would likely include the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，从等待连接的TCP监听器的角度，你成功地实现了Netcat的巨大安全漏洞。你可以使用类似的逻辑，从连接客户端的角度实现功能，将本地二进制程序的标准输出和标准输入重定向到远程监听器。具体细节由你来确定，但可能包括以下内容：
- en: Establish a connection to a remote listener via `net.Dial(`network`,` address
    string`)`.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`net.Dial(`network`, `address string`)`建立与远程监听器的连接。
- en: Initialize a `Cmd` via `exec.Command(`name string`,` arg ...string`)`.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`exec.Command(`name string`, `arg ...string`)`初始化一个`Cmd`。
- en: Redirect `Stdin` and `Stdout` properties to utilize the `net.Conn` object.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重定向`Stdin`和`Stdout`属性，以便使用`net.Conn`对象。
- en: Run the command.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行命令。
- en: At this point, the listener should receive a connection. Any data sent to the
    client should be interpreted as stdin on the client, and any data received on
    the listener should be interpreted as stdout. The full code of this example is
    available at [*https://github.com/blackhat-go/bhg/blob/master/ch-2/netcat-exec/*](https://github.com/blackhat-go/bhg/blob/master/ch-2/netcat-exec/main.go)*main.go*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，监听器应该已接收到连接。发送到客户端的任何数据应视为客户端的标准输入(stdin)，而在监听器上接收到的任何数据应视为标准输出(stdout)。此示例的完整代码可在[*https://github.com/blackhat-go/bhg/blob/master/ch-2/netcat-exec/*](https://github.com/blackhat-go/bhg/blob/master/ch-2/netcat-exec/main.go)*main.go*中找到。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: Now that you’ve explored practical applications and usage of Go as it relates
    to networking, I/O, and concurrency, let’s move on to creating usable HTTP clients.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经探索了Go语言在网络、I/O和并发方面的实际应用，让我们继续讨论如何创建可用的HTTP客户端。
