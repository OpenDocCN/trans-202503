- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ENCRYPTION</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">加密</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: Encryption is the principal application of cryptography; it makes data incomprehensible
    to ensure its *confidentiality*. Encryption uses an algorithm called a *cipher*
    and a secret value called the *key*. If you don’t know the secret key, you can’t
    decrypt, nor can you learn any bit of information on the encrypted message—and
    neither can any attacker.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 加密是密码学的主要应用，它使得数据变得不可理解，以确保其*机密性*。加密使用一种叫做*密码算法*的算法和一个称为*密钥*的秘密值。如果你不知道这个秘密密钥，就无法解密，也无法获取任何加密消息中的信息——攻击者也是如此。
- en: This chapter focuses on symmetric encryption, which is the simplest kind of
    encryption. In *symmetric encryption*, the decryption key is the same as the encryption
    key (unlike *asymmetric encryption*, or *public-key encryption*, in which the
    keys are different). You’ll start by learning about the weakest forms of symmetric
    encryption, classical ciphers that are secure against only the most illiterate
    attacker, and then we’ll move on to the strongest forms that are secure forever.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍对称加密，这是最简单的加密方式。在*对称加密*中，解密密钥与加密密钥相同（与*非对称加密*或*公钥加密*不同，后者的密钥是不同的）。你将从学习最简单的对称加密方法开始，这些经典密码仅能抵御最不懂密码学的攻击者，然后我们将继续学习最强的对称加密方法，它们能保证永久的安全。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">The Basics</samp>'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">基础知识</samp>'
- en: 'When encrypting a message, *plaintext* refers to the unencrypted message and
    *ciphertext* to the encrypted message. A cipher is therefore composed of two functions:
    *encryption* turns a plaintext into a ciphertext, and *decryption* turns a ciphertext
    back into a plaintext. But we’ll often say “cipher” when we actually mean “encryption.”
    For example, [Figure 1-1](chapter1.xhtml#fig1-1) shows a cipher, **E**, represented
    as a box taking as input a plaintext, *P*, and a key, *K*, and producing a ciphertext,
    *C*, as output. I’ll write this relation as *C* = **E**(*K*, *P*). Similarly,
    when the cipher is in decryption mode, I’ll write **D**(*K*, *C*).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密消息时，*明文*指的是未加密的消息，*密文*指的是加密后的消息。因此，密码算法由两个功能组成：*加密*将明文转化为密文，*解密*将密文转回明文。但我们通常会说“密码”时，实际上是指“加密”。例如，[图1-1](chapter1.xhtml#fig1-1)展示了一个密码**E**，它接收明文*P*和密钥*K*作为输入，并输出密文*C*。我会将这个关系写作
    *C* = **E**(*K*, *P*)。类似地，当密码处于解密模式时，我会写作 **D**(*K*, *C*)。
- en: '![](../images/fig1-1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig1-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: Basic encryption
    and decryption</samp>'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图1-1：基本加密与解密</samp>
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-10
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*For some ciphers, the ciphertext is the same size as the plaintext; for others,
    the ciphertext is slightly longer. However, ciphertexts can never be shorter than
    plaintexts.*'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于某些密码算法，密文与明文的大小相同；对于其他算法，密文会稍微长一些。但密文永远不可能比明文短。*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Classical Ciphers</samp>
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">经典密码</samp>
- en: Classical ciphers predate computers and therefore work on letters rather than
    on bits, making them much simpler than a modern cipher like the Data Encryption
    Standard. For example, in ancient Rome or during World War I, you couldn’t use
    a computer chip’s power to scramble a message; you had to do everything with only
    pen and paper. There are many classical ciphers, but the most famous are the Caesar
    cipher and Vigenère cipher.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 经典密码出现在计算机之前，因此它们作用于字母而非比特，这使得它们比现代密码算法（如数据加密标准）要简单得多。例如，在古罗马或第一次世界大战期间，你无法利用计算机芯片的能力来加密一条信息；你只能用笔和纸来完成一切。经典密码有很多种，但最著名的有凯撒密码和维吉尼亚密码。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Caesar Cipher</samp>
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">凯撒密码</samp>
- en: The Caesar cipher is so named because the Roman historian Suetonius reported
    that Julius Caesar used it. It encrypts a message by shifting each of the letters
    down three positions in the alphabet, wrapping back around to *A* if the shift
    reaches *Z*. For example, *ZOO* encrypts to *CRR*, *FDHVDU* decrypts to *CAESAR*,
    and so on, as shown in [Figure 1-2](chapter1.xhtml#fig1-2). There’s nothing special
    about the value 3; it’s just easier to compute in one’s head than 11 or 23.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码之所以得名，是因为罗马历史学家苏托尼乌斯报告说尤利乌斯·凯撒使用了它。它通过将每个字母在字母表中向下移动三个位置来加密信息，如果位移到达*Z*，则会回绕到*A*。例如，*ZOO*加密为*CRR*，*FDHVDU*解密为*CAESAR*，等等，如[图1-2](chapter1.xhtml#fig1-2)所示。数字3并没有什么特别之处；它只是比11或23更容易在脑海中计算。
- en: '![](../images/fig1-2.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig1-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-2: The Caesar cipher</samp>'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图1-2：凯撒密码</samp>
- en: 'The Caesar cipher is super easy to break: to decrypt a given ciphertext, simply
    shift the letters three positions back to retrieve the plaintext. That said, the
    Caesar cipher may have been strong enough during the time of Crassus and Cicero.
    Because no secret key is involved (it’s always 3), users of Caesar’s cipher assumed
    that attackers were illiterate or too uneducated to figure it out—an assumption
    that’s much less realistic today. (In fact, in 2006, the Italian police arrested
    a mafia boss after decrypting messages written on small scraps of paper that were
    encrypted using a variant of the Caesar cipher: *ABC* was encrypted to 456 instead
    of *DEF*, for example.)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码非常容易破解：要解密一个给定的密文，只需将字母向回移位三个位置，就能恢复明文。话虽如此，凯撒密码在克拉苏斯和西塞罗时代可能足够强大。因为它没有涉及任何秘密密钥（始终是3），凯撒密码的用户假设攻击者是文盲或太缺乏教育以至于无法破解——而这种假设今天显然不再现实。（事实上，在2006年，意大利警方破译了用凯撒密码变种加密的纸条，成功逮捕了一名黑帮头目。例如，*ABC*被加密为456，而不是*DEF*。）
- en: Could the Caesar cipher be made more secure? You might imagine a version that
    uses a secret shift value instead of always using 3, but that wouldn’t help much
    because an attacker could try all 25 possible shift values until the decrypted
    message makes sense.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒密码能否变得更加安全？你可能会想象一种版本，使用一个秘密的位移值，而不是始终使用3，但这也帮助不大，因为攻击者可以尝试所有25个可能的位移值，直到解密出的消息有意义为止。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Vigenère Cipher</samp>
  id: totrans-20
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">维吉尼亚密码</samp>
- en: It took about 1,500 years to see a meaningful improvement of the Caesar cipher
    in the form of the Vigenère cipher, created in the 16th century by an Italian
    named Giovan Battista Bellaso. The name *Vigenère* comes from the Frenchman Blaise
    de Vigenère, who invented a different cipher in the 16th century, but due to historical
    misattribution, Vigenère’s name stuck. Nevertheless, the Vigenère cipher became
    popular and was later used during the American Civil War by Confederate forces
    and during WWI by the Swiss Army, among others.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 大约花费了1500年，凯撒密码才在16世纪通过意大利人Giovan Battista Bellaso的创造得到了有意义的改进，变成了维吉尼亚密码。*维吉尼亚*这个名字来源于法国人布莱兹·德·维吉尼亚，他在16世纪发明了另一种密码，但由于历史上的错误归因，维吉尼亚的名字最终被使用了。尽管如此，维吉尼亚密码还是变得非常流行，后来在美国内战中被南方联邦军使用，并且在第一次世界大战期间也被瑞士军队使用，等等。
- en: 'The Vigenère cipher is similar to the Caesar cipher, except that letters aren’t
    shifted by three places but rather by values defined by a *key*, a collection
    of letters that represent numbers based on their position in the alphabet. For
    example, if the key is DUH, letters in the plaintext are shifted using the values
    3, 20, 7 because *D* is three letters after *A*, *U* is 20 letters after *A*,
    and *H* is seven letters after *A*. The 3, 20, 7 pattern repeats until you’ve
    encrypted the entire plaintext. For example, the word *CRYPTO* would encrypt to
    *FLFSNV* using DUH as the key: *C* is shifted three positions to *F*, *R* is shifted
    20 positions to *L*, and so on. [Figure 1-3](chapter1.xhtml#fig1-3) illustrates
    this principle when encrypting the sentence *THEY DRINK THE TEA*.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 维吉尼亚密码与凯撒密码类似，不同之处在于字母的位移不是固定的3个位置，而是由一个*密钥*定义的值，密钥是由表示字母位置的字母集合构成，表示数字。例如，如果密钥是DUH，明文中的字母会按照3、20、7的值进行位移，因为*D*是比*A*多3个字母，*U*是比*A*多20个字母，*H*是比*A*多7个字母。3、20、7的模式会一直重复，直到加密整个明文。例如，使用DUH作为密钥，*CRYPTO*会加密为*FLFSNV*：*C*被移位3个位置变成*F*，*R*被移位20个位置变成*L*，依此类推。[图1-3](chapter1.xhtml#fig1-3)展示了加密句子*THEY
    DRINK THE TEA*时的原理。
- en: '![](../images/fig1-3.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig1-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-3: The Vigenère cipher</samp>'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图1-3：维吉尼亚密码</samp>
- en: The Vigenère cipher is clearly more secure than the Caesar cipher, yet it’s
    still fairly easy to break. The first step in decrypting it is to figure out the
    key’s length. Take the example in [Figure 1-3](chapter1.xhtml#fig1-3), wherein
    *THEY DRINK THE TEA* encrypts to *WBLBXYLHRWBLWYH* with the key DUH. (Spaces are
    usually removed to hide word boundaries.) Notice that in the ciphertext *WBLBXYLHRWBLWYH*,
    the group of three letters *WBL* appears twice in the ciphertext at nine-letter
    intervals. This suggests that the same three-letter word was encrypted using the
    same shift values, producing *WBL* each time. A cryptanalyst can then deduce that
    the key’s length is either nine or a value that divides nine (that is, three).
    Furthermore, they may guess that this repeated three-letter word is *THE* and
    therefore determine DUH as a possible encryption key.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 维吉尼亚密码显然比凯撒密码更安全，但它仍然相对容易破解。解密的第一步是找出密钥的长度。以[图1-3](chapter1.xhtml#fig1-3)中的例子为例，*THEY
    DRINK THE TEA*被加密为*WBLBXYLHRWBLWYH*，密钥为DUH。（通常会去除空格以隐藏单词边界。）请注意，在密文*WBLBXYLHRWBLWYH*中，字母组*WBL*在密文中每隔九个字母就出现一次。这表明相同的三字母单词使用相同的移位值进行了加密，每次都会生成*WBL*。密码分析员可以推测密钥的长度是九，或者是可以整除九的值（即三）。此外，他们还可以猜测这个重复的三字母单词是*THE*，从而确定DUH是一个可能的加密密钥。
- en: The second step to breaking the Vigenère cipher is to determine the actual key
    using a method called *frequency analysis*, which exploits the uneven distribution
    of letters in languages. For example, in English, *E* is the most common letter,
    so if you find that *X* is the most common letter in a ciphertext, then the most
    likely plaintext value at this position is *E*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 破解维吉尼亚密码的第二步是使用一种叫做*频率分析*的方法来确定实际的密钥，这种方法利用了语言中字母分布的不均匀性。例如，在英语中，*E*是最常见的字母，因此如果你发现*X*是密文中最常见的字母，那么这个位置最可能的明文值就是*E*。
- en: Despite its relative weakness, the Vigenère cipher may have been good enough
    to securely encrypt messages in its time. Frequency analysis is limited in that
    it requires a few sentences, meaning it won’t work if the cipher is used to encrypt
    short messages. Also, most messages needed to be secret for short periods of time,
    so it didn’t matter if ciphertexts were eventually decrypted by the enemy. (The
    19th-century cryptographer Auguste Kerckhoffs estimated that most encrypted wartime
    messages required confidentiality for only three to four hours.)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管相对较弱，维吉尼亚密码在其时代可能足以安全地加密消息。频率分析的局限性在于它需要几个句子，这意味着如果密码用来加密短消息，它就无法奏效。而且，大多数消息只需要在短时间内保密，因此即使密文最终被敌人解密，也没有太大问题。（19世纪的密码学家奥古斯特·凯尔科夫斯估计，大多数加密的战时消息只需要保密三到四个小时。）
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Ciphers Work</samp>
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">密码的工作原理</samp>
- en: 'Basing ourselves on the simplistic Caesar and Vigenère ciphers, we can try
    to abstract out the workings of a cipher by identifying its two main components:
    a permutation and a mode of operation. A *permutation* is a function that transforms
    an item (in cryptography, a letter or a group of bits) such that each item has
    a unique inverse (for example, the Caesar cipher’s three-letter shift). A *mode
    of operation* is an algorithm that uses a permutation to process messages of arbitrary
    size. The mode of the Caesar cipher is trivial—it just repeats the same permutation
    for each letter—but as you’ve seen, the Vigenère cipher has a more complex mode,
    where letters at different positions undergo different permutations.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 基于简单的凯撒密码和维吉尼亚密码，我们可以尝试通过识别密码的两个主要组成部分：排列和运作模式，来抽象出密码的工作原理。*排列*是一种函数，它将一个项（在加密学中，指的是一个字母或一组比特）转换，使得每个项都有一个唯一的逆（例如，凯撒密码中的三字母移位）。*运作模式*是一个算法，它利用排列来处理任意大小的消息。凯撒密码的运作模式是微不足道的——它只是对每个字母重复相同的排列——但正如你所看到的，维吉尼亚密码有一个更复杂的模式，其中不同位置的字母会经历不同的排列。
- en: In the following sections, I discuss in more detail what these components are
    and how they relate to a cipher’s security. I use each component to show why classical
    ciphers are doomed to be insecure, unlike modern ciphers that run on high-speed
    computers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我将更详细地讨论这些组成部分是什么，以及它们与密码安全的关系。我会使用每个组成部分来展示为什么经典的密码注定是不安全的，而不像现代密码那样可以在高速计算机上运行。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Permutation</samp>
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">排列</samp>
- en: 'Most classical ciphers work by replacing each letter with another letter—in
    other words, by performing a *substitution*. In the Caesar and Vigenère ciphers,
    the substitution is a shift in the alphabet, though the alphabet or set of symbols
    can vary: instead of the English alphabet, it could be the Arabic alphabet; instead
    of letters, it could be words, numbers, or ideograms, for example. The representation
    or encoding of information is a separate matter that is mostly irrelevant to security.
    (We’re considering Latin letters because that’s what classical ciphers use.)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数经典密码都是通过将每个字母替换为另一个字母来工作的——换句话说，通过执行 *替代*。在凯撒密码和维吉尼亚密码中，替代是字母表的移位，尽管字母表或符号集可以有所不同：例如，它可以是阿拉伯字母表，而不是英语字母表；它也可以是单词、数字或表意符号，而不是字母。信息的表示或编码是一个单独的问题，通常与安全性无关。（我们考虑拉丁字母，因为经典密码使用的是这些字母。）
- en: A cipher’s substitution can’t be just any substitution. It should be a permutation,
    which is a rearrangement of the letters *A* to *Z*, such that each letter has
    a unique inverse. For example, a substitution that transforms the letters *A*,
    *B*, *C*, and *D*, respectively, to *C*, *A*, *D*, and *B* is a permutation, because
    each letter maps to another single letter. But a substitution that transforms
    *A*, *B*, *C*, *D* to *D*, *A*, *A*, *C* is not a permutation, because both B
    and C map onto A. With a permutation, each letter has exactly one inverse.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一种密码的替代方式不能是随便的替代方式。它应该是一个置换，即字母 *A* 到 *Z* 的重新排列，使得每个字母都有一个独特的逆转。例如，将字母 *A*、*B*、*C*
    和 *D* 分别转换为 *C*、*A*、*D* 和 *B* 的替代就是一个置换，因为每个字母都映射到另一个单独的字母。但将 *A*、*B*、*C*、*D*
    转换为 *D*、*A*、*A*、*C* 的替代就不是一个置换，因为 B 和 C 都映射到 A。对于置换，每个字母都有唯一的逆转。
- en: 'Still, not every permutation is secure. To be secure, a cipher’s permutation
    should satisfy three criteria:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，并非所有置换都是安全的。为了确保安全，密码的置换应满足三个标准：
- en: '**The permutation should be determined by the key **This keeps the permutation
    secret as long as the key is secret. In the Vigenère cipher, if you don’t know
    the key, you don’t know which of the 26 permutations was used; hence, you can’t
    easily decrypt.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**置换应该由密钥决定 **这可以确保只要密钥是保密的，置换也是保密的。在维吉尼亚密码中，如果你不知道密钥，你就无法知道使用了哪一个置换；因此，你无法轻易地解密。'
- en: '**Different keys should result in different permutations **Otherwise, it becomes
    easier to decrypt without the key: if different keys result in identical permutations,
    that means there are fewer distinct keys than distinct permutations and therefore
    fewer possibilities to try when decrypting without the key. In the Vigenère cipher,
    each letter from the key determines a substitution; there are 26 distinct letters
    and as many distinct permutations.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**不同的密钥应产生不同的置换 **否则，在没有密钥的情况下解密会变得更容易：如果不同的密钥产生相同的置换，那么说明不同的密钥数量少于置换的数量，因此在没有密钥的情况下解密时可尝试的可能性就会减少。在维吉尼亚密码中，每个密钥中的字母决定一个替代方式；有
    26 个不同的字母，也有相同数量的不同置换。'
- en: '**The permutation should look random, loosely speaking **There should be no
    pattern in the ciphertext after performing a permutation, because patterns make
    a permutation predictable for an attacker and therefore less secure. For example,
    the Vigenère cipher’s substitution is pretty predictable: for a given offset,
    if you determine that *A* encrypts to *F*, you could conclude that the shift value
    is 5, and you would also know that *B* encrypts to *G*, that *C* encrypts to *H*,
    and so on. However, with a randomly chosen permutation, knowing that *A* encrypts
    to *F* would tell you only that *B* does *not* encrypt to *F*.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**置换应该看起来是随机的，简单来说 **在执行置换后，密文中不应有任何规律，因为模式会使置换对攻击者来说变得可预测，从而降低安全性。例如，维吉尼亚密码的替代方式是相当可预测的：对于给定的偏移量，如果你确定
    *A* 加密为 *F*，你就可以推断出移位值是 5，并且你也会知道 *B* 加密为 *G*，*C* 加密为 *H*，以此类推。然而，使用随机选择的置换，如果你知道
    *A* 加密为 *F*，你只能知道 *B* *不会* 加密为 *F*。'
- en: We’ll call a permutation that satisfies these criteria a *secure permutation*.
    As you’ll see next, a secure permutation is necessary but insufficient on its
    own for building a secure cipher. A cipher also needs a mode of operation to support
    messages of any length.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将满足这些标准的置换称为 *安全置换*。正如你接下来会看到的，一个安全置换是建立一个安全密码所必需的，但仅凭这一点并不足以保证安全。密码还需要一种操作模式来支持任意长度的消息。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Mode of Operation</samp>
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">操作模式</samp>
- en: Say we have a secure permutation that transforms *A* to *X*, *B* to *M*, and
    *N* to *L*, for example. The word *BANANA* therefore encrypts to *MXLXLX*, where
    each occurrence of *A* is replaced by an *X*. Using the same permutation for all
    the letters in the plaintext thus reveals any duplicate letters. By analyzing
    these duplicates, you might not learn the entire message, but you’ll learn *something*
    about it. In the *BANANA* example, you don’t need the key to guess that the plaintext’s
    three *X* positions share a letter and that another letter is shared at the two
    *L* positions. If you know the message is a fruit’s name, you could determine
    that it’s *BANANA* rather than *CHERRY*, *LYCHEE*, or another six-letter fruit.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个安全的置换，它将 *A* 转换为 *X*，*B* 转换为 *M*，*N* 转换为 *L*，例如。因此，单词 *BANANA* 会加密为 *MXLXLX*，其中每个
    *A* 被替换为 *X*。对于明文中的所有字母使用相同的置换，揭示了任何重复的字母。通过分析这些重复字母，你可能无法了解整个信息，但你会了解 *某些* 信息。在
    *BANANA* 的例子中，你不需要密钥就能猜测出明文中的三个 *X* 位置共享一个字母，而两个 *L* 位置共享另一个字母。如果你知道这个信息是某种水果的名字，你可以确定它是
    *BANANA*（香蕉），而不是 *CHERRY*（樱桃）、*LYCHEE*（荔枝）或其他六个字母的水果。
- en: 'The mode of operation (or *mode*) of a cipher mitigates the exposure of duplicate
    letters in the plaintext by using different permutations for duplicate letters.
    The mode of the Vigenère cipher partially addresses this: if the key is *N* letters
    long, then *N* different permutations will be used for every *N* consecutive letter.
    However, this can still result in patterns in the ciphertext because every *N*th
    letter of the message uses the same permutation. That’s why frequency analysis
    works to break the Vigenère cipher.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 密码的操作模式（或 *模式*）通过对重复字母使用不同的置换，减少了明文中重复字母的暴露。维吉尼亚密码的模式部分解决了这个问题：如果密钥长度为 *N*，那么每
    *N* 个连续字母将使用 *N* 种不同的置换。然而，这仍然可能导致密文中的模式，因为每个第 *N* 个字母使用相同的置换。这就是为什么频率分析能够破解维吉尼亚密码的原因。
- en: 'Frequency analysis can be defeated if the Vigenère cipher encrypts only plaintexts
    that are of the same length as the key. But even then, there’s another problem:
    reusing the same key several times exposes similarities between plaintexts. For
    example, with the key KYN, the words *TIE* and *PIE* encrypt to *DGR* and *ZGR*,
    respectively. Both end with the same two letters (*GR*), revealing that both plaintexts
    share their last two letters as well. Finding these patterns shouldn’t be possible
    with a secure cipher.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果维吉尼亚密码只对与密钥长度相同的明文进行加密，那么频率分析可以被击败。但即便如此，仍然存在另一个问题：多次重复使用相同的密钥会暴露明文之间的相似性。例如，使用密钥
    KYN 时，单词 *TIE* 和 *PIE* 会分别加密为 *DGR* 和 *ZGR*。两者都以相同的两个字母（*GR*）结尾，揭示了两个明文的最后两个字母也相同。一个安全的密码不应该能发现这些模式。
- en: To build a secure cipher, you must combine a secure permutation with a secure
    mode. Ideally, this combination prevents attackers from learning anything about
    a message other than its length.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个安全的密码，必须将安全的置换与安全的模式结合起来。理想情况下，这种结合应该阻止攻击者从消息中获取除长度之外的任何信息。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Why Classical Ciphers
    Are Insecure</samp>
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">为什么经典密码不安全</samp>
- en: Classical ciphers are doomed to be insecure because they’re limited to operations
    you can do in your head or on a piece of paper. They lack the computational power
    of a computer and are easily broken by simple computer programs. Let’s see the
    fundamental reason why that simplicity makes them insecure in today’s world.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 经典密码注定不安全，因为它们仅限于你可以用头脑或纸张进行的操作。它们缺乏计算机的计算能力，且容易被简单的计算机程序破解。让我们看看这种简单性为何使它们在今天的世界中变得不安全。
- en: 'Remember that a cipher’s permutation should look random to be secure. Of course,
    the best way to look random is to *be* random—that is, to select every permutation
    randomly from the set of all permutations. And there are many permutations to
    choose from. In the case of the 26-letter English alphabet, there are approximately
    2^(88) permutations:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，密码的置换应该看起来是随机的，才能是安全的。当然，最好的方法就是 *变* 随机——也就是从所有置换中随机选择每个置换。而且有很多置换可以选择。以26个字母的英语字母表为例，大约有
    2^(88) 种置换：
- en: '![](../images/pg9-1.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg9-1.jpg)'
- en: 'Here, the exclamation point (!) is the factorial symbol, defined as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，感叹号 (!) 是阶乘符号，定义如下：
- en: '![](../images/pg9-2.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg9-2.jpg)'
- en: '(To see why we end up with this number, count the permutations as lists of
    reordered letters: there are 26 choices for the first possible letter, then 25
    possibilities for the second, 24 for the third, and so on.) This number is huge:
    it’s of the same order of magnitude as the number of atoms in the human body.
    But classical ciphers can use only a small fraction of those permutations—namely,
    those that require simple operations (such as shifts) and have a short description
    (like a short algorithm or a small lookup table). The problem is that a secure
    permutation can’t accommodate both of these limitations.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: （要理解为什么我们得出这个数字，可以将置换看作是重新排列字母的列表：第一个字母有26种选择，第二个字母有25种可能，第三个字母有24种可能，以此类推。）这个数字是巨大的：它和人体中的原子数量在同一个数量级。但经典密码只能使用这些置换中的一小部分——即那些需要简单操作（如移位）并且有简短描述（如简短算法或小型查找表）的置换。问题在于，一个安全的置换不能同时满足这两个限制。
- en: You can get secure permutations using simple operations by picking a random
    permutation, representing it as a table of 25 letters (enough to represent a permutation
    of 26 letters, with the 26th one missing), and applying it by looking up letters
    in this table. But then you wouldn’t have a short description. For example, it
    would take 250 letters to describe 10 different permutations, rather than just
    the 10 letters used in the Vigenère cipher.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过简单的操作获得安全的置换，方法是选择一个随机的置换，将其表示为一个包含25个字母的表格（足以表示26个字母的置换，其中缺少第26个字母），然后通过查找这个表中的字母来应用它。但那样你就不会有简短的描述了。例如，描述10种不同的置换将需要250个字母，而不仅仅是维吉尼亚密码中使用的10个字母。
- en: 'You can also produce secure permutations with a short description. Instead
    of just shifting the alphabet, you could use more complex operations such as addition
    and multiplication. This is how modern ciphers work: given a key of typically
    128 or 256 bits, they perform hundreds of bit operations to encrypt a single letter.
    This process is fast on a computer that can do billions of bit operations per
    second, but it would take hours to do by hand and would still be vulnerable to
    frequency analysis.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过简短的描述生成安全的置换。与仅仅移位字母表不同，你可以使用更复杂的操作，如加法和乘法。这就是现代密码的工作方式：给定一个通常为128位或256位的密钥，它们执行数百次比特操作来加密一个字母。在每秒可以进行数十亿次比特操作的计算机上，这一过程非常迅速，但如果手动操作则需要数小时，而且仍然容易受到频率分析的攻击。
- en: '<samp class="SANS_Futura_Std_Bold_B_11">The Perfect Cipher: The One-Time Pad</samp>'
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">完美的密码：一次性密钥</samp>
- en: 'Essentially, a classical cipher can’t be secure unless it comes with a huge
    key, but encrypting with a huge key is impractical. However, the one-time pad
    is such a cipher, and it is the most secure cipher. In fact, it guarantees *perfect
    secrecy*: even if an attacker has unlimited computing power, it’s impossible to
    learn anything about the plaintext except for its length.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，经典密码在没有巨大的密钥的情况下无法保持安全，但使用巨大的密钥进行加密是不实际的。然而，一次性密钥就是这样一种密码，它是最安全的密码。事实上，它保证了*完美的保密性*：即使攻击者拥有无限的计算能力，也无法了解关于明文的任何信息，除了其长度。
- en: In the next sections, I’ll show you how a one-time pad works and then offer
    a sketch of its security proof.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我将向你展示一次性密钥是如何工作的，并提供其安全性证明的概要。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Encryption and Decryption</samp>
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">加密与解密</samp>
- en: The one-time pad takes a plaintext, *P*, and a random key, *K*, that’s the same
    length as *P* and produces a ciphertext, *C*, defined as
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性密钥采用一个明文，*P*，和一个与*P*长度相同的随机密钥，*K*，并生成一个密文，*C*，其定义为：
- en: '![](../images/pg9-3.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg9-3.jpg)'
- en: where *C*, *P*, and *K* are bit strings of the same length and ⊕ is the bitwise
    exclusive OR operation (XOR), defined as 0 ⊕ 0 = 0, 0 ⊕ 1 = 1, 1 ⊕ 0 = 1, 1 ⊕
    1 = 0.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*C*、*P*和*K*是相同长度的比特串，⊕是按位异或操作（XOR），定义为：0 ⊕ 0 = 0，0 ⊕ 1 = 1，1 ⊕ 0 = 1，1 ⊕ 1
    = 0。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*I’m presenting the one-time pad in its usual form, as working on bits, but
    it can be adapted to other symbols. With letters, for example, you’d end up with
    a variant of the Caesar cipher with a shift index picked at random for each letter.*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*我展示的是一次性密钥的常见形式，基于比特操作，但它可以适配其他符号。例如，使用字母时，你将得到一种变种的凯撒密码，其中每个字母的位移指数是随机选定的。*'
- en: 'The one-time pad’s decryption is identical to encryption; it’s just an XOR:
    *P* = *C* ⊕ *K*. Indeed, we can verify *C* ⊕ *K* = *P* ⊕ *K* ⊕ *K* = *P* because
    XORing *K* with itself gives the all-zero string 000 . . . 000\. That’s it—even
    simpler than the Caesar cipher.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性密码本的解密与加密是完全相同的；它只是一个异或操作：*P* = *C* ⊕ *K*。事实上，我们可以验证* C* ⊕ *K* = *P* ⊕ *K*
    ⊕ *K* = *P*，因为将*K*与自身进行异或会得到全零字符串000...000。这就是全部——甚至比凯撒密码还简单。
- en: 'For example, if *P* = 01101101 and *K* = 10110100, then we can calculate the
    following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果*P* = 01101101，*K* = 10110100，那么我们可以计算出以下内容：
- en: '![](../images/pg10-1.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg10-1.jpg)'
- en: 'Decryption retrieves *P* by computing the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 解密通过计算以下内容来恢复*P*：
- en: '![](../images/pg10-2.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg10-2.jpg)'
- en: 'The important thing is that a one-time pad can be used *one time*: each key
    *K* should be used only once. If the same *K* is used to encrypt *P*[1] and *P*[2]
    to *C*[1] and *C*[2], then an eavesdropper can compute the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，一次性密码本只能*使用一次*：每个密钥*K*应该仅使用一次。如果相同的*K*用于加密*P*[1]和*P*[2]，生成的密文是*C*[1]和*C*[2]，那么窃听者可以计算以下内容：
- en: '![](../images/pg10-3.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg10-3.jpg)'
- en: An eavesdropper would thus learn the XOR difference of *P*[1] and *P*[2], information
    that should be kept secret. Moreover, if either plaintext message is known, then
    the other message can be recovered.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，窃听者会了解到*P*[1]和*P*[2]的异或差异，这本应是保密的信息。此外，如果知道其中一个明文消息，那么另一个消息也能被恢复。
- en: The one-time pad is utterly inconvenient to use because it requires a key as
    long as the plaintext and a new random key for each new message or group of data.
    To encrypt a 1TB hard drive, you’d need another 1TB drive to store the key! Nonetheless,
    the one-time pad has been used throughout history—by the British Special Operations
    Executive during World War II, by Soviet spies, by the National Security Agency
    (NSA)—and is still used today in specific contexts. (I’ve heard of Swiss bankers
    who couldn’t agree on a cipher trusted by both parties and ended up using one-time
    pads, but I don’t recommend doing this.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性密码本的使用极其不方便，因为它需要一个与明文一样长的密钥，并且每个新消息或数据组都需要一个新的随机密钥。要加密一个1TB的硬盘，你还需要另一个1TB的硬盘来存储密钥！尽管如此，一次性密码本在历史上被广泛使用——第二次世界大战期间英国特种行动执行部、苏联间谍、美国国家安全局（NSA）都曾使用过，至今在特定的情况下仍然被使用。（我听说过一些瑞士银行家，他们无法达成一致选择一个双方都信任的密码，最后不得不用一次性密码本，但我不建议这样做。）
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Why Is the One-Time
    Pad Secure?</samp>
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">为什么一次性密码本是安全的？</samp>
- en: Although the one-time pad is not practical, it’s important to understand what
    makes it secure. In the 1940s, American mathematician Claude Shannon proved that
    the one-time pad’s key must be at least as long as the message to achieve perfect
    secrecy. The proof’s idea is fairly simple. You assume that the attacker has unlimited
    power and thus can try all the keys. The goal is to encrypt such that the attacker
    can’t rule out any possible plaintext given some ciphertext.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一次性密码本不实用，但理解它的安全性是非常重要的。在20世纪40年代，美国数学家克劳德·香农证明了，要实现完美的保密性，一次性密码本的密钥必须至少与消息一样长。这个证明的思路相当简单。假设攻击者具有无限的能力，因此可以尝试所有的密钥。目标是加密，使得攻击者在给定一些密文的情况下无法排除任何可能的明文。
- en: 'The intuition behind the one-time pad’s perfect secrecy goes as follows: if
    *K* is random, the resulting *C* looks as random as *K* to an attacker because
    the XOR of a random string with any fixed string yields a random string. To see
    this, consider the probability of getting 0 as the first bit of a random string
    (a probability of 1/2). What’s the probability that a random bit XORed with the
    second bit is 0? Right, 1/2 again. The same argument can be iterated over bit
    strings of any length. The ciphertext *C* thus looks random to an attacker that
    doesn’t know *K*, so it’s literally impossible to learn anything about *P* given
    *C*, even for an attacker with unlimited time and power. In other words, knowing
    the ciphertext gives no information whatsoever about the plaintext except its
    length—pretty much the definition of a secure cipher.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性密码本完美保密性的直觉如下：如果*K*是随机的，那么生成的密文*C*对于攻击者来说看起来就像*K*一样随机，因为将一个随机字符串与任何固定字符串进行异或运算都会得到一个随机字符串。为了理解这一点，考虑一下随机字符串的第一个比特是0的概率（为1/2）。那么随机比特与第二个比特进行异或得到0的概率是多少呢？对，仍然是1/2。这个论证可以在任意长度的比特串上进行迭代。因此，密文*C*对于不知道*K*的攻击者来说看起来是随机的，所以即使是拥有无限时间和能力的攻击者，也无法从*C*中得出关于*P*的任何信息。换句话说，知道密文并不能提供关于明文的任何信息，除了它的长度——这几乎就是安全密码的定义。
- en: For example, if a ciphertext is 128 bits long (meaning the plaintext is 128
    bits as well), there are 2^(128) possible ciphertexts; therefore, there should
    be 2^(128) possible plaintexts from the attacker’s point of view. But if there
    are fewer than 2^(128) possible keys, the attacker can rule out some plaintexts.
    If the key is only 64 bits, for example, the attacker can determine the 2^(64)
    possible plaintexts and rule out the overwhelming majority of 128-bit strings.
    The attacker wouldn’t learn what the plaintext is, but they would learn what the
    plaintext is not, which makes the encryption’s secrecy imperfect.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果密文长度为128位（意味着明文也是128位），则有2^(128)种可能的密文；因此，从攻击者的角度来看，应该有2^(128)种可能的明文。但是，如果可能的密钥少于2^(128)，攻击者可以排除一些明文。例如，如果密钥只有64位，攻击者可以确定2^(64)种可能的明文，并排除绝大多数128位字符串。攻击者不能得知明文是什么，但他们能知道明文是什么不是，这使得加密的保密性变得不完美。
- en: You must have a key as long as the plaintext to achieve perfect security, but
    this quickly becomes impractical for real-world use. Next, I’ll discuss the approaches
    taken in modern-day encryption to achieve the best security that’s both possible
    and practical.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现完美的安全性，你必须拥有与明文一样长的密钥，但这对于实际使用来说很快就变得不切实际。接下来，我将讨论现代加密方法，以实现既可能又实际的最佳安全性。
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">Encryption Security</samp>'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '### <samp class="SANS_Futura_Std_Bold_B_11">加密安全</samp>'
- en: Classical ciphers aren’t secure, but a perfectly secure cipher like the one-time
    pad is impractical. We’ll thus have to give a little in terms of security if we
    want secure *and* usable ciphers. But what does *secure* really mean, besides
    the obvious and informal “eavesdroppers can’t decrypt secure messages”?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的密码不安全，但像一次性密钥这样的完全安全的密码是不切实际的。因此，如果我们想要既安全又可用的密码，就必须在安全性上做出一定的妥协。但是，除了显而易见的、非正式的“窃听者无法解密安全消息”之外，*安全*到底意味着什么呢？
- en: 'A cipher is secure if, even given a large number of plaintext–ciphertext pairs,
    *nothing can be learned* about the cipher’s behavior when applied to other plaintexts
    or ciphertexts. This opens up new questions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个密码是安全的，如果即使给定大量明文–密文对，*也无法得知*该密码在应用于其他明文或密文时的行为。这引出了新的问题：
- en: How does an attacker come by these pairs? How large is a “large number”? This
    is all defined by *attack models*, assumptions about what the attacker can and
    cannot do.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击者是如何得到这些明文–密文对的？什么是“足够大”的数字？这些都由*攻击模型*定义，即对攻击者能做什么和不能做什么的假设。
- en: What could be “learned,” and what “cipher’s behavior” are we talking about?
    This is defined by *security goals*, descriptions of what is considered a successful
    attack.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是可以“学到”的？我们说的“密码的行为”是什么？这些由*安全目标*定义，即对什么算作成功攻击的描述。
- en: Attack models and security goals must go together; you can’t claim that a system
    is secure without explaining against whom or from what it’s safe. A *security
    notion* is the combination of a security goal with an attack model. We’ll say
    that a cipher *achieves* a certain security notion if any attacker working in
    a given model can’t break the security goal.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击模型和安全目标必须配合使用；你不能仅仅声称一个系统是安全的，而不解释它是针对谁或防止什么的。*安全概念*是安全目标与攻击模型的结合。如果在给定模型中，任何攻击者都无法突破安全目标，我们就说某个密码*实现了*某个安全概念。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Attack Models</samp>
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">攻击模型</samp>
- en: 'An attack model is a set of assumptions about how attackers might interact
    with a cipher and what they can and can’t do. The goals of an attack model are
    as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击模型是一组关于攻击者如何与密码交互以及他们能做什么和不能做什么的假设。攻击模型的目标如下：
- en: To set requirements for cryptographers who design ciphers so that they know
    what attackers and what kinds of attacks to protect against.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为设计密码的密码学家设定要求，使他们知道要保护自己免受哪些攻击者及其攻击类型。
- en: To give guidelines to users about whether a cipher will be safe to use in their
    environment.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了给用户提供关于某个密码是否在他们的环境中安全使用的指导。
- en: To provide clues for cryptanalysts who attempt to break ciphers so they know
    whether a given attack is valid. An attack is valid only if it’s doable in the
    model considered.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了给试图破解密码的密码分析师提供线索，让他们知道某个攻击是否有效。只有在考虑的模型中可行的攻击才是有效的。
- en: Attack models don’t need to match reality exactly; they’re an approximation.
    As the statistician George E. P. Box put it, “All models are wrong; the practical
    question is how wrong do they have to be to not be useful.” To be useful in cryptography,
    attack models should at least encompass what attackers can actually do to attack
    a cipher. It’s beneficial if a model overestimates attackers’ capabilities because
    it helps anticipate future attack techniques—only the paranoid cryptographers
    survive. A bad model underestimates attackers and provides false confidence in
    a cipher by making it seem secure in theory when it’s not secure in reality.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击模型不需要完全符合现实；它们只是近似值。正如统计学家乔治·E·P·博克斯所说：“所有模型都是错误的；实际的问题是它们必须错到什么程度才不再有用。”为了在密码学中有用，攻击模型至少应涵盖攻击者可以实际用来攻击加密算法的手段。如果一个模型高估了攻击者的能力，这是有益的，因为它有助于预测未来的攻击技术——只有偏执的密码学家才能生存。一个糟糕的模型低估了攻击者的能力，通过让它看起来理论上安全而实际上不安全，提供了对加密算法的虚假信心。
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Kerckhoffs’s Principle</samp>'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">克尔克霍夫原则</samp>'
- en: 'One assumption made in all models is *Kerckhoffs’s principle*, which states
    that the security of a cipher should rely only on the secrecy of the key and not
    on the secrecy of the cipher. This may sound obvious today, when ciphers and protocols
    are publicly specified and used by everyone. But historically, Dutch linguist
    Auguste Kerckhoffs was referring to military encryption machines specifically
    designed for a given army or division. Quoting from his 1883 essay, “La Cryptographie
    Militaire,” where he listed six requirements of a military encryption system:
    “The system must not require secrecy and can be stolen by the enemy without causing
    trouble.”'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模型中都有一个假设，即*克尔克霍夫原则*，该原则指出，加密算法的安全性应仅依赖于密钥的保密性，而不是加密算法的保密性。今天，当加密算法和协议是公开指定并为所有人使用时，这听起来可能显而易见。但从历史上看，荷兰语言学家奥古斯特·克尔克霍夫指的是专门为特定军队或分队设计的军事加密机器。引用他1883年在《军事密码学》一文中的话，他列出了军事加密系统的六个要求：“该系统不需要保密，且可以被敌人窃取而不会造成问题。”
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Black-Box Models</samp>
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">黑盒模型</samp>
- en: Let’s consider some useful attack models expressed in terms of what the attacker
    can observe and what queries they can make to the cipher. A *query* for our purposes
    is the operation that sends an input value to some function and gets the output
    in return, without exposing the details of that function. An *encryption query*,
    for example, takes a plaintext and returns a corresponding ciphertext, without
    revealing the secret key.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些有用的攻击模型，这些模型通过攻击者能够观察到的内容和他们可以对加密算法进行的查询来表达。对于我们来说，一个*查询*是将一个输入值发送到某个函数并返回输出的操作，而不暴露该函数的详细信息。例如，一个*加密查询*会接受一个明文并返回相应的密文，而不透露秘密密钥。
- en: We call these *black-box models* because the attacker sees only what goes in
    and out of the cipher. For example, some smart card chips securely protect a cipher’s
    internals as well as its keys, yet you’re allowed to connect to the chip and ask
    it to decrypt any ciphertext. The attacker would then receive the corresponding
    plaintext, which may help them determine the key. That’s a real example where
    *decryption queries* are possible.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这些为*黑盒模型*，因为攻击者只能看到加密算法的输入和输出。例如，一些智能卡芯片能够安全地保护加密算法的内部工作原理及其密钥，但你可以连接到该芯片并要求它解密任何密文。攻击者随后会收到相应的明文，这可能有助于他们确定密钥。这是一个*解密查询*可行的真实示例。
- en: 'There are several different black-box attack models. Here, I list them in order
    from weakest to strongest, describing attackers’ capabilities for each model:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 黑盒攻击模型有几种不同类型。这里，我将它们按从最弱到最强的顺序列出，并描述每种模型下攻击者的能力：
- en: '**Ciphertext-only attackers (COAs) **Observe ciphertexts but don’t know the
    associated plaintexts or how the plaintexts were selected. Attackers in the COA
    model are passive and can’t perform encryption or decryption queries.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**仅密文攻击者（COA）**观察密文，但不知道关联的明文或明文是如何选择的。COA模型中的攻击者是被动的，无法执行加密或解密查询。'
- en: '**Known-plaintext attackers (KPAs) **Observe ciphertexts and do know the associated
    plaintexts. Attackers in the KPA model thus get a list of plaintext–ciphertext
    pairs, where plaintexts are assumed to be randomly selected. KPA is a passive
    attacker model.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**已知明文攻击者（KPA）**观察密文并且知道关联的明文。KPA模型中的攻击者因此可以得到一组明文–密文对，假设这些明文是随机选择的。KPA是一种被动攻击模型。'
- en: '**Chosen-plaintext attackers (CPAs) **Can perform encryption queries for plaintexts
    of their choice and observe the resulting ciphertexts. This model captures situations
    where attackers can choose all or part of the encrypted plaintexts and then get
    to see the ciphertexts. Unlike COA or KPA, which are passive models, CPAs are
    *active* attackers because they influence the encryption processes rather than
    passively eavesdropping.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择明文攻击者（CPAs）**可以执行选择明文的加密查询，并观察生成的密文。该模型捕捉了攻击者可以选择所有或部分加密明文并查看其密文的情形。与COA或KPA等被动模型不同，CPAs是*主动*攻击者，因为他们影响加密过程，而不是被动监听。'
- en: '**Chosen-ciphertext attackers (CCAs) **Can both encrypt and decrypt; that is,
    they get to perform encryption queries and decryption queries (of ciphertexts
    different from the targeted ciphertext). The CCA model may sound ludicrous at
    first—if you can decrypt, what else do you need?—but like the CPA model, it aims
    to represent situations where attackers can have some influence on the ciphertext
    and later get access to the plaintext. Moreover, decryption is not always enough
    to break a system. For example, some video-protection devices allow attackers
    to perform encryption queries and decryption queries using the device’s chip,
    but in that context, attackers are interested in the key in order to redistribute
    it; in this case, being able to decrypt “for free” isn’t sufficient to break the
    system.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择密文攻击者（CCAs）**可以执行加密和解密操作；也就是说，他们可以进行加密查询和解密查询（对不同于目标密文的密文进行查询）。最初，CCA模型可能听起来很荒谬——如果你能解密，还有什么需要的吗？——但与CPA模型一样，它旨在表示攻击者可以对密文施加某些影响并随后获取明文的情况。此外，解密并不总是足以破解系统。例如，某些视频保护设备允许攻击者使用设备芯片执行加密查询和解密查询，但在这种情况下，攻击者对密钥感兴趣，以便重新分发密钥；在这种情况下，仅仅能够“免费”解密并不足以破解系统。'
- en: In the preceding models, ciphertexts that are observed as well as queried don’t
    come for free. Each ciphertext comes from the computation of the encryption function.
    This means that generating 2*^N* plaintext–ciphertext pairs through encryption
    queries takes about as much computation as trying 2*^N* keys, for example. The
    cost of queries should be taken into account when computing the cost of an attack.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述模型中，被观察和查询的密文并不是免费的。每个密文都是通过加密函数计算得来的。这意味着，通过加密查询生成2*^N*对明文–密文对的计算量大致相当于尝试2*^N*个密钥的计算量。例如，在计算攻击成本时应该考虑查询的成本。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Gray-Box Models</samp>
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">灰盒模型</samp>
- en: In a *gray-box model*, the attacker has access to a cipher’s *implementation*.
    This makes gray-box models more realistic than black-box models for applications
    such as smart cards, embedded systems, and virtualized systems, to which attackers
    often have physical access and can thus tamper with the algorithms’ internals.
    By the same token, gray-box models are more difficult to define than black-box
    ones because they depend on physical, analog properties rather than just on an
    algorithm’s input and outputs, and crypto theory often fails to abstract the complexity
    of the real world.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在*灰盒模型*中，攻击者可以访问加密算法的*实现*。这使得灰盒模型比黑盒模型更具现实性，尤其是在智能卡、嵌入式系统和虚拟化系统等应用中，因为攻击者通常可以物理接触到这些系统，从而有可能篡改算法的内部细节。因此，灰盒模型比黑盒模型更难定义，因为它们依赖于物理、模拟特性，而不仅仅是依赖于算法的输入和输出，而密码学理论往往无法抽象出现实世界的复杂性。
- en: '*Side-channel attacks* are a family of attacks within gray-box models. A side
    channel is a source of information that depends on the implementation of the cipher,
    be it in software or in hardware. Side-channel attackers observe or measure analog
    characteristics of a cipher’s implementation but don’t alter its integrity; they
    are *noninvasive*. For pure software implementations, typical side channels are
    the execution time and the behavior of the system that surrounds the cipher, such
    as error messages, return values, and branches. In the case of implementations
    on smart cards, for example, typical side-channel attackers measure power consumption,
    electromagnetic emanations, or acoustic noise.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*旁路攻击*是一类在灰盒模型中的攻击。旁路是指依赖于密码实现的一个信息源，无论是在软件中还是硬件中。旁路攻击者观察或测量密码实现的模拟特征，但不会改变其完整性；它们是*非侵入性的*。对于纯软件实现，典型的旁路通道包括执行时间和系统中与密码相关的行为，如错误消息、返回值和分支。以智能卡实现为例，典型的旁路攻击者可能会测量功耗、电磁辐射或声学噪音。'
- en: '*Invasive attacks* are a family of attacks on cipher implementations that are
    more powerful than side-channel attacks and are more expensive because they often
    require sophisticated equipment. You can run basic side-channel attacks with a
    standard PC and an off-the-shelf oscilloscope, but invasive attacks may require
    tools such as a high-resolution microscope and a chemical lab. Invasive attacks
    consist of a whole set of techniques and procedures, including using nitric acid
    to remove a chip’s packaging, acquiring microscopic imagery, partial reverse engineering,
    and modifying the chip’s behavior with techniques such as laser fault injection
    and electromagnetic injections.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*侵入性攻击*是一类针对密码实现的攻击，比旁路攻击更为强大且成本更高，因为它们通常需要复杂的设备。你可以使用标准PC和普通示波器进行基本的旁路攻击，但侵入性攻击可能需要如高分辨率显微镜和化学实验室等工具。侵入性攻击包括一整套技术和程序，包括使用硝酸去除芯片包装、获取显微图像、部分逆向工程，以及通过激光故障注入和电磁注入等技术修改芯片行为。'
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Goals</samp>'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">安全目标</samp>'
- en: 'I’ve informally defined the goal of security as “nothing can be learned about
    the cipher’s behavior.” To turn this idea into a rigorous mathematical definition,
    cryptographers define two security goals that correspond to different ideas of
    what it means to learn about a cipher’s behavior:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我非正式地将安全的目标定义为“无法从密码的行为中获得任何信息”。为了将这个概念转化为严格的数学定义，密码学家定义了两个安全目标，分别对应于了解密码行为的不同概念：
- en: '**Indistinguishability (IND) **Ciphertexts should be indistinguishable from
    random strings. This is usually illustrated with a hypothetical game: if an attacker
    picks two plaintexts and then receives a ciphertext of one of the two (chosen
    at random), they shouldn’t be able to tell which plaintext was encrypted, even
    by performing encryption queries with the two plaintexts (and decryption queries,
    if the model is CCA rather than CPA).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可区分性 (IND) **密文应该与随机字符串无法区分。通常通过一个假设的游戏来说明：如果攻击者选择两个明文，并随机获得其中一个明文的密文，那么他们应该无法判断出到底是哪一个明文被加密，即使他们通过对这两个明文进行加密查询（如果模型是CCA而非CPA，还包括解密查询）也无法得出结论。'
- en: '**Nonmalleability (NM) **Given a ciphertext *C*[1] = **E**(*K*, *P*[1]), it
    should be impossible to create another ciphertext, *C*[2], whose corresponding
    plaintext, *P*[2], is related to *P*[1] in a meaningful way (for example, to create
    a *P*[2] that is equal to *P*[1] ⊕ 1 or to *P*[1] ⊕ *X* for some known value,
    *X*). Surprisingly, the one-time pad is malleable: given a ciphertext *C*[1] =
    *P*[1] ⊕ *K*, you can define *C*[2] = *C*[1] ⊕ 1, which is a valid ciphertext
    of *P*[2] = *P*[1] ⊕ 1 under the same key *K*. Oops, so much for our perfect cipher.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可篡改性 (NM) **给定密文*C*[1] = **E**(*K*, *P*[1])，应该不可能创建另一个密文*C*[2]，其对应的明文*P*[2]在某种有意义的方式上与*P*[1]相关（例如，创建一个*P*[2]，使其等于*P*[1]
    ⊕ 1，或等于*P*[1] ⊕ *X*，其中*X*是已知的某个值）。令人惊讶的是，一次性密钥是可篡改的：给定密文*C*[1] = *P*[1] ⊕ *K*，你可以定义*C*[2]
    = *C*[1] ⊕ 1，这也是一个有效的密文，解密得到*P*[2] = *P*[1] ⊕ 1，且使用相同的密钥*K*。哎呀，看来我们的完美密码也不是那么完美。'
- en: Next, I’ll discuss these security goals in the context of different attack models.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将讨论这些安全目标在不同攻击模型中的应用。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Notions</samp>
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">安全概念</samp>
- en: Security goals are useful only when combined with an attack model. The convention
    is to write a security notion as *GOAL*-*MODEL*. For example, IND-CPA denotes
    indistinguishability against chosen-plaintext attackers, NM-CCA denotes nonmalleability
    against chosen-ciphertext attackers, and so on. Let’s start with the security
    goals for an attacker.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 安全目标只有在结合攻击模型时才有意义。惯例是将安全概念写作*目标*-*模型*。例如，IND-CPA表示针对选择明文攻击者的不可区分性，NM-CCA表示针对选择密文攻击者的不可篡改性，等等。让我们从攻击者的安全目标开始。
- en: '<samp class="SANS_Futura_Std_Bold_Condensed_B_11">Semantic Security and Randomized
    Encryption: IND-CPA</samp>'
  id: totrans-110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">语义安全与随机化加密：IND-CPA</samp>
- en: 'The most important security notion is IND-CPA, also called *semantic security*.
    It captures the intuition that ciphertexts shouldn’t leak any information about
    plaintexts as long as the key is secret. To achieve IND-CPA security, encryption
    must return different ciphertexts if called twice on the same plaintext; otherwise,
    an attacker could identify duplicate plaintexts from their ciphertexts, contradicting
    the definition that ciphertexts shouldn’t reveal any information. But note that
    even the IND-CPA-secure scheme will inevitably leak one piece of information about
    the plaintext: its length, or at least approximate length. This is why encrypting
    compressed data is generally not a good idea, as the size of the compressed data
    can reveal information on the original data.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的安全概念是IND-CPA，也称为*语义安全*。它表达了这样一种直觉：只要密钥保密，密文就不应该泄漏任何关于明文的信息。为了实现IND-CPA安全，加密必须在对相同明文加密两次时返回不同的密文；否则，攻击者就可能通过密文识别出重复的明文，从而违背了密文不应泄漏任何信息的定义。但需要注意的是，即使是IND-CPA安全的方案，也不可避免地会泄漏关于明文的一条信息：它的长度，或者至少是大致长度。这就是为什么加密压缩数据通常不是一个好主意，因为压缩数据的大小可能会泄漏原始数据的一些信息。
- en: One way to achieve IND-CPA security is to use *randomized encryption*. As the
    name suggests, it randomizes the encryption process and returns different ciphertexts
    when the same plaintext is encrypted twice. Encryption can then be expressed as
    *C* = **E**(*K*, *R*, *P*), where *R* is fresh random bits. Decryption remains
    deterministic, however, because given **D**(*K*, *R*, *C*), you should always
    get *P*, regardless of the value of *R*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 实现IND-CPA安全性的一种方法是使用*随机化加密*。顾名思义，它随机化加密过程，并且当相同明文被加密两次时，返回不同的密文。加密可以表示为*C* =
    **E**(*K*, *R*, *P*)，其中*R*是新生成的随机位。然而，解密仍然是确定性的，因为给定**D**(*K*, *R*, *C*)，无论*R*的值如何，你总是应该得到*P*。
- en: What if encryption isn’t randomized? In the IND game introduced in the “Security
    Goals” section on the previous page, the attacker picks two plaintexts, *P*[1]
    and *P*[2], and receives a ciphertext of one of the two but doesn’t know which
    plaintext the ciphertext corresponds to. That is, they get *C*i = **E**(*K*, *P*i)
    and have to guess whether *i* is 1 or 2\. In the CPA model, the attacker can perform
    encryption queries to determine both *C*[1] = **E**(*K*, *P*[1]) and *C*[2] =
    **E**(*K*, *P*[2]). If encryption isn’t randomized, it suffices to see if *C*i
    is equal to *C*[1] or to *C*[2] in order to determine which plaintext was encrypted
    and thereby win the IND game. Therefore, randomization is key to the IND-CPA notion.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加密没有随机化怎么办？在前一页“安全目标”部分介绍的IND游戏中，攻击者选择两个明文，*P*[1] 和 *P*[2]，并收到其中一个的密文，但不知道密文对应的是哪个明文。也就是说，他们得到*C*i
    = **E**(*K*, *P*i)，并必须猜测*i*是1还是2。在CPA模型中，攻击者可以执行加密查询来确定*C*[1] = **E**(*K*, *P*[1])和*C*[2]
    = **E**(*K*, *P*[2])。如果加密没有随机化，只需查看*C*i是否等于*C*[1]或*C*[2]，就可以确定加密的是哪个明文，从而赢得IND游戏。因此，随机化是IND-CPA概念的关键。
- en: If you don’t have a pseudorandom generator, you may still achieve IND-CPA security
    by using an encryption scheme that requires a *nonce* (or *number used only once*),
    rather than a random, unpredictable value. A nonce must be unique for every new
    encryption call. A mere counter (1, 2, 3, . . .) would do the trick. For example,
    AES-CTR (the AES block cipher used in CTR mode) is IND-CPA if its additional input,
    the nonce, is unique. Unlike some randomized encryption schemes that just use
    randomness as part of the encryption process, the nonce is *necessary to decrypt*
    with algorithms using nonces.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有伪随机生成器，仍然可以通过使用需要*唯一数值*（或*仅使用一次的数字*）的加密方案来实现IND-CPA安全，而不是使用随机且不可预测的值。每次新的加密调用必须使用唯一的nonce。一个简单的计数器（1,
    2, 3, ...）就能起作用。例如，AES-CTR（在CTR模式下使用的AES块密码）是IND-CPA安全的，只要它的附加输入nonce是唯一的。与一些随机化加密方案不同，后者仅将随机性作为加密过程的一部分，nonce是*解密时必需的*，对于使用nonce的算法尤为重要。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*With randomized encryption, ciphertexts must be slightly longer than plaintexts
    to allow for more than one possible ciphertext per plaintext. For example, if
    there are 2**^(64)* *possible ciphertexts per plaintext, ciphertexts must be at
    least 64 bits longer than plaintexts.*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*对于随机化加密，密文必须比明文稍长，以允许每个明文对应多个可能的密文。例如，如果每个明文有2**^(64)* *种可能的密文，密文必须比明文长至少64位。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Semantically Secure Encryption</samp>
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">语义安全加密</samp>
- en: 'One of the simplest constructions of a semantically secure cipher uses a *deterministic
    random bit generator (DRBG)*, an algorithm that returns random-looking bits given
    some secret value:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个语义安全密码最简单的方式之一是使用*确定性随机位生成器（DRBG）*，这是一种给定某个秘密值后返回看似随机位的算法：
- en: '![](../images/pg16-1.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg16-1.jpg)'
- en: 'Here, *R* is a string randomly chosen for each new encryption and given to
    a DRBG along with the key (*K* || *R* denotes the string consisting of *K* followed
    by *R*). This approach is reminiscent of the one-time pad: instead of picking
    a random key of the same length as the message, we leverage a random bit generator
    to get a random-looking string.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*R*是为每个新的加密随机选择的字符串，并与密钥一起传递给DRBG（*K* || *R*表示由*K*后跟*R*组成的字符串）。这种方法让人联想到一次性密钥：我们不是选择与消息长度相同的随机密钥，而是利用随机位生成器得到一个看似随机的字符串。
- en: 'The proof that this cipher is IND-CPA secure is simple, if we assume that the
    DRBG produces random bits. The proof works ad absurdum: if you can distinguish
    ciphertexts from random strings, which means you can distinguish **DRBG**(*K*
    || *R*) ⊕ *P* from random, then this means you can distinguish **DRBG**(*K* ||
    *R*) from random. Remember that the CPA model lets you get ciphertexts for chosen
    values of *P*, so you can XOR *P* to **DRBG**(*K* || *R*) ⊕ *P* and get **DRBG**(*K*
    || *R*). But now we have a contradiction because we started by assuming that **DRBG**(*K*
    || *R*) can’t be distinguished from random, producing random strings. So we conclude
    that ciphertexts can’t be distinguished from random strings and therefore that
    the cipher is secure.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 证明该密码是IND-CPA安全的过程很简单，前提是我们假设DRBG生成随机位。该证明是归谬法：如果你能区分密文与随机字符串，意味着你能区分**DRBG**(*K*
    || *R*) ⊕ *P*与随机字符串，那么这意味着你能区分**DRBG**(*K* || *R*)与随机字符串。请记住，CPA模型允许你对选择的*P*值获得密文，所以你可以将*P*与**DRBG**(*K*
    || *R*) ⊕ *P*进行异或，从而得到**DRBG**(*K* || *R*)。但现在我们有一个矛盾，因为我们假设**DRBG**(*K* || *R*)无法与随机值区分开来，它生成的是随机字符串。因此，我们得出结论，密文无法与随机字符串区分开来，因此该密码是安全的。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-122
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*As an exercise, try to determine what other security notions are satisfied
    by the cipher* ***E****(*K*,* R*,* P*) = (****DRBG****(*K *||* R*)* ⊕ P*,* R*).
    Is it NM-CPA? IND-CCA? You’ll find the answers in the next section.*'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*作为练习，尝试确定该密码***E****(*K*,* R*,* P*) = (****DRBG****(*K *||* R*)* ⊕ P*,* R*)*满足哪些其他安全性概念。它是NM-CPA吗？IND-CCA吗？你将在下一节找到答案。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Notions Comparisons</samp>
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">安全性概念对比</samp>
- en: You’ve learned that attack models such as CPA and CCA are combined with security
    goals such as NM and IND to build the security notions NM-CPA, NM-CCA, IND-CPA,
    and IND-CCA. How are these notions related? Can we prove that satisfying notion
    X implies satisfying notion Y?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学过，攻击模型如CPA和CCA与安全目标如NM和IND结合起来，构建了安全性概念如NM-CPA、NM-CCA、IND-CPA和IND-CCA。这些概念之间有什么关系？我们能否证明满足概念X意味着满足概念Y？
- en: 'Some relations are obvious: IND-CCA implies IND-CPA, and NM-CCA implies NM-CPA
    because anything a CPA attacker can do, a CCA attacker can do as well. That is,
    if you can’t break a cipher by performing chosen-ciphertext and chosen-plaintext
    queries, you can’t break it by performing only chosen-plaintext queries.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一些关系是显而易见的：IND-CCA意味着IND-CPA，NM-CCA意味着NM-CPA，因为任何CPA攻击者能做的，CCA攻击者也能做。也就是说，如果你不能通过执行选择密文和选择明文查询来破解一个密码，那么你仅通过执行选择明文查询也无法破解它。
- en: 'A less obvious relation is that IND-CPA does not imply NM-CPA. To understand
    this, observe that the previous IND-CPA construction (**DRBG**(*K*, *R*) ⊕ *P*,
    *R*) is not NM-CPA: given a ciphertext (*X*, *R*), you can create the ciphertext
    (*X* ⊕ 1, *R*), which is a valid ciphertext of *P* ⊕ 1, thus contradicting the
    notion of nonmalleability.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不太明显的关系是，IND-CPA并不意味着NM-CPA。为了理解这一点，观察前面提到的IND-CPA构造（**DRBG**(*K*, *R*) ⊕
    *P*, *R*）并不是NM-CPA：给定一个密文(*X*, *R*)，你可以创建密文(*X* ⊕ 1, *R*)，这其实是*P* ⊕ 1的有效密文，从而与不可篡改性（nonmalleability）的概念相矛盾。
- en: 'But the opposite relation holds: NM-CPA implies IND-CPA. The intuition is that
    IND-CPA encryption is like putting items in a bag: you don’t get to see them,
    but you can rearrange their positions in the bag by shaking it up and down. NM-CPA
    is more like a safe: once inside, you can’t interact with what you put in there.
    This analogy doesn’t work for IND-CCA and NM-CCA, which are equivalent notions
    that each imply the presence of the other. I’ll spare you the proof, which is
    pretty technical.  ### <samp class="SANS_Futura_Std_Bold_B_11">Asymmetric Encryption</samp>'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但相反的关系成立：NM-CPA意味着IND-CPA。直观上，IND-CPA加密就像把物品放入袋子里：你看不到它们，但可以通过上下摇晃袋子改变它们的位置。NM-CPA更像是一个保险箱：一旦放进去，你就无法与里面的东西互动。这个类比不适用于IND-CCA和NM-CCA，它们是等价的概念，彼此意味着对方的存在。我就不赘述证明了，那个比较技术性。
- en: 'So far, we’ve considered only symmetric encryption, where two parties share
    a key. In *asymmetric encryption*, there are two keys: one encrypts and the other
    decrypts. The encryption key is called a *public key* and is generally considered
    publicly available to anyone who wants to send you encrypted messages. The decryption
    key, however, must remain secret and is called a *private key*.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只讨论了对称加密，其中两方共享一个密钥。在*非对称加密*中，有两个密钥：一个用于加密，另一个用于解密。加密密钥被称为*公钥*，通常认为是公开的，任何想要向你发送加密消息的人都可以使用。而解密密钥则必须保密，被称为*私钥*。
- en: The public key can be computed from the private key, but the private key can’t
    be computed from the public key. In other words, it’s easy to compute in one direction
    but not in the other—and that’s the point of *public-key cryptography*, whose
    functions are easy to compute in one direction but practically impossible to invert.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥可以从私钥计算得出，但私钥无法从公钥计算得出。换句话说，计算一个方向很容易，但反方向则不行——这就是*公钥加密*的关键，它的函数在一个方向上容易计算，但实际上不可能逆转。
- en: The attack models and security goals for asymmetric encryption are about the
    same as for symmetric encryption, except that because the encryption key is public,
    any attacker can make encryption queries by using the public key to encrypt. The
    default model for asymmetric encryption is therefore the chosen-plaintext attacker.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称加密的攻击模型和安全目标与对称加密大致相同，不同之处在于因为加密密钥是公开的，任何攻击者都可以通过使用公钥进行加密查询。因此，非对称加密的默认模型是选择明文攻击者。
- en: Symmetric and asymmetric encryption are the two main types of encryption, and
    they are usually combined to build secure communication systems. They also form
    the basis of more sophisticated schemes, as you’ll see next.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密和非对称加密是两种主要的加密方式，它们通常结合使用以构建安全的通信系统。它们也构成了更复杂方案的基础，正如你接下来会看到的。
- en: <samp class="SANS_Futura_Std_Bold_B_11">When Ciphers Do More Than Encryption</samp>
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">当密码不只是加密</samp>
- en: Basic encryption turns plaintexts into ciphertexts and ciphertexts into plaintexts,
    with no requirements other than security. However, some applications often need
    more than that, be it extra security features or functionalities. That’s why cryptographers
    created variants of symmetric and asymmetric encryption. Some are well understood,
    efficient, and widely deployed, while others are experimental, hardly used, and
    offer poor performance.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 基本加密将明文转换为密文，再将密文转换为明文，除了安全性外没有其他要求。然而，一些应用程序常常需要更多的功能，无论是额外的安全特性还是其他功能。这就是为什么密码学家创建了对称加密和非对称加密的变体。一些加密方法已被广泛理解、高效且被广泛部署，而另一些则是实验性的，几乎未被使用，并且性能较差。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Authenticated Encryption</samp>
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">认证加密</samp>
- en: '*Authenticated encryption (AE)* is a type of symmetric encryption that returns
    an *authentication tag* in addition to a ciphertext. [Figure 1-4](chapter1.xhtml#fig1-4)
    shows authenticated encryption sets **AE**(*K*, *P*) = (*C*, *T*), where the authentication
    tag *T* is a short string that’s impossible to guess without the key. Decryption
    takes *K*, *C*, and *T* and returns the plaintext *P* only if it verifies that
    *T* is a valid tag for that plaintext–ciphertext pair; otherwise, it aborts and
    returns some error.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*认证加密（AE）*是一种对称加密，它除了返回密文外，还会返回*认证标签*。[图 1-4](chapter1.xhtml#fig1-4)展示了认证加密的公式**AE**(*K*,
    *P*) = (*C*, *T*)，其中认证标签*T*是一个短字符串，在没有密钥的情况下几乎无法猜测。解密时需要*K*、*C*和*T*，并且只有当*T*验证为该明文-密文对的有效标签时，才能返回明文*P*；否则，解密操作会中止并返回错误。'
- en: '![](../images/fig1-4.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig1-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-4: Authenticated encryption</samp>'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-4：认证加密</samp>
- en: The tag ensures the *integrity* of the message and serves as evidence that the
    ciphertext received is identical to the one sent in the first place by a legitimate
    party that knows the key *K*. When *K* is shared with only one other party, the
    tag also guarantees that the message was sent by that party; that is, it implicitly
    *authenticates* the expected sender as the actual creator of the message.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 标签确保消息的*完整性*，并作为证据，表明接收到的密文与最初由知道密钥*K*的合法方发送的密文是相同的。当*K*只与另一方共享时，标签还可以保证消息是由该方发送的；也就是说，它隐式地*认证*了预期的发送者为消息的实际创建者。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*I use “creator” rather than “sender” here because an eavesdropper can record
    some (*C*,* T*) pairs sent by party A to party B and then send them again to B,
    pretending to be A. This is called a* replay attack*, and it can be prevented—for
    example, by including a counter number in the message. When a message is decrypted,
    its counter* i *increases by one:* i *+ 1\. In this way, one could check the counter
    to see if a message has been sent twice, indicating that an attacker is attempting
    a replay attack by resending the message. This also enables the detection of lost
    messages.*'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*我在这里使用“创建者”而不是“发送者”，因为窃听者可以记录一些由A方发送到B方的(*C*, *T*)对，然后再次将它们发送给B方，假装是A方。这个被称为*重放攻击*，可以通过包括计数器号码在消息中来防止。例如，当消息被解密时，它的计数器*i*增加1：*i*
    + 1。通过这种方式，可以检查计数器以查看消息是否被发送了两次，从而指示攻击者试图通过重新发送消息来进行重放攻击。这也可以帮助检测丢失的消息。*'
- en: '*Authenticated encryption with associated data (AEAD)* is an extension of authenticated
    encryption that takes some cleartext and unencrypted data and uses it to generate
    the authentication tag **AEAD**(*K*, *P*, *A*) = (*C*, *A*, *T*). A typical application
    of AEAD protects protocols’ datagrams with a cleartext header and an encrypted
    payload. In such cases, at least some header data has to remain in the clear;
    for example, destination addresses need to be clear to route network packets.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*带关联数据的认证加密（AEAD）*是认证加密的扩展，它将某些明文和未加密数据结合起来，并用它生成认证标签**AEAD**(*K*, *P*, *A*)
    = (*C*, *A*, *T*)。AEAD的一个典型应用是保护协议的数据报，其中包含明文头和加密负载。在这种情况下，至少有一些头部数据必须保持明文；例如，目的地地址需要保持明文，以便路由网络包。'
- en: For more on authenticated encryption, jump to [Chapter 8](chapter8.xhtml).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解更多认证加密的内容，请跳转到[第8章](chapter8.xhtml)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Format-Preserving
    Encryption</samp>
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">格式保持加密</samp>
- en: A basic cipher takes bits and returns bits; it doesn’t care whether bits represent
    text, an image, or a PDF document. The ciphertext may in turn be encoded as raw
    bytes, hexadecimal characters, base64, and other formats. But what if you need
    the ciphertext to have the same format as the plaintext, as is sometimes required
    by database systems that can record data only in a prescribed format?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的密码算法将比特流作为输入，输出比特流；它并不关心这些比特是表示文本、图像，还是PDF文档。密文可能会被编码成原始字节、十六进制字符、base64或其他格式。但如果你需要密文与明文保持相同格式呢？这是一些数据库系统所要求的，它们只能以规定的格式记录数据。
- en: '*Format-preserving encryption (FPE)* solves this problem. It can create ciphertexts
    that have the same format as the plaintext. For example, FPE can encrypt IP addresses
    to IP addresses (as shown in [Figure 1-5](chapter1.xhtml#fig1-5)), ZIP codes to
    ZIP codes, credit card numbers to credit card numbers with a valid checksum, and
    so on.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*格式保留加密（FPE）* 解决了这个问题。它能够生成与明文格式相同的密文。例如，FPE可以将IP地址加密成IP地址（如[图1-5](chapter1.xhtml#fig1-5)所示），将邮政编码加密成邮政编码，将信用卡号加密成具有有效校验和的信用卡号，等等。'
- en: '![](../images/fig1-5.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig1-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-5: Format-preserving
    encryption for IP addresses</samp>'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图1-5：用于IP地址的格式保留加密</samp>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fully Homomorphic
    Encryption</samp>
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">全同态加密</samp>
- en: '*Fully homomorphic encryption (FHE)* is the holy grail to cryptographers: it
    enables its users to replace a ciphertext, *C* = **E**(*K*, *P*), with another
    ciphertext, *C* ′ = **E**(*K*, **F**(*P*)), where **F**(*P*) can be any function
    of *P*, without ever decrypting the initial ciphertext, *C*. For example, *P*
    can be a text document and **F** can be the modification of part of the text.
    Imagine a cloud application that stores your encrypted data, but the cloud provider
    doesn’t know what the data is or the type of changes made when you modify that
    data. Sounds amazing, doesn’t it?'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*全同态加密（FHE）* 是密码学家们的圣杯：它允许用户将一个密文 *C* = **E**(*K*, *P*) 替换为另一个密文 *C* ′ = **E**(*K*,
    **F**(*P*))，其中 **F**(*P*) 可以是 *P* 的任何函数，而无需解密初始密文 *C*。例如，*P* 可以是一个文本文件，**F** 可以是修改文本的某一部分。想象一下，一个云应用程序存储你的加密数据，但云提供商不知道数据是什么，或者你修改数据时做了什么更改。听起来是不是很棒？'
- en: 'But there’s a flip side: this type of encryption is slow—so slow that even
    the most basic operation would take an unacceptably long time. The first FHE scheme
    was created in 2009, and since then more efficient variants have appeared, but
    it remains unclear whether FHE will ever be fast enough to be useful. However,
    application-specific use cases of (partially) homomorphic encryption have proved
    more efficient for operations such as evaluating machine learning models.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这也有一个缺点：这种加密方式非常慢——慢到连最基本的操作都需要不可接受的时间。第一个全同态加密（FHE）方案是在2009年创建的，从那时起，出现了更高效的变种，但仍不清楚FHE是否会足够快以供实际使用。然而，（部分）同态加密在某些特定应用场景下，特别是在评估机器学习模型时，已经证明比其他方法更高效。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Searchable Encryption</samp>
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">可搜索加密</samp>
- en: '*Searchable encryption* enables searching over an encrypted database without
    leaking the searched terms by encrypting the search query itself. Like fully homomorphic
    encryption, searchable encryption could enhance the privacy of many cloud-based
    applications by hiding your searches from your cloud provider. Some commercial
    solutions claim to offer searchable encryption, though they’re mostly based on
    standard cryptography with a few tricks to enable partial searchability. As of
    this writing, however, searchable encryption remains experimental within the research
    community.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*可搜索加密* 使得可以在加密的数据库中进行搜索，而不会泄露搜索词，方法是加密搜索查询本身。像全同态加密一样，可搜索加密能够通过隐藏搜索内容来增强许多基于云的应用程序的隐私，防止云服务提供商看到你的搜索内容。虽然一些商业解决方案声称提供可搜索加密，但它们大多基于标准加密技术，并通过一些技巧实现部分可搜索性。截至目前，可搜索加密仍然是研究社区中的实验性技术。'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Tweakable Encryption</samp>
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">可调加密</samp>
- en: '*Tweakable encryption (TE)* is similar to basic encryption, except for an additional
    parameter called the *tweak*, which aims to simulate different versions of a cipher
    (see [Figure 1-6](chapter1.xhtml#fig1-6)). The tweak might be a unique per-customer
    value to ensure that a customer’s cipher can’t be cloned by other parties using
    the same product, but the main application of TE is *disk encryption*. However,
    TE is not bound to a single application and is a lower-level type of encryption
    used to build other schemes, such as authentication encryption modes.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*可调加密（TE）* 类似于基本加密，唯一的不同是多了一个称为 *tweak* 的额外参数，它旨在模拟不同版本的密码算法（参见 [图 1-6](chapter1.xhtml#fig1-6)）。这个
    tweak 可能是每个客户独有的值，用以确保某个客户的密码不会被其他使用相同产品的第三方克隆，但 TE 的主要应用是 *磁盘加密*。然而，TE 并不限于单一应用，它是一种低层次的加密方式，用于构建其他加密方案，比如认证加密模式。'
- en: '![](../images/fig1-6.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig1-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-6: Tweakable encryption</samp>'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 1-6: 可调加密</samp>'
- en: In disk encryption, TE encrypts the content of storage devices such as hard
    drives or solid-state drives. (Randomized encryption can’t be used because it
    increases the size of the data, which is unacceptable for files on storage media.)
    To make encryption unpredictable, TE uses a tweak value that depends on the position
    of the data encrypted, which is usually a sector number or a block index.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在磁盘加密中，TE 加密存储设备的内容，如硬盘或固态硬盘。（不能使用随机化加密，因为它会增加数据大小，这对存储介质中的文件来说是不可接受的。）为了使加密不可预测，TE
    使用依赖于加密数据位置的 tweak 值，通常这个位置是扇区号或块索引。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">可能出错的地方</samp>
- en: Encryption algorithms or implementations thereof can fail to protect confidentiality
    in many ways. This can be due to a failure to match the security requirements
    (such as “be IND-CPA secure”) or to set requirements matching reality (if you
    target only IND-CPA security when attackers can actually perform chosen-ciphertext
    queries). Alas, many engineers don’t even think about cryptographic security requirements
    and want to be “secure” without understanding what that actually means. That’s
    usually a recipe for disaster. Let’s look at two examples.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 加密算法或其实现方式可能以多种方式无法保护机密性。这可能是因为未能满足安全要求（例如“必须是 IND-CPA 安全”）或未设定与实际情况相匹配的要求（如果你仅针对
    IND-CPA 安全，而攻击者实际上可以执行选择密文查询）。遗憾的是，许多工程师甚至没有考虑过密码安全要求，只是想要“安全”，却不理解这到底意味着什么。通常，这种做法是灾难的导火索。让我们看看两个例子。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Weak Cipher</samp>
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">弱密码</samp>
- en: Our first example concerns ciphers that can be attacked using cryptanalysis
    techniques, as occurred with the 2G mobile communication standard. Encryption
    in 2G mobile phones used a cipher called A5/1 that turned out to be weaker than
    expected, enabling the interception of calls by anyone with the right skills and
    tools. Telecommunication operators had to find workarounds to prevent the attack.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个例子涉及那些可以通过密码分析技术攻击的密码，正如 2G 移动通信标准所发生的那样。2G 移动电话中的加密使用了名为 A5/1 的密码，结果证明它比预期的要弱，任何具备相应技能和工具的人都可以拦截通话。电信运营商不得不找到解决办法以防止这种攻击。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*The 2G standard also defined A5/2, a cipher for areas other than the European
    Union and United States. A5/2 was purposefully weaker to prevent the use of strong
    encryption everywhere.*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*2G 标准还定义了 A5/2，这是一个适用于欧盟和美国以外地区的密码。A5/2 被故意设计得较弱，以防止强加密在所有地方的使用。*'
- en: That said, attacking A5/1 isn’t trivial, and it took more than 10 years for
    researchers to come up with an effective cryptanalysis method. Furthermore, the
    attack is a *time-memory trade-off (TMTO)*, a type of method that first runs computations
    for days or weeks to build large lookup tables, which are subsequently used for
    the actual attack. For A5/1, the precomputed tables are of the order of 1TB. Later
    standards for mobile encryption, such as 3G and LTE, specify stronger ciphers,
    but that doesn’t mean their encryption won’t be compromised; it simply means that
    the encryption won’t be compromised by breaking the symmetric cipher that’s part
    of the system.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，攻击A5/1并非易事，研究人员花了超过10年时间才提出一种有效的密码分析方法。此外，这种攻击是一种*时间-空间折衷（TMTO）*，这是一种方法，首先进行长时间（几天或几周）的计算，构建大型查找表，然后将这些表用于实际攻击。对于A5/1，预计算的表大约有1TB。后来的移动加密标准，如3G和LTE，指定了更强的密码，但这并不意味着它们的加密不会被破解；它只是意味着通过破解系统中的对称密码，无法破坏其加密。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Wrong Model</samp>
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">错误模型</samp>
- en: The next example concerns an invalid attack model that overlooked some side
    channels.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子涉及一个忽视了一些侧信道的无效攻击模型。
- en: Many communication protocols that use encryption ensure that they use ciphers
    considered secure in the CPA or CCA model. However, some attacks don’t require
    encryption queries, as in the CPA model, nor do they require decryption queries,
    as in the CCA model. They simply need *validity queries* to tell whether a ciphertext
    is valid, and these queries are usually sent to the system responsible for decrypting
    ciphertexts. *Padding oracle attacks* are an example of such attacks, wherein
    an attacker learns whether a ciphertext conforms to the required format.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用加密的许多通信协议确保它们使用在CPA或CCA模型中被认为是安全的密码。然而，一些攻击并不需要加密查询（如在CPA模型中那样），也不需要解密查询（如在CCA模型中那样）。它们只需要*有效性查询*来判断密文是否有效，而这些查询通常是发送给负责解密密文的系统的。*填充oracle攻击*就是这种攻击的一个例子，在这种攻击中，攻击者能够判断一个密文是否符合要求的格式。
- en: Specifically, in the case of padding oracle attacks, a ciphertext is valid only
    if its plaintext has the proper *padding*, a sequence of bytes appended to the
    plaintext to simplify encryption. Decryption fails if the padding is incorrect,
    and attackers can often detect decryption failures and attempt to exploit them.
    For example, the presence of the Java exception <samp class="SANS_TheSansMonoCd_W5Regular_11">javax.crypto.BadPaddingException</samp>
    indicates that an incorrect padding was observed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，在填充oracle攻击的情况下，只有当密文的明文具有正确的*填充*时，密文才是有效的，填充是附加到明文上以简化加密的字节序列。如果填充不正确，解密会失败，攻击者通常可以检测到解密失败并尝试利用这些失败。例如，Java异常<samp
    class="SANS_TheSansMonoCd_W5Regular_11">javax.crypto.BadPaddingException</samp>的存在表明观察到了不正确的填充。
- en: In 2010, researchers found padding oracle attacks in several web application
    servers. The validity queries consisted of sending a ciphertext to some system
    and observing whether it threw an error. Thanks to these queries, they could decrypt
    otherwise-secure ciphertexts without knowing the key.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年，研究人员在多个Web应用服务器中发现了填充oracle攻击。有效性查询包括将一个密文发送到某个系统并观察是否抛出错误。通过这些查询，他们可以在不知道密钥的情况下解密本应安全的密文。
- en: Cryptographers often overlook attacks like padding oracle attacks because they
    usually depend on an application’s behavior and on how users can interact with
    the application. But if you don’t anticipate such attacks and fail to include
    them in your model when designing and deploying cryptography, you may have some
    nasty surprises.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 密码学家通常忽视像填充oracle攻击这样的攻击，因为它们通常依赖于应用程序的行为以及用户如何与应用程序交互。但如果你没有预见到这种攻击，并且在设计和部署加密时没有将其包含在模型中，你可能会遇到一些令人惊讶的问题。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">进一步阅读</samp>
- en: We discuss encryption and its various forms in more detail throughout this book,
    especially how modern, secure ciphers work. Still, I can’t cover everything and
    have passed over many fascinating topics. For example, to learn the theoretical
    foundations of encryption and gain a deeper understanding of the notion of indistinguishability,
    read the 1982 paper that introduced the idea of semantic security, “Probabilistic
    Encryption and How to Play Mental Poker Keeping Secret All Partial Information”
    by Goldwasser and Micali. If you’re interested in physical attacks and cryptographic
    hardware, the proceedings of the Cryptographic Hardware and Embedded Systems (CHES)
    conference are the main reference.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将详细讨论加密及其各种形式，特别是现代安全密码如何运作。然而，我无法涵盖所有内容，很多令人着迷的话题我都未能涉及。例如，要学习加密的理论基础，并更深入地理解不可区分性的概念，可以阅读1982年由Goldwasser和Micali提出的关于语义安全的开创性论文《概率加密与如何在保持所有部分信息秘密的情况下进行心理扑克》。如果你对物理攻击和密码硬件感兴趣，Cryptographic
    Hardware and Embedded Systems（CHES）会议的论文集是主要参考资料。
- en: There are also many more types of encryption than those presented in this chapter,
    including attribute-based encryption, broadcast encryption, functional encryption,
    identity-based encryption, message-locked encryption, and proxy reencryption,
    to cite but a few. For the latest research on those topics, check *[https://<wbr>eprint<wbr>.iacr<wbr>.org](https://eprint.iacr.org)*,
    an electronic archive of cryptography research papers.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，除了本章中介绍的加密类型外，还有许多其他类型的加密，包括基于属性的加密、广播加密、功能加密、基于身份的加密、消息锁定加密和代理重加密，仅举几例。有关这些主题的最新研究，请访问*[https://<wbr>eprint<wbr>.iacr<wbr>.org](https://eprint.iacr.org)*，这是一个密码学研究论文的电子档案。
