- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">HASH
    FUNCTIONS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">6</samp> <samp class="SANS_Dogma_OT_Bold_B_11">哈希函数</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: 'Hash functions—such as SHA-256, SHA3, and BLAKE3—compose the cryptographer’s
    Swiss Army Knife: they are used in digital signatures, public-key encryption,
    integrity verification, message authentication, password protection, key agreement
    protocols, and many other cryptographic protocols.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数——如 SHA-256、SHA3 和 BLAKE3——组成了密码学家的瑞士军刀：它们被用于数字签名、公钥加密、完整性验证、消息认证、密码保护、密钥协议以及许多其他加密协议。
- en: Whether you’re encrypting an email, sending a message on your mobile phone,
    connecting to an HTTPS website, or connecting to a remote machine through a virtual
    private network (VPN) or Secure Shell (SSH), a hash function is somewhere under
    the hood.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是在加密电子邮件、在手机上发送信息、连接到 HTTPS 网站，还是通过虚拟私人网络（VPN）或安全外壳（SSH）连接到远程机器，哈希函数都会在幕后发挥作用。
- en: 'Hash functions are by far the most versatile and ubiquitous of all crypto algorithms.
    Their applications include the following: cloud storage systems use them to identify
    identical files and to detect modified files; the Git revision control system
    uses them to identify files in a repository; endpoint detection and response (EDR)
    systems use them to detect modified files; network-based intrusion detection systems
    (NIDSs) use hashes to detect known-malicious data going through a network; forensic
    analysts use hash values to prove that digital artifacts have not been modified;
    Bitcoin uses a hash function in its proof-of-work systems—and there are many more.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数是迄今为止最通用和最普遍的所有加密算法。它们的应用包括：云存储系统使用它们来识别相同的文件并检测修改过的文件；Git 版本控制系统使用它们来识别仓库中的文件；终端检测和响应（EDR）系统使用它们来检测修改过的文件；基于网络的入侵检测系统（NIDS）使用哈希值来检测通过网络的已知恶意数据；法医分析师使用哈希值来证明数字化文物未被修改；比特币在其工作量证明系统中使用哈希函数——还有更多应用。
- en: Unlike stream ciphers, which create a long output from a short one, hash functions
    take a long input and produce a short output, called a *hash value* or *digest*
    (see [Figure 6-1](chapter6.xhtml#fig6-1)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与流密码不同，流密码从短输入生成长输出，哈希函数则从长输入生成短输出，称为 *哈希值* 或 *摘要*（见[图6-1](chapter6.xhtml#fig6-1)）。
- en: '![](../images/fig6-1.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig6-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-1: A hash function’s
    input and output</samp>'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图6-1：哈希函数的输入和输出</samp>
- en: 'This chapter revolves around two main topics. First, security: What does it
    mean for a hash function to be secure? To that end, I introduce two essential
    notions—collision resistance and preimage resistance. The second topic revolves
    around hash function construction. I explain the high-level techniques modern
    hash functions use and then review the internals of the most common hash functions:
    SHA-1, SHA-2, SHA-3, and BLAKE2\. Finally, you see how secure hash functions can
    behave insecurely if misused.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章围绕两个主要话题展开。首先是安全性：一个哈希函数安全意味着什么？为此，我介绍了两个关键概念——碰撞抗性和原像抗性。第二个话题则围绕哈希函数的构建展开。我解释了现代哈希函数使用的高级技术，并回顾了最常见的哈希函数的内部结构：SHA-1、SHA-2、SHA-3
    和 BLAKE2。最后，你将看到如果误用，安全哈希函数也可能表现得不安全。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-11
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*Don’t confuse cryptographic hash functions with* noncryptographic *ones. You
    use noncryptographic hash functions in data structures such as hash tables or
    to detect accidental errors, and they provide no security whatsoever. For example,
    cyclic redundancy checks (CRCs) are noncryptographic hashes you use to detect
    accidental modifications of a file.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*不要将加密哈希函数与* 非加密 *哈希函数混淆。你在数据结构中使用非加密哈希函数，如哈希表，或用于检测偶然的错误，它们根本不提供任何安全性。例如，循环冗余检验（CRC）是非加密哈希，你用它来检测文件的意外修改。*'
- en: <samp class="SANS_Futura_Std_Bold_B_11">Secure Hash Functions</samp>
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">安全哈希函数</samp>
- en: The notion of security for hash functions is different from what we’ve discussed
    thus far. Whereas ciphers protect data confidentiality in an effort to guarantee
    that data sent in the clear can’t be read, hash functions protect data integrity
    in an effort to guarantee that data—whether sent in the clear or encrypted—hasn’t
    been modified. If a hash function is secure, two distinct pieces of data should
    always have different hashes. A file’s hash can thus serve as its identifier.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数的安全性概念与我们迄今为止讨论的有所不同。加密算法通过保护数据的机密性，确保明文数据无法被读取，而哈希函数则通过保护数据的完整性，确保数据——无论是明文还是加密——未被篡改。如果哈希函数是安全的，那么两组不同的数据应该始终具有不同的哈希值。因此，文件的哈希值可以作为其唯一标识符。
- en: 'Consider the most common application of a hash function: *digital signatures*,
    or just *signatures*. When using digital signatures, applications process the
    hash of the message to be signed rather than the message itself, as [Figure 6-2](chapter6.xhtml#fig6-2)
    illustrates.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑哈希函数最常见的应用：*数字签名*，或简称*签名*。在使用数字签名时，应用程序处理的是要签名消息的哈希值，而不是消息本身，正如[图6-2](chapter6.xhtml#fig6-2)所示。
- en: '![](../images/fig6-2.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig6-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-2: A hash function
    in a digital signature scheme, wherein the hash acts as a proxy for the message</samp>'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图6-2：数字签名方案中的哈希函数，其中哈希值充当消息的代理</samp>
- en: The hash acts as an identifier for the message. If even a single bit is changed
    in the message, the hash of the message will be totally different. The hash function
    thus helps ensure that the message hasn’t been modified. Signing a message’s hash
    is as secure as signing the message itself, and signing a short hash of, say,
    256 bits is much faster than signing a message that may be very large. In fact,
    most signature algorithms work only on short inputs such as hash values.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希值充当消息的标识符。如果消息中哪怕只有一个位被改变，消息的哈希值将完全不同。因此，哈希函数有助于确保消息没有被篡改。签名消息的哈希值与签名消息本身同样安全，而签名一个较短的哈希值，比如256位，比签名一个可能非常大的消息要快得多。事实上，大多数签名算法仅在像哈希值这样的短输入上工作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Unpredictability</samp>
    <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Again</samp>
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">不可预测性</samp> <samp
    class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">再一次</samp>
- en: 'The cryptographic strength of hash functions stems from the unpredictability
    of their outputs. Take the following 256-bit hexadecimal values; you compute these
    hashes using the NIST standard hash function SHA-256 with the ASCII letters <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> as inputs. Though the
    values <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> differ by only 1 or
    2 bits (<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> is the bit sequence
    01100001, <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> is 01100010,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp> is 01100011), their
    hash values are completely different:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希函数的密码学强度来源于其输出的不可预测性。以下是256位的十六进制值；你可以使用NIST标准哈希函数SHA-256，输入ASCII字母<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>来计算这些哈希。尽管<samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">c</samp>的差异仅为1或2个位（<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>是位序列01100001，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>是01100010，<samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>是01100011），但它们的哈希值却完全不同：
- en: '![](../images/pg117-1.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg117-1.jpg)'
- en: Given only these three hashes, it’s impossible to predict the value of the SHA-256
    hash of <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp> or any of its bits
    because hash values of a secure hash function are *unpredictable*. A secure hash
    function should be like a black box that returns a random string each time it
    receives an input.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 仅凭这三个哈希值，无法预测<samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp>的SHA-256哈希值或其任何位，因为安全哈希函数的哈希值是*不可预测*的。一个安全的哈希函数应该像一个黑箱，每次接收到输入时返回一个随机字符串。
- en: The general, theoretical definition of a secure hash function is that it behaves
    like a truly random function (sometimes called a *random oracle*). Specifically,
    a secure hash function shouldn’t have any property or pattern that a random function
    wouldn’t have. This definition is helpful for theoreticians, but in practice we
    need more specific notions, namely, preimage resistance and collision resistance.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 安全哈希函数的通用理论定义是，它的行为类似于一个真正的随机函数（有时称为*随机神谕*）。具体来说，一个安全哈希函数不应该具有任何随机函数不具备的属性或模式。这个定义对理论工作者有帮助，但在实际应用中，我们需要更具体的概念，即预影像抗性和碰撞抗性。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Preimage Resistance</samp>
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">预影像抗性</samp>
- en: A *preimage* of a given hash value, *H*, is any message, *M*, such that **Hash**(*M*)
    = *H*. Preimage *resistance* describes the security guarantee that given a random
    hash value, an attacker will never find a preimage of that hash value. Indeed,
    you can sometimes call hash functions *one-way functions* because you can go from
    the message to its hash but not the other way around.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一个给定哈希值*H*的*预影像*是任何一个消息*M*，使得 **Hash**(*M*) = *H*。预影像*抗性*描述了这样的安全保证：给定一个随机的哈希值，攻击者永远无法找到该哈希值的预影像。实际上，你有时可以将哈希函数称为*单向函数*，因为你可以从消息得到它的哈希值，但不能反过来。
- en: 'Indeed, you can’t invert a hash function, even given unlimited computing power.
    For example, suppose that I hash some message using the SHA-256 hash function
    and get this 256-bit hash value:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，即使拥有无限的计算能力，你也无法反转哈希函数。例如，假设我使用 SHA-256 哈希函数对某个消息进行哈希，得到这个 256 位的哈希值：
- en: '![](../images/pg118-1.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg118-1.jpg)'
- en: Even given infinite time and computing power, you’d never be able to determine
    *the* message that I picked to produce this particular hash, since there are many
    messages hashing to the same value. You would therefore find *some* messages that
    produce this hash value (possibly including the one I picked) but would be unable
    to determine the message I used. You get *unconditional security*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 即使拥有无限的时间和计算能力，你也永远无法确定我选择的*那*个消息来生成这个特定的哈希值，因为有很多消息会哈希到相同的值。因此，你会找到*一些*消息，它们会生成这个哈希值（可能包括我选择的那个），但你无法确定我用的具体消息。你将获得*无条件的安全性*。
- en: For example, there are 2^(256) possible values of a 256-bit hash (a typical
    length with hash functions used in practice), but there are many more values of,
    say, 1,024-bit messages (namely, 2^(1,024) possible values). Therefore, it follows
    that, on average, each possible 256-bit hash value will have 2^(1,024) / 2^(256)
    = 2^(1,024 – 256) = 2^(768) preimages of 1,024 bits each.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个 256 位的哈希值有 2^(256) 种可能的值（这是实际使用的哈希函数的典型长度），但比如说，1,024 位消息有更多的值（即，2^(1,024)
    种可能的值）。因此，可以推导出，平均而言，每个可能的 256 位哈希值会有 2^(1,024) / 2^(256) = 2^(1,024 – 256) =
    2^(768) 个 1,024 位的预影像。
- en: In practice, you must be sure that it’s practically impossible to find *any*
    message that maps to a given hash value, not just the message that was used, which
    is what preimage resistance actually stands for. Specifically, you can speak of
    first-preimage and second-preimage resistance. *First-preimage resistance* (or
    just *preimage resistance*) describes cases where it’s practically impossible
    to find a message that hashes to a given value. *Second-preimage resistance*,
    on the other hand, describes the case that when given a message, *M*[1], it’s
    practically impossible to find another message, *M*[2], that hashes to the same
    value that *M*[1] does.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你必须确保几乎不可能找到*任何*与给定哈希值对应的消息，而不仅仅是被用来生成该哈希值的消息，这正是预影像抗性所代表的含义。具体来说，你可以讨论第一预影像抗性和第二预影像抗性。*第一预影像抗性*（或称*预影像抗性*）描述了在这种情况下，几乎不可能找到与给定哈希值对应的消息。另一方面，*第二预影像抗性*描述的是，给定一个消息*M*[1]，几乎不可能找到另一个消息*M*[2]，使得*M*[1]
    和 *M*[2] 的哈希值相同。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Cost of Preimages</samp>
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">预影像的代价</samp>
- en: Given a hash function and a hash value, you can search for first preimages by
    trying different messages until one hits the target hash. [Listing 6-1](chapter6.xhtml#Lis6-1)
    shows how to do this using an algorithm similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">solve_preimage()</samp>.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个哈希函数和一个哈希值，你可以通过尝试不同的消息来搜索第一个预影像，直到找到与目标哈希匹配的那个。[列表 6-1](chapter6.xhtml#Lis6-1)
    显示了如何使用类似于 <samp class="SANS_TheSansMonoCd_W5Regular_11">solve_preimage()</samp>
    的算法来实现这一点。
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-1: The optimal preimage
    search algorithm for a secure hash function</samp>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 6-1：安全哈希函数的最佳逆像搜索算法</samp>
- en: 'Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">random_message()</samp>
    generates a random message (say, a random 1,024-bit value). If the hash’s bit
    length, *n*, is large enough, <samp class="SANS_TheSansMonoCd_W5Regular_11">solve_preimage()</samp>will
    practically never complete, because it will take on average 2*^n* attempts before
    finding a preimage. That’s a hopeless situation when working with *n* = 256, as
    in modern hashes like SHA-256 and BLAKE2.  ##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Why
    Second-Preimage Resistance Is Weaker</samp>'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，<samp class="SANS_TheSansMonoCd_W5Regular_11">random_message()</samp>生成一个随机消息（比如，一个随机的1024位值）。如果哈希的位长*n*足够大，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">solve_preimage()</samp>几乎永远不会完成，因为它在找到逆像之前，平均需要2*^n*次尝试。这在处理*n*
    = 256时是个无望的局面，像现代哈希函数SHA-256和BLAKE2就是如此。  ##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">为什么第二个逆像抵抗力较弱</samp>'
- en: If you can find first preimages, then you can find second preimages as well
    (for the same hash function). As proof, if the algorithm <samp class="SANS_TheSansMonoCd_W5Regular_11">solve_preimage()</samp>
    returns a preimage of a given hash value, use the algorithm in [Listing 6-2](chapter6.xhtml#Lis6-2)
    to find a second preimage of some message, *M*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够找到第一个逆像，那么你也能找到第二个逆像（对于同一个哈希函数）。作为证明，如果算法<samp class="SANS_TheSansMonoCd_W5Regular_11">solve_preimage()</samp>返回给定哈希值的逆像，使用[清单
    6-2](chapter6.xhtml#Lis6-2)中的算法找到某个消息*M*的第二个逆像。
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-2: How to find second
    preimages if you can find first preimages</samp>'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 6-2：如果能够找到第一个逆像，如何找到第二个逆像</samp>
- en: You’ll find the second preimage by seeing it as a preimage problem and applying
    the preimage attack. It follows that any second-preimage resistant hash function
    is also preimage resistant. (Were it not, it wouldn’t be second preimage resistant
    either, per the preceding <samp class="SANS_TheSansMonoCd_W5Regular_11">solve_second_preimage()</samp>
    algorithm.) In other words, the best attack you can use to find second preimages
    is almost identical to the best attack you can use to find first preimages, unless
    the hash function has some defect that allows for more efficient attacks. Also
    note that a preimage search attack is fundamentally similar to a key-recovery
    attack on a block cipher or stream cipher, except that in the case of encryption
    there is exactly one solution of known size.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过将第二个逆像问题视为一个逆像问题并应用逆像攻击来找到第二个逆像。因此，任何抗第二个逆像的哈希函数也是抗逆像的。（如果不是这样，它也不会对第二个逆像具有抵抗力，参见前面的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">solve_second_preimage()</samp>算法。）换句话说，找到第二个逆像的最佳攻击几乎与找到第一个逆像的最佳攻击相同，除非哈希函数存在某些缺陷，允许更高效的攻击。另请注意，逆像搜索攻击本质上类似于对分组密码或流密码的密钥恢复攻击，不同之处在于加密情况下有一个已知大小的确切解。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Collision Resistance</samp>
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">抗碰撞性</samp>
- en: Whatever hash function you choose, collisions will inevitably exist because
    of the *pigeonhole principle*, which posits that if you have *m* holes and *n*
    pigeons to put into those holes and if *n* is greater than *m*, at least one hole
    must contain more than one pigeon.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种哈希函数，碰撞是不可避免的，因为*抽屉原理*指出，如果你有*m*个洞和*n*只鸽子要放进这些洞中，并且*n*大于*m*，那么至少有一个洞必须包含超过一只鸽子。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*You can generalize the pigeonhole principle to other items and containers.
    For example, any 27-word sequence in the US Constitution includes at least two
    words that start with the same letter. In the world of hash functions, holes are
    the hash values, and pigeons are the messages. Because you know that there are
    many more possible messages than hash values, collisions* must *exist.*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*你可以将抽屉原理推广到其他物品和容器。例如，美国宪法中的任何27个单词序列至少包含两个以相同字母开头的单词。在哈希函数的世界里，洞是哈希值，而鸽子是消息。因为你知道可能的消息数量远大于哈希值的数量，所以碰撞*必定*会存在。*'
- en: However, despite the inevitable, collisions should be hard to find to consider
    a hash function *collision resistant*—in other words, attackers shouldn’t be able
    to find two distinct messages that hash to the same value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管碰撞是不可避免的，但要考虑一个哈希函数是*抗碰撞*的，碰撞应该很难找到——换句话说，攻击者不应该能够找到两个不同的消息，它们的哈希值相同。
- en: 'The notion of collision resistance relates to that of second-preimage resistance:
    if you can find second preimages for a hash function, you can also find collisions,
    as [Listing 6-3](chapter6.xhtml#Lis6-3) shows.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 碰撞抗性与第二预像抗性有关：如果你能为一个哈希函数找到第二预像，你也能找到碰撞，正如[列表 6-3](chapter6.xhtml#Lis6-3)所示。
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-3: The naive collision
    search algorithm</samp>'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 6-3：天真碰撞搜索算法</samp>
- en: That is, any collision-resistant hash is also second-preimage resistant. If
    this were not the case, there would be an efficient solve-second-preimage algorithm
    that could be used to break collision resistance.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，任何碰撞抗性的哈希也是第二预像抗性的。如果不是这样，就会有一个高效的解第二预像算法可以用来破解碰撞抗性。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How to Find Collisions</samp>
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">如何寻找碰撞</samp>
- en: 'Finding collisions is faster than finding preimages: it takes approximately
    2*^n*^(/2) operations instead of 2*^n*, thanks to the *birthday attack*, whose
    key idea is the following: given *N* messages and as many hash values, you can
    produce a total of *N* × (*N* – 1) / 2 potential collisions by considering each
    *pair* of two hash values (a number of the same order of magnitude as *N* ²).
    It’s called the *birthday* attack because it’s usually illustrated using the *birthday
    paradox*, which is the fact that a group of 23 people will include two people
    having the same birth date with probability close to 1/2—which is not a paradox,
    just a surprise for many people.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找碰撞比寻找预像更快：它大约需要 2*^n*^(/2) 次操作，而不是 2*^n*，这是由于*生日攻击*，其核心思想如下：给定 *N* 个消息和同样数量的哈希值，你可以通过考虑每一对哈希值（数量级大约为
    *N*²）来产生 *N* × (*N* – 1) / 2 个潜在的碰撞。之所以叫做*生日*攻击，是因为它通常用*生日悖论*来说明，生日悖论指出一组 23 个人中，恰好有两个人生日相同的概率接近
    1/2——这并不是悖论，只是对许多人来说是一个惊讶。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: N *× (*N *– 1) / 2 is the count of pairs of two* distinct *messages, where you
    divide by 2 because you view (*M1*,* M2*) and (*M2*,* M1*) as a same pair, the
    ordering being unimportant.*
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: N *× (*N *– 1) / 2 是两个*不同*消息的对数，你除以 2 是因为你将 (*M1*,* M2*) 和 (*M2*,* M1*) 视为同一对，顺序不重要。*
- en: 'For comparison, in the case of a preimage search, *N* messages get you only
    *N* candidate preimages, whereas the same *N* messages give approximately *N*
    ² potential collisions. With *N* ² instead of *N*, you can say that there are
    *quadratically* more chances to find a solution. The complexity of the search
    is in turn quadratically lower: to find a collision, use the square root of 2*^n*
    messages; that is, use 2*^n*^(/2) instead of 2*^n*.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 作比较，在预像搜索的情况下，*N* 个消息仅能得到 *N* 个候选预像，而相同的 *N* 个消息大约会得到 *N*² 个潜在的碰撞。通过 *N*² 代替
    *N*，你可以说找到解决方案的机会是*二次*增多的。搜索的复杂度相应降低：要找到一个碰撞，使用 2*^n*^(/2) 条消息，而不是 2*^n*。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">The Naive Birthday Attack</samp>
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">天真生日攻击</samp>
- en: 'Here’s the simplest way to find collisions using the birthday attack:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是使用生日攻击寻找碰撞的最简单方法：
- en: 1.  Compute 2*^n*^(/2) hashes of 2*^n*^(/2) arbitrarily chosen messages and
    store all the message/hash pairs in a list.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  计算 2*^n*^(/2) 个消息的 2*^n*^(/2) 哈希值，并将所有消息/哈希对存储在一个列表中。
- en: 2.  Sort the list with respect to the hash value to move any identical hash
    values next to each other.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  按哈希值对列表进行排序，将相同的哈希值放在一起。
- en: 3.  Search the sorted list to find two consecutive entries with the same hash
    value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  搜索排序后的列表，找到两个连续的条目，它们具有相同的哈希值。
- en: Unfortunately, this method requires a lot of memory (enough to store 2*^n*^(/2)
    message/hash pairs), and sorting lots of elements slows down the search, requiring
    about *n*2*^(n/2)* operations on average, using a fast sorting algorithm such
    as quicksort.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种方法需要大量内存（足以存储 2*^n*^(/2) 个消息/哈希对），而排序大量元素会减慢搜索速度，平均需要大约 *n*2*^(n/2)*
    次操作，使用快速排序算法如快速排序。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Low-Memory Collision Search
    with the Rho Method</samp>
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">低内存碰撞搜索与 Rho 方法</samp>
- en: 'The *Rho method* is an algorithm for finding collisions that, unlike the naive
    birthday attack, requires only a small amount of memory. It works like this:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*Rho 方法*是一种寻找碰撞的算法，不同于天真生日攻击，它只需要少量内存。它的工作原理如下：'
- en: 1.  Given a hash function with *n*-bit hash values, pick some random hash value
    (*H*[1]), and define *H*[1] = *H* ′[1].
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 给定一个具有*n*位哈希值的哈希函数，选择一个随机的哈希值（*H*[1]），并定义 *H*[1] = *H* ′[1]。
- en: 2.  Compute *H*[2] = **Hash**(*H*[1]) and *H* ′[2] = **Hash**(**Hash**(*H* ′[1])).
    In the first case apply the hash function once, while in the second case apply
    it twice.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 计算 *H*[2] = **Hash**(*H*[1]) 和 *H* ′[2] = **Hash**(**Hash**(*H* ′[1]))。在第一种情况下应用哈希函数一次，而在第二种情况下应用哈希函数两次。
- en: 3.  Iterate the process and compute *H*i [+ 1] = **Hash**(*H*i), *H* ′i [+ 1]
    = **Hash**(**Hash** (*H* ′i)), for increasing values of *i*, until you reach *i*
    such that *H*i [+ 1] = *H* ′i [+ 1].
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 迭代该过程并计算 *H*i [+ 1] = **Hash**(*H*i)， *H* ′i [+ 1] = **Hash**(**Hash** (*H*
    ′i))，对*i*值递增，直到达到 *i* 使得 *H*i [+ 1] = *H* ′i [+ 1]。
- en: '[Figure 6-3](chapter6.xhtml#fig6-3) helps visualize the attack, where an arrow
    from, say, *H*[1] to *H*[2] means *H*[2] = **Hash**(*H*[1]). Observe that the
    sequence of *H*is eventually enters a loop, also called a *cycle*, which resembles
    the Greek letter rho (ρ) in shape. The cycle starts at *H*[5] and is characterized
    by the collision **Hash**(*H*[4]) = **Hash**(*H*[10]) = *H*[5]. The key observation
    here is that to find a collision, you simply need to find such a cycle. The Rho
    method allows an attacker to detect the position of the cycle and therefore to
    find the collision.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 6-3](chapter6.xhtml#fig6-3)帮助可视化该攻击，其中从*H*[1]到*H*[2]的箭头表示 *H*[2] = **Hash**(*H*[1])。观察到*H*的序列最终进入一个循环，也叫做*周期*，其形状类似希腊字母rho（ρ）。该周期从*H*[5]开始，且由碰撞
    **Hash**(*H*[4]) = **Hash**(*H*[10]) = *H*[5]所特征化。这里的关键观察是，找到一个碰撞，你只需要找到这样的一个周期。Rho方法允许攻击者检测到周期的位置，因此能够找到碰撞。'
- en: '![](../images/fig6-3.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig6-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-3: The structure of
    the Rho hash function, where each arrow represents an evaluation of the hash function.
    The cycle beginning at</samp> <samp class="SANS_Futura_Std_Book_11">H</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUB_11">5</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">corresponds
    to a collision,</samp> <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Hash</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">(</samp><samp class="SANS_Futura_Std_Book_11">H</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUB_11">4</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">)
    =</samp> <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Hash</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">(</samp><samp
    class="SANS_Futura_Std_Book_11">H</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">10</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">) =</samp> <samp class="SANS_Futura_Std_Book_11">H</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUB_11">5</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">.</samp>'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 6-3：Rho 哈希函数的结构，其中每个箭头表示哈希函数的评估。开始于</samp>
    <samp class="SANS_Futura_Std_Book_11">H</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">5</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">的周期对应于一个碰撞，</samp> <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Hash</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">(</samp><samp class="SANS_Futura_Std_Book_11">H</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUB_11">4</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">)
    =</samp> <samp class="SANS_Futura_Std_Bold_Oblique_BI_11">Hash</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">(</samp><samp
    class="SANS_Futura_Std_Book_11">H</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">10</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">) =</samp> <samp class="SANS_Futura_Std_Book_11">H</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I-SUB_11">5</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">。</samp>
- en: 'Advanced collision-finding techniques based on the Rho method work by first
    detecting the start of the cycle and then finding the collision, without storing
    numerous values in memory or needing to sort a long list. This takes about 2*^n*^(/2)
    operations to succeed. Indeed, [Figure 6-3](chapter6.xhtml#fig6-3) has many fewer
    hash values than would an actual function with digests of 256 bits or more. On
    average, the cycle and the tail (the part that extends from *H*[1] to *H*[5] in
    [Figure 6-3](chapter6.xhtml#fig6-3)) each include about 2*^n*^(/2) hash values,
    where *n* is the bit length of the hash values. Therefore, you’ll need at least
    2*^n*^(/2) + 2*^n*^(/2) evaluations of the hash to find a collision.  ### <samp
    class="SANS_Futura_Std_Bold_B_11">How to Build Hash Functions</samp>'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Rho方法的先进碰撞查找技术通过先检测循环的起始点，再找到碰撞，而不需要在内存中存储大量值或排序一个长列表。成功找到碰撞大约需要2*^n*^(/2)次操作。实际上，[图6-3](chapter6.xhtml#fig6-3)中的哈希值要远少于一个具有256位或更多摘要的实际函数。平均来说，循环和尾部（从*H*[1]到*H*[5]的部分，在[图6-3](chapter6.xhtml#fig6-3)中展示）各自包括大约2*^n*^(/2)个哈希值，其中*n*是哈希值的位长度。因此，找到碰撞至少需要进行2*^n*^(/2)
    + 2*^n*^(/2)次哈希评估。### <samp class="SANS_Futura_Std_Bold_B_11">如何构建哈希函数</samp>
- en: 'In the 1980s, cryptographers realized that the simplest way to hash a message
    is to split it into chunks and process each chunk consecutively using a similar
    algorithm. This strategy, *iterative hashing*, comes in two main forms:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在1980年代，加密学者意识到，哈希消息最简单的方法是将其分割成若干块，并使用相似的算法逐块处理。这个策略即为*迭代哈希*，它有两种主要形式：
- en: Iterative hashing using a *compression function* that transforms an input to
    a *smaller output*, as [Figure 6-4](chapter6.xhtml#fig6-4) illustrates. This technique
    is also called the *Merkle–Damgård* construction, named after the cryptographers
    Ralph Merkle and Ivan Damgård who described it.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*压缩函数*进行迭代哈希，该函数将输入转换为*更小的输出*，正如[图6-4](chapter6.xhtml#fig6-4)所示。这种技术也叫做*Merkle–Damgård*结构，以加密学者拉尔夫·梅尔克尔和伊万·丹麦戈德命名，他们首次描述了这种结构。
- en: Iterative hashing using a function that transforms an input to an output of
    the *same size*, such that any two different inputs give two different outputs
    (that is, a *permutation*). Such functions are called *sponge functions*.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用将输入转换为*相同大小*输出的函数进行迭代哈希，使得任何两个不同的输入都会产生两个不同的输出（即*排列*）。这样的函数称为*海绵函数*。
- en: '![](../images/fig6-4.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig6-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-4: The Merkle–Damgård
    construction using a compression function called Compress</samp>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图6-4：使用名为Compress的压缩函数的Merkle–Damgård结构</samp>
- en: We’ll now discuss how these constructions work and how compression functions
    look in practice.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将讨论这些结构如何工作以及压缩函数在实践中的表现。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Compression-Based
    Hash Functions</samp>
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">基于压缩的哈希函数</samp>
- en: 'All hash functions developed from the 1980s through the 2010s are based on
    the Merkle–Damgård (M–D) construction: MD4, MD5, SHA-1, and the SHA-2 family,
    as well as the lesser-known RIPEMD and Whirlpool hash functions. While the M–D
    construction isn’t perfect, it is simple and has proven to be secure enough for
    many applications.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从1980年代到2010年代开发的所有哈希函数都基于Merkle–Damgård（M–D）结构：MD4、MD5、SHA-1以及SHA-2系列，还有不太知名的RIPEMD和Whirlpool哈希函数。虽然M–D结构并不完美，但它简单且已证明对许多应用足够安全。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*In MD4, MD5, and RIPEMD, the* MD *stands for* message digest *rather than*
    Merkle–Damgård*.*'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*在MD4、MD5和RIPEMD中，*MD*代表*消息摘要*，而非*Merkle–Damgård*。*'
- en: To hash a message, the M–D construction splits the message into blocks of identical
    size and mixes these blocks with an internal state using a compression function,
    as [Figure 6-4](chapter6.xhtml#fig6-4) shows. Here, *H*[0] is the *initial value*
    (denoted IV) of the internal state, the values *H*[1], *H*[2], . . . are the *chaining
    values*, and the final value of the internal state is the message’s hash value.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对消息进行哈希，M–D结构将消息分成相同大小的块，并使用压缩函数将这些块与内部状态混合，如[图6-4](chapter6.xhtml#fig6-4)所示。这里，*H*[0]是内部状态的*初始值*（记作IV），*H*[1]、*H*[2]等是*链值*，最终的内部状态值就是消息的哈希值。
- en: The message blocks are often 512 or 1,024 bits, but they can, in principle,
    be any size. Whatever the block length, it is fixed for a given hash function.
    For example, SHA-256 works with 512-bit blocks, and SHA-512 works with 1,024-bit
    blocks.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 消息块通常是 512 位或 1,024 位，但原则上可以是任意大小。无论块的长度如何，它对特定的哈希函数是固定的。例如，SHA-256 使用 512 位块，SHA-512
    使用 1,024 位块。
- en: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Padding Blocks</samp>'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '##### <samp class="SANS_Futura_Std_Bold_Condensed_B_11">填充块</samp>'
- en: 'What happens if you want to hash a message that can’t be split into a sequence
    of complete blocks? For example, if blocks are 512 bits, then a 520-bit message
    consists of one 512-bit block plus 8 bits. In such a case, the M–D construction
    forms the last block as follows: take the chunk of bits left (8 in our example),
    append 1 bit, then append 0 bits, and finally append the length of the original
    message, encoded on a fixed number of bits. This padding trick guarantees that
    any two distinct messages give a distinct sequence of blocks and thus a distinct
    hash value.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要哈希一个无法分割为完整块的消息会发生什么？例如，如果块是 512 位，那么一个 520 位的消息将包含一个 512 位块和 8 位。此时，M–D
    构造会按照以下方式形成最后一个块：取出剩下的比特块（在我们的例子中为 8 位），附加 1 位，然后附加 0 位，最后附加原始消息的长度，长度以固定比特数编码。这个填充技巧保证了任何两个不同的消息都会给出不同的块序列，从而得到不同的哈希值。
- en: 'For example, if you hash the 8-bit string 10101010 using SHA-256, which is
    a hash function with 512-bit message blocks, the first and only block appears,
    in bits, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你使用 SHA-256 对 8 位字符串 10101010 进行哈希，该哈希函数使用 512 位消息块，则第一个也是唯一一个块的位表示如下：
- en: '![](../images/pg123-1.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg123-1.jpg)'
- en: Here, the message bits are the first 8 bits (10101010), and the padding bits
    are all the subsequent bits (shown in italic). The *1000* at the end of the block
    (underlined) is the message’s length, or 8 encoded in binary (on 32 bits at most).
    The padding thus produces a 512-bit message composed of a single 512-bit block,
    ready to be processed by SHA-256’s compression function.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，消息位是前 8 位（10101010），而填充位是其后所有位（以斜体显示）。块末尾的*1000*（带下划线）是消息的长度，即 8 的二进制编码（最多
    32 位）。因此，填充产生了一个由单个 512 位块组成的 512 位消息，准备好由 SHA-256 的压缩函数处理。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security Guarantees</samp>
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">安全性保证</samp>
- en: 'The Merkle–Damgård construction turns a secure compression function that takes
    small, fixed-length inputs into a secure hash function that takes inputs of arbitrary
    lengths. If a compression function is preimage and collision resistant, then a
    hash function built on it using the M–D construction is also preimage and collision
    resistant. This is true because we can turn any successful preimage attack for
    the M–D hash into a successful preimage attack for the compression function, as
    Merkle and Damgård demonstrated in their 1989 papers (see this chapter’s “Further
    Reading” section). The same is true for collisions: an attacker can’t break the
    hash’s collision resistance without breaking the underlying compression function’s
    collision resistance; hence, the security of the latter guarantees the security
    of the hash.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Merkle–Damgård 构造将一个安全的压缩函数（其输入为小且固定长度）转变为一个安全的哈希函数，该哈希函数能够接受任意长度的输入。如果一个压缩函数是抗原像攻击和抗碰撞攻击的，那么基于
    M–D 构造构建的哈希函数同样也具备这两种抗性。之所以如此，是因为我们可以将针对 M–D 哈希的任何成功的原像攻击转化为对压缩函数的成功原像攻击，正如 Merkle
    和 Damgård 在他们 1989 年的论文中所展示的那样（请参见本章的“进一步阅读”部分）。碰撞的情况也是如此：攻击者无法打破哈希函数的抗碰撞性，除非打破了底层压缩函数的抗碰撞性；因此，后者的安全性保证了哈希函数的安全性。
- en: Note that the converse argument doesn’t hold, because a collision for the compression
    function doesn’t necessarily give a collision for the hash. An arbitrary collision
    between **Compress**(*X*, *M*[1]) and **Compress**(*Y*, *M*[2]) for chaining values
    *X* and *Y*, both distinct from *H*[0], won’t get you a collision for the hash
    because you can’t “plug” the collision into the iterative chain of hashes—except
    if one of the chaining values happens to be *X* and the other *Y*, but that’s
    unlikely to happen.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，反过来的论点并不成立，因为压缩函数的碰撞不一定会导致哈希的碰撞。对于链式值 *X* 和 *Y*，它们都不同于 *H*[0]，**Compress**(*X*,
    *M*[1]) 和 **Compress**(*Y*, *M*[2]) 之间的任意碰撞不会导致哈希碰撞，因为你无法将碰撞“插入”到哈希的迭代链中——除非其中一个链值恰好是
    *X*，另一个是 *Y*，但这种情况发生的可能性很小。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Finding Multicollisions</samp>
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">寻找多重碰撞</samp>
- en: 'A *multicollision* occurs when a set of three or more messages hash to the
    same value. For example, the triplet (*X*, *Y*, *Z*), such that **Hash**(*X*)
    = **Hash**(*Y*) = **Hash**(*Z*), is a *3-collision*. Ideally, multicollisions
    should be much harder to find than collisions, but there’s a simple trick for
    finding them at almost the same cost as that of a single collision. Here’s how
    it works:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*多重碰撞*发生在三条或更多消息哈希到相同的值时。例如，三元组(*X*, *Y*, *Z*)，使得**Hash**(*X*) = **Hash**(*Y*)
    = **Hash**(*Z*)，就是一个*3-碰撞*。理想情况下，多重碰撞应该比单一碰撞更难找到，但有一个简单的技巧可以几乎以与单次碰撞相同的成本找到它们。其工作原理如下：'
- en: 1.  Find a collision **Compress**(*H*[0], *M*[1.1]) = **Compress**(*H*[0], *M*[1.2])
    = *H*[1]. This is just a 2-collision, or two messages hashing to the same value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  找到一个碰撞 **Compress**(*H*[0], *M*[1.1]) = **Compress**(*H*[0], *M*[1.2]) =
    *H*[1]。这只是一个 2-碰撞，即两条消息哈希到相同的值。
- en: '2.  Find a second collision with *H*[1] as a starting chaining value: **Compress**
    (*H*[1], *M*[2.1]) = **Compress**(*H*[1], *M*[2.2]) = *H*[2]. Now you have a 4-collision,
    with four messages hashing to the same value *H*[2]: *M*[1.1] || *M*[2.1], *M*[1.1]
    || *M*[2.2], *M*[1.2] || *M*[2.1], and *M*[1.2] || *M*[2.2].'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  以 *H*[1] 作为起始链值，找到第二次碰撞：**Compress** (*H*[1], *M*[2.1]) = **Compress**(*H*[1],
    *M*[2.2]) = *H*[2]。现在你得到了一个 4-碰撞，四条消息哈希到相同的值 *H*[2]：*M*[1.1] || *M*[2.1]，*M*[1.1]
    || *M*[2.2]，*M*[1.2] || *M*[2.1]，以及 *M*[1.2] || *M*[2.2]。
- en: 3.  Repeat and find *N* times a collision, and you’ll have 2*^N* messages, each
    of *N* blocks, hashing to the same value—that is, a 2*^N*-collision, at the cost
    of “only” about *N*2*^N* hash computations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  重复找到 *N* 次碰撞，你将得到 2*^N* 条消息，每条包含 *N* 个块，哈希到相同的值——即 2*^N* 碰撞，代价“仅仅”约为 *N*2*^N*
    次哈希计算。
- en: In practice, this trick isn’t all that practical because it requires finding
    a basic 2-collision in the first place.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个技巧并不是特别实用，因为它首先需要找到一个基本的 2-碰撞。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Building Compression Functions</samp>
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">构建压缩函数</samp>
- en: All compression functions used in real hash functions such as SHA-256 and BLAKE2
    are based on block ciphers because that’s the simplest way to build a compression
    function. [Figure 6-5](chapter6.xhtml#fig6-5) shows the most common of the block
    cipher–based compression functions, the *Davies–Meyer construction*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 所有在实际哈希函数中使用的压缩函数，如 SHA-256 和 BLAKE2，都基于块密码，因为这是构建压缩函数最简单的方法。[图 6-5](chapter6.xhtml#fig6-5)
    展示了基于块密码的最常见压缩函数，即 *Davies–Meyer 构造*。
- en: '![](../images/fig6-5.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig6-5.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-5: The Davies–Meyer
    construction. The dark triangle shows where the block cipher’s key is input.</samp>'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 6-5: Davies–Meyer 构造。深色三角形显示了块密码密钥的输入位置。</samp>'
- en: 'Given a message block *M*i and the previous chaining value *H*i [– 1], the
    Davies–Meyer compression function uses a block cipher, **E**, to compute the new
    chaining value as:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 给定消息块 *M*i 和前一个链值 *H*i [– 1]，Davies–Meyer 压缩函数使用一个块密码 **E** 来计算新的链值，公式如下：
- en: '![](../images/pg124-1.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg124-1.jpg)'
- en: The message block *M*i acts as the block cipher key, and the chaining value
    *H*i [– 1] acts as its plaintext block. As long as the block cipher is secure,
    the resulting compression function is secure as well as collision and preimage
    resistant. Without the XOR of the preceding chaining value (⊕ *H*i [– 1]), Davies–Meyer
    would be insecure because you could invert it, going from the new chaining value
    to the previous one using the block cipher’s decryption function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 消息块 *M*i 作为块密码的密钥，链值 *H*i [– 1] 作为其明文块。只要块密码是安全的，结果的压缩函数也将是安全的，并且抵抗碰撞和前像攻击。如果没有前一个链值的异或操作（⊕
    *H*i [– 1]），Davies–Meyer 就不安全，因为你可以反转它，通过块密码的解密函数从新的链值回到前一个链值。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The Davies–Meyer construction has a surprising property: you can find* fixed
    points*, or chaining values, that are unchanged after applying the compression
    function with a given message block. It suffices to take* H[i –] 1 *=* **D***(*M[i]*,
    0) as a chaining value, where* **D** *is the decryption function corresponding
    to* ***E****. The new chaining value* H[i] *is therefore equal to the original*
    H[i –] 1*:*'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Davies–Meyer 构造有一个令人惊讶的性质：你可以找到* 固定点*，或链值，在应用给定消息块的压缩函数后保持不变。只需将* H[i –] 1
    *=* **D***(*M[i]*, 0) 作为链值，其中 *D* 是与 *E* 对应的解密函数。因此，新的链值 *H[i]* 等于原始的 *H[i –]
    1*：*'
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![](../images/pg125-1.jpg)'
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![](../images/pg125-1.jpg)'
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You get* H[i] *=* H[i –] 1 *because plugging the decryption of zero into the
    encryption function yields zero—the term* ***E****(*M[i]*,* ***D****(*M[i]*, 0))
    = 0—leaving only the* ⊕ H[i –] 1 *part of the equation in the expression of the
    compression function’s output. You can then find fixed points for the compression
    functions of the SHA-2 functions, for example, which are based on the Davies–Meyer
    construction. Fortunately, fixed points aren’t a security risk.*'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are many block cipher–based compression functions other than Davies–Meyer,
    such as those in [Figure 6-6](chapter6.xhtml#fig6-6).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig6-6.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-6: Other secure block
    cipher–based compression function constructions</samp>'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: These are less popular because they’re more complex or require the message block
    to be the same length as the chaining value.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Permutation-Based
    Hash Functions</samp>
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After decades of research, cryptographers know everything there is to know about
    block cipher–based hashing techniques. Still, shouldn’t there be a simpler way
    to hash? Why bother with a block cipher, an algorithm that takes a secret key,
    when hash functions don’t take a secret key? Why not build hash functions with
    a fixed-key block cipher, a single permutation algorithm?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Those simpler hash functions are sponge functions, and they use a single permutation
    instead of a compression function and a block cipher (see [Figure 6-7](chapter6.xhtml#fig6-7)).
    Instead of using a block cipher to mix message bits with the internal state, sponge
    functions just do an XOR operation. Sponge functions are not only simpler than
    Merkle–Damgård functions, they’re also more versatile. You’ll find them used as
    hash functions and also as deterministic random bit generators, stream ciphers,
    pseudorandom functions (see [Chapter 7](chapter7.xhtml)), and authenticated ciphers
    (see [Chapter 8](chapter8.xhtml)). The most famous sponge function is Keccak,
    also known as SHA-3.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig6-7.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-7: The sponge construction</samp>'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'A sponge function works as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 1.  It XORs the first message block, *M*[1], to *H*[0], a predefined initial
    value of the internal state (for example, the all-zero string). Message blocks
    are all the same size and smaller than the internal state.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 2.  A permutation, **P**, transforms the internal state to another value of
    the same size.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 3.  It XORs block *M*[2] and applies **P** and then repeats this for the message
    blocks *M*[3], *M*[4], and so on. This is the *absorbing phase*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 4.  After injecting all the message blocks, it applies **P** again and extracts
    a block of bits from the state to form the hash. If you need a longer hash, apply
    **P** again and extract a block. This is the *squeezing phase*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: The security of a sponge function depends on the length of its internal state
    and the length of the blocks. If message blocks are *r*-bit long and the internal
    state is *w*-bit long, then there are *c* = *w* – *r* bits of the internal state
    that message blocks can’t modify. The value of *c* is a sponge’s *capacity*, and
    the security level guaranteed by the sponge function is *c*/2\. For example, to
    reach 256-bit security with 64-bit message blocks, the internal state should be
    at least *w* = 2 × 256 + 64 = 576 bits. The security level also depends on the
    length, *n*, of the hash value. The complexity of a collision attack is therefore
    the smallest value between 2*^n*^(/2) and 2*^c*^(/2), while the complexity of
    a second preimage attack is the smallest value between 2*^n* and 2*^c*^(/2).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: To be secure, the permutation **P** should behave like a random permutation,
    without statistical bias and without a mathematical structure that would allow
    an attacker to predict outputs. As with compression function–based hashes, sponge
    functions also pad messages, but the padding is simpler because it doesn’t need
    to include the message’s length. The last message bit is simply followed by a
    1 bit and as many zeros as necessary.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The SHA Family of Hash Functions</samp>
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *Secure Hash Algorithm (SHA)* hash functions are standards defined by NIST
    for use by nonmilitary federal government agencies in the United States. They
    are considered worldwide standards, and only certain non-US governments opt for
    their own hash algorithms (such as China’s SM3, Russia’s Streebog, and Ukraine’s
    Kupyna) for reasons of sovereignty rather than a lack of trust in SHA’s security.
    The US SHAs have been more extensively reviewed by cryptanalysts than the non-US
    ones.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Message Digest 5 (MD5) was the most popular hash function from 1992 until
    it was broken around 2005, and many applications switched to one of the SHA hash
    functions. MD5 processes 512-bit block messages and updates a 128-bit internal
    state to produce a 128-bit hash, thus providing at best 128-bit preimage security
    and 64-bit collision security. In 1996, cryptanalysts warned of a collision for
    MD5’s compression function, but their warning went unheeded until 2005 when a
    team of Chinese cryptanalysts discovered how to compute collisions for the full
    MD5 hash. As I write this, it takes only seconds to find a collision for MD5,
    yet some systems still use or support MD5, often for reasons of backward compatibility.*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">SHA-1</samp>
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The SHA-1 standard arose from a failure in the NSA’s original SHA-0 hash function.
    In 1993, NIST standardized the SHA-0 hash algorithm, but in 1995 the NSA released
    SHA-1 to fix an unidentified security issue in SHA-0\. The reason for the tweak
    became clear when in 1998 two researchers discovered how to find collisions for
    SHA-0 in about 2^(60) operations instead of the 2^(80) expected for 160-bit hash
    functions such as SHA-0 and SHA-1\. Later attacks reduced the complexity to around
    2^(33) operations, leading to actual collisions in less than an hour for SHA-0.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-1标准源自NSA原始SHA-0哈希函数的失败。1993年，NIST标准化了SHA-0哈希算法，但1995年NSA发布了SHA-1，以修复SHA-0中未发现的安全问题。当1998年两位研究人员发现如何在约2^(60)次操作内找到SHA-0的碰撞，而不是预期的SHA-0和SHA-1这样的160位哈希函数所需的2^(80)次操作时，修正的原因变得明确。后来，攻击将复杂度降低到约2^(33)次操作，导致SHA-0在不到一个小时内就发生了实际碰撞。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">SHA-1 Internals</samp>
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">SHA-1 内部结构</samp>
- en: 'SHA-1 combines a Merkle–Damgård hash function with a Davies–Meyer compression
    function based on a specially crafted block cipher. That is, SHA-1 works by iterating
    the following operation over 512-bit message blocks (*M*):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-1结合了Merkle-Damgård哈希函数和基于专门设计的块密码的Davies-Meyer压缩函数。也就是说，SHA-1通过对512位消息块（*M*）进行以下操作的迭代来工作：
- en: '![](../images/pg127-1.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg127-1.jpg)'
- en: 'Here, the use of a plus sign (+) rather than ⊕ (XOR) is intentional. **E**(*M*,
    *H*) and *H* are viewed as arrays of 32-bit integers, and two words at the same
    position are added together: the first 32-bit word of **E**(*M*, *H*) with the
    first 32-bit word of *H*, and so on. The initial value of *H* is constant for
    any message, then *H* is modified as per the previous equation, and the final
    value of *H* after processing all blocks is returned as the hash of the message.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用加号（+）而非⊕（XOR）是有意为之。**E**(*M*, *H*)和 *H* 被视为32位整数的数组，两个处于相同位置的词相加：**E**(*M*,
    *H*)的第一个32位词与 *H* 的第一个32位词相加，依此类推。*H* 的初始值对任何消息都是固定的，随后 *H* 根据之前的公式进行修改，处理完所有块后，*H*
    的最终值作为消息的哈希值返回。
- en: Once the block cipher is run using the message block as a key and the current
    160-bit chaining value as a plaintext block, the 160-bit result is seen as an
    array of five 32-bit words, each of which is added to its 32-bit counterpart in
    the initial *H* value.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用消息块作为密钥、当前160位链接值作为明文块运行块密码，160位的结果就会被视为五个32位词的数组，其中每个词与初始 *H* 值中的对应32位词相加。
- en: '[Listing 6-4](chapter6.xhtml#Lis6-4) shows SHA-1’s compression function, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">SHA1-compress()</samp>:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单6-4](chapter6.xhtml#Lis6-4)展示了SHA-1的压缩函数，<samp class="SANS_TheSansMonoCd_W5Regular_11">SHA1-compress()</samp>：'
- en: '[PRE3]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-4: SHA-1’s compression
    function</samp>'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单6-4：SHA-1的压缩函数</samp>
- en: SHA-1’s block cipher <samp class="SANS_TheSansMonoCd_W5Regular_11">SHA1-blockcipher()</samp>,
    shown in bold, takes a 512-bit message block, *M*, as a key and transforms the
    five 32-bit words (<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>, <samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>)
    by iterating 80 steps of a short sequence of operations to replace the word <samp
    class="SANS_TheSansMonoCd_W5Regular_11">a</samp> with a combination of all five
    words. It then shifts the other words in the array, as in a shift register. [Listing
    6-5](chapter6.xhtml#Lis6-5) describes these operations in pseudocode, where <samp
    class="SANS_TheSansMonoCd_W5Regular_11">K[i]</samp> is a round-dependent constant.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: SHA-1的块密码 <samp class="SANS_TheSansMonoCd_W5Regular_11">SHA1-blockcipher()</samp>，以粗体显示，接受一个512位的消息块
    *M* 作为密钥，并通过迭代80步的短操作序列来转换五个32位词（<samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">b</samp>、<samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>、<samp
    class="SANS_TheSansMonoCd_W5Regular_11">d</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>），通过这些步骤将词
    <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp> 替换为五个词的组合。然后，它会像移位寄存器一样移动数组中的其他词。[清单6-5](chapter6.xhtml#Lis6-5)以伪代码描述了这些操作，其中
    <samp class="SANS_TheSansMonoCd_W5Regular_11">K[i]</samp> 是与轮次相关的常量。
- en: '[PRE4]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-5: SHA-1’s block
    cipher</samp>'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单6-5：SHA-1的块密码</samp>
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">expand()</samp> function in
    [Listing 6-5](chapter6.xhtml#Lis6-5) creates an array of 80 32-bit words, *W*,
    from the 16-word message block by setting *W*’s first 16 words to *M* and the
    subsequent ones to an XOR combination of previous words, rotated 1 bit to the
    left. [Listing 6-6](chapter6.xhtml#Lis6-6) shows the corresponding pseudocode.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-6: SHA-1’s</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">expand()</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11"><<< 1</samp> operation in
    [Listing 6-6](chapter6.xhtml#Lis6-6) is the only difference between the SHA-1
    and the SHA-0 functions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Finally, [Listing 6-7](chapter6.xhtml#Lis6-7) shows the <samp class="SANS_TheSansMonoCd_W5Regular_11">f()</samp>
    function in <samp class="SANS_TheSansMonoCd_W5Regular_11">SHA1-blockcipher()</samp>,
    a sequence of basic bitwise logical operations (a Boolean function) that depends
    on the round number.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-7: SHA-1’s</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">f()</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: The second and fourth Boolean functions in [Listing 6-7](chapter6.xhtml#Lis6-7)
    simply XOR the three input words together, which is a linear operation. In contrast,
    the first and third functions use the nonlinear <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator (logical AND) to protect against differential cryptanalysis, which exploits
    the predictable propagation of bitwise difference. Without the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator (in other words, if <samp class="SANS_TheSansMonoCd_W5Regular_11">f()</samp>
    were always <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp> ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>
    ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">d</samp>, for example), SHA-1
    would be easy to break by tracing patterns within its internal state.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Attacks on SHA-1</samp>
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Though more robust than SHA-0, SHA-1 is also insecure, which is why the Chrome
    browser marks websites using SHA-1 in their HTTPS connection as insecure since
    2014\. Although its 160-bit hash should grant it 80-bit collision resistance,
    in 2005 researchers found weaknesses in SHA-1 and estimated that finding a collision
    would take approximately 2^(63) calculations (against 2^(80) if the algorithm
    were flawless). A real SHA-1 collision came only 12 years later when after years
    of research, cryptanalysts presented two colliding PDF documents through a joint
    work with Google researchers (see *[https://<wbr>shattered<wbr>.io](https://shattered.io)*).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: You should not use SHA-1\. Most web browsers now mark SHA-1 as insecure, and
    SHA-1 is no longer recommended by NIST. Use SHA-2, SHA-3, BLAKE2, or BLAKE3 instead.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">SHA-2</samp>
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'SHA-2, the successor to SHA-1, was designed by the NSA and standardized by
    NIST in 2002\. SHA-2 is a family of four hash functions: SHA-224, SHA-256, SHA-384,
    and SHA-512 (of which SHA-256 and SHA-512 are the two main algorithms). The three-digit
    numbers represent the bit lengths of each hash.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: The initial motivation behind the development of SHA-2 was to generate longer
    hashes and thus deliver higher security levels than SHA-1\. However, SHA-1 and
    SHA-2 algorithms are similar in their construction. All SHA-2 instances also use
    the Merkle–Damgård construction and have a compression function that closely resembles
    that of SHA-1 but with stronger nonlinearity and difference propagation properties.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">SHA-256</samp>
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: SHA-256 is the most common version of SHA-2\. Whereas SHA-1 has 160-bit chaining
    values, SHA-256 has 256-bit chaining values as eight 32-bit words. Both SHA-1
    and SHA-256 have 512-bit message blocks, but whereas SHA-1 makes 80 rounds, SHA-256
    makes 64 rounds, expanding the 16-word message block to a 64-word message block
    using the <samp class="SANS_TheSansMonoCd_W5Regular_11">expand256()</samp> function,
    as [Listing 6-8](chapter6.xhtml#Lis6-8) shows.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-8: SHA-256’s</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">expand256()</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">function</samp>'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Note how SHA-2’s <samp class="SANS_TheSansMonoCd_W5Regular_11">expand256()</samp>
    message expansion is more complex than SHA-1’s <samp class="SANS_TheSansMonoCd_W5Regular_11">expand()</samp>
    in [Listing 6-6](chapter6.xhtml#Lis6-6), which in contrast simply performs XORs
    and a 1-bit rotation. The main loop of SHA-256’s compression function is also
    more complex than that of SHA-1, performing 26 arithmetic operations per iteration
    compared to 11 for SHA-1\. Again, these operations are XORs, logical ANDs, and
    word rotations. This greater complexity makes SHA-256 more resistant to differential
    cryptanalysis.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Other SHA-2 Algorithms</samp>
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The SHA-2 family includes SHA-224, which is algorithmically identical to SHA-256
    except that its initial value is a different set of eight 32-bit words, and its
    hash value length is 224 bits, instead of 256 bits, and is taken as the first
    224 bits of the final chaining value.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The SHA-2 family also includes the algorithms SHA-512 and SHA-384\. SHA-512
    is similar to SHA-256 except that it works with 64-bit words instead of 32-bit
    words. As a result, it uses 512-bit chaining values (eight 64-bit words) and ingests
    1,024-bit message blocks (sixteen 64-bit words), and it makes 80 rounds instead
    of 64\. The compression function is otherwise almost the same as that of SHA-256,
    though with different rotation distances to cope with the wider word size. (For
    example, SHA-512 includes the operation <samp class="SANS_TheSansMonoCd_W5Regular_11">a
    >>> 34</samp>, which wouldn’t make sense with SHA-256’s 32-bit words.) SHA-384
    is to SHA-512 what SHA-224 is to SHA-256—namely, the same algorithm but with a
    different initial value and a final hash truncated to 384 bits.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Security-wise, all four SHA-2 versions have lived up to their promises so far:
    SHA-256 guarantees 256-bit preimage resistance, SHA-512 guarantees about 256-bit
    collision resistance, and so on. Still, there is no genuine proof that SHA-2 functions
    are secure; we’re talking about probable security.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, after practical attacks on MD5 and on SHA-1, researchers and NIST
    grew concerned about SHA-2’s long-term security because of its similarity to SHA-1,
    and many believed that attacks on SHA-2 were just a matter of time. As I write
    this, we have yet to see a successful attack on SHA-2\. Regardless, NIST developed
    a backup plan: SHA-3.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The SHA-3 Competition</samp>
  id: totrans-166
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Announced in 2007, the NIST Hash Function Competition (the official name of
    the SHA-3 competition) began with a call for submissions and some basic requirements:
    hash submissions were to be at least as secure and as fast as SHA-2, and they
    should be able to do at least as much as SHA-2\. SHA-3 candidates also shouldn’t
    look too much like SHA-1 and SHA-2 to be immune to attacks that would break SHA-1
    and potentially SHA-2\. By 2008, NIST had received 64 submissions from around
    the world, including from universities and large corporations (BT, IBM, Microsoft,
    Qualcomm, and Sony, to name a few). Of these 64 submissions, 51 matched the requirements
    and entered the first round of the competition.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'During the first weeks of the competition, cryptanalysts mercilessly attacked
    the submissions. In July 2009, NIST announced 14 second-round candidates. After
    spending 15 months analyzing and evaluating the performance of these candidates,
    NIST chose five finalists:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '**BLAKE **An enhanced Merkle–Damgård hash whose compression function is based
    on a block cipher, which is in turn based on the core function of the stream cipher
    ChaCha, a chain of additions, XORs, and word rotations. BLAKE was designed by
    a team of academic researchers based in Switzerland and the UK, including myself
    while I was a PhD student.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '**Grøstl **An enhanced Merkle–Damgård hash whose compression function uses
    two permutations (or fixed-key block ciphers) based on the AES block cipher. Grøstl
    was designed by a team of seven academic researchers from Denmark and Austria.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '**JH **A tweaked sponge function construction wherein message blocks are injected
    before and after the permutation rather than just before. The permutation also
    performs operations similar to a substitution–permutation block cipher (see [Chapter
    4](chapter4.xhtml)). JH was designed by a cryptographer from a university in Singapore.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**Keccak **A sponge function whose permutation performs only bitwise operations.
    Keccak was designed by a team of four cryptographers working for a semiconductor
    company based in Belgium and Italy and included one of the two designers of AES.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '**Skein **A hash function based on a different mode of operation than Merkle–Damgård
    and whose compression function is based on a novel block cipher that uses only
    integer addition, XORs, and word rotation. Skein was designed by a team of eight
    cryptographers from academia and industry, all but one of whom is based in the
    United States, including the renowned Bruce Schneier.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'After extensive analysis of the five finalists, NIST announced a winner: Keccak.
    NIST’s report rewarded Keccak for its “elegant design, large security margin,
    good general performance, excellent efficiency in hardware, and its flexibility.”
    Let’s see how Keccak works.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Keccak (SHA-3)</samp>
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the reasons that NIST chose Keccak is that it’s completely different
    from SHA-1 and SHA-2\. For one thing, it’s a sponge function. Keccak’s core algorithm
    is a permutation of a 1,600-bit state that ingests blocks of 1,152, 1,088, 832,
    or 576 bits, producing hash values of 224, 256, 384, or 512 bits, respectively—the
    same four lengths produced by SHA-2 hash functions. But unlike SHA-2, SHA-3 uses
    a single core algorithm rather than two algorithms for all four hash lengths.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Another reason is that Keccak is more than just a hash. The SHA-3 standard document
    FIPS 202 defines four hashes—SHA3-224, SHA3-256, SHA3-384, and SHA3-512—and two
    algorithms called SHAKE128 and SHAKE256\. (The name *SHAKE* stands for *Secure
    Hash Algorithm with Keccak*.) These two algorithms are *extendable-output functions
    (XOFs)*, or hash functions that can produce hashes of variable length, even very
    long ones. The numbers 128 and 256 represent the security level of each algorithm.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: The FIPS 202 standard itself is lengthy and hard to parse, but you’ll find open
    source implementations that are reasonably fast and make the algorithm easy to
    understand. For example, the tiny_sha3 (*[https://<wbr>github<wbr>.com<wbr>/mjosaarinen<wbr>/tiny<wbr>_sha3](https://github.com/mjosaarinen/tiny_sha3)*)
    by Markku-Juhani O. Saarinen explains Keccak’s core algorithm in 19 lines of C
    code, as partially reproduced in [Listing 6-9](chapter6.xhtml#Lis6-9).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 6-9: The tiny_sha3
    implementation</samp>'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'The tiny_sha3 program implements the permutation, **P**, of Keccak, an invertible
    transformation of a 1,600-bit state viewed as an array of twenty-five 64-bit words.
    The code iterates a series of rounds, where each round consists of four main steps:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 1.  <samp class="SANS_TheSansMonoCd_W5Regular_11">Theta</samp> ❶ includes XORs
    between 64-bit words or a 1-bit rotated value of the words (the <samp class="SANS_TheSansMonoCd_W5Regular_11">ROTL64(w,
    1)</samp> operation left-rotates a word <samp class="SANS_TheSansMonoCd_W5Regular_11">w</samp>
    of 1 bit).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 2.  <samp class="SANS_TheSansMonoCd_W5Regular_11">Rho Pi</samp> ❷ includes rotations
    of 64-bit words by constants hardcoded in the <samp class="SANS_TheSansMonoCd_W5Regular_11">keccakf_rotc[]</samp>
    array.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 3.  <samp class="SANS_TheSansMonoCd_W5Regular_11">Chi</samp> ❸ includes more
    XORs but also logical ANDs (the <samp class="SANS_TheSansMonoCd_W5Regular_11">&</samp>
    operator) between 64-bit words. These ANDs are the only nonlinear operations in
    Keccak, and they bring with them cryptographic strength.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 4.  <samp class="SANS_TheSansMonoCd_W5Regular_11">Iota</samp> ❹ includes an
    XOR with a 64-bit constant, hardcoded in <samp class="SANS_TheSansMonoCd_W5Regular_11">keccakf
    _rndc[]</samp>.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: These operations provide SHA-3 with a strong permutation algorithm free of any
    bias or exploitable structure. SHA-3 is the product of more than a decade of research,
    and hundreds of skilled cryptanalysts have failed to break it. It’s unlikely to
    be broken anytime soon.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The BLAKE2 and BLAKE3 Hash Functions</samp>
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Security may matter most, but speed comes second. I’ve seen many cases where
    a developer wouldn’t switch from MD5 to SHA-1 simply because MD5 is faster or
    from SHA-1 to SHA-2 because SHA-2 is noticeably slower than SHA-1\. Unfortunately,
    SHA-3 isn’t faster than SHA-2, and because SHA-2 is still secure, there are few
    incentives to upgrade to SHA-3\. So how do we hash faster than SHA-1 and SHA-2
    and be even more secure? The answer lies in the hash function BLAKE2, released
    after the SHA-3 competition.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Full disclosure: I’m a designer of BLAKE2, together with Samuel Neves, Zooko
    Wilcox-O’Hearn, and Christian Winnerlein.*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: 'BLAKE2 was designed with the following ideas in mind:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: It should be at least as secure as SHA-3, if not stronger.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be faster than all previous hash standards, including MD5.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be suited for use in modern applications and able to hash large amounts
    of data either as a few large messages or as many small ones, with or without
    a secret key.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should be suited for use on modern CPUs supporting parallel computing on
    multicore systems as well as instruction-level parallelism within a single core.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The outcome of the engineering process is a pair of main hash functions:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: BLAKE2b (or just BLAKE2), optimized for 64-bit platforms, produces digests ranging
    from 1 to 64 bytes.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BLAKE2s, optimized for 8- to 32-bit platforms, produces digests ranging from
    1 to 32 bytes.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each function has a parallel variant that can leverage multiple CPU cores. The
    parallel counterpart of BLAKE2b, BLAKE2bp, runs on four cores, whereas BLAKE2sp
    runs on eight cores. The former is the fastest on modern server and laptop CPUs
    and can hash at close to 2Gbps on a laptop CPU. BLAKE2’s speed and features have
    made it the most popular non-NIST-standard hash. BLAKE2 is used in countless software
    applications and has been integrated into major cryptography libraries such as
    OpenSSL and Sodium. BLAKE2 is also an Internet Engineering Task Force (IETF) standard,
    described in RFC 7693.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-200
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*You can find BLAKE2’s specifications and reference code at* [https://<wbr>blake2<wbr>.net](https://blake2.net)*,
    and you can download optimized code and libraries from* [https://<wbr>github<wbr>.com/BLAKE2](https://github.com/BLAKE2)*.
    The reference code also provides BLAKE2X, an extension of BLAKE2 that can produce
    hash values of arbitrary length.*'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: As [Figure 6-8](chapter6.xhtml#fig6-8) illustrates, BLAKE2’s compression function
    is a variant of the Davies–Meyer construction that takes parameters as additional
    input—namely, a *counter* (which ensures that each compression function behaves
    like a different function) and a *flag* (which indicates whether the compression
    function is processing the last message block, for increased security).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig6-8.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-8: BLAKE2’s compression
    function. The two halves of the state are XORed together after the block cipher.</samp>'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'The block cipher in BLAKE2’s compression function is based on the stream cipher
    ChaCha, itself a variant of the Salsa20 stream cipher discussed in [Chapter 5](chapter5.xhtml).
    Within this block cipher, BLAKE2b’s core operation is composed of the following
    chain of operations, which transforms a state of four 64-bit words using two message
    words, *M*i and *M*j:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg135-1.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: BLAKE2s’s core operation is similar but works with 32-bit instead of 64-bit
    words (and thus uses different rotation values).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, BLAKE3 is a more parallelizable, simpler, more versatile,
    and faster version of BLAKE2 that was presented in 2020 at the Real World Crypto
    conference. Designed by Jack O’Connor, Samuel Neves, Zooko Wilcox-O’Hearn, and
    myself, BLAKE3 has quickly become one of the most popular hash functions, thanks
    to its undeniable advantages. For more details, see *[https://<wbr>github<wbr>.com<wbr>/BLAKE3<wbr>-team<wbr>/BLAKE3](https://github.com/BLAKE3-team/BLAKE3)*.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Despite their apparent simplicity, hash functions can cause major security
    troubles when used at the wrong place or in the wrong way—for example, when using
    weak checksum algorithms like CRCs instead of a crypto hash to check file integrity
    in applications transmitting data over a network. However, this weakness pales
    in comparison to others, which can cause total compromise in seemingly secure
    hash functions. You’ll see two examples of failures: the first one applies to
    SHA-1 and SHA-2 but not to BLAKE2 or SHA-3, whereas the second one applies to
    all four of these functions.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Length-Extension
    Attack</samp>
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Figure 6-9](chapter6.xhtml#fig6-9) shows the *length-extension attack*, which
    is the main threat to the Merkle–Damgård construction.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig6-9.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 6-9: The length-extension
    attack</samp>'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Basically, if you know **Hash**(*M*) for some *unknown* message, *M*, composed
    of blocks *M*[1] and *M*[2] (after padding), you can determine **Hash**(*M*[1]
    || *M*[2] || *M*[3]) for any block, *M*[3]. Because the hash of *M*[1] || *M*[2]
    is the chaining value that follows immediately after *M*[2], you can add another
    block, *M*[3], to the hashed message, even though you don’t know the data that
    was hashed. What’s more, this trick generalizes to any number of blocks in the
    unknown message (*M*[1] || *M*[2] here) or in the suffix (*M*[3]).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The length-extension attack won’t affect most applications of hash functions,
    but it can compromise security if using the hash a bit too creatively. Unfortunately,
    SHA-2 hash functions are vulnerable to the length-extension attack, even though
    the NSA designed the functions and NIST standardized them while both were well
    aware of the flaw. This flaw could have been avoided simply by making the last
    compression function call different from all others (for example, by taking a
    1 bit as an extra parameter while the previous calls take a 0 bit). That is what
    BLAKE2 does.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Fooling Proof-of-Storage
    Protocols</samp>
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Cloud computing applications use hash functions within *proof-of-storage* protocols—that
    is, protocols where a server (the cloud provider) proves to a client (a user of
    a cloud storage service) that the server does in fact store the files that it’s
    supposed to store on behalf of the client.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'In 2007, the paper “SafeStore: A Durable and Practical Storage System” (*[https://<wbr>www<wbr>.cs<wbr>.utexas<wbr>.edu<wbr>/~lorenzo<wbr>/papers<wbr>/p129<wbr>-kotla<wbr>.pdf](https://www.cs.utexas.edu/~lorenzo/papers/p129-kotla.pdf)*)
    by Ramakrishna Kotla, Lorenzo Alvisi, and Mike Dahlin proposed a proof-of-storage
    protocol to verify the storage of some file, *M*, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 1.  The client picks a random value, *C,* as a *challenge*.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 2.  The server computes **Hash**(*M* || *C*) as a *response* and sends the result
    to the client.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 3.  The client also computes **Hash**(*M* || *C*) and checks that it matches
    the value received from the server.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'The premise of the paper is that the server shouldn’t be able to fool the client
    because if the server doesn’t know *M*, it can’t guess **Hash**(*M* || *C*). But
    there’s a catch: in reality, **Hash** is an iterated hash that processes its input
    block by block, computing intermediate chaining values between each block. For
    example, if **Hash** is SHA-256 and *M* is 512 bits long (the size of a block
    in SHA-256), the server can cheat. How? The first time the server receives *M*,
    it computes *H*[1] = **Compress**(*H*[0], *M*[1]), the chaining value obtained
    from SHA-256’s initial value, *H*[0], and from the 512-bit *M*. It then records
    *H*[1] in memory and discards *M*, at which point it no longer stores *M*.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: When the client sends a random value, *C*, the server computes **Compress**(*H*[1],
    *C*), after adding the padding to *C* to fill a complete block, and returns the
    result as **Hash**(*M* || *C*). The client then believes that because the server
    returned the correct value of **Hash**(*M* || *C*), it holds the complete message—except
    that it may not, as you’ve seen.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'This trick works for SHA-1, SHA-2, as well as SHA-3 and BLAKE2\. The solution
    is simple: ask for **Hash**(*C* || *M*) instead of **Hash**(*M* || *C*).'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To learn more about hash functions, read the classics from the 1980s and ’90s:
    research articles like Ralph Merkle’s “One Way Hash Functions and DES” and Ivan
    Damgård’s “A Design Principle for Hash Functions.” Also read the first thorough
    study of block cipher–based hashing, “Hash Functions Based on Block Ciphers: A
    Synthetic Approach” by Bart Preneel, René Govaerts, and Joos Vandewalle.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: For more on collision search, read the 1997 paper “Parallel Collision Search
    with Cryptanalytic Applications” by Paul van Oorschot and Michael Wiener. To learn
    more about the theoretical security notions that underpin preimage resistance
    and collision resistance, as well as length-extension attacks, search for *indifferentiability*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: For more recent research on hash functions, see the archives of the SHA-3 competition,
    which include all the different algorithms and how they were broken. You’ll find
    many references on the SHA-3 Zoo at *[https://<wbr>ehash<wbr>.iaik<wbr>.tugraz<wbr>.at<wbr>/wiki<wbr>/The<wbr>_SHA<wbr>-3<wbr>_Zoo<wbr>.html](https://ehash.iaik.tugraz.at/wiki/The_SHA-3_Zoo.html)*,
    and on NIST’s page, *[https://<wbr>csrc<wbr>.nist<wbr>.gov<wbr>/projects<wbr>/hash<wbr>-functions<wbr>/sha<wbr>-3<wbr>-project](https://csrc.nist.gov/projects/hash-functions/sha-3-project)*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: For more on the SHA-3 winner Keccak and sponge functions, see *[https://<wbr>keccak<wbr>.team<wbr>/sponge<wbr>_duplex<wbr>.html](https://keccak.team/sponge_duplex.html)*,
    the official page of the Keccak designers.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you may look up these two real exploitations of weak hash functions:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: The nation-state malware Flame exploited an MD5 collision to make a counterfeit
    certificate and appear to be a legitimate piece of software.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Xbox game console used a weak block cipher (called TEA) to build a hash
    function, which was exploited to hack the console and run arbitrary code on it.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
