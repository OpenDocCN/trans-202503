<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_49"/><strong><span class="big">6</span></strong><br/><strong>INJECTION ATTACKS</strong></h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="image" width="190" height="190"/></div>&#13;
<p class="noindent">Now that you have a solid grasp of how the internet works, let’s focus on specific vulnerabilities and the methods hackers use to exploit them. This chapter covers <em>injection attacks</em>, which occur when the attacker injects external code into an application in an effort to take control of the application or read sensitive data.</p>&#13;
<p class="indent">Recall that the internet is an example of a <em>client-server architecture</em>, meaning that a web server handles connections from many clients at once. Most clients are web browsers, responsible for generating HTTP requests to the web server as a user navigates the website. The web server returns HTTP responses containing the HTML that makes up the content of the website’s pages.</p>&#13;
<p class="indent">Because the web server controls the website’s content, server-side code naturally expects specific types of user interactions to occur, and therefore expects the browser to generate specific types of HTTP requests. For instance, the server expects to see a <code>GET</code> request to a new URL each time the <span epub:type="pagebreak" id="page_50"/>user clicks a link, or a <code>POST</code> request if they enter their login credentials and click Submit.</p>&#13;
<p class="indent">However, it’s perfectly possible for a browser to generate unexpected HTTP requests to a server. In addition, web servers happily accept HTTP requests from any type of client, not just browsers. A programmer equipped with an HTTP client library can write scripts that send requests to arbitrary URLs on the internet. The hacking tools we reviewed in <a href="ch01.xhtml#ch01">Chapter 1</a> do exactly that.</p>&#13;
<p class="indent">Server-side code has no reliable way of telling whether a script or a browser generated an HTTP request, because the contents of the HTTP request are indistinguishable regardless of the client. The best a server can do is to check the <code>User-Agent</code> header, which is <em>supposed</em> to describe the type of <em>agent</em> that generated the request, but scripts and hacking tools typically <em>spoof</em> the contents of this header, so it matches what a browser would send.</p>&#13;
<p class="indent">Knowing all of this, hackers attacking a website frequently pass malicious code in an HTTP request so that it tricks the server into executing the code. This is the basis of an injection attack on a website.</p>&#13;
<p class="indent">Injection attacks are astonishingly common on the internet and, if successful, can be devastating in their impact. As a web developer, you’ll need to know all the ways they can occur and how to defend against them. When writing website code, it’s important to consider what <em>could</em> come through in the HTTP requests being handled by the site, not just what you expect to come through. In this chapter, you’ll look at four types of injection attacks: SQL injection attacks, command injection attacks, remote code execution attacks, and attacks that exploit file upload vulnerabilities.</p>&#13;
<h3 class="h3" id="ch00lev1sec69"><strong>SQL Injection</strong></h3>&#13;
<p class="noindent"><em>SQL injection</em> attacks target websites that use an underlying SQL database and construct data queries to the database in an insecure fashion. SQL injection attacks pose one of the greatest risks to websites because SQL databases are so common. This was evident in 2008, when hackers stole 130 million credit card numbers from Heartland Payment Systems, a payment processor that stores credit card details and handles payments for merchants. The hackers used a SQL injection attack to access the web servers that handled payment data, which was a disaster for a company that relies on the assurance of their information’s security to do business.</p>&#13;
<p class="indent">Let’s begin by reviewing how SQL databases work, so that we can get to the heart of how SQL injection works and how we can stop it.</p>&#13;
<h4 class="h4" id="ch00lev1sec70"><strong><em>What Is SQL?</em></strong></h4>&#13;
<p class="noindent"><em>Structured Query Language</em>, or <em>SQL</em>, extracts data and data structures in relational databases. Relational databases store data in tables; each row in a table is a data item (for example, a user, or a product being sold). SQL syntax allows applications such as web servers to add rows to the database by using <code>INSERT</code> statements, read rows by using <code>SELECT</code> statements, update rows by using <code>UPDATE</code> statements, and remove rows by using <code>DELETE</code> statements.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_51"/>Consider the SQL statements that a web server might run behind the scenes when you sign up on a website, as shown in <a href="ch06.xhtml#ch6list1">Listing 6-1</a>.</p>&#13;
<pre><span class="ent">❶</span> INSERT INTO users (email, encrypted_password)<br/>   VALUES ('billy@gmail.com', '$10$WMT9Y')<br/><span class="ent">❷</span> SELECT * FROM users WHERE email = 'billy@gmail.com'<br/>   AND encrypted_password = '$10$WMT9Y'<br/><span class="ent">❸</span> UPDATE USERS users encrypted_password ='3D$MW$10Z'<br/>   WHERE email='billy@gmail.com'<br/><span class="ent">❹</span> DELETE FROM users WHERE email = 'billy@gmail.com'</pre>&#13;
<p class="caption"><a id="ch6list1"/><em>Listing 6-1: Typical SQL statements that a web server might run when a user interacts with a website</em></p>&#13;
<p class="indent">SQL databases typically store information about the website’s users in a <code>users</code> table. When a user first signs up and chooses a username and password, the web server runs an <code>INSERT</code> statement on the database to create a new row in the <code>users</code> table <span class="ent">❶</span>. The next time a user logs in to the website, the web server runs a <code>SELECT</code> statement to attempt to find the corresponding row in the <code>users</code> table <span class="ent">❷</span>. If the user changes their password, the web server runs an <code>UPDATE</code> statement to update the corresponding row in the <code>users</code> table <span class="ent">❸</span>. Finally, if the user closes their account, the website might run a <code>DELETE</code> statement to remove their row from the <code>users</code> table <span class="ent">❹</span>.</p>&#13;
<p class="indent">For each interaction, the web server is responsible for taking parts of the HTTP request (for example, the username and password entered into a login form) and constructing a SQL statement to run against the database. The actual execution of the statement happens through the <em>database driver</em>, a dedicated code library used to communicate with the database.</p>&#13;
<h4 class="h4" id="ch00lev1sec71"><strong><em>Anatomy of a SQL Injection Attack</em></strong></h4>&#13;
<p class="noindent">SQL injection attacks occur when the web server insecurely constructs the SQL statement it passes to the database driver. This allows the attacker to pass arguments via the HTTP request that cause the driver to perform actions other than those the developer intends.</p>&#13;
<p class="indent">Let’s look at an insecurely constructed SQL statement that reads user data from the database when a user attempts to log in to a website, as shown in the Java code in <a href="ch06.xhtml#ch6list2">Listing 6-2</a>.</p>&#13;
<pre>Connection connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);<br/>Statement statement = connection.createStatement();<br/>String sql = "SELECT * FROM users WHERE email='" + email +<br/>             "' AND encrypted_password='" + password + "'";<br/>statement.executeQuery(sql);</pre>&#13;
<p class="caption"><a id="ch6list2"/><em>Listing 6-2: An insecure method of reading user data from the database during a login attempt</em></p>&#13;
<p class="indent">The construction of this SQL statement isn’t secure! This snippet uses the <code>email</code> and <code>password</code> parameters taken from the HTTP request, and inserts them directly into the SQL statement. Because the parameters aren’t checked for SQL control characters (such as <code>'</code>) that change the meaning of the SQL <span epub:type="pagebreak" id="page_52"/>statement, a hacker can craft input that bypasses the website’s authentication system.</p>&#13;
<p class="indent">An example of this is shown in <a href="ch06.xhtml#ch6list3">Listing 6-3</a>. In this example, the attacker passes the user <code>email</code> parameter as <code>billy@gmail.com'--</code>, which terminates the SQL statement early and causes the password-checking logic to not execute:</p>&#13;
<pre>statement.executeQuery(<br/>  <span class="codestrong1">"SELECT * FROM users WHERE email='billy@gmail.com'</span><span class="ent">❶</span>--' AND encrypted_password='Z$DSA92H0'<span class="ent">❷</span>");</pre>&#13;
<p class="caption"><a id="ch6list3"/><em>Listing 6-3: Using SQL injection to bypass authentication</em></p>&#13;
<p class="indent">The database driver executes only the SQL statement <span class="ent">❶</span>, and ignores everything that comes after it <span class="ent">❷</span>. In this type of SQL injection attack, the single quote character (<code>'</code>) closes the email argument early, and the SQL comment syntax (<code>--</code>) tricks the database driver into ignoring the end of the statement that does password checking. This SQL statement allows the attacker to log in as <em>any</em> user without having to know their password! All the attacker has to do is add the <code>'</code> and <code>--</code> characters to the user’s email address in the login form.</p>&#13;
<p class="indent">This is a relatively simple example of a SQL injection attack. A more advanced attack might cause the database driver to run additional commands on the database. <a href="ch06.xhtml#ch6list4">Listing 6-4</a> shows a SQL injection attack that runs a <code>DROP</code> command to remove the <code>users</code> table entirely, in order to corrupt the database.</p>&#13;
<pre>statement.executeQuery("SELECT * FROM users WHERE email='billy@gmail.com';<span class="ent">❶</span><br/><span class="codestrong1">DROP TABLE users;</span><span class="ent">❷</span>--' AND encrypted_password='Z$DSA92H0'");</pre>&#13;
<p class="caption"><a id="ch6list4"/><em>Listing 6-4: A SQL injection attack in progress</em></p>&#13;
<p class="indent">In this scenario, the attacker passes the email parameter as <code>billy@gmail.com'; DROP TABLE users;--</code>. The semicolon character (<code>;</code>) terminates the first SQL statement <span class="ent">❶</span>, after which the attacker inserts an additional, destructive statement <span class="ent">❷</span>. The database driver will run both statements, leaving your database in a corrupt state!</p>&#13;
<p class="indent">If your website is vulnerable to SQL injection, an attacker can often run arbitrary SQL statements against your database, allowing them to bypass authentication; read, download, and delete data at will; or even inject malicious JavaScript into the pages rendered to your users. To scan websites for SQL injection vulnerabilities, hacking tools like Metasploit can be used to crawl websites and test HTTP parameters with potential exploits. If your site is vulnerable to SQL injection attacks, you can be sure that somebody will eventually take advantage of it.</p>&#13;
<h4 class="h4" id="ch00lev1sec72"><strong><em>Mitigation 1: Use Parameterized Statements</em></strong></h4>&#13;
<p class="noindent">To protect against SQL injection attacks, your code needs to construct SQL strings using bind parameters. <em>Bind parameters</em> are placeholder characters that the database driver will safely replace with some supplied inputs—like <span epub:type="pagebreak" id="page_53"/>the email or password values shown in <a href="ch06.xhtml#ch6list1">Listing 6-1</a>. A SQL statement containing bind parameters is called a <em>parameterized statement</em>.</p>&#13;
<p class="indent">SQL injection attacks use “control characters” that have special meaning in SQL statements to “jump out” of the context and change the whole semantics of the SQL statement. When you use bind parameters, these control characters are prefixed with “escape characters” that tell the database not to treat the following character as a control character. This escaping of control characters defuses potential injection attacks.</p>&#13;
<p class="indent">A securely constructed SQL statement using bind parameters should look like <a href="ch06.xhtml#ch6list5">Listing 6-5</a>.</p>&#13;
<pre>   Connection connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);<br/>   Statement statement = connection.createStatement();<br/><span class="ent">❶</span> String sql = "SELECT * FROM users WHERE email = ? and encrypted_password = ?";<br/><span class="ent">❷</span> statement.executeQuery(sql, email, password);</pre>&#13;
<p class="caption"><a id="ch6list5"/><em>Listing 6-5: Using bind parameters to protect against SQL injection</em></p>&#13;
<p class="indent">This code constructs the SQL query in parameterized form using <code>?</code> as the bind parameter <span class="ent">❶</span>. The code then <em>binds</em> the input values for each parameter to the statement <span class="ent">❷</span>, asking the database driver to insert the parameter values into the SQL statement while securely handling any control characters. If an attacker attempts to hack this code using the method outlined in <a href="ch06.xhtml#ch6list4">Listing 6-4</a> by passing in a username of <code>billy@email.com'--</code>, your securely constructed SQL statement will defuse the attack, as shown in <a href="ch06.xhtml#ch6list6">Listing 6-6</a>.</p>&#13;
<pre>statement.executeQuery(<br/>  "SELECT * FROM users WHERE email = ? AND encrypted_password = ?",<br/>  "billy@email.com'--,",<br/>  "Z$DSA92H0");</pre>&#13;
<p class="caption"><a id="ch6list6"/><em>Listing 6-6: The SQL injection attack is defused.</em></p>&#13;
<p class="indent">Because the database driver makes sure not to terminate the SQL statement early, this <code>SELECT</code> statement will safely return <em>no</em> users, and the attack should fail. Parameterized statements ensure that the database driver treats all control characters (such as <code>'</code>, <code>--</code>, and <code>;</code>) as an <em>input</em> to the SQL statement, rather than as part of the SQL statement. If you’re not sure whether your website is using parameterized statements, go check immediately! SQL injection is probably the biggest risk your website will face.</p>&#13;
<p class="indent">Similar types of injection attacks may be possible whenever a web server communicates with a separate backend by constructing a statement in the backend’s native language. This includes NoSQL databases like MongoDB and Apache Cassandra, distributed caches like Redis and Memcached, and directories that implement the Lightweight Directory Access Protocol (LDAP). Libraries that communicate with these platforms have their own implementation of bind parameters, so be sure to understand how they work and to use them in your code.</p>&#13;
<h4 class="h4" id="ch00lev1sec73"><span epub:type="pagebreak" id="page_54"/><strong><em>Mitigation 2: Use Object-Relational Mapping</em></strong></h4>&#13;
<p class="noindent">Many web server libraries and frameworks abstract away the explicit construction of SQL statements in code and allow you to access data objects by using object-relational mapping. <em>Object-relational mapping (ORM)</em> libraries map rows in database tables to code objects in memory, meaning the developer generally doesn’t have to write their own SQL statements in order to read from and update the database. This architecture protects against SQL injection attacks under most circumstances, but can still be vulnerable if custom SQL statements are used—so it’s important to understand how your ORM works behind the scenes.</p>&#13;
<p class="indent">The ORM that people are probably most familiar with is the Ruby on Rails ActiveRecord framework. <a href="ch06.xhtml#ch6list7">Listing 6-7</a> shows a simple line of Rails code that finds a user in a secure fashion.</p>&#13;
<pre>User.find_by(email: "billy@gmail.com")</pre>&#13;
<p class="caption"><a id="ch6list7"/><em>Listing 6-7: Ruby on Rails code that looks up a user by email in a way that is protected against injection attacks</em></p>&#13;
<p class="indent">Because ORMs use bind parameters under the hood, they protect against injection attacks in most cases. However, most ORMs also have backdoors that allow the developer to write raw SQL if needed. If you use these types of functions, you need to be careful about how you construct the SQL statements. For instance, <a href="ch06.xhtml#ch6list8">Listing 6-8</a> shows Rails code that <em>is</em> vulnerable to injection.</p>&#13;
<pre>def find_user(email, password)<br/>  User.where("email = '" + email + "' and encrypted_password = '" + password + "'")<br/>end</pre>&#13;
<p class="caption"><a id="ch6list8"/><em>Listing 6-8: Ruby on Rails code that is vulnerable to injection</em></p>&#13;
<p class="indent">Because this code passes part of the SQL statements as a raw string, an attacker can pass in special characters to manipulate the SQL statement that Rails generates. If the attacker can set the <code>password</code> variable to <code>' OR 1=1</code>, they can run a SQL statement that disables the password check, as shown in <a href="ch06.xhtml#ch6list9">Listing 6-9</a>.</p>&#13;
<pre>SELECT * FROM users WHERE email='billy@gmail.com' AND encrypted_password ='' OR 1=1</pre>&#13;
<p class="caption"><a id="ch6list9"/><em>Listing 6-9: The <span class="codeitalic">1=1</span> statement, which is trivially true, disables the password check.</em></p>&#13;
<p class="indent">The final clause of this SQL statement disables the password check, allowing the attacker to log in as that user. You can securely call the <code>where</code> function in Rails by using bind parameters, as shown in <a href="ch06.xhtml#ch6list10">Listing 6-10</a>.</p>&#13;
<pre>def find_user(email, encrypted_password)<br/>  User.where(["email = ? and encrypted_password = ?", email, encrypted_password])<br/>end</pre>&#13;
<p class="caption"><a id="ch6list10"/><em>Listing 6-10: Secure use of the <span class="codeitalic">where</span> function</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_55"/>In this scenario, the ActiveRecord framework will securely handle any SQL control characters an attacker adds to the <code>email</code> or <code>password</code> parameter.</p>&#13;
<h4 class="h4" id="ch00lev1sec74"><strong><em>Bonus Mitigation: Use Defense in Depth</em></strong></h4>&#13;
<p class="noindent">As a rule of thumb, you should always secure your website with redundancies. It’s not enough to check your code line by line for vulnerabilities. You need to consider and enforce security at every level of the stack, allowing failures at one level to be mitigated by other strategies. This is an approach called <em>defense in depth</em>.</p>&#13;
<p class="indent">Consider how you secure your home. The most important defense is installing locks on all doors and windows, but it also helps to have a burglar alarm, security cameras, household insurance, and maybe a large bad-tempered dog, in order to cover all eventualities.</p>&#13;
<p class="indent">When it comes to preventing SQL injection, defense in depth means using bind parameters, but also taking additional steps to minimize the harm in case an attacker <em>still</em> finds a way to successfully execute injection attacks. Let’s look at a couple of other ways to mitigate the risk of injection attacks.</p>&#13;
<h5 class="h5" id="ch00lev1sec75"><strong>Principle of Least Privilege</strong></h5>&#13;
<p class="noindent">An additional way to mitigate injection attacks is to follow the <em>principle of least privilege</em>, which demands that every process and application run only with the permissions it needs to perform its permitted functions, and no more. This means that if an attacker injects code into your web server and compromises a particular software component, the damage they can do is limited to the actions permissible by that particular software component.</p>&#13;
<p class="indent">If your web server talks to a database, make sure the account it uses to log into the database has limited permissions on the data. Most websites need to run only SQL statements that fall under the subset of SQL called the <em>data manipulation language (DML)</em>, which includes the <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, and <code>DELETE</code> statements we discussed earlier.</p>&#13;
<p class="indent">A subset of the SQL language called <em>data definition language (DDL)</em> uses <code>CREATE</code>, <code>DROP</code>, and <code>MODIFY</code> statements to create, drop, and modify the table structures in the database itself. Web servers generally don’t require permissions to execute DDL statements, so don’t grant them the DDL set of permissions at runtime! Narrowing the web server privileges to the minimal DML set reduces the harm an attacker can do if they discover a code vulnerability.</p>&#13;
<h5 class="h5" id="ch00lev1sec76"><strong>Blind and Nonblind SQL Injection</strong></h5>&#13;
<p class="noindent">Hackers distinguish between blind and nonblind SQL injection attacks. If your website’s error message leaks sensitive information to the client, like the message <code>Unique constraint violated: this email address already exists in users table</code>, this is a <em>nonblind</em> SQL attack. In this scenario, the attacker gets immediate feedback on their attempts to compromise your system.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_56"/>If you keep your error messages to the client more generic, like the messages <code>Could not find this username and password</code> or <code>An unexpected error occurred</code>, this is a <em>blind</em> SQL attack. This scenario means the attacker is effectively operating in the dark and has less to work with. Websites vulnerable to nonblind injection attacks are much easier to compromise, so avoid leaking information in error messages.</p>&#13;
<h3 class="h3" id="ch00lev1sec77"><strong>Command Injection</strong></h3>&#13;
<p class="noindent">Another type of injection attack is <em>command injection</em>, which attackers can use to exploit a website that makes insecure command line calls to the underlying operating system. If your web application makes command line calls, make sure to construct your command strings securely. Otherwise, attackers can craft HTTP requests that execute arbitrary operating system commands, and seize control of your application.</p>&#13;
<p class="indent">For many programming languages, constructing command strings to invoke operating systems is actually pretty unusual. Java, for example, runs in a virtual machine, so although you <em>could</em> call out to the operating system by using the <code>java.lang.Runtime</code> class, Java applications are generally designed to be portable between different operating systems, so relying on the availability of specific operating systems functions would go against its philosophy.</p>&#13;
<p class="indent">Command line calls are more common for interpreted languages. PHP is designed to follow the Unix philosophy—programs should do one thing and communicate with each other via text streams—so it’s common for PHP applications to call other programs via the command line. Similarly, Python and Ruby are popular for scripting tasks, so they make it easy to execute commands at the operating system level.</p>&#13;
<h4 class="h4" id="ch00lev1sec78"><strong><em>Anatomy of a Command Injection Attack</em></strong></h4>&#13;
<p class="noindent">If your website makes use of command line calls, make sure an attacker can’t trick the web server into injecting extra commands into the execution call. Imagine, for instance, that you have a simple website that does <code>nslookup</code> to resolve domains and IP addresses. The PHP code takes the domain or IP address from the HTTP request and constructs an operating system call as shown in <a href="ch06.xhtml#ch6list11">Listing 6-11</a>.</p>&#13;
<pre>&lt;?php<br/>    if (isset($_GET['domain'])) {<br/>        echo '&lt;pre&gt;';<br/>        $domain = $_GET['domain']<span class="ent">❶</span>;<br/>        $lookup = system("nslookup {$domain<span class="ent">❷</span>}");<br/>        echo($lookup);<br/>        echo '&lt;/pre&gt;';<br/>    }<br/>?&gt;</pre>&#13;
<p class="caption"><a id="ch6list11"/><em>Listing 6-11: PHP code receiving an HTTP request and constructing an operating system call</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_57"/>The <code>domain</code> parameter is extracted from the HTTP request at <span class="ent">❶</span>. Because the code does not escape the <code>domain</code> argument when constructing the command string <span class="ent">❷</span>, an attacker can craft a malicious URL and tag an extra command on the end, as shown in <a href="ch06.xhtml#ch6fig1">Figure 6-1</a>.</p>&#13;
<div class="image"><img src="Images/06fig01.jpg" alt="image" width="1388" height="949"/></div>&#13;
<p class="figcap"><a id="ch6fig1"/><em>Figure 6-1: Using the URL to inject a malicious command</em></p>&#13;
<p class="indent">Here the attacker sends a domain parameter with the value <code>google.com &amp;&amp; echo "HAXXED"</code>, and the browser URL-encodes the whitespace and nonalphanumeric characters. The <code>&amp;&amp;</code> syntax in Unix concatenates separate commands. Because our PHP code doesn’t strip such control characters, the attacker carefully constructs the HTTP request to append an extra command. Two separate commands will get executed in this scenario: the expected <code>nslookup</code> command that looks up <em>google.com</em>, followed by the <em>injected</em> command <code>echo "HAXXED"</code>.</p>&#13;
<p class="indent">In this case, the injected command is a harmless <code>echo</code> command, which simply prints out <code>"HAXXED"</code> in the HTTP response. However, an attacker can use this vulnerability to inject and execute any command they choose on your server. With a bit of effort, they can explore the filesystem, read sensitive information, and compromise the entire application. Command line access on a web server gives the attacker complete freedom to take control of the system unless you take deliberate steps to lessen the impact.</p>&#13;
<h4 class="h4" id="ch00lev1sec79"><strong><em>Mitigation: Escape Control Characters</em></strong></h4>&#13;
<p class="noindent">As with SQL injection, you can defend against command injection by properly escaping inputs from the HTTP request. This means replacing sensitive control characters (like the <code>&amp;</code> character in our example) with a <span epub:type="pagebreak" id="page_58"/>safe alternative. How you do this depends on the operating system and programing language you’re using. To make the PHP code in <a href="ch06.xhtml#ch6list11">Listing 6-11</a> more secure, we simply need to use a call to <code>escapeshellarg</code>, as shown in <a href="ch06.xhtml#ch6list12">Listing 6-12</a>.</p>&#13;
<pre>&lt;?php<br/>    if (isset($_GET['domain'])) {<br/>        echo '&lt;pre&gt;';<br/>        $domain = <span class="codestrong1">escapeshellarg</span><span class="ent">❶</span>($_GET['domain']);<br/>        $lookup = system("nslookup {$domain}");<br/>        echo($lookup);<br/>        echo '&lt;/pre&gt;';<br/>    }<br/>?&gt;</pre>&#13;
<p class="caption"><a id="ch6list12"/><em>Listing 6-12: PHP code escaping inputs from the HTTP request</em></p>&#13;
<p class="indent">The call to <code>escapeshellarg</code> <span class="ent">❶</span> ensures that attackers can’t inject extra commands via the <code>domain</code> parameter.</p>&#13;
<p class="indent">Python and Ruby can prevent potential command injection attacks too.</p>&#13;
<p class="indent">In Python, the <code>call()</code> function should be invoked with an array, rather than a string, to prevent attackers from tagging extra commands onto the end, as shown in <a href="ch06.xhtml#ch6list13">Listing 6-13</a>.</p>&#13;
<pre>    from subprocess import call<br/>    call(["nslookup", domain])</pre>&#13;
<p class="caption"><a id="ch6list13"/><em>Listing 6-13: The <span class="codeitalic">call</span> function in Python’s <span class="codeitalic">subprocess</span> module</em></p>&#13;
<p class="indent">In Ruby, the <code>system()</code> function makes a command line call. Supply it with an array of arguments, rather than a string, to ensure that attackers can’t sneak in extra commands, as shown in <a href="ch06.xhtml#ch6list14">Listing 6-14</a>.</p>&#13;
<pre>    system("nslookup", domain)</pre>&#13;
<p class="caption"><a id="ch6list14"/><em>Listing 6-14: The <span class="codeitalic">system()</span> function in Ruby</em></p>&#13;
<p class="indent">As with SQL injection, following the principle of least privilege also helps limit the impact of successful command injection attacks. Your web server process should run with only the permissions it requires. For instance, you should limit the directories the web server process can read from and write to. On Linux, you can use the <code>chroot</code> command to prevent the process from exploring outside a designated root directory. You should try to limit the network access your web server has, too, by configuring firewalls and access control lists on the network. These steps will make it much harder for a hacker to exploit a command injection vulnerability, because even if they can execute commands, they can’t do anything besides read files in the web server’s running directory.</p>&#13;
<h3 class="h3" id="ch00lev1sec80"><span epub:type="pagebreak" id="page_59"/><strong>Remote Code Execution</strong></h3>&#13;
<p class="noindent">So far, you’ve seen how vulnerabilities can creep in when web code constructs a call to databases, as with SQL injection, or to the operating system it’s running on, as with command injection. In other circumstances, attackers can inject malicious code to be executed in the language of the web server itself, a tactic called <em>remote code execution</em>. Remote code execution attacks on websites are rarer than the injection attacks we discussed earlier, but every bit as dangerous.</p>&#13;
<h4 class="h4" id="ch00lev1sec81"><strong><em>Anatomy of a Remote Code Execution Attack</em></strong></h4>&#13;
<p class="noindent">An attacker can achieve remote code execution by discovering a vulnerability in a particular type of web server, and then creating <em>exploit scripts</em> to target websites running on that web server technology. The exploit script incorporates malicious code in the body of the HTTP request, encoded in such a way that the server will read and execute that code when the request is handled. The techniques used to perform remote execution attacks vary significantly. Security researchers will analyze codebases for common web servers, looking for vulnerabilities that permit malicious code to be injected.</p>&#13;
<p class="indent">In early 2013, researchers discovered a vulnerability in Ruby on Rails that permitted attackers to inject their own Ruby code into the server process. Because the Rails framework automatically parses requests according to their <code>Content-Type</code> header, security researchers noticed that if they created an XML request with an embedded YAML object (a markup language commonly used in the Rails community for storing configuration data), they could trick the parsing process into executing arbitrary code.</p>&#13;
<h4 class="h4" id="ch00lev1sec82"><strong><em>Mitigation: Disable Code Execution During Deserialization</em></strong></h4>&#13;
<p class="noindent">Remote code execution vulnerabilities usually occur when web server software uses insecure serialization. <em>Serialization</em> is the process of converting an in-memory data structure into a stream of binary data, usually for the purpose of passing the data structure across a network. <em>Deserialization</em> refers to the reverse process that occurs at the other end, when the binary data is converted back into a data structure.</p>&#13;
<p class="indent">Serialization libraries exist in every major programming language and are widely used. Some serialization libraries, such as the YAML parser used by Rails, allow data structures to execute code as they reinitialize themselves in memory. This is a useful feature if you trust the source of the serialized data, but can be <em>very</em> dangerous if you don’t, because it can permit arbitrary code execution.</p>&#13;
<p class="indent">If a web server uses deserialization to handle data coming in from HTTP requests, it needs to defuse any serialization libraries it uses by disabling any code-execution capabilities; otherwise, an attacker may be able to find a way to inject code directly into the web server process. We can typically disable code execution via a relevant configuration setting that will allow your web server software to deserialize data without executing code.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_60"/>As a developer who uses a web server to build sites, rather than one who writes the web server code itself, protecting against remote code execution in your web stack usually amounts to staying aware of security advisories. You’re unlikely to be writing your own serialization libraries, so be aware of where your codebase uses third-party serialization libraries. Make sure to turn off active code execution features in your own code, and keep an eye out for vulnerability announcements issued by your web server vendor.</p>&#13;
<h3 class="h3" id="ch00lev1sec83"><strong>File Upload Vulnerabilities</strong></h3>&#13;
<p class="noindent">The final type of injection attack we’ll look at in this chapter takes advantage of vulnerabilities in file upload functions. Websites use <em>file upload functions</em> for a variety of purposes: letting users add images to their profile or posts, adding attachments to messages, submitting paperwork, sharing documents with other users, and so on. Browsers make it easy to upload files via built-in file-upload widgets and JavaScript APIs that allow you to drag files onto a web page and send them asynchronously to the server.</p>&#13;
<p class="indent">However, browsers aren’t exactly careful about checking the contents of a file. Attackers can easily abuse file upload functions by injecting malicious code into an uploaded file. Web servers typically treat uploaded files like large blobs of binary data, so it’s pretty easy for an attacker to upload a malicious payload without the web server detecting it. Even if your site has JavaScript code that checks a file’s content before uploading it, an attacker can write scripts to post file data to the server-side endpoint directly, circumventing any security measures you put in place on the client side.</p>&#13;
<p class="indent">Let’s see how attackers typically exploit file upload functions so that we identify the various security weaknesses that we need to plug.</p>&#13;
<h4 class="h4" id="ch00lev1sec84"><strong><em>Anatomy of a File Upload Attack</em></strong></h4>&#13;
<p class="noindent">As an example of a file upload vulnerability, let’s look at how an attacker could potentially abuse the profile image upload function of your site. The attacker first writes a small <em>web shell</em>, a simple executable script that will take an argument from an HTTP request, execute it on the command line, and output the result. Web shells are a common tool used by hackers attempting to compromise a web server. <a href="ch06.xhtml#ch6list15">Listing 6-15</a> shows an example of a web shell written in PHP.</p>&#13;
<pre>&lt;?php<br/>  if(isset($_REQUEST['cmd'])) {<br/>    $cmd = ($_REQUEST['cmd']);<br/>    system($cmd);<br/>  } else {<br/>    echo "What is your bidding?";<br/>  }<br/>?&gt;</pre>&#13;
<p class="caption"><a id="ch6list15"/><em>Listing 6-15: A web shell written in the PHP language</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_61"/>The attacker saves this script as <em>hack.php</em> on their computer and uploads it as their profile “image” on your site. PHP files are typically treated by operating systems as <em>executable</em> files, which is key to making this attack work. Clearly a file ending with <em>.php</em> isn’t a valid image file, but the attacker can fairly easily disable any JavaScript file-type checking done during the upload process.</p>&#13;
<p class="indent">Once the attacker has uploaded their “image” file, their website profile page will show a missing image icon, because their profile image is corrupted and not actually an image. However, at this point they have achieved their real aim: smuggling the web shell file onto your server, which means their malicious code is now deployed to your site, waiting to be executed in some fashion.</p>&#13;
<p class="indent">Because the web shell is available on a public URL, the attacker has potentially created a backdoor for executing the malicious code. If your server’s operating system has a PHP runtime installed, and the file was written to disk with executable privileges during the upload process, the attacker can pass commands to run the web shell simply by invoking the URL that corresponds to their profile image.</p>&#13;
<p class="indent">To perform a command injection attack, the hacker can pass a <code>cmd</code> argument to the web shell to execute arbitrary operating system commands on your server, as shown in <a href="ch06.xhtml#ch6fig2">Figure 6-2</a>.</p>&#13;
<div class="image"><img src="Images/06fig02.jpg" alt="image" width="1049" height="521"/></div>&#13;
<p class="figcap"><a id="ch6fig2"/><em>Figure 6-2: If your file upload function is vulnerable, a hacker could use a web shell to access your database credentials.</em></p>&#13;
<p class="indent">In this scenario, the attacker can explore your filesystem. The attacker has taken advantage of your file upload function to gain the same access to your operating system as they would with a command injection attack.</p>&#13;
<h4 class="h4" id="ch00lev1sec85"><strong><em>Mitigations</em></strong></h4>&#13;
<p class="noindent">You can use several mitigations to protect yourself against vulnerabilities in file upload code. The most important mitigations ensure that any uploaded files can’t be executed as code. Following the principle of defense in depth, you should also analyze uploaded files and reject any that appear to be corrupt or malicious.</p>&#13;
<h5 class="h5" id="ch00lev1sec86"><span epub:type="pagebreak" id="page_62"/><strong>Mitigation 1: Host Files on a Secure System</strong></h5>&#13;
<p class="noindent">The first, most important approach to securing file upload functions is to ensure that your web server treats uploaded files as inert rather than executable objects. You can do this by hosting your uploaded files in a content delivery network (CDN) such as Cloudflare or Akamai, as described in <a href="ch04.xhtml#ch04">Chapter 4</a>, which offloads the security burden to a third party who stores your files securely.</p>&#13;
<p class="indent">CDNs have other nonsecurity-related benefits too. CDNs serve files extremely fast to the browser, and can put them through processing pipelines as you upload them. Many CDNs offer sophisticated JavaScript upload widgets that you can add with a few lines of code, and that provide bonus features like image cropping.</p>&#13;
<p class="indent">If for some reason a CDN isn’t an option, you can get many of the same benefits by storing uploaded files in cloud-based storage (for example, Amazon Simple Storage Service, or S3) or a dedicated content management system. Both approaches provide secure storage that defuses all web shells as they’re uploaded. (Although, if you’re hosting your own content management system, you’ll have to make sure to configure it correctly.)</p>&#13;
<h5 class="h5" id="ch00lev1sec87"><strong>Mitigation 2: Ensure Uploaded Files Cannot Be Executed</strong></h5>&#13;
<p class="noindent">If using a CDN or content management system isn’t an option, you need to take the same steps to secure your files that a CDN or content management does behind the scenes. This means ensuring that all files are written to disk without executable permissions, separating uploaded files into a particular directory or partition (so they aren’t intermingled with code), and <em>hardening</em> your servers so that only the minimally required software is installed. (Uninstall the PHP engine if you aren’t using it!) It’s a good idea to rename files as you upload them too, so you don’t write files with dangerous file extensions to disk.</p>&#13;
<p class="indent">The ways to achieve these ends vary depending on your hosting technology, operating system, and the programming language you use. If you’re running a Python web server on Linux, for instance, you can set file permissions when creating a file by using the <code>os</code> module, as shown in <a href="ch06.xhtml#ch6list16">Listing 6-16</a>.</p>&#13;
<pre>import os<br/>file_descriptor = os.open("/path/to/file", os.O_WRONLY | os.O_CREAT, 0o600)<br/>with os.fdopen(open(file_descriptor, "wb")) as file_handle:<br/>  file_handle.write(...)</pre>&#13;
<p class="caption"><a id="ch6list16"/><em>Listing 6-16: Writing a file with read-write (but not execute) permissions in Python on Linux</em></p>&#13;
<p class="indent">Removing unneeded software from your operating system is always a good idea, because it gives a hacker fewer tools to play with. The Center for Internet Security (CIS) provides prehardened operating system images that make a good starting point. They’re available as Docker images or as Amazon Machine Images (AMIs) in the Amazon Web Services Marketplace.</p>&#13;
<h5 class="h5" id="ch00lev1sec88"><span epub:type="pagebreak" id="page_63"/><strong>Mitigation 3: Validate the Content of Uploaded Files</strong></h5>&#13;
<p class="noindent">If you’re uploading files with a known file type, consider adding some file-type checking in your code. Make sure the <code>Content-Type</code> header in the HTTP request of the upload matches the expected file type, but be aware that an attacker can easily spoof the header.</p>&#13;
<p class="indent">It’s possible to validate the file type after the file has been uploaded, particularly with image files, so it’s a good idea to implement this feature in your server-side code, as shown in <a href="ch06.xhtml#ch6list17">Listing 6-17</a>. Your mileage should vary, though; clever hackers in the past have infiltrated various systems by designing payloads that are valid for more than one type of file format.</p>&#13;
<pre>&gt;&gt;&gt; import imghdr<br/>&gt;&gt;&gt; imghdr.what('/tmp/what_is_this.dat')<br/>'gif'</pre>&#13;
<p class="caption"><a id="ch6list17"/><em>Listing 6-17: Reading the file headers to validate a file format in Python</em></p>&#13;
<h5 class="h5" id="ch00lev1sec89"><strong>Mitigation 4: Run Antivirus Software</strong></h5>&#13;
<p class="noindent">Finally, if you’re running on a server platform that’s prone to viruses (hello, Microsoft Windows!) make sure you’re running up-to-date antivirus software. File upload functions are an open door to virus payloads.</p>&#13;
<h3 class="h3" id="ch00lev1sec90"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, you learned about various injection attacks, whereby an attacker crafts malicious HTTP requests to take control of backend systems.</p>&#13;
<p class="indent">SQL injection attacks take advantage of web code that doesn’t securely construct SQL strings when communicating with a SQL database. You can mitigate SQL injection by using bind parameters when communicating with the database driver.</p>&#13;
<p class="indent">Command injection attacks take advantage of code that makes insecure calls to operating system functions. You can similarly defuse command injection through correct use of binding.</p>&#13;
<p class="indent">Remote code execution vulnerabilities allow hackers to run exploits inside the web server process itself, and typically stem from insecure serialization libraries. Make sure to stay on top of any security advisories for the serialization libraries you use, and for your web server software.</p>&#13;
<p class="indent">File upload functions often enable command injection attacks if your file upload functionality writes uploaded files to disk with executable privileges. Make sure to write uploads to a third-party system or to disk with appropriate permissions, and do whatever you can to validate the file type as you upload them.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_64"/>You can mitigate the risks around all types of injection attacks by following the principle of least privilege: processes and software components should run with only the permissions they require to perform their assigned tasks, and no more. This approach reduces the harm an attack can do if they inject harmful code. Examples of following the principle of least privilege include limiting file and network access for your web server process, and connecting to your database under an account with limited permissions.</p>&#13;
<p class="indent">In the next chapter, you’ll look at how hackers can use JavaScript vulnerabilities to attack your website.</p>&#13;
</div>



  </body></html>