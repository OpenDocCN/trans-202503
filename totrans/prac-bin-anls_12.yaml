- en: '9'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '9'
- en: BINARY INSTRUMENTATION
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制插桩
- en: In [Chapter 7](ch07.xhtml#ch07), you learned several techniques for modifying
    and augmenting binary programs. While relatively simple to use, those techniques
    are limited in the amount of new code you can insert into the binary and where
    you can insert it. In this chapter, you’ll learn about a technique called *binary
    instrumentation* that allows you to insert a practically unlimited amount of code
    at any location in a binary to observe or modify that binary’s behavior.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第七章](ch07.xhtml#ch07)中，你学习了几种修改和增强二进制程序的技术。尽管这些技术相对容易使用，但它们在能够向二进制中插入多少新代码以及能插入到何处方面有所限制。在本章中，你将学习一种叫做*二进制插桩*的技术，它允许你在二进制中的任何位置插入几乎无限量的代码，以观察或修改该二进制的行为。
- en: After a brief overview of binary instrumentation, I’ll discuss how to implement
    *static binary instrumentation (SBI)* and *dynamic binary instrumentation (DBI)*,
    two types of binary instrumentation with different trade-offs. Finally, you’ll
    learn how to build your own binary instrumentation tools with Pin, a popular DBI
    system made by Intel.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要介绍二进制插桩之后，我将讨论如何实现*静态二进制插桩（SBI）*和*动态二进制插桩（DBI）*，这两种二进制插桩方式具有不同的权衡。最后，你将学习如何使用
    Intel 提供的流行 DBI 系统 Pin，构建自己的二进制插桩工具。
- en: 9.1 What Is Binary Instrumentation?
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1 什么是二进制插桩？
- en: Inserting new code at any point in an existing binary to observe or modify the
    binary’s behavior in some way is called *instrumenting* the binary. The point
    where you add new code is called the *instrumentation point*, and the added code
    is called *instrumentation code*.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有二进制文件的任何位置插入新代码，以观察或修改该二进制行为的方式，称为*插桩*二进制。你添加新代码的位置称为*插桩点*，而添加的代码则称为*插桩代码*。
- en: For example, let’s say you want to know which functions in a binary are called
    most often so that you can focus on optimizing those functions. To find this out,
    you can instrument all `call` instructions in the binary,^([1](footnote.xhtml#ch09fn_1))
    adding instrumentation code that records the target of the call so that the instrumented
    binary produces a list of called functions when you execute it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想知道一个二进制文件中哪些函数被调用得最频繁，以便集中精力优化这些函数。要找出这个信息，你可以在二进制文件中对所有`call`指令进行插桩，^([1](footnote.xhtml#ch09fn_1))
    添加记录调用目标的插桩代码，使得当你执行插桩后的二进制文件时，它能够生成被调用函数的列表。
- en: Although this example only observes the binary’s behavior, you can also modify
    it. For instance, you can improve a binary’s security against control-flow-hijacking
    attacks by instrumenting all indirect control transfers (such as `call rax` and
    `ret`) with code that checks whether the control-flow target is in a set of expected
    targets. If not, you abort the execution and raise an alert.^([2](footnote.xhtml#ch09fn_2))
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子只是观察二进制的行为，你也可以对其进行修改。例如，你可以通过对所有间接控制流转移（如`call rax`和`ret`）进行插桩，添加代码检查控制流目标是否在一组预期目标中，从而提高二进制的安全性，防止控制流劫持攻击。如果目标不在预期范围内，你就中止执行并触发警报。^([2](footnote.xhtml#ch09fn_2))
- en: '*9.1.1 Binary Instrumentation APIs*'
  id: totrans-8
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.1.1 二进制插桩 API*'
- en: Generic binary instrumentation that allows you to add new code at every point
    in a binary is far more difficult to implement correctly than the simple binary
    modification techniques you saw in [Chapter 7](ch07.xhtml#ch07). Recall that you
    cannot simply insert new code into an existing binary code section because the
    new code will shift existing code to different addresses, thereby breaking references
    to that code. It’s practically impossible to locate and patch all existing references
    after moving code around, because binaries don’t contain any information that
    tells you where these references are and there’s no way to reliably distinguish
    referenced addresses from constants that *look* like addresses but aren’t.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通用的二进制插桩技术，允许你在二进制的每个位置添加新代码，远比你在[第七章](ch07.xhtml#ch07)中看到的简单二进制修改技术更难正确实现。回想一下，你不能简单地将新代码插入到现有的二进制代码段中，因为新代码会将现有代码移动到不同的地址，从而破坏对这些代码的引用。移动代码之后，几乎不可能找到并修补所有现有的引用，因为二进制文件中没有任何信息告诉你这些引用的位置，也没有可靠的方法来区分引用地址和看起来像地址但实际上不是地址的常量。
- en: Fortunately, there are generic binary instrumentation platforms you can use
    to handle all of the implementation complexities for you, and they offer relatively
    easy-to-use APIs with which you can implement binary instrumentation tools. These
    APIs typically allow you to install callbacks to instrumentation code at instrumentation
    points of your choice.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一些通用的二进制插装平台可以帮助你处理所有实现的复杂性，并提供相对易于使用的 API，你可以用它们实现二进制插装工具。这些 API 通常允许你在选择的插装点安装回调到插装代码中。
- en: Later in this chapter, you’ll see two practical examples of binary instrumentation
    using Pin, a popular binary instrumentation platform. You’ll use Pin to implement
    a profiler that records statistics about a binary’s execution to aid optimization.
    You’ll also use Pin to implement an automatic unpacker that helps you deobfuscate
    *packed binaries*.^([3](footnote.xhtml#ch09fn_3))
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，你将看到两个使用 Pin 平台的二进制插装的实际示例。Pin 是一个流行的二进制插装平台，你将使用它实现一个分析器，记录二进制文件执行过程中的统计数据以帮助优化。你还将使用
    Pin 实现一个自动解压程序，帮助你去混淆 *打包的二进制文件*。^([3](footnote.xhtml#ch09fn_3))
- en: 'You can distinguish two classes of binary instrumentation platforms: static
    and dynamic. Let’s first discuss the differences between these two classes and
    then explore how they work at a low level.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以区分两类二进制插装平台：静态和动态。我们首先讨论这两类的区别，然后再探讨它们在底层的工作原理。
- en: '*9.1.2 Static vs. Dynamic Binary Instrumentation*'
  id: totrans-13
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.1.2 静态与动态二进制插装*'
- en: Static and dynamic binary instrumentation solve the difficulties with inserting
    and relocating code using different approaches. SBI uses *binary rewriting* techniques
    to permanently modify binaries on disk. You’ll learn about the various binary
    rewriting approaches that SBI platforms use in [Section 9.2](ch09.xhtml#ch09_2).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 静态和动态二进制插装通过不同的方法解决了插入和重定位代码的难题。SBI 使用 *二进制重写* 技术永久修改磁盘上的二进制文件。你将在 [第9.2节](ch09.xhtml#ch09_2)
    学到 SBI 平台使用的各种二进制重写方法。
- en: On the other hand, DBI doesn’t modify binaries on disk at all but instead monitors
    binaries as they execute and inserts new instructions into the instruction stream
    on the fly. The advantage of this approach is that it avoids code relocation issues.
    The instrumentation code is injected only into the instruction stream, not into
    the binary’s code section in memory, so it doesn’t break references. However,
    the trade-off is that DBI’s runtime instrumentation is more computationally expensive,
    causing larger slowdowns in the instrumented binary than SBI.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，DBI 完全不修改磁盘上的二进制文件，而是在执行过程中监控二进制文件，并动态插入新的指令流。此方法的优势在于避免了代码重定位问题。插装代码仅被注入到指令流中，而不是内存中二进制代码段中，因此不会破坏引用。然而，权衡是
    DBI 的运行时插装更为计算密集，导致插装后的二进制文件比 SBI 慢得多。
- en: '[Table 9-1](ch09.xhtml#ch09tab1) summarizes the main advantages and disadvantages
    of SBI and DBI, showing advantages with a + symbol and disadvantages with a –
    symbol.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 9-1](ch09.xhtml#ch09tab1)总结了SBI和DBI的主要优缺点，优点用 + 符号表示，缺点用 - 符号表示。'
- en: '**Table 9-1:** Trade-offs of Dynamic and Static Binary Instrumentation'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 9-1：** 动态与静态二进制插装的权衡'
- en: '| **Dynamic instrumentation** | **Static instrumentation** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **动态插装** | **静态插装** |'
- en: '| --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| – Relatively slow (4 times or more) | + Relatively fast (10% to 2 times)
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| – 相对较慢（4 倍或更多） | + 相对较快（10% 到 2 倍） |'
- en: '| --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| – Depends on DBI library and tool | + Stand-alone binary |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| – 依赖于 DBI 库和工具 | + 独立的二进制文件 |'
- en: '| --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| + Transparently instruments libraries | – Must explicitly instrument libraries
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| + 透明地插装库 | – 必须显式插装库 |'
- en: '| --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| + Handles dynamically generated code | – Dynamically generated code unsupported
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| + 处理动态生成的代码 | – 不支持动态生成的代码 |'
- en: '| --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| + Can dynamically attach/detach | – Instruments entire execution |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| + 可以动态附加/分离 | – 插装整个执行过程 |'
- en: '| --- | --- |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| + No need for disassembly | – Prone to disassembly errors |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| + 无需反汇编 | – 易出错的反汇编 |'
- en: '| --- | --- |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| + Transparent, no need to modify binary | – Error-prone binary rewriting
    |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| + 透明，不需要修改二进制文件 | – 易出错的二进制重写 |'
- en: '| --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| + No symbols needed | – Symbols preferable to minimize errors |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| + 无需符号 | – 为了最小化错误，最好有符号 |'
- en: '| --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: 'As you can see, DBI’s need for runtime analysis and instrumentation induces
    slowdowns of four times or more, while SBI only induces a slowdown of 10 percent
    to two times. Note that these are ballpark numbers, and the actual slowdown can
    vary significantly depending on your instrumentation needs and the implementation
    quality of your tool. Moreover, binaries instrumented with DBI are more difficult
    to distribute: you have to ship not only the binary itself but also the DBI platform
    and tool that contain the instrumentation code. On the other hand, binaries instrumented
    with SBI are stand-alone, and you can distribute them normally once the instrumentation
    is done.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，DBI对运行时分析和插桩的需求导致了四倍或更多的性能下降，而SBI只会导致10%到两倍的性能下降。请注意，这些只是大致数字，实际的性能下降可能会根据你的插桩需求和工具的实现质量有所不同。此外，使用DBI插桩的二进制文件更难分发：你不仅需要分发二进制文件本身，还需要分发包含插桩代码的DBI平台和工具。另一方面，使用SBI插桩的二进制文件是独立的，插桩完成后，你可以正常分发它们。
- en: A major advantage of DBI is that it’s much easier to use than SBI. Because DBI
    uses runtime instrumentation, it automatically accounts for all executed instructions,
    whether those are part of the original binary or of libraries used by the binary.
    In contrast, with SBI you have to explicitly instrument and distribute all libraries
    that the binary uses, unless you’re willing to leave those libraries uninstrumented.
    The fact that DBI operates on the executed instruction stream also means that
    it supports dynamically generated code that SBI cannot support, such as JIT-compiled
    code or self-modifying code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: DBI的一个主要优点是，它比SBI更易于使用。因为DBI使用运行时插桩，它自动考虑所有执行的指令，无论这些指令是原始二进制文件的一部分还是二进制文件使用的库的一部分。相比之下，使用SBI时，你必须显式地插桩并分发二进制文件使用的所有库，除非你愿意让这些库不进行插桩。DBI在执行的指令流上操作，这意味着它支持SBI无法支持的动态生成代码，如JIT编译代码或自修改代码。
- en: Additionally, DBI platforms can typically attach to and detach from processes
    dynamically, just like debuggers can. That’s convenient if you want to observe
    part of the execution of a long-running process, for example. With DBI, you can
    simply attach to that process, gather the information you want, and then detach,
    leaving the process running normally again. With SBI, this is not possible; you
    either instrument the entire execution or don’t instrument at all.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，DBI平台通常可以像调试器一样动态地附加到和分离进程。这在你想观察长时间运行的进程的部分执行时非常方便。例如，使用DBI，你可以简单地附加到该进程，收集你需要的信息，然后分离，使进程恢复正常运行。而SBI则做不到这一点；你要么插桩整个执行过程，要么根本不插桩。
- en: Finally, DBI is far less error-prone than SBI. SBI instruments binaries by disassembling
    them and then making any needed changes. That means disassembly errors can easily
    cause errors in the instrumentation, potentially causing incorrect results or
    even breaking the binary. DBI doesn’t have this problem because it doesn’t require
    disassembly; it simply observes instructions as they’re being executed, so it’s
    guaranteed to see the correct instruction stream.^([4](footnote.xhtml#ch09fn_4))
    To minimize the possibility of disassembly errors, many SBI platforms require
    symbols, while DBI has no such requirement.^([5](footnote.xhtml#ch09fn_5))
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，DBI比SBI更不容易出错。SBI通过反汇编二进制文件并进行必要的修改来插桩。这意味着反汇编错误很容易导致插桩错误，可能会导致不正确的结果，甚至使二进制文件崩溃。而DBI没有这个问题，因为它不需要反汇编；它只是在指令执行时观察指令，因此可以确保看到正确的指令流。^([4](footnote.xhtml#ch09fn_4))
    为了最小化反汇编错误的可能性，许多SBI平台需要符号，而DBI则没有此要求。^([5](footnote.xhtml#ch09fn_5))
- en: As I mentioned earlier, there are various ways to implement SBI’s binary rewriting
    and DBI’s runtime instrumentation. In the next two sections, let’s look at the
    most popular ways to implement SBI and DBI, respectively.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前提到的，实现SBI的二进制重写和DBI的运行时插桩有多种方式。在接下来的两个部分中，我们将分别看看实现SBI和DBI的最流行方式。
- en: 9.2 Static Binary Instrumentation
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2 静态二进制插桩
- en: Static binary instrumentation works by disassembling a binary and then adding
    instrumentation code where needed and storing the updated binary permanently on
    disk. Well-known SBI platforms include PEBIL^([6](footnote.xhtml#ch09fn_6)) and
    Dyninst^([7](footnote.xhtml#ch09fn_7)) (which supports both DBI and SBI). PEBIL
    requires symbols while Dyninst does not. Note that both PEBIL and Dyninst are
    research tools, so they’re not as well documented as a production-quality tool.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 静态二进制插装（SBI）通过反汇编二进制文件，然后在需要的地方添加插装代码，并将更新后的二进制文件永久存储在磁盘上。著名的SBI平台包括PEBIL^([6](footnote.xhtml#ch09fn_6))和Dyninst^([7](footnote.xhtml#ch09fn_7))（它同时支持DBI和SBI）。PEBIL需要符号，而Dyninst则不需要。请注意，PEBIL和Dyninst都是研究工具，因此它们的文档不如生产级工具那么完备。
- en: The main challenge in implementing SBI is finding a way to add the instrumentation
    code and rewrite the binary without breaking any existing code or data references.
    Let’s consider two popular solutions to this challenge, which I call the *int
    3 approach* and the *trampoline approach*. Note that, in practice, SBI engines
    may incorporate elements from both these techniques or use another technique entirely.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 实现SBI的主要挑战是找到一种方法来添加插装代码并重写二进制文件，同时不破坏任何现有的代码或数据引用。让我们考虑两种常见的解决方案，我称之为*int 3方法*和*跳板方法*。请注意，在实际应用中，SBI引擎可能结合这两种技术的元素，或者采用完全不同的技术。
- en: '*9.2.1 The int 3 Approach*'
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.2.1 int 3 方法*'
- en: The *int 3 approach* gets its name from the x86 `int 3` instruction, which debuggers
    use to implement software breakpoints. To illustrate the need for `int 3`, let’s
    first consider an SBI approach that does *not* work in the general case.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*int 3方法*得名于x86的`int 3`指令，调试器使用它来实现软件断点。为了说明`int 3`的必要性，我们首先考虑一种在一般情况下*不*有效的SBI方法。'
- en: A Naive SBI Implementation
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个简单的SBI实现
- en: Given the practical impossibility of fixing all references to relocated code,
    it’s clear that SBI cannot store the instrumentation code inline in an existing
    code section. Because there’s no room for arbitrary amounts of new code in the
    existing code sections, it follows that SBI approaches must store instrumentation
    code in a separate location, such as a new section or a shared library, and then
    somehow transfer control to the instrumentation code when execution reaches an
    instrumentation point. To achieve this, you might come up with the solution shown
    in [Figure 9-1](ch09.xhtml#ch09fig1).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于修复所有指向已重新定位代码的引用在实际中几乎不可能，显然SBI不能将插装代码内联到现有的代码段中。由于现有代码段中没有足够的空间来添加任意数量的新代码，因此SBI方法必须将插装代码存储在一个独立的位置，比如一个新的代码段或共享库中，然后在执行到插装点时，某种方式将控制转移到插装代码。为了实现这一点，你可能会想到[图9-1](ch09.xhtml#ch09fig1)中所示的解决方案。
- en: '![image](Images/f227-01.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f227-01.jpg)'
- en: '*Figure 9-1: A nongeneric SBI approach that uses* `jmp` *to hook instrumentation
    points*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-1：一种非通用的SBI方法，它使用* `jmp` *来挂钩插装点*'
- en: The leftmost column of [Figure 9-1](ch09.xhtml#ch09fig1) shows a chunk of original,
    uninstrumented code. Let’s say you want to instrument the instruction `mov edx,0x1`
    ➊, adding instrumentation code to run before and after that instruction. To get
    around the problem that there’s no room to add the new code inline, you overwrite
    `mov edx,0x1` with a `jmp` to your instrumentation code ➋, stored in a separate
    code section or library. The instrumentation code first runs any *pre-instrumentation*
    code that you added ➌, which is code that runs before the original instruction.
    Next, it runs the original `mov edx,0x1` instruction ➍ and then the *post-instrumentation*
    code ➎. Finally, the instrumentation code jumps back to the instruction following
    the instrumentation point ➏, resuming normal execution.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-1](ch09.xhtml#ch09fig1)的最左列展示了一块原始的、未插装的代码。假设你想在指令`mov edx,0x1` ➊前后添加插装代码。为了绕过无法在原地添加新代码的问题，你可以将`mov
    edx,0x1`替换为一个跳转指令`jmp`，该跳转指令指向你存储在独立代码段或库中的插装代码 ➋。插装代码首先运行你添加的*前置插装*代码 ➌，也就是在原始指令之前执行的代码。接着，它运行原始的`mov
    edx,0x1`指令 ➍，然后执行*后置插装*代码 ➎。最后，插装代码跳转回插装点后面的指令 ➏，恢复正常执行。'
- en: Note that if the pre-instrumentation or post-instrumentation code changes register
    contents, that may inadvertently affect other parts of the program. That’s why
    SBI platforms store the register state before running this added code and restore
    the state afterward, unless you explicitly tell the SBI platform that you *want*
    to change the register state.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果预先或后置的代码更改了寄存器内容，这可能会无意中影响程序的其他部分。因此，SBI 平台在运行这些新增代码之前会保存寄存器的状态，并在之后恢复状态，除非你明确告诉
    SBI 平台你*想要*更改寄存器状态。
- en: As you can see, the approach in [Figure 9-1](ch09.xhtml#ch09fig1) is a simple
    and elegant way to run arbitrary amounts of code of your choice before or after
    any instruction. So what’s the problem with this approach? The issue is that `jmp`
    instructions take up multiple bytes; to jump to instrumentation code, you typically
    need a 5-byte `jmp` instruction that consists of 1 opcode byte with a 32-bit offset.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，[图 9-1](ch09.xhtml#ch09fig1) 中的方法是一种简单而优雅的方式，可以在任意指令之前或之后运行你选择的任意量的代码。那么这个方法有什么问题呢？问题在于，`jmp`
    指令占用多个字节；要跳转到仪器化代码，你通常需要一个 5 字节的 `jmp` 指令，其中包括 1 个操作码字节和一个 32 位的偏移量。
- en: When you instrument a short instruction, the `jmp` to your instrumentation code
    may be longer than the instruction it replaces. For example, the `xor esi,esi`
    instruction at the top left of [Figure 9-1](ch09.xhtml#ch09fig1) is only 2 bytes
    long, so if you replace that with a 5-byte `jmp`, the `jmp` will overwrite and
    corrupt part of the next instruction. You can’t solve this issue by making that
    next overwritten instruction part of the instrumentation code because the instruction
    may be a branch target. Any branches targeting that instruction would end up in
    the middle of the `jmp` you inserted, breaking the binary.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对一条短指令进行仪器化时，跳转到仪器化代码的 `jmp` 可能比它所替代的指令要长。例如，[图 9-1](ch09.xhtml#ch09fig1)
    左上角的 `xor esi,esi` 指令只有 2 个字节长，因此，如果你用 5 字节的 `jmp` 替换它，`jmp` 会覆盖并破坏下一条指令的一部分。你无法通过将被覆盖的下一条指令作为仪器化代码的一部分来解决这个问题，因为该指令可能是一个分支目标。任何指向该指令的分支都将落入你插入的
    `jmp` 的中间，破坏二进制文件。
- en: This brings us back to the `int 3` instruction. You can use the `int 3` instruction
    to instrument short instructions where multibyte jumps don’t fit, as you’ll see
    next.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这又将我们带回到 `int 3` 指令。你可以使用 `int 3` 指令来仪器化那些无法适配多字节跳转的短指令，正如接下来所看到的那样。
- en: Solving the Multibyte Jump Problem with int 3
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `int 3` 解决多字节跳转问题
- en: The x86 `int 3` instruction generates a software interrupt that user-space programs
    like SBI libraries or debuggers can catch (on Linux) in the form of a `SIGTRAP`
    signal delivered by the operating system. The key detail about `int 3` is that
    it’s only 1 byte long, so you can overwrite any instruction with it without fear
    of overwriting a neighboring instruction. The opcode for `int 3` is `0xcc`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: x86 的 `int 3` 指令生成一个软件中断，用户空间程序（如 SBI 库或调试器）可以捕获该中断（在 Linux 上以 `SIGTRAP` 信号的形式由操作系统传递）。关于
    `int 3` 的关键细节是，它只有 1 个字节长，因此你可以用它覆盖任何指令，而无需担心覆盖相邻的指令。`int 3` 的操作码是 `0xcc`。
- en: From an SBI viewpoint, to instrument an instruction using `int3`, you simply
    overwrite the first byte of that instruction with `0xcc`. When a `SIGTRAP` happens,
    you can use Linux’s `ptrace` API to find out at which address the interrupt occurred,
    telling you the instrumentation point address. You can then invoke the appropriate
    instrumentation code for that instrumentation point, just as you saw in [Figure
    9-1](ch09.xhtml#ch09fig1).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SBI 的角度来看，要使用 `int 3` 来仪器化一条指令，你只需将该指令的第一个字节覆盖为 `0xcc`。当发生 `SIGTRAP` 时，你可以使用
    Linux 的 `ptrace` API 来查找中断发生的地址，从而告诉你仪器化点的地址。然后，你可以调用该仪器化点的适当仪器化代码，正如你在 [图 9-1](ch09.xhtml#ch09fig1)
    中看到的那样。
- en: From a purely functional standpoint, `int 3` is an ideal way to implement SBI
    because it’s easy to use and doesn’t require any code relocation. Unfortunately,
    software interrupts like `int 3` are slow, causing excessive overhead in the instrumented
    application. Moreover, the *int 3 approach* is incompatible with programs that
    are already being debugged using `int 3` for breakpoints. That’s why in practice
    many SBI platforms use more complicated but faster rewriting methods, such as
    the trampoline approach.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从纯粹的功能角度来看，`int 3` 是实现 SBI 的理想方式，因为它易于使用且不需要任何代码重定位。不幸的是，像 `int 3` 这样的软件中断较慢，会导致仪器化应用程序产生过多的开销。此外，*int
    3 方法*与已经使用 `int 3` 作为断点的程序不兼容。因此，在实际应用中，许多 SBI 平台使用更复杂但更快速的重写方法，如跳板方法。
- en: '*9.2.2 The Trampoline Approach*'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.2.2 跳板方法*'
- en: Unlike the `int 3` approach, the trampoline approach makes no attempt to instrument
    the original code directly. Instead, it creates a copy of all the original code
    and instruments only this copied code. The idea is that this won’t break any code
    or data references because these all still point to the original, unchanged locations.
    To ensure that the binary runs the instrumented code instead of the original code,
    the trampoline approach uses `jmp` instructions called *trampolines* to redirect
    the original code to the instrumented copy. Whenever a call or jump transfers
    control to a part of the original code, the trampoline at that location immediately
    jumps to the corresponding instrumented code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 与`int 3`方法不同，跳板方法不会直接尝试对原始代码进行插装。相反，它创建了原始代码的副本，仅对这个副本进行插装。其理念是，这样做不会破坏任何代码或数据引用，因为这些引用仍然指向原始、未更改的位置。为了确保二进制文件运行插装后的代码而不是原始代码，跳板方法使用`jmp`指令，称为*跳板*，将原始代码重定向到插装后的副本。每当调用或跳转将控制权转移到原始代码的某个部分时，那个位置的跳板会立即跳转到对应的插装代码。
- en: To clarify the trampoline approach, consider the example shown in [Figure 9-2](ch09.xhtml#ch09fig2).
    The figure shows an uninstrumented binary on the left side, while the right side
    shows how that binary transforms when you instrument it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地理解跳板方法，参考[图9-2](ch09.xhtml#ch09fig2)中展示的示例。图中左侧显示的是未插装的二进制文件，右侧则显示了插装后的二进制文件如何变化。
- en: '![image](Images/f229-01.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f229-01.jpg)'
- en: '*Figure 9-2: Static binary instrumentation with trampolines*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-2：使用跳板的静态二进制插装*'
- en: Let’s assume the original noninstrumented binary contains two functions called
    `f1` and `f2`. [Figure 9-2](ch09.xhtml#ch09fig2) shows that `f1` contains the
    following code. The contents of `f2` are not important for this example.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设原始的未插装二进制文件包含两个函数，分别是`f1`和`f2`。[图9-2](ch09.xhtml#ch09fig2)显示了`f1`包含的代码。`f2`的内容对于这个示例并不重要。
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When you instrument a binary using the trampoline approach, the SBI engine
    creates copies of all the original functions, places them in a new code section
    (called `.text.instrum` in [Figure 9-2](ch09.xhtml#ch09fig2)), and overwrites
    the first instruction of each original function with a `jmp` trampoline that jumps
    to the corresponding copied function. For example, the SBI engine rewrites the
    original `f1` as follows to redirect it to `f1_copy`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用跳板方法对二进制文件进行插装时，SBI引擎会创建所有原始函数的副本，将它们放置在一个新的代码段中（在[图9-2](ch09.xhtml#ch09fig2)中称为`.text.instrum`），并用`jmp`跳板指令覆盖每个原始函数的第一条指令，指向相应的复制函数。例如，SBI引擎会按如下方式重写原始的`f1`，将其重定向到`f1_copy`：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The trampoline instruction is a 5-byte `jmp`, so it may partially overwrite
    and corrupt multiple instructions, creating “junk bytes” just after the trampoline.
    However, this isn’t normally a problem for the trampoline approach because it
    ensures that these corrupted instructions are never executed. You’ll see some
    cases where this may go wrong at the end of this section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 跳板指令是一个5字节的`jmp`，因此它可能部分覆盖并破坏多个指令，导致跳板后面出现“垃圾字节”。然而，这通常不是跳板方法的问题，因为它确保这些损坏的指令永远不会被执行。你将在本节末尾看到一些可能出错的情况。
- en: Trampoline Control Flow
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳板控制流
- en: To get a better sense of the control flow of a program instrumented with the
    trampoline approach, let’s return to the right side of [Figure 9-2](ch09.xhtml#ch09fig2)
    showing the instrumented binary and assume that the original `f1` function has
    just been called. As soon as `f1` is called, the trampoline jumps to `f1_copy`
    ➊, the instrumented version of `f1`. There may be some junk bytes following the
    trampoline ➋, but these aren’t executed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解通过跳板方法插装的程序控制流，回到[图9-2](ch09.xhtml#ch09fig2)右侧显示的插装二进制文件，并假设原始的`f1`函数刚刚被调用。只要`f1`被调用，跳板就会跳转到`f1_copy`
    ➊，即`f1`的插装版本。跳板后面可能会有一些垃圾字节 ➋，但这些字节不会被执行。
- en: The SBI engine inserts several `nop` instructions at every possible instrumentation
    point in `f1_copy` ➌. That way, to instrument an instruction, the SBI engine can
    simply overwrite the `nop` instructions at that instrumentation point with a `jmp`
    or `call` to a chunk of instrumentation code. Note that both the `nop` insertion
    and the instrumentation are done statically, not at runtime. In [Figure 9-2](ch09.xhtml#ch09fig2),
    all of the `nop` regions are unused except for the last one, just before the `ret`
    instruction, as I’ll explain in a moment.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: SBI引擎会在`f1_copy`中的每个可能的插装点插入若干个`nop`指令 ➌。这样，为了插装一条指令，SBI引擎只需将该插装点的`nop`指令覆盖为跳转`jmp`或调用`call`到一个插装代码块。请注意，`nop`插入和插装操作都是静态完成的，而不是在运行时完成的。在[图9-2](ch09.xhtml#ch09fig2)中，所有的`nop`区域除了最后一个区域——位于`ret`指令之前——都没有使用，正如我稍后会解释的那样。
- en: To maintain the correctness of relative jumps despite the code shifting because
    of newly inserted instructions, the SBI engine patches the offsets of all relative
    `jmp` instructions. Additionally, the engine replaces all 2-byte relative `jmp`
    instructions, which have an 8-bit offset, with a corresponding 5-byte version
    that has a 32-bit offset ➍. This is necessary because as you shift code around
    in `f1_copy`, the offset between `jmp` instructions and their targets may become
    too large to encode in 8 bits.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在插入新指令后代码发生偏移时仍能保持相对跳转的正确性，SBI引擎会修补所有相对`jmp`指令的偏移量。此外，SBI引擎还会将所有2字节的相对`jmp`指令（具有8位偏移量）替换为相应的5字节版本，这些版本具有32位的偏移量
    ➍。这是必要的，因为当你在`f1_copy`中移动代码时，`jmp`指令与其目标之间的偏移可能会变得过大，无法用8位编码。
- en: Similarly, the SBI engine rewrites direct calls, such as `call f2`, so that
    they target the instrumented function instead of the original ➎. Given this rewriting
    of direct calls, you may wonder why the trampolines at the start of every original
    function are needed at all. As I’ll explain in a moment, they’re necessary to
    accommodate indirect calls.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，SBI引擎会重写直接调用，如`call f2`，使它们指向插装后的函数，而不是原始函数 ➎。鉴于这种对直接调用的重写，你可能会想知道为什么每个原始函数开头的跳板仍然是必要的。正如我稍后会解释的那样，它们是为了适应间接调用而必需的。
- en: Now let’s assume you’ve told the SBI engine to instrument every `ret` instruction.
    To do this, the SBI engine overwrites the `nop` instructions reserved for this
    purpose with a `jmp` or `call` to your instrumentation code ➏. In the example
    of [Figure 9-2](ch09.xhtml#ch09fig2), the instrumentation code is a function named
    `hook_ret`, which is placed in a shared library and reached by a `call` that the
    SBI engine placed at the instrumentation point.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你已经告诉SBI引擎插装每条`ret`指令。为此，SBI引擎会将为此目的预留的`nop`指令覆盖为跳转`jmp`或调用`call`到你的插装代码
    ➏。在[图9-2](ch09.xhtml#ch09fig2)的示例中，插装代码是一个名为`hook_ret`的函数，它被放置在共享库中，并通过SBI引擎在插装点插入的`call`调用来访问。
- en: The `hook_ret` function first saves state ➐, such as register contents, and
    then runs any instrumentation code that you specified. Finally, it restores the
    saved state ➑ and resumes normal execution by returning to the instruction following
    the instrumentation point.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`hook_ret`函数首先保存状态 ➐，例如寄存器内容，然后运行你指定的任何插装代码。最后，它恢复保存的状态 ➑，并通过返回到插装点后的指令来恢复正常执行。'
- en: Now that you’ve seen how the trampoline approach rewrites direct control flow
    instructions, let’s take a look at how it handles indirect control flow.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了跳板方法如何重写直接控制流指令，让我们来看一下它是如何处理间接控制流的。
- en: Handling Indirect Control Flow
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理间接控制流
- en: 'Because indirect control flow instructions target dynamically computed addresses,
    there’s no reliable way for SBI engines to statically redirect them. The trampoline
    approach allows indirect control transfers to flow to original, uninstrumented
    code and uses trampolines placed in the original code to intercept and redirect
    the control flow back to the instrumented code. [Figure 9-3](ch09.xhtml#ch09fig3)
    shows how the trampoline approach handles two types of indirect control flow:
    indirect function calls and indirect jumps used to implement C/C++ `switch` statements.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于间接控制流指令的目标是动态计算的地址，因此SBI引擎无法静态地重定向它们。跳板技术允许间接控制流转移到原始的、未插装的代码，并通过在原始代码中放置跳板来拦截并将控制流重新定向回插装过的代码。[图9-3](ch09.xhtml#ch09fig3)展示了跳板方法如何处理两种类型的间接控制流：间接函数调用和用于实现C/C++
    `switch`语句的间接跳转。
- en: '![image](Images/f231-01.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f231-01.jpg)'
- en: '*Figure 9-3: Indirect control transfers in a statically instrumented binary*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9-3：静态插装二进制中的间接控制转移*'
- en: '[Figure 9-3a](ch09.xhtml#ch09fig3) shows how the trampoline approach handles
    indirect calls. The SBI engine doesn’t alter code that computes addresses, so
    the target addresses used by indirect calls point to the original function ➊.
    Because there’s a trampoline at the start of every original function, control
    flows immediately back to the instrumented version of the function ➋.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-3a](ch09.xhtml#ch09fig3) 展示了跳板方法如何处理间接调用。SBI 引擎不会改变计算地址的代码，因此间接调用使用的目标地址指向原始函数
    ➊。由于每个原始函数的开始处都有一个跳板，控制流会立即返回到该函数的插桩版本 ➋。'
- en: For indirect jumps, things are more complicated, as you can see in [Figure 9-3b](ch09.xhtml#ch09fig3).
    For the purposes of this example, let’s assume an indirect jump that’s part of
    a C/C++ `switch` statement. At the binary level, switch statements are often implemented
    using a *jump table* that contains all the addresses of the possible `switch`
    cases. To jump to a particular case, the `switch` computes the corresponding jump
    table index and uses an indirect `jmp` to jump to the address stored there ➊.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于间接跳转，事情变得更加复杂，正如你在[图 9-3b](ch09.xhtml#ch09fig3)中看到的那样。为了简化这个例子，假设这是一个作为 C/C++
    `switch` 语句一部分的间接跳转。在二进制级别，`switch` 语句通常使用一个*跳转表*来实现，该表包含所有可能的 `switch` 情况的地址。为了跳转到特定的情况，`switch`
    会计算出对应的跳转表索引，并使用间接的 `jmp` 跳转到该地址 ➊。
- en: Trampolines in Position-Independent Code
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 位置无关代码中的跳板
- en: 'SBI engines based on the trampoline approach require special support for indirect
    control flows in position-independent executables (PIE binaries), which don’t
    depend on any particular load address. PIE binaries read the value of the program
    counter and use it as the basis for address computations. On 32-bit x86, PIE binaries
    read the program counter by executing a `call` instruction and then reading the
    return address from the stack. For example, `gcc 5.4.0` emits the following function
    that you can call to read the address of the instruction after the `call`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 基于跳板方法的 SBI 引擎需要对位置独立可执行文件（PIE 二进制文件）中的间接控制流提供特别支持，这些文件不依赖于任何特定的加载地址。PIE 二进制文件会读取程序计数器的值，并将其作为地址计算的基础。在
    32 位 x86 上，PIE 二进制文件通过执行 `call` 指令来读取程序计数器，然后从栈中读取返回地址。例如，`gcc 5.4.0` 会生成以下函数，你可以调用它来读取
    `call` 指令之后的指令地址：
- en: '[PRE2]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This function copies the return address into `ebx` and then returns. On x64,
    you can read the program counter (`rip`) directly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数将返回地址复制到 `ebx` 中，然后返回。在 x64 中，你可以直接读取程序计数器（`rip`）。
- en: The danger with PIE binaries is that they may read the program counter while
    running instrumented code and use it in address computations. This likely yields
    incorrect results because the layout of the instrumented code differs from the
    original layout that the address computation assumes. To solve this, SBI engines
    instrument code constructs that read the program counter such that they return
    the value the program counter would have in the original code. That way, subsequent
    address computations yield the original code location just as in an uninstrumented
    binary, allowing the SBI engine to intercept control there with a trampoline.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: PIE（二进制位置独立）可执行文件的危险在于，它们可能在运行插桩代码时读取程序计数器并将其用于地址计算。这很可能导致错误的结果，因为插桩代码的布局与地址计算假设的原始布局不同。为了解决这个问题，SBI
    引擎会对读取程序计数器的代码结构进行插桩，使其返回原始代码中程序计数器应有的值。这样，随后的地址计算将像在未插桩的二进制文件中一样，得出原始代码的位置，从而允许
    SBI 引擎通过跳板拦截该位置的控制流。
- en: By default, the addresses stored in the jump table all point into the original
    code ➋. Thus, the indirect `jmp` ends up in the middle of an original function,
    where there’s no trampoline, and resumes execution there ➌. To avoid this problem,
    the SBI engine must either patch the jump table, changing original code addresses
    to new ones, or place a trampoline at every `switch` case in the original code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，跳转表中存储的地址都指向原始代码 ➋。因此，间接的 `jmp` 最终会跳到原始函数的中间，那里没有跳板，然后继续执行 ➌。为了避免这个问题，SBI
    引擎必须要么修补跳转表，修改原始代码地址为新的地址，要么在原始代码中的每个 `switch` 情况处放置一个跳板。
- en: Unfortunately, basic symbolic information (as opposed to extensive DWARF information)
    contains no information on the layout of `switch` statements, making it hard to
    figure out where to place the trampolines. Additionally, there may not be enough
    room between the `switch` statements to accommodate all trampolines. Patching
    jump tables is also dangerous because you risk erroneously changing data that
    just happens to be a valid address but isn’t really part of a jump table.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，基本的符号信息（与大量DWARF信息不同）没有包含`switch`语句的布局信息，这使得很难判断在哪里放置跳板。此外，`switch`语句之间可能没有足够的空间来容纳所有的跳板。修补跳转表也是危险的，因为你有可能错误地改变一些数据，这些数据恰好是一个有效的地址，但并不真正属于跳转表的一部分。
- en: Reliability of the Trampoline Approach
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳板方法的可靠性
- en: As you can tell from the problems handling `switch` statements, the trampoline
    approach is error-prone. Similar to `switch` cases that are too small to accommodate
    a normal trampoline, programs may (however unlikely) contain very short functions
    that don’t have enough room for a 5-byte `jmp`, requiring the SBI engine to fall
    back to another solution like the `int 3` approach. Moreover, if the binary contains
    any inline data mixed in with the code, trampolines may inadvertently overwrite
    part of that data, causing errors when the program uses the data. All this is
    assuming that the disassembly used is correct in the first place; if it’s not,
    any changes made by the SBI engine may break the binary.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，处理`switch`语句时，跳板方法容易出错。类似于那些空间不足以容纳正常跳板的`switch`语句，程序可能（尽管不太可能）包含非常短的函数，它们没有足够的空间放置一个5字节的`jmp`，这时SBI引擎需要回退到另一种解决方案，比如`int
    3`方法。此外，如果二进制文件中包含任何与代码混合的内联数据，跳板可能会不小心覆盖部分数据，导致程序在使用这些数据时出现错误。所有这些假设反汇编本身就是正确的；如果不正确，SBI引擎所做的任何修改都可能会破坏二进制文件。
- en: Unfortunately, there’s no known SBI technique that’s both efficient and sound,
    making SBI dangerous to use on production binaries. In many cases, DBI solutions
    are preferable, because they’re not prone to the errors SBI faces. Although they’re
    not as fast as SBI, modern DBI platforms perform efficiently enough for many practical
    use cases. The rest of this chapter focuses on DBI, specifically on a well-known
    DBI platform called Pin. Let’s take a look at some of DBI’s implementation details
    and then explore practical examples.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，目前没有一种既高效又可靠的SBI技术，这使得SBI在生产二进制文件中使用时存在风险。在许多情况下，DBI解决方案更为可取，因为它们不容易遭遇SBI所面临的错误。尽管DBI的速度不如SBI，但现代DBI平台在许多实际应用场景中已经足够高效。本章的其余部分将重点介绍DBI，特别是一个著名的DBI平台——Pin。我们将首先看看DBI的实现细节，然后探讨一些实际的例子。
- en: 9.3 Dynamic Binary Instrumentation
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3 动态二进制插装
- en: Because DBI engines monitor binaries (or rather, processes) as they execute
    and instrument the instruction stream, they don’t require disassembly or binary
    rewriting like SBI does, making them less error-prone.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因为DBI引擎在执行过程中监控二进制文件（或更准确地说，监控进程），并对指令流进行插装，它们不像SBI那样需要反汇编或二进制重写，因此它们更不容易出错。
- en: '[Figure 9-4](ch09.xhtml#ch09fig4) shows the architecture of modern DBI systems
    like Pin and DynamoRIO. These systems are all based on the same high-level approach,
    although they differ in implementation details and optimizations. I’ll focus the
    rest of this chapter on the kind of “pure” DBI systems shown in the figure, rather
    than hybrid platforms like Dyninst that support both SBI and DBI by using code-patching
    techniques such as trampolines.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-4](ch09.xhtml#ch09fig4)展示了现代DBI系统（如Pin和DynamoRIO）的架构。这些系统都基于相同的高级方法，尽管它们在实现细节和优化上有所不同。我将把本章的其余部分集中在图中展示的“纯”DBI系统，而不是像Dyninst这样的混合平台，后者通过使用代码修补技术（如跳板）来支持SBI和DBI。'
- en: '*9.3.1 Architecture of a DBI System*'
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.3.1 DBI系统架构*'
- en: DBI engines dynamically instrument processes by monitoring and controlling all
    the executed instructions. The DBI engine exposes an API that allows you to write
    user-defined DBI tools (often in the form of a shared library loaded by the engine)
    that specify which code should be instrumented and how. For example, the DBI tool
    shown on the right side of [Figure 9-4](ch09.xhtml#ch09fig4) implements (in pseudocode)
    a simple profiler that counts how many basic blocks are executed. To achieve that,
    it uses the DBI engine’s API to instrument the last instruction of every basic
    block with a callback to a function that increments a counter.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: DBI 引擎通过监控和控制所有已执行的指令来动态地插桩进程。DBI 引擎暴露了一个 API，允许你编写用户定义的 DBI 工具（通常是由引擎加载的共享库形式），以指定哪些代码需要插桩以及如何插桩。例如，[图
    9-4](ch09.xhtml#ch09fig4) 右侧显示的 DBI 工具实现了一个简单的性能分析器（伪代码），该分析器统计执行了多少个基本块。为了实现这一点，它使用
    DBI 引擎的 API，在每个基本块的最后一条指令上插桩一个回调函数，以增加计数器。
- en: Before the DBI engine starts the main application process (or resumes it, if
    you attach to an existing process), it allows the DBI tool to initialize itself.
    In [Figure 9-4](ch09.xhtml#ch09fig4), the DBI tool’s initialization function registers
    a function called `instrument_bb` with the DBI engine ➊. This function tells the
    DBI engine how to instrument every basic block; in this case, it adds a callback
    to `bb_callback` after the last instruction in the basic block. Next, the initialization
    function informs the DBI engine that it’s done initializing and ready to start
    the application ➋.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DBI 引擎启动主应用程序进程之前（或者如果你附加到现有进程，则在恢复它之前），它允许 DBI 工具进行初始化。在[图 9-4](ch09.xhtml#ch09fig4)中，DBI
    工具的初始化函数将一个名为`instrument_bb`的函数注册到 DBI 引擎 ➊。这个函数告诉 DBI 引擎如何对每个基本块进行插桩；在这种情况下，它在基本块的最后一条指令后添加了一个回调到`bb_callback`。接下来，初始化函数通知
    DBI 引擎它已完成初始化并准备启动应用程序 ➋。
- en: '![image](Images/f234-01.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f234-01.jpg)'
- en: '*Figure 9-4: Architecture of a DBI system*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 9-4：DBI 系统的架构*'
- en: The DBI engine never runs the application process directly but instead runs
    code in a *code cache* that contains all the instrumented code. Initially, the
    code cache is empty, so the DBI engine fetches a block of code from the process
    ➌ and instruments that code ➍ as instructed by the DBI tool ➎. Note that DBI engines
    don’t necessarily fetch and instrument code at basic block granularity, as I’ll
    explain further in [Section 9.4](ch09.xhtml#ch09_4). However, for this example
    I’ll assume that the engine instruments code at basic block granularity by calling
    `instrument_bb`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: DBI 引擎从不直接运行应用程序进程，而是运行包含所有插桩代码的*代码缓存*中的代码。最初，代码缓存是空的，因此 DBI 引擎从进程中获取一块代码 ➌，并按照
    DBI 工具的指示对该代码进行插桩 ➍。请注意，DBI 引擎不一定以基本块粒度获取和插桩代码，正如我将在[第 9.4 节](ch09.xhtml#ch09_4)中进一步解释的那样。然而，在这个例子中，我假设引擎通过调用`instrument_bb`以基本块粒度插桩代码。
- en: After instrumenting the code, the DBI engine compiles it with a just-intime
    (JIT) compiler ➏, which re-optimizes the instrumented code and stores the compiled
    code in the code cache ➐. The JIT compiler also rewrites control flow instructions
    to ensure that the DBI engine retains control, preventing control transfers from
    continuing execution in the uninstrumented application process. Note that unlike
    most compilers, the JIT compiler in a DBI engine doesn’t translate the code into
    a different language; it compiles from native machine code to native machine code.
    It’s only necessary to instrument and JIT-compile code the first time it’s executed.
    After that, it’s stored in the code cache and reused.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在对代码进行插桩后，DBI 引擎使用即时编译器（JIT） ➏进行编译，JIT 编译器重新优化插桩后的代码，并将编译后的代码存储在代码缓存中 ➐。JIT
    编译器还会重写控制流指令，确保 DBI 引擎保持控制，防止控制转移继续在未插桩的应用程序进程中执行。请注意，与大多数编译器不同，DBI 引擎中的 JIT 编译器不会将代码翻译成不同的语言；它是从原生机器码编译到原生机器码。只需在首次执行代码时进行插桩和
    JIT 编译。之后，代码会存储在代码缓存中并重用。
- en: The instrumented and JIT-compiled code now executes in the code cache until
    there’s a control-flow instruction that requires fetching new code or looking
    up another code chunk in the cache ➑ DBI engines like Pin and DynamoRIO reduce
    runtime overhead by rewriting control-flow instructions when possible, so they
    jump directly to the next block in the code cache without mediation by the DBI
    engine. When that’s not possible (for example, for indirect calls), the rewritten
    instructions return control to the DBI engine so that it can prepare and start
    the next code chunk.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 插装并 JIT 编译后的代码现在在代码缓存中执行，直到遇到需要获取新代码或在缓存中查找另一个代码块的控制流指令 ➑。像 Pin 和 DynamoRIO
    这样的 DBI 引擎通过在可能的情况下重写控制流指令，减少了运行时开销，从而使它们能够直接跳转到代码缓存中的下一个块，而无需经过 DBI 引擎的中介。当不可能这样做时（例如，对于间接调用），重写的指令会将控制权返回给
    DBI 引擎，以便它准备并启动下一个代码块。
- en: While most instructions run natively in the code cache, the DBI engine may emulate
    some instructions instead of running them directly. For example, Pin does this
    for system calls like `execve` that require special handling by the DBI engine.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数指令在代码缓存中本地运行，但 DBI 引擎可能会模拟某些指令，而不是直接运行它们。例如，Pin 对像 `execve` 这样的系统调用进行模拟，因为它们需要
    DBI 引擎特别处理。
- en: The instrumented code contains callbacks to functions in the DBI tool that observe
    or modify the code’s behavior ➒. For instance, in [Figure 9-4](ch09.xhtml#ch09fig4),
    the DBI tool’s `instrument_bb` function adds a callback at the end of every basic
    block that invokes `bb_callback`, which increments the DBI tool’s basic block
    counter. The DBI engine automatically saves and restores register state when transferring
    control to or from a callback function in the DBI tool.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 插装后的代码包含回调到 DBI 工具中的函数，这些函数观察或修改代码的行为 ➒。例如，在 [图 9-4](ch09.xhtml#ch09fig4) 中，DBI
    工具的 `instrument_bb` 函数在每个基本块的末尾添加一个回调，调用 `bb_callback`，该回调递增 DBI 工具的基本块计数器。DBI
    引擎在将控制转移到或从 DBI 工具中的回调函数时，会自动保存和恢复寄存器状态。
- en: Now that you’re familiar with the workings of DBI engines, let’s discuss Pin,
    the DBI engine I’ll use for the examples in this chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了 DBI 引擎的工作原理，让我们来讨论 Pin，这是我在本章示例中使用的 DBI 引擎。
- en: '*9.3.2 Introduction to Pin*'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*9.3.2 Pin 介绍*'
- en: One of the most popular DBI platforms, Intel Pin is an actively developed, free-to-use
    (though not open source), and well-documented tool that offers a relatively easy-to-use
    API.^([8](footnote.xhtml#ch09fn_8)) You’ll find Pin v3.6 preinstalled on the virtual
    machine in *~/pin/pin-3.6-97554-g31f0a167d-gcc-linux*. Pin ships with many example
    tools that you can find in the *source/tools* subdirectory of the main Pin directory.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最受欢迎的 DBI 平台之一，Intel Pin 是一个积极开发的、免费使用（尽管不是开源的）且文档齐全的工具，它提供了一个相对易用的 API。^([8](footnote.xhtml#ch09fn_8))
    你会在虚拟机的 *~/pin/pin-3.6-97554-g31f0a167d-gcc-linux* 路径下找到预装的 Pin v3.6。Pin 附带了许多示例工具，你可以在主
    Pin 目录的 *source/tools* 子目录中找到它们。
- en: Pin Internals
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pin 内部结构
- en: Pin currently supports Intel CPU architectures including x86 and x64 and is
    available for Linux, Windows, and macOS. Its architecture is similar to [Figure
    9-4](ch09.xhtml#ch09fig4). Pin fetches and JIT-compiles code at *trace* granularity,
    a basic block-like abstraction that can be entered only at the top but may contain
    multiple exits, unlike regular basic blocks.^([9](footnote.xhtml#ch09fn_9)) Pin
    defines a trace as a straight-line instruction sequence that ends when it hits
    an unconditional control transfer or reaches a predefined maximum length or number
    of conditional control-flow instructions.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Pin 当前支持包括 x86 和 x64 在内的 Intel CPU 架构，并可用于 Linux、Windows 和 macOS。其架构类似于 [图 9-4](ch09.xhtml#ch09fig4)。Pin
    按 *trace* 粒度获取和 JIT 编译代码，*trace* 是一种类似基本块的抽象，可以仅在顶部进入，但可能包含多个退出点，不同于常规的基本块。^([9](footnote.xhtml#ch09fn_9))
    Pin 将 trace 定义为一条直线指令序列，直到遇到无条件控制转移或达到预定义的最大长度或条件控制流指令数量时结束。
- en: Although Pin always JIT-compiles code at trace granularity, it allows you to
    instrument code at many granularities, including instruction, basic block, trace,
    function, and image (a complete executable or library). Both Pin’s DBI engine
    and Pintools run in user space, so you can only instrument user-space processes
    with Pin.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Pin 始终按 trace 粒度进行 JIT 编译代码，但它允许你在多种粒度下对代码进行插装，包括指令、基本块、trace、函数和镜像（完整的可执行文件或库）。Pin
    的 DBI 引擎和 Pintools 都在用户空间运行，因此你只能使用 Pin 对用户空间进程进行插装。
- en: Implementing Pintools
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 Pintools
- en: The DBI tools you implement with Pin are called *Pintools*, which are shared
    libraries that you write in C/C++ using the Pin API. The Pin API is architecture
    independent as far as possible, using architecture-specific components only when
    needed. This allows you to write Pintools that are portable between architectures
    or require only minimal changes to support another architecture.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a Pintool, you write two different kinds of functions: *instrumentation
    routines* and *analysis routines*. Instrumentation routines tell Pin which instrumentation
    code to add and where; these functions run only the first time Pin encounters
    a particular piece of code that’s not yet instrumented. To instrument code, the
    instrumentation routines install callbacks to analysis routines that contain the
    actual instrumentation code and are called every time an instrumented code sequence
    runs.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Note that you shouldn’t confuse Pin’s *instrumentation routines* with the SBI
    term *instrumentation code*. Instrumentation code is new code added to an instrumented
    program and corresponds to Pin’s analysis routines, not to the instrumentation
    routines that insert the callbacks to the analysis routines. The distinction between
    instrumentation and analysis routines will become clearer in the practical examples
    that follow.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Because of Pin’s popularity, many other binary analysis platforms are based
    on it. For example, you’ll see Pin again in [Chapters 10](ch10.xhtml#ch10) through
    [13](ch13.xhtml#ch13) about dynamic taint analysis and symbolic execution.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll see two practical examples implemented with Pin: a
    profiling tool and an automatic unpacker. In the course of implementing these
    tools, you’ll learn about Pin’s internals, such as the instrumentation points
    it supports. Let’s start with the profiling tool.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 9.4 Profiling with Pin
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The profiling tool records statistics about a program’s execution to help optimize
    that program. Specifically, it counts the number of executed instructions and
    the number of times basic blocks, functions, and syscalls are invoked.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '*9.4.1 The Profiler’s Data Structures and Setup Code*'
  id: totrans-120
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 9-1](ch09.xhtml#ch09list1) shows the first part of the profiler’s
    code. The following discussion omits standard includes and functions that don’t
    use any Pin functionality, such as the usage function and the function that prints
    the results. You can see these in the *profiler.cpp* source file on the VM. I’ll
    refer to the profiler Pintool as “the Pintool” or “the profiler” and to the profiled
    program, which the profiler instruments, as “the application.”'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-1:* profiler.cpp'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Every Pintool must include *pin.H* to access the Pin API ➊.^([10](footnote.xhtml#ch09fn_10))
    This single header file provides the entire API.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Note that Pin observes the program starting from the first instruction, which
    means the profiler sees not only the application code but also the instructions
    executed by the dynamic loader and shared libraries. This is important to keep
    in mind for all Pintools that you write.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Command Line Options and Data Structures
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pintools can implement tool-specific command line options, which are called
    *knobs* in Pin parlance. The Pin API includes a dedicated `KNOB` class that you
    use to create command line options. In [Listing 9-1](ch09.xhtml#ch09list1), there
    are two Boolean options (`KNOB<bool>`) ➋ called `ProfileCalls` and `ProfileSyscalls`.
    The options use mode `KNOB_MODE_WRITEONCE` because they’re Boolean flags that
    are set only once when you supply the flag. You enable the `ProfileCalls` option
    by passing the flag `-c` to the Pintool, and you enable `ProfileSyscalls` by passing
    `-s`. (You’ll see how to pass these options in the profiler tests.) Both options
    have the default value 0, meaning they’re false if you don’t pass the flag. Pin
    also allows you to create other types of command line options, such as `string`
    or `int` options. To learn more about these options, you can refer to the Pin
    documentation online or take a look at the example tools.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: The profiler uses multiple `std::map` data structures and counters to keep track
    of the program’s runtime statistics ➌. The `cflows` and `calls` data structures
    map addresses of control flow targets (basic blocks or functions) to another map
    that in turn tracks the addresses of the control flow instructions (jumps, calls,
    and so on) that invoked each target and counts how often that control transfer
    was taken. The `syscall` map simply tracks how often each syscall number was invoked,
    and `funcnames` maps function addresses to symbolic names, if known. The counters
    (`insn_count`, `cflow_count`, `call_count`, and `syscall_count`) track the total
    number of executed instructions, control flow instructions, calls, and syscalls,
    respectively.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Pin
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like normal C/C++ programs, Pintools start in the `main` function. The first
    Pin function that the profiler calls is `PIN_InitSymbols` ➍, which causes Pin
    to read the application’s symbol tables. To use symbols in your Pintool, Pin requires
    that you call `PIN_InitSymbols` before any other Pin API function. The profiler
    uses symbols when they’re available to show human-readable statistics on how often
    each function was called.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: The next function the profiler calls is `PIN_Init` ➎, which initializes Pin
    and must be called before any other Pin function except `PIN_InitSymbols`. It
    returns `true` if anything went wrong during initialization, in which case the
    profiler prints usage instructions and exits. The `PIN_Init` function processes
    Pin’s command line options as well as your Pintool’s options as specified by the
    `KNOB`s you created. Usually, your Pintool won’t need to implement any of its
    own command line processing code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Registering Instrumentation Functions
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that Pin is initialized, it’s time to initialize the Pintool. The most important
    part of that is registering the instrumentation routines that are responsible
    for instrumenting the application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The profiler registers three instrumentation routines ➏. The first of these,
    called `parse_funcsyms`, instruments at image granularity, while `instrument_trace`
    and `instrument_insn` instrument at trace and instruction granularity, respectively.
    To register these routines with Pin, you call `IMG _AddInstrumentFunction`, `TRACE_AddInstrument
    Function`, and `INS_AddInstrument Function`, respectively. Note that you can add
    as many instrumentation routines of each type as you want.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll see shortly, the three instrumentation routines take an `IMG`, a `TRACE`,
    and an `INS` object as their first parameter, respectively, depending on their
    type. Additionally, they all take a `void*` as their second parameter, which allows
    you to pass a Pintool-specific data structure that you specify when you register
    the instrumentation routines using `*_AddInstrument Function`. The profiler doesn’t
    use this facility (it passes `NULL` for each `void*`).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Registering a Syscall Entry Function
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pin also allows you to register functions that are called before or after every
    syscall, in the same way as you register instrumentation callbacks. Note that
    you can’t specify callbacks for only some syscalls; you can only differentiate
    between syscalls inside the callback function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: The profiler uses `PIN_AddSyscallEntryFunction` to register a function named
    `log_syscall` that’s called whenever a syscall is entered ➐. To register a callback
    that triggers when a syscall exits, use `PIN_AddSyscallExitFunction` instead.
    The profiler registers the callback only if `ProfileSyscalls.Value()`, the value
    of the `ProfileSyscalls` knob, is `true`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Registering a Fini Function
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final callback that the profiler registers is a *fini function*, which is
    called when the application exits or when you detach Pin from it ➑. Fini functions
    receive an exit status code (an `INT32`) and a user-defined `void*`. To register
    a fini function, you use `PIN_AddFiniFunction`. Note that fini functions may not
    be called reliably for some programs, depending on how the program exits.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: The fini function that the profiler registers is responsible for printing the
    profiling results. I won’t discuss it here because it doesn’t contain any Pin-specific
    code, but you can see the output of `print_results` when testing the profiler.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Starting the Application
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last step of every Pintool’s initialization is to call `PIN_StartProgram`,
    which starts the application running ➒. After that, it’s no longer possible to
    register any new callbacks; the Pintool gets back control only when an instrumentation
    or analysis routine is called. The `PIN_StartProgram` function never returns,
    meaning that the `return 0` at the end of `main` is never reached.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '*9.4.2 Parsing Function Symbols*'
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you know how to initialize a Pintool and register instrumentation routines
    and other callbacks, let’s take a detailed look at the callback functions just
    registered. Let’s start with `parse_funcsyms`, shown in [Listing 9-2](ch09.xhtml#ch09list2).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-2:* profiler.cpp *(continued)*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Recall that `parse_funcsyms` is an image-granularity instrumentation routine,
    which you can tell because it receives an `IMG` object as its first argument.
    Image instrumentation routines are called when a new image (an executable or shared
    library) loads, allowing you to instrument the image as a whole. Among other things,
    this lets you loop over all the functions in the image and add analysis routines
    that run before or after each function. Note that function instrumentation is
    reliable only if the binary contains symbolic information, and after-function
    instrumentation doesn’t work with some optimizations, such as tail calls.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: However, `parse_funcsyms` doesn’t add any instrumentation at all. Instead, it
    takes advantage of another feature of image instrumentation, which lets you inspect
    the symbolic names of all functions in the image. The profiler saves these names
    so that it can read them back later to show human-readable function names in the
    output.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Before using its `IMG` argument, `parse_funcsyms` calls `IMG_Valid` to ensure
    that it’s a valid image ➊. If it is, `parse_funcsyms` loops over all the `SEC`
    objects in the image, which represent all the sections ➋. `IMG_SecHead` returns
    the first section in the image, and `SEC_Next` returns the next section; the loop
    continues until `SEC_Valid` returns `false`, indicating that there’s no next remaining
    section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: For each section, `parse_funcsyms` loops over all the functions (represented
    by `RTN` objects, as in “routine”) ➌ and maps each function’s address (as returned
    by `RTN_Address`) in the `funcnames` map to the symbolic name of the function
    (as returned by `RTN_Name`) ➍. If the function’s name is not known (for example,
    when the binary has no symbol table), `RTN_Name` returns an empty string.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: After `parse_funcsyms` completes, `funcnames` contains a mapping of all known
    function addresses to symbolic names.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '*9.4.3 Instrumenting Basic Blocks*'
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recall that one of the things the profiler records is the number of instructions
    the program executes. To that end, the profiler instruments every basic block
    with a call to an analysis function that increases the instruction counter (`insn_count`)
    by the number of instructions in the basic block.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: A Few Notes on Basic Blocks in Pin
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because Pin discovers basic blocks dynamically, the basic blocks that Pin finds
    may differ from what you would find based on static analysis. For example, Pin
    may initially find a large basic block, only to later discover a jump into the
    middle of that basic block, forcing Pin to renew its decision, break the basic
    block in two, and reinstrument both basic blocks. Although this doesn’t matter
    for the profiler since it doesn’t care about the shape of basic blocks, only the
    number of executed instructions, it’s important to keep in mind to prevent confusion
    with some Pintools.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Also note that as an alternative implementation, you could increment `insn_count`
    on every instruction. However, that would be significantly slower than the basic
    block-level implementation because it requires one callback per instruction to
    the analysis function that increments `insn_count`. In contrast, the basic block-level
    implementation requires only one callback per basic block. When writing a Pintool,
    it’s important to optimize the analysis routines as much as you can because they’re
    called repeatedly throughout the execution, unlike instrumentation routines, which
    are called only the first time a piece of code is encountered.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Basic Block Instrumentation
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can’t directly instrument basic blocks in the Pin API. That is, there’s
    no `BBL_AddInstrumentFunction`. To instrument basic blocks, you have to add a
    trace-level instrumentation routine and then loop over all the basic blocks in
    the trace, instrumenting each one, as shown in [Listing 9-3](ch09.xhtml#ch09list3).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-3:* profiler.cpp *(continued)*'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first function in the listing, `instrument_trace`, is the trace-level instrumentation
    routine that the profiler registered earlier. Its first argument is the `TRACE`
    to instrument.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: First, `instrument_trace` calls `IMG_FindByAddress` with the trace’s address
    to find the `IMG` that the trace is part of ➊. Next, it verifies that the image
    is valid and calls `IMG_IsMainExecutable` to check that the trace is part of the
    main application executable. If not, `instrument_trace` returns without instrumenting
    the trace. The rationale behind this is that when you’re profiling an application,
    you typically want to count code only inside the application itself, not code
    in shared libraries or the dynamic loader.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: If the trace is valid and part of the main application, `instrument_trace` loops
    over all the basic blocks (`BBL` objects) in the trace ➋. For each `BBL`, it calls
    `instrument_bb` ➌, which performs the actual instrumentation of each `BBL`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'To instrument a given `BBL`, `instrument_bb` calls `BBL_InsertCall` ➍, which
    is Pin’s API function to instrument a basic block with an analysis routine callback.
    The `BBL_InsertCall` function takes three mandatory arguments: the basic block
    to instrument (`bb` in this case), an *insertion point*, and a function pointer
    to the analysis routine you want to add.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: The insertion point determines where in the basic block Pin inserts the analysis
    callback. In this case, the insertion point is `IPOINT_ANYWHERE` ➎ because it
    doesn’t matter at what point in the basic block the instruction counter is updated.
    This allows Pin to optimize the placement of the analysis callback. [Table 9-2](ch09.xhtml#ch09tab2)
    shows all the possible insertion points. These apply not only for basic block-level
    instrumentation but also for instruction instrumentation and all other granularities.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: The name of the analysis routine is `count_bb_insns` ➏, and you’ll see its implementation
    in a moment. Pin provides an `AFUNPTR` type that you should cast function pointers
    to when passing them to Pin API functions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 9-2: Pin Insertion Points'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '| **Insertion point** | **Analysis callback** | **Validity** |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: '| `IPOINT_BEFORE` | Before instrumented object | Always valid |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| `IPOINT_AFTER` | On fallthrough edge (of branch or “regular” instruction)
    | If `INS_HasFallthrough` is `true` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| `IPOINT_ANYWHERE` | Anywhere in instrumented object | For `TRACE` or `BBL`
    only |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| `IPOINT_TAKEN_BRANCH` | On taken edge of branch | If `INS_IsBranchOrCall`
    is `true` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: After the mandatory arguments to `BBL_InsertCall`, you can add optional arguments
    to pass to the analysis routine. In this case, there’s an optional argument of
    type `IARG_UINT32` ➐ with value `BBL_NumIns`. This way, the analysis routine (`count_bb_insns`)
    receives a `UINT32` argument containing the number of instructions in the basic
    block so that it can increment the instruction counter as needed. You’ll see other
    types of arguments in the rest of this example and the next example. You can find
    a complete overview of all possible argument types in the Pin documentation. When
    you’re done passing in optional arguments, you add the special argument `IARG_END`
    ➑ to inform Pin that the argument list is complete.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: The final result of the code in [Listing 9-3](ch09.xhtml#ch09list3) is that
    Pin instruments each executed basic block in the main application with a callback
    to `count _bb_insns`, which increases the profiler’s instruction counter by the
    number of instructions in the basic block.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '*9.4.4 Instrumenting Control Flow Instructions*'
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Besides counting how many instructions the application executes, the profiler
    also counts the number of control flow transfers and, optionally, the number of
    calls. It uses the instruction-level instrumentation routine shown in [Listing
    9-4](ch09.xhtml#ch09list4) to insert the analysis callbacks that count control-flow
    transfers and calls.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-4:* profiler.cpp *(continued)*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The instrumentation routine, named `instrument_insn`, receives an `INS` object
    as its first argument, representing the instruction to instrument. First, `instrument_insn`
    calls `INS_IsBranchOrCall` to check whether this is a control-flow instruction
    ➊. If not, it doesn’t add any instrumentation. After ensuring that it’s dealing
    with a control-flow instruction, `instrument_insn` checks that the instruction
    is part of the main application, just as you saw for the basic block instrumentation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Instrumenting the Taken Edge
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To record control transfers and calls, `instrument_insn` inserts three different
    analysis callbacks. First, it uses `INS_InsertPredicatedCall` ➋ to insert a callback
    on the instruction’s taken edge ➌ (see [Figure 9-5](ch09.xhtml#ch09fig5)). The
    inserted analysis callback to `count_cflow` increments the control-flow counter
    (`cflow_count`) in case the branch is taken and records the source and target
    addresses of the control transfer. To that end, the analysis routine takes two
    arguments: the instruction pointer value at the time of the callback (`IARG_INST_PTR`)
    ➍ and the target address of the branch’s taken edge (`IARG_BRANCH_TARGET_ADDR`)
    ➎.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Note that `IARG_INST_PTR` and `IARG_BRANCH_TARGET_ADDR` are special argument
    types for which the data type and value are implicit. In contrast, for the `IARG_UINT32`
    argument you saw in [Listing 9-3](ch09.xhtml#ch09list3), you have to separately
    specify the type (`IARG_UINT32`) and the value (`BBL_NumIns` in that example).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: As you saw in [Table 9-2](ch09.xhtml#ch09tab2), the taken edge is a valid instrumentation
    point only for branch or call instructions (`INS_IsBranchOrCall` must return `true`).
    In this case, the check at the start of `instrument_insn` guarantees that it’s
    a branch or call.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f245-01.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-5: Insertion points on the fallthrough and taken edges of a branch*'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Note that `instrument_insn` uses `INS_InsertPredicatedCall` to insert the analysis
    callback instead of `INS_InsertCall`. Some x86 instructions, such as conditional
    moves (`cmov`) and string operations with `rep` prefixes, have built-in predicates
    that cause the instruction to repeat if certain conditions hold. Analysis callbacks
    inserted with `INS_InsertPredicatedCall` are called only if that condition holds
    and the instruction is actually executed. In contrast, callbacks inserted with
    `INS_InsertCall` are called even if the repeat condition doesn’t hold, leading
    to an overestimation of the instruction count.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Instrumenting the Fallthrough Edge
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’ve just seen how the profiler instruments the taken edge of control-flow
    instructions. However, the profiler should record control transfers regardless
    of the branch direction. In other words, it should instrument not only the taken
    edge but also the fallthrough edge of control-flow instructions that have one
    (see [Figure 9-5](ch09.xhtml#ch09fig5)). Note that some instructions, such as
    unconditional jumps, have no fallthrough edge, so you have to explicitly check
    `INS_HasFallthrough` before you try to instrument an instruction’s fallthrough
    edge ➏. Also note that by Pin’s definition, non-control-flow instructions that
    just continue to the next instruction do have a fallthrough edge.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: If the given instruction turns out to have a fallthrough edge, `instrument _insn`
    inserts an analysis callback to `count_cflow` on that edge just as it did for
    the taken edge. The only difference is that this new callback uses insertion point
    `IPOINT_AFTER` ➐ and passes the fallthrough address (`IARG _FALLTHROUGH_ADDR`)
    as the target address to record ➑.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Instrumenting Calls
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, the profiler keeps a separate counter and mapping to track called functions
    so that you can see which functions are the most rewarding options for optimizing
    your application. Recall that to track called functions, you have to enable the
    profiler’s `-c` option.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: To instrument calls, `instrument_insn` first uses `INS_IsCall` to separate calls
    from other instructions ➒. If the instruction currently being instrumented is
    indeed a call and if the `-c` option was passed to the Pintool, the profiler inserts
    an analysis callback before the call instruction (at `IPOINT _BEFORE`) ➓ to an
    analysis routine called `count_call`, passing in the call’s source (`IARG_INST_PTR`)
    and target address (`IARG_BRANCH_TARGET_ADDR`). Note that in this case, it’s safe
    to use `INS_InsertCall` instead of `INS_InsertPredicatedCall` because there are
    no call instructions with built-in conditionals.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '*9.4.5 Counting Instructions, Control Transfers, and Syscalls*'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: So far, you’ve seen all the code responsible for initializing the Pintool and
    inserting the required instrumentation in the form of callbacks to analysis routines.
    The only code you haven’t seen yet consists of the actual analysis routines that
    count and record statistics as the application runs. [Listing 9-5](ch09.xhtml#ch09list5)
    shows all the analysis routines that the profiler uses.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-5:* profiler.cpp *(continued)*'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, the analysis routines are simple, implementing only the bare
    minimum code to track the required statistics. That’s important because analysis
    routines are called often as the application executes and so have a major impact
    on the performance of your Pintool.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The first analysis routine `count_bb_insns` ➊ is called when a basic block executes
    and simply increments `insn_count` by the number of instructions in the basic
    block. Similarly, `count_cflow` ➋ increments `cflow_count` when a control flow
    instruction executes. Additionally, it records the branch’s source and target
    address in the `cflows` map and increments the counter for this particular combination
    of source and target. In Pin, you use the `ADDRINT` integer type ➌ to store addresses.
    The analysis routine that records call information, `count_call` ➍, is analogous
    to `count_cflow`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'The last function in [Listing 9-5](ch09.xhtml#ch09list5), `log_syscall` ➎,
    is not a regular analysis routine but a callback for syscall entry events. In
    Pin, syscall handlers take four arguments: a `THREADID` identifying the thread
    that made the syscall; a `CONTEXT*` containing things like the syscall number,
    arguments, and return value (only for syscall exit handlers); a `SYSCALL_STANDARD`
    argument that identifies the syscall’s calling convention; and finally, the now-familiar
    `void*` that lets you pass in a user-defined data structure.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Recall that the purpose of `log_syscall` is to record how often each syscall
    is called. To that end, it calls `PIN_GetSyscallNumber` to get the number of the
    current syscall ➏ and records a hit for that syscall in the `syscalls` map.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen all of the profiler’s important code, let’s test it!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '*9.4.6 Testing the Profiler*'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this test, you’ll see two use cases for the profiler. First you’ll see how
    to profile an application’s entire execution from the start, and then you’ll learn
    how to attach the profiler Pintool to a running application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Profiling an Application from the Start
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Listing 9-6](ch09.xhtml#ch09list6) shows how to profile an application from
    the start.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-6: Profiling* /bin/true *with the profiler Pintool*'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: To use Pin, you first navigate to the main Pin directory ➊, where you’ll find
    an executable called `pin` that starts the Pin engine. Next, you start your application
    running under the control of `pin` with the Pintool of your choice ➋.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, `pin` uses a special format for the command line parameters.
    The `-t` option indicates the path to the Pintool you want to use and is followed
    by any options you want to pass *to the Pintool*. In this case, the used options
    are `-c` and `-s` to enable profiling for both calls and syscalls. Next, the `--`
    indicates the end of the Pintool’s options, which is followed by the name and
    options of the application you want to run with Pin (*/bin/true* in this case,
    without any command line options).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: When the application terminates, the Pintool invokes its fini function to print
    the recorded statistics, and then Pin terminates itself after the fini function
    completes. The profiler prints statistics on the number of executed instructions
    ➌, the taken control transfers ➍, the function calls ➎, and the syscalls ➏. Because
    */bin/true* is an extremely simple program,^([11](footnote.xhtml#ch09fn_11)) it
    executes only 95 instructions during its lifetime.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'The profiler reports control transfers in the format `target <- source: count`,
    where the count indicates how often this specific branch edge was taken and for
    what percentage of all control transfers the branch edge accounts. In this case,
    all control transfers are taken exactly once: there were apparently no loops or
    other repetitions of the same code. Aside from `_init` and `__libc_start_main`,
    */bin/true* makes only two function calls to internal functions with no known
    symbolic name. The most used syscall is syscall number 9, which is `sys_mmap`.
    This is because of the dynamic loader, which sets up the address space for */bin/true*.
    (In contrast to instructions and control transfers, the profiler does record syscalls
    that originate in the loader or shared libraries.)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to run an application with a Pintool from the start, let’s
    look at how to attach Pin to an already running process.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the Profiler to a Running Application
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To attach Pin to a running process, you use the `pin` program just like when
    you instrument an application from the start. However, the `pin` options are a
    little different, as you can see in [Listing 9-7](ch09.xhtml#ch09list7).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-7: Attaching the profiler to a running* netcat *process*'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: On some Linux platforms, including the Ubuntu distribution on the virtual machine,
    there’s a security mechanism in place that prevents Pin from attaching to running
    processes. To allow Pin to attach normally, you have to temporarily disable that
    security mechanism, as shown in [Listing 9-7](ch09.xhtml#ch09list7) ➊ (it will
    automatically be re-enabled on the next reboot). Additionally, you’ll need a suitable
    test process to attach Pin to. [Listing 9-7](ch09.xhtml#ch09list7) starts a background
    `netcat` process for this purpose that listens on UDP port 9999 on the local-host
    ➋. To attach to a process, you need to know its PID, which you can write down
    when you start the process ➌ or find with `ps`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: With these preliminaries out of the way, you can now navigate to the Pin folder
    ➍ and start `pin` ➎. The `-pid` option tells Pin to attach to the running process
    with the given PID (3100 for the example `netcat` process), and the `-t` option
    tells Pin the path to your Pintool as usual.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: To coax the listening `netcat` process into executing some instructions rather
    than blocking waiting for network input, [Listing 9-7](ch09.xhtml#ch09list7) uses
    another `netcat` instance to send it the message “Testing the profiler” ➏. Then,
    it brings the listening `netcat` process to the foreground ➐ and terminates it.
    When the application terminates, the profiler calls its fini function and prints
    statistics for you to inspect, including a list of control transfers ➑, called
    functions ➒ and syscalls ➓. You can see network-related function calls like `connect`,
    as well as a `sys_recvfrom` system call (number 45) that `netcat` used to receive
    the test message.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Note that once you attach Pin to a running process, it will stay attached until
    that process terminates or you call `PIN_Detach` from somewhere inside your Pintool.
    This means if you want to instrument a system process that never terminates, you
    have to incorporate some suitable termination criterion into your Pintool.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at a slightly more complex Pintool: an automatic unpacker that
    can extract obfuscated binaries!'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 9.5 Automatic Binary Unpacking with Pin
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, you’ll see how to use Pin to build a Pintool that can automatically
    unpack packed binaries. But first, let’s briefly discuss what packed binaries
    are so that you can better understand the example that follows.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '*9.5.1 Introduction to Executable Packers*'
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Executable packers*, or *packers* for short, are programs that take a binary
    as input and “pack” that binary’s code and data sections together into a compressed
    or encrypted data region, producing a new *packed executable*. Originally, packers
    were used mainly for compressing binaries, but nowadays they’re often used by
    malware to produce binaries that are more difficult for reverse engineers to analyze
    statically. [Figure 9-6](ch09.xhtml#ch09fig6) illustrates the packing process
    and the loading process of a packed binary.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f251-01.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-6: Creating and running a packed binary*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The left part of [Figure 9-6](ch09.xhtml#ch09fig6) shows a normal binary containing
    an executable header and a code and data section ➊. The entry point field in the
    executable header points into the code section.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Executing Packed Binaries
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you process the binary with a packer, it produces a new binary in which
    all the original code and data are compressed or encrypted into a packed region
    ➋ (see [Figure 9-6](ch09.xhtml#ch09fig6)). Additionally, the packer inserts a
    new code section that contains bootstrap code and redirects the binary’s entry
    point to the bootstrap code. When you try to statically disassemble and analyze
    the packed program, you see only the packed region and the bootstrap code, which
    don’t give you any idea of what the binary actually does at runtime.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: When you load and execute the packed binary, the bootstrap code extracts the
    original code and data into memory and then transfers control to the *original
    entry point (OEP)* of the binary, resuming execution normally ➌.^([12](footnote.xhtml#ch09fn_12))
    The point of the automatic unpacking Pintool you’ll see shortly is to detect the
    moment that the bootstrap code transfers control to the OEP and then to dump the
    unpacked code and data to disk so that you can statically disassemble and reverse
    engineer it as you would a normal binary.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Unpacking Packed Binaries
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many different packers that pack binaries in their own way. For well-known
    packers, such as UPX^([13](footnote.xhtml#ch09fn_13)) and AsPack,^([14](footnote.xhtml#ch09fn_14))
    there are specialized unpacking tools that can automatically extract an approximation
    of the original binary from a packed binary. However, that’s not always possible
    for packers used in malware, which malware authors often customize or design from
    scratch. To unpack such malware, you have to build your own unpacking tool, unpack
    the malware manually (for instance, by using a debugger to locate the jump to
    OEP and then dumping the code to disk), or use a generic unpacker, as you’ll see
    next.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Generic unpackers rely on common (but not foolproof) runtime patterns indicative
    of packers to try to detect the jump to the original entry point and then dump
    the memory region that contains the OEP (and ideally the rest of the code) to
    disk. The automatic unpacker you’ll see in a moment is a simple generic unpacker.
    It assumes that when you run a packed binary, the bootstrap code unpacks the original
    code completely, writes it into memory, and later transfers control to the OEP
    in the previously written code. When the unpacker detects that control transfer,
    it dumps the targeted memory region to disk.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how packers work and have a high-level intuition of the automatic
    unpacker’s behavior, let’s implement the automatic unpacker with Pin. After that,
    you’ll learn how to use it to unpack a UPX-packed binary.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '*9.5.2 The Unpacker’s Data Structures and Setup Code*'
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s begin by taking a look at the unpacker’s setup code and the data structures
    it revolves around. [Listing 9-8](ch09.xhtml#ch09list8) shows the first part of
    the unpacker’s code, omitting standard C++ includes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-8:* unpacker.cpp'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The unpacker tracks memory activity by logging written or executed memory bytes
    in a `struct` type called `mem_access_t` ➊, which records the type of memory access
    (write or execute) and the value of written bytes. Later in the unpacking process,
    when dumping memory to disk, the unpacker needs to cluster adjacent memory bytes.
    It uses a second `struct` type called `mem_cluster_t` ➋ to cluster those bytes,
    recording the base address, size, and access permissions of the memory cluster.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: There are four global variables ➌. First, there’s a log file where the unpacker
    logs details on the unpacking progress and the written memory regions. Then there’s
    a global `std::map` called `shadow_mem`, which is a “shadow memory” that maps
    memory addresses to `mem_access_t` objects that detail the accesses and writes
    to each address. The `std::vector` called `clusters` is where the unpacker stores
    all the unpacked memory clusters it’s found, and `saved_addr` is a temporary variable
    that’s needed for storing state between two analysis routines.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Note that `clusters` can contain multiple unpacked memory regions because some
    binaries may have multiple layers of packing. In other words, you can pack an
    already packed binary again with another packer. When the unpacker detects a control
    transfer to a previously written memory region, it has no way of knowing whether
    that’s the jump to the OEP or simply a jump to the bootstrap code of the next
    packer. Therefore, the unpacker dumps all of the candidate regions it finds to
    disk, leaving you to figure out which dumped file is the final unpacked binary.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'The unpacker has only one command line option ➍: a `string` knob where you
    can specify the name of the log file. By default, the log file is named *unpacker.log*
    .'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll see shortly, the unpacker registers one fini function called `fini`
    ➎, which calls `print_clusters` to print a summary of all the memory clusters
    the unpacker found to the log file. I won’t show the listing of that function
    here because it doesn’t use any Pin functionality, but you’ll see its output when
    we test the unpacker.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The unpacker’s `main` function is similar to the profiler’s you saw previously.
    It initializes Pin ➏, skipping symbol initialization since the unpacker doesn’t
    use symbols. Next, it opens the log file ➐, registers an instruction-level instrumentation
    routine called `instrument_mem_cflow` ➑ and the fini function ➒, and finally starts
    the packed application running ➓.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the instrumentation that `instrument_mem_cflow` adds to the
    packed program to track its memory access and control flow activity.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '*9.5.3 Instrumenting Memory Writes*'
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 9-9](ch09.xhtml#ch09list9) shows how `instrument_mem_cflow` instruments
    memory writes and control-flow instructions.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-9:* unpacker.cpp *(continued)*'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first three analysis callbacks that `instrument_mem_cflow` inserts (at ➊
    through ➑) are for tracking memory writes. It adds these callbacks only for instructions
    for which `INS_IsMemoryWrite` and `INS_hasKnownMemorySize` are both true ➊. The
    first of these, `INS_IsMemoryWrite`, tells you whether an instruction writes to
    memory, while `INS_hasKnownMemorySize` tells you whether the size (in bytes) of
    the write is known. That’s important because the unpacker records written bytes
    in `shadow_mem`, and it can copy the right number of bytes only if the write size
    is known. Because memory writes with an unknown size occur only for special-purpose
    instructions, such as MMX and SSE instructions, the unpacker simply ignores them.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: For every memory write, the unpacker needs to know the written address and the
    write size so that it can record all the written bytes. Unfortunately, in Pin
    the write address is known only *before* the memory write happens (at `IPOINT_BEFORE`),
    but you can’t copy the written bytes until after the write is done. That’s why
    `instrument_mem_cflow` inserts multiple analysis routines for every write.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: First, it adds an analysis callback to `queue_memwrite` before every memory
    write ➋, which saves the write’s effective address (`IARG_MEMORYWRITE_EA` ➌) into
    the global `saved_addr` variable. Then, for memory write instructions that have
    a fallthrough edge ➍, `instrument_mem_cflow` instruments that fallthrough edge
    with a callback to `log_memwrite` ➎, which records all the written bytes in `shadow_mem`.
    The `IARG_MEMORYWRITE_SIZE` parameter ➏ tells `log_memwrite` how many bytes to
    record, starting from the `saved_addr` that `queue_memwrite` saved before the
    write. Similarly, for writes that happen as part of a branch or call ➐, the unpacker
    adds an analysis callback to `log_memwrite` on the taken edge ➑, ensuring that
    the write will be recorded regardless of which branch direction the application
    takes at runtime.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '*9.5.4 Instrumenting Control-Flow Instructions*'
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Recall that the unpacker’s goal is to detect the control transfer to the original
    entry point and then dump the unpacked binary to disk. To that end, `instrument_mem_cflow`
    instruments indirect branches and calls ➒ with a call-back to `check_indirect_ctransfer`
    ➓, an analysis routine that checks whether the branch targets a previously writable
    memory region and, if so, marks it as a possible jump to OEP and dumps the targeted
    memory region to disk.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Note that for optimization, `instrument_mem_cflow` instruments only indirect
    control transfers because many packers use indirect branches or calls to jump
    to the unpacked code. This may not be true for all packers, and you can easily
    change `instrument_mem_cflow` to instrument all control transfers instead of only
    indirect ones, but this will be at the cost of a significant performance hit.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '*9.5.5 Tracking Memory Writes*'
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 9-10](ch09.xhtml#ch09list10) shows the analysis routines responsible
    for recording memory writes, which you’ve already seen in the previous sections.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-10:* unpacker.cpp *(continued)*'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The first of the analysis routines, `queue_memwrite` ➊, is called before every
    memory write and stores the write’s address in the global variable `saved_addr`.
    Recall that this is necessary because Pin allows you to inspect the write’s address
    only at `IPOINT_BEFORE`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: After every memory write (on the fallthrough or taken edge), there’s a callback
    to `log_memwrite` ➋, which records all the written bytes in `shadow_mem`. It first
    retrieves the write’s base address by reading `saved_addr` ➌ and then loops over
    all the written addresses ➍. It marks each address as written in `shadow_mem`
    ➎ and calls `PIN_SafeCopy` to copy the value of the written byte from application
    memory into `shadow_mem` ➏.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Note that the unpacker must copy all written bytes into its own memory because
    when it later dumps unpacked memory to disk, the application may have already
    deallocated part of that memory region. When copying bytes from application memory,
    you should always use `PIN_SafeCopy` because Pin may modify some memory contents.
    If you read from application memory directly, you’d see the contents written by
    Pin, which is usually not what you want. In contrast, `PIN_SafeCopy` will always
    show you the memory state as written by the original application and will also
    safely handle cases where memory regions are inaccessible without causing a segmentation
    fault.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: You may notice that the unpacker ignores the return value of `PIN _SafeCopy`,
    which indicates the number of bytes it successfully read. For the unpacker, there’s
    nothing it can do if a read from application memory fails; the unpacked code will
    simply be corrupted. In other Pintools, you’ll want to check the return value
    and handle errors gracefully.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '*9.5.6 Detecting the Original Entry Point and Dumping the Unpacked Binary*'
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The ultimate goal of the unpacker is to detect the jump to the OEP and dump
    the unpacked code. [Listing 9-11](ch09.xhtml#ch09list11) shows the analysis routine
    that implements this.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-11:* unpacker.cpp *(continued)*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When `check_indirect_ctransfer` detects a suspected jump to OEP, it builds a
    memory cluster ➊ of all the consecutive bytes surrounding the OEP and dumps that
    to disk. Because `check_indirect_ctransfer` is called only on control-flow instructions,
    it always marks the target address as executable ➋. If the target address lies
    within a once-written memory region ➌, then this may be a jump to OEP, and the
    unpacker proceeds to dump the targeted memory region if it hasn’t already done
    so. To check whether the region has been dumped before, the unpacker calls `in_cluster`
    ➍, which checks whether there’s already a memory cluster containing the target
    address. I won’t discuss `in_cluster`’s code here since it doesn’t use any Pin
    functionality.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f258-01.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-7: Building a memory cluster after a control transfer to a candidate
    OEP*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: If the targeted region isn’t unpacked yet, `check_indirect_ctransfer` calls
    `set_cluster` ➎ to cluster the memory around the suspected OEP into a contiguous
    chunk it can dump to disk and stores that chunk into `clusters` ➏, the global
    list of all unpacked regions. I won’t go over `set_cluster`’s code here, but [Figure
    9-7](ch09.xhtml#ch09fig7) illustrates how it simply searches backward and forward
    in `shadow_mem` starting from the suspected OEP, expanding the cluster across
    all neighboring bytes that have been written, until it hits a “gap” of unwritten
    memory locations.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Next, `check_indirect_ctransfer` unpacks the just-built memory cluster by dumping
    it to disk ➐. Rather than assuming that the unpacking was successful and exiting
    the application, the unpacker continues just as it did before because there might
    be another layer of packing to discover and unpack.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '*9.5.7 Testing the Unpacker*'
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s test the automatic unpacker by using it to unpack an executable packed
    with UPX, a well-known packer that you can install on Ubuntu with `apt install
    upx`. [Listing 9-12](ch09.xhtml#ch09list12) shows how to pack a test binary with
    UPX (the *Makefile* for this chapter does this automatically).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-12: Packing* /bin/ls *with UPX*'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For this example, let’s copy */bin/ls* to a file called *packed* ➊ and then
    pack it with UPX ➋. UPX reports that it successfully packed the binary and compressed
    it to 45.18 percent of its original size ➌. You can confirm that a binary is packed
    by viewing it in IDA Pro, as shown in [Figure 9-8](ch09.xhtml#ch09fig8). As you
    can see, the packed binary contains a much smaller number of functions than most
    binaries; IDA finds only four functions because all others are packed. You can
    also use IDA to see that there’s a large region of data containing the packed
    code and data (not shown in the figure).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f260-01.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-8: The packed binary as shown in IDA Pro*'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s test the unpacker’s ability to recover *ls*’s original code and data
    from the packed binary. [Listing 9-13](ch09.xhtml#ch09list13) shows how to use
    the unpacker.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-13: Testing the binary unpacker*'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To use the unpacker, you call `pin` with the unpacker as the Pintool and the
    packed binary (*packed*) as the application ➊. The application now runs with the
    unpacker’s instrumentation and, because it’s a copy of */bin/ls*, prints a directory
    listing ➋. You can see that the directory listing contains several unpacked files,
    each of which uses a naming scheme that indicates the dumped region’s start and
    end address and the entry point address detected by the instrumentation code.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: The log file *unpacker.log* details the extracted regions and lists all the
    memory clusters (even the ones that weren’t unpacked) that the unpacker found
    ➌. Let’s take a more detailed look at the largest unpacked file ➍, named *unpacked.0x400000-0x41da64_entry-0x40000c*.^([15](footnote.xhtml#ch09fn_15))
    Using `file`, you can tell it’s an ELF binary ➎, although a somewhat “damaged”
    one in the sense that ELF binaries’ memory representation doesn’t correspond directly
    to the on-disk representation that utilities like `file` expect. For example,
    the section header table isn’t available at runtime, so there’s no way for the
    unpacker to recover it. Nevertheless, let’s see if IDA Pro and other utilities
    can parse the unpacked file.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Figure 9-9](ch09.xhtml#ch09fig9), IDA Pro manages to find a lot
    more functions in the unpacked binary than it did in the packed one, which is
    promising.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f261-01.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: '*Figure 9-9: The unpacked binary as shown in IDA Pro*'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, you can use `strings` to see that the unpacked binary contains many
    human-readable strings that suggest a successful unpack, as shown in [Listing
    9-14](ch09.xhtml#ch09list14).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-14: Strings found in the unpacked binary*'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Recall from [Chapter 5](ch05.xhtml#ch05) that `strings` ➊ is a Linux utility
    that shows you human-readable strings that it finds in any file. For the unpacked
    binary, `strings` shows the usage instructions for */bin/ls* ➋ (among many other
    strings).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: As a final sanity check, let’s use `objdump` to compare the unpacked code to
    *ls*’s original code. [Listing 9-15](ch09.xhtml#ch09list15) shows part of the
    original `main` function in */bin/ls*, and [Listing 9-16](ch09.xhtml#ch09list16)
    shows the corresponding unpacked code.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: To disassemble the original binary, you can use `objdump` normally ➊, but for
    the unpacked binary you need to pass some special options ➋ telling `objdump`
    to treat the file as a raw binary containing x86-64 code and to disassemble all
    of the file’s contents (`-D` instead of the usual `-d`). That’s necessary because
    the unpacked binary doesn’t contain a section header table that `objdump` can
    use to figure out where the code sections are.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 9-15: Partial disassembly of* main *in the original* /bin/ls'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 9-16: Partial disassembly of* main *in the unpacked binary*'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Comparing [Listings 9-15](ch09.xhtml#ch09list15) and [9-16](ch09.xhtml#ch09list16)
    side by side, you can see that the code is identical, except for code addresses
    at ➌ and ➍. That’s because `objdump` isn’t aware of the unpacked binary’s expected
    load address because of the missing section header table. Note that in the unpacked
    binary, `objdump` is also unable to automatically annotate calls to PLT stubs
    with the corresponding function names. Fortunately, disassemblers like IDA Pro
    allow you to manually specify a load address so that after some configuration,
    you can reverse engineer the unpacked binary just like you would a normal one!
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 9.6 Summary
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you learned how binary instrumentation techniques work and
    how to instrument binaries with Pin. You should now be ready to build your own
    Pintools to analyze and modify binaries at runtime. You’ll see Pin again in [Chapters
    10](ch10.xhtml#ch10) through [13](ch13.xhtml#ch13) when I cover taint analysis
    and symbolic execution platforms that build on Pin.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Extending the Profiler
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: The profiler records all syscalls, even ones that happen outside of the main
    application. Modify the profiler to check where a syscall originated and profile
    only those that originate in the main application. To find out how to do this,
    you’ll have to consult the Pin user manual online.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Investigating Unpacked Files
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: When you were testing the unpacker, it dumped several files, one of which was
    the unpacked */bin/ls*. Investigate what the other files contain and why the unpacker
    dumped them.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Extending the Unpacker
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Add a command line option to the automatic unpacker that, when enabled, causes
    it to instrument *all* control transfers, rather than just indirect ones, to look
    for the jump to OEP. Compare the runtimes of the unpacker with and without this
    option enabled. How would a packer that jumps to OEP with a direct control transfer
    work?
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Dumping Decrypted Data
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: Build a Pintool that can monitor an application and automatically detect and
    dump data when the application decrypts it with RC4 (or another cryptographic
    algorithm of your choice). Your Pintool is allowed to report false positives (bogus
    data that’s not really decrypted) but should try to minimize them.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
