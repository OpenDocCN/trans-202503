["```\nFor all 219 values of LFSR 1's initial state\n    For all 222 values of LFSR 2's initial state\n        For all 211 values of LFSR 3's clocking bit during the first 11 clocks\n            Reconstruct LFSR 3's initial state\n            Test whether guess is correct; if yes, return; else continue\n```", "```\nj = 0\n# Set S to the array S[0] = 0, S[1] = 1, . . . , S[255] = 255.\nS = range(256)\n# Iterate over i from 0 to 255.\nfor i in range(256):\n    # Compute the sum of v.\n    j = (j + S[i] + K[i % n]) % 256\n    # Swap S[i] and S[j].\n    S[i], S[j] = S[j], S[i]\n```", "```\ni = 0\nj = 0\nfor b in range(m):\n    i = (i + 1) % 256\n    j = (j + S[i]) % 256\n    S[i], S[j] = S[j], S[i]\n    KS[b] = S[(S[i] + S[j]) % 256]\n```", "```\n61707865 00000000 00000000 00000000      61707865 00000000 00000000 00000000\n00000000 3320646e ffffffff ffffffff      00000000 3320646e ffffffff ffffffff\n**00000000** 00000000 79622d32 00000000      **00000001** 00000000 79622d32 00000000\n00000000 00000000 00000000 6b206574      00000000 00000000 00000000 6b206574\n```", "```\ne98680bc f730ba7a 38663ce0 5f376d93      1ba4d492 c14270c3 9fb05306 ff808c64\n85683b75 a56ca873 26501592 64144b6d      b49a4100 f5d8fbbd 614234a0 e20663d1\n6dcb46fd 58178f93 8cf54cfe cfdc27d7      12e1e116 6a61bc8f 86f01bcb 2efead4a\n68bbe09e 17b403a1 38aa1f27 54323fe0      77775a13 d17b99d5 eb773f5b 2c3a5e7d\n```", "```\nbuf = S[i]\nS[i] = S[j]\nS[j] = buf\n```", "```\nx = x <samp class=\"SANS_DejaVu_Sans_Book_I_11\">⊕</samp> y\ny = x <samp class=\"SANS_DejaVu_Sans_Book_I_11\">⊕</samp> y\nx = x <samp class=\"SANS_DejaVu_Sans_Book_I_11\">⊕</samp> y\n```", "```\n#define TOBYTE(x) (x) & 255\n#define SWAP(x,y) do {x^=y; y^=x; x^=y;} while (0)\n\nstatic unsigned char S[256];\nstatic int i=0, j=0;\n\nvoid init(char *passphrase) {\n    int passlen = strlen(passphrase);\n    for (i=0; i<256; i++)\n        S[i] = i;\n    for (i=0; i<256; i++) {\n        j = TOBYTE(j + S[TOBYTE(i)] + passphrase[j % passlen]);\n        SWAP(S[TOBYTE(i)], S[j]);\n    }\n    i = 0; j = 0;\n}\n\nunsigned char encrypt_one_byte(unsigned char c) {\n    int k;\n    i = TOBYTE(i+1);\n    j = TOBYTE(j + S[i]);\n    SWAP(S[i], S[j]);\n    k = TOBYTE(S[i] + S[j]);\n    return c ^ S[k];\n}\n```"]