- en: '**8**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**MANIPULATING CONTROL FLOW IN A GAME**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Forcing a game to execute foreign code is definitely powerful, but what if you
    could alter the way a game executes its own code? What if you could force the
    game to bypass the code that draws the fog of war, trick it into making enemies
    visible through walls, or manipulate the arguments it passes to functions? *Control
    flow manipulation* lets you do exactly that, allowing you to change what a process
    does by intercepting code execution and monitoring, modifying, or preventing it.
  prefs: []
  type: TYPE_NORMAL
- en: There are many ways to manipulate the control flow of a process, but almost
    all require you to modify the process’s assembly code. Depending on your goals,
    you’ll need to either completely remove code from the process (called *NOPing*)
    or force the process to redirect execution to injected functions (called *hooking*).
    In the beginning of this chapter, you’ll learn about NOPing, several types of
    hooking, and other control flow manipulation techniques. Once I’ve explained the
    basics, I’ll show you how I’ve applied these principles to common game libraries
    like Adobe AIR and Direct3D.
  prefs: []
  type: TYPE_NORMAL
- en: Open the directory *GameHackingExamples/Chapter8_ControlFlow* in this book’s
    resource files to see the complete sample code for the next section and “[Hooking
    to Redirect Game Execution](ch08.xhtml#ch00lev1sec151)” on [page 153](ch08.xhtml#page_153).
  prefs: []
  type: TYPE_NORMAL
- en: '**NOPing to Remove Unwanted Code**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Chapter 7](ch07.xhtml#ch07) described how to inject new code into a game,
    but the opposite—removing code from a game—can also be useful. Some hacks require
    you to stop some of a game’s original code from being executed, and to do that,
    you’ll have to get rid of it. One way to eliminate code from a game process is
    NOPing, which involves overwriting the original x86 assembly code with NOP instructions.'
  prefs: []
  type: TYPE_NORMAL
- en: '***When to NOP***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider a game that won’t show the health bars of cloaked enemies. It’s pretty
    hard to see cloaked enemies coming, and you’d have a huge advantage in combat
    if you could at least see their health bars. The code to draw health bars often
    looks like [Listing 8-1](ch08.xhtml#ch8exe1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-1: The loop from the* `drawCreatureHealthBarExample()` *function*'
  prefs: []
  type: TYPE_NORMAL
- en: When drawing health bars, a game with cloaked creatures might use a `for` loop
    to check whether the creatures within the screen’s bounds are cloaked. If an enemy
    isn’t cloaked, the loop calls some function (`drawHealthBar()` in this example)
    to display the enemy’s health bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the source code, you could force the game to draw even cloaked enemies’
    health bars by simply removing `if (c.isEnemy && c.isCloaked) continue;` from
    the code. But as a game hacker, you have only the assembly code, not the source
    code. When simplified, the assembly that [Listing 8-1](ch08.xhtml#ch8exe1) translates
    into looks something like this pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To trick the game into drawing all enemy health bars, regardless of cloaking,
    you’d need to remove the `JMP increment` command ➊ that executes when `c.isEnemy
    && c.isCloaked` evaluates to `true`. In assembly, though, replacing unwanted code
    with instructions that do nothing is easier than deleting code. That’s where the
    NOP command comes in. Since NOP is a single byte (0x90), you can overwrite the
    2-byte `JMP increment` command with two NOP commands. When the processor reaches
    those NOP commands, it rolls over them and falls into `drawHealthBar()` even when
    `c.isEnemy && c.isCloaked` evaluates to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '***How to NOP***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The first step to NOPing a chunk of assembly code is making the memory chunk
    where the code lives writable. It’s possible for the code on the same memory page
    to be executed while you’re writing the NOP commands, though, so you also want
    to make sure the memory is still executable. You can accomplish both of these
    tasks by setting the memory’s protection to `PAGE_EXECUTE_READWRITE`. Once the
    memory is properly protected, you can write the NOP commands and be done. It technically
    doesn’t hurt to leave the memory writable, but it’s good practice to also restore
    the original protection when you’re finished.
  prefs: []
  type: TYPE_NORMAL
- en: Provided you have facilities in place for writing and protecting memory (as
    described in [Chapter 6](ch06.xhtml#ch06)), you can write a function like the
    one shown in [Listing 8-2](ch08.xhtml#ch8exe2) to write NOP commands to game memory.
    (Follow along by opening the project’s *NOPExample.cpp* file.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-2: Proper NOPing, complete with memory protection*'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, the `writeNop()` function sets the appropriate memory protection,
    writes a number of NOP commands equal to `SIZE`, and reapplies the original memory
    protection level.
  prefs: []
  type: TYPE_NORMAL
- en: The `writeNop()` function takes the number of NOP instructions to place as a
    template parameter, since the memory functions require a correctly sized type
    at compile time. Passing an integer `SIZE` tells the memory functions to operate
    on a type of `BYTE[SIZE]` at compile time. To specify a dynamic size at runtime,
    simply drop the loop and instead call `protectMemory<BYTE>` and pass `address`
    and `address + SIZE` as arguments. As long as the size isn’t larger than a page
    (and really, you shouldn’t be NOPing a full page), this will ensure that the memory
    gets properly protected even if it’s on a page boundary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call this function with the address where you want to place your NOPs and the
    number of NOP commands to place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that the number of NOP commands should match the size in bytes
    of the command being removed. This call to `writeNop()` writes two NOP commands
    to the address 0xDEADBEEF.
  prefs: []
  type: TYPE_NORMAL
- en: '**PRACTICE NOPING**'
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t already, open *NOPExample.cpp* in this chapter’s example code
    now and play around with it for a bit. You’ll find a working implementation of
    the `writeNop()` function and an interesting function called `getAddressforNOP()`
    that scans the example program’s memory to find where the NOP command should be
    placed.
  prefs: []
  type: TYPE_NORMAL
- en: To see the NOP command in action, run the compiled NOPapplication in Visual
    Studio’s debugger with breakpoints at the start and end of the `writeNop()` function.
    When the first breakpoint is hit, press ALT-8 to open the disassembly window,
    enter `address` in the input box, and press ENTER. This brings you to the NOP’s
    target address, where you’ll see the assembly code fully intact. Press F5 to continue
    execution, which triggers the second breakpoint after allowing the application
    to place the NOPs. Finally, jump back to `address` in the disassembly tab to see
    that the code was replaced by NOPs.
  prefs: []
  type: TYPE_NORMAL
- en: You can rework this code to do other cool stuff. For example, you might try
    placing NOPs on the comparisons instead of the jump or even modifying the jump’s
    type or destination.
  prefs: []
  type: TYPE_NORMAL
- en: These and other alternative approaches may work, but note that they introduce
    more room for error than overwriting the single JMP with NOP commands. When modifying
    foreign code, make as few changes as possible to minimize the potential for errors.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hooking to Redirect Game Execution**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, I’ve shown you how to manipulate games by adding code to them, hijacking
    their threads, creating new threads, and even removing existing code from their
    execution flow. These methods are very powerful on their own, but when combined,
    they form an even more potent method of manipulation called *hooking*. Hooking
    allows you to intercept precise branches of execution and redirect them to injected
    code that you’ve written to dictate what the game should do next, and it comes
    in a variety of flavors. In this section, I’ll teach you about four of the most
    powerful hooking methods for game hacking: call hooking, virtual function table
    hooking, import address table hooking, and jump hooking.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Call Hooking***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A *call hook* directly modifies the target of a `CALL` operation to point to
    a new piece of code. There are a few variations of the `CALL` operation in x86
    assembly, but call hooks are generally used on only one: the *near call*, which
    takes an immediate address as an operand.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Working with Near Calls in Memory**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In an assembly program, a near call looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This near call is represented by the byte 0xE8, so you might assume it is stored
    in memory like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, when split into single bytes and swapped for endianness, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'But the anatomy of a near call in memory is not that simple. Instead of storing
    the callee’s absolute address, a near call stores an offset to the callee relative
    to the address immediately after the call. Since a near call is 5 bytes, the address
    immediately after the call is 5 bytes later in memory. Given that, the address
    stored can be computed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If `CALL 0x0BADF00D` lives at 0xDEADBEEF in memory, then the value after 0xE8
    is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In memory, then, that `CALL` instruction looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To hook a near call, you first need to change the offset following 0xE8 (that
    is, the little-endian 0x19 0x31 0x00 0x2D) to point to your new callee.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hooking a Near Call**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Following the same memory protection rules shown in [Listing 8-2](ch08.xhtml#ch8exe2),
    you hook a near call like so (follow along by opening *CallHookExample.cpp*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This function takes as arguments the address of the `CALL` to hook (`hookAt`)
    and the address to redirect execution to (`newFunc`), and it uses them to calculate
    the offset required to call the code at the address `newFunc` contains. After
    you apply the correct memory protections, the `callHook()` function writes the
    new offset to the memory at `hookAt + 1` ➊, applies the old memory protections,
    calculates the address of the original call ➋, and returns that value to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how you might actually use a function like this in a game hack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This hooks the near call to 0x0BADF00D at 0xDEADBEEF and redirects it to the
    address of `someNewFunction`, which is the code your hack will execute. After
    this is called, the `origFunc` value will hold 0x0BADF00D.
  prefs: []
  type: TYPE_NORMAL
- en: '**Cleaning Up the Stack**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The new callee must also properly handle the stack, preserve registers, and
    pass proper return values. At the least, this means your replacement function
    must match the game’s original function in both calling convention and argument
    count.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say this is the original full function call, in assembly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can tell the function has the C++ `__cdecl` convention because the stack
    is being reset by the caller. Additionally, the 0x0C bytes being cleaned from
    the stack show that there are three arguments, which you can calculate as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0155-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Of course, you can also obtain the number of arguments by checking how many
    things are pushed to the stack: there are three `PUSH` commands, one for each
    argument.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing a Call Hook**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In any case, the new callee, `someNewFunction`, must follow the `__cdecl` convention
    and have three arguments. Here’s an example skeleton for the new callee:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In Visual Studio, C++ programs use the `__cdecl` convention by default, so technically
    you could omit it from your function definition; however, I’ve found it’s better
    to be verbose so you get into the habit of being specific. Also keep in mind that
    if the caller expects a value to be returned, the return type of your function
    should match as well. This example assumes the return type is always a `DWORD`
    or smaller. Since return types in this size range will all be passed back on EAX,
    further examples will also use a return type of `DWORD`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, a hook finishes by calling the original function and passing
    its return value back to the caller. Here’s how all of that might fit together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This example uses `typedef` to declare a type representing the original function’s
    prototype and creates a pointer with this type to the original function. Then
    `someNewFunction()` uses this pointer to call the original function with the original
    arguments and pass the returned value back to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, all `someNewFunction()` does is return to the original function.
    But you can do whatever you want from inside the `someNewFunction()` call from
    here. You can modify the parameters being passed to the original function or intercept
    and store interesting parameters for later use. If you know the caller isn’t expecting
    a return value (or if you know how to spoof the return value), you can even forget
    about the original function and completely replace, replicate, or improve its
    functionality inside the new callee. Once you’ve perfected this skill, you can
    add your own native C or C++ code to any part of a game that you wish.
  prefs: []
  type: TYPE_NORMAL
- en: '***VF Table Hooking***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unlike call hooks, *virtual function (VF) table hooks* don’t modify assembly
    code. Instead, they modify the function addresses stored in the VF tables of classes.
    (If you need a refresher on VF tables, see “[A Class with Virtual Functions](ch04.xhtml#ch00lev1sec78)”
    on [page 75](ch04.xhtml#page_75).) All instances of the same class type share
    a static VF table, so VF table hooks will intercept all calls made to a member
    function, regardless of which class instance the game is calling the function
    from. This can be both powerful and tricky.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE TRUTH ABOUT VF TABLES**'
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the explanation, I lied a little when I said that VF table hooks
    could intercept all calls made to a function. In reality, the VF table is traversed
    only when a virtual function is called in a way that leaves the compiler with
    some plausible type ambiguity. For example, a VF table will be traversed when
    a function is called through the `inst->function()` call format. A VF table won’t
    be traversed when a virtual function is invoked in such a way that the compiler
    is sure about the type, as in `inst.function()` or similar calls, since the compiler
    will know the function’s address. Conversely, calling `inst.function()` from a
    scope where `inst` is passed in as a reference would trigger a VF table traversal.
    Before you try to deploy VF table hooking, make sure the function calls you want
    to hook have type ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing a VF Table Hook**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Before we go any deeper into how to place a VF table hook, we need to talk about
    those pesky calling conventions again. VF tables are used by class instances to
    call virtual member functions, and all member functions will have the `__thiscall`
    convention. The name `__thiscall` is derived from the `this` pointer that member
    functions use to reference the active class instance. Thus, member functions are
    given `this` as a pseudoparameter on ECX.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to match the prototype of a `__thiscall` by declaring a class
    that acts as a container for all `__thiscall` hook callbacks, but I don’t prefer
    this method. Instead, I find it easier to control the data using inline assembly.
    Let’s explore how you control the data when placing a VF hook on a class that
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `someBaseClass` class just has one member (a public virtual function), and
    the `someClass` class inherits from `someBaseClass` and overrides the `someBaseClass::someFunction`
    member. To hook `someClass::someFunction`, you replicate the prototype in your
    VF table hook, as shown in [Listing 8-3](ch08.xhtml#ch8exe3) (follow along in
    the *VFHookExample.cpp* file of the project).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-3: The start of a VF table hook*'
  prefs: []
  type: TYPE_NORMAL
- en: This function works as a hook because `__thiscall` only differs from `__stdcall`
    in that the former is given `this` on ECX. To reconcile this small difference,
    the callback function uses inline assembly (denoted by `__asm`) to copy `this`
    from ECX to a static variable ➊. Since the static variable is actually initialized
    as a global, the only code that executes before `MOV _this, ECX` is the code that
    sets up the stack frame—and that code never touches ECX. That ensures that the
    proper value is in ECX when the assembly is executed.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If multiple threads start calling the same VF function, the* `someNewVFFunction()`
    *hook will break because* `_this` *might be modified by one call while still being
    used by another call. I’ve never personally run into this problem, as games don’t
    typically throw around multiple instances of critical classes between threads,
    but an efficient remedy would be to store* `_this` *in thread local storage, ensuring
    each thread would have its own copy.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before returning, a VF table callback must also restore ECX, to keep with the
    `__thiscall` convention. Here’s how that process looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: After executing some game-hacking code, this version of the function `someNewVFFunction()`
    restores ECX ➊ with a reversed version of the first `MOV` instruction from [Listing
    8-3](ch08.xhtml#ch8exe3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike with `__cdecl` functions, however, you shouldn’t call functions that
    use the `__thiscall` convention from pure C++ using only a function pointer and
    `typedef` (as you would for a call hook). When calling the original function from
    a VF table hook, you must use inline assembly—that’s the only way to be sure you’re
    passing data (specifically `_this`) around properly. For example, this is how
    you continue to build the `someNewVFFunction()` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, `someNewVFFunction()` stores `this` in the `_this` variable, allows some
    code to execute, calls the original game function ➊ that’s being hooked, stores
    that function’s return value in `_ret` ➋, allows some more code to execute, restores
    `this` to ECX ➌, and returns the value stored in `_ret`. The callee cleans the
    stack for `__thiscall` calls, so unlike a call hook, the pushed argument doesn’t
    need to be removed.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you want to remove a single pushed argument at any point, use the assembly
    instruction* `ADD ESP, 0x4` *because a single argument is 4 bytes.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using a VF Table Hook**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'With the calling convention established and a skeleton callback in place, it’s
    time to move on to the fun part: actually using a VF table hook. A pointer to
    a class’s VF table is the first member of every class instance, so placing a VF
    table hook requires only a class instance address and the index of the function
    to be hooked. Using these two pieces of information, you need only a modest amount
    of code to place a hook. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `hookVF()` function finds the VF table by reading the first member of the
    class instance ➊ and storing it in `VFTable`. Since the VF table is just an array
    of `DWORD`-sized addresses, this code finds the function address by multiplying
    the function’s index in the VF table (`funcIndex` in this example) by the size
    of a `DWORD`, which is 4, and adding the result to the VF table’s address. From
    there, `hookVF()` acts similar to a call hook: it makes sure the memory is properly
    accessible by setting appropriate protections, stores the original function address
    for later, writes the new function address, and finally, restores the original
    memory protection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll typically hook the VF table of a class instantiated by the game, and
    calling a function like `hookVF()` for a VF table hook looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As usual, you need to find `classInstAddr` and the `funcIndex` argument ahead
    of time.
  prefs: []
  type: TYPE_NORMAL
- en: There are some very niche cases in which VF table hooks are useful, and it can
    be really hard to find the right class pointers and functions. Given that, instead
    of showing contrived use cases, I’ll come back to VF table hooks in “[Applying
    Jump Hooks and VF Hooks to Direct3D](ch08.xhtml#ch00lev1sec174)” on [page 175](ch08.xhtml#page_175),
    once I’ve discussed other types of hooking.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to play with VF hooks before reading more, add new virtual functions
    to the example classes in this book’s resource files and practice hooking them.
    You might even create a second class that derives from `someBaseClass` and place
    a hook on its virtual table to demonstrate how you can have two completely separate
    VF hooks on two classes that inherit the same base class.
  prefs: []
  type: TYPE_NORMAL
- en: '***IAT Hooking***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: IAT hooks actually replace function addresses in a specific type of VF table,
    called the *import address table (IAT)*. Each loaded module in a process contains
    an IAT in its PE header. A module’s IAT holds a list of all the other modules
    on which the module depends, as well as a list of functions that the module uses
    from each dependency. Think of an IAT as a lookup table for APIs to call one another.
  prefs: []
  type: TYPE_NORMAL
- en: When a module is loaded, its dependencies are also loaded. Dependency loading
    is a recursive process that continues until all dependencies for all modules are
    loaded. As each dependency is loaded, the operating system finds all functions
    used by the dependent module and fills any blank spaces in its IAT with the function
    addresses. Then, when a module calls a function from a dependency, it makes that
    call by resolving the function’s address from the IAT.
  prefs: []
  type: TYPE_NORMAL
- en: '**Paying for Portability**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Function addresses are always resolved from the IAT in real time, so hooking
    the IAT is similar to hooking VF tables. Since function pointers are stored in
    the IAT beside their actual names, there’s no need to do any reverse engineering
    or memory scanning; as long as you know the name of the API you want to hook,
    you can hook it! Moreover, IAT hooking lets you easily hook Windows API calls
    on a module-specific basis, allowing your hooks to intercept only API calls from
    a game’s main module.
  prefs: []
  type: TYPE_NORMAL
- en: This portability has a cost, though; the code to place an IAT hook is much more
    complex than what you’ve seen so far. First, you need to locate the PE header
    of the game’s main module. Since the PE header is the first structure in any binary,
    you can find it at the base address of each module, as shown in [Listing 8-4](ch08.xhtml#ch8exe4)
    (follow along in the *IATHookExample.cpp* file of the project).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-4: Fetching the module’s base address*'
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve found the base address, you must verify that the PE header is valid.
    This validation can be very important, as some games try to prevent these types
    of hooks by scrambling nonessential parts of their PE header after they load.
    A valid PE header is prefixed by a DOS header, which indicates the file is a DOS
    MZ executable; the DOS header is identified by the magic value 0x5A4D. A member
    of the DOS header called `e_lfanew` then points to the optional header, which
    contains values like the size of the code, a version number, and so on and is
    identified by the magic value 0x10B.
  prefs: []
  type: TYPE_NORMAL
- en: The Windows API has PE structures called `IMAGE_DOS_HEADER` and `IMAGE_OPTIONAL_HEADER`
    that correspond to the DOS header and optional header, respectively. You can use
    them to validate the PE header with code like [Listing 8-5](ch08.xhtml#ch8exe5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-5: Confirming the DOS and optional headers are valid*'
  prefs: []
  type: TYPE_NORMAL
- en: The calls to `pointMemory()` create pointers to the two headers that need to
    be checked. If either `if()` statement returns `0`, then the corresponding header
    has the wrong magic number, meaning the PE header isn’t valid.
  prefs: []
  type: TYPE_NORMAL
- en: References to the IAT from assembly are hardcoded, meaning assembly references
    don’t traverse the PE header to locate the IAT. Instead, each function call has
    a static location indicating where to find the function address. That means overwriting
    the PE header to say that there are no imports is a viable way to protect against
    IAT hooks, and some games have this protection.
  prefs: []
  type: TYPE_NORMAL
- en: To account for that, you also need to make sure the game’s IAT still exists.
    [Listing 8-6](ch08.xhtml#ch8exe6) shows how to add such a check to the code in
    [Listing 8-5](ch08.xhtml#ch8exe5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-6: Checking that the IAT actually exists*'
  prefs: []
  type: TYPE_NORMAL
- en: The PE header contains many sections that store information about the application’s
    code, embedded resources, relocations, and so on. The piece of code in [Listing
    8-6](ch08.xhtml#ch8exe6) is particularly interested in the data section, which—as
    you might guess—stores many different types of data. Each type of data is stored
    in its own directory, and the `DataDirectory` member of `IMAGE_OPTIONAL_HEADER`
    is an array of directory headers that describes the size and virtual address of
    each directory in the data section. The Windows API defines a constant called
    `IMAGE_DIRECTORY_ENTRY_IMPORT`, which happens to be the index of the IAT header
    within the `DataDirectory` array.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, this code uses `optHeader->DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]`
    to resolve the header of the IAT and check that the header’s `Size` and `VirtualAddress`
    are nonzero, essentially confirming its existence.
  prefs: []
  type: TYPE_NORMAL
- en: '**Traversing the IAT**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once you know the IAT is still intact, you can start traversing it, and this
    is where IAT hooking starts to get ugly. The IAT is an array of structures called
    *import descriptors*. There is one import descriptor for each dependency, each
    import descriptor points to an array of structures called *thunks*, and each thunk
    represents a function imported from the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, the Windows API exposes both the import descriptors and thunks through
    the `IMAGE_IMPORT_DESCRIPTOR` and `IMAGE_THUNK_DATA` structures, respectively.
    Having the structures predefined saves you from creating your own, but it doesn’t
    make the code to traverse the IAT any prettier. To see what I mean, look at [Listing
    8-7](ch08.xhtml#ch8exe7), which builds on [Listings 8-4](ch08.xhtml#ch8exe4) through
    [8-6](ch08.xhtml#ch8exe6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-7: Iterating over the IAT to find a function*'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping in mind that the import descriptors are stored relative to the start
    of the PE header, this code adds the module’s base address to the virtual address
    found in the IAT’s directory header ➊, creating a pointer, `impDesc`, that points
    to the module’s first import descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: Import descriptors are stored in a sequential array, and a descriptor with a
    `FirstThunk` member set to `NULL` signifies the end of the array. Knowing this,
    the code uses a `while` loop ➋ that continues until `impDesc->FirstThunk` is `NULL`,
    incrementing the descriptor by executing `impDesc++` each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: For each import descriptor, the code creates a pointer called `thunkData` ➌
    that points to the first thunk inside the descriptor. Using a familiar loop, the
    code iterates over thunks ➍ until one is found with a `Function` member set to
    `NULL`. The loop also uses an integer, `n`, to keep track of the current thunk
    index, as the index is important when placing the hook.
  prefs: []
  type: TYPE_NORMAL
- en: '**Placing the IAT Hook**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: From here, placing the hook is just a matter of finding the proper function
    name and replacing the function address. You can find the name inside the nested
    `while` loop, as shown in [Listing 8-8](ch08.xhtml#ch8exe8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-8: Finding the function name*'
  prefs: []
  type: TYPE_NORMAL
- en: The function name for each thunk is stored at `thunkData->u1.AddressOfData +
    2` bytes into the module, so you can add that value to the module’s base address
    to locate the function name in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'After obtaining a pointer to the function name, use `strcmp()` to check whether
    it’s the target function, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Once you’ve located the target function using its name, you simply need to overwrite
    the function address with the address of your own function. Unlike function names,
    function addresses are stored in an array at the start of each import descriptor.
    Using `n` from the thunk loop, you can finally set the hook, as shown in [Listing
    8-9](ch08.xhtml#ch8exe9).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-9: Finding the function address*'
  prefs: []
  type: TYPE_NORMAL
- en: This code locates the VF table for the current descriptor by adding the address
    of the first thunk to the module base address. The VF table is an array of function
    addresses, so the code uses the `n` variable as an index to locate the target
    function address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the address is found, the code in [Listing 8-9](ch08.xhtml#ch8exe9) works
    just like a typical VF hook: it stores the original function address, sets the
    protection of index `n` in the VF table to `PAGE_READWRITE` ➊, inserts the new
    function address into the VF table ➋, and finally restores the old protection.'
  prefs: []
  type: TYPE_NORMAL
- en: If you stitch together the code from [Listings 8-4](ch08.xhtml#ch8exe4) through
    [8-9](ch08.xhtml#ch8exe9), the final IAT hooking function looks like [Listing
    8-10](ch08.xhtml#ch8exe10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-10: The complete IAT hooking function*'
  prefs: []
  type: TYPE_NORMAL
- en: This is the most complex code that we’ve put together so far, and it’s pretty
    hard to read when squished to fit on a page. If you haven’t yet wrapped your head
    around what it’s doing, you might want to study the example code from this book’s
    resource files before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using an IAT Hook to Sync with a Game Thread**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: With the code in [Listing 8-10](ch08.xhtml#ch8exe10), hooking any Windows API
    function is as simple as knowing the function name and the proper prototype. The
    `Sleep()` API is a common API to hook when game hacking, as bots can use a `Sleep()`
    hook to thread-sync with a game’s main loop.
  prefs: []
  type: TYPE_NORMAL
- en: '**GETTING IN SYNC WITH THREAD SYNC**'
  prefs: []
  type: TYPE_NORMAL
- en: Your injected code will inevitably have to sync with a game’s main loop, or
    it won’t work. When you’re reading or writing data larger than 4 bytes, for example,
    being out of sync allows the game to read or write that data at the same time
    as you. You’ll be stepping on the game’s toes, and vice versa, leading to all
    sorts of race conditions and data corruption issues. Similarly, if you try to
    call a game’s function from your own thread, you run the risk of crashing the
    game if the function is not thread safe.
  prefs: []
  type: TYPE_NORMAL
- en: Since IAT hooks are thread-safe modifications to the PE header, they can be
    placed from any thread. By placing one on a function that’s called before or after
    the game’s main loop, you can effectively sync with the game’s main thread. All
    you need to do is place the hook and execute any thread-sensitive code from your
    hook callback.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one way to use `hookIAT()` to hook the `Sleep()` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here’s why this works. At the end of a game’s main loop, it might call `Sleep()`
    to rest until it’s ready to draw the next frame. Since it’s sleeping, it’s safe
    for you to do anything you want without worrying about synchronization issues.
    Some games might not do this, or they might call `Sleep()` from multiple threads,
    and those games will require a different method.
  prefs: []
  type: TYPE_NORMAL
- en: A more portable alternative is to hook the `PeekMessageA()` API function, because
    games often call that function from the main loop while waiting for input. Then,
    your bot can do thread-sensitive operations from within the `PeekMessageA()` hook,
    ensuring that they’re done from the game’s main thread. You may also want your
    bot to use this method to hook the `send()` and `recv()` API functions, as intercepting
    these allows you to create a packet sniffer relatively simply.
  prefs: []
  type: TYPE_NORMAL
- en: '***Jump Hooking***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Jump hooking* allows you to hook code in places where there is no branching
    code to manipulate. A jump hook replaces the code being hooked with an unconditional
    jump to a *trampoline function*. When the jump is hit, the trampoline function
    stores all current register and flag values, calls a callback function of your
    choice, restores the registers, restores the flags, executes the code that was
    replaced by the hook, and finally jumps back to the code just below the hook.
    This process is shown in [Figure 8-1](ch08.xhtml#ch8fig1).'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f08-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 8-1: A jump hook*'
  prefs: []
  type: TYPE_NORMAL
- en: The original code shows an example of some unmodified assembly you might find
    in a game, and the hooked code shows how that assembly might look after being
    hooked by a jump hook. The trampoline box shows an example trampoline function,
    in assembly, and the callback represents the code you’re trying to execute through
    hooking. In the original code, the assembly executes from top to bottom. In the
    hooked code, to get from the `SUB EAX,1` instruction to the `RETN` instruction,
    execution must follow the path shown by the dashed arrows.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If your callback code is simple, it can be integrated into the trampoline
    instead. It’s also not always necessary to store and restore the registers and
    flags, but doing so is good practice.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Placing a Jump**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The byte code of an unconditional jump resembles that of a near call, but the
    first byte is 0xE9 instead of 0xE8\. (See “[Working with Near Calls in Memory](ch08.xhtml#ch00lev1sec153)”
    on [page 153](ch08.xhtml#page_153) for a refresher.) In [Figure 8-1](ch08.xhtml#ch8fig1),
    the unconditional jump `JMP trampoline` replaces the following four operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you need to replace multiple sequential operations to accommodate
    the 5-byte size of the unconditional jump. You may come across cases where the
    size of the operation (or operations) being replaced is larger than 5 bytes. When
    this happens, replace the remaining bytes with NOP instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at how to replace those operations. [Listing 8-11](ch08.xhtml#ch8exe11)
    shows the code to place a jump hook.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-11: How to place a jump hook*'
  prefs: []
  type: TYPE_NORMAL
- en: This function takes the address to hook at, the address of the callback function,
    and the size of the memory to overwrite (in bytes) as arguments. First, it calculates
    the offset between the hook site and the trampoline and stores the result in `newOffset`
    ➊. Next, `PAGE_EXECUTE_READWRITE` permissions are applied to the memory to be
    changed. The unconditional jump (0xE9) ➋ and the address of the callback function
    ➌ are then written to memory, and a `for` loop writes NOP instructions (0x90)
    to any abandoned bytes. After the old protections are reapplied, `hookWithJump()`
    returns to the original address.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the `hookWithJump()` function ensures that `size` is not above 12
    before placing the jump. This check is important because a jump takes up 5 bytes,
    meaning it can replace up to five commands if the first four are each a single
    byte. If the first four commands are each a single byte, the fifth command would
    need to be more than 8 bytes to trigger the `if (size > 12)` clause. Because 9-byte
    operations are very, very rare, 12 is a safe but flexible limit. Having this limit
    can stop all sorts of bugs from happening, especially if your bot is dynamically
    detecting the `size` parameter. If the bot messes up and passes a `size` of `500,000,000`,
    for instance, the check will stop you from NOPing the whole universe.
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing the Trampoline Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Using the function in [Listing 8-11](ch08.xhtml#ch8exe11), you can replicate
    the hook shown in [Figure 8-1](ch08.xhtml#ch8fig1), but first you’ll have to create
    the trampoline function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Just like the trampoline described alongside [Figure 8-1](ch08.xhtml#ch8fig1),
    this trampoline stores all current flag ➊ and register values ➋, calls a callback
    function ➌, restores the registers ➍, restores the flags ➎, executes the code
    that was replaced by the hook at ➏ and ➐, and finally jumps back to the original
    code just below the jump and NOPs ➑.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To ensure that the compiler doesn’t autogenerate any extra code within the
    trampoline, always declare the trampoline using the* `__declspec(naked)` *convention.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Finishing the Jump Hook**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Once you create the trampoline, define the callback and set the hook like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, inside the `jumpHookCallback()` function, execute the code that relies
    on the hook. If your code needs to read or write the values of the registers as
    they were when the hook executed, you’re in luck. The `PUSHAD` command pushes
    them to the stack in the order EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and
    EDI. The trampoline calls `PUSHAD` directly before the `jumpHookCallback()` call,
    so you can reference the register values as arguments, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Since the trampoline uses `POPAD` to directly restore the registers from these
    values on the stack, any modifications you make to the parameters will be applied
    to the actual registers when they are restored from the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Like VF table hooks, jump hooks are rarely needed, and they can be tricky to
    simulate with a simple example. To help you wrap your head around them, I’ll explore
    a real-world, practical use case in “[Applying Jump Hooks and VF Hooks to Direct3D](ch08.xhtml#ch00lev1sec174)”
    on [page 175](ch08.xhtml#page_175).
  prefs: []
  type: TYPE_NORMAL
- en: '**PROFESSIONAL API HOOKING LIBRARIES**'
  prefs: []
  type: TYPE_NORMAL
- en: There are prewritten hooking libraries, like Microsoft’s Detours and MadCHook,
    that use only jump hooks. These libraries can automatically detect and follow
    other hooks, they know how many instructions to replace, and they generate trampoline
    functions for you. The libraries are able to do this because they understand how
    to disassemble and walk through assembly instructions to determine lengths, jump
    destinations, and so on. If you need to use hooks with that much power, it is
    arguably better to use one of those libraries than to create your own.
  prefs: []
  type: TYPE_NORMAL
- en: '**Applying Call Hooks to Adobe AIR**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adobe AIR is a development framework that can be used to make cross-platform
    games in an environment similar to Abode Flash. AIR is a common framework for
    online games, as it allows developers to write cross-platform code in a versatile,
    high-level language called ActionScript. ActionScript is an interpreted language,
    and AIR runs the code inside a virtual machine, which makes it infeasible to hook
    game-specific code with AIR. Instead, it is easier to hook AIR itself.
  prefs: []
  type: TYPE_NORMAL
- en: The example code for this section can be found in *GameHackingExamples/Chapter8_AdobeAirHook*
    in this book’s source files. The code comes from an old project of mine, and it
    works on any game running *Adobe AIR.dll* version 3.7.0.1530\. I’ve gotten it
    working on other versions as well, but I can’t guarantee it will work with much
    newer or much older versions, so treat this as a case study.
  prefs: []
  type: TYPE_NORMAL
- en: '***Accessing the RTMP Goldmine***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *Real Time Messaging Protocol (RTMP)* is a text-based network protocol that
    ActionScript uses to serialize and send entire objects over the network. RTMP
    sits on top of the *HyperText Transfer Protocol (HTTP)*, and a secure version,
    RTMPS, sits on top of *HTTP Secure (HTTPS)*. RTMPS allows game developers to easily
    send and receive entire object instances over a secure connection with little
    complication, making it the network protocol of choice for any games running on
    AIR.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Data sent over RTMP/RTMPS is serialized through* Action Message Format (AMF)*,
    and parsing AMF packets is beyond the scope of this book. Search online for “AMF3
    Parser,” and you’ll find a lot of code that does it.*'
  prefs: []
  type: TYPE_NORMAL
- en: Data sent over RTMP and RTMPS is very rich. The packets contain information
    about object types, names, and values. This is a gold mine. If you can intercept
    this data in real time, you can instantaneously respond to changes in game state,
    see a wealth of critical information without ever reading it from memory, and
    find useful pieces of data that you might not even know exist.
  prefs: []
  type: TYPE_NORMAL
- en: A while back, I was working on a tool that required a ton of insight into the
    state of a game. Obtaining such a large amount of data directly from memory would
    have been extremely hard, if not impossible. After some research, I realized that
    the game was using RTMPS to communicate with the server, and that prompted me
    to start digging into this gold mine.
  prefs: []
  type: TYPE_NORMAL
- en: Since RTMPS is encrypted, I knew I had to somehow hook the cryptographic functions
    used by AIR before I could get any usable data. After searching online, I found
    source code for a small tool called airlog, created by another game hacker who,
    like me, was trying to log packets sent over RTMPS. Although the tool hooked the
    exact functions I needed, the code was outdated, messy, and, worst of all, didn’t
    work on the version of AIR I was trying to hook.
  prefs: []
  type: TYPE_NORMAL
- en: But that didn’t mean it was useless. Not only did airlog hook the two functions
    I needed, but it also located them by scanning for certain byte patterns within
    the Adobe AIR library. These byte patterns were three years old, though, so they
    weren’t working anymore. The newer versions of Adobe AIR had changed enough that
    the assembly bytes were no longer the same. The difference in bytes was a problem
    for the code in airlog, but not for me.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside an inline assembly block, you can specify raw bytes with the following
    function call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you replace `BYTE` with, say, `0x03`, the code will be compiled in a way
    that treats `0x03` as a byte in the assembly code, regardless of whether that
    makes sense. Using this trick, I compiled the byte arrays back to assembly code.
    The code didn’t do anything, and it wasn’t meant to; using this trick simply allowed
    me to attach to my dummy application with OllyDBG and inspect bytes, which were
    conveniently presented as a clean disassembly.
  prefs: []
  type: TYPE_NORMAL
- en: Since these bytes represented the code surrounding the functions I needed, so,
    too, did their disassembly. The code was pretty standard and didn’t seem likely
    to change, so I turned my attention to the constants. The code had a few immediate
    values passed as offsets in commands. Knowing how commonly these can change, I
    rewired airlog’s pattern-matching algorithm to support wildcards, updated the
    patterns to treat any constants as wildcards, and then ran the match. After some
    tweaks to the patterns and a bit of digging through duplicate search results,
    I tracked down the functions I wanted to hook. I appropriately named them `encode()`
    and `decode()` and began working on a tool similar to airlog—but better.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hooking the RTMPS encode() Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I discovered that the `encode()` function, which is used to encrypt the data
    for outgoing packets, is a nonvirtual `__thiscall`, meaning it’s called by a near
    call. Moreover, the call happens inside a loop. The entire loop looks like [Listing
    8-12](ch08.xhtml#ch8exe12), taken directly from the OllyDBG disassembly pane.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-12: The `encode()` loop*'
  prefs: []
  type: TYPE_NORMAL
- en: With a bit of analysis and some guidance from airlog, I determined that the
    `encode()` function called at ➊ takes a byte array and buffer length (let’s call
    them `buffer` and `size`, respectively) as parameters. The function returns `-1`
    when it fails and returns `size` otherwise. The function operates on chunks of
    4,096 bytes, which is why this happens in a loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Turned into more readable pseudocode, the loop calling `encode()` looks like
    this (the numbers refer to the relevant assembly instructions in [Listing 8-12](ch08.xhtml#ch8exe12)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: I wasn’t interested in what `encode()` did, but I needed the entire buffer it
    was looping over, and hooking `encode()` was my means of getting that buffer.
    Looking at the real loop in [Listing 8-12](ch08.xhtml#ch8exe12), I knew that the
    calling object instance’s full buffer was stored at ESI+0x1C58, that the full
    size was stored at ESI+0x3C58, and that EDI contained the loop counter. I devised
    the hook with these things in mind, ultimately creating a two-part hook.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of my hook was a `reportEncode()` function that logs the entire
    buffer on the first loop iteration. Here’s the `reportEncode()` function in full:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes `buffer`, `size`, and `loopCounter` as parameters and returns
    the address of the function I dubbed `encode()`. Before fetching that address,
    however, the second part of my hook, a `myEncode()` function, does all of the
    dirty work to obtain `buffer`, `size`, and `loopCounter`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `myEncode()` function is a pure assembly function that replaces the original
    `encode()` function call using a near call hook. After storing ECX on the stack,
    `myEncode()` obtains `buffer`, `size`, and `loopCounter` and passes them to the
    `reportEncode()` function. After calling the `reportEncode()` function, the `myEncode()`
    function restores ECX and jumps directly into `encode()`, causing the original
    function to execute and return gracefully to the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `myEncode()` cleans everything it uses from the stack, the stack still
    contains the original parameters and return address in the correct spot after
    `myEncode()` runs. That’s why `myEncode()` jumps directly into `encode()` instead
    of using a function call: that stack is already set up with the proper return
    address and parameters, so the `encode()` function will think everything happened
    as normal.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hooking the RTMPS decode() Function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The function I named `decode()`, which is used to decrypt incoming data, was
    also a `__thiscall` that was called in a loop. It worked on chunks of 4,096 bytes
    and took a buffer and size as parameters. The loop was quite a bit more complex,
    containing multiple function calls, nested loops, and loop escapes, but hooking
    worked much the same as hooking the so-called `encode()` function. The reason
    for the added complexity is not relevant to hooking the function, but it makes
    the code difficult to summarize, so I won’t show the original function here. The
    bottom line is this: once all the complexity was rubbed away, the `decode()` loop
    was the `encode()` loop in reverse.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, I devised a two-part near call hook. The first part, `reportDecode()`,
    is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The function logs each packet that comes through. I didn’t have a loop index
    at the time, so I decided that it was okay to log every single partial packet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of the hook, the `myDecode()` function, acts as the new callee
    and does all of the dirty work, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: I knew the buffer was decrypted in place, meaning the encrypted chunk would
    be overwritten with the decrypted one once the call to `decode()` was complete.
    This meant that `myDecode()` had to call the original `decode()` function ➊ before
    calling the `reportDecode()` function, which would give the results of the decoding.
    Ultimately, `myDecode()` also needed to return with the same value that the original
    `decode()` function would and clean up the stack, and the final `POP` ➋ and `RETN`
    ➌ instructions took care of that.
  prefs: []
  type: TYPE_NORMAL
- en: '***Placing the Hooks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The next problem I ran into was that the hooks were for code inside the module
    *Adobe AIR.dll*, which was not the main module of the game. Because of the code’s
    location, I needed to find the base addresses for the hooks a bit differently.
    Additionally, since I needed these hooks to work across a few different versions
    of Adobe AIR, I also had to find the right addresses for each version. Instead
    of trying to get my hands on all of the different versions of Adobe AIR, I took
    another page out of airlog’s playbook and decided to programmatically locate the
    addresses by writing a small memory scanner. Before I could write the memory scanner,
    I needed both the base address and size of *Adobe AIR.dll* so I could limit my
    memory search to only that area.
  prefs: []
  type: TYPE_NORMAL
- en: 'I found these values using `Module32First()` and `Module32Next()` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through all modules in the process until it finds *Adobe AIR.dll*
    ➊. When it finds the correct module entry ➋, it fetches the `modBaseSize` and
    `modBaseAddr` properties from it and breaks out immediately.
  prefs: []
  type: TYPE_NORMAL
- en: The next step was finding a sequence of bytes I could use to identify the functions.
    I decided to use the byte code surrounding each call. I also had to make sure
    that each sequence was unique while avoiding the use of any constants in the patterns
    to ensure the code’s portability. [Listing 8-13](ch08.xhtml#ch8exe13) shows the
    byte sequences I ended up with.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-13: The `encode()` and `decode()` byte sequences*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the `CALL` instruction in each pattern; these are the calls to the Adobe
    AIR functions I named `encode()` and `decode()`. I scanned for these sequences
    with the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Treating the memory of *Adobe AIR.dll* as a byte array, the `findSequence()`
    function looks for a sequence of bytes as a subset of that byte array and returns
    the address of the first match it finds. With the `findSequence()` function written,
    finding the addresses I needed to hook `encode()` and `decode()` was simple. Here’s
    how those calls looked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Since each target call was 2 bytes into its receptive search sequence, all I
    had to do was locate each sequence and add 2\. After that, the final step was
    to place the hooks using the method described in “[Call Hooking](ch08.xhtml#ch00lev1sec152)”
    on [page 153](ch08.xhtml#page_153).
  prefs: []
  type: TYPE_NORMAL
- en: With my hook finished, I could see every single piece of data that went between
    the game’s client and server. Moreover, since the RTMPS protocol sends serialized
    ActionScript objects, the data was basically self-documenting. Every single piece
    of information was accompanied by a variable name. Every variable existed as a
    member of a well-described object. Every object had a consistent name. Like I
    said—it was a gold mine.
  prefs: []
  type: TYPE_NORMAL
- en: '**Applying Jump Hooks and VF Hooks to Direct3D**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unlike the Adobe AIR hook I just described, hooks for Direct3D (the 3D graphics
    component of Microsoft’s DirectX API) are very common and highly documented. Direct3D
    is ubiquitous in the world of gaming: a majority of PC games use the library,
    which means that hooking it gives you a very powerful method for intercepting
    data and manipulating the graphics layers of many different games. You can use
    a Direct3D hook for a number of tasks, such as detecting locations of hidden enemy
    players, increasing the lighting of dark in-game environments, and seamlessly
    displaying additional graphical information. Making effective use of a Direct3D
    hook requires you to learn about the API, but there’s more than enough information
    in this book to get you started.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I’ll give you a high-level introduction to a game loop that
    uses Direct3D before diving right into the implementation of a Direct3D hook.
    Rather than detailing the internals and giving you the analytical backstory as
    I did with the Adobe AIR hook, I’ll go over the most popular Direct3D hook method,
    as it is well documented and used by the majority of game hackers.
  prefs: []
  type: TYPE_NORMAL
- en: The online resources for this book include two pieces of example code for this
    section; find those files now if you want to follow along. The first part, an
    example Direct3D 9 application for you to hack on, can be found under *GameHackingExamples/Chapter8_Direct3DApplication*.
    The second part, the actual hook, is under *Chapter8_Direct3DHook*.
  prefs: []
  type: TYPE_NORMAL
- en: There are multiple versions of Direct3D in use at any given time, and there
    are ways to hook each one. For this book, I’ll focus on hooking Direct3D 9, because
    it is the only commonly used version that is supported by Windows XP.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Even though XP has reached end of life, many people in less developed countries
    still use it as a primary gaming system. Direct3D 9 works on all versions of Windows
    and is nearly as powerful as its successors, so many game companies still prefer
    to use it over newer versions that don’t have as much backward compatibility.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Drawing Loop***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s jump right in with a crash course on how Direct3D works. Inside a Direct3D
    game’s source code, you’ll find an infinite loop that processes input and renders
    graphics. Each iteration in this drawing loop is called a *frame*. If we cut out
    all the extraneous code and focus simply on a bare skeleton, we can visualize
    a game’s main loop with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This function is the entry point of the game. Simply put, it initializes the
    game and then enters the game’s main loop. Inside the main loop, it executes code
    responsible for processing user input before calling `drawFrame()` to redraw the
    screen using Direct3D. (Check out the code in *GameHackingExamples/Chapter8_Direct3DApplication*
    to see a fully functional game loop.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time it is called, the `drawFrame()` function redraws the entire screen.
    The code looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: After clearing the screen with `device->Clear` ➊, the `drawFrame()` function
    calls `device->BeginScene()` to unlock the scene for drawing. It then executes
    some drawing code (what that drawing code actually does isn’t important right
    now) and locks the scene with a `device->EndScene()` call. To finish up, it renders
    the scene to the screen by calling the `device->Present()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that all of these functions are called as members of some instance called
    `device`. This is simply an object instance representing the Direct3D device,
    which is used to invoke all sorts of drawing calls. Also, notice that this function
    is devoid of any actual drawing code, but that’s okay. It’s really only important
    for you to understand the high-level concepts of drawing loops, frames, and the
    Direct3D device. To recap, games have a main loop with two responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: • Handling incoming messages
  prefs: []
  type: TYPE_NORMAL
- en: • Drawing the game to the screen
  prefs: []
  type: TYPE_NORMAL
- en: Each iteration in this loop is called a frame, and each frame is drawn by a
    device. Taking control of the device gives you access to the most sensitive and
    descriptive details of the game’s state; that is, you’ll be able to peek into
    the game’s state after the data has been parsed, processed, and rendered to the
    screen. Moreover, you’ll be able to modify the output of this state. These two
    superpowers enable you to pull off all kinds of awesome hacks.
  prefs: []
  type: TYPE_NORMAL
- en: '***Finding the Direct3D Device***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To take control of a Direct3D device, you hook the member functions in the device’s
    VF table. Unfortunately, however, using the Direct3D API to instantiate your own
    instance of the same `device` class from injected code doesn’t mean you’ll share
    a VF table with the game’s instance. Direct3D devices use a customized runtime
    implementation of VF tables, and each device gets its own unique VF table. Additionally,
    devices sometimes rewrite their own VF tables, removing any hooks and restoring
    the original function addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of these Direct3D quirks leave you with one inevitable option: you must
    find the address of the game’s device and modify its VF table directly. Here’s
    how:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Direct3D device and traverse its VF table to locate the true address
    of `EndScene()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Place a temporary jump hook on `EndScene()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the jump hook callback is executed, store the address of the device that
    was used to call the function, remove the hook, and restore execution normally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From there, use VF hooks to hook any member function of the Direct3D device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Jump Hooking EndScene()**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Since every device will call `EndScene()` at the end of each frame, you can
    hook `EndScene()` using a jump hook and intercept the game’s device from your
    hook callback. Unique devices may have their own unique VF tables, but the different
    tables still point to the same functions, so you can find the address of `EndScene()`
    in the VF table of any arbitrary device. Using standard Direct3D API calls, you
    can create your own device like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Explaining how everything in Direct3D works is outside the scope of this book,
    so just know that you can copy this code to create a Direct3D device that contains
    the `EndScene()` function as a member. The `EndScene()` address is at index `42`
    in the VF table of `device` (see “The Meaning of Device, Direct3D, and VF Hooks”
    box to learn how to find that index), and you can read it using a subset of the
    VF table hooking code from “[Using a VF Table Hook](ch08.xhtml#ch00lev1sec159)”
    on [page 159](ch08.xhtml#page_159), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve obtained the address, your discovery device has served its purpose,
    and it can be destroyed with a call to the `Release()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: With the address of `EndScene()` in hand, you’d be ready to start thinking about
    how to place your hook in memory. But since you just have a function address,
    your only option is to place a jump hook at the top of the function.
  prefs: []
  type: TYPE_NORMAL
- en: '**THE MEANING OF DEVICE, DIRECT3D, AND VF HOOKS**'
  prefs: []
  type: TYPE_NORMAL
- en: If you’re wondering how I know that the index of the `EndScene()` function is
    `42`, you’ve come to the right box. Since Direct3D 9 is a freely available library,
    you can actually see quite a bit of what goes on under the hood. The main header
    file for the library is *d3d9.h*. If you open this file in your editor and search
    for “EndScene,” you’ll end up in the middle of a large class definition that specifies
    several functions using C macros. This is the base class for all Direct3D 9 `device`
    implementations, and it defines the virtual functions used by the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The VF table is constructed in the same order as the functions are defined
    in code, so you can determine the index of any member function by simply counting
    the lines. You can scroll to the top of the class definition (at line 426 in my
    version of the library, and probably yours too), note the line where the first
    function is declared (line 429), and then scroll to the `EndScene()` definition
    and note that line (line 473). Finally, count the number of blank or commented
    lines (two for me) and do some math: 473 – 429 – 2 = 42.'
  prefs: []
  type: TYPE_NORMAL
- en: Presto! The `EndScene()` function is the 43rd function declared, so it sits
    at the 42nd spot in the VF table. Another advantage to having this header is that
    you can see the name, argument types, argument names, and return type of every
    single function in the device class. So when you’re writing your own hooks in
    the future, you’ll know exactly where to look.
  prefs: []
  type: TYPE_NORMAL
- en: '**Placing and Removing the Jump Hook**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Since you’re just using the hook to find the device, you need to call it only
    once. After obtaining the device, you’ll remove the jump hook and restore execution
    back to the start of `EndScene()` so that the drawing loop can carry on its work.
    Believe it or not, this makes your life much easier. Since the code will be restored
    immediately, there’s no need for your trampoline to execute the commands that
    are replaced by the jump, and there’s no need to pad the jump with NOPs. All you
    need to do is store the original bytes and place the hook. To do so, you use a
    slightly tweaked version of the jump-hooking code from [Listing 8-11](ch08.xhtml#ch8exe11):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Like the function in [Listing 8-11](ch08.xhtml#ch8exe11), this function makes
    the memory writable ➊, places the hook ➌, and restores the memory protection.
    Before placing the hook, it allocates a 5-byte buffer called `originals` ➋ and
    fills it with the original bytes. After the hook is placed, it returns `originals`
    to the calling function.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it’s time to remove the hook, pass `originals` to the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This code simply iterates over `originals` and quietly places those 5 bytes
    back where they were found so that everything is as expected when execution returns
    to the `EndScene()` function. When the time comes, you can place and remove your
    actual hook using two lines of code, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Once you have the `hookWithJump()` and `unhookWithJump()` functions, it’s time
    to prepare the callback and find the device.
  prefs: []
  type: TYPE_NORMAL
- en: '**Writing the Callback and Trampoline**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Even though you can obtain the `EndScene()` address from a VF table, the `EndScene()`
    function doesn’t actually follow the `__thiscall` convention. Direct3D classes
    are simple wrappers around a C API, and all of the member function calls are forwarded
    to `__stdcall` functions that take a class instance as a first parameter. This
    means that your trampoline only needs to grab the device from the stack, pass
    it to the callback, and then jump back to `EndScene()`. The callback only has
    to remove the jump hook before returning to the trampoline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final code for the callback and trampoline to this jump hook looks something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Using the `hookWithJump()` function, you can place a jump hook on `EndScene()`
    that calls the `endSceneTrampoline()` function. When the game’s device calls the
    `EndScene()` function, the trampoline function calls the `reportInitEndScene()`
    function ➊. The `reportInitEndScene()` function stores the captured device pointer
    to a global variable called `discoveredDevice`, removes the hook by calling `unhookWithJump()`,
    and returns the address of `EndScene()` to the trampoline. To finish up, the trampoline
    jumps directly to EAX, which will be holding the address that was returned from
    the reporting function.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You can use jump hooks to completely skip the VF table hooking that I’ll show
    you, but it’s very unreliable to use “dumb” jump hooks on commonly hooked API
    functions. Consistently obtaining good results with only jump hooks requires professional
    hooking libraries, and I’d rather teach you how to do it completely on your own.*'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, all that’s left to do is hook the VF table of `discoveredDevice`
    to hack the game. The next two sections will walk you through hooks on the `EndScene()`
    and `Reset()` functions, which are required if you want a stable hook.
  prefs: []
  type: TYPE_NORMAL
- en: '***Writing a Hook for EndScene()***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A hook on `EndScene()` is useful because it allows you to intercept a completed
    frame just before it is rendered; you can effectively execute your own rendering
    code inside the game loop. As you saw when locating this function’s address in
    “[Jump Hooking `EndScene()`](ch08.xhtml#ch00lev1sec177)” on [page 178](ch08.xhtml#page_178),
    this function is at index `42` in the VF table. You can hook `EndScene()` using
    a VF hook as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the `hookVF()` function from “[Using a VF Table Hook](ch08.xhtml#ch00lev1sec159)”
    on [page 159](ch08.xhtml#page_159) to hook `EndScene()` at index `42` of `discoveredDevice`,
    using `myEndScene()` as the callback function. A direct Direct3D device will occasionally
    repatch its own VF table and restore the original function addresses. This typically
    happens from within the `EndScene()` function, meaning you also have to repatch
    the VF table after calling the original `EndScene()` function. There are a few
    changes you can make to this hook to handle that, as shown in [Listing 8-14](ch08.xhtml#ch8exe14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 8-14: Final code to hook `EndScene()`*'
  prefs: []
  type: TYPE_NORMAL
- en: The code to place the hook has been moved into a function called `placeHooks()`
    so it can be called multiple times with ease. The callback function still forwards
    the call to the original function, but it makes sure to call `placeHooks()` before
    returning. This ensures that the hook is always active, even if the original `EndScene()`
    function removes it.
  prefs: []
  type: TYPE_NORMAL
- en: Another point to notice is that `placeHooks()` updates the address of `origEndScene()`
    every time the hook is replaced, as long as the address returned from `hookVF()`
    isn’t the address of the `myEndScene()` function. This does two distinct things.
    First, it allows other applications to hook `EndScene()` without stepping on their
    toes, since it will update `origEndScene()` to whatever is seen in the VF table.
    Second, it makes sure that the value of `origEndScene()` can never be the address
    of our callback, preventing a potential infinite loop. An infinite loop is possible
    otherwise, because `origEndScene()` doesn’t always fix the device’s VF table,
    meaning `placeHooks()` can be called when the VF table still contains the `myEndScene()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '***Writing a Hook for Reset()***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When you’re using a Direct3D hook in production, you’ll be doing all kinds of
    tasks like drawing custom text, displaying images related to your bot, and interacting
    with function calls from the game. These tasks will require you to create your
    own Direct3D objects that are tied to the game’s device, and that can be a problem.
    From time to time, the game may completely reset its device through a `Reset()`
    function. When a device is reset, you’ll need to update any objects (most commonly
    fonts and sprites) that you’ve created for the device, using their `OnLostDevice()`
    member functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since `Reset()` is called from the VF table of the device, you can use a hook
    on it to tell you when the device has been reset. `Reset()` takes two parameters
    and is at index `16` in the VF table. You can add this code to `placeHooks()`
    in [Listing 8-14](ch08.xhtml#ch8exe14) to hook the `Reset()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is the declaration to use for `origReset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'When a reset is successful, the original function returns `D3D_OK`. Your hook
    function recognizes this and calls `OnLostDevice()` accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Once you fill in the contents of the `if()` statement, all of your objects are
    ready to use again.
  prefs: []
  type: TYPE_NORMAL
- en: '***What’s Next?***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that I’ve shown you how to take control of a game’s Direct3D device, you’re
    probably wondering what you can do with it. Unlike the other examples in the book,
    the code in this section and the example code don’t have a one-to-one correlation,
    but the functionality is still the same. Here’s a high-level view of the correlation
    between this chapter and the code in the *Chapter8_Direct3DHook* example project.
  prefs: []
  type: TYPE_NORMAL
- en: The file *DirectXHookCallbacks.h* contains the callbacks for the `EndScene()`
    and `Reset()` functions, two callbacks for other common functions, and the trampoline
    and reporter functions for the temporary jump hook. These functions are all pretty
    much as described in this chapter, except they call into a singleton class defined
    in *DirectXHook.h* and *DirectXHook.cpp*. This singleton class is responsible
    for forwarding the calls to the original functions.
  prefs: []
  type: TYPE_NORMAL
- en: The class is also responsible for all of the heavy lifting, and it contains
    the code to create the discovery device, place the hooks, draw text, handle device
    resets, and display images. Furthermore, it allows external code to add custom
    callbacks for each hook, as you can see in *main.cpp*. Here, you’ll see a number
    of different callbacks that are drawing custom text, adding new images to the
    screen, and changing the textures of models that are drawn by the game. I recommend
    poking around in the code to get a better understanding of what’s going on, but
    don’t get too carried away. We’ll dive into this code in [Chapter 9](ch09.xhtml#ch09)
    to talk about all the cool hacks it can do.
  prefs: []
  type: TYPE_NORMAL
- en: '**OPTIONAL FIXES FOR STABILITY**'
  prefs: []
  type: TYPE_NORMAL
- en: The `Reset()` and `EndScene()` hooks described in this chapter should work well
    for any game running Direct3D 9, but it is slightly unstable. If the game tries
    to execute `EndScene()` when the jump hook is placed, it will crash because the
    bytes are being modified. There are two ways to fix this. First, you can place
    the jump hook from within an IAT hook on `PeekMessage()`. This will work because
    placing an IAT hook is a thread-safe operation, but it assumes that `PeekMessage()`
    is called only from the same thread that does the Direct3D drawing.
  prefs: []
  type: TYPE_NORMAL
- en: A safer, but more complex, alternative is to iterate over every thread in the
    game (similar to how it worked for thread hijacking) and use `SuspendThread()`
    to pause all threads in the game (except for the one placing the hook, of course).
    Before pausing a thread, you must make sure its `EIP` is not executing the first
    5 bytes of `EndScene()`. After the hook is placed, you must use `ResumeThread()`
    to restore execution with your hook in place.
  prefs: []
  type: TYPE_NORMAL
- en: '**Closing Thoughts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Control flow manipulation is a very important skill in game hacking, and a lot
    of the hacks in this book rely on it. Throughout the next two chapters you’ll
    learn how to create common hacks using the Direct3D hook, and you’ll get a better
    idea of the general use cases of hooking. Even if you feel a little shaky, continue
    to [Chapter 9](ch09.xhtml#ch09). The code examples there center on the Direct3D
    hook and will get you even more familiar with hooking techniques.
  prefs: []
  type: TYPE_NORMAL
