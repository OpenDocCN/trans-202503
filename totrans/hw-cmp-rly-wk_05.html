<html><head></head><body>
<span epub:type="pagebreak" id="page_73"/>&#13;
<h2 class="h2"><strong><span class="big">5</span><br/>MATH WITH DIGITAL CIRCUITS</strong></h2>&#13;
<div class="image1"><img src="../images/common.jpg" alt="Image"/></div>&#13;
<p class="noindents">In the previous chapter we covered logic gates and digital circuits, which enable us to implement logical expressions in hardware. Earlier in this book we defined computers as electronic devices that can be programmed to carry out a set of instructions. In this chapter, I begin to bridge those concepts by showing you how simple logic gates pave the way for the operations a computer executes. We cover a specific operation that all computers are able to perform–addition. First, we go over the basics of addition in binary. Then we use logic gates to build hardware that adds, demonstrating how simple gates work together in a computer to perform useful operations. Finally, we cover the representation of integers as signed and unsigned numbers in a computer.</p>&#13;
<h3 class="h3" id="lev1_29"><strong><span epub:type="pagebreak" id="page_74"/>Binary Addition</strong></h3>&#13;
<p class="noindent">Let’s look at the basics of how addition works in binary. The underlying principles of addition are the same for all place-value systems, so you have a head start since you already know how to add in decimal! Rather than deal in abstract concepts, let’s take a concrete example: adding two specific 4-bit numbers, 0010 and 0011, as shown in <a href="ch05.xhtml#ch5fig1">Figure 5-1</a>.</p>&#13;
<div class="image" id="ch5fig1"><img src="../images/fig5-1.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-1: Adding two binary numbers</em></p>&#13;
<p class="indent">Just as we do in decimal, we begin with the rightmost place, known as the <em>least significant bit</em>, and add the two values together (<a href="ch05.xhtml#ch5fig2">Figure 5-2</a>). Here, 0 + 1 is 1.</p>&#13;
<div class="image" id="ch5fig2"><img src="../images/fig5-2.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-2: Adding the least significant bit of two binary numbers</em></p>&#13;
<p class="indent">Now let’s move one bit to the left and add those values together, as shown in <a href="ch05.xhtml#ch5fig3">Figure 5-3</a>.</p>&#13;
<div class="image" id="ch5fig3"><img src="../images/fig5-3.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-3: Adding the twos place</em></p>&#13;
<p class="indent">As you can see in <a href="ch05.xhtml#ch5fig3">Figure 5-3</a>, this place requires us to add 1 + 1, which presents us with an interesting twist. In decimal, we represent 1 + 1 with the symbol 2, but in binary we only have two symbols, 0 and 1. In binary, 1 + 1 is 10 (see <a href="ch01.xhtml">Chapter 1</a> for an explanation), which requires two bits to represent. We can only put one bit in this place, so 0 goes into the current place, and we carry the 1 to the next place, as indicated in <a href="ch05.xhtml#ch5fig3">Figure 5-3</a>. We can now move to the next place (see <a href="ch05.xhtml#ch5fig4">Figure 5-4</a>), and when we add these bits, we must include the carried bit from the previous place. This gives us 1 + 0 + 0 = 1.</p>&#13;
<span epub:type="pagebreak" id="page_75"/>&#13;
<div class="image" id="ch5fig4"><img src="../images/fig5-4.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-4: Adding the fours place</em></p>&#13;
<p class="indent">Finally, we add the <em>most significant bit</em>, as shown in <a href="ch05.xhtml#ch5fig5">Figure 5-5</a>.</p>&#13;
<div class="image" id="ch5fig5"><img src="../images/fig5-5.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-5: Adding the eights place</em></p>&#13;
<p class="indent">Once we add all the places, the complete result in binary is 0101. One way to sanity-check our work is to simply convert everything to decimal, as shown in <a href="ch05.xhtml#ch5fig6">Figure 5-6</a>.</p>&#13;
<div class="image" id="ch5fig6"><img src="../images/fig5-6.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-6: Adding two binary numbers, then converting to decimal</em></p>&#13;
<p class="indent">As you can see in <a href="ch05.xhtml#ch5fig6">Figure 5-6</a>, our answer in binary (0101) matches what we’d expect in decimal (5). Simple enough!</p>&#13;
<div class="sidebar">&#13;
<p class="exercise" id="ch5ex1"><strong>EXERCISE 5-1: PRACTICE BINARY ADDITION</strong></p>&#13;
<p class="exercise-para">You can now practice what you’ve just learned. Try the following addition problems:</p>&#13;
<p class="exercise-para">0001 + 0010 = ______</p>&#13;
<p class="exercise-para">0011 + 0001 = ______</p>&#13;
<p class="exercise-para">0101 + 0011 = ______</p>&#13;
<p class="exercise-para">0111 + 0011 = ______</p>&#13;
<p class="exercise-parai">See <a href="appa.xhtml">Appendix A</a> for answers.</p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_76"/>Fortunately, addition works the same way no matter what base you’re working in. The only difference between bases is how many symbols are available to you. Binary makes addition particularly straightforward, since the addition of each place always results in exactly two output bits, each with only two possible values:</p>&#13;
<p class="block"><strong>Output 1</strong>   A <em>sum</em> bit (S) of 0 or 1, representing the least significant bit of the result of the addition operation</p>&#13;
<p class="block"><strong>Output 2</strong>   A <em>carry-out</em> bit (C<sub>out</sub>) of 0 or 1</p>&#13;
<h3 class="h3" id="lev1_30"><strong>Half Adders</strong></h3>&#13;
<p class="noindent">Now let’s say we want to construct a digital circuit that adds a <em>single</em> place of two binary numbers. We initially focus on the least significant bit. Adding the least significant bits of two numbers only requires two binary inputs (let’s call them A and B), and the binary outputs are a sum bit (S) and a carry-out bit (C<sub>out</sub>). We call such a circuit a <em>half adder</em>. <a href="ch05.xhtml#ch5fig7">Figure 5-7</a> shows the symbol for a half adder.</p>&#13;
<div class="image" id="ch5fig7"><img src="../images/fig5-7.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-7: Symbol for a half adder</em></p>&#13;
<p class="indent">To clarify how the half adder fits in with our earlier example of adding two binary numbers, <a href="ch05.xhtml#ch5fig8">Figure 5-8</a> relates the two concepts.</p>&#13;
<div class="image" id="ch5fig8"><img src="../images/fig5-8.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-8: Half adder in action</em></p>&#13;
<p class="indent">As you can see in <a href="ch05.xhtml#ch5fig8">Figure 5-8</a>, the least significant bit from the first number is input A and the least significant bit from the second number is input B. The sum is an output, S, and the carry-out is also an output.</p>&#13;
<p class="indent">Internally, the half adder can be implemented as a combinational logic circuit, so we can also describe it with a truth table, as shown in <a href="ch05.xhtml#ch5tab1">Table 5-1</a>. Note that A and B are inputs, while S and C<sub>out</sub> are outputs.</p>&#13;
<span epub:type="pagebreak" id="page_77"/>&#13;
<p class="tabcap" id="ch5tab1"><strong>Table 5-1:</strong> Truth Table for a Half Adder</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" colspan="2" class="borderb"><p class="tab"><strong>Inputs</strong></p></th>&#13;
<th style="vertical-align: top;" colspan="2" class="borderb"><p class="tab"><strong>Outputs</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><strong>A</strong></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><strong>B</strong></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><strong>S</strong></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><strong>C<sub>out</sub></strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Let’s walk through the truth table in <a href="ch05.xhtml#ch5tab1">Table 5-1</a>. Adding 0 and 0 results in 0 with no carry. Adding 0 and 1 (or the reverse) results in 1 with no carry. Adding 1 and 1 gives us 0 with a carry of 1.</p>&#13;
<p class="indent">Now, how do we go about implementing this with digital logic gates? The solution is straightforward if we examine one output at a time, as shown in <a href="ch05.xhtml#ch5fig9">Figure 5-9</a>.</p>&#13;
<div class="image" id="ch5fig9"><img src="../images/fig5-9.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-9: Truth table for a half adder; outputs match XOR, AND</em></p>&#13;
<p class="indent">Looking at only output S in <a href="ch05.xhtml#ch5fig9">Figure 5-9</a>, we can see that it exactly matches the truth table for an XOR gate (see <a href="ch04.xhtml">Chapter 4</a>). Looking at C<sub>out</sub> only, we can observe that it matches the output of an AND gate. Therefore, we can implement a half adder using only two gates: XOR and AND, as shown in <a href="ch05.xhtml#ch5fig10">Figure 5-10</a>.</p>&#13;
<div class="image" id="ch5fig10"><img src="../images/fig5-10.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-10: Half adder implemented with two logic gates, XOR and AND</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_78"/>As you can see in <a href="ch05.xhtml#ch5fig10">Figure 5-10</a>, digital inputs A and B act as the inputs for both the XOR gate and the AND gate. The gates then produce the desired outputs, S and C<sub>out</sub>.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Please see <a href="ch05.xhtml#proj5">Project #5</a> on <a href="ch05.xhtml#page_89">page 89</a>, where you can build a circuit for a half adder</em>.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev1_31"><strong>Full Adders</strong></h3>&#13;
<p class="noindent">A half adder can handle the logic needed to perform addition for the least significant bits of two binary numbers. However, each subsequent bit requires an additional input: the carry-in bit, C<sub>in</sub>. This is because every bit place, except the least significant bit, needs to handle the situation where addition of the previous bit place resulted in a carry-out, which in turn becomes the carry-in for the current bit place. Adding a C<sub>in</sub> input to our adder component requires a new circuit design, and we call this circuit a <em>full adder</em>. The symbol for a full adder, shown in <a href="ch05.xhtml#ch5fig11">Figure 5-11</a>, is similar to the symbol for a half adder, differing only by an extra input, C<sub>in</sub>.</p>&#13;
<div class="image" id="ch5fig11"><img src="../images/fig5-11.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-11: Symbol for a full adder</em></p>&#13;
<p class="indent">In <a href="ch05.xhtml#ch5fig12">Figure 5-12</a>, we see an example of the relationship between binary addition of a single place and the full adder.</p>&#13;
<div class="image" id="ch5fig12"><img src="../images/fig5-12.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-12: Full adder in action</em></p>&#13;
<p class="indent">The full adder handles the addition of a single place, including the carry-in bit. In the example shown in <a href="ch05.xhtml#ch5fig12">Figure 5-12</a>, we add the bits in the 4s place. Since the bits in the previous place were 1 and 1, there’s a carry-in of 1. The full adder takes all three inputs (A = 0, B = 0, and C<sub>in</sub> = 1) and produces an output of S = 1 and C<sub>out</sub> = 0.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_79"/>For a complete picture of the possible inputs and outputs of a full adder, we can use a truth table, shown in <a href="ch05.xhtml#ch5tab2">Table 5-2</a>. This table has three inputs (A, B, C<sub>in</sub>) and two outputs (S, C<sub>out</sub>). Take a moment to consider the outputs from the various input combinations.</p>&#13;
<p class="tabcap" id="ch5tab2"><strong>Table 5-2:</strong> Full Adder Truth Table</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" colspan="2" class="borderb"><p class="tab"><strong>Inputs</strong></p></th>&#13;
<th style="vertical-align: top;" colspan="3" class="borderb"><p class="tab"><strong>Outputs</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><strong>A</strong></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><strong>B</strong></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><strong>C<sub>in</sub></strong></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><strong>S</strong></p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab"><strong>C<sub>out</sub></strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">How do we go about implementing a full adder? As the name implies, a full adder can be realized by combining two half adders (<a href="ch05.xhtml#ch5fig13">Figure 5-13</a>).</p>&#13;
<div class="image" id="ch5fig13"><img src="../images/fig5-13.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-13: A full adder circuit realized with two half adders and an OR gate</em></p>&#13;
<p class="indent">A full adder’s sum output (S) should be the sum of A and B (which we can calculate using one half adder—HA1) plus C<sub>in</sub> (which we can calculate with a second half adder—HA2), as shown in <a href="ch05.xhtml#ch5fig13">Figure 5-13</a>.</p>&#13;
<p class="indent">We also need our full adder to output a carry-out bit. This turns out to be simple to implement, because the full adder’s C<sub>out</sub> value is 1 if the carry-out from either half adder is 1. We can therefore use an OR gate to complete the full adder circuit, as shown in <a href="ch05.xhtml#ch5fig13">Figure 5-13</a>.</p>&#13;
<p class="indent">Here we see another example of encapsulation. Once this circuit is constructed, the functionality of a full adder can be used without knowledge of the specific implementation details. In the next section, let’s see how we can use full and half adders together to add a number with multiple bits.</p>&#13;
<h3 class="h3" id="lev1_32"><strong><span epub:type="pagebreak" id="page_80"/>A 4-bit Adder</strong></h3>&#13;
<p class="noindent">A full adder allows us to add two 1-bit numbers, plus a carry-in bit. This gives us a building block for creating a circuit that can add binary numbers with more than one place. Let’s now combine several 1-bit adder circuits to create a 4-bit adder. Let’s use a half adder for the least significant bit (since it doesn’t require a carry-in) and full adders for the other bits. The idea is to string the adders together so the carry-out from each adder flows into the carry-in of the subsequent adder, as shown in <a href="ch05.xhtml#ch5fig14">Figure 5-14</a>.</p>&#13;
<div class="image" id="ch5fig14"><img src="../images/fig5-14.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-14: A 4-bit adder</em></p>&#13;
<p class="indent">For consistency with the way people write numbers, I’ve arranged <a href="ch05.xhtml#ch5fig14">Figure 5-14</a> with the least significant bit on the right, and the diagram’s flow progressing from right to left. This means that our adder block diagrams will have inputs and outputs positioned differently than previously shown; don’t let that confuse you!</p>&#13;
<p class="indent">In <a href="ch05.xhtml#ch5fig15">Figure 5-15</a>, I applied our earlier example of two (0010) plus three (0011) to this 4-bit adder.</p>&#13;
<div class="image" id="ch5fig15"><img src="../images/fig5-15.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-15: A 4-bit adder in action</em></p>&#13;
<p class="indent">In <a href="ch05.xhtml#ch5fig15">Figure 5-15</a>, we can see how each bit from input A (0010) and input B (0011) is fed into each subsequent adder unit, starting with the least <span epub:type="pagebreak" id="page_81"/>significant bit on the right, moving to the most significant bit on the left. You can follow the flow of the diagram by reading from right to left. Add the rightmost bits first, 0 (A0) and 1 (B0); the result is 1 (S0) with a carry of 0.</p>&#13;
<p class="indent">The output carry bit from the rightmost adder flows into the next adder as C1, where 1 (A1) and 1 (B1) are added, along with the carry of 0. This results in 0 (S1) with a carry of 1 (C2). The process continues until the leftmost adder completes. The final result is a set of the output bits, 0101 (S3 to S0), and a carry of 0 (C4). If we need to handle a larger number of bits, we can extend the design in <a href="ch05.xhtml#ch5fig15">Figure 5-15</a> by simply incorporating more full adders.</p>&#13;
<p class="indent">This type of adder requires the carry bits to propagate, or ripple, through the circuit. For this reason, we call this circuit a <em>ripple carry adder</em>. Each carry bit that ripples to the next full adder introduces a small delay, so extending the design to handle more bits makes the circuit slower. The output of the circuit will be inaccurate until all the carry bits have time to propagate.</p>&#13;
<p class="indent">Several versions of 4-bit adders are available in the 7400 series of ICs. If you need a 4-bit adder in a project, you can use such an IC rather than construct the adder from individual logic gates.</p>&#13;
<p class="indent">Let’s pause here and consider the broader implications of what we’ve just covered. Yes, you learned how to build a 4-bit adder, but how does this relate to computing? Recall that computers are electronic devices that can be programmed to carry out a set of logical instructions. Those instructions include mathematical operations, and we just saw how logic gates, built from transistors, can be combined to perform one of those operations—addition. We covered addition as a concrete example of a computer operation, and although we don’t go into the details in this book, you can also implement other fundamental computer operations with logic gates. This is how computers work—simple logic gates work together to perform complex tasks.</p>&#13;
<h3 class="h3" id="lev1_33"><strong>Signed Numbers</strong></h3>&#13;
<p class="noindent">Thus far in this chapter we’ve only concerned ourselves with positive integers, but what if we want to be able to handle negative integers as well? First, we need to consider how a negative number can be represented in a digital system like a computer. As you know, all data in a computer is represented as sequences of 0s and 1s. A negative sign is neither a 0 nor a 1, so we need to adopt a convention for representing negative values in a digital system. In computing, a <em>signed number</em> is a sequence of bits that can be used to represent a negative or positive number, depending on the specific values of those bits.</p>&#13;
<p class="indent">A digital system’s design must define how many bits are used to represent an integer. Typically, we represent integers using 8, 16, 32, or 64 bits. One of those bits can be assigned to represent a negative sign. We can, for example, say that if the most significant bit is 0, then the number is positive, and if the most significant bit is 1, then the number is negative. The remaining bits are then used to represent the absolute value of the number. This approach is known as <em>signed magnitude representation</em>. This works, but it requires extra complexity in a system’s design to account for the bit that has a special meaning. For example, the adder circuits we built earlier would need to be modified to account for the sign bit.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_82"/>A better way to represent negative numbers in a computer is known as <em>two’s complement</em>. In this context, the two’s complement of a number represents the negative of that number. The simplest way to find the two’s complement of a number is to replace every 1 with a 0 and every 0 with a 1 (in other words, flip the bits), and then add 1. Hang tight with me here; this is going to seem overly complicated at first, but if you follow the details, it will make sense.</p>&#13;
<p class="indent">Let’s take a 4-bit example, the number 5, or 0101 in binary. <a href="ch05.xhtml#ch5fig16">Figure 5-16</a> shows the process of finding the two’s complement of this number.</p>&#13;
<div class="image" id="ch5fig16"><img src="../images/fig5-16.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-16: Finding the two’s complement of 0101</em></p>&#13;
<p class="indent">First, we flip the bits, then we add one, giving us 1011 binary. So, in this system, 5 is represented as 0101 and –5 is represented as 1011. Keep in mind that 1011 only represents –5 in the context of a 4-bit signed number. That binary sequence could be interpreted in other ways in a different context, as we will see later. What if we want to go the other way, starting with the negative value? The process is the same, as shown in <a href="ch05.xhtml#ch5fig17">Figure 5-17</a>.</p>&#13;
<div class="image" id="ch5fig17"><img src="../images/fig5-17.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-17: Finding the two’s complement of 1011</em></p>&#13;
<p class="indent">As you can see in <a href="ch05.xhtml#ch5fig17">Figure 5-17</a>, taking the two’s complement of –5 gets us back to the original value of 5. This makes sense, given that the negative of –5 is 5.</p>&#13;
<div class="sidebar">&#13;
<p class="exercise" id="ch5ex2"><strong>EXERCISE 5-2: FIND THE TWO’S COMPLEMENT</strong></p>&#13;
<p class="exercise-para">Find the 4-bit two’s complement of 6. See <a href="appa.xhtml">Appendix A</a> for the answer.</p>&#13;
</div>&#13;
<p class="indent">Now we know how to represent a number as a positive value or a negative value using two’s complement, but how is this useful? I think the easiest way to see the benefits of this system is to just try it. Let’s say we want to add 7 and –3 (that is, subtract 3 from 7). We expect the result to be positive 4. Let’s first determine what our inputs are in binary, shown in <a href="ch05.xhtml#ch5fig18">Figure 5-18</a>.</p>&#13;
<div class="image" id="ch5fig18"><img src="../images/fig5-18.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-18: Find the 4-bit two’s complement form of 7 and –3.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_83"/>Our two binary inputs will be 0111 and 1101. Now, forget for a moment that we’re dealing with positive and negative values. Just add the two binary numbers. Don’t worry about what the bits represent, just add them, and prepare to be amazed! Look at <a href="ch05.xhtml#ch5fig19">Figure 5-19</a> once you’ve done the binary math.</p>&#13;
<div class="image" id="ch5fig19"><img src="../images/fig5-19.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-19: Addition of two binary numbers, interpreted as signed decimal</em></p>&#13;
<p class="indent">As you can see in <a href="ch05.xhtml#ch5fig19">Figure 5-19</a>, this addition results in a carry-out bit beyond what a 4-bit number can represent. I’ll explain this in more detail later, but for now, we can ignore that carry-out bit. This gives us a 4-bit result of 0100, which is positive 4, our expected number! That’s the beauty of two’s complement notation. We don’t have to do anything special during the addition or subtraction operation; it just works.</p>&#13;
<p class="indent">Let’s pause here and reflect on the implications of this. Remember those adder circuits we built earlier? They will work for negative values too! Any circuit designed to handle binary addition can use the two’s complement as a means of handling negative numbers or subtraction. The detailed mathematical explanation for why all of this works is outside the scope of this book; if you are curious, there are good explanations available online.</p>&#13;
<div class="sidebar">&#13;
<p class="exercise"><strong>TWO’S COMPLEMENT TERMINOLOGY</strong></p>&#13;
<p class="exercise-para">The term <em>two’s complement</em> actually refers to two related concepts. Two’s complement is a form of <em>notation</em> for representing positive and negative integers. For example, the number 5, represented in 4-bit two’s complement notation is 0101, whereas –5 is represented as 1011. At the same time, two’s complement is also an <em>operation</em> used to negate an integer stored in two’s complement format. For example, taking the two’s complement of 0101 gives us 1011.</p>&#13;
</div>&#13;
<p class="indent">Here’s another way to look at two’s complement notation: the most significant place has a weight equal to the negative value of that place, and all other places have weights equal to the positive values of those places. So, for a 4-bit number, the places have the weights shown in <a href="ch05.xhtml#ch5fig20">Figure 5-20</a>.</p>&#13;
<span epub:type="pagebreak" id="page_84"/>&#13;
<div class="image" id="ch5fig20"><img src="../images/fig5-20.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-20: Place-value weights of a signed 4-bit number using two’s complement notation</em></p>&#13;
<p class="indent">If we then apply this approach to the two’s complement representation of –3 (1101), we can calculate the decimal value as shown in <a href="ch05.xhtml#ch5fig21">Figure 5-21</a>.</p>&#13;
<div class="image" id="ch5fig21"><img src="../images/fig5-21.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-21: Find the signed decimal value of 1101 using two’s complement place value.</em></p>&#13;
<p class="indent">When dealing with two’s complement, I find that looking at the most significant place’s weight as equal to the negative value of that place is a convenient mental shortcut. Now that we have covered the weights of all the places in a 4-bit signed number, we can examine the full range of values that can be represented with such a number, as shown in <a href="ch05.xhtml#ch5tab3">Table 5-3</a>.</p>&#13;
<p class="tabcap" id="ch5tab3"><strong>Table 5-3:</strong> All Possible Values of a 4-bit Signed Number</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Binary</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Signed decimal</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0000</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">0001</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0010</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">0011</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">3</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0100</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">0101</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">5</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0110</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">6</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">0111</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">7</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1000</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">–8</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">1001</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">–7</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1010</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">–6</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab"><span epub:type="pagebreak" id="page_85"/>1011</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">–5</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1100</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">–4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">1101</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">–3</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1110</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">–2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">1111</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">–1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Given <a href="ch05.xhtml#ch5tab3">Table 5-3</a>, we can observe that for a signed 4-bit number, our maximum value is 7 and our most negative value is –8, for a total of 16 possible values. Note that anytime the most significant bit is 1, the value will be negative. We can generalize as follows for an <em>n</em>-bit signed number:</p>&#13;
<ul>&#13;
<li class="noindent">Maximum value: (2<sup><em>n</em>–1</sup>) – 1</li>&#13;
<li class="noindent">Minimum value: –(2<sup><em>n</em>–1</sup>)</li>&#13;
<li class="noindent">Count of unique values: 2<sup><em>n</em></sup></li>&#13;
</ul>&#13;
<p class="indent">So, for an 8-bit signed number (as an example), we find that</p>&#13;
<ul>&#13;
<li class="noindent">Maximum value = 127</li>&#13;
<li class="noindent">Minimum value = –128</li>&#13;
<li class="noindent">Count of unique values = 256</li>&#13;
</ul>&#13;
<h3 class="h3" id="lev1_34"><strong>Unsigned Numbers</strong></h3>&#13;
<p class="noindent">Signed integers that use two’s complement to represent negative values are a convenient way to handle negatives without requiring specialized adder hardware. The adder we covered earlier works just as well with negative values as it does with positive values. However, there are scenarios in computing in which negative values simply aren’t needed, and treating our numbers as signed simply wastes about half the range of values (all the negative values go unused), while also capping the maximum possible value to about half of what could otherwise be represented. Because of this, in such scenarios we want to treat numbers as <em>unsigned</em>, meaning the sequence of bits always represents a positive value or zero, but never a negative value.</p>&#13;
<p class="indent">Looking again at a 4-bit number, <a href="ch05.xhtml#ch5tab4">Table 5-4</a> shows what each 4-bit binary value represents if we interpret it as signed or unsigned.</p>&#13;
<p class="tabcap" id="ch5tab4"><strong>Table 5-4:</strong> All Possible Values of a 4-bit Number, Signed or Unsigned</p>&#13;
<table class="bordertb">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Binary</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Signed decimal</strong></p></th>&#13;
<th style="vertical-align: top;" class="borderb"><p class="tab"><strong>Unsigned decimal</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0000</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">0001</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0010</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">2</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab"><span epub:type="pagebreak" id="page_86"/>0011</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">3</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">3</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0100</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">4</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">0101</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">5</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">5</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">0110</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">6</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">6</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">0111</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">7</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">7</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1000</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">–8</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">8</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">1001</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">–7</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">9</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1010</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">–6</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">10</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">1011</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">–5</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">11</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1100</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">–4</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">12</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">1101</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">–3</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">13</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">1110</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">–2</p></td>&#13;
<td style="vertical-align: top;" class="bg-g"><p class="tab">14</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;"><p class="tab">1111</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">–1</p></td>&#13;
<td style="vertical-align: top;"><p class="tab">15</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">We can generalize as follows for an <em>n</em>-bit unsigned number:</p>&#13;
<ul>&#13;
<li class="noindent">Maximum value: (2<sup><em>n</em></sup>) – 1</li>&#13;
<li class="noindent">Minimum value: 0</li>&#13;
<li class="noindent">Count of unique values: 2<sup><em>n</em></sup></li>&#13;
</ul>&#13;
<p class="indent">So, let’s take an example 4-bit value, say 1011. Looking at <a href="ch05.xhtml#ch5tab4">Table 5-4</a>, what does it represent? Does it represent –5 or does it represent 11? The answer is “it depends!” It can represent either –5 or 11, depending on the context. From an adder circuit’s point of view, it doesn’t matter. As far as the adder is concerned, the 4-bit value is just 1011. Any addition operation is performed the same way regardless; the only difference is how we interpret the result. Let’s look at an example. In <a href="ch05.xhtml#ch5fig22">Figure 5-22</a>, we add two binary numbers: 1011 and 0010.</p>&#13;
<div class="image" id="ch5fig22"><img src="../images/fig5-22.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-22: Adding two binary numbers, interpreted as signed or unsigned</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_87"/>As you can see in <a href="ch05.xhtml#ch5fig22">Figure 5-22</a>, adding those two binary numbers results in 1101, regardless of whether we’re working with signed or unsigned numbers. After the calculation is complete, we get to decide how to interpret that result. Either we just added –5 and 2 and the result was –3, or we added 11 and 2 and the result was 13. In either case the math works out; it’s just a matter of interpretation! In the context of computing, it is the program running on a computer that is responsible for correctly interpreting the result of an addition operation as signed or unsigned.</p>&#13;
<div class="sidebar">&#13;
<p class="exercise" id="ch5ex3"><strong>EXERCISE 5-3: ADD TWO BINARY NUMBERS AND INTERPRET AS SIGNED AND UNSIGNED</strong></p>&#13;
<p class="exercise-para">Add 1000 and 0110. Interpret your work as signed numbers. Then interpret it as unsigned. Do the results make sense? See <a href="appa.xhtml">Appendix A</a> for the answer.</p>&#13;
</div>&#13;
<p class="indent">So far, we’ve mostly ignored the most significant carry-out bit, but it has a meaning that should be understood. For unsigned numbers, a carry-out of 1 means that an <em>integer overflow</em> has occurred. In other words, the result is too large to be represented by the number of bits assigned to represent an integer. For signed numbers, if the most significant carry-in bit is not equal to the most significant carry-out bit, then an overflow has occurred. Also for signed numbers, if the most significant carry-in is equal to the most significant carry-out, then no overflow has occurred, and the carry-out bit can be ignored.</p>&#13;
<p class="indent">Integer overflows are a source of errors in computer programs. If a program does not check if an overflow has occurred, then the result of an addition operation may be incorrectly interpreted, leading to unexpected behavior. A famous example of an integer overflow error is found in the arcade game Pac-Man. When the player reaches level 256, the right side of the screen is filled with garbled graphics. This happens because the level number is stored as an 8-bit unsigned integer, and adding 1 to its maximum value of 255 results in an overflow. The game’s logic doesn’t account for this condition, leading to the glitch.</p>&#13;
<h3 class="h3" id="lev1_35"><strong>Summary</strong></h3>&#13;
<p class="noindent">In this chapter, we used addition as an example of how computers build upon logic gates to perform complex tasks. You learned how to perform addition in binary and how to construct hardware that can add binary numbers from logic gates. You saw how a half adder can add 2 bits and produce a sum and a carry-out bit, whereas a full adder can add 2 bits plus a carry-in bit. We covered how single-bit adders can be combined to perform multi-bit addition. You also learned how integers are represented in a computer using signed and unsigned numbers.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_88"/>In the next chapter, we’ll move beyond combinational logic circuits and learn about sequential logic. With sequential logic, hardware can have memory, allowing for the storage and retrieval of data. You’ll see how memory circuits can be built. We’ll also cover clock signals, a method of synchronizing the state of multiple components in a computer system.</p>&#13;
<div class="sidebarp">&#13;
<span epub:type="pagebreak" id="page_89"/>&#13;
<p class="exercise" id="proj5"><strong><span class="black1">PROJECT #5: BUILD A HALF ADDER</span></strong></p>&#13;
<p class="exercise-para">In this project, you’ll construct a half adder using an XOR gate and an AND gate. The inputs will be controlled with switches or pushbuttons. The outputs should be connected to LEDs to easily observe their states. For this project, you’ll need the following components:</p>&#13;
<ul>&#13;
<li class="noindent_sidebar">Breadboard</li>&#13;
<li class="noindent_sidebar">Two LEDs</li>&#13;
<li class="noindent_sidebar">Two current-limiting resistors to use with your LEDs (approximately 220Ω)</li>&#13;
<li class="noindent_sidebar">Jumper wires</li>&#13;
<li class="noindent_sidebar">7408 IC (contains four AND gates)</li>&#13;
<li class="noindent_sidebar">7486 IC (contains four XOR gates)</li>&#13;
<li class="noindent_sidebar">Two pushbuttons or switches that will fit a breadboard</li>&#13;
<li class="noindent_sidebar">Two 470Ω resistors</li>&#13;
<li class="noindent_sidebar">5-volt power supply</li>&#13;
</ul>&#13;
<p class="exercise-parai">As a reminder, see the sections “Buying Electronic Components” on <a href="appb.xhtml#page_333">page 333</a> and “Powering Digital Circuits” on <a href="appb.xhtml#page_336">page 336</a> if you need help on those topics. For a reminder of how the pins are numbered on the 7408 IC, see <a href="ch04.xhtml#ch4fig14">Figure 4-14</a>. The 7486 IC wasn’t covered previously, so I’m including its pinout diagram here in <a href="ch05.xhtml#ch5fig23">Figure 5-23</a>.</p>&#13;
<div class="image" id="ch5fig23"><img src="../images/fig5-23.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-23: Pinout diagram for the 7486 XOR integrated circuit</em></p>&#13;
<p class="exercise-parai"><a href="ch05.xhtml#ch5fig24">Figure 5-24</a> provides the wiring diagram for a half adder. Keep reading past the figure for more details on how to build this circuit.</p>&#13;
<span epub:type="pagebreak" id="page_90"/>&#13;
<div class="image" id="ch5fig24"><img src="../images/fig5-24.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-24: Half adder built from XOR and AND gates</em></p>&#13;
<p class="exercise-parai"><a href="ch05.xhtml#ch5fig24">Figure 5-24</a> shows the connections for switches, with pull-down resistors, and for LEDs, with current-limiting resistors. Also note the pin numbers on the 7486 and 7408 ICs, shown in boxes. Note the black dots found on the wires connecting A and B to the resistors and ICs. The dots represent a connection point—for example, switch A, the 470Ω resistor, pin 1 on the 7486 IC, and pin 4 on the 7408 IC are all connected. Don’t forget to connect the 7486 and 7408 ICs to 5V and ground via pins 14 and 7 (not shown in <a href="ch05.xhtml#ch5fig24">Figure 5-24</a>), respectively.</p>&#13;
<p class="exercise-parai"><a href="ch05.xhtml#ch5fig25">Figure 5-25</a> shows how this circuit could look when implemented on a breadboard.</p>&#13;
<div class="image" id="ch5fig25"><img src="../images/fig5-25.jpg" alt="image"/></div>&#13;
<p class="figcap"><em>Figure 5-25: Half adder built from XOR and AND gates</em></p>&#13;
<p class="exercise-parai">Once you’ve constructed this circuit, try all combinations of inputs A and B to confirm that the outputs match the expected values as shown in the half adder truth table (<a href="ch05.xhtml#ch5tab1">Table 5-1</a>).</p>&#13;
</div>&#13;
</body></html>