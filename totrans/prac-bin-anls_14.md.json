["```\n    /* some #includes omitted for brevity */\n\n➊  #include \"pin.H\"\n\n➋  #include \"branch_pred.h\"\n   #include \"libdft_api.h\"\n   #include \"syscall_desc.h\"\n   #include \"tagmap.h\"\n\n➌  extern syscall_desc_t syscall_desc[SYSCALL_MAX];\n\n   void alert(uintptr_t addr, const char *source, uint8_t tag);\n   void check_string_taint(const char *str, const char *source);\n   static void post_socketcall_hook(syscall_ctx_t *ctx);\n   static void pre_execve_hook(syscall_ctx_t *ctx);\n\n   int\n   main(int argc, char **argv)\n   {\n➍    PIN_InitSymbols();\n➎    if(unlikely(PIN_Init(argc, argv))) {\n        return 1;\n     }\n\n➏    if(unlikely(libdft_init() != 0)) {\n➐       libdft_die();\n        return 1;\n     }\n\n➑    syscall_set_post(&syscall_desc[__NR_socketcall], post_socketcall_hook);\n➒    syscall_set_pre (&syscall_desc[__NR_execve], pre_execve_hook);\n\n➒    PIN_StartProgram();\n\n     return 0;\n   }\n```", "```\n➊  extern ins_desc_t ins_desc[XED_ICLASS_LAST];\n   /* ... */\n➋  ins_set_post(&ins_desc[XED_ICLASS_RET_NEAR], dta_instrument_ret);\n```", "```\n   void\n➊  alert(uintptr_t addr, const char *source, uint8_t tag)\n   {\n     fprintf(stderr,\n       \"\\n(dta-execve) !!!!!!! ADDRESS 0x%x IS TAINTED (%s, tag=0x%02x), ABORTING !!!!!!!\\n\",\n       addr, source, tag);\n     exit(1);\n   }\n   void\n➋  check_string_taint(const char *str, const char *source)\n   {\n     uint8_t tag;\n     uintptr_t start = (uintptr_t)str;\n     uintptr_t end   = (uintptr_t)str+strlen(str);\n\n     fprintf(stderr, \"(dta-execve) checking taint on bytes 0x%x -- 0x%x (%s)... \",\n             start, end, source);\n\n➌   for(uintptr_t addr = start; addr <= end; addr++) {\n➍      tag = tagmap_getb(addr);\n➎      if(tag != 0) alert(addr, source, tag);\n     }\n\n     fprintf(stderr, \"OK\\n\");\n   }\n```", "```\n   static void\n   post_socketcall_hook(syscall_ctx_t *ctx)\n   {\n     int fd;\n     void *buf;\n     size_t len;\n\n➊   int call            =            (int)ctx->arg[SYSCALL_ARG0];\n➋   unsigned long *args = (unsigned long*)ctx->arg[SYSCALL_ARG1];\n\n     switch(call) {\n➌   case SYS_RECV:\n     case SYS_RECVFROM:\n➍      if(unlikely(ctx->ret <= 0)) {\n          return;\n       }\n\n➎     fd =     (int)args[0];\n➏     buf =  (void*)args[1];\n➐     len = (size_t)ctx->ret;\n\n       fprintf(stderr, \"(dta-execve) recv: %zu bytes from fd %u\\n\", len, fd);\n\n       for(size_t i = 0; i < len; i++) {\n         if(isprint(((char*)buf)[i])) fprintf(stderr, \"%c\", ((char*)buf)[i]);\n         else                         fprintf(stderr, \"\\\\x%02x\", ((char*)buf)[i]);\n       }\n       fprintf(stderr, \"\\n\");\n\n       fprintf(stderr, \"(dta-execve) tainting bytes %p -- 0x%x with tag 0x%x\\n\",\n               buf, (uintptr_t)buf+len, 0x01);\n\n➑      tagmap_setn((uintptr_t)buf, len, 0x01);\n\n       break;\n     default:\n       break;\n     }\n   }\n```", "```\n   static void\n   pre_execve_hook(syscall_ctx_t *ctx)\n   {\n➊   const char *filename = (const char*)ctx->arg[SYSCALL_ARG0];\n➋   char * const *args   = (char* const*)ctx->arg[SYSCALL_ARG1];\n➌   char * const *envp   = (char* const*)ctx->arg[SYSCALL_ARG2];\n\n     fprintf(stderr, \"(dta-execve) execve: %s (@%p)\\n\", filename, filename);\n\n➍    check_string_taint(filename, \"execve command\");\n➎    while(args && *args) {\n        fprintf(stderr, \"(dta-execve) arg: %s (@%p)\\n\", *args, *args);\n➏       check_string_taint(*args, \"execve argument\");\n        args++;\n     }\n➐    while(envp && *envp) {\n        fprintf(stderr, \"(dta-execve) env: %s (@%p)\\n\", *envp, *envp);\n➑       check_string_taint(*envp, \"execve environment parameter\");\n        envp++;\n     }\n   }\n```", "```\n   int\n   main(int argc, char *argv[])\n   {\n     char buf[4096];\n     struct sockaddr_storage addr;\n\n➊   int sockfd = open_socket(\"localhost\", \"9999\");\n\n     socklen_t addrlen = sizeof(addr);\n➋   recvfrom(sockfd, buf, sizeof(buf), 0, (struct sockaddr*)&addr, &addrlen);\n\n➌   int child_fd = exec_cmd(buf);\n➍   FILE *fp = fdopen(child_fd, \"r\");\n\n     while(fgets(buf, sizeof(buf), fp)) {\n➎       sendto(sockfd, buf, strlen(buf)+1, 0, (struct sockaddr*)&addr, addrlen);\n     }\n\n     return 0;\n   }\n```", "```\n➊  static struct __attribute__((packed)) {\n➋   char prefix[32];\n     char datefmt[32];\n     char cmd[64];\n   } cmd = { \"date: \", \"\\%Y-\\%m-\\%d \\%H:\\%M:\\%S\",\n             \"/home/binary/code/chapter11/date\" };\n\n   int\n   exec_cmd(char *buf)\n   {\n     int pid;\n     int p[2];\n     char *argv[3];\n\n➌   for(size_t i = 0; i < strlen(buf); i++) { /* Buffer overflow! */\n       if(buf[i] == '\\n') {\n         cmd.prefix[i] = '\\0';\n         break;\n       }\n       cmd.prefix[i] = buf[i];\n    }\n\n➍   argv[0] = cmd.cmd;\n    argv[1] = cmd.datefmt;\n    argv[2] = NULL;\n\n➎   pipe(p);\n➏   switch(pid = fork()) {\n    case -1: /* Error */\n      perror(\"(execve-test) fork failed\");\n      return -1;\n➐   case 0: /* Child */\n       printf(\"(execve-test/child) execv: %s %s\\n\", argv[0], argv[1]);\n\n➑     close(1);\n       dup(p[1]);\n       close(p[0]);\n\n       printf(\"%s\", cmd.prefix);\n       fflush(stdout);\n➒     execv(argv[0], argv);\n       perror(\"(execve-test/child) execv failed\");\n       kill(getppid(), SIGINT);\n       exit(1);\n     default: /* Parent */\n       close(p[1]);\n       return p[0];\n     }\n\n     return -1;\n  }\n```", "```\n   $ cd /home/binary/code/chapter11/\n➊ $ ./execve-test-overflow &\n   [1] 2506\n➋ $ nc -u 127.0.0.1 9999\n➌ foobar:\n   (execve-test/child) execv: /home/binary/code/chapter11/date %Y-%m-%d %H:%M:%S\n➍ foobar: 2017-12-06 15:25:08\n   ˆC\n   [1]+ Done                     ./execve-test-overflow\n➎ $ ./execve-test-overflow &\n   [1] 2533\n➏ $ nc -u 127.0.0.1 9999\n➐ AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB/home/binary/code/chapter11/echo\n   (execve-test/child) execv: /home/binary/code/chapter11/echo BB...BB/home/binary/.../echo\n➑ AA...AABB...BB/home/binary/code/chapter11/echo BB...BB/home/binary/code/chapter11/echo\n   ˆC\n   [1]+ Done                     ./execve-test-overflow\n```", "```\nstatic struct __attribute__((packed)) {\n  char prefix[32];  /* AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA */\n  char datefmt[32]; /* BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB */\n  char cmd[64];     /* /home/binary/code/chapter11/echo */\n} cmd;\n```", "```\n   $ cd /home/binary/libdft/pin-2.13-61206-gcc.4.4.7-linux/\n➊  $ ./pin.sh -follow_execv -t /home/binary/code/chapter11/dta-execve.so \\\n              -- /home/binary/code/chapter11/execve-test-overflow &\n   [1] 2994\n➋  $ nc -u 127.0.0.1 9999\n➌  AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB/home/binary/code/chapter11/echo\n➍  (dta-execve) recv: 97 bytes from fd 4\n    AA...AABB...BB/home/binary/code/chapter11/echo\\x0a\n➎  (dta-execve) tainting bytes 0xffa231ec -- 0xffa2324d with tag 0x1\n➏  (execve-test/child) execv: /home/binary/code/chapter11/echo BB...BB/home/binary/.../echo\n➐  (dta-execve) execve: /home/binary/code/chapter11/echo (@0x804b100)\n➑  (dta-execve) checking taint on bytes 0x804b100 -- 0x804b120 (execve command)...\n➒  (dta-execve) !!!!!!! ADDRESS 0x804b100 IS TAINTED (execve command, tag=0x01), ABORTING !!!!!!!\n➓   AA...AABB...BB/home/binary/code/chapter11/echo\n    [1]+ Done ./pin.sh -follow_execv ...\n```", "```\n  int\n  exec_cmd(char *buf)\n  {\n    int pid;\n    int p[2];\n    char *argv[3];\n\n➊   for(size_t i = 0; i < strlen(buf); i++) {\n       if(buf[i] == '\\n') {\n         cmd.prefix[i] = '\\0';\n         break;\n       }\n➋      char c = 0;\n➌      while(c < buf[i]) c++;\n➍      cmd.prefix[i] = c;\n    }\n\n    /* Set up argv and continue with execv */\n  }\n```", "```\n➊  #include \"pin.H\"\n\n   #include  \"branch_pred.h\"\n   #include  \"libdft_api.h\"\n   #include  \"syscall_desc.h\"\n   #include  \"tagmap.h\"\n\n➋  extern syscall_desc_t syscall_desc[SYSCALL_MAX];\n➌  static std::map<int, uint8_t> fd2color;\n➍  static std::map<uint8_t, std::string> color2fname;\n\n➎  #define MAX_COLOR 0x80\n\n   void alert(uintptr_t addr, uint8_t tag);\n   static void post_open_hook(syscall_ctx_t *ctx);\n   static void post_read_hook(syscall_ctx_t *ctx);\n   static void pre_socketcall_hook(syscall_ctx_t *ctx);\n\n   int\n   main(int argc, char **argv)\n   {\n     PIN_InitSymbols();\n\n     if(unlikely(PIN_Init(argc, argv))) {\n       return 1;\n     }\n\n     if(unlikely(libdft_init() != 0)) {\n       libdft_die();\n       return 1;\n     }\n\n➏  syscall_set_post(&syscall_desc[__NR_open], post_open_hook);\n➐  syscall_set_post(&syscall_desc[__NR_read], post_read_hook);\n➑  syscall_set_pre (&syscall_desc[__NR_socketcall], pre_socketcall_hook);\n\n   PIN_StartProgram();\n\n   return 0;\n }\n```", "```\n   void\n   alert(uintptr_t addr, uint8_t tag)\n   {\n➊   fprintf(stderr,\n       \"\\n(dta-dataleak) !!!!!!! ADDRESS 0x%x IS TAINTED (tag=0x%02x), ABORTING !!!!!!!\\n\",\n       addr, tag);\n\n➋   for(unsigned c = 0x01; c <= MAX_COLOR; c <<= 1) {\n➌     if(tag & c) {\n➍       fprintf(stderr, \" tainted by color = 0x%02x (%s)\\n\", c, color2fname[c].c_str());\n      }\n    }\n➎   exit(1);\n  }\n```", "```\n   static void\n   post_open_hook(syscall_ctx_t *ctx)\n   {\n➊   static uint8_t next_color = 0x01;\n     uint8_t color;\n➋   int fd            =         (int)ctx->ret;\n➌   const char *fname = (const char*)ctx->arg[SYSCALL_ARG0];\n\n➍   if(unlikely((int)ctx->ret < 0)) {\n       return;\n     }\n\n➎   if(strstr(fname, \".so\") || strstr(fname, \".so.\")) {\n       return;\n     }\n\n     fprintf(stderr, \"(dta-dataleak) opening %s at fd %u with color 0x%02x\\n\",\n            fname, fd, next_color);\n\n➏    if(!fd2color[fd]) {\n        color = next_color;\n        fd2color[fd] = color;\n➐      if(next_color < MAX_COLOR) next_color <<= 1;\n➑    } else {\n       /* reuse color of file with same fd that was opened previously */\n       color = fd2color[fd];\n     }\n\n     /* multiple files may get the same color if the same fd is reused\n     * or we run out of colors */\n➒   if(color2fname[color].empty()) color2fname[color] = std::string(fname);\n➓   else color2fname[color] += \" | \" + std::string(fname);\n  }\n```", "```\n   static void\n   post_read_hook(syscall_ctx_t *ctx)\n   {\n➊    int fd     =    (int)ctx->arg[SYSCALL_ARG0];\n➋    void *buf  =  (void*)ctx->arg[SYSCALL_ARG1];\n➌    size_t len = (size_t)ctx->ret;\n     uint8_t color;\n\n➍    if(unlikely(len <= 0)) {\n       return;\n     }\n\n     fprintf(stderr, \"(dta-dataleak) read: %zu bytes from fd %u\\n\", len, fd);\n\n➎    color = fd2color[fd];\n➏    if(color) {\n        fprintf(stderr, \"(dta-dataleak) tainting bytes %p -- 0x%x with color 0x%x\\n\",\n               buf, (uintptr_t)buf+len, color);\n➐      tagmap_setn((uintptr_t)buf, len, color);\n➑    } else {\n       fprintf(stderr, \"(dta-dataleak) clearing taint on bytes %p -- 0x%x\\n\",\n               buf, (uintptr_t)buf+len);\n➒      tagmap_clrn((uintptr_t)buf, len);\n     }\n   }\n```", "```\n   static void\n   pre_socketcall_hook(syscall_ctx_t *ctx)\n   {\n     int fd;\n     void *buf;\n     size_t i, len;\n     uint8_t tag;\n     uintptr_t start, end, addr;\n\n➊   int call            =            (int)ctx->arg[SYSCALL_ARG0];\n➋   unsigned long *args = (unsigned long*)ctx->arg[SYSCALL_ARG1];\n\n     switch(call) {\n➌    case SYS_SEND:\n     case SYS_SENDTO:\n➍     fd  =    (int)args[0];\n       buf =  (void*)args[1];\n       len = (size_t)args[2];\n\n       fprintf(stderr, \"(dta-dataleak) send: %zu bytes to fd %u\\n\", len, fd);\n\n       for(i = 0; i < len; i++) {\n         if(isprint(((char*)buf)[i])) fprintf(stderr, \"%c\", ((char*)buf)[i]);\n         else                         fprintf(stderr, \"\\\\x%02x\", ((char*)buf)[i]);\n       }\n       fprintf(stderr, \"\\n\");\n\n       fprintf(stderr, \"(dta-dataleak) checking taint on bytes %p -- 0x%x...\",\n              buf, (uintptr_t)buf+len);\n\n       start = (uintptr_t)buf;\n       end   = (uintptr_t)buf+len;\n➎     for(addr = start; addr <= end; addr++) {\n➏        tag = tagmap_getb(addr);\n➐        if(tag != 0) alert(addr, tag);\n       }\n\n       fprintf(stderr, \"OK\\n\");\n          break;\n\n       default:\n          break;\n       }\n    }\n```", "```\n   int\n   main(int argc, char *argv[])\n   {\n     size_t i, j, k;\n     FILE *fp[10];\n     char buf[4096], *filenames[10];\n     struct sockaddr_storage addr;\n\n     srand(time(NULL));\n\n➊   int sockfd = open_socket(\"localhost\", \"9999\");\n\n     socklen_t addrlen = sizeof(addr);\n➋   recvfrom(sockfd, buf, sizeof(buf), 0, (struct sockaddr*)&addr, &addrlen);\n\n➌   size_t fcount = split_filenames(buf, filenames, 10);\n\n➍   for(i = 0; i < fcount; i++) {\n       fp[i] = fopen(filenames[i], \"r\");\n     }\n\n➎   i = rand() % fcount;\n     do { j = rand() % fcount; } while(j == i);\n\n     memset(buf1, '\\0', sizeof(buf1));\n     memset(buf2, '\\0', sizeof(buf2));\n\n➏   while(fgets(buf1, sizeof(buf1), fp[i]) && fgets(buf2, sizeof(buf2), fp[j])) {\n       /* sizeof(buf)-1 ensures that there will be a final NULL character\n        * regardless of the XOR-ed values */\n       for(k = 0; k < sizeof(buf1)-1 && k < sizeof(buf2)-1; k++) {\n➐       buf1[k] ˆ= buf2[k];\n       }\n➑     sendto(sockfd, buf1, strlen(buf1)+1, 0, (struct sockaddr*)&addr, addrlen);\n     }\n\n     return 0;\n   }\n```", "```\n   $ cd ~/libdft/pin-2.13-61206-gcc.4.4.7-linux/\n➊ $./pin.sh -follow_execv -t ~/code/chapter11/dta-dataleak.so \\\n             -- ~/code/chapter11/dataleak-test-xor &\n\n➋ (dta-dataleak) read: 512 bytes from fd 4\n   (dta-dataleak) clearing taint on bytes 0xff8b34d0 -- 0xff8b36d0\n   [1] 22713\n➌ $ nc -u 127.0.0.1 9999\n➍ /home/binary/code/chapter11/dta-execve.cpp .../dta-dataleak.cpp .../date.c .../echo.c\n➎ (dta-dataleak) opening /home/binary/code/chapter11/dta-execve.cpp at fd 5 with color 0x01\n   (dta-dataleak) opening /home/binary/code/chapter11/dta-dataleak.cpp at fd 6 with color 0x02\n   (dta-dataleak) opening /home/binary/code/chapter11/date.c at fd 7 with color 0x04\n   (dta-dataleak) opening /home/binary/code/chapter11/echo.c at fd 8 with color 0x08\n➏ (dta-dataleak) read: 155 bytes from fd 8\n   (dta-dataleak) tainting bytes 0x872a5c0 -- 0x872a65b with color 0x8\n➐ (dta-dataleak) read: 3923 bytes from fd 5\n   (dta-dataleak) tainting bytes 0x872b5c8 -- 0x872c51b with color 0x1\n➑ (dta-dataleak) send: 20 bytes to fd 4\n   \\x0cCdclude <stdio.h>\\x0a\\x00\n➒ (dta-dataleak) checking taint on bytes 0xff8b19cc -- 0xff8b19e0...\n➓ (dta-dataleak) !!!!!!! ADDRESS 0xff8b19cc IS TAINTED (tag=0x09), ABORTING !!!!!!!\n     tainted by color = 0x01 (/home/binary/code/chapter11/dta-execve.cpp)\n     tainted by color = 0x08 (/home/binary/code/chapter11/echo.c)\n   [1]+ Exit 1 ./pin.sh -follow_execv -t ~/code/chapter11/dta-dataleak.so ...\n```"]