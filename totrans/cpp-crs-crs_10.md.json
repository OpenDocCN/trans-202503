["```\n#include <cstdio>\n\nint main() {\n  int x{};\n  ++x; ➊\n  42; ➋\n  printf(\"The %d True Morty\\n\", x); ➌\n}\n--------------------------------------------------------------------------\nThe 1 True Morty ➌\n```", "```\n#include <cstdio>\n\nstruct Tracer {\n  Tracer(const char* name) : name{ name } {\n    printf(\"%s constructed.\\n\", name);\n  }\n  ~Tracer() {\n    printf(\"%s destructed.\\n\", name);\n  }\nprivate:\n  const char* const name;\n};\n\nint main() {\n  Tracer main{ \"main\" }; ➊\n  {\n    printf(\"Block a\\n\"); ➋\n    Tracer a1{ \"a1\" }; ➌\n    Tracer a2{ \"a2\" }; ➍\n }\n  {\n    printf(\"Block b\\n\"); ➎\n    Tracer b1{ \"b1\" }; ➏\n    Tracer b2{ \"b2\" }; ➐\n  }\n}\n--------------------------------------------------------------------------\nmain constructed. ➊\nBlock a ➋\na1 constructed. ➌\na2 constructed.➍\na2 destructed.\na1 destructed.\nBlock b ➎\nb1 constructed. ➏\nb2 constructed. ➐\nb2 destructed.\nb1 destructed.\nmain destructed.\n```", "```\nvoid randomize(uint32_t&);\n```", "```\nvoid randomize(uint32_t& x) {\n  x = 0x3FFFFFFF & (0x41C64E6D * x + 12345) % 0x80000000;\n}\n```", "```\n#include <cstdio>\n#include <cstdint>\n\nvoid randomize(uint32_t&); ➊\n\nint main() {\n  size_t iterations{}; ➋\n  uint32_t number{ 0x4c4347 }; ➌\n  while (number != 0x474343) { ➍\n    randomize(number); ➎\n    ++iterations; ➏\n  }\n  printf(\"%zu\", iterations); ➐\n}\n\nvoid randomize(uint32_t& x) {\n  x = 0x3FFFFFFF & (0x41C64E6D * x + 12345) % 0x80000000; ➑\n}\n--------------------------------------------------------------------------\n927393188 ➐\n```", "```\nstruct RandomNumberGenerator {\n  explicit RandomNumberGenerator(uint32_t seed) ➊\n    : number{ seed } {} ➋\n  uint32_t next(); ➌\nprivate:\n  uint32_t number;\n};\n```", "```\nuint32_t➊ RandomNumberGenerator::➋next() {\n  number = 0x3FFFFFFF & (0x41C64E6D * number + 12345) % 0x80000000; ➌\n  return number; ➍\n}\n```", "```\n#include <cstdio>\n#include <cstdint>\n\nstruct RandomNumberGenerator {\n  explicit RandomNumberGenerator(uint32_t seed)\n    : iterations{}➊, number { seed }➋ {}\n  uint32_t next(); ➌\n  size_t get_iterations() const; ➍\nprivate:\n  size_t iterations;\n  uint32_t number;\n};\n\nint main() {\n  RandomNumberGenerator rng{ 0x4c4347 }; ➎\n  while (rng.next() != 0x474343) { ➏\n    // Do nothing...\n  }\n  printf(\"%zu\", rng.get_iterations()); ➐\n}\n\nuint32_t RandomNumberGenerator::next() { ➑\n  ++iterations;\n  number = 0x3FFFFFFF & (0x41C64E6D * number + 12345) % 0x80000000;\n  return number;\n}\n\nsize_t RandomNumberGenerator::get_iterations() const { ➒\n  return iterations;\n}\n--------------------------------------------------------------------------\n927393188 ➐\n```", "```\nnamespace BroopKidron13 {\n  // All symbols declared within this block\n  // belong to the BroopKidron13 namespace\n}\n```", "```\nnamespace BroopKidron13 {\n  namespace Shaltanac {\n    // All symbols declared within this block\n    // belong to the BroopKidron13::Shaltanac namespace\n  }\n}\n```", "```\nnamespace BroopKidron13::Shaltanac {\n  // All symbols declared within this block\n  // belong to the BroopKidron13::Shaltanac namespace\n}\n```", "```\n#include <cstdio>\n\nnamespace BroopKidron13::Shaltanac { ➊\n  enum class Color { ➋\n    Mauve,\n    Pink,\n    Russet\n };\n}\n\nint main() {\n  const auto shaltanac_grass{ BroopKidron13::Shaltanac::Color::Russet➌ };\n  if(shaltanac_grass == BroopKidron13::Shaltanac::Color::Russet) {\n    printf(\"The other Shaltanac's joopleberry shrub is always \"\n           \"a more mauvey shade of pinky russet.\");\n  }\n}\n--------------------------------------------------------------------------\nThe other Shaltanac's joopleberry shrub is always a more mauvey shade of pinky russet.\n```", "```\nusing my-type;\n```", "```\n#include <cstdio>\n\nnamespace BroopKidron13::Shaltanac {\n  enum class Color {\n    Mauve,\n    Pink,\n    Russet\n  };\n}\n\nint main() {\n  using BroopKidron13::Shaltanac::Color; ➊\n  const auto shaltanac_grass = Color::Russet➋;\n  if(shaltanac_grass == Color::Russet➌) {\n    printf(\"The other Shaltanac's joopleberry shrub is always \"\n           \"a more mauvey shade of pinky russet.\");\n  }\n}\n--------------------------------------------------------------------------\nThe other Shaltanac's joopleberry shrub is always a more mauvey shade of pinky russet.\n```", "```\n#include <cstdio>\n\nnamespace BroopKidron13::Shaltanac {\n  enum class Color {\n    Mauve,\n    Pink,\n    Russet\n  };\n\n  struct JoopleberryShrub {\n    const char* name;\n    Color shade;\n  };\n\n  bool is_more_mauvey(const JoopleberryShrub& shrub) {\n    return shrub.shade == Color::Mauve;\n  }\n}\n\nusing namespace BroopKidron13::Shaltanac; ➊\nint main() {\n  const JoopleberryShrub➋ yours{\n    \"The other Shaltanac\",\n    Color::Mauve➌\n  };\n\n  if (is_more_mauvey(yours)➍) {\n    printf(\"%s's joopleberry shrub is always a more mauvey shade of pinky\"\n           \"russet.\", yours.name);\n  }\n}\n--------------------------------------------------------------------------\nThe other Shaltanac's joopleberry shrub is always a more mauvey shade of pinky\nrusset.\n```", "```\nusing type-alias = type-id;\n```", "```\n#include <cstdio>\n\nnamespace BroopKidron13::Shaltanac {\n  enum class Color {\n    Mauve,\n    Pink,\n    Russet\n  };\n}\n\nusing String = const char[260]; ➊\nusing ShaltanacColor = BroopKidron13::Shaltanac::Color; ➋\n\nint main() {\n  const auto my_color{ ShaltanacColor::Russet }; ➌\n  String saying { ➍\n    \"The other Shaltanac's joopleberry shrub is \"\n    \"always a more mauvey shade of pinky russet.\"\n  };\n  if (my_color == ShaltanacColor::Russet) {\n    printf(\"%s\", saying);\n  }\n}\n```", "```\n#include <cstdio>\n#include <stdexcept>\n\ntemplate <typename To, typename From>\nstruct NarrowCaster const { ➊\n  To cast(From value) {\n    const auto converted = static_cast<To>(value);\n    const auto backwards = static_cast<From>(converted);\n    if (value != backwards) throw std::runtime_error{ \"Narrowed!\" };\n    return converted;\n  }\n};\n\ntemplate <typename From>\nusing short_caster = NarrowCaster<short, From>; ➋\n\nint main() {\n  try {\n    const short_caster<int> caster; ➌\n    const auto cyclic_short = caster.cast(142857);\n    printf(\"cyclic_short: %d\\n\", cyclic_short);\n  } catch (const std::runtime_error& e) {\n    printf(\"Exception: %s\\n\", e.what()); ➍\n  }\n}\n--------------------------------------------------------------------------\nException: Narrowed! ➍\n```", "```\nauto [object-1, object-2, ...] = plain-old-data;\n```", "```\nstruct TextFile {\n  bool success; ➊\n  const char* contents; ➋\n  size_t n_bytes; ➌\n};\n```", "```\nTextFile read_text_file(const char* path);\n```", "```\n#include <cstdio>\n\nstruct TextFile { ➊\n  bool success;\n  const char* data;\n  size_t n_bytes;\n};\n\nTextFile read_text_file(const char* path) { ➋\n  const static char contents[]{ \"Sometimes the goat is you.\" };\n  return TextFile{\n    true,\n    contents,\n    sizeof(contents)\n  };\n}\n\nint main() {\n  const auto [success, contents, length]➌ = read_text_file(\"REAMDE.txt\"); ➍\n  if (success➎) {\n    printf(\"Read %zu bytes: %s\\n\", length➏, contents➐);\n  } else {\n    printf(\"Failed to open REAMDE.txt.\");\n  }\n}\n--------------------------------------------------------------------------\nRead 27 bytes: Sometimes the goat is you.\n```", "```\n#include <cstdio>\n#include <stdexcept>\n\n[[noreturn]] void pitcher() { ➊\n  throw std::runtime_error{ \"Knuckleball.\" }; ➋\n}\n\nint main() {\n  try {\n    pitcher(); ➌\n  } catch(const std::exception& e) {\n    printf(\"exception: %s\\n\", e.what()); ➍\n  }\n}\n--------------------------------------------------------------------------\nException: Knuckleball. ➍\n```", "```\nif (condition-1) {\n  // Execute only if condition-1 is true ➊\n} else if (condition-2) { // optional\n  // Execute only if condition-2 is true ➋\n}\n// ... as many else ifs as desired\n--snip--\n} else { // optional\n  // Execute only if none of the conditionals is true ➌\n}\n```", "```\n#include <cstdio>\n\ntemplate<typename T>\nconstexpr const char* sign(const T& x) {\n  const char* result{};\n  if (x == 0) { ➊\n    result = \"zero\";\n  } else if (x > 0) { ➋\n    result = \"positive\";\n  } else { ➌\n    result = \"negative\";\n  }\n  return result;\n}\n\nint main() {\n  printf(\"float 100 is %s\\n\", sign(100.0f));\n  printf(\"int  -200 is %s\\n\", sign(-200));\n printf(\"char    0 is %s\\n\", sign(char{}));\n}\n--------------------------------------------------------------------------\nfloat 100 is positive\nint  -200 is negative\nchar    0 is zero\n```", "```\nif (init-statement; condition-1) {\n  // Execute only if condition-1 is true\n} else if (init-statement; condition-2) { // optional\n  // Execute only if condition-2 is true\n}\n--snip--\n```", "```\n#include <cstdio>\n\nstruct TextFile {\n  bool success;\n  const char* data;\n  size_t n_bytes;\n};\n\nTextFile read_text_file(const char* path) {\n  --snip--\n}\n\nint main() {\n  if(const auto [success, txt, len]➊ = read_text_file(\"REAMDE.txt\"); success➋)\n  {\n    printf(\"Read %d bytes: %s\\n\", len, txt); ➌\n  } else {\n    printf(\"Failed to open REAMDE.txt.\"); ➍\n  }\n}\n--------------------------------------------------------------------------\nRead 27 bytes: Sometimes the goat is you. ➌\n```", "```\nif constexpr (condition-1) {\n  // Compile only if condition-1 is true\n} else if constexpr (condition-2) { // optional; can be multiple else ifs\n  // Compile only if condition-2 is true\n}\n--snip--\n} else { // optional\n  // Compile only if none of the conditionals is true\n}\n```", "```\n#include <cstdio>\n#include <stdexcept>\n#include <type_traits>\n\ntemplate <typename T>\nauto value_of(T x➊) {\n  if constexpr (std::is_pointer<T>::value) { ➋\n    if (!x) throw std::runtime_error{ \"Null pointer dereference.\" }; ➌\n    return *x; ➍\n } else {\n    return x; ➎\n  }\n}\n\nint main() {\n  unsigned long level{ 8998 };\n  auto level_ptr = &level;\n  auto &level_ref = level;\n  printf(\"Power level = %lu\\n\", value_of(level_ptr)); ➏\n  ++*level_ptr;\n  printf(\"Power level = %lu\\n\", value_of(level_ref)); ➐\n  ++level_ref;\n  printf(\"It's over %lu!\\n\", value_of(level++)); ➑\n  try {\n    level_ptr = nullptr;\n    value_of(level_ptr);\n  } catch(const std::exception& e) {\n    printf(\"Exception: %s\\n\", e.what()); ➒\n  }\n}\n--------------------------------------------------------------------------\nPower level = 8998 ➏\nPower level = 8999 ➐\nIt's over 9000! ➑\nException: Null pointer dereference. ➒\n```", "```\nswitch (init-expression➊; condition) {\n  case (case-a): {\n    // Handle case-a here\n  } break;\n  case (case-b): {\n    // Handle case-b here\n  } break;\n    // Handle other conditions as desired\n  default: {\n    // Handle the default case here\n  }\n}\n```", "```\n#include <cstdio>\n\nenum class Color { ➊\n  Mauve,\n  Pink,\n  Russet\n};\n\nstruct Result { ➋\n  const char* name;\n  Color color;\n};\n\nResult observe_shrub(const char* name) { ➌\n  return Result{ name, Color::Russet };\n}\n\nint main() {\n  const char* description;\n  switch (const auto result➍ = observe_shrub(\"Zaphod\"); result.color➎) {\n  case Color::Mauve: {\n    description = \"mauvey shade of pinky russet\";\n    break;\n  } case Color::Pink: {\n    description = \"pinky shade of mauvey russet\";\n    break;\n  } case Color::Russet: {\n description = \"russety shade of pinky mauve\";\n    break;\n  } default: {\n    description = \"enigmatic shade of whitish black\";\n  }}\n  printf(\"The other Shaltanac's joopleberry shrub is \"\n         \"always a more %s.\", description); ➏\n}\n--------------------------------------------------------------------------\nThe other Shaltanac's joopleberry shrub is always a more russety shade of\npinky mauve. ➏\n```", "```\nwhile (condition) {\n  // The statement in the body of the loop\n  // executes upon each iteration\n}\n```", "```\n#include <cstdio>\n#include <cstdint>\n\nbool double_return_overflow(uint8_t& x) { ➊\n  const auto original = x;\n  x *= 2;\n  return original > x;\n}\nint main() {\n  uint8_t x{ 1 }; ➋\n  printf(\"uint8_t:\\n===\\n\");\n  while (!double_return_overflow(x)➌) {\n    printf(\"%u \", x); ➍\n  }\n}\n--------------------------------------------------------------------------\nuint8_t:\n===\n2 4 8 16 32 64 128 ➍\n```", "```\ndo {\n  // The statement in the body of the loop\n  // executes upon each iteration\n} while (condition);\n```", "```\n#include <cstdio>\n#include <cstdint>\n\nbool double_return_overflow(uint8_t& x) {\n  --snip--\n}\n\nint main() {\n  uint8_t x{ 1 };\n  printf(\"uint8_t:\\n===\\n\");\n  do {\n    printf(\"%u \", x); ➊\n  } while (!double_return_overflow(x)➋);\n}\n--------------------------------------------------------------------------\nuint8_t:\n===\n1 2 4 8 16 32 64 128 ➊\n```", "```\nfor(initialization➊; conditional➋; iteration➌) {\n  // The statement in the body of the loop\n  // executes upon each iteration\n}\n```", "```\n#include <cstdio>\n\nint main() {\n  const int x[]{ 1, 1, 2, 3, 5, 8 }; ➊\n  printf(\"i: x[i]\\n\"); ➋\n  for (int i{}➌; i < 6➍; i++➎) {\n    printf(\"%d: %d\\n\", i, x[i]);\n  }\n}\n--------------------------------------------------------------------------\ni: x[i] ➋\n0: 1\n1: 1\n2: 2\n3: 3\n4: 5\n5: 8\n```", "```\nfor(range-declaration : range-expression) {\n  // The statement in the body of the loop\n  // executes upon each iteration\n}\n```", "```\n#include <cstdio>\n\nint main() {\n  const int x[]{ 1, 1, 2, 3, 5, 8 }; ➊\n  for (const auto element➋ : x➌) {\n    printf(\"%d \", element➍);\n  }\n}\n--------------------------------------------------------------------------\n1 1 2 3 5 8\n```", "```\nconst auto e = range.end();➊\nfor(auto b = range.begin()➋; b != e➌; ++b➍) {\n  const auto& element➎ = *b;\n}\n```", "```\nstruct FibonacciIterator {\n  bool operator!=(int x) const {\n    return x >= current; ➊\n  }\n\n  FibonacciIterator& operator++() {\n    const auto tmp = current; ➋\n    current += last; ➌\n    last = tmp; ➍\n    return *this; ➎\n  }\n\n  int operator*() const {\n    return current; ➏\n }\nprivate:\n  int current{ 1 }, last{ 1 };\n};\n\nstruct FibonacciRange {\n  explicit FibonacciRange(int max➐) : max{ max } { }\n  FibonacciIterator begin() const { ➑\n    return FibonacciIterator{};\n  }\n  int end() const { ➒\n    return max;\n  }\nprivate:\n  const int max;\n};\n```", "```\n#include <cstdio>\n\nstruct FibonacciIterator {\n  --snip--\n};\n\nstruct FibonacciRange {\n  --snip--;\n};\n\nint main() {\n for (const auto i : FibonacciRange{ 5000 }➊) {\n    printf(\"%d \", i); ➋\n  }\n}\n--------------------------------------------------------------------------\n1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 ➋\n```", "```\n#include <cstdio>\n\nstruct FibonacciIterator {\n  --snip--\n};\n\nstruct FibonacciRange {\n  --snip--;\n};\n\nint main() {\n  FibonacciRange range{ 5000 };\n  const auto end = range.end();➊\n  for (auto x = range.begin()➋; x != end ➌; ++x ➍) {\n    const auto i = *x;\n    printf(\"%d \", i);\n  }\n}\n--------------------------------------------------------------------------\n1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181\n```", "```\n#include <cstdio>\n\nstruct FibonacciIterator {\n  --snip--\n};\n\nstruct FibonacciRange {\n  --snip--;\n};\n\nint main() {\n  for (auto i : FibonacciRange{ 5000 }) {\n    if (i == 21) { ➊\n      printf(\"*** \"); ➋\n      break; ➌\n    }\n    printf(\"%d \", i);\n  }\n}\n--------------------------------------------------------------------------\n1 2 3 5 8 13 *** ➋\n```", "```\n#include <cstdio>\n\nstruct FibonacciIterator {\n  --snip--\n};\n\nstruct FibonacciRange {\n  --snip--;\n};\n\nint main() {\n  for (auto i : FibonacciRange{ 5000 }) {\n    if (i == 21) {\n      printf(\"*** \"); ➊\n      continue; ➋\n    }\n    printf(\"%d \", i);\n  }\n}\n--------------------------------------------------------------------------\n1 2 3 5 8 13 *** ➊34 55 89 144 233 377 610 987 1597 2584 4181\n```", "```\n#include <cstdio>\n\nint main() {\nluke: ➊\n  printf(\"I'm not afraid.\\n\");\nyoda: ➋\n  printf(\"You will be.\");\n}\n--------------------------------------------------------------------------\nI'm not afraid.\nYou will be.\n```", "```\ngoto label;\n```", "```\n#include <cstdio>\n\nint main() {\n  goto silent_bob; ➊\nluke:\n  printf(\"I'm not afraid.\\n\");\n  goto yoda; ➌\nsilent_bob:\n  goto luke; ➋\nyoda:\n  printf(\"You will be.\");\n}\n--------------------------------------------------------------------------\nI'm not afraid.\nYou will be.\n```"]