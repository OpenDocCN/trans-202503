["```\n...\n    function animate() {\n    **//      animation_wasm();**\n      ctx.putImageData(image_data, 0, 0); // render pixel data\n      requestAnimationFrame(animate);\n    }\n...\n```", "```\n function animate() {\n      animation_wasm();\n  **//**   **ctx.putImageData(image_data, 0, 0);** // render pixel data\n      requestAnimationFrame(animate);\n    }\n```", "```\nnpm install binaryen -g\n```", "```\nwasm-opt collide.wasm -Oz -o collide-z.wasm\n```", "```\nwasm-opt collide.wasm -O3 -o collide-3.wasm\n```", "```\nwasm2wat collide-3.wasm -f -o collide-3.wat\n```", "```\n (func $add_three ;; function adds three numbers together\n    (param $a i32)\n    (param $b i32)\n    (param $c i32)\n    (result i32)\n local.get $a\n    local.get $b\n    local.get $c\n    i32.add\n    i32.add\n  )\n  (func (export \"inline_test\")  ;; I will inline functions in inline_test\n    (param $p1 i32)\n    (param $p2 i32)\n    (param $p3 i32)\n    (result i32)\n    (call $add_three (local.get $p1) (i32.const 2) (local.get $p2))\n    (call $add_three (local.get $p3) (local.get $p1) (i32.const 13))\n    ;; add the results together and return\n    i32.add\n )\n```", "```\n (func (export \"inline_test\");; I will inline the functions in inline_test\n    (param $p1 i32)\n    (param $p2 i32)\n    (param $p3 i32)\n    (result i32)\n;;  (call $add_three (local.get $p1) (i32.const 2) (local.get $p2))\n;;  the function above is inlined into the code below\n    local.get $p1\n    i32.const 2\n    local.get $p2\n    i32.add\n    i32.add\n;;  (call $add_three (local.get $p3) (local.get $p1) (i32.const 13))\n;;  the function above is inlined into the code below\n    local.get $p3\n    local.get $p1\n    i32.const 13\n    i32.add\n    i32.add\n\n    i32.add\n )\n```", "```\n(module\n  (func $add_three\n    (param $a i32)\n    (param $b i32)\n    (param $c i32)\n    (result i32)\n    local.get $a\n    local.get $b\n    local.get $c\n    i32.add\n    i32.add\n  )\n  (func $square\n    (param $a i32)\n    (result i32)\n    local.get $a\n    local.get $a\n    i32.mul\n  )\n  (func $inline_test (export \"inline_test\")\n    (param $p1 i32)\n    (param $p2 i32)\n    (param $p3 i32)\n    (result i32)\n    (call $add_three (local.get $p1) (i32.const 2) (local.get $p2))\n    (call $add_three (local.get $p3) (local.get $p1) (i32.const 13))\n    call $square\n    i32.add\n    call $square\n  )\n)\n```", "```\nwat2wasm inline.wat\n```", "```\nwasm-opt inline.wasm -O3 -o inline-opt.wasm\n```", "```\nwasm2wat inline-opt.wasm\n```", "```\n(module\n  (type (;0;) (func (param i32 i32 i32) (result i32)))\n  (func (;0;) (type 0) (param i32 i32 i32)\n    (result i32) ;; $inline_test function\n    local.get 0\n    local.get 1\n    i32.const 2  \n    i32.add\n    i32.add\n    local.get 2\n    local.get 0\n    i32.const 13\n    i32.add\n    i32.add\n    local.tee 0\n    local.get 0\n    i32.mul\n    i32.add\n    local.tee 0\n    local.get 0\n    i32.mul)\n  (export \"inline_test\" (func 0)))\n```", "```\n(module\n  (func (export \"pow2_mul\")\n    (param $p1 i32)\n    (param $p2 i32)\n    (result i32)\n    local.get $p1\n    i32.const 16\n    i32.mul ;; multiply by 16, which is 24\n    local.get $p2\n    i32.const 8\n    i32.div_u ;; divide by 8, which is 23\n i32.add\n  )\n)\n```", "```\n(module\n  (type (;0;) (func (param i32 i32) (result i32)))\n  (func (;0;) (type 0) (param i32 i32) (result i32)\n    local.get 1\n    i32.const 8\n    i32.div_u\n    local.get 0\n    i32.const 4\n    i32.shl\n    i32.add)\n  (export \"pow2_mul\" (func 0)))\n```", "```\n(module\n  (func $combine_constants (export \"combine_constants\")\n    (result i32)\n    i32.const 10\n    i32.const 20\n    i32.add\n i32.const 55\n    i32.add\n  )\n)\n```", "```\n(module\n  (type (;0;) (func (result i32)))\n  (func (;0;) (type 0) (result i32)\n1 i32.const 85)\n  (export \"combine_constants\" (func 0)))\n```", "```\n(module\n1 (func $dead_code_1\n    (param $a i32)\n    (param $b i32)\n    (param $c i32)\n    (result i32)\n    local.get $a\n    local.get $b\n    local.get $c\n    i32.add\n    i32.add\n  )\n2 (func $dead_code_2\n    (param $a i32)\n    (result i32)\n    local.get $a\n    local.get $a\n    i32.mul\n  )\n  (func $dce_test (export \"dce_test\")\n    (param $p1 i32)\n (param $p2 i32)\n    (result i32)\n    local.get $p1\n    local.get $p2\n    i32.add\n  )\n)\n```", "```\n(module\n  (type (;0;) (func (param i32 i32) (result i32)))\n  (func (;0;) (type 0) (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    i32.add)\n  (export \"dce_test\" (func 0)))\n```", "```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Collide JS</title>\n</head>\n<body>\n    <canvas id=\"canvas\" width=\"1024\" height=\"1024\"></canvas>\n...\n```", "```\n...\n    <script type=\"text/javascript\">\n        // javascript version\n        var animate_callback;\n        const out_tag = document.getElementById('out');\n        const cnvs_size = 1024 | 0;\n\n        const noh_color = 0xff00ff00 | 0;\n        const hit_color = 0xff0000ff | 0;\n\n        const obj_start = cnvs_size * cnvs_size * 4;\n        const obj_size = 8 | 0;\n        const obj_cnt = 3000 | 0;\n\n        const canvas = document.getElementById(\"canvas\");\n        const ctx = canvas.getContext(\"2d\");\n\n        class Collider {\n            constructor() {\n                this.x = Math.random() * cnvs_size;\n                this.y = Math.random() * cnvs_size;\n                this.xv = (Math.round(Math.random() * 4) - 2);\n                this.yv = (Math.round(Math.random() * 4) - 2);\n                this.color = \"green\";\n            }\n\n            move = () => {\n                this.x += this.xv;\n                this.y += this.yv;\n                this.x %= 1024;\n                this.y %= 1024;\n            }\n            draw = () => {\n                ctx.beginPath();\n                ctx.fillStyle = this.color;\n                ctx.fillRect(this.x, this.y, obj_size, obj_size);\n                ctx.stroke();\n            }\n            hitTest = (c2) => {\n                let x_dist = this.x - c2.x;\n                let y_dist = this.y - c2.y;\n\n                if (Math.abs(x_dist) <= obj_size &&\n                    Math.abs(y_dist) <= obj_size) {\n                    this.color = \"red\";\n                    return true;\n                }\n                else {\n                    this.color = \"green\";\n                }\n                return false;\n            }\n        }\n\n let collider_array = new Array();\n        for (let i = 0; i < obj_cnt; i++) {\n            collider_array.push(new Collider());\n        }\n\n        let animate_count = 0;\n\n        function animate() {\n            // clear\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            for (let i = 0; i < collider_array.length; i++) {\n                collider_array[i].move();\n            }\n\n            // loop and render\n            for (i = 0; i < collider_array.length; i++) {\n                for (let j = 0; j < collider_array.length; j++) {\n                    if (i === j) {\n                        continue;\n                    }\n                    if (collider_array[i].hitTest(collider_array[j]))\n                    {\n                        break;\n                    }\n                }\n                collider_array[i].draw();\n            }\n            requestAnimationFrame(animate);\n        }\n        requestAnimationFrame(animate);\n    </script>\n</body>\n</html>\n```", "```\n(module\n  (func $mod (export \"mod\")\n    (param $p0 i32)\n    (result i32)\n    local.get $p0\n    i32.const 1000\n    i32.rem_u\n  )\n\n  (func $and (export \"and\")\n    (param $p0 i32)\n    (result i32)\n    local.get $p0\n    i32.const 0x3ff\n    i32.and\n  )\n)\n```", "```\nconst fs = require('fs');\nconst bytes = fs.readFileSync('./mod_and.wasm');\n\n(async () => {\n  const obj =\n    await WebAssembly.instantiate(new Uint8Array(bytes));\n  let mod = obj.instance.exports.mod;\n  let and = obj.instance.exports.and;\n\n let start_time = Date.now(); // reset start_time\n // The '| 0' syntax is a hint to the JavaScript engine to tell it\n // to use integers instead of floats, which can improve performance in\n // some circumstances\n  for (let i = 0 | 0; i < 4_000_000; i++) {\n    mod(i);  // call the mod function 4 million times\n  }\n// calculate the time it took to run 4 million mod calls\n  console.log(`mod: ${Date.now() - start_time}`);\n  start_time = Date.now(); // reset start_time\n\n  for (let i = 0 | 0; i < 4_000_000; i++) {\n    and(i); // call the and function 4 million times\n  }\n// calculate the time it took to run 4 million and calls\n  console.log(`and: ${Date.now() - start_time}`);\n  start_time = Date.now(); // reset start_time\n  for (let i = 0 | 0; i < 4_000_000; i++) {\n    Math.floor(i % 1000);\n  }\n// calculate the time it took to run 4 million modulo calls\n  console.log(`js mod: ${Date.now() - start_time}`);\n})();\n```", "```\nnode mod_and.js\n```", "```\nmod: 29\nand: 23\njs mod: 4\n```", "```\n(module\n  (func (export \"mod_loop\")\n    (result i32)\n    (local $i i32)\n    (local $total i32)\n    i32.const 100_000_000 ;; loop 100 million times\n    local.set $i\n\n    (loop $loop\n      local.get $i\n      i32.const 0x3ff\n      i32.rem_u\n      local.set $total\n\n      local.get $i\n      i32.const 1\n      i32.sub\n      local.tee $i  ;; i--\n\n      br_if $loop\n    )\n    local.get $total\n  )\n\n  (func (export \"and_loop\")\n    (result i32)\n    (local $total i32)\n    (local $i i32)\n    i32.const 100_000_000 ;; loop 100 million times\n    local.set $i\n\n    (loop $loop\n      local.get $i\n      i32.const 0x3ff\n      i32.and\n      local.set $total\n\n      local.get $i\n      i32.const 1\n      i32.sub\n      local.tee $i ;; i--\n\n      br_if $loop\n    )\n local.get $total\n  )\n)\n```", "```\nconst fs = require('fs');\nconst bytes = fs.readFileSync('./mod_and_loop.wasm');\n\n(async () => {\n  const obj =\n    await WebAssembly.instantiate(new Uint8Array(bytes));\n  let mod_loop = obj.instance.exports.mod_loop;\n  let and_loop = obj.instance.exports.and_loop;\n\n  let start_time = Date.now(); // set start_time\n  and_loop();\n  console.log(`and_loop: ${Date.now() - start_time}`);\n\n  start_time = Date.now(); // reset start_time\n  mod_loop();\n  console.log(`mod_loop: ${Date.now() - start_time}`);\n  start_time = Date.now(); // reset start_time\n  let x = 0;\n  for (let i = 0; i < 100_000_000; i++) {\n    x = i % 1000;\n  }\n  console.log(`js mod: ${Date.now() - start_time}`);\n})();\n```", "```\nand_loop: 31\nmod_loop: 32\njs mod: 52\n```", "```\n(module\n  ;; this is the original function we wrote\n  (func (export \"pow2\")\n    (param $p1 i32)\n    (param $p2 i32)\n    (result i32)\n    local.get $p1\n    i32.const 16\n    i32.mul\n    local.get $p2\n    i32.const 8\n    i32.div_u\n    i32.add\n  )\n...\n```", "```\n...\n ;; wasm-opt placed the div before mul, so let's see if that helps\n  (func (export \"pow2_reverse\")\n    (param $p1 i32)\n    (param $p2 i32)\n    (result i32)\n    local.get $p2\n i32.const 8\n    i32.div_u\n    local.get $p1\n    i32.const 16\n    i32.mul\n    i32.add\n  )\n...\n```", "```\n...\n ;; change multiply and divide to shifts\n  (func (export \"pow2_mul_div_shift\")\n    (param $p1 i32)\n    (param $p2 i32)\n    (result i32)\n    local.get $p2\n    i32.const 3\n    i32.shr_u\n    local.get $p1\n    i32.const 4\n    i32.shl\n    i32.add\n  )\n...\n```", "```\n...\n ;; back to original order of multiply and divide\n  (func (export \"pow2_mul_div_nor\")\n    (param $p1 i32)\n    (param $p2 i32)\n    (result i32)\n    local.get $p1\n    i32.const 4\n    i32.shl\n    local.get $p2\n    i32.const 3\n    i32.shr_u\n    i32.add\n  )\n...\n```", "```\n...\n;; this was what was generated by wasm-opt\n  (func (export \"pow2_opt\") (param i32 i32) (result i32)\n    local.get 1\n    i32.const 8\n    i32.div_u\n    local.get 0\n    i32.const 4\n    i32.shl\n    i32.add\n  )\n)\n```", "```\nnpm i --save-dev benchmark\n```", "```\n// import benchmark.js\n1 var Benchmark = require('benchmark');\n2 var suite = new Benchmark.Suite();\n\n// use fs to read the pow2_test.wasm module into a byte array\n3 const fs = require('fs');\nconst bytes = fs.readFileSync('./pow2_test.wasm');\nconst colors = require('colors'); // allow console logs with color\n\n// Variables for the WebAssembly functions\nvar pow2;\nvar pow2_reverse;\nvar pow2_mul_shift;\nvar pow2_mul_div_shift;\nvar pow2_mul_div_nor;\n\nconsole.log(`\n================= RUNNING BENCHMARK =================\n`.rainbow 4);\n...\n```", "```\n...\n1 function init_benchmark() {\n  // adds the callbacks for the benchmarks\n2 suite.add('#1 '.yellow + 'Original Function', pow2);\n  suite.add('#2 '.yellow + 'Reversed Div/Mult order', pow2_reverse);\n  suite.add('#3 '.yellow + 'Replace mult with shift',\n             pow2_mul_shift);\n  suite.add('#4 '.yellow + 'Replace mult & div with shift',\n             pow2_mul_div_shift);\n  suite.add('#5 '.yellow + 'wasm-opt optimized version', pow2_opt);\n  suite.add('#6 '.yellow + 'Use shifts with OG order',\n             pow2_mul_div_nor);\n // add listeners\n3 suite.on('cycle', function (event) {\n    console.log(String(event.target));\n  });\n\n4 suite.on('complete', function () {\n    // when the benchmark has finished, log the fastest and slowest functions\n    let fast_string = ('Fastest is ' +\n      5 this.filter('fastest').map('name'));\n    let slow_string = ('Slowest is ' +\n        this.filter('slowest').map('name'));\n  6 console.log(`\n    ------------------------------------------------------------\n    ${fast_string.green}\n    ${slow_string.red}\n    ------------------------------------------------------------\n    `);\n\n    // create an array of all successful runs and sort fast to slow\n  7 var arr = this.filter('successful');\n  8 arr.sort(function (a, b) { \n    return a.stats.mean - b.stats.mean;\n    });\n\n    console.log(`\n\n    `);\n    console.log(\"============ FASTEST ============\".green);\n  9 while (obj = arr.shift()) {\n let extension = '';\n      let count = Math.ceil(1 / obj.stats.mean);\n\n     if (count > 1000) {\n       count /= 1000;\n       extension = 'K'.green.bold;\n     }\n\n     if (count > 1000) {\n      count /= 1000;\n      extension = 'M'.green.bold;\n     }\n\n     count = Math.ceil(count);\n     let count_string = count.toString().yellow + extension;\n     console.log(\n      `${obj.name.padEnd(45, ' ')} ${count_string} exec/sec`\n      );\n    }\n    console.log(\"============ SLOWEST ============\".red);\n  });\n  // run async\n  a suite.run({ 'async': false });\n}\n...\n```", "```\n...\n(async () => {\n1 const obj = await WebAssembly.instantiate(new Uint8Array(bytes));\n2 pow2 = obj.instance.exports.pow2;\n  pow2_reverse = obj.instance.exports.pow2_reverse;\n  pow2_mul_shift = obj.instance.exports.pow2_mul_shift;\n  pow2_mul_div_shift = obj.instance.exports.pow2_mul_div_shift;\n pow2_opt = obj.instance.exports.pow2_opt;\n  pow2_mul_div_nor = obj.instance.exports.pow2_mul_div_nor;\n3 init_benchmark();\n})();\n```", "```\nnode benchmark_test.js\n```", "```\n1 function bytecode_test() {\n  let x = 0;\n2 for (let i = 0; i < 100_000_000; i++) {\n  3 x = i % 1000;\n  }\n4 return 99;\n} \n```", "```\n5 bytecode_test();\n```", "```\nnode --print-bytecode --print-bytecode-filter=bytecode_test print_bytecode.js\n```", "```\n[generated bytecode for function: bytecode_test]\nParameter count 1\nRegister count 2\nFrame size 16\n22 E> 0000009536F965F6 @    0 : a5                **StackCheck**\n38 S> 0000009536F965F7 @    1 : 0b                **LdaZero**\n      0000009536F965F8 @    2 : 26 fb             **Star r0**\n57 S> 0000009536F965FA @    4 : 0b                **LdaZero**\n      0000009536F965FB @    5 : 26 fa             **Star r1**\n62 S> 0000009536F965FD @    7 : 01 0c 00 e1 f5 05 **LdaSmi.ExtraWide [100000000]**\n62 E> 0000009536F96603 @   13 : 69 fa 00          **TestLessThan r1, [0]**\n      0000009536F96606 @   16 : 99 16             **JumpIfFalse [22]** (0000009536F9661C @ 38)\n44 E> 0000009536F96608 @   18 : a5                **StackCheck**\n89 S> 0000009536F96609 @   19 : 25 fa             **Ldar r1**\n95 E> 0000009536F9660B @   21 : 00 44 e8 03 01 00 **ModSmi.Wide [1000], [1]**\n      0000009536F96611 @   27 : 26 fb             **Star r0**\n78 S> 0000009536F96613 @   29 : 25 fa             **Ldar r1**\n      0000009536F96615 @   31 : 4c 02             **Inc [2]**\n      0000009536F96617 @   33 : 26 fa             **Star r1**\n      0000009536F96619 @   35 : 8a 1c 00          **JumpLoop [28], [0]** (0000009536F965FD @ 7)\n111 S> 0000009536F9661C @   38 : 0c 63             **LdaSmi [99]**\n121 S> 0000009536F9661E @   40 : a9                **Return**\nConstant pool (size = 0)\nHandler Table (size = 0)\n```", "```\n;; A = Accumulator R0 = Register 0, R1 = Register 1\nStackCheck\nLdaZero                                   **;; A = 0**\nStar r0                                   **;; R0 = A**\nLdaZero                                   **;; A = 0**\nStar r1                                   **;; R1 = A**\n;; THIS IS THE TOP OF THE LOOP\nLdaSmi.ExtraWide [100000000]              **;; A=100_000_000**\nTestLessThan r1, [0]                      **;; R1 < A**\nJumpIfFalse [22] (0000006847C9661C @ 38)  **;; IF R1 >= A GO 22 BYTES**\n                                          **;;   AHEAD [END OF LOOP]**\nStackCheck\nLdar r1                                   **;; A = R1**\nModSmi.Wide [1000], [1]                   **;; A %= 1_000**\nStar r0                                   **;; R0 = A**\nLdar r1                                   **;; A = R1**\nInc [2]                                   **;; A++**\nStar r1                                   **;; R1 = A**\nJumpLoop [28], [0] (0000006847C965FD @ 7) **;; 28 BYTES BACK [LOOP TOP]**\nLdaSmi [99]                               **;; A = 99 | END OF LOOP**\nReturn                                    **;; RETURN A**\n```"]