- en: Chapter 4. Calculations
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4章 计算
- en: In this chapter, we’ll look at various one-liners for performing calculations,
    such as finding minimum and maximum elements, counting, shuffling and permuting
    words, and calculating dates and numbers. You’ll also learn about the `-a`, `-M`,
    and `-F` command-line arguments, the `$`, special variable, and the `@{[ ... ]}`
    construction that lets you run code inside double quotes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍各种用于计算的一行代码，如查找最小值和最大值、计数、打乱和排列单词，以及计算日期和数字。你还将了解`-a`、`-M`和`-F`命令行参数、`$`特殊变量，以及`@{[
    ... ]}`构造，它允许你在双引号内运行代码。
- en: 4.1 Check if a number is a prime
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 检查一个数字是否是质数
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This one-liner uses an ingenious regular expression by Abigail to detect whether
    a given number is a prime. (Don’t take this regular expression too seriously;
    I’ve included it for its artistic value. For serious purposes, use the `Math::Primality`
    module from CPAN to see whether a number is prime.)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码使用了Abigail巧妙的正则表达式来检测给定的数字是否是质数。（不要把这个正则表达式当真；我把它放在这里是为了其艺术价值。如果是严肃的用途，请使用CPAN的`Math::Primality`模块来判断一个数字是否是质数。）
- en: 'Here’s how this ingenious one-liner works: First, the number is converted into
    its unary representation by `(1x$_)`. For example, `5` is converted into `1x5`,
    which is `11111` (`1` repeated `5` times). Next, the unary number is tested against
    the regular expression. If it doesn’t match, the number is a prime; otherwise
    it’s a composite. The `!~` operator is the opposite of the `=~` operator and is
    true if the regular expression doesn’t match.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个巧妙的一行代码的工作原理：首先，数字通过`(1x$_)`转换成其一元表示法。例如，`5`被转换为`1x5`，即`11111`（`1`重复`5`次）。接下来，一元数字会被测试是否与正则表达式匹配。如果不匹配，则该数字是质数；否则，它是合成数。`!~`运算符是`=~`运算符的反义，如果正则表达式不匹配，则返回true。
- en: 'The regular expression consists of two parts: The first part, `^1?$`, matches
    `1` and the empty string. The empty string and 1 are clearly not prime numbers,
    so this part of the regular expression discards them.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式由两部分组成：第一部分`^1?$`匹配`1`和空字符串。显然，空字符串和1都不是质数，因此这一部分的正则表达式会将它们排除。
- en: The second part, `^(11+?)\1+$`, determines whether two or more `1`s repeatedly
    make up the whole number. If so, the regular expression matches, which means the
    number is a composite. If not, it’s a prime.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分`^(11+?)\1+$`决定了两个或更多的`1`是否重复构成整个数字。如果是，正则表达式匹配，意味着该数字是合成数。如果不是，它是质数。
- en: Now consider how the second part of the regular expression would act on the
    number 5\. The number 5 in unary is 11111, so the `(11+?)` matches the first two
    `1`s, the back-reference `\1` becomes 11, and the whole regular expression now
    becomes `^11(11)+$`. Because it can’t match five `1`s, it fails. Next, it attempts
    to match the first three `1`s. The back-reference becomes 111, and the whole regular
    expression becomes `^111(111)+$`, which doesn’t match. The process repeats for
    1111 and 11111, which also don’t match, and as a result the entire regular expression
    doesn’t match and the number is a prime.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑正则表达式的第二部分如何作用于数字5。数字5的一元表示法是11111，因此`(11+?)`匹配前两个`1`，回溯引用`\1`变成11，整个正则表达式变为`^11(11)+$`。由于它无法匹配五个`1`，所以失败。接下来，它尝试匹配前三个`1`。回溯引用变为111，整个正则表达式变为`^111(111)+$`，仍然不匹配。该过程对1111和11111也重复，最终整个正则表达式没有匹配，说明该数字是质数。
- en: What about the number 4? The number 4 is 1111 in unary. The `(11+?)` matches
    the first two `1`s. The back-reference `\1` becomes 11, and the regular expression
    becomes `^11(11)+$`, which matches the original string and confirms that the number
    is not prime.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么数字4呢？数字4在一元表示法中是1111。`(11+?)`匹配前两个`1`。回溯引用`\1`变成11，整个正则表达式变为`^11(11)+$`，匹配原始字符串并确认该数字不是质数。
- en: 4.2 Print the sum of all fields on each line
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 打印每行所有字段的总和
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This one-liner turns on field *auto-splitting* with the `-a` command-line option
    and imports the `sum` function from the `List::Util` module with `-Mlist::Util=sum`.
    (`List::Util` is part of the Perl core, so you don’t need install it.) Auto-splitting
    happens on whitespace characters by default, and the resulting fields are put
    in the `@F` variable. For example, the line `1 4 8` would be split on each space
    so that `@F` would become `(1, 4, 8)`. The `sum @F` statement sums the elements
    in the `@F` array, giving you `13`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行命令通过`-a`命令行选项打开字段*自动分割*，并通过`-Mlist::Util=sum`导入`List::Util`模块的`sum`函数。 (`List::Util`是Perl的核心模块之一，所以你不需要安装它。）自动分割默认发生在空白字符上，结果字段会被放入`@F`变量中。例如，行`1
    4 8`会按空格分割，使得`@F`变成`(1, 4, 8)`。`sum @F`语句将求和`@F`数组中的元素，得到`13`。
- en: The `-Mmodule=arg` option imports `arg` from `module`. It’s the same as writing
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`-Mmodule=arg`选项从`module`导入`arg`。它等同于写成'
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This one-liner is equivalent to
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行命令相当于
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can change auto-splitting’s default behavior by specifying an argument
    to the `-F` command-line switch. Say you have the following line:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过为`-F`命令行开关指定一个参数来改变自动分割的默认行为。假设你有以下一行：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And you wish to find the sum of all these numbers. You can simply specify `:`
    as an argument to the `-F` switch, like this:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望找到所有这些数字的总和，可以简单地将`:`指定为`-F`开关的参数，像这样：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This splits the line on the colon character and sums all the numbers. The output
    is `55` because that’s the sum of the numbers 1 through 10.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按冒号字符分割行并求和所有的数字。输出是`55`，因为这是从1到10的数字之和。
- en: 4.3 Print the sum of all fields on all lines
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 打印所有行中所有字段的总和
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This one-liner keeps pushing the split fields in `@F` to the `@S` array. Once
    the input stops and Perl is about to quit, the `END { }` block is executed and
    it outputs the sum of all items in `@S`. This sums all fields over all lines.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行命令不断将分割后的字段推送到`@S`数组中。当输入结束且Perl准备退出时，`END { }`代码块会被执行，并输出`@S`中所有项目的总和。这样会对所有行中的所有字段求和。
- en: Notice how pushing the `@F` array to the `@S` array actually appends elements
    to it. This differs from many other languages, where pushing array1 to array2
    would put array1 into array2, rather than appending the elements of array1 onto
    array2\. Perl performs list flattening by design.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如何将`@F`数组推送到`@S`数组实际上是将元素附加到它。与许多其他编程语言不同，推送数组1到数组2会将数组1放入数组2中，而不是将数组1的元素附加到数组2中。Perl默认执行列表展平。
- en: 'Unfortunately, summing all fields on all lines using this solution creates
    a massive `@S` array. A better solution is to keep only the running sum, like
    this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，使用这个方法对所有行的所有字段求和会创建一个庞大的`@S`数组。一个更好的解决方法是只保留运行时的和，像这样：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, each line is split into `@F` and the values are summed and stored in the
    running sum variable `$s`. Once all input has been processed, the one-liner prints
    the value of `$s`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每一行被分割成`@F`，然后将值求和并存储在运行时的和变量`$s`中。一旦所有输入被处理完，单行命令会打印出`$s`的值。
- en: 4.4 Shuffle all fields on each line
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 将每一行的所有字段洗牌
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The trickiest part of this one-liner is the `@{[shuffle @F]}` construction.
    This construction allows you to execute the code inside the quotation marks. Normally
    text and variables are placed inside quotation marks, but with the `@{[ ... ]}`
    construction you can run code, too.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行命令最棘手的部分是`@{[shuffle @F]}`构造。这个构造允许你执行引号内的代码。通常，文本和变量会放入引号中，但使用`@{[ ...
    ]}`构造，你也可以运行代码。
- en: In this one-liner, the code to execute inside of the quotation marks is `shuffle
    @F`, which shuffles the fields and returns the shuffled list. The `[shuffle @F]`
    creates an array reference containing the shuffled fields, and the `@{ ... }`
    dereferences it. You simply create a reference and immediately dereference it.
    This allows you to run the code inside the quotation marks.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个单行命令中，执行的代码是`shuffle @F`，它对字段进行洗牌并返回洗牌后的列表。`[shuffle @F]`创建了一个包含洗牌字段的数组引用，`@{
    ... }`则是解除引用。你只需创建一个引用并立即解除引用。这使得你能够执行引号内的代码。
- en: 'Let’s look at several examples to understand why I chose to run the code inside
    the quotation marks. If I had written `print shuffle @F`, the fields on the line
    would be concatenated. Compare the output of this one-liner:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看几个例子，理解为什么我选择在引号内执行代码。如果我写了`print shuffle @F`，那么行中的字段会被连接起来。对比一下这个单行命令的输出：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'to this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 转换成：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the first example, the array of shuffled fields (inside the double quotation
    marks) is interpolated, and the array’s elements are separated by a space, so
    the output is `b c d a`. In the second example, interpolation doesn’t happen,
    and Perl simply dumps out element by element without separating them, and the
    output is `bcda`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，打乱顺序的字段数组（双引号内）会被插值，并且数组元素用空格分隔，因此输出为`b c d a`。在第二个例子中，插值没有发生，Perl会逐个输出元素，而不进行分隔，输出为`bcda`。
- en: 'You can use the `$`, special variable to change the separator between array
    elements when they’re printed. For example, here’s what happens when I change
    the separator to a colon:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`$`这个特殊变量来改变打印时数组元素之间的分隔符。例如，当我将分隔符更改为冒号时，会发生以下情况：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can also use the `join` function to join the elements of `@F` with a space:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`join`函数通过空格连接`@F`中的元素：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, the `join` function joins the elements of an array using the given separator,
    but the `@{[ ... ]}` construction is the cleanest way to do it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`join`函数使用给定的分隔符连接数组的元素，而`@{[ ... ]}`结构是实现这一操作最简洁的方式。
- en: 4.5 Find the numerically smallest element (minimum element) on each line
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5 找出每行中数值最小的元素（最小元素）
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This one-liner is somewhat similar to the previous ones. It uses the `min` function
    from `List::Util`. Once the line has been automatically split by `-a` and the
    elements are in the `@F` array, the `min` function finds the numerically smallest
    element, which it prints.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个一行代码与前面的例子有些相似。它使用了`List::Util`中的`min`函数。一旦通过`-a`自动拆分行并将元素存入`@F`数组，`min`函数就能找到数值最小的元素并打印出来。
- en: 'For example, if you have a file that contains these lines:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个文件包含以下行：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running this one-liner produces the following output:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这行代码会产生以下输出：
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The smallest number on the first line is `-8`; on the second line, the smallest
    number is `0`; and on the third line, `-25`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行的最小数字是`-8`；第二行的最小数字是`0`；第三行的最小数字是`-25`。
- en: 4.6 Find the numerically smallest element (minimum element) over all lines
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.6 找出所有行中数值最小的元素（最小元素）
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This one-liner combines one-liners 4.3 and 4.5\. The `@M = (@M, @F)` construct
    is the same as `push @M, @F`. It appends the contents of `@F` to the `@M` array.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码结合了4.3和4.5的代码。`@M = (@M, @F)`结构等同于`push @M, @F`。它将`@F`的内容附加到`@M`数组中。
- en: 'This one-liner stores all data in memory, and if you run it on a really huge
    file, Perl will run out of memory. Your best bet is to find the smallest element
    on every line and compare that element with the smallest element on the previous
    line. If the element on the current line is less than the previous one, it’s the
    smallest element so far. Once all lines have been processed, you can just print
    the smallest element found through the `END` block:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个一行代码将所有数据存储在内存中，如果你在一个非常大的文件上运行它，Perl可能会耗尽内存。最好的方法是找出每一行的最小元素，并将该元素与前一行的最小元素进行比较。如果当前行的元素小于前一行的元素，那么它就是目前为止最小的元素。处理完所有行后，你可以通过`END`块打印出找到的最小元素：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, you first find the minimum element on the current line and store it in
    `$min`. Then you check to see if the smallest element on the current line is the
    smallest element so far. If so, assign it to `$rmin`. Once you’ve looped over
    the whole input, the `END` block executes and you print the `$rmin`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你首先找到当前行的最小元素并将其存储在`$min`中。然后检查当前行的最小元素是否是迄今为止最小的元素。如果是，就将它赋值给`$rmin`。当你遍历完所有行后，`END`块会执行并打印出`$rmin`。
- en: 'Say your file contains these lines:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的文件包含以下行：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Running this one-liner outputs `-25` because that’s the smallest number in the
    file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这行代码会输出`-25`，因为这是文件中最小的数字。
- en: 'If you’re using Perl 5.10 or later, you can do the same thing with this one-liner:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Perl 5.10或更高版本，你可以通过以下一行代码实现相同的功能：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This one-liner uses the `//` operator, which is new to Perl 5.10\. This operator
    is similar to the logical OR operator (`||`), except that it tests the left side’s
    definedness rather than the truth. What that means is it tests whether the left
    side is defined rather than whether it is true or false. In this one-liner, the
    expression `$min // ()` returns `$min` if `$min` has been defined, or else it
    returns an empty list `()`. The `//` operator saves you from having to use `defined`
    to test definedness.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行代码使用了 `//` 运算符，这是 Perl 5.10 新增的运算符。这个运算符类似于逻辑 OR 运算符 (`||`)，不同之处在于它测试的是左边的定义性而非真假值。这意味着它测试左边是否已定义，而不是是否为真或假。在这个单行代码中，表达式
    `$min // ()` 如果 `$min` 已定义，则返回 `$min`，否则返回一个空列表 `()`。`//` 运算符避免了你使用 `defined`
    来测试定义性。
- en: Consider what happens when this one-liner is run on the previous file. First,
    Perl reads the line `-8 9 10 5`, splits it, and puts the numbers in the `@F` array.
    The `@F` array is now `(-8, 9, 10, 5)`. Next, it executes `$min = min ($min //
    (), @F)`. Because `$min` hasn’t been defined, `$min // ()` evaluates to `()`,
    so the whole expression becomes `$min = min ((), (-8, 9, 10, 5))`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑当这个单行代码在前面的文件上运行时会发生什么。首先，Perl 读取行 `-8 9 10 5`，将其拆分并将数字放入 `@F` 数组中。此时，`@F`
    数组变为 `(-8, 9, 10, 5)`。接着，它执行 `$min = min ($min // (), @F)`。由于 `$min` 尚未定义，`$min
    // ()` 解析为 `()`，所以整个表达式变为 `$min = min ((), (-8, 9, 10, 5))`。
- en: Perl does list flattening by design, so after flattening the arguments to the
    `min` function, the expression becomes `$min = min(-8, 9, 10, 5)`. This defines
    `$min`, setting it to `-8`. Perl proceeds to the next line, where it sets `@F`
    to `(7, 0, 9, 3)` and again evaluates `$min = min($min // (), @F)`. Because `$min`
    has now been defined, `$min // ()` evaluates to `$min` and the expression becomes
    `$min = min(-8, 7, 0, 9, 3)`. At this point, `-8` is still the smallest element,
    so `$min` remains `-8`. Finally, Perl reads in the last line, and after evaluating
    `$min = min(-8, 5, -25, 9, 999)`, it finds that `-25` is the smallest element
    in the file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Perl 设计上就支持列表扁平化，因此在将参数传递给 `min` 函数时，表达式变成了 `$min = min(-8, 9, 10, 5)`。这定义了
    `$min`，并将其设置为 `-8`。Perl 继续执行下一行，在这一行中，它将 `@F` 设置为 `(7, 0, 9, 3)`，然后再次求值 `$min
    = min($min // (), @F)`。因为 `$min` 已经定义，所以 `$min // ()` 会被解析为 `$min`，表达式变成 `$min
    = min(-8, 7, 0, 9, 3)`。此时，`-8` 仍然是最小的元素，所以 `$min` 保持为 `-8`。最后，Perl 读取最后一行，执行 `$min
    = min(-8, 5, -25, 9, 999)`，发现 `-25` 是文件中的最小元素。
- en: 4.7 Find the numerically largest element (maximum element) on each line
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.7 找到每行的数值最大元素（最大元素）
- en: '[PRE20]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This works the same as one-liner 4.5, except that you replace `min` with `max`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这与单行代码 4.5 的作用相同，唯一不同的是将 `min` 替换为 `max`。
- en: 4.8 Find the numerically largest element (maximum element) over all lines
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.8 找到所有行的数值最大元素（最大元素）
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This one-liner is similar to one-liners 4.6 and 4.7\. In this one-liner, each
    line is auto-split and put in the `@F` array, and then this array is merged with
    the `@M` array. When the input has been processed, the `END` block executes and
    the maximum element is printed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行代码与单行代码 4.6 和 4.7 类似。在这个单行代码中，每一行都会自动拆分并放入 `@F` 数组中，然后该数组会与 `@M` 数组合并。当输入处理完毕后，`END`
    块执行，并打印出最大元素。
- en: 'Here’s another way to find the maximum element, keeping just the running maximum
    element instead of all elements in memory:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一种找到最大元素的方法，它只保留当前的最大元素，而不是将所有元素保存在内存中：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you’re using Perl 5.10 or later, you can use the `//` operator to shorten
    this one-liner:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Perl 5.10 或更高版本，可以使用 `//` 运算符来简化这个单行代码：
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is the same as one-liner 4.6, except you replace `min` with `max`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这与单行代码 4.6 相同，唯一不同的是将 `min` 替换为 `max`。
- en: 4.9 Replace each field with its absolute value
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.9 将每个字段替换为其绝对值
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This one-liner first auto-splits the line using the `-a` option. The split fields
    end up in the `@F` variable. Next, it calls the absolute value function `abs`
    on each field with the help of the `map` function. Essentially, the `map` function
    applies a given function to each element of the list and returns a new list that
    contains the results of applying the function. For example, if the list `@F` is
    `(-4, 2, 0)`, mapping `abs` over it produces the list `(4, 2, 0)`. Finally, this
    one-liner prints the new list of positive values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单行代码首先使用 `-a` 选项自动拆分该行。拆分后的字段会存储在 `@F` 变量中。接着，它使用 `map` 函数对每个字段调用绝对值函数 `abs`。本质上，`map`
    函数会将给定的函数应用到列表的每个元素，并返回一个包含应用该函数结果的新列表。例如，如果列表 `@F` 是 `(-4, 2, 0)`，对其进行 `abs`
    映射后会得到列表 `(4, 2, 0)`。最后，这个单行代码会打印出新列表中的正值。
- en: The `@{[ ... ]}` construct, introduced in one-liner 4.4, allows you to execute
    the code inside the quotation marks.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`@{[ ... ]}` 结构，介绍于一行代码 4.4，允许你执行引号内的代码。'
- en: 4.10 Print the total number of fields on each line
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.10 打印每行的字段总数
- en: '[PRE25]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This one-liner forces the evaluation of `@F` in the scalar context, which in
    Perl means “the number of elements in `@F`.” As a result, it prints the number
    of elements on each line.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个一行代码强制在标量上下文中求值 `@F`，在 Perl 中这意味着“`@F` 中的元素数量”。因此，它打印每行中的元素数量。
- en: 'For example, if your file contains the following lines:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的文件包含以下几行：
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Running this one-liner produces the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个一行代码将产生以下输出：
- en: '[PRE27]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first line has three fields, the second line has two fields, and the last
    line has one field.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行有三个字段，第二行有两个字段，最后一行有一个字段。
- en: 4.11 Print the total number of fields on each line, followed by the line
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.11 打印每行的字段总数，后跟该行内容
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This one-liner is the same as one-liner 4.10, with the addition of `$_` at the
    end, which prints the whole line. (Remember that `-n` puts each line in the `$_`
    variable.)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个一行代码和一行代码 4.10 相同，只是在末尾添加了 `$_`，它打印整行内容。（记住，`-n` 会将每一行放入 `$_` 变量中。）
- en: 'Let’s run this one-liner on the same example file that I used in one-liner
    4.10:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在和一行代码 4.10 相同的示例文件上运行这个一行代码：
- en: '[PRE29]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Running the one-liner produces the following output:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个一行代码将产生以下输出：
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 4.12 Print the total number of fields on all lines
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.12 打印所有行的字段总数
- en: '[PRE31]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, the one-liner keeps adding the number of fields on each line to variable
    `$t` until all lines have been processed. Next, it prints the result, which contains
    the number of words on all lines. Notice that you add the `@F` array to the scalar
    variable `$t`. Because `$t` is scalar, the `@F` array is evaluated in the scalar
    context and returns the number of elements it contains.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，这行代码将每行的字段数累加到变量 `$t` 中，直到所有行都被处理完。接下来，它打印结果，结果包含所有行的单词数量。注意，你将 `@F` 数组添加到标量变量
    `$t` 中。由于 `$t` 是标量，`@F` 数组在标量上下文中求值并返回它所包含的元素数量。
- en: 'Running this one-liner on the following file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下文件上运行这个一行代码：
- en: '[PRE32]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: produces the number `6` as output because the file contains a total of six words.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 输出数字 `6`，因为该文件总共包含六个单词。
- en: 4.13 Print the total number of fields that match a pattern
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.13 打印匹配模式的字段总数
- en: '[PRE33]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This one-liner uses `map` to apply an operation to each element in the `@F`
    array. In this example, the operation checks to see if each element matches `/regex/`,
    and if it does, it increments the `$t` variable. It then prints the `$t` variable,
    which contains the number of fields that match the `/regex/` pattern. The `$t
    || 0` construct is necessary because if no fields match, `$t` wouldn’t exist,
    so you must provide a default value. Instead of `0`, you can provide any other
    default value, even a string!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个一行代码使用 `map` 对 `@F` 数组中的每个元素应用操作。在这个示例中，操作检查每个元素是否匹配 `/regex/`，如果匹配，则增加 `$t`
    变量。然后它打印 `$t` 变量，其中包含匹配 `/regex/` 模式的字段数量。`$t || 0` 结构是必要的，因为如果没有字段匹配，`$t` 将不存在，所以必须提供一个默认值。你可以提供任何其他默认值，甚至是字符串，而不是
    `0`！
- en: 'Looping would be a better approach:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 循环会是一个更好的方法：
- en: '[PRE34]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, each element in `@F` is tested against `/regex/`. If it matches, `/regex/`
    returns true; otherwise it returns false. When used numerically, true converts
    to `1` and false converts to `0`, so `$t += /regex/` adds either `1` or `0` to
    the `$t` variable. As a result, the number of matches is counted in `$t`. You
    do not need a default value when printing the result in the `END` block because
    the `+=` operator is run regardless of whether the field matches. You will always
    get a value, and sometimes that value will be `0`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`@F` 中的每个元素都与 `/regex/` 进行测试。如果匹配，`/regex/` 返回真；否则返回假。当按数值使用时，真转化为 `1`，假转化为
    `0`，因此 `$t += /regex/` 会将 `1` 或 `0` 加到 `$t` 变量中。结果是，匹配的数量被计入 `$t`。在 `END` 块中打印结果时不需要默认值，因为无论字段是否匹配，`+=`
    操作符都会执行。你总会得到一个值，有时这个值会是 `0`。
- en: 'Another way to do this is to use `grep` in the scalar context:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种做法是使用在标量上下文中的 `grep`：
- en: '[PRE35]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, `grep` returns the number of matches because it’s evaluated in the scalar
    context. In the list context, `grep` returns all matching elements, but in the
    scalar context, it returns the number of matching elements. This number is accumulated
    in `$t` and printed in the `END` block. In this case, you don’t need to provide
    a default value for `$t` because `grep` returns `0` in those situations.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`grep` 返回匹配的数量，因为它在标量上下文中被求值。在列表上下文中，`grep` 返回所有匹配的元素，但在标量上下文中，它返回匹配元素的数量。这个数字会累计到
    `$t` 中，并在 `END` 块中打印。在这种情况下，你不需要为 `$t` 提供默认值，因为 `grep` 在这些情况下会返回 `0`。
- en: 4.14 Print the total number of lines that match a pattern
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.14 打印匹配模式的行数
- en: '[PRE36]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here, `/regex/` evaluates to true if the current line of input matches this
    regular expression. Writing `/regex/ && $t++` is the same as writing `if ($_ =~
    /regex/) { $t++ }`, which increments the `$t` variable if the line matches the
    specified pattern. In the `END` block, the `$t` variable contains the total number
    of pattern matches and is printed; but if no lines match, `$t` is once again undefined,
    so you must print a default value.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`/regex/` 如果当前输入行匹配这个正则表达式，则评估为真。写 `/regex/ && $t++` 就等同于写 `if ($_ =~ /regex/)
    { $t++ }`，它会在行匹配指定模式时递增 `$t` 变量。在 `END` 块中，`$t` 变量包含模式匹配的总次数并被打印；但是如果没有匹配的行，`$t`
    会再次未定义，因此你必须打印一个默认值。
- en: 4.15 Print the number π
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.15 打印数字 π
- en: '[PRE37]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `bignum` package exports the `bpi` function that calculates the π constant
    to the desired accuracy. This one-liner prints π to 20 decimal places. (Notice
    that you need to specify `n+1` to print it to an accuracy of `n`.)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`bignum` 包导出了 `bpi` 函数，用于按所需精度计算 π 常数。这个一行代码将 π 打印到 20 位小数。（注意，你需要指定 `n+1`
    才能将其精确到 `n` 位。）'
- en: 'The `bignum` library also exports the constant π, precomputed to 39 decimal
    places:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`bignum` 库还导出了常数 π，已预计算到 39 位小数：'
- en: '[PRE38]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 4.16 Print the number *e*
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.16 打印数字 *e*
- en: '[PRE39]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `bignum` library exports the `bexp` function, which takes two arguments:
    the power to raise *e* to, and the desired accuracy. This one-liner prints the
    constant *e* to 20 decimal places.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`bignum` 库导出了 `bexp` 函数，它接受两个参数：要将 *e* 提高的幂数和所需的精度。这个一行代码将常数 *e* 打印到 20 位小数。'
- en: 'For example, you could print the value of *e*² to 30 decimal places:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以打印 *e*² 的值，精确到 30 位小数：
- en: '[PRE40]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As with π, `bignum` also exports the constant *e* precomputed to 39 decimal
    places:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与 π 相似，`bignum` 也导出了常数 *e*，并已预计算到 39 位小数：
- en: '[PRE41]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 4.17 Print UNIX time (seconds since January 1, 1970, 00:00:00 UTC)
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.17 打印 UNIX 时间（自 1970 年 1 月 1 日 00:00:00 UTC 起的秒数）
- en: '[PRE42]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The built-in `time` function returns seconds since the epoch. This one-liner
    simply prints the time.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `time` 函数返回自纪元以来的秒数。这个一行代码仅打印当前时间。
- en: 4.18 Print Greenwich Mean Time and local computer time
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.18 打印格林威治标准时间和本地计算机时间
- en: '[PRE43]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `gmtime` function is a built-in Perl function. When used in the scalar context,
    it returns the time localized to Greenwich Mean Time (GMT).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`gmtime` 函数是一个内置的 Perl 函数。当在标量上下文中使用时，它返回本地化为格林威治标准时间（GMT）的时间。'
- en: 'The built-in `localtime` function acts like `gmtime`, except it returns the
    computer’s local time when it’s used in the scalar context:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 `localtime` 函数与 `gmtime` 类似，不同之处在于，当在标量上下文中使用时，它返回计算机的本地时间：
- en: '[PRE44]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the list context, both `gmtime` and `localtime` return a nine-element list
    (known as `struct tm` to UNIX programmers) with the following elements:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表上下文中，`gmtime` 和 `localtime` 都返回一个包含九个元素的列表（UNIX 程序员称之为 `struct tm`），其中包含以下元素：
- en: '[PRE45]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can *slice* this list (that is, extract elements from it) or print individual
    elements if you need just some part of the information it contains. For example,
    to print `H:M:S`, slice the elements `2`, `1`, and `0` from `localtime`, like
    this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以 *切片* 这个列表（即从中提取元素），或者如果只需要其中的一部分信息，可以打印单个元素。例如，要打印 `H:M:S`，可以从 `localtime`
    中切片元素 `2`、`1` 和 `0`，如下所示：
- en: '[PRE46]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To slice elements individually, specify a list of elements to extract, for
    instance `[2,1,0]`. Or slice them as a range:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要单独切片元素，可以指定一个要提取的元素列表，例如 `[2,1,0]`。或者按范围切片：
- en: '[PRE47]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This one-liner prints the hour, date, month, year, and day of the week.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码打印小时、日期、月份、年份和星期几。
- en: 'You can also use negative indexes to select elements from the opposite end
    of a list:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用负索引从列表的另一端选择元素：
- en: '[PRE48]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This one-liner prints elements `7` and `6`, which are the day of the year (for
    example, the 200th day) and of the week (for example, the 4th day), respectively.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个一行代码打印元素 `7` 和 `6`，它们分别是年份中的第几天（例如，第 200 天）和星期几（例如，第 4 天）。
- en: 4.19 Print yesterday’s date
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.19 打印昨天的日期
- en: '[PRE49]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Remember that `localtime` returns a nine-item list (see one-liner 4.18) of various
    date elements. The fourth element in the list is the current month’s day. If you
    subtract 1 from this element, you get yesterday.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`localtime`返回一个包含九个元素的列表（参见一行代码 4.18），这些元素是各种日期信息。列表中的第四个元素是当前月的日期。如果从这个元素中减去1，你将得到昨天的日期。
- en: The `mktime` function constructs the UNIX epoch time from this modified nine-element
    list, and the `scalar localtime` construct prints the new date, which is yesterday.
    This one-liner also works in edge cases, such as when the current day is the first
    day of the month. You need the `POSIX` package because it exports the `mktime`
    function.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`mktime`函数根据这个修改过的九元素列表构建UNIX纪元时间，而`scalar localtime`结构打印出新的日期，即昨天。这行代码在一些极端情况下也能正常工作，比如当前日期是月初时。你需要`POSIX`包，因为它导出了`mktime`函数。'
- en: For example, if it’s *Mon May 20 05:49:55* right now, running this one-liner
    prints *Sun May 19 05:49:55*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果现在是*Mon May 20 05:49:55*，运行这行代码将打印出*Sun May 19 05:49:55*。
- en: 4.20 Print the date 14 months, 9 days, and 7 seconds ago
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.20 打印出14个月、9天和7秒前的日期
- en: '[PRE50]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This one-liner modifies the first, fourth, and fifth elements of the `@now`
    list. The first element is seconds, the fourth is days, and the fifth is months.
    The `mktime` command generates the UNIX time from this new structure, and `localtime`,
    which is evaluated in the scalar context, prints the date 14 months, 9 days, and
    7 seconds ago.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码修改了`@now`列表中的第一个、第四个和第五个元素。第一个元素是秒，第四个是天，第五个是月。`mktime`命令根据这个新的结构生成UNIX时间，而在标量上下文中计算的`localtime`则打印出14个月、9天和7秒前的日期。
- en: 4.21 Calculate the factorial
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.21 计算阶乘
- en: '[PRE51]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This one-liner uses the `bfac()` function from the `Math::BigInt` module in
    the Perl core. (In other words, you don’t need to install it.) The `Math::BigInt->new(5)`
    construction creates a new `Math::BigInt` object with a value of `5`, after which
    the `bfac()` method is called on the newly created object to calculate the factorial
    of `5`. Change `5` to any number you wish to find its factorial.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码使用了`Math::BigInt`模块中的`bfac()`函数（即Perl核心自带，无需安装）。`Math::BigInt->new(5)`构造创建了一个值为`5`的`Math::BigInt`对象，接着调用该对象的`bfac()`方法来计算`5`的阶乘。将`5`改为任何你想要的数字来找到它的阶乘。
- en: 'Another way to calculate a factorial is to multiply the numbers from 1 to *n*
    together:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 计算阶乘的另一种方法是将1到*n*的数字相乘：
- en: '[PRE52]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, I set `$f` to `1` and then loop from `1` to `5` and multiply `$f` by each
    value. The result is `120` (`1*2*3*4*5`), the factorial of `5`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将`$f`设置为`1`，然后从`1`循环到`5`，并将`$f`乘以每个值。结果是`120`（`1*2*3*4*5`），即5的阶乘。
- en: 4.22 Calculate the greatest common divisor
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.22 计算最大公约数
- en: '[PRE53]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '`Math::BigInt` has several other useful math functions including `bgcd`, which
    calculates the *greatest common divisor (gcd)* of a list of numbers. For example,
    to find the greatest common divisor of `(20, 60, 30)`, execute the one-liner like
    this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Math::BigInt`有几个其他有用的数学函数，包括`bgcd`，它计算一组数字的*最大公约数（gcd）*。例如，要找到`(20, 60, 30)`的最大公约数，可以像这样执行这行代码：'
- en: '[PRE54]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To calculate the gcd from a file or user’s input, use the `-a` command-line
    argument and pass the `@F` array to the `bgcd` function:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要从文件或用户输入中计算最大公约数，可以使用`-a`命令行参数，并将`@F`数组传递给`bgcd`函数：
- en: '[PRE55]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: (I explained the `-a` argument and the `@F` array in one-liner 4.2 on page 30.)
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: （我在一行代码 4.2中解释了`-a`参数和`@F`数组，见第30页。）
- en: 'You could also use Euclid’s algorithm to find the gcd of `$n` and `$m`. This
    one-liner does just that and stores the result in `$m`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用欧几里得算法来找到`$n`和`$m`的最大公约数。这行代码正是做了这件事，并将结果存储在`$m`中：
- en: '[PRE56]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Euclid’s algorithm is one of the oldest algorithms for finding the gcd.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得算法是最古老的求最大公约数算法之一。
- en: 4.23 Calculate the least common multiple
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.23 计算最小公倍数
- en: 'The *least common multiple (lcm)* function, `blcm`, is included in `Math::BigInt`.
    Use this one-liner to find the least common multiple of `(35, 20, 8)`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '*最小公倍数（lcm）*函数`blcm`包含在`Math::BigInt`中。使用这行代码来找到`(35, 20, 8)`的最小公倍数：'
- en: '[PRE57]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To find the lcm from a file with numbers, use the `-a` command-line switch
    and the `@F` array:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要从包含数字的文件中找到最小公倍数，可以使用`-a`命令行开关和`@F`数组：
- en: '[PRE58]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If you know a bit of number theory, you may recall that there is a connection
    between the gcd and the lcm. Given two numbers `$n` and `$m`, you know that their
    lcm is `$n*$m/gcd($n,$m)`. This one-liner, therefore, follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道一些数论知识，可能会记得最大公约数和最小公倍数之间是有关系的。给定两个数字`$n`和`$m`，你知道它们的最小公倍数是`$n*$m/gcd($n,$m)`。因此，这行代码如下所示：
- en: '[PRE59]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 4.24 Generate 10 random numbers between 5 and 15 (excluding 15)
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.24 生成5到15之间（不包括15）的10个随机数
- en: '[PRE60]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This one-liner prints 10 random numbers between 5 and 15\. It may look complicated,
    but it’s actually simple. `int(rand(15-5))` is just `int(rand(10))`, which returns
    a random integer from 0 to 9\. Adding `5` to it makes it return a random integer
    from 5 to 14\. The range `1..10` makes it draw 10 random integers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码打印了10个介于5和15之间的随机数。看起来可能很复杂，但其实很简单。`int(rand(15-5))`其实就是`int(rand(10))`，它返回一个从0到9之间的随机整数。加上`5`后，它返回一个从5到14之间的随机整数。范围`1..10`使得它生成10个随机整数。
- en: 'You can also write this one-liner more verbosely:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将这个一行代码写得更详细一些：
- en: '[PRE61]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, all variables are more explicit. To modify this one-liner, change the
    variables `$n`, `$min`, and `$max`. The `$n` variable represents how many random
    numbers to generate, and `$min-$max` is the range of numbers for use in that generation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，所有的变量都更为明确。要修改这个一行代码，可以更改变量`$n`、`$min`和`$max`。`$n`变量表示要生成多少个随机数，而`$min-$max`是生成随机数时的范围。
- en: The `$`, variable is set to a space because it’s the output field separator
    for `print` and it’s `undef` by default. If you didn’t set `$`, to a space, the
    numbers would be printed concatenated. (See one-liner 4.4 on page 32 for a discussion
    of `$`,.)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`$`变量被设置为空格，因为它是`print`的输出字段分隔符，默认值是`undef`。如果你没有将`$`设置为空格，数字就会被连接在一起打印。（参见第32页的一行代码4.4，讨论了`$`的用法。）'
- en: 4.25 Generate all permutations of a list
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.25 生成列表的所有排列
- en: '[PRE62]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This one-liner uses the object-oriented interface of the module `Algorithm::Permute`
    to find all permutations of a list, that is, all ways to rearrange items. The
    constructor of `Algorithm::Permute` takes an array reference of elements to permute.
    In this particular one-liner, the elements are the numbers `1, 2, 3, 4, 5`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码使用了`Algorithm::Permute`模块的面向对象接口来找到列表的所有排列，也就是所有重新排列项的方式。`Algorithm::Permute`的构造函数接收一个元素数组的引用，用于排列。在这个特定的一行代码中，元素是数字`1,
    2, 3, 4, 5`。
- en: 'The `next` method returns the next permutation. Calling it repeatedly iterates
    over all permutations, and each permutation is put in the `@r` array and then
    printed. (Beware: The output list gets large really quickly. There are `n!` (*n*
    factorial) permutations for a list of `n` elements.)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`next`方法返回下一个排列。反复调用它可以遍历所有排列，每个排列都会被放入`@r`数组中并打印出来。（注意：输出的排列列表会迅速变大。对于一个包含`n`个元素的列表，有`n!`（*n*的阶乘）个排列。）'
- en: 'Another way to print all permutations is with the `permute` subroutine:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 打印所有排列的另一种方式是使用`permute`子例程：
- en: '[PRE63]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here’s what you get if you change `@l` to just three elements `(1, 2, 3)` and
    run it:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`@l`更改为仅包含三个元素`(1, 2, 3)`并运行它，得到的结果如下：
- en: '[PRE64]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 4.26 Generate the powerset
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.26 生成幂集
- en: '[PRE65]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This one-liner uses the `List::PowerSet` module from CPAN. The module exports
    the `powerset` function, which takes a list of elements and returns a reference
    to an array containing references to subset arrays. You can install this module
    by running `cpan List::PowerSet` at the command line.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码使用了来自CPAN的`List::PowerSet`模块。该模块导出了`powerset`函数，它接收一个元素列表并返回一个数组引用，该数组包含指向子集数组的引用。你可以通过在命令行运行`cpan
    List::PowerSet`来安装此模块。
- en: In the `for` loop, you call the `powerset` function and pass it the list of
    elements of `@l`. Next, you dereference the return value of `powerset`, which
    is a reference to an array of subsets, and then dereference each individual subset
    `@$_` and print it.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中，你调用`powerset`函数并将`@l`的元素列表传递给它。接下来，你取消引用`powerset`的返回值，它是一个包含子集的数组引用，然后再取消引用每个子集`@$_`并打印出来。
- en: 'The *powerset* is the set of all subsets. For a set of *n* elements, there
    are exactly 2^(*n*) subsets in the powerset. Here’s an example of the powerset
    of `(1, 2, 3)`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*幂集*是所有子集的集合。对于一个包含*n*个元素的集合，幂集中恰好有2^(*n*)个子集。这里是`(1, 2, 3)`的幂集示例：'
- en: '[PRE66]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 4.27 Convert an IP address to an unsigned integer
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.27 将IP地址转换为无符号整数
- en: '[PRE67]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This one-liner converts the IP address `127.0.0.1` into an unsigned integer
    by first doing a global match of `(\d+)` on the IP address. Performing a `for`
    loop over a global match iterates over all the matches, which are the four parts
    of the IP address: `127`, `0`, `0`, `1`.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码将IP地址`127.0.0.1`转换为一个无符号整数，方法是首先对IP地址进行全局匹配`(\d+)`。执行`for`循环遍历全局匹配时，会迭代所有的匹配项，这些匹配项就是IP地址的四个部分：`127`、`0`、`0`、`1`。
- en: Next, the matches are summed in the `$u` variable. The first bit is shifted
    8 × 3 = 24 places, the second is shifted 8 × 2 = 16 places, and the third is shifted
    8 places. The last is simply added to `$u`. The resulting integer happens to be
    `2130706433` (a very geeky number).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，匹配结果被加总到`$u`变量中。第一个位移8 × 3 = 24位，第二个位移8 × 2 = 16位，第三个位移8位。最后一个直接加到`$u`中。得到的整数恰好是`2130706433`（一个非常极客的数字）。
- en: 'Here are some more one-liners:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有更多的单行代码：
- en: '[PRE68]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This one-liner utilizes the fact that `127.0.0.1` can be easily converted to
    hex. Here, the `$ip` is matched against `(\d+)`, and each IP part is transformed
    into a hex number with `sprintf("%02x", $1)` inside the `s` operator. The `/e`
    flag of the `s` operator makes it evaluate the substitution part as a Perl expression.
    As a result, `127.0.0.1` is transformed into `7f000001` and then interpreted as
    a hexadecimal number by Perl’s `hex` operator, which converts it to a decimal
    number.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码利用了`127.0.0.1`可以很容易转换为十六进制的事实。在这里，`$ip`与`(\d+)`匹配，每个IP部分都通过`sprintf("%02x",
    $1)`在`s`操作符内转换为十六进制数字。`s`操作符的`/e`标志使得替换部分作为Perl表达式进行求值。结果，`127.0.0.1`被转换为`7f000001`，然后通过Perl的`hex`操作符将其解释为十六进制数，并转换为十进制数。
- en: 'You can also use `unpack`:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`unpack`：
- en: '[PRE69]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This one-liner is probably as short as possible. It uses *vstring literals*
    (version strings) to express the IP address. A vstring forms a string literal
    composed of characters with the specified ordinal values. The newly formed string
    literal is unpacked into a number from a string in network byte order (big-endian
    order) and then printed.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码可能是尽可能简短的了。它使用了*vstring字面量*（版本字符串）来表示IP地址。vstring是由指定的序号值组成的字符串字面量。新形成的字符串字面量被解包为网络字节顺序（大端顺序）的数字，并被打印出来。
- en: 'If you have a string with an IP (rather than a vstring), you first have to
    convert it to byte form with the function `inet_aton`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个包含IP的字符串（而不是vstring），你首先需要使用`inet_aton`函数将其转换为字节形式：
- en: '[PRE70]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, `inet_aton` converts the string `127.0.0.1` to the byte form (equivalent
    to the pure vstring `127.0.0.1`) and then `unpack` unpacks it, as in the previous
    one-liner.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`inet_aton`将字符串`127.0.0.1`转换为字节形式（等同于纯粹的vstring `127.0.0.1`），然后`unpack`将其解包，就像前面的单行代码那样。
- en: 4.28 Convert an unsigned integer to an IP address
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.28 将无符号整数转换为IP地址
- en: '[PRE71]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here, the integer `2130706433` is packed into a number in big-endian byte order
    and then passed to the `inet_ntoa` function that converts a number back to an
    IP address. (Notice that `inet_ntoa` is the opposite of `inet_aton`.)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，整数`2130706433`被打包成大端字节顺序的数字，然后传递给`inet_ntoa`函数，该函数将数字转换回IP地址。（注意，`inet_ntoa`是`inet_aton`的反向操作。）
- en: 'You can do the same thing like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以这样做：
- en: '[PRE72]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Here, the `$ip` is shifted 24 bits to the right and then bitwise ANDed with
    `0xFF` to produce the first part of the IP, which is `127`. Next, it’s shifted
    16 bits and bitwise ANDed with `0xFF`, producing `0`, and then shifted 8 bits
    and bitwise ANDed with `0xFF`, producing another `0`. Finally, the whole number
    is bitwise ANDed with `0xFF`, producing `1`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`$ip`首先向右移动24位，然后与`0xFF`进行按位与运算，生成IP的第一部分，即`127`。接着，向右移动16位并与`0xFF`按位与，得到`0`，然后再向右移动8位并与`0xFF`按位与，得到另一个`0`。最后，整个数字与`0xFF`按位与，得到`1`。
- en: The result from `map { ... }` is a list `(127, 0, 0, 1)`. That list is now `join`ed
    by a dot `"."` to produce the IP address `127.0.0.1`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`map { ... }`的结果是一个列表`(127, 0, 0, 1)`。这个列表现在通过点号`"."`连接，生成IP地址`127.0.0.1`。'
- en: 'You can replace `join` with the special variable `$`,, which acts as a value
    separator for the `print` statement:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用特殊变量`$`替代`join`，它在`print`语句中充当值分隔符：
- en: '[PRE73]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Because `reverse 0..3` is the same as `3,2,1,0`, you could also write:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`reverse 0..3`与`3,2,1,0`相同，所以你也可以写成：
- en: '[PRE74]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
