["```\n$ `date`\nTue Dec 28 15:54:08 CET 2010\n$ `date -s '2018-02-01 21:39'`\ndate: cannot set date: Operation not permitted\nThu Feb  1 21:39:00 CET 2018\n```", "```\n$ `sudo date -s '2018-02-01 21:39'`\nroot's password:\nThu Feb  1 21:39:00 CET 2018\n$ `date`\nThu Feb  1 21:39:02 CET 2018\n```", "```\n$ `whereis -b date`                           *Find location of* *date* *binary*\ndate: /bin/date\n$ `cp /bin/date .`\n$ `sudo setcap \"cap_sys_time=pe\" date`\nroot's password:\n$ `getcap date`\ndate = cap_sys_time+ep\n```", "```\n$ `./date -s '2010-12-28 15:55'`\nTue Dec 28 15:55:00 CET 2010\n$ `date`\nTue Dec 28 15:55:02 CET 2010\n```", "```\nP'(permitted) = (P(inheritable) & F(inheritable)) | (F(permitted) & cap_bset)\n\nP'(effective) = F(effective) ? P'(permitted) : 0\n\nP'(inheritable) = P(inheritable)\n```", "```\nP'(permitted) = P(inheritable) | cap_bset\nP'(effective) = P'(permitted)\n```", "```\n$ `sudo setcap \"cap_dac_read_search=p\" check_password_caps`\nroot's password:\n$ `getcap check_password_caps`\ncheck_password_caps = cap_dac_read_search+p\n$ `./check_password_caps`\nUsername: `mtk`\nPassword:\nSuccessfully authenticated: UID=1000\n```", "```\n`cap/check_password_caps.c`\n#define _BSD_SOURCE         /* Get getpass() declaration from <unistd.h> */\n#define _XOPEN_SOURCE       /* Get crypt() declaration from <unistd.h> */\n#include <sys/capability.h>\n#include <unistd.h>\n#include <limits.h>\n#include <pwd.h>\n#include <shadow.h>\n#include \"tlpi_hdr.h\"\n\n/* Change setting of capability in caller's effective capabilities */\n\nstatic int\nmodifyCap(int capability, int setting)\n{\n    cap_t caps;\n    cap_value_t capList[1];\n\n    /* Retrieve caller's current capabilities */\n\n    caps = cap_get_proc();\n    if (caps == NULL)\n        return -1;\n\n    /* Change setting of 'capability' in the effective set of 'caps'. The\n       third argument, 1, is the number of items in the array 'capList'. */\n\n    capList[0] = capability;\n    if (cap_set_flag(caps, CAP_EFFECTIVE, 1, capList, setting) == -1) {\n        cap_free(caps);\n        return -1;\n    }\n\n    /* Push modified capability sets back to kernel, to change\n       caller's capabilities */\n\n    if (cap_set_proc(caps) == -1) {\n        cap_free(caps);\n        return -1;\n    }\n\n    /* Free the structure that was allocated by libcap */\n\n    if (cap_free(caps) == -1)\n        return -1;\n\n    return 0;\n}\n\nstatic int              /* Raise capability in caller's effective set */\nraiseCap(int capability)\n{\n    return modifyCap(capability, CAP_SET);\n}\n\n/* An analogous dropCap() (unneeded in this program), could be\n   defined as: modifyCap(capability, CAP_CLEAR); */\n\nstatic int              /* Drop all capabilities from all sets */\ndropAllCaps(void)\n{\n    cap_t empty;\n    int s;\n\n    empty = cap_init();\n    if (empty == NULL)\n        return -1;\n\n    s = cap_set_proc(empty);\n    if (cap_free(empty) == -1)\n        return -1;\n\n    return s;\n}\n\nint\nmain(int argc, char *argv[])\n{\n    char *username, *password, *encrypted, *p;\n    struct passwd *pwd;\n    struct spwd *spwd;\n    Boolean authOk;\n    size_t len;\n    long lnmax;\n\n    lnmax = sysconf(_SC_LOGIN_NAME_MAX);\n    if (lnmax == -1)                        /* If limit is indeterminate */\n        lnmax = 256;                        /* make a guess */\n\n    username = malloc(lnmax);\n    if (username == NULL)\n        errExit(\"malloc\");\n\n    printf(\"Username: \");\n    fflush(stdout);\n    if (fgets(username, lnmax, stdin) == NULL)\n        exit(EXIT_FAILURE);                 /* Exit on EOF */\n\n    len = strlen(username);\n    if (username[len - 1] == '\\n')\n        username[len - 1] = '\\0';           /* Remove trailing '\\n' */\n\n    pwd = getpwnam(username);\n    if (pwd == NULL)\n        fatal(\"couldn't get password record\");\n\n    /* Only raise CAP_DAC_READ_SEARCH for as long as we need it */\n\n    if (raiseCap(CAP_DAC_READ_SEARCH) == -1)\n        fatal(\"raiseCap() failed\");\n\n    spwd = getspnam(username);\n    if (spwd == NULL && errno == EACCES)\n        fatal(\"no permission to read shadow password file\");\n\n    /* At this point, we won't need any more capabilities,\n       so drop all capabilities from all sets */\n\n    if (dropAllCaps() == -1)\n        fatal(\"dropAllCaps() failed\");\n\n    if (spwd != NULL)               /* If there is a shadow password record */\n        pwd->pw_passwd = spwd->sp_pwdp;     /* Use the shadow password */\n\n    password = getpass(\"Password: \");\n\n    /* Encrypt password and erase cleartext version immediately */\n\n    encrypted = crypt(password, pwd->pw_passwd);\n    for (p = password; *p != '\\0'; )\n        *p++ = '\\0';\n\n    if (encrypted == NULL)\n        errExit(\"crypt\");\n\n    authOk = strcmp(encrypted, pwd->pw_passwd) == 0;\n    if (!authOk) {\n        printf(\"Incorrect password\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    printf(\"Successfully authenticated: UID=%ld\\n\", (long) pwd->pw_uid);\n\n    /* Now do authenticated work... */\n\n    exit(EXIT_SUCCESS);\n}\n     `cap/check_password_caps.c`\n```", "```\nif (prctl(PR_SET_SECUREBITS,\n          /* SECBIT_KEEP_CAPS off */\n          SECBIT_NO_SETUID_FIXUP | SECBIT_NO_SETUID_FIXUP_LOCKED |\n          SECBIT_NOROOT | SECBIT_NOROOT_LOCKED)\n        == -1)\n    errExit(\"prctl\");\n```"]