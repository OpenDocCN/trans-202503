<html><head></head><body>
<div id="sbo-rt-content" class="calibre1"><section aria-labelledby="ch26" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="title" id="ch26">
<span class="cn"><span aria-label=" Page 305. " epub:type="pagebreak" id="pg_305" role="doc-pagebreak" class="calibre2"/><span class="sans_dogma_ot_bold_b_">26</span></span>
<span class="ct1"><span class="sans_dogma_ot_bold_b_">AUTOMATIC RESTARTS AND MULTITHREADING</span></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener1" height="407" src="../images/chapter.jpg" width="408"/>
</figure>
<p class="chapterintro">In this chapter, I’ll explore solutions to a couple of vexing issues for any coder: intermittent failures and hangs, specifically the type that usually execute successfully if restarted. I’ll detail how to automatically restart an intermittent failure of any process in a bat file. Hangs are a little trickier, but I’ll introduce a technique for terminating or killing the hung process before restarting it. For both types of issues, I’ll step through how to create a solution, including design considerations, specifications, coding, and even testing.</p>
<p class="tx">Along the way, I’ll introduce some interesting commands that have applications beyond automatic restarts. One puts a bat file to sleep for a defined period of time. Another one monitors all of the processes running on a computer (think of it as Task Manager inside a bat file). Yet another <span aria-label=" Page 306. " epub:type="pagebreak" id="pg_306" role="doc-pagebreak"/>command terminates any specific process or multiple processes on a computer. Ultimately, this discussion will lead to the seemingly unrelated technique of multithreading or concurrency.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="h"><span id="sec1"/><span id="h1-175"/><span class="sans_futura_std_bold_b_">Five Stages of Intermittent Failures</span></h3>
<p class="tni">The bane of a coder’s existence is the intermittent failure. It might be a simple <span class="sans_thesansmonocd_w5regular_">xcopy</span> command that fails because of a temporary network or server communication issue. You might have to call a program written by someone else that sometimes fails to connect to a web service or simply fails for no apparent reason from time to time. Simply rerunning the process “fixes” the issue, but doing so wastes resources and causes delays. I’ve been involved in a number of these episodes, and every last one has followed these “Five Stages of Intermittent Failures” (loosely based on the “Five Stages of Grief”):</p>
<p class="runinpara"><b class="calibre10">Stage 1: Denial</b>    “This looks like a fluke. I can’t find anything wrong. Just rerun it.”</p>
<p class="runinpara1"><b class="calibre10">Stage 2: Anger</b>    The operator who’s tasked with tracking down and restarting the failures is peeved; the Batch coder who has no control over the network or the executable they’re invoking is cross; the mid-level manager with even less control is vexed. Each failure makes the situation worse until everybody is just plain angry.</p>
<p class="runinpara1"><b class="calibre10">Stage 3: Finger Pointing</b>    “It’s the fault of networking. Our servers are held together with duct tape and chicken wire.” “No, the vendor product is malfunctioning.” “No, your environment can’t support our product.” “It’s a problem with our internet provider.” “That guy who retired a couple of months ago left us with junk.”</p>
<p class="runinpara1"><b class="calibre10">Stage 4: Exploration</b>    A manager harrumphs, “I don’t want a Band-Aid. We need to find the root cause.” This is something everyone can agree on, because no one wants to be the lone member of the Band-Aid caucus—at least initially. Extra logging is put in place and diagnostic tools are installed on any piece of hardware that might be remotely involved in the issue. Different groups dive into their codebase and develop theories. Sometimes the root cause is found, sparing everyone the last stage, but more often than not the ghost in the machine remains an enigma.</p>
<p class="runinpara2"><b class="calibre10">Stage 5: Acceptance</b>    Finally heeding Voltaire’s proverb, “The best is the enemy of the good,” the Batch coder fixes the issue with an automatic restart of the suspect process.</p>
<p class="tx">As long as one person holds onto the hope of finding the root cause, it’s difficult to move on to the final stage of acceptance. It might take days, weeks, or months, but when it becomes obvious that a root cause won’t be forthcoming or would be exceedingly expensive or difficult to fix, the only option is to attack the problem at its manifestation. Notice that in the fifth stage I didn’t put the word <i class="calibre6">fixes</i> in quotes. Some holdouts will still call it a <span aria-label=" Page 307. " epub:type="pagebreak" id="pg_307" role="doc-pagebreak"/>Band-Aid or a work-around, but a well-designed automatic restart process will correct the problem so that no one will be bothered by it again. I call that a <i class="calibre6">fix</i>.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">
<h3 class="h"><span id="sec2"/><span id="h1-176"/><span class="sans_futura_std_bold_b_">The timeout Command</span></h3>
<p class="tni">Before building an automatic restart, I’ll introduce a new command that’ll be very helpful in its design. Prior to initiating an automatic restart, I’ll want to put the bat file to sleep for a short period of time to allow any momentary server or connectivity issues to clear. Doing nothing is easy for humans; for some it’s our default state, but a computer program is designed to execute as fast as possible. Fortunately, Batch has given us the <span class="sans_thesansmonocd_w5regular_">timeout</span> command, possibly modeled after the timeout taken in sports or enforced upon a misbehaving youth.</p>
<p class="tx">It’s a simple command that accepts a single argument: the length of the timeout in seconds. This command will sleep for one minute:</p>
<pre class="pre"><code class="calibre11">timeout 60</code></pre>
<p class="tx">Batch allows for a maximum timeout of 99,999 seconds, which translates to more than 27 hours. When this command is used interactively, the user sees a countdown on the console until processing resumes and has the option of pressing any key to end the timeout early and continue.</p>
<p class="tx">There are a couple of mild oddities with the <span class="sans_thesansmonocd_w5regular_">timeout</span> command. First, it accepts an argument of <span class="sans_thesansmonocd_w5regular_">0</span>. This would make no sense as a hardcoded value, but consider this command:</p>
<pre class="pre"><code class="calibre11">timeout %sleepSeconds%</code></pre>
<p class="tx">If you are determining the sleep time in the code, it offers an easy way of essentially turning off the command without wrapping it up in an <span class="sans_thesansmonocd_w5regular_">if</span> command. Set <span class="sans_thesansmonocd_w5regular_">sleepSeconds</span> to <span class="sans_thesansmonocd_w5regular_">300</span> for a five-minute break or to <span class="sans_thesansmonocd_w5regular_">0</span> if you want to skip the command. An argument of <span class="sans_thesansmonocd_w5regular_">-1</span> results in an indefinite wait time until any key is pressed, which is really just a glorified <span class="sans_thesansmonocd_w5regular_">pause</span> command.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">
<h3 class="h"><span id="sec3"/><span id="h1-177"/><span class="sans_futura_std_bold_b_">The Automatic Restart</span></h3>
<p class="tni">Let’s step through the process of building an automatic restart of some process that fails intermittently. Design considerations will inform the specifications that’ll lead to writing and testing the code.</p>
<section aria-labelledby="sec4" epub:type="division">
<h4 class="h1"><span id="sec4"/><span id="h2-78"/><span class="sans_futura_std_heavy_oblique_bi_">The Design Considerations</span></h4>
<p class="tni">The basic concept of an auto-restart is straightforward. When any process generates a bad return code, the main logic normally aborts the execution in an orderly fashion. An auto-restart instead circles back and reruns the offending process. In Batch, that might sound like nothing more than an <span aria-label=" Page 308. " epub:type="pagebreak" id="pg_308" role="doc-pagebreak"/><span class="sans_thesansmonocd_w5regular_">if</span> command and a <span class="sans_thesansmonocd_w5regular_">goto</span> command, but the details quickly become involved and in need of a well-thought-out design.</p>
<p class="tx">Ideally the restart works, and the process continues to completion, but sometimes the auto-restart also fails, and if it continues to fail, the prospect of an endless loop mounts. Someone has to make a decision concerning the number of times to restart the process before conceding defeat and initiating an abort.</p>
<p class="tx">If a process fails without explanation one time in 100, the restarted process will likely fail one time in 100 as well. Basic probability theory dictates that if an event occurs once in 100 attempts, the odds are 1/100. To find the odds of this randomly occurring twice in succession, the ratio is squared, giving us 1/10,000. Cubing the original odds gives us one chance in a million of the event occurring in three consecutive attempts. An exponent of five tells us that just one in 10 billion events should see this fail five straight times.</p>
<p class="tx">This means that five or six attempts should get us to a point where the failures will realistically no longer happen if—and this is an enormous if—the one failure in 100 attempts is truly random.</p>
<p class="tx">Oftentimes failures are not random, and that also factors into the design considerations. Failures might happen when a server or a database is busy during peak processing times. Occasionally, for no apparent reason two servers will lose connectivity for a split second or a couple of seconds or several minutes. If a copy from one of these boxes to another one fails, the next 10 auto-restarts might happen in less time than it takes you to read this sentence, meaning that all 10 happen during the window of lost connectivity. This isn’t random.</p>
<p class="tx">For that type of failure, you’ll need more analysis. How long does it take for the issue to typically clear itself? In most situations, it’s best to go to sleep for a few seconds before the first auto-restart, as mentioned previously. After subsequent failures, we can initiate longer and longer wait times. If the issue typically clears in a minute, the total restart attempts should finish up in about three or four minutes, with the time frame adjusted from there.</p>
<p class="tx">If this seems overwhelming, does it make sense to just go with hundreds of auto-restart attempts over the course of several hours? No, it doesn’t. If the auto-restart process makes an excessive number of attempts or if the sleep time between attempts is too great, the solution can become self-defeating. If a server loses connectivity at noon on a Friday, excessively generous auto-restarts might mask the problem until the evening. Processes might be hours behind schedule before anyone is even aware of the problem. A compromise is needed.</p>
<p class="tx">Another consideration is the nature of the failure. You should make every effort to differentiate between legitimate failures and restartable failures. If a program aborts because of a data condition that won’t differ on a restart, an auto-restart will simply be a waste of time and CPU cycles. Sometimes you can divine the nature of the error from the return code. If so, you can use it to determine the next course of action. If not, that also factors into the calculus; maybe you should attempt fewer restarts.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h4 class="h1"><span id="sec5"/><span id="h2-79"/><span aria-label=" Page 309. " epub:type="pagebreak" id="pg_309" role="doc-pagebreak"/><span class="sans_futura_std_heavy_oblique_bi_">The Specifications</span></h4>
<p class="tni">For this exercise, I’ll invent a scenario requiring an auto-restart and write some specifications with all of the just-considered design considerations in mind.</p>
<p class="tx">A compiled executable communicating with a database on a remote server works great most of the time. It runs more than 30 times daily, but every three days or so it fails, returning an <span class="sans_thesansmonocd_w5regular_">errorlevel</span> of <span class="sans_thesansmonocd_w5regular_">7</span>. The first few times it happened, someone restarted it, but a couple failures a week became a nuisance. Then a Sunday morning failure that went unnoticed until later in the week became a huge embarrassment for everyone involved. Something had to be done.</p>
<p class="tx">The fictitious failure happens about once in every 100 attempts, which is fortuitous because I just did some math assuming that exact frequency. After we have gathered all of the statistics, some failures appear to be truly random, but the unexplained connectivity with the database seems to clear up in less than five seconds, so we won’t need long sleep times.</p>
<p class="tx">Fortunately, whoever wrote the executable did a good job with the return code. Other failures, such as the inability to find certain entries in the database, generate return codes other than <span class="sans_thesansmonocd_w5regular_">7</span>, and a successful invocation always returns <span class="sans_thesansmonocd_w5regular_">0</span>.</p>
<p class="tx">We now have what we need to write the specifications. The first one is obvious, but the other two require a little finesse, as you might come up with slightly different numbers:</p>
<div class="top">
<p class="listnumber">  1.  Initiate an auto-restart if <span class="sans_thesansmonocd_w5regular_">errorlevel</span> is <span class="sans_thesansmonocd_w5regular_">7</span>. Continue if <span class="sans_thesansmonocd_w5regular_">0</span>, and abort for all other returned values.</p>
<p class="listnumber">  2.  Attempt up to four auto-restarts for a total of five executions of the program, aborting after the fifth.</p>
<p class="listnumber">  3.  Pause for 2 seconds after the first attempt and double it for each subsequent attempt, meaning that the wait times will be 2, 4, 8, and 16 seconds.</p>
</div>
<p class="tx">After little more than 30 seconds (plus however long the executable runs), the fifth failure will initiate an abort. In an endeavor that is as much computer art as computer science, this should be a good compromise. Now, we’re ready to code.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h4 class="h1"><span id="sec6"/><span id="h2-80"/><span class="sans_futura_std_heavy_oblique_bi_">The Auto-Restart Code</span></h4>
<p class="tni"><a href="#Lis26-1" class="calibre3">Listing 26-1</a> meets the defined specifications. The only prerequisite to this code executing is that we must set the <span class="sans_thesansmonocd_w5regular_">flakyExe</span> variable to the program or process experiencing the intermittent failure.</p>
<span aria-label=" Page 310. " epub:type="pagebreak" id="pg_310" role="doc-pagebreak"/>
<span id="Lis26-1"/>
<pre class="pre"><code class="calibre11"><span aria-label="annotation1" class="codeannotationhang1">❶</span> prompt $T$G
 if not defined sleepIncrmt  set sleepIncrmt=2
 if not defined maxAttempts  set maxAttempts=5
 set attempt=0

<span aria-label="annotation2" class="codeannotationhang">❷</span> :Restart
 set /A attempt += 1

 %flakyExe%

<span aria-label="annotation3" class="codeannotationhang1">❸</span> if %errorlevel% equ 7 (
  <span aria-label="annotation4" class="code_codeannotation">❹</span> if %attempt% lss %maxAttempts% (
     <span aria-label="annotation5" class="code_codeannotation">❺</span> timeout %sleepIncrmt%
       set /A sleepIncrmt *= 2
       goto :Restart
    ) else (
    <span aria-label="annotation6" class="code_codeannotation">❻</span> goto :Abort
    )
) else if %errorlevel% neq 0 (
  <span aria-label="annotation7" class="code_codeannotation">❼</span> goto :Abort
) else (
  <span aria-label="annotation8" class="code_codeannotation">❽</span> &gt; con echo Successful Call of the Flaky Executable
)
</code></pre>
<p class="listingcaption"><span class="futura_std_book_oblique_i_">Listing 26-1: Code that initiates up to four auto-restarts of a flaky executable</span></p>
<p class="tx">In the first section of the code, the <span class="sans_thesansmonocd_w5regular_">prompt</span> command <span aria-label="annotation1" class="codeannotation">❶</span> (introduced in <span class="xref"><a href="chapter21.xhtml" class="calibre3">Chapter 21</a></span>) embeds the time into the prompt string that’s prepended to each executed line in stdout, making it easier to verify that the process is pausing for the requisite amount of time. I define the variable for the sleep increment as <span class="sans_thesansmonocd_w5regular_">2</span> seconds and the variable for the maximum attempts as <span class="sans_thesansmonocd_w5regular_">5</span> attempts. I also initialize the <span class="sans_thesansmonocd_w5regular_">attempt</span> variable, which tracks the attempt being executed, to <span class="sans_thesansmonocd_w5regular_">0</span>.</p>
<p class="tx">To add flexibility to the code, I use the technique of setting <span class="sans_thesansmonocd_w5regular_">sleepIncrmt</span> and <span class="sans_thesansmonocd_w5regular_">maxAttempts</span> only if they aren’t already defined. Much effort has been put into the specifications, but if the compromise between averting an abort and minimizing the time it takes to perform the auto-restarts isn’t quite right, a user can set these variables prior to calling this logic or set them globally on the computer. If one abort is still occurring each month, anyone can increase the sleep increment or the maximum attempts without changing this code, but I’ll assume the defaults for this exercise.</p>
<p class="tx">The logic proceeds past the <span class="sans_thesansmonocd_w5regular_">:Restart</span> label <span aria-label="annotation2" class="codeannotation">❷</span> and increments the <span class="sans_thesansmonocd_w5regular_">attempt</span> variable to <span class="sans_thesansmonocd_w5regular_">1</span>, before resolving <span class="sans_thesansmonocd_w5regular_">flakyExe</span> and thus executing the program. (In this exercise, the variable contains the flaky executable that’s failing, but this invocation could instead be an <span class="sans_thesansmonocd_w5regular_">xcopy</span> command to or from a remote server; it could be a call to a flaky bat file or whatever process might fail and need restarting.)</p>
<p class="tx">I next evaluate the <span class="sans_thesansmonocd_w5regular_">errorlevel</span> the executable returned. If the code encounters the bad return code of <span class="sans_thesansmonocd_w5regular_">7</span> <span aria-label="annotation3" class="codeannotation">❸</span>, I look to see whether I’ve made the requisite <span class="sans_thesansmonocd_w5regular_">5</span> attempts <span aria-label="annotation4" class="codeannotation">❹</span>. Since this is the first attempt, the execution enters the code block <span aria-label="annotation5" class="codeannotation">❺</span> and executes the <span class="sans_thesansmonocd_w5regular_">timeout</span> command to sleep for <span class="sans_thesansmonocd_w5regular_">2</span> seconds. <span aria-label=" Page 311. " epub:type="pagebreak" id="pg_311" role="doc-pagebreak"/>Then I double the increment, <span class="sans_thesansmonocd_w5regular_">sleepIncrmt</span>, so that the process will sleep for <span class="sans_thesansmonocd_w5regular_">4</span> seconds if invoked again. Next, I break out of this logic, backward, via the <span class="sans_thesansmonocd_w5regular_">goto</span> command.</p>
<p class="tx">This brings us back to the <span class="sans_thesansmonocd_w5regular_">:Restart</span> label <span aria-label="annotation2" class="codeannotation">❷</span> that the execution processed past just a moment ago. Here’s a great application of the <span class="sans_thesansmonocd_w5regular_">do...while</span> command from <span class="xref"><a href="chapter9.xhtml" class="calibre3">Chapter 9</a></span>. Notice the strategic placement of the label. I increment the total number of attempts to <span class="sans_thesansmonocd_w5regular_">2</span> after invoking the first restart and then execute the flaky process again.</p>
<p class="tx">If <span class="sans_thesansmonocd_w5regular_">7</span> is again the return code <span aria-label="annotation3" class="codeannotation">❸</span>, the same process executes another restart, this time upping <span class="sans_thesansmonocd_w5regular_">attempt</span> to <span class="sans_thesansmonocd_w5regular_">3</span>, which is still less than <span class="sans_thesansmonocd_w5regular_">5</span> <span aria-label="annotation4" class="codeannotation">❹</span>. Back in the code block <span aria-label="annotation5" class="codeannotation">❺</span> and after taking the four-second timeout, I double the sleep increment to <span class="sans_thesansmonocd_w5regular_">8</span> and return again to the <span class="sans_thesansmonocd_w5regular_">:Restart</span> label <span aria-label="annotation2" class="codeannotation">❷</span>.</p>
<p class="tx">If this fails four times, I’ll sleep for <span class="sans_thesansmonocd_w5regular_">16</span> seconds <span aria-label="annotation5" class="codeannotation">❺</span> and make one last attempt. If this also fails, <span class="sans_thesansmonocd_w5regular_">attempt</span> resolves to <span class="sans_thesansmonocd_w5regular_">5</span> and is no longer less than the target value in <span class="sans_thesansmonocd_w5regular_">maxAttempts</span> <span aria-label="annotation4" class="codeannotation">❹</span>, so the code will abort via the <span class="sans_thesansmonocd_w5regular_">:Abort</span> routine <span aria-label="annotation6" class="codeannotation">❻</span> that isn’t shown.</p>
<p class="tx">We need to think like the interpreter for two more scenarios. You already know what happens when <span class="sans_thesansmonocd_w5regular_">errorlevel</span> is <span class="sans_thesansmonocd_w5regular_">7</span>. Now imagine that the flaky process returns anything but <span class="sans_thesansmonocd_w5regular_">0</span> or <span class="sans_thesansmonocd_w5regular_">7</span>. The <span class="sans_thesansmonocd_w5regular_">else if</span> clause, <span class="sans_thesansmonocd_w5regular_">%errorlevel% neq 0</span>, is true, and the code invokes the <span class="sans_thesansmonocd_w5regular_">:Abort</span> routine <span aria-label="annotation7" class="codeannotation">❼</span>.</p>
<p class="tx">As the final scenario, imagine that <span class="sans_thesansmonocd_w5regular_">0</span> is the return code. This is the only possible way to get to the code block <span aria-label="annotation8" class="codeannotation">❽</span> after the default <span class="sans_thesansmonocd_w5regular_">else</span> clause that verifies that the execution was successful.</p>
<p class="tx">The abort routine should distinguish between the two types of aborts. One failed after multiple auto-restarts <span aria-label="annotation6" class="codeannotation">❻</span>, and the other failed due to something unrelated to the restarts <span aria-label="annotation7" class="codeannotation">❼</span> after just a single failure.</p>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h4 class="h1"><span id="sec7"/><span id="h2-81"/><span class="sans_futura_std_heavy_oblique_bi_">The Testing</span></h4>
<p class="tni">This is clearly some advanced Batch coding, but after you’ve grasped the concept and coded up something such as what’s in <a href="#Lis26-1" class="calibre3">Listing 26-1</a>, what might seem like an even more difficult task awaits: testing. If you run this code 100 times, you’re likely to see at least one failure, but there’s still a better than one chance in three of seeing no failures at all. Billions of executions wouldn’t even guarantee seeing five failures. (Look up the Poisson distribution if you’re curious about the math.)</p>
<p class="tx">We need a means of simulating the failure, and entering this command prior to <a href="#Lis26-1" class="calibre3">Listing 26-1</a> will do exactly that:</p>
<pre class="pre"><code class="calibre11">set flakyExe=cmd /C exit 7</code></pre>
<p class="tx">When the interpreter resolves <span class="sans_thesansmonocd_w5regular_">flakyExe</span> in the code, the <span class="sans_thesansmonocd_w5regular_">cmd</span> command (introduced in <span class="xref"><a href="chapter21.xhtml" class="calibre3">Chapter 21</a></span>) executes, running the <span class="sans_thesansmonocd_w5regular_">exit</span> command that sets <span class="sans_thesansmonocd_w5regular_">errorlevel</span> to <span class="sans_thesansmonocd_w5regular_">7</span>. If the main logic was coded correctly, this’ll trigger an auto-restart, and then it’ll repeat the same process a total of five times before aborting.</p>
<p class="tx">After you are satisfied with that testing, change <span class="sans_thesansmonocd_w5regular_">exit 7</span> to <span class="sans_thesansmonocd_w5regular_">exit 4</span> and run it again; expect to see a different abort, one that doesn’t invoke a restart. <span aria-label=" Page 312. " epub:type="pagebreak" id="pg_312" role="doc-pagebreak"/>Change it again to <span class="sans_thesansmonocd_w5regular_">exit 0</span>, and you should see a successful run (or at least a simulated successful run).</p>
<p class="tx">An ideal test might invoke two auto-restarts after two failures return <span class="sans_thesansmonocd_w5regular_">7</span> and then succeed with a return code of <span class="sans_thesansmonocd_w5regular_">0</span> on the third call. You could replace the <span class="sans_thesansmonocd_w5regular_">cmd</span> command in this setting with a <span class="sans_thesansmonocd_w5regular_">call</span> command of a simple bat file containing some conditional logic to set the return code based on the attempt being executed. Better yet, just use this setting:</p>
<pre class="pre"><code class="calibre11">set flakyExe=if ^^!attempt^^! lss 3 (cmd /C exit 7) else (cmd /C exit 0)</code></pre>
<p class="tx">As you learned in <span class="xref"><a href="chapter14.xhtml" class="calibre3">Chapter 14</a></span>, I escape the exclamation marks so they’ll be stored in the variable. Then when the code resolves <span class="sans_thesansmonocd_w5regular_">flakyExe</span>, the value contained in the <span class="sans_thesansmonocd_w5regular_">attempt</span> variable will be part of the conditional clause. It’ll be true the first two times it executes, resulting in a return code of <span class="sans_thesansmonocd_w5regular_">7</span>; then on the third execution, the conditional clause will be false. Hence, the return code will be <span class="sans_thesansmonocd_w5regular_">0</span>. I recommended against messy <span class="sans_thesansmonocd_w5regular_">if</span> commands like this in <span class="xref"><a href="chapter4.xhtml" class="calibre3">Chapter 4</a></span>, but it’s perfect for this type of testing.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="h1"><span id="sec8"/><span id="h2-82"/><span class="sans_futura_std_heavy_oblique_bi_">The Central Log</span></h4>
<p class="tni">The previous example is stripped down and perfectly functional, but when actually implemented, another key feature is a central log of each auto-restart. When this process completes, we can interrogate <span class="sans_thesansmonocd_w5regular_">attempt</span>; anything greater than <span class="sans_thesansmonocd_w5regular_">1</span> means that the code executed at least one auto-restart. With this information we can write a timestamped entry to a logfile with details about the auto-restart, especially the number of attempts.</p>
<p class="tx">You might become a victim of your own success if the auto-restart completely masks the failures. There’s still an underlying and unresolved issue, so it’s important to keep a record of the aborts avoided. After a month, you can use the log to definitively state that some number of processes would have aborted without the auto-restart. It might be just two or three or a dozen or maybe hundreds.</p>
<p class="tx">Whatever the number, you can use this log as a testament to the successful implementation of the auto-restart process. It’ll also monitor the underlying root problem. The frequency of the issue might decrease or vanish after the installation of new hardware, or it might happen more as existing hardware ages. This information can help determine the urgency of a solution targeting the root cause. (It may also be hard numbers for your annual review.)</p>
</section>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h3 class="h"><span id="sec9"/><span id="h1-178"/><span class="sans_futura_std_bold_b_">Hangs</span></h3>
<p class="tni">I’ve discussed automatically restarting a failed process that returns a certain value or set of values for <span class="sans_thesansmonocd_w5regular_">errorlevel</span>. An even bigger challenger is a hang; a <i class="calibre6">hang</i> occurs when a called process fails to terminate and never returns a value for <span class="sans_thesansmonocd_w5regular_">errorlevel</span>—even worse, hangs never return control to the Batch code.</p>
<p class="tx">A hang can be the result of an endless loop that would happen again on a restart, but sometimes a faulty process will hang when a connection <span aria-label=" Page 313. " epub:type="pagebreak" id="pg_313" role="doc-pagebreak"/>drops or it can’t find a resource. In short, if you can go into Task Manager, kill the hung process, restart it, and have it process successfully with no other intervention, then the process is a great candidate for an automatic kill and restart.</p>
<p class="tx">But any auto-kill-and-restart process has one major obstacle. An auto-restart is fairly straightforward in concept. When you get back certain bad return codes, you simply invoke the restart logic. But with a hang, the Batch code is, well, hanging. The process has taken its ball home and promised never to share it again. By definition, a hang will not return control to the Batch code, so the bat file that called it can’t do anything, much less kill and restart the process. But there’s always a way: something or someone must kill the hung process. Hence, the coder must anticipate and code for the possibility of a hang.</p>
<p class="tx">To accomplish this, we’ll need some important commands that aren’t in an everyday bat file. The <span class="sans_thesansmonocd_w5regular_">start</span> command (detailed in <span class="xref"><a href="chapter10.xhtml" class="calibre3">Chapter 10</a></span>) will spawn a second command window that’ll actually run the process that might hang. The <span class="sans_thesansmonocd_w5regular_">tasklist</span> command will monitor the spawned bat file that may possibly hang, and the <span class="sans_thesansmonocd_w5regular_">taskkill</span> command will ... I think this one is self-explanatory.</p>
<p class="tx">Just listing these commands sketches out the broad underpinnings of the plan, but before getting into details, I must properly introduce these two new commands.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h3 class="h"><span id="sec10"/><span id="h1-179"/><span class="sans_futura_std_bold_b_">Retrieving a List of Processes</span></h3>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">tasklist</span> command provides much of the information that you can find on a Windows machine “manually” with Task Manager. It retrieves a list of all or some of the current processes running on a machine. We’ll be using it in a bat file, but first bring up a command prompt and type <span class="sans_thesansmonocd_w7bold_b_">tasklist</span> and you’ll get a list of everything running on the machine, including the memory usage, session information, and process indicator (PID). Scores of processes will be running at any given time, but here’s an example of just a few rows:</p>
<pre class="pre"><code class="calibre11">Image Name                     PID Session Name        Session#    Mem Usage
========================= ======== ================ =========== ============
System Idle Process              0 Services                   0          8 K
System                           4 Services                   0      3,168 K
Registry                       120 Services                   0     51,168 K
cmd.exe                       8692 Services                   0        432 K
</code></pre>
<p class="tx">The PID is a number that the operating system assigns to a process when its execution starts. The <span class="sans_thesansmonocd_w5regular_">System Idle Process</span> is always running, and its PID is always <span class="sans_thesansmonocd_w5regular_">0</span>; <span class="sans_thesansmonocd_w5regular_">System</span> usually runs with a PID of <span class="sans_thesansmonocd_w5regular_">4</span> or <span class="sans_thesansmonocd_w5regular_">8</span>, depending on the operating system, and all other processes are assigned a unique number divisible by 4. At some point PIDs are reused, but not until thousands of different processes have run on the machine. The <span class="sans_thesansmonocd_w5regular_">tasklist</span> command displays each executing bat file with an image name of <i class="calibre6">cmd.exe</i> as seen in the fourth and final entry.</p>
<p class="tx"><span aria-label=" Page 314. " epub:type="pagebreak" id="pg_314" role="doc-pagebreak"/>The command has some very useful parameters. When parsing through the output of the command (which we’ll be doing shortly), we’ll want to avoid the first two header lines of the output. The <span class="sans_thesansmonocd_w5regular_">/NH</span> option (for <i class="calibre6">no headers</i>) removes the first line of header information as well as the cosmetic second line of equal signs.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">/FO</span> option (for <i class="calibre6">format</i>) alters the presentation of the data. The available formats are comma-delimited (<span class="sans_thesansmonocd_w5regular_">/FO:CSV</span>), list (<span class="sans_thesansmonocd_w5regular_">/FO:LIST</span>), and table (<span class="sans_thesansmonocd_w5regular_">/FO:TABLE</span>), which is also the default shown in the sample output.</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">/FI</span> option will <i class="calibre6">filter</i> out unwanted entries or include only wanted entries. You can include or exclude certain window titles or build filters involving the CPU time, PID, image name, and more. For example, the following command brings up all instances of Notepad++ running on a machine:</p>
<pre class="pre"><code class="calibre11">tasklist /FI:"ImageName eq notepad++.exe"</code></pre>
<p class="tni">(Please don’t ask why this option uses the equality operator <span class="sans_thesansmonocd_w5regular_">eq</span> instead of <span class="sans_thesansmonocd_w5regular_">equ</span>, but it does.)</p>
<p class="tx">Using the wildcard (<span class="sans_thesansmonocd_w5regular_">*</span>) brings up all instances of Notepad, Notepad++, and anything else that might start with those seven letters:</p>
<pre class="pre"><code class="calibre11">tasklist /FI:"ImageName eq notepad*"</code></pre>
<p class="tx">The following command uses the greater-than operator to display all processes currently being memory hogs:</p>
<pre class="pre"><code class="calibre11">tasklist /FI:"MemUsage gt 250000"</code></pre>
<p class="tx">Use the help for more details on the <span class="sans_thesansmonocd_w5regular_">/FI</span> option; what I’ve shown here is just a sampling of the operands and operators.</p>
</section>
<section aria-labelledby="sec11" epub:type="division">
<h3 class="h"><span id="sec11"/><span id="h1-180"/><span class="sans_futura_std_bold_b_">Killing Processes</span></h3>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">taskkill</span> command can terminate a specific process or several at one time. Some of its parameters are shared with the <span class="sans_thesansmonocd_w5regular_">tasklist</span> command, most important, the <span class="sans_thesansmonocd_w5regular_">/FI</span> option. The following command attempts to kill all instances of Notepad running on a machine:</p>
<pre class="pre"><code class="calibre11">taskkill /FI:"imagename eq notepad.exe"</code></pre>
<p class="tx">This command tries to close all opened Notepad files, immediately doing so for all that are saved. Notepad generates a pop-up window for all unsaved work, kindly asking the user to save the file, but the <span class="sans_thesansmonocd_w5regular_">/F</span> option <i class="calibre6">forcefully</i> kills the processes. Using the option will unapologetically terminate the processes unsaved. The <span class="sans_thesansmonocd_w5regular_">/T</span> option kills not only a process but also any processes that it may have started. Before long, we’ll kill the spawned bat file with both of these options to ensure that it, and everything associated with it, is truly terminated.</p>
<p class="tx"><span aria-label=" Page 315. " epub:type="pagebreak" id="pg_315" role="doc-pagebreak"/>Used with the <span class="sans_thesansmonocd_w5regular_">/PID</span> option, the <span class="sans_thesansmonocd_w5regular_">taskkill</span> command terminates one or more specific processes based on the process indicator. For instance, this’ll terminate two processes:</p>
<pre class="pre"><code class="calibre11">taskkill /PID 12348 /PID 6784</code></pre>
<p class="tx">You can also forcefully kill processes with very specific window titles. (Foreshadowing isn’t just for fiction.)</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h3 class="h"><span id="sec12"/><span id="h1-181"/><span class="sans_futura_std_bold_b_">The Automatic Kill and Restart</span></h3>
<p class="tni">Just as we did with the automatic restart, let’s step through the building of an automatic kill and restart of a process prone to occasional hangs, including design, specifications, coding, and testing.</p>
<p class="tx">In this fictitious scenario, the flaky executable will continue to work perfectly well 99.9 percent of the time, but one time in 1,000 it hangs. We know that the root cause isn’t a simple endless loop, because we can manually kill and restart it and see it run successfully. The team theorizes about how interacting with the database could cause the problem, or maybe it has nothing to do with the database. It happens so infrequently, it’s nearly impossible to troubleshoot, but it happens frequently enough to be a problem, and no one can find the root cause.</p>
<p class="tx">After cycling through the five stages, we’ve decided to fix the issue with an auto-kill-and-restart. We’ll put the call to the offending process into a dynamically created bat file and spawn it in lieu of calling the process directly. The spawned process will execute completely independently of the main bat file, which will then monitor the spawned bat file, killing and restarting it if we determine that it’s hung.</p>
<section aria-labelledby="sec13" epub:type="division">
<h4 class="h1"><span id="sec13"/><span id="h2-83"/><span class="sans_futura_std_heavy_oblique_bi_">The Design Considerations</span></h4>
<p class="tni">By far the trickiest part of the design is determining exactly how long to wait for the executable to finish up before assuming a hang. How long does it typically take? What’s the maximum time that it can take when there isn’t a hang? Is the execution time consistent, or does it fluctuate? If it fluctuates, can we predict it by the size of an input file, or is it more random? If a process typically takes 3 or 4 minutes to execute, it’s reasonable to set the maximum execution time to 10 minutes. But this will kill and restart a particularly slow-running execution that needs 10 minutes and a second to complete just as it’s about to finish up.</p>
<p class="tx">We must complete a great deal of analysis before settling on a length of time. I usually set this to be three times the length of time of a typical run if the execution times are fairly consistent. If the execution time is dictated by an input file size, you can wait longer for larger files. If the execution times seem to be random, add even more time, but don’t make the maximum time so long that it’s self-defeating.</p>
<p class="tx"><span aria-label=" Page 316. " epub:type="pagebreak" id="pg_316" role="doc-pagebreak"/>The number of attempted restarts before aborting is another factor you must determine. The same considerations that applied with the auto-restart process also apply here. In short, how frequent and random are the hangs?</p>
<p class="tx">An additional design consideration of a proposed auto-kill-and-restart is how often to check the status of the spawned bat file. If a process usually takes 3 or 4 minutes and the maximum execution time is set at 10 minutes, it doesn’t make sense to wait the full 10 minutes before checking on it. We can check on it every 15 seconds; if it’s done, we can move on without waiting any longer; if it isn’t done, we can wait another 15 seconds for up to a total of 10 minutes. It’s important to note that the interval selected is the maximum amount of time that we might add to any one execution.</p>
</section>
<section aria-labelledby="sec14" epub:type="division">
<h4 class="h1"><span id="sec14"/><span id="h2-84"/><span class="sans_futura_std_heavy_oblique_bi_">The Specifications</span></h4>
<p class="tni">Continuing with this imagined scenario, the executable typically runs in 10 or 20 seconds. After much testing, even concurrent testing, 35 seconds is the maximum runtime we’ve observed. A reasonable maximum wait time seems to be 60 seconds; it’s three times longer than a typical long execution and comfortably exceeds the longest observed execution time.</p>
<p class="tx">Checking the spawned bat file every 10 seconds seems to make sense. A quick run will finish up just before the first check, most others will be done by the second check, and all but a few will be completed by the third, which will add no more than 10 seconds to any execution compared to a direct call of the flaky executable.</p>
<p class="tx">A total of four attempts before aborting should also work. Since it fails once in 1,000 attempts, four completely random failures would happen once in a trillion attempts. This might sound like overkill, but we’ve observed multiple hangs at roughly the same time, meaning that these failures aren’t truly random. They might be happening during a period of lost connectivity.</p>
<p class="tx">At worst, four failed attempts will take a little over four minutes before we initiate an abort. This process aims to mitigate the threat of a hang in as short of a timeframe as possible. As with the auto-restart, there is an art to these specifications. Reasonable co-workers might want longer or shorter wait times, or more or fewer restarts.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h4 class="h1"><span id="sec15"/><span id="h2-85"/><span class="sans_futura_std_heavy_oblique_bi_">The Core Auto-Kill-and-Restart Logic</span></h4>
<p class="tni">Before sharing the code, I’ll discuss the process that’s at the heart of this entire enterprise—the spawning, tracking, and possible killing of a second bat file.</p>
<p class="tx">At a very high level, I’ll launch the spawned bat file via the <span class="sans_thesansmonocd_w5regular_">start</span> command, not the <span class="sans_thesansmonocd_w5regular_">call</span> command, so that the two bat files will execute independently. The spawned bat file will change its title to some unique text also known to the main process. This’ll allow the main process to track or monitor the spawned bat file with the <span class="sans_thesansmonocd_w5regular_">tasklist</span> command, and if it’s taking an excessive amount of time to finish up, we’ll kill it with the <span class="sans_thesansmonocd_w5regular_">taskkill</span> <span aria-label=" Page 317. " epub:type="pagebreak" id="pg_317" role="doc-pagebreak"/>command. Then we’ll spawn the dynamically created bat file again, monitor it again ... and possibly kill it again.</p>
<p class="tx">In <span class="xref"><a href="chapter15.xhtml" class="calibre3">Chapter 15</a></span>, I introduced the <span class="sans_thesansmonocd_w5regular_">title</span> command to change the title displayed in the top-left corner of the command window when we ran an interactive bat file. It never hurts to title the command window so that we humans can differentiate one window from another, but the uses of the <span class="sans_thesansmonocd_w5regular_">title</span> command go beyond cosmetic. I’ll use it here to attach a tracking device.</p>
<p class="tx">Just as marine biologists might attach an electronic tracking device to the shell of a sea turtle, we’ll attach a tracking device to the spawned bat file. The biologist uses satellite telemetry to track the sea turtle’s movements for many years throughout the world’s oceans and beaches, following them as they mate, forage, and lay eggs. Our goal is less ambitious; we’re simply tracking the life of an executing bat file on one machine.</p>
<p class="tx">If the <span class="sans_thesansmonocd_w5regular_">title</span> command attaches the tracking device, then the <span class="sans_thesansmonocd_w5regular_">tasklist</span> command is analogous to the satellite tracking the sea turtle. In the main bat file, the <span class="sans_thesansmonocd_w5regular_">tasklist</span> command will use the same unique title used by the <span class="sans_thesansmonocd_w5regular_">title</span> command in the spawned bat file. The following command will track the spawned bat file with the unique title contained in the <span class="sans_thesansmonocd_w5regular_">uniqTitle</span> variable:</p>
<pre class="pre"><code class="calibre11">tasklist /FI:"WindowTitle eq %uniqTitle%" /NH</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">/FI</span> option allows us to filter on many different characteristics of the various processes running on a machine. For example, the <span class="sans_thesansmonocd_w5regular_">ImageName</span> of the spawned bat file will be <i class="calibre6">cmd.exe</i>, but this is true of all bat files, including the main bat file doing the tracking, so that’s of no use here. But filtering on the <span class="sans_thesansmonocd_w5regular_">WindowTitle</span> will return the one and only process with that title. (For this reason, it’s critical that the unique title truly be unique in this design.)</p>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">/NH</span> option gets rid of those pesky headers, so if the spawned bat file is running when the previous command executes, it will return something such as this to stdout:</p>
<pre class="pre"><code class="calibre11">cmd.exe                      9736 Console                     1      4,996 K</code></pre>
<p class="tx">This shows the image name, PID, session name, session number, and memory usage. We aren’t interested in most of this information, but we do care about how this entry contrasts to what this command returns if the process isn’t running:</p>
<pre class="pre"><code class="calibre11">INFO: No tasks are running which match the specified criteria.</code></pre>
<p class="tx">The obvious differences will tell us whether the spawned bat file is still running. A <span class="sans_thesansmonocd_w5regular_">for /F</span> command can pull out the first token for interrogation; if it’s <i class="calibre6">cmd.exe</i>, the bat file with the unique title is running, and if it’s <span class="sans_thesansmonocd_w5regular_">INFO:</span>, nothing with the title is running.</p>
<p class="tx">After taking great care to positively identify the hung process, the following <span class="sans_thesansmonocd_w5regular_">taskkill</span> command will kill or terminate it with surgical precision. <span aria-label=" Page 318. " epub:type="pagebreak" id="pg_318" role="doc-pagebreak"/>Using the same <span class="sans_thesansmonocd_w5regular_">/FI</span> option looking for the same <span class="sans_thesansmonocd_w5regular_">WindowTitle</span> from the <span class="sans_thesansmonocd_w5regular_">tasklist</span> command ensures that we don’t overreach and kill anything else:</p>
<pre class="pre"><code class="calibre11">taskkill /F /T /FI:"WindowTitle eq %uniqTitle%"</code></pre>
<p class="tni">The <span class="sans_thesansmonocd_w5regular_">/F</span> and <span class="sans_thesansmonocd_w5regular_">/T</span> options will forcefully kill the spawned bat file and any child processes that it might have initiated.</p>
<p class="tx">By the way, this is where I end my sea turtle analogy. We don’t want to harm sea turtles in any way. They’re some of the most beautiful and fascinating animals in existence, other than bats, of course.</p>
<p class="tx">Now let’s put this all together.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h4 class="h1"><span id="sec16"/><span id="h2-86"/><span class="sans_futura_std_heavy_oblique_bi_">The Auto-Kill-and-Restart Code</span></h4>
<p class="tni"><a href="#Lis26-2" class="calibre3">Listing 26-2</a> is clearly one of the most complex in the book, but even so I’ve stripped it down of most error handling and used hardcoded values that really should be parameterized. I’ll address these concerns a bit later, but <a href="#Lis26-2" class="calibre3">Listing 26-2</a> meets all of the specifications assuming that <span class="sans_thesansmonocd_w5regular_">flakyExe</span> is assigned the executable that occasionally hangs.</p>
<span id="Lis26-2"/>
<pre class="pre"><code class="calibre11"> set spawnedBat=C:\Batch\Spawned.bat
 set uniqTitle=Spawned Bat - %date% %time%
<span aria-label="annotation1" class="codeannotationhang1">❶</span> &gt;  %spawnedBat%  echo   setlocal EnableExtensions EnableDelayedExpansion
 &gt;&gt; %spawnedBat%  echo   title %uniqTitle%
 &gt;&gt; %spawnedBat%  echo   %flakyExe%
 &gt;&gt; %spawnedBat%  echo   goto :eof

 set totHangs=0
<span aria-label="annotation2" class="codeannotationhang">❷</span> :Restart
 set totSleep=0
<span aria-label="annotation3" class="codeannotationhang1">❸</span> start /MIN %spawnedBat%
 timeout 1
<span aria-label="annotation4" class="codeannotationhang1">❹</span> for /F usebackq %%i in (`tasklist /FI:"WindowTitle eq %uniqTitle%" /NH`) do (
    if /i "%%i" equ "INFO:" (
      call :Abort "%uniqTitle% Not Spawned"
 )  )
  
<span aria-label="annotation5" class="codeannotationhang">❺</span> :WaitMore
 timeout 10
 set /A totSleep += 10
<span aria-label="annotation6" class="codeannotationhang1">❻</span> for /F usebackq %%i in (`tasklist /FI:"WindowTitle eq %uniqTitle%" /NH`) do (
    if /i "%%i" equ "cmd.exe" (
     <span aria-label="annotation7" class="code_codeannotation">❼</span> if %totSleep% lss 60 (
          goto :WaitMore
       ) else (
        <span aria-label="annotation8" class="code_codeannotation">❽</span> taskkill /F /T /FI:"WindowTitle eq %uniqTitle%"
          set /A totHangs += 1
        <span aria-label="annotation9" class="code_codeannotation">❾</span> if !totHangs! lss 4 (
             goto :Restart
          ) else (
             call :Abort "%uniqTitle% - 4 Hangs"
)  )  )  )
<span aria-label="annotation10" class="codeannotationhang">❿</span> &gt; con echo The Spawned Bat Has Completed.
 pause
 goto :eof

:Abort
 &gt; con echo Aborting: %~1
 &gt; con pause
 exit
</code></pre>
<span aria-label=" Page 319. " epub:type="pagebreak" id="pg_319" role="doc-pagebreak"/>
<p class="listingcaption"><span class="futura_std_book_oblique_i_">Listing 26-2: Code that initiates up to three auto-kill-and-restarts of a flaky executable</span></p>
<p class="tx">There are three main sections to this code centered around the spawned bat file: creating it, starting or executing it, and monitoring it. I’ll take a closer look at each section.</p>
<div class="top">
<p class="listnumber">  1.  Create <i class="calibre6">Spawned.bat</i>: Using the bat-building-bat technique from <span class="listnumber_xref"><a href="chapter25.xhtml" class="calibre3">Chapter 25</a></span>, I’m creating <i class="calibre6">Spawned.bat</i> with four <span class="sans_thesansmonocd_w5regular_">echo</span> commands <span aria-label="annotation1" class="codeannotation">❶</span>. It’s a simple bat file that does little more than define a unique title, <span class="sans_thesansmonocd_w5regular_">uniqTitle</span>, and invoke the flaky executable. There isn’t even any error handling.</p>
<p class="listbody">The complete contents of <i class="calibre6">Spawned.bat</i> might look like the following, depending on the contents of <span class="sans_thesansmonocd_w5regular_">date</span>, <span class="sans_thesansmonocd_w5regular_">time</span>, and <span class="sans_thesansmonocd_w5regular_">flakyExe</span>:</p>
<pre class="list"><code class="calibre11"><span class="sans_thesansmonocd_w5regular_">setlocal EnableExtensions EnableDelayedExpansion</span>
title Spawned Bat - Mon 11/01/2004 10:30:59.33
C:\Batch\Flaky.exe
goto :eof
</code></pre>
<p class="listbody">We assign the unique title its value before creating the spawned bat file so that both bat files know what it is. By using the date and time in the <span class="sans_thesansmonocd_w5regular_">uniqTitle</span> variable, I’m assuming that two processes won’t be invoked within one hundredth of a second, but ideally, there should be some unique variable in each execution of the bat file that you can add to the title. (For the purposes of this example, I’m assuming that this title is truly unique.)</p>
<p class="listnumber">  2.  Start <i class="calibre6">Spawned.bat</i>: The <span class="sans_thesansmonocd_w5regular_">:Restart</span> label <span aria-label="annotation2" class="codeannotation">❷</span> has no impact on the code as of now, but we’ll eventually use it to restart the process after terminating the hang. I initialize the total number of hangs, <span class="sans_thesansmonocd_w5regular_">totHangs</span>, to <span class="sans_thesansmonocd_w5regular_">0</span> prior to the label, ensuring that a restart won’t reset it. I’m also setting the total sleep time measured in seconds, <span class="sans_thesansmonocd_w5regular_">totSleep</span>, to <span class="sans_thesansmonocd_w5regular_">0</span>, but after the label. If and when this builds up to <span class="sans_thesansmonocd_w5regular_">60</span> seconds of wait time, I’ll initiate a restart and re-execute this command, thus reinitializing <span class="sans_thesansmonocd_w5regular_">totSleep</span> to <span class="sans_thesansmonocd_w5regular_">0</span>.</p>
<p class="listbody">The <span class="sans_thesansmonocd_w5regular_">start</span> command <span aria-label="annotation3" class="codeannotation">❸</span> starts, spawns, or launches the dynamically created bat file independently of the main process. So as not to inundate the desktop with extra windows, the <span class="sans_thesansmonocd_w5regular_">/MIN</span> option immediately minimizes the spawned window.</p>
<p class="listbody"><span aria-label=" Page 320. " epub:type="pagebreak" id="pg_320" role="doc-pagebreak"/>To verify that the spawned bat file is off and running, I’ll pause for just a second to give it time to execute its <span class="sans_thesansmonocd_w5regular_">title</span> command, allowing this code to find it. This assumes that the spawned process will run for at least a second. (If there’s even the remotest possibility that this isn’t true, I can always add the <span class="sans_thesansmonocd_w5regular_">timeout 1</span> command to the end of spawned bat file, ensuring that it runs for at least a second.)</p>
<p class="listbody">The input to the <span class="sans_thesansmonocd_w5regular_">for</span> command <span aria-label="annotation4" class="codeannotation">❹</span> is the same <span class="sans_thesansmonocd_w5regular_">tasklist</span> command detailed earlier, by default passing just the first token into the code block. If that token is equal to <span class="sans_thesansmonocd_w5regular_">INFO:</span>, something is wrong—the spawned bat file hasn’t started, and it’s far too soon for it to be done—and we go to the abort routine passing it an appropriate error message; otherwise, we continue.</p>
<p class="listnumber">  3.  Monitor <i class="calibre6">Spawned.bat</i>: Finally, we get to the core logic. Another <span class="sans_thesansmonocd_w5regular_">timeout</span> command <span aria-label="annotation5" class="codeannotation">❺</span> sleeps for <span class="sans_thesansmonocd_w5regular_">10</span> seconds as defined in our specifications, and we add those <span class="sans_thesansmonocd_w5regular_">10</span> seconds to <span class="sans_thesansmonocd_w5regular_">totSleep</span>, which represents the total time spent waiting for the spawned bat file to finish. Next, another <span class="sans_thesansmonocd_w5regular_">for</span> command <span aria-label="annotation6" class="codeannotation">❻</span> similar to the prior one executes, but the code block is now looking for the first token to be equal to <i class="calibre6">cmd.exe</i>, an indication that the process is still running. If so and if evaluating the next <span class="sans_thesansmonocd_w5regular_">if</span> command <span aria-label="annotation7" class="codeannotation">❼</span> shows that we haven’t slept for <span class="sans_thesansmonocd_w5regular_">60</span> seconds, the <span class="sans_thesansmonocd_w5regular_">goto</span> command circles back to the <span class="sans_thesansmonocd_w5regular_">:WaitMore</span> label <span aria-label="annotation5" class="codeannotation">❺</span>.</p>
<p class="listbody">After the total wait time has reached or exceeded <span class="sans_thesansmonocd_w5regular_">60</span> seconds <span aria-label="annotation7" class="codeannotation">❼</span>, the <span class="sans_thesansmonocd_w5regular_">taskkill</span> command <span aria-label="annotation8" class="codeannotation">❽</span> terminates the spawned bat file. We increment and interrogate the total number of hangs, <span class="sans_thesansmonocd_w5regular_">totHangs</span>. After four attempts <span aria-label="annotation9" class="codeannotation">❾</span>, there must be a larger issue at play, so we initiate an abort. But otherwise, we go back to the <span class="sans_thesansmonocd_w5regular_">:Restart</span> label <span aria-label="annotation2" class="codeannotation">❷</span> and restart the entire process again.</p>
<p class="listbody">Notice that the code contains two overlapping <span class="sans_thesansmonocd_w5regular_">do...while</span> commands, a twist on the technique introduced in <span class="xref"><a href="chapter9.xhtml" class="calibre3">Chapter 9</a></span>. The more modest one goes back to wait another 10 seconds until a minute has passed (<span class="sans_thesansmonocd_w5regular_">:WaitMore</span> <span aria-label="annotation5" class="codeannotation">❺</span><span aria-label="annotation7" class="codeannotation">❼</span>). The other restarts the entire process after it encounters a hang (<span class="sans_thesansmonocd_w5regular_">:Restart</span> <span aria-label="annotation2" class="codeannotation">❷</span><span aria-label="annotation9" class="codeannotation">❾</span>).</p>
<p class="listbody">If all goes well, the <span class="sans_thesansmonocd_w5regular_">tasklist</span> command embedded in the <span class="sans_thesansmonocd_w5regular_">for</span> command <span aria-label="annotation6" class="codeannotation">❻</span> eventually won’t find the instance of <i class="calibre6">cmd.exe</i> running with the specific title. This indicates that the spawned bat file has finished up, and we fall through to the <span class="sans_thesansmonocd_w5regular_">echo</span> command noting its completion <span aria-label="annotation10" class="codeannotation">❿</span>.</p>
</div>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h4 class="h1"><span id="sec17"/><span id="h2-87"/><span class="sans_futura_std_heavy_oblique_bi_">The Testing</span></h4>
<p class="tni">If testing an intermittent failure that occurs 1 percent of the time is difficult, then testing an intermittent hang that occurs 0.1 percent of the time is nearly impossible without some intervention. To fix a hang, we first need to create a hang for testing. You could write a program that occasionally executes an endless loop (at one time or another every coder has done this without even trying). But since this is a book about Batch, let’s write a bat file that’ll go into an endless loop about 20 percent of the time. <i class="calibre6">OccasionalHang.bat</i> will do just this; here are its complete contents:</p>
<pre class="pre"><code class="calibre11"><span aria-label=" Page 321. " epub:type="pagebreak" id="pg_321" role="doc-pagebreak"/> timeout 15
 set /A rand = %random% %% 5
:EndlessLoop
 if %rand% equ 0  goto :EndlessLoop
 exit
</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">timeout</span> command simulates a program that runs for 15 seconds. Without this, the bat file would usually complete in a small fraction of a second. The <span class="sans_thesansmonocd_w5regular_">set /A</span> command captures a pseudo-random number between 0 and 4 in the <span class="sans_thesansmonocd_w5regular_">rand</span> variable by modulo dividing the <span class="sans_thesansmonocd_w5regular_">random</span> pseudo-environment variable (<span class="xref"><a href="chapter21.xhtml" class="calibre3">Chapter 21</a></span>) by <span class="sans_thesansmonocd_w5regular_">5</span>. If <span class="sans_thesansmonocd_w5regular_">rand</span> is greater than <span class="sans_thesansmonocd_w5regular_">0</span>, we exit the bat file successfully, but roughly one time in five the value will be <span class="sans_thesansmonocd_w5regular_">0</span>, and we’ll fall into an endless loop. If <span class="sans_thesansmonocd_w5regular_">rand</span> equals <span class="sans_thesansmonocd_w5regular_">0</span>, the <span class="sans_thesansmonocd_w5regular_">goto</span> command repeatedly loops back to the <span class="sans_thesansmonocd_w5regular_">:EndlessLoop</span> label on the prior line with no hope of liberation. To make this bat file hang more often, you can tweak the modulo division; for instance, <span class="sans_thesansmonocd_w5regular_">%% 2</span> will hang about half of the time.</p>
<p class="tx">To call this bat file instead of the flaky executable, simply enter the following command into the main bat file prior to the code in <a href="#Lis26-2" class="calibre3">Listing 26-2</a>:</p>
<pre class="pre"><code class="calibre11">set flakyExe=call C:\Batch\OccasionalHang.bat</code></pre>
<p class="tx">The <span class="sans_thesansmonocd_w5regular_">call</span> command is part of the variable’s value, so when <span class="sans_thesansmonocd_w5regular_">flakyExe</span> resolves, the interpreter calls <i class="calibre6">OccasionalHang.bat</i>.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h4 class="h1"><span id="sec18"/><span id="h2-88"/><span class="sans_futura_std_heavy_oblique_bi_">Real-World Tweaks</span></h4>
<p class="tni">Even though <a href="#Lis26-2" class="calibre3">Listing 26-2</a> is extremely involved, I’ve left out some error handling and used hardcoded values where I normally wouldn’t, all to keep the focus on the auto-kill-and-restart logic, but I have a number of suggested tweaks or enhancements for a real-world application.</p>
<p class="tx">Three hardcoded values in the code should have been variables. I hardcoded them purely for the sake of readability, but I should have set up the sleep interval, maximum number of hangs, and maximum sleep time with overridable defaults like this:</p>
<pre class="pre"><code class="calibre11">if not defined sleepIntrvl  set sleepIntrvl=10
if not defined maxHangs     set maxHangs=4
if not defined maxSleep     set maxSleep=60
</code></pre>
<p class="tx">Just as with the auto-restart, these variables should replace the hardcoded numbers in the code. If a user wants to change any of these values, they can do so with a <span class="sans_thesansmonocd_w5regular_">set</span> command prior to executing this logic.</p>
<p class="tx">I mentioned earlier that you might be able to predict the expected execution time of the process based on the size of an input file. The following code will set the maximum sleep time to a baseline of 30 seconds, adding <span aria-label=" Page 322. " epub:type="pagebreak" id="pg_322" role="doc-pagebreak"/>1 second for every 1,000 bytes of data in the input file, but only if someone hasn’t defined it already:</p>
<pre class="pre"><code class="calibre11">if not defined maxSleep (
   for %%s in (C:\Batch\InputFile.txt) do (
      set /A maxSleep = 30 + %%~Zs / 1000
)  )
</code></pre>
<p class="tni">You can fine-tune this algorithm with a little analysis comparing file sizes and typical runtimes.</p>
<p class="tx">Sometimes you can identify a hang by looking at the expected output file. If it doesn’t appear after so many seconds, you may already know the process is hung. You can capture the size of the file periodically, and if it doesn’t get any larger during some interval, that might also be an indication of a hang. A little analysis will greatly enhance the process, finding the balance between not killing a good yet long-running execution versus pausing the execution for as little time as is necessary.</p>
<p class="tx">Another possible tweak is to increase the maximum sleep time before the last attempt. Even after all the analysis done in the scenario we’ve tackled here, one execution might legitimately require more than a minute to execute. If you’ve killed the process three times after 60 seconds each, it might not be a bad idea to allow 2 minutes for the final attempt. Just multiply <span class="sans_thesansmonocd_w5regular_">maxSleep</span> by <span class="sans_thesansmonocd_w5regular_">2</span> if the values of <span class="sans_thesansmonocd_w5regular_">attempt</span> and <span class="sans_thesansmonocd_w5regular_">maxHangs</span> are equal. If future logging shows that a number of failures are succeeding on the final attempt, you can reevaluate the maximum sleep time.</p>
<p class="tx">If the hangs seem to happen when two runs kick off simultaneously, there’s a good chance of a contention issue, and if we kill and restart the two runs on the same schedule, it might just happen again because they’ll still be synced up. A way around that situation is to put in a wait of a few seconds just after the kill. Staggering the sleep times can be tricky because the <span class="sans_thesansmonocd_w5regular_">random</span> pseudo-environment variables will also be in sync in the two bat files if they were started at the same instant, but with a little effort, you can ideally find a unique number in each of these executions.</p>
<p class="tx">A glaring omission in <a href="#Lis26-2" class="calibre3">Listing 26-2</a> is the error handling inside the spawned bat file. The code in the main bat file can tell us when the spawned bat file has finished, but it has zero visibility into whether it executed successfully. It’s tantamount to running a program and not checking the return code. One solution is for the spawned bat file to write <span class="sans_thesansmonocd_w5regular_">errorlevel</span> and maybe even a status message to a small file. The main logic can then read the file and proceed based on its contents.</p>
<p class="tx">A good solid design will make the end product much more usable and stable. This is the type of process that really needs to be thought out in great detail with all the possibilities of what can happen in both threads as they run simultaneously. Speaking of threads ...</p>
</section>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h3 class="h"><span id="sec19"/><span id="h1-182"/><span aria-label=" Page 323. " epub:type="pagebreak" id="pg_323" role="doc-pagebreak"/><span class="sans_futura_std_bold_b_">Multithreading</span></h3>
<p class="tni">Before moving on to the next chapter, let’s take the components we’ve used to build the automatic kill and restart process and reimagine them as pieces for something completely different: <i class="calibre6">multithreading</i> or <i class="calibre6">concurrency</i>.</p>
<p class="tx">This is another feature of Batch not envisioned by its creators but realized by later coders. To fully implement the multithreading found in other languages, we’ll need to perform three tasks. First, we’ll need to spawn two or more processes called <i class="calibre6">threads</i>. Second, we’ll need to monitor those processes to determine when each completes. Third, we’ll need to allow those spawned processes to communicate with each other and the main process, even sharing data.</p>
<p class="tx">You can perform the first two tasks with what you’ve learned in this chapter. The <span class="sans_thesansmonocd_w5regular_">start</span> command will start or spawn any number of other bat files, which I’ll now refer to as threads. You can use the <span class="sans_thesansmonocd_w5regular_">title</span> and <span class="sans_thesansmonocd_w5regular_">tasklist</span> commands to track the uniquely named threads in the same way you tracked a spawned process prone to hanging. The only difference is that you’ll now spawn and monitor multiple processes instead of just one. If the number of processes might vary, you can keep track of them in an array. (I’ll get to arrays in <span class="xref"><a href="chapter29.xhtml" class="calibre3">Chapter 29</a></span>.) Languages with built-in multithreading tools often have a means of killing all threads if they’re still running after a certain amount of time, and you can do the same in Batch with the <span class="sans_thesansmonocd_w5regular_">timeout</span> the <span class="sans_thesansmonocd_w5regular_">taskkill</span> commands.</p>
<p class="tx">Admittedly, the one piece that is difficult to fully implement is the ability for the main process and the threads to talk to each other. It should come as no surprise that there is no such thing as a block of asynchronous Batch code accessible from multiple threads, but some communication is possible. Each thread can record its status and high-level information such as the number of records processed in a simple text file named after its title. Since the main process also knows the title for each thread, that main process can find and process this information as each thread completes or even as each thread executes.</p>
<p class="tx">Multithreading is a wonderful technique for breaking down time-consuming processes into more manageable chunks, and with a little work, you can make it happen in Batch.</p>
</section>
<section aria-labelledby="sec20" epub:type="division">
<h3 class="h"><span id="sec20"/><span id="h1-183"/><span class="sans_futura_std_bold_b_">Summary</span></h3>
<p class="tni">Coders can rate all intermittent failures and hangs on a scale of irritant to catastrophe. In this chapter, you’ve learned some advanced Batch coding techniques to mitigate these issues. I’ve detailed the auto-restart and the auto-kill-and-restart processes to deal with them. For both, I walked through design considerations, specifications, the coding, and even the testing. You also learned about some new and useful commands and new applications for others already discussed, and I even introduced multithreading.</p>
<p class="tx"><span aria-label=" Page 324. " epub:type="pagebreak" id="pg_324" role="doc-pagebreak"/>Above all else, I hope you have gained an appreciation for the nuance required to build these solutions. Even before getting into the many details of a particular solution, we had to perform much analysis just to determine if an automatic restart is appropriate. And remember, it’s a real fix, not a “fix.”</p>
<p class="tx">In the next chapter, I’ll delve into a topic that sounds like something that should have been a very short section in <span class="xref"><a href="chapter4.xhtml" class="calibre3">Chapter 4</a></span>, namely, using the <span class="sans_thesansmonocd_w5regular_">and</span> and <span class="sans_thesansmonocd_w5regular_">or</span> operators in the conditional clause of an <span class="sans_thesansmonocd_w5regular_">if</span> command. I won’t spoil here why this is <span class="xref"><a href="part3.xhtml" class="calibre3">Part III</a></span> material.</p>
</section>
</section>
</div></body></html>