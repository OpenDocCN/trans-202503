<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch00"><span epub:type="pagebreak" id="page_xxv"/><strong>INTRODUCTION</strong></h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">My first exposure to programming came in the summer of 1980. It involved an Apple II+ computer. As principal of the local high school, my father was able to bring it home for us to play with over the summer. It was the only personal computer in the school. I already knew about video games and had an Atari 2600 game console. But the idea of being able to make the machine do whatever I wanted it to was amazing and seductive.</p>&#13;
<p class="indent">The Apple II+ included a version of unstructured BASIC in ROM called Applesoft. As far as BASIC programming languages go, it was somewhat limited. However, it opened a new world to me, and I ran with it, writing small program after small program as I explored what the Apple II+ was and could do. It could ask questions, interpret answers, calculate formulas, plot pictures, and make sounds. And all of that power was at the tips of my 14-year-old fingers.</p>&#13;
<p class="indent">Of course, I wanted one of these godlike machines for my own. My father, likely thinking it would put me off, told my younger brother, Bob, and me we could have one if we learned how to program it. Challenge accepted!</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_xxvi"/>Months later, we did just that, and for Christmas in 1981, we got our own Apple II+. I still have it; it’s sitting on a shelf some five feet from me as I type this. And it still works.</p>&#13;
<p class="indent">My brother and I both ended up in computer science. During high school, I taught myself BASIC, 6502 assembly, Pascal, and FORTRAN, all on the Apple II+. I fell in love with programming languages and became a programming language junkie. A high school friend showed me a cryptic and small but powerful language he had for his TRS-80 color computer. He said its name was “Forth.” I kept that in the back of my mind for years until I encountered it again in the 1990s. Forth is one of the languages we’ll explore in this book, and it was my go-to language for most of the 1990s, on a Macintosh no less. My other language at the time was Modula-2, a successor of Pascal.</p>&#13;
<p class="indent">Thousands of programming languages have been developed over the years. I suspect a thorough history of programming languages would occupy several volumes. However, the purpose of this book is not history. The purpose of this book is:</p>&#13;
<ul>&#13;
<li class="noindent">To give you a sense of where programming languages came from and provide some context for the languages we use today and the structures they contain.</li>&#13;
<li class="noindent">To explain some of the essential elements of programming languages, so you become familiar with terms like <em>Turing machine</em> and <em>Turing complete</em>.</li>&#13;
<li class="noindent">To expand your thinking about what a programming language can be and how it can express thought and process in creative and elegant ways. We’ll do this by exploring various programming languages ranging from the unusual to the downright bizarre.</li>&#13;
<li class="noindent"><em>To have fun!</em> We’ll create our own programming languages, and see how we can use them to implement some algorithms. We’ll even put one on a small computer for standalone projects (the BBC micro:bit).</li>&#13;
</ul>&#13;
<p class="indent">The “unusual to downright bizarre” programming languages have a name. They’re called <em>esoteric languages</em> or <em>esolangs</em>. Playing with and developing esolangs is a hobby for many, and even a serious pursuit for some. Most esolangs are not intended for actual work (whatever that might be). However, some languages that might be considered on the fringe of the esolang world <em>are</em> used for serious work. For example, Forth has been used for <span epub:type="pagebreak" id="page_xxvii"/>spacecraft control on several NASA missions, and NASA developed a language called CLIPS for expert system development. I consider languages like Forth and CLIPS to be “atypical” programming languages, with everyday languages like Python, Java, and C/C++ being typical languages. Naturally, these labels are subjective and open to debate.</p>&#13;
<h3 class="h3" id="lev1sec1"><strong>Who Is This Book For?</strong></h3>&#13;
<p class="noindent">This book is for all fans of programming languages. It’s for people enamored with the idea of encoding thought in a form usable by a machine.</p>&#13;
<p class="indent">I hope anyone who codes finds something of value in this book. My primary goal is to help you expand your conception of what it means to code, what programming actually is, and how coding might be expressed.</p>&#13;
<p class="indent">This book is truly for anyone who does more than use a computer. If you are a professional developer, you’ll appreciate the freedom that comes from thinking about your craft in unusual ways. If you are a student, you’ll hopefully see that programming can be more than what you may perceive it to be based on your introductory programming courses, as necessary as they are. If you’re a hobbyist, you’re likely already somewhat familiar with esolangs and are looking to feed your passion. Come on in, the water’s fine.</p>&#13;
<h3 class="h3" id="lev1sec2"><strong>What Can You Expect to Learn?</strong></h3>&#13;
<p class="noindent">You can expect to learn about where the programming languages you use—perhaps daily—came from. You can expect to learn about alternate ways to think about programming and, by extension, see your everyday programming in a new light.</p>&#13;
<p class="indent">You can also expect to learn about the essential elements of a programming language, something about what makes a programming language complete (that is, capable of expressing any program), and something about how we can even know such a thing.</p>&#13;
<p class="indent">You can expect to learn a little about a lot of programming languages, with a focus on esolangs and other “atypical” languages. As I indicated above, I used Forth almost exclusively for a decade to write everything from web CGI frameworks to scientific analysis tools for functional brain imaging (see <a href="ch00.xhtml#ch00fig1">Figure 1</a>). I (not so) secretly hope a bright mind out there can see how to merge the rule-based expert system power of CLIPS with the power of modern deep learning. I suspect there’s a case to be made about why the two should work together.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_xxviii"/><img id="ch00fig1" src="Images/00fig01.jpg" alt="Image" width="679" height="474"/></div>&#13;
<p class="figcap"><em>Figure 1: A functional brain imaging analysis program written in Forth (circa 1998)</em></p>&#13;
<p class="indent">It’s my belief you’ll learn that developing a programming language is fun, even if the language itself is not overly useful. The Filska and Firefly languages we’ll create have different potential uses, but if nothing else, Filska can crunch numbers, and Firefly can make pretty pictures on a BBC micro:bit. The appendix demonstrates that even simple languages like Firefly can be useful for more “advanced” pursuits, like genetic programming.</p>&#13;
<p class="indent">I also expect you’ll take what we do here and expand on it yourself. For example, the micro:bit has two pushbuttons. Why not enhance Firefly to use them? Or make additions to the ABC implementation beyond what we’ll add in the book, as it’s so simplistic that it’s begging for additions. If you do, please share your results to <em><a href="mailto:rkneuselbooks@gmail.com">rkneuselbooks@gmail.com</a></em>.</p>&#13;
<h3 class="h3" id="lev1sec3"><strong>What I Expect You to Know Already</strong></h3>&#13;
<p class="noindent">I expect you are already familiar with programming at some level. We’ll use Python to implement several esolangs, so it will help if you know something about Python. Beyond that, I don’t have any expectation of prior knowledge. The most important thing you can bring to this book is curiosity.</p>&#13;
<p class="indent">It’s said curiosity killed the cat, but you’re not a cat. For us, curiosity is what made humans conquer fire, and develop stone tools, civilizations, art, music, mathematics, science, and ultimately, a car-sized robot wandering the surface of Mars—a robot we named “Curiosity.”</p>&#13;
<p class="indent">If you’re curious, if you wonder “why?”, then you’ve got all the background you need to engage with the material in this book.</p>&#13;
<h3 class="h3" id="lev1sec4"><span epub:type="pagebreak" id="page_xxix"/><strong>What This Book Is Not</strong></h3>&#13;
<p class="noindent">Many books tell you what they are. Few tell you what they are not. I think this one should clarify itself, at least a little.</p>&#13;
<p class="indent">There are university courses and textbooks with titles like “Principles of Programming Languages” or just “Programming Languages.” These courses and books are highly mathematical treatments of what programming languages are. They are fascinating, but very technical, and involve a lot of math and logic. I put them in the category of theoretical computer science. This book is not one of these texts. You won’t find any deep mathematics here. The logic is implicit in the code, not formal. This book is about programming languages from a historical, practical, and, of paramount importance, fun perspective—with additional emphasis on the fun.</p>&#13;
<p class="indent">The end of the book points you toward more academic treatments of programming languages. Please do investigate. However, please don’t put this book down believing you need to be a computer science graduate student to follow it. You don’t. If you happen to be a computer science graduate student, please don’t put the book down, either. I promise you’ll have fun with it.</p>&#13;
<h3 class="h3" id="lev1sec5"><strong>About This Book</strong></h3>&#13;
<p class="noindent">The book reads well straight through. However, after <a href="ch03.xhtml#ch03">Chapter 3</a>, you can pretty much hop around as you wish. The first three chapters provide background and context. After that come three chapters on atypical programming languages (Forth, SNOBOL, and CLIPS) followed by five on esolangs (ABC, FRACTRAN, Piet, Brainfuck, and Befunge).</p>&#13;
<p class="indent">In the two chapters after those, we define, implement, and experiment with our first homegrown esolang, Filska. The two chapters after that do the same for Firefly. Lastly, the book ends by pointing you to more—there’s always more to know.</p>&#13;
<p class="indent">The appendix explores genetic programming with Firefly. Genetic programming evolves programs instead of writing them by hand. The simplicity of Firefly makes it well-suited to such experiments—take a look and see.</p>&#13;
<h3 class="h3" id="lev1sec6"><strong>Operating Environment</strong></h3>&#13;
<p class="noindent">We assume Linux as our operating system. Specifically, we assume an Ubuntu distribution, at least version 20.04. None of the languages we’ll explore require much in the way of external libraries, so it’s highly likely future versions of Ubuntu will work without much effort.</p>&#13;
<p class="indent">We won’t give explicit instructions here, but many macOS users will be able to install the languages as well. Windows users might need to work in a Unix-like environment like Cygwin, and will have to expend more effort to find some of the language tarballs and work through the installation <span epub:type="pagebreak" id="page_xxx"/>process. Other options are using the Windows Subsystem for Linux or simply running Ubuntu in a virtual machine, both of which are easier than using Cygwin.</p>&#13;
<p class="indent">We need a C compiler to build some of the languages. Ubuntu usually comes with the gcc compiler suite for C and C++. You can test it with</p>&#13;
<pre>$ <span class="codestrong1">gcc --version</span>&#13;
gcc (Ubuntu 9.3.0-17ubuntu1~20.04) 9.3.0&#13;
Copyright (C) 2019 Free Software Foundation, Inc.&#13;
This is free software; see the source for copying conditions.  There is NO&#13;
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</pre>&#13;
<p class="noindent">Almost any version of gcc will work.</p>&#13;
<p class="indent">If gcc is not installed, and you get an error from the command above, the simplest way to install it is</p>&#13;
<pre>$ <span class="codestrong1">sudo apt update</span>&#13;
$ <span class="codestrong1">sudo apt install build-essential</span></pre>&#13;
<p class="noindent">Once you’ve done this, repeat the command above to verify that gcc is now present.</p>&#13;
<p class="indent">We’ll also implement some of the languages ourselves using Python 3. The exact version of Python 3 is not critical. Ubuntu 20.04 comes with version 3.8.5,</p>&#13;
<pre>$ <span class="codestrong1">python3 --version</span>&#13;
Python 3.8.5</pre>&#13;
<p class="noindent">so version 3.8.5 or later will suffice.</p>&#13;
<p class="indent">Now, in the immortal words of Ms. Frizzle, “Take chances, make mistakes, and get messy!” Ready? Let’s go.</p>&#13;
</div></body></html>