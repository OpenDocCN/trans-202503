<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch16">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_889" aria-label="889"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch16">&#13;
<span class="CN"><span class="SANS_Futura_Std_Bold_Condensed_B_11">16</span></span>&#13;
<span class="CT"><span class="SANS_Dogma_OT_Bold_B_11">STAND-ALONE ASSEMBLY LANGUAGE PROGRAMS</span></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="378" height="378"/>&#13;
</figure>&#13;
<p class="ChapterIntro">Until now, this book has relied upon a C/C++ main program to call the example code written in assembly language. While this is probably the biggest use of assembly language in the real world, it is also possible to write stand-alone code (no C/C++ main program) in assembly language. In this chapter, you’ll learn how to write such stand-alone programs.</p>&#13;
<p class="TX">For the purposes of this book, <i>stand-alone assembly language program</i> means that the assembly language code contains an actual <i>main</i> program (not <span class="SANS_TheSansMonoCd_W5Regular_11">asmMain</span>, which is just a function that a C++ program calls). Such a program does not make any C/C++ stdlib calls; the only external calls to code outside the application itself are OS API function calls.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Some readers might take the term</i> <span class="note_Italic">stand-alone</span> <i>to mean that an assembly language program makes no external function calls, not even to an OS, and handles all I/O at the hardware level within the application itself. That’s an appropriate definition for embedded systems, but not the definition I use in this book.</i></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_890" aria-label="890"/>Technically, your assembly code will always be called by a C/C++ program. That’s because the OS itself is written in C/C++, with a tiny bit of assembly code. When the OS transfers control to your assembly code, this is not much different from a C/C++ main program calling your assembly code. Nevertheless, “pure” assembly applications have some clear advantages: you’re not dragging along the C/C++ library code and application runtime system, so your programs can be smaller and you won’t have external naming conflicts with C/C++ public names.</p>&#13;
<p class="TX">This chapter covers OS system calls for macOS and Linux (including Pi OS). It begins by explaining how to maintain portability in your code, given that system calls are not portable between OSes. It then introduces the concept of system calls for these two OSes. After discussing the <span class="SANS_TheSansMonoCd_W5Regular_11">svc</span> (supervisor call) instruction used to make calls to OS API functions, it provides two examples: a stand-alone “Hello, world!” application and a file I/O application. Finally, it points out that macOS frowns on direct system calls and expects you to interface to the OS via C library function calls.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h1-160"/><span class="SANS_Futura_Std_Bold_B_11">16.1 Portability Issues with System Calls</span></h3>&#13;
<p class="TNI1">While most of the example programs appearing in this book so far are portable between macOS and Linux, system API calls vary by OS. Code in the previous chapters ignored this issue by calling C/C++ stdlib functions that handled the low-level OS details, but the example code in this chapter makes OS-specific calls. Therefore, portability won’t happen automatically. You have four options for handling this issue:</p>&#13;
<ul class="ul">&#13;
<li class="BL">Ignore portability and write a given example program only for macOS or only for Linux. In general, I take this approach when writing code specific to an OS.</li>&#13;
<li class="BL">Write two (nonportable) versions of the same program: one for Linux and one for macOS.</li>&#13;
<li class="BL">Write a single program that uses conditional assembly to include OS-specific code, as necessary.</li>&#13;
<li class="BL">Create two wrapper files, one that has macOS versions of OS calls and another that has Linux version, and include the appropriate wrapper with your main (portable) code.</li>&#13;
</ul>&#13;
<p class="TX">The appropriate mechanism to use depends on your application. If you are not interested in writing portable assembly code that will work across OSes (the most common case when writing assembly applications), you’ll use the first approach and write code just for the OS you are targeting.</p>&#13;
<p class="TX">If you do want your assembly application to run on macOS and Linux, your approach will depend on the size of the application. If the application is relatively small, writing two OS-specific variants is not that difficult (though maintenance may be an issue, as you’ll have to maintain two separate versions of the application). If the application is large, or you expect to <span role="doc-pagebreak" epub:type="pagebreak" id="pg_891" aria-label="891"/>upgrade and maintain it frequently, the third or fourth approach is probably better. A single application that uses conditional assembly to deal with OS-specific issues is usually much easier to maintain and expand than two separate applications, and using wrapper code makes it easier to maintain the code for each specific OS.</p>&#13;
<p class="TX">There is a fifth approach: write all your OS-dependent code in C/C++ and call assembly functions that deal with the non-OS-specific functionality. That’s how all the example programs in this book have been written.</p>&#13;
<p class="TX">It should go without saying that the code in this chapter does not use the <i>build</i> script to compile/assemble the example applications. The <i>build</i> script assumes the use of the <i>c.cpp</i> main program (and the whole point of this chapter is to stop using that code). Therefore, each example program in this chapter includes a makefile that builds the code.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h3 class="H1" id="sec2"><span id="h1-161"/><span class="SANS_Futura_Std_Bold_B_11">16.2 Stand-Alone Code and System Calls</span></h3>&#13;
<p class="TNI1">The first example program in this book, <span class="Xref">Listing 1-1</span> on <span class="Xref"><a href="chapter1.xhtml#pg_5">page 5</a></span>, is a stand-alone program. Here it is as Listing 16-1, with a couple of changes, for the sake of discussion.</p>&#13;
<pre id="pre-1197"><code>// Listing16-1.S&#13;
//&#13;
// Comments consist of all text from a //&#13;
// sequence to the end of the line.&#13;
// The .text directive tells MASM that the&#13;
// statements following this directive go in&#13;
// the section of memory reserved for machine&#13;
// instructions (code).&#13;
&#13;
       .text&#13;
&#13;
// Here is the main function.&#13;
// (This example assumes that the&#13;
// assembly language program is a&#13;
// stand-alone program with its own&#13;
// main function.)&#13;
//&#13;
// Under macOS, the main program&#13;
// must have the name _main&#13;
// beginning with an underscore.&#13;
// Linux systems generally don't&#13;
// require the underscore.&#13;
//&#13;
// The .global _main statement&#13;
// makes the _main procedure's name&#13;
// visible outside this source file&#13;
// (needed by the linker to produce&#13;
// an executable).&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_892" aria-label="892"/>     <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> .global _main  // This is the macOS entry point.&#13;
     <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> .global main   // This is the Linux entry point name.&#13;
&#13;
// The .align 2 statement tells the&#13;
// assembler to align the following code&#13;
// on a 4-byte boundary (required by the&#13;
// ARM CPU). The 2 operand specifies&#13;
// 2 raised to this power (2), which&#13;
// is 4.&#13;
&#13;
       .align 2&#13;
&#13;
// Here's the actual main program. It&#13;
// consists of a single ret (return)&#13;
// instruction that simply returns&#13;
// control to the operating system.&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> _main:&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> main:&#13;
    <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> ret</code></pre>&#13;
<p class="TX">I’ve made two changes to this code compared with that in Listing 1-1. At both instances of <span class="CodeAnnotation" aria-label="annotation1">❶</span> and <span class="CodeAnnotation" aria-label="annotation2">❷</span>, I’ve introduced a new symbol, <span class="SANS_TheSansMonoCd_W5Regular_11">main</span> (and <span class="SANS_TheSansMonoCd_W5Regular_11">_main</span>). This is because Linux requires the main program to be named <span class="SANS_TheSansMonoCd_W5Regular_11">main</span>, whereas macOS requires the name <span class="SANS_TheSansMonoCd_W5Regular_11">_main</span>. Were you to attempt to compile <span class="Xref">Listing 1-1</span> under Linux, you would get something like an <span class="SANS_TheSansMonoCd_W5Regular_11">undefined reference to `main`</span> message. Rather than mess around with conditional assembly (or write two separate versions of Listing 16-1), I simply include both symbols in the source file. Linux largely ignores the <span class="SANS_TheSansMonoCd_W5Regular_11">_main</span> symbol, and macOS ignores the <span class="SANS_TheSansMonoCd_W5Regular_11">main</span> symbol; the program happily compiles under either OS.</p>&#13;
<p class="TX">Listing 16-1 consists of a single instruction: <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. On entry, the LR register contains a return address that transfers control back to the OS. Therefore, this program (should you actually execute it) returns immediately to the OS.</p>&#13;
<p class="TX">Although returning to the OS via a <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction works (particularly if building this code with GCC), this isn’t the standard way to return to Linux or macOS. Instead, an application should make a call to the <span class="SANS_TheSansMonoCd_W5Regular_11">exit()</span> API function. To call a system API function, a program must load a function number into a register, load appropriate parameters into the parameter registers (X0 through X7), and then execute the supervisor (OS) call instruction <span class="SANS_TheSansMonoCd_W5Regular_11">svc #</span><span class="SANS_TheSansMonoCd_W5Regular_Italic_11">OSint</span>, where <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">OSint</span> is 0 for Linux and 0x80 for macOS.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>In reality, macOS seems to ignore the immediate constant following the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">svc</span> <i>instruction. Many online examples use the value 0 as the</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">svc</span> <i>operand (and personal experiments show that it works). However, the macOS source code seems to use 0x80 as the constant, so I recommend using this value under macOS.</i></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_893" aria-label="893"/>Under Linux, you load the system call number into the X8 register, while under macOS you load this into X16. I’ve added the following statements in <i>aoaa.inc</i> to handle this:</p>&#13;
<pre id="pre-1198"><code>#if isMacOS&#13;
&#13;
    // Under macOS, the system call number&#13;
    // goes into X16:&#13;
&#13;
    #define svcReg x16&#13;
    #define OSint  0x80&#13;
&#13;
#else&#13;
&#13;
    // Under Linux, the system call number&#13;
    // is passed in X8:&#13;
&#13;
    #define svcReg x8&#13;
    #define OSint  0&#13;
&#13;
#endif</code></pre>&#13;
<p class="TX">Under both Linux and macOS, the <span class="SANS_TheSansMonoCd_W5Regular_11">exit</span> function expects a single integer parameter in the X0 register holding the program’s return code (generally this is 0 if no errors occurred while running the program). The only question remaining is, “What is the system call number for <span class="SANS_TheSansMonoCd_W5Regular_11">exit()</span>?” Under Linux, the code is 93, while under macOS it’s 1 (I’ll discuss how I determined these magic numbers in section 16.3, <span class="Xref">“The</span> <span class="SANS_TheSansMonoCd_W5Regular_11">svc</span> <span class="Xref">Interface and OS Portability,”</span> on <span class="Xref">the next page</span>). Listing 16-2 provides a very simple assembly application that immediately returns to the OS and that you can compile for macOS or Linux.</p>&#13;
<pre id="pre-1199"><code>// Listing16-2.S&#13;
//&#13;
// Simple shell program that calls exit()&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> #include    "aoaa.inc"&#13;
&#13;
        // Specify OS-dependent return code:&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> #ifdef      isMacOS&#13;
        #define     exitCode 1&#13;
        #else&#13;
        #define     exitCode 93&#13;
        #endif&#13;
&#13;
        .text&#13;
        .global     _main&#13;
        .global     main&#13;
        .align      2&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_894" aria-label="894"/>_main:&#13;
main:&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> mov         x0, #0  // Return success.&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> mov         svcReg, exitCode&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> svc         #OSint</code></pre>&#13;
<p class="TX">Listing 16-2 includes <i>aoaa.inc</i> <span class="CodeAnnotation" aria-label="annotation1">❶</span> in order to generate an error if the OS symbol (Linux or Darwin) is not defined on the command line (which <i>aoaa.inc</i> translates to <span class="SANS_TheSansMonoCd_W5Regular_11">isLinux</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">isMacOS</span>), as well as to obtain the <span class="SANS_TheSansMonoCd_W5Regular_11">OSint</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">svcReg</span> constants.</p>&#13;
<p class="TX">The program uses conditional assembly to generate the different code needed for macOS or Linux, setting the constant <span class="SANS_TheSansMonoCd_W5Regular_11">exitCode</span> equal to the OS’s exit function number <span class="CodeAnnotation" aria-label="annotation2">❷</span>. This function loads X0 with 0 <span class="CodeAnnotation" aria-label="annotation3">❸</span> to indicate success when it returns. It then loads the <span class="SANS_TheSansMonoCd_W5Regular_11">exitCode</span> function number into the OS’s function number parameter register <span class="CodeAnnotation" aria-label="annotation4">❹</span> (<span class="SANS_TheSansMonoCd_W5Regular_11">svcReg</span> is X8 under Linux and X16 under macOS, as defined in <i>aoaa.inc</i>, as per the previous example). Finally, the code issues the supervisor call instruction to call the OS <span class="CodeAnnotation" aria-label="annotation5">❺</span>. Because of the nature of this call, the <span class="SANS_TheSansMonoCd_W5Regular_11">svc</span> instruction never returns control back to the program, so there is no need for a <span class="SANS_TheSansMonoCd_W5Regular_11">ret</span> instruction.</p>&#13;
<p class="TX">Here’s the makefile to build the program in Listing 16-2:</p>&#13;
<pre id="pre-1200"><code># Listing16-2.mak&#13;
#&#13;
# makefile to build the Listing16-2 file&#13;
&#13;
unamestr=`uname`&#13;
&#13;
Listing16-2:&#13;
    g++ -D$(unamestr) Listing16-2.S -o Listing16-2&#13;
&#13;
clean:&#13;
    rm -f Listing16-2.o&#13;
    rm -f Listing16-2</code></pre>&#13;
<p class="TX">To build and run this program, enter the following commands into the shell program:</p>&#13;
<pre id="pre-1201"><code>% <span class="SANS_TheSansMonoCd_W7Bold_11">make -f Listing16-2.mak</span>&#13;
g++ -D`uname` Listing16-2.S -o Listing16-2&#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing16-2</span></code></pre>&#13;
<p class="Continued1">The program returns without producing any output, as expected.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h3 class="H1" id="sec3"><span id="h1-162"/><span class="SANS_Futura_Std_Bold_B_11">16.3 The svc Interface and OS Portability</span></h3>&#13;
<p class="TNI1">Both macOS and Linux use the supervisor call instruction (<span class="SANS_TheSansMonoCd_W5Regular_11">svc</span>) to make API calls to the OS. However, the exact calling sequence varies considerably between the two OSes. This section clarifies the differences between them with respect to the functions (the API) that they support—in particular, regarding call numbers, parameters, and error handling.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_895" aria-label="895"/>Although both OSes are Unix based (and share many POSIX-compliant functions), each has its own set of OS-specific functions that may have no equivalence on the other system. Even the common (for example, POSIX) functions may expect different arguments and produce different return results, meaning you must be especially careful when attempting to write assembly code that is portable between these two OSes. This is a good example of how using wrappers to localize OS system calls can help improve the portability and maintainability of your code.</p>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h2-268"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">16.3.1 Call Numbers</span></h4>&#13;
<p class="TNI1">As noted earlier, the function call number values differ between OSes, as does the location where you pass the call numbers (X8 for Linux, X16 for macOS). It’s easy enough to overcome the register location issue by using a <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> (or <span class="SANS_TheSansMonoCd_W5Regular_11">.req</span> directive). However, the function call number values are completely OS dependent.</p>&#13;
<p class="TX">The <i>sys</i>/<i>syscall.h</i> file is a header file that contains definitions for all the system API call numbers. (You can include it in an assembly language source file even though it’s a C header file.) This file is generally installed on your system when you install your C compiler (GCC or Clang) and is typically found in the default include path used by the compiler. See the GCC or Xcode documentation for more details.</p>&#13;
<p class="TX">Although <span class="SANS_TheSansMonoCd_W5Regular_11">#include &lt;sys/syscall.h&gt;</span> will work on both Linux and macOS, the actual definitions may appear in a different file elsewhere in the compiler’s directory tree, with an appropriate <span class="SANS_TheSansMonoCd_W5Regular_11">#include</span> inside <i>sys</i>/<i>syscall.h</i> leading to the actual file.</p>&#13;
<p class="TX">Here are a few lines from <i>sys/syscall.h</i> on a macOS machine:</p>&#13;
<pre id="pre-1202"><code>#ifdef __APPLE_API_PRIVATE&#13;
#define SYS_syscall        0&#13;
#define SYS_exit           1&#13;
#define SYS_fork           2&#13;
#define SYS_read           3&#13;
#define SYS_write          4&#13;
#define SYS_open           5&#13;
#define SYS_close          6&#13;
#define SYS_wait4          7&#13;
   .&#13;
   .&#13;
   .</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">#ifdef</span> statement in this code is a warning that Apple considers the <span class="SANS_TheSansMonoCd_W5Regular_11">svc</span> API interface to be undocumented and private, as discussed in the <span class="Xref">“Using</span> <span class="SANS_TheSansMonoCd_W5Regular_11">svc</span> <span class="Xref">Under macOS”</span> box on the next page.</p>&#13;
<p class="TX">On my macOS system, I used the Unix <span class="SANS_TheSansMonoCd_W5Regular_11">find</span> command to locate <i>sys</i>/<i>syscall.h</i> buried deep in the Xcode directory path <i>/Library/Developer/CommandLineTools/SDK/ ...</i> , but your mileage may vary.</p>&#13;
<aside class="box" aria-label="box-36">&#13;
<p class="BH" id="box-36"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_896" aria-label="896"/><span class="SANS_Dogma_OT_Bold_B_11">USING SVC UNDER MACOS</span></p>&#13;
<p class="BTNI"><span class="SANS_Futura_Std_Book_11">While using the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">svc</span> <span class="SANS_Futura_Std_Book_11">interface to the OS is perfectly acceptable under Linux, using</span> <span class="SANS_TheSansMonoCd_W5Regular_11">svc</span> <span class="SANS_Futura_Std_Book_11">to call system functions is considered an undocumented or private API call under macOS. Apple does not guarantee that such calls will continue to work in future versions of macOS. Furthermore, if you attempt to sell an application in the App Store that contains such calls, Apple may reject your application because it uses undocumented APIs.</span></p>&#13;
<p class="BoxBodyLast"><span class="SANS_Futura_Std_Book_11">According to Apple, the correct way to make such API calls is through the use of system libraries. For example, you should call the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">_exit()</span> <span class="SANS_Futura_Std_Book_11">function rather than loading 1 into X16 and executing</span> <span class="SANS_TheSansMonoCd_W5Regular_11">svc</span><span class="SANS_Futura_Std_Book_11">. I’ll have more to say about this subject in section 16.6, “Calling System Library Functions Under macOS,” on <a href="chapter16.xhtml#pg_926">page 926</a>).</span></p>&#13;
</aside>&#13;
<p class="TX">Under Debian Linux, <span class="SANS_TheSansMonoCd_W5Regular_11">#include &lt;sys/syscall.h&gt;</span> includes <i>/usr/include/asm -generic/unistd.h</i> (again, use the Unix <span class="SANS_TheSansMonoCd_W5Regular_11">find</span> command if this file isn’t present at this location). Here are a few lines from that file, sorted to match the order of the statements in the macOS <i>syscall.h</i> file:</p>&#13;
<pre id="pre-1203"><code>#define __NR_exit 93&#13;
__SYSCALL(__NR_exit, sys_exit)&#13;
#define __NR_read 63&#13;
__SYSCALL(__NR_read, sys_read)&#13;
#define __NR_write 64&#13;
__SYSCALL(__NR_write, sys_write)&#13;
#define __NR_openat 56&#13;
__SYSCALL(__NR_openat, sys_openat)&#13;
#define __NR_close 57&#13;
__SYSCALL(__NR_close, sys_close)&#13;
   .&#13;
   .&#13;
   .</code></pre>&#13;
<p class="TX">As you can see, the function names, the constant names, and the function call numbers in the two files don’t agree. For example, Linux generally prefers <span class="SANS_TheSansMonoCd_W5Regular_11">openat()</span> over the <span class="SANS_TheSansMonoCd_W5Regular_11">open()</span> function. Fortunately, macOS also provides <span class="SANS_TheSansMonoCd_W5Regular_11">openat()</span>, so it’s possible to use the same function on both OSes. However, the symbolic names macOS and Linux use for the same functions are quite different, which means including <i>sys/syscall.h</i> isn’t a portable solution. You’ll still have to provide your own local names that map to the corresponding Linux and macOS names (suggestion: use two syscall wrapper <i>.S</i> files, one for Mac and one for Linux, to resolve these problems).</p>&#13;
<p class="TX">Unfortunately, the <i>sys/syscall.h</i> header files don’t provide the parameter lists for the various functions. You can find the parameter information for Linux at <i><a href="https://arm.syscall.sh">https://<wbr/>arm<wbr/>.syscall<wbr/>.sh</a></i>. For example, consider the entry for the <span class="SANS_TheSansMonoCd_W5Regular_11">exit()</span> function:</p>&#13;
<pre id="pre-1204"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_897" aria-label="897"/>name  reference   x8    x0               x1 x2 x3 x4 x5&#13;
exit  man/ cs/    5D    int error_code   -- -- -- -- --</code></pre>&#13;
<p class="TX">This line tells you that X8 must contain 0x5D (93) and X0 must contain the exit code (<span class="SANS_TheSansMonoCd_W5Regular_11">error_code</span>). Linux system calls have a maximum of six parameters (X0 through X5), but <span class="SANS_TheSansMonoCd_W5Regular_11">exit()</span> uses only one of them (in addition to the function call number in X8).</p>&#13;
<p class="TX">On macOS, you must use the macOS call number (1 for exit) and load that call number into X16. The parameters are generally the same for equivalent macOS functions, subject (of course) to the differences in the Linux versus macOS ABI (see section 16.8, <span class="Xref">“For More Information,”</span> on <span class="Xref"><a href="chapter16.xhtml#pg_930">page 930</a></span> for the set of system calls).</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h2-269"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">16.3.2 API Parameters</span></h4>&#13;
<p class="TNI1">As a general rule, all the system calls have well-defined names and parameter lists, which you can find online by searching for the function’s name or by using the <span class="SANS_TheSansMonoCd_W5Regular_11">man</span> command at the command line. For example, the <span class="SANS_TheSansMonoCd_W5Regular_11">openat()</span> call has the following parameters (from the Linux man page):</p>&#13;
<pre id="pre-1205"><code>int openat(int dfd, const char *pathname, int flags, mode_t mode);</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">openat</span> code (57 in Linux, 463 under macOS) goes in X8 (Linux) or X16 (macOS), a directory descriptor goes in X0, a pointer to the filename (pathname) goes in X1, and the flags get passed in X2 (an optional <span class="SANS_TheSansMonoCd_W5Regular_11">mode</span> parameter can be passed in X3). You choose the parameter registers according to the ARM ABI.</p>&#13;
<p class="TX">To create code that’s portable between macOS and Linux, you can use the following conditional assembly at the beginning of your source file to select the constants based on the OS:</p>&#13;
<pre id="pre-1206"><code>    #include "aoaa.inc"&#13;
    #include &lt;sys/syscall.h&gt;&#13;
&#13;
#if isMacOS&#13;
&#13;
    #define  sys_openat SYS_openat&#13;
    #define  sys_read SYS_read&#13;
    #define  sys_close SYS_close&#13;
&#13;
#elif isLinux&#13;
&#13;
    #define  sys_openat __NR_openat&#13;
    #define  sys_read __NR_read&#13;
    #define  sys_close __NR_close&#13;
&#13;
#endif</code></pre>&#13;
<p class="TX">From this point forward, you can use the symbols <span class="SANS_TheSansMonoCd_W5Regular_11">sys_*</span> on either OS. Of course, if you don’t require portability between the two OSes, you can <span role="doc-pagebreak" epub:type="pagebreak" id="pg_898" aria-label="898"/>simply include <i>sys/syscall.h</i> and use the <span class="SANS_TheSansMonoCd_W5Regular_11">SYS_*</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">_NR_*</span> symbols as appropriate for your OS choice.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h2-270"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">16.3.3 API Error Handling</span></h4>&#13;
<p class="TNI1">One other big difference between macOS and Linux API calls is in the way they return an indication of an error. For macOS API calls, the error status is returned in the carry flag (C = 1 for error, C = 0 for no error). If the carry flag is set, macOS returns an error code in the X0 register. Linux, on the other hand, returns –1 in X0 if there is an error; you must then fetch the actual error code from the <span class="SANS_TheSansMonoCd_W5Regular_11">errno</span> variable (as shown in <span class="Xref">Listing 7-2</span> on <span class="Xref"><a href="chapter7.xhtml#pg_358">page 358</a></span>, for example).</p>&#13;
<p class="TX">Dealing with error return values in portable code could be problematic. One solution is to use a set of wrapper functions to handle errors in an OS-specific fashion for each OS. I’ve chosen to create a small macro to translate the error return status to a common value on both macOS and Linux:</p>&#13;
<pre id="pre-1207"><code>            .macro  checkError&#13;
&#13;
            #if     isMacOS&#13;
&#13;
            // If macOS, convert the error code to be&#13;
            // compatible with Linux (carry set is&#13;
            // error flag and X0 is error code):&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> bcc     0f&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> neg     x0, x0&#13;
&#13;
            #elif   isLinux&#13;
&#13;
            // If Linux, fetch the errno error code&#13;
            // (if return value is -1), negate it,&#13;
            // and return that as the error code:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> cmp     x0, #-1&#13;
            bne     0f&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> getErrno&#13;
            neg     x0, x0&#13;
&#13;
            #endif&#13;
0:&#13;
            .endm</code></pre>&#13;
<p class="TX">Under macOS, if the carry is clear <span class="CodeAnnotation" aria-label="annotation1">❶</span>, then this macro does nothing (no error). If there is an error (carry set), the macro negates the value in X0 <span class="CodeAnnotation" aria-label="annotation2">❷</span> (which is currently a positive error code).</p>&#13;
<p class="TX">Under Linux, an error is indicated by returning –1 in X0, in which case the code has to retrieve the actual error code from the <span class="SANS_TheSansMonoCd_W5Regular_11">errno</span> variable. If the API function returns –1 <span class="CodeAnnotation" aria-label="annotation3">❸</span>, the code fetches <span class="SANS_TheSansMonoCd_W5Regular_11">errno</span>’s value <span class="CodeAnnotation" aria-label="annotation4">❹</span> (which is a positive number) and negates it.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_899" aria-label="899"/>This macro assumes that the API function will return a nonnegative result in X0 if there is no error, so it returns a negation of the actual error code if there was an error. This will provide a sign-consistent set of values you can test for under either OS.</p>&#13;
<p class="TX">Although the <span class="SANS_TheSansMonoCd_W5Regular_11">checkError</span> macro produces a portable set of error codes, do not assume that the two OSes will produce exactly the same error codes for any given situation. They are more likely to produce slightly different error codes under the same circumstances. At the very least, you should be able to handle any error return code that either the macOS or Linux man pages list for a given API function (yet another argument for using a wrapper function to handle error codes in portable code).</p>&#13;
<p class="TX">You can lift the appropriate defines from the <i>errno.h</i> file (or other files it may include); this will allow you to refer to Unix-compatible constant names like <span class="SANS_TheSansMonoCd_W5Regular_11">EPERM</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">EACCES</span> in your assembly source code. Don’t forget that the <span class="SANS_TheSansMonoCd_W5Regular_11">checkError</span> macro negates the error code, so you have to compare against negated <i>errno.h</i> constants (for example, <span class="SANS_TheSansMonoCd_W5Regular_11">-EPERM</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">-EACCES</span>).</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h3 class="H1" id="sec7"><span id="h1-163"/><span class="SANS_Futura_Std_Bold_B_11">16.4 A Stand-Alone “Hello, World!” Program</span></h3>&#13;
<p class="TNI1">By convention, the first “real” program to try when writing a stand-alone assembly program is “Hello, world!” Under Linux and macOS, you can use the system <span class="SANS_TheSansMonoCd_W5Regular_11">write()</span> function to write a string to the standard output device, as shown in Listing 16-3.</p>&#13;
<pre id="pre-1208"><code>// Listing16-3.S&#13;
//&#13;
// A stand-alone "Hello, world!" program&#13;
&#13;
        #include    "aoaa.inc"&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> #include    &lt;sys/syscall.h&gt;&#13;
&#13;
        // Specify OS-dependent return code:&#13;
&#13;
        #if         isMacOS&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> #define     exitCode    SYS_exit&#13;
        #define     sys_write   SYS_write&#13;
&#13;
        #else&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> #define     exitCode    __NR_exit&#13;
        #define     sys_write   __NR_write&#13;
&#13;
        #endif&#13;
&#13;
        .data&#13;
hwStr:  .asciz      "Hello, world!\n"&#13;
hwSize  =           .-hwStr&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_900" aria-label="900"/>       .text&#13;
       .global      _main&#13;
       .global      main&#13;
       .align       2&#13;
&#13;
_main:&#13;
main:&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> mov         x0, #1          // stdout file handle&#13;
        lea         x1, hwStr       // String to print&#13;
        mov         x2, #hwSize     // Num chars to print&#13;
        mov         svcReg, #sys_write&#13;
        svc         #OSint          // Call OS to print str.&#13;
&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> mov         svcReg, #exitCode&#13;
        mov         x0, #0&#13;
        svc         #OSint          // Quit program.</code></pre>&#13;
<p class="TX">In Listing 16-3, the <span class="SANS_TheSansMonoCd_W5Regular_11">#include</span> statement loads in the operating-specific constant names for the API function call values <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The code defines the system call constants for macOS <span class="CodeAnnotation" aria-label="annotation2">❷</span>. As the <span class="SANS_TheSansMonoCd_W5Regular_11">write</span> symbol was already defined in the <i>aoaa.inc</i> header file (the name of the C stdlib <span class="SANS_TheSansMonoCd_W5Regular_11">write()</span> function), I’ve used <span class="SANS_TheSansMonoCd_W5Regular_11">sys_write</span> to overcome namespace pollution. Likewise, the code defines the Linux system call constants <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">Calling the system API <span class="SANS_TheSansMonoCd_W5Regular_11">write()</span> function prints <span class="SANS_TheSansMonoCd_W5Regular_11">Hello, world!</span> <span class="CodeAnnotation" aria-label="annotation4">❹</span>. This call expects a pointer to the string in X1, the string length in X2, and a file descriptor value in X0. For the stdout device, the file descriptor is 1. Finally, I include the usual program termination code <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<p class="TX">Note that the C stdlib <span class="SANS_TheSansMonoCd_W5Regular_11">write()</span> function is nothing more than facade code that directly calls the Linux <span class="SANS_TheSansMonoCd_W5Regular_11">write()</span> API function. If we were willing to link with C code, we could have accomplished the same thing by calling <span class="SANS_TheSansMonoCd_W5Regular_11">write()</span>, but doing so would defeat the purpose of this chapter.</p>&#13;
<p class="TX">Here’s the makefile that will build the program in Listing 16-3:</p>&#13;
<pre id="pre-1209"><code># Listing16-3.mak&#13;
#&#13;
# makefile to build the Listing16-3 file&#13;
&#13;
unamestr=`uname`&#13;
&#13;
Listing16-3:&#13;
    g++ -D$(unamestr) Listing16-3.S -o Listing16-3&#13;
&#13;
clean:&#13;
    rm -f Listing16-3.o&#13;
    rm -f Listing16-3</code></pre>&#13;
<p class="TX">Here are the commands to build and run the program, along with the sample output:</p>&#13;
<pre id="pre-1210"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_901" aria-label="901"/>% <span class="SANS_TheSansMonoCd_W7Bold_11">make -f Listing16-3.mak clean</span>&#13;
rm -f Listing16-3.o&#13;
rm -f Listing16-3&#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">make -f Listing16-3.mak</span>&#13;
g++ -D`uname` Listing16-3.S -o Listing16-3&#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing16-3</span>&#13;
Hello, world!</code></pre>&#13;
<p class="TX">Note that the program did not print <span class="SANS_TheSansMonoCd_W5Regular_11">Calling Listing16-3</span> nor <span class="SANS_TheSansMonoCd_W5Regular_11">Listing16-3 terminated</span>. That output is produced by the <i>c.cpp</i> <span class="SANS_TheSansMonoCd_W5Regular_11">main()</span> function, which this code is not using.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h1-164"/><span class="SANS_Futura_Std_Bold_B_11">16.5 A Sample File I/O Program</span></h3>&#13;
<p class="TNI1">File I/O has been conspicuously absent from the book thus far. While reading and writing file data is easily achieved using the C stdlib functions such as <span class="SANS_TheSansMonoCd_W5Regular_11">fopen</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">fclose</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">fprintf</span>, the Linux and macOS APIs provide many useful functions (on which the C stdlib is built) for this purpose. This section describes a few of these functions:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">open</span>    Open (or create) a file for reading, writing, or appending.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">read</span>    Read data from an open file.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">write</span>    Write data to an open file.</p>&#13;
<p class="RunInPara"><span class="SANS_TheSansMonoCd_W7Bold_11">close</span>    Close an open file.</p>&#13;
</div>&#13;
<p class="TX">For the purposes of this example, I’ll implement these calls as a <i>files</i> library consisting of three source modules:</p>&#13;
<div class="top">&#13;
<p class="RunInPara"><b><i>volatile.S</i></b>    A pair of utility functions that save and restore all the volatile registers</p>&#13;
<p class="RunInPara"><b><i>stdio.S</i></b>    A set of I/O routines that write data to the stdout device and read data from the stdin device (console I/O)</p>&#13;
<p class="RunInPara"><b><i>files.S</i></b>    A set of routines for opening, reading, writing, and closing files</p>&#13;
</div>&#13;
<p class="TX">I’ve put these files in a <i>files</i> subdirectory, along with a <i>files.mak</i> makefile that will assemble these files and put them in a <i>file.a</i> archive file. Here’s the makefile:</p>&#13;
<pre id="pre-1211"><code># files.mak&#13;
#&#13;
# makefile to build the files library&#13;
&#13;
unamestr=`uname`&#13;
&#13;
files.a:files.o stdio.o volatile.o&#13;
    ar rcs files.a files.o stdio.o volatile.o&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> cp files.a ..&#13;
&#13;
files.o:files.S files.inc ../aoaa.inc&#13;
    g++ -c -D$(unamestr) files.S&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_902" aria-label="902"/>stdio.o:stdio.S files.inc ../aoaa.inc&#13;
    g++ -c -D$(unamestr) stdio.S&#13;
&#13;
volatile.o:volatile.S files.inc ../aoaa.inc&#13;
    g++ -c -D$(unamestr) volatile.S&#13;
&#13;
clean:&#13;
    rm -f files.o&#13;
    rm -f volatile.o&#13;
    rm -f stdio.o&#13;
    rm -f files.a</code></pre>&#13;
<p class="TX">After this makefile successfully builds the source files (and combines them into the <i>file.a</i> archive file) <span class="CodeAnnotation" aria-label="annotation1">❶</span>, it copies <i>file.a</i> into the parent directory, where the application that uses <i>files.a</i> appears.</p>&#13;
<p class="TX">Before discussing the file library’s source files, I’ll present the <i>files.inc</i> header file, since it contains definitions that both the library and application source code will use:</p>&#13;
<pre id="pre-1212"><code>// files.inc&#13;
//&#13;
// Header file that holds the files library&#13;
// globals and constants&#13;
&#13;
            #include "../aoaa.inc"  // Get isMacOS and isLinux.&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> #if isMacOS&#13;
#define __APPLE_API_PRIVATE&#13;
#endif&#13;
            #include        &lt;sys/syscall.h&gt;&#13;
&#13;
            #if     isMacOS&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> sys_Read    =       SYS_read&#13;
sys_Write   =       SYS_write&#13;
sys_Open    =       SYS_openat&#13;
sys_Close   =       SYS_close&#13;
AT_FDCWD    =       -2&#13;
&#13;
#define O_CREAT     00000200&#13;
&#13;
            #else&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> sys_Read    =       __NR_read&#13;
sys_Write   =       __NR_write&#13;
sys_Open    =       __NR_openat&#13;
sys_Close   =       __NR_close&#13;
AT_FDCWD    =       -100&#13;
&#13;
#define O_CREAT     00000100&#13;
&#13;
            #endif&#13;
&#13;
// Handles for the stdio files:&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_903" aria-label="903"/><span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> stdin       =       0&#13;
stdout      =       1&#13;
stderr      =       2&#13;
&#13;
// Other useful constants:&#13;
&#13;
cr          =       0xd     // Carriage return (ENTER)&#13;
lf          =       0xa     // Line feed/newline char&#13;
bs          =       0x8     // Backspace&#13;
&#13;
// Note the following are octal (base 8) constants!&#13;
// (Leading 0 indicates octal in Gas.)&#13;
//&#13;
// These constants were copied from fcntl.h.&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation5">❺</span> #define S_IRWXU  (00700)&#13;
#define S_RDWR   (00666)&#13;
#define S_IRUSR  (00400)&#13;
#define S_IWUSR  (00200)&#13;
#define S_IXUSR  (00100)&#13;
#define S_IRWXG  (00070)&#13;
#define S_IRGRP  (00040)&#13;
#define S_IWGRP  (00020)&#13;
#define S_IXGRP  (00010)&#13;
#define S_IRWXO  (00007)&#13;
#define S_IROTH  (00004)&#13;
#define S_IWOTH  (00002)&#13;
#define S_IXOTH  (00001)&#13;
#define S_ISUID  (0004000)&#13;
#define S_ISGID  (0002000)&#13;
#define S_ISVTX  (0001000)&#13;
&#13;
#define O_RDONLY    00000000&#13;
#define O_WRONLY    00000001&#13;
#define O_RDWR      00000002&#13;
#define O_EXCL      00000200&#13;
#define O_NOCTTY    00000400&#13;
#define O_TRUNC     00001000&#13;
#define O_APPEND    00002000&#13;
#define O_NONBLOCK  00004000&#13;
#define O_DSYNC     00010000&#13;
#define FASYNC      00020000&#13;
#define O_DIRECT    00040000&#13;
#define O_LARGEFILE 00100000&#13;
#define O_DIRECTORY 00200000&#13;
#define O_NOFOLLOW  00400000&#13;
#define O_NOATIME   01000000&#13;
#define O_CLOEXEC   02000000&#13;
&#13;
// Macro to test an error return&#13;
// value from an OS API call:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> .macro  file.checkError&#13;
&#13;
            #if     isMacOS&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_904" aria-label="904"/>            // If macOS, convert the error code to be&#13;
            // compatible with Linux (carry set is&#13;
            // error flag, and X0 is error code):&#13;
&#13;
            bcc     0f&#13;
            neg     x0, x0&#13;
&#13;
            #elif   isLinux&#13;
&#13;
            // If Linux, fetch the errno error code&#13;
            // (if return value is -1), negate it,&#13;
            // and return that as the error code:&#13;
&#13;
            cmp     x0, #-1&#13;
            bne     0f&#13;
            getErrno&#13;
            neg     x0, x0&#13;
&#13;
            #endif&#13;
0:&#13;
            .endm&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation7">❼</span> .extern saveVolatile&#13;
            .extern restoreVolatile&#13;
&#13;
            .extern file.write&#13;
            .extern file.read&#13;
            .extern file.open&#13;
            .extern file.openNew&#13;
            .extern file.close&#13;
&#13;
            .extern stdout.puts&#13;
            .extern stdout.newLn&#13;
&#13;
            .extern stdin.read&#13;
            .extern stdin.getc&#13;
            .extern stdin.readln</code></pre>&#13;
<p class="TX">As mentioned earlier, the macOS <span class="SANS_TheSansMonoCd_W5Regular_11">SYS_*</span> symbols appear inside an <span class="SANS_TheSansMonoCd_W5Regular_11">#ifdef</span> block that hides the definitions if the symbol <span class="SANS_TheSansMonoCd_W5Regular_11">__APPLE_API_PRIVATE</span> is not defined. Therefore, when including the <span class="SANS_TheSansMonoCd_W5Regular_11">sys/syscall.h</span> header file under macOS, <i>files.inc</i> needs to define the symbol <span class="SANS_TheSansMonoCd_W5Regular_11">__APPLE_API_PRIVATE</span> so that all the <span class="SANS_TheSansMonoCd_W5Regular_11">SYS_*</span> labels will be processed by the CPP <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">The <i>files.inc</i> header then defines various symbols whose values differ by OS (in particular, the API function call numbers) <span class="CodeAnnotation" aria-label="annotation2">❷</span> <span class="CodeAnnotation" aria-label="annotation3">❸</span>. This conditional assembly block also defines the <span class="SANS_TheSansMonoCd_W5Regular_11">O_CREAT</span> symbol, which is different for the two OSes.</p>&#13;
<p class="TX">Next, the header defines various constants that will be useful in both the library source code and in applications that link against the library <span class="CodeAnnotation" aria-label="annotation4">❹</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">stdin</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">stdout</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">stderr</span> constants are the Unix file descriptor values for the standard input device, the standard output device, and the standard <span role="doc-pagebreak" epub:type="pagebreak" id="pg_905" aria-label="905"/>error (output) device, respectively. The library uses <span class="SANS_TheSansMonoCd_W5Regular_11">cr</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">lf</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">bs</span> as ASCII character code constants.</p>&#13;
<p class="TX">I’ve then inserted several <span class="SANS_TheSansMonoCd_W5Regular_11">#define</span> statements lifted from <i>fcntl.h</i> <span class="CodeAnnotation" aria-label="annotation5">❺</span> (yet another C/C++ header file containing useful API constant definitions; you’ll usually find it in the same directory as <i>syscall.h</i>). These constants are used with the <span class="SANS_TheSansMonoCd_W5Regular_11">openat()</span> function when creating a new file (you supply these constants for the <span class="SANS_TheSansMonoCd_W5Regular_11">mode</span> parameter). As with <i>errno.h</i>, you cannot simply include <i>fcntl.h</i> because Gas will not be able to process the C/C++ statements that appear in it.</p>&#13;
<p class="TX">As previously discussed, the library uses the <span class="SANS_TheSansMonoCd_W5Regular_11">file.checkError</span> macro <span class="CodeAnnotation" aria-label="annotation6">❻</span> after <span class="SANS_TheSansMonoCd_W5Regular_11">svc</span> instructions to check error return results. Finally, the code includes external definitions for all the functions that appear in the <i>files.a</i> library <span class="CodeAnnotation" aria-label="annotation7">❼</span>.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h2-271"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">16.5.1 volatiles.S Functions</span></h4>&#13;
<p class="TNI1">The <i>volatiles.S</i> source file contains two functions that save and restore all the volatile registers, <span class="SANS_TheSansMonoCd_W5Regular_11">saveVolatile</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">restoreVolatile</span>:</p>&#13;
<pre id="pre-1213"><code>// volatiles.S&#13;
//&#13;
// saveVolatile and restoreVolatile functions used&#13;
// to preserve volatile registers&#13;
&#13;
            #include    "../aoaa.inc"&#13;
            #include    "files.inc"&#13;
&#13;
            .code&#13;
            .align  2&#13;
&#13;
// saveVolatile&#13;
//&#13;
// A procedure that will save all the volatile&#13;
// registers at the location pointed at by FP&#13;
&#13;
            proc    saveVolatile, public&#13;
            stp     x0,  x1,  [fp], #16&#13;
            stp     x2,  x3,  [fp], #16&#13;
            stp     x4,  x5,  [fp], #16&#13;
            stp     x6,  x7,  [fp], #16&#13;
            stp     x8,  x9,  [fp], #16&#13;
            stp     x10, x11, [fp], #16&#13;
            stp     x12, x13, [fp], #16&#13;
            stp     x14, x15, [fp], #16&#13;
            stp     q0,  q1,  [fp], #32&#13;
            stp     q2,  q3,  [fp], #32&#13;
            stp     q4,  q5,  [fp], #32&#13;
            stp     q6,  q7,  [fp], #32&#13;
            stp     q8,  q9,  [fp], #32&#13;
            stp     q10, q11, [fp], #32&#13;
            stp     q12, q13, [fp], #32&#13;
            stp     q14, q15, [fp], #32&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_906" aria-label="906"/>            ret&#13;
            endp    saveVolatile&#13;
&#13;
// restoreVolatile&#13;
//&#13;
// A procedure that will restore all the volatile&#13;
// registers from the location pointed at by FP&#13;
&#13;
            proc    restoreVolatile, public&#13;
            ldp     x0,  x1,  [fp], #16&#13;
            ldp     x2,  x3,  [fp], #16&#13;
            ldp     x4,  x5,  [fp], #16&#13;
            ldp     x6,  x7,  [fp], #16&#13;
            ldp     x8,  x9,  [fp], #16&#13;
            ldp     x10, x11, [fp], #16&#13;
            ldp     x12, x13, [fp], #16&#13;
            ldp     x14, x15, [fp], #16&#13;
            ldp     q0,  q1,  [fp], #32&#13;
            ldp     q2,  q3,  [fp], #32&#13;
            ldp     q4,  q5,  [fp], #32&#13;
            ldp     q6,  q7,  [fp], #32&#13;
            ldp     q8,  q9,  [fp], #32&#13;
            ldp     q10, q11, [fp], #32&#13;
            ldp     q12, q13, [fp], #32&#13;
            ldp     q14, q15, [fp], #32&#13;
            ret&#13;
            endp    restoreVolatile</code></pre>&#13;
<p class="TX">These functions simply store the registers into successive locations at the address held in the FP register. It is the caller’s responsibility to preserve FP and load it with the address of the <span class="SANS_TheSansMonoCd_W5Regular_11">volatile_save</span> structure before calling <span class="SANS_TheSansMonoCd_W5Regular_11">saveVolatile</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">restoreVolatile</span>. As you can see in <i>volatiles.S</i>, this code does not preserve the value in the FP register.</p>&#13;
<p class="TX">The purpose behind <span class="SANS_TheSansMonoCd_W5Regular_11">saveVolatile</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">restoreVolatile</span> is to overcome the fact that the OS API calls can modify the volatile register set. It’s good assembly language programming style to always preserve register values unless you are explicitly returning a result in a register. The <i>volatiles.S</i> functions allow you to conform to this style even when calling low-level API functions that trash the volatile registers.</p>&#13;
<p class="TX">The one downside of these functions is that you never know which volatile registers a given API function might modify, so you have to preserve them all, even if the API function changes only a few. This, sadly, introduces inefficiency into the code; reading and writing memory is not especially fast. However, not having to worry about volatile registers in your assembly language code is worth the slight efficiency loss. (Moreover, file I/O is usually a relatively slow process to begin with, so if you’re frequently calling file I/O functions, saving and restoring the registers is probably a very small percentage of the running time.)</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_907" aria-label="907"/>The <i>aoaa.inc</i> header file contains the following structure to define the layout of the registers saved by <span class="SANS_TheSansMonoCd_W5Regular_11">saveVolatile</span> and loaded by <span class="SANS_TheSansMonoCd_W5Regular_11">restoreVolatile</span>:</p>&#13;
<pre id="pre-1214"><code>struct  volatile_save&#13;
qword   volatile_save.x0x1&#13;
qword   volatile_save.x2x3&#13;
qword   volatile_save.x4x5&#13;
qword   volatile_save.x6x7&#13;
qword   volatile_save.x8x9&#13;
qword   volatile_save.x10x11&#13;
qword   volatile_save.x12x13&#13;
qword   volatile_save.x14x15&#13;
qword   volatile_save.v0&#13;
qword   volatile_save.v1&#13;
qword   volatile_save.v2&#13;
qword   volatile_save.v3&#13;
qword   volatile_save.v4&#13;
qword   volatile_save.v5&#13;
qword   volatile_save.v6&#13;
qword   volatile_save.v7&#13;
qword   volatile_save.v8&#13;
qword   volatile_save.v9&#13;
qword   volatile_save.v10&#13;
qword   volatile_save.v11&#13;
qword   volatile_save.v12&#13;
qword   volatile_save.v13&#13;
qword   volatile_save.v14&#13;
qword   volatile_save.v15&#13;
ends    volatile_save</code></pre>&#13;
<p class="TX">Because this structure is rather large, <span class="SANS_TheSansMonoCd_W5Regular_11">saveVolatile</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">restoreVolatile</span> do not refer to the individual fields. The offsets to certain members of this structure are too large to encode in the addressing mode offset field of a 32-bit load instruction. Nevertheless, these structures do document where <span class="SANS_TheSansMonoCd_W5Regular_11">saveVolatile</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">restoreVolatile</span> place the data.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h2-272"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">16.5.2 files.S File I/O Functions</span></h4>&#13;
<p class="TNI1">The <i>files.S</i> source file contains the file I/O functions in the library. Because this file is rather long, I’ll break it into pieces and discuss each section in turn. (I won’t include the parameter values you pass to these functions; these are well documented online, or you can use the Unix <span class="SANS_TheSansMonoCd_W5Regular_11">man</span> command for the <span class="SANS_TheSansMonoCd_W5Regular_11">read()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">write()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">open()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">openat()</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">close()</span> functions.)</p>&#13;
<p class="TX">Most of the <i>files.S</i> functions are facade code—that is, they exist to change the environment or parameters of another function (in this case, the OS API functions). These functions preserve volatile registers so that the caller doesn’t have to worry about their preservation; in a few cases (open calls), they automatically set up certain default parameters for the caller; or, in the event of an error, they modify the return codes to produce a consistent result across OSes. The <span class="SANS_TheSansMonoCd_W5Regular_11">file.write</span> function demonstrates <span role="doc-pagebreak" epub:type="pagebreak" id="pg_908" aria-label="908"/>providing a uniform interface (across OSes), preserving the volatile registers, and returning a consistent error code:</p>&#13;
<pre id="pre-1215"><code>// files.S&#13;
//&#13;
// File I/O functions:&#13;
&#13;
            #include    "../aoaa.inc"&#13;
            #include    "files.inc"&#13;
&#13;
            .code&#13;
            .align  2&#13;
&#13;
// file.write&#13;
//&#13;
// Write data to a file handle.&#13;
//&#13;
// X0- File handle&#13;
// X1- Pointer to buffer to write&#13;
// X2- Length of buffer to write&#13;
//&#13;
// Returns:&#13;
//&#13;
// X0- Number of bytes actually written&#13;
//     or -1 if there was an error&#13;
&#13;
            proc    file.write, public&#13;
&#13;
            locals  fw_locals&#13;
            qword   fw_locals.saveX0&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> byte    fw_locals.volSave, volatile_save.size&#13;
            byte    fw_locals.stkspace, 64&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> dword   fw_locals.fpSave&#13;
            endl    fw_locals&#13;
&#13;
            enter   fw_locals.size&#13;
&#13;
            // Preserve all the volatile registers because&#13;
            // the OS API write function might modify them.&#13;
            //&#13;
            // Note: Because fw_locals.volSave is at the&#13;
            // bottom of the activation record, SP just&#13;
            // happens to be pointing at it right now.&#13;
            // Use it to temporarily save FP so you can&#13;
            // pass the address of fw_locals.volSave to&#13;
            // saveVolatile in the FP register.&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> str     fp, [sp]    // fw_locals.fpSave&#13;
            add     fp, fp, #fw_locals.volSave&#13;
            bl      saveVolatile&#13;
            ldr     fp, [sp]    // Restore FP.&#13;
&#13;
            // Okay, now do the write operation (note that&#13;
            // the sys_Write arguments are already sitting&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_909" aria-label="909"/>            // in X0, X1, and X2 upon entry into this&#13;
            // function):&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> mov     svcReg, #sys_Write&#13;
            svc     #OSint&#13;
&#13;
            // Check for error return code:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> file.checkError&#13;
&#13;
            // Restore the volatile registers, except&#13;
            // X0 (because we return the function&#13;
            // result in X0):&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> str     x0, [fp, #fw_locals.saveX0] // Return value.&#13;
            str     fp, [sp]    // fw_locals.fpSave&#13;
            add     fp, fp, #fw_locals.volSave&#13;
            bl      restoreVolatile&#13;
            ldr     fp, [sp]    // Restore FP.&#13;
            ldr     x0, [fp, #fw_locals.saveX0]&#13;
            leave&#13;
            endp    file.write</code></pre>&#13;
<p class="TX">In the activation record, <span class="SANS_TheSansMonoCd_W5Regular_11">file.write</span> reserves space for the volatile register save area <span class="CodeAnnotation" aria-label="annotation1">❶</span> and the special variable <span class="SANS_TheSansMonoCd_W5Regular_11">fw_locals.fpSave</span> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The code will use this variable to preserve the FP register across calls to <span class="SANS_TheSansMonoCd_W5Regular_11">saveVolatile</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">restoreVolatile</span>. Note that <span class="SANS_TheSansMonoCd_W5Regular_11">fw_locals.fpSave</span> appears last in the activation record, so it will be located on the top of the stack when <span class="SANS_TheSansMonoCd_W5Regular_11">file.write</span> builds the activation record. This is a temporary variable that will not be used when system calls use the space on the top of the stack (assuming they do).</p>&#13;
<p class="TX">Next, <span class="SANS_TheSansMonoCd_W5Regular_11">file.write</span> saves all the volatile registers to the volatile save area (<span class="SANS_TheSansMonoCd_W5Regular_11">fw_locals.volSave</span>) <span class="CodeAnnotation" aria-label="annotation3">❸</span>. Because <span class="SANS_TheSansMonoCd_W5Regular_11">saveVolatile</span> expects FP pointing at the save area, this code saves FP to the top of the stack (which just happens to be the location of the <span class="SANS_TheSansMonoCd_W5Regular_11">fw_locals.fpSave</span> variable), loads FP with the address of the <span class="SANS_TheSansMonoCd_W5Regular_11">fw_locals.volSave</span> structure, calls <span class="SANS_TheSansMonoCd_W5Regular_11">saveVolatile</span>, and then restores FP upon return.</p>&#13;
<p class="TX">Note that the code could not reference the <span class="SANS_TheSansMonoCd_W5Regular_11">fw_locals.fpSave</span> variable by using the <span class="SANS_TheSansMonoCd_W5Regular_11">[FP, #fw_locals.fpSave]</span> addressing mode. First, the size of the activation record is too large, and the offset of <span class="SANS_TheSansMonoCd_W5Regular_11">fw_locals.fpSave</span> cannot be encoded into a 32-bit instruction. Second, FP is not pointing at the activation record upon return from <span class="SANS_TheSansMonoCd_W5Regular_11">saveVolatile</span>, so the <span class="SANS_TheSansMonoCd_W5Regular_11">[FP, #fw_locals.fpSave]</span> addressing mode would reference the wrong location (even if the offset weren’t too large).</p>&#13;
<p class="TX">The code then actually calls the API function <span class="CodeAnnotation" aria-label="annotation4">❹</span>. This code is almost trivial, because all the parameters the <span class="SANS_TheSansMonoCd_W5Regular_11">write()</span> function requires are already in the appropriate registers, as they were passed into <span class="SANS_TheSansMonoCd_W5Regular_11">file.write</span> in those registers.</p>&#13;
<p class="TX">The code checks for an error and massages the value in X0 if an error occurred during the write operation <span class="CodeAnnotation" aria-label="annotation5">❺</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">file.write</span> function restores the registers previously saved to <span class="SANS_TheSansMonoCd_W5Regular_11">fw_locals.volSave</span> <span class="CodeAnnotation" aria-label="annotation6">❻</span>. The code and <span role="doc-pagebreak" epub:type="pagebreak" id="pg_910" aria-label="910"/>explanation are almost identical to that at <span class="CodeAnnotation" aria-label="annotation3">❸</span>, with one exception: the value in X0. Because this code returns a function result in X0 and <span class="SANS_TheSansMonoCd_W5Regular_11">restoreVolatile</span> will restore X0 to its original value, this code has to save and restore X0 across the call to <span class="SANS_TheSansMonoCd_W5Regular_11">restoreVolatile</span>. Because the variable <span class="SANS_TheSansMonoCd_W5Regular_11">fw_locals.saveX0</span> appears in the activation record before <span class="SANS_TheSansMonoCd_W5Regular_11">fw_locals.volSave</span>, there is no problem with the offset when using the <span class="SANS_TheSansMonoCd_W5Regular_11">[FP, #fw_locals.saveX0]</span> addressing mode; only the variables appearing after <span class="SANS_TheSansMonoCd_W5Regular_11">fw_locals.volSave</span> will have offsets too large to use in the addressing mode.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">file.read</span> function is almost identical to the <span class="SANS_TheSansMonoCd_W5Regular_11">file.write</span> function:</p>&#13;
<pre id="pre-1216"><code>// files.S (cont.)&#13;
//&#13;
// file.read&#13;
//&#13;
// Read data from a file handle.&#13;
//&#13;
// X0- File handle&#13;
// X1- Pointer to buffer receive data&#13;
// X2- Length of data to read&#13;
//&#13;
// Returns:&#13;
//&#13;
// X0- Number of bytes actually read&#13;
//     or negative value if there was an error&#13;
&#13;
            proc    file.read, public&#13;
&#13;
            locals  fr_locals&#13;
            qword   fr_locals.saveX0&#13;
            byte    fr_locals.volSave, volatile_save.size&#13;
            byte    fr_locals.stkspace, 64&#13;
            dword   fr_locals.fpSave&#13;
            endl    fr_locals&#13;
&#13;
            enter   fr_locals.size&#13;
&#13;
            // Preserve all the volatile registers because&#13;
            // the OS API read function might modify them.&#13;
            //&#13;
            // Note: Because fr_locals.volSave is at the&#13;
            // bottom of the activation record, SP just&#13;
            // happens to be pointing at it right now.&#13;
            // Use it to temporarily save FP so we can&#13;
            // pass the address of fr_locals.volSave to&#13;
            // saveVolatile in the FP register.&#13;
&#13;
            str     fp, [sp]    // fr_locals.fpSave&#13;
            add     fp, fp, #fr_locals.volSave&#13;
            bl      saveVolatile&#13;
            ldr     fp, [sp]    // Restore FP.&#13;
&#13;
            // Okay, now do the read operation (note that&#13;
            // the sys_Read arguments are already sitting&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_911" aria-label="911"/>            // in X0, X1, and X2 upon entry into this&#13;
            // function):&#13;
&#13;
            mov     svcReg, #sys_Read&#13;
            svc     #OSint&#13;
&#13;
            // Check for error return code:&#13;
&#13;
            file.checkError&#13;
&#13;
            // Restore the volatile registers, except&#13;
            // X0 (because we return the function&#13;
            // result in X0):&#13;
&#13;
            str     x0, [fp, #fr_locals.saveX0] // Return value.&#13;
            str     fp, [sp]    // fr_locals.fpSave&#13;
            add     fp, fp, #fr_locals.volSave&#13;
            bl      restoreVolatile&#13;
            ldr     fp, [sp]    // Restore FP.&#13;
            ldr     x0, [fp, #fr_locals.saveX0]&#13;
            leave&#13;
            endp    file.read</code></pre>&#13;
<p class="TX">The only real difference between <span class="SANS_TheSansMonoCd_W5Regular_11">file.read</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">file.write</span> is the function number loaded into the <span class="SANS_TheSansMonoCd_W5Regular_11">svcReg</span> register.</p>&#13;
<p class="TX">Next, <i>files.S</i> provides the code for the <span class="SANS_TheSansMonoCd_W5Regular_11">file.open</span> function:</p>&#13;
<pre id="pre-1217"><code>// files.S (cont.)&#13;
//&#13;
// file.open&#13;
//&#13;
// Open existing file for reading or writing.&#13;
//&#13;
// X0- Pointer to pathname string (zero-terminated)&#13;
// X1- File access flags&#13;
//     (O_RDONLY, O_WRONLY, or O_RDWR)&#13;
//&#13;
// Returns:&#13;
//&#13;
// X0- Handle of open file (or negative value if there&#13;
//     was an error opening the file)&#13;
&#13;
            proc    file.open, public&#13;
&#13;
            locals  fo_locals&#13;
            qword   fo_locals.saveX0&#13;
            byte    fo_locals.volSave, volatile_save.size&#13;
            byte    fo_locals.stkspace, 64&#13;
            dword   fo_locals.fpSave&#13;
            endl    fo_locals&#13;
&#13;
            enter   fo_locals.size&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_912" aria-label="912"/>            // Preserve all the volatile registers because&#13;
            // the OS API open function might modify them:&#13;
&#13;
            str     fp, [sp]    // fo_locals.fpSave&#13;
            add     fp, fp, #fo_locals.volSave&#13;
            bl      saveVolatile&#13;
            ldr     fp, [sp]    // Restore FP.&#13;
&#13;
            // Call the OS API open function:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> mov     svcReg, #sys_Open&#13;
            mov     x2, x1&#13;
            mov     x1, x0&#13;
            mov     x0, #AT_FDCWD&#13;
            mov     x3, #S_RDWR     // Mode, usually ignored&#13;
            svc     #OSint&#13;
&#13;
            // Check for error return code:&#13;
&#13;
            file.checkError&#13;
&#13;
            // Restore the volatile registers, except&#13;
            // X0 (because we return the function&#13;
            // result in X0):&#13;
&#13;
            str     x0, [fp, #fo_locals.saveX0] // Return value.&#13;
            str     fp, [sp]    // fo_locals.fpSave&#13;
            add     fp, fp, #fo_locals.volSave&#13;
            bl      restoreVolatile&#13;
            ldr     fp, [sp]    // Restore FP.&#13;
            ldr     x0, [fp, #fo_locals.saveX0]&#13;
            leave&#13;
            endp    file.open</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">file.open</span> function is identical to <span class="SANS_TheSansMonoCd_W5Regular_11">file.write</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">file.read</span>, except for the call to the OS API function <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Instead of calling the API <span class="SANS_TheSansMonoCd_W5Regular_11">open()</span> function, <span class="SANS_TheSansMonoCd_W5Regular_11">file.open</span> calls the API <span class="SANS_TheSansMonoCd_W5Regular_11">openat()</span> function, a more modern version of <span class="SANS_TheSansMonoCd_W5Regular_11">open()</span>. Here are the C/C++ prototypes for these two functions:</p>&#13;
<pre id="pre-1218"><code>int open(const char *pathname, int flags);&#13;
int openat(int dirfd, const char *pathname, int flags);</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">openat()</span> function has one extra parameter, <span class="SANS_TheSansMonoCd_W5Regular_11">int dirfd</span>. This complicates matters because <span class="SANS_TheSansMonoCd_W5Regular_11">file.open</span> expects the same parameters as the <span class="SANS_TheSansMonoCd_W5Regular_11">open()</span> function; therefore, upon entry to <span class="SANS_TheSansMonoCd_W5Regular_11">file.open</span>, the parameters are sitting in the wrong registers for a call to <span class="SANS_TheSansMonoCd_W5Regular_11">openat()</span>.</p>&#13;
<p class="TX">This is easily fixed by moving X1 to X2 and X0 to X1, then loading X0 with the value <span class="SANS_TheSansMonoCd_W5Regular_11">AT_FDCWD</span> to make the <span class="SANS_TheSansMonoCd_W5Regular_11">openat()</span> function behave like <span class="SANS_TheSansMonoCd_W5Regular_11">open()</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. The <span class="SANS_TheSansMonoCd_W5Regular_11">open()</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">openat()</span> functions have an optional third or fourth parameter (respectively) that lets you set the permissions when creating a new file. The <span class="SANS_TheSansMonoCd_W5Regular_11">file.open</span> function is intended for opening existing files, so you don’t normally specify that extra parameter when calling it. However, just in case <span role="doc-pagebreak" epub:type="pagebreak" id="pg_913" aria-label="913"/>the caller specifies <span class="SANS_TheSansMonoCd_W5Regular_11">O_CREAT</span> in X1, this code sets X3 to a reasonable value (read and write permissions for everyone).</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">file.openNew</span> function is a variant of <span class="SANS_TheSansMonoCd_W5Regular_11">file.open</span> used to create new files:</p>&#13;
<pre id="pre-1219"><code>// files.S (cont.)&#13;
//&#13;
// file.openNew&#13;
//&#13;
// Creates a new file and opens it for writing&#13;
//&#13;
// X0- Pointer to filename string (zero-terminated)&#13;
//&#13;
// Returns:&#13;
//&#13;
// X0- Handle of open file (or negative if there&#13;
//     was an error creating the file)&#13;
&#13;
            proc    file.openNew, public&#13;
&#13;
            locals  fon_locals&#13;
            qword   fon_locals.saveX0&#13;
            byte    fon_locals.volSave, volatile_save.size&#13;
            byte    fon_locals.stkspace, 64&#13;
            dword   fon_locals.fpSave&#13;
            endl    fon_locals&#13;
&#13;
            enter   fon_locals.size&#13;
&#13;
            // Preserve all the volatile registers because&#13;
            // the OS API open function might modify them:&#13;
&#13;
            str     fp, [sp]    // fon_locals.fpSave&#13;
            add     fp, fp, #fon_locals.volSave&#13;
            bl      saveVolatile&#13;
            ldr     fp, [sp]    // Restore FP.&#13;
&#13;
            // Call the OS API open function:&#13;
&#13;
            mov     svcReg, #sys_Open&#13;
            mov     x2, #O_CREAT+O_WRONLY+O_EXCL&#13;
            mov     x1, x0&#13;
            mov     x0, #AT_FDCWD&#13;
            mov     x3, #S_RDWR // User/Group has RW perms.&#13;
            svc     #OSint&#13;
&#13;
            // Check for error return code:&#13;
&#13;
            file.checkError&#13;
&#13;
            // Restore the volatile registers, except&#13;
            // X0 (because we return the function&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_914" aria-label="914"/>            // result in X0):&#13;
&#13;
            str     x0, [fp, #fon_locals.saveX0] // Return value.&#13;
            str     fp, [sp]    // w_locals.fpSave&#13;
            add     fp, fp, #fon_locals.volSave&#13;
            bl      restoreVolatile&#13;
            ldr     fp, [sp]    // Restore FP.&#13;
            ldr     x0, [fp, #fon_locals.saveX0]&#13;
            leave&#13;
            endp    file.openNew</code></pre>&#13;
<p class="TX">The only difference between <span class="SANS_TheSansMonoCd_W5Regular_11">file.openNew</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">file.open</span> is that <span class="SANS_TheSansMonoCd_W5Regular_11">file .openNew</span> expects just a single parameter (the pathname in X0) and automatically supplies the flag values (<span class="SANS_TheSansMonoCd_W5Regular_11">O_CREAT+O_WRONLY+O_EXCL</span>) for the call to <span class="SANS_TheSansMonoCd_W5Regular_11">openat()</span>.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">file.close</span> function is the final file I/O function in the <i>files.S</i> source file:</p>&#13;
<pre id="pre-1220"><code>// files.S (cont.)&#13;
//&#13;
// file.close&#13;
//&#13;
// Closes a file specified by a file handle&#13;
//&#13;
// X0- Handle of file to close&#13;
&#13;
            proc    file.close, public&#13;
&#13;
            locals  fc_locals&#13;
            qword   fc_locals.saveX0&#13;
            byte    fc_locals.volSave, volatile_save.size&#13;
            byte    fc_locals.stkspace, 64&#13;
            dword   fc_locals.fpSave&#13;
            endl    fc_locals&#13;
&#13;
            enter   fc_locals.size&#13;
&#13;
            // Preserve all the volatile registers because&#13;
            // the OS API open function might modify them:&#13;
&#13;
            str     fp, [sp]    // fc_locals.fpSave&#13;
            add     fp, fp, #fc_locals.volSave&#13;
            bl      saveVolatile&#13;
            ldr     fp, [sp]    // Restore FP.&#13;
&#13;
            // Call the OS API close function (handle is&#13;
            // already in X0):&#13;
&#13;
            mov     svcReg, #sys_Close&#13;
            svc     #OSint&#13;
&#13;
            // Check for error return code:&#13;
&#13;
            file.checkError&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_915" aria-label="915"/>            // Restore the volatile registers, except&#13;
            // X0 (because we return the function&#13;
            // result in X0):&#13;
&#13;
            str     x0, [fp, #fc_locals.saveX0] // Return value.&#13;
            str     fp, [sp]    // w_locals.fpSave&#13;
            add     fp, fp, #fc_locals.volSave&#13;
            bl      restoreVolatile&#13;
            ldr     fp, [sp]    // Restore FP.&#13;
            ldr     x0, [fp, #fc_locals.saveX0]&#13;
            leave&#13;
            endp    file.close</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">file.close</span> function expects a file descriptor in X0 (returned by a successful call to <span class="SANS_TheSansMonoCd_W5Regular_11">file.open</span> or <span class="SANS_TheSansMonoCd_W5Regular_11">file.openNew</span>) and passes that descriptor along to the API <span class="SANS_TheSansMonoCd_W5Regular_11">close()</span> function. Otherwise, it’s similar in form to the <span class="SANS_TheSansMonoCd_W5Regular_11">file.read</span> and <span class="SANS_TheSansMonoCd_W5Regular_11">file.write</span> functions.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h4 class="H2" id="sec11"><span id="h2-273"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">16.5.3 stdio.S Functions</span></h4>&#13;
<p class="TNI1">The last source file in the files library is the <i>stdio.S</i> file. This module contains functions you can use to read and write strings on the console (standard I/O) device. Again, because of its size, I’ve broken this source file into more easily digestible pieces.</p>&#13;
<p class="TX">First, the <span class="SANS_TheSansMonoCd_W5Regular_11">stdout.puts</span> function writes a (zero-terminated) string to the standard output device (usually the display console):</p>&#13;
<pre id="pre-1221"><code>// stdio.S&#13;
//&#13;
// Standard input and standard output functions:&#13;
&#13;
            #include    "../aoaa.inc"&#13;
            #include    "files.inc"&#13;
            #include    &lt;sys/syscall.h&gt;&#13;
&#13;
            .code&#13;
            .align  2&#13;
&#13;
// stdout.puts&#13;
//&#13;
// Outputs a zero-terminated string to standard output device&#13;
//&#13;
// X0- Address of string to print to standard output&#13;
&#13;
            proc    stdout.puts, public&#13;
&#13;
            locals  lcl_puts&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> qword   lcl_puts.saveX0X1&#13;
            dword   lcl_puts.saveX2&#13;
            byte    lcl_puts.stkSpace, 64&#13;
            endl    lcl_puts&#13;
&#13;
            enter   lcl_puts.size&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_916" aria-label="916"/>            stp     x0, x1, [fp, #lcl_puts.saveX0X1]&#13;
            str     x2,     [fp, #lcl_puts.saveX2]&#13;
&#13;
            mov     x1, x0&#13;
&#13;
// Compute the length of the string:&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation2">❷</span> lenLp:      ldrb    w2, [x1], #1&#13;
            cbnz    w2, lenLp&#13;
            sub     x2, x1, x0  // Compute length&#13;
&#13;
            // Call file_write to print the string:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> mov     x1, x0&#13;
            mov     x0, #stdout&#13;
            bl      file.write&#13;
&#13;
            // Return to caller:&#13;
&#13;
            ldr     x2,     [fp, #lcl_puts.saveX2]&#13;
            ldp     x0, x1, [fp, #lcl_puts.saveX0X1]&#13;
            leave&#13;
            endp    stdout.puts</code></pre>&#13;
<p class="TX">Note that this code does not preserve all the volatile registers <span class="CodeAnnotation" aria-label="annotation1">❶</span>, because the <span class="SANS_TheSansMonoCd_W5Regular_11">stdout.puts</span> function does not directly call an OS API function that might modify the registers. Therefore, this function preserves only the actual registers it uses.</p>&#13;
<p class="TX">This function will call <span class="SANS_TheSansMonoCd_W5Regular_11">file.write</span> to write the string to the standard output device. The <span class="SANS_TheSansMonoCd_W5Regular_11">file.write</span> function requires three parameters: a file descriptor (the <span class="SANS_TheSansMonoCd_W5Regular_11">stdout</span> constant works fine for the descriptor value), the address of the data (string) to write, and a length value. Although <span class="SANS_TheSansMonoCd_W5Regular_11">stdout.put</span> has the address of the string in X0, there is no length parameter. Therefore this code computes the length of the zero-terminated string whose address appears in X0 <span class="CodeAnnotation" aria-label="annotation2">❷</span>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Scanning the string a byte at a time is a lame way to compute string length, but I’ve done so here because it is simpler than the alternative. If this really bothers you, you can link in the C stdlib</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">strlen()</span> <i>function. However, keep in mind that making the system call and drawing all those pixels on the screen to print the string is many orders of magnitude slower than this string-length calculation, so you won’t save much time by using faster string-length computation code.</i></p>&#13;
<p class="TX">Once the length is computed, the <span class="SANS_TheSansMonoCd_W5Regular_11">stdout.put</span> function calls <span class="SANS_TheSansMonoCd_W5Regular_11">file.write</span> to actually print the string to the standard output device <span class="CodeAnnotation" aria-label="annotation3">❸</span>. After restoring the few registers this code changed, the function returns.</p>&#13;
<p class="TX">Technically, <span class="SANS_TheSansMonoCd_W5Regular_11">file.write</span> could return an error code (which <span class="SANS_TheSansMonoCd_W5Regular_11">stdout.puts</span> ignores and doesn’t return to its caller). However, the likelihood of such an error is low, so this code ignores errors. One likely problem could be if standard output were redirected to a disk file and there was an issue writing <span role="doc-pagebreak" epub:type="pagebreak" id="pg_917" aria-label="917"/>to the disk, so this bug is worth addressing if this routine finds its way into production code; I chose not to address this here to keep the code cleaner (and because of the extremely low probability of occurrence).</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">stdout.newLn</span> function is identical to <span class="SANS_TheSansMonoCd_W5Regular_11">stdout.puts</span>, except that it writes a fixed string (a newline character) to the standard output device:</p>&#13;
<pre id="pre-1222"><code>// stdio.S (cont.)&#13;
//&#13;
// stdout.newLn&#13;
//&#13;
// Outputs a newline sequence to the standard output device:&#13;
&#13;
stdout.nl:  .ascii  "\n"&#13;
nl.len      =       .-stdout.nl&#13;
            .byte   0&#13;
            .align  2&#13;
&#13;
            proc    stdout.newLn, public&#13;
            locals  lcl_nl&#13;
            qword   lcl_nl.saveX0X1&#13;
            dword   lcl_nl.saveX2&#13;
            byte    lcl_nl.stkSpace, 64&#13;
            endl    lcl_nl&#13;
&#13;
            enter   lcl_nl.size&#13;
            stp     x0, x1, [fp, #lcl_nl.saveX0X1]&#13;
            str     x2,     [fp, #lcl_nl.saveX2]&#13;
&#13;
            lea     x1, stdout.nl&#13;
            mov     x2, #nl.len&#13;
            mov     x0, stdout&#13;
            bl      file.write&#13;
&#13;
            ldr     x2,     [fp, #lcl_nl.saveX2]&#13;
            ldp     x0, x1, [fp, #lcl_nl.saveX0X1]&#13;
            leave&#13;
            endp    stdout.newLn</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">stdin.read</span> function is the input complement to <span class="SANS_TheSansMonoCd_W5Regular_11">stdout.write</span>:</p>&#13;
<pre id="pre-1223"><code>// stdio.S (cont.)&#13;
//&#13;
// stdin.read&#13;
//&#13;
// Reads data from the standard input&#13;
//&#13;
// X0- Buffer to receive data&#13;
// X1- Buffer count (note that data input will&#13;
//     stop on a newline character if that&#13;
//     comes along before X1 characters have&#13;
//     been read)&#13;
//&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_918" aria-label="918"/>// Returns:&#13;
//&#13;
// X0- Negative value if error, bytes read if successful&#13;
&#13;
             proc    stdin.read, public&#13;
             locals  sr_locals&#13;
             qword   sr_locals.saveX1X2&#13;
             byte    sr_locals.stkspace, 64&#13;
             dword   sr_locals.fpSave&#13;
             endl    sr_locals&#13;
&#13;
             enter   sr_locals.size&#13;
             stp     x1, x2, [fp, #sr_locals.saveX1X2]&#13;
&#13;
             // Call the OS API read function:&#13;
&#13;
           <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> mov     svcReg, #sys_Read&#13;
             mov     x2, x1&#13;
             mov     x1, x0&#13;
             mov     x0, #stdin&#13;
             svc     #OSint&#13;
&#13;
             file.checkError&#13;
&#13;
             ldp     x1, x2, [fp, #sr_locals.saveX1X2]&#13;
             leave&#13;
             endp    stdin.read</code></pre>&#13;
<p class="TX">When you pass <span class="SANS_TheSansMonoCd_W5Regular_11">stdin.read</span> a buffer’s address and size, it will read up to that number of characters from the standard input device (usually the keyboard) and place those characters into the buffer. This function will stop reading characters when it either reads the specified number of characters or encounters a newline character (line feed) in the input.</p>&#13;
<p class="TX">The twist to this otherwise straightforward code is that it has to move the address and byte count around <span class="CodeAnnotation" aria-label="annotation1">❶</span> prior to calling the OS <span class="SANS_TheSansMonoCd_W5Regular_11">read()</span> function. This is because the buffer address needs to go in X1 and X2 when calling <span class="SANS_TheSansMonoCd_W5Regular_11">read()</span>, and the function has to load the standard input file descriptor into X0.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">stdin.getc</span> function is a one-character version of <span class="SANS_TheSansMonoCd_W5Regular_11">stdin.read</span>:</p>&#13;
<pre id="pre-1224"><code>// stdio.S (cont.)&#13;
//&#13;
// stdin_getc&#13;
//&#13;
// Read a single character from the standard input.&#13;
// Returns character in X0 register&#13;
&#13;
            proc    stdin.getc, public&#13;
            locals  sgc_locals&#13;
            qword   sgc_locals.saveX1X2&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> byte    sgc_buf, 16&#13;
            byte    sgc_locals.stkspace, 64&#13;
            endl    sgc_locals&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_919" aria-label="919"/>            enter   sgc_locals.size&#13;
            stp     x1, x2, [fp, #sgc_locals.saveX1X2]&#13;
&#13;
            // Initialize return value to all 0s:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> str     xzr, [fp, #sgc_buf]&#13;
&#13;
            // Call the OS API read function to read&#13;
            // a single character:&#13;
&#13;
            mov     svcReg, #sys_Read&#13;
            mov     x0, #stdin&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> add     x1, fp, #sgc_buf&#13;
            mov     x2, #1&#13;
            svc     #OSint&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> file.checkError&#13;
            cmp     x0, #0&#13;
            bpl     noError&#13;
&#13;
            // If there was an error, return the&#13;
            // error code in X0 rather than a char:&#13;
&#13;
            str     x0, [fp, #sgc_buf]&#13;
&#13;
noError:&#13;
            ldp     x1, x2, [fp, #sgc_locals.saveX1X2]&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> ldr     x0, [fp, #sgc_buf]&#13;
            leave&#13;
&#13;
            endp    stdin.getc</code></pre>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">stdin.getc</span> function returns the character it reads in X0 rather than placing it in a buffer. This function has to reserve storage for a buffer <span class="CodeAnnotation" aria-label="annotation1">❶</span> because the call to the API <span class="SANS_TheSansMonoCd_W5Regular_11">read()</span> function requires a buffer. Technically, the buffer needs to be only eight characters long, but this function reserves 16 bytes just to help keep the stack 16-byte aligned. This code initializes the first 8 bytes of the buffer to 0 <span class="CodeAnnotation" aria-label="annotation2">❷</span>. The function will actually return all 8 bytes (even though the read operation stores only a single byte into the buffer). This function computes the address of the buffer to pass to the API <span class="SANS_TheSansMonoCd_W5Regular_11">read()</span> function <span class="CodeAnnotation" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">If, somehow, the call to the API <span class="SANS_TheSansMonoCd_W5Regular_11">read()</span> function returns an error, the code will store the negative error return code into the first 8 bytes of the buffer <span class="CodeAnnotation" aria-label="annotation4">❹</span>. Before returning, <span class="SANS_TheSansMonoCd_W5Regular_11">stdin.getc</span> loads the 8 bytes at the beginning of the buffer into X0 and returns that value (this is either the single character plus seven 0s, a UTF-8 value, or the 8-byte negative error code) <span class="CodeAnnotation" aria-label="annotation5">❺</span>.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>The</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">stdin.get</span> <i>function does not read a single character from the keyboard and then immediately return to the caller. Instead, the OS will read a whole line of text from the</i> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_920" aria-label="920"/><i>keyboard and return the first character of that line. Successive calls to</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">stdin.get</span> <i>will read the remaining characters from that internal OS buffer. This is standard Unix behavior, not a specific feature of this function.</i></p>&#13;
<p class="TX">The last function in the <i>stdio.S</i> file is <span class="SANS_TheSansMonoCd_W5Regular_11">stdin.readln</span>:</p>&#13;
<pre id="pre-1225"><code>// stdio.S (cont.)&#13;
//&#13;
// stdin.readln&#13;
//&#13;
// Reads a line of text from the user.&#13;
// Automatically processes backspace characters&#13;
// (deleting previous characters, as appropriate).&#13;
// Line returned from function is zero-terminated&#13;
// and does not include the ENTER key code (carriage&#13;
// return) or line feed.&#13;
//&#13;
// X0- Buffer to place line of text read from user&#13;
// X1- Maximum buffer length&#13;
//&#13;
// Returns:&#13;
//&#13;
// X0- Number of characters read from the user&#13;
//     (does not include ENTER key)&#13;
&#13;
            proc    stdin.readln, public&#13;
            locals  srl_locals&#13;
            qword   srl_locals.saveX1X2&#13;
            dword   srl_locals.saveX3&#13;
            byte    srl_buf, 16&#13;
            byte    srl_locals.stkspace, 64&#13;
            endl    srl_locals&#13;
&#13;
            enter   srl_locals.size&#13;
            stp     x1, x2, [fp, #srl_locals.saveX1X2]&#13;
            str     x3,     [fp, #srl_locals.saveX3]&#13;
&#13;
            mov     x3, x0          // Buf ptr in X3&#13;
            mov     x2, #0          // Character count&#13;
            cbz     x1, exitRdLn    // Bail if zero chars.&#13;
&#13;
            sub     x1, x1, #1      // Leave room for 0 byte.&#13;
readLp:&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> bl      stdin.getc      // Read 1 char from stdin.&#13;
&#13;
            cmp     w0, wzr         // Check for error.&#13;
            bmi     exitRdLn&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> cmp     w0, #cr         // Check for newline code.&#13;
            beq     lineDone&#13;
&#13;
            cmp     w0, #lf         // Check for newline code.&#13;
            beq     lineDone&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_921" aria-label="921"/>          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> cmp     w0, #bs         // Handle backspace character.&#13;
            bne     addChar&#13;
&#13;
// If a backspace character came along, remove the previous&#13;
// character from the input buffer (assuming there is a&#13;
// previous character):&#13;
&#13;
            cmp     x2, #0          // Ignore BS character if no&#13;
            beq     readLp          // chars in the buffer.&#13;
            sub     x2, x2, #1&#13;
            b.al    readLp&#13;
&#13;
// If a normal character (that we return to the caller),&#13;
// add the character to the buffer if there is room&#13;
// for it (ignore the character if the buffer is full):&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation4">❹</span> addChar:    cmp     x2, x1          // See if you're at the&#13;
            bhs     readLp          // end of the buffer.&#13;
            strb    w0, [x3, x2]    // Save char to buffer.&#13;
            add     x2, x2, #1&#13;
            b.al    readLp&#13;
&#13;
// When the user presses the ENTER key (or line feed)&#13;
// during input, come down here and zero-terminate the string:&#13;
&#13;
lineDone:&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> strb    wzr, [x3, x2]&#13;
&#13;
exitRdLn:   mov     x0, x2          // Return char cnt in X0.&#13;
            ldp     x1, x2, [fp, #srl_locals.saveX1X2]&#13;
            ldr     x3,     [fp, #srl_locals.saveX3]&#13;
            leave&#13;
            endp    stdin.readln</code></pre>&#13;
<p class="TX">This function, intended mainly for interactive use, reads a line of text from the keyboard with a modicum of editing (handling backspace characters), placing those characters into a buffer. In many respects, it works just like <span class="SANS_TheSansMonoCd_W5Regular_11">stdin.read</span>, except that pressing <small>BACKSPACE</small> deletes a character from the input buffer rather than returning the backspace ASCII code as a character of the buffer.</p>&#13;
<p class="TX">This function repeatedly calls <span class="SANS_TheSansMonoCd_W5Regular_11">stdin.getc</span> <span class="CodeAnnotation" aria-label="annotation1">❶</span>, reading one character at a time. If <span class="SANS_TheSansMonoCd_W5Regular_11">stdin.getc</span> returns an error (a negative return value), this function immediately returns, passing the error code on to its caller.</p>&#13;
<p class="TX">The code checks whether the input line is complete by comparing the character against the ASCII codes for a carriage return or newline (line feed) <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If the character matches one of these two, the code exits the loop.</p>&#13;
<p class="TX">The <span class="SANS_TheSansMonoCd_W5Regular_11">stdin.readln</span> function then checks for a backspace character <span class="CodeAnnotation" aria-label="annotation3">❸</span>. If it is a backspace, this function will delete the previous character from the input buffer (if there was one). If the character is not a backspace, the code branches down to <span class="CodeAnnotation" aria-label="annotation4">❹</span>, where it appends the character to the end of the buffer.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_922" aria-label="922"/>When the function finds a carriage return or line feed in the input stream, it transfers control to <span class="CodeAnnotation" aria-label="annotation5">❺</span>, where it zero-terminates the string and returns the number of characters actually read in the X0 register.</p>&#13;
<p class="TX">Beyond processing backspace characters, there are two additional differences between reading a line of text with <span class="SANS_TheSansMonoCd_W5Regular_11">stdin.readln</span> and simply calling <span class="SANS_TheSansMonoCd_W5Regular_11">stdin.read</span>. First, <span class="SANS_TheSansMonoCd_W5Regular_11">stdin.readln</span> will zero-terminate the string read into the buffer. Second, <span class="SANS_TheSansMonoCd_W5Regular_11">stdin.readln</span> does not place the newline character (or carriage return) in the buffer.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
&#13;
<h4 class="H2" id="sec12"><span id="h2-274"/><span class="SANS_Futura_Std_Bold_Condensed_Oblique_11">16.5.4 File I/O Demo Application</span></h4>&#13;
<p class="TNI1">The simple application in Listing 16-4 demonstrates the use of the <i>file.a</i> library.</p>&#13;
<pre id="pre-1226"><code>// Listing16-4.S&#13;
//&#13;
// File I/O demonstration:&#13;
&#13;
            #include    "aoaa.inc"&#13;
            #include    "files/files.inc"&#13;
            #include    &lt;sys/syscall.h&gt;&#13;
&#13;
            #if isMacOS&#13;
&#13;
// Map main to "_main" as macOS requires&#13;
// underscores in front of global names&#13;
// (inherited from C code, anyway).&#13;
&#13;
#define main _main&#13;
sys_Exit    =   SYS_exit&#13;
&#13;
            #else&#13;
&#13;
sys_Exit    =   __NR_exit&#13;
&#13;
            #endif&#13;
&#13;
            .data&#13;
&#13;
// Buffer to hold line of text read from user:&#13;
&#13;
inputLn:    .space  256, (0)&#13;
inputLn.len =       .-inputLn&#13;
&#13;
// Buffer to hold data read from a file:&#13;
&#13;
fileBuffer: .space  4096, (0)&#13;
fileBuffer.len =    .-fileBuffer&#13;
&#13;
// Prompt the user for a filename:&#13;
&#13;
prompt:     .ascii  "Enter (text) filename:"&#13;
prompt.len  =       .-prompt&#13;
            .byte   0&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_923" aria-label="923"/>// Error message string:&#13;
&#13;
badOpenMsg: wastr   "Could not open file\n"&#13;
&#13;
OpenMsg:    wastr   "Opening file: "&#13;
&#13;
            .code&#13;
&#13;
// Here is the asmMain function:&#13;
&#13;
            proc    main, public&#13;
            locals  am&#13;
            dword   am.inHandle&#13;
            byte    am_stkSpace, 64&#13;
            endl    am&#13;
&#13;
            enter   am.size&#13;
&#13;
// Get a filename from the user:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> lea     x0, prompt&#13;
            bl      stdout.puts&#13;
&#13;
            lea     x0, inputLn&#13;
            mov     x1, #inputLn.len&#13;
            bl      stdin.readln&#13;
            cmp     x0, #0&#13;
            bmi     badOpen&#13;
&#13;
            lea     x0, OpenMsg&#13;
            bl      stdout.puts&#13;
            lea     x0, inputLn&#13;
            bl      stdout.puts&#13;
            bl      stdout.newLn&#13;
&#13;
// Open the file, read its contents, and display&#13;
// the contents to the standard output device:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> lea     x0, inputLn&#13;
            mov     x1, #O_RDONLY&#13;
            bl      file.open&#13;
            cmp     x0, xzr&#13;
            ble     badOpen&#13;
&#13;
            str     x0, [fp, #am.inHandle]&#13;
&#13;
// Read the file 4,096 bytes at a time:&#13;
&#13;
readLoop:&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation3">❸</span> ldr     x0, [fp, #am.inHandle]&#13;
            lea     x1, fileBuffer&#13;
            mov     x2, fileBuffer.len&#13;
            bl      file.read&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_924" aria-label="924"/>            // Quit if there was an error or&#13;
            // file.read read 0 bytes:&#13;
&#13;
            cmp     x0, xzr&#13;
            ble     allDone&#13;
&#13;
            // Write the data just read to the&#13;
            // stdout device:&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> mov     x2, x0        // Bytes to write&#13;
            lea     x1, fileBuffer&#13;
            mov     x0, #stdout&#13;
            bl      file.write&#13;
            b.al    readLoop&#13;
&#13;
badOpen:    lea     x0, badOpenMsg&#13;
            bl      stdout.puts&#13;
&#13;
allDone:&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> ldr     x0, [fp, #am.inHandle]&#13;
            bl      file.close&#13;
&#13;
            // Return error code 0 to the OS:&#13;
&#13;
            mov     svcReg, #sys_Exit&#13;
            mov     x0, #0&#13;
            svc     #OSint&#13;
            endp    main</code></pre>&#13;
<p class="TX">This program begins by prompting the user to enter a filename <span class="CodeAnnotation" aria-label="annotation1">❶</span>. It reads this filename from the user and then echoes the filename to the display. The program opens the file and saves away the file handle that <span class="SANS_TheSansMonoCd_W5Regular_11">file .open</span> returns <span class="CodeAnnotation" aria-label="annotation2">❷</span>. If an error occurred opening the file, the program drops down to the <span class="SANS_TheSansMonoCd_W5Regular_11">badOpen</span> label, prints an error message, and quits.</p>&#13;
<p class="TX">Next, the program continuously reads a block of (up to) 4,096 bytes until the end of the file is reached (or another error occurs) <span class="CodeAnnotation" aria-label="annotation3">❸</span>. When reading from a file, the <span class="SANS_TheSansMonoCd_W5Regular_11">file.read</span> function will read the full 4,096 bytes, ignoring any newline characters (it stops on newlines only when reading from the standard input). If this function reads 0 bytes from the input, it has reached the end of the file, and the loop exits.</p>&#13;
<p class="TX">The code then writes the bytes read to the standard output device <span class="CodeAnnotation" aria-label="annotation4">❹</span>, using the return value from <span class="SANS_TheSansMonoCd_W5Regular_11">file.read</span> as the byte count on the call to <span class="SANS_TheSansMonoCd_W5Regular_11">file .write</span>. This is because the last block of bytes read from the file might not be 4,096 bytes in length; if it read fewer than 4,096 bytes, the next read will return 0 bytes and the operation will be complete. Once the program completes, it closes the file and quits <span class="CodeAnnotation" aria-label="annotation5">❺</span>&gt;.</p>&#13;
<p class="TX">Here’s the makefile that will build the program in Listing 16-4:</p>&#13;
<pre id="pre-1227"><code># Listing16-4.mak&#13;
#&#13;
# makefile to build the Listing16-4.S file&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_925" aria-label="925"/>unamestr=`uname`&#13;
&#13;
Listing16-4:Listing16-4.S aoaa.inc files/files.inc files.a&#13;
    cd files; make -f files.mak; cd ..&#13;
    g++ -D$(unamestr) -o Listing16-4 Listing16-4.S files.a&#13;
&#13;
clean:&#13;
    rm -f Listing16-4.o&#13;
    rm -f Listing16-4&#13;
    rm -f file.a&#13;
    cd files; make -f files.mak clean; cd ..</code></pre>&#13;
<p class="TX">Here’s a sample build operation and execution of the program:</p>&#13;
<pre id="pre-1228"><code>% <span class="SANS_TheSansMonoCd_W7Bold_11">make -f Listing16-4.mak clean</span>&#13;
rm -f Listing16-4.o&#13;
rm -f Listing16-4&#13;
rm -f file.a&#13;
cd files; make -f files.mak clean; cd ..&#13;
rm -f files.o&#13;
rm -f volatile.o&#13;
rm -f stdio.o&#13;
rm -f files.a&#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">make -f Listing16-4.mak</span>&#13;
cd files; make -f files.mak; cd ..&#13;
g++ -c -D`uname` files.S&#13;
g++ -c -D`uname` stdio.S&#13;
g++ -c -D`uname` volatile.S&#13;
ar rcs files.a files.o stdio.o volatile.o&#13;
cp files.a ..&#13;
g++ -D`uname` -o Listing16-4 Listing16-4.S files.a&#13;
% <span class="SANS_TheSansMonoCd_W7Bold_11">./Listing16-4</span>&#13;
Enter (text) filename:Listing16-4.mak&#13;
Opening file: Listing16-4.mak&#13;
# listing16-4.mak&#13;
#&#13;
# makefile to build the Listing16-4.S file.&#13;
&#13;
unamestr=`uname`&#13;
&#13;
Listing16-4:Listing16-4.S aoaa.inc files/files.inc files.a&#13;
    cd files; make -f files.mak; cd ..&#13;
    g++ -D$(unamestr) -o Listing16-4 Listing16-4.S files.a&#13;
&#13;
clean:&#13;
    rm -f Listing16-4.o&#13;
    rm -f Listing16-4&#13;
    rm -f file.a&#13;
    cd files; make -f files.mak clean; cd ..</code></pre>&#13;
<p class="TX">I’ve used the <i>Listing16-4.mak</i> text file as the input for this run of the program.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_926" aria-label="926"/>&#13;
<h3 class="H1" id="sec13"><span id="h1-165"/><span class="SANS_Futura_Std_Bold_B_11">16.6 Calling System Library Functions Under macOS</span></h3>&#13;
<p class="TNI1">As I mentioned earlier, Apple frowns on applications that make direct calls to the macOS kernel via the <span class="SANS_TheSansMonoCd_W5Regular_11">svc</span> instruction. The company claims the proper way to make those calls is via the C library code Apple has provided. This chapter has shown you the low-level calls because, well, that was the purpose of this chapter; if you’re the one writing the C library code (or similar library code that interfaces to the OS), you need to know this information. However, I would be remiss if I didn’t show you how Apple recommends interfacing applications with macOS.</p>&#13;
<p class="TX">I’ve created a variant of the <i>files.a</i> library, stored in the <i>files-macOS</i> directory in the online source code set, that links in the kernel <span class="SANS_TheSansMonoCd_W5Regular_11">read()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">write()</span>, <span class="SANS_TheSansMonoCd_W5Regular_11">open()</span>, and <span class="SANS_TheSansMonoCd_W5Regular_11">close()</span> functions. To avoid redundancy, I don’t print all that code in this chapter, but I’ll list the <span class="SANS_TheSansMonoCd_W5Regular_11">file.write</span> function here to give you an idea of the simplicity of the change:</p>&#13;
<pre id="pre-1229"><code>// file.write&#13;
//&#13;
// Write data to a file handle.&#13;
//&#13;
// X0- File handle&#13;
// X1- Pointer to buffer to write&#13;
// X2- Length of buffer to write&#13;
//&#13;
// Returns:&#13;
//&#13;
// X0- Number of bytes actually written&#13;
//     or -1 if there was an error&#13;
&#13;
            proc    file.write, public&#13;
            locals  fw_locals&#13;
            qword   fw_locals.saveX0&#13;
            byte    fw_locals.volSave, volatile_save.size&#13;
            byte    fw_locals.stkspace, 64&#13;
            dword   fw_locals.fpSave&#13;
            endl    fw_locals&#13;
&#13;
            enter   fw_locals.size&#13;
&#13;
            // Preserve all the volatile registers because&#13;
            // the OS API write function might modify them.&#13;
            //&#13;
            // Note: because fw_locals.volSave is at the&#13;
            // bottom of the activation record, SP just&#13;
            // happens to be pointing at it right now.&#13;
            // Use it to temporarily save FP so you can&#13;
            // pass the address of w_locals.volSave to&#13;
            // saveVolatile in the FP register.&#13;
&#13;
            str     fp, [sp]    // fw_locals.fpSave&#13;
            add     fp, fp, #fw_locals.volSave&#13;
            bl      saveVolatile&#13;
            ldr     fp, [sp]    // Restore FP.&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_927" aria-label="927"/>            // Okay, now do the write operation (note that&#13;
            // the write arguments are already sitting&#13;
            // in X0, X1, and X2 upon entry into this&#13;
            // function):&#13;
&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation1">❶</span> bl      _write&#13;
&#13;
            // Check for error return code:&#13;
&#13;
            file.checkError&#13;
&#13;
            // Restore the volatile registers, except&#13;
            // X0 (because we return the function&#13;
            // result in X0):&#13;
&#13;
            str     x0, [fp, #fw_locals.saveX0] // Return value.&#13;
            str     fp, [sp]    // w_locals.fpSave&#13;
            add     fp, fp, #fw_locals.volSave&#13;
            bl      restoreVolatile&#13;
            ldr     fp, [sp]    // Restore FP.&#13;
            ldr     x0, [fp, #fw_locals.saveX0]&#13;
            leave&#13;
            endp    file.write</code></pre>&#13;
<p class="TX">The only difference between this version of <span class="SANS_TheSansMonoCd_W5Regular_11">file.write</span> and the version in the original <i>files.a</i> library is that I’ve replaced the <span class="SANS_TheSansMonoCd_W5Regular_11">svc</span> instruction sequence with a call to the <span class="SANS_TheSansMonoCd_W5Regular_11">_write()</span> function <span class="CodeAnnotation" aria-label="annotation1">❶</span>.</p>&#13;
<p class="TX">The new <i>files.a</i> library also includes a couple of changes to the <i>files.inc</i> header file. The most important change is to the <span class="SANS_TheSansMonoCd_W5Regular_11">file.checkError</span> macro:</p>&#13;
<pre id="pre-1230"><code>            .macro  file.checkError&#13;
&#13;
            cmp     x0, #-1&#13;
            bne     0f&#13;
            getErrno&#13;
            neg     x0, x0&#13;
0:&#13;
            .endm</code></pre>&#13;
<p class="TX">The macOS <span class="SANS_TheSansMonoCd_W5Regular_11">_write()</span> function returns –1 when an error occurs, since C code can’t test the carry flag. Therefore, I modified <span class="SANS_TheSansMonoCd_W5Regular_11">file.checkError</span> to handle errors the same way Linux does.</p>&#13;
<p class="TX">I had to build the <i>files-macOS</i> library first (to create a new version of <i>file.a</i>, replacing the version that made direct OS calls), then made <i>Listing16-4.S</i> by using the <i>file.a</i> library from <i>files-macOS</i>. The program ran the same as the original file I/O example from the previous section.</p>&#13;
<p class="TX">In theory, you could use this same approach with Linux, creating slightly more portable code between the two OSes. However, the <span class="SANS_TheSansMonoCd_W5Regular_11">svc</span> API interface under Linux is well defined and documented, so there is no reason not to call the API functions directly.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_928" aria-label="928"/>&#13;
<h3 class="H1" id="sec14"><span id="h1-166"/><span class="SANS_Futura_Std_Bold_B_11">16.7 Creating Assembly Applications Without GCC</span></h3>&#13;
<p class="TNI1">Throughout this chapter, I’ve continued to use GCC to assemble and link the assembly language files. That’s because most of the example code in this chapter includes <i>aoaa.inc</i>, and that file depends on the CPP. You might view this approach with suspicion, thinking GCC might be sneaking some C code into your program. And you would be right: even when you build a “pure” assembly language program with GCC, it links in some code to set up the environment prior to the execution of your program (so that if you do call any C library code, the environment has been set up for it).</p>&#13;
<p class="TX">Generally, such extra code is of little consequence—it executes once, is fairly fast, and doesn’t take up that much space. However, if you are an absolute purist and you want to execute only the code you’ve written, you can do so with a little extra work. You just won’t be able to use <i>aoaa.inc</i>, and you’ll have to write non-portable code specifically for macOS or Linux.</p>&#13;
<p class="TX">Listing 16-5 is a “pure” assembly language program written for Linux.</p>&#13;
<pre id="pre-1231"><code><span class="codeannotated_CodeAnnotation" aria-label="annotation1">❶</span> // Listing16-5.s&#13;
//&#13;
// A truly stand-alone "Hello, world!" program&#13;
// written for Linux&#13;
&#13;
        .text&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation2">❷</span> .global     _start&#13;
        .align      2&#13;
hwStr:  .asciz      "Hello, world!\n"&#13;
hwSize  =           .-hwStr&#13;
        .align      2&#13;
&#13;
<span class="codeannotated_CodeAnnotation" aria-label="annotation3">❸</span> _start:&#13;
&#13;
        mov         x0, #1          // stdout file handle&#13;
        adr         x1, hwStr       // String to print&#13;
        mov         x2, #hwSize     // Num chars to print&#13;
        mov         X8, #64         // __NR_write&#13;
        svc         #0              // Call OS to print str.&#13;
&#13;
        mov         X8, #93         // __NR_exit&#13;
        mov         x0, #0&#13;
        svc         #0              // Quit program.</code></pre>&#13;
<p class="TX">Please note that this filename must have a lowercase <i>.s</i> suffix <span class="CodeAnnotation" aria-label="annotation1">❶</span>; you will not be compiling this using GCC, so you won’t be using CPP with this code. Under Linux, the default program entry point is named <span class="SANS_TheSansMonoCd_W5Regular_11">_start</span>. Therefore, this code declares <span class="SANS_TheSansMonoCd_W5Regular_11">_start</span> as a global symbol <span class="CodeAnnotation" aria-label="annotation2">❷</span> and uses <span class="SANS_TheSansMonoCd_W5Regular_11">_start</span> as the entry point for the program <span class="CodeAnnotation" aria-label="annotation3">❸</span>. I got away with using <span class="SANS_TheSansMonoCd_W5Regular_11">main</span> (or <span class="SANS_TheSansMonoCd_W5Regular_11">_main</span>) in earlier examples in this chapter because the C code that GCC links in supplies the <span class="SANS_TheSansMonoCd_W5Regular_11">_start</span> label and transfers control to <span class="SANS_TheSansMonoCd_W5Regular_11">main</span> (<span class="SANS_TheSansMonoCd_W5Regular_11">or _main</span>); however, as we’re giving up the GCC-generated code, we have to explicitly supply the <span class="SANS_TheSansMonoCd_W5Regular_11">_start</span> label.</p>&#13;
<p class="TX">To assemble, link, and run this program, use the following Linux commands:</p>&#13;
<pre id="pre-1232"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_929" aria-label="929"/><span class="SANS_TheSansMonoCd_W7Bold_11">as -o Listing16-5.o Listing16-5.s</span>&#13;
<span class="SANS_TheSansMonoCd_W7Bold_11">ld -s -o Listing16-5 Listing16-5.o</span>&#13;
<span class="SANS_TheSansMonoCd_W7Bold_11">./Listing16-5</span>&#13;
Hello, world!</code></pre>&#13;
<p class="TX">To make this program run under macOS, you must first modify the source code to use the appropriate macOS API constants, as shown in Listing 16-6.</p>&#13;
<pre id="pre-1233"><code>// Listing16-6.s&#13;
//&#13;
// A truly stand-alone "Hello, world!" program&#13;
// written for macOS&#13;
&#13;
        .text&#13;
        .global     _start&#13;
        .global     _main    // Later versions of macOS require this name.&#13;
        .align      2&#13;
hwStr:  .asciz      "Hello, world!\n"&#13;
hwSize  =           .-hwStr&#13;
        .align      2&#13;
&#13;
_start:&#13;
_main:&#13;
&#13;
        mov         x0, #1          // stdout file handle&#13;
        adr         x1, hwStr       // String to print&#13;
        mov         x2, #hwSize     // Num chars to print&#13;
        mov         X16, #4         // SYS_write&#13;
        svc         #0x80           // Call OS to print str.&#13;
&#13;
        mov         X16, #1         // SYS_exit&#13;
        mov         x0, #0&#13;
        svc         #0x80           // Quit program.&#13;
&#13;
        svc         #0              // Quit program.</code></pre>&#13;
<p class="TX">Assembling the code is similar to Linux (note that the program name suffix is also a lowercase <i>.s</i>):</p>&#13;
<pre id="pre-1234"><code><span class="SANS_TheSansMonoCd_W7Bold_11">as -arch arm64 -o Listing16-6.o Listing16-6.s</span></code></pre>&#13;
<p class="TX">Linking the program, however, is a bit more complex:</p>&#13;
<pre id="pre-1235"><code><span class="SANS_TheSansMonoCd_W7Bold_11">ld -macos_version_min 12.3.0 -o HelloWorld Listing16-6.o \</span>&#13;
<span class="SANS_TheSansMonoCd_W7Bold_11">   -lSystem -syslibroot `xcrun -sdk macosx --show-sdk-path` -arch arm64</span></code></pre>&#13;
<p class="TX">It’s best to use a makefile when building pure assembly files under macOS; manually typing these commands every time you want to build the application can be quite tedious!</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_930" aria-label="930"/>As you can see, the linker (<span class="SANS_TheSansMonoCd_W5Regular_11">ld</span>) command still links in a bunch of C code (<span class="SANS_TheSansMonoCd_W5Regular_11">libSystem</span>). There’s no other way (that I know of) to avoid this, which is why I’m perfectly happy letting GCC do all this work for me.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><span class="SANS_Dogma_OT_Bold_B_15">NOTE</span></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Apple isn’t kidding when it warns you against writing code like this. Between the time I first wrote this “Hello, World!” and the time this chapter was reviewed, Apple made changes to its system that broke the program. In particular, the linker now expects the program to be named</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">_main</span> <i>rather than</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">_start</span><i>, and the command line for</i> <span class="SANS_TheSansMonoCd_W5Regular_Italic_11">ld</span> <i>has some subtle changes. Moral of the story: stick with GCC (Clang) to do all this work for you.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
&#13;
<h3 class="H1" id="sec15"><span id="h1-167"/><span class="SANS_Futura_Std_Bold_B_11">16.8 For More Information</span></h3>&#13;
<ul class="ul">&#13;
<li class="BL">You can find the system call numbers for Linux at <i><a href="https://github.com/torvalds/linux/blob/v4.17/include/uapi/asm-generic/unistd.h">https://<wbr/>github<wbr/>.com<wbr/>/torvalds<wbr/>/linux<wbr/>/blob<wbr/>/v4<wbr/>.17<wbr/>/include<wbr/>/uapi<wbr/>/asm<wbr/>-generic<wbr/>/unistd<wbr/>.h</a></i>.</li>&#13;
<li class="BL">Find the system call numbers for macOS at <i><a href="https://github.com/opensource-apple/xnu/blob/master/bsd/kern/syscalls.master">https://<wbr/>github<wbr/>.com<wbr/>/opensource<wbr/>-apple<wbr/>/xnu<wbr/>/blob<wbr/>/master<wbr/>/bsd<wbr/>/kern<wbr/>/syscalls<wbr/>.master</a></i> or <i><a href="https://opensource.apple.com/source/xnu/xnu-1504.3.12/bsd/kern/syscalls.master">https://<wbr/>opensource<wbr/>.apple<wbr/>.com<wbr/>/source<wbr/>/xnu<wbr/>/xnu<wbr/>-1504<wbr/>.3<wbr/>.12<wbr/>/bsd<wbr/>/kern<wbr/>/syscalls<wbr/>.master</a></i>.</li>&#13;
</ul>&#13;
<aside class="box" aria-label="box-37">&#13;
<p class="BH" id="box-37"><span class="SANS_Dogma_OT_Bold_B_11">TEST YOURSELF</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  1.  What is the purpose of the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">svc</span> <span class="SANS_Futura_Std_Book_11">instruction?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  2.  What is the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">svc</span> <span class="SANS_Futura_Std_Book_11">operand for Linux?</span></p>&#13;
<p class="BoxListNumber"><span class="SANS_Futura_Std_Book_11">  3.  What is the</span> <span class="SANS_TheSansMonoCd_W5Regular_11">svc</span> <span class="SANS_Futura_Std_Book_11">operand for macOS?</span></p>&#13;
</aside>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>