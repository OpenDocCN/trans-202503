- en: '**INTRODUCTION**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/f0xxi-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This book explores the field of *computer architecture*, examining the underlying
    principles and design of computer hardware. The field spans a wide range of hardware
    components and technologies at many levels, from basic silicon and transistors,
    through logic gates, simple calculating machines, and assembly languages, up to
    complex processors and memory.
  prefs: []
  type: TYPE_NORMAL
- en: The book also traces the history of computing, from ancient Greek mechanisms
    to World War II code-breaking machines, retro 8-bit game consoles, highly optimized
    contemporary CPUs and deep-learning GPUs, embedded Internet of Things devices
    and cloud servers, and even future architectures, such as quantum computers. Computer
    architecture identifies the trends connecting these various machines and components.
    As you’ll see, some computing principles are much older than you think.
  prefs: []
  type: TYPE_NORMAL
- en: Who Is This Book For?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Computer architecture is one of a few subjects that separate full-blown computer
    scientists from mere programmers. If you’re an undergraduate computer science
    student, it’s probably a requirement for your degree. If you’re a self-taught
    programmer or hacker, it may be a subject you wish to learn more about, both to
    make your programs run more harmoniously with your hardware and as a badge of
    professionalism that many employers look for. This book assumes you know some
    basic high school programming, math, and physics, but otherwise is self-contained.
    It can serve as a textbook for the hardware requirements of an undergraduate computer
    architecture degree or as a first resource for independent learners.
  prefs: []
  type: TYPE_NORMAL
- en: Why Computer Architecture?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When I was a young programmer in the 1980s, programming and using a computer
    was deeply intertwined with an understanding of the computer’s design. For example,
    the art of writing games on 8-bit micros in the 1980s was very much about becoming
    one with the particular CPU and chipset in your home microcomputer; we were fiercely
    loyal to our chosen architectures. Computers had very limited resources, so games
    were written to exploit specific features of the architecture and to squeeze out
    as much power as possible. Many game concepts from this time emerged as results
    of specific architectural structures and tricks.
  prefs: []
  type: TYPE_NORMAL
- en: Programming today is quite different. In most application-level programming,
    there are many levels of software hierarchy insulating the programmer from the
    hardware. You might program in a language whose types bear little relation to
    those of the processor and memory. Those types spare you from thinking in terms
    of memory addresses—or at least they sit on an operating system that replaces
    physical with virtual memory addresses and prohibits access to programs stored
    in hardware other than via some abstracted interface of system calls. As a result,
    when programmers from the 8-bit era see today’s reconstructed Android and JavaScript
    versions of their games, they can find them inauthentic. The games have lost the
    intimate connection to the hardware that inspired and constrained them.
  prefs: []
  type: TYPE_NORMAL
- en: Some people, *systems programmers*, design and maintain the stack of tools mediating
    between hardware and software, but everyone else sits on top of that stack. Nevertheless,
    those tools still connect you to the underlying hardware, albeit indirectly, and
    if you understand the hardware’s structure, you can often make more effective
    use of the tools at all levels. You can also take better measurements of how the
    tools are performing and use that information to make smarter choices in your
    programs. You might use a more efficient algorithm or change how some process
    is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Programmers who really care about high performance, such as writers of game
    engines and science and financial simulations, can benefit from cutting through
    some of the layers of the stack and talking directly to the “bare metal” hardware.
    This kind of programming, known as *assembly programming*, is rare today, since
    optimizing compilers can generally beat most handwritten assembly attempts; still,
    some programmers like to move closer to the metal. They might do this by switching
    from a memory-managed language to a pointer-based one, or from a language using
    symbolic types to languages using the machine’s own types. For many decades, the
    lower-level language of choice has been C, though new contenders, such as Rust,
    are always emerging.
  prefs: []
  type: TYPE_NORMAL
- en: Computer architecture is also directly relevant to computer security. Attacks
    often involve working at some lower level than the one assumed to be secure. While
    a computer may be proved safe at some level, such as the userland of an operating
    system, lower-level details like the precise timings of CPU components and the
    speed of access to different memory locations open new possibilities for exploitation.
    For example, the Spectre and Meltdown vulnerabilities exist at the CPU level but
    can be measured and exploited by userland code when the programmer understands
    what to look for.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, by studying the history of computer architecture and seeing how the
    field has evolved not just over decades but also over centuries, we can learn
    from past mistakes and discover new uses for old ideas. It’s quite common for
    concepts from historical architectures to come back into use after long periods.
    For example, to look at a number, Charles Babbage’s mechanical computers had to
    physically move it out of RAM and into the processor; this meant the number could
    exist only in one place at a time, rather than being copied. We now see exactly
    this structure in today’s research into quantum computing, where some of Babbage’s
    ideas to work around the problem may find new life. The history of architecture
    acts as a reservoir of ideas that we can draw upon as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Changes in the Field
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Until recently, computer architecture was a boring, mature subject. It was
    developed in the 1950s and 1960s, and its basic principles held for a long time.
    Books were updated periodically to feature the latest product examples, such as
    CPUs that were faster and used smaller transistors, but the architectural principles
    remained the same. Since 2010, however, this has all changed: the subject has
    entered a new “golden age,” in part due to the shifting requirements of other
    branches of computing. There’s been a recent trend away from traditional desktops,
    in two opposite directions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, computers are becoming *less* powerful, both in the sense of computational
    ability and energy usage. We now want to have larger numbers of smaller, cheaper,
    lower-energy computers supporting all aspects of our lives. These sorts of devices
    enable *smart cities*, *smart agriculture*, *smart transport*, and the *Internet
    of Things*. At the same time, these devices collect vast quantities of data—what
    we now call *big data*—and processing that data requires a second, new type of
    computer: extremely large supercomputers or compute clusters located in purpose-built
    sites the size of factories. Inside these buildings there are no people, only
    rows of blinking server lights.'
  prefs: []
  type: TYPE_NORMAL
- en: You may have heard of *deep learning*, a rebranding of the 60-year-old *neural
    network* algorithm. It could be argued that deep learning isn’t a branch of machine
    learning or AI theory at all, but rather a branch of computer architecture. After
    all, it’s new architectures, based on massive hardware parallelization through
    clusters of GPUs and custom silicon, that have brought the old algorithm up to
    speed, enabling it to run at scales many orders of magnitude larger than before.
    Thanks to these advances in computer architecture, we can finally use neural networks
    to solve real-world problems such as recognizing objects in videos and conversing
    with humans in natural language chatbots.
  prefs: []
  type: TYPE_NORMAL
- en: Another architectural change has shaken a long-held belief. For many decades,
    programmers swore by *Moore’s law*, which said, depending on who you believe,
    that either the number of transistors or the speed of processors would double
    every 18 months. This made programmers complacent, thinking they would get ever-increasing
    speed on conventional architectures. Recently, however, considerations of energy
    usage have brought the speed form of Moore’s law to an end. We’re still able to
    build more and more transistors, but for the first time since the Victorian era,
    we now need to reconceptualize computing as inherently parallel in order to make
    use of them.
  prefs: []
  type: TYPE_NORMAL
- en: It remains an open question whether parallel architectures will be visible to
    programmers in the future and thus require inherently parallel thinking for everyday
    programming, or whether people will write new compilers that translate between
    conventional serial programs and novel parallel architectures. Either way, there
    will be exciting new careers figuring it out. We’re looking for new ideas that
    might come from very old sources, such as clockwork and water computers, or from
    very new ones, such as neural, optical, and quantum computing.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the recent widespread availability of online collaboration tools has
    enabled a new wave of open source architectural systems and tools. RISC-V, BOOM,
    and Chisel, as well as emulators of past, present, and future machines, have all
    made the study of computer architecture easier, quicker, and more accessible.
    You’ll be introduced to many of these tools in this book. For the first time in
    a long time, it’s very exciting to study and teach architecture!
  prefs: []
  type: TYPE_NORMAL
- en: How to Use This Book
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Architecture is often a compulsory course or professional requirement, and
    many people who don’t enjoy the subject still have to learn it—I should know,
    I used to be one of them! For such students, I’ve added some spoonfuls of sugar
    to help the medicine go down: I’ll link the subject to other topics you might
    be more passionate about. If you hate hardware but like music, robotics, AI, history,
    or even advanced LEGO building, then this might be the book for you. You might
    even begin to love architecture through one of these connections; or, if you do
    just need to pass an exam, maybe this book will help you get through it less painfully
    than some of the others.'
  prefs: []
  type: TYPE_NORMAL
- en: Though the future of computer architecture is novel and exciting, it’s important
    to know the past, so this book takes a broadly historical approach. Computers
    have generally grown more complex over time; by tracing their history, we can
    progressively build up this complexity. For example, you’ll learn the basic structures
    of a CPU—as still in use today—by learning to program on a steampunk, Victorian
    Analytical Engine. I’ll show you how to convert its moving mechanical parts into
    logic gate-based equivalents and how to build up and program a version of the
    Manchester Baby, one of the first electronic computers. You’ll then extend electronic
    machines to 8-bit and 16-bit retro gaming computers, learning to program a Commodore
    64 and an Amiga. Next, I’ll introduce modern desktop and smart computers, including
    x86 and RISC-V architectures, before moving on to cloud and supercomputers. Finally,
    we’ll look at ideas for future technologies.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll study many example systems in this book, but they’re intended primarily
    to illustrate the general concepts rather than be a guide to the specifics of
    modern products. When you’ve finished reading the book, you should have enough
    understanding, for example, to be able to build an 8-bit micro on a breadboard,
    write retro 8-bit games in assembly, write basic embedded and parallel programs,
    understand the arc of history, and predict some of the future of architecture.
    You should also then be ready to read the canonical reference books for future
    study and work.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll get the most out of this book if you try to geek out over each chapter—don’t
    just take them at face value. For example, large-scale CPUs can be designed in
    LogiSim, burned onto cheap field programmable gate arrays (FPGAs), and run for
    real. As another example, you can use all of the architectures and assemblers
    presented in this book to write your own video games. The LogiSim files and assembly
    code snippets discussed in the book are all available for download; see the book’s
    web page, *[https://nostarch.com/computerarchitecture](https://nostarch.com/computerarchitecture)*,
    for a link. I also encourage you to learn more about the book’s topics by using
    the library, Wikipedia, and the wider web, and finding the further readings listed
    at the end of each chapter; then find the interesting resources that *they* reference,
    too. Likewise, try to use the tools presented in the book’s end-of-chapter exercises
    in new ways, and look out for other interesting project ideas online. For instance,
    many YouTubers have built simple 8-bit computers by ordering a 6502, RAM chips,
    and wires from eBay. Architecture is a particularly visual, bloggable, and YouTube-friendly
    subject, so if you create something interesting, be sure to share the results.
  prefs: []
  type: TYPE_NORMAL
- en: A good way to begin your study of architecture is to buy a set of small screwdrivers
    and void your products’ warranties by opening up your PC, laptop, and smartphone,
    as well as some less obvious devices such as your router, TV, and washing machine.
    In the following section, we’ll see some examples of what you might find inside
    these devices and how to navigate around them.
  prefs: []
  type: TYPE_NORMAL
- en: Inside Common Devices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Computer architecture ranges from the atomic scale of transistors to the planetary
    scale of internetworked grid computing. To get an early feel for the subject,
    we’ll begin here at the most human level: what we see when we take the cover off
    a domestic computer and look inside. Typically, the main components visible to
    the naked eye are silicon chips arranged on a printed circuit board. Later in
    the book, we’ll dig down through chips, logic gates, and transistors and build
    upward to clusters and grids.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Desktop PC*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the last couple of decades, most desktop PCs have used components and casings
    of standardized sizes, so you can assemble a PC from components made by many competitors
    without worrying about whether they’ll fit together. IBM started this trend in
    the 1980s. Thanks to this standardization, if you remove the screws and cover
    and open up a desktop PC, you’ll usually see something like the structure shown
    in [Figure 1](fm03.xhtml#fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fxxvi-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1: The inside of a desktop PC*'
  prefs: []
  type: TYPE_NORMAL
- en: The key feature is a large printed circuit board called a *mainboard* (aka a
    *motherboard* or *systemboard*), with other smaller boards plugged into it at
    right angles. The mainboard, as shown in [Figure 2](fm03.xhtml#fig2), contains
    the essential parts of the computer, including the *central processing unit (CPU)*,
    sometimes just called the *processor*, and main memory; the other boards are optional
    extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can usually locate the CPU by eye: it’s the center of the system, looking
    like the capital city of a country on a map, with all the roads leading to it.
    It’s typically under a very large fan to disperse the heat created by all the
    CPU’s transistors. The memory is the next most important component. Main memory
    is usually clearly visible as some physically large but homogeneous region; this
    is because main memory is computationally large and homogeneous. In a desktop,
    main memory appears in several boards of several identical RAM chips, clearly
    lined up.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fxxvii-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2: A mainboard from a desktop PC*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Printed circuit boards (PCBs)*, such as mainboards, are made using a similar
    process to silk-screening posters or T-shirts, as shown in [Figure 3](fm03.xhtml#fig3).
    In silk-screen printing, you choose a number of colors for your design and buy
    a can of paint in each. You then use a CAD program to make your design from block
    regions of these colors. You print out binary images for each color onto separate
    transparencies, to show where that color paint will go, and then you make a silk
    screen *mask* for each color. A mask begins as a piece of silk fabric, which you
    cover in a light-sensitive gel. You place the transparency that you printed out
    over it, then shine a bright light onto it.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fxxvii-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3: To print this poster, a silk screen mask is placed on a piece of
    paper, and paint is pushed through it using a squeegee.*'
  prefs: []
  type: TYPE_NORMAL
- en: The gel reacts where the printout is transparent and doesn’t react where the
    printout is black. You then put the mask in water, which washes away the reacted
    parts of gel and leaves in place the non-reacted parts. The remaining gel doesn’t
    allow paint to pass through it, but the exposed areas of the silk fabric do allow
    paint to pass through. You can now lay your mask on top of a blank piece of paper
    or T-shirt, pour paint all over it, and the paint will pass through only in the
    desired areas of your design. Once you allow this color layer to dry, you repeat
    the whole process for each remaining color to build up the design.
  prefs: []
  type: TYPE_NORMAL
- en: PCBs can be made similarly. You start with an acid-proof fiberglass insulator
    board, completely covered with a layer of copper. You design the circuit layout
    in a CAD program, print it onto a transparency, and shine a light through the
    transparency to selectively mask a light-sensitive chemical on the board. You
    then dip the board in acid to remove the unmasked parts of the copper layer. The
    remaining copper forms the wiring for the PCB. Next, you solder electronic components
    onto the appropriate locations on the board. The soldering used to be done by
    hand, but now it’s done by robots, which are much more accurate and can handle
    smaller components.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the mainboard, the rest of a PC case contains power transformers that
    convert domestic electricity into the various voltages used in the computer, as
    well as bulk storage devices such as hard disks and optical media disc drives—that
    is, CD, DVD, or Blu-ray.
  prefs: []
  type: TYPE_NORMAL
- en: In previous decades, PCs had lots of extension cards for interfacing with the
    monitor, sound equipment, and networks, but more recently these standard interfaces
    have moved to chips on the mainboard. The standard-sized PC case (called the ATX
    form factor) often contains mostly empty space in modern desktops as the parts
    have been miniaturized and integrated onto the mainboard. The noticeable exception
    to this trend is the graphics card (graphics processing unit, or GPU), which in
    high-end machines may have grown as large as or larger than the mainboard to enable
    fast 3D video games and scientific computing. Gamers like to show off these cards
    by illuminating them with LED lights and using transparent PC cases.
  prefs: []
  type: TYPE_NORMAL
- en: '*Laptop*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Laptop PCs have the same logical structure as desktops, but they use smaller,
    less power-consuming components, albeit with less computing power and higher manufacturing
    costs. [Figure 4](fm03.xhtml#fig4) shows an example laptop mainboard.
  prefs: []
  type: TYPE_NORMAL
- en: The laptop mainboard isn’t perfectly rectangular; rather, it’s shaped to fit
    the available space. Since there’s no room for large connectors, many components
    are soldered directly together. Rather than having swappable extension cards sticking
    out at right angles to the mainboard, the form factors here are chosen to make
    everything fit neatly under the keyboard. There’s also less standardization of
    form factors and components than for desktops, with each manufacturer choosing
    their own. Together, these features tend to make laptops more expensive and harder
    to upgrade or interchange.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fxxix-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 4: A laptop mainboard*'
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, the secure boot systems in laptops have opened up a security
    application of computer architecture. It used to be quite easy to take your employer’s
    laptop, which was encumbered by some proprietary operating system, remove the
    operating system, and replace it with an open source one such as Linux. The makers
    of the proprietary operating systems tried to remove your freedom to do this,
    in some cases claiming it was what your employer wanted, by paying hardware makers
    to implement secure boot systems. These systems lock the user out of access to
    the hard disk’s boot sector even before the operating system or a bootloader has
    a chance to load. You now need to circumvent the secure boot at the hardware level,
    such as by hot-wiring two pins on a dedicated chip together, thus factory-resetting
    the computer. The pins are quite small nowadays, so it sometimes requires a microscope
    and precision soldering to do the hot-wiring. (This is purely hypothetical, as
    it may be illegal to tamper with your employer’s device or with the hardware maker’s
    agreements with the operating system vendor.)
  prefs: []
  type: TYPE_NORMAL
- en: '*Smartphone*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a computing context, the word *smart* nowadays means “is a computer.” Historically,
    consumer devices like phones and televisions were designed for single purposes,
    but a recent trend has been to include full computation power in them. For a while,
    this was a novelty, but now a large portion of the world’s population carry a
    full computer in their pocket. We therefore need to take smartphones and other
    smart devices seriously as computers, just as much as traditional desktops and
    laptops. [Figure 5](fm03.xhtml#fig5) shows a mainboard for a smartphone.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0xxx-01.jpg)![Image](../images/f0xxx-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 5: The inside of a Wileyfox Swift smartphone, showing the top and bottom
    sides of the mainboard*'
  prefs: []
  type: TYPE_NORMAL
- en: The design is based around an ARM Cortex CPU. Some of the other chips are specialized
    for phone-specific roles, including Wi-Fi and cell network (GSM) radio communications,
    battery management, and position and environment sensing (such as the inertial
    measurement unit and temperature and pressure sensors). The memory is different
    from desktops and laptops—here we see the use of low-power RAM (LPDDR). This reduces
    battery usage by clearing and turning off parts of the memory when they aren’t
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: Computers are now so miniaturized that their connectors may be the bottlenecks
    taking up the most space, rather than the actual computer. For example, replacing
    a phone’s 3.5 mm headphone jack connector with a smaller port is an ongoing debate.
    No longer having a standard headphone connector can be a nuisance, but having
    one is a limiting factor for the phone’s size.
  prefs: []
  type: TYPE_NORMAL
- en: '*Washing Machine*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If our phones and TVs are computers, might we even consider our washing machine
    to be a computer nowadays? [Figure 6](fm03.xhtml#fig6) shows the mainboard of
    a typical modern washing machine.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a small processor on the board, which probably contains *firmware*,
    a single program “burned” into the chip that performs only one task. This is an
    example of the embedded systems we’ll discuss in [Chapter 12](ch12.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/fxxxi-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 6: The mainboard of a washing machine*'
  prefs: []
  type: TYPE_NORMAL
- en: Consumer devices such as washing machines and refrigerators are currently of
    interest because, like phones, they might be next to become “smart”—that is, capable
    of running arbitrary programs. When “smart homes” are complete, users will expect
    to be able to dial into their washing machine to check its status and give it
    commands from far away. A smart washing machine might even come with an app store
    that enables you to download and run extra functions, such as machine learning
    tools. These could detect and appropriately wash different individual items of
    clothing, saving money and Earth’s energy and water resources.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our tour of a few devices. As we dive into computer architecture
    in the coming chapters, our understanding of how these devices work and are organized
    will grow. Before we get started, here’s a quick overview of the book and a few
    exercises for you to try.
  prefs: []
  type: TYPE_NORMAL
- en: Book Overview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Part I](part01.xhtml) introduces the fundamental concepts underlying all architectures.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 1: Historical Architectures](ch01.xhtml)** Describes the historical
    evolution of computing, not just to teach the history itself but because many
    concepts recur and increase in complexity over time; this will enable you to learn
    about complex modern systems by understanding their simpler ancestors first.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 2: Data Representation](ch02.xhtml)** Discusses how to represent
    data using binary coding schemes, which will later be implemented using digital
    logic.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 3: Basic CPU-Based Architecture](ch03.xhtml)** Explores what a CPU
    is, its basic subcomponents, and its machine code user interface.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you understand the concepts from [Part I](part01.xhtml), the core structures
    of computer architecture are fundamentally hierarchical; [Part II](part02.xhtml)
    works its way up this hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 4: Switches](ch04.xhtml)** Introduces switches, the basic building
    blocks of modern computers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 5: Digital Logic](ch05.xhtml)** Constructs logic gates from these
    switches.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 6: Simple Machines](ch06.xhtml)** Combines these logic gates into
    simple machines.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 7: Digital CPU Design](ch07.xhtml)** Uses these simple machines
    to make components of a CPU and, finally, a complete but small-scale CPU.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 8: Advanced CPU Design](ch08.xhtml)** Introduces more advanced,
    modern CPU features such as pipelining and out-of-order execution.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 9: Input/Output](ch09.xhtml)** Adds input/output (I/O), making one
    more step from a CPU to a complete computer.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 10: Memory](ch10.xhtml)** Introduces memory, the last requirement
    for a full computer.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Part III](part03.xhtml) consists of progressively complex examples and applications,
    coinciding roughly with their historical order; these examples are intended to
    reinforce your knowledge of the structures studied in [Part II](part02.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 11: Retro Architectures](ch11.xhtml)** Begins with relatively simple,
    complete retro computers from the 8-bit and 16-bit era, including showing you
    how to write retro video games in their assembly languages.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 12: Embedded Architectures](ch12.xhtml)** Shows how modern, low-power
    Internet of Things devices have similar structures, capabilities, and programming
    styles to retro devices.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 13: Desktop Architectures](ch13.xhtml)** Studies the complex instruction
    set and history of the x86 architecture, which is probably the basis for your
    main desktop computer. This will enable you to program your computer in assembly,
    on “bare metal” (that is, without an operating system getting in the way). You’ll
    also explore the common PC I/O standards and peripherals that your desktop likely
    contains.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 14: Smart Architectures](ch14.xhtml)** Turns to the multitude of
    smaller smart devices replacing desktop computers. These are characterized by
    RISC architectures such as RISC-V, along with assembly programming and digital
    logic design tooling.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 15: Parallel Architectures](ch15.xhtml)** Discusses parallel architectures,
    which have become more common as CPUs have struggled to run faster.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 16: Future Architectures](ch16.xhtml)** Concludes by speculating
    about possible future architectures, including neural, DNA, and quantum computing.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ARCHITECTURE, ORGANIZATION, OR DESIGN?**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Computer architecture* is traditionally distinguished from *computer organization*,
    with the former referring to the design of hardware-software interfaces visible
    to the programmer and the latter referring to the hardware implementations of
    these interfaces not visible to the programmer. In this context, the programmer
    was considered to be working at the level of assembly language, which performed
    the role of the programmer interface. In the modern world, however, it’s rare
    for programmers to see the assembly language level, as they almost always work
    in compiled languages. The compiler and now the operating system—and even higher-level
    structures like libraries and game engines—abstract the user many further levels
    above the old assembly interface. As such, the old architecture-versus-organization
    distinction has become less meaningful.'
  prefs: []
  type: TYPE_NORMAL
- en: In this book, we’ll instead use *architecture* to refer to the study of all
    the above, and we’ll use the term *instruction set architecture (ISA)* to denote
    the more specific study of the hardware-programmer interface. Our definition of
    architecture also includes the study of the parts of computer hardware outside
    the CPU, such as memory and I/O systems, which is sometimes called *computer design*.
    Modern computers are increasingly interconnected as clusters and clouds, so it
    can now be hard or meaningless to distinguish a group of tightly connected computers
    from a single large computer. Our conception of architecture thus also extends
    to these kinds of systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'The words *architecture* and *hierarchy* both contain the morpheme *arch*.
    The connection isn’t trivial: architecture is all about hierarchies. Hierarchies
    are the ways that complete structures are organized into components and subcomponents.
    No human could comprehend the structure of a billion transistors on a chip, but
    as in software design, we survive by mentally chunking them into many layers of
    abstraction. We chunk transistors into groups of about four or five, called logic
    gates; then we chunk logic gates into simple machines like adders; then we chunk
    those machine into components of CPUs and then the CPUs themselves. This way,
    each level can be designed from tens or hundreds of comprehensible components,
    with the designer having to think only at the single level at which they’re working.
    As mentioned earlier, the structure of [Part II](part02.xhtml) of this book follows
    this hierarchy, beginning with transistors and building upward, introducing progressively
    larger and higher structures.'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each chapter ends with some exercises to help you apply what you’ve learned
    to real-world systems. Some of the tasks, indicated by a “Challenging” heading,
    present an extra challenge and therefore are more difficult. Tasks under a “More
    Challenging” heading are extremely hard or time-consuming and are intended more
    as suggestions for large personal projects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Inside Your Own Devices**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re happy to void the warranty of your devices, buy a set of small screwdrivers
    and open up a desktop PC to see what’s inside. Take care to only open the box
    and not disturb any of the circuit boards themselves. Try to identify the main
    components, including the power supply, mainboard, CPU, RAM, GPU, and communications
    devices, as in the examples we discussed earlier. If you’re unsure about your
    screwdriver skills, you might wish to practice on an older, sacrificial device
    before or instead of your main one, or to search for internet videos of other
    people opening a similar device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most of the components you find inside will have a brand name and model number
    stamped on them. Search the internet for these to obtain the components’ formal
    product datasheets. Use the datasheets to identify some of the parts’ key properties,
    such as the number and speed of the CPU cores, the size of the RAM and its caches,
    the size of the GPU memory, what input and output devices are present, and what
    their capabilities and speeds are. (If your CPU is hard to access due to a heatsink,
    you can usually find its make and model on the mainboard datasheet.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Software Device Inspection**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can also dig for similar information without voiding your warranty on many
    machines by using software tools that inspect the hardware for you. For example,
    if you’re running Linux, try these commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: lscpu
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: cat /proc/cpuinfo
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lshw
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: free
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: hwinfo
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lspci
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: lsusb
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: nvidia-smi
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: clinfo
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On Windows, run the Settings program from the Start menu and look around System
    Settings for similar information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Do some internet research to interpret the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you physically opened your device, check that the brands and model numbers
    inside match those reported by the software—it’s quite common and interesting
    for them to not match, so research why this happens if you see an example!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Challenging**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re used to opening up desktop computers and looking inside, buy some
    smaller screwdrivers and do the same for an old laptop.
  prefs: []
  type: TYPE_NORMAL
- en: '**More Challenging**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re used to opening up laptops, buy some even smaller screwdrivers and
    try to do the same for your phone or game console. Some phones can be opened using
    Torx screwdrivers, although others may require a phone repair kit that you can
    buy online for a few dollars. Some Japanese consoles use Japanese rather than
    Western-standard screws. You can order a repair kit for these as well, again for
    a few dollars. (Some devices are not intended to be accessible or repairable and
    so are glued together, making it hard to do this.)
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This book is intended primarily for readers who want to learn about architecture
    in order to be *users* of it. It should also be useful, however, for those who
    want to *work* in architecture, for example, as chip designers. If you’re such
    a reader, you might want to take at least a quick glance at the larger, harder
    standard text for working architects, to get more of a flavor of what they do:'
  prefs: []
  type: TYPE_NORMAL
- en: 'John Hennessy and David Patterson, *Computer Architecture: A Quantitative Approach*,
    6th ed. (Cambridge, MA: Morgan Kaufmann, 2017).'
  prefs: []
  type: TYPE_NORMAL
- en: This is the classic and authoritative reference book by the Turing Award–winning
    inventors of RISC and RISC-V. Just a glance at it is suggested for now. You will
    likely come back to it after finishing the present book as preparation.
  prefs: []
  type: TYPE_NORMAL
