- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ADDING
    OAUTH</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">添加
    OAuth</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/Drop-image.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Drop-image.jpg)'
- en: In this chapter, you’ll add OAuth authentication to the Food Finder app, giving
    users the opportunity to log in with their GitHub accounts. You’ll also implement
    the wish list page to which authenticated users can add and remove locations,
    as well as the button component needed to accomplish this. Lastly, you’ll learn
    how to protect your GraphQL mutations from unauthenticated users.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将为 Food Finder 应用添加 OAuth 身份验证，为用户提供使用其 GitHub 帐户登录的机会。你还将实现愿望清单页面，经过身份验证的用户可以在该页面上添加和移除位置，以及完成此操作所需的按钮组件。最后，你将学习如何保护你的
    GraphQL 变更免受未经身份验证用户的访问。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Adding OAuth with next-auth</samp>
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">使用 next-auth 添加 OAuth</samp>
- en: 'Developers usually use third-party libraries or SDKs to implement OAuth. For
    the Food Finder application, we’ll use the *next-auth* package from Auth.js, which
    comes with an extensive set of preconfigured templates that allow us to connect
    to an OAuth service easily. These templates are called *providers*, and we’ll
    use one of them: the GitHub provider, which adds a Log In with GitHub button to
    our app. For a refresher on the OAuth authentication process, return to [Chapter
    9](chapter9.xhtml).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员通常使用第三方库或 SDK 来实现 OAuth。对于 Food Finder 应用程序，我们将使用来自 Auth.js 的 *next-auth*
    包，该包包含一整套预配置的模板，允许我们轻松连接到 OAuth 服务。这些模板被称为 *providers*，我们将使用其中一个：GitHub provider，它为我们的应用添加了一个通过
    GitHub 登录的按钮。有关 OAuth 身份验证过程的复习，请返回 [第 9 章](chapter9.xhtml)。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a GitHub
    OAuth App</samp>
  id: totrans-7
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建 GitHub OAuth 应用</samp>
- en: First we need to create an OAuth application using GitHub. This should give
    us the client ID and client secret that the Food Finder application needs to connect
    to GitHub. If you don’t already have a GitHub account, create one now at [*https://<wbr>github<wbr>.com*](https://github.com),
    then log in. Navigate to [*https://<wbr>github<wbr>.com<wbr>/settings<wbr>/developers*](https://github.com/settings/developers)
    and create a new OAuth app in the OAuth Apps section. Enter the Food Finder app’s
    details in the resulting form, which should look similar to [Figure 15-1](chapter15.xhtml#fig15-1).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使用 GitHub 创建一个 OAuth 应用程序。这将为 Food Finder 应用提供连接 GitHub 所需的客户端 ID 和客户端密钥。如果你还没有
    GitHub 帐号，可以现在在 [*https://<wbr>github<wbr>.com*](https://github.com) 创建一个帐号并登录。然后导航至
    [*https://<wbr>github<wbr>.com<wbr>/settings<wbr>/developers*](https://github.com/settings/developers)，在
    OAuth 应用程序部分创建一个新的 OAuth 应用。在生成的表单中输入 Food Finder 应用的详细信息，表单应类似于 [图 15-1](chapter15.xhtml#fig15-1)。
- en: '![](../images/Figure15-1.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 15-1: The GitHub user
    interface for adding a new OAuth application</samp>'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 15-1：GitHub 用户界面用于添加新的 OAuth
    应用</samp>
- en: Enter **Food Finder** as the name, set the home page URL to **http://localhost:3000/**,
    and set the authorization callback URL to **http://localhost:3000/api/auth/callback/github**.
    After registering the application, GitHub should show us the client ID and let
    us generate a client secret.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 **Food Finder** 作为名称，将主页 URL 设置为 **http://localhost:3000/**，并将授权回调 URL 设置为
    **http://localhost:3000/api/auth/callback/github**。注册应用程序后，GitHub 应该会显示客户端 ID，并让我们生成客户端密钥。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding the Client
    Credentials</samp>
  id: totrans-12
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">添加客户端凭证</samp>
- en: 'Now copy these credentials as <samp class="SANS_TheSansMonoCd_W5Regular_11">GITHUB_CLIENT_ID</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GITHUB_CLIENT_SECRET</samp>
    to the *env.local* file in the application’s code root folder. This file looks
    like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将这些凭证复制为 <samp class="SANS_TheSansMonoCd_W5Regular_11">GITHUB_CLIENT_ID</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">GITHUB_CLIENT_SECRET</samp>，并粘贴到应用程序代码根目录中的
    *env.local* 文件中。该文件如下所示：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Fill in the placeholders with your credentials.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 用你的凭证填写占位符。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Installing next-auth</samp>
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">安装 next-auth</samp>
- en: 'To add Auth.js’s OAuth SDK for *next-auth* to the Food Finder app and configure
    it to connect to the provider, run the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Auth.js 的 OAuth SDK 添加到 *next-auth* 中并将其配置为连接到 provider，请运行以下命令：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By default, this SDK uses encrypted JWTs to store and attach session information
    to API requests. The library automatically handles the encryption and decryption
    as long as we provide it with a secret. To add such a secret, open the *env.local*
    file and add the following line to the end:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，该 SDK 使用加密的 JWT 来存储并将会话信息附加到 API 请求中。只要我们提供密钥，库将自动处理加密和解密。要添加这样的密钥，请打开
    *env.local* 文件，并在文件末尾添加以下行：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Use any secret you’d like. The string used here was randomly generated with
    *OpenSSL* at *[https://www.usemodernfullstack.dev/api/v1/generate-secret](https://www.usemodernfullstack.dev/api/v1/generate-secret)*,
    and you should use a fresh one for each application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的任何密钥。此处使用的字符串是通过 *OpenSSL* 在 *[https://www.usemodernfullstack.dev/api/v1/generate-secret](https://www.usemodernfullstack.dev/api/v1/generate-secret)*
    上随机生成的，您应该为每个应用程序使用一个新的密钥。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Authentication
    Callback</samp>
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">创建认证回调</samp>
- en: Now we’ll develop the *api/auth* route for the authorization callback URL we
    supplied to GitHub when registering the OAuth application. Create the *auth* folder
    in the *pages/api* directory containing the file *[...nextauth].ts*. The ... in
    the filename tells the Next.js router that this is a catch all, meaning it handles
    all API calls to endpoints below */auth*; for example, *auth/signin* or *auth/callback/github*.
    Add the code from [Listing 15-1](chapter15.xhtml#Lis15-1) to the file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开发 *api/auth* 路由，用于我们在注册 OAuth 应用时提供给 GitHub 的授权回调 URL。在 *pages/api* 目录下创建
    *auth* 文件夹，并在其中创建文件 *[...nextauth].ts*。文件名中的 ... 告诉 Next.js 路由器这是一个“捕获所有”路由，意味着它处理所有指向
    */auth* 下端点的 API 调用；例如，*auth/signin* 或 *auth/callback/github*。将 [列表 15-1](chapter15.xhtml#Lis15-1)
    中的代码添加到该文件中。
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 15-1: The pages/api/auth/[...nextauth].ts file'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15-1：pages/api/auth/[...nextauth].ts 文件
- en: We import our dependencies, including the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">GithubProvider</samp>
    and the default <samp class="SANS_TheSansMonoCd_W5Regular_11">crypto</samp> module.
    Then we create a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">createUserId</samp>
    function, which takes a string as an argument and calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">crypto</samp>
    module’s <samp class="SANS_TheSansMonoCd_W5Regular_11">createHash</samp> function
    to return the hashed user ID from this string.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入依赖项，包括内置的 <samp class="SANS_TheSansMonoCd_W5Regular_11">GithubProvider</samp>
    和默认的 <samp class="SANS_TheSansMonoCd_W5Regular_11">crypto</samp> 模块。然后，我们创建一个简单的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">createUserId</samp> 函数，它接受一个字符串作为参数，并调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">crypto</samp> 模块的 <samp class="SANS_TheSansMonoCd_W5Regular_11">createHash</samp>
    函数，以从该字符串返回哈希的用户 ID。
- en: Next, we create and export the default asynchronous <samp class="SANS_TheSansMonoCd_W5Regular_11">auth</samp>
    function. To do so, we initialize the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextAuth</samp>
    module and add the <samp class="SANS_TheSansMonoCd_W5Regular_11">GithubProvider</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">providers</samp> array. We
    configure it to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">clientId</samp>
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">clientSecret</samp> we stored
    in the environment variables.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建并导出默认的异步 <samp class="SANS_TheSansMonoCd_W5Regular_11">auth</samp> 函数。为此，我们初始化
    <samp class="SANS_TheSansMonoCd_W5Regular_11">NextAuth</samp> 模块，并将 <samp class="SANS_TheSansMonoCd_W5Regular_11">GithubProvider</samp>
    添加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">providers</samp> 数组中。我们将其配置为使用我们存储在环境变量中的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">clientId</samp> 和 <samp class="SANS_TheSansMonoCd_W5Regular_11">clientSecret</samp>。
- en: Since we want to keep our application as simple as possible, we’ll keep it stateless;
    hence, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">jwt</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">session</samp> callbacks, which
    *next-auth* uses every time it creates a new session or JWT internally. In the
    callback, we calculate the hashed user ID from the user’s email with our <samp
    class="SANS_TheSansMonoCd_W5Regular_11">createId</samp> function (if it’s not
    already available in the current token or session object). Finally, we store it
    in a private claim.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望保持应用程序尽可能简单，因此我们将其保持无状态；因此，我们使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">jwt</samp>
    和 <samp class="SANS_TheSansMonoCd_W5Regular_11">session</samp> 回调，每次 *next-auth*
    创建新的会话或 JWT 时都会使用这些回调。在回调中，我们通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">createId</samp>
    函数计算用户的电子邮件的哈希用户 ID（如果它当前的令牌或会话对象中尚不可用）。最后，我们将其存储在一个私有声明中。
- en: We’ve just created a new property, <samp class="SANS_TheSansMonoCd_W5Regular_11">fdlst_private_userId</samp>,
    on the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> object in the
    *next-auth* session. As expected, TSC warns us that this property doesn’t exist
    on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Session</samp> type. We need
    to augment the type’s interface by adjusting the *customs.d.ts* file in our application’s
    root directory to match [Listing 15-2](chapter15.xhtml#Lis15-2).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在*next-auth*会话中的<samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>对象上创建了一个新的属性<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fdlst_private_userId</samp>。正如预期的那样，TSC警告我们该属性在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Session</samp>类型中不存在。我们需要通过调整应用程序根目录中的*customs.d.ts*文件来增强类型接口，使其与[清单15-2](chapter15.xhtml#Lis15-2)相匹配。
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 15-2: The updated customs.d.ts file with the augmented <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Session</samp>
    interface'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 清单15-2：更新后的customs.d.ts文件，其中增强了<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Session</samp>接口
- en: In the updated code, we import the *next-auth* package’s <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultSession</samp>,
    which defines the default session object, and then create and redeclare the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Session</samp> interface’s <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>
    object with the new <samp class="SANS_TheSansMonoCd_W5Regular_11">fdlst_private_userId</samp>
    property. Because TypeScript overwrites the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>
    object, we explicitly add it from the <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultSession</samp>
    object. In other words, we add our new <samp class="SANS_TheSansMonoCd_W5Regular_11">fdlst_private_userId</samp>
    property to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Session</samp> interface.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新后的代码中，我们导入了*next-auth*包的<samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultSession</samp>，它定义了默认的会话对象，然后创建并重新声明了<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Session</samp>接口的<samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>对象，并为其添加了新的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fdlst_private_userId</samp>属性。由于TypeScript会覆盖现有的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">user</samp>对象，我们显式地从<samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultSession</samp>对象中添加它。换句话说，我们将新的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fdlst_private_userId</samp>属性添加到<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Session</samp>接口中。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Sharing the Session
    Across Pages and Components</samp>
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">跨页面和组件共享会话</samp>
- en: With the callback URL set up, we need to ensure that a user’s session is shared
    among all Next.js pages and React components. We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">useContext</samp>
    hook discussed in [Chapter 4](chapter4.xhtml), which *next-auth* provides for
    us. In the *pages/_app .tsx* file, wrap the application in a <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionProvider</samp>,
    as shown in [Listing 15-3](chapter15.xhtml#Lis15-3).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好回调URL后，我们需要确保用户的会话在所有Next.js页面和React组件中共享。我们可以使用[s第4章](chapter4.xhtml)中讨论的*next-auth*提供的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">useContext</samp>钩子。在*pages/_app.tsx*文件中，如[清单15-3](chapter15.xhtml#Lis15-3)所示，将应用程序包装在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">SessionProvider</samp>中。
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 15-3: The modified pages/_app.tsx file'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 清单15-3：修改后的pages/_app.tsx文件
- en: We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionProvider</samp>
    from the *next-auth* package and enhance the <samp class="SANS_TheSansMonoCd_W5Regular_11">pageProps</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">session</samp> object.
    We store the current <samp class="SANS_TheSansMonoCd_W5Regular_11">session</samp>
    in the provider’s <samp class="SANS_TheSansMonoCd_W5Regular_11">session</samp>
    attribute, making it available throughout the Next.js application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从*next-auth*包中导入了<samp class="SANS_TheSansMonoCd_W5Regular_11">SessionProvider</samp>，并通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">session</samp>对象增强了<samp class="SANS_TheSansMonoCd_W5Regular_11">pageProps</samp>。我们将当前的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">session</samp>存储在提供者的<samp class="SANS_TheSansMonoCd_W5Regular_11">session</samp>属性中，使其在整个Next.js应用程序中都可用。
- en: Before we can access the session in the frontend and middleware, we need to
    add the <samp class="SANS_TheSansMonoCd_W5Regular_11">auth-element</samp> with
    the Sign In button, which will allow users to log in.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够访问前端和中间件中的会话之前，我们需要添加带有“登录”按钮的<samp class="SANS_TheSansMonoCd_W5Regular_11">auth-element</samp>，这样用户才能登录。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Generic Button Component</samp>
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">通用按钮组件</samp>
- en: It’s time to implement the generic button component we mentioned earlier. Technically,
    this component will be a generic <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>
    element that we’ll style to look like a button, with a few variations. It will
    serve as the Sign In/Sign Out button in the <samp class="SANS_TheSansMonoCd_W5Regular_11">auth-element</samp>
    and the Add To/Remove From button in the location detail component. Create a new
    folder, *button*, in the *components* folder, adding an *index.module.css* file
    with the code in [Listing 15-4](chapter15.xhtml#Lis15-4), as well as an *index.tsx*
    file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现我们之前提到的通用按钮组件了。从技术角度来看，这个组件将是一个通用的 <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>
    元素，我们将为其添加样式使其看起来像一个按钮，并具有一些变化。它将作为 <samp class="SANS_TheSansMonoCd_W5Regular_11">auth-element</samp>
    中的登录/退出按钮，以及位置详情组件中的添加到/从中移除按钮。请在 *components* 文件夹中创建一个新的文件夹 *button*，并添加一个名为
    *index.module.css* 的文件，文件内容参见 [Listing 15-4](chapter15.xhtml#Lis15-4)，同时创建一个 *index.tsx*
    文件。
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 15-4: The components/button/index.module.css file'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 15-4: components/button/index.module.css 文件'
- en: We add styles for each of the button variations we’d like to create. All are
    35 pixels tall and have rounded corners. We define a default style, a variation
    with a blue background and white color, and an outlined version whose background
    is white. In addition, we define styles to use for deactivated buttons.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每种希望创建的按钮变体添加样式。所有按钮的高度均为 35 像素，并且具有圆角。我们定义了一个默认样式，一个蓝色背景和白色文字的变体，以及一个背景为白色的轮廓版本。此外，我们还定义了用于禁用按钮的样式。
- en: With the styles in place, we can write code for the component. Copy the contents
    of [Listing 15-5](chapter15.xhtml#Lis15-5) into the component’s *index.tsx* file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在样式就绪后，我们可以为组件编写代码。将 [Listing 15-5](chapter15.xhtml#Lis15-5) 中的内容复制到组件的 *index.tsx*
    文件中。
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 15-5: The components/button/index.tsx file'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 15-5: components/button/index.tsx 文件'
- en: After importing the dependencies, we define the interface for the component’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">prop</samp> argument. We also define
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Button</samp> component as a
    function that returns a JSX element and then use object-destructuring syntax to
    split the <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> object into
    constants representing the object’s key-value pairs. We define the internal <samp
    class="SANS_TheSansMonoCd_W5Regular_11">renderContent</samp> function with one
    argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp>, typed
    as a <samp class="SANS_TheSansMonoCd_W5Regular_11">ReactNode</samp> and rendered
    wrapped in a span element. Depending on the state of the <samp class="SANS_TheSansMonoCd_W5Regular_11">disabled</samp>
    property, we also add the click handler from the <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    object. The component itself returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>
    that we styled to look like a button.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入依赖项之后，我们定义组件的 <samp class="SANS_TheSansMonoCd_W5Regular_11">prop</samp> 参数的接口。我们还将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">Button</samp> 组件定义为一个返回 JSX 元素的函数，并使用对象解构语法将
    <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> 对象分解为表示对象键值对的常量。我们定义了内部的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">renderContent</samp> 函数，该函数有一个参数
    <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp>，其类型为 <samp class="SANS_TheSansMonoCd_W5Regular_11">ReactNode</samp>，并将其包裹在一个
    span 元素中进行渲染。根据 <samp class="SANS_TheSansMonoCd_W5Regular_11">disabled</samp>
    属性的状态，我们还会从 <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> 对象中添加点击处理程序。该组件本身返回一个我们已经设置了样式使其看起来像按钮的
    <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp> 元素。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The AuthElement Component</samp>
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">AuthElement 组件</samp>
- en: Although we’ve added the *next-auth* package to the project, created the OAuth
    API route, and configured our OAuth provider, we still can’t access session information,
    as there is no Sign In button. Let’s create this <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthElement</samp>
    component and then add it to the header. This component uses our default button
    component, and as soon as the user is logged in, it displays their full name,
    as well as a link to their wish list.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经将 *next-auth* 包添加到项目中，创建了 OAuth API 路由并配置了 OAuth 提供者，但我们仍然无法访问会话信息，因为没有登录按钮。让我们创建这个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthElement</samp> 组件，然后将其添加到页面头部。该组件使用我们默认的按钮组件，一旦用户登录，它会显示用户的全名，并提供指向用户愿望清单的链接。
- en: Create the folder *auth-element* in the *components/header* directory and then
    add the *index.module.css* file with the code in [Listing 15-6](chapter15.xhtml#Lis15-6).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *components/header* 目录中创建 *auth-element* 文件夹，然后添加一个名为 *index.module.css* 的文件，文件内容参见
    [Listing 15-6](chapter15.xhtml#Lis15-6)。
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 15-6: The components/header/auth-element/index.module.css file'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 15-6：components/header/auth-element/index.module.css文件
- en: We define a set of basic styles for the component, using a flexbox and margins
    to align them vertically, and change their layout for smaller screens.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为组件定义了一组基本样式，使用flexbox和边距将它们垂直对齐，并为小屏幕更改它们的布局。
- en: To write the component itself, add an *index.tsx* file to the *auth-element*
    folder and enter the code from [Listing 15-7](chapter15.xhtml#Lis15-7) into it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写组件本身，请在*auth-element*文件夹中添加一个*index.tsx*文件，并将[Listing 15-7](chapter15.xhtml#Lis15-7)中的代码输入其中。
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 15-7: The components/header/auth-element/index.tsx file'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 15-7：components/header/auth-element/index.tsx文件
- en: The most notable imports are the <samp class="SANS_TheSansMonoCd_W5Regular_11">signIn</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">signOut</samp> functions and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp> hook from
    *next-auth*. The latter enables us to access session information easily, whereas
    the two functions trigger the sign-in flow or terminate the session.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最显著的导入项是来自*next-auth*的<samp class="SANS_TheSansMonoCd_W5Regular_11">signIn</samp>和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">signOut</samp>函数以及<samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp>钩子。后者使我们能够轻松访问会话信息，而这两个函数则触发登录流程或终止会话。
- en: We then define the <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthElement</samp>
    component and retrieve the <samp class="SANS_TheSansMonoCd_W5Regular_11">session
    data</samp> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">session status</samp>
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp> hook.
    We need both of these to construct the JSX element we return from the component.
    On the client side, we can access the session information directly via the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp> hook. On the server
    side, though, we’ll need to access it through the JWT, because the session information
    is part of the API request’s HTTP cookies.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们定义<samp class="SANS_TheSansMonoCd_W5Regular_11">AuthElement</samp>组件，并从<samp
    class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp>钩子中获取<samp class="SANS_TheSansMonoCd_W5Regular_11">session
    data</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">session status</samp>。我们需要这两者来构造我们从组件返回的JSX元素。在客户端，我们可以通过<samp
    class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp>钩子直接访问会话信息。然而，在服务器端，我们需要通过JWT访问，因为会话信息是API请求的HTTP
    cookies的一部分。
- en: When the session’s status is authenticated, we render the user’s name from the
    session data and add the Your Wish List and Sign Out buttons to the navigation’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nav</samp> element. Otherwise, we
    add the Sign In button to start the OAuth flow. For all of those, we use the generic
    button component and the <samp class="SANS_TheSansMonoCd_W5Regular_11">signIn</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">signOut</samp> functions we
    imported from the *next-auth* module, both of which handle the OAuth flow automatically.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当会话状态被认证时，我们从会话数据中呈现用户的姓名，并将“您的愿望清单”和“登出”按钮添加到导航的<samp class="SANS_TheSansMonoCd_W5Regular_11">nav</samp>元素中。否则，我们将添加“登录”按钮以启动OAuth流程。对于所有这些，我们使用通用按钮组件和从*next-auth*模块导入的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">signIn</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">signOut</samp>函数，它们都自动处理OAuth流程。
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp> element
    to link to the user’s wish list. (This is another Next.js page we’ll implement
    in a moment.) The wish list is available at the dynamic route */list/:userId*,
    which uses the user ID we created by hashing the user’s email address and storing
    it in <samp class="SANS_TheSansMonoCd_W5Regular_11">fdlst_private_userId</samp>.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用<samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp>元素来链接到用户的愿望清单。（这是我们稍后会实现的另一个Next.js页面。）愿望清单通过动态路由*/list/:userId*提供，该路由使用我们通过哈希化用户的电子邮件地址并将其存储在<samp
    class="SANS_TheSansMonoCd_W5Regular_11">fdlst_private_userId</samp>中的用户ID。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Adding the AuthElement Component to
    the Header</samp>
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">将AuthElement组件添加到Header中</samp>
- en: Now we have to add the new component to the header. Open the *index.tsx* file
    in the *components/header* directory and adjust it so that it matches [Listing
    15-8](chapter15.xhtml#Lis15-8).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须将新组件添加到头部。打开*components/header*目录中的*index.tsx*文件，并进行调整，使其与[Listing 15-8](chapter15.xhtml#Lis15-8)匹配。
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 15-8: The modified components/header/index.tsx file'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 15-8：修改后的components/header/index.tsx文件
- en: The update is simple; we import the <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthElement</samp>
    component and add it next to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Logo</samp>
    inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">header</samp>.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 更新很简单；我们导入 <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthElement</samp>
    组件，并将其添加到 <samp class="SANS_TheSansMonoCd_W5Regular_11">Logo</samp> 旁边，放在 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">header</samp> 内。
- en: Test the OAuth workflow to see our session management in practice. When you
    open *http://localhost:3000*, the Sign In button should be in the header, as in
    [Figure 15-2](chapter15.xhtml#fig15-2).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 OAuth 工作流程，看看我们的会话管理实践。当你打开 *http://localhost:3000* 时，登录按钮应该出现在头部，如[图 15-2](chapter15.xhtml#fig15-2)所示。
- en: '![](../images/Figure15-2.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 15-2: The header in
    a logged-out state with the Sign In button</samp>'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 15-2：登出状态下的头部，显示登录按钮</samp>
- en: Let’s log in using OAuth. Click the **Sign In** button, and *next-auth* should
    redirect you to the login screen, where you can select to sign in with the configured
    OAuth providers to use ([Figure 15-3](chapter15.xhtml#fig15-3)).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 OAuth 登录。点击 **登录** 按钮，*next-auth* 应该会将你重定向到登录屏幕，在那里你可以选择使用配置的 OAuth 提供者登录（见[图
    15-3](chapter15.xhtml#fig15-3)）。
- en: '![](../images/Figure15-3.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 15-3: OAuth requires
    us to choose a provider.</samp>'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 15-3：OAuth 要求我们选择一个提供者。</samp>
- en: Click the button to log in. OAuth should redirect you to the application, where
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthElement</samp> renders your
    name and new buttons based on the session information. The screen should look
    similar to [Figure 15-4](chapter15.xhtml#fig15-4).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 点击按钮进行登录。OAuth 应该会将你重定向到应用程序，在那里 <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthElement</samp>
    根据会话信息渲染你的名字和新的按钮。屏幕应该与[图 15-4](chapter15.xhtml#fig15-4)相似。
- en: '![](../images/Figure15-4.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure15-4.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 15-4: The header in
    the logged-in state with the session information</samp>'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_BI_11">图 15-4：登录状态下的头部，显示会话信息</samp>
- en: The header element has changed according to the session’s state. We display
    the current user’s name received from the OAuth provider, the link to their public
    wish list, and the Sign Out button.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 头部元素已经根据会话状态发生变化。我们显示了从 OAuth 提供者获取的当前用户的名字、指向他们公共愿望清单的链接以及注销按钮。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Wish List Next.js Page</samp>
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">愿望清单 Next.js 页面</samp>
- en: The wish list button in the header should link to a wish list page at the dynamic
    URL *list/:userId*. This regular Next.js page should display all locations whose
    <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp> property contains
    the user ID specified in the dynamic URL. It will look quite similar to the start
    page, and we can build it out of existing components.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 头部中的愿望清单按钮应链接到动态 URL *list/:userId* 的愿望清单页面。这个常规的 Next.js 页面应该显示所有其 <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp>
    属性包含在动态 URL 中指定的用户 ID 的位置。它看起来会与起始页非常相似，我们可以利用现有组件构建它。
- en: To create the page’s route, create the *list* folder with the *[userId].tsx*
    file in the *pages* directory. Then add the code from [Listing 15-9](chapter15.xhtml#Lis15-9)
    to this *.tsx* file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建页面路由，在 *pages* 目录下创建 *list* 文件夹，并在其中创建 *[userId].tsx* 文件。然后将[Listing 15-9](chapter15.xhtml#Lis15-9)中的代码添加到这个
    *.tsx* 文件中。
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 15-9: The pages/list/[userId].tsx file'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 15-9: 页面/list/[userId].tsx 文件'
- en: Although we want the wish list page to look similar to the start page, we use
    SSR, with <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp>,
    as we did for the location detail page. The wish list page is highly dynamic;
    hence, we need to regenerate the HTML on each request.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们希望愿望清单页面看起来与起始页相似，但我们使用 SSR，并结合 <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp>，就像我们在位置详情页面中做的那样。愿望清单页面是高度动态的；因此，我们需要在每次请求时重新生成
    HTML。
- en: Another approach would be to use client-side rendering, then request the user’s
    locations through the GraphQL API in a <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    hook. However, this would cause the user to see a loading screen each time they
    opened the wish list page. We can avoid this inferior user experience altogether
    with SSR.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用客户端渲染，然后通过 GraphQL API 在 <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    钩子请求用户的位置。然而，这会导致用户每次打开愿望清单页面时看到加载页面。我们可以通过 SSR 完全避免这种较差的用户体验。
- en: In the server-side part of the page’s code, we first extract the URL parameter,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">userId</samp>, from the context’s
    query object. We use the user’s ID and the <samp class="SANS_TheSansMonoCd_W5Regular_11">onUsersWishlist</samp>
    service to get all locations for the user’s wish list. If there is an error, we
    simply continue instead of redirecting to the *404* error page, rendering an empty
    list.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在页面代码的服务器端部分，我们首先从上下文的查询对象中提取URL参数<samp class="SANS_TheSansMonoCd_W5Regular_11">userId</samp>。我们使用用户的ID和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">onUsersWishlist</samp>服务获取用户愿望单中的所有位置。如果发生错误，我们会继续执行，而不是重定向到*404*错误页面，呈现一个空列表。
- en: We then pass the locations array and the user’s ID to the Next.js page, where
    we extract the locations as usual, as well as the <samp class="SANS_TheSansMonoCd_W5Regular_11">userId</samp>.
    We compare the user ID from the URL with the user ID in the current session. If
    they match, we know that the currently logged-in user has visited their own wish
    list and adjust the user interface accordingly.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将位置数组和用户ID传递给Next.js页面，在那里我们像往常一样提取位置以及<samp class="SANS_TheSansMonoCd_W5Regular_11">userId</samp>。我们将URL中的用户ID与当前会话中的用户ID进行比较。如果它们匹配，我们就知道当前登录的用户访问了自己的愿望单，并相应地调整用户界面。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Adding the Button to the Location Detail
    Component</samp>
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">将按钮添加到位置详情组件</samp>
- en: We can now visit the wish list page, but it will always be empty. We haven’t
    yet provided users with a way to add items to it. To change this, we’ll place
    a button in the location details component that lets users add or remove a particular
    location. We’ll use the generic button component and session information. Open
    the *index.ts* file in the *components/location-details.tsx* directory and modify
    the code to match [Listing 15-10](chapter15.xhtml#Lis15-10).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以访问愿望单页面，但它始终为空。我们还没有提供用户将项目添加到其中的方式。为了改变这一点，我们将在位置详情组件中放置一个按钮，允许用户添加或删除特定位置。我们将使用通用按钮组件和会话信息。打开*index.ts*文件，位于*components/location-details.tsx*目录中，并修改代码以匹配[Listing
    15-10](chapter15.xhtml#Lis15-10)。
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 15-10: The modified components/location-details/index.tsx file'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 15-10: 修改后的components/location-details/index.tsx文件'
- en: First we import <samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp>
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">next-auth</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> from React,
    and the generic <samp class="SANS_TheSansMonoCd_W5Regular_11">Button</samp> component.
    Then we define <samp class="SANS_TheSansMonoCd_W5Regular_11">WishlistInterface</samp>,
    the interface for the <samp class="SANS_TheSansMonoCd_W5Regular_11">wishlistAction</samp>
    function we’ll implement in a bit.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们从<samp class="SANS_TheSansMonoCd_W5Regular_11">next-auth</samp>导入<samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp>，从React导入<samp
    class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp>，以及通用的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">Button</samp>组件。然后我们定义<samp class="SANS_TheSansMonoCd_W5Regular_11">WishlistInterface</samp>，这是我们稍后将实现的<wishlistAction</samp>函数的接口。
- en: Inside the component, we get the <samp class="SANS_TheSansMonoCd_W5Regular_11">session</samp>
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp> hook,
    then create the <samp class="SANS_TheSansMonoCd_W5Regular_11">onWishlist</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">loading</samp> state variables
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> as Boolean
    values. We use the first state variable to specify whether a location is currently
    on the user’s wish list, then update the user interface accordingly. We calculate
    the initial state in the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    hook based on the location’s <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp>
    property. As soon as we’ve successfully added or removed the location to or from
    the wish list, we update the state variable and the button’s text.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在组件内部，我们通过<samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp>钩子获取<samp
    class="SANS_TheSansMonoCd_W5Regular_11">session</samp>，然后使用<samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp>创建<samp
    class="SANS_TheSansMonoCd_W5Regular_11">onWishlist</samp>和<samp class="SANS_TheSansMonoCd_W5Regular_11">loading</samp>状态变量，作为布尔值。我们使用第一个状态变量来指定某个位置当前是否在用户的愿望单中，然后相应地更新用户界面。我们基于位置的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp>属性，在<samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>钩子中计算初始状态。一旦成功将位置添加或移除到愿望单中，我们就会更新状态变量和按钮的文本。
- en: We implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">wishlistAction</samp>
    function to update the <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp>
    property. First we deconstruct the argument object and then check the <samp class="SANS_TheSansMonoCd_W5Regular_11">loading</samp>
    state to see if there is currently a running request. If so, we exit the function.
    Otherwise, we set the loading state to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    to block the user interface, calculate the action for the GraphQL mutations, and
    use it to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">wishlist</samp>
    mutation. After successfully modifying the document in the database, we update
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">onWishlist</samp> state and
    unblock the user interface.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了 <samp class="SANS_TheSansMonoCd_W5Regular_11">wishlistAction</samp> 函数来更新
    <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp> 属性。首先，我们解构参数对象，然后检查
    <samp class="SANS_TheSansMonoCd_W5Regular_11">loading</samp> 状态，以查看是否当前有请求在进行。如果有，我们退出函数。否则，我们将加载状态设置为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>，以阻止用户界面，计算 GraphQL mutation
    的操作，并用它来调用 <samp class="SANS_TheSansMonoCd_W5Regular_11">wishlist</samp> mutation。在成功修改数据库中的文档后，我们更新
    <samp class="SANS_TheSansMonoCd_W5Regular_11">onWishlist</samp> 状态，并解除用户界面的阻塞。
- en: We check the current session to see if the user is logged in. If so, we render
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Button</samp> component and
    set the <samp class="SANS_TheSansMonoCd_W5Regular_11">disabled</samp> and class
    name attributes based on the loading state, as well as an on-click event. With
    each click of the button, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">wishlistAction</samp>
    function with the current location ID and user ID as arguments. Finally, we set
    the button’s text based on the <samp class="SANS_TheSansMonoCd_W5Regular_11">onWishlist</samp>
    state, either adding the current location to the wish list or removing it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查当前会话，以查看用户是否已登录。如果是，我们渲染 <samp class="SANS_TheSansMonoCd_W5Regular_11">Button</samp>
    组件，并根据加载状态设置 <samp class="SANS_TheSansMonoCd_W5Regular_11">disabled</samp> 和类名属性，并绑定点击事件。每次点击按钮时，我们调用
    <samp class="SANS_TheSansMonoCd_W5Regular_11">wishlistAction</samp> 函数，并将当前地点
    ID 和用户 ID 作为参数传递。最后，我们根据 <samp class="SANS_TheSansMonoCd_W5Regular_11">onWishlist</samp>
    状态设置按钮的文本，决定是将当前地点添加到愿望列表中，还是将其移除。
- en: Try adding and removing a few locations to the wish list before moving on. Check
    that the button’s text changes accordingly and that a list of locations similar
    to the one on the start page appears on the wish list page.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，尝试向愿望列表中添加和移除几个地点。检查按钮的文本是否相应变化，并且在愿望列表页面上是否出现与起始页面类似的地点列表。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Securing the GraphQL Mutations</samp>
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">保护 GraphQL Mutation</samp>
- en: 'There is one more thing we have to do to wrap up the application: secure the
    GraphQL API. While the queries should be publicly available, the mutations should
    be accessible only to logged-in users, who should be able to add or remove only
    their own user ID for the <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp>
    property.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事我们必须做才能完成应用程序：保护 GraphQL API。虽然查询应该是公开可用的，但 mutation 应仅供登录用户访问，且用户只能为 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp> 属性添加或移除自己的用户 ID。
- en: 'But if you test the API with the <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp>
    command, you’ll see that, currently, everyone can access the API. Note that you
    must enter the values supplied to the <samp class="SANS_TheSansMonoCd_W5Regular_11">-d</samp>
    flag on a single line, or the server might return an error:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你使用 <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp> 命令测试 API，你会看到当前每个人都可以访问该
    API。请注意，你必须将提供给 <samp class="SANS_TheSansMonoCd_W5Regular_11">-d</samp> 标志的值输入在同一行上，否则服务器可能会返回错误：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As a test, we send a simple mutation to remove the location with the ID 12340
    from a nonexistent user’s wish list. (The mutation won’t work, which is fine;
    we just want to verify whether the API is accessible to the public.) The command
    receives a *200* response and the expected JSON, proving that the mutations are
    public.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 作为测试，我们发送一个简单的 mutation 请求，试图将 ID 为 12340 的地点从一个不存在的用户的愿望列表中移除。（mutation 不会生效，这没关系；我们只是想验证
    API 是否对公众开放。）该命令收到 *200* 响应和预期的 JSON，证明 mutation 是公开的。
- en: Let’s implement an <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp>
    to protect our mutations. A *guard* is a pattern that checks a condition and then
    throws an error if it isn’t met, and an *auth guard* protects a route or an API
    from unauthorized access.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp> 来保护我们的变更操作。*guard*
    是一种模式，它检查一个条件，如果条件不满足，则抛出错误，而 *auth guard* 保护一个路由或 API 防止未经授权的访问。
- en: We begin by creating the file *auth-guards.ts* in the *middleware* folder and
    adding the code in [Listing 15-11](chapter15.xhtml#Lis15-11).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从在 *middleware* 文件夹中创建 *auth-guards.ts* 文件开始，并将[列表 15-11](chapter15.xhtml#Lis15-11)中的代码添加到该文件。
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 15-11: The middleware/auth-guards.ts file'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15-11：middleware/auth-guards.ts 文件
- en: We also import <samp class="SANS_TheSansMonoCd_W5Regular_11">JWT</samp> from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">next-auth</samp> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphQLError</samp>
    constructor from <samp class="SANS_TheSansMonoCd_W5Regular_11">graphql</samp>.
    We’ll use the latter to create the error objects returned to the user if authentication
    fails. Next, we define our interfaces for the <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp>
    function’s arguments and export the function itself.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从 <samp class="SANS_TheSansMonoCd_W5Regular_11">next-auth</samp> 导入 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">JWT</samp>，并从 <samp class="SANS_TheSansMonoCd_W5Regular_11">graphql</samp>
    导入 <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphQLError</samp> 构造函数。如果身份验证失败，我们将使用后者创建返回给用户的错误对象。接下来，我们为
    <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp> 函数的参数定义接口，并导出该函数本身。
- en: 'We’ll call the auth guard from the mutation resolver with two parameters: an
    object with the user ID and the location ID, for which we defined the <samp class="SANS_TheSansMonoCd_W5Regular_11">paramInterface</samp>,
    and the context object with the token, the <samp class="SANS_TheSansMonoCd_W5Regular_11">contextInterface</samp>.
    The auth guard returns either a Boolean indicating that authentication succeeded
    or an error. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp>
    function, we verify that every access to our mutation has a token with a private
    claim ❶ and that the user ID in the private claim matches the user ID we pass
    to the mutation ❷. In other words, we verify that a logged-in user has made the
    API request and that they’re modifying their own wish list.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在变更解析器中调用认证守卫，并传递两个参数：一个包含用户 ID 和位置 ID 的对象，我们为此定义了 <samp class="SANS_TheSansMonoCd_W5Regular_11">paramInterface</samp>，以及包含令牌的上下文对象，<samp
    class="SANS_TheSansMonoCd_W5Regular_11">contextInterface</samp>。认证守卫返回一个布尔值，表示认证是否成功，或者返回一个错误。在
    <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp> 函数中，我们验证每次访问变更操作时，是否带有包含私有声明
    ❶ 的令牌，并且私有声明中的用户 ID 是否与我们传递给变更操作的用户 ID 匹配 ❷。换句话说，我们验证的是，一个已登录的用户发出了 API 请求，并且他们正在修改自己的愿望清单。
- en: If the checks fail, we create an error with a message and code. In addition,
    we set the HTTP status code to *500*. Remember that unlike REST APIs, which rely
    on an extensive list of precise HTTP status codes to communicate with the caller,
    a GraphQL API usually uses either *200* or *500* as the status code for errors.
    Broadly speaking, we send a *500* status code when GraphQL can’t execute the query
    at all and *200* when the query can be executed. In both cases, the GraphQL API
    should include precise information about what error occurred.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果检查失败，我们会创建一个带有消息和代码的错误。此外，我们将 HTTP 状态码设置为*500*。请记住，与依赖精确的 HTTP 状态码列表与调用方进行通信的
    REST API 不同，GraphQL API 通常使用*200*或*500*作为错误的状态码。广义上来说，当 GraphQL 完全无法执行查询时，我们发送*500*状态码；当查询可以执行时，发送*200*状态码。在这两种情况下，GraphQL
    API 都应该包含关于错误发生的详细信息。
- en: Now we must pass the user’s OAuth token to the resolvers, which will then pass
    it to the auth guard. To do so, we’ll use the context function we implemented
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">startServerAndCreateNextHandler</samp>
    function, found in the *pages/api/graphql.ts* file. Open the file and adjust it
    to match the code in [Listing 15-12](chapter15.xhtml#Lis15-12).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须将用户的 OAuth 令牌传递给解析器，然后它们会将令牌传递给认证守卫。为此，我们将使用在 <samp class="SANS_TheSansMonoCd_W5Regular_11">startServerAndCreateNextHandler</samp>
    函数中实现的上下文函数，该函数位于 *pages/api/graphql.ts* 文件中。打开该文件，并根据[列表 15-12](chapter15.xhtml#Lis15-12)中的代码进行调整。
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 15-12: The modified pages/api/graphql.ts file with the JWT token'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 15-12：修改后的 pages/api/graphql.ts 文件，包含 JWT 令牌
- en: Unlike on the client side, where we can access the session information directly
    via the <samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp> hook,
    here we need to access it through the JWT on the server side. This is because
    the session information is part of the API request’s HTTP cookies on the server
    instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionProvider</samp>’s
    shared session state, and we need to extract it from the request. To do so, we
    import the <samp class="SANS_TheSansMonoCd_W5Regular_11">getToken</samp> function
    from the *next-auth* <samp class="SANS_TheSansMonoCd_W5Regular_11">jwt</samp>
    module. Then we pass the request object we receive from the <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp>
    function to call <samp class="SANS_TheSansMonoCd_W5Regular_11">getToken</samp>
    and await the decoded JWT. Next, we return the token from the <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp>
    function so that we can access the token in the resolver functions.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 与客户端不同，在客户端我们可以通过 <samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp>
    hook 直接访问会话信息，在这里我们需要通过服务器端的 JWT 来访问会话信息。这是因为会话信息作为 API 请求的 HTTP cookies 存储在服务器上，而不是
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionProvider</samp> 的共享会话状态中，我们需要从请求中提取它。为此，我们从
    *next-auth* 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">jwt</samp> 模块导入 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">getToken</samp> 函数。然后，我们将从 <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp>
    函数接收到的请求对象传递给 <samp class="SANS_TheSansMonoCd_W5Regular_11">getToken</samp> 并等待解码后的
    JWT。接下来，我们从 <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp> 函数返回该
    token，以便在解析器函数中访问该 token。
- en: Finally, let’s use the token to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp>
    to our resolvers to protect them from unauthenticated and unauthorized access.
    Open the *graphql/locations/mutations.ts* file and update it with the code from
    [Listing 15-13](chapter15.xhtml#Lis15-13).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们使用 token 将 <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp>
    添加到我们的解析器中，以保护它们免受未经身份验证和未经授权的访问。打开 *graphql/locations/mutations.ts* 文件，并使用 [Listing
    15-13](chapter15.xhtml#Lis15-13) 中的代码进行更新。
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 15-13: The graphql/locations/mutations.ts file with the added <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">authGuard</samp>'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 15-13: 添加了 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">authGuard</samp>
    的 graphql/locations/mutations.ts 文件'
- en: We define a new interface for the context and update the context parameter to
    contain the JWT. Next, we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp>
    function to our mutations and follow the guard pattern by returning the error
    immediately instead of proceeding with the code.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为上下文定义了一个新接口，并更新了上下文参数以包含 JWT。接下来，我们将 <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp>
    函数添加到我们的 mutations 中，并遵循守卫模式，立即返回错误，而不是继续执行代码。
- en: To test the <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp> functionality,
    run <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp> again. The command
    line output should look similar to [Listing 15-14](chapter15.xhtml#Lis15-14).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试 <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp> 功能，再次运行 <samp
    class="SANS_TheSansMonoCd_W5Regular_11">curl</samp>。命令行输出应该类似于 [Listing 15-14](chapter15.xhtml#Lis15-14)。
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 15-14: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">curl</samp>
    command to test our API'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 15-14: 用于测试我们 API 的 <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">curl</samp>
    命令'
- en: Unlike the previous <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp>
    call, the GraphQL API now responds with <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/1.1
    500 Internal Server Error</samp> and an extensive error message, which we defined
    when we created the <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphQLError</samp>
    in the *auth-guards.ts* file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的 <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp> 调用不同，GraphQL
    API 现在返回 <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/1.1 500 Internal Server
    Error</samp> 和一个详细的错误信息，这个错误信息是在我们创建 <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphQLError</samp>
    时定义的，位于 *auth-guards.ts* 文件中。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">总结</samp>
- en: We’ve successfully added an OAuth authentication flow to the Food Finder application.
    Now the user can log in with their GitHub account. Once logged in, they can maintain
    their personal public wish list. In addition, we’ve protected the GraphQL mutations,
    meaning they are no longer available to anyone; instead, only logged-in users
    can access them. In the final chapter, we’ll add automated tests to evaluate the
    application using Jest.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地在 Food Finder 应用中添加了 OAuth 身份验证流程。现在，用户可以使用他们的 GitHub 账号登录。一旦登录，他们可以维护个人的公开愿望清单。此外，我们还保护了
    GraphQL 的变更操作，这意味着它们不再对任何人开放；相反，只有登录用户才能访问这些变更操作。在最后一章，我们将使用 Jest 添加自动化测试来评估该应用。
