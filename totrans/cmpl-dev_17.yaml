- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">15</samp> <samp class="SANS_Dogma_OT_Bold_B_11">ADDING
    OAUTH</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Drop-image.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll add OAuth authentication to the Food Finder app, giving
    users the opportunity to log in with their GitHub accounts. You’ll also implement
    the wish list page to which authenticated users can add and remove locations,
    as well as the button component needed to accomplish this. Lastly, you’ll learn
    how to protect your GraphQL mutations from unauthenticated users.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Adding OAuth with next-auth</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Developers usually use third-party libraries or SDKs to implement OAuth. For
    the Food Finder application, we’ll use the *next-auth* package from Auth.js, which
    comes with an extensive set of preconfigured templates that allow us to connect
    to an OAuth service easily. These templates are called *providers*, and we’ll
    use one of them: the GitHub provider, which adds a Log In with GitHub button to
    our app. For a refresher on the OAuth authentication process, return to [Chapter
    9](chapter9.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating a GitHub
    OAuth App</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: First we need to create an OAuth application using GitHub. This should give
    us the client ID and client secret that the Food Finder application needs to connect
    to GitHub. If you don’t already have a GitHub account, create one now at [*https://<wbr>github<wbr>.com*](https://github.com),
    then log in. Navigate to [*https://<wbr>github<wbr>.com<wbr>/settings<wbr>/developers*](https://github.com/settings/developers)
    and create a new OAuth app in the OAuth Apps section. Enter the Food Finder app’s
    details in the resulting form, which should look similar to [Figure 15-1](chapter15.xhtml#fig15-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 15-1: The GitHub user
    interface for adding a new OAuth application</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Enter **Food Finder** as the name, set the home page URL to **http://localhost:3000/**,
    and set the authorization callback URL to **http://localhost:3000/api/auth/callback/github**.
    After registering the application, GitHub should show us the client ID and let
    us generate a client secret.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Adding the Client
    Credentials</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now copy these credentials as <samp class="SANS_TheSansMonoCd_W5Regular_11">GITHUB_CLIENT_ID</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">GITHUB_CLIENT_SECRET</samp>
    to the *env.local* file in the application’s code root folder. This file looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Fill in the placeholders with your credentials.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Installing next-auth</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To add Auth.js’s OAuth SDK for *next-auth* to the Food Finder app and configure
    it to connect to the provider, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, this SDK uses encrypted JWTs to store and attach session information
    to API requests. The library automatically handles the encryption and decryption
    as long as we provide it with a secret. To add such a secret, open the *env.local*
    file and add the following line to the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Use any secret you’d like. The string used here was randomly generated with
    *OpenSSL* at *[https://www.usemodernfullstack.dev/api/v1/generate-secret](https://www.usemodernfullstack.dev/api/v1/generate-secret)*,
    and you should use a fresh one for each application.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Creating the Authentication
    Callback</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’ll develop the *api/auth* route for the authorization callback URL we
    supplied to GitHub when registering the OAuth application. Create the *auth* folder
    in the *pages/api* directory containing the file *[...nextauth].ts*. The ... in
    the filename tells the Next.js router that this is a catch all, meaning it handles
    all API calls to endpoints below */auth*; for example, *auth/signin* or *auth/callback/github*.
    Add the code from [Listing 15-1](chapter15.xhtml#Lis15-1) to the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-1: The pages/api/auth/[...nextauth].ts file'
  prefs: []
  type: TYPE_NORMAL
- en: We import our dependencies, including the built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">GithubProvider</samp>
    and the default <samp class="SANS_TheSansMonoCd_W5Regular_11">crypto</samp> module.
    Then we create a simple <samp class="SANS_TheSansMonoCd_W5Regular_11">createUserId</samp>
    function, which takes a string as an argument and calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">crypto</samp>
    module’s <samp class="SANS_TheSansMonoCd_W5Regular_11">createHash</samp> function
    to return the hashed user ID from this string.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create and export the default asynchronous <samp class="SANS_TheSansMonoCd_W5Regular_11">auth</samp>
    function. To do so, we initialize the <samp class="SANS_TheSansMonoCd_W5Regular_11">NextAuth</samp>
    module and add the <samp class="SANS_TheSansMonoCd_W5Regular_11">GithubProvider</samp>
    to the <samp class="SANS_TheSansMonoCd_W5Regular_11">providers</samp> array. We
    configure it to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">clientId</samp>
    and the <samp class="SANS_TheSansMonoCd_W5Regular_11">clientSecret</samp> we stored
    in the environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Since we want to keep our application as simple as possible, we’ll keep it stateless;
    hence, we use the <samp class="SANS_TheSansMonoCd_W5Regular_11">jwt</samp> and
    <samp class="SANS_TheSansMonoCd_W5Regular_11">session</samp> callbacks, which
    *next-auth* uses every time it creates a new session or JWT internally. In the
    callback, we calculate the hashed user ID from the user’s email with our <samp
    class="SANS_TheSansMonoCd_W5Regular_11">createId</samp> function (if it’s not
    already available in the current token or session object). Finally, we store it
    in a private claim.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve just created a new property, <samp class="SANS_TheSansMonoCd_W5Regular_11">fdlst_private_userId</samp>,
    on the <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> object in the
    *next-auth* session. As expected, TSC warns us that this property doesn’t exist
    on the <samp class="SANS_TheSansMonoCd_W5Regular_11">Session</samp> type. We need
    to augment the type’s interface by adjusting the *customs.d.ts* file in our application’s
    root directory to match [Listing 15-2](chapter15.xhtml#Lis15-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-2: The updated customs.d.ts file with the augmented <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">Session</samp>
    interface'
  prefs: []
  type: TYPE_NORMAL
- en: In the updated code, we import the *next-auth* package’s <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultSession</samp>,
    which defines the default session object, and then create and redeclare the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Session</samp> interface’s <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>
    object with the new <samp class="SANS_TheSansMonoCd_W5Regular_11">fdlst_private_userId</samp>
    property. Because TypeScript overwrites the existing <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp>
    object, we explicitly add it from the <samp class="SANS_TheSansMonoCd_W5Regular_11">DefaultSession</samp>
    object. In other words, we add our new <samp class="SANS_TheSansMonoCd_W5Regular_11">fdlst_private_userId</samp>
    property to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Session</samp> interface.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Sharing the Session
    Across Pages and Components</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With the callback URL set up, we need to ensure that a user’s session is shared
    among all Next.js pages and React components. We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">useContext</samp>
    hook discussed in [Chapter 4](chapter4.xhtml), which *next-auth* provides for
    us. In the *pages/_app .tsx* file, wrap the application in a <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionProvider</samp>,
    as shown in [Listing 15-3](chapter15.xhtml#Lis15-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-3: The modified pages/_app.tsx file'
  prefs: []
  type: TYPE_NORMAL
- en: We import the <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionProvider</samp>
    from the *next-auth* package and enhance the <samp class="SANS_TheSansMonoCd_W5Regular_11">pageProps</samp>
    with the <samp class="SANS_TheSansMonoCd_W5Regular_11">session</samp> object.
    We store the current <samp class="SANS_TheSansMonoCd_W5Regular_11">session</samp>
    in the provider’s <samp class="SANS_TheSansMonoCd_W5Regular_11">session</samp>
    attribute, making it available throughout the Next.js application.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can access the session in the frontend and middleware, we need to
    add the <samp class="SANS_TheSansMonoCd_W5Regular_11">auth-element</samp> with
    the Sign In button, which will allow users to log in.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Generic Button Component</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s time to implement the generic button component we mentioned earlier. Technically,
    this component will be a generic <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>
    element that we’ll style to look like a button, with a few variations. It will
    serve as the Sign In/Sign Out button in the <samp class="SANS_TheSansMonoCd_W5Regular_11">auth-element</samp>
    and the Add To/Remove From button in the location detail component. Create a new
    folder, *button*, in the *components* folder, adding an *index.module.css* file
    with the code in [Listing 15-4](chapter15.xhtml#Lis15-4), as well as an *index.tsx*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-4: The components/button/index.module.css file'
  prefs: []
  type: TYPE_NORMAL
- en: We add styles for each of the button variations we’d like to create. All are
    35 pixels tall and have rounded corners. We define a default style, a variation
    with a blue background and white color, and an outlined version whose background
    is white. In addition, we define styles to use for deactivated buttons.
  prefs: []
  type: TYPE_NORMAL
- en: With the styles in place, we can write code for the component. Copy the contents
    of [Listing 15-5](chapter15.xhtml#Lis15-5) into the component’s *index.tsx* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-5: The components/button/index.tsx file'
  prefs: []
  type: TYPE_NORMAL
- en: After importing the dependencies, we define the interface for the component’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">prop</samp> argument. We also define
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Button</samp> component as a
    function that returns a JSX element and then use object-destructuring syntax to
    split the <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp> object into
    constants representing the object’s key-value pairs. We define the internal <samp
    class="SANS_TheSansMonoCd_W5Regular_11">renderContent</samp> function with one
    argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">children</samp>, typed
    as a <samp class="SANS_TheSansMonoCd_W5Regular_11">ReactNode</samp> and rendered
    wrapped in a span element. Depending on the state of the <samp class="SANS_TheSansMonoCd_W5Regular_11">disabled</samp>
    property, we also add the click handler from the <samp class="SANS_TheSansMonoCd_W5Regular_11">props</samp>
    object. The component itself returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">div</samp>
    that we styled to look like a button.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The AuthElement Component</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although we’ve added the *next-auth* package to the project, created the OAuth
    API route, and configured our OAuth provider, we still can’t access session information,
    as there is no Sign In button. Let’s create this <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthElement</samp>
    component and then add it to the header. This component uses our default button
    component, and as soon as the user is logged in, it displays their full name,
    as well as a link to their wish list.
  prefs: []
  type: TYPE_NORMAL
- en: Create the folder *auth-element* in the *components/header* directory and then
    add the *index.module.css* file with the code in [Listing 15-6](chapter15.xhtml#Lis15-6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-6: The components/header/auth-element/index.module.css file'
  prefs: []
  type: TYPE_NORMAL
- en: We define a set of basic styles for the component, using a flexbox and margins
    to align them vertically, and change their layout for smaller screens.
  prefs: []
  type: TYPE_NORMAL
- en: To write the component itself, add an *index.tsx* file to the *auth-element*
    folder and enter the code from [Listing 15-7](chapter15.xhtml#Lis15-7) into it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-7: The components/header/auth-element/index.tsx file'
  prefs: []
  type: TYPE_NORMAL
- en: The most notable imports are the <samp class="SANS_TheSansMonoCd_W5Regular_11">signIn</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">signOut</samp> functions and
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp> hook from
    *next-auth*. The latter enables us to access session information easily, whereas
    the two functions trigger the sign-in flow or terminate the session.
  prefs: []
  type: TYPE_NORMAL
- en: We then define the <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthElement</samp>
    component and retrieve the <samp class="SANS_TheSansMonoCd_W5Regular_11">session
    data</samp> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">session status</samp>
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp> hook.
    We need both of these to construct the JSX element we return from the component.
    On the client side, we can access the session information directly via the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp> hook. On the server
    side, though, we’ll need to access it through the JWT, because the session information
    is part of the API request’s HTTP cookies.
  prefs: []
  type: TYPE_NORMAL
- en: When the session’s status is authenticated, we render the user’s name from the
    session data and add the Your Wish List and Sign Out buttons to the navigation’s
    <samp class="SANS_TheSansMonoCd_W5Regular_11">nav</samp> element. Otherwise, we
    add the Sign In button to start the OAuth flow. For all of those, we use the generic
    button component and the <samp class="SANS_TheSansMonoCd_W5Regular_11">signIn</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">signOut</samp> functions we
    imported from the *next-auth* module, both of which handle the OAuth flow automatically.
  prefs: []
  type: TYPE_NORMAL
- en: We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">next/link</samp> element
    to link to the user’s wish list. (This is another Next.js page we’ll implement
    in a moment.) The wish list is available at the dynamic route */list/:userId*,
    which uses the user ID we created by hashing the user’s email address and storing
    it in <samp class="SANS_TheSansMonoCd_W5Regular_11">fdlst_private_userId</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Adding the AuthElement Component to
    the Header</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now we have to add the new component to the header. Open the *index.tsx* file
    in the *components/header* directory and adjust it so that it matches [Listing
    15-8](chapter15.xhtml#Lis15-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-8: The modified components/header/index.tsx file'
  prefs: []
  type: TYPE_NORMAL
- en: The update is simple; we import the <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthElement</samp>
    component and add it next to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Logo</samp>
    inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">header</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: Test the OAuth workflow to see our session management in practice. When you
    open *http://localhost:3000*, the Sign In button should be in the header, as in
    [Figure 15-2](chapter15.xhtml#fig15-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 15-2: The header in
    a logged-out state with the Sign In button</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s log in using OAuth. Click the **Sign In** button, and *next-auth* should
    redirect you to the login screen, where you can select to sign in with the configured
    OAuth providers to use ([Figure 15-3](chapter15.xhtml#fig15-3)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 15-3: OAuth requires
    us to choose a provider.</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Click the button to log in. OAuth should redirect you to the application, where
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">AuthElement</samp> renders your
    name and new buttons based on the session information. The screen should look
    similar to [Figure 15-4](chapter15.xhtml#fig15-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure15-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_BI_11">Figure 15-4: The header in
    the logged-in state with the session information</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The header element has changed according to the session’s state. We display
    the current user’s name received from the OAuth provider, the link to their public
    wish list, and the Sign Out button.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Wish List Next.js Page</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The wish list button in the header should link to a wish list page at the dynamic
    URL *list/:userId*. This regular Next.js page should display all locations whose
    <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp> property contains
    the user ID specified in the dynamic URL. It will look quite similar to the start
    page, and we can build it out of existing components.
  prefs: []
  type: TYPE_NORMAL
- en: To create the page’s route, create the *list* folder with the *[userId].tsx*
    file in the *pages* directory. Then add the code from [Listing 15-9](chapter15.xhtml#Lis15-9)
    to this *.tsx* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-9: The pages/list/[userId].tsx file'
  prefs: []
  type: TYPE_NORMAL
- en: Although we want the wish list page to look similar to the start page, we use
    SSR, with <samp class="SANS_TheSansMonoCd_W5Regular_11">getServerSideProps</samp>,
    as we did for the location detail page. The wish list page is highly dynamic;
    hence, we need to regenerate the HTML on each request.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach would be to use client-side rendering, then request the user’s
    locations through the GraphQL API in a <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    hook. However, this would cause the user to see a loading screen each time they
    opened the wish list page. We can avoid this inferior user experience altogether
    with SSR.
  prefs: []
  type: TYPE_NORMAL
- en: In the server-side part of the page’s code, we first extract the URL parameter,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">userId</samp>, from the context’s
    query object. We use the user’s ID and the <samp class="SANS_TheSansMonoCd_W5Regular_11">onUsersWishlist</samp>
    service to get all locations for the user’s wish list. If there is an error, we
    simply continue instead of redirecting to the *404* error page, rendering an empty
    list.
  prefs: []
  type: TYPE_NORMAL
- en: We then pass the locations array and the user’s ID to the Next.js page, where
    we extract the locations as usual, as well as the <samp class="SANS_TheSansMonoCd_W5Regular_11">userId</samp>.
    We compare the user ID from the URL with the user ID in the current session. If
    they match, we know that the currently logged-in user has visited their own wish
    list and adjust the user interface accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Adding the Button to the Location Detail
    Component</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can now visit the wish list page, but it will always be empty. We haven’t
    yet provided users with a way to add items to it. To change this, we’ll place
    a button in the location details component that lets users add or remove a particular
    location. We’ll use the generic button component and session information. Open
    the *index.ts* file in the *components/location-details.tsx* directory and modify
    the code to match [Listing 15-10](chapter15.xhtml#Lis15-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-10: The modified components/location-details/index.tsx file'
  prefs: []
  type: TYPE_NORMAL
- en: First we import <samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp>
    from <samp class="SANS_TheSansMonoCd_W5Regular_11">next-auth</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> from React,
    and the generic <samp class="SANS_TheSansMonoCd_W5Regular_11">Button</samp> component.
    Then we define <samp class="SANS_TheSansMonoCd_W5Regular_11">WishlistInterface</samp>,
    the interface for the <samp class="SANS_TheSansMonoCd_W5Regular_11">wishlistAction</samp>
    function we’ll implement in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the component, we get the <samp class="SANS_TheSansMonoCd_W5Regular_11">session</samp>
    from the <samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp> hook,
    then create the <samp class="SANS_TheSansMonoCd_W5Regular_11">onWishlist</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">loading</samp> state variables
    with <samp class="SANS_TheSansMonoCd_W5Regular_11">useState</samp> as Boolean
    values. We use the first state variable to specify whether a location is currently
    on the user’s wish list, then update the user interface accordingly. We calculate
    the initial state in the <samp class="SANS_TheSansMonoCd_W5Regular_11">useEffect</samp>
    hook based on the location’s <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp>
    property. As soon as we’ve successfully added or removed the location to or from
    the wish list, we update the state variable and the button’s text.
  prefs: []
  type: TYPE_NORMAL
- en: We implement the <samp class="SANS_TheSansMonoCd_W5Regular_11">wishlistAction</samp>
    function to update the <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp>
    property. First we deconstruct the argument object and then check the <samp class="SANS_TheSansMonoCd_W5Regular_11">loading</samp>
    state to see if there is currently a running request. If so, we exit the function.
    Otherwise, we set the loading state to <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>
    to block the user interface, calculate the action for the GraphQL mutations, and
    use it to call the <samp class="SANS_TheSansMonoCd_W5Regular_11">wishlist</samp>
    mutation. After successfully modifying the document in the database, we update
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">onWishlist</samp> state and
    unblock the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: We check the current session to see if the user is logged in. If so, we render
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">Button</samp> component and
    set the <samp class="SANS_TheSansMonoCd_W5Regular_11">disabled</samp> and class
    name attributes based on the loading state, as well as an on-click event. With
    each click of the button, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">wishlistAction</samp>
    function with the current location ID and user ID as arguments. Finally, we set
    the button’s text based on the <samp class="SANS_TheSansMonoCd_W5Regular_11">onWishlist</samp>
    state, either adding the current location to the wish list or removing it.
  prefs: []
  type: TYPE_NORMAL
- en: Try adding and removing a few locations to the wish list before moving on. Check
    that the button’s text changes accordingly and that a list of locations similar
    to the one on the start page appears on the wish list page.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Securing the GraphQL Mutations</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is one more thing we have to do to wrap up the application: secure the
    GraphQL API. While the queries should be publicly available, the mutations should
    be accessible only to logged-in users, who should be able to add or remove only
    their own user ID for the <samp class="SANS_TheSansMonoCd_W5Regular_11">on_wishlist</samp>
    property.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But if you test the API with the <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp>
    command, you’ll see that, currently, everyone can access the API. Note that you
    must enter the values supplied to the <samp class="SANS_TheSansMonoCd_W5Regular_11">-d</samp>
    flag on a single line, or the server might return an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As a test, we send a simple mutation to remove the location with the ID 12340
    from a nonexistent user’s wish list. (The mutation won’t work, which is fine;
    we just want to verify whether the API is accessible to the public.) The command
    receives a *200* response and the expected JSON, proving that the mutations are
    public.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement an <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp>
    to protect our mutations. A *guard* is a pattern that checks a condition and then
    throws an error if it isn’t met, and an *auth guard* protects a route or an API
    from unauthorized access.
  prefs: []
  type: TYPE_NORMAL
- en: We begin by creating the file *auth-guards.ts* in the *middleware* folder and
    adding the code in [Listing 15-11](chapter15.xhtml#Lis15-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-11: The middleware/auth-guards.ts file'
  prefs: []
  type: TYPE_NORMAL
- en: We also import <samp class="SANS_TheSansMonoCd_W5Regular_11">JWT</samp> from
    <samp class="SANS_TheSansMonoCd_W5Regular_11">next-auth</samp> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphQLError</samp>
    constructor from <samp class="SANS_TheSansMonoCd_W5Regular_11">graphql</samp>.
    We’ll use the latter to create the error objects returned to the user if authentication
    fails. Next, we define our interfaces for the <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp>
    function’s arguments and export the function itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll call the auth guard from the mutation resolver with two parameters: an
    object with the user ID and the location ID, for which we defined the <samp class="SANS_TheSansMonoCd_W5Regular_11">paramInterface</samp>,
    and the context object with the token, the <samp class="SANS_TheSansMonoCd_W5Regular_11">contextInterface</samp>.
    The auth guard returns either a Boolean indicating that authentication succeeded
    or an error. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp>
    function, we verify that every access to our mutation has a token with a private
    claim ❶ and that the user ID in the private claim matches the user ID we pass
    to the mutation ❷. In other words, we verify that a logged-in user has made the
    API request and that they’re modifying their own wish list.'
  prefs: []
  type: TYPE_NORMAL
- en: If the checks fail, we create an error with a message and code. In addition,
    we set the HTTP status code to *500*. Remember that unlike REST APIs, which rely
    on an extensive list of precise HTTP status codes to communicate with the caller,
    a GraphQL API usually uses either *200* or *500* as the status code for errors.
    Broadly speaking, we send a *500* status code when GraphQL can’t execute the query
    at all and *200* when the query can be executed. In both cases, the GraphQL API
    should include precise information about what error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Now we must pass the user’s OAuth token to the resolvers, which will then pass
    it to the auth guard. To do so, we’ll use the context function we implemented
    in the <samp class="SANS_TheSansMonoCd_W5Regular_11">startServerAndCreateNextHandler</samp>
    function, found in the *pages/api/graphql.ts* file. Open the file and adjust it
    to match the code in [Listing 15-12](chapter15.xhtml#Lis15-12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-12: The modified pages/api/graphql.ts file with the JWT token'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike on the client side, where we can access the session information directly
    via the <samp class="SANS_TheSansMonoCd_W5Regular_11">useSession</samp> hook,
    here we need to access it through the JWT on the server side. This is because
    the session information is part of the API request’s HTTP cookies on the server
    instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionProvider</samp>’s
    shared session state, and we need to extract it from the request. To do so, we
    import the <samp class="SANS_TheSansMonoCd_W5Regular_11">getToken</samp> function
    from the *next-auth* <samp class="SANS_TheSansMonoCd_W5Regular_11">jwt</samp>
    module. Then we pass the request object we receive from the <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp>
    function to call <samp class="SANS_TheSansMonoCd_W5Regular_11">getToken</samp>
    and await the decoded JWT. Next, we return the token from the <samp class="SANS_TheSansMonoCd_W5Regular_11">context</samp>
    function so that we can access the token in the resolver functions.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s use the token to add the <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp>
    to our resolvers to protect them from unauthenticated and unauthorized access.
    Open the *graphql/locations/mutations.ts* file and update it with the code from
    [Listing 15-13](chapter15.xhtml#Lis15-13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-13: The graphql/locations/mutations.ts file with the added <samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">authGuard</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: We define a new interface for the context and update the context parameter to
    contain the JWT. Next, we add the <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp>
    function to our mutations and follow the guard pattern by returning the error
    immediately instead of proceeding with the code.
  prefs: []
  type: TYPE_NORMAL
- en: To test the <samp class="SANS_TheSansMonoCd_W5Regular_11">authGuard</samp> functionality,
    run <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp> again. The command
    line output should look similar to [Listing 15-14](chapter15.xhtml#Lis15-14).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 15-14: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">curl</samp>
    command to test our API'
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the previous <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp>
    call, the GraphQL API now responds with <samp class="SANS_TheSansMonoCd_W5Regular_11">HTTP/1.1
    500 Internal Server Error</samp> and an extensive error message, which we defined
    when we created the <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphQLError</samp>
    in the *auth-guards.ts* file.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve successfully added an OAuth authentication flow to the Food Finder application.
    Now the user can log in with their GitHub account. Once logged in, they can maintain
    their personal public wish list. In addition, we’ve protected the GraphQL mutations,
    meaning they are no longer available to anyone; instead, only logged-in users
    can access them. In the final chapter, we’ll add automated tests to evaluate the
    application using Jest.
  prefs: []
  type: TYPE_NORMAL
