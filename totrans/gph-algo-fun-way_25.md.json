["```\ndef make_graph_from_edges(num_nodes: int,\n                          undirected: bool,\n                          edge_list: list) -> Graph: \n    g: Graph = Graph(num_nodes, undirected)\n    for edge in edge_list:\n        g.insert_edge(edge.from_node, edge.to_node, edge.weight)\n    return g \n```", "```\ndef make_graph_from_weighted_csv(filename: str, undirected: bool) -> Graph: \n    g: Graph = Graph(0, undirected)\n    node_indices: dict = {}\n\n  ❶ with open(filename) as f:\n        graph_reader = csv.reader(f, delimiter=',')\n      ❷ for row in graph_reader:\n            name1: str = row[0]\n            if name1 not in node_indices:\n                new_node: Node = g.insert_node(label=name1)\n                node_indices[name1] = new_node.index\n            index1: int = node_indices[name1]\n\n          ❸ if len(row) > 1:\n                name2: str = row[1]\n                if name2 not in node_indices:\n                    new_node = g.insert_node(label=name2)\n                    node_indices[name2] = new_node.index\n                index2: int = node_indices[name2] ❹ if len(row) > 2:\n                    weight: float = float(row[2])\n                else:\n                    weight = 1.0\n\n                g.insert_edge(index1, index2, weight)\n    return g \n```", "```\ndef save_graph_to_csv(g: Graph, filename: str): \n  ❶ with open(filename, 'w', newline=\"\\n\") as f:\n        graph_writer = csv.writer(f, delimiter=',')\n      ❷ for node in g.nodes:\n            graph_writer.writerow([node.index])\n\n      ❸ for node in g.nodes:\n            for edge in node.get_edge_list():\n                graph_writer.writerow([edge.from_node, edge.to_node,\n                                       edge.weight]) \n```", "```\nself.node_indices: dict = {} \n```", "```\ndef get_index_by_name(self, name: str) -> int: \n    if name not in self.node_indices:\n        new_node: Node = self.insert_node() self.node_indices[name] = new_node.index\n    return self.node_indices[name] \n```", "```\ndef make_graph_from_weighted_csv2(filename: str, undirected: bool) -> Graph: \n    g: Graph = Graph(0, undirected)\n\n    with open(filename) as f:\n        graph_reader = csv.reader(f, delimiter=',')\n        for row in graph_reader:\n          ❶ index1: int = g.get_index_by_name(row[0])\n\n            if len(row) > 1:\n              ❷ index2: int = g.get_index_by_name(row[1])\n\n                if len(row) > 2:\n                    weight: float = float(row[2])\n                else:\n                    weight = 1.0\n                g.insert_edge(index1, index2, weight)\n    return g \n```", "```\ndef make_graph_from_multi_csv(filename: str) -> Graph: \n    g: Graph = Graph(0, undirected=True)\n    with open(filename) as f:\n        graph_reader = csv.reader(f, delimiter=',')\n        for row in graph_reader:\n            num_items: int = len(row)\n\n            for i in range(num_items):\n                index1: int = g.get_index_by_name(row[i])\n\n                for j in range(i + 1, num_items):\n                    index2: int = g.get_index_by_name(row[j])\n                    edge: Union[Edge, None] = g.get_edge(index1, index2)\n                  ❶ if edge is not None:\n                        weight = edge.weight + 1.0\n                    else:\n                        weight = 1.0\n                  ❷ g.insert_edge(index1, index2, weight)\n    return g \n```", "```\nclass Point: \n    def __init__(self, x: float, y: float):\n        self.x: float = x\n        self.y: float = y\n\n    def distance(self, b) -> float:\n        diff_x: float = (self.x - b.x)\n        diff_y: float = (self.y - b.y)\n      ❶ dist: float = math.sqrt(diff_x*diff_x + diff_y*diff_y)\n        return dist \n```", "```\n dist: float = abs(diff_x) + abs(diff_y) \n```", "```\ndef build_graph_from_points(points: list) -> Graph:  \n    num_pts: int = len(points)\n    g: Graph = Graph(num_pts, undirected=True)\n\n    for i in range(num_pts):\n        for j in range(i + 1, num_pts): dist: float = points[i].distance(points[j])\n            g.insert_edge(i, j, dist)\n    return g \n```", "```\ndef make_graph_from_dependencies(dependencies: dict) -> Graph: \n    g: Graph = Graph(0, undirected=False)\n    for node in dependencies:\n        n_index: int = g.get_index_by_name(node) for prior in dependencies[node]:\n            p_index: int = g.get_index_by_name(prior)\n            g.insert_edge(p_index, n_index, 1.0)\n    return g \n```"]