- en: Chapter 48. System V Shared Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter describes System V shared memory. Shared memory allows two or more
    processes to share the same region (usually referred to as a *segment*) of physical
    memory. Since a shared memory segment becomes part of a process’s user-space memory,
    no kernel intervention is required for IPC. All that is required is that one process
    copies data into the shared memory; that data is immediately available to all
    other processes sharing the same segment. This provides fast IPC by comparison
    with techniques such as pipes or message queues, where the sending process copies
    data from a buffer in user space into kernel memory and the receiving process
    copies in the reverse direction. (Each process also incurs the overhead of a system
    call to perform the copy operation.)
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the fact that IPC using shared memory is not mediated by
    the kernel means that, typically, some method of synchronization is required so
    that processes don’t simultaneously access the shared memory (e.g., two processes
    performing simultaneous updates, or one process fetching data from the shared
    memory while another process is in the middle of updating it). System V semaphores
    are a natural method for such synchronization. Other methods, such as POSIX semaphores
    ([Chapter 53](ch53.html "Chapter 53. POSIX Semaphores")) and file locks ([Chapter 55](ch55.html
    "Chapter 55. File Locking")), are also possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In *mmap()* terminology, a memory region is *mapped* at an address, while in
    System V terminology, a shared memory segment is *attached* at an address. These
    terms are equivalent; the terminology differences are a consequence of the separate
    origins of these two APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to use a shared memory segment, we typically perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Call *shmget()* to create a new shared memory segment or obtain the identifier
    of an existing segment (i.e., one created by another process). This call returns
    a shared memory identifier for use in later calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use *shmat()* to *attach* the shared memory segment; that is, make the segment
    part of the virtual memory of the calling process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At this point, the shared memory segment can be treated just like any other
    memory available to the program. In order to refer to the shared memory, the program
    uses the *addr* value returned by the *shmat()* call, which is a pointer to the
    start of the shared memory segment in the process’s virtual address space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call *shmdt()* to detach the shared memory segment. After this call, the process
    can no longer refer to the shared memory. This step is optional, and happens automatically
    on process termination.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call *shmctl()* to delete the shared memory segment. The segment will be destroyed
    only after all currently attached processes have detached it. Only one process
    needs to perform this step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating or Opening a Shared Memory Segment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *shmget()* system call creates a new shared memory segment or obtains the
    identifier of an existing segment. The contents of a newly created shared memory
    segment are initialized to 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns shared memory segment identifier on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *key* argument is a key generated using one of the methods described in
    [IPC Keys](ch45.html#ipc_keys "IPC Keys") (i.e., usually the value `IPC_PRIVATE`
    or a key returned by *ftok()*).
  prefs: []
  type: TYPE_NORMAL
- en: When we use *shmget()* to create a new shared memory segment, *size* specifies
    a positive integer that indicates the desired size of the segment, in bytes. The
    kernel allocates shared memory in multiples of the system page size, so *size*
    is effectively rounded up to the next multiple of the system page size. If we
    are using *shmget()* to obtain the identifier of an existing segment, then *size*
    has no effect on the segment, but it must be less than or equal to the size of
    the segment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *shmflg* argument performs the same task as for the other IPC *get* calls,
    specifying the permissions ([Table 15-4](ch15.html#constants_for_file_permission_bits
    "Table 15-4. Constants for file permission bits"), in [Permissions on Regular
    Files](ch15.html#permissions_on_regular_files "Permissions on Regular Files"))
    to be placed on a new shared memory segment or checked against an existing segment.
    In addition, zero or more of the following flags can be ORed (|) in *shmflg* to
    control the operation of *shmget()*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`IPC_CREAT`'
  prefs: []
  type: TYPE_NORMAL
- en: If no segment with the specified *key* exists, create a new segment.
  prefs: []
  type: TYPE_NORMAL
- en: '`IPC_EXCL`'
  prefs: []
  type: TYPE_NORMAL
- en: If `IPC_CREAT` was also specified, and a segment with the specified *key* already
    exists, fail with the error `EEXIST`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above flags are described in more detail in Section 45.1\. In addition,
    Linux permits the following nonstandard flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SHM_HUGETLB` (since Linux 2.6)'
  prefs: []
  type: TYPE_NORMAL
- en: A privileged (`CAP_IPC_LOCK`) process can use this flag to create a shared memory
    segment that uses *huge pages*. Huge pages are a feature provided by many modern
    hardware architectures to manage memory using very large page sizes. (For example,
    x86-32 allows 4-MB pages as an alternative to 4-kB pages.) On systems that have
    large amounts of memory, and where applications require large blocks of memory,
    using huge pages reduces the number of entries required in the hardware memory
    management unit’s translation look-aside buffer (TLB). This is beneficial because
    entries in the TLB are usually a scarce resource. See the kernel source file `Documentation/vm/hugetlbpage.txt`
    for further information.
  prefs: []
  type: TYPE_NORMAL
- en: '`SHM_NORESERVE` (since Linux 2.6.15)'
  prefs: []
  type: TYPE_NORMAL
- en: This flag serves the same purpose for *shmget()* as the `MAP_NORESERVE` flag
    serves for *mmap()*. See Section 49.9.
  prefs: []
  type: TYPE_NORMAL
- en: On success, *shmget()* returns the identifier for the new or existing shared
    memory segment.
  prefs: []
  type: TYPE_NORMAL
- en: Using Shared Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *shmat()* system call attaches the shared memory segment identified by *shmid*
    to the calling process’s virtual address space.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns address at which shared memory is attached on success, or *(void *)*
    -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: 'The *shmaddr* argument and the setting of the `SHM_RND` bit in the *shmflg*
    bit-mask argument control how the segment is attached:'
  prefs: []
  type: TYPE_NORMAL
- en: If *shmaddr* is `NULL`, then the segment is attached at a suitable address selected
    by the kernel. This is the preferred method of attaching a segment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *shmaddr* is not `NULL`, and `SHM_RND` is not set, then the segment is attached
    at the address specified by *shmaddr*, which must be a multiple of the system
    page size (or the error `EINVAL` results).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If *shmaddr* is not `NULL`, and `SHM_RND` is set, then the segment is mapped
    at the address provided in *shmaddr*, rounded down to the nearest multiple of
    the constant `SHMLBA` (*shared memory low boundary address*). This constant is
    equal to some multiple of the system page size. Attaching a segment at an address
    that is a multiple of `SHMLBA` is necessary on some architectures in order to
    improve CPU cache performance and to prevent the possibility that different attaches
    of the same segment have inconsistent views within the CPU cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On the x86 architectures, `SHMLBA` is the same as the system page size, reflecting
    the fact that such caching inconsistencies can’t arise on those architectures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifying a non-`NULL` value for *shmaddr* (i.e., either the second or third
    option listed above) is not recommended, for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It reduces the portability of an application. An address valid on one UNIX implementation
    may be invalid on another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An attempt to attach a shared memory segment at a particular address will fail
    if that address is already in use. This could happen if, for example, the application
    (perhaps inside a library function) had already attached another segment or created
    a memory mapping at that address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As its function result, *shmat()* returns the address at which the shared memory
    segment is attached. This value can be treated like a normal C pointer; the segment
    looks just like any other part of the process’s virtual memory. Typically, we
    assign the return value from *shmat()* to a pointer to some programmer-defined
    structure, in order to impose that structure on the segment (see, for example,
    [Example 48-2](ch48.html#transfer_blocks_of_data_from_stdin_to_a "Example 48-2. Transfer
    blocks of data from stdin to a System V shared memory segment")).
  prefs: []
  type: TYPE_NORMAL
- en: To attach a shared memory segment for read-only access, we specify the flag
    `SHM_RDONLY` in *shmflg*. Attempts to update the contents of a read-only segment
    result in a segmentation fault (the `SIGSEGV` signal). If `SHM_RDONLY` is not
    specified, the memory can be both read and modified.
  prefs: []
  type: TYPE_NORMAL
- en: To attach a shared memory segment, a process requires read and write permissions
    on the segment, unless `SHM_RDONLY` is specified, in which case only read permission
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is possible to attach the same shared memory segment multiple times within
    a process, and even to make one attach read-only while another is read-write.
    The contents of the memory at each attachment point are the same, since the different
    entries of the process virtual memory page tables are referring to the same physical
    pages of memory.
  prefs: []
  type: TYPE_NORMAL
- en: One final value that may be specified in *shmflg* is `SHM_REMAP`. In this case,
    *shmaddr* must be non-`NULL`. This flag requests that the *shmat()* call replace
    any existing shared memory attachment or memory mapping in the range starting
    at *shmaddr* and continuing for the length of the shared memory segment. Normally,
    if we try to attach a shared memory segment at an address range that is already
    in use, the error `EINVAL` results. `SHM_REMAP` is a nonstandard Linux extension.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 48-1](ch48.html#shmflg_bit-mask_values_for_shmat_open_pa "Table 48-1. shmflg
    bit-mask values for shmat()") summarizes the constants that can be ORed in the
    *shmflg* argument of *shmat()*.'
  prefs: []
  type: TYPE_NORMAL
- en: When a process no longer needs to access a shared memory segment, it can call
    *shmdt()* to detach the segment from its virtual address space. The *shmaddr*
    argument identifies the segment to be detached. It should be a value returned
    by a previous call to *shmat()*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: Detaching a shared memory segment is not the same as deleting it. Deletion is
    performed using the *shmctl()* `IPC_RMID` operation, as described in Section 48.7.
  prefs: []
  type: TYPE_NORMAL
- en: A child created by *fork()* inherits its parent’s attached shared memory segments.
    Thus, shared memory provides an easy method of IPC between parent and child.
  prefs: []
  type: TYPE_NORMAL
- en: During an *exec()*, all attached shared memory segments are detached. Shared
    memory segments are also automatically detached on process termination.
  prefs: []
  type: TYPE_NORMAL
- en: Table 48-1. *shmflg* bit-mask values for *shmat()*
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SHM_RDONLY` | Attach segment read-only |'
  prefs: []
  type: TYPE_TB
- en: '| `SHM_REMAP` | Replace any existing mapping at *shmaddr* |'
  prefs: []
  type: TYPE_TB
- en: '| `SHM_RND` | Round *shmaddr* down to multiple of `SHMLBA` bytes |'
  prefs: []
  type: TYPE_TB
- en: 'Example: Transferring Data via Shared Memory'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now look at an example application that uses System V shared memory and
    semaphores. The application consists of two programs: the *writer* and the *reader*.
    The writer reads blocks of data from standard input and copies (“writes”) them
    into a shared memory segment. The reader copies (“reads”) blocks of data from
    the shared memory segment to standard output. In effect, the programs treat the
    shared memory somewhat like a pipe.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The two programs employ a pair of System V semaphores in a binary semaphore
    protocol (the *initSemAvailable()*, *initSemInUse()*, *reserveSem()*, and *releaseSem()*
    functions defined in [Implementing a Binary Semaphores Protocol](ch47.html#implementing_a_binary_semaphores_protoco
    "Implementing a Binary Semaphores Protocol")) to ensure that:'
  prefs: []
  type: TYPE_NORMAL
- en: only one process accesses the shared memory segment at a time; and
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the processes alternate in accessing the segment (i.e., the writer writes some
    data, then the reader reads the data, then the writer writes again, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 48-1](ch48.html#using_semaphores_to_ensure_exclusive_com "Figure 48-1. Using
    semaphores to ensure exclusive, alternating access to shared memory") provides
    an overview of the use of these two semaphores. Note that the writer initializes
    the two semaphores so that it is the first of the two programs to be able to access
    the shared memory segment; that is, the writer’s semaphore is initially available,
    and the reader’s semaphore is initially in use.'
  prefs: []
  type: TYPE_NORMAL
- en: The source code for the application consists of three files. The first of these,
    [Example 48-1](ch48.html#header_file_for_svshm_underscore_xfr_und "Example 48-1. Header
    file for svshm_xfr_writer.c and svshm_xfr_reader.c"), is a header file shared
    by the reader and writer programs. This header defines the *shmseg* structure
    that we use to declare pointers to the shared memory segment. Doing this allows
    us to impose a structure on the bytes of the shared memory segment.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using semaphores to ensure exclusive, alternating access to shared memory](figs/web/48-1_SVSHM-shm_xfr.png.jpg)Figure 48-1. Using
    semaphores to ensure exclusive, alternating access to shared memoryExample 48-1. Header
    file for `svshm_xfr_writer.c` and `svshm_xfr_reader.c`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 48-2](ch48.html#transfer_blocks_of_data_from_stdin_to_a "Example 48-2. Transfer
    blocks of data from stdin to a System V shared memory segment") is the writer
    program. This program performs the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a set containing the two semaphores that are used by the writer and reader
    program to ensure that they alternate in accessing the shared memory segment ![](figs/web/U001.png).
    The semaphores are initialized so that the writer has first access to the shared
    memory segment. Since the writer creates the semaphore set, it must be started
    before the reader.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the shared memory segment and attach it to the writer’s virtual address
    space at an address chosen by the system ![](figs/web/U002.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enter a loop that transfers data from standard input to the shared memory segment
    ![](figs/web/U003.png). The following steps are performed in each loop iteration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reserve (decrement) the writer semaphore ![](figs/web/U004.png).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Read data from standard input into the shared memory segment ![](figs/web/U005.png).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Release (increment) the reader semaphore ![](figs/web/U006.png).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The loop terminates when no further data is available from standard input ![](figs/web/U007.png).
    On the last pass through the loop, the writer indicates to the reader that there
    is no more data by passing a block of data of length 0 (*shmp -> cnt* is 0).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upon exiting the loop, the writer once more reserves its semaphore, so that
    it knows that the reader has completed the final access to the shared memory ![](figs/web/U008.png).
    The writer then removes the shared memory segment and semaphore set ![](figs/web/U009.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example 48-3](ch48.html#transfer_blocks_of_data_from_a_system_v "Example 48-3. Transfer
    blocks of data from a System V shared memory segment to stdout") is the reader
    program. It transfers blocks of data from the shared memory segment to standard
    output. The reader performs the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Obtain the IDs of the semaphore set and shared memory segment that were created
    by the writer program ![](figs/web/U001.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attach the shared memory segment for read-only access ![](figs/web/U002.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enter a loop that transfers data from the shared memory segment ![](figs/web/U003.png).
    The following steps are performed in each loop iteration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reserve (decrement) the reader semaphore ![](figs/web/U004.png).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether *shmp -> cnt* is 0; if so, exit this loop ![](figs/web/U005.png).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the block of data in the shared memory segment to standard output ![](figs/web/U006.png).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Release (increment) the writer semaphore ![](figs/web/U007.png).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After exiting the loop, detach the shared memory segment ![](figs/web/U008.png)
    and releases the writer semaphore ![](figs/web/U009.png), so that the writer program
    can remove the IPC objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Example 48-2. Transfer blocks of data from *stdin* to a System V shared memory
    segment
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Example 48-3. Transfer blocks of data from a System V shared memory segment
    to *stdout*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The following shell session demonstrates the use of the programs in [Example 48-2](ch48.html#transfer_blocks_of_data_from_stdin_to_a
    "Example 48-2. Transfer blocks of data from stdin to a System V shared memory
    segment") and [Example 46-9](ch46.html#client_for_file_server_using_system_v_me
    "Example 46-9. Client for file server using System V message queues"). We invoke
    the writer, using the file `/etc/services` as input, and then invoke the reader,
    directing its output to another file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The *diff* command produced no output, indicating that the output file produced
    by the reader has the same content as the input file used by the writer.
  prefs: []
  type: TYPE_NORMAL
- en: Location of Shared Memory in Virtual Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Memory Layout of a Process](ch06.html#memory_layout_of_a_process "Memory
    Layout of a Process"), we considered the layout of the various parts of a process
    in virtual memory. It is useful to revisit this topic in the context of attaching
    System V shared memory segments. If we follow the recommended approach of allowing
    the kernel to choose where to attach a shared memory segment, then (on the x86-32
    architecture) the memory layout appears as shown in [Figure 48-2](ch48.html#locations_of_shared_memory_comma_memory
    "Figure 48-2. Locations of shared memory, memory mappings, and shared libraries
    (x86-32)"), with the segment being attached in the unallocated space between the
    upwardly growing heap and the downwardly growing stack. To allow space for heap
    and stack growth, shared memory segments are attached starting at the virtual
    address `0x40000000`. Mapped mappings ([Chapter 49](ch49.html "Chapter 49. Memory
    Mappings")) and shared libraries ([Chapter 41](ch41.html "Chapter 41. Fundamentals
    of Shared Libraries") and [Chapter 42](ch42.html "Chapter 42. Advanced Features
    of Shared Libraries")) are also placed in this area. (There is some variation
    in the default location at which shared memory mappings and memory segments are
    placed, depending on the kernel versions and the setting of the process’s `RLIMIT_STACK`
    resource limit.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The address `0x40000000` is defined as the kernel constant `TASK_UNMAPPED_BASE`.
    It is possible to change this address by defining this constant with a different
    value and rebuilding the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: A shared memory segment (or memory mapping) can be placed at an address below
    `TASK_UNMAPPED_BASE`, if we employ the unrecommended approach of explicitly specifying
    an address when calling *shmat()* (or *mmap()*).
  prefs: []
  type: TYPE_NORMAL
- en: Using the Linux-specific `/proc/`*PID*`/maps` file, we can see the location
    of the shared memory segments and shared libraries mapped by a program, as we
    demonstrate in the shell session below.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with kernel 2.6.14, Linux also provides the `/proc/`*PID*`/smaps` file,
    which exposes more information about the memory consumption of each of a process’s
    mappings. For further details, see the *proc(5)* manual page.
  prefs: []
  type: TYPE_NORMAL
- en: '![Locations of shared memory, memory mappings, and shared libraries (x86-32)](figs/web/48-2_SVSHM-shm-layout.png.jpg)Figure 48-2. Locations
    of shared memory, memory mappings, and shared libraries (x86-32)'
  prefs: []
  type: TYPE_IMG
- en: 'In the shell session below, we employ three programs that are not shown in
    this chapter, but are provided in the `svshm` subdirectory in the source code
    distribution for this book. These programs perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: The `svshm_create.c` program creates a shared memory segment. This program takes
    the same command-line options as the corresponding programs that we provide for
    message queues ([Example 46-1](ch46.html#using_msgget_open_parenthesis_close_pare
    "Example 46-1. Using msgget()"), in [Creating or Opening a Message Queue](ch46.html#creating_or_opening_a_message_queue
    "Creating or Opening a Message Queue")) and semaphores, but includes an additional
    argument that specifies the size of the segment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `svshm_attach.c` program attaches the shared memory segments identified
    by its command-line arguments. Each of these arguments is a colon-separated pair
    of numbers consisting of a shared memory identifier and an attach address. Specifying
    0 for the attach address means that the system should choose the address. The
    program displays the address at which the memory is actually attached. For informational
    purposes, the program also displays the value of the SHMLBA constant and the process
    ID of the process running the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `svshm_rm.c` program deletes the shared memory segments identified by its
    command-line arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We begin the shell session by creating two shared memory segments (100 kB and
    3200 kB in size):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We then start a program that attaches these two segments at addresses chosen
    by the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The output above shows the addresses at which the segments were attached. Before
    the program completes sleeping, we suspend it, and then examine the contents of
    the corresponding `/proc/`*PID*`/maps` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The output produced by the *cat* command is shown in [Example 48-4](ch48.html#example_of_contents_of_solidus_proc_soli
    "Example 48-4. Example of contents of /proc/PID/maps").
  prefs: []
  type: TYPE_NORMAL
- en: Example 48-4. Example of contents of `/proc/`*PID*`/maps`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output from `/proc/`*PID*`/maps` shown in [Example 48-4](ch48.html#example_of_contents_of_solidus_proc_soli
    "Example 48-4. Example of contents of /proc/PID/maps"), we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Three lines for the main program, *shm_attach*. These correspond to the text
    and data segments of the program ![](figs/web/U001.png). The second of these lines
    is for a read-only page holding the string constants used by the program.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two lines for the attached System V shared memory segments ![](figs/web/U002.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lines corresponding to the segments for two shared libraries. One of these is
    the standard C library (`libc`-*version*.`so`) ![](figs/web/U003.png). The other
    is the dynamic linker (`ld`-*version*.`so`), which we describe in [Using a Shared
    Library](ch41.html#using_a_shared_library "Using a Shared Library") ![](figs/web/U004.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line labeled `[stack]`. This corresponds to the process stack ![](figs/web/U005.png).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A line containing the tag `[vdso]` ![](figs/web/U006.png). This is an entry
    for the *linux-gate* virtual dynamic shared object (DSO). This entry appears only
    in kernels since 2.6.12\. See [http://www.trilithium.com/johan/2005/08/linux-gate/](http://www.trilithium.com/johan/2005/08/linux-gate/)
    for further information about this entry.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following columns are shown in each line of `/proc/`*PID*`/maps`, in order
    from left to right:'
  prefs: []
  type: TYPE_NORMAL
- en: A pair of hyphen-separated numbers indicating the virtual address range (in
    hexadecimal) at which the memory segment is mapped. The second of these numbers
    is the address of the next byte *after* the end of the segment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Protection and flags for this memory segment. The first three letters indicate
    the protection of the segment: read (`r`), write (`w`), and execute (`x`). A hyphen
    (`-`) in place of any of these letters indicates that the corresponding protection
    is disabled. The final letter indicates the mapping flag for the memory segment;
    it is either private (`p`) or shared (`s`). For an explanation of these flags,
    see the description of the `MAP_PRIVATE` and `MAP_SHARED` flags in Section 49.2\.
    (A System V shared memory segment is always marked shared.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The hexadecimal offset (in bytes) of the segment within the corresponding mapped
    file. The meanings of this and the following two columns will become clearer when
    we describe the *mmap()* system call in [Chapter 49](ch49.html "Chapter 49. Memory
    Mappings"). For a System V shared memory segment, the offset is always 0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The device number (major and minor IDs) of the device on which the corresponding
    mapped file is located.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The i-node number of the mapped file, or, for System V shared memory segments,
    the identifier for the segment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The filename or other identifying tag associated with this memory segment.
    For a System V shared memory segment, this consists of the string `SYSV` concatenated
    with the *shmget() key* of the segment (expressed in hexadecimal). In this example,
    `SYSV` is followed by zeros because we created the segments using the key `IPC_PRIVATE`
    (which has the value 0). The string `(deleted)` that appears after the `SYSV`
    field for a System V shared memory segment is an artifact of the implementation
    of shared memory segments. Such segments are created as mapped files in an invisible
    *tmpfs* file system ([A Virtual Memory File System: *tmpfs*](ch14.html#a_virtual_memory_file_system_colon_tmpfs
    "A Virtual Memory File System: tmpfs")), and then later unlinked. Shared anonymous
    memory mappings are implemented in the same manner. (We describe mapped files
    and shared anonymous memory mappings in [Chapter 49](ch49.html "Chapter 49. Memory
    Mappings").)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Storing Pointers in Shared Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each process may employ different shared libraries and memory mappings, and
    may attach different sets of shared memory segments. Therefore, if we follow the
    recommended practice of letting the kernel choose where to attach a shared memory
    segment, the segment may be attached at a different address in each process. For
    this reason, when storing references inside a shared memory segment that point
    to other addresses within the segment, we should use (relative) offsets, rather
    than (absolute) pointers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose we have a shared memory segment whose starting address
    is pointed to by *baseaddr* (i.e., *baseaddr* is the value returned by *shmat()*).
    Furthermore, at the location pointed to by *p*, we want to store a pointer to
    the same location as is pointed to by *target*, as shown in [Figure 48-3](ch48.html#using_pointers_in_a_shared_memory_segmen
    "Figure 48-3. Using pointers in a shared memory segment"). This sort of operation
    would be typical if we were building a linked list or a binary tree within the
    segment. The usual C idiom for setting **p* would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![Using pointers in a shared memory segment](figs/web/48-3_SVSHM-pointers-scale90.png.jpg)Figure 48-3. Using
    pointers in a shared memory segment'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with this code is that the location pointed to by *target* may
    reside at a different virtual address when the shared memory segment is attached
    in another process, which means that the value stored at **p* is meaningless in
    that process. The correct approach is to store an offset at **p*, as in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When dereferencing such pointers, we reverse the above step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, we assume that in each process, *baseaddr* points to the start of the
    shared memory segment (i.e., it is the value returned by *shmat()* in each process).
    Given this assumption, an offset value is correctly interpreted, no matter where
    the shared memory segment is attached in a process’s virtual address space.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, if we are linking together a set of fixed-size structures, we
    can cast the shared memory segment (or a part thereof) as an array, and then use
    index numbers as the “pointers” referring from one structure to another.
  prefs: []
  type: TYPE_NORMAL
- en: Shared Memory Control Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *shmctl()* system call performs a range of control operations on the shared
    memory segment identified by *shmid*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returns 0 on success, or -1 on error
  prefs: []
  type: TYPE_NORMAL
- en: The *cmd* argument specifies the control operation to be performed. The *buf*
    argument is required by the `IPC_STAT` and `IPC_SET` operations (described below),
    and should be specified as `NULL` for the remaining operations.
  prefs: []
  type: TYPE_NORMAL
- en: In the remainder of this section, we describe the various operations that can
    be specified for *cmd*.
  prefs: []
  type: TYPE_NORMAL
- en: Generic control operations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The following operations are the same as for other types of System V IPC objects.
    Further details about these operations, including the privileges and permissions
    required by the calling process, are described in Section 45.3.
  prefs: []
  type: TYPE_NORMAL
- en: '`IPC_RMID`'
  prefs: []
  type: TYPE_NORMAL
- en: Mark the shared memory segment and its associated *shmid_ds* data structure
    for deletion. If no processes currently have the segment attached, deletion is
    immediate; otherwise, the segment is removed after all processes have detached
    from it (i.e., when the value of the *shm_nattch* field in the *shmid_ds* data
    structure falls to 0). In some applications, we can make sure that a shared memory
    segment is tidily cleared away on application termination by marking it for deletion
    immediately after all processes have attached it to their virtual address space
    with *shmat()*. This is analogous to unlinking a file once we’ve opened it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On Linux, if a shared segment has been marked for deletion using `IPC_RMID`,
    but has not yet been removed because some process still has it attached, then
    it is possible for another process to attach that segment. However, this behavior
    is not portable: most UNIX implementations prevent new attaches to a segment marked
    for deletion. (SUSv3 is silent on what behavior should occur in this scenario.)
    A few Linux applications have come to depend on this behavior, which is why Linux
    has not been changed to match other UNIX implementations.'
  prefs: []
  type: TYPE_NORMAL
- en: '`IPC_STAT`'
  prefs: []
  type: TYPE_NORMAL
- en: Place a copy of the *shmid_ds* data structure associated with this shared memory
    segment in the buffer pointed to by *buf*. (We describe this data structure in
    Section 48.8.)
  prefs: []
  type: TYPE_NORMAL
- en: '`IPC_SET`'
  prefs: []
  type: TYPE_NORMAL
- en: Update selected fields of the *shmid_ds* data structure associated with this
    shared memory segment using values in the buffer pointed to by *buf*.
  prefs: []
  type: TYPE_NORMAL
- en: Locking and unlocking shared memory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A shared memory segment can be locked into RAM, so that it is never swapped
    out. This provides a performance benefit, since, once each page of the segment
    is memory-resident, an application is guaranteed never to be delayed by a page
    fault when it accesses the page. There are two *shmctl()* locking operations:'
  prefs: []
  type: TYPE_NORMAL
- en: The `SHM_LOCK` operation locks a shared memory segment into memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SHM_UNLOCK` operation unlocks the shared memory segment, allowing it to
    be swapped out.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These operations are not specified by SUSv3, and they are not provided on all
    UNIX implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In versions of Linux before 2.6.10, only privileged (`CAP_IPC_LOCK`) processes
    can lock a shared memory segment into memory. Since Linux 2.6.10, an unprivileged
    process can lock and unlock a shared memory segment if its effective user ID matches
    either the owner or the creator user ID of the segment and (in the case of `SHM_LOCK`)
    the process has a sufficiently high `RLIMIT_MEMLOCK` resource limit. See [Memory
    Locking: *mlock()* and *mlockall()*](ch50.html#memory_locking_colon_mlock_open_parenthe
    "Memory Locking: mlock() and mlockall()") for details.'
  prefs: []
  type: TYPE_NORMAL
- en: Locking a shared memory segment does not guarantee that all of the pages of
    the segment are memory-resident at the completion of the *shmctl()* call. Rather,
    nonresident pages are individually locked in only as they are faulted into memory
    by subsequent references by processes that have attached the shared memory segment.
    Once faulted in, the pages stay resident until subsequently unlocked, even if
    all processes detach the segment. (In other words, the `SHM_LOCK` operation sets
    a property of the shared memory segment, rather than a property of the calling
    process.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By *faulted into memory*, we mean that when the process references the nonresident
    page, a page fault occurs. At this point, if the page is in the swap area, then
    it is reloaded into memory. If the page is being referenced for the first time,
    no corresponding page exists in the swap file. Therefore, the kernel allocates
    a new page of physical memory and adjusts the process’s page tables and the bookkeeping
    data structures for the shared memory segment.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative method of locking memory, with slightly different semantics,
    is the use of *mlock()*, which we describe in Section 50.2.
  prefs: []
  type: TYPE_NORMAL
- en: Shared Memory Associated Data Structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each shared memory segment has an associated *shmid_ds* data structure of the
    following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: SUSv3 requires all of the fields shown here. Some other UNIX implementations
    include additional nonstandard fields in the *shmid_ds* structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fields of the *shmid_ds* structure are implicitly updated by various shared
    memory system calls, and certain subfields of the *shm_perm* field can be explicitly
    updated using the *shmctl()* `IPC_SET` operation. The details are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*shm_perm*'
  prefs: []
  type: TYPE_NORMAL
- en: When the shared memory segment is created, the fields of this substructure are
    initialized as described in Section 45.3\. The *uid*, *gid*, and (the lower 9
    bits of the) *mode* subfields can be updated via `IPC_SET`. As well as the usual
    permission bits, the *shm_perm.mode* field holds two read-only bit-mask flags.
    The first of these, `SHM_DEST` (destroy), indicates whether the segment is marked
    for deletion (via the *shmctl()* `IPC_RMID` operation) when all processes have
    detached it from their address space. The other flag, `SHM_LOCKED`, indicates
    whether the segment is locked into physical memory (via the *shmctl()* `SHM_LOCK`
    operation). Neither of these flags is standardized in SUSv3, and equivalents appear
    on only a few other UNIX implementations, in some cases with different names.
  prefs: []
  type: TYPE_NORMAL
- en: '*shm_segsz*'
  prefs: []
  type: TYPE_NORMAL
- en: On creation of the shared memory segment, this field is set to the requested
    size of the segment in bytes (i.e., to the value of the *size* argument specified
    in the call to *shmget()*). As noted in [Creating or Opening a Shared Memory Segment](ch48.html#creating_or_opening_a_shared_memory_segm
    "Creating or Opening a Shared Memory Segment"), shared memory is allocated in
    units of pages, so the actual size of the segment may be larger than this value.
  prefs: []
  type: TYPE_NORMAL
- en: '*shm_atime*'
  prefs: []
  type: TYPE_NORMAL
- en: This field is set to 0 when the shared memory segment is created, and set to
    the current time whenever a process attaches the segment (*shmat()*). This field
    and the other timestamp fields in the *shmid_ds* structure are typed as *time_t*,
    and store time in seconds since the Epoch.
  prefs: []
  type: TYPE_NORMAL
- en: '*shm_dtime*'
  prefs: []
  type: TYPE_NORMAL
- en: This field is set to 0 when the shared memory segment is created, and set to
    the current time whenever a process detaches the segment (*shmdt()*).
  prefs: []
  type: TYPE_NORMAL
- en: '*shm_ctime*'
  prefs: []
  type: TYPE_NORMAL
- en: This field is set to the current time when the segment is created, and on each
    successful `IPC_SET` operation.
  prefs: []
  type: TYPE_NORMAL
- en: '*shm_cpid*'
  prefs: []
  type: TYPE_NORMAL
- en: This field is set to the process ID of the process that created the segment
    using *shmget()*.
  prefs: []
  type: TYPE_NORMAL
- en: '*shm_lpid*'
  prefs: []
  type: TYPE_NORMAL
- en: This field is set to 0 when the shared memory segment is created, and then set
    to the process ID of the calling process on each successful *shmat()* or *shmdt()*.
  prefs: []
  type: TYPE_NORMAL
- en: '*shm_nattch*'
  prefs: []
  type: TYPE_NORMAL
- en: This field counts the number of processes that currently have the segment attached.
    It is initialized to 0 when the segment is created, and then incremented by each
    successful *shmat()* and decremented by each successful *shmdt()*. The *shmatt_t*
    data type used to define this field is an unsigned integer type that SUSv3 requires
    to be at least the size of *unsigned short*. (On Linux, this type is defined as
    *unsigned long*.)
  prefs: []
  type: TYPE_NORMAL
- en: Shared Memory Limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most UNIX implementations impose various limits on System V shared memory. Below
    is a list of the Linux shared memory limits. The system call affected by the limit
    and the error that results if the limit is reached are noted in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: '`SHMMNI`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a system-wide limit on the number of shared memory identifiers (in other
    words, shared memory segments) that can be created. (*shmget()*, `ENOSPC`)
  prefs: []
  type: TYPE_NORMAL
- en: '`SHMMIN`'
  prefs: []
  type: TYPE_NORMAL
- en: This is the minimum size (in bytes) of a shared memory segment. This limit is
    defined with the value 1 (this can’t be changed). However, the effective limit
    is the system page size. (*shmget()*, `EINVAL`)
  prefs: []
  type: TYPE_NORMAL
- en: '`SHMMAX`'
  prefs: []
  type: TYPE_NORMAL
- en: This is the maximum size (in bytes) of a shared memory segment. The practical
    upper limit for `SHMMAX` depends on available RAM and swap space. (*shmget()*,
    `EINVAL`)
  prefs: []
  type: TYPE_NORMAL
- en: '`SHMALL`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a system-wide limit on the total number of pages of shared memory. Most
    other UNIX implementations don’t provide this limit. The practical upper limit
    for `SHMALL` depends on available RAM and swap space. (*shmget()*, `ENOSPC`)
  prefs: []
  type: TYPE_NORMAL
- en: 'Some other UNIX implementations also impose the following limit (which is not
    implemented on Linux):'
  prefs: []
  type: TYPE_NORMAL
- en: '`SHMSEG`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a per-process limit on the number of attached shared memory segments.
  prefs: []
  type: TYPE_NORMAL
- en: 'At system startup, the shared memory limits are set to default values. (These
    defaults may vary across kernel versions, and some distributors’ kernels set different
    defaults from those provided by vanilla kernels.) On Linux, some of the limits
    can be viewed or changed via files in the `/proc` file system. [Table 48-2](ch48.html#system_v_shared_memory_limits
    "Table 48-2. System V shared memory limits") lists the `/proc` file corresponding
    to each limit. As an example, here are the default limits that we see for Linux
    2.6.31 on one x86-32 system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The Linux-specific *shmctl()* `IPC_INFO` operation retrieves a structure of
    type *shminfo*, which contains the values of the various shared memory limits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: A related Linux-specific operation, `SHM_INFO`, retrieves a structure of type
    *shm_info* that contains information about actual resources used for shared memory
    objects. An example of the use of `SHM_INFO` is provided in the file `svshm/svshm_info.c`
    in the source code distribution for this book.
  prefs: []
  type: TYPE_NORMAL
- en: Details about `IPC_INFO`, `SHM_INFO`, and the *shminfo* and *shm_info* structures
    can be found in the *shmctl(2)* manual page.
  prefs: []
  type: TYPE_NORMAL
- en: Table 48-2. System V shared memory limits
  prefs: []
  type: TYPE_NORMAL
- en: '| Limit | Ceiling value (x86-32) | Corresponding file in `/proc/sys/kernel`
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SHMMNI` | `32768` (`IPCMNI`) | `shmmni` |'
  prefs: []
  type: TYPE_TB
- en: '| `SHMMAX` | Depends on available memory | `shmmax` |'
  prefs: []
  type: TYPE_TB
- en: '| `SHMALL` | Depends on available memory | `shmall` |'
  prefs: []
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shared memory allows two or more processes to share the same pages of memory.
    No kernel intervention is required to exchange data via shared memory. Once a
    process has copied data into a shared memory segment, that data is immediately
    visible to other processes. Shared memory provides fast IPC, although this speed
    advantage is somewhat offset by the fact that normally we must use some type of
    synchronization technique, such as a System V semaphore, to synchronize access
    to the shared memory.
  prefs: []
  type: TYPE_NORMAL
- en: The recommended approach when attaching a shared memory segment is to allow
    the kernel to choose the address at which the segment is attached in the process’s
    virtual address space. This means that the segment may reside at different virtual
    addresses in different processes. For this reason, any references to addresses
    within the segment should be maintained as relative offsets, rather than as absolute
    pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Further information
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Linux memory-management scheme and some details of the implementation of
    shared memory are described in [Bovet & Cesati, 2005].
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Replace the use of binary semaphores in [Example 48-2](ch48.html#transfer_blocks_of_data_from_stdin_to_a
    "Example 48-2. Transfer blocks of data from stdin to a System V shared memory
    segment") (`svshm_xfr_writer.c`) and [Example 48-3](ch48.html#transfer_blocks_of_data_from_a_system_v
    "Example 48-3. Transfer blocks of data from a System V shared memory segment to
    stdout") (`svshm_xfr_reader.c`) with the use of event flags (Exercise 47-5).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Explain why the program in [Example 48-3](ch48.html#transfer_blocks_of_data_from_a_system_v
    "Example 48-3. Transfer blocks of data from a System V shared memory segment to
    stdout") incorrectly reports the number of bytes transferred if the `for` loop
    is modified as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Try compiling the programs in [Example 48-2](ch48.html#transfer_blocks_of_data_from_stdin_to_a
    "Example 48-2. Transfer blocks of data from stdin to a System V shared memory
    segment") (`svshm_xfr_writer.c`) and [Example 48-3](ch48.html#transfer_blocks_of_data_from_a_system_v
    "Example 48-3. Transfer blocks of data from a System V shared memory segment to
    stdout") (`svshm_xfr_reader.c`) with a range of different sizes (defined by the
    constant `BUF_SIZE`) for the buffer used to exchange data between the two programs.
    Time the execution of `svshm_xfr_reader.c` for each buffer size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program that displays the contents of the *shmid_ds* data structure
    ([Shared Memory Associated Data Structure](ch48.html#shared_memory_associated_data_structure
    "Shared Memory Associated Data Structure")) associated with a shared memory segment.
    The identifier of the segment should be specified as a command-line argument.
    (See the program in [Example 47-3](ch47.html#a_semaphore_monitoring_program "Example 47-3. A
    semaphore monitoring program"), in [Monitoring a semaphore set](ch47.html#monitoring_a_semaphore_set-id1
    "Monitoring a semaphore set"), which performs the analogous task for System V
    semaphores.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a directory service that uses a shared memory segment to publish name-value
    pairs. You will need to provide an API that allows callers to create a new name,
    modify an existing name, delete an existing name, and retrieve the value associated
    with a name. Use semaphores to ensure that a process performing an update to the
    shared memory segment has exclusive access to the segment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a program (analogous to program in [Example 46-6](ch46.html#displaying_all_system_v_message_queues_o
    "Example 46-6. Displaying all System V message queues on the system"), in [Client-Server
    Programming with Message Queues](ch46.html#client-server_programming_with_message_q
    "Client-Server Programming with Message Queues")) that uses the *shmctl()* `SHM_INFO`
    and `SHM_STAT` operations to obtain and display a list of all shared memory segments
    on the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
