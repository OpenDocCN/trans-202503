- en: '**7'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**7'
- en: DIAGRAMS AND ANIMATIONS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**图表和动画**'
- en: '*Tell me, Steed. Is everything to scale?*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*告诉我，Steed，一切都是按比例的吗？*'
- en: —Mrs. Peel
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —Mrs. Peel
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: Diagrams are an essential form of scientific communication and education. The
    type of diagram treated in this chapter is distinct from the plots of data or
    mathematical functions we worked with in [Chapter 4](ch04.xhtml). *Diagrams* in
    this context refers to illustrations of mathematical structures, drawings of experimental
    setups, flowcharts describing algorithms or processing pipelines, and similar
    graphical descriptions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图表是科学交流和教育的重要形式。本章讨论的图表类型不同于我们在[第 4 章](ch04.xhtml)中处理的数据或数学函数图表。在这个上下文中，*图表*指的是数学结构的插图、实验设置的图示、描述算法或处理流程的流程图，以及类似的图形描述。
- en: Animations now frequently accompany scientific papers reporting on simulations,
    as supplementary material offered online. They’re also a valuable tool in education
    and have a myriad of uses in scientific and mathematical communication. In this
    chapter, we’ll explore several Julia packages that can help you create a variety
    of types of diagrams and animations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 动画现在常常作为科学论文的附加材料，在线提供以展示模拟结果。它们也是教育中一个宝贵的工具，并在科学和数学交流中有着广泛的应用。在本章中，我们将探索几个可以帮助你创建各种类型图表和动画的
    Julia 包。
- en: '**Diagramming with Luxor**'
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Luxor 绘制图表**'
- en: The `Luxor` package is sophisticated and highly versatile, allowing you to create
    almost any type of diagram. To install it, enter add Luxor in the package manager.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`Luxor` 包非常复杂且高度通用，可以让你创建几乎任何类型的图表。要安装它，请在包管理器中输入添加 Luxor。'
- en: The package uses an imperative style to build up a picture in stages. You enter
    a series of commands that manipulate a global state, each command potentially
    adding something to the drawing. The effect of each drawing command depends on
    the state at the time it is entered. For example, to draw a blue circle, first
    set the color to blue and then enter the circle-drawing command, with arguments
    giving its position, size, and whether it should be “stroked” (an outline drawn)
    or filled. The outline or fill will use the currently set color. Each element—circles,
    polygons, lines, text, or any of a variety of objects—requires a separate command,
    and colors, styles, opacities, and other settings are set globally before each
    command is issued.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 该包采用命令式风格逐步构建图形。你输入一系列命令来操作全局状态，每个命令都可能为图形添加某些元素。每个绘图命令的效果取决于执行时的状态。例如，要画一个蓝色圆圈，首先将颜色设置为蓝色，然后输入画圆命令，命令参数包括位置、大小以及是否需要“描边”（画出轮廓）或填充。轮廓或填充将使用当前设置的颜色。每个元素——圆圈、多边形、线条、文本或其他各种对象——都需要单独的命令，并且颜色、样式、不透明度等设置是在每个命令执行前全局设定的。
- en: For a concrete example, let’s create a simple diagram (shown in [Figure 7-1](ch07.xhtml#ch7fig1))
    of the relative sizes of the planets in the solar system, arranged in order of
    their distance from the Sun.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个具体的例子，假设我们创建一个简单的图表（见[图 7-1](ch07.xhtml#ch7fig1)），展示太阳系行星的相对大小，按它们距离太阳的顺序排列。
- en: '![Image](../images/ch07fig01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch07fig01.jpg)'
- en: '*Figure 7-1: The relative sizes of the planets*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-1：行星的相对大小*'
- en: '[Listing 7-1](ch07.xhtml#ch7lis1) shows the complete REPL session that creates
    the diagram in [Figure 7-1](ch07.xhtml#ch7fig1).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 7-1](ch07.xhtml#ch7lis1) 显示了完整的 REPL 会话，该会话创建了[图 7-1](ch07.xhtml#ch7fig1)中的图示。'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 7-1: Creating a diagram of the solar system using* Luxor'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-1：使用* Luxor *创建太阳系图表*'
- en: The program gets its planetary diameters, which are in kilometers, from a NASA
    website (see “Further Reading” on [page 211](ch07.xhtml#fur7)). When copying and
    pasting from the NASA table there, the numbers are space separated. This creates
    a `1\times10` array (Earth’s moon and Pluto are included), which is fine; we just
    need a list we can iterate over.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 程序从 NASA 网站获取行星的直径，这些直径单位是公里（请参阅[第 211 页](ch07.xhtml#fur7)中的“进一步阅读”）。当从 NASA
    表格中复制并粘贴数据时，数字是以空格分隔的。这会创建一个 `1\times10` 数组（包括地球的月球和冥王星），这没问题；我们只需要一个可以遍历的列表。
- en: The double semicolon at the end of the line ➊ breaks the literal input of the
    array over two lines (this feature was added in Julia v1.7). Although spaces and
    double semicolons both signify concatenation along the second dimension, normally
    you may not mix them in a single literal array definition. The usage here is an
    exception just for this purpose.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 行尾的双分号➊将数组的字面量输入分为两行（这个特性是在Julia v1.7中添加的）。虽然空格和双分号都表示沿第二维度的连接，但通常你不能在一个字面量数组定义中混合使用它们。这里的用法是一个特例，仅为此目的使用。
- en: The two variables `dimenx` and `dimeny` hold the dimensions of our diagram.
    Dimensions in `Luxor` are points, which are 1/72 of an inch.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 两个变量`dimenx`和`dimeny`保存了我们图表的尺寸。`Luxor`中的尺寸单位是点（points），每个点是1/72英寸。
- en: '`Luxor` supplies several macros for conveniently setting up the drawing environment.
    The `@png` macro ➋ initializes a PNG illustration, defines the origin of the coordinate
    system to be the center of the picture, and displays the result upon reaching
    the end of the block ➐. After the final `end` statement, we give the dimensions
    of the image and its filename (you can leave this out, but probably won’t want
    to). The default size is 600×600, and the default filename is *luxor-drawing-*
    followed by a timestamp and the file extension. This can lead to a profusion of
    files on your disk as you develop your drawing code, so you probably want to specify
    a filename, which will get overwritten on each run. The file extension is optional
    and `Luxor` will supply one if you leave it out.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Luxor`提供了几个宏来方便地设置绘图环境。`@png`宏➋初始化PNG插图，定义坐标系统的原点为图片的中心，并在代码块结束时显示结果➐。在最后的`end`语句之后，我们给出图像的尺寸和文件名（虽然可以省略，但通常不建议）。默认尺寸为600×600，默认文件名为*luxor-drawing-*，后跟时间戳和文件扩展名。随着绘图代码的不断发展，这可能会在磁盘上产生大量文件，因此你可能希望指定一个文件名，该文件名在每次运行时会被覆盖。文件扩展名是可选的，如果省略，`Luxor`会自动提供一个。'
- en: We need a scaling factor to deal with the large planetary diameters, which we
    assign to `dscale`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个缩放因子来处理较大的行星直径，这个因子被赋值给`dscale`。
- en: The macro sets the origin of the coordinate system to the center of the diagram,
    which, using our variables, would be `(dimenx/2, dimeny/2)`. The code will be
    neater if we set the origin ➌ in the *x*-direction such that the left edge of
    the first planet starts at the left boundary.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该宏将坐标系统的原点设置为图表的中心，使用我们的变量，它会是`(dimenx/2, dimeny/2)`。如果我们在*x*方向上设置原点➌，使得第一个行星的左边缘从左边界开始，代码会更加整洁。
- en: I discovered that, on my system, if I don’t set a `fontface` ➍, I get ugly bitmapped
    fonts in the output. This particular font may not exist on your system, so adjust
    as needed. If you ask for a font that `Luxor` can’t find, it will carry on, making
    a substitution.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现，在我的系统中，如果我没有设置`fontface` ➍，输出中会出现难看的位图字体。这个特定的字体可能在你的系统上不存在，所以你可以根据需要进行调整。如果请求一个`Luxor`找不到的字体，它会继续运行并进行替代。
- en: 'The x-coordinate of the current circle’s center is assigned to `ledge`, which
    is updated twice ➎ for each planet: once to increase it by the radius of the previous
    planet and once by the planet about to be drawn. The result is a series of osculating
    circles.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当前圆心的x坐标被赋值给`ledge`，该值会被更新两次➎，每个行星都会增加：一次是增加前一个行星的半径，另一次是增加即将绘制的行星的半径。最终结果是一系列相切的圆。
- en: The color is set to blue and the dash style to dot ➏ before each label is printed.
    As with other diagrams in this chapter, you can find color versions in the online
    supplement at [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在打印每个标签之前，颜色被设置为蓝色，虚线样式设置为点线➏。与本章其他图表一样，你可以在在线补充资料中找到彩色版本，链接为 [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org)。
- en: If you run the code from [Listing 7-1](ch07.xhtml#ch7lis1) in the REPL, your
    default image viewing application will open a window displaying the diagram file
    when you run the code. The REPL will hang until you quit the application. If you
    run this in Pluto or Jupyter, the diagram will be embedded in the cell below the
    code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在REPL中运行[示例7-1](ch07.xhtml#ch7lis1)中的代码，当你运行代码时，默认的图像查看应用程序会打开一个窗口，显示图表文件。REPL会一直停顿，直到你退出该应用程序。如果你在Pluto或Jupyter中运行该代码，图表将嵌入到代码下方的单元格中。
- en: Other options for macros are `@svg` and `@pdf`, which create files of the respective
    types. However, PDFs will not be embedded into notebooks.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 宏的其他选项包括`@svg`和`@pdf`，它们分别创建这两种类型的文件。然而，PDF文件无法嵌入到笔记本中。
- en: In addition to lines, circles, and text, `Luxor` has commands for drawing several
    other shapes, and even such geometrical constructions as tangent lines to circles.
    (See “Further Reading” on [page 211](ch07.xhtml#fur7) for a link to the manual.)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了线条、圆形和文本，`Luxor`还提供了用于绘制其他几何形状的命令，甚至可以绘制如圆的切线等几何构造。（有关手册的链接，请参见[第7章](ch07.xhtml#fur7)中的“进一步阅读”部分。）
- en: '**The Graphs Package**'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**图形包**'
- en: With enough patience, you can use `Luxor` to create any type of diagram. However,
    it’s usually easier to use a specialized package for diagrams of a specific, standard
    type.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 只要有足够的耐心，你就可以使用`Luxor`创建任何类型的图表。然而，通常对于特定的标准类型图表，使用专门的包会更容易。
- en: This section is about graphs in the mathematical sense and their visualization.
    The word *graph* is often used synonymously with the types of plots that were
    the subject of [Chapter 4](ch04.xhtml), but to a mathematician, a graph is a set
    of nodes connected by edges, and that’s the type of graph we consider here. Graphs
    of this type are used to represent a huge variety of systems. Anytime you have
    a collection of objects that are connected together in a network of relationships,
    you have a graph. Examples include a taxonomy of plants or animals, call sites
    in a computer program, grammatical structures in a sentence, organizational charts,
    and the relationships among characters in a novel. In such a graph, the objects
    (parts of the organization or characters in the novel) are called *nodes* and
    the connections between nodes are called *edges*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本节内容讨论的是数学意义上的图和其可视化。*图*这个词通常与[第4章](ch04.xhtml)中讨论的绘图类型同义使用，但对于数学家而言，图是由节点通过边连接起来的集合，这就是我们在这里讨论的图的类型。这种类型的图用于表示各种各样的系统。每当你有一组对象，通过网络中的关系连接起来时，你就有了一个图。例如，植物或动物的分类、计算机程序中的调用位置、句子的语法结构、组织结构图以及小说中人物之间的关系，都是图的例子。在这样的图中，物体（组织的一部分或小说中的人物）被称为*节点*，节点之间的连接被称为*边*。
- en: The Julia `Graphs` package contains functions for making several types of graphs.
    It depends upon `Plots` and `GraphRecipes` to actually draw the pictures representing
    the graphs. The first of these we’re familiar with from [Chapter 4](ch04.xhtml);
    the second is a collection of *plotting recipes* that, in turn, use `Plots` to
    draw pictures. The recipe mechanism allows users and package authors to extend
    `Plots` so that it can visualize new data types or make new types of plots. To
    understand how these recipes work, we need to know more about the type system,
    so plot recipes are covered in “Plot Recipes” on [page 252](ch08.xhtml#ch08lev7).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Julia的`Graphs`包包含了生成多种类型图表的函数。它依赖于`Plots`和`GraphRecipes`来实际绘制表示图形的图像。我们在[第4章](ch04.xhtml)中已经熟悉了第一个包；第二个包则是一个*绘图配方*集合，它通过`Plots`绘制图形。配方机制允许用户和包的作者扩展`Plots`，使其能够可视化新的数据类型或生成新的图表类型。要理解这些配方如何工作，我们需要了解更多关于类型系统的内容，因此在[第8章](ch08.xhtml#ch08lev7)中的“绘图配方”部分对配方进行了介绍。
- en: 'As an introduction to the `Graphs` package, we’ll build a program to create
    a diagram of the predator–prey relationships among 14 species living in the Chesapeake
    Bay in the eastern United States:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`Graphs`包的介绍，我们将构建一个程序，用于创建一个关于位于美国东部切萨皮克湾的14个物种之间的捕食–被捕食关系的图表：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: First, we import the three necessary libraries (`Plots`, `Graphs`, and `Graph`
    `Recipes`) and create a vector of the names of the creatures. These names will
    become labels in the diagram and will also serve as references for the graph’s
    nodes.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入三个必要的库（`Plots`、`Graphs`和`Graph` `Recipes`），并创建一个包含生物名称的向量。这些名称将成为图表中的标签，并且还将作为图中节点的参考。
- en: The final line of the program so far creates an empty *directed graph* with
    14 nodes (called “vertices” by `Graphs.jl)`. A directed graph is one where the
    edges have a direction, usually represented visually as an arrowhead. For this
    example, the direction of the edge will represent what creature eats what. In
    an *undirected graph*, the edges simply represent connections, with no hierarchy
    involved.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 目前程序的最后一行创建了一个空的*有向图*，包含14个节点（`Graphs.jl`称之为“顶点”）。有向图是指边有方向，通常通过箭头表示。在这个例子中，边的方向代表了哪个生物吃了哪个生物。在*无向图*中，边只是表示连接，没有层级关系。
- en: The next step is to add edges to `foodchain` representing information about
    the predator–prey relationships. The `add_edge!(foodchain, a, b)` function mutates
    the graph in its first argument by adding an edge going from node `a` to node
    `b`. That’s what we want, but it’s not convenient, because `a` and `b` need to
    be integers representing the orders of the nodes in the list. To enter these arguments,
    we would have to count through the list of `creatures` for each relationship.
    For example, to enter an edge representing the fact that striped bass eat worms,
    we would have to call `add_edge!(foodchain, 1, 7)`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是向`foodchain`添加表示捕食者-猎物关系的边。`add_edge!(foodchain, a, b)`函数通过在图的第一个参数中添加一条从节点`a`到节点`b`的边来修改图。这正是我们想要的，但不太方便，因为`a`和`b`需要是整数，代表列表中节点的顺序。为了输入这些参数，我们需要为每个关系遍历`creatures`列表。例如，要输入一条表示条纹鲈鱼吃蠕虫的边，我们必须调用`add_edge!(foodchain,
    1, 7)`。
- en: 'Let’s make the process more convenient by defining a dictionary and a function
    that will allow us to refer to the creatures by name:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过定义一个字典和一个函数来使这个过程更方便，这样我们就可以通过名称来引用生物：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `food_dict` dictionary simply associates each creature string with its order
    in the list, for easy reference. The new function allows us to add edges by naming
    the predator and its prey. We’re using a name for this function that can serve
    as an infix operator (see “Operators Are Functions Too” on [page 159](ch06.xhtml#ch06lev1sec4)).
    The REPL shortcut (and LaTeX command) for that character is `\hookrightarrow`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`food_dict`字典将每个生物字符串与其在列表中的顺序关联，以便于引用。新的函数允许我们通过命名捕食者及其猎物来添加边。我们为这个函数使用了一个可以作为中缀运算符的名称（参见“运算符也是函数”章节，见[第159页](ch06.xhtml#ch06lev1sec4)）。这个字符的REPL快捷键（和LaTeX命令）是`\hookrightarrow`。'
- en: 'With the hooked arrow function in place, we can list a set of predator–prey
    relationships taken from a study of the ecology of the Chesapeake Bay:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入钩形箭头函数后，我们可以列出一组来自切萨皮克湾生态研究的捕食者-猎物关系：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `add_edge!()` function mutates the `foodchain` graph by adding edges. The
    last call produces the illustration shown in [Figure 7-2](ch07.xhtml#ch7fig2).
    In the diagram, the arrows point from predator to prey, reflecting the directions
    of the edges we defined.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_edge!()`函数通过添加边来修改`foodchain`图形。最后一次调用生成了如[图 7-2](ch07.xhtml#ch7fig2)所示的插图。在图中，箭头指向从捕食者到猎物，反映了我们定义的边的方向。'
- en: '![Image](../images/ch07fig02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch07fig02.jpg)'
- en: '*Figure 7-2: The predator–prey food net in the Chesapeake Bay*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-2：切萨皮克湾的捕食者-猎物食物网*'
- en: If you run this program, you will find that your picture looks somewhat different.
    In fact, each time you run it the diagram will be arranged differently in space,
    although the *structure* will always be the same—the same creatures being eaten
    by the same predators. This happens because of a random element in how the nodes
    and edges are arranged. In fact, I had to run the program about five times before
    I got a result that I liked. Some of the generated graphs were rather poor, with
    overlapping nodes.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，你会发现你的图看起来有所不同。实际上，每次运行时，图的布局都会有所不同，尽管*结构*始终相同——相同的生物被相同的捕食者吃掉。这是因为节点和边的排列存在随机因素。事实上，我运行了这个程序大约五次才得到了我喜欢的结果。有些生成的图表效果较差，节点重叠。
- en: 'The final argument in the call to `graphplot()`, `method`, selects an algorithm
    for laying out the graph: for turning the structure into a picture by deciding
    where to place the nodes. The `stress` algorithm does this by trying to maximize
    a global measure of how far the distances between nodes differ from a theoretical
    optimum. The random element comes in because the algorithm finds this maximum
    by deforming a random initial state.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`graphplot()`时的最后一个参数`method`选择了图形布局的算法：即通过决定节点的位置来将结构转化为图像。`stress`算法通过尽量使节点之间的距离差异最大化，从而实现这一点，衡量的标准是距离理论最优值的偏差。随机因素出现在算法通过变形一个随机的初始状态来找到这个最大值。
- en: '***The Adjacency Matrix***'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***邻接矩阵***'
- en: Internally, the list of edges established by calls to `add_edge!()` gets transformed
    into an *adjacency matrix*. We can see the adjacency matrix as shown in [Listing
    7-2](ch07.xhtml#ch7lis2).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，通过调用`add_edge!()`建立的边的列表会转换成一个*邻接矩阵*。我们可以看到邻接矩阵，如[清单 7-2](ch07.xhtml#ch7lis2)所示。
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 7-2: The adjacancy matrix is a sparse array.*'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 7-2：邻接矩阵是一个稀疏数组。*'
- en: The result is returned as a *sparse array*, one of a collection of data types
    defined in the `SparseArrays` package, which the `Graphs` package loads automatically.
    A sparse array behaves similarly to a normal array, but is specialized to be efficient
    when only a small proportion of its elements are defined. The REPL displays them
    as shown in [Listing 7-2](ch07.xhtml#ch7lis2), with dots representing undefined
    locations.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 结果作为一个*稀疏数组*返回，它是`SparseArrays`包中定义的一种数据类型，`Graphs`包会自动加载这个包。稀疏数组的行为类似于普通数组，但它特别适用于当只有一小部分元素被定义时的高效处理。REPL将它们显示为[示例7-2](ch07.xhtml#ch7lis2)所示，未定义的位置用点表示。
- en: The elements of an adjacency matrix are set to 1 to record the existence of
    edges in the graph. For example, `foodchain_matrix[1, 6]` has a 1, because there’s
    an edge going from node 1 to node 6 (established by `"Striped bass"`↪ `"Bay anchovy"`).
    The adjacency matrix encodes the structure of the graph, and therefore contains
    its complete definition, because a graph is identical to its structure. We can
    plot the graph with a call to `graphplot(foodchain_matrix)`; the remaining arguments
    simply supply details, such as names for labeling the nodes, for its display.
    If the adjacency matrix is symmetrical (`M[i, j]` `== M[j, i]`), it represents
    an undirected graph. Otherwise, as in the food chain example, it represents a
    directed graph, and `graphplot()` will draw it using arrows rather than simple
    lines. The adjacency matrix must have at least one nonzero element, or at least
    one edge defined with `add_edge!()`, before plotting a graph.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接矩阵的元素设置为1，以记录图中边的存在。例如，`foodchain_matrix[1, 6]` 为1，因为从节点1到节点6有一条边（由“条纹鲈鱼”↪“海湾鳀”建立）。邻接矩阵编码了图的结构，因此包含了图的完整定义，因为图与其结构是等价的。我们可以通过调用`graphplot(foodchain_matrix)`来绘制图；其余的参数仅提供一些细节信息，例如用于标记节点的名称，以便显示。如果邻接矩阵是对称的（`M[i,
    j]` `== M[j, i]`），它表示一个无向图。否则，如在食物链示例中，它表示一个有向图，`graphplot()`将使用箭头而不是简单的线条来绘制它。在绘制图之前，邻接矩阵必须至少有一个非零元素，或者至少用`add_edge!()`定义一条边。
- en: The package uses sparse matrices for efficiency, but, if we’re constructing
    an adjacency matrix directly, as in the next example, we have the option of using
    normal matrices. In this case, a 0 element indicates the absence of an edge and
    nonzero elements show where the edges are.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 该包使用稀疏矩阵以提高效率，但如果我们像下一个示例中那样直接构造邻接矩阵，我们也可以选择使用普通矩阵。在这种情况下，0元素表示没有边，而非零元素表示边的位置。
- en: '***Factor Trees***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***因子树***'
- en: 'At the risk of awakening bad memories from high school algebra class, our next
    example, found in [Listing 7-3](ch07.xhtml#ch7lis3), will be a program to draw
    factor trees: graph diagrams showing the division of a number into ever-smaller
    factors, ending with its unique prime factors. It will show how to build a graph
    by constructing its adjacency matrix and provide an example of an undirected graph
    with a tree structure. Here’s the complete program that produces the factor tree.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在冒着唤起高中代数课糟糕回忆的风险下，我们的下一个示例（见[示例7-3](ch07.xhtml#ch7lis3)）将是一个绘制因子树的程序：因子树是显示一个数字不断被分解成更小因子的图形，最终显示它的唯一素因子。它将展示如何通过构造邻接矩阵来构建图，并提供一个具有树形结构的无向图示例。以下是生成因子树的完整程序。
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 7-3: A program to create a factor tree*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例7-3：创建因子树的程序*'
- en: The new import, the first line of the program, gets us the `factor()` function
    ➊, which returns the prime factors of its argument. The program works only for
    integers `n` greater than 1\. The first argument supplied to `factor()` tells
    it to return the results in a vector, the form that we need to construct the factor
    tree. The default is to return the results in a special-purpose type that lists
    factors and multiplicities. If there is only one of those, `n` is a prime number,
    so we stop immediately ➋, announcing why. The program proceeds through the list
    of primes, dividing and concatenating the results onto the `names` vector. We
    then initialize the adjacency matrix `a` ➌ and record the links between each pair
    of factors and their product up the tree. The final call to `graphplot()` takes
    the adjacency matrix as its first argument; the keyword arguments set details
    for the illustration. The `nodesize` argument sets the extra size of the circles
    beyond what is required for them to contain their labels. The algorithm for enlarging
    them does not quite succeed in making them grow big enough, so we add something
    extra proportional to the number of digits in the label ➍. Calling `factree(14200)`
    produces [Figure 7-3](ch07.xhtml#ch7fig3).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 新的导入是程序的第一行，它为我们引入了 `factor()` 函数 ➊，该函数返回其参数的素因数。该程序仅适用于大于 1 的整数 `n`。传递给 `factor()`
    的第一个参数要求其返回一个向量结果，这是构建因子树所需的形式。默认情况下，返回的是一种专用类型，列出因子及其多重性。如果只有一个因子，`n` 就是一个素数，因此程序立即停止
    ➋，并宣布原因。程序继续遍历素数列表，进行除法运算并将结果拼接到 `names` 向量中。接着，我们初始化邻接矩阵 `a` ➌ 并记录每对因子及其乘积在树上的链接。最终调用
    `graphplot()` 时，将邻接矩阵作为第一个参数；关键字参数设置插图的详细信息。`nodesize` 参数设置圆圈的额外大小，以容纳标签所需的空间。扩大圆圈的算法并没有完全成功地使其足够大，因此我们添加了与标签中数字个数成比例的额外部分
    ➍。调用 `factree(14200)` 会生成[图 7-3](ch07.xhtml#ch7fig3)。
- en: '![Image](../images/ch07fig03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch07fig03.jpg)'
- en: '*Figure 7-3: A factor tree for the number 14,200*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-3：数字 14,200 的因子树*'
- en: The package provides two layout methods for creating tree-like graphs. The `:tree`
    method works, but the results are a bit free-form. The `:buchheim` method ➎ produces
    the regular tree shown in [Figure 7-3](ch07.xhtml#ch7fig3). Although the prime
    factorization is unique, the factor tree that leads to it, and thus the result
    of the program, may not be.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 该包提供了两种布局方法来创建树状图。`:tree` 方法有效，但结果略显自由形式。`:buchheim` 方法 ➎ 产生了[图 7-3](ch07.xhtml#ch7fig3)所示的规则树。尽管素因数分解是唯一的，但导致其结果的因子树以及程序的结果可能并非唯一。
- en: '**Animations with Javis**'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Javis 制作动画**'
- en: The widely used `Javis` package is a good choice for making almost any type
    of animated diagram. It’s built on top of `Luxor` (see “Diagramming with Luxor”
    on [page 190](ch07.xhtml#ch07lev1)), which means you can build on your knowledge
    of that package to create animations. A `Javis` program creates objects from `Luxor`
    drawing commands and turns them into videos by means of a fairly intuitive set
    of calls to rotate, translate, or move them along paths, as well as by changing
    shape parameters in time.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 广泛使用的 `Javis` 包是制作几乎任何类型动画图表的好选择。它构建在 `Luxor` 之上（参见[第 190 页](ch07.xhtml#ch07lev1)的“使用
    Luxor 绘图”），这意味着你可以基于对该包的了解来创建动画。一个 `Javis` 程序通过 `Luxor` 的绘图命令创建对象，并通过一系列直观的调用将它们转换为视频，操作包括旋转、平移或沿路径移动它们，同时在时间上改变形状参数。
- en: '***Closures***'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***闭包***'
- en: To use `Javis` effectively, it helps to be familiar with a programming technique
    called a *closure*. Experienced programmers who know how to use closures can safely
    skip this section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效使用 `Javis`，了解一种称为 *闭包* 的编程技巧是有帮助的。对于熟练的程序员，若知道如何使用闭包，可以直接跳过这一部分。
- en: A closure is a function that is created and returned by another function. We’ll
    refer to the returned function as the *inner function* and the one that creates
    it as the *outer function*. Most modern languages allow the programmer to create
    closures, but some are more convenient for this than others. Julia, because of
    its lexical scoping and convenient syntax for function definition, makes closures
    easy and intuitive.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是由另一个函数创建并返回的函数。我们将返回的函数称为 *内函数*，而创建它的函数称为 *外函数*。大多数现代编程语言都允许程序员创建闭包，但有些语言比其他语言更方便。由于
    Julia 具有词法作用域和方便的函数定义语法，它使得闭包既简单又直观。
- en: The key aspect to closures is that the inner function can access variables defined
    in the outer function. We say that they are *closed over*, hence the name. The
    outer function becomes a function factory, returning a function whose behavior
    depends on the arguments passed to the outer function, but with, potentially,
    a completely different function signature.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包的关键在于，内部函数可以访问在外部函数中定义的变量。我们说它们是*封闭的*，因此得名。外部函数成为一个函数工厂，返回一个其行为取决于传递给外部函数的参数，但可能具有完全不同函数签名的函数。
- en: '[Listing 7-4](ch07.xhtml#ch7lis4) shows a simple example of a closure that
    we’ll find a useful application for shortly.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7-4](ch07.xhtml#ch7lis4)展示了一个简单的闭包示例，我们很快会发现它有一个有用的应用。'
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 7-4: Defining a closure*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 7-4：定义一个闭包*'
- en: 'With this definition, when we call, for example, `power(5)`, we get a function
    of a single variable that raises that variable to the fifth power and returns
    the result. In other words, if we define two functions this way:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个定义，当我们调用`power(5)`时，我们得到一个单变量的函数，它将该变量提升到第五次方并返回结果。换句话说，如果我们这样定义两个函数：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'then `p` and `q` have the same behavior:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`p`和`q`具有相同的行为：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The function `power()` returns is anonymous, but we can assign it to a variable,
    in this case `p`, as we can any other function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`power()`返回的是匿名函数，但我们可以像对待其他函数一样将其分配给变量，这里是`p`。
- en: Now `power()` is a function factory that makes functions that raise their arguments
    to any desired exponent. As mentioned in “Plotting Functions” on [page 88](ch04.xhtml#ch04lev1sec2),
    one version of the `plot()` function from the `Plots` package accepted the simple
    names of functions of one variable to plot. We can plot such functions without
    mentioning variables or defining arrays.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`power()`是一个函数工厂，它生成将其参数提升到任何期望指数的函数。正如在“绘图函数”部分中提到的，在[第88页](ch04.xhtml#ch04lev1sec2)的`plot()`函数版本中，`Plots`包接受单变量函数的简单名称进行绘图。我们可以在不提及变量或定义数组的情况下绘制这些函数。
- en: It would seem that this convenience could not be exploited to plot, say, functions
    that depend on a parameter in addition to the independent variable, and that we
    would need to use named functions or the anonymous function syntax to pass such
    functions to `plot()`. For example, if we want to plot `f(x, n) = x^n`, we can’t
    just call `plot(f)`, because `f()` needs two arguments, but we could call `plot((x)
    -> x^n)` if `n` were already defined. Closures are an alternative to passing anonymous
    functions in cases such as this.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎这种便利性无法被用于绘制依赖于除了自变量之外的其他参数的函数，因此我们需要使用命名函数或匿名函数语法来将这些函数传递给`plot()`。例如，如果我们想绘制`f(x,
    n) = x^n`，我们不能仅仅调用`plot(f)`，因为`f()`需要两个参数，但如果`n`已经定义，我们可以调用`plot((x) -> x^n)`。闭包是传递匿名函数的替代方法，适用于此类情况。
- en: 'Once we have the closure defined in [Listing 7-4](ch07.xhtml#ch7lis4), we can
    make the following plotting call:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了[列表 7-4](ch07.xhtml#ch7lis4)中的闭包，我们就可以进行以下绘图调用：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This produces the plot in [Figure 7-4](ch07.xhtml#ch7fig4).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这会生成[图 7-4](ch07.xhtml#ch7fig4)中的图。
- en: '![Image](../images/ch07fig04.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/ch07fig04.jpg)'
- en: '*Figure 7-4: Plotting with closures*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-4：使用闭包绘图*'
- en: This plotting example is simply one application of closures. They are a powerful
    technique for generating functions that capture the state under which they are
    defined.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个绘图示例只是闭包的一种应用。它们是生成捕获定义时状态的函数的强大技术。
- en: '***Epicycle Animation***'
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***外循环动画***'
- en: The pattern for using `Javis` is to define functions that produce each of the
    objects you intend to animate, and then call a series of statements that refer
    to those objects and animate them, changing their positions or other properties
    in time.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Javis`的模式是定义生成每个要动画化的对象的函数，然后调用一系列引用这些对象并使其动画化的语句，改变它们的位置或其他属性。
- en: '**NOTE**'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Since* Javis *is built on* Luxor*, it imports* Luxor *itself and re-exports
    that package’s functions. The consequence is that a program that contains* using
    Javis *must not also contain* using Luxor*, because that would lead to name conflicts.
    If you’ve been using* Luxor *in the REPL, you must start a new REPL before using*
    Javis*.*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*由于* Javis *是基于* Luxor *构建的，因此它导入* Luxor *本身，并重新导出该包的函数。结果是，包含* using Javis
    *的程序不得同时包含* using Luxor *，因为这会导致名称冲突。如果你已经在 REPL 中使用过* Luxor *，你必须在使用* Javis *之前重新启动
    REPL。*'
- en: The object-creating functions use one or more `Luxor` functions for circles,
    lines, text, or other graphical entities available through `Luxor`, and optionally
    return information about the object for use in the animation calls.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对象的函数使用一个或多个`Luxor`函数来绘制圆形、线条、文本或其他通过`Luxor`提供的图形实体，并可以选择性地返回有关该对象的信息，以便在动画调用中使用。
- en: The `Luxor` documentation describes three methods for passing the object-creating
    functions into the animation functions. We’ll learn another method, based on closures,
    that’s more general and leads to neater and easier-to-read code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Luxor`文档描述了三种将对象创建函数传递给动画函数的方法。我们将学习另一种基于闭包的方法，它更通用，并且能生成更简洁、易读的代码。'
- en: The goal for this example is to create a program that produces animations of
    models of the solar system in the style of Ptolemy. This ancient cosmology put
    our Earth at the center of the universe and explained observations of planets
    as caused by their circular orbits, which themselves circled around larger orbits.
    These circular orbits are called *epicycles*; any one planet’s motion might be
    modeled by one or more epicycles, ending with a large circle around a point somewhat
    displaced from Earth by a distance called the *eccentricity*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例的目标是创建一个程序，生成以托勒密风格展示太阳系模型的动画。该古代宇宙学模型将地球置于宇宙的中心，并解释了行星的观测现象，认为行星的运动是由于它们的圆形轨道，而这些轨道本身又环绕着更大的轨道。这些圆形轨道被称为*本轮*；任何一颗行星的运动都可以通过一个或多个本轮来建模，最终形成一个围绕一个略微偏离地球的点的大圆，偏离的距离称为*偏心率*。
- en: 'To build the program, we’ll start with functions that create the planets and
    orbits. Here’s the one for a planet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建程序，我们将从创建行星和轨道的函数开始。这是一个行星的函数：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a closure. A call to `planet()` returns a function that accepts three
    positional arguments and draws a circle with a radius, color, and position determined
    not by the arguments passed to the returned function, but by the original arguments
    passed to `planet()`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个闭包。对`planet()`的调用返回一个接受三个位置参数的函数，并根据传递给`planet()`的原始参数，而不是传递给返回函数的参数，绘制一个具有特定半径、颜色和位置的圆形。
- en: 'This indirection is necessary because the `Javis` functions that do the animation
    expect a function as their first and only required argument. They don’t accept
    a shape as an argument, but a function that draws a shape. They pass the three
    values `(video, object, frame)` to this function: data types representing the
    video, the object being animated, and the integer frame number. The function can
    use any of them, or as in the case of the function created by `planet()`, none
    of them.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种间接性是必要的，因为执行动画的`Javis`函数期望函数作为它们的第一个也是唯一必需的参数。它们不接受形状作为参数，而是接受一个绘制形状的函数。它们将三个值`(video,
    object, frame)`传递给这个函数：分别表示视频、正在动画化的对象和帧号的整数数据类型。该函数可以使用它们中的任何一个，或者像`planet()`创建的函数那样，不使用它们。
- en: The closure returns the circle’s position. We must do this if other animation
    functions need to know that position, as is the case in our video.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包返回圆形的位置。如果其他动画函数需要知道该位置（如我们的视频中所示），我们必须这样做。
- en: 'The function for drawing orbits will be almost the same:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制轨道的函数几乎是相同的：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Orbits will have an outline, but won’t be filled in.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 轨道将有轮廓，但不会填充颜色。
- en: With these two functions, we can draw animatable planets and orbits, which is
    most of what we need. But it would also be nice to show how the wandering of the
    planet around the solar system translates into changes in its observed location
    in the sky relative to the fixed stars as the days go by. We’ll approximate this
    movement by the projection of the planet’s position along the horizontal coordinate.
    The `pos()` function supplied by `Javis` returns an object’s position, and it
    has convenient `x` and `y` fields for extracting the respective coordinates.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个函数，我们可以绘制可动画化的行星和轨道，这几乎是我们所需的全部。但也希望能够展示行星在太阳系中的漂移如何转化为其相对于恒星的观测位置随时间的变化。我们将通过行星位置在水平方向上的投影来近似这种运动。`Javis`提供的`pos()`函数返回对象的位置，并具有方便的`x`和`y`字段来提取相应的坐标。
- en: 'The following function accepts an object and draws another circle that shares
    its horizontal coordinate, close to the top of the video:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数接受一个对象并绘制另一个与其共享水平方向坐标、接近视频顶部的圆形：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here `observed_position()` uses the `video` argument’s `height` field ➊ automatically
    supplied by the animation functions.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`observed_position()`使用了`video`参数的`height`字段 ➊，这是动画函数自动提供的。
- en: 'We would like to draw one more object: a curve in space visualizing the path
    taken by the planet. We’ll record this path as a series of points in a global
    `positions` vector. At every frame, this function pushes the new position onto
    the vector and draws a series of tiny circles tracing the path:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想绘制一个对象：在空间中可视化行星轨迹的曲线。我们将把这条路径记录为一个全局`positions`向量中的一系列点。在每一帧中，函数会将新位置添加到向量中，并绘制一系列小圆圈来描绘轨迹：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We need one more drawing function, used in nearly all `Javis` animations, for
    defining the background:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个绘图函数，这是几乎所有`Javis`动画中都需要用到的，用于定义背景：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This definition for `ground()` creates a drawing canvas with a black background
    and uses white as the default drawing color.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`ground()`定义创建了一个带黑色背景的绘图画布，并使用白色作为默认的绘图颜色。
- en: 'With functions for each object we want to draw, we can create the animation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有了每个对象的绘制函数后，我们可以创建动画：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `epicycles()` function accepts one required positional argument, `inputcycles`,
    in the form `[(s1, f1), (s2, f2), ..., fp]`. Each `(s, f)` pair gives the size
    `s` as a fraction of the main orbit radius of an epicycle with an orbital frequency
    of `f`. Frequencies here refer to the number of cycles completed during the animation.
    The final `fp` is the planet’s frequency.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`epicycles()`函数接受一个必需的位置参数`inputcycles`，其形式为`[(s1, f1), (s2, f2), ..., fp]`。每一对`(s,
    f)`表示一个外循环的大小`s`，是主轨道半径的一个分数，轨道频率为`f`。这里的频率指的是在动画过程中完成的循环次数。最终的`fp`是行星的频率。'
- en: 'After some calculations to scale the orbits according to the video’s overall
    size, and to adjust this size to account for the epicycles input by the user,
    we have the one statement ➊ that all `Javis` animations require: defining the
    `Video` and its dimensions.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行一些计算后，根据视频的整体大小来缩放轨道，并根据用户输入的外循环调整大小，我们得出了所有`Javis`动画所需的一个语句 ➊：定义`Video`及其尺寸。
- en: The first animation command ➋ establishes the background to be drawn for the
    first 500 frames. The next three animation commands are calls to `Object()`; this
    is the `Javis` command that places the graphical element on the background. The
    `Object()` function accepts a range of frames as a first argument, but uses the
    range supplied to the most recent `Background()` or `Object()` command as a default.
    `Javis` is an imperative system that maintains a state to which animation statements
    apply, containing the current `Video` and range of frames.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个动画命令 ➋ 为前500帧设置了要绘制的背景。接下来的三个动画命令是对`Object()`的调用；这是`Javis`命令，用于将图形元素放置到背景上。`Object()`函数接受一个帧范围作为第一个参数，但会使用最近的`Background()`或`Object()`命令提供的范围作为默认值。`Javis`是一个命令式系统，维护着一个动画语句适用的状态，其中包含当前的`Video`和帧范围。
- en: Next we have a loop that adds orbits for each epicycle supplied in the argument.
    The `act!()` function ➌ is how we create most types of motion in `Javis`. Its
    first argument is the object we want to animate, and the second argument is a
    function defining the motion. The only such motion we use in this program is `anim_rotate_around()`,
    which takes an angle (in radians) and the object that becomes the center of rotation.
    The complex, compound motions in the epicycle model are easy to construct because
    the object rotated around can itself be in motion.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个循环，它为每个传入的外循环添加轨道。`act!()`函数 ➌ 是我们在`Javis`中创建大多数类型运动的方式。它的第一个参数是我们想要动画化的对象，第二个参数是定义运动的函数。这个程序中使用的唯一运动是`anim_rotate_around()`，它接受一个角度（以弧度为单位）和一个成为旋转中心的对象。外循环模型中的复杂复合运动容易构建，因为旋转的对象本身也可以处于运动状态。
- en: The final two `Object()` calls ➍ create the path tracking the planet and the
    projection showing its approximate observed position. Although these are animated
    objects, they don’t need an `act!()` call because they’re defined with reference
    to other animated objects.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的两个`Object()`调用 ➍ 创建了追踪行星路径的轨迹和显示其大致观测位置的投影。尽管这些是动画对象，但它们不需要`act!()`调用，因为它们是参考其他动画对象定义的。
- en: The `epicycles()` function also accepts two optional keyword arguments. The
    `eccentricity` gives the displacement of Earth from the center of the main orbit.
    If `file` is supplied, the program creates a video file and saves it there; if
    not, it displays the result in an interactive viewer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`epicycles()`函数还接受两个可选的关键字参数。`eccentricity`给出地球偏离主轨道中心的位移。如果提供了`file`，程序会创建一个视频文件并保存在指定位置；如果没有，它将在交互式查看器中显示结果。'
- en: 'As an example, to produce an animation with a planet that goes around once
    during the movie, with two epicycles going around two and three times as fast,
    the first with a diameter half of the orbit’s diameter, and the second with a
    diameter half the first’s, make the following call:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，要制作一个动画，让一个行星在电影中转一圈，同时有两个外圈分别绕行两圈和三圈，第一个外圈的直径是轨道直径的一半，第二个外圈的直径是第一个的二分之一，可以使用以下调用：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This call saves the rendered animation in an MP4 file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用会将渲染后的动画保存为 MP4 文件。
- en: The type of viewer depends on the coding environment. In the REPL, `Javis` opens
    a window with controls to step or scrub through the animation frames. In a Pluto
    notebook, the frames appear in a horizontal list with a scroll bar. A change to
    the rendering call when using a notebook, setting `liveview=false` ➎, will embed
    an animated GIF directly in the notebook instead. The `Javis` package can save
    animations as GIFs or MP4 files; the choice is controlled with the file extension.
    As GIFs can become quite large, the MP4 format is a good option; however, either
    one requires significant time to render compared with the `liveview` option, which
    is remarkably fast.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 视图类型取决于编码环境。在 REPL 中，`Javis` 会打开一个窗口，带有控制按钮，用于逐步或拖动动画帧。在 Pluto 笔记本中，帧以水平列表的形式出现，并带有滚动条。在使用笔记本时，修改渲染调用，将
    `liveview=false` ➎，会将动画 GIF 直接嵌入到笔记本中。`Javis` 包可以将动画保存为 GIF 或 MP4 文件；选择由文件扩展名控制。由于
    GIF 文件可能变得非常大，MP4 格式是一个不错的选择；然而，无论哪种格式，与 `liveview` 选项相比，都需要显著的渲染时间，而 `liveview`
    非常快速。
- en: '[Figure 7-5](ch07.xhtml#ch7fig5) shows one frame from the rendered video. (See
    the book’s online supplement at [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org)
    for the full video.)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7-5](ch07.xhtml#ch7fig5) 显示了渲染视频中的一帧。（请访问本书的在线补充材料 [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org)
    获取完整视频。）'
- en: '![Image](../images/ch07fig05.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/ch07fig05.jpg)'
- en: '*Figure 7-5: A frame from an animation created using* Javis'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 7-5：使用* Javis 创建的动画中的一帧'
- en: We are able to create this visualization using only one type of motion, the
    `anim_rotate_around()` call. To make an object spin around its origin, the call
    is `anim_rotate()`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够仅通过一种类型的运动 `anim_rotate_around()` 来创建这个可视化效果。要让一个对象围绕其原点旋转，调用是 `anim_rotate()`。
- en: 'Some of the other motions that we can create by supplying them as arguments
    to `Action()` include the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将它们作为参数传递给 `Action()`，我们可以创建以下一些其他的运动：
- en: appear() **and** disappear() Accept any of the arguments `:fade`, `:scale`,
    and `:fade_line_width`, and make the object come into or out of existence by changing
    the specified property. Using `:draw_text` makes text appear with a typing effect.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: appear() **和** disappear() 接受 `:fade`、`:scale` 和 `:fade_line_width` 等任何参数，并通过改变指定的属性使对象出现或消失。使用
    `:draw_text` 可以使文本出现，带有打字效果。
- en: follow_path() Causes an object to follow a path given as a series of points.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: follow_path() 使一个对象沿着一系列点的路径移动。
- en: anim_scale() Shrinks or grows an object.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: anim_scale() 缩小或放大一个对象。
- en: anim_translate() Moves an object along a line.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: anim_translate() 沿直线移动一个对象。
- en: change() Changes any property of an object.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: change() 改变对象的任何属性。
- en: '**Animations with Reel**'
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**使用 Reel 创建动画**'
- en: The `Reel` package, like `Javis`, creates animations, but it serves a different
    purpose. While `Javis` makes it easy to create animations by programmatically
    describing objects and their motions, `Reel` lets us create a video from any function
    that creates images depending on a parameter (typically time).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reel` 包与 `Javis` 类似，也用于创建动画，但用途不同。虽然 `Javis` 通过编程描述对象及其运动来轻松创建动画，`Reel` 则让我们可以根据一个参数（通常是时间）从任何创建图像的函数生成视频。'
- en: 'We use an exported function from `Reel`, called `roll()`, to which we pass
    an image-creating function of two positional arguments: the `duration` that we
    want for the video and the frames per second (`fps`). The two aforementioned positional
    arguments are time (`t`) and timestep (`dt`); `roll()` calculates both of these,
    setting `dt = duration/fps`, and passes them to the function, calling it repeatedly,
    each time with an updated `t`. It returns a video object that we turn into either
    a GIF or an MP4 file with a call to `write()`. Arranging for a function to accept
    `t` and `dt` and create the desired video frame is our responsibility.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '*The* Reel *package is not updated frequently, and may not work properly in
    every computing environment. An alternative, that only creates GIFs but is simple
    and convenient, is built into recent versions of* Plots*. See “Further Reading”
    on [page 211](ch07.xhtml#fur7)* *for documentation of the* @animate *and* @gif
    *macros.*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-5](ch07.xhtml#ch7lis5) calculates the displacement of one axisymmetric
    mode of a vibrating drumhead and creates a video visualizing the motion as a heatmap.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 7-5: Animating the vibration of a circular drum head*'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: First we import three packages. The vibrating circular drumhead has a radial
    dependence described by a Bessel function, available from the `SpecialFunctions`
    package. We use a plotting function from `Plots` to create our movie frames, and
    then use `Reel` to stitch the animation together.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: After defining a few constants for the solution, we define the `vibe()` function,
    which takes the radial coordinate and a keyword argument `t` and returns the solution
    at that time and coordinate. The Bessel function *J*[0] from the `SpecialFunctions`
    package is named `besselj0()` ➊.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two lines define the coordinate arrays for plotting. A polar coordinate
    system is most natural in this circular geometry: `r` is the radial coordinate
    and `theta` is the angular coordinate. We have to wrap ➋ the plotting function
    in a function of `t` and `dt` so that `roll()` can generate the animation frames.
    For this application, we don’t use `dt` for anything, but the function still needs
    to accept two arguments. The call to `heatmap()` uses the `:curl` color spectrum,
    which has a thin white region near 0, letting us see the nodal lines and clearly
    distinguishing the positive and negative regions. The `proj` argument selects
    the polar geometry.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-6](ch07.xhtml#ch7fig6) shows one frame from the resulting animation.
    (See the online supplement at [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org)
    for the complete video.)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch07fig06.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: One frame from a vibrating drumhead animation*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: After we create the video with the `roll()` function, we save the result to
    a file using `write()`. The file extension specifies the video format; the other
    two choices are GIF and WEBM.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The `write()` function is Julia’s standard for writing data to files. The `Reel`
    package defines a version of it that converts the video to the requested format
    when it sees a `Reel` video in its second argument. [Chapter 8](ch08.xhtml) explains
    how this is possible and how you can make your own specialized versions of functions
    activated by the types of their arguments.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '**Interactive Visualizations in Pluto**'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Pluto notebook (see “Pluto: A Better Notebook” on [page 17](ch01.xhtml#ch01lev1sec9))
    provides an easy way to create interactive animations through its `@bind` macro.
    This macro binds the output of any of the standard HTML input controls to a Julia
    variable. When we execute a cell containing a `@bind` macro call, Pluto creates
    the control in the output area for the cell. When the user manipulates the control,
    Pluto instantly updates the value of the variable to which the control is bound.
    Because of the reactive nature of the notebook, any cells that depend on that
    value are automatically re-executed. If any of those cells produce a graph or
    other visualization, the graphic will change in response to the user interaction.
    Input controls in HTML include sliders, numerical or text input boxes, file choosers,
    color pickers, checkboxes, selection menus, and more.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to actually write any HTML (or know anything about it) thanks
    to the `PlutoUI` package, which provides a convenient Julia interface to the HTML
    input controls. For HTML experts, however, the option to use the web’s markup
    language directly is supported. It’s even possible to create custom controls using
    JavaScript. See “Further Reading” on [page 211](ch07.xhtml#fur7) for links to
    more information and for `PlutoUI` documentation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a few examples of how to use the `@bind` macro with `PlutoUI`
    controls. The following uses the browser’s date-picker widget:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This command assigns the date the user selected to some_date, which will have
    Julia’s `Dates.DateTime` data type.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'This example uses the HTML checkbox:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here a_setting becomes a `Boolean`: `true` if the user clicks the box and `false`
    otherwise.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'The following uses an HTML text field:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This call will assign whatever the user types into a text box as a `String`
    to the variable label.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: There are many more. All of these functions accept a `default` keyword argument,
    and some accept other arguments as well. For example, `TextField()` accepts an
    optional tuple argument; if supplied, it creates a multiline `textarea` with the
    number of columns and rows taken from the tuple’s first and second elements.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: As an example of an interactive visualization, let’s return to the vibrating
    drumhead problem from [Listing 7-5](ch07.xhtml#ch7lis5). The goal is to create
    a notebook containing a plot of the drumhead where the user can move in time by
    manipulating a slider.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: We’ll make a few small changes to the code from [Listing 7-5](ch07.xhtml#ch7lis5).
    First, we need one additional import, `using PlutoUI`, to be able to use the HTML
    widgets, and we won’t need to import `Reel`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vibe()` function needs no changes, but let’s alter the plotting function
    to make a surface plot rather than a heatmap and to show the time in a title.
    The `surface()` function from `Plots` doesn’t understand polar coordinates, so
    we need to use `x` and `y` and convert manually:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We want the interactivity to be responsive, so we’ll sacrifice some smoothness
    in the plot by using a coarser gridding:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We’re not making a movie, so we don’t need the last two lines of [Listing 7-5](ch07.xhtml#ch7lis5).
    To make the notebook, we import `Pluto` in the REPL and execute `Pluto.run()`,
    which opens a new tab in the default web browser with the Pluto start page. After
    clicking the link to create a new notebook, we can enter all these variable and
    function definitions into cells. The final cell will contain the line:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The range supplied as an argument will become the starting, step size, and ending
    values for the slider. The ending value is the time for one complete vibration
    cycle.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: A picture in a book can’t convey the experience of using the notebook. For that,
    there is no substitute for trying it yourself. But [Figure 7-7](ch07.xhtml#ch7fig7)
    shows a screenshot of the plot and slider.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch07fig07.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: The vibrating drumhead in a Pluto notebook*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Interactive Pluto notebooks are a powerful means to create explanatory documents
    and educational material. The fact that they’re stored as text files makes them
    easy to share, at least with other Julia users.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The packages we’ve explored in this chapter make it easy to create a wide variety
    of diagrams and animations. This facility is a boon to the community of Julia
    users, as many of the scientists and engineers who form a large segment of its
    audience are also teachers, conference presenters, and creators of online educational
    materials. All of these activities are enhanced by having tools at hand to construct
    explanatory visualizations. The ability to create complex visualizations within
    Julia is important: much of the time they will require computations that we’re
    already performing in our Julia programs. Indeed, often they will be part of the
    dissemination of the results of those computations. Packages such as `Luxor` and
    `Javis` free us from the need to reach for external programs and from becoming
    mired in another “two language problem.”'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll return to the language itself and learn about the
    type system. This is the final piece required for Julia mastery; putting it in
    place will unlock a new level of programming power.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Videos and color images are available in the online supplement at [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Luxor` documentation is available at [*http://juliagraphics.github.io/Luxor.jl/stable/*](http://juliagraphics.github.io/Luxor.jl/stable/).
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Javis` documentation is available at [*https://juliaanimators.github.io/Javis.jl/stable/*](https://juliaanimators.github.io/Javis.jl/stable/).
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `GraphRecipes` attributes, including a complete list of available layout
    algorithms, visit [*https://docs.juliaplots.org/stable/generated/graph_attributes/*](https://docs.juliaplots.org/stable/generated/graph_attributes/).
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation for the `NetworkLayout` package that supplies the different graph
    layout algorithms, where you can see interesting animations of the workings of
    the various layout strategies, is available at [*https://juliagraphs.org/NetworkLayout.jl/stable/*](https://juliagraphs.org/NetworkLayout.jl/stable/).
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For details on how to use the `@gif` and `@animate` macros, visit [*https://docs.juliaplots.org/latest/animations/*](https://docs.juliaplots.org/latest/animations/).
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tutorial on making custom interface components for Pluto using JavaScript
    is available at [*https://cotangent.dev/how-to-make-custom-pluto-ui-components/*](https://cotangent.dev/how-to-make-custom-pluto-ui-components/).
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The creator of Pluto explains how to create custom interactions using JavaScript
    in this video: [*https://www.youtube.com/watch?v=SAC_RCjyRRs*](https://www.youtube.com/watch?v=SAC_RCjyRRs).'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For documentation on the functions available in `PlutoUI`, visit [*https://docs.juliahub.com/PlutoUI/*](https://docs.juliahub.com/PlutoUI/).
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
