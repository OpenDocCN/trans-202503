- en: '**7'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DIAGRAMS AND ANIMATIONS**
  prefs: []
  type: TYPE_NORMAL
- en: '*Tell me, Steed. Is everything to scale?*'
  prefs: []
  type: TYPE_NORMAL
- en: —Mrs. Peel
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Diagrams are an essential form of scientific communication and education. The
    type of diagram treated in this chapter is distinct from the plots of data or
    mathematical functions we worked with in [Chapter 4](ch04.xhtml). *Diagrams* in
    this context refers to illustrations of mathematical structures, drawings of experimental
    setups, flowcharts describing algorithms or processing pipelines, and similar
    graphical descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: Animations now frequently accompany scientific papers reporting on simulations,
    as supplementary material offered online. They’re also a valuable tool in education
    and have a myriad of uses in scientific and mathematical communication. In this
    chapter, we’ll explore several Julia packages that can help you create a variety
    of types of diagrams and animations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Diagramming with Luxor**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Luxor` package is sophisticated and highly versatile, allowing you to create
    almost any type of diagram. To install it, enter add Luxor in the package manager.
  prefs: []
  type: TYPE_NORMAL
- en: The package uses an imperative style to build up a picture in stages. You enter
    a series of commands that manipulate a global state, each command potentially
    adding something to the drawing. The effect of each drawing command depends on
    the state at the time it is entered. For example, to draw a blue circle, first
    set the color to blue and then enter the circle-drawing command, with arguments
    giving its position, size, and whether it should be “stroked” (an outline drawn)
    or filled. The outline or fill will use the currently set color. Each element—circles,
    polygons, lines, text, or any of a variety of objects—requires a separate command,
    and colors, styles, opacities, and other settings are set globally before each
    command is issued.
  prefs: []
  type: TYPE_NORMAL
- en: For a concrete example, let’s create a simple diagram (shown in [Figure 7-1](ch07.xhtml#ch7fig1))
    of the relative sizes of the planets in the solar system, arranged in order of
    their distance from the Sun.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch07fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-1: The relative sizes of the planets*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-1](ch07.xhtml#ch7lis1) shows the complete REPL session that creates
    the diagram in [Figure 7-1](ch07.xhtml#ch7fig1).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-1: Creating a diagram of the solar system using* Luxor'
  prefs: []
  type: TYPE_NORMAL
- en: The program gets its planetary diameters, which are in kilometers, from a NASA
    website (see “Further Reading” on [page 211](ch07.xhtml#fur7)). When copying and
    pasting from the NASA table there, the numbers are space separated. This creates
    a `1\times10` array (Earth’s moon and Pluto are included), which is fine; we just
    need a list we can iterate over.
  prefs: []
  type: TYPE_NORMAL
- en: The double semicolon at the end of the line ➊ breaks the literal input of the
    array over two lines (this feature was added in Julia v1.7). Although spaces and
    double semicolons both signify concatenation along the second dimension, normally
    you may not mix them in a single literal array definition. The usage here is an
    exception just for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The two variables `dimenx` and `dimeny` hold the dimensions of our diagram.
    Dimensions in `Luxor` are points, which are 1/72 of an inch.
  prefs: []
  type: TYPE_NORMAL
- en: '`Luxor` supplies several macros for conveniently setting up the drawing environment.
    The `@png` macro ➋ initializes a PNG illustration, defines the origin of the coordinate
    system to be the center of the picture, and displays the result upon reaching
    the end of the block ➐. After the final `end` statement, we give the dimensions
    of the image and its filename (you can leave this out, but probably won’t want
    to). The default size is 600×600, and the default filename is *luxor-drawing-*
    followed by a timestamp and the file extension. This can lead to a profusion of
    files on your disk as you develop your drawing code, so you probably want to specify
    a filename, which will get overwritten on each run. The file extension is optional
    and `Luxor` will supply one if you leave it out.'
  prefs: []
  type: TYPE_NORMAL
- en: We need a scaling factor to deal with the large planetary diameters, which we
    assign to `dscale`.
  prefs: []
  type: TYPE_NORMAL
- en: The macro sets the origin of the coordinate system to the center of the diagram,
    which, using our variables, would be `(dimenx/2, dimeny/2)`. The code will be
    neater if we set the origin ➌ in the *x*-direction such that the left edge of
    the first planet starts at the left boundary.
  prefs: []
  type: TYPE_NORMAL
- en: I discovered that, on my system, if I don’t set a `fontface` ➍, I get ugly bitmapped
    fonts in the output. This particular font may not exist on your system, so adjust
    as needed. If you ask for a font that `Luxor` can’t find, it will carry on, making
    a substitution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The x-coordinate of the current circle’s center is assigned to `ledge`, which
    is updated twice ➎ for each planet: once to increase it by the radius of the previous
    planet and once by the planet about to be drawn. The result is a series of osculating
    circles.'
  prefs: []
  type: TYPE_NORMAL
- en: The color is set to blue and the dash style to dot ➏ before each label is printed.
    As with other diagrams in this chapter, you can find color versions in the online
    supplement at [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org).
  prefs: []
  type: TYPE_NORMAL
- en: If you run the code from [Listing 7-1](ch07.xhtml#ch7lis1) in the REPL, your
    default image viewing application will open a window displaying the diagram file
    when you run the code. The REPL will hang until you quit the application. If you
    run this in Pluto or Jupyter, the diagram will be embedded in the cell below the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Other options for macros are `@svg` and `@pdf`, which create files of the respective
    types. However, PDFs will not be embedded into notebooks.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to lines, circles, and text, `Luxor` has commands for drawing several
    other shapes, and even such geometrical constructions as tangent lines to circles.
    (See “Further Reading” on [page 211](ch07.xhtml#fur7) for a link to the manual.)
  prefs: []
  type: TYPE_NORMAL
- en: '**The Graphs Package**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With enough patience, you can use `Luxor` to create any type of diagram. However,
    it’s usually easier to use a specialized package for diagrams of a specific, standard
    type.
  prefs: []
  type: TYPE_NORMAL
- en: This section is about graphs in the mathematical sense and their visualization.
    The word *graph* is often used synonymously with the types of plots that were
    the subject of [Chapter 4](ch04.xhtml), but to a mathematician, a graph is a set
    of nodes connected by edges, and that’s the type of graph we consider here. Graphs
    of this type are used to represent a huge variety of systems. Anytime you have
    a collection of objects that are connected together in a network of relationships,
    you have a graph. Examples include a taxonomy of plants or animals, call sites
    in a computer program, grammatical structures in a sentence, organizational charts,
    and the relationships among characters in a novel. In such a graph, the objects
    (parts of the organization or characters in the novel) are called *nodes* and
    the connections between nodes are called *edges*.
  prefs: []
  type: TYPE_NORMAL
- en: The Julia `Graphs` package contains functions for making several types of graphs.
    It depends upon `Plots` and `GraphRecipes` to actually draw the pictures representing
    the graphs. The first of these we’re familiar with from [Chapter 4](ch04.xhtml);
    the second is a collection of *plotting recipes* that, in turn, use `Plots` to
    draw pictures. The recipe mechanism allows users and package authors to extend
    `Plots` so that it can visualize new data types or make new types of plots. To
    understand how these recipes work, we need to know more about the type system,
    so plot recipes are covered in “Plot Recipes” on [page 252](ch08.xhtml#ch08lev7).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an introduction to the `Graphs` package, we’ll build a program to create
    a diagram of the predator–prey relationships among 14 species living in the Chesapeake
    Bay in the eastern United States:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: First, we import the three necessary libraries (`Plots`, `Graphs`, and `Graph`
    `Recipes`) and create a vector of the names of the creatures. These names will
    become labels in the diagram and will also serve as references for the graph’s
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: The final line of the program so far creates an empty *directed graph* with
    14 nodes (called “vertices” by `Graphs.jl)`. A directed graph is one where the
    edges have a direction, usually represented visually as an arrowhead. For this
    example, the direction of the edge will represent what creature eats what. In
    an *undirected graph*, the edges simply represent connections, with no hierarchy
    involved.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to add edges to `foodchain` representing information about
    the predator–prey relationships. The `add_edge!(foodchain, a, b)` function mutates
    the graph in its first argument by adding an edge going from node `a` to node
    `b`. That’s what we want, but it’s not convenient, because `a` and `b` need to
    be integers representing the orders of the nodes in the list. To enter these arguments,
    we would have to count through the list of `creatures` for each relationship.
    For example, to enter an edge representing the fact that striped bass eat worms,
    we would have to call `add_edge!(foodchain, 1, 7)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make the process more convenient by defining a dictionary and a function
    that will allow us to refer to the creatures by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `food_dict` dictionary simply associates each creature string with its order
    in the list, for easy reference. The new function allows us to add edges by naming
    the predator and its prey. We’re using a name for this function that can serve
    as an infix operator (see “Operators Are Functions Too” on [page 159](ch06.xhtml#ch06lev1sec4)).
    The REPL shortcut (and LaTeX command) for that character is `\hookrightarrow`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the hooked arrow function in place, we can list a set of predator–prey
    relationships taken from a study of the ecology of the Chesapeake Bay:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `add_edge!()` function mutates the `foodchain` graph by adding edges. The
    last call produces the illustration shown in [Figure 7-2](ch07.xhtml#ch7fig2).
    In the diagram, the arrows point from predator to prey, reflecting the directions
    of the edges we defined.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch07fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-2: The predator–prey food net in the Chesapeake Bay*'
  prefs: []
  type: TYPE_NORMAL
- en: If you run this program, you will find that your picture looks somewhat different.
    In fact, each time you run it the diagram will be arranged differently in space,
    although the *structure* will always be the same—the same creatures being eaten
    by the same predators. This happens because of a random element in how the nodes
    and edges are arranged. In fact, I had to run the program about five times before
    I got a result that I liked. Some of the generated graphs were rather poor, with
    overlapping nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final argument in the call to `graphplot()`, `method`, selects an algorithm
    for laying out the graph: for turning the structure into a picture by deciding
    where to place the nodes. The `stress` algorithm does this by trying to maximize
    a global measure of how far the distances between nodes differ from a theoretical
    optimum. The random element comes in because the algorithm finds this maximum
    by deforming a random initial state.'
  prefs: []
  type: TYPE_NORMAL
- en: '***The Adjacency Matrix***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Internally, the list of edges established by calls to `add_edge!()` gets transformed
    into an *adjacency matrix*. We can see the adjacency matrix as shown in [Listing
    7-2](ch07.xhtml#ch7lis2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-2: The adjacancy matrix is a sparse array.*'
  prefs: []
  type: TYPE_NORMAL
- en: The result is returned as a *sparse array*, one of a collection of data types
    defined in the `SparseArrays` package, which the `Graphs` package loads automatically.
    A sparse array behaves similarly to a normal array, but is specialized to be efficient
    when only a small proportion of its elements are defined. The REPL displays them
    as shown in [Listing 7-2](ch07.xhtml#ch7lis2), with dots representing undefined
    locations.
  prefs: []
  type: TYPE_NORMAL
- en: The elements of an adjacency matrix are set to 1 to record the existence of
    edges in the graph. For example, `foodchain_matrix[1, 6]` has a 1, because there’s
    an edge going from node 1 to node 6 (established by `"Striped bass"`↪ `"Bay anchovy"`).
    The adjacency matrix encodes the structure of the graph, and therefore contains
    its complete definition, because a graph is identical to its structure. We can
    plot the graph with a call to `graphplot(foodchain_matrix)`; the remaining arguments
    simply supply details, such as names for labeling the nodes, for its display.
    If the adjacency matrix is symmetrical (`M[i, j]` `== M[j, i]`), it represents
    an undirected graph. Otherwise, as in the food chain example, it represents a
    directed graph, and `graphplot()` will draw it using arrows rather than simple
    lines. The adjacency matrix must have at least one nonzero element, or at least
    one edge defined with `add_edge!()`, before plotting a graph.
  prefs: []
  type: TYPE_NORMAL
- en: The package uses sparse matrices for efficiency, but, if we’re constructing
    an adjacency matrix directly, as in the next example, we have the option of using
    normal matrices. In this case, a 0 element indicates the absence of an edge and
    nonzero elements show where the edges are.
  prefs: []
  type: TYPE_NORMAL
- en: '***Factor Trees***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At the risk of awakening bad memories from high school algebra class, our next
    example, found in [Listing 7-3](ch07.xhtml#ch7lis3), will be a program to draw
    factor trees: graph diagrams showing the division of a number into ever-smaller
    factors, ending with its unique prime factors. It will show how to build a graph
    by constructing its adjacency matrix and provide an example of an undirected graph
    with a tree structure. Here’s the complete program that produces the factor tree.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-3: A program to create a factor tree*'
  prefs: []
  type: TYPE_NORMAL
- en: The new import, the first line of the program, gets us the `factor()` function
    ➊, which returns the prime factors of its argument. The program works only for
    integers `n` greater than 1\. The first argument supplied to `factor()` tells
    it to return the results in a vector, the form that we need to construct the factor
    tree. The default is to return the results in a special-purpose type that lists
    factors and multiplicities. If there is only one of those, `n` is a prime number,
    so we stop immediately ➋, announcing why. The program proceeds through the list
    of primes, dividing and concatenating the results onto the `names` vector. We
    then initialize the adjacency matrix `a` ➌ and record the links between each pair
    of factors and their product up the tree. The final call to `graphplot()` takes
    the adjacency matrix as its first argument; the keyword arguments set details
    for the illustration. The `nodesize` argument sets the extra size of the circles
    beyond what is required for them to contain their labels. The algorithm for enlarging
    them does not quite succeed in making them grow big enough, so we add something
    extra proportional to the number of digits in the label ➍. Calling `factree(14200)`
    produces [Figure 7-3](ch07.xhtml#ch7fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch07fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-3: A factor tree for the number 14,200*'
  prefs: []
  type: TYPE_NORMAL
- en: The package provides two layout methods for creating tree-like graphs. The `:tree`
    method works, but the results are a bit free-form. The `:buchheim` method ➎ produces
    the regular tree shown in [Figure 7-3](ch07.xhtml#ch7fig3). Although the prime
    factorization is unique, the factor tree that leads to it, and thus the result
    of the program, may not be.
  prefs: []
  type: TYPE_NORMAL
- en: '**Animations with Javis**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The widely used `Javis` package is a good choice for making almost any type
    of animated diagram. It’s built on top of `Luxor` (see “Diagramming with Luxor”
    on [page 190](ch07.xhtml#ch07lev1)), which means you can build on your knowledge
    of that package to create animations. A `Javis` program creates objects from `Luxor`
    drawing commands and turns them into videos by means of a fairly intuitive set
    of calls to rotate, translate, or move them along paths, as well as by changing
    shape parameters in time.
  prefs: []
  type: TYPE_NORMAL
- en: '***Closures***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To use `Javis` effectively, it helps to be familiar with a programming technique
    called a *closure*. Experienced programmers who know how to use closures can safely
    skip this section.
  prefs: []
  type: TYPE_NORMAL
- en: A closure is a function that is created and returned by another function. We’ll
    refer to the returned function as the *inner function* and the one that creates
    it as the *outer function*. Most modern languages allow the programmer to create
    closures, but some are more convenient for this than others. Julia, because of
    its lexical scoping and convenient syntax for function definition, makes closures
    easy and intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: The key aspect to closures is that the inner function can access variables defined
    in the outer function. We say that they are *closed over*, hence the name. The
    outer function becomes a function factory, returning a function whose behavior
    depends on the arguments passed to the outer function, but with, potentially,
    a completely different function signature.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-4](ch07.xhtml#ch7lis4) shows a simple example of a closure that
    we’ll find a useful application for shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-4: Defining a closure*'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this definition, when we call, for example, `power(5)`, we get a function
    of a single variable that raises that variable to the fifth power and returns
    the result. In other words, if we define two functions this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'then `p` and `q` have the same behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The function `power()` returns is anonymous, but we can assign it to a variable,
    in this case `p`, as we can any other function.
  prefs: []
  type: TYPE_NORMAL
- en: Now `power()` is a function factory that makes functions that raise their arguments
    to any desired exponent. As mentioned in “Plotting Functions” on [page 88](ch04.xhtml#ch04lev1sec2),
    one version of the `plot()` function from the `Plots` package accepted the simple
    names of functions of one variable to plot. We can plot such functions without
    mentioning variables or defining arrays.
  prefs: []
  type: TYPE_NORMAL
- en: It would seem that this convenience could not be exploited to plot, say, functions
    that depend on a parameter in addition to the independent variable, and that we
    would need to use named functions or the anonymous function syntax to pass such
    functions to `plot()`. For example, if we want to plot `f(x, n) = x^n`, we can’t
    just call `plot(f)`, because `f()` needs two arguments, but we could call `plot((x)
    -> x^n)` if `n` were already defined. Closures are an alternative to passing anonymous
    functions in cases such as this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the closure defined in [Listing 7-4](ch07.xhtml#ch7lis4), we can
    make the following plotting call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This produces the plot in [Figure 7-4](ch07.xhtml#ch7fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch07fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-4: Plotting with closures*'
  prefs: []
  type: TYPE_NORMAL
- en: This plotting example is simply one application of closures. They are a powerful
    technique for generating functions that capture the state under which they are
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: '***Epicycle Animation***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The pattern for using `Javis` is to define functions that produce each of the
    objects you intend to animate, and then call a series of statements that refer
    to those objects and animate them, changing their positions or other properties
    in time.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Since* Javis *is built on* Luxor*, it imports* Luxor *itself and re-exports
    that package’s functions. The consequence is that a program that contains* using
    Javis *must not also contain* using Luxor*, because that would lead to name conflicts.
    If you’ve been using* Luxor *in the REPL, you must start a new REPL before using*
    Javis*.*'
  prefs: []
  type: TYPE_NORMAL
- en: The object-creating functions use one or more `Luxor` functions for circles,
    lines, text, or other graphical entities available through `Luxor`, and optionally
    return information about the object for use in the animation calls.
  prefs: []
  type: TYPE_NORMAL
- en: The `Luxor` documentation describes three methods for passing the object-creating
    functions into the animation functions. We’ll learn another method, based on closures,
    that’s more general and leads to neater and easier-to-read code.
  prefs: []
  type: TYPE_NORMAL
- en: The goal for this example is to create a program that produces animations of
    models of the solar system in the style of Ptolemy. This ancient cosmology put
    our Earth at the center of the universe and explained observations of planets
    as caused by their circular orbits, which themselves circled around larger orbits.
    These circular orbits are called *epicycles*; any one planet’s motion might be
    modeled by one or more epicycles, ending with a large circle around a point somewhat
    displaced from Earth by a distance called the *eccentricity*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the program, we’ll start with functions that create the planets and
    orbits. Here’s the one for a planet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is a closure. A call to `planet()` returns a function that accepts three
    positional arguments and draws a circle with a radius, color, and position determined
    not by the arguments passed to the returned function, but by the original arguments
    passed to `planet()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This indirection is necessary because the `Javis` functions that do the animation
    expect a function as their first and only required argument. They don’t accept
    a shape as an argument, but a function that draws a shape. They pass the three
    values `(video, object, frame)` to this function: data types representing the
    video, the object being animated, and the integer frame number. The function can
    use any of them, or as in the case of the function created by `planet()`, none
    of them.'
  prefs: []
  type: TYPE_NORMAL
- en: The closure returns the circle’s position. We must do this if other animation
    functions need to know that position, as is the case in our video.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function for drawing orbits will be almost the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Orbits will have an outline, but won’t be filled in.
  prefs: []
  type: TYPE_NORMAL
- en: With these two functions, we can draw animatable planets and orbits, which is
    most of what we need. But it would also be nice to show how the wandering of the
    planet around the solar system translates into changes in its observed location
    in the sky relative to the fixed stars as the days go by. We’ll approximate this
    movement by the projection of the planet’s position along the horizontal coordinate.
    The `pos()` function supplied by `Javis` returns an object’s position, and it
    has convenient `x` and `y` fields for extracting the respective coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following function accepts an object and draws another circle that shares
    its horizontal coordinate, close to the top of the video:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here `observed_position()` uses the `video` argument’s `height` field ➊ automatically
    supplied by the animation functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We would like to draw one more object: a curve in space visualizing the path
    taken by the planet. We’ll record this path as a series of points in a global
    `positions` vector. At every frame, this function pushes the new position onto
    the vector and draws a series of tiny circles tracing the path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We need one more drawing function, used in nearly all `Javis` animations, for
    defining the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This definition for `ground()` creates a drawing canvas with a black background
    and uses white as the default drawing color.
  prefs: []
  type: TYPE_NORMAL
- en: 'With functions for each object we want to draw, we can create the animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `epicycles()` function accepts one required positional argument, `inputcycles`,
    in the form `[(s1, f1), (s2, f2), ..., fp]`. Each `(s, f)` pair gives the size
    `s` as a fraction of the main orbit radius of an epicycle with an orbital frequency
    of `f`. Frequencies here refer to the number of cycles completed during the animation.
    The final `fp` is the planet’s frequency.
  prefs: []
  type: TYPE_NORMAL
- en: 'After some calculations to scale the orbits according to the video’s overall
    size, and to adjust this size to account for the epicycles input by the user,
    we have the one statement ➊ that all `Javis` animations require: defining the
    `Video` and its dimensions.'
  prefs: []
  type: TYPE_NORMAL
- en: The first animation command ➋ establishes the background to be drawn for the
    first 500 frames. The next three animation commands are calls to `Object()`; this
    is the `Javis` command that places the graphical element on the background. The
    `Object()` function accepts a range of frames as a first argument, but uses the
    range supplied to the most recent `Background()` or `Object()` command as a default.
    `Javis` is an imperative system that maintains a state to which animation statements
    apply, containing the current `Video` and range of frames.
  prefs: []
  type: TYPE_NORMAL
- en: Next we have a loop that adds orbits for each epicycle supplied in the argument.
    The `act!()` function ➌ is how we create most types of motion in `Javis`. Its
    first argument is the object we want to animate, and the second argument is a
    function defining the motion. The only such motion we use in this program is `anim_rotate_around()`,
    which takes an angle (in radians) and the object that becomes the center of rotation.
    The complex, compound motions in the epicycle model are easy to construct because
    the object rotated around can itself be in motion.
  prefs: []
  type: TYPE_NORMAL
- en: The final two `Object()` calls ➍ create the path tracking the planet and the
    projection showing its approximate observed position. Although these are animated
    objects, they don’t need an `act!()` call because they’re defined with reference
    to other animated objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `epicycles()` function also accepts two optional keyword arguments. The
    `eccentricity` gives the displacement of Earth from the center of the main orbit.
    If `file` is supplied, the program creates a video file and saves it there; if
    not, it displays the result in an interactive viewer.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, to produce an animation with a planet that goes around once
    during the movie, with two epicycles going around two and three times as fast,
    the first with a diameter half of the orbit’s diameter, and the second with a
    diameter half the first’s, make the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This call saves the rendered animation in an MP4 file.
  prefs: []
  type: TYPE_NORMAL
- en: The type of viewer depends on the coding environment. In the REPL, `Javis` opens
    a window with controls to step or scrub through the animation frames. In a Pluto
    notebook, the frames appear in a horizontal list with a scroll bar. A change to
    the rendering call when using a notebook, setting `liveview=false` ➎, will embed
    an animated GIF directly in the notebook instead. The `Javis` package can save
    animations as GIFs or MP4 files; the choice is controlled with the file extension.
    As GIFs can become quite large, the MP4 format is a good option; however, either
    one requires significant time to render compared with the `liveview` option, which
    is remarkably fast.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-5](ch07.xhtml#ch7fig5) shows one frame from the rendered video. (See
    the book’s online supplement at [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org)
    for the full video.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch07fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-5: A frame from an animation created using* Javis'
  prefs: []
  type: TYPE_NORMAL
- en: We are able to create this visualization using only one type of motion, the
    `anim_rotate_around()` call. To make an object spin around its origin, the call
    is `anim_rotate()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the other motions that we can create by supplying them as arguments
    to `Action()` include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: appear() **and** disappear() Accept any of the arguments `:fade`, `:scale`,
    and `:fade_line_width`, and make the object come into or out of existence by changing
    the specified property. Using `:draw_text` makes text appear with a typing effect.
  prefs: []
  type: TYPE_NORMAL
- en: follow_path() Causes an object to follow a path given as a series of points.
  prefs: []
  type: TYPE_NORMAL
- en: anim_scale() Shrinks or grows an object.
  prefs: []
  type: TYPE_NORMAL
- en: anim_translate() Moves an object along a line.
  prefs: []
  type: TYPE_NORMAL
- en: change() Changes any property of an object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Animations with Reel**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Reel` package, like `Javis`, creates animations, but it serves a different
    purpose. While `Javis` makes it easy to create animations by programmatically
    describing objects and their motions, `Reel` lets us create a video from any function
    that creates images depending on a parameter (typically time).
  prefs: []
  type: TYPE_NORMAL
- en: 'We use an exported function from `Reel`, called `roll()`, to which we pass
    an image-creating function of two positional arguments: the `duration` that we
    want for the video and the frames per second (`fps`). The two aforementioned positional
    arguments are time (`t`) and timestep (`dt`); `roll()` calculates both of these,
    setting `dt = duration/fps`, and passes them to the function, calling it repeatedly,
    each time with an updated `t`. It returns a video object that we turn into either
    a GIF or an MP4 file with a call to `write()`. Arranging for a function to accept
    `t` and `dt` and create the desired video frame is our responsibility.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The* Reel *package is not updated frequently, and may not work properly in
    every computing environment. An alternative, that only creates GIFs but is simple
    and convenient, is built into recent versions of* Plots*. See “Further Reading”
    on [page 211](ch07.xhtml#fur7)* *for documentation of the* @animate *and* @gif
    *macros.*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 7-5](ch07.xhtml#ch7lis5) calculates the displacement of one axisymmetric
    mode of a vibrating drumhead and creates a video visualizing the motion as a heatmap.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 7-5: Animating the vibration of a circular drum head*'
  prefs: []
  type: TYPE_NORMAL
- en: First we import three packages. The vibrating circular drumhead has a radial
    dependence described by a Bessel function, available from the `SpecialFunctions`
    package. We use a plotting function from `Plots` to create our movie frames, and
    then use `Reel` to stitch the animation together.
  prefs: []
  type: TYPE_NORMAL
- en: After defining a few constants for the solution, we define the `vibe()` function,
    which takes the radial coordinate and a keyword argument `t` and returns the solution
    at that time and coordinate. The Bessel function *J*[0] from the `SpecialFunctions`
    package is named `besselj0()` ➊.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two lines define the coordinate arrays for plotting. A polar coordinate
    system is most natural in this circular geometry: `r` is the radial coordinate
    and `theta` is the angular coordinate. We have to wrap ➋ the plotting function
    in a function of `t` and `dt` so that `roll()` can generate the animation frames.
    For this application, we don’t use `dt` for anything, but the function still needs
    to accept two arguments. The call to `heatmap()` uses the `:curl` color spectrum,
    which has a thin white region near 0, letting us see the nodal lines and clearly
    distinguishing the positive and negative regions. The `proj` argument selects
    the polar geometry.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7-6](ch07.xhtml#ch7fig6) shows one frame from the resulting animation.
    (See the online supplement at [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org)
    for the complete video.)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch07fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-6: One frame from a vibrating drumhead animation*'
  prefs: []
  type: TYPE_NORMAL
- en: After we create the video with the `roll()` function, we save the result to
    a file using `write()`. The file extension specifies the video format; the other
    two choices are GIF and WEBM.
  prefs: []
  type: TYPE_NORMAL
- en: The `write()` function is Julia’s standard for writing data to files. The `Reel`
    package defines a version of it that converts the video to the requested format
    when it sees a `Reel` video in its second argument. [Chapter 8](ch08.xhtml) explains
    how this is possible and how you can make your own specialized versions of functions
    activated by the types of their arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Interactive Visualizations in Pluto**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Pluto notebook (see “Pluto: A Better Notebook” on [page 17](ch01.xhtml#ch01lev1sec9))
    provides an easy way to create interactive animations through its `@bind` macro.
    This macro binds the output of any of the standard HTML input controls to a Julia
    variable. When we execute a cell containing a `@bind` macro call, Pluto creates
    the control in the output area for the cell. When the user manipulates the control,
    Pluto instantly updates the value of the variable to which the control is bound.
    Because of the reactive nature of the notebook, any cells that depend on that
    value are automatically re-executed. If any of those cells produce a graph or
    other visualization, the graphic will change in response to the user interaction.
    Input controls in HTML include sliders, numerical or text input boxes, file choosers,
    color pickers, checkboxes, selection menus, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: We don’t need to actually write any HTML (or know anything about it) thanks
    to the `PlutoUI` package, which provides a convenient Julia interface to the HTML
    input controls. For HTML experts, however, the option to use the web’s markup
    language directly is supported. It’s even possible to create custom controls using
    JavaScript. See “Further Reading” on [page 211](ch07.xhtml#fur7) for links to
    more information and for `PlutoUI` documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a few examples of how to use the `@bind` macro with `PlutoUI`
    controls. The following uses the browser’s date-picker widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This command assigns the date the user selected to some_date, which will have
    Julia’s `Dates.DateTime` data type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example uses the HTML checkbox:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here a_setting becomes a `Boolean`: `true` if the user clicks the box and `false`
    otherwise.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following uses an HTML text field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This call will assign whatever the user types into a text box as a `String`
    to the variable label.
  prefs: []
  type: TYPE_NORMAL
- en: There are many more. All of these functions accept a `default` keyword argument,
    and some accept other arguments as well. For example, `TextField()` accepts an
    optional tuple argument; if supplied, it creates a multiline `textarea` with the
    number of columns and rows taken from the tuple’s first and second elements.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of an interactive visualization, let’s return to the vibrating
    drumhead problem from [Listing 7-5](ch07.xhtml#ch7lis5). The goal is to create
    a notebook containing a plot of the drumhead where the user can move in time by
    manipulating a slider.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll make a few small changes to the code from [Listing 7-5](ch07.xhtml#ch7lis5).
    First, we need one additional import, `using PlutoUI`, to be able to use the HTML
    widgets, and we won’t need to import `Reel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `vibe()` function needs no changes, but let’s alter the plotting function
    to make a surface plot rather than a heatmap and to show the time in a title.
    The `surface()` function from `Plots` doesn’t understand polar coordinates, so
    we need to use `x` and `y` and convert manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We want the interactivity to be responsive, so we’ll sacrifice some smoothness
    in the plot by using a coarser gridding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re not making a movie, so we don’t need the last two lines of [Listing 7-5](ch07.xhtml#ch7lis5).
    To make the notebook, we import `Pluto` in the REPL and execute `Pluto.run()`,
    which opens a new tab in the default web browser with the Pluto start page. After
    clicking the link to create a new notebook, we can enter all these variable and
    function definitions into cells. The final cell will contain the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The range supplied as an argument will become the starting, step size, and ending
    values for the slider. The ending value is the time for one complete vibration
    cycle.
  prefs: []
  type: TYPE_NORMAL
- en: A picture in a book can’t convey the experience of using the notebook. For that,
    there is no substitute for trying it yourself. But [Figure 7-7](ch07.xhtml#ch7fig7)
    shows a screenshot of the plot and slider.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/ch07fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 7-7: The vibrating drumhead in a Pluto notebook*'
  prefs: []
  type: TYPE_NORMAL
- en: Interactive Pluto notebooks are a powerful means to create explanatory documents
    and educational material. The fact that they’re stored as text files makes them
    easy to share, at least with other Julia users.
  prefs: []
  type: TYPE_NORMAL
- en: '**Conclusion**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The packages we’ve explored in this chapter make it easy to create a wide variety
    of diagrams and animations. This facility is a boon to the community of Julia
    users, as many of the scientists and engineers who form a large segment of its
    audience are also teachers, conference presenters, and creators of online educational
    materials. All of these activities are enhanced by having tools at hand to construct
    explanatory visualizations. The ability to create complex visualizations within
    Julia is important: much of the time they will require computations that we’re
    already performing in our Julia programs. Indeed, often they will be part of the
    dissemination of the results of those computations. Packages such as `Luxor` and
    `Javis` free us from the need to reach for external programs and from becoming
    mired in another “two language problem.”'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll return to the language itself and learn about the
    type system. This is the final piece required for Julia mastery; putting it in
    place will unlock a new level of programming power.
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  prefs: []
  type: TYPE_NORMAL
- en: Videos and color images are available in the online supplement at [*https://julia.lee-phillips.org*](https://julia.lee-phillips.org).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Luxor` documentation is available at [*http://juliagraphics.github.io/Luxor.jl/stable/*](http://juliagraphics.github.io/Luxor.jl/stable/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Javis` documentation is available at [*https://juliaanimators.github.io/Javis.jl/stable/*](https://juliaanimators.github.io/Javis.jl/stable/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For `GraphRecipes` attributes, including a complete list of available layout
    algorithms, visit [*https://docs.juliaplots.org/stable/generated/graph_attributes/*](https://docs.juliaplots.org/stable/generated/graph_attributes/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation for the `NetworkLayout` package that supplies the different graph
    layout algorithms, where you can see interesting animations of the workings of
    the various layout strategies, is available at [*https://juliagraphs.org/NetworkLayout.jl/stable/*](https://juliagraphs.org/NetworkLayout.jl/stable/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For details on how to use the `@gif` and `@animate` macros, visit [*https://docs.juliaplots.org/latest/animations/*](https://docs.juliaplots.org/latest/animations/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tutorial on making custom interface components for Pluto using JavaScript
    is available at [*https://cotangent.dev/how-to-make-custom-pluto-ui-components/*](https://cotangent.dev/how-to-make-custom-pluto-ui-components/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The creator of Pluto explains how to create custom interactions using JavaScript
    in this video: [*https://www.youtube.com/watch?v=SAC_RCjyRRs*](https://www.youtube.com/watch?v=SAC_RCjyRRs).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For documentation on the functions available in `PlutoUI`, visit [*https://docs.juliahub.com/PlutoUI/*](https://docs.juliahub.com/PlutoUI/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
