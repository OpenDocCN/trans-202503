<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="315" id="Page_315"/>12</span><br/>
<span class="ChapterTitle">Network File Transfer and Sharing</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">This chapter surveys options for distributing and sharing files between machines on a network. We’ll start by looking at some ways to copy files other than the <code>scp</code> and <code>sftp</code> utilities that you’ve already seen. Then we’ll discuss true file sharing, where you attach a directory on one machine to another machine.</p>
<p><span epub:type="pagebreak" title="316" id="Page_316"/>Because there are so many ways to distribute and share files, here’s a list of scenarios with corresponding solutions:</p>
<table id="tabular-500402c12-0001" border="1"><tbody>
<tr>
<td>Make a file or directory from your Linux machine temporarily available to other machines.</td><td>Python SimpleHTTPServer (<span class="xref" itemid="xref_target_Section 12.1">Section 12.1</span>)</td></tr>
<tr>
<td>Distribute (copy) files across machines, particularly on a regular basis.</td><td>rsync (<span class="xref" itemid="xref_target_Section 12.2">Section 12.2</span>)</td></tr>
<tr>
<td>Regularly share the files on your Linux machine to Windows machines.</td><td>Samba (<span class="xref" itemid="xref_target_Section 12.4">Section 12.4</span>)</td></tr>
<tr>
<td>Mount Windows shares on your Linux machine.</td><td>CIFS (<span class="xref" itemid="xref_target_Section 12.4">Section 12.4</span>)</td></tr>
<tr>
<td>Implement small-scale sharing between Linux machines with minimal setup.</td><td>SSHFS (<span class="xref" itemid="xref_target_Section 12.5">Section 12.5</span>)</td></tr>
<tr>
<td>Mount larger filesystems from an NAS or other server on your trusted local network.</td><td>NFS (<span class="xref" itemid="xref_target_Section 12.6">Section 12.6</span>)</td></tr>
<tr>
<td>Mount cloud storage to your Linux machine.</td><td>Various FUSE-based filesystems (<span class="xref" itemid="xref_target_Section 12.7">Section 12.7</span>)</td></tr>
</tbody>
</table>
<p>Notice that there’s nothing here about large-scale sharing between multiple locations with many users. Though not impossible, such a solution generally requires a fair amount of work, and is not within the scope of this book. We’ll end the chapter by discussing why this is the case.</p>
<p>Unlike many other chapters in this book, the last part of this chapter is not advanced material. In fact, the sections that you might get the most value from are the most “theoretical” ones. Sections <span class="xref" itemid="xref_target_12.3">12.3</span> and <span class="xref" itemid="xref_target_12.8">12.8</span> will help you understand <em>why</em> there are so many options listed here in the first place.</p>
<h2 id="h1-500402c12-0001">	12.1	Quick Copy</h2>
<p class="BodyFirst">Let’s say you want to copy a file (or files) from your Linux machine to another one on your personal network, and you don’t care about copying it back or anything fancy—you just want to get your files there quickly. There’s a convenient way to do this with Python. Just go to the directory containing the file(s) and run:</p>
<pre><code>$ <b>python -m SimpleHTTPServer</b></code></pre>
<p>This starts a basic web server that makes the current directory available to any browser on the network. By default, it runs on port 8000, so if the machine you run this on is at address 10.1.2.4, point your browser on the destination system to <em>http://10.1.2.4:8000</em> and you’ll be able to grab what you need.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">WARNING</span></h2>
<p>	This method assumes that your local network is secure. Don’t do this on a public network or any other network environment that you do not trust.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c12-0002"><span epub:type="pagebreak" title="317" id="Page_317"/>	12.2	rsync</h2>
<p class="BodyFirst">When you want to start copying more than just a file or two, you can turn to tools that require server support on the destination. For example, you can copy an entire directory structure to another place with <code>scp -r</code>, provided that the remote destination has SSH and SCP server support (this is available for Windows and macOS). We’ve already seen this option in <span class="xref" itemid="xref_target_Chapter 10">Chapter 10</span>:  </p>
<pre><code>$ <b>scp -r </b><var class="bold">directory</var><b> </b><var class="bold">user</var><b>@</b><var class="bold">remote_host[</var><b>:</b><var class="bold">dest_dir]</var></code></pre>
<p>This method gets the job done but is not very flexible. In particular, after the transfer completes, the remote host may not have an exact copy of the directory. If <var>directory</var> already exists on the remote machine and contains some extraneous files, those files persist after the transfer.</p>
<p>If you expect to do this sort of thing regularly (and especially if you plan to automate the process), you should use a dedicated synchronizer system that can also perform analysis and verification. On Linux, <code>rsync</code> is the standard synchronizer, offering good performance and many useful ways to perform transfers. In this section we’ll cover some of the essential <code>rsync</code> operation modes and look at some of its peculiarities.</p>
<h3 id="h2-500402c12-0001">12.2.1	 Getting Started with rsync</h3>
<p class="BodyFirst">To get <code>rsync</code> working between two hosts, you must install the <code>rsync</code> program on both the source and destination, and you’ll need a way to access one machine from the other. The easiest way to transfer files is to use a remote shell account, and let’s assume that you want to transfer files using SSH access. However, remember that <code>rsync</code> can be handy even for copying files and directories between locations on a single machine, such as from one filesystem to another. </p>
<p>On the surface, the <code>rsync</code> command is not much different from <code>scp</code>. In fact, you can run <code>rsync</code> with the same arguments. For example, to copy a group of files to your home directory on <em>host</em>, enter:</p>
<pre><code>$ <b>rsync </b><var class="bold">file1</var><b> </b><var class="bold">file2</var><b> ... </b><var class="bold">host</var><b>:</b></code></pre>
<p>On any contemporary system, <code>rsync</code> assumes that you’re using SSH to connect to the remote host.</p>
<p>Beware of this error message: </p>
<pre><code>rsync not found
rsync: connection unexpectedly closed (0 bytes read so far)
rsync error: error in rsync protocol data stream (code 12) at io.c(165)</code></pre>
<p>This notice says that your remote shell can’t find <code>rsync</code> on its system. If <code>rsync</code> is on the remote system but isn’t in the command path for the user on that system, use <code>--rsync-path=</code><var>path</var> to manually specify its location. </p>
<p><span epub:type="pagebreak" title="318" id="Page_318"/>If the username is different on the two hosts, add <var>user@</var> to the remote hostname in the command arguments, where <var>user</var> is your username on <var>host</var>: </p>
<pre><code>$ <b>rsync </b><var class="bold">file1 file2</var><b> ... </b><var class="bold">user</var><b>@</b><var class="bold">host</var><b>:</b></code></pre>
<p>Unless you supply extra options, <code>rsync</code> copies only files. In fact, if you specify just the options described so far and you supply a directory <var>dir</var> as an argument, you’ll see this message: </p>
<pre><code>skipping directory <var>dir</var></code></pre>
<p>To transfer entire directory hierarchies—complete with symbolic links, permissions, modes, and devices—use the <code>-a</code> option. Furthermore, if you want to copy to a directory other than your home directory on the remote host, place its name after the remote host, like this: </p>
<pre><code>$ <b>rsync -a </b><var class="bold">dir</var><b> </b><var class="bold">host</var><b>:</b><var class="bold">dest_dir</var></code></pre>
<p>Copying directories can be tricky, so if you’re not exactly sure what will happen when you transfer the files, use the <code>-nv</code> option combination. The <code>-n</code> option tells <code>rsync</code> to operate in “dry run” mode—that is, to run a trial without actually copying any files. The <code>-v</code> option is for verbose mode, which shows details about the transfer and the files involved: </p>
<pre><code>$ <b>rsync -nva </b><var class="bold">dir</var><b> </b><var class="bold">host</var><b>:</b><var class="bold">dest_dir</var></code></pre>
<p>The output looks like this: </p>
<pre><code>building file list ... done
ml/nftrans/nftrans.html
[more files]
wrote 2183 bytes read 24 bytes 401.27 bytes/sec</code></pre>
<h3 id="h2-500402c12-0002">12.2.2	 Making Exact Copies of a Directory Structure</h3>
<p class="BodyFirst">By default, <code>rsync</code> copies files and directories without considering the previous contents of the destination directory. For example, if you transferred directory <em>d</em> containing the files <em>a</em> and <em>b</em> to a machine that already had a file named <em>d/c</em>, the destination would contain <em>d/a</em>, <em>d/b</em>, and <em>d/c</em> after the <code>rsync</code>. </p>
<p>To make an exact replica of the source directory, you must delete files in the destination directory that do not exist in the source directory, such as <em>d/c</em> in this example. Use the <code>--delete</code> option to do that: </p>
<pre><code>$ <b>rsync -a --delete </b><var class="bold">dir</var><b> </b><var class="bold">host</var><b>:</b><var class="bold">dest_dir</var></code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">WARNING</span></h2>
<p>	This operation can be dangerous, so take the time to inspect the destination directory to see if there’s anything that you’ll inadvertently delete. Remember, if you’re not certain about your transfer, use the <var>-nv</var> option to perform a dry run so that you’ll know exactly when <var>rsync</var> wants to delete a file. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c12-0003"><span epub:type="pagebreak" title="319" id="Page_319"/>12.2.3	 Using the Trailing Slash</h3>
<p class="BodyFirst">Be particularly careful when specifying a directory as the source in an <code>rsync</code> command line. Consider the basic command that we’ve been working with so far: </p>
<pre><code>$ <b>rsync -a </b><var class="bold">dir</var><b> </b><var class="bold">host</var><b>:</b><var class="bold">dest_dir</var></code></pre>
<p>Upon completion, you’ll have the directory <var>dir</var> inside <var>dest_dir</var> on <var>host</var>. <a href="#figure12-1" id="figureanchor12-1">Figure 12-1</a> shows an example of how <code>rsync</code> normally handles a directory with files named <em>a</em> and <em>b</em>.</p>
<figure>
<img src="image_fi/500402c12/f12001.png" alt="f12001"/>
<figcaption><p><a id="figure12-1">Figure 12-1</a>: Normal <var>rsync</var> copy</p></figcaption></figure>
<p>However, adding a slash (<code>/</code>) to the source name significantly changes the behavior: </p>
<pre><code>$ <b>rsync -a </b><var class="bold">dir</var><b>/ </b><var class="bold">host</var><b>:</b><var class="bold">dest_dir</var></code></pre>
<p>Here, <code>rsync</code> copies everything <em>inside</em> <var>dir</var> to <var>dest_dir</var> on <var>host</var> without actually creating <var>dir</var> on the destination host. Therefore, you can think of a transfer of <var>dir/</var> as an operation similar to <code>cp </code><var>dir/* dest_dir</var> on the local filesystem.</p>
<p>For example, say you have a directory <em>dir</em> containing the files <em>a</em> and <em>b</em> (<em>dir/a</em> and <em>dir/b</em>). You run the trailing-slash version of the command to transfer them to the <var>dest_dir</var> directory on <var>host</var>: </p>
<pre><code>$ <b>rsync -a dir/ </b><var class="bold">host</var><b>:</b><var class="bold">dest_dir</var></code></pre>
<p>When the transfer completes, <var>dest_dir</var> contains copies of <em>a</em> and <em>b</em> but <em>not</em> <em>dir</em>. If, however, you had omitted the trailing <code>/ </code>on <em>dir</em>, <var>dest_dir</var> would have gotten a copy of <em>dir</em> with <em>a</em> and <em>b</em> inside. Then, as a result of the transfer, you’d have files and directories named <var>dest_dir</var><em>/dir/a</em> and <var>dest_dir</var><em>/dir/b</em> on the remote host. <a href="#figure12-2" id="figureanchor12-2">Figure 12-2</a> illustrates how <code>rsync</code> handles the directory structure from <a href="#figure12-1">Figure 12-1</a> when using a trailing slash.</p>
<p>When transferring files and directories to a remote host, accidentally adding a <code>/</code> after a path would normally be nothing more than a nuisance; you could go to the remote host, add the <em>dir</em> directory, and put all of the <span epub:type="pagebreak" title="320" id="Page_320"/>transferred items back in <em>dir</em>. Unfortunately, there’s a greater potential for disaster when you combine the trailing <code>/</code> with the <code>--delete</code> option; be extremely careful because you can easily remove unrelated files this way.</p>
<figure>
<img src="image_fi/500402c12/f12002.png" alt="f12002"/>
<figcaption><p><a id="figure12-2">Figure 12-2</a>: Effect of trailing slash in <var>rsync</var></p></figcaption></figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">WARNING</span></h2>
<p>	Because of this potential, be wary of your shell’s automatic filename completion feature. Many shells tack trailing slashes onto completed directory names after you press <span class="KeyCaps">tab</span>. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c12-0004">12.2.4	 Excluding Files and Directories</h3>
<p class="BodyFirst">One important feature of <code>rsync</code> is its ability to exclude files and directories from a transfer operation. For example, say you’d like to transfer a local directory called <em>src</em> to <em>host</em>, but you want to exclude anything named <em>.git</em>. You can do it like this: </p>
<pre><code>$ <b>rsync -a --exclude=.git src </b><var class="bold">host</var><b>:</b></code></pre>
<p>Note that this command excludes <em>all</em> files and directories named <em>.git</em> because <code>--exclude</code> takes a pattern, not an absolute filename. To exclude one specific item, specify an absolute path that starts with <em>/</em>, as shown here: </p>
<pre><code>$ <b>rsync -a --exclude=/src/.git src </b><var class="bold">host</var><b>:</b></code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The first <var>/</var> in <var>/src/.git</var> in this command is <span class="Regular">not</span> the root directory of your system but rather the base directory of the transfer. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>Here are a few more tips on how to exclude patterns: </p>
<ul>
<li>You can have as many <code>--exclude</code> parameters as you like. </li>
<li>If you use the same patterns repeatedly, place them in a plaintext file (one pattern per line) and use <code>--exclude-from=</code><var>file</var>. </li>
<li>To exclude directories named <em>item</em> but include files with this name, use a trailing slash: <code>--exclude=</code><var>item</var><code>/</code>. </li>
<li>The exclude pattern is based on a full file or directory name component and may contain simple globs (wildcards). For example, <code>t*s</code> matches <em>this</em>, but it does not match <em>ethers</em>. </li>
<li>If you exclude a directory or filename but find that your pattern is too restrictive, use <code>--include</code> to specifically include another file or directory. </li>
</ul>
<h3 id="h2-500402c12-0005"><span epub:type="pagebreak" title="321" id="Page_321"/>12.2.5	 Checking Transfers, Adding Safeguards, and Using Verbose Mode</h3>
<p class="BodyFirst">To speed operation, <code>rsync</code> uses a quick check to determine whether any files on the transfer source are already on the destination. The check uses a combination of the file size and its last-modified date. The first time you transfer an entire directory hierarchy to a remote host, <code>rsync</code> sees that none of the files already exist at the destination, and it transfers everything. Testing your transfer with <code>rsync -n</code> verifies this for you. </p>
<p>After running <code>rsync</code> once, run it again using <code>rsync -v</code>. This time you should see that no files show up in the transfer list because the file set exists on both ends, with the same modification dates. </p>
<p>When the files on the source side are not identical to the files on the destination side, <code>rsync</code> transfers the source files and overwrites any files that exist on the remote side. The default behavior may be inadequate, though, because you may need additional reassurance that files are indeed the same before skipping over them in transfers, or you might want to add some extra safeguards. Here are some options that come in handy:</p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">--checksum</code><b> </b>(abbreviation: <code class="bold">-c</code>)</span>  Computes checksums (mostly unique signatures) of the files to see if they’re the same. This option consumes a small amount of I/O and CPU resources during transfers, but if you’re dealing with sensitive data or files that often have uniform sizes, this is a must.</li>
<li><span class="RunInHead"><code class="bold">--ignore-existing</code></span>  Doesn’t clobber files already on the target side. </li>
<li><span class="RunInHead"><code class="bold">--backup</code><b> </b>(abbreviation: <code class="bold">-b</code>)</span>  Doesn’t clobber files already on the target but rather renames these existing files by adding a <code>~</code> suffix to their names before transferring the new files. </li>
<li><span class="RunInHead"><code class="bold">--suffix=s</code></span>  Changes the suffix used with <code>--backup</code> from <code>~</code> to <var>s</var>. </li>
<li><span class="RunInHead"><code class="bold">--update</code><b> </b>(abbreviation: <code class="bold">-u</code>)</span>  Doesn’t clobber any file on the target that has a later date than the corresponding file on the source. </li>
</ol>
<p>With no special options, <code>rsync</code> operates quietly, producing output only when there’s a problem. However, you can use <code>rsync -v</code> for verbose mode or <code>rsync -vv</code> for even more details. (You can tack on as many <code>v</code> options as you like, but two is probably more than you need.) For a comprehensive summary after the transfer, use <code>rsync --stats</code>. </p>
<h3 id="h2-500402c12-0006">12.2.6	 Compressing Data</h3>
<p class="BodyFirst">Many users like the <code>-z</code> option in conjunction with <code>-a</code> to compress the data before transmission: </p>
<pre><code>$ <b>rsync -az </b><var class="bold">dir</var><b> </b><var class="bold">host</var><b>:</b><var class="bold">dest_dir</var></code></pre>
<p>Compression can improve performance in certain situations, such as when you’re uploading a large amount of data across a slow connection (like a slow upstream link) or when the latency between the two hosts is <span epub:type="pagebreak" title="322" id="Page_322"/>high. However, across a fast local area network, the two endpoint machines can be constrained by the CPU time that it takes to compress and decompress data, so uncompressed transfer may be faster.</p>
<h3 id="h2-500402c12-0007">12.2.7	 Limiting Bandwidth</h3>
<p class="BodyFirst">It’s easy to clog the uplink of internet connections when you’re uploading a large amount of data to a remote host. Even though you won’t be using your (normally large) downlink capacity during such a transfer, your connection will still seem quite slow if you let <code>rsync</code> go as fast as it can, because outgoing TCP packets such as HTTP requests will have to compete with your transfers for bandwidth on your uplink. </p>
<p>To get around this, use <code>--bwlimit</code> to give your uplink a little breathing room. For example, to limit the bandwidth to 100,000Kbps, you might do something like this: </p>
<pre><code>$ <b>rsync --bwlimit=100000 -a </b><var class="bold">dir</var><b> </b><var class="bold">host</var><b>:</b><var class="bold">dest_dir</var></code></pre>
<h3 id="h2-500402c12-0008">12.2.8	 Transferring Files to Your Computer</h3>
<p class="BodyFirst">The <code>rsync</code> command isn’t just for copying files from your local machine to a remote host. You can also transfer files from a remote machine to your local host by placing the remote host and remote source path as the first argument on the command line. For example, to transfer <var>src_dir</var> on the remote system to <var>dest_dir</var> on the local host, run this command: </p>
<pre><code>$ <b>rsync -a </b><var class="bold">host</var><b>:</b><var class="bold">src_dir</var><b> </b><var class="bold">dest_dir</var></code></pre>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	As mentioned before, you can use <var>rsync</var> to duplicate directories on your local machine; just omit <code>host:</code> on both arguments. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c12-0009">12.2.9	 Further rsync Topics</h3>
<p class="BodyFirst">Whenever you need to copy numerous files, <code>rsync</code> should be one of the first utilities that comes to mind. Running <code>rsync</code> in batch mode is particularly useful for copying the same set of files to multiple hosts, because it speeds up long transfers and makes it possible to resume when interrupted.</p>
<p>You’ll also find <code>rsync</code> useful for making backups. For example, you can attach internet storage, such as Amazon’s S3, to your Linux system and then use <code>rsync --delete</code> to periodically synchronize a filesystem with the network storage to implement a very effective backup system.</p>
<p>There are many more command-line options than those described here. For a rough overview, run <code>rsync --help</code>. You’ll find more detailed information in the rsync(1) manual page as well as at the <code>rsync</code> home page (<a href="https://rsync.samba.org/" class="LinkURL">https://rsync.samba.org/</a>). </p>
<h2 id="h1-500402c12-0003"><span epub:type="pagebreak" title="323" id="Page_323"/>	12.3	Introduction to File Sharing</h2>
<p class="BodyFirst">Your Linux machine probably doesn’t live alone on your network, and when you have multiple machines on a network, there’s nearly always a reason to share files among them. For the remainder of this chapter, we’ll first look at file sharing between Windows and macOS machines, and you’ll learn more about how Linux adapts to interacting with completely foreign environments. For the purpose of sharing files between Linux machines or accessing files from a Network Area Storage (NAS) device, we’ll wrap up by talking about using SSHFS and the Network File System (NFS) as a client.</p>
<h3 id="h2-500402c12-0010">12.3.1	 File Sharing Usage and Performance</h3>
<p class="BodyFirst">One thing you need to ask yourself when working with any kind of file sharing system is why you’re doing it in the first place. In traditional Unix-based networks, there were two major reasons: convenience and lack of local storage. One user could log in to one of several machines on a network, each with access to the user’s home directory. It was far more economical to concentrate storage on a small number of centralized servers than to buy and maintain a lot of local storage for every machine on the network.</p>
<p>This model’s advantages are overshadowed by one major disadvantage that has remained constant over the years: network storage performance is often poor compared to local storage. Some kinds of data access are okay; for example, contemporary hardware and networks have no problems streaming video and audio data from a server to a media player in part because the data access pattern is very predictable. A server sending the data from a large file or stream can pre-load and buffer the data efficiently, because it knows that the client will likely access data sequentially.</p>
<p>However, if you’re doing more complex manipulation or accessing many different files at once, you’ll find your CPU waiting on the network more often than not. Latency is one of the primary culprits. This is the time it takes to receive data from any random (arbitrary) network file access. Before sending any data to the client, the server must accept and decipher the request, and then locate and load the data. The first steps are often the slowest, and are done for almost every new file access.</p>
<p>The moral of the story is that when you start thinking about network file sharing, ask yourself why you’re doing it. If it’s for large amounts of data not requiring frequent random access, you likely won’t have a problem. But if, for example, you’re editing video or developing a software system of any substantial size, you’ll want to keep all of your files on local storage.</p>
<h3 id="h2-500402c12-0011">12.3.2	 File Sharing Security</h3>
<p class="BodyFirst">Traditionally, security in file sharing protocols has not been treated as a high priority. This has consequences for how and where you want to implement file sharing. If you have any reason to doubt the security of the network(s) <span epub:type="pagebreak" title="324" id="Page_324"/>between the machines sharing files, you’ll want to consider both authorization/authentication and encryption in your configuration. Good authorization and authentication means that only parties with the correct credentials have access to files (and that the server is who it claims to be), and encryption ensures that no one will be able steal file data as it transits to its destination.</p>
<p>The file sharing options that are the easiest to configure are typically the least secure, and unfortunately, there are no standardized ways to secure these types of access. However, if you’re willing to put in the work of connecting the correct pieces, tools such as stunnel, IPSec, and VPNs can secure the layers below basic file sharing protocols.</p>
<h2 id="h1-500402c12-0004">	12.4	Sharing Files with Samba</h2>
<p class="BodyFirst">If you have machines running Windows, you’ll probably want to permit access to your Linux system’s files and printers from those Windows machines using the standard Windows network protocol, <em>Server Message Block (SMB)</em>. macOS supports SMB file sharing too, but you can also use SSHFS, described in <span class="xref" itemid="xref_target_Section 12.5">Section 12.5</span>. </p>
<p>The standard file sharing software suite for Unix is called <em>Samba</em>. Not only does Samba allow your network’s Windows computers to get to your Linux system, but it also works the other way around: you can print and access files on Windows servers from your Linux machine via its Samba client software.</p>
<p>To set up a Samba server, do the following: </p>
<ol class="decimal">
<li value="1">Create an <em>smb.conf</em> file.</li>
<li value="2">Add file sharing sections to <em>smb.conf</em>.</li>
<li value="3">Add printer sharing sections to <em>smb.conf</em>.</li>
<li value="4">Start the Samba daemons <code>nmbd</code> and <code>smbd</code>.</li>
</ol>
<p>When you install Samba from a distribution package, your system should perform these steps using some reasonable defaults for the server. However, it probably won’t be able to determine which particular <em>shares</em> (resources) on your Linux machine you want to offer to clients.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	The discussion of Samba in this chapter is not intended to be comprehensive; it’s limited to getting Windows machines on a single subnet to see a standalone Linux machine through the Windows Network Places browser. There are countless ways to configure Samba, because there are many possibilities for access control and network topology. For the gory details on how to configure a large-scale server, see <span class="Regular">Using Samba</span>, 3rd edition, by Gerald Carter, Jay Ts, and Robert Eckstein (O’Reilly, 2007), which is a much more extensive guide, and visit the Samba website (<a href="https://samba.org/" class="LinkURL">https://samba.org/</a>). </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c12-0012">12.4.1	 Server Configuration</h3>
<p class="BodyFirst">The central Samba configuration file is <em>smb.conf</em>, which most distributions place in an <em>etc</em> directory, such as <em>/etc/samba</em>. However, you might have to hunt around to find this file, as it could also be in a <em>lib</em> directory, such as <em>/usr/local/samba/lib</em>. </p>
<p><span epub:type="pagebreak" title="325" id="Page_325"/>The <em>smb.conf</em> file format is similar to the XDG style that you’ve seen elsewhere (such as the systemd configuration format) and breaks down into several sections denoted with square brackets such as <code>[global]</code> and <code>[printers]</code>. The <code>[global]</code> section in <em>smb.conf</em> contains general options that apply to the entire server and all shares. These options primarily pertain to network configuration and access control. This sample <code>[global]</code> section shows how to set the server name, description, and workgroup: </p>
<pre><code>[global]
# server name
netbios name = <var>name</var>
# server description
server string = My server via Samba
# workgroup
workgroup = MYNETWORK</code></pre>
<p>These parameters work as follows: </p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">netbios name</code></span>  The server name. If you omit this parameter, Samba uses the Unix hostname. NetBIOS is an API that SMB hosts often employ to talk to one another.</li>
<li><span class="RunInHead"><code class="bold">server string</code></span>  A short description of the server. The default is the Samba version number. </li>
<li><span class="RunInHead"><code class="bold">workgroup</code></span>  The Windows workgroup name. If you’re on a Windows domain, set this parameter to the name of your domain. </li>
</ol>
<h3 id="h2-500402c12-0013">12.4.2	 Server Access Control</h3>
<p class="BodyFirst">You can add options to your <em>smb.conf</em> file to limit which machines and users can access your Samba server. Here are a few of the many options that you can set in your <code>[global]</code> section and in the sections that control individual shares (as described later in the chapter):</p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">interfaces</code></span>  Set this to have Samba listen (accept connections) on the given networks or interfaces. For example: 
<pre><code>interfaces = 10.23.2.0/255.255.255.0
interfaces = enp0s31f6</code></pre>
</li>
<li><span class="RunInHead"><code class="bold">bind interfaces only</code></span>  Set this to <code>yes</code> when using the <code>interfaces</code> parameter in order to limit access to only the machines that you can directly reach on those interfaces. </li>
<li><span class="RunInHead"><code class="bold">valid users</code></span>  Set this to allow the given users access. For example: 
<pre><code>valid users = jruser, bill</code></pre>
</li>
<li><span class="RunInHead"><code class="bold">guest ok</code></span>  Set this parameter to <code>true</code> to make a share available to anonymous users on the network. Do this only if you’re sure that the network is private.</li>
<li><span epub:type="pagebreak" title="326" id="Page_326"/><span class="RunInHead"><code class="bold">browseable</code></span>  Set this to make shares viewable by network browsers. If you set this parameter to <code>no</code> for any shares, you’ll still be able to access the shares on the Samba server, but you’ll need to know their exact names in order to be able to access them. </li>
</ol>
<h3 id="h2-500402c12-0014">12.4.3	 Passwords</h3>
<p class="BodyFirst">In general, you should allow access to your Samba server only with password authentication. Unfortunately, the basic password system on Unix is different from that on Windows, so unless you specify cleartext network passwords or authenticate passwords with a Windows domain server, you must set up an alternative password system. This section shows you how to set up an alternative password system using Samba’s <em>Trivial Database (TDB)</em> backend, which is appropriate for small networks.</p>
<p>First, use these entries in your <em>smb.conf</em> <code>[global]</code> section to define the Samba password database characteristics: </p>
<pre><code># use the tdb for Samba to enable encrypted passwords
security = user
passdb backend = tdbsam
obey pam restrictions = yes
smb passwd file = /etc/samba/passwd_smb</code></pre>
<p>These lines allow you to manipulate the Samba password database with the <code>smbpasswd</code> command. The <code>obey pam restrictions</code> parameter ensures that any user changing their password with the <code>smbpasswd</code> command must obey any rules that PAM (Pluggable Authentication Modules, covered in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>) enforces for normal password changes. For the <code>passdb backend</code> parameter, you can optionally specify a pathname for the TDB file after a colon—for example, <code>tdbsam:/etc/samba/private/passwd.tdb</code>.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If you have access to a Windows domain, you can set <var>security = domain</var> to make Samba use the domain’s authentication system and eliminate the need for a password database. However, in order for domain users to access the machine running Samba, each domain user must have a local account with the same username on that machine.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-500402c12-0001">Adding and Deleting Users</h4>
<p class="BodyFirst">The first thing you need to do to give a Windows user access to your Samba server is to add the user to the password database with the <code>smbpasswd -a</code> command: </p>
<pre><code># <b>smbpasswd -a </b><var class="bold">username</var></code></pre>
<p>The <var>username</var> parameter to the <code>smbpasswd</code> command must be a valid username on your Linux system. </p>
<p><span epub:type="pagebreak" title="327" id="Page_327"/>Like the regular system’s <code>passwd</code> program, <code>smbpasswd</code> asks you to enter the new SMB user’s password twice. After the password passes any necessary security checks, <code>smbpasswd</code> confirms that it has created the new user. </p>
<p>To remove a user, use the <code>-x</code> option to <code>smbpasswd</code>: </p>
<pre><code># <b>smbpasswd -x </b><var class="bold">username</var></code></pre>
<p>To just temporarily deactivate the user, use the <code>-d</code> option; the <code>-e</code> option can be used later to reenable the user: </p>
<pre><code># <b>smbpasswd -d</b><code> </code><var class="bold">username</var>
# <b>smbpasswd -e</b><code> </code><var class="bold">username</var></code></pre>
<h4 id="h3-500402c12-0002">Changing Passwords</h4>
<p class="BodyFirst">You can change a Samba password as the superuser by using <code>smbpasswd</code> with no options or keywords other than the username: </p>
<pre><code># <b>smbpasswd </b><var class="bold">username</var></code></pre>
<p>However, if the Samba server is running, any user can change their own Samba password by entering <code>smbpasswd</code> by itself on the command line.</p>
<p>Finally, here’s one place in your configuration to beware of. If you see a line like this in your <em>smb.conf</em> file, be careful:</p>
<pre><code>unix password sync = yes</code></pre>
<p>This line causes <code>smbpasswd</code> to change a user’s normal password <em>in addition</em> to the Samba password. The result can be very confusing, especially when a user changes their Samba password to something that’s not their Linux password and discovers that they can no longer log in to their Linux system. Some distributions set this parameter by default in their Samba server packages!</p>
<h3 id="h2-500402c12-0015">12.4.4	 Manual Server Startup</h3>
<p class="BodyFirst">Typically, you shouldn’t need to worry about starting the server if you installed Samba from a distribution package. Check the list from <code>systemctl --type=service</code> to verify. However, if you installed it from source code, run <code>nmbd</code> and <code>smbd</code> with the following arguments, where <var>smb_config_file</var> is the full path of your <em>smb.conf</em> file: </p>
<pre><code># <b>nmbd -D -s </b><var class="bold">smb_config_file</var>
# <b>smbd -D -s </b><var class="bold">smb_config_file</var></code></pre>
<p>The <code>nmbd</code> daemon is a NetBIOS name server, and <code>smbd</code> does the actual work of handling share requests. The <code>-D</code> option specifies daemon mode. If you alter the <em>smb.conf</em> file while <code>smbd</code> is running, you can notify the daemon <span epub:type="pagebreak" title="328" id="Page_328"/>of the changes with a HUP signal, though it’s almost always for the better if you let systemd supervise the server, in which case you can get <code>systemctl</code> to do the work for you. </p>
<h3 id="h2-500402c12-0016">12.4.5	 Diagnostics and Logfiles</h3>
<p class="BodyFirst">If something goes wrong when a Samba server starts up, an error message appears on the command line. However, runtime diagnostic messages go to the <em>log.nmbd</em> and <em>log.smbd</em> logfiles, which are usually in a <em>/var/log</em> directory, such as <em>/var/log/samba</em>. You’ll also find other logfiles there, such as individual logs for each individual client.</p>
<h3 id="h2-500402c12-0017">12.4.6	 File Share Configuration</h3>
<p class="BodyFirst">To export a directory to SMB clients (that is, to share a directory with a client), add a section like this to your <em>smb.conf</em> file, where <var>label</var> is what you would like to call the share (such as <code>mydocuments</code>) and <var>path</var> is the full directory path: </p>
<pre><code>[<var>label</var>]
path = <var>path</var>
comment = <var>share description</var>
guest ok = no
writable = yes
printable = no</code></pre>
<p>These parameters are useful in directory shares: </p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">guest ok</code></span>  A <code>yes</code> setting here allows guest access to the share. The <code>public</code> parameter is a synonym. </li>
<li><span class="RunInHead"><code class="bold">writable</code></span>  A <code>yes</code> or <code>true</code> setting here marks the share as read-write. Do not allow guest access to a read-write share. </li>
<li><span class="RunInHead"><code class="bold">printable</code></span>  Obviously, on a directory share, this parameter must be set to <code>no</code> or <code>false</code>. </li>
<li><span class="RunInHead"><code class="bold">veto files</code></span>  This parameter prevents the export of any files that match the given patterns. You must enclose each pattern between forward slashes (so that it looks like <var>/pattern/</var>). This example bars object files, as well as any file or directory named <em>bin</em>:
<pre><code>veto files = /*.o/bin/</code></pre>
</li>
</ol>
<h3 id="h2-500402c12-0018">12.4.7	 Home Directories</h3>
<p class="BodyFirst">You can add a section called <code>[homes]</code> to your <em>smb.conf</em> file if you want to export home directories to users. The section should look like this: </p>
<pre><code>[homes]
comment = home directories
<span epub:type="pagebreak" title="329" id="Page_329"/>browseable = no
writable = yes</code></pre>
<p>By default, Samba reads the logged-in user’s <em>/etc/passwd</em> entry to determine their home directory for <code>[homes]</code>. However, if you don’t want Samba to follow this behavior (that is, you want to keep the Windows home directories in a different place than the regular Linux home directories), you can use the <code>%S</code> substitution in a <code>path</code> parameter. For example, here’s how you would switch a user’s <code>[homes]</code> directory to <em>/u/user</em>: </p>
<pre><code>path = /u/%S</code></pre>
<p>Samba substitutes the current username for the <code>%S</code>. </p>
<h3 id="h2-500402c12-0019">12.4.8	 Printer Sharing</h3>
<p class="BodyFirst">You can export your printers to Windows clients by adding a <code>[printers]</code> section to your <em>smb.conf</em> file. Here’s how the section looks when you’re using CUPS, the standard Unix printing system: </p>
<pre><code>[printers]
comment = Printers
browseable = yes
printing = CUPS
path = cups
printable = yes
writable = no</code></pre>
<p>To use the <code>printing = CUPS</code> parameter, your Samba installation must be configured and linked against the CUPS library. </p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	Depending on your configuration, you may also want to allow guest access to your printers with the <var>guest ok = yes</var> option rather than give a Samba password or account to everyone who needs to access the printers. For example, it’s easy to limit printer access to a single subnet with firewall rules.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h3 id="h2-500402c12-0020">12.4.9	 The Samba Client</h3>
<p class="BodyFirst">The Samba client program <code>smbclient</code> can print to and access remote Windows shares. This program comes in handy when you’re in an environment where you must interact with Windows servers that don’t offer a Unix-friendly means of communication. </p>
<p>To get started with <code>smbclient</code>, use the <code>-L</code> option to get a list of shares from a remote server named <var>SERVER</var>: </p>
<pre><code>$ <b>smbclient -L -U </b><var class="bold">username SERVER</var></code></pre>
<p>You don’t need <code>-U</code> <var>username</var> if your Linux username is the same as your username on <var>SERVER</var>. </p>
<p><span epub:type="pagebreak" title="330" id="Page_330"/>After you run this command, <code>smbclient</code> asks for a password. To try to access a share as a guest, press <span class="KeyCaps">enter</span>; otherwise, enter your password on <var>SERVER</var>. Upon success, you should get a share list like this:</p>
<pre><code>Sharename   Type        Comment
---------   ----        -------
Software    Disk        Software distribution
Scratch     Disk        Scratch space
IPC$        IPC         IPC Service
ADMIN$      IPC         IPC Service
Printer1    Printer     Printer in room 231A
Printer2    Printer     Printer in basement</code></pre>
<p>Use the <code>Type</code> field to help you make sense of each share, and pay attention only to the <code>Disk</code> and <code>Printer</code> shares (the <code>IPC</code> shares are for remote management). This list has two disk shares and two printer shares. Use the name in the <code>Sharename</code> column to access each share. </p>
<h4 id="h3-500402c12-0003">Accessing Files as a Client</h4>
<p class="BodyFirst">If you need only casual access to files in a disk share, use the following command (again, you can omit the <code>-U</code> <var>username</var> if your Linux username matches your username on the server): </p>
<pre><code>$ <b>smbclient -U </b><var class="bold">username</var><b> '\\</b><var class="bold">SERVER</var><b>\</b><var class="bold">sharename</var><b>'</b></code></pre>
<p>Upon success, you will get a prompt like this, indicating that you can now transfer files: </p>
<pre><code>smb: \&gt;</code></pre>
<p>In this file transfer mode, <code>smbclient</code> is similar to the Unix <code>ftp</code>, and you can run these commands: </p>
<ol class="none">
<li><span class="RunInHead"><code class="bold">get </code><var class="bold">file</var></span>  Copies <var>file</var> from the remote server to the current local directory. </li>
<li><span class="RunInHead"><code class="bold">put </code><var class="bold">file</var></span>  Copies <var>file</var> from the local machine to the remote server. </li>
<li><span class="RunInHead"><code class="bold">cd </code><var class="bold">dir</var></span>  Changes the directory on the remote server to <var>dir</var>. </li>
<li><span class="RunInHead"><code class="bold">lcd </code><var class="bold">localdir</var></span>  Changes the current local directory to <var>localdir</var>. </li>
<li><span class="RunInHead"><code class="bold">pwd</code></span>  Prints the current directory on the remote server, including the server and share names. </li>
<li><span class="RunInHead"><code class="bold">!</code><var class="bold">command</var></span>  Runs <var>command</var> on the local host. Two particularly handy commands are <code>!pwd</code> and <code>!ls</code> to determine directory and file status on the local side. </li>
<li><span class="RunInHead"><code class="bold">help</code></span>  Shows a full list of commands. </li>
</ol>
<h4 id="h3-500402c12-0004"><span epub:type="pagebreak" title="331" id="Page_331"/>Using the CIFS Filesystem</h4>
<p class="BodyFirst">If you’d like to have more convenient access to files on a Windows server, you can attach a share directly to your system with <code>mount</code>. The command syntax is as follows (notice the use of <var>SERVER</var><code>:</code><var>sharename</var> rather than the normal <code>\\</code><var>SERVER</var><code>\</code><var>sharename</var> format): </p>
<pre><code># <b>mount -t cifs </b><var class="bold">SERVER</var><b>:</b><var class="bold">sharename</var><b> </b><var class="bold">mountpoint</var><b> -o user=</b><var class="bold">username</var><b>,pass=</b><var class="bold">password</var></code></pre>
<p>In order to use <code>mount</code> like this, you must have the Common Internet File System (CIFS) utilities installed on your system. Most distributions offer these as a separate package. </p>
<h2 id="h1-500402c12-0005">	12.5	SSHFS</h2>
<p class="BodyFirst">With Windows file sharing systems out of the way, in this section we’ll discuss file sharing between Linux systems. For scenarios that aren’t particularly complicated, a convenient option to consider is SSHFS. This is nothing more than a user-space filesystem that opens an SSH connection and presents the files on the other side at a mount point on your machine. Most distributions don’t install it by default, so you might need to install your distribution’s SSHFS package.</p>
<p>The syntax for using SSHFS on the command line looks superficially similar to SSH commands that you’ve seen before. Of course, you need to supply the shared directory (on the remote host) and the desired mount point:</p>
<pre><code>$ <b>sshfs</b> <var class="bold">username</var><b>@</b><var class="bold">host</var><b>:</b><var class="bold">dir</var> <var class="bold">mountpoint</var></code></pre>
<p>Just like in SSH, you can drop the <var>username</var><code>@</code> if the username is the same on the remote host, and you can also omit <code>:</code><var>dir</var> if you just want to mount the home directory on the other side. This command asks for the password on the other side if necessary.</p>
<p>Because this is a user-space filesystem, you have to unmount it with <code>fusermount</code> if you’re running this as a regular user:</p>
<pre><code>$ <b>fusermount -u </b><var class="bold">mountpoint</var></code></pre>
<p>The superuser can also unmount these filesystems with <code>umount</code>. To ensure consistency of ownership and security, this type of filesystem is usually best mounted as a regular user.</p>
<p>SSHFS has these advantages:</p>
<ul>
<li>It has minimal setup. The only requirement on the remote host is that SFTP is enabled, and most SSH servers enable it by default.</li>
<li>It’s not dependent on any kind of specific network configuration. If you can open an SSH connection, SSHFS will work, regardless if it’s on a secure local network or over an insecure remote network.</li>
</ul>
<p><span epub:type="pagebreak" title="332" id="Page_332"/>The disadvantages of SSHFS are:</p>
<ul>
<li>Performance suffers. There is a lot of overhead in encryption, translation, and transport (but it may not be as bad as you expect).</li>
<li>Multiuser setups are limited.</li>
</ul>
<p>It’s definitely worth trying SSHFS if you think it might work for you, because it’s so easy to set up.</p>
<h2 id="h1-500402c12-0006">	12.6	NFS</h2>
<p class="BodyFirst">One of the most commonly used traditional systems for file sharing among Unix systems is NFS, and there are many different versions of NFS for different scenarios. You can serve NFS over TCP and UDP, with a large number of authentication and encryption options (very few of which are enabled by default, unfortunately). Because there are so many options, NFS can be a big topic, so we’ll just stick to the bare minimum of coverage.</p>
<p>To mount a remote directory on a server with NFS, use the same basic syntax as for mounting a CIFS directory:</p>
<pre><code># <b>mount -t nfs </b><var class="bold">server</var><b>:</b><var class="bold">directory</var><b> </b><var class="bold">mountpoint</var></code></pre>
<p>Technically, you don’t need the <code>-t nfs</code> option because <code>mount</code> should figure this out for you, but you may want to investigate the options in the nfs(5) manual page. You’ll find several different options for security using the <code>sec</code> option. Many administrators on small, closed networks use host-based access control. More sophisticated methods, such as Kerberos-based authentication, require additional configuration on other parts of your system.</p>
<p>When you find that you’re making greater use of filesystems over a network, set up the automounter so that your system will mount the filesystems only when you actually try to use them in order to prevent problems with dependencies on boot. The traditional automounting tool was called automount, and there’s a newer version called amd, but much of this functionality has now been supplanted by the automount unit type in systemd.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="box">
<h2>NFS Servers</h2>
<p class="BoxBodyFirst">Setting up an NFS server to share files to other Linux machines is more complicated than configuring the client side. You need to run the server daemons (<code>mountd</code> and <code>nfsd</code>) and set up the <em>/etc/exports</em> file to reflect the directories that you’re sharing. However, we won’t cover NFS servers, primarily because it’s often much more convenient to share storage over a network by simply purchasing an NAS device to handle it for you. Many of these devices are Linux based, <span epub:type="pagebreak" title="333" id="Page_333"/>so they’ll naturally have NFS server support. Vendors add value to their NAS devices by offering their own administration tools to take the pain out of tedious tasks such as setting up RAID configurations and cloud backups.</p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h2 id="h1-500402c12-0007">	12.7	Cloud Storage</h2>
<p class="BodyFirst">Speaking of cloud backups, another network file storage option is cloud storage, such as AWS S3 or Google Cloud Storage. These systems don’t have the performance of storage on a local network, but they do offer two significant advantages: you never have to maintain them, and you shouldn’t have to worry about backups.</p>
<p>Aside from the web (and programmatic) interfaces that all cloud storage providers offer, there are ways to mount most kinds of cloud storage on a Linux system. Unlike most of the filesystems that we’ve seen so far, these are nearly all implemented as FUSE (File System in User Space) interfaces. For some popular cloud storage providers such as S3, there are even multiple options. This makes sense, because a FUSE handler is nothing more than a user-space daemon that acts as an intermediary between the data source and the kernel.</p>
<p>This book doesn’t cover the specifics of setting up a cloud storage client, because every one is different.</p>
<h2 id="h1-500402c12-0008">	12.8	The State of Network File Sharing</h2>
<p class="BodyFirst">At this point, you might feel that this discussion of the NFS and file sharing in general seems somewhat incomplete—and it might be, but only as much as the file sharing systems themselves. We discussed performance and security concerns in Sections <span class="xref" itemid="xref_target_12.3.1">12.3.1</span> and <span class="xref" itemid="xref_target_12.3.2">12.3.2</span>. In particular, the base security level of NFS is quite low, requiring significant extra work to improve. CIFS systems are somewhat better in this regard, as the necessary encryption layers are built into contemporary software. However, performance limitations aren’t easy to overcome, not to mention how badly a system can perform when it is temporarily unable to access its network storage.</p>
<p>There have been several attempts to deal with this issue. Perhaps the most extensive is the Andrew File System (AFS), first designed in the 1980s, which was built around solutions to these problems. So why doesn’t everyone use AFS or something like it?</p>
<p>There is no one answer to this question, but much of it comes down to a certain lack of flexibility in some parts of the design. For example, the security mechanism requires a Kerberos authentication system. Though universally available, it has never been standard on Unix systems, and requires a nontrivial amount of work to set up and maintain (you have to set up a server for it).</p>
<p><span epub:type="pagebreak" title="334" id="Page_334"/>For a large institution, fulfilling requirements such as Kerberos isn’t a problem. This is exactly the setting in which AFS has thrived; universities and financial institutions are big AFS sites. But for the small user, it’s simply easier not to do it, preferring  simpler options like NFS or CIFS shares. This sort of limitation even extends to Windows; starting with Windows 2000, Microsoft switched to Kerberos as the default authentication on its server product, but small networks don’t tend to be Windows domains with this kind of server.</p>
<p>Aside from the authentication prerequisite, there’s a problem that stems from more technical reasons. Many network filesystem clients have traditionally been kernel code, NFS in particular. Unfortunately, the requirements of network filesystems are complex enough that problems start to occur. The authentication alone has no place in the kernel. A kernel client implementation also severely limits the potential developer base for a network filesystem, hampering the system as a whole. In some cases, client code was in user space, but there was always some sort of kernel customization underneath.</p>
<p>At the moment, we find ourselves without a truly standard means of network file sharing in the Linux/Unix world (at least if you’re not a large site or you aren’t willing to put in a fair amount of work). However, this won’t necessarily always be the case.</p>
<p>When providers started to offer cloud storage, it was clear that the traditional forms of network file sharing wouldn’t be suitable. In the cloud, access methods are built on top of security mechanisms such as TLS that make it possible to access storage without setting up a large system such as Kerberos. As mentioned in the preceding section, there are many options available via FUSE to access cloud storage. We’re no longer dependent on the kernel for any part of the client; any kind of authentication, encryption, or handling can easily be done in user space.</p>
<p>All of this means that the future could very well see some file-sharing designs incorporating more flexibility in security and other areas such as filename translation.</p>
</section>
</body></html>