<html><head></head><body><div id="sbo-rt-content"><h2 class="h2a" id="ch03"><span epub:type="pagebreak" id="page_57"/><span class="big">3</span><br/>THE PE FORMAT: A BRIEF INTRODUCTION</h2>&#13;
<p class="startpara">Now that you know all about the ELF format, let’s take a brief look at another popular binary format: the Portable Executable (PE) format. Because PE is the main binary format used on Windows, being familiar with PE is useful for analyzing the Windows binaries common in malware analysis.</p>&#13;
<p class="indent">PE is a modified version of the Common Object File Format (COFF), which was also used on Unix-based systems before being replaced by ELF. For this historic reason, PE is sometimes also referred to as PE/COFF. Confusingly, the 64-bit version of PE is called PE32+. Because PE32+ has only minor differences compared to the original PE format, I’ll simply refer to it as “PE.”</p>&#13;
<p class="indent">In the following overview of the PE format, I’ll highlight its main differences from ELF in case you want to work on the Windows platform. I won’t go into quite as much detail as I did with ELF since PE isn’t the main focus in this book. That said, PE (along with most other binary formats) shares many similarities with ELF. Now that you’re up to speed on ELF, you’ll notice it’s much easier to learn about new binary formats!</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_58"/>I’ll center the discussion around <a href="ch03.xhtml#ch03fig1">Figure 3-1</a>. The data structures shown in the figure are defined in <em>WinNT.h</em>, which is included in the Microsoft Windows Software Developer Kit.</p>&#13;
<h3 class="h3" id="ch03_1">3.1 The MS-DOS Header and MS-DOS Stub</h3>&#13;
<p class="noindent">Looking at <a href="ch03.xhtml#ch03fig1">Figure 3-1</a>, you’ll see a lot of similarities to the ELF format, as well as a few crucial differences. One of the main differences is the presence of an MS-DOS header. That’s right, MS-DOS, the old Microsoft operating system from 1981! What’s Microsoft’s excuse for including this in a supposedly modern binary format? As you may have guessed, the reason is backward compatibility.</p>&#13;
<p class="indent">When PE was introduced, there was a transitional period when users used both old-fashioned MS-DOS binaries and the newer PE binaries. To make the transition less confusing, every PE file starts with an MS-DOS header so that it can also be interpreted as an MS-DOS binary, at least in a limited sense. The main function of the MS-DOS header is to describe how to load and execute an <em>MS-DOS stub</em>, which comes right after the MSDOS header. This stub is usually just a small MS-DOS program, which is run instead of the main program when the user executes a PE binary in MSDOS. The MS-DOS stub program typically prints a string like “This program cannot be run in DOS mode” and then exits. However, in principle, it can be a full-fledged MS-DOS version of the program!</p>&#13;
<p class="indent">The MS-DOS header starts with a magic value, which consists of the ASCII characters “MZ.”<sup><a id="ch03fn_1a" href="footnote.xhtml#ch03fn_1">1</a></sup> For this reason, it’s also sometimes referred to as an <em>MZ header</em>. For the purposes of this chapter, the only other important field in the MS-DOS header is the last field, called <span class="literal">e_lfanew</span>. This field contains the file offset at which the <em>real</em> PE binary begins. Thus, when a PE-aware program loader opens the binary, it can read the MS-DOS header and then skip past it and the MS-DOS stub to go right to the start of the PE headers.</p>&#13;
<h3 class="h3" id="ch03_2">3.2 The PE Signature, File Header, and Optional Header</h3>&#13;
<p class="noindent">You can consider the PE headers analogous to ELF’s executable header, except that in PE, the “executable header” is split into three parts: a 32-bit signature, a <em>PE file header</em>, and a <em>PE optional header</em>. If you take a look in <em>WinNT.h</em>, you can see that there’s a <span class="literal">struct</span> called <span class="literal">IMAGE_NT_HEADERS64</span>, which encompasses all three of these parts. You could say that <span class="literal">struct IMAGE_NT_HEADERS64</span> as a whole is PE’s version of the executable header. However, in practice, the signature, file header, and optional header are considered separate entities.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_59"/><a id="ch03fig1"/><img src="Images/f059-01.jpg" alt="image" width="693" height="1111"/></div>&#13;
<p class="fig-caption"><em>Figure 3-1: A PE32+ binary at a glance</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_60"/>In the next few sections, I’ll discuss each of these header components. To see all the header elements in action, let’s look at <em>hello.exe</em>, a PE version of the <span class="literal">compilation_example</span> program from <a href="ch01.xhtml#ch01">Chapter 1</a>. <a href="ch03.xhtml#ch03list1">Listing 3-1</a> shows a dump of the most important header elements and the <span class="literal">DataDirectory</span> of <em>hello.exe</em>. I’ll explain what the <span class="literal">DataDirectory</span> is in a moment.</p>&#13;
<p class="listing1" id="ch03list1"><em>Listing 3-1: Example dump of PE headers and</em> <span class="codeitalic">DataDirectory</span></p>&#13;
<p class="programs">   $ <span class="codestrong1">objdump -x hello.exe</span><br/><br/>   hello.exe:    <span class="ent">➊</span>file format pei-x86-64<br/>   hello.exe<br/>   architecture: i386:x86-64, flags 0x0000012f:<br/>   HAS_RELOC, EXEC_P, HAS_LINENO, HAS_DEBUG, HAS_LOCALS, D_PAGED<br/>   start address 0x0000000140001324<br/><br/><span class="ent">➋</span> Characteristics 0x22<br/>           executable<br/>           large address aware<br/><br/><br/>   Time/Date               Thu Mar 30 14:27:09 2017<br/><span class="ent">➌</span> Magic                   020b     (PE32+)<br/>   MajorLinkerVersion      14<br/>   MinorLinkerVersion      10<br/>   SizeOfCode              00000e00<br/>   SizeOfInitializedData   00001c00<br/>   SizeOfUninitializedData 00000000<br/><span class="ent">➍</span> AddressOfEntryPoint     0000000000001324<br/><span class="ent">➎</span> BaseOfCode              0000000000001000<br/><span class="ent">➏</span> ImageBase               0000000140000000<br/>   SectionAlignment        0000000000001000<br/>   FileAlignment           0000000000000200<br/>   MajorOSystemVersion     6<br/>   MinorOSystemVersion     0<br/>   MajorImageVersion       0<br/>   MinorImageVersion       0<br/>   MajorSubsystemVersion   6<br/>   MinorSubsystemVersion   0<br/>   Win32Version            00000000<br/>   SizeOfImage             00007000<br/>   SizeOfHeaders           00000400<br/>   CheckSum                00000000<br/>   Subsystem               00000003     (Windows CUI)<br/>   DllCharacteristics      00008160<br/>   SizeOfStackReserve      0000000000100000<br/>   SizeOfStackCommit       0000000000001000<br/>   SizeOfHeapReserve       0000000000100000<br/>   SizeOfHeapCommit        0000000000001000<br/>   LoaderFlags             00000000<br/>   NumberOfRvaAndSizes     00000010<br/><br/><span class="ent">➐</span> The Data Directory<br/>   Entry 0 0000000000000000 00000000 Export Directory [.edata]<br/>   Entry 1 0000000000002724 000000a0 Import Directory [parts of .idata]<br/>   Entry 2 0000000000005000 000001e0 Resource Directory [.rsrc]<br/>   Entry 3 0000000000004000 00000168 Exception Directory [.pdata]<br/>   Entry 4 0000000000000000 00000000 Security Directory<br/>   Entry 5 0000000000006000 0000001c Base Relocation Directory [.reloc]<br/>   Entry 6 0000000000002220 00000070 Debug Directory<br/>   Entry 7 0000000000000000 00000000 Description Directory<br/>   Entry 8 0000000000000000 00000000 Special Directory<br/>   Entry 9 0000000000000000 00000000 Thread Storage Directory [.tls]<br/>   Entry a 0000000000002290 000000a0 Load Configuration Directory<br/>   Entry b 0000000000000000 00000000 Bound Import Directory<br/>   Entry c 0000000000002000 00000188 Import Address Table Directory<br/>   Entry d 0000000000000000 00000000 Delay Import Directory<br/>   Entry e 0000000000000000 00000000 CLR Runtime Header<br/>   Entry f 0000000000000000 00000000 Reserved<br/><br/>   ...</p>&#13;
<h4 class="h4" id="ch03_2_1"><em>3.2.1 The PE Signature</em></h4>&#13;
<p class="noindent">The PE signature is simply a string containing the ASCII characters “PE,” followed by two <span class="literal">NULL</span> characters. It’s analogous to the magic bytes in the <span class="literal">e_ident</span> field in ELF’s executable header.</p>&#13;
<h4 class="h4" id="ch03_2_2"><em>3.2.2 The PE File Header</em></h4>&#13;
<p class="noindent">The file header describes general properties of the file. The most important fields are <span class="literal">Machine</span>, <span class="literal">NumberOfSections</span>, <span class="literal">SizeOfOptionalHeader</span>, and <span class="literal">Characteristics</span>. The two fields describing the symbol table are deprecated, and PE files should no longer make use of embedded symbols and debugging information. Instead, these symbols are optionally emitted as part of a separate debugging file.</p>&#13;
<p class="indent">As in ELF’s <span class="literal">e_machine</span>, the <span class="literal">Machine</span> field describes the architecture of the machine for which the PE file is intended. In this case, this is x86-64 (defined as the constant <span class="literal">0x8664</span>) <span class="ent">➊</span>. The <span class="literal">NumberOfSections</span> field is simply the number of entries in the section header table, and <span class="literal">SizeOfOptionalHeader</span> is the size in bytes of the optional header that follows the file header. The <span class="literal">Characteristics</span> field contains flags describing things such as the endianness of the binary, whether it’s a DLL, and whether it has been stripped. As shown in the <span class="literal">objdump</span> output, the example binary contains <span class="literal">Characteristics</span> flags that mark it as a large-address-aware executable file <span class="ent">➋</span>.</p>&#13;
<h4 class="h4" id="ch03_2_3"><span epub:type="pagebreak" id="page_61"/><em>3.2.3 The PE Optional Header</em></h4>&#13;
<p class="noindent">Despite what the name suggests, the PE optional header is not really optional for executables (though it may be missing in object files). In fact, you’ll likely find the PE optional header in any PE executable you’ll encounter. It contains lots of fields, and I’ll go over the most important ones here.</p>&#13;
<p class="indent">First, there’s a 16-bit magic value, which is set to <span class="literal">0x020b</span> for 64-bit PE files <span class="ent">➌</span>. There are also several fields describing the major and minor version numbers of the linker that was used to create the binary, as well as the minimal operating system version needed to run the binary. The <span class="literal">ImageBase</span> field <span class="ent">➏</span> describes the address at which to load the binary (PE binaries are designed to be loaded at a specific virtual address). Other pointer fields contain <em>relative virtual addresses (RVAs)</em>, which are intended to be added to the base address to derive a virtual address. For instance, the <span class="literal">BaseOfCode</span> field <span class="ent">➎</span> specifies the base address of the code sections as an RVA. Thus, you can find the base virtual address of the code sections by computing <span class="literal">ImageBase+BaseOfCode</span>. As you may have guessed, the <span class="literal">AddressOfEntryPoint</span> field <span class="ent">➍</span> contains the entry point address of the binary, also specified as an RVA.</p>&#13;
<p class="indent">Probably the least self-explanatory field in the optional header is the <span class="literal">DataDirectory</span> array <span class="ent">➐</span>. The <span class="literal">DataDirectory</span> contains entries of a <span class="literal">struct</span> type called <span class="literal">IMAGE_DATA_DIRECTORY</span>, which contains an RVA and a size. Every entry in the array describes the starting RVA and size of an important portion of the binary; the precise interpretation of the entry depends on its index in the array. The most important entries are the one at index 0, which describes the base RVA and size of the <em>export directory</em> (basically a table of exported functions); the entry at index 1, which describes the <em>import directory</em> (a table of imported functions); and the entry at index 5, which describes the relocation table. I’ll talk more about the export and import tables when I discuss PE sections. The <span class="literal">DataDirectory</span> essentially serves as a shortcut for the loader, allowing it to quickly look up particular portions of data without having to iterate through the section header table.</p>&#13;
<h3 class="h3" id="ch03_3">3.3 The Section Header Table</h3>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_62"/>In most ways, the PE section header table is analogous to ELF’s section header table. It’s an array of <span class="literal">IMAGE_SECTION_HEADER</span> structures, each of which describes a single section, denoting its size in the file and in memory (<span class="literal">SizeOfRawData</span> and <span class="literal">VirtualSize</span>), its file offset and virtual address (<span class="literal">PointerToRawData</span> and <span class="literal">VirtualAddress</span>), relocation information, and any flags (<span class="literal">Characteristics</span>). Among other things, the flags describe whether the section is executable, readable, writable, or some combination of these. Instead of referring to a string table as the ELF section headers do, PE section headers specify the section name using a simple character array field, aptly called <span class="literal">Name</span>. Because the array is only 8 bytes long, PE section names are limited to 8 characters.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_63"/>Unlike ELF, the PE format does not explicitly distinguish between sections and segments. The closest thing PE files have to ELF’s execution view is the <span class="literal">DataDirectory</span>, which provides the loader with a shortcut to certain portions of the binary needed for setting up the execution. Other than that, there is no separate program header table; the section header table is used for both linking and loading.</p>&#13;
<h3 class="h3" id="ch03_4">3.4 Sections</h3>&#13;
<p class="noindent">Many of the sections in PE files are directly comparable to ELF sections, often even having (almost) the same name. <a href="ch03.xhtml#ch03list2">Listing 3-2</a> shows an overview of the sections in <em>hello.exe</em>.</p>&#13;
<p class="listing1" id="ch03list2"><em>Listing 3-2: Overview of sections in example PE binary</em></p>&#13;
<p class="programs">$ <span class="codestrong1">objdump -x hello.exe</span><br/>...<br/><br/>Sections:<br/>Idx Name       Size        VMA              LMA               File off Algn<br/>  0 .text      00000db8    0000000140001000 0000000140001000  00000400 2**4<br/>               CONTENTS,   ALLOC, LOAD, READONLY, CODE       <br/>  1 .rdata     00000d72    0000000140002000 0000000140002000  00001200 2**4<br/>               CONTENTS,   ALLOC, LOAD, READONLY, DATA       <br/>  2 .data      00000200    0000000140003000 0000000140003000  00002000 2**4<br/>               CONTENTS,   ALLOC, LOAD, DATA                 <br/>  3 .pdata     00000168    0000000140004000 0000000140004000  00002200 2**2<br/>               CONTENTS,   ALLOC, LOAD, READONLY, DATA       <br/>  4 .rsrc      000001e0    0000000140005000 0000000140005000  00002400 2**2<br/>               CONTENTS,   ALLOC, LOAD, READONLY, DATA       <br/>  5 .reloc     0000001c    0000000140006000 0000000140006000  00002600 2**2<br/>               CONTENTS,   ALLOC, LOAD, READONLY, DATA<br/>...</p>&#13;
<p class="indent">As you can see in <a href="ch03.xhtml#ch03list2">Listing 3-2</a>, there’s a <span class="literal">.text</span> section containing code, an .rdata section containing read-only data (roughly equivalent to <span class="literal">.rodata</span> in ELF), and a <span class="literal">.data</span> section containing readable/writable data. Usually there’s also a <span class="literal">.bss</span> section for zero-initialized data, though it’s missing in this simple example binary. There’s also a <span class="literal">.reloc</span> section, which contains relocation information. One important thing to note is that PE compilers like Visual Studio sometimes place read-only data in the <span class="literal">.text</span> section (mixed in with the code) instead of in <span class="literal">.rdata</span>. This can be problematic during disassembly, because it makes it possible to accidentally interpret constant data as instructions.</p>&#13;
<h4 class="h4" id="ch03_4_1"><span epub:type="pagebreak" id="page_64"/><em>3.4.1 The .edata and .idata Sections</em></h4>&#13;
<p class="noindent">The most important PE sections that have no direct equivalent in ELF are <span class="literal">.edata</span> and <span class="literal">.idata</span>, which contain tables of exported and imported functions, respectively. The export directory and import directory entries in the <span class="literal">DataDirectory</span> array refer to these sections. The <span class="literal">.idata</span> section specifies which symbols (functions and data) the binary imports from shared libraries, or DLLs in Windows terminology. The <span class="literal">.edata</span> section lists the symbols and their addresses that the binary exports. Thus, to resolve references to external symbols, the loader needs to match up the required imports with the export table of the DLL that provides the required symbols.</p>&#13;
<p class="indent">In practice, you may find that there are no separate <span class="literal">.idata</span> and .edata sections. In fact, they’re not present in the example binary in <a href="ch03.xhtml#ch03list2">Listing 3-2</a> either! When these sections aren’t present, they’re usually merged into <span class="literal">.rdata</span>, but their contents and workings remain the same.</p>&#13;
<p class="indent">When the loader resolves dependencies, it writes the resolved addresses into the <em>Import Address Table (IAT)</em>. Similar to the Global Offset Table in ELF, the IAT is simply a table of resolved pointers with one slot per pointer. The IAT is also part of the <span class="literal">.idata</span> section, and it initially contains pointers to the names or identifying numbers of the symbols to be imported. The dynamic loader then replaces these pointers with pointers to the actual imported functions or variables. A call to a library function is then implemented as a call to a <em>thunk</em> for that function, which is nothing more than an indirect jump through the IAT slot for the function. <a href="ch03.xhtml#ch03list3">Listing 3-3</a> shows what thunks look like in practice.</p>&#13;
<p class="listing1" id="ch03list3"><em>Listing 3-3: Example PE thunks</em></p>&#13;
<p class="programs">$ <span class="codestrong1">objdump -M intel -d hello.exe</span><br/>...<br/>140001cd0: ff 25 b2 03 00 00    jmp QWORD PTR [rip+0x3b2]   # <span class="ent">➊</span>0x140002088<br/>140001cd6: ff 25 a4 03 00 00    jmp QWORD PTR [rip+0x3a4]   # <span class="ent">➋</span>0x140002080<br/>140001cdc: ff 25 06 04 00 00    jmp QWORD PTR [rip+0x406]   # <span class="ent">➌</span>0x1400020e8<br/>140001ce2: ff 25 f8 03 00 00    jmp QWORD PTR [rip+0x3f8]   # <span class="ent">➍</span>0x1400020e0<br/>140001ce8: ff 25 ca 03 00 00    jmp QWORD PTR [rip+0x3ca]   # <span class="ent">➎</span>0x1400020b8<br/>...</p>&#13;
<p class="indent">You’ll often see thunks grouped together as in <a href="ch03.xhtml#ch03list3">Listing 3-3</a>. Note that the target addresses for the jumps <span class="ent">➊</span> through <span class="ent">➎</span> are all stored in the import directory, contained in the <span class="literal">.rdata</span> section, which starts at address <span class="literal">0x140002000</span>. These are jump slots in the IAT.</p>&#13;
<h4 class="h4" id="ch03_4_2"><em>3.4.2 Padding in PE Code Sections</em></h4>&#13;
<p class="noindent">Incidentally, when disassembling PE files, you may notice that there are lots of <span class="literal">int3</span> instructions. Visual Studio emits these instructions as padding (instead of the <span class="literal">nop</span> instructions used by <span class="literal">gcc</span>) to align functions and blocks of <span epub:type="pagebreak" id="page_65"/>code in memory such that they can be accessed efficiently.<sup><a id="ch03fn_2a" href="footnote.xhtml#ch03fn_2">2</a></sup> The <span class="literal">int3</span> instruction is normally used by debuggers to set breakpoints; it causes the program to trap to the debugger or to crash if no debugger is present. This is okay for padding code since padding instructions are not intended to be executed.</p>&#13;
<h3 class="h3" id="ch03_5">3.5 Summary</h3>&#13;
<p class="noindent">If you’ve made it through both <a href="ch02.xhtml#ch02">Chapter 2</a> and this chapter, I applaud your perseverance. After reading this chapter, you should now be aware of the main similarities and differences between ELF and PE. This will help you if you are interested in analyzing binaries on the Windows platform. In the next chapter, you’ll get your hands dirty and start building your first real binary analysis tool: a binary loading library that can load up ELF and PE binaries for analysis.</p>&#13;
<div class="box">&#13;
<p class="headbox" id="ch03_6">Exercises</p>&#13;
<p class="boxhead1">1. Manual Header Inspection</p>&#13;
<p class="noindent">Just as you did for ELF binaries in <a href="ch02.xhtml#ch02">Chapter 2</a>, use a hex viewer like <span class="literal">xxd</span> to view the bytes in a PE binary. You can use the same command as before, <span class="literal">xxd</span> <em>program.exe</em> <span class="literal">| head -n 30</span>, where <em>program.exe</em> is your PE binary. Can you identify the bytes representing the PE header and make sense of all of the header fields?</p>&#13;
<h3 class="h3">2. Disk Representation vs. Memory Representation</h3>&#13;
<p class="noindent">Use <span class="literal">readelf</span> to view the contents of a PE binary. Then make an illustration of the binary’s on-disk representation versus its representation in memory. What are the major differences?</p>&#13;
<h3 class="h3">3. PE vs. ELF</h3>&#13;
<p class="noindent">Use <span class="literal">objdump</span> to disassemble an ELF and a PE binary. Do the binaries use different kinds of code and data constructs? Can you identify some code or data patterns that are typical for the ELF compiler and the PE compiler you’re using, respectively?</p>&#13;
</div>&#13;
</div></body></html>