- en: '**5'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**5**'
- en: READ THIS BEFORE YOU BREAK SOMETHING ELSE! (BACKUP AND RECOVERY)**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在您打破其他东西之前，请阅读此内容！（备份和恢复）**
- en: '![image](../images/common01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common01.jpg)'
- en: The most common cause of system failure is those pesky humans, but hardware
    and operating systems also fail. Hackers learn new ways to disrupt networks and
    penetrate applications, and you’ll inevitably need to upgrade and patch your system
    on a regular basis. (Whether or not you *will* upgrade and patch is an entirely
    separate question.) Any time you touch a system, there’s a chance you’ll make
    a mistake, misconfigure a vital service, or otherwise totally ruin your system.
    Just think of how many times you’ve patched a computer running any OS and found
    something behaving oddly afterward! Even small system changes can damage data.
    You should, therefore, always assume that the worst is about to happen. In our
    case, this means that if either the hardware or a human being destroys the data
    on your hard drive, you must be able to restore that data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 系统故障最常见的原因是那些烦人的人类，但硬件和操作系统也会出现故障。黑客不断学习新方法来破坏网络和渗透应用程序，您不可避免地需要定期升级和修补您的系统。（您是否*会*升级和修补是另一个完全不同的问题。）每次操作系统时，您都有可能犯错、配置错误至关重要的服务，或彻底毁坏系统。想想看，每次修补任何操作系统的计算机后，总会发现某些地方异常！即使是小的系统变动也可能损坏数据。因此，您应该始终假设最坏的情况即将发生。在我们的情况下，这意味着如果硬件或人为因素破坏了硬盘上的数据，您必须能够恢复这些数据。
- en: We’ll start with system backups and managing tape drives using tar(1) and then
    review recording system behavior with script(1). Finally, should you suffer a
    partial or near-total disaster, we’ll consider recovering and rebuilding with
    single-user mode and the install media.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从使用 tar(1) 进行系统备份和管理磁带驱动器开始，然后回顾如何使用 script(1) 记录系统行为。最后，如果您遭遇部分或几乎完全的灾难，我们将考虑如何通过单用户模式和安装介质恢复和重建系统。
- en: '**System Backups**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**系统备份**'
- en: You need a system backup only if you care about your data. That isn’t as inane
    as it sounds. The real question is, “How much would it cost to replace my data?”
    A low-end tape backup system can run a few hundred dollars. How much is your time
    worth, and how long will it take to restore your system from the install media?
    If the most important data on your hard disk is your web browser’s bookmarks file,
    a backup system probably isn’t worth the investment. But if your server is your
    company’s backbone, you’ll want to take this investment very seriously.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在您关心数据时，才需要进行系统备份。这并不像听起来那么无意义。真正的问题是，“如果我的数据丢失，替代它的成本是多少？”低端磁带备份系统可能只需几百美元。您的时间值多少钱，恢复系统所需的时间有多久？如果硬盘上最重要的数据是您浏览器的书签文件，那么备份系统可能不值得投资。但如果您的服务器是公司骨干，您就需要非常认真地对待这一投资。
- en: Online backups can easily be damaged or destroyed by whatever ruins the live
    server. Proper backups are stored safely offline. Tools like rsync(1), and even
    ZFS replication, don’t create actual backups; they create convenient online copies.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在线备份很容易被破坏或摧毁，就像破坏正在运行的服务器一样。正确的备份应该安全地离线存储。像 rsync(1) 这样的工具，甚至是 ZFS 复制，都不创建实际的备份；它们只是创建方便的在线副本。
- en: A complete backup and restore operation requires a tape drive and media. You
    can also back up to files, across the network, or to removable media, such as
    CDs or DVDs. Many people use removable multiterabyte hard drives connected via
    USB 3 for backups. Despite our best efforts, tape is still an important medium
    for many environments.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的备份和恢复操作需要磁带驱动器和介质。您还可以将数据备份到文件、通过网络或到可移动介质（如 CD 或 DVD）。许多人使用通过 USB 3 连接的可移动多
    terabyte 硬盘进行备份。尽管我们尽力而为，但磁带仍然是许多环境中的重要媒介。
- en: '**Backup Tapes**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**备份磁带**'
- en: FreeBSD supports SCSI and USB tape drives. SCSI drives are the fastest and most
    reliable. USB tape drives are not always standards-compliant and hence not always
    compatible with FreeBSD. Definitely check the release notes or the FreeBSD mailing
    list archives to confirm that your tape drive is compatible with FreeBSD.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 支持 SCSI 和 USB 磁带驱动器。SCSI 驱动器是最快且最可靠的。USB 磁带驱动器并不总是符合标准，因此并非总是与 FreeBSD
    兼容。务必检查发布说明或 FreeBSD 邮件列表存档，以确认您的磁带驱动器是否与 FreeBSD 兼容。
- en: 'Once you’ve physically installed your tape drive, you need to confirm that
    FreeBSD recognizes it. The simplest way is to check the */var/run/dmesg.boot*
    file for *sa* devices (see [Chapter 4](ch04.xhtml#ch04)). For example, the following
    three lines from *dmesg.boot* describe the SCSI tape device in this machine:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你物理安装了磁带驱动器，需要确认 FreeBSD 是否识别它。最简单的方法是检查 */var/run/dmesg.boot* 文件中是否有 *sa*
    设备（参见 [第 4 章](ch04.xhtml#ch04)）。例如，以下三行来自 *dmesg.boot*，描述了此机器中的 SCSI 磁带设备：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Of all the information we have on this tape drive, the most important is that
    your FreeBSD system knows this device as sa0 ➊. We also see that it’s attached
    to the SCSI card mps0 ➋ at SCSI ID 3 ➌, and we see the drive’s model number ➍
    as well as the fact that it can run at 600MB per second ➎.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有关于这个磁带驱动器的信息中，最重要的是你的 FreeBSD 系统将这个设备识别为 sa0 ➊。我们还看到它连接到 SCSI 卡 mps0 ➋，SCSI
    ID 为 3 ➌，并且我们看到驱动器的型号 ➍，以及它能够以每秒 600MB 的速度运行 ➎。
- en: '***Tape Drive Device Nodes, Rewinding, and Ejecting***'
  id: totrans-14
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***磁带驱动器设备节点、倒带和弹出***'
- en: Tape is a linear storage medium. Each section of tape holds a particular piece
    of data. If you back up multiple chunks of data to tape, avoid rewinding after
    each backup operation. Imagine that you wrote a backup of one system to tape,
    rewound the tape, and backed up another system. The second backup would overwrite
    the first because it used the same chunk of tape. When you run multiple backups
    on a single tape, use the appropriate device node to ensure you don’t rewind the
    tape between tasks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 磁带是一种线性存储介质。每一段磁带存储一部分数据。如果你将多个数据块备份到磁带，避免在每次备份操作后倒带。假设你将一个系统的备份写入磁带，倒带磁带后再备份另一个系统，第二次备份会覆盖第一次备份，因为它使用了相同的磁带段。当你在单个磁带上进行多个备份时，使用合适的设备节点以确保任务之间不会倒带。
- en: 'As with many Unix devices with decades worth of history, the way you access
    a tape drive controls how it behaves. Tape drives have several different device
    nodes, and each one makes the tape drive behave differently. The most basic tape-control
    mechanism is the device node used to access it. Normal tape drives have three
    nodes: */dev/esa0*, */dev/nsa0*, and */dev/sa0*.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多有着数十年历史的 Unix 设备一样，访问磁带驱动器的方式决定了它的行为。磁带驱动器有多个不同的设备节点，每个节点让磁带驱动器表现不同。最基本的磁带控制机制是用来访问它的设备节点。普通磁带驱动器有三个节点：*/dev/esa0*、*/dev/nsa0*
    和 */dev/sa0*。
- en: Tapes are sequential access devices, and to access certain data on a particular
    section of tape, you must roll the tape back to expose that section. To rewind
    or not to rewind is an important question.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 磁带是顺序访问设备，要访问磁带上某一特定段的数据，必须倒带磁带以暴露该段。是否倒带是一个重要的问题。
- en: '**NOTE**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The behavior of different tape device nodes varies between operating systems.
    Different versions of Unix, with different tape management software, handle tapes
    differently. Do not make assumptions with your backup tapes!*'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*不同磁带设备节点的行为在操作系统之间有所不同。不同版本的 Unix，以及不同的磁带管理软件，会以不同的方式处理磁带。不要对你的备份磁带做假设！*'
- en: If you use the node name that matches the device name, the tape drive will automatically
    rewind when your command finishes. Our sample SCSI tape drive has a device name
    of sa0, so if you run a command using */dev/sa0* as the device node, the tape
    will rewind when the command finishes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用与设备名称匹配的节点名称，当命令完成时，磁带驱动器将自动倒带。我们的示例 SCSI 磁带驱动器的设备名称为 sa0，因此如果你使用 */dev/sa0*
    作为设备节点运行命令，命令完成后磁带将倒带。
- en: If you don’t want the tape to automatically rewind when the command completes,
    stop it from rewinding by using the node name that starts with *n*. Perhaps you
    need to append a second backup from a different machine onto the tape or you want
    to catalog the tape before rewinding and ejecting. In our example, use */dev/nsa0*
    to run your command without rewinding.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不希望命令完成时磁带自动倒带，可以使用以 *n* 开头的节点名称来阻止倒带。也许你需要将来自另一台机器的第二个备份附加到磁带上，或者你想在倒带和弹出之前对磁带进行编目。在我们的示例中，使用
    */dev/nsa0* 来运行命令而不进行倒带。
- en: To automatically eject a tape when a command finishes, use the node that begins
    with *e*. For example, if you’re running a full system backup, you probably want
    the tape to eject when the command finishes so the operator can put the tape in
    a case to ship offsite or place in storage. Our example uses the */dev/esa0* device
    name to eject the tape when the command finishes. Some tape drives might not support
    automatic ejection; they’ll require you to push the physical button to work the
    lever that winches the tape out of the drive. The easiest way to identify such
    a drive is to try to eject it via the device node and see what happens.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要在命令完成时自动弹出磁带，可以使用以 *e* 开头的节点。例如，如果你正在运行完整系统备份，可能希望命令完成时自动弹出磁带，这样操作员就可以将磁带放入盒子中送往外部存储或存放起来。我们的示例使用
    */dev/esa0* 设备名称，在命令完成时弹出磁带。一些磁带驱动器可能不支持自动弹出；它们需要你按下物理按钮，操作杠杆将磁带从驱动器中拉出。识别这种驱动器的最简单方法是尝试通过设备节点弹出它，然后看看发生了什么。
- en: '***The $TAPE Variable***'
  id: totrans-23
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***$TAPE 变量***'
- en: Many programs assume that your tape drive is */dev/sa0*, but that isn’t always
    correct. Even if you have only one tape drive, you might want to eject it automatically
    (*/dev/esa0*) or not to rewind it upon completion (*/dev/nsa0*).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序假设你的磁带驱动器是 */dev/sa0*，但这并不总是正确的。即使你只有一个磁带驱动器，你也可能希望在命令完成时自动弹出磁带（*/dev/esa0*），或者在完成时不自动倒带（*/dev/nsa0*）。
- en: Many (but not all) backup-related programs use the environment variable `$TAPE`
    to control which device node they use by default. You can always override `$TAPE`
    on the command line, but setting it to your most commonly used choice can save
    you some annoyances later.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 许多（但不是所有）与备份相关的程序使用环境变量 `$TAPE` 来控制它们默认使用的设备节点。你始终可以在命令行上覆盖 `$TAPE`，但将其设置为你最常用的选项可以节省你以后的一些麻烦。
- en: '***Tape Status with mt(1)***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 mt(1) 检查磁带状态***'
- en: 'Now that you know how to find your tape drive, you can perform basic actions
    on it—such as rewinding, retensioning, erasing, and so on—with mt(1). One basic
    thing mt(1) does is check a tape drive’s status, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何找到你的磁带驱动器后，你可以使用 mt(1) 执行基本操作——如倒带、重张、擦除等等。mt(1) 做的一个基本操作是检查磁带驱动器的状态，具体如下：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You don’t have to worry about most of the information here, but if you want
    to go through it line by line, the mt(1) man page contains a good description
    of all the features. At the very least, if the command returns anything useful,
    this means mt(1) can find your tape drive.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必担心这里的大多数信息，但如果你想逐行查看，mt(1) 手册页面包含了所有功能的良好描述。至少，如果命令返回了任何有用的信息，意味着 mt(1) 能找到你的磁带驱动器。
- en: One of the first things we see is the drive density ➊. Older drives can have
    tapes of different densities for different purposes, but modern tape drives pack
    data as tightly as possible. This particular tape drive is a DDS-3 model; while
    you could choose to use another density, all the choices it offers are DDS-3\.
    We also see that this tape drive offers hardware compression with the DCLZ algorithm
    ➋. Near the bottom, we see what the tape drive is doing right now ➌.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先看到的是驱动器密度 ➊。旧的驱动器可以有不同密度的磁带，用于不同的目的，但现代磁带驱动器尽可能紧密地压缩数据。这个特定的磁带驱动器是 DDS-3
    型号；虽然你可以选择使用其他密度，但它提供的所有选择都是 DDS-3。我们还看到这个磁带驱动器提供了 DCLZ 算法的硬件压缩 ➋。在底部附近，我们看到磁带驱动器现在正在做什么
    ➌。
- en: 'The `status` command might give you different sorts of messages. The most problematic
    is the one that tells you that your tape drive is not configured:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`status` 命令可能会给你不同种类的信息。最有问题的就是那个告诉你磁带驱动器未配置的消息：'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This means that you don’t actually have a tape at the device node that your
    `$TAPE` variable points at. You can experiment with device nodes and mt(1) by
    using the `-f` flag to specify a device node (for example, `mt -f` `/d``ev/nsa1
    status`), although you should get correct information from *dmesg.boot*. If you’re
    sure that your device node is correct, perhaps you don’t have a tape inserted
    into the drive or the tape drive needs cleaning.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你在 `$TAPE` 变量指向的设备节点上实际上没有磁带。你可以通过使用 `-f` 标志来指定设备节点（例如，`mt -f` `/dev/nsa1
    status`）来实验设备节点和 mt(1)，尽管你应该从 *dmesg.boot* 获取正确的信息。如果你确定你的设备节点是正确的，也许是因为驱动器中没有插入磁带，或者磁带驱动器需要清洁。
- en: 'Another response you might get from `mt status` is `mt: /dev/nsa0: Device busy`.
    You asked for the status of your tape, and it replied, “I can’t talk now. I’m
    busy.” Try again later, or check `ps -ax` to see what commands are using the tape
    drive. When you’re working with actual tape, only one program instance can access
    it at a time. You can’t list the contents of a tape while you’re extracting a
    file from that tape.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '从`mt status`返回的另一个响应是`mt: /dev/nsa0: 设备忙碌`。你请求了磁带的状态，磁带回应：“我现在忙，不能接听。”稍后再试，或者使用`ps
    -ax`查看哪些命令正在使用磁带驱动器。当你在操作实际的磁带时，只有一个程序实例能够同时访问它。你无法在从磁带提取文件时列出磁带内容。'
- en: '***Other Tape Drive Commands***'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***其他磁带驱动器命令***'
- en: You can do more with a tape drive than just check to see whether it’s alive.
    The mt(1) subcommands I use most frequently are `retension`, `erase`, `rewind`,
    and `offline`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用磁带驱动器做的不仅仅是检查它是否正常工作。我最常用的mt(1)子命令是`retension`、`erase`、`rewind`和`offline`。
- en: Tapes tend to stretch, especially after they’re used the first time. (I know
    perfectly well that modern tape vendors all claim that they prestretch their tapes
    or that their tapes can’t be stretched, but that claim and two slices of bread
    will get you a bologna sandwich.) *Retensioning* a tape is simply running the
    tape completely through, both forward and back, with the command `mt retension`.
    Retensioning takes all the slack out of the tape and makes backups more reliable.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 磁带有伸展的倾向，尤其是在第一次使用后。（我非常清楚，现代的磁带供应商都声称他们的磁带经过预拉伸，或者说他们的磁带无法被拉伸，但这个说法和两片面包就能做成一个博洛尼亚三明治。）*重新张紧*磁带只是将磁带完全前后地通过一次，命令是`mt
    retension`。重新张紧会去掉磁带中的松弛部分，使备份更加可靠。
- en: '*Erasing* removes all data from a tape. This isn’t a solidly reliable erasure,
    which you’d need to conceal data from a data recovery firm or the IRS; `mt erase`
    simply rolls through the tape and overwrites everything once. This can take a
    very long time. If you want to erase the tape quickly, you can use `mt erase 0`
    to simply mark the tape as blank.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*擦除*会从磁带上移除所有数据。这不是一个完全可靠的擦除方法，如果你需要隐藏数据以防止数据恢复公司或税务局查看，`mt erase`只是简单地在磁带上滚动并覆盖所有内容一次。这可能需要很长时间。如果你想快速擦除磁带，可以使用`mt
    erase 0`将磁带标记为空白。'
- en: The `mt rewind` command rolls a tape back to the beginning, same as accessing
    the device through its default device node.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`mt rewind`命令将磁带倒带到起始位置，和通过默认设备节点访问设备一样。'
- en: When you *offline* a tape, you rewind and eject it so that you can put a new
    tape in. The command is, oddly enough, `mt offline`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你*脱机*磁带时，你需要倒带并弹出磁带，这样才能插入新的磁带。奇怪的是，命令是`mt offline`。
- en: Now let’s get some data on that tape.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们获取一些关于这张磁带的数据。
- en: '**TAPE DRIVE TEMPERAMENT**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**磁带驱动器的特性**'
- en: Not all tape drives support all functions. Older tape drives in particular are
    quite touchy, even crotchety, requiring very specific settings to work acceptably.
    If you have a problem with a particular drive, check the *FreeBSD-questions* mailing
    list archive for messages from others with the same problem. You’ll probably find
    your answer there.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的磁带驱动器都支持所有功能。特别是老旧的磁带驱动器非常挑剔，甚至有些脾气不好，要求非常特定的设置才能正常工作。如果你遇到特定驱动器的问题，可以查看*FreeBSD-questions*邮件列表归档，看看是否有其他人遇到过相同的问题。你很可能在那里找到答案。
- en: '**BSD tar(1)**'
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**BSD tar(1)**'
- en: The most popular tool for backing up systems to tape is tar(1). *Tar* is short
    for “tape archiver”—it’s literally written for backups. FreeBSD also includes
    dump(8), but that’s intended only for UFS filesystems that don’t use soft updates
    journaling. You’ll certainly encounter other backup tools too, such as pax and
    cpio, as well as network-based backup tools, like Amanda, Bacula, and Tarsnap.
    These tools are well suited for certain environments but aren’t as universal as
    tar. Tar is a common standard recognized by almost every operating system vendor;
    you can find tar for Windows, Linux, Unix, BSD, macOS, AS/400, VMS, Atari, Commodore
    64, QNX, and just about everything else you might encounter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 用于将系统备份到磁带的最流行工具是tar(1)。*Tar*是“磁带归档程序”的缩写——它是专门为备份而编写的。FreeBSD也包含了dump(8)，但它仅适用于不使用软更新日志的UFS文件系统。你还会遇到其他备份工具，如pax和cpio，以及基于网络的备份工具，如Amanda、Bacula和Tarsnap。这些工具适合某些特定环境，但不如tar那样通用。Tar是几乎所有操作系统供应商都认可的常见标准；你可以在Windows、Linux、Unix、BSD、macOS、AS/400、VMS、Atari、Commodore
    64、QNX等几乎所有其他平台上找到tar。
- en: You can use tar(1) to back up to tape or to a file. A backup file containing
    tarred files is called a *tarball*. It’s very fast and easy to restore just one
    file or a subset of files from a tarball. It’s also easy to restore a portion
    of your backup from tape, but it’s not nearly as fast.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用tar(1)将文件备份到磁带或文件中。包含tar文件的备份文件称为*tarball*。从tarball中恢复单个文件或一部分文件非常快速且简单。从磁带中恢复备份的一部分也很容易，但速度远不如直接恢复。
- en: FreeBSD uses a version of tar called *bsdtar*. Bsdtar can behave completely
    consistently with GNU tar and can also behave in strict accordance with POSIX
    tar. If you’re at all concerned about the differences between GNU tar, POSIX tar,
    and bsdtar, read tar(1) for all the gory details. Bsdtar is built on libarchive(3),
    a library specifically for creating and extracting backup archives. Thanks to
    libarchive, bsdtar can extract files from anything from a traditional tape backup
    to an ISO image, all with the same interface. If you need to open an RPM, a zip
    file, or almost any other archive, bsdtar is your friend.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD使用的tar版本叫做*bsdtar*。bsdtar可以完全一致地与GNU tar配合使用，也可以严格遵循POSIX tar的行为。如果你对GNU
    tar、POSIX tar和bsdtar之间的差异有任何疑虑，阅读tar(1)以了解所有详细信息。bsdtar基于libarchive(3)构建，这是一个专门用于创建和提取备份归档的库。得益于libarchive，bsdtar可以从传统的磁带备份到ISO镜像提取文件，所有操作都有相同的界面。如果你需要打开RPM、zip文件或几乎任何其他归档文件，bsdtar都是你的朋友。
- en: Bsdtar, like any other tar(1), can be dumb. If your filesystem is corrupt in
    any way, bsdtar will back up what it thinks you asked for. It will then happily
    restore files that were damaged during the original backup, overwriting working-but-incorrect
    files with not-working-and-still-incorrect versions. These sorts of problems rarely
    happen, but tend to be unforgettable when they do.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 像其他任何tar(1)一样，bsdtar也可以很“傻”。如果你的文件系统以任何方式损坏，bsdtar会备份它认为你请求的内容。然后，它会愉快地恢复在原始备份过程中损坏的文件，将正在工作但不正确的文件覆盖为无法正常工作的错误版本。虽然这种问题很少发生，但一旦发生，往往令人难以忘怀。
- en: '**FILESYSTEM COHERENCE**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件系统一致性**'
- en: No matter what backup software you use, files can change as you’re trying to
    back them up. Log files constantly add stuff at the end, while databases can change
    anywhere in the file. Filesystem snapshots are always consistent, and both UFS
    ([Chapter 11](ch11.xhtml#ch11)) and ZFS ([Chapter 12](ch12.xhtml#ch12)) support
    them. Never back up live databases; instead, dump the database to an archive file
    and back up that archive.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么备份软件，在你尝试备份文件时，文件可能会发生变化。日志文件会不断地在末尾添加内容，而数据库可能在文件的任何地方发生变化。文件系统快照始终是一致的，UFS（[第11章](ch11.xhtml#ch11)）和ZFS（[第12章](ch12.xhtml#ch12)）都支持这种功能。绝不要备份正在运行的数据库；应该将数据库转储到归档文件中，然后备份该归档文件。
- en: '***tar Modes***'
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***tar模式***'
- en: Tar can perform several different actions, controlled by the command line flags.
    These different actions are called *modes*. You’ll need to read the man page for
    a complete description of all tar modes, but the following list describes the
    most commonly used ones.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: tar可以执行几种不同的操作，这些操作由命令行标志控制。这些不同的操作被称为*模式*。你需要阅读man页面，了解所有tar模式的完整描述，但以下列表列出了最常用的几种。
- en: '**Create an Archive**'
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**创建归档**'
- en: 'Use *create mode* (`-c`) to create a new archive. Unless you specify otherwise,
    this flag backs up everything to your tape drive (`$TAPE`, or */dev/sa0* if you
    haven’t set `$TAPE`). To back up your entire system, you’d tell tar to archive
    everything from the root directory down:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*创建模式*（`-c`）来创建一个新的归档。除非另有指定，否则此标志将把所有内容备份到你的磁带驱动器（`$TAPE`，如果没有设置`$TAPE`，则为*/dev/sa0*）。要备份整个系统，你需要告诉tar从根目录开始归档所有内容：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In response, your tape drive should light up and, if your tape is big enough,
    eventually present you with a complete system backup. Many modern hard drives
    are bigger than tape drives can hold, however, so it makes sense to back up only
    the vital portions of your system. For example, if the only files on your computer
    that you need are in the directories */home* and */var*, you could specify those
    directories on the command line:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 作为回应，你的磁带驱动器应该亮起，如果你的磁带足够大，最终会呈现出一个完整的系统备份。然而，许多现代硬盘比磁带驱动器能够容纳的容量还要大，因此备份系统中仅重要的部分是更为合理的。例如，如果你电脑上唯一需要的文件都在*/home*和*/var*目录下，你可以在命令行中指定这些目录：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**List Archive Contents**'
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**列出归档内容**'
- en: '*List mode* (`-t`) lists all the files in an archive. Once you’ve created an
    archive, you can use this mode to list the tape’s contents.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*列出模式*（`-t`）列出归档中的所有文件。创建归档后，你可以使用此模式列出磁带的内容。'
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This list includes all the files in your backup and might take a while to run.
    Note that the initial slashes are missing from filenames; for example, */tmp*
    shows up as *tmp*. This becomes important during restores.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表包括你备份中的所有文件，运行时可能需要一些时间。注意，文件名中的初始斜杠缺失；例如，*/tmp* 会显示为 *tmp*。这在恢复时变得很重要。
- en: '**Extract Files from Backup**'
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从备份中提取文件**'
- en: In *extract* mode, tar retrieves files from the archive and copies them to the
    disk. (This is also called *untarring*.) Tar extracts files in your current location;
    if you want to overwrite the existing */etc* directory of your system with files
    from your backup, go to the root directory first. On the other hand, to restore
    a copy of */etc* in my home directory, I’d go to my home directory first.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在*提取*模式下，tar 从归档中恢复文件并将其复制到磁盘上。（这也叫做*解压*。）tar 在你当前的位置提取文件；如果你想用备份中的文件覆盖现有的 */etc*
    目录，首先进入根目录。另一方面，如果我要在我的主目录中恢复一个 */etc* 的副本，我会首先进入我的主目录。
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Remember when I said that the missing initial slash would be important? Here’s
    why. If the backup included that initial slash, tar would always extract files
    relative to the root directory. The restored backup of */etc/rc.conf* would always
    be written to */etc/rc.conf*. Without the leading */*, you can recover the file
    anywhere you want; the restored */etc/rc.conf* can be resurrected as */home/mwlucas/etc/rc.conf*.
    If I’m restoring files from a machine that’s been decommissioned, I don’t want
    them to overwrite files on the current machine; I want them placed elsewhere so
    they won’t interfere with my system.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我说过，缺少的初始斜杠很重要吗？这就是原因。如果备份中包含了那个初始斜杠，tar 将始终相对于根目录提取文件。恢复的 */etc/rc.conf*
    将始终写入到 */etc/rc.conf*。没有前导的 */*，你可以将文件恢复到你想要的任何位置；恢复后的 */etc/rc.conf* 可以被恢复为 */home/mwlucas/etc/rc.conf*。如果我正在从一台已退役的机器恢复文件，我不希望它们覆盖当前机器上的文件；我希望它们被放置在其他地方，以免干扰我的系统。
- en: '**Verify Backups**'
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**验证备份**'
- en: Once you have a backup, you probably want to confirm that it matches your system.
    *Diff* mode (`-d`) compares the files on tape to the files on disk. If everything
    on the tape matches the system, `tar -d` runs silently. A perfect match between
    tape and system is *not* normal, however. Log files usually grow during the backup
    process, so the log files on tape shouldn’t match the files on disk. Similarly,
    if you have a database server running, the database files might not match. If
    you truly want a perfect backup (also called a *cold backup*), you’ll need to
    shut down to single-user mode before taking the backup. You must decide which
    errors you can live with and which require correction.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了备份，你可能想确认它是否与你的系统匹配。*Diff* 模式（`-d`）将磁带上的文件与磁盘上的文件进行比较。如果磁带上的一切与系统匹配，`tar
    -d` 将默默运行。然而，磁带和系统之间的完美匹配并*不*是正常的情况。日志文件通常在备份过程中增长，因此磁带上的日志文件不应该与磁盘上的文件匹配。类似地，如果你有一个正在运行的数据库服务器，数据库文件可能不匹配。如果你真的想要一个完美的备份（也叫做*冷备份*），你需要在备份之前将系统切换到单用户模式。你必须决定你可以接受哪些错误，哪些错误需要修正。
- en: '***Other tar Features***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***其他 tar 特性***'
- en: Tar has several other features that can make it more friendly or useful. These
    include verbose behavior, different types of compression, permissions restore,
    and the most popular option—alternate storage.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Tar 还有一些其他功能，可以使它更友好或更有用。这些功能包括详细模式、不同类型的压缩、权限恢复，以及最流行的选项——备用存储。
- en: '**Use Non-default Storage**'
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**使用非默认存储**'
- en: 'Tar feeds everything to your tape drive by default, but the `-f` flag allows
    you to specify another device or file as the destination. In all of the preceding
    examples, either I’m using the default tape drive, */dev/sa0*, or I’ve set `$TAPE`.
    If I have neither of these, I’d need to specify a tape drive with `-f`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，tar 会将所有内容传输到你的磁带驱动器，但 `-f` 标志允许你指定另一个设备或文件作为目标。在之前的所有示例中，我要么使用默认的磁带驱动器
    */dev/sa0*，要么设置了 `$TAPE`。如果我没有这两者中的任何一个，我需要使用 `-f` 来指定磁带驱动器：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also back up to a file (or tarball) instead of using a tape. Source
    code distributed via the internet is frequently distributed as tarballs. Use the
    same `-f` flag to specify a filename. For example, to back up the chapters of
    this book as they were written, I ran the following every so often to create the
    tarball *bookbackup.tar*:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将备份保存到文件（或 tar 包）中，而不是使用磁带。通过互联网分发的源代码通常以 tar 包的形式分发。使用相同的 `-f` 标志来指定文件名。例如，为了备份这本书写作时的各个章节，我每隔一段时间运行以下命令来创建
    tar 包 *bookbackup.tar*：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This file can easily be backed up on machines elsewhere—so even if my house
    burns down, the book would be safe. I could then run phone and power lines to
    the neighbor’s house, borrow a laptop, find an open wireless access point, run
    `tar -xf bookbackup.tar`, and work amidst the charred timbers while waiting for
    the insurance company. (I couldn’t do much else at the time, anyway.)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件可以轻松地在其他地方的机器上进行备份——即使我的房子着火了，书籍也会安全。我可以接通电话和电力线到邻居家，借一台笔记本电脑，找到一个开放的无线接入点，运行
    `tar -xf bookbackup.tar`，在焦黑的木材中工作，等待保险公司处理。 (反正那时我也做不了别的事。)
- en: '**Verbose**'
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**详细模式**'
- en: Tar normally runs silently unless it encounters an error. This is good most
    of the time (who wants to read the complete list of files on the server every
    time a backup runs?), but sometimes you like to have the warm fuzzy feeling of
    watching a program do its work. Adding the `-v` flag makes tar print the name
    of each file it processes. You can use the verbose flag to create a complete list
    of all the files being backed up or restored. In a routine backup or restore,
    this verbosity makes errors difficult to see.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 除非遇到错误，否则 tar 通常静默运行。大多数时候这是好的（谁想在每次备份时查看服务器上完整的文件列表？），但有时你会想看到程序执行的过程，获得一种温暖的满足感。添加
    `-v` 标志会使 tar 打印它处理的每个文件的名称。你可以使用详细模式标志来创建所有正在备份或恢复的文件的完整列表。在常规的备份或恢复中，这种冗余信息会使错误变得难以察觉。
- en: '***Compression***'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***压缩***'
- en: Bsdtar inherits support for every compression algorithm libarchive(3) understands.
    We’ll cover a few you might use to create archives, in order from the most to
    least desirable. Bsdtar supports many more compression algorithms, but you wouldn’t
    normally use them to create an archive.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Bsdtar 继承了 libarchive(3) 所理解的所有压缩算法的支持。我们将介绍一些你可能用来创建归档的压缩算法，按从最理想到最不推荐的顺序排列。Bsdtar
    支持更多的压缩算法，但通常情况下你不会使用它们来创建归档。
- en: '**XZ Compression**'
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**XZ 压缩**'
- en: The XZ compression algorithm is the new hotness. Enable it with `-J`. Non-FreeBSD
    hosts might need to pipe restores through xz(1) to read them. Tarballs compressed
    with XZ usually end in *.txz*.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: XZ 压缩算法是当前的新热点。使用`-J`启用它。非 FreeBSD 主机可能需要通过 xz(1) 管道恢复数据以进行读取。使用 XZ 压缩的 Tarball
    通常以 *.txz* 结尾。
- en: '**bzip Compression**'
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**bzip 压缩**'
- en: FreeBSD’s tar supports bzip compression, which shrinks files even more tightly
    than gzip, with the `-j` flag. Bzip uses more CPU time than gzip, but these days,
    CPU time is not nearly as limited as when gzip came out. Not all versions of tar
    support bzip compression, either. If you’ll only be reading your files on a FreeBSD
    machine or you’re comfortable installing bzip on other platforms, use the `-j`
    flag. Most tarballs compressed with bzip(1) end in *.tbz*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 的 tar 支持 bzip 压缩，它比 gzip 压缩得更紧凑，使用 `-j` 标志。Bzip 使用的 CPU 时间比 gzip 多，但如今，CPU
    时间不像 gzip 出现时那样有限。并不是所有版本的 tar 都支持 bzip 压缩。如果你只会在 FreeBSD 机器上读取文件，或者你愿意在其他平台上安装
    bzip，可以使用 `-j` 标志。大多数使用 bzip(1) 压缩的 tarball 以 *.tbz* 结尾。
- en: '**gzip Compression**'
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**gzip 压缩**'
- en: The gzip flag (`-z`) runs the files through the gzip(1) compression program
    on their way to or from the archive. Compressed tarballs usually have the extension
    *.tar.gz*, *.tgz*, or, on rare occasion, *.taz*. Compression can greatly reduce
    the size of an archive; many backups shrink by 50 percent or more with compression.
    While all modern versions of tar support gzip, older versions don’t, so if you
    want absolutely everybody to be able to read your backup, don’t use `-z`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: gzip 标志（`-z`）会在归档的过程中将文件通过 gzip(1) 压缩程序进行处理。压缩后的 tarball 通常以 *.tar.gz*、*.tgz*
    或在少数情况下以 *.taz* 结尾。压缩可以大大减小归档的大小；许多备份在压缩后减小了 50% 或更多。虽然所有现代版本的 tar 都支持 gzip，但旧版本不支持，因此，如果你希望每个人都能读取你的备份，最好不要使用
    `-z`。
- en: '**Primordial Unix Compression**'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**原始 Unix 压缩**'
- en: In contrast, all Unix versions of tar can use the `-Z` flag to compress files
    with compress(1). The compress program isn’t as efficient as gzip, but it does
    reduce file size. Every implementation of tar you’re likely to encounter supports
    compress(1). Tarballs compressed with `-Z` have the extension *.tar.Z*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，所有 Unix 版本的 tar 都可以使用 `-Z` 标志通过 compress(1) 压缩文件。compress 程序的效率不如 gzip，但它确实能够减小文件大小。你可能会遇到的每个
    tar 实现都支持 compress(1)。使用 `-Z` 压缩的 tarball 后缀为 *.tar.Z*。
- en: '***Permissions Restore***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***权限恢复***'
- en: The `-p` flag restores the original permissions on extracted files. By default,
    tar sets the owner of an extracted file to the username that’s extracting the
    file. This is fine for source code, but for system restores, you really want to
    restore the file’s original permissions. (Try to restore these permissions by
    hand some time; you’ll learn quite a bit about why you should have done it right
    the first time.)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p`标志会恢复提取文件的原始权限。默认情况下，tar会将提取文件的所有者设置为提取文件的用户名。对于源代码来说这没问题，但在进行系统恢复时，你真的希望恢复文件的原始权限。（有时间手动恢复这些权限试试看；你会学到不少关于为什么第一次就应该做对的事情。）'
- en: '**COMPRESSION AND FREEBSD TAR**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**压缩与 FreeBSD TAR**'
- en: FreeBSD’s libarchive autodetects compression types used in backups. While you
    must specify your desired compression when creating an archive, you don’t need
    to give a compression algorithm when extracting. Let tar(1) determine the compression
    type, and it will Do The Right Thing automatically, even if the archive is compressed
    with an algorithm you’ve never seen before.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD的libarchive会自动检测备份中使用的压缩类型。在创建档案时，你必须指定所需的压缩方式，但提取时不需要提供压缩算法。让tar(1)来决定压缩类型，它会自动执行正确的操作，即使档案是使用你从未见过的算法进行压缩的。
- en: '***And More, More, More . . .***'
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***还有更多，更多，更多……***'
- en: Tar has many, many more functions to accommodate decades of changes in backups,
    files, filesystems, and disks. For a complete list of functions, read man tar(1).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Tar有许多更多的功能，以适应备份、文件、文件系统和磁盘几十年来的变化。欲了解完整的功能列表，请阅读man tar(1)。
- en: '**Recording What Happened**'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**记录发生的事情**'
- en: You can now back up your entire system as well as track changes in a single
    file. All that remains is to track what’s happening on the screen in front of
    you. One of those rarely mentioned but quite useful tools every sysadmin should
    know is script(1). It logs everything you type and everything that appears on
    the screen. You can record errors and log output for later dissection and analysis.
    For example, if you’re running a program that fails in the same spot every time,
    you can use script to copy your keystrokes and the program’s response. This is
    notably useful when upgrading your system or building software from source code;
    the last 30 lines or so of the log file make a nice addition to a help request.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以备份整个系统并跟踪单个文件中的变化。剩下的就是跟踪屏幕前发生的事情。一个很少被提及但非常有用的工具是每个系统管理员都应该知道的`script(1)`。它记录你输入的所有内容以及屏幕上显示的所有内容。你可以记录错误和日志输出，供以后分析和剖析。例如，如果你正在运行一个每次都会在同一位置失败的程序，你可以使用`script`来复制你的按键和程序的响应。这在升级系统或从源代码构建软件时特别有用；日志文件的最后30行左右是请求帮助时的好材料。
- en: 'To start script(1), just type script. You’ll get your command prompt back and
    can continue working normally. When you want the recording to stop, just type
    `exit` or press CTRL-D. Your activity will appear in a file named *typescript*.
    If you want the file to have a particular name or be in a particular location,
    just give that name as an argument to `script`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 启动`script(1)`只需输入`script`。你将会得到命令提示符，可以继续正常工作。当你想停止记录时，只需输入`exit`或按CTRL-D。你的活动将会出现在名为*typescript*的文件中。如果你希望文件有特定的名称或位于特定位置，只需将该名称作为参数传递给`script`：
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This tool is extremely useful for recording exactly what you typed and exactly
    how the system responded. Any time you need to ask for help, consider script(1).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具对于精确记录你输入的内容以及系统如何响应非常有用。每当你需要寻求帮助时，考虑使用`script(1)`。
- en: '**Repairing a Broken System**'
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**修复损坏的系统**'
- en: The best way to learn an operating system is to play with it, and the harder
    you play, the more you learn. If you play hard enough, you’ll certainly break
    something, which is a good thing—having to fix a badly broken system is arguably
    the fastest way to learn. If you’ve just rendered your system unbootable or plan
    to learn quickly enough to risk doing that, this section is for you. If your system
    is deeply hosed, you’ll learn a lot and quickly.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 学习操作系统的最佳方式是与它玩耍，你玩得越深入，学到的越多。如果你玩得足够狠，你肯定会弄坏某些东西，而这恰恰是好事——修复一个严重损坏的系统可以说是学习的最快方式。如果你刚刚让你的系统无法启动，或者计划快速学习到足够的程度以冒险这样做，那么这一节适合你。如果你的系统已经严重损坏，你会学到很多并且会很快掌握。
- en: Single-user mode (discussed in [Chapter 4](ch04.xhtml#ch04)) gives you access
    to many different commands and tools. What if you’ve destroyed those tools, however?
    Perhaps you’ve even damaged the statically linked programs in */rescue*. That’s
    where the install media comes in.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 单用户模式（在[第4章](ch04.xhtml#ch04)中讨论）为你提供了访问许多不同命令和工具的权限。然而，如果你破坏了这些工具怎么办？也许你甚至破坏了*/rescue*中的静态链接程序。这时，安装介质就派上用场了。
- en: The FreeBSD installation images have an option to activate a live system. This
    live system includes all the programs that come by default with FreeBSD. When
    you boot off the install media, you can choose to enter the live CD instead of
    installing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: FreeBSD 安装镜像提供了一个激活 Live 系统的选项。这个 Live 系统包括了 FreeBSD 默认提供的所有程序。当你从安装介质启动时，你可以选择进入
    Live CD，而不是进行安装。
- en: You must have some familiarity with system administration to use the live CD.
    Essentially, the live CD gives you a command prompt and a variety of Unix utilities.
    You get to use the boot-time error messages and that ballast you keep between
    your ears to fix the problem. It’s you against the computer. Of the first half-dozen
    times I’ve resorted to a live CD or its predecessors, the computer won three.
    After that, though, my success rate was much improved. Reading this book, as well
    as other Unix administration manuals, will improve your odds of success.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Live CD 你必须对系统管理有所了解。基本上，Live CD 为你提供了一个命令行提示符和各种 Unix 工具。你可以使用启动时的错误信息以及你脑海中的那部分“平衡物”来修复问题。这是你与计算机的较量。在我第一次使用
    Live CD 或其前身时，计算机赢了三次。不过之后，我的成功率大大提高了。阅读本书以及其他 Unix 管理手册将提高你的成功几率。
- en: It’s impossible to outline a step-by-step process for generic problem situations;
    the exact steps you must follow depend on the exact damage you’ve inflicted on
    your poor, innocent operating system. If you’re really desperate, however, the
    live CD gives you a shot at recovery without reinstalling. I’ve had problems where
    I’ve accidentally destroyed my */etc* directory or fried the getty(1) program
    that displays a login prompt. Careful use of the live CD can repair these problems
    in a fraction of the time a reinstall would take. If nothing else, perhaps you
    can back up any data that survived being exposed to you and then reinstall.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为通用问题情境概括一个逐步的过程几乎是不可能的；你必须遵循的确切步骤取决于你对可怜的、无辜的操作系统造成的具体损害。不过，如果你真的很绝望，Live CD
    可以让你在不重新安装的情况下有机会恢复。我曾经不小心破坏了*/etc* 目录，或者损坏了显示登录提示符的 getty(1) 程序。小心使用 Live CD
    可以在重新安装所需的时间的一小部分内修复这些问题。如果什么都做不到，也许你可以备份任何幸存的数据，然后重新安装。
- en: Always use install media that’s roughly equivalent to the FreeBSD version you’re
    running. You can probably use a 12.2 install CD to repair a 12.1 system, but a
    14-current install disk might cause a whole new set of problems.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用与你当前运行的 FreeBSD 版本大致相当的安装介质。你可能可以使用 12.2 安装 CD 来修复 12.1 系统，但 14-current
    安装光盘可能会引发一系列新的问题。
- en: 'Now that you can recover from almost any mistake you might make, let’s dive
    into the heart of FreeBSD: the kernel.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经可以从几乎所有可能犯的错误中恢复过来了，我们可以深入 FreeBSD 的核心部分：内核。
