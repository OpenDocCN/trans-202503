- en: '**1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SETTING THE STAGE**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg23_Image_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We’ll start with a brief overview of how computer hardware can be thought of
    as organized into three subsystems. The goal of this chapter is to make sure we
    have a common framework for discussing how things are organized and how they fit
    together. Working within this framework, you’ll learn how a program is created
    and executed.
  prefs: []
  type: TYPE_NORMAL
- en: There is a fair amount of programming in this book. To help you prepare for
    this, the chapter ends with a section describing how to set up a programming environment,
    using my system as an example.
  prefs: []
  type: TYPE_NORMAL
- en: '**Computer Subsystems**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can think of computer hardware as consisting of three separate subsystems:
    the *central processing unit (CPU)*, *memory*, and *input/output (I/O)*. These
    are connected with *buses*, as shown in [Figure 1-1](ch01.xhtml#ch1fig1).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/pg30_Image_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-1: The subsystems of a computer*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take each of these elements in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Central processing unit (CPU)**   Controls the flow of data to and from memory
    and I/O devices. The CPU performs arithmetic and logical operations on the data.
    It can decide the order of operations based on the results of arithmetic and logic
    operations. It contains a small amount of very fast memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory**   Provides storage that is readily accessible to the CPU and I/O
    devices for the instructions to the CPU and the data they manipulate.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input/output (I/O)**   Communicates with the outside world and with mass
    storage devices (for example, the disk, network, USB, and printer).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bus**   A physical communication pathway with a protocol specifying exactly
    how the pathway is used.'
  prefs: []
  type: TYPE_NORMAL
- en: As indicated by the arrows in [Figure 1-1](ch01.xhtml#ch1fig1), signals can
    flow in either direction on the buses. The *address bus* is used to specify a
    memory location or an I/O device. Program data and program instructions flow on
    the *data bus*. The *control bus* carries signals that specify how each of the
    subsystems should be using the signals on the other buses.
  prefs: []
  type: TYPE_NORMAL
- en: The buses shown in [Figure 1-1](ch01.xhtml#ch1fig1) indicate logical groupings
    of the signals that must pass between the three subsystems. A given bus implementation
    might not have physically separate paths for each of the three types of signals.
    For example, if you have ever installed a graphics card in a computer, it probably
    used the Peripheral Component Interconnect Express (PCI-E) bus. The same physical
    connections on the PCI-E bus carry addresses and data, but at different times.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating and Executing a Program**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *program* consists of a sequence of machine instructions stored in memory.
    A *machine instruction* causes the computer to perform a specific operation and
    can be thought of as the native language of the computer.
  prefs: []
  type: TYPE_NORMAL
- en: When we create a new program, we use an *editor* to write the *source code*
    for the program, usually in a high-level language such as Python, Java, C++, or
    C. Python continues to be one of the top programming languages. It’s also the
    most commonly used language for programming the Raspberry Pi.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a program in Python, we use an editor to write the program and store
    it in a source code file. Then, we use the `python` command to execute our program.
    For example, to execute the Python program called *my_program.py*, we would use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This command invokes the Python program, which is an *interpreter* that translates
    each Python language statement into machine instructions and tells the computer
    to execute it. Each time we want to execute our program, we need to use the `python`
    command to interpret our source code and execute it.
  prefs: []
  type: TYPE_NORMAL
- en: Python and other interpreted languages do a good job of hiding the machine language
    from us. However, our goal in this book is to see how a program uses machine language
    to control the computer, so we’ll use C for our programming, which will make it
    easier for us to see the machine code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with Python, we use an editor to write a program in C and store it in a
    source code file. We then use a *compiler* to translate the C source code into
    machine language. Instead of translating and executing each statement one at a
    time, a compiler considers all the statements in a source code file when figuring
    out how to best translate them into machine code. The resulting machine code is
    stored in an *object* file. One or more object files can be linked together to
    produce an *executable* file, which is what we use to run our program. For example,
    we can compile a program named *my_program.c* with the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To execute our program, we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Don’t worry if you don’t know C. I’ll explain the features we need as we go
    through the book.
  prefs: []
  type: TYPE_NORMAL
- en: Whether they come from an interpreter program or an executable file, the machine
    instructions that make up the program are loaded into memory. Most programs include
    some constant data that is also loaded into memory. The CPU executes the program
    by reading, or *fetching*, each instruction from memory and executing it. The
    data is also fetched as needed by the program.
  prefs: []
  type: TYPE_NORMAL
- en: When the CPU is ready to execute the next instruction in the program, the location
    of that instruction in memory is placed on the address bus. The CPU also places
    a *read* signal on the control bus. The memory subsystem responds by placing the
    instruction on the data bus, from where the CPU can copy it. The same sequence
    of events takes place if the CPU is instructed to read data from memory.
  prefs: []
  type: TYPE_NORMAL
- en: If the CPU is instructed to store data in memory, it places the data on the
    data bus, places the location in memory where the data is to be stored on the
    address bus, and places a *write* signal on the control bus. The memory subsystem
    responds by copying the data on the data bus into the specified memory location.
  prefs: []
  type: TYPE_NORMAL
- en: Most programs also access I/O devices. Some of these are meant to interact with
    humans, such as a keyboard, mouse, or screen. Others are meant for machine-readable
    I/O, such as a disk. I/O devices are very slow compared to the CPU and memory,
    and they vary widely in their timing characteristics. Because of their timing
    characteristics, data transfers between I/O devices and the CPU and memory must
    be explicitly programmed.
  prefs: []
  type: TYPE_NORMAL
- en: Programming an I/O device requires a thorough understanding of how the device
    works and how it interacts with the CPU and memory. We’ll look at some of the
    general concepts near the end of the book. Meanwhile, nearly every program we
    write in this book will use at least the terminal screen, which is an output device.
    The operating system includes functions to perform I/O, and the C runtime environment
    provides a library of application-oriented functions to access the operating system’s
    I/O functions. We’ll use these C library functions to perform most of our I/O
    operations and leave I/O programming to more advanced books.
  prefs: []
  type: TYPE_NORMAL
- en: These few paragraphs are intended to provide you with a general overview of
    how computer hardware is organized. Before exploring these concepts in more depth,
    the next section will help you set up the tools you’ll need for the programming
    covered in the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Programming Environment**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, I’ll describe how I set up my Raspberry Pi to do all the programming
    described in this book. If you’re setting up a Raspberry Pi, I also recommend
    reading the “Set Up Your Raspberry Pi” section of the Raspberry Pi documentation
    at *[https://www.raspberrypi.com/documentation/computers/getting-started.html](https://www.raspberrypi.com/documentation/computers/getting-started.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: I’m using the officially supported operating system, Raspberry Pi OS, which
    is based on the Debian distribution of Linux. You must use the 64-bit version
    for the programming in this book; the 32-bit version will not work. Other operating
    systems available for the Raspberry Pi may not support the programming we’ll be
    doing.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a hard drive or solid-state drive, the Raspberry Pi uses a micro
    SD card for secondary storage. I used Raspberry Pi Imager to set up my micro SD
    card (it’s available at *[https://www.raspberrypi.com/software/](https://www.raspberrypi.com/software/)*,
    with a short video showing how this is done). When you run Raspberry Pi Imager,
    select **Raspberry Pi OS (other)** and then **Raspberry Pi OS Full (64-bit)**.
  prefs: []
  type: TYPE_NORMAL
- en: The full version includes software tools you’ll need for the programming in
    this book. You should use the latest version and keep your system updated. This
    might install newer versions of the software development tools than are available
    at the time of writing this book. You may see some differences from the code listings
    in the book, but any variations should be small.
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi OS uses the `bash` shell program to accept keyboard commands and
    pass them to the operating system. If you’re new to the command line, I’ll show
    you the basic commands you need as we go through the book. You’ll be much more
    productive if you take the time to become familiar with using the command line.
    To learn more, I recommend William Shotts’s *The Linux Command Line*, 2nd edition
    (No Starch Press, 2019).
  prefs: []
  type: TYPE_NORMAL
- en: You should also become familiar with the documentation provided in Linux for
    the programming tools we’ll be using. The simplest is the help system built into
    most programs. You access help by typing the name of the program with only the
    `--help` option. For example, `gcc --help` brings up a list of the command line
    options you can use with `gcc`, with a brief description of what each does.
  prefs: []
  type: TYPE_NORMAL
- en: Most Linux programs include a manual, usually called a *man page*, that provides
    more complete documentation than the help facility. You can read it by using the
    `man` command followed by the name of the program. For example, `man man` brings
    up the man page for the `man` program.
  prefs: []
  type: TYPE_NORMAL
- en: 'GNU programs come with even more complete documentation that can be read with
    the `info` program. You can install the Raspberry Pi OS `info` package on your
    system with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it’s installed, you can read about `info` with the following command,
    which generates the output shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Items beginning with `*` and ending with `::` are hyperlinks to other pages
    in the manual. Use the arrow keys on your keyboard to put the cursor any place
    within such an item and press ENTER to bring up that page.
  prefs: []
  type: TYPE_NORMAL
- en: 'I had to install the following Raspberry Pi OS packages to get the `info` documentation
    for the programming tools we’ll be using:'
  prefs: []
  type: TYPE_NORMAL
- en: binutils-doc   This adds useful documentation for the GNU assembler `as` (sometimes
    called `gas`).
  prefs: []
  type: TYPE_NORMAL
- en: gcc-doc   This adds useful documentation for the GNU `gcc` compiler.
  prefs: []
  type: TYPE_NORMAL
- en: The packages you need to get these features may differ depending on the version
    of the operating system you are using.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, I’ve compiled the programs with no optimization (the `-O0` option)
    because the goal is to study concepts, not to create the most efficient code.
    The examples should work with most versions of `gcc`, `g++`, and `as` that are
    installed with Raspberry Pi OS. However, the machine code generated by the compiler
    may differ, depending on its specific configuration and version. You will begin
    seeing compiler-generated assembly language about halfway through the book. Any
    differences should be consistent as you continue through the rest of the book.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to use a text editor for your programming. Do not use a word processor.
    Word processors add a lot of hidden control characters to format the text. These
    hidden characters confuse compilers and assemblers, causing them to not work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several excellent text editors exist for the Raspberry Pi, each with its own
    personality. I recommend trying several and deciding which one you prefer. A few
    options are preinstalled with Raspberry Pi OS. If you right-click a text file,
    you will get your choice of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Geany**   This is the default editor for programming. It opens if you simply
    double-click a source code file. The Geany editor provides many useful features
    in an integrated development environment (IDE).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Text Editor**   The actual editor is Mousepad. It’s a very minimal editor
    lacking many features that are useful for writing program code.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vim**   The Vim editor is an improved version of the Vi editor, which was
    created for Unix in 1976\. It provides a command line user interface that is mode-oriented.
    Text is manipulated through keyboard commands. Several commands place Vim in “text
    insert” mode. The ESC key is used to return to command mode.'
  prefs: []
  type: TYPE_NORMAL
- en: Raspberry Pi OS also comes with the Thonny IDE preinstalled. The tools it includes
    are intended primarily for Python programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another popular editor is Emacs. You can install it on your Raspberry Pi with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can use Emacs from the command line or through a graphical user interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'My favorite editor is Visual Studio Code (VS Code). VS Code is free and available
    for all common platforms; you can learn more about it at *[https://code.visualstudio.com](https://code.visualstudio.com)*.
    It’s also in the Raspberry Pi OS package repositories and can be installed with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When installed, it shows up as Visual Studio Code when you right-click a text
    file. VS Code uses a graphic user interface for editing. It also allows you to
    open a terminal window to use the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The names of the programs mentioned here are `geany`, `mousepad`, `vim`, `thonny`,
    `emacs`, and `code`. To launch any of these editors from the command line, give
    the name of the program followed by the name of the file you wish to open. For
    example, you can use VS Code to create the Python program in “Your Turn” [exercise
    1.1](ch01.xhtml#ch1exe1) with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If the file *hello_world.py* does not yet exist, VS Code will create it when
    you save your work. If the file does exist, VS Code will open it for you to work
    on.
  prefs: []
  type: TYPE_NORMAL
- en: I installed VS Code on my Windows 11 laptop. It allows me to log on to my Raspberry
    Pi, do all my editing in the editing panel, and open a terminal panel for compiling
    and executing my programs. You don’t need to install VS Code on your Raspberry
    Pi for this.
  prefs: []
  type: TYPE_NORMAL
- en: Geany, Vim, and VS Code are all good choices for the programming covered in
    this book. If you’re already comfortable with a text editor on the Raspberry Pi,
    I recommend sticking with that. Don’t spend too much time trying to pick the “best”
    one.
  prefs: []
  type: TYPE_NORMAL
- en: '**YOUR TURN**'
  prefs: []
  type: TYPE_NORMAL
- en: 1.1     Make sure that you understand the Raspberry Pi you’ll be using for the
    programming in this book. What CPU does it use? How much memory does it have?
    What are the I/O devices connected to it? Which editor will you be using?
  prefs: []
  type: TYPE_NORMAL
- en: '1.2     Create the following Python program in a file named *hello_world.py*
    and execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: What files were created in this exercise?
  prefs: []
  type: TYPE_NORMAL
- en: '1.3     Write the following C program in a file named *hello_world.c*, then
    compile and execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: What files were created in this exercise?
  prefs: []
  type: TYPE_NORMAL
- en: '**What You’ve Learned**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Central processing unit (CPU)**  The subsystem that controls most of the
    activities of the computer. It also contains a small amount of very fast memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Memory**   The subsystem that provides storage for programs and data.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input/output (I/O)**   The subsystem that provides a means of communication
    with the outside world and with mass storage devices.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bus**   A communication pathway between the CPU, memory, and I/O.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Program execution**   An overview of how the three subsystems and the buses
    are used when a program is run.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Programming environment**   An example of how to set up the tools needed
    to do the programming in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will start learning how data is stored in a computer,
    get an introduction to programming in C, and start learning how to use the debugger
    as a learning tool.
  prefs: []
  type: TYPE_NORMAL
