- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 12 CREATING FUNCTIONS AND PACKAGES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you will learn how to define your own R functions, including
    the parameters they should accept. Then, you’ll create a package to distribute
    those functions, add your code and dependencies to it, write its documentation,
    and choose the license under which to release it.
  prefs: []
  type: TYPE_NORMAL
- en: Saving your code as custom functions and then distributing them in packages
    can have numerous benefits. First, packages make your code easier for others to
    use. For example, when researchers at the Moffitt Cancer Center needed to access
    code from a database, data scientists Travis Gerke and Garrick Aden-Buie used
    to write R code for each researcher, but they quickly realized they were reusing
    the same code over and over. Instead, they made a package with functions for accessing
    databases. Now researchers no longer had to ask for help; they could simply install
    the package Gerke and Aden-Buie had made and use its functions themselves.
  prefs: []
  type: TYPE_NORMAL
- en: What’s more, developing packages allows you to shape how others work. Say you
    make a ggplot theme that follows the principles of high-quality data visualization
    discussed in [Chapter 3](chapter3.xhtml). If you put this theme in a package,
    you can give others an easy way to follow these design principles. In short, functions
    and packages help you work with others using shared code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Your Own Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hadley Wickham, developer of the tidyverse set of packages, recommends creating
    a function once you’ve copied some code three times. Functions have three pieces:
    a name, a body, and arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Simple Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ll begin by writing an example of a relatively simple function. This function,
    called show_in_excel_penguins(), opens the penguin data from [Chapter 7](chapter7.xhtml)
    in Microsoft Excel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code first loads the tidyverse and fs packages. You’ll use tidyverse to
    create a filename for the CSV file and save it, and fs to open the CSV file in
    Excel (or whichever program your computer uses to open CSV files by default).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the read_csv() function imports the penguin data and names the data frame
    penguins ❶. Then it creates the new show_in_excel_penguins function, using the
    assignment operator (<-) and function() to specify that show_in_excel_penguins
    isn’t a variable name but a function name ❷. The open curly bracket ({) at the
    end of the line indicates the start of the function body, where the “meat” of
    the function can be found. In this case, the body does three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a location for a CSV file to be saved using the str_glue() function
    combined with the tempfile() function. This creates a file at a temporary location
    with the *.csv* extension and saves it as csv_file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writes penguins to the location set in csv_file. The x argument in write _csv()
    refers to the data frame to be saved. It also specifies that all NA values should
    show up as blanks. (By default, they would display the text *NA*.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses the file_show() function from the fs package to open the temporary CSV
    file in Excel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use the show_in_excel_penguins() function, highlight the lines that define
    the function and then press COMMAND-ENTER on macOS or CTRL-ENTER on Windows. You
    should now see the function in your global environment, as shown in [Figure 12-1](chapter12.xhtml#fig12-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-1: The new function in the global environment'
  prefs: []
  type: TYPE_NORMAL
- en: From now on, any time you run the code show_in_excel_penguins(), R will open
    the penguins data frame in Excel.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Arguments
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You’re probably thinking that this function doesn’t seem very useful. All it
    does is open the penguins data frame. Why would you want to keep doing that? A
    more practical function would let you open *any* data in Excel so you can use
    it in a variety of contexts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The show_in_excel() function does just that: it takes any data frame from R,
    saves it as a CSV file, and opens the CSV file in Excel. Bruno Rodrigues, head
    of the Department of Statistics and Data Strategy at the Ministry of Higher Education
    and Research in Luxembourg, wrote show_in_excel() to easily share data with his
    non-R-user colleagues. Whenever he needed data in a CSV file, he could run this
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replace your show_in_excel_penguins() function definition with this slightly
    simplified version of the code that Rodrigues used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This code looks the same as show_in_excel_penguins(), with two exceptions. Notice
    that the first line now says function(data). Items listed within the parentheses
    of the function definition are arguments. If you look farther down, you’ll see
    the second change. Within write_csv(), instead of x = penguins, it now says x
    = data. This allows you to use the function with any data, not just penguins.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this function, you simply tell show_in_excel() what data to use, and
    the function opens the data in Excel. For example, tell it to open the penguins
    data frame as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Having created the function with the data argument, now you can run it with
    any data you want to. This code, for example, imports the COVID case data from
    [Chapter 10](chapter10.xhtml) and opens it in Excel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use show_in_excel() at the end of a pipeline. This code filters
    the covid_data data frame to include only data from California before opening
    it in Excel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Rodrigues could have copied the code within the show_in_excel() function and
    rerun it every time he wanted to view his data in Excel. But, by creating a function,
    he was able to write the code just once and then run it as many times as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Function to Format Race and Ethnicity Data
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hopefully now you better understand how functions work, so let’s walk through
    an example function you could use to simplify some of the activities from previous
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 11](chapter11.xhtml), when you used the tidycensus package to automatically
    import data from the US Census Bureau, you learned that the census data has many
    variables with nonintuitive names. Say you regularly want to access data about
    race and ethnicity from the American Community Survey, but you can never remember
    which variables enable you to do so. To make your task more efficient, you’ll
    create a get_acs_race_ethnicity() function step-by-step in this section, learning
    some important concepts about custom functions along the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'A first version of the get_acs_race_ethnicity() function might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Within the function body, this code calls the get_acs() function from tidycensus
    to retrieve population data at the state level. But instead of returning the function’s
    default output, it updates the hard-to-remember variable names to human-readable
    names, such as White and Black/African American, and saves them as an object called
    race_ethnicity_data. The code then uses the race_ethnicity_data object to return
    that data when the get_acs_race_ethnicity() function is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run this function, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing so should return data with easy-to-read race and ethnicity group names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You could improve this function in a few ways. You might want the resulting
    variable names to follow a consistent syntax, for example, so you could use the
    clean_names() function from the janitor package to format them in *snake case*
    (in which all words are lowercase and separated by underscores). However, you
    might also want to have the option of keeping the original variable names. To
    accomplish this, add the clean_variable_names argument to the function definition
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This code adds the clean_variable_names argument to get_acs_race _ethnicity()
    and specifies that its value should be FALSE by default. Then, in the function
    body, an if statement says that if the argument is TRUE, the variable names should
    be overwritten by versions formatted in snake case ❶. If the argument is FALSE,
    the variable names remain unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the function now, nothing should change, because the new argument
    is set to FALSE by default. Try setting clean_variable_names to TRUE as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This function call should return data with consistent variable names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that GEOID and NAME now appear as geoid and name.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen how to add arguments to two separate functions, you’ll
    learn how to pass arguments from one function to another.
  prefs: []
  type: TYPE_NORMAL
- en: Using ... to Pass Arguments to Another Function
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The get_acs_race_ethnicity() function you’ve created retrieves population data
    at the state level by passing the geography = "state" argument to the get_acs()
    function. But what if you wanted to obtain county-level or census tract data?
    You could do so using get_acs(), but get_acs_race_ethnicity() isn’t currently
    written in a way that would allow this. How could you modify the function to make
    it more flexible?
  prefs: []
  type: TYPE_NORMAL
- en: 'Your first idea might be to add a new argument for the level of data to retrieve.
    You could edit the first two lines of the function as follows to add a my_geography
    argument and then use it in the get_acs() function like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: But what if you also want to select the year for which to retrieve data? Well,
    you could add an argument for that as well. However, as you saw in [Chapter 11](chapter11.xhtml),
    the get_acs() function has many arguments, and repeating them all in your code
    would quickly become cumbersome.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ... syntax gives you a more efficient option. Placing ... in the get_acs_race_ethnicity()
    function allows you to automatically pass any of its arguments to get_acs() by
    including ... in that function as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Try running your function by passing it the geography argument set to "state":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You’ll see that the GEOID and NAME variables are uppercase because the clean_variable_names
    argument is set to FALSE by default, and we didn’t change it when using the get_acs_race_ethnicity()
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you could change the value of the argument to get data by county:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also run the function with the geometry = TRUE argument to return
    geospatial data alongside demographic data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The function should return data like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The ... syntax allows you to create your own function and pass arguments from
    it to another function without repeating all of that function’s arguments in your
    own code. This approach gives you flexibility while keeping your code concise.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at how to put your custom functions into a package.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Package
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Packages bundle your functions so you can use them in multiple projects. If
    you find yourself copying functions from one project to another, or from a *functions.R*
    file into each new project, that’s a good indication that you should make a package.
  prefs: []
  type: TYPE_NORMAL
- en: While you can run the functions from a *functions.R* file in your own environment,
    this code might not work on someone else’s computer. Other users may not have
    the necessary packages installed, or they may be confused about how your functions’
    arguments work and not know where to go for help. Putting your functions in a
    package makes them more likely to work for everyone, as they include the necessary
    dependencies as well as built-in documentation to help others use the functions
    on their own.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the Package
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To create a package in RStudio, go to **File****New Project****New Directory**.
    Select **R Package** from the list of options and give your package a name. In
    [Figure 12-2](chapter12.xhtml#fig12-2), I’ve called mine dk. Also decide where
    you want your package to live on your computer. You can leave everything else
    as is.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig12-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12-2: The RStudio menu for creating your own package'
  prefs: []
  type: TYPE_NORMAL
- en: RStudio will now create and open the package. It should already contain a few
    files, including *hello.R*, which has a prebuilt function called hello() that,
    when run, prints the text Hello, world! in the console. You’ll get rid of this
    and a few other default files so you can start with a clean slate. Delete *hello.R*,
    *NAMESPACE*, and *hello.Rd* in the *man* directory.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Functions with use_r()
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All of the functions in a package should go in separate files in the *R* folder.
    To add these files to the package automatically and test that they work correctly,
    you’ll use the usethis and devtools packages. Install them using install.packages()
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a function to the package, run the use_r() function from the usethis
    package in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The package::function() syntax allows you to use a function without loading
    the associated package. The use_r() function should create a file in the *R* directory
    with the argument name you provide—in this case, the file is called *acs.R*. The
    name itself doesn’t really matter, but it’s a good practice to choose something
    that gives an indication of the functions the file contains. Now you can open
    the file and add code to it. Copy the get_acs_race_ethnicity() function to the
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the Package with devtools
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You need to change the get_acs_race_ethnicity() function in a few ways to make
    it work in a package. The easiest way to figure out what changes you need to make
    is to use built-in tools to check that your package is built correctly. Run the
    function devtools::check() in the console to perform what is known as an R CMD
    check, a command that runs under the hood to ensure others can install your package
    on their system. Running R CMD check on the dk package outputs this long message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The last part is the most important, so let’s review the output from bottom
    to top. The line 0 errors  | 2 warnings ｘ | 1 note ｘ highlights three levels
    of issues identified in the package. Errors are the most severe, as they mean
    others won’t be able to install your package, while warnings and notes may cause
    problems for others. It’s best practice to eliminate all errors, warnings, and
    notes.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by addressing the note at ❶. To help you understand what R CMD check
    is saying here, I need to explain a bit about how packages work. When you install
    a package using the install.packages() function, it often takes a while. That’s
    because the package you’re telling R to install likely uses functions from other
    packages. To access these functions, R must install these packages (known as *dependencies*)
    for you; after all, it would be a pain if you had to manually install a whole
    set of dependencies every time you installed a new package. But to make sure that
    the appropriate packages are installed for any user of the dk package, you still
    have to make a few changes.
  prefs: []
  type: TYPE_NORMAL
- en: R CMD check is saying this package includes several “undefined global functions
    or variables” and “no visible global function definition” for various functions.
    This is because you’re trying to use functions from the tidycensus and janitor
    packages, but you haven’t specified where these functions come from. I can run
    this code in my environment because I have tidycensus and janitor installed, but
    you can’t assume the same of everyone.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Dependency Packages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To ensure the package’s code will work, you need to install tidycensus and
    janitor for users when they install the dk package. To do this, run the use_package()
    function from the usethis package in the console, first specifying "tidycensus"
    for the package argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The Setting active project... line indicates that you’re working in the dk project.
    The second line indicates that the *DESCRIPTION* file has been edited. This file
    provides metadata about the package you’re developing.
  prefs: []
  type: TYPE_NORMAL
- en: Next, add the janitor package the same way you added tidyverse
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'which should give you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If you open the *DESCRIPTION* file in the root directory of your project, you
    should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The Imports section at the bottom of the file indicates that when a user installs
    the dk package, the tidycensus and janitor packages will also be imported.
  prefs: []
  type: TYPE_NORMAL
- en: Referring to Functions Correctly
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The output from running usethis::use_package(package = "janitor") also included
    the line Refer to functions with tidycensus::fun() (where fun() stands for function
    name). This tells you that in order to use functions from other packages in the
    dk package, you need to specify both the package name and the function name to
    ensure that the correct function is used at all times. On rare occasions, you’ll
    find functions with identical names used across multiple packages, and this syntax
    avoids ambiguity. Remember this line from the R CMD check?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It appeared because you were using functions without saying what package they
    came from. The clean_names() function comes from the janitor package, and get_acs()
    comes from tidycensus, so you will need to add these package names before each
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can run devtools::check() again, and you should see that the notes
    have gone away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: However, there are still two warnings to deal with. You’ll do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Documentation with Roxygen
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The checking for missing documentation entries warning indicates that you need
    to document your get_acs_race_ethnicity() function. One of the benefits of creating
    a package is that you can add documentation to help others use your code. In the
    same way that users can enter ?get_acs() and see documentation about that function,
    you want them to be able to enter ?get_acs_race_ethnicity() to learn how your
    function works.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create documentation for get_acs_race_ethnicity(), you’ll use Roxygen, a
    documentation tool that uses a package called roxygen2. To get started, place
    your cursor anywhere in your function. Then, in RStudio go to **Code** **Insert
    Roxygen Skeleton**. This should add the following text before the get _acs_race_ethnicity()
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This text is the documentation’s skeleton. Each line starts with the special
    characters #'', which indicate that you’re working with Roxygen. Now you can edit
    the text to create your documentation. Begin by replacing Title with a sentence
    that describes the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, turn your attention to the lines beginning with @param. Roxygen automatically
    creates one of these lines for each function argument, but it’s up to you to fill
    them in with a description. Begin by describing what the clean_variable_names
    argument does. Next, specify that the ... will pass additional arguments to the
    tidycensus::get_acs() function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The @return line should tell the user what the get_acs_race_ethnicity() function
    returns. In this case, it returns data, which you document as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: After @return is @export. You don’t need to change anything here. Most functions
    in a package are known as *exported functions*, meaning they’re available to users
    of the package. In contrast, internal functions, which are used only by the package
    developers, don’t have @export in the Roxygen skeleton.
  prefs: []
  type: TYPE_NORMAL
- en: The last section is @examples. This is where you can give examples of code that
    users can run to learn how the function works. Doing this introduces some complexity
    and isn’t required, so you can skip it here and delete the line with @examples
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*If you want to learn more about adding examples to your documentation, the
    second edition of Hadley Wickham and Jenny Bryan’s book* R Packages *is a great
    resource.*'
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve added documentation with Roxygen, run devtools::document() in
    the console. This should create a *get_acs_race_ethnicity.Rd* documentation file
    in the *man* directory using the very specific format that R packages require.
    You’re welcome to look at it, but you can’t change it; it’s read-only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the function should also create a *NAMESPACE* file, which lists the
    functions that your package makes available to users. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Your get_acs_race_ethnicity() function is now almost ready for users.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a License and Metadata
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Run devtools::check() again to see if you’ve fixed the issues that led to the
    warnings. The warning about missing documentation should no longer be there. However,
    you do still get one warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This warning reminds you that you have not given your package a license. If
    you plan to make your package publicly available, choosing a license is important
    because it tells other people what they can and cannot do with your code. For
    information about how to choose the right license for your package, see *[https://choosealicense.com](https://choosealicense.com)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, you’ll use the MIT license, which allows users to do essentially
    whatever they want with your code, by running usethis::use_mit_license(). The
    usethis package has similar functions for other common licenses. You should get
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The use_mit_license() function handles a lot of the tedious parts of adding
    a license to your package. Most importantly for our purposes, it specifies the
    license in the *DESCRIPTION* file. If you open it, you should see this confirmation
    that you’ve added the MIT license:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the license, the *DESCRIPTION* file contains metadata about
    the package. You can make a few changes to identify its title and add an author,
    a maintainer, and a description. The final *DESCRIPTION* file might look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Having made these changes, run devtools::check() one more time to make sure
    everything is in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly what you want to see!
  prefs: []
  type: TYPE_NORMAL
- en: Writing Additional Functions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ve now got a package with one working function in it. If you wanted to
    add more functions, you would follow the same procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Create a new *.R* file with usethis::use_r() or copy another function to
    the existing *.R* file.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Develop your function using the package::function() syntax to refer to functions
    from other packages.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Add any dependency packages with use_package().
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Add documentation for your function.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Run devtools::check() to make sure you did everything correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Your package can contain a single function, like dk, or as many functions as
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Package
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you’re ready to install and use the new package. When you’re developing
    your own package, installing it for your own use is relatively straightforward.
    Simply run devtools::install(), and the package will be ready for you to use in
    any project.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you’re developing a package, you’re likely doing it not just for
    yourself but for others as well. The most common way to make your package available
    to others is with the code-sharing website GitHub. The details of how to put your
    code on GitHub are beyond what I can cover here, but the book *Happy Git and GitHub
    for the useR* by Jenny Bryan (self-published at *[https://happygitwithr.com](https://happygitwithr.com)*)
    is a great place to start.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve pushed the dk package to GitHub, and you can find it at *[https://github.com/dgkeyes/dk](https://github.com/dgkeyes/dk)*.
    If you’d like to install it, first make sure you have the remotes package installed,
    then run the code remotes::install_github("dgkeyes/dk") in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this chapter, you saw that packages are useful because they let you bundle
    several elements needed to reliably run your code: a set of functions, instructions
    to automatically install dependency packages, and code documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own R package is especially beneficial when you’re working for
    an organization, as packages can allow advanced R users to help colleagues with
    less experience. When Travis Gerke and Garrick Aden-Buie provided researchers
    at the Moffitt Cancer Center with a package that contained functions for easily
    accessing their databases, the researchers began to use R more creatively.
  prefs: []
  type: TYPE_NORMAL
- en: If you create a package, you can also guide people to use R in the way you think
    is best. Packages are a way to ensure that others follow best practices (without
    even being aware they are doing so). They make it easy to reuse functions across
    projects, help others, and adhere to a consistent style.
  prefs: []
  type: TYPE_NORMAL
- en: Additional Resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Malcolm Barrett, “Package Development with R,” online course, accessed December
    2, 2023, *[https://rfortherestofus.com/courses/package-development](https://rfortherestofus.com/courses/package-development)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hadley Wickham and Jennifer Bryan, *R Packages*, 2nd ed. (Sebastopol, CA: O’Reilly
    Media, 2023), *[https://r-pkgs.org](https://r-pkgs.org)*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: R was invented in 1993 as a tool for statistics, and in the years since, it
    has been used for plenty of statistical analysis. But over the last three decades,
    R has also become a tool that can do much more than statistics.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen in this book, R is great for making visualizations. You can use
    it to create high-quality graphics and maps, make your own theme to keep your
    visuals consistent and on-brand, and generate tables that look good and communicate
    well. Using R Markdown or Quarto, you can create reports, presentations, and websites.
    And best of all, these documents are all reproducible, meaning that updating them
    is as easy as rerunning your code. Finally, you’ve seen that R can help you automate
    how you access data, as well as assist you in collaborating with others through
    the functions and packages you create.
  prefs: []
  type: TYPE_NORMAL
- en: If R was new to you when you started this book, I hope you now feel inspired
    to use it. If you’re an experienced R user, I hope this book has shown you some
    ways to use R that you hadn’t previously considered. No matter your background,
    my hope is that you now understand how to use R like a pro. Because it isn’t just
    a tool for statisticians—R is a tool for the rest of us too.
  prefs: []
  type: TYPE_NORMAL
