- en: '**22  Mask ROM Photography**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some chips store their program bits as markings on the masks that lithographically
    draw the microchip. We call this a mask ROM, to distinguish it from EEPROM, flash
    ROM, and other field-programmable technologies. In this chapter, we’ll go over
    the theory behind photographing these ROMs to extract their bits, and in the following
    chapters we’ll work out examples of real targets from beginning to end.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mask ROMs come in three types: via, diffusion, and implant. These are quite
    different chemically and physically, but in extracting them, we just need to understand
    them well enough to make the bits visible. [Table 22.1](ch22.xhtml#ch22tab1) lists
    a number of microcontrollers and their ROM processes.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Via* or *contact* ROMs use a via between layers to mark a bit. These aren’t
    very efficient for layout space, but they are quite easy to decode because the
    bits are clearly visible when you find them. Many of them, such as those in the
    Nintendo Game Boy, are even visible from the surface without delayering!'
  prefs: []
  type: TYPE_NORMAL
- en: '*Diffusion* ROMs are lower in the chip. Bits here are marked by the presence
    of a diffusion pool making a working transistor, or the absence of the diffusion
    pool breaking that transistor. Because they are so low, you almost always need
    to delayer the chip to see them, but there’s little risk of damaging the chip
    during the process.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Implant* ROMs are the most frustrating of these three. Bits are encoded by
    an additional ion implant in an otherwise working transistor, and by some infernal
    coincidence the damaged and undamaged transistors are exactly the same color!
    These ROMs generally require delayering to the inside of the bits, then staining
    a difference into their coloring with a Dash etch, which we will discuss shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: '|  Model  | ROM Type |'
  prefs: []
  type: TYPE_TB
- en: '| TMS1000 | Via |'
  prefs: []
  type: TYPE_TB
- en: '| Game Boy | Via |'
  prefs: []
  type: TYPE_TB
- en: '| T44C080C | Via |'
  prefs: []
  type: TYPE_TB
- en: '| TMS320C15 | Via |'
  prefs: []
  type: TYPE_TB
- en: '| MSP430F1, F2, F4 | Via |'
  prefs: []
  type: TYPE_TB
- en: '| 6500/1 | Diffusion |'
  prefs: []
  type: TYPE_TB
- en: '| EMZ1001 | Diffusion |'
  prefs: []
  type: TYPE_TB
- en: '| MYK82 | Diffusion |'
  prefs: []
  type: TYPE_TB
- en: '| Tengen Rabbit | Diffusion |'
  prefs: []
  type: TYPE_TB
- en: '| TMS32C10NL | Diffusion |'
  prefs: []
  type: TYPE_TB
- en: '| HCS300 | Diffusion |'
  prefs: []
  type: TYPE_TB
- en: '| Z8 | Diffusion |'
  prefs: []
  type: TYPE_TB
- en: '| SM590 | Implant |'
  prefs: []
  type: TYPE_TB
- en: '| MK3870 | Implant |'
  prefs: []
  type: TYPE_TB
- en: '| TLCS-47 (TMP47) | Implant |'
  prefs: []
  type: TYPE_TB
- en: 'Table 22.1: Example ROM Types'
  prefs: []
  type: TYPE_NORMAL
- en: There are of course as many ways to encode bits as there are unique shapes invented
    by the silicon wizards. I use these broad categories to describe the effort required
    for bit extraction, but there are of course ROMs with markings on the metal layers
    instead of the via layer, which are also surface visible. Like anything in reverse
    engineering, let’s use this abstraction until it ceases to be useful, then dig
    a little deeper to see what’s inside.
  prefs: []
  type: TYPE_NORMAL
- en: '**Microscopy**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once the chip is ready, we’ll need to photograph it.
  prefs: []
  type: TYPE_NORMAL
- en: You will need a metallurgical microscope, which is one in which the column of
    light comes down through the lens to reflect back from the die. Microscopes that
    send light up through the sample are great for biology, but they will not help
    to photograph an opaque microchip.
  prefs: []
  type: TYPE_NORMAL
- en: A camera is also required. While it’s possible to get decent pictures from a
    lens adapter on a monocular microscope, it’s much easier to use a trinocular scope
    so that your own eyes can find the target and the camera is only required at the
    end for the photos.
  prefs: []
  type: TYPE_NORMAL
- en: It’s generally impossible to zoom out enough to keep the whole image in frame
    while also keeping its details in focus, so we instead photograph a series of
    shots that overlap one another. These can be combined after the fact with panorama
    software, such as Hugin.
  prefs: []
  type: TYPE_NORMAL
- en: This photography can be quite tedious at the limits of your scope’s capabilities,
    so I generally try to first make a whole-chip panorama at minimum magnification
    and then follow that with high-magnification panoramas of my area of interest,
    such as the ROM. A million thanks to John McMaster for selling me a microscope
    with a motorized stage, so all of my photographs now have consistent spacing and
    filenames that indicate the row and column.
  prefs: []
  type: TYPE_NORMAL
- en: '**Delayering with Hydrofluoric Acid**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To delayer a chip, I heat it in dilute hydrofluoric acid (HF), which is available
    over the counter in the States as Whink or Rust-Go branded rust stain remover.
  prefs: []
  type: TYPE_NORMAL
- en: Hydrofluoric acid is dangerous to your bones, and it will damage them without
    giving the courtesy of much skin pain. Be very careful if you mess with this stuff,
    and do not skimp on safety.^([1](footnotes.xhtml#ch22fn1)) Another hassle with
    hydrofluoric acid is that we are using it because it attacks glass, so we can’t
    very well use a glass beaker to hold the reaction. Plastic beakers, or plastic
    centrifuge tubes, are critical here.
  prefs: []
  type: TYPE_NORMAL
- en: As the HF attacks your target, you’ll see some bubbles as it reacts to metals.
    The first flurry of bubbles usually indicates the top metal layer, and in reactions
    where you need to get a particular depth into the chip, it’s often handy to delayer
    many chips at once and to sort them after the fact to find your right depth.
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that the metal layers lift off of the chip rather than dissolving
    into a liquid. A little agitation is helpful to get these away from the die, so
    that they don’t mask your delayering reactions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dash Etching for Implant ROMs**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For implant ROMs, where the bits are identical in color, we need to give them
    different colors in order to photograph them. This is accomplished after delayering
    by a Dash etch, which is best described in Beck (1998) and McMaster (2019).
  prefs: []
  type: TYPE_NORMAL
- en: Delayering here can be quite confusing, as you can’t really see how close we
    are to the implants that we’d like to photograph. It might help to delayer many
    samples, returning those that haven’t been sufficiently delayered to the bath.
  prefs: []
  type: TYPE_NORMAL
- en: The Dash etch consists of three parts. Hydrofluoric acid and nitric acid attack
    the silicon, while acetic acid (HAc) buffers the reaction to slow it down. When
    the ratios are right, p-type doping will slightly tip this reaction in favor of
    oxidization, causing the p-type silicon to turn brown faster than the n-type silicon
    does.
  prefs: []
  type: TYPE_NORMAL
- en: I perform this with John McMaster’s Rust-Go solution, which is made from 3mL
    of 65% HNO[3], 4mL of 12% HF (Rust-Go), and 8mL of acetic acid. The final proportions
    are roughly 4.3% HNO[3] and 3.2% HF; the remainder of the solution is HAc and
    H[2]O to buffer the reaction.
  prefs: []
  type: TYPE_NORMAL
- en: Beck recommends a solution of 3mL 65% HNO[3], 1mL 48% HF, and 10 mL to 12 mL
    98% HAc. McMaster himself has moved on to this mixture, and I only hesitate to
    follow because HF is a nasty poison.^([2](footnotes.xhtml#ch22fn2))
  prefs: []
  type: TYPE_NORMAL
- en: Whichever solution is used, the already delayered die is placed into it under
    a bright light, such as that from a halogen fiber lamp. A minute or two under
    the light will darken the chip in splotches, and if you’re lucky, the ones will
    stand out as much darker than the zeroes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0208-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22.1: TMP47C434N Implant ROM'
  prefs: []
  type: TYPE_NORMAL
- en: It is absolutely critical to keep the metal content low during these reactions.
    You mustn’t have any metal salts from a delayering reaction on your glassware,
    and you mustn’t have any remnant of the lead frame beneath the die. Quite often,
    you can even see markings on the edge of the die from your tweezers during the
    reaction.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 22.1](ch22.xhtml#ch22fig1) shows the datasheet description of the TMP47C-434N’s
    font implant ROM, along with a die photograph from my lab after staining the bits
    with a Dash etch. Notice how the Dash etch leads to uneven contrast; some are
    much darker or lighter than others.'
  prefs: []
  type: TYPE_NORMAL
- en: '**From Photographs to Bits**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After capturing the bits photographically, it’s necessary to extract the bits
    digitally. One way to do this is by carefully writing them down, patiently marking
    each one or zero without losing your place or losing your mind. Another way is
    to let software do the boring work. “Work smarter, not harder,” as Coach Crigger
    would tell me back in high school.
  prefs: []
  type: TYPE_NORMAL
- en: An early public example of this is Rompar from Laurie (2013), a Python application
    written to mark the bits in a MARC4 microcontroller from a car’s key fob. More
    recently, Bitractor from Gerlinsky (2019) and my own Mask ROM Tool from Goodspeed
    (2024), both in C`++`. These three tools vary dramatically in their implementation
    and usage, but the general principle is to come up with a matrix of bit positions,
    then to sample the color of each bit to determine the difference between the ones
    and the zeroes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0210-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22.2: MYK82 Bits in the Diffusion Layer'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0210-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22.3: Color Distributions from the MYK82 ROM'
  prefs: []
  type: TYPE_NORMAL
- en: When you try this yourself, you will find that a naive sampling strategy is
    surprisingly effective. Most bits can be correctly decoded by a threshold in one
    color channel, usually red or green. It helps to improve those odds by drawing
    a histogram of samples in each color channel, to ensure that there is a clean
    bimodal separation between the ones and zeroes and that your threshold is set
    between the two groups.
  prefs: []
  type: TYPE_NORMAL
- en: For a concrete example, [Figure 22.2](ch22.xhtml#ch22fig2) shows a closeup of
    bits from the NSA’s MYK82 that we’ll discuss in detail and whose ROM we will dump
    in [Chapter 24](ch24.xhtml#ch24). You’ll see bits between the central squares
    and the horizontal wires as a rectangular box that’s darker than its surroundings.
    [Figure 22.3](ch22.xhtml#ch22fig3) shows just how much darker the ones are than
    the zeroes in the red channel, a total separation with no bits on the threshold
    and very few near it. Green has a separation that is nearly as good, but the blue
    channel shows no real separation.
  prefs: []
  type: TYPE_NORMAL
- en: In cases where a clean bimodal separation does not exist in any color channel,
    it can help to create one by image preprocessing or by sampling more than a single
    pixel. In my tool, I have sampling techniques that return the darkest of each
    color channel in a thin horizontal or vertical strip. This is particularly effective
    for over-etched diffusion ROMs, where bits have a bordering color but any color
    difference in the center of the bit has already been etched away.
  prefs: []
  type: TYPE_NORMAL
- en: While the available bit-marking tools have many differences, they have all standardized
    on ASCII art as an export format. Generally, the wider axis is arbitrarily defined
    as X to fit with computer monitor dimensions, and you can expect some rotations
    to be necessary before decoding the bits.
  prefs: []
  type: TYPE_NORMAL
- en: '**From Bits to Bytes**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After extracting the bits in the physical order, you’ll need to rearrange them
    into bytes in the logical order. Before we jump into the tools that make this
    less painful, let’s discuss a little about why the bits are in such a confusing
    order to begin with.
  prefs: []
  type: TYPE_NORMAL
- en: In natural languages, we have considerable variety in our writing. Some languages
    are written from left to right, while others are written from right to left. Some
    represent words by groups of letters, some use ideograms, and a few mix these
    concepts, building one larger symbol out of smaller ones to represent a word.
  prefs: []
  type: TYPE_NORMAL
- en: ROMs also have some common rules and infinite variety in the arrangement, but
    there is one concept that they almost never implement. They almost never group
    the bits of a byte together, instead preferring to scatter them into eight columns,
    separated from one another for physical convenience.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out the ordering of bits, one method is to very carefully study the
    bits of a ROM and to try out different patterns until they make sense. If you
    see 16 columns in a 16-bit microcontroller, for example, you might guess that
    one bit is taken from each column to make a word. Checking all of the words in
    both the top row and the bottom row might reveal an entry point of the program,
    making the entirety of the layout make sense.
  prefs: []
  type: TYPE_NORMAL
- en: Gerlinsky (2019) introduces BitViewer, a tool in [Figure 22.4](ch22.xhtml#ch22fig4)
    that graphically displays bits, adjusting their organization so that a human operator
    can explore their meaning. After loading a bitstream, you can choose how tall
    and wide bit pixels are, how much spacing to put between them, and how many to
    group into a major column. Bits are selected individually or grouped into columns
    and rows, allowing an operator to spot patterns that reveal the ROM contents.
    This is much less painful than doing the same on graph paper.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0213-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22.4: BitViewer from Gerlinsky (2019)'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0213-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 22.5: MaskRomTool from Goodspeed (2024)'
  prefs: []
  type: TYPE_NORMAL
- en: '|  cols-downl  | First bit is top left, then move down,'
  prefs: []
  type: TYPE_NORMAL
- en: then move right. |
  prefs: []
  type: TYPE_NORMAL
- en: '| cols-downr | First bit is top right, then move down,'
  prefs: []
  type: TYPE_NORMAL
- en: then move left. |
  prefs: []
  type: TYPE_NORMAL
- en: '| cols-left | First bit is top right, then move left,'
  prefs: []
  type: TYPE_NORMAL
- en: then move down. |
  prefs: []
  type: TYPE_NORMAL
- en: '| cols-right | First bit is top left, then move right,'
  prefs: []
  type: TYPE_NORMAL
- en: then move down. |
  prefs: []
  type: TYPE_NORMAL
- en: '| squeeze-lr | `byte&0xAA` use cols-left, `byte&0x55` use cols-right. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 22.2: Zorrom Decoding Strategies'
  prefs: []
  type: TYPE_NORMAL
- en: McMaster (2018) takes another approach in a program called Zorrom. It implements
    decoding strategies for a number of known chips, along with a series of transformations
    such as a flip on the X axis, rotating the bit matrix and inverting the bits.
    When you are lucky, which is about half the time, it can correctly solve the decoding
    given just the bits themselves and a guess at a few bits or bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Zorrom’s decoding strategies are listed in [Table 22.2](ch22.xhtml#ch22tab2).
    To apply a strategy, first divide the bit columns into eight groups and then sample
    one bit from each group to form a byte, with the least significant bit being the
    one on the left. So for the cols-downr strategy, your first byte would be formed
    from the top right bit of every group. Your second byte would have its bits just
    beneath those of the first, and after sampling a bit from every row of the groups,
    you would move one bit column to the right and start again from the top.
  prefs: []
  type: TYPE_NORMAL
- en: It doesn’t bother to support decoding strategies that start from the bottom
    of the group or that place the most significant bit on the left. These are handled
    by the existing strategies, after rotations and an optional flip on the X axis.
  prefs: []
  type: TYPE_NORMAL
- en: My own solution to bit decoding is called GatoROM, which runs both as a CLI
    tool and as a C`++` library. A GUI extension to my Mask ROM Tool from Goodspeed
    (2024) was then written using the library. It is shamelessly inspired by McMaster’s
    tool, implementing all of the necessary transformations for compatibility with
    his solver.
  prefs: []
  type: TYPE_NORMAL
- en: Used as a library, `void*` pointers allow a bidirectional association between
    the physically ordered bits and the logically ordered bytes of the ROM. You can
    select bytes in the hex viewer and then ask the software to highlight them in
    the GUI. This is incredibly handy when implementing new decoding strategies for
    chips that don’t quite fit the existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever tooling you use to decode a ROM, the end result is a flat binary file
    containing the bytes. When you first get a meaningful decoding, be a little suspicious
    of its ordering, as small ordering mistakes might not be noticed until the ROM
    is disassembled and reverse engineered.^([3](footnotes.xhtml#ch22fn3))
  prefs: []
  type: TYPE_NORMAL
