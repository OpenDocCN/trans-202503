- en: '**INTRODUCTION**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**简介**'
- en: '![Image](../images/common01.jpg)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common01.jpg)'
- en: I’m assuming that you’ve learned to use a programming language such as C, C++,
    Java, or Python . . . and I’m hoping that you’re hooked. It’s hard to explain
    to nonprogrammers why solving problems through programming is so rewarding and
    fun.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你已经学会了使用像 C、C++、Java 或 Python 这样的编程语言……并且我希望你已经被它吸引了。很难向非程序员解释为什么通过编程解决问题是如此有意义且有趣的。
- en: I’m also hoping that you’re ready to take your programming skill to the next
    level. I have the privilege of helping you do that.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我还希望你已经准备好将你的编程技能提升到一个新高度。我有幸帮助你做到这一点。
- en: What We’ll Do
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们将做什么
- en: I could start by teaching you some fancy new techniques, telling you why they’re
    useful, and comparing them to other fancy techniques, but I won’t. That material
    would lay inert, holding on for a little, waiting for the opportunity to spring
    into action—if in fact some opportunity ever did present itself.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以从教授你一些炫酷的新技巧开始，告诉你它们为何有用，并将它们与其他炫酷技巧进行比较，但我不会那样做。这些内容会被静置一旁，等待着某个机会来临——如果某个机会真能出现的话。
- en: 'Instead, what I do throughout this book is pose problems: hard problems. These
    are problems that I hope you cannot solve, problems that I hope stymie your current
    approaches. You’re a programmer. You want to solve problems. Now it’s time for
    learning those fancy techniques. This book is all about posing hard problems and
    then solving them by bridging between what you know and what you need.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在这本书中，我所做的就是提出问题：困难的问题。这些是我希望你无法解决的问题，是我希望会让你当前的方法陷入困境的问题。你是程序员，你想解决问题。现在是时候学习那些炫酷的技巧了。本书的全部内容就是提出难题，然后通过将你所知道的与你所需要的知识连接起来，解决这些问题。
- en: 'You won’t see traditional textbook problems here. You won’t find an optimal
    way to multiply a chain of matrices or compute Fibonacci numbers. I promise: you
    won’t solve the Towers of Hanoi puzzle. There are many excellent textbooks out
    there that do these things, but I suspect that many people are not motivated by
    those kinds of puzzles.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里你不会看到传统的教科书题目。你不会找到一个最优的矩阵链相乘方法，也不会计算斐波那契数列。我保证：你不会解决汉诺塔问题。市面上有很多优秀的教科书可以做这些事情，但我怀疑很多人并不会被这类谜题所吸引。
- en: My approach is to use new problems that you haven’t seen before. Each year,
    thousands of people participate in programming competitions, and these competitions
    require new problems to measure what participants can come up with on their own
    rather than who can google the fastest. These problems are fascinating, riffing
    on the classics while adding twists and context to challenge people to find new
    solutions. There is a seemingly endless stream of programming and computing knowledge
    encompassed by these problems. We can learn as much as we like by choosing the
    right problems.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我的做法是使用你之前未见过的新问题。每年，成千上万的人参加编程竞赛，这些竞赛需要新的问题来衡量参与者能独立解决什么问题，而不是看谁能最快地用谷歌搜索。这些问题很吸引人，它们在经典问题的基础上加入了新的转折和背景，挑战人们找到新的解决方案。这些问题涵盖了似乎无尽的编程和计算知识。我们可以通过选择合适的问题，尽情学习。
- en: Let’s start with some basics. A *data structure* is a way to organize data so
    that desirable operations are fast. An *algorithm* is a sequence of steps that
    solves a problem. Sometimes we can make fast algorithms without using sophisticated
    data structures; other times, the right data structure can offer a significant
    speed boost. My goal is not to turn you into a competitive programmer, though
    I’d take that as a happy side benefit. Rather, my goal is to teach you data structures
    and algorithms using problems from the competitive programming world—and to have
    fun while doing so. You can reach me at *[daniel.zingaro@gmail.com](mailto:daniel.zingaro@gmail.com)*.
    Email me if you have learned. Email me if you have laughed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些基础开始。*数据结构*是组织数据的一种方式，目的是让所需的操作更快。*算法*是解决问题的一系列步骤。有时我们可以在不使用复杂数据结构的情况下制作快速算法；而有时候，正确的数据结构能大大提升速度。我的目标不是将你培养成一名竞赛程序员，虽然我会把那当作一种愉快的副产品。相反，我的目标是通过竞赛编程中的问题来教授你数据结构和算法——并在这个过程中享受乐趣。你可以通过*
    [daniel.zingaro@gmail.com](mailto:daniel.zingaro@gmail.com) *联系我。如果你学到了东西，给我发邮件。如果你笑了，给我发邮件。
- en: New to the Second Edition
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二版新增内容
- en: I’ve thoroughly enjoyed the opportunity to discuss the first edition of this
    book with readers. Their feedback has led to many of the changes and improvements
    in this new edition.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常享受与读者讨论本书第一版的机会。他们的反馈促成了本新版本中的许多变化和改进。
- en: 'I’ve made small improvements and additions throughout, but here are the major
    highlights of what’s new:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我对全书做了一些小的改进和补充，但以下是一些重要的更新亮点：
- en: '**[Chapter 1](ch01.xhtml)**   I removed the Compound Words problem, as it can
    be solved in ways that did not require a hash table. Instead, now we have a problem
    about passwords on a social networking website. I’ve also streamlined the code
    in this chapter to help those without a C/C++ programming background, and I added
    more information about the efficiency of hash tables.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第1章](ch01.xhtml)**   我移除了复合词问题，因为这个问题可以通过不需要哈希表的方法来解决。现在我们有了一个关于社交网站密码的问题。此外，我还简化了这一章的代码，以帮助没有C/C++编程背景的读者，并增加了关于哈希表效率的更多信息。'
- en: '**[Chapter 3](ch03.xhtml)**   I added more guidance for how to discover the
    needed subproblems when solving a problem with dynamic programming.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第3章](ch03.xhtml)**   我增加了更多关于如何发现动态规划中需要的子问题的指导。'
- en: '**[Chapter 4](ch04.xhtml)**   This chapter is completely new, and it focuses
    on more advanced uses of memoization and dynamic programming. This was a frequent
    request of readers, and I’m excited to have been able to add this. You’ll learn
    how to look at dynamic programming problems in reverse (and why you’d want to),
    how to work with more dimensions in your subproblem arrays, and how to further
    optimize your dynamic programming code when it’s just not fast enough.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第4章](ch04.xhtml)**   这一章是全新的，重点讲解了更高级的记忆化和动态规划的应用。这是读者频繁提出的需求，我很高兴能够将这一部分加入其中。你将学习如何从反向的角度看待动态规划问题（以及为什么要这样做），如何在子问题数组中处理更多维度，并且如何进一步优化动态规划代码，尤其是在它还不够快速的时候。'
- en: '**[Chapter 5](ch05.xhtml), previously [Chapter 4](ch04.xhtml)**   I added guidance
    on how to choose between using dynamic programming and using a graph.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第5章](ch05.xhtml)，之前是[第4章](ch04.xhtml)**   我加入了如何在使用动态规划和图之间做选择的指导。'
- en: '**[Chapter 8](ch08.xhtml), previously [Chapter 7](ch07.xhtml)**   I added further
    discussion of why we implement heaps as arrays rather than as explicit trees.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第8章](ch08.xhtml)，之前是[第7章](ch07.xhtml)**   我进一步讨论了为什么我们将堆实现为数组而不是显式的树。'
- en: '**[Chapter 10](ch10.xhtml)**   This chapter is completely new and teaches you
    how to use randomization, a topic not often covered in books. Randomization is
    a technique that can help you design algorithms that are simple and fast. You’ll
    use two types of randomization algorithms to solve problems that would otherwise
    be very difficult. You’ll also learn what to look for in a problem when trying
    to decide whether to use randomization in the first place.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**[第10章](ch10.xhtml)**   这一章是全新的，教你如何使用随机化，这个主题在书籍中并不常见。随机化是一种可以帮助你设计简单且快速的算法的技术。你将使用两种类型的随机化算法来解决那些否则会非常困难的问题。你还将学习如何在遇到问题时，判断是否需要使用随机化技术。'
- en: Who This Book Is For
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本书的读者群体
- en: This book is for any programmer who wants to learn how to solve tough problems.
    You’ll learn many data structures and algorithms, their benefits, the types of
    problems they can help you solve, and how to implement them. You’ll be a better
    programmer after this!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本书适合任何想学习如何解决复杂问题的程序员。你将学习许多数据结构和算法，它们的优点，它们可以帮助你解决的各种问题，以及如何实现它们。读完本书后，你会成为一个更优秀的程序员！
- en: Are you taking a course on data structures and algorithms and getting your butt
    kicked by a wall of theorems and proofs? It doesn’t have to be that way. This
    book can serve as a companion text for you, helping you get to the core of what’s
    going on so that you can write code and solve problems.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否正在参加一门数据结构和算法的课程，却被一堆定理和证明搞得不知所措？情况不一定非得如此。这本书可以作为你的辅导书，帮助你快速理解核心内容，以便你能够编写代码并解决问题。
- en: Are you looking for an edge in your next coding interview? You need to be able
    to compare and contrast different approaches for solving a problem, choose the
    best data structure or algorithm, and explain and implement your solution. You’ll
    practice all of these skills over and over as you read this book. Never fear hash
    tables, recursion, dynamic programming, trees, graphs, or heaps again!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否在为下一次编程面试寻找优势？你需要能够比较和对比不同的解决问题的方法，选择最合适的数据结构或算法，并能解释和实现你的解决方案。在阅读本书的过程中，你将反复练习这些技能。再也不需要害怕哈希表、递归、动态规划、树、图或堆了！
- en: Are you an independent learner working toward expertise in data structures and
    algorithms? Piecing together stuff from all over the internet can be tiring and
    lead to knowledge gaps if the right resources are not found. This book will provide
    you the solid foundation and consistent presentation that you need to become an
    expert.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你是一个独立学习者，正在朝着数据结构和算法的专家目标努力吗？如果没有找到合适的资源，从互联网上拼凑学习内容会很累，而且可能会导致知识漏洞。本书将为你提供扎实的基础和一致的展示，帮助你成为专家。
- en: 'As explored further in the next section, all code in this book is written in
    the C programming language. However, this isn’t a book on learning C. If your
    prior programming experience is in C or C++, then jump right in. If instead you’ve
    programmed in a language such as Java or Python, I suspect that you’ll pick up
    most of what you need by reading, but you may wish to review some C concepts now
    or on first encounter. In particular, I’ll use pointers and dynamic memory allocation,
    so, no matter what your prior experience, you might like to brush up on those
    topics. The best C book I can recommend is *C Programming: A Modern Approach*,
    2nd edition, by K. N. King. Even if you’re okay with C, read it anyway. It’s that
    good and a wonderful companion any time you get tripped up by C stuff.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如下节所述，本书中的所有代码都是用 C 编程语言编写的。然而，这不是一本学习 C 的书。如果你之前有 C 或 C++ 的编程经验，那就直接开始吧。如果你之前用过
    Java 或 Python 这类语言，我猜你通过阅读会掌握大部分需要的知识，但你可能希望回顾一些 C 的概念，特别是在第一次遇到时。我会使用指针和动态内存分配，所以无论你之前有什么经验，你可能都需要复习这些主题。我推荐的最佳
    C 书籍是 K. N. King 的《C 程序设计：现代方法》（第二版）。即使你对 C 没问题，也建议读一读。它非常优秀，任何时候遇到 C 相关的问题，都是极好的伴侣。
- en: Our Programming Language
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的编程语言
- en: I’ve chosen to use C as the programming language for this book, rather than
    some higher-level language such as C++, Java, or Python. I’ll discuss why and
    also justify a couple of other C-related decisions I’ve made.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用 C 作为本书的编程语言，而不是 C++、Java 或 Python 这类高级语言。我会讨论为什么这样做，并且解释我在 C 相关的其他一些决策。
- en: '*Why Use C?*'
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*为什么使用 C？*'
- en: 'The primary reason for using C is that I want to teach you data structures
    and algorithms from the ground up. When we want a hash table, we’ll build it ourselves.
    There will be no reliance on dictionaries or hashmaps or similar data structures
    of other languages. When we don’t know the maximum length of a string, we’ll build
    an extensible array: we won’t let the language handle memory allocation for us.
    I want you to know exactly what’s going on, with no tricks up my sleeve. Using
    C helps me toward this goal.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C 的主要原因是我希望从零开始教你数据结构和算法。当我们需要哈希表时，我们自己构建它。不会依赖字典、哈希映射或其他语言的类似数据结构。当我们不知道字符串的最大长度时，我们会构建一个可扩展的数组：我们不会让语言为我们处理内存分配。我希望你能完全明白发生了什么，绝不藏私。使用
    C 帮助我实现这个目标。
- en: Solving programming problems in C, as we do in this book, is a useful primer
    should you decide to continue with C++. If you become serious about competitive
    programming, then you’ll be happy to know that C++ is the most popular language
    used by competitive programmers, thanks to its rich standard library and ability
    to generate code that favors speed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，像我们这样用 C 解决编程问题，是你决定继续学习 C++ 时的有用入门。如果你决定深入竞争性编程，你会高兴地发现，C++ 是最受竞争性编程人员欢迎的语言，因为它有丰富的标准库，并且能够生成优化速度的代码。
- en: '*Static Keyword*'
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*静态关键字*'
- en: Regular local variables are stored on what’s called the *call stack*. On each
    call of a function, some of the call stack memory is used to store local variables.
    Then, when the function returns, that memory is freed up for other local variables
    to use later. The call stack is small, though, and isn’t appropriate for some
    of the massive arrays that we’ll meet in this book. Enter the `static` keyword.
    When used on a local variable, it changes the storage duration from automatic
    to static, which means that the variable maintains its value between function
    calls. As a side effect, these variables are *not* stored in the same memory area
    along with regular local variables, since then their values would be lost when
    a function is terminated. Instead, they’re stored in their own separate segment
    of memory, where they don’t have to compete with whatever else might be on the
    call stack.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 常规的局部变量存储在所谓的 *调用栈* 中。每次调用一个函数时，部分调用栈内存会用来存储局部变量。然后，当函数返回时，这些内存会被释放出来，以供其他局部变量使用。不过，调用栈较小，不适合存储本书中我们会遇到的一些庞大数组。这时，`static`
    关键字就派上用场了。将 `static` 用于局部变量时，会将其存储持续时间从自动变为静态，这意味着该变量在函数调用之间保持其值。副作用是，这些变量 *不会*
    与常规局部变量存储在同一内存区域，否则它们的值在函数结束时会丢失。相反，它们被存储在自己独立的内存段中，不必与调用栈上的其他内容竞争。
- en: One thing to watch out for with this `static` keyword is that such local variables
    are only initialized once! For a quick example, see [Listing 1](#ch00ex1).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `static` 关键字时需要注意的一点是，这些局部变量只会被初始化一次！快速示例请参见 [示例 1](#ch00ex1)。
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 1: A local variable with a static keyword*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 1：带有 static 关键字的局部变量*'
- en: 'I’ve used `static` on local variable `x` ❶. Without that, you’d expect `5`
    to be printed three times. However, since `static` is there, you should see this
    output instead:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我在局部变量 `x` ❶ 上使用了 `static`。没有它，你应该会看到 `5` 被打印三次。然而，由于使用了 `static`，你应该看到如下输出：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Include Files*'
  id: totrans-37
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*包含文件*'
- en: 'To save space, I don’t include the `#include` lines that should be added to
    the start of C programs. You’ll be safe if you include the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，我没有包括应该在 C 程序开头添加的 `#include` 行。如果你包含以下内容，就不会出错：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Freeing Memory*'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*释放内存*'
- en: Unlike Java or Python, C requires the programmer to free all memory that is
    manually allocated. The pattern is to allocate memory using `malloc`, use that
    memory, and then free the memory using `free`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 或 Python 不同，C 语言要求程序员释放所有手动分配的内存。模式是使用 `malloc` 分配内存，使用该内存，然后使用 `free`
    释放内存。
- en: 'For two reasons, though, I do not free memory here. First, freeing memory adds
    clutter, distracting from the primary teaching purpose of the code. Second, these
    programs are not long-lived: your program will run on a few test cases, and that’s
    it. The operating system reclaims all of the unfreed memory on program termination,
    so there’s nothing to worry about even if you run a program many times. Of course,
    not freeing memory is quite irresponsible in practice: no one is happy with a
    program that consumes more and more memory as it runs. If you’d like to practice
    freeing memory, you can add calls of `free` to the programs presented in this
    book.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于两个原因，我在这里没有释放内存。首先，释放内存会增加杂乱，分散代码的主要教学目的。其次，这些程序的生命周期很短：你的程序将在几个测试用例上运行，完事儿就结束了。操作系统在程序终止时会回收所有未释放的内存，所以即使你多次运行程序，也无需担心。当然，在实践中不释放内存是非常不负责任的：没有人会喜欢一个随着运行而消耗越来越多内存的程序。如果你想练习释放内存，你可以在本书中展示的程序里加入
    `free` 调用。
- en: Topic Selection
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主题选择
- en: The fields of data structures and algorithms are too large to be corralled by
    one book (or by this one author!). I used three criteria to help me decide what
    topics made the cut.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构和算法的领域太广泛，无法被一本书（或者这位作者）所包容。我使用了三个标准来帮助我决定哪些主题值得纳入其中。
- en: 'First, I chose topics of broad applicability: each can be used to solve not
    only the corresponding problems in the book but many other problems as well. In
    each chapter, I focus on at least two problems. I generally use the first problem
    to introduce the data structure or algorithm and one of its prototypical uses.
    The other problems are meant to give a sense of what else the data structure or
    algorithm can do. For example, in [Chapter 6](ch06.xhtml), we study Dijkstra’s
    algorithm. If you google it, you’ll see that Dijkstra’s algorithm is used to find
    shortest paths. Indeed, in the first problem of the chapter, we use it for that
    very purpose. However, in the second problem, we go further, tweaking Dijkstra’s
    algorithm to find not only the shortest path but also the number of shortest paths.
    I hope that, as you progress through each chapter, you learn more and more about
    the affordances, constraints, and subtleties of each technique.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我选择了具有广泛适用性的主题：每个主题不仅可以用来解决书中的相应问题，还能解决许多其他问题。在每一章中，我至少关注两个问题。我通常用第一个问题来介绍数据结构或算法以及它的一个典型应用。其他问题则旨在让你了解数据结构或算法的更多用途。例如，在[第
    6 章](ch06.xhtml)中，我们研究了 Dijkstra 算法。如果你在 Google 上搜索它，你会发现 Dijkstra 算法用于寻找最短路径。的确，在本章的第一个问题中，我们就是用它来做这个事情。然而，在第二个问题中，我们进一步改进
    Dijkstra 算法，不仅找出最短路径，还计算最短路径的数量。我希望随着你深入每一章，你能更多地了解每种技术的应用范围、约束和细节。
- en: Second, I chose topics whose implementation did not overwhelm the surrounding
    discussion. I wanted the solution to any problem to top out at around 150 lines.
    That includes reading the input, solving the problem itself, and producing the
    output. A data structure or algorithm whose implementation took 200 or 300 lines
    was for practical reasons not suitable.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我选择了那些实现不会淹没周围讨论的主题。我希望任何问题的解决方案的代码量不超过 150 行。那包括读取输入、解决问题本身和产生输出。如果某个数据结构或算法的实现需要
    200 或 300 行代码，那出于实际原因，它就不适合了。
- en: 'Third, I chose topics that lend themselves to correctness arguments that I
    hope are convincing and intuitive. Teaching you specific data structures and algorithms
    is of course one of my goals, because I am imagining that you’re here to learn
    powerful problem-solving approaches and how to implement them. Meanwhile, I’m
    also hoping that you’re interested in *why* what you’re learning works, so I have
    more quietly pursued another goal: convincing you that the data structure or algorithm
    is correct. There won’t be formal proofs or anything like that. Nonetheless, if
    I have succeeded in my secret goal, then you’ll learn about correctness right
    along with the data structure or algorithm. Don’t be content in merely tracing
    code and marveling that it magically works every time. There is no magic, and
    the insights that make code tick are within your grasp, just as is the code itself.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，我选择了那些能够支持正确性论证的主题，我希望这些论证既令人信服又直观。教授你特定的数据结构和算法当然是我的目标之一，因为我假设你来这里是为了学习强大的问题解决方法及其实现。同时，我也希望你对*为什么*你所学的内容有效感兴趣，所以我在更为隐秘的目标上也做了一些努力：说服你相信数据结构或算法是正确的。这里不会有正式的证明或类似的内容。不过，如果我在我的隐秘目标上取得了成功，那么你将在学习数据结构或算法的同时，也学到正确性的问题。不要仅仅满足于追踪代码并惊叹它每次都能神奇地运行。没有魔法，能够使代码运行的洞察就在你手边，就像代码本身一样。
- en: If you’d like to go beyond the chapters of this book, I recommend starting with
    [Appendix B](app02.xhtml). There, I’ve included some additional material related
    to [Chapters 1](ch01.xhtml), [3](ch03.xhtml), [5](ch05.xhtml), [8](ch08.xhtml),
    [9](ch09.xhtml), and [10](ch10.xhtml).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想深入了解本书的内容，建议从[附录 B](app02.xhtml)开始。在那里，我加入了一些与[第 1 章](ch01.xhtml)、[第 3 章](ch03.xhtml)、[第
    5 章](ch05.xhtml)、[第 8 章](ch08.xhtml)、[第 9 章](ch09.xhtml)和[第 10 章](ch10.xhtml)相关的附加材料。
- en: Many readers will benefit by practicing or reading additional material as they
    progress through the book. The Notes sections at the end of the chapters point
    to additional resources, some of which contain further examples and sample problems.
    There are also online resources that offer a curated, categorized list of problems
    and their solution strategies. The *Methods to Solve* page by Steven Halim and
    Felix Halim is the most comprehensive that I’ve found; see [*https://cpbook.net/methodstosolve*](https://cpbook.net/methodstosolve).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 许多读者通过在阅读本书的同时进行练习或阅读额外的资料将受益。章节末尾的“注释”部分指出了额外的资源，其中一些包含了更多的例子和样例题。还有一些在线资源提供了精选的、分类整理的问题及其解题策略。我找到的最全面的资源是Steven
    Halim和Felix Halim的*解题方法*页面；请参见 [*https://cpbook.net/methodstosolve*](https://cpbook.net/methodstosolve)。
- en: Programming Judges
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编程竞赛平台
- en: 'Each problem that I have chosen is available on a programming-judge website.
    Many such websites exist, each of which generally contains hundreds of problems.
    I’ve tried to keep the number of judges that we use small but large enough to
    give me the flexibility to choose the most appropriate problems. For each judge
    website, you’ll need a username and password; it’s worth setting up your accounts
    now so that you don’t have to stop to do so while working through the book. Here
    are the judges that we’ll use:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择的每个问题都可以在一个编程竞赛平台上找到。许多这样的竞赛平台存在，每个平台通常包含数百个问题。我尽量保持我们使用的竞赛平台数量较少，但又足够多，以便给我选择最合适问题的灵活性。对于每个竞赛平台，你需要一个用户名和密码；现在就设置好你的账户是值得的，这样在阅读本书时，你就不用中途停下来去设置账户了。以下是我们将使用的竞赛平台：
- en: '**Codeforces**   [*https://codeforces.com*](https://codeforces.com)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**Codeforces**   [*https://codeforces.com*](https://codeforces.com)'
- en: '**DMOJ**   [*https://dmoj.ca*](https://dmoj.ca)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**DMOJ**   [*https://dmoj.ca*](https://dmoj.ca)'
- en: '**POJ**   [*http://poj.org*](http://poj.org)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**POJ**   [*http://poj.org*](http://poj.org)'
- en: '**SPOJ**   [*http://spoj.com*](http://spoj.com)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**SPOJ**   [*http://spoj.com*](http://spoj.com)'
- en: '**UVa**   [*https://uva.onlinejudge.org*](https://uva.onlinejudge.org)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**UVa**   [*https://uva.onlinejudge.org*](https://uva.onlinejudge.org)'
- en: Each problem description begins by indicating the judge website where the problem
    can be found and the particular problem code that you should use to access it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 每个问题的描述开始时都会指明该问题可以在某个竞赛平台上找到，并给出你应使用的特定问题代码以访问该问题。
- en: 'While some problems on the judge websites are written by individual contributors,
    others are originally from well-known competitions. Here are some of the competitions
    from which problems in this book originate:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管竞赛平台上的一些问题由个人贡献者编写，但其他问题则来自于著名的竞赛。以下是一些本书中问题来源的竞赛：
- en: '**International Olympiad in Informatics (IOI)**   This is a prestigious annual
    competition for high school students. Each participating country sends up to four
    participants, but each participant competes individually. The competition runs
    over two days, with multiple programming tasks on each day.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**国际信息学奥林匹克（IOI）**   这是一个为高中生举办的著名年度比赛。每个参赛国最多派出四名选手，但每名选手单独参赛。比赛持续两天，每天都有多个编程任务。'
- en: '**Canadian Computing Competition (CCC) and Canadian Computing Olympiad (CCO)**   These
    annual competitions for high school students are organized by the University of
    Waterloo. CCC (aka Stage 1) takes place at individual schools, with the top performers
    moving on to take the CCO (aka Stage 2) at the University of Waterloo. The top
    performers in Stage 2 represent Canada at the IOI. When I was a high school student,
    I participated in the CCC, but I never made it to the CCO—I wasn’t even close.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**加拿大计算机竞赛（CCC）和加拿大信息学奥林匹克（CCO）**   这些是由滑铁卢大学组织的年度高中生竞赛。CCC（即第一阶段）在各个学校举行，表现最好的选手将进入第二阶段（CCO），即在滑铁卢大学举行的竞赛。第二阶段表现最好的选手将代表加拿大参加IOI。作为一名高中生时，我参加了CCC，但我从未进入CCO——我连接近的机会都没有。'
- en: '**Croatian Open Competition in Informatics (COCI)**   This online competition
    is offered many times per year. Performance is used to determine the Croatian
    IOI team.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**克罗地亚信息学公开赛（COCI）**   这个在线比赛每年举办多次。表现优异的选手将被选入克罗地亚的IOI代表队。'
- en: '**National Olympiad in Informatics in Province (NOIP)**   This is an annual
    competition for high school students in China, similar in function to the CCC.
    The top performers are invited to the National Olympiad in Informatics (NOI),
    China. The top NOI contestants are eligible for further training and possible
    selection to China’s IOI team.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**全国中学生信息学奥林匹克（NOIP）** 这是中国的一个年度比赛，类似于加拿大的CCC。表现最好的选手将被邀请参加中国全国信息学奥林匹克（NOI）。NOI的优胜者有资格参加进一步的训练，并可能被选拔进入中国IOI队。'
- en: '**South African Programming Olympiad (SAPO)**   This competition is offered
    in three rounds per year. The rounds increase in difficulty, from Round 1 to Round
    2 to the Final Round. Performance is used to select students to represent South
    Africa at the IOI.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**南非编程奥林匹克（SAPO）** 这项比赛每年举办三轮。比赛的难度逐渐增加，从第一轮到第二轮，再到最终轮。比赛成绩用于选拔代表南非参加IOI的学生。'
- en: '**USA Computing Olympiad (USACO)**   This online competition is offered several
    times per year, the most challenging of which is the US Open competition. In each
    competition, you’ll encounter four levels of problems: bronze (easiest), silver,
    gold, and platinum (hardest). Performance is used to determine the American IOI
    team.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**美国计算奥林匹克（USACO）** 这项在线比赛每年举办几次，其中最具挑战性的比赛是美国公开赛。在每次比赛中，你将遇到四个难度级别的题目：青铜（最简单）、白银、黄金和铂金（最难）。比赛成绩用于选拔美国IOI队伍。'
- en: '**East Central North America (ECNA) Regional Programming Contest**   In this
    annual competition for university students, the top performers are invited to
    the annual International Collegiate Programming Contest (ICPC) world finals. Unlike
    the other competitions here, where students compete individually, ECNA and the
    world finals competitions are team competitions.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**中北美东部地区编程竞赛（ECNA）** 在这项为大学生举办的年度比赛中，表现最好的选手将被邀请参加年度国际大学生程序设计竞赛（ICPC）世界总决赛。与这里的其他比赛不同，学生们是单独竞争的，而ECNA和世界总决赛则是团队比赛。'
- en: '**DWITE**   This was an online programming contest designed to help students
    practice for annual competitions. Unfortunately, DWITE is no longer running, but
    the old problems—and they are good ones!—are still available.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**DWITE** 这是一个旨在帮助学生为年度比赛做准备的在线编程比赛。不幸的是，DWITE现在已经不再举行，但那些旧的题目——它们真的很不错！——依然可以使用。'
- en: See [Appendix C](app03.xhtml) for the source of each problem in this book.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[附录C](app03.xhtml)了解本书中每个问题的来源。
- en: 'When you submit code for a problem, the judge compiles your program and runs
    it on test cases. If your program passes all test cases, and does so within the
    allotted time, then your code is accepted as correct; judges show `AC` for accepted
    solutions. If your program fails one or more test cases, then your program is
    not accepted; judges show `WA` (for “Wrong Answer”) in these cases. A final popular
    outcome is for when your program is too slow, in which case judges show `TLE`
    (“Time-Limit Exceeded”). Note that `TLE` does not mean that your code is otherwise
    correct: if your code times out, the judges do not run any further test cases,
    so there may be some `WA` bugs hidden behind the `TLE`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当你提交代码解决问题时，评审会编译你的程序并在测试用例上运行。如果你的程序通过了所有的测试用例，并且在规定时间内完成，那么你的代码会被接受为正确；评审会显示`AC`表示接受的解答。如果你的程序未通过一个或多个测试用例，那么你的程序将不被接受；在这种情况下，评审会显示`WA`（“错误答案”）。一种常见的结果是程序运行过慢，评审会显示`TLE`（“超时”）。请注意，`TLE`并不意味着你的代码其他部分是正确的：如果你的代码超时，评审将不再运行后续的测试用例，所以可能有一些`WA`的bug被隐藏在`TLE`背后。
- en: At the time of publication, my solution for each problem passes all test cases
    within the allotted time with the specified judge. Within those base requirements,
    my aim has been to make the code readable and to choose clarity over speed. This
    is a book about teaching data structures and algorithms, not squeezing further
    performance out of a program that otherwise gets the job done.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书出版时，我为每个问题提供的解决方案均能在规定时间内通过所有测试用例并满足指定的评审要求。在这些基本要求的基础上，我的目标是让代码具有可读性，并且选择清晰性优于速度。这是一本关于教授数据结构与算法的书，而不是让程序在完成任务的前提下追求更高的性能。
- en: Anatomy of a Problem Description
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 问题描述的结构
- en: 'Before solving a problem, we must be precise about what we are being asked
    to do. This precision is required not only in understanding the task itself but
    also in the way that we should read input and produce output. For this reason,
    each problem begins with a problem description of three components:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决问题之前，我们必须清楚自己被要求做什么。这种精确性不仅仅体现在理解任务本身上，还体现在我们应该如何读取输入并产生输出。因此，每个问题开始时都会有三个组成部分的描述：
- en: '**The Problem**   Here, I provide the context for the problem and what we are
    being asked to do. It’s important to read this material carefully so that you
    know exactly what problem we’re solving. Sometimes, misreading or misinterpreting
    seemingly small words can lead to incorrect solutions. For example, one of our
    problems in [Chapter 3](ch03.xhtml) asks us to buy “at least” a certain number
    of apples: if you instead buy “exactly” that many apples, your program will fail
    some of the test cases.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**   在这里，我提供了问题的背景和我们需要做的事情。仔细阅读这部分材料很重要，以便你能完全理解我们要解决的问题。有时，误读或误解一些看似微小的词语可能会导致错误的解决方案。例如，[第3章](ch03.xhtml)中的一个问题要求我们购买“至少”一定数量的苹果：如果你只购买“恰好”那数量的苹果，程序将无法通过某些测试用例。'
- en: '**Input**   The author of the problem provides test cases, all of which must
    be passed for a submission to be deemed correct. It’s our responsibility to read
    each test case from the input so that we can process it. How do we know how many
    test cases there are? What is on each line of each test case? If there are numbers,
    what are their ranges? If there are strings, how long can they be? All of this
    information is provided here.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入**   问题的作者提供了测试用例，必须通过所有测试用例，提交才会被认为是正确的。我们的责任是从输入中读取每个测试用例，以便我们可以处理它。我们怎么知道有多少个测试用例呢？每个测试用例的每一行包含什么内容？如果是数字，它们的范围是什么？如果是字符串，它们的长度可以是多少？所有这些信息都在这里提供。'
- en: '**Output**   It can be very frustrating to have a program that produces the
    correct answer but fails test cases because it does not output answers in the
    correct format. The output portion of a problem description dictates exactly how
    we should produce output. For example, it will tell us how many lines of output
    to produce for each test case, what to put on each line, whether blank lines are
    required between or after test cases, and so on. In addition, I provide the time
    limit for the problem here: if the program does not output the solution for all
    test cases within the time limit, then the program does not pass.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**   如果一个程序能够输出正确的答案，但因为输出格式不正确而未通过测试用例，这会让人非常沮丧。问题描述中的输出部分明确规定了我们应该如何生成输出。例如，它会告诉我们每个测试用例应产生多少行输出，每行应包含什么内容，是否需要在测试用例之间或之后添加空行，等等。此外，我还提供了问题的时间限制：如果程序未能在时间限制内为所有测试用例输出解决方案，那么程序将无法通过。'
- en: I have rewritten the text of each problem from the official description so that
    I can maintain a consistent presentation throughout. Despite these tweaks, my
    description will convey the same information as the official description.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经重写了每个问题的文本，以便在整个文档中保持一致的呈现方式。尽管有这些修改，我的描述传达的信息将与官方描述相同。
- en: For most problems in this book, we’ll read input from standard input and write
    output to standard output. (There are only two problems where standard input and
    output are not involved; they are in [Chapter 7](ch07.xhtml).) This means we should
    use C functions such as `scanf`, `getchar`, `printf`, and so on and not explicitly
    open and close files.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中大多数问题，我们会从标准输入读取数据并将输出写入标准输出。（只有两个问题不涉及标准输入和输出；它们在[第7章](ch07.xhtml)中。）这意味着我们应该使用诸如`scanf`、`getchar`、`printf`等C语言函数，而不是显式地打开和关闭文件。
- en: 'Starter Problem: Food Lines'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动问题：食物排队
- en: Let’s familiarize ourselves with a sample problem description. I’ll provide
    some commentary in parentheses along the way, directing your attention to the
    important bits. Once we understand the problem, I can think of nothing better
    to do than solve it. Unlike the other problems in the book, we’ll be able to do
    so with programming constructs and ideas that I hope you already know. If you
    can solve the problem on your own or work through my solution with little or no
    trouble, then I think you’re ready for what’s to come. If you get seriously stuck,
    then you may wish to revisit programming fundamentals and/or solve a few other
    starter problems before continuing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例问题描述来熟悉一下。我会在过程中提供一些评论（括号内），引导你关注重要的部分。一旦我们理解了问题，我想不出比解决它更好的办法了。与书中的其他问题不同，我们将能够使用我希望你已经掌握的编程结构和思想来解决它。如果你能独立解决这个问题，或者轻松跟随我的解决方案，那我认为你已经为接下来的内容做好准备。如果你遇到严重的困难，可能需要回顾一些编程基础，或者先解决一些其他入门问题再继续。
- en: This is DMOJ problem `lkp18c2p1`. (You might like to go now to the DMOJ website
    and search for this problem so that you’re ready to submit our code once we’re
    done.)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是DMOJ问题`lkp18c2p1`。（你可能现在就想去DMOJ网站搜索这个问题，以便我们完成代码后提交。）
- en: '*The Problem*'
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*问题描述*'
- en: There are *n* lines of people waiting for food. We know the number of people
    that are already waiting in each line. Then, each of *m* new people will arrive,
    and they will join a shortest line (a line with the fewest number of people).
    Our task is to determine the number of people in each line that each of the *m*
    people joins.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有*n*条排队等候食物的队伍。我们知道每条队伍中已经排队的人数。接着，*m*个新的人将到达，他们会加入到人数最少的队伍（即人数最少的队伍）。我们的任务是确定每个新加入的人会加入哪个队伍以及该队伍中的人数。
- en: (Spend a little time interpreting the above paragraph. There’s an example coming
    next, so if anything is unclear, try to remedy it with the combination of the
    above paragraph and the example below.)
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: （花点时间理解上面的段落。接下来会有一个示例，如果有什么不清楚的，可以通过结合上面的段落和下面的示例来解决。）
- en: Here’s an example. Suppose that there are three lines of people, with three
    people in Line 1, two people in Line 2, and five people in Line 3\. Then, four
    new people arrive. (Try to work out what happens for this case before reading
    the rest of this paragraph.) The first person joins a line with two people, Line
    2; now Line 2 has three people. The second person joins a line with three people,
    Line 1 or Line 2—let’s say Line 1; Line 1 now has four people. The third person
    joins a line with three people, Line 2; Line 2 now has four people. The fourth
    and final person joins a line with four people, Line 1 or Line 2—let’s say Line
    1; Line 1 now has five people.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例。假设有三条队伍，队伍1有3个人，队伍2有2个人，队伍3有5个人。然后，四个新的人到达。（在继续读下去之前，试着计算一下这种情况会发生什么。）第一个人加入队伍2，队伍2现在有3个人。第二个人加入队伍1，队伍1现在有4个人。第三个人加入队伍2，队伍2现在有4个人。第四个也是最后一个人加入队伍1，队伍1现在有5个人。
- en: Input
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输入
- en: The input contains one test case. The first line of input contains two positive
    integers, *n* and *m*, giving the number of lines of people and number of new
    people, respectively. *n* and *m* are at most 100\. The second line of input contains
    *n* positive integers, giving the number of people in each line of people before
    the new people arrive. Each of these integers is at most 100.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 输入包含一个测试用例。输入的第一行包含两个正整数，*n*和*m*，分别表示排队的人数行数和新来的人数。*n*和*m*的最大值为100。输入的第二行包含*n*个正整数，表示新来的人到达前每条队伍的人数。这些整数的最大值为100。
- en: 'Here’s the input for the above test case:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述测试用例的输入：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: (Note how there is exactly one test case here. Therefore, we should expect to
    read exactly two lines of input.)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，这里只有一个测试用例。因此，我们应该期望读取恰好两行输入。）
- en: Output
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 输出
- en: For each of the *m* new people, output a line containing the number of people
    in the line that they join.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个新加入的*m*个人，输出一行，包含他们所加入队伍的人数。
- en: 'The correct output for the above test case is:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 上述测试用例的正确输出是：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The time limit for solving the test case is three seconds. (Given that we have
    to handle at most 100 new people for each test case, three seconds is a long time.
    We won’t need any fancy data structures or algorithms.)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 解决该测试用例的时间限制是三秒。（鉴于我们每个测试用例最多要处理100个新加入的人，三秒足够了。我们不需要任何复杂的数据结构或算法。）
- en: '*Solving the Problem*'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*解决问题*'
- en: For problems involving data structures that are difficult to build by hand,
    I may start by reading the input. Otherwise, I tend to save that code for last.
    The reason for this is that we can generally test the functions we’re writing
    by calling them with sample values; there is no need to worry about parsing the
    input until we’re ready to solve the whole problem.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及难以手动构建的数据结构的问题，我可能会先从读取输入开始。否则，我倾向于把这部分代码留到最后。原因是我们通常可以通过传入示例值来测试我们编写的函数；直到我们准备好解决整个问题时，才需要担心解析输入。
- en: The key data that we need to maintain are the number of people in each line.
    The appropriate storage technique is an array, using one index per line. We’ll
    use a variable named `lines` for that array.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要维护的关键数据是每条行中的人数。合适的存储方式是使用数组，每条行一个索引。我们将使用一个名为`lines`的变量来存储这个数组。
- en: Each new person that arrives chooses to join a shortest line, so we’ll need
    a helper function to tell us which line that is. That helper function is given
    in [Listing 2](#ch00ex2).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新到的人都会选择加入一条最短的行，所以我们需要一个辅助函数来告诉我们哪一行是最短的。该辅助函数见[清单 2](#ch00ex2)。
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 2: Index of a shortest line*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2：最短行的索引*'
- en: 'Now, given a `lines` array and `n` and `m`, we can solve a test case, the code
    for which is given in [Listing 3](#ch00ex3):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，给定一个`lines`数组以及`n`和`m`，我们可以解决一个测试用例，相关代码见[清单 3](#ch00ex3)：
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 3: Solving the problem*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3：解决问题*'
- en: 'For each iteration of the `for` loop, we call our helper function to grab the
    index of the shortest line. We then print the length of that shortest line. This
    person then joins that line: that’s why we must increment the number of people
    in that line by one ❶.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环的每次迭代中，我们调用辅助函数来获取最短行的索引。然后我们打印该最短行的长度。接着，这个人加入该行：因此我们必须将该行中的人数加一 ❶。
- en: All that’s left is to read the input and call `solve`; that’s done in [Listing
    4](#ch00ex4).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是读取输入并调用`solve`函数；这在[清单 4](#ch00ex4)中完成。
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 4: The main function*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 4：主函数*'
- en: 'Putting together our `shortest_line_index`, `solve`, and `main` functions and
    adding the required `#include` lines at the top gives us a complete solution that
    we can submit to the judge. When doing so, be sure to choose the correct programming
    language: for the programs in this book, you want to find GCC, or C99, or C11,
    or however the judge refers to a compiler for C.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的`shortest_line_index`、`solve`和`main`函数整合起来，并在顶部添加所需的`#include`语句，就能得到一个完整的解决方案，可以提交给评测系统。在提交时，务必选择正确的编程语言：对于本书中的程序，你需要选择GCC、C99、C11，或评测系统所指定的C语言编译器。
- en: 'If you want to test your code locally before submitting it to the judge, then
    you have a few options. Since our programs read from standard input, one thing
    you can do is run the program and type a test case by hand. That’s a reasonable
    thing to do for small test cases, but it’s tedious doing that over and over, especially
    for large test cases. (You may also need to issue an end-of-file control code
    after you type the input, such as CTRL-Z on Windows or CTRL-D on other operating
    systems.) A better option is to store the input in a file and then use *input
    redirection* from the command prompt to have the program read from that file instead
    of the keyboard. For example, if you store a test case for the present problem
    in file *food.txt*, and your compiled program is called *food*, then try:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在提交代码之前在本地测试它，有几种方法。由于我们的程序是从标准输入读取的，你可以做的一件事是运行程序并手动输入测试用例。对于小型测试用例，这是一种合理的做法，但重复这样做会很繁琐，特别是对于大型测试用例。（你可能还需要在输入后发出一个文件结束控制代码，例如在Windows上按CTRL-Z，或在其他操作系统上按CTRL-D。）一个更好的方法是将输入存储在文件中，然后使用*输入重定向*从命令提示符将程序输入重定向到该文件，而不是键盘。例如，如果你将当前问题的测试用例存储在文件*food.txt*中，且编译后的程序名为*food*，那么可以尝试：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This makes it easy to play with many test cases: just change what’s in *food.txt*
    and then run the program with input redirection again.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就可以轻松地处理多个测试用例：只需更改*food.txt*中的内容，然后再次使用输入重定向运行程序。
- en: Congratulations! You’ve solved your first problem. Moreover, you now know our
    game plan for each problem in the book, as we’ll use the same general structure
    I have given here. We’ll first understand the problem itself and work through
    some examples. Then we’ll start writing code to solve the problem. We won’t always
    get it right the first time, though. Maybe our code will be too slow or fail some
    specific test cases. That’s okay! We’ll learn new data structures and algorithms
    and then strike back at the problem. Eventually, we will solve each one—and after
    each such experience, we will know more and be better programmers than when we
    started.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！你已经解决了第一个问题。而且，你现在了解了我们在本书中处理每个问题的游戏计划，我们将使用我在这里给出的相同通用结构。我们首先会理解问题本身并通过一些例子来演示。接着，我们将开始编写代码来解决问题。不过，我们不一定会一次就写对。也许我们的代码会太慢，或者无法通过某些特定的测试用例。这没关系！我们将学习新的数据结构和算法，然后重新应对问题。最终，我们将解决每一个问题——而每次解决后，我们都会比开始时更了解并成为更好的程序员。
- en: Let’s get to it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Online Resources
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在线资源
- en: Supplementary resources for this book, including downloadable code and additional
    exercises, are available at [*https://nostarch.com/algorithmic-thinking-2nd-edition*](https://nostarch.com/algorithmic-thinking-2nd-edition).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的补充资源，包括可下载的代码和额外的练习题，可以在[*https://nostarch.com/algorithmic-thinking-2nd-edition*](https://nostarch.com/algorithmic-thinking-2nd-edition)找到。
- en: Notes
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: Food Lines is originally from the 2018 LKP Contest 2, hosted by DMOJ.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 《食品线》最初来自2018年LKP竞赛2，由DMOJ主办。
