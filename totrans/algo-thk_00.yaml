- en: '**INTRODUCTION**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](../images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: I’m assuming that you’ve learned to use a programming language such as C, C++,
    Java, or Python . . . and I’m hoping that you’re hooked. It’s hard to explain
    to nonprogrammers why solving problems through programming is so rewarding and
    fun.
  prefs: []
  type: TYPE_NORMAL
- en: I’m also hoping that you’re ready to take your programming skill to the next
    level. I have the privilege of helping you do that.
  prefs: []
  type: TYPE_NORMAL
- en: What We’ll Do
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I could start by teaching you some fancy new techniques, telling you why they’re
    useful, and comparing them to other fancy techniques, but I won’t. That material
    would lay inert, holding on for a little, waiting for the opportunity to spring
    into action—if in fact some opportunity ever did present itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, what I do throughout this book is pose problems: hard problems. These
    are problems that I hope you cannot solve, problems that I hope stymie your current
    approaches. You’re a programmer. You want to solve problems. Now it’s time for
    learning those fancy techniques. This book is all about posing hard problems and
    then solving them by bridging between what you know and what you need.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You won’t see traditional textbook problems here. You won’t find an optimal
    way to multiply a chain of matrices or compute Fibonacci numbers. I promise: you
    won’t solve the Towers of Hanoi puzzle. There are many excellent textbooks out
    there that do these things, but I suspect that many people are not motivated by
    those kinds of puzzles.'
  prefs: []
  type: TYPE_NORMAL
- en: My approach is to use new problems that you haven’t seen before. Each year,
    thousands of people participate in programming competitions, and these competitions
    require new problems to measure what participants can come up with on their own
    rather than who can google the fastest. These problems are fascinating, riffing
    on the classics while adding twists and context to challenge people to find new
    solutions. There is a seemingly endless stream of programming and computing knowledge
    encompassed by these problems. We can learn as much as we like by choosing the
    right problems.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with some basics. A *data structure* is a way to organize data so
    that desirable operations are fast. An *algorithm* is a sequence of steps that
    solves a problem. Sometimes we can make fast algorithms without using sophisticated
    data structures; other times, the right data structure can offer a significant
    speed boost. My goal is not to turn you into a competitive programmer, though
    I’d take that as a happy side benefit. Rather, my goal is to teach you data structures
    and algorithms using problems from the competitive programming world—and to have
    fun while doing so. You can reach me at *[daniel.zingaro@gmail.com](mailto:daniel.zingaro@gmail.com)*.
    Email me if you have learned. Email me if you have laughed.
  prefs: []
  type: TYPE_NORMAL
- en: New to the Second Edition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ve thoroughly enjoyed the opportunity to discuss the first edition of this
    book with readers. Their feedback has led to many of the changes and improvements
    in this new edition.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve made small improvements and additions throughout, but here are the major
    highlights of what’s new:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 1](ch01.xhtml)**   I removed the Compound Words problem, as it can
    be solved in ways that did not require a hash table. Instead, now we have a problem
    about passwords on a social networking website. I’ve also streamlined the code
    in this chapter to help those without a C/C++ programming background, and I added
    more information about the efficiency of hash tables.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 3](ch03.xhtml)**   I added more guidance for how to discover the
    needed subproblems when solving a problem with dynamic programming.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 4](ch04.xhtml)**   This chapter is completely new, and it focuses
    on more advanced uses of memoization and dynamic programming. This was a frequent
    request of readers, and I’m excited to have been able to add this. You’ll learn
    how to look at dynamic programming problems in reverse (and why you’d want to),
    how to work with more dimensions in your subproblem arrays, and how to further
    optimize your dynamic programming code when it’s just not fast enough.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 5](ch05.xhtml), previously [Chapter 4](ch04.xhtml)**   I added guidance
    on how to choose between using dynamic programming and using a graph.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 8](ch08.xhtml), previously [Chapter 7](ch07.xhtml)**   I added further
    discussion of why we implement heaps as arrays rather than as explicit trees.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 10](ch10.xhtml)**   This chapter is completely new and teaches you
    how to use randomization, a topic not often covered in books. Randomization is
    a technique that can help you design algorithms that are simple and fast. You’ll
    use two types of randomization algorithms to solve problems that would otherwise
    be very difficult. You’ll also learn what to look for in a problem when trying
    to decide whether to use randomization in the first place.'
  prefs: []
  type: TYPE_NORMAL
- en: Who This Book Is For
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This book is for any programmer who wants to learn how to solve tough problems.
    You’ll learn many data structures and algorithms, their benefits, the types of
    problems they can help you solve, and how to implement them. You’ll be a better
    programmer after this!
  prefs: []
  type: TYPE_NORMAL
- en: Are you taking a course on data structures and algorithms and getting your butt
    kicked by a wall of theorems and proofs? It doesn’t have to be that way. This
    book can serve as a companion text for you, helping you get to the core of what’s
    going on so that you can write code and solve problems.
  prefs: []
  type: TYPE_NORMAL
- en: Are you looking for an edge in your next coding interview? You need to be able
    to compare and contrast different approaches for solving a problem, choose the
    best data structure or algorithm, and explain and implement your solution. You’ll
    practice all of these skills over and over as you read this book. Never fear hash
    tables, recursion, dynamic programming, trees, graphs, or heaps again!
  prefs: []
  type: TYPE_NORMAL
- en: Are you an independent learner working toward expertise in data structures and
    algorithms? Piecing together stuff from all over the internet can be tiring and
    lead to knowledge gaps if the right resources are not found. This book will provide
    you the solid foundation and consistent presentation that you need to become an
    expert.
  prefs: []
  type: TYPE_NORMAL
- en: 'As explored further in the next section, all code in this book is written in
    the C programming language. However, this isn’t a book on learning C. If your
    prior programming experience is in C or C++, then jump right in. If instead you’ve
    programmed in a language such as Java or Python, I suspect that you’ll pick up
    most of what you need by reading, but you may wish to review some C concepts now
    or on first encounter. In particular, I’ll use pointers and dynamic memory allocation,
    so, no matter what your prior experience, you might like to brush up on those
    topics. The best C book I can recommend is *C Programming: A Modern Approach*,
    2nd edition, by K. N. King. Even if you’re okay with C, read it anyway. It’s that
    good and a wonderful companion any time you get tripped up by C stuff.'
  prefs: []
  type: TYPE_NORMAL
- en: Our Programming Language
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ve chosen to use C as the programming language for this book, rather than
    some higher-level language such as C++, Java, or Python. I’ll discuss why and
    also justify a couple of other C-related decisions I’ve made.
  prefs: []
  type: TYPE_NORMAL
- en: '*Why Use C?*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The primary reason for using C is that I want to teach you data structures
    and algorithms from the ground up. When we want a hash table, we’ll build it ourselves.
    There will be no reliance on dictionaries or hashmaps or similar data structures
    of other languages. When we don’t know the maximum length of a string, we’ll build
    an extensible array: we won’t let the language handle memory allocation for us.
    I want you to know exactly what’s going on, with no tricks up my sleeve. Using
    C helps me toward this goal.'
  prefs: []
  type: TYPE_NORMAL
- en: Solving programming problems in C, as we do in this book, is a useful primer
    should you decide to continue with C++. If you become serious about competitive
    programming, then you’ll be happy to know that C++ is the most popular language
    used by competitive programmers, thanks to its rich standard library and ability
    to generate code that favors speed.
  prefs: []
  type: TYPE_NORMAL
- en: '*Static Keyword*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Regular local variables are stored on what’s called the *call stack*. On each
    call of a function, some of the call stack memory is used to store local variables.
    Then, when the function returns, that memory is freed up for other local variables
    to use later. The call stack is small, though, and isn’t appropriate for some
    of the massive arrays that we’ll meet in this book. Enter the `static` keyword.
    When used on a local variable, it changes the storage duration from automatic
    to static, which means that the variable maintains its value between function
    calls. As a side effect, these variables are *not* stored in the same memory area
    along with regular local variables, since then their values would be lost when
    a function is terminated. Instead, they’re stored in their own separate segment
    of memory, where they don’t have to compete with whatever else might be on the
    call stack.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to watch out for with this `static` keyword is that such local variables
    are only initialized once! For a quick example, see [Listing 1](#ch00ex1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1: A local variable with a static keyword*'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve used `static` on local variable `x` ❶. Without that, you’d expect `5`
    to be printed three times. However, since `static` is there, you should see this
    output instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Include Files*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To save space, I don’t include the `#include` lines that should be added to
    the start of C programs. You’ll be safe if you include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Freeing Memory*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unlike Java or Python, C requires the programmer to free all memory that is
    manually allocated. The pattern is to allocate memory using `malloc`, use that
    memory, and then free the memory using `free`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For two reasons, though, I do not free memory here. First, freeing memory adds
    clutter, distracting from the primary teaching purpose of the code. Second, these
    programs are not long-lived: your program will run on a few test cases, and that’s
    it. The operating system reclaims all of the unfreed memory on program termination,
    so there’s nothing to worry about even if you run a program many times. Of course,
    not freeing memory is quite irresponsible in practice: no one is happy with a
    program that consumes more and more memory as it runs. If you’d like to practice
    freeing memory, you can add calls of `free` to the programs presented in this
    book.'
  prefs: []
  type: TYPE_NORMAL
- en: Topic Selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fields of data structures and algorithms are too large to be corralled by
    one book (or by this one author!). I used three criteria to help me decide what
    topics made the cut.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, I chose topics of broad applicability: each can be used to solve not
    only the corresponding problems in the book but many other problems as well. In
    each chapter, I focus on at least two problems. I generally use the first problem
    to introduce the data structure or algorithm and one of its prototypical uses.
    The other problems are meant to give a sense of what else the data structure or
    algorithm can do. For example, in [Chapter 6](ch06.xhtml), we study Dijkstra’s
    algorithm. If you google it, you’ll see that Dijkstra’s algorithm is used to find
    shortest paths. Indeed, in the first problem of the chapter, we use it for that
    very purpose. However, in the second problem, we go further, tweaking Dijkstra’s
    algorithm to find not only the shortest path but also the number of shortest paths.
    I hope that, as you progress through each chapter, you learn more and more about
    the affordances, constraints, and subtleties of each technique.'
  prefs: []
  type: TYPE_NORMAL
- en: Second, I chose topics whose implementation did not overwhelm the surrounding
    discussion. I wanted the solution to any problem to top out at around 150 lines.
    That includes reading the input, solving the problem itself, and producing the
    output. A data structure or algorithm whose implementation took 200 or 300 lines
    was for practical reasons not suitable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Third, I chose topics that lend themselves to correctness arguments that I
    hope are convincing and intuitive. Teaching you specific data structures and algorithms
    is of course one of my goals, because I am imagining that you’re here to learn
    powerful problem-solving approaches and how to implement them. Meanwhile, I’m
    also hoping that you’re interested in *why* what you’re learning works, so I have
    more quietly pursued another goal: convincing you that the data structure or algorithm
    is correct. There won’t be formal proofs or anything like that. Nonetheless, if
    I have succeeded in my secret goal, then you’ll learn about correctness right
    along with the data structure or algorithm. Don’t be content in merely tracing
    code and marveling that it magically works every time. There is no magic, and
    the insights that make code tick are within your grasp, just as is the code itself.'
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to go beyond the chapters of this book, I recommend starting with
    [Appendix B](app02.xhtml). There, I’ve included some additional material related
    to [Chapters 1](ch01.xhtml), [3](ch03.xhtml), [5](ch05.xhtml), [8](ch08.xhtml),
    [9](ch09.xhtml), and [10](ch10.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Many readers will benefit by practicing or reading additional material as they
    progress through the book. The Notes sections at the end of the chapters point
    to additional resources, some of which contain further examples and sample problems.
    There are also online resources that offer a curated, categorized list of problems
    and their solution strategies. The *Methods to Solve* page by Steven Halim and
    Felix Halim is the most comprehensive that I’ve found; see [*https://cpbook.net/methodstosolve*](https://cpbook.net/methodstosolve).
  prefs: []
  type: TYPE_NORMAL
- en: Programming Judges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Each problem that I have chosen is available on a programming-judge website.
    Many such websites exist, each of which generally contains hundreds of problems.
    I’ve tried to keep the number of judges that we use small but large enough to
    give me the flexibility to choose the most appropriate problems. For each judge
    website, you’ll need a username and password; it’s worth setting up your accounts
    now so that you don’t have to stop to do so while working through the book. Here
    are the judges that we’ll use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Codeforces**   [*https://codeforces.com*](https://codeforces.com)'
  prefs: []
  type: TYPE_NORMAL
- en: '**DMOJ**   [*https://dmoj.ca*](https://dmoj.ca)'
  prefs: []
  type: TYPE_NORMAL
- en: '**POJ**   [*http://poj.org*](http://poj.org)'
  prefs: []
  type: TYPE_NORMAL
- en: '**SPOJ**   [*http://spoj.com*](http://spoj.com)'
  prefs: []
  type: TYPE_NORMAL
- en: '**UVa**   [*https://uva.onlinejudge.org*](https://uva.onlinejudge.org)'
  prefs: []
  type: TYPE_NORMAL
- en: Each problem description begins by indicating the judge website where the problem
    can be found and the particular problem code that you should use to access it.
  prefs: []
  type: TYPE_NORMAL
- en: 'While some problems on the judge websites are written by individual contributors,
    others are originally from well-known competitions. Here are some of the competitions
    from which problems in this book originate:'
  prefs: []
  type: TYPE_NORMAL
- en: '**International Olympiad in Informatics (IOI)**   This is a prestigious annual
    competition for high school students. Each participating country sends up to four
    participants, but each participant competes individually. The competition runs
    over two days, with multiple programming tasks on each day.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Canadian Computing Competition (CCC) and Canadian Computing Olympiad (CCO)**   These
    annual competitions for high school students are organized by the University of
    Waterloo. CCC (aka Stage 1) takes place at individual schools, with the top performers
    moving on to take the CCO (aka Stage 2) at the University of Waterloo. The top
    performers in Stage 2 represent Canada at the IOI. When I was a high school student,
    I participated in the CCC, but I never made it to the CCO—I wasn’t even close.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Croatian Open Competition in Informatics (COCI)**   This online competition
    is offered many times per year. Performance is used to determine the Croatian
    IOI team.'
  prefs: []
  type: TYPE_NORMAL
- en: '**National Olympiad in Informatics in Province (NOIP)**   This is an annual
    competition for high school students in China, similar in function to the CCC.
    The top performers are invited to the National Olympiad in Informatics (NOI),
    China. The top NOI contestants are eligible for further training and possible
    selection to China’s IOI team.'
  prefs: []
  type: TYPE_NORMAL
- en: '**South African Programming Olympiad (SAPO)**   This competition is offered
    in three rounds per year. The rounds increase in difficulty, from Round 1 to Round
    2 to the Final Round. Performance is used to select students to represent South
    Africa at the IOI.'
  prefs: []
  type: TYPE_NORMAL
- en: '**USA Computing Olympiad (USACO)**   This online competition is offered several
    times per year, the most challenging of which is the US Open competition. In each
    competition, you’ll encounter four levels of problems: bronze (easiest), silver,
    gold, and platinum (hardest). Performance is used to determine the American IOI
    team.'
  prefs: []
  type: TYPE_NORMAL
- en: '**East Central North America (ECNA) Regional Programming Contest**   In this
    annual competition for university students, the top performers are invited to
    the annual International Collegiate Programming Contest (ICPC) world finals. Unlike
    the other competitions here, where students compete individually, ECNA and the
    world finals competitions are team competitions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**DWITE**   This was an online programming contest designed to help students
    practice for annual competitions. Unfortunately, DWITE is no longer running, but
    the old problems—and they are good ones!—are still available.'
  prefs: []
  type: TYPE_NORMAL
- en: See [Appendix C](app03.xhtml) for the source of each problem in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you submit code for a problem, the judge compiles your program and runs
    it on test cases. If your program passes all test cases, and does so within the
    allotted time, then your code is accepted as correct; judges show `AC` for accepted
    solutions. If your program fails one or more test cases, then your program is
    not accepted; judges show `WA` (for “Wrong Answer”) in these cases. A final popular
    outcome is for when your program is too slow, in which case judges show `TLE`
    (“Time-Limit Exceeded”). Note that `TLE` does not mean that your code is otherwise
    correct: if your code times out, the judges do not run any further test cases,
    so there may be some `WA` bugs hidden behind the `TLE`.'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of publication, my solution for each problem passes all test cases
    within the allotted time with the specified judge. Within those base requirements,
    my aim has been to make the code readable and to choose clarity over speed. This
    is a book about teaching data structures and algorithms, not squeezing further
    performance out of a program that otherwise gets the job done.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a Problem Description
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before solving a problem, we must be precise about what we are being asked
    to do. This precision is required not only in understanding the task itself but
    also in the way that we should read input and produce output. For this reason,
    each problem begins with a problem description of three components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Problem**   Here, I provide the context for the problem and what we are
    being asked to do. It’s important to read this material carefully so that you
    know exactly what problem we’re solving. Sometimes, misreading or misinterpreting
    seemingly small words can lead to incorrect solutions. For example, one of our
    problems in [Chapter 3](ch03.xhtml) asks us to buy “at least” a certain number
    of apples: if you instead buy “exactly” that many apples, your program will fail
    some of the test cases.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input**   The author of the problem provides test cases, all of which must
    be passed for a submission to be deemed correct. It’s our responsibility to read
    each test case from the input so that we can process it. How do we know how many
    test cases there are? What is on each line of each test case? If there are numbers,
    what are their ranges? If there are strings, how long can they be? All of this
    information is provided here.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Output**   It can be very frustrating to have a program that produces the
    correct answer but fails test cases because it does not output answers in the
    correct format. The output portion of a problem description dictates exactly how
    we should produce output. For example, it will tell us how many lines of output
    to produce for each test case, what to put on each line, whether blank lines are
    required between or after test cases, and so on. In addition, I provide the time
    limit for the problem here: if the program does not output the solution for all
    test cases within the time limit, then the program does not pass.'
  prefs: []
  type: TYPE_NORMAL
- en: I have rewritten the text of each problem from the official description so that
    I can maintain a consistent presentation throughout. Despite these tweaks, my
    description will convey the same information as the official description.
  prefs: []
  type: TYPE_NORMAL
- en: For most problems in this book, we’ll read input from standard input and write
    output to standard output. (There are only two problems where standard input and
    output are not involved; they are in [Chapter 7](ch07.xhtml).) This means we should
    use C functions such as `scanf`, `getchar`, `printf`, and so on and not explicitly
    open and close files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Starter Problem: Food Lines'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s familiarize ourselves with a sample problem description. I’ll provide
    some commentary in parentheses along the way, directing your attention to the
    important bits. Once we understand the problem, I can think of nothing better
    to do than solve it. Unlike the other problems in the book, we’ll be able to do
    so with programming constructs and ideas that I hope you already know. If you
    can solve the problem on your own or work through my solution with little or no
    trouble, then I think you’re ready for what’s to come. If you get seriously stuck,
    then you may wish to revisit programming fundamentals and/or solve a few other
    starter problems before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: This is DMOJ problem `lkp18c2p1`. (You might like to go now to the DMOJ website
    and search for this problem so that you’re ready to submit our code once we’re
    done.)
  prefs: []
  type: TYPE_NORMAL
- en: '*The Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There are *n* lines of people waiting for food. We know the number of people
    that are already waiting in each line. Then, each of *m* new people will arrive,
    and they will join a shortest line (a line with the fewest number of people).
    Our task is to determine the number of people in each line that each of the *m*
    people joins.
  prefs: []
  type: TYPE_NORMAL
- en: (Spend a little time interpreting the above paragraph. There’s an example coming
    next, so if anything is unclear, try to remedy it with the combination of the
    above paragraph and the example below.)
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example. Suppose that there are three lines of people, with three
    people in Line 1, two people in Line 2, and five people in Line 3\. Then, four
    new people arrive. (Try to work out what happens for this case before reading
    the rest of this paragraph.) The first person joins a line with two people, Line
    2; now Line 2 has three people. The second person joins a line with three people,
    Line 1 or Line 2—let’s say Line 1; Line 1 now has four people. The third person
    joins a line with three people, Line 2; Line 2 now has four people. The fourth
    and final person joins a line with four people, Line 1 or Line 2—let’s say Line
    1; Line 1 now has five people.
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The input contains one test case. The first line of input contains two positive
    integers, *n* and *m*, giving the number of lines of people and number of new
    people, respectively. *n* and *m* are at most 100\. The second line of input contains
    *n* positive integers, giving the number of people in each line of people before
    the new people arrive. Each of these integers is at most 100.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the input for the above test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: (Note how there is exactly one test case here. Therefore, we should expect to
    read exactly two lines of input.)
  prefs: []
  type: TYPE_NORMAL
- en: Output
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For each of the *m* new people, output a line containing the number of people
    in the line that they join.
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct output for the above test case is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The time limit for solving the test case is three seconds. (Given that we have
    to handle at most 100 new people for each test case, three seconds is a long time.
    We won’t need any fancy data structures or algorithms.)
  prefs: []
  type: TYPE_NORMAL
- en: '*Solving the Problem*'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For problems involving data structures that are difficult to build by hand,
    I may start by reading the input. Otherwise, I tend to save that code for last.
    The reason for this is that we can generally test the functions we’re writing
    by calling them with sample values; there is no need to worry about parsing the
    input until we’re ready to solve the whole problem.
  prefs: []
  type: TYPE_NORMAL
- en: The key data that we need to maintain are the number of people in each line.
    The appropriate storage technique is an array, using one index per line. We’ll
    use a variable named `lines` for that array.
  prefs: []
  type: TYPE_NORMAL
- en: Each new person that arrives chooses to join a shortest line, so we’ll need
    a helper function to tell us which line that is. That helper function is given
    in [Listing 2](#ch00ex2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 2: Index of a shortest line*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, given a `lines` array and `n` and `m`, we can solve a test case, the code
    for which is given in [Listing 3](#ch00ex3):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3: Solving the problem*'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each iteration of the `for` loop, we call our helper function to grab the
    index of the shortest line. We then print the length of that shortest line. This
    person then joins that line: that’s why we must increment the number of people
    in that line by one ❶.'
  prefs: []
  type: TYPE_NORMAL
- en: All that’s left is to read the input and call `solve`; that’s done in [Listing
    4](#ch00ex4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 4: The main function*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting together our `shortest_line_index`, `solve`, and `main` functions and
    adding the required `#include` lines at the top gives us a complete solution that
    we can submit to the judge. When doing so, be sure to choose the correct programming
    language: for the programs in this book, you want to find GCC, or C99, or C11,
    or however the judge refers to a compiler for C.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to test your code locally before submitting it to the judge, then
    you have a few options. Since our programs read from standard input, one thing
    you can do is run the program and type a test case by hand. That’s a reasonable
    thing to do for small test cases, but it’s tedious doing that over and over, especially
    for large test cases. (You may also need to issue an end-of-file control code
    after you type the input, such as CTRL-Z on Windows or CTRL-D on other operating
    systems.) A better option is to store the input in a file and then use *input
    redirection* from the command prompt to have the program read from that file instead
    of the keyboard. For example, if you store a test case for the present problem
    in file *food.txt*, and your compiled program is called *food*, then try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes it easy to play with many test cases: just change what’s in *food.txt*
    and then run the program with input redirection again.'
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You’ve solved your first problem. Moreover, you now know our
    game plan for each problem in the book, as we’ll use the same general structure
    I have given here. We’ll first understand the problem itself and work through
    some examples. Then we’ll start writing code to solve the problem. We won’t always
    get it right the first time, though. Maybe our code will be too slow or fail some
    specific test cases. That’s okay! We’ll learn new data structures and algorithms
    and then strike back at the problem. Eventually, we will solve each one—and after
    each such experience, we will know more and be better programmers than when we
    started.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get to it.
  prefs: []
  type: TYPE_NORMAL
- en: Online Resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Supplementary resources for this book, including downloadable code and additional
    exercises, are available at [*https://nostarch.com/algorithmic-thinking-2nd-edition*](https://nostarch.com/algorithmic-thinking-2nd-edition).
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Food Lines is originally from the 2018 LKP Contest 2, hosted by DMOJ.
  prefs: []
  type: TYPE_NORMAL
