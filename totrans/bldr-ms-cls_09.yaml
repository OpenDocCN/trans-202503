- en: Chapter 9. Hair and Particle Systems
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 9 章. 头发与粒子系统
- en: Blender’s particle systems are a powerful tool that you can use to create both
    static and dynamic hair and animated particle effects. They can also be used to
    populate your scene with instanced objects in order to create grass and other
    foliage. In this chapter, we’ll use Blender’s hair particles to create fur for
    the Bat Creature and to create grass for the Jungle Temple scene.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Blender 的粒子系统是一个强大的工具，可以用来创建静态和动态的头发及动画粒子效果。它们还可以用来在场景中填充实例化的物体，从而创建草地和其他植物。在本章中，我们将使用
    Blender 的头发粒子为蝙蝠生物创建毛发，并为丛林神庙场景创建草地。
- en: When you add a particle system to an object, the system is initially set up
    as a dynamic one that spawns point particles that are then simulated using Blender’s
    physics engine. In this chapter, though, we’ll mostly use the “hair” type for
    particles to create strands that are emitted from the surface of your mesh by
    default (see [Figure 9-1](ch09.html#standard_particle_system_in_blender_with "Figure 9-1. The
    standard particle system in Blender with the particle system type set to hair")).
    These strands will respond to physics and can be combed over the surface of your
    model and be procedurally modified to look like hair, fur, grass, or a variety
    of other materials. You’ll learn how to move from the default system shown in
    [Figure 9-1](ch09.html#standard_particle_system_in_blender_with "Figure 9-1. The
    standard particle system in Blender with the particle system type set to hair")
    to creating realistic hair and fur that we’ll add materials to in [Chapter 12](ch12.html
    "Chapter 12. Materials") and then render in [Chapter 14](ch14.html "Chapter 14. Rendering
    and Compositing").
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将粒子系统添加到物体上时，系统最初设置为动态粒子系统，它会生成点状粒子，并通过 Blender 的物理引擎进行模拟。不过，在本章中，我们主要使用粒子的“头发”类型来创建从网格表面发射的发丝（默认为此类型，参见[图
    9-1](ch09.html#standard_particle_system_in_blender_with "图 9-1. Blender 中的标准粒子系统，粒子系统类型设置为头发")）。这些发丝将响应物理影响，并可以在模型表面上梳理，还可以通过程序化方法修改，呈现出头发、毛发、草或其他多种材质的效果。你将学会如何从[图
    9-1](ch09.html#standard_particle_system_in_blender_with "图 9-1. Blender 中的标准粒子系统，粒子系统类型设置为头发")中展示的默认系统开始，逐步创建真实的头发和毛发，接着在[第
    12 章](ch12.html "第 12 章. 材质")中为其添加材质，然后在[第 14 章](ch14.html "第 14 章. 渲染与合成")中进行渲染。
- en: Particles for Hair
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 头发粒子
- en: 'In order to make Blender’s basic particle system resemble fur or hair, we need
    to give it some guidance. First, we determine where and how we want the fur to
    grow, after which we can comb the resulting hair for more control over how it
    looks. But rather than do this for hundreds of thousands of hairs on a body, we’ll
    define a few hairs by hand as parent particles and then have Blender fill in the
    rest with child particles automatically. These stages are represented in [Figure 9-2](ch09.html#hair_particle_systems_at_different_stage
    "Figure 9-2. Hair particle systems at different stages"): First, the particle
    system is added 1; then, the hair is restricted to some areas with a vertex group
    2; next, it’s combed 3; and finally, child particles are added 4. You then have
    a basic render 5.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Blender 的基本粒子系统呈现出毛发或头发效果，我们需要给它一些引导。首先，我们要确定毛发的生长位置和方式，然后我们可以梳理生成的头发，以更好地控制它的外观。但我们不会对模型上的成千上万根头发进行逐一梳理，而是先手动定义一些作为父粒子的头发，然后让
    Blender 自动通过子粒子填充其余部分。这些步骤在[图 9-2](ch09.html#hair_particle_systems_at_different_stage
    "图 9-2. 不同阶段的头发粒子系统")中有所展示：首先，添加粒子系统 1；接着，使用顶点组限制头发生长的区域 2；然后，梳理头发 3；最后，添加子粒子
    4。最终，你将得到一个基础渲染效果 5。
- en: Choosing an Object to Add Hair To
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择添加头发的物体
- en: One question to think about when creating the hair or fur for a model is what
    mesh you want to assign the particle system to, as this can be approached in several
    ways. The simplest option is to just add a particle system to the mesh you have
    modeled and intend to texture and render later. However, this means that you can
    no longer edit your mesh (at least beyond moving vertices), as changes to the
    vertex order of your model will corrupt the hair.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在为模型创建头发或毛发时，需要思考的一个问题是，你希望将粒子系统赋予哪个网格，因为这一点可以通过多种方式来处理。最简单的选择是将粒子系统直接添加到你已建模并打算后续纹理化和渲染的网格上。然而，这意味着你将无法再编辑网格（至少无法编辑顶点顺序），因为对模型顶点顺序的修改会破坏头发的效果。
- en: '![The standard particle system in Blender with the particle system type set
    to hair](httpatomoreillycomsourcenostarchimages1538592.png.jpg)Figure 9-1. The
    standard particle system in Blender with the particle system type set to hair![Hair
    particle systems at different stages](httpatomoreillycomsourcenostarchimages1538594.png.jpg)Figure 9-2. Hair
    particle systems at different stages'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '![Blender中的标准粒子系统，粒子系统类型设置为头发](httpatomoreillycomsourcenostarchimages1538592.png.jpg)图9-1.
    Blender中的标准粒子系统，粒子系统类型设置为头发！[不同阶段的头发粒子系统](httpatomoreillycomsourcenostarchimages1538594.png.jpg)图9-2.
    不同阶段的头发粒子系统'
- en: In the case of the Bat Creature, the final render will be done using a mesh
    created by applying some of the multires subdivision to the model and leaving
    the rest to be re-created using a displacement map. Because this will require
    creating a new mesh, I could either wait until that stage before creating the
    hair or create the hair system using a different mesh, which I would keep in the
    .*blend* file for the final render later. The latter option allows me to work
    on a “safe” mesh, which I can then use to work on the fur—the mesh won’t change
    if I make further changes (within reason) to the “skin” model later. I will use
    this mesh only to hold the hair for the character, and its surface will not be
    rendered.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于蝙蝠生物，最终渲染将使用通过对模型应用某些Multires细分而创建的网格，并将其余部分通过位移贴图重新创建。因为这需要创建一个新的网格，我可以选择在该阶段创建头发，或者使用不同的网格创建头发系统，并将其保存在.*blend*文件中以便最终渲染时使用。后者的选项让我可以在一个“安全”的网格上工作，然后继续为毛发进行工作——如果稍后对“皮肤”模型进行进一步修改（在合理范围内），这个网格不会改变。我将仅使用这个网格来容纳角色的头发，并且其表面不会被渲染。
- en: Creating a Scalp
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建头皮
- en: A similar strategy can be useful when creating a haircut for a character. While
    we might wish to make all kinds of changes to the model for a head, the shape
    of the skull is likely to remain reasonably static. In order to keep the hair
    separate, then, it is often useful to create a “scalp” object to which the hair
    can be added by duplicating the head mesh and deleting any parts that aren’t needed
    (see [Figure 9-3](ch09.html#creating_a_scalp_to_hold_the_particle_sy "Figure 9-3. Creating
    a scalp to hold the particle system for a character’s hair. This allows you to
    keep modifying the model for the head without disturbing the hair. Here, the two
    are shown side by side, but generally they would be on top of one another.")).
    The particle system for the hair can then be added to this object.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在为角色设计发型时，类似的策略也很有用。虽然我们可能希望对头部模型进行各种修改，但头骨的形状很可能保持相对静态。因此，为了保持头发与模型的分离，通常有用的方法是创建一个“头皮”对象，将头发添加到该对象上，这可以通过复制头部网格并删除不需要的部分来实现（参见[图9-3](ch09.html#creating_a_scalp_to_hold_the_particle_sy
    "图9-3. 创建头皮以容纳角色头发的粒子系统。这使得你可以继续修改头部模型，而不会影响头发。在这里，二者并排显示，但通常它们会重叠在一起。")）。然后，头发的粒子系统可以添加到这个对象中。
- en: '![Creating a scalp to hold the particle system for a character’s hair. This
    allows you to keep modifying the model for the head without disturbing the hair.
    Here, the two are shown side by side, but generally they would be on top of one
    another.](httpatomoreillycomsourcenostarchimages1538596.png.jpg)Figure 9-3. Creating
    a scalp to hold the particle system for a character’s hair. This allows you to
    keep modifying the model for the head without disturbing the hair. Here, the two
    are shown side by side, but generally they would be on top of one another.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '![创建头皮以容纳角色头发的粒子系统。这使得你可以继续修改头部模型，而不会影响头发。在这里，二者并排显示，但通常它们会重叠在一起。](httpatomoreillycomsourcenostarchimages1538596.png.jpg)图9-3.
    创建头皮以容纳角色头发的粒子系统。这使得你可以继续修改头部模型，而不会影响头发。在这里，二者并排显示，但通常它们会重叠在一起。'
- en: For the Bat Creature, I created a new mesh to hold the particle system by duplicating
    my sculpted high-resolution mesh and applying the Multires modifier at level 1\.
    To do this on a mesh that has shape keys, use the Convert to Mesh operator (ALT-C▸**Mesh
    from Curve/Meta/Text**). This applies all modifiers and shape keys to the mesh.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于蝙蝠生物，我通过复制我的雕刻高分辨率网格并应用Multires修改器在1级上，创建了一个新的网格来容纳粒子系统。对于具有形状键的网格，可以使用“转换为网格”操作符（ALT-C▸**从曲线/元件/文本生成网格**）。这将所有修改器和形状键应用到网格上。
- en: Vertex Groups for Hair
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 头发的顶点组
- en: By default, particle systems emit particles from all over the surface of an
    object. In order to restrict hair to specific areas of a model and control the
    length and behavior of the hair, we use vertex groups. A *vertex group* is a subset
    of the vertices in a mesh, like the legs of a character or a specific part of
    a wall. You can assign vertices to these groups either in Edit mode or Weight
    Paint mode.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，粒子系统从物体表面的各个地方发射粒子。为了将头发限制在模型的特定区域并控制头发的长度和行为，我们使用顶点组。*顶点组*是网格中顶点的子集，像角色的腿部或墙壁的特定部分。你可以在编辑模式或权重绘制模式下将顶点分配给这些组。
- en: Vertices can also be partially assigned to a group, with their weighting for
    the group (that is, how strongly they belong to it) given any value between 0
    and 1\. This allows for smooth gradients and blending between vertices that are
    and are not assigned to groups.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点也可以部分分配给一个组，且该组的权重（即它们属于该组的程度）可以设置为0到1之间的任何值。这允许在分配和未分配到组的顶点之间进行平滑渐变和混合。
- en: Once created, vertex groups can be used to control the effects of modifiers,
    to make it easy to quickly select vertices in Edit mode, and to influence particle
    systems. By using vertex groups, we can “paint” hair placement in Weight Paint
    mode and then assign the vertex group to the particle settings to tell Blender
    to create particles only where we want them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，顶点组可以用于控制修改器的效果，便于在编辑模式下快速选择顶点，并影响粒子系统。通过使用顶点组，我们可以在权重绘制模式下“绘制”头发的位置，然后将顶点组分配给粒子设置，告诉Blender只在我们想要的位置创建粒子。
- en: Weight Painting
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 权重绘制
- en: Blender offers two methods of editing vertex groups. The first is to manually
    assign weights to a group in Edit mode, using the buttons in the Object Data tab
    of the Properties editor and the tools in the Properties region of the 3D Viewport
    (press **N** to bring this up). This method is useful for defining more precise
    groups, like the ones we used in [Chapter 4](ch04.html "Chapter 4. Blocking In")
    and [Chapter 6](ch06.html "Chapter 6. Sculpting") to restrict the effect of the
    Displace modifier.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Blender提供了两种编辑顶点组的方法。第一种是在编辑模式下手动为一个组分配权重，使用属性编辑器中的对象数据标签的按钮和3D视图区域中的工具（按**N**可以调出）。这种方法适用于定义更精确的组，比如我们在[第4章](ch04.html
    "第4章. 阻塞")和[第6章](ch06.html "第6章. 雕刻")中使用的，用来限制位移修改器的效果。
- en: But if your goal is to produce smoother, less precise groups with more variation
    and randomness, Blender’s Weight Paint mode tools (shown in [Figure 9-4](ch09.html#weight_paint_modedot_red_areas_represent
    "Figure 9-4. Weight Paint mode. Red areas represent vertices fully assigned to
    the current group, and blue areas represent vertices that are not assigned to
    the current group.")) are a better option. Entering Weight Paint mode (CTRL-TAB,
    or use the mode drop-down menu in the 3D Viewport header) allows you to paint
    vertex weights using brushes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你的目标是生成更平滑、更不精确的组，并且有更多的变化和随机性，Blender的权重绘制模式工具（如[图9-4](ch09.html#weight_paint_modedot_red_areas_represent
    "图9-4. 权重绘制模式。红色区域表示完全分配给当前组的顶点，蓝色区域表示未分配给当前组的顶点")所示）会是更好的选择。进入权重绘制模式（CTRL-TAB，或者使用3D视图头部的模式下拉菜单）可以使用画笔绘制顶点权重。
- en: 'The standard brush tools in Weight Paint mode are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 权重绘制模式中的标准画笔工具如下：
- en: '****Mix****. Replaces the current weighting with the weight specified by the
    brush. This is the standard brush for painting vertex groups.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '****混合****。用画笔指定的权重替换当前的权重。这是绘制顶点组的标准画笔。'
- en: '****Blur****. Blurs vertex weights between neighboring vertices and is useful
    for smoothing transitions.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '****模糊****。模糊相邻顶点之间的权重，适用于平滑过渡。'
- en: '****Add****. Adds to the vertices’ weight.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '****添加****。增加顶点的权重。'
- en: '****Subtract****. Subtracts from the vertices’ weight. This brush is useful
    as an eraser.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '****减法****。从顶点的权重中减去一个值。这个画笔作为橡皮擦非常有用。'
- en: '****Multiply****. Multiplies the vertices’ current weight by a particular value.
    Set the weight to 0 to use this as an eraser; use higher values to reduce vertex
    weights without completely removing vertices from the current group.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '****乘法****。将顶点当前的权重乘以一个特定的值。将权重设置为0可以作为橡皮擦使用；使用更高的值可以减少顶点的权重，而不完全从当前组中移除顶点。'
- en: '****Lighten****. Replaces the vertices’ current weight with the weight you
    specify for the brush if the new weight is greater.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '****加亮****。如果新权重大于当前顶点的权重，则将顶点的当前权重替换为你指定的权重。'
- en: '****Darken****. Replaces the vertices’ current weight with the weight you specify
    for the brush if the new weight is less.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '****加深****。如果新权重较小，它将用您指定的权重替换顶点当前的权重。'
- en: Blender’s default brushes work pretty well, so you probably won’t need to make
    your own, though you can do so in much the same way as described in [Chapter 6](ch06.html
    "Chapter 6. Sculpting").
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Blender 的默认画笔效果很好，因此您可能不需要自己制作画笔，尽管您可以按照[第 6 章](ch06.html "第 6 章。雕刻")中描述的方法来制作。
- en: '![Weight Paint mode. Red areas represent vertices fully assigned to the current
    group, and blue areas represent vertices that are not assigned to the current
    group.](httpatomoreillycomsourcenostarchimages1538598.png.jpg)Figure 9-4. Weight
    Paint mode. Red areas represent vertices fully assigned to the current group,
    and blue areas represent vertices that are not assigned to the current group.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '![权重绘制模式。红色区域表示完全分配给当前组的顶点，蓝色区域表示未分配给当前组的顶点。](httpatomoreillycomsourcenostarchimages1538598.png.jpg)
    图 9-4。权重绘制模式。红色区域表示完全分配给当前组的顶点，蓝色区域表示未分配给当前组的顶点。'
- en: Hair Density
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 毛发密度
- en: To control where the Bat Creature’s hair will grow, I needed to paint a vertex
    group that defined where I wanted hair and where I didn’t. I began by adding a
    new vertex group that I’ll call *hair density*. Then in Weight Paint mode (CTRL-TAB),
    I began assigning areas I wanted to be furry to the group using a Mix type brush.
    I could remove areas using the Subtract brush and smooth the transition between
    hairy and hairless areas with the Blur brush. (Because I am editing only the hair
    density for now, the boundaries of the vertex group will still have long hairs.
    To make the hairy regions fade out into shorter hairs, I will create a second
    vertex group in a minute to control the hair length.)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制蝙蝠生物毛发的生长位置，我需要绘制一个顶点组，定义我希望毛发生长的位置以及不希望毛发生长的位置。我首先添加了一个新的顶点组，命名为*毛发密度*。然后在权重绘制模式下（CTRL-TAB），我开始使用混合类型画笔为我希望有毛发的区域分配到该组。使用减去画笔可以去除一些区域，并且可以使用模糊画笔平滑毛发区域和无毛发区域之间的过渡。（因为我现在只编辑毛发密度，所以顶点组的边界仍然会有长毛发。为了让毛发区域渐变成较短的毛发，我稍后会创建一个第二个顶点组来控制毛发长度。）
- en: '[Figure 9-4](ch09.html#weight_paint_modedot_red_areas_represent "Figure 9-4. Weight
    Paint mode. Red areas represent vertices fully assigned to the current group,
    and blue areas represent vertices that are not assigned to the current group.")
    shows my hair-density group: Areas on the upper body and upper legs are fully
    assigned to the group, areas like the arms and lower legs are only partially assigned,
    and areas like the wings and face that are to remain hairless are not assigned
    at all.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 9-4](ch09.html#weight_paint_modedot_red_areas_represent "图 9-4。权重绘制模式。红色区域表示完全分配给当前组的顶点，蓝色区域表示未分配给当前组的顶点。")
    显示了我的毛发密度组：上半身和大腿上部的区域完全分配给该组，像手臂和小腿这样的区域部分分配，而像翅膀和面部这些不希望有毛发的区域则没有分配。'
- en: To completely remove part of a mesh from a vertex group, you can use the Subtract
    brush in Weight Paint mode, but it’s easier to do this precisely in Edit mode.
    To do so, use the Object Data tab of the Properties editor to edit vertex groups
    and manually add or remove vertices by selecting them in Edit mode and pressing
    the Assign or Remove buttons. For example, for the Bat Creature, I manually selected
    the wings and removed them from the density (and length) vertex group to be sure
    the wings wouldn’t grow hair.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全从顶点组中移除网格的一部分，您可以在权重绘制模式下使用减去画笔，但在编辑模式下做得更精确。为此，使用属性编辑器的对象数据选项卡来编辑顶点组，并通过在编辑模式中选择顶点，按“分配”或“移除”按钮来手动添加或删除顶点。例如，在蝙蝠生物的情况下，我手动选择了翅膀，并将其从密度（和长度）顶点组中移除，以确保翅膀不会长毛。
- en: Hair Length
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 毛发长度
- en: The hair-length vertex group (see [Figure 9-5](ch09.html#hair-length_vertex_group
    "Figure 9-5. The hair-length vertex group")) controls the length of the hair by
    defining how long the hair created by our particle system will grow, relative
    to the maximum length we choose in the Particle System settings. This group is
    similar to the hairdensity group, except that I assigned the chest and pelvis
    much more than other areas, giving them the longest hair, and I blurred the weights
    more significantly between areas to produce a smooth transition in hair length.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 头发长度顶点组（见[图 9-5](ch09.html#hair-length_vertex_group "图 9-5. 头发长度顶点组")）通过定义我们粒子系统所创建的头发的生长长度，控制头发的长度，相对于我们在粒子系统设置中选择的最大长度。这个组类似于头发密度组，不同之处在于我给胸部和骨盆分配了比其他区域更多的权重，从而使它们拥有最长的头发，并且我在不同区域之间显著模糊了权重，产生了头发长度的平滑过渡。
- en: When painting the length group, you can paint outside the bounds of the hair-density
    group without fear because hair will not grow outside the density group. This
    allows you, for example, to grow long hair right up to the edge of the density
    group, if you wish.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘制长度组时，你可以在头发密度组的边界外进行绘制，而不用担心，因为头发不会在密度组之外生长。这允许你，例如，在密度组的边缘生长长发，如果你愿意的话。
- en: '![The hair-length vertex group](httpatomoreillycomsourcenostarchimages1538600.png.jpg)Figure 9-5. The
    hair-length vertex group'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '![头发长度顶点组](httpatomoreillycomsourcenostarchimages1538600.png.jpg)图 9-5. 头发长度顶点组'
- en: Adding a Particle System
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加粒子系统
- en: Having added the basic hair vertex groups, I next created a particle system
    to “grow” the hair. To do so, I went to the Particles tab of the Properties editor
    and added a new particle system using the + icon on the right. (You can add additional
    particle systems to the same object and switch between them using the selector
    at the top of the Particles tab.)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了基本的头发顶点组之后，我接下来创建了一个粒子系统来“生长”头发。为此，我进入了属性编辑器的粒子选项卡，通过右侧的+图标添加了一个新的粒子系统。（你可以在同一物体上添加多个粒子系统，并通过粒子选项卡顶部的选择器在它们之间切换。）
- en: Adding a new particle system brings up a whole slew of panels, like the ones
    shown earlier in [Figure 9-1](ch09.html#standard_particle_system_in_blender_with
    "Figure 9-1. The standard particle system in Blender with the particle system
    type set to hair"). I began modifying some of these. First, I changed the particle
    system type from an emitter of dynamic particles to a hair system by changing
    the type setting to Hair. This change initially caused the mesh to look like a
    crazy hairball. To turn the hair particle system into something useful, I used
    the vertex groups I created for hair length and density to restrict the hair growth.
    Then, I assigned the settings for the particles and combed and cut the hair to
    make it look the way I wanted. To make going through these stages easier, I’ll
    first discuss the main panels for particle systems when creating hair-type particle
    systems. These are discussed below in the order they appear in the Particles tab
    of the Properties editor.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新的粒子系统会弹出一大堆面板，就像在[图 9-1](ch09.html#standard_particle_system_in_blender_with
    "图 9-1. Blender中的标准粒子系统，粒子系统类型设置为头发")中显示的那样。我开始修改其中的一些。首先，我将粒子系统类型从动态粒子发射器改为头发系统，通过将类型设置更改为“Hair”。这一更改最初导致网格看起来像个疯狂的毛球。为了将头发粒子系统变得有用，我使用了我为头发长度和密度创建的顶点组来限制头发的生长。然后，我为粒子分配了设置，梳理并修剪了头发，使其看起来符合我的要求。为了让这些阶段更容易理解，我将首先讨论在创建头发类型粒子系统时，粒子系统的主要面板。它们按顺序在“属性编辑器”的“粒子”选项卡中讨论。
- en: Particle System Properties
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 粒子系统属性
- en: 'At the top of the Particles tab in the Properties editor, you’ll find a panel
    showing the existing particle systems assigned to the active object. Below this
    are a few basic options that define what sort of particle system you are creating:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性编辑器的粒子选项卡顶部，你会看到一个面板，显示分配给活动物体的现有粒子系统。下面是一些基本选项，用于定义你正在创建的粒子系统类型：
- en: '****Type (Hair/Emitter)****. Set this to *Hair* for creating hair and fur.
    The Emitter type is for creating dynamic, point-particle stems.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '****类型（头发/发射器）****。将此设置为*Hair*以创建头发和毛发。发射器类型用于创建动态的点粒子。'
- en: '****Advanced****. Turn this on for greater control over particle emission.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '****高级****。打开此选项以获得对粒子发射的更大控制。'
- en: '****Segments****. This determines how many control points are used per strand
    of hair in order to control the shape of the hair. More control points mean you
    can incorporate more twists and bends into your project. For short hair and fur,
    the default value of 5 is fine, but for longer haircuts, consider turning the
    value up.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '****细分****。这决定了每根发丝使用多少个控制点，以便控制发型的形状。更多的控制点意味着你可以在项目中加入更多的扭曲和弯曲。对于短发和毛发，默认值5就足够了，但对于更长的发型，可以考虑将该值调高。'
- en: Emission Panel
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发射面板
- en: This panel controls how many particles are emitted from your mesh and their
    distribution.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此面板控制从你的网格中发射的粒子数量及其分布。
- en: '****Number****. Determines the number of particles the particle system will
    generate. If you use child particles in the settings, the total number of particles
    will be this setting multiplied by the number of child particles. Keep this in
    mind when setting up a hair particle system because for the same final number
    of particles, you could create lots of parents and fewer children, or fewer parents
    and more children. In general, you want to have to edit as few strands as possible,
    while maintaining control over the look of the hair over the surface of the mesh.
    So when adding hair to a simple head, Blender’s default of 1,000 might be a little
    high, but for larger areas (for example, when covering a whole creature in fur),
    you might want to increase this value. For the Bat Creature, I chose a value of
    2,000.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '****数量****。决定粒子系统将生成的粒子数量。如果在设置中使用了子粒子，那么粒子的总数量将是此设置乘以子粒子的数量。在设置头发粒子系统时请记住这一点，因为对于相同的最终粒子数，你可以创建很多父粒子和较少的子粒子，或者较少的父粒子和更多的子粒子。一般来说，你希望尽量编辑较少的发丝，同时控制头发在网格表面上的外观。所以在给简单的头部添加头发时，Blender的默认值1,000可能会稍高，但对于更大的区域（例如覆盖整个生物的毛发）时，你可能需要增加这个值。对于蝙蝠生物，我选择了2,000这个值。'
- en: '****Emit From (Verts/Faces/Volume)****. Determines where hair particles are
    emitted from, such as from the vertices of the mesh, scattered over its faces,
    or from inside the volume of a closed mesh.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '****从（顶点/面/体积）发射****。决定头发粒子从何处发射，比如从网格的顶点发射、散布在其面上，或从封闭网格的体积内部发射。'
- en: '****Random****. Emits particles randomly, ignoring the order in which you created
    the faces of your mesh. Leave this set to *Random* for hair.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '****随机****。随机发射粒子，忽略你创建网格面的顺序。对于头发，将其保持为*随机*。'
- en: '****Even Distribution****. Scales the number of particles emitted from each
    face according to the face’s area. Leave this checked, or large faces will appear
    sparsely populated with hair when compared to smaller faces.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '****均匀分布****。根据面部的面积，调整每个面发射的粒子数量。勾选此选项，否则较大的面在与较小面相比时，会显得头发分布稀疏。'
- en: '****Jittered/Random, Particles Per Face, and Jittering Amount****. These settings
    control how the emission locations for particles are generated. The default values
    almost always work well.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '****抖动/随机、每面粒子数和抖动量****。这些设置控制粒子发射位置的生成方式。默认值通常效果很好。'
- en: Velocity Panel
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 速度面板
- en: The settings in the Velocity panel basically determine how long your hairs will
    be and in what direction they’ll point. The random and normal values are most
    important here. *Normal* values cause hair to point straight out from the surface,
    while *random* values make the hair point in random directions. Combining the
    two will allow you to point the hair generally away from the head with the normal
    value, while keeping a little roughness with the random value. The other settings
    in this panel can be useful if you want the hair to point in a specific direction
    (such as straight up, using the *Z* value).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 速度面板中的设置基本上决定了头发的长度和方向。这里最重要的是随机值和法线值。*法线*值使头发从表面笔直地指向外面，而*随机*值则使头发朝随机方向指向。将这两者结合起来，可以使头发大致从头部指向外侧，使用法线值控制，同时保持一定的粗糙感，使用随机值。此面板中的其他设置可以在你希望头发指向特定方向时很有用（例如，使用*Z*值让头发直立）。
- en: Rotation
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 旋转
- en: The Rotation panel isn’t particularly important when working with strand-particle
    hair, but if you set the render type for the particle system to Object or Group,
    you can use the settings here to add random rotation to the objects as they are
    generated. This feature is a great way to prevent particle systems that use the
    Object render type from looking too repetitive by making it more difficult to
    recognize repeated objects.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用发束粒子头发时，旋转面板并不是特别重要，但如果你将粒子系统的渲染类型设置为“对象”或“组”，你可以使用此处的设置为生成的对象添加随机旋转。此功能是防止使用对象渲染类型的粒子系统看起来过于重复的好方法，使得重复的对象更难被识别出来。
- en: Render
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染
- en: This panel contains settings for how your particles will be rendered in the
    final image. These settings, listed below, will interact with the material we
    apply to the particles later on in [Chapter 12](ch12.html "Chapter 12. Materials").
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此面板包含了粒子在最终图像中如何渲染的设置。以下列出的设置将在[第12章](ch12.html "第12章。材质")中与应用于粒子的材质进行交互。
- en: '****Material****. This determines what material slot (in the Materials tab
    of the Properties editor) the hair particles will use. For example, if your first
    material slot for the object is the skin material for your model, you could set
    this to 2 and use the second slot to define the hair material.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '****材质****。此设置决定头发粒子将使用哪个材质槽（在属性编辑器的材质标签中）。例如，如果你为模型的第一个材质槽设置了皮肤材质，你可以将其设置为2，并使用第二个槽来定义头发材质。'
- en: '****Emitter****. When this setting is checked, both the hair and its emitter
    mesh will render; when unchecked, only the hair itself will render. This setting
    is useful to disable if you are using an object other than your “skin” object
    to generate hair or if you’re generating objects with a particle system and you
    want to render only those instanced objects.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '****发射器****。选中此设置时，头发及其发射网格都会被渲染；未选中时，仅渲染头发本身。如果你使用的发射器不是你的“皮肤”对象，或者你正在使用粒子系统生成对象并只想渲染这些实例化的对象时，此设置非常有用。'
- en: '****Parents****. If you are using child particles, this setting will cause
    the parent particles to be rendered along with the children.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '****父物体****。如果你使用子粒子，此设置将导致父粒子与子粒子一起渲染。'
- en: '****None/Path/Object/Group****. This setting determines which renderable geometry
    the particle system will use for particle generation. The default setting of *Path*
    is used to create particle hair, but a particle system can also be used to create
    other kinds of geometry. Setting this to *Object* will turn each hair particle
    into a duplicate of the object chosen in the box that appears, and setting it
    to *Group* will choose objects from a group and duplicate them in the same way.
    These options are useful for making grass or for populating a surface with extra
    details, like rocks or debris. The *None* option will cause particles not to be
    rendered.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '****无/路径/对象/组****。此设置决定粒子系统将使用哪种可渲染的几何体来生成粒子。默认的*路径*设置用于创建粒子头发，但粒子系统也可以用来创建其他类型的几何体。将其设置为*对象*会将每个头发粒子转化为所选对象的副本，而将其设置为*组*则会从一个组中选择对象并以相同的方式复制它们。这些选项适用于制作草地或在表面上增加细节，如石头或碎片。*无*选项将导致粒子不被渲染。'
- en: 'For hair, choose the Path option, which brings up the following additional
    settings that determine how particle hair will be rendered:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于头发，选择“路径”选项，该选项会弹出以下附加设置，决定粒子头发如何渲染：
- en: '****Strand Render****. This uses Blender’s custom strand primitive to render
    hair and fur in a way that produces much faster results. The downside to this
    rendering method is that it’s not compatible with ray-traced shadows, so you will
    need to use spot lamps with buffer shadows instead.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '****发束渲染****。此方法使用Blender的自定义发束原语渲染头发和毛发，从而产生更快的渲染结果。此渲染方法的缺点是它与光线追踪阴影不兼容，因此你需要使用带有缓冲阴影的聚光灯来代替。'
- en: '****Adaptive Renderer****. This option for rendering hair is compatible with
    ray tracing and optimizes the hair geometry, simplifying bends in the hair so
    that long, straight sections use less geometry than more complex, curved parts
    of strands. This keeps the total amount of geometry used for hair to a minimum
    and thus can speed up renders.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '****自适应渲染器****。这个渲染头发的选项兼容光线追踪，并优化头发的几何形状，简化头发的弯曲部分，使得长的直发部分比复杂的弯曲部分使用更少的几何体积。这可以将头发所用的几何体积降到最小，从而加速渲染。'
- en: '****Degrees****. The strand renderer renders hairs in a sequence of straight
    sections, and this value determines how many degrees the underlying curve must
    bend through in order to create a new section. Smaller values will result in smoother-looking
    hair but will take longer to render as they will generate more sections.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '****度数****。发丝渲染器按直线段顺序渲染头发，这个值决定了基础曲线必须弯曲多少度才能生成一个新段。较小的值会生成更平滑的头发，但渲染时间较长，因为它们会生成更多的段。'
- en: '****B-Spline****. This method uses a Bézier-like curve to render hair strands,
    resulting in much smoother curves but with some loss of detail in the shape of
    your edited hair as the curve is smoothed out.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '****B样条曲线****。这种方法使用类似 Bézier 曲线的方式来渲染发丝，能够生成更平滑的曲线，但在平滑处理过程中会丧失一些发型细节。'
- en: '****Steps****. This method determines how many sections in total are generated
    for the hair curve, expressed as the number of times the hair is subdivided. For
    example, a value of 3 will make the hair twice as smooth (twice as many sections)
    as 2, and a value of 4 will make the hair curve twice as smooth again.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '****步骤****。该方法决定了为头发曲线生成的总段数，表示为头发被细分的次数。例如，值为 3 会使头发比 2 时平滑两倍（即段数增加两倍），而值为
    4 会使头发曲线再平滑两倍。'
- en: Display
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示
- en: This panel works like the Render panel but defines how your particles appear
    in the 3D Viewport. Turning these settings down can often speed up the 3D Viewport
    when working with complex particle systems, while turning them up can give you
    a better feel for what your rendered particles will actually look like.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个面板的功能类似于渲染面板，但定义了粒子在 3D 视口中的显示方式。调低这些设置通常可以加快 3D 视口的响应速度，特别是在处理复杂粒子系统时，而调高这些设置可以让你更好地预览渲染后的粒子效果。
- en: '****None/Rendered/Path****. These options allow you to determine how particles
    appear in the 3D Viewport. Setting this to *Rendered* will use the display type
    used for the render. *None* prevents the particle system being drawn at all in
    the 3D Viewport, and *Path* draws particles as paths regardless of the render
    type.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '****无/渲染/路径****。这些选项允许你确定粒子在 3D 视口中的显示方式。将此设置为*渲染*将使用渲染时的显示类型。*无*会阻止粒子系统在 3D
    视口中显示，*路径*则会将粒子作为路径显示，无论渲染类型如何。'
- en: '****Display (Percentage)****. This option sets the proportion of the total
    number of hairs visible in the 3D Viewport. Lower settings will reduce the strain
    on your machine when working with complex hair systems.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '****显示（百分比）****。这个选项设置在 3D 视口中可见的头发总数的比例。较低的设置可以减少在处理复杂发型系统时对计算机的压力。'
- en: '****Size, Velocity, Number****. These options will draw the corresponding datum
    for each particle on screen next to that particle datum (that is, the particle’s
    size, velocity, or ID number).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '****大小、速度、数量****。这些选项会在每个粒子旁边显示相应的数据（即粒子的大小、速度或 ID 号）。'
- en: '****Color (Material/Velocity/Acceleration/None)****. This option is more relevant
    for emitter particle systems. Leave it set to *Material* for hair particles.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '****颜色（材质/速度/加速度/无）****。这个选项更适用于发射器粒子系统。对于头发粒子，保持设置为*材质*。'
- en: '****Steps****. This option determines how many subdivisions are used to draw
    the hair in the 3D Viewport (as in the render options). Set this higher if you
    need to work on complex hairstyles or lower if you need a more responsive 3D Viewport.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '****步骤****。这个选项决定了在 3D 视口中绘制头发时使用多少细分（如同渲染选项中的细分）。如果你需要处理复杂的发型，请将此值设置得更高；如果你需要更灵敏的
    3D 视口，请将此值设置得较低。'
- en: Children
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子粒子
- en: Here, we get to the most powerful aspect of particle systems. Child particles
    work by treating each original parent particle created by the particle system
    as a guide for creating further particles. Not only does this let you define relatively
    few particles and then create a great many more, but it also allows you to add
    novel features, like clumping, twisting, and even braiding, to the hair around
    the parent particle guides, making your hair look more varied and interesting.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们进入粒子系统的最强大部分。子粒子通过将粒子系统创建的每个原始父粒子视为进一步创建粒子的指南来工作。这不仅让你可以定义相对较少的粒子并生成更多的粒子，还允许你为父粒子周围的头发增加新的特性，如团聚、扭曲甚至编织，使头发看起来更加多样化和有趣。
- en: '****None/Simple/Interpolated****. Simple particles are a basic option that
    creates a basic bundle of child particles around each original parent, all of
    which follow the same path as their parent. Simple children aren’t attached to
    the mesh surface, and they don’t use vertex-group inputs to influence how they
    are generated. Other than in basic hair systems, simple children don’t usually
    look as good as interpolated children. This is because interpolated children are
    generated from the surface of the mesh just like parent hairs, and then they interpolate
    their paths from the various parent particles around them. Interpolated children
    generally give nicer results, so assume for this chapter that we are using interpolated
    child particles.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '****无/简单/插值****。简单粒子是一种基本选项，在每个原始父母周围创建一束基本的子粒子，它们都遵循与父母相同的路径。简单子粒子没有附着在网格表面上，并且不使用顶点组输入来影响它们的生成方式。除非在基本头发系统中，简单子粒子通常不如插值子粒子看起来好。因为插值子粒子就像父母头发一样从网格表面生成，然后它们根据周围的不同父母粒子插值自己的路径。插值子粒子通常能提供更好的效果，因此在本章中我们假设使用插值子粒子。'
- en: '****Display****. Determines how many child particles to create and display
    in the 3D Viewport.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '****显示****。决定在 3D 视口中创建和显示多少子粒子。'
- en: '****Render****. Determines how many child particles to create at render time.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '****渲染****。确定在渲染时要创建多少子粒子。'
- en: '****Seed****. Lets you choose the random seed for use in generating child particles.
    If you have a few child particles that you really don’t like, try changing this
    value.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '****种子****。让你选择用于生成子粒子的随机种子。如果你不喜欢一些子粒子，可以尝试更改这个值。'
- en: '****Virtual Parents****. Creates extra virtual parent particles before generating
    children, which gives the children more targets to clump to or kink around, making
    the hair look more varied.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '****虚拟父母****。在生成子粒子之前创建额外的虚拟父母粒子，这为子粒子提供更多的目标，使其能够聚集或绕着父母粒子弯曲，从而使头发看起来更加多样化。'
- en: '****Clump****. Causes child hairs to clump together around their parents, making
    the hair look matted or spiky. Negative values cause hairs to puff out toward
    the ends instead. The *shape* value determines how far up the hairs start to clump.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '****簇集****。使子头发围绕父母粒子聚集在一起，造成头发看起来是打结或尖刺状的。负值会导致头发向末端膨胀。*形状*值决定了头发开始聚集的距离。'
- en: '****Length****. Determines how long the child particles grow as a proportion
    of the parent particle length. The threshold value below this setting allows some
    particles to reach the full length, while others are cut down to the shorter value
    specified by the Length setting.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '****长度****。决定子粒子的生长长度与父母粒子长度的比例。低于该设置的阈值允许一些粒子达到完整的长度，而其他粒子则被剪短到长度设置中指定的较短值。'
- en: '****Parting Controls****. These options only appear if Virtual Parents is set
    to 0\. Turning up the parting (cap) amount forces child particles to pick a side
    when interpolating between parents that point in different directions. As you
    might imagine, this is useful for parting hair (though as we will see later, there
    are other ways). The *min* and *max* values determine the range of angles or distances
    between parent hairs that child particles will part over.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '****发缝控制****。这些选项只有在虚拟父母设置为 0 时才会出现。增加发缝（帽子）量会强制子粒子在插值不同方向的父母粒子之间时选择一边。正如你可能想象的那样，这对于分发头发非常有用（尽管我们稍后会看到还有其他方法）。*最小*和*最大*值决定了子粒子在父母头发之间分缝时的角度或距离范围。'
- en: '****Roughness****. You can apply three kinds of roughness to the child hairs.
    The *Uniform Rough* setting roughens up the hair depending on location, affecting
    all hairs in a local area in the same way. The *size* value determines the scale
    of these perturbations. The *Endpoint Rough* setting randomizes the endpoints
    of the hairs, pushing them farther apart (much like the opposite of the Clump
    setting). The *Random Rough* setting roughens the hairs independently, with the
    *size* value determining the scale of perturbations and the *threshold* value
    determining what proportion of hairs are left unaffected by this roughening. (Random
    roughness is good for adding stray hairs or for making hair look frizzy.)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '****粗糙度****。你可以将三种粗糙度应用到子头发上。*均匀粗糙度*设置根据位置粗化头发，影响局部区域内的所有头发。*大小*值决定这些扰动的尺度。*末端粗糙度*设置会随机化头发的末端，将它们推得更远（类似于簇集设置的反向效果）。*随机粗糙度*设置独立地使头发变粗，*大小*值决定扰动的尺度，*阈值*值决定有多少比例的头发不受此粗糙化影响。（随机粗糙度适用于增加杂乱的头发或让头发看起来蓬乱。）'
- en: '****Kink (Nothing/Curl/Radial/Wave/Braid)****. These options (shown in [Figure 9-6](ch09.html#different_kink_settings_applied_to_the_c
    "Figure 9-6. Different kink settings applied to the children of a single parent
    particle. Left to right: No Kink (but with Clump turned on so that the strands
    come to a point), Curl, Radial, Wave, and Braid.")) add secondary patterns to
    the way the child hairs follow the parents. *Curl* causes the hair to form curls,
    *Radial* makes the hairs move periodically closer and farther apart, *Wave* adds
    waves to the hair, and *Braid* makes them form a threestranded braid. The settings
    below these choices determine the amplitude and frequency of this secondary pattern,
    as well as how it is affected by clumping and distributed along the hairs using
    the *shape* value. The *flatness* value causes the hairs to flatten together when
    taking on these secondary shapes.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![Different kink settings applied to the children of a single parent particle.
    Left to right: No Kink (but with Clump turned on so that the strands come to a
    point), Curl, Radial, Wave, and Braid.](httpatomoreillycomsourcenostarchimages1538602.png.jpg)Figure 9-6. Different
    kink settings applied to the children of a single parent particle. Left to right:
    No Kink (but with Clump turned on so that the strands come to a point), Curl,
    Radial, Wave, and Braid.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: Vertex Groups
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this panel, you can assign various vertex groups to control the settings
    over the surface of a mesh. This panel is where we apply the vertex groups we
    created earlier in order to control the density and length of our initial parent
    hairs before combing and cutting them (see [Figure 9-7](ch09.html#using_vertex_groups_to_control_hair_leng
    "Figure 9-7. Using vertex groups to control hair length and density. You can add
    vertex groups for the other properties later on, but this is all we need for now.")).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '![Using vertex groups to control hair length and density. You can add vertex
    groups for the other properties later on, but this is all we need for now.](httpatomoreillycomsourcenostarchimages1538604.png.jpg)Figure 9-7. Using
    vertex groups to control hair length and density. You can add vertex groups for
    the other properties later on, but this is all we need for now.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Using vertex groups to control particle systems affects both the initial generation
    of parent particles and the later distribution of child particles. However, once
    you start editing the parent particles in Particle mode, you can add or remove
    particles and edit them independently of the properties defined by vertex groups
    using the Particle mode brushes, as discussed in the next section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Particle Mode
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having set up a basic hair system, you can edit it in Particle mode (see [Figure 9-8](ch09.html#combing_fur_in_particle_mode
    "Figure 9-8. Combing fur in Particle mode")), using a variety of tools that let
    you grow, comb, cut, and smooth your hair or fur, as well as add or delete hairs.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: You can switch to Particle mode from the mode drop-down menu in the header of
    the 3D Viewport. Once in Particle mode, the hair particles in the currently selected
    particle system become editable. (At the same time, you will no longer be able
    to edit the Particle Emission settings in the Properties editor, unless you click
    Free Edit at the top of the Particle Settings tab to scrap your edited particles
    and start again.) Similar to Sculpt mode, Particle mode brings up a list of brushes
    in the Tool Shelf on the left of the 3D Viewport, along with some options for
    how these brushes affect your particles.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从3D视图头部的模式下拉菜单中切换到粒子模式。一旦进入粒子模式，当前选中的粒子系统中的毛发粒子就变得可编辑。（同时，你将无法再在属性编辑器中编辑粒子发射设置，除非你点击粒子设置标签顶部的Free
    Edit按钮，以废弃你编辑的粒子并重新开始。）与雕刻模式类似，粒子模式会在3D视图的左侧工具架上列出一组刷子，并提供一些选项来控制这些刷子如何影响你的粒子。
- en: Shaping Your Hair
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 塑造你的毛发
- en: In Particle mode, I began shaping and styling the hair for the Bat Creature
    using Blender’s particle brushes. I first used the Comb tool to flatten the hair
    and get it to flow along with the contours of the body (see [Figure 9-8](ch09.html#combing_fur_in_particle_mode
    "Figure 9-8. Combing fur in Particle mode")), adding some peaks and scruffy areas
    as well. By default, when you comb hair in Particle mode, it’s deflected by the
    emitter mesh, making it easy to comb it along the mesh’s surface. (You can turn
    this off using the *Deflect Emitter* option from the Tool Shelf, if you wish.)
    If the hair in an area gets a bit too flat, use the Puff tool to fluff it back
    up. (The Puff tool causes the hairs to repel one another and generally spread
    out.)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在粒子模式下，我开始使用Blender的粒子刷为蝙蝠生物塑造和修饰毛发。我首先使用了梳理工具将毛发压平，并使其沿着身体的轮廓流动（见[图9-8](ch09.html#combing_fur_in_particle_mode
    "图9-8. 在粒子模式下梳理毛发")），同时添加了一些峰值和凌乱的区域。默认情况下，当你在粒子模式下梳理毛发时，它会受到发射器网格的影响，从而使毛发容易沿网格的表面梳理。（如果需要，你可以通过工具架上的*Deflect
    Emitter*选项关闭这一功能。）如果某个区域的毛发变得过于平坦，可以使用Puff工具将其蓬松起来。（Puff工具使毛发相互排斥，通常会使毛发分散开来。）
- en: '![Combing fur in Particle mode](httpatomoreillycomsourcenostarchimages1538606.png.jpg)Figure 9-8. Combing
    fur in Particle mode'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![在粒子模式下梳理毛发](httpatomoreillycomsourcenostarchimages1538606.png.jpg)图9-8. 在粒子模式下梳理毛发'
- en: To control the length of the hair strands, the Length and Cut tools are the
    most useful. The Length tool allows you to grow or shrink hairs to adjust their
    length, while the Cut tool cuts them back away from the brush as you make strokes
    with it. The Cut tool will also completely remove a hair if you cut it right down
    to the base, so this is a useful technique for getting rid of awkward hairs that
    are causing your child particles to behave strangely. (If it’s difficult to see
    the base of a strand, try switching to wireframe view and zooming in.)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制毛发的长度，Length和Cut工具是最有用的。Length工具允许你拉长或缩短毛发以调整其长度，而Cut工具则能在你刷动时将毛发从刷子中剪掉。Cut工具还可以完全剪掉毛发，直到根部，因此这是去除那些让子粒表现异常的尴尬毛发的一个有用技巧。（如果很难看到毛发的根部，可以尝试切换到线框视图并放大。）
- en: You can also add extra hairs using the Add brush, which creates new hairs wherever
    you stroke. Turning on the *Interpolate* option (usually advisable) causes new
    hairs to follow the direction of surrounding ones that already exist, which comes
    in handy when adding extra hairs to an area you have already combed. For example,
    with the Bat Creature, I added some extra hairs to the ears and around the feet
    and hands to better define the flow of the hair around these areas.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用Add刷子添加额外的毛发，它会在你刷动的地方生成新的毛发。打开*Interpolate*选项（通常建议使用）会让新毛发跟随周围已有毛发的方向，这在你为已经梳理过的区域添加额外毛发时特别有用。例如，在制作蝙蝠生物时，我在耳朵和脚趾、手指周围添加了一些额外的毛发，以更好地定义这些区域的毛发流向。
- en: Styling Tips
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样式建议
- en: Be sure when styling to rotate the model frequently to see it from different
    angles. As you rotate it, think about the silhouette you are carving out as well
    as the direction the hair is pointing and use the Cut tool to trim stray hairs
    that disrupt the silhouette. If you cut any hairs too short, you can use the Length
    brush to grow hair back out.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在修饰毛发时，务必经常旋转模型，从不同的角度查看它。当你旋转时，要考虑你正在雕刻的轮廓以及毛发的方向，并使用Cut工具修剪那些破坏轮廓的杂毛。如果你剪得太短了，可以使用Length刷子重新拉长毛发。
- en: You can select and manipulate individual or multiple hairs as you would in Edit
    mode, using the right mouse button to select and the **G**, **S**, and **R** keys
    to grab, rotate, and scale strands. You can also switch between different selection
    methods in Particle mode, selecting either the whole hair or individual points
    along it or just choosing to comb and cut the overall path. This is analogous
    to being able to choose between selecting vertices, edges, or faces in Edit mode.
    Selecting hair strands can be useful for dealing with tricky areas, as the brush
    tools will work only on selected strands, allowing you to select specific particle
    hairs that are causing issues and comb or cut them in isolation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像在编辑模式中一样选择和操作单根或多根毛发，使用右键点击来选择，然后按**G**、**S**和**R**键来抓取、旋转和缩放发丝。你还可以在粒子模式中切换不同的选择方法，可以选择整根毛发，或选择沿着毛发的单个点，或者仅仅选择梳理和剪切整体路径。这类似于在编辑模式中可以选择顶点、边缘或面一样。选择毛发发丝对于处理棘手区域非常有用，因为刷子工具只会对选中的发丝进行操作，允许你选中出现问题的特定粒子毛发，并在单独的区域内梳理或剪切它们。
- en: Another useful trick is to press **L** to select hairs under the cursor. Hold
    down **L** and wave the mouse over an area to select a few hairs at random. Then,
    comb them independently. This works well for roughening up hair and adding volume.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的小技巧是按**L**来选择光标下的毛发。按住**L**并将鼠标移动到一个区域，可以随机选择几根毛发。然后，你可以独立地整理这些毛发。这对于打乱发型和增加发量效果非常有效。
- en: Child Particles
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子粒子
- en: Once you have the basic hairstyle roughly in place, turn on **Child Particles**
    in the Particles tab to see what effect it has on the look of your hair. Set the
    child type to **Interpolated** and set the **Display** number of particles to
    about **50**. (The Render number can be a lot higher, but keep in mind how this
    will affect the total number of hairs and thus your render times.)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦基本的发型大致确定，启用**子粒子**选项，在粒子面板中查看它对发型外观的影响。将子粒子类型设置为**插值**，并将**显示**的粒子数量设置为大约**50**。（渲染数量可以设置得更高，但要记住，这会影响到总的毛发数量，从而影响渲染时间。）
- en: For the Bat Creature, I set Virtual Parents to 0.3 and Clump to 0.5, and I added
    a very small amount of Random, Endpoint, and Uniform Roughness (around 0.001 to
    0.01 for each, as these are sensitive settings). Turning up the virtual parents
    gives the child particles more parent strands to clump around and prevents the
    hair from looking too patchy. Adding some roughness makes it look less neat and
    smooth.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于蝙蝠生物，我将虚拟父母设置为0.3，团簇设置为0.5，并且添加了非常小的随机、端点和均匀粗糙度（每个大约为0.001到0.01，因为这些是敏感设置）。增加虚拟父母可以让子粒子有更多的父发丝来团簇，从而防止毛发看起来过于零散。添加一些粗糙度可以让毛发看起来不那么整洁光滑。
- en: I also added some variation to the particle length using a Length setting of
    0.5, and I set the threshold value to 0.15 to produce hair of different lengths
    and to give a more natural look to the fur (see [Figure 9-9](ch09.html#particle_settings_for_the_bat_creature
    "Figure 9-9. Particle settings for the Bat Creature")).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我还通过将长度设置为0.5并将阈值设置为0.15，增加了粒子长度的变化，从而产生不同长度的毛发，给毛发增添了更自然的外观（见[图9-9](ch09.html#particle_settings_for_the_bat_creature
    "图9-9. 蝙蝠生物的粒子设置")）。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Returning to Particle mode will hide your child particles by default, but
    you can turn them on in the draw options in the 3D Viewport Tool Shelf by checking
    the Children option.*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*返回粒子模式将默认隐藏子粒子，但你可以通过在3D视图工具架中的绘制选项勾选子粒子选项来开启它们。*'
- en: When working on hair systems, it can be useful to render occasionally, as the
    shading of hairs in the 3D Viewport can look flat and ambiguous. You may want
    to skip to [Chapter 12](ch12.html "Chapter 12. Materials") for a discussion of
    materials for hair and then create a quick render setup for use while you are
    working on hair (see [Figure 9-10](ch09.html#fur_for_the_bat_creaturedot_while_the_3d
    "Figure 9-10. The fur for the Bat Creature. While the 3D Viewport gives a good
    estimate of what the hair is doing, a render will really show you what areas need
    attention. Here, I set the skin of my character to black to see the hair on its
    own and rendered it with a simple three-point light setup. (See Chapter 12 to
    learn how to set up materials and Chapter 13 for lighting.)")). See [Chapter 13](ch13.html
    "Chapter 13. Lighting") for how to light the scene and [Chapter 14](ch14.html
    "Chapter 14. Rendering and Compositing") for more on rendering.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理头发系统时，偶尔进行渲染是很有用的，因为在 3D 视口中的头发阴影看起来可能很平坦且模糊不清。你可能想跳到[第 12 章](ch12.html "第
    12 章. 材质")，了解有关头发材质的讨论，然后创建一个快速渲染设置，以便在你处理头发时使用（参见[图 9-10](ch09.html#fur_for_the_bat_creaturedot_while_the_3d
    "图 9-10. 蝙蝠生物的毛发。虽然 3D 视口能够较好地估计头发的表现，但渲染结果能真正显示出需要注意的区域。在这里，我将角色的皮肤设置为黑色，以便单独查看头发，并用简单的三点光源进行了渲染。（详见第
    12 章了解如何设置材质，第 13 章了解照明。）"))。参见[第 13 章](ch13.html "第 13 章. 照明")了解如何照亮场景，并参见[第
    14 章](ch14.html "第 14 章. 渲染与合成")了解更多关于渲染的内容。
- en: '![Particle settings for the Bat Creature](httpatomoreillycomsourcenostarchimages1538608.png.jpg)Figure 9-9. Particle
    settings for the Bat Creature![The fur for the Bat Creature. While the 3D Viewport
    gives a good estimate of what the hair is doing, a render will really show you
    what areas need attention. Here, I set the skin of my character to black to see
    the hair on its own and rendered it with a simple three-point light setup. (See
    to learn how to set up materials and for lighting.)](httpatomoreillycomsourcenostarchimages1538610.png.jpg)Figure 9-10. The
    fur for the Bat Creature. While the 3D Viewport gives a good estimate of what
    the hair is doing, a render will really show you what areas need attention. Here,
    I set the skin of my character to black to see the hair on its own and rendered
    it with a simple three-point light setup. (See [Chapter 12](ch12.html "Chapter 12. Materials")
    to learn how to set up materials and [Chapter 13](ch13.html "Chapter 13. Lighting")
    for lighting.)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![蝙蝠生物的粒子设置](httpatomoreillycomsourcenostarchimages1538608.png.jpg)图 9-9. 蝙蝠生物的粒子设置![蝙蝠生物的毛发。虽然
    3D 视口能够较好地估计头发的表现，但渲染结果能真正显示出需要注意的区域。在这里，我将角色的皮肤设置为黑色，以便单独查看头发，并用简单的三点光源进行了渲染。（详见了解如何设置材质和照明。）](httpatomoreillycomsourcenostarchimages1538610.png.jpg)图
    9-10. 蝙蝠生物的毛发。虽然 3D 视口能够较好地估计头发的表现，但渲染结果能真正显示出需要注意的区域。在这里，我将角色的皮肤设置为黑色，以便单独查看头发，并用简单的三点光源进行了渲染。（详见[第
    12 章](ch12.html "第 12 章. 材质")了解如何设置材质和[第 13 章](ch13.html "第 13 章. 照明")了解照明。）'
- en: Peach Fuzz
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 桃毛
- en: I also decided to add a second particle system to my Bat Creature to incorporate
    some short hair that covered more of the body, like the head, ears, and some of
    the wings. I made this in exactly the same way as the first system. I started
    by adding another new particle system to the same object as the first, this time
    with a much shorter length. Then, I created a vertex group to limit this hair
    to the body, head, and the beginnings of the wings. I didn’t need a length vertex
    group this time, as the hair was all very short. Next, I combed the hair to follow
    the contours of the body and added child particles to increase the hair density.
    The resulting particle system can be seen in [Figure 9-11](ch09.html#peach_fuzz_particle_system_for_the_bat_c
    "Figure 9-11. The Peach Fuzz particle system for the Bat Creature adds fine hairs
    covering most of the body.").
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我还决定为我的蝙蝠生物添加第二个粒子系统，以增加一些短发，覆盖更多的身体部位，例如头部、耳朵和一些翅膀。我是按照与第一个粒子系统完全相同的方式制作的。我从为与第一个粒子系统相同的物体添加另一个新的粒子系统开始，这次粒子的长度要短得多。然后，我创建了一个顶点组，将这些头发限制在身体、头部和翅膀的开始部分。这次我不需要长度顶点组，因为这些头发都非常短。接下来，我将头发梳理成跟随身体轮廓的样子，并添加了子粒子以增加头发的密度。最终的粒子系统可以在[图
    9-11](ch09.html#peach_fuzz_particle_system_for_the_bat_c "图 9-11. 蝙蝠生物的桃毛粒子系统，增加了覆盖大部分身体的细毛。")中看到。
- en: '![The Peach Fuzz particle system for the Bat Creature adds fine hairs covering
    most of the body.](httpatomoreillycomsourcenostarchimages1538612.png.jpg)Figure 9-11. The
    Peach Fuzz particle system for the Bat Creature adds fine hairs covering most
    of the body.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![蝙蝠生物的“桃毛”粒子系统为其大部分身体覆盖上了细小的毛发。](httpatomoreillycomsourcenostarchimages1538612.png.jpg)图9-11.
    蝙蝠生物的“桃毛”粒子系统为其大部分身体覆盖上了细小的毛发。'
- en: Complex Haircuts
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂发型
- en: The hair for the Bat Creature was pretty simple, so let’s look at a character
    with a more complex hairdo. The character in [Figure 9-12](ch09.html#using_different_particle_systems_with_un
    "Figure 9-12. Using different particle systems with unique Density vertex groups
    allows more control over the look of each. Here, I have created separate vertex
    groups for the hair, goatee, eyebrows, and stubble.") uses several different particle
    systems, each of which covers different areas of the overall hairstyle. Each system
    is restricted to its own area by a separate vertex group, allowing it to be edited
    separately.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 蝙蝠生物的头发相对简单，所以我们来看一个发型更复杂的角色。[图9-12](ch09.html#using_different_particle_systems_with_un
    "图9-12. 使用不同的粒子系统，并为每个系统设置独特的密度顶点组，可以更好地控制每个部分的外观。在这里，我为头发、山羊胡、眉毛和胡茬分别创建了独立的顶点组。")中的角色使用了几种不同的粒子系统，每种系统覆盖了整体发型的不同区域。每个系统通过独立的顶点组限制在其自身的区域内，从而可以单独编辑。
- en: Creating hair this way makes it easier to iterate through different styles and
    create more complex hair because you can edit individual aspects without worrying
    about their effect on others.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式创建头发，可以更轻松地迭代不同的发型，并创造出更复杂的发型，因为你可以单独编辑各个方面，而不必担心它们对其他部分的影响。
- en: '[Figure 9-13](ch09.html#multiple_particle_hair_systems_combine_t "Figure 9-13. Multiple
    particle hair systems combine to create the full effect. Here, five different
    hair systems are used to create the final hairstyle on the bottom right. Each
    can be combed and have its settings adjusted separately, allowing considerably
    more control.") shows a character that makes full use of this strategy with different
    hair particle systems that all use different settings. For example, the braids
    in the beard are single parent strands that use the Braid Kink setting for children,
    while other systems use different kink settings. This technique is often useful
    when creating a hairstyle with a parting of some kind because splitting the hair
    into two particle systems makes it much easier to comb outward from the parting
    on either side.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-13](ch09.html#multiple_particle_hair_systems_combine_t "图9-13. 多个粒子头发系统结合在一起，创建出完整的效果。在这里，使用了五个不同的头发系统，最终的发型位于右下角。每个系统都可以单独梳理并调整设置，从而提供更多的控制。")展示了一个充分利用这一策略的角色，使用了多个粒子头发系统，每个系统都有不同的设置。例如，胡须中的辫子是使用“辫子扭曲”设置的单根父级发丝，而其他系统则使用不同的扭曲设置。这种技术在创建带有分发的发型时特别有用，因为将头发分成两个粒子系统可以使从分发两侧向外梳理变得更容易。'
- en: '![Using different particle systems with unique Density vertex groups allows
    more control over the look of each. Here, I have created separate vertex groups
    for the hair, goatee, eyebrows, and stubble.](httpatomoreillycomsourcenostarchimages1538614.png.jpg)Figure 9-12. Using
    different particle systems with unique Density vertex groups allows more control
    over the look of each. Here, I have created separate vertex groups for the hair,
    goatee, eyebrows, and stubble.![Multiple particle hair systems combine to create
    the full effect. Here, five different hair systems are used to create the final
    hairstyle on the bottom right. Each can be combed and have its settings adjusted
    separately, allowing considerably more control.](httpatomoreillycomsourcenostarchimages1538616.png.jpg)Figure 9-13. Multiple
    particle hair systems combine to create the full effect. Here, five different
    hair systems are used to create the final hairstyle on the bottom right. Each
    can be combed and have its settings adjusted separately, allowing considerably
    more control.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用不同的粒子系统，并为每个系统设置独特的密度顶点组，可以更好地控制每个部分的外观。在这里，我为头发、山羊胡、眉毛和胡茬分别创建了独立的顶点组。](httpatomoreillycomsourcenostarchimages1538614.png.jpg)图9-12.
    使用不同的粒子系统，并为每个系统设置独特的密度顶点组，可以更好地控制每个部分的外观。在这里，我为头发、山羊胡、眉毛和胡茬分别创建了独立的顶点组。![多个粒子头发系统结合在一起，创建出完整的效果。在这里，使用了五个不同的头发系统，最终的发型位于右下角。每个系统都可以单独梳理并调整设置，从而提供更多的控制。](httpatomoreillycomsourcenostarchimages1538616.png.jpg)图9-13.
    多个粒子头发系统结合在一起，创建出完整的效果。在这里，使用了五个不同的头发系统，最终的发型位于右下角。每个系统都可以单独梳理并调整设置，从而提供更多的控制。'
- en: Controlling Particles with Textures
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用纹理控制粒子
- en: While so far we have focused on using vertex groups to control particle hair
    properties, Blender can also use texture input to control aspects of particle
    systems in the same way that we use vertexes. To use a texture this way, first
    assign a particle system to your mesh, switch to the Textures tab of the Properties
    editor, and click the **Particle Textures** icon (see [Figure 9-14](ch09.html#using_a_texture_to_control_hair_particle
    "Figure 9-14. Using a texture to control hair particles. Here, a procedural Voronoi
    texture has been used to affect particle length. You can use both procedural and
    image textures to affect particle properties.")). Now you can add textures and
    use them for the same inputs as you would vertex groups, including the density
    and length of hair for hair particles, as well as clump, kink, and rough values.
    (Values such as time and velocity are used for dynamic point particle systems.)
    By default, white will be mapped to 1.0, and black to 0.0 for these values.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然到目前为止我们一直集中在使用顶点组控制粒子头发属性，Blender也可以使用纹理输入来控制粒子系统的各个方面，方式与我们使用顶点相同。要以这种方式使用纹理，首先将粒子系统分配给网格，切换到属性编辑器的纹理标签，点击**粒子纹理**图标（见[图9-14](ch09.html#using_a_texture_to_control_hair_particle
    "图9-14. 使用纹理控制头发粒子。在这里，使用了一种程序Voronoi纹理来影响粒子的长度。你可以使用程序纹理和图像纹理来影响粒子属性。")）。现在，你可以添加纹理，并将其用于与顶点组相同的输入，包括头发粒子的密度和长度，以及毛发的团簇、扭曲和粗糙值。（诸如时间和速度等值用于动态点粒子系统。）默认情况下，白色将映射为1.0，黑色映射为0.0。
- en: Controlling particle systems with textures allows you to use Blender’s procedural
    textures to add variation to how a hair or fur system looks. For example, by using
    a cloud texture to affect the rough value of the fur for the Bat Creature, I could
    quickly add some randomized roughness to the creature’s hair, without having to
    edit vertex groups manually.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纹理控制粒子系统可以让你使用Blender的程序纹理，为头发或毛发系统的外观增加变化。例如，通过使用云纹理来影响蝙蝠生物毛发的粗糙值，我可以迅速为生物的毛发添加一些随机的粗糙度，而无需手动编辑顶点组。
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Textures can also be used to affect the look of particles through Blender’s
    materials, as you’ll learn in [Chapter 12](ch12.html "Chapter 12. Materials").*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*纹理也可以通过Blender的材质影响粒子的外观，正如你将在[第12章](ch12.html "第12章. 材质")中学习的那样。*'
- en: Other Uses for Particle Systems
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 粒子系统的其他用途
- en: In addition to modeling hair and fur, Blender’s particle systems are useful
    for numerous other tasks. For example, for the Jungle Temple, I used a particle
    system to create patches of grass on the ground, using the Group render type to
    duplicate a few different grass objects many times.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 除了建模头发和毛发，Blender的粒子系统还可用于许多其他任务。例如，对于丛林神庙，我使用粒子系统在地面上创建了一些草地，使用Group渲染类型将几种不同的草地物体复制多次。
- en: Grass for the Jungle Temple
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 丛林神庙的草地
- en: While I placed most of the plants in the Jungle Temple scene by hand, I used
    a particle system to generate some grass around my scene. While hair strands on
    their own can look a lot like grass with the right materials, I chose to create
    models for the individual blades of grass. Then, I used a particle system to scatter
    them around the scene, as shown in [Figure 9-15](ch09.html#simple_grass_modelsdot_these_are_all_jus
    "Figure 9-15. Simple grass models. These are all just planes and cylinders that
    are subdivided, stretched, and grabbed with proportional editing to form them
    into the stems and leaves of the grass. Each is a separate object with its origin
    at the base of the plant.").
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我手动放置了大多数植物在丛林神庙场景中，但我使用了粒子系统来生成场景周围的一些草地。虽然单独的头发丝在适当的材质下看起来非常像草，但我选择为每根草叶创建模型。然后，我使用粒子系统将它们散布在场景中，如[图9-15](ch09.html#simple_grass_modelsdot_these_are_all_jus
    "图9-15. 简单草模型。这些都是仅仅经过细分、拉伸并通过比例编辑拉伸成草茎和草叶的平面和圆柱体。每个都是一个独立的物体，其原点位于植物的底部。")所示。
- en: '![Using a texture to control hair particles. Here, a procedural Voronoi texture
    has been used to affect particle length. You can use both procedural and image
    textures to affect particle properties.](httpatomoreillycomsourcenostarchimages1538618.png.jpg)Figure 9-14. Using
    a texture to control hair particles. Here, a procedural Voronoi texture has been
    used to affect particle length. You can use both procedural and image textures
    to affect particle properties.![Simple grass models. These are all just planes
    and cylinders that are subdivided, stretched, and grabbed with proportional editing
    to form them into the stems and leaves of the grass. Each is a separate object
    with its origin at the base of the plant.](httpatomoreillycomsourcenostarchimages1538620.png.jpg)Figure 9-15. Simple
    grass models. These are all just planes and cylinders that are subdivided, stretched,
    and grabbed with proportional editing to form them into the stems and leaves of
    the grass. Each is a separate object with its origin at the base of the plant.![The
    density vertex group for my grass particle system, shown here with grass growing
    on the assigned areas](httpatomoreillycomsourcenostarchimages1538622.png.jpg)Figure 9-16. The
    density vertex group for my grass particle system, shown here with grass growing
    on the assigned areas'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用纹理控制毛发粒子。在这里，使用了一个程序化的 Voronoi 纹理来影响粒子的长度。你可以使用程序化纹理和图像纹理来影响粒子的属性。](httpatomoreillycomsourcenostarchimages1538618.png.jpg)图
    9-14. 使用纹理控制毛发粒子。在这里，使用了一个程序化的 Voronoi 纹理来影响粒子的长度。你可以使用程序化纹理和图像纹理来影响粒子的属性。![简单的草模型。这些只是一些被细分、拉伸，并通过比例编辑抓取的平面和圆柱体，形成草的茎和叶。每个模型都是一个独立的物体，原点位于植物的根部。](httpatomoreillycomsourcenostarchimages1538620.png.jpg)图
    9-15. 简单的草模型。这些只是一些被细分、拉伸，并通过比例编辑抓取的平面和圆柱体，形成草的茎和叶。每个模型都是一个独立的物体，原点位于植物的根部。![我草粒子系统的密度顶点组，这里显示的是在指定区域上生长的草](httpatomoreillycomsourcenostarchimages1538622.png.jpg)图
    9-16. 我草粒子系统的密度顶点组，这里显示的是在指定区域上生长的草'
- en: Creating a Grass Particle System
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建草粒子系统
- en: To create grass this way, I needed some models for different blades or clumps
    of grass and then a particle system (added to my ground mesh) that would duplicate
    and scatter these models around the scene. First, I created a few different grass
    models (see [Figure 9-15](ch09.html#simple_grass_modelsdot_these_are_all_jus "Figure 9-15. Simple
    grass models. These are all just planes and cylinders that are subdivided, stretched,
    and grabbed with proportional editing to form them into the stems and leaves of
    the grass. Each is a separate object with its origin at the base of the plant."))
    and added them all into a single group (CTRL-G). Next, I added a new particle
    system to the ground mesh in my Jungle Temple and created a vertex group for the
    grass density and length (as I did for the hair) to place the grass in just a
    few key areas (see [Figure 9-16](ch09.html#density_vertex_group_for_my_grass_partic
    "Figure 9-16. The density vertex group for my grass particle system, shown here
    with grass growing on the assigned areas")). Then, I set the render type for the
    particle system to Group and chose my grass group as the group to use (the Dupli
    Group setting). Finally, I enabled the Use Count option to determine how each
    member of the group was duplicated so that the small grass models repeated more
    often than the larger ones (see [Figure 9-17](ch09.html#particle_settings_for_the_grass_systemdo
    "Figure 9-17. The particle settings for the grass system. To give different orientations
    and sizes to the duplicated blades, I used the rotation settings and the Size
    and Random size options. I used the Use Count option to repeat some objects in
    the group more often than others.")).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了以这种方式创建草地，我需要一些不同草叶或草丛的模型，然后创建一个粒子系统（添加到我的地面网格中），该系统会在场景中复制并散布这些模型。首先，我创建了一些不同的草模型（参见[图9-15](ch09.html#simple_grass_modelsdot_these_are_all_jus
    "图9-15. 简单的草地模型。这些模型都是平面和圆柱体，通过细分、拉伸并使用比例编辑来形成草的茎和叶。每个模型都是一个单独的对象，原点位于植物的基部。")），并将它们都加入到一个组中（CTRL-G）。接着，我向丛林神庙中的地面网格添加了一个新的粒子系统，并为草的密度和长度创建了一个顶点组（就像我为头发做的那样），以便将草放置在几个关键区域（参见[图9-16](ch09.html#density_vertex_group_for_my_grass_partic
    "图9-16. 我草地粒子系统的密度顶点组，这里显示了草在指定区域生长")）。然后，我将粒子系统的渲染类型设置为“组”，并选择了我的草地组作为要使用的组（即Dupli
    Group设置）。最后，我启用了“使用计数”选项，以决定如何复制组中的每个成员，这样较小的草模型会比较大的草模型更频繁地重复（参见[图9-17](ch09.html#particle_settings_for_the_grass_systemdo
    "图9-17. 草地系统的粒子设置。为了让复制的草叶有不同的方向和大小，我使用了旋转设置和大小与随机大小选项。我使用了使用计数选项，使得某些对象在组中比其他对象更频繁地重复。")）。
- en: To give the grass duplicates some random rotation, I used the rotation properties
    (see [Figure 9-17](ch09.html#particle_settings_for_the_grass_systemdo "Figure 9-17. The
    particle settings for the grass system. To give different orientations and sizes
    to the duplicated blades, I used the rotation settings and the Size and Random
    size options. I used the Use Count option to repeat some objects in the group
    more often than others.")). By setting the rotation axis to Normal and the random
    values to 0.15 for the rotation axis and 1.0 for the rotation phase, each grass
    element gets a bit of random rotation, making it look more unique (see [Figure 9-18](ch09.html#grass_particle_system_in_the_final_jungl
    "Figure 9-18. The grass particle system in the final Jungle Temple scene")). Similar
    variation can be achieved for the scale of the objects with the Random Size setting
    in the particle systems physics properties (see [Figure 9-17](ch09.html#particle_settings_for_the_grass_systemdo
    "Figure 9-17. The particle settings for the grass system. To give different orientations
    and sizes to the duplicated blades, I used the rotation settings and the Size
    and Random size options. I used the Use Count option to repeat some objects in
    the group more often than others.")).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让草地的副本具有一些随机旋转，我使用了旋转属性（参见[图9-17](ch09.html#particle_settings_for_the_grass_systemdo
    "图9-17. 草地系统的粒子设置。为了让复制的草叶有不同的方向和大小，我使用了旋转设置和大小与随机大小选项。我使用了使用计数选项，使得某些对象在组中比其他对象更频繁地重复。")）。通过将旋转轴设置为法线，并将旋转轴的随机值设置为0.15，旋转相位设置为1.0，每个草元素都获得了一些随机旋转，使其看起来更加独特（参见[图9-18](ch09.html#grass_particle_system_in_the_final_jungl
    "图9-18. 最终丛林神庙场景中的草地粒子系统")）。类似的变化可以通过粒子系统物理属性中的随机大小设置来实现（参见[图9-17](ch09.html#particle_settings_for_the_grass_systemdo
    "图9-17. 草地系统的粒子设置。为了让复制的草叶有不同的方向和大小，我使用了旋转设置和大小与随机大小选项。我使用了使用计数选项，使得某些对象在组中比其他对象更频繁地重复。")）。
- en: Object Rotation and Particle Systems
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对象旋转与粒子系统
- en: It should be noted that in order for the grass particle system to work correctly,
    the grass meshes need to be rotated so that the stems of the grass point along
    Blender’s *y*-axis. This is because, although the *z*-axis is treated as the “up”
    direction in Blender’s global coordinates, for particle systems, the *y*-axis
    of an object points along the length of the strand.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to rotate the grass objects correctly is to select them in Object
    mode and (assuming you initially modeled them pointing upward with respect to
    everything else in the scene) press **R**▸**X** to rotate the objects around the
    global *x*-axis and enter **–90** degrees to specify the amount of rotation. This
    should leave your grass pointing along the *y*-axis of the scene. Press CTRL-A
    and select **Rotation** to apply this rotation to the objects’ geometry.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '![The particle settings for the grass system. To give different orientations
    and sizes to the duplicated blades, I used the rotation settings and the Size
    and Random size options. I used the Use Count option to repeat some objects in
    the group more often than others.](httpatomoreillycomsourcenostarchimages1538624.png.jpg)Figure 9-17. The
    particle settings for the grass system. To give different orientations and sizes
    to the duplicated blades, I used the rotation settings and the Size and Random
    size options. I used the Use Count option to repeat some objects in the group
    more often than others.![The grass particle system in the final Jungle Temple
    scene](httpatomoreillycomsourcenostarchimages1538626.png.jpg)Figure 9-18. The
    grass particle system in the final Jungle Temple scene'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Hair and Fur Tips
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are some final tips for working with hair particle systems.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '****Split up complex tasks.**** For complex haircuts, split the hair into different
    systems that you can comb and cut separately. Use different settings to get the
    effect you need.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '****Keep an eye on particle counts.**** As an example, human hair has an approximate
    density of a few hundred hairs per square centimeter, but you don’t always need
    to reach this value. When rendering your hair, try various numbers of children
    to see what looks best.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '****Experiment.**** Hair is tough to get right. Sometimes the only way is to
    try a number of different settings to see what works best. Getting a quick render
    of your hair will often provide useful insight.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '****Materials make a difference.**** [Chapter 12](ch12.html "Chapter 12. Materials")
    features some materials geared specifically for particle hair. If you’re tearing
    your hair out wondering why your fur doesn’t look right, it might not be the particle
    system’s fault. Make sure you have a good material on your hair system to help
    it look its best.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: In Review
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’ve looked at ways to create particle hair and fur systems
    and discovered other uses for Blender’s hair particles, such as for procedurally
    scattering objects, as we did for grass. In later chapters, we’ll return to hair
    and fur, as we discuss what materials to apply to create nice looking hair (see
    [Chapter 12](ch12.html "Chapter 12. Materials")), how to light strand particles
    (see [Chapter 13](ch13.html "Chapter 13. Lighting")), and how to get the best
    results when rendering hair (see [Chapter 14](ch14.html "Chapter 14. Rendering
    and Compositing")) by rendering it as a separate render layer.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何创建粒子毛发和毛皮系统，并发现了Blender粒子毛发的其他用途，例如像我们为草地所做的那样进行程序化物体散布。在后续章节中，我们将再次讨论毛发和毛皮，介绍如何选择材料以创建漂亮的毛发（参见[第12章](ch12.html
    "第12章。材料")），如何为毛发粒子提供适当的光照（参见[第13章](ch13.html "第13章。光照")），以及如何在渲染毛发时通过将其作为单独的渲染层来获得最佳效果（参见[第14章](ch14.html
    "第14章。渲染与合成")）。
