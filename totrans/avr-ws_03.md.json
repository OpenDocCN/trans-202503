["```\n\n      // Project 8 - Blinking an LED on Command\n\n      #include <avr/io.h>\n\n      #include <util/delay.h>\n\n      int main(void)\n\n      {\n\n      ❶ DDRB =  0b00001111;\n\n      ❷ PORTB = 0b00000000;\n\n      for (;;)\n\n      {\n\n      ❸ if (PINB == 0b00010000) // If PB4 is HIGH . . .\n\n      ❹ {\n\n      PORTB = 0b00000001;  // then turn on PB0 output\n\n      _delay_ms(1000);     // Wait a moment\n\n      PORTB = 0b00000000;  // Turn off PB0 output\n\n      }\n\n      }\n\n      return 0;\n\n      }\n\n```", "```\n\n      if (PINB == 0b00010000) // If PB4 is high . . .\n\n      {\n\n      PORTB = 0b00000001;  // turn on PB0 output\n\n      } else\n\n      {\n\n      PORTB = 0b00000000;  // turn off PB0 output\n\n      }\n\n```", "```\n\n      if (counter>=23 && counter <42) // If counter is between 23 and 42 . . .\n\n      {\n\n      PORTB = 0b00000001;          // turn on PB0 output\n\n      } else\n\n      {\n\n      PORTB = 0b00000000;          // turn off PB0 output\n\n      }\n\n```", "```\n\n      if (counter<100 || counter >115) // If counter is under 100 or over 115 . . .\n\n      {\n\n      PORTB = 0b00000001;           // turn on PB0 output\n\n      } else\n\n      {\n\n      PORTB = 0b00000000;           // turn off PB0 output\n\n      }\n\n```", "```\n\n      switch(counter)\n\n      {\n\n      case 1:   // Do something if the value of counter is 1\n\n      break; // Finish and exit the switch statement\n\n      case 2:   // Do something if the value of counter is 2\n\n      break; // Finish and exit the switch statement\n\n      case 3:   // Do something if the value of counter is 3\n\n      break; // Finish and exit the switch statement\n\n      default:  // Do something if counter isn't 1, 2, or 3\n\n      // (the \"default\" section is optional)\n\n      }\n\n```", "```\n\n     void\n     `name()` \n\n     {\n\n     // Insert your code to run here.\n\n     }\n\n```", "```\n\n     // Project 9 - A Simple Custom Function\n\n     #include <avr/io.h>\n\n     #include <util/delay.h>\n\n     ❶ void blinkTwice()\n\n     {\n\n     PORTB = 0b11111111;\n\n     _delay_ms(100);\n\n     PORTB = 0b00000000;\n\n     _delay_ms(100);\n\n     PORTB = 0b11111111;\n\n     _delay_ms(100);\n\n     PORTB = 0b00000000;\n\n     _delay_ms(100);\n\n     }\n\n     int main(void)\n\n     {\n\n     // Set PB3 (and all other pins on PORTB) as output\n\n     DDRB = 0b11111111;\n\n     for(;;)\n\n     {\n\n     ❷ blinkTwice();\n\n     _delay_ms(5000);\n\n     }\n\n     return 0;\n\n     }\n\n```", "```\n\n     `void name` \n     (\n     `type variable` \n     ,\n     `type variable2` \n     , . . .)\n\n     {\n\n     // Insert your code to run here.\n\n     }\n\n```", "```\n\n     // Project 10 - Custom Functions with Internal Variables\n\n     #include <avr/io.h>\n\n     #include <util/delay.h>\n\n     void delay_ms(int ms)\n\n     {\n\n     uint8_t i;\n\n     for (i = 0; i < ms; i++)\n\n     {\n\n     _delay_ms(1);\n\n     }\n\n     }\n\n     ❶ void blinkLED(uint8_t blinks)\n\n     {\n\n     uint8_t i;\n\n     for (i = 0; i < blinks; i++)\n\n     {\n\n     PORTB = 0b11111111;\n\n     delay_ms(100);\n\n     PORTB = 0b00000000;\n\n     delay_ms(100);\n\n     }\n\n     }\n\n     int main(void)\n\n     {\n\n     DDRB = 0b11111111; // Set PB3 as output\n\n     for(;;)\n\n     {\n\n     ❷ blinkLED(10);\n\n     _delay_ms(3000);\n\n     }\n\n     return 0;\n\n     }\n\n```", "```\n\n     void blinkLED(uint8_t blinks, uint8_t blinkDelay)\n\n     {\n\n     uint8_t i;\n\n     for (i = 0; i < blinks; i++)\n\n     {\n\n     PORTB = 0b11111111;\n\n     delay_ms(blinkDelay);\n\n     PORTB = 0b00000000;\n\n     delay_ms(blinkDelay);\n\n     }\n\n```", "```\n\n     `type variable` \n     (\n     `type variable` \n     ,\n     `type variable 2` \n     , . . .)\n\n     {\n\n     // Declare a variable to hold the results of the calculations.\n\n     // Insert your code to run here.\n\n     // Return the declared variable.\n\n     }\n\n```", "```\n\n     // Project 11 - Custom Functions That Return Values\n\n     #include <avr/io.h>\n\n     #include <util/delay.h>\n\n     void blinkLED(uint8_t blinks)\n\n     {\n\n     uint8_t i;\n\n     for (i = 0; i < blinks; i++)\n\n     {\n\n     PORTB = 0b11111111;\n\n     _delay_ms(100);\n\n     PORTB = 0b00000000;\n\n     _delay_ms(100);\n\n     }\n\n     }\n\n     ❶ uint8_t timesThree(uint8_t subject)\n\n     {\n\n     uint8_t product;\n\n     ❷ product = subject * 3;\n\n     ❸ return product;\n\n     }\n\n     int main(void)\n\n     {\n\n     DDRB = 0b11111111; // Set PB3 as output\n\n     uint8_t j;\n\n     uint8_t k;\n\n     for(;;)\n\n     {\n\n     j = 4;\n\n     k = timesThree(j);\n\n     blinkLED(k);\n\n     _delay_ms(2000);\n\n     }\n\n     return 0;\n\n     }\n\n```", "```\n\n     k = timesThree(j);\n\n```", "```\n\n      // Project 12 - Building a Single-Digit Numerical Counter\n\n      #include <avr/io.h>\n\n      #include <util/delay.h>\n\n      #define TIME 150\n\n      ❶ void displayNumber(uint8_t value)\n\n      // Displays numbers 0–9 on a seven-segment LED display\n\n      {\n\n      switch(value)\n\n      {\n\n      case 0 : PORTB = 0b00111111; break; // 0\n\n      case 1 : PORTB = 0b00000110; break; // 1\n\n      case 2 : PORTB = 0b01011011; break; // 2\n\n      case 3 : PORTB = 0b01001111; break; // 3\n\n      case 4 : PORTB = 0b01100110; break; // 4\n\n      case 5 : PORTB = 0b01101101; break; // 5\n\n      case 6 : PORTB = 0b01111101; break; // 6\n\n      case 7 : PORTB = 0b00000111; break; // 7\n\n      case 8 : PORTB = 0b01111111; break; // 8\n\n      case 9 : PORTB = 0b01101111; break; // 9\n\n      }\n\n      }\n\n      int main(void)\n\n      {\n\n      ❷ uint8_t i = 0;             // Counter value\n\n      ❸ DDRB = 0b11111111;         // Set PORTB to outputs\n\n      DDRD = 0b00000000;         // Set PORTD to inputs\n\n      ❹ PORTD = 0b11111100;        // Turn off internal pullups for PD0 and PD1\n\n      for(;;)\n\n      {\n\n      ❺ displayNumber(i);       // Display count\n\n      _delay_ms(TIME);\n\n      ❻ if (PIND == 0b11111110) // If reset button pressed . . .\n\n      {\n\n      i = 0;               // set counter to zero\n\n      }\n\n      ❼ if (PIND == 0b11111101) // If count button pressed . . .\n\n      {\n\n      i++;                 // increase counter\n\n      if (i > 9)           // If counter is greater than 9 . . .\n\n      {\n\n      i = 0;            // set counter to zero\n\n      }\n\n      }\n\n      }\n\n      return 0;\n\n      }\n\n```", "```\n\n     ADMUX = 0b00100010;\n\n```", "```\n\n     ADCSRA = 0b10000011;\n\n```", "```\n\n     ADCSRA |= (1 << ADSC);\n\n```", "```\n\n     while (ADCSRA & (1 << ADSC));\n\n```", "```\n\n      // Project 13 - Making a Single-Cell Battery Tester\n\n      #include <avr/io.h>\n\n      #include <util/delay.h>\n\n      ❶ void startADC()\n\n      // Set up the ADC\n\n      {\n\n      ADMUX = 0b00100010;               // Set ADC pin to 3\n\n      ADCSRA = 0b10000011;              // Set prescaler speed for 1 MHz\n\n      }\n\n      int main(void)\n\n      {\n\n      DDRB = 0b00000011;                // Set pins 5 and 6 as outputs\n\n      ❷  startADC();\n\n      for(;;)\n\n      {\n\n      ❸ ADCSRA |= (1 << ADSC);         // Start ADC measurement\n\n      while (ADCSRA & (1 << ADSC) ); // Wait until conversion completes\n\n      _delay_ms(5);\n\n      ❹ if (ADCH >= 71)\n\n      {\n\n      // If ADC input voltage is more than or equal to ~1.4 V . . .\n\n      PORTB = 0b00000010;         // Turn on \"battery OK\" LED2\n\n      ❺ } else if (ADCH < 71)\n\n      {\n\n      // Else, if ADC input voltage is less than ~1.4 V . . .\n\n      PORTB = 0b00000001;         // Turn on \"battery not OK\" LED1\n\n      }\n\n      }\n\n      return 0;\n\n```", "```\n\n     ADMUX |= (1 << REFS0);\n\n```", "```\n\n     ADMUX |= (1 << MUX2) | (1 << MUX0);\n\n```", "```\n\n     ADCSRA |= (1 << ADPS1) | (1 << ADPS0);\n\n```", "```\n\n     ADCSRA |= (1 << ADEN);\n\n```", "```\n\n     ADCSRA |= (1 << ADSC);\n\n```", "```\n\n     loop_until_bit_is_clear(ADCSRA, ADSC);\n\n```", "```\n\n     ADCvalue = ADC;\n\n```", "```\n\n      // Project 14 - Experimenting with an ATmega328P-PU ADC\n\n      #include <avr/io.h>\n\n      #include <math.h>\n\n      #include <util/delay.h>\n\n      ❶ void startADC()\n\n      // Set up the ADC\n\n      {\n\n      ADMUX |= (1 << REFS0);                 // Use AVcc pin with ADC\n\n      ADMUX |= (1 << MUX2) | (1 << MUX0);    // Use ADC5 (pin 28)\n\n      ADCSRA |= (1 << ADPS1) | (1 << ADPS0); // Prescaler for 1MHz (/8)\n\n      ADCSRA |= (1 << ADEN);                 // Enable ADC\n\n      }\n\n      int main(void)\n\n      {\n\n      uint16_t ADCvalue;\n\n      ❷ DDRB = 0b11111111;                      // Set PORTB to outputs\n\n      DDRC = 0b00000000;                      // Set PORTC to inputs\n\n      ❸ startADC();\n\n      for(;;)\n\n      {\n\n      ❹ // Take reading from potentiometer via ADC\n\n      ADCSRA |= (1 << ADSC);                // Start ADC measurement\n\n      loop_until_bit_is_clear(ADCSRA, ADSC);\n\n      // Wait for conversion to finish\n\n      ❺ _delay_ms(10);\n\n      ❻ // Assign ADC value to \"ADCvalue\"\n\n      ADCvalue = ADC;\n\n      ❼ if (ADCvalue>=0 && ADCvalue <256)\n\n      {\n\n      PORTB = 0b00000001;\n\n      }\n\n      else if (ADCvalue>=256 && ADCvalue<512)\n\n      {\n\n      PORTB = 0b00000010;\n\n      }\n\n      else if (ADCvalue>=512 && ADCvalue<768)\n\n      {\n\n      PORTB = 0b00000100;\n\n      }\n\n      else if (ADCvalue>=768 && ADCvalue<1023)\n\n      {\n\n      PORTB = 0b00001000;\n\n      }\n\n      // Turn off the LEDs in preparation for the next reading\n\n      _delay_ms(100);\n\n      PORTB = 0b00000000;\n\n      }\n\n      return 0;\n\n      }\n\n```", "```\n\n     432 + 956; // Addition\n\n     100 / 20;  // Division\n\n     5 * 200;   // Multiplication\n\n     25 - 25;   // Subtraction\n\n     10 % 4;    // Modulo\n\n```", "```\n\n     #include <math.h>\n\n```", "```\n\n      // Project 15 - Creating a Digital Thermometer\n\n      ❶ #include <avr/io.h>\n\n      #include <math.h>\n\n      #include <util/delay.h>\n\n      ❷ void startADC()\n\n      // Set up the ADC\n\n      {\n\n      ADMUX |= (1 << REFS0);                 // Use AVcc pin with  ADC\n\n      ADMUX |= (1 << MUX2) | (1 << MUX0);    // Use ADC5 (pin 28)\n\n      ADCSRA |= (1 << ADPS1) | (1 << ADPS0); // Prescaler for 1MHz (/8)\n\n      ADCSRA |= (1 << ADEN);                 // enable ADC}\n\n      }\n\n      ❸ void displayNumber(uint8_t value)\n\n      // Displays a number from 0–9 on the seven-segment LED display\n\n      {\n\n      switch(value)\n\n      {\n\n      case 0 : PORTB = 0b00111111; break; // 0\n\n      case 1 : PORTB = 0b00110000; break; // 1\n\n      case 2 : PORTB = 0b01011011; break; // 2\n\n      case 3 : PORTB = 0b01111001; break; // 3\n\n      case 4 : PORTB = 0b01110100; break; // 4\n\n      case 5 : PORTB = 0b01101101; break; // 5\n\n      case 6 : PORTB = 0b01101111; break; // 6\n\n      case 7 : PORTB = 0b00111000; break; // 7\n\n      case 8 : PORTB = 0b01111111; break; // 8\n\n      case 9 : PORTB = 0b01111101; break; // 9\n\n      }\n\n      }\n\n      int main(void)\n\n      {\n\n      ❹ uint8_t tens = 0;  // Holds tens digit for temperature\n\n      uint8_t ones = 0;  // Holds ones digit for temperature\n\n      float temperature;\n\n      float voltage;\n\n      uint16_t ADCvalue;\n\n      uint8_t finalTemp;\n\n      DDRB = 0b11111111; // Set PORTB to outputs\n\n      DDRC = 0b00000000; // Set PORTC to inputs\n\n      startADC();\n\n      for(;;)\n\n      {\n\n      ❺ // Take reading from TMP36 via ADC\n\n      ADCSRA |= (1 << ADSC);         // Start ADC measurement\n\n      while (ADCSRA & (1 << ADSC) ); // Wait for conversion to finish\n\n      _delay_ms(10);\n\n      // Get value from ADC register, store in ADCvalue\n\n      ADCvalue = ADC;\n\n      ❻ // Convert reading to temperature value (Celsius)\n\n      voltage = (ADCvalue * 5);\n\n      voltage = voltage / 1024;\n\n      temperature = ((voltage - 0.5) * 100);\n\n      ❼ // Display temperature on LED module\n\n      finalTemp = (uint8_t) round(temperature);\n\n      tens = finalTemp / 10;\n\n      ones = finalTemp % 10;\n\n      ❽ displayNumber(tens);  // Display tens digit\n\n      _delay_ms(250);\n\n      displayNumber(ones);  // Display ones digit\n\n      _delay_ms(250);\n\n      ❾ // Turn off the LED display in preparation for the next reading\n\n      PORTB = 0b00000000;\n\n      _delay_ms(1000);\n\n      }\n\n      return 0;\n\n      }\n\n```"]