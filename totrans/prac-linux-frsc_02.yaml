- en: '**2'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LINUX OVERVIEW**
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter provides an overview of Linux for digital forensic investigators.
    It describes the history of Linux, including the significance and influence of
    Unix, and establishes the definition of “modern Linux” used throughout this book.
    I explain the role of the Linux kernel, devices, systemd, and the command line
    shell. I also provide examples of shell and command line basics, followed by a
    tour of various desktop environments and an overview of the birth and evolution
    of popular Linux distributions. The chapter concludes with a focus on digital
    forensics applied to Linux systems, especially in comparison to forensic analysis
    of other operating systems such as Windows or macOS.
  prefs: []
  type: TYPE_NORMAL
- en: '**History of Linux**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Understanding the historical roots of operating systems helps to explain the
    rationale and design decisions leading up to modern Linux systems. Software development,
    including operating system software, is largely an evolutionary process. Linux
    has been evolving since Linus Torvalds first announced it, but the core ideas
    and philosophy behind Linux started a few decades earlier.
  prefs: []
  type: TYPE_NORMAL
- en: '***Unix Roots***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The creation and development of Linux and the associated GNU tools were heavily
    influenced by Unix, and many Linux concepts and philosophies are taken directly
    from Unix. To appreciate the Unix roots and similarities to Linux, a section on
    Unix history is helpful.
  prefs: []
  type: TYPE_NORMAL
- en: The early ideas for Unix were born out of a joint research project in the United
    States between MIT, General Electric, and Bell Telephone Labs. The group was developing
    the Multics (Multiplexed Information and Computing Service) time-share operating
    system, but in the spring of 1969, Bell withdrew involvement, leaving its researchers
    in search of other projects. A Digital Equipment Corporation (DEC) PDP-7 minicomputer
    was available at the time, and Ken Thompson spent the summer of 1969 developing
    the basic system components that included a filesystem, the kernel, shell, editor,
    and assembler. This initial implementation (not yet named) was written in assembly
    language and intended to be less complex than Multics. Dennis Ritchie and several
    others joined in the early development effort to create a functioning system.
    In 1970, the name *Unix* was coined, jokingly referring to an “emasculated Multics.”
    Interest in the system had grown within Bell Labs, and a proposal to create a
    text processing system helped justify the purchase of a PDP-11 in the summer of
    1970.
  prefs: []
  type: TYPE_NORMAL
- en: The earliest Unix editions were written in assembly language, which was difficult
    to understand and ran only on hardware for which the code was intended. Dennis
    Ritchie created the C programming language, a high-level language that was easier
    to program and could be compiled into machine code for any hardware architecture.
    The kernel and tools were rewritten in C, which made Unix “portable,” meaning
    it could be compiled and run on any machine with a C compiler. In 1974, Ken Thompson
    and Dennis Ritchie submitted a paper to the Association for Computing Machinery
    (ACM) describing the Unix system.^([1](footnotes.xhtml#ch02foot_01)) The paper
    was only 11 pages long and described the basic design principles and operation
    of Unix. The filesystem was a central component of Unix, and everything, including
    hardware devices, was accessible as a file in a hierarchical tree. The paper described
    the shell, file redirection and the concept of pipes, and the execution of binary
    files and shell scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing the Unix paper attracted the attention of academia, and free copies
    of Unix, including source code, were given to universities for research purposes
    (paying only for shipping and distribution media—much like Linux distributions
    later on). Further research and development by academic researchers grew, and
    Bill Joy at the University of California at Berkeley released a version of Unix
    called the Berkeley Software Distribution, or BSD. Over time, BSD grew to include
    extensive network hardware support and TCP/IP protocols for the ARPANET (which
    would become the internet as we know it today). Interest in network connectivity
    and BSD’s free implementation of TCP/IP was important to universities who wanted
    to connect to the early internet. BSD started to become a community-driven operating
    system with contributions from researchers and students from across academia and
    from around the world. One of the original BSD developers, Kirk McKusick, has
    a talk titled “A Narrative History of BSD” (multiple versions are available on
    YouTube).
  prefs: []
  type: TYPE_NORMAL
- en: Before Unix, selling computer products involved the development of hardware
    and writing an operating system (both proprietary). As Unix popularity grew, companies
    building proprietary computers began using Unix as the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: An explosion of Unix systems hit the marketplace, including Silicon Graphics
    Irix, DEC Ultrix, Sun Microsystems SunOS and Solaris, IBM AIX, HP UX, and others.
    Versions of Unix software for commodity PCs were also available, including Microsoft’s
    Xenix, Santa Cruz Operation (SCO) Unix, Univel Unixware, and others. This commercialization
    led to the issue of Unix licensing and several decades-long legal sagas, first
    with BSD and AT&T and later between SCO, Novell, and IBM.
  prefs: []
  type: TYPE_NORMAL
- en: The commercial proliferation led to many different Unix “flavors,” as each company
    introduced proprietary modifications for competitive advantage. Unix started to
    become fragmented and incompatible, leading to the creation of standards like
    POSIX, The Open Group’s Single Unix Specification, the Common Desktop Environment
    (CDE), and others.
  prefs: []
  type: TYPE_NORMAL
- en: Today, Unix is still found in enterprise computing environments. Steve Jobs
    made the decision to use Unix for NeXT computers, and this was adopted as the
    basis for Apple’s OS X Macintosh operating system and later for Apple’s iOS mobile
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: The cost of commercial Unix led to the creation of free alternatives for hobbyists,
    students, researchers, and others. Two popular alternatives for a free Unix-like
    system were 386BSD and Minix. A series of articles in *Dr. Dobb’s Journal* described
    the 386BSD system, which was based on one of the last free releases of BSD Unix.
    Two user communities were writing patches for 386BSD and eventually formed FreeBSD
    and NetBSD, both of which are actively developed today.
  prefs: []
  type: TYPE_NORMAL
- en: Minix was a Unix clone developed by Andrew Tanenbaum for university teaching
    and research. It was initially intended to replace AT&T Unix, which Tanenbaum
    had used to teach an operating systems class. Minix is still actively developed
    today, and it played a key role in the creation of Linux.
  prefs: []
  type: TYPE_NORMAL
- en: In 1983, Richard Stallman created the GNU project, and named it using the recursive
    acronym “GNU’s Not Unix!". The goal of GNU was to create a free Unix-like operating
    system complete with a kernel and userspace. By the early 1990s, the userspace
    utilities were largely complete and only the kernel was missing. This missing
    piece was about to be completed by a young student in Finland.
  prefs: []
  type: TYPE_NORMAL
- en: The different Unix systems, Unix clones, and other Unix-like systems all share
    the same underlying *Unix philosophy*. In essence, this philosophy encourages
    programmers to create small programs that do one thing well and can interact with
    one another. Free and open source software has a tendency to follow this philosophy,
    and this philosophy can (or should) be applied to writing digital forensics software,
    as well. For example, The Sleuth Kit (TSK) is a forensics toolkit consisting of
    many small tools, each one performing a specific task, with the output from one
    tool being usable as input for another. Commercial software has a tendency to
    be the opposite, which often means massive monolithic tools that try to do everything
    and avoid interoperability for competitive reasons (although APIs are becoming
    more common).
  prefs: []
  type: TYPE_NORMAL
- en: '***Early Linux Systems***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Linus Torvalds created Linux while studying at the University of Helsinki. He
    wanted an alternative to Minix that had a different license, and he preferred
    a monolithic kernel design (in contrast to Tanenbaum who favored a microkernel).
    He started writing his own kernel in 1991, using Minix as a development platform.
    After several months, he mentioned it in a Minix news group and asked for feedback.
    Some weeks later, he posted an announcement with an FTP site containing the code
    and a call to contribute:^([2](footnotes.xhtml#ch02foot_02))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Linus Torvalds created the Linux kernel, which adopted the concepts and philosophy
    of Unix. GNU tools, like the C compiler, were required to build it. Other GNU
    tools, like the shell, were necessary to actually use the operating system. A
    community of curious and excited developers grew around this project, contributing
    patches and testing the code on different hardware. By 1994, the first kernel
    considered mature enough for general use was released as version 1.0\. Linux kernel
    development evolved to include multiprocessor support and was ported to other
    CPU architectures. Developers were implementing support for every hardware device
    possible (proprietary undocumented hardware was a challenge and still is). This
    enthusiastic community under the direction of Linus Torvalds continues to develop
    and improve the Linux kernel we have today.
  prefs: []
  type: TYPE_NORMAL
- en: '***Early Desktop Environments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the early days of Unix, graphics terminals (like the Tektronix 4010 series)
    were separate devices used by graphics programs like computer-aided design (CAD).
    Graphical terminals were not part of the user interface like graphical user interfaces
    (GUIs) today. Many experimental and proprietary windowing and desktop systems
    were available by the mid-1980s, but the introduction of the X Window System changed
    how users interfaced with computers.
  prefs: []
  type: TYPE_NORMAL
- en: In 1984, MIT introduced the open standard X, and after several years of rapid
    development (11 versions), X11 was released in 1987\. This provided a standard
    protocol for graphical programs (the X11 client) to be displayed on a screen (the
    X11 server). The X11 protocol could be built into an application and could display
    windows on any X11 server, even over a network. X11 became generally adopted among
    commercial Unix vendors producing graphical workstations. Because building workstations
    included developing graphics hardware, the X11 server was often a proprietary
    component of the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Free Unix-like operating systems needed a free X11 server for commodity PC graphic
    cards. In 1992, the XFree86 project was created to fill this gap and allow the
    development of free X11 desktops on PCs running BSDs and Linux. In 2004, the [X.Org](http://X.Org)
    Foundation (*[https://x.org/](https://x.org/)*) was created and forked a version
    of XFree86 as an X11 reference implementation. A change in license and disagreement
    among XFree86 developers caused [X.Org](http://X.Org) to become the de facto standard
    Linux X11 implementation.^([3](footnotes.xhtml#ch02foot_03))
  prefs: []
  type: TYPE_NORMAL
- en: X11 is simply a protocol standard. It does not provide window management or
    a desktop environment. To manage X11 windows, a separate window manager is needed.
    A *window manager* (just another X11 client application) speaks the X11 protocol
    and is responsible for basic window functions such as resizing, moving, and minimizing.
    Window managers also provided window decorations, title bars, buttons, and other
    GUI features. Multiple window managers became available to offer choice in Linux
    distributions. Popular window managers in the first Linux distributions, commonly
    referred to as distros, were TWM and FVWM. For more information about classic
    window managers, see *[http://www.xwinman.org/](http://www.xwinman.org/)*.
  prefs: []
  type: TYPE_NORMAL
- en: X11 applications are built with graphical *widgets* to create menus, buttons,
    scroll bars, toolbars, and so on. These widgets give the application a unique
    look and feel. Developers are free to create their own widgets, but most use the
    libraries included with a system. Early examples of widget toolkits include Athena,
    OPEN LOOK, and Motif. X11 desktop applications can use any style of graphical
    widget they want; no system-wide standard is enforced, which can lead to an inconsistent
    desktop appearance when every application uses a different toolkit. The two most
    common toolkits used with Linux today are GTK (used with GNOME) and Qt (used with
    KDE).
  prefs: []
  type: TYPE_NORMAL
- en: However, having window managers and widget toolkits was not enough to provide
    the full desktop experience that users expected. Functionality was needed for
    application launchers, trash cans, wallpaper, themes, panels, and other typical
    elements you’d expect in a modern computer desktop. The Unix community created
    CDE to provide a standard full-featured desktop that was vendor independent. This
    was (initially) not open, so the free and open source community developed its
    own desktop standards (XDG and *[freedesktop.org](http://freedesktop.org)*).
  prefs: []
  type: TYPE_NORMAL
- en: '**Modern Linux Systems**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Linux kernel and Linux distributions have advanced beyond being basic Unix
    clones. Many new technologies have been independently developed for Linux that
    are not derived from Unix. Many legacy technologies also have been replaced in
    newer versions of Linux. These technological advancements help differentiate traditional
    Linux from modern Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than covering forensic analysis topics involving traditional Unix and
    early Linux systems, this book focuses on the forensic analysis of modern Linux
    system components. The rest of this section provides an overview of these new
    or different components for those who are less familiar with modern Linux.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hardware***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To analyze a Linux system in a forensic context, you want to determine (as accurately
    as possible) what hardware has been physically installed or attached to the system
    since it was installed. The kernel manages hardware devices and leaves traces
    of added or removed hardware in the logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Internal devices might be integrated on the mainboard (onboard), plugged in
    to PCI Express slots (including M.2 slots), plugged in to SATA ports, or attached
    to other pin-blocks on the mainboard. Examples of internal hardware components
    to identify may include:'
  prefs: []
  type: TYPE_NORMAL
- en: Mainboard (describing the board itself)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Onboard devices (integrated into mainboard)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PCI Express devices (graphic cards and other PCIe cards)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal drives (SATA or NVMe)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network devices (wireless or wired)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux does not require a reinstallation when a mainboard is replaced (upgraded)
    with another one, so more than one mainboard might be identified. Physical examination
    of the mainboard may also include reading out the NVRAM to analyze the UEFI variables
    and other BIOS information.
  prefs: []
  type: TYPE_NORMAL
- en: Another internal interface is the Advanced Configuration and Power Interface
    (ACPI), which was developed so that operating systems could control various aspects
    of power management to the system and components. Linux supports the ACPI interface
    and typically manages events through systemd or the acpid daemon.
  prefs: []
  type: TYPE_NORMAL
- en: 'External hardware components are typically attached by USB, Thunderbolt, DisplayPort,
    HDMI, or other external connectors. Examples of external hardware components or
    peripherals to identify may include:'
  prefs: []
  type: TYPE_NORMAL
- en: External storage media
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mouse and keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Video monitors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Printers and scanners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Webcams, cameras, and video equipment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Audio devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any other external peripheral devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The identification of hardware from a forensically acquired disk image will
    rely on traces in the logs, configuration files, and other persistent data. Physical
    examination of seized hardware should correlate with traces found on the forensic
    image.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Kernel***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The kernel is the heart of a Linux system. It provides the interface between
    the user programs (called *userspace* or *userland*) and the hardware. The kernel
    detects when hardware is attached or removed from a system and makes those changes
    visible to the rest of the system. Overall, the kernel is responsible for many
    tasks, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Memory, CPU, and process management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hardware device drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filesystems and storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Network hardware and protocols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security policy enforcement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Human interface and peripheral devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 2-1](ch02.xhtml#ch02fig01) shows an architectural overview of the Linux
    kernel and its subsystems.^([4](footnotes.xhtml#ch02foot_04))'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/ch02fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 2-1: Linux kernel architecture (modified from* [https://github.com/makelinux/linux_kernel_map/](https://github.com/makelinux/linux_kernel_map/)*)*'
  prefs: []
  type: TYPE_NORMAL
- en: The kernel has gained many new features over the years. The ability to perform
    advanced isolation of processes using cgroups and namespaces forms the basis for
    containers. New filesystems such as btrfs were designed specifically for Linux
    systems. The btrfs filesystem merges storage features previously found in separate
    components (like RAID or LVM) to provide snapshots, subvolumes, and other volume
    management capabilities. New firewall technology like nftables is replacing the
    traditional iptables with a faster, more efficient operation and cleaner rulesets.
    New VPN technology like WireGuard is a simpler alternative to the aging IPsec
    and OpenVPN standards.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel is executed by a bootloader when a system is started. The bootloader
    technology has transitioned from the traditional MBR (BIOS execution of sector
    zero) to the more advanced UEFI (firmware using GPT partitions, UEFI binaries,
    and EFI variables). During operation, the kernel can be dynamically changed and
    configured, and more functionality can be added with loadable kernel modules.
    When a system is shut down, the kernel is the last thing to stop running.
  prefs: []
  type: TYPE_NORMAL
- en: This book will cover all of these newer technologies from a digital forensic
    investigation perspective.
  prefs: []
  type: TYPE_NORMAL
- en: '***Devices***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A Linux device is a special file, typically located in */dev/*, that provides
    access to device drivers in the kernel. The device drivers in the kernel interface
    with physical hardware components or create pseudo-devices. Device files are created
    as either a *block* or *character* device type. Block devices move data in chunks
    (buffered blocks), and character devices move data in a continuous stream (unbuffered).
    Linux storage devices (hard disks, SSDs, and so forth) are typically block devices.
  prefs: []
  type: TYPE_NORMAL
- en: Most Linux forensic tools are designed to operate directly on forensically acquired
    image files. However, many useful troubleshooting, debugging, and diagnostic tools
    operate only on Linux device files. In those situations, the suspect drive either
    needs to be attached to the analysis system with a write blocker, or a loop device
    can be used. Linux is able to associate a regular file with a special loop device
    that behaves like a physically attached drive, which makes it possible to access
    forensic image files with tools that normally operate only on devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `losetup` tool to create loop devices. In this example, a loop
    device is created for a forensically acquired image file named *image.raw*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `sudo` command executes `losetup` as a privileged user (root). The first
    two flags tell `losetup` to map the image file to the next available loop device
    it finds (*/dev/loop0*) in a read-only manner. The last two flags instruct the
    kernel to scan the image’s partition table and show the loop device’s name on
    completion (*/dev/loop0*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `ls` command shows the partition loop devices that were created
    (`loop0p1` and `loop0p2`). You can view the partition table on */dev/loop0* with
    regular forensic tools, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here the `fdisk`^([5](footnotes.xhtml#ch02foot_05)) command reads the device
    like a normal attached drive and displays the partition table of the image file.
    Any tool that works with block devices should also be able to access image files
    in this manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The examples shown in this book use a variety of tools and techniques. Each
    tool may require a different form of access to a drive, forensic image file, or
    even a mounted filesystem. To help avoid confusion, I’ll use the following naming
    scheme in subsequent examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '***image.raw*** A forensically acquired raw image file (using sector offsets
    for the filesystem)'
  prefs: []
  type: TYPE_NORMAL
- en: '***partimageX.raw*** A separately extracted partition image file(s) containing
    only the partition contents (usually the filesystem)'
  prefs: []
  type: TYPE_NORMAL
- en: '***/dev/sda*** A block device (in */dev/*) physically attached or using a loopback
    (`losetup`)'
  prefs: []
  type: TYPE_NORMAL
- en: '***/dev/loopX*** A block device associated with a forensic image file'
  prefs: []
  type: TYPE_NORMAL
- en: '***/evidence/*** A path to a mounted filesystem of a suspect/victim drive'
  prefs: []
  type: TYPE_NORMAL
- en: If there is no leading forward slash (/), the paths to files and directories
    are relative to the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: '***Systemd***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Throughout this book you will find many references to systemd. *Systemd* is
    an initialization system (called *init*), a system manager, and a service manager.
    Among popular Linux distros, systemd has become the de facto system layer between
    the kernel and userland. There are systemd commands to start and stop background
    programs (called daemons or services), power off and reboot the system, view logs,
    and check the status of services and the overall state of the system. You can
    edit different systemd text files (unit files and configuration files) to customize
    system behavior. Systemd basically manages the overall system running outside
    the kernel from initial startup to shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of systemd to the Linux community was not without debate, and
    involved a transition away from the traditional Unix sysvinit initialization system.
    This book contains significant coverage of systemd because it has been adopted
    by all the major Linux distributions. From a digital forensics perspective, systemd
    provides many forensic artifacts and evidence traces that could be interesting
    for an investigation.
  prefs: []
  type: TYPE_NORMAL
- en: The systemd project is well documented and man pages are available for nearly
    everything in systemd. As a starting point, see the systemd(1) man page or type
    apropos systemd at a Linux command line.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of systemd has caused a fundamental shift toward starting daemons
    using on-demand activation rather than explicitly starting daemons at boot. This
    is done both at the system level and user level. At the user level, it becomes
    unnecessary to start many background programs from login shell scripts because
    those programs are now started automatically as needed. This was done mainly for
    performance reasons, but the additional log entries generated from starting and
    stopping programs can be useful in the forensic reconstruction of past activity.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Command Line***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The shell is a program that provides a command line interpreter used to interface
    with people (typing commands) or shell scripts (running commands from a file).
    The shell runs in userspace and is executed by either the system or a logged-in
    user. This is different from the graphical shell that is part of the desktop environment.
    The shell and associated concepts are taken directly from Unix.
  prefs: []
  type: TYPE_NORMAL
- en: The most common shell on Linux is *Bash (Bourne-again shell)*.^([6](footnotes.xhtml#ch02foot_06))
    Users can change their default shell, and many shells are available to choose
    from. Two popular alternatives today are zsh and fish. The zsh shell is highly
    customizable and a favorite of some power users. The fish shell is designed more
    for comfortable human interaction. Shells are just normal programs that can be
    executed (you can even run another shell from your current shell).
  prefs: []
  type: TYPE_NORMAL
- en: Modern desktop users may never need to use a shell prompt. To interact with
    a shell, you need to log in to the console (locally or remotely with SSH) or open
    a terminal emulator in your desktop environment. Once you have a shell (typically
    a dollar sign followed by a cursor), you can enter commands.
  prefs: []
  type: TYPE_NORMAL
- en: Shell commands may be part of the shell program itself (built-in commands),
    or they can be the names of programs you want to run. You can specify configuration
    information by adding flags or parameters after a command and you can set environment
    variables to configure a shell.
  prefs: []
  type: TYPE_NORMAL
- en: The most powerful shell concepts are piping and redirection. Piping allows the
    output from one program to be sent directly to the input of another program. Redirection
    allows programs to take input from files and send output to files. The shell provides
    all of this functionality; it doesn’t need to be built in to each program (this
    is all part of the Unix philosophy mentioned earlier).
  prefs: []
  type: TYPE_NORMAL
- en: 'The command line symbols used to connect programs and files together are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '>     Sends data from a program to a file (creates file if needed)'
  prefs: []
  type: TYPE_NORMAL
- en: '>>    Appends data from a program to a file (creates file if needed)'
  prefs: []
  type: TYPE_NORMAL
- en: <     Sends data from a file to a program
  prefs: []
  type: TYPE_NORMAL
- en: '|     Sends data from one program to another program'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples to illustrate piping and redirection with programs and
    files on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first three examples show a program run using input and output from a file.
    The next two examples show a program sending output to another program (or programs).
    You can also use multiple pipes and redirects in series on the command line. In
    the last example, data from file1 is redirected into program1, output from program1
    is piped into program2, output from program2 is piped into program3, and, lastly,
    output from program3 is redirected into file2.
  prefs: []
  type: TYPE_NORMAL
- en: From a digital forensics perspective, the shell is interesting because it can
    save a history of the commands that a user entered. The forensic analysis of shell
    history is covered in a later section.
  prefs: []
  type: TYPE_NORMAL
- en: '***Modern Desktop Environments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Modern Linux desktop environments are either built on top of X11 and a window
    manager (discussed in an earlier section) or integrated with a Wayland compositor.
    Desktop environments (sometimes called DEs or desktop shells) provide functionality
    like application launchers, trash cans, wallpaper, themes, panels, and other features.
    The most common desktop environments in use today are GNOME and KDE. Other popular
    desktops include MATE, Cinnamon, Xfce, LXDE, and Enlightenment. Each of these
    environments provides a different look and feel.
  prefs: []
  type: TYPE_NORMAL
- en: A set of community standards was formed to provide underlying interoperability
    between desktop environments. These are known as the *Cross-Desktop Group (XDG)
    specifications*. See the specifications page at *[https://www.freedesktop.org/](https://www.freedesktop.org/)*
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some features with documented specifications that standardize interoperability
    across desktop environments include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Autostart applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trash cans or recycle bins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Desktop bookmarks or recent files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clipboard management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thumbnails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Desktop trays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Status notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password managers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearly this list is also interesting for digital forensic examiners and will
    be covered in a later section.
  prefs: []
  type: TYPE_NORMAL
- en: To ease the learning curve for new users, the original computer desktops attempted
    to replicate physical desktops, which is referred to as the *desktop metaphor*.
    This included overlapping windows (like overlapping sheets of paper), folder icons
    (like paper folders), and so on. In recent years, the trend is moving away from
    the traditional desktop metaphor toward desktop shells that behave differently,
    using features such as tiling, tabbing, or fullscreen windows.
  prefs: []
  type: TYPE_NORMAL
- en: The current trend is to replace X11-based desktops with Wayland. The Wayland
    protocol was developed from scratch and is intended to modernize Linux graphics,
    eliminate unused functionality, and take better advantage of local hardware.
  prefs: []
  type: TYPE_NORMAL
- en: One of X11’s design goals was networking. If a site had a powerful central Unix
    server and distributed X11 terminals (called thin clients today), users could
    run programs on the central machine but display them on the screen of the terminal.
    This feature of X11 is largely obsolete today due to powerful client machines,
    client/server applications, and remote desktop protocols. Wayland drops support
    for integrated networking of individual windows.
  prefs: []
  type: TYPE_NORMAL
- en: X11 has security issues. Once a client application is able to use the X11 server,
    it is considered trusted. The client is then authorized to snoop around the rest
    of the desktop, observing the contents of other windows and intercepting keystrokes.
    This is how screenshot programs, remote screen sharing, and programmable hotkey
    programs work. Wayland was developed with security in mind and doesn’t trust applications.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a graphical desktop environment is optional for Linux servers. Servers
    can operate with a monitor and text-based console for shell access. Even the monitor
    is optional, in which case the server is operating in *headless* mode, and logins
    must be done over a network.
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux Distributions**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Strictly speaking, only the Linux kernel is the actual operating system. The
    rest of the system, such as the shell, tools, GUI, software packages, and so on,
    are not Linux. Those things may be part of a Linux distribution, but Linux technically
    refers only to the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: However, practically speaking, people use the term *Linux* to refer to more
    than just the kernel and think about Linux in terms of distributions (or “distros").
    This section describes the rise of the Linux distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Evolution of Linux Distributions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Originally, building a system based on a Linux kernel required a significant
    amount of technical knowledge. It meant downloading the sources (for the kernel
    and other programs) from FTP sites, unpacking, compiling on a Minix system, and
    manually copying the files to the target filesystem. Configuration was done by
    hand using text editors (like vi). Updates and patches were also done by hand
    (a repeat of the just-described process). This arrangement was fine for developers
    and hackers, but it wasn’t okay for regular users.^([7](footnotes.xhtml#ch02foot_07))
  prefs: []
  type: TYPE_NORMAL
- en: The first Linux systems required a significant amount of manual technical work
    to install and maintain. Before the proliferation of Linux distributions, nearly
    everything was a manual process. Linux distros were needed to fill this gap. Distributions
    were invented to make it easier for people to install, configure, and maintain
    their Linux-based systems. By the end of 1992, two complete and functional Linux
    distros were available. Peter MacDonald of Canada created the Softlanding Linux
    System (SLS), and Adam Richter of Berkeley, California, created Yggdrasil Linux.
    Once distributions made Linux easier for people to install, it started to become
    more popular outside the kernel developer community. Over time, the features offered
    by distros became significant enough to be commercially profitable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The typical components that make up a distro today include:'
  prefs: []
  type: TYPE_NORMAL
- en: Boot media (ISO images for CD, DVD, or USB stick)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installer scripts and tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package management system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Precompiled packages (compiling from source optional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preconfigured desktop environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation (online or in print)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updates and security advisories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support forums and user mailing lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distro philosophy, vision, mission, or style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distros may have periodic release dates that follow a traditional software life-cycle
    model. However, a more recent model is the *rolling release*, which simply means
    there are no fixed versions or release dates. The packages are constantly updated
    and the release version is associated with the last time you updated. This system
    can introduce instability risks, but users don’t have to wait to get the latest
    software.
  prefs: []
  type: TYPE_NORMAL
- en: Linux distros can be non-profit or commercial. Non-profit distros like Debian,
    Arch, Slackware, or Gentoo are typically free and open source, and are maintained
    by volunteers. However, money is still needed for server hardware, network infrastructure,
    and network bandwidth, so project teams typically raise money from donations or
    selling swag (T-shirts, coffee mugs, stickers, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Commercial distros like SUSE, Red Hat, or Ubuntu (Canonical) have staff employed
    and are regular for-profit companies. Due to the GPL license, commercial companies
    are not permitted to sell Linux software; however, they are allowed to make money
    from distribution media, subscriptions, services, and support. Many commercial
    distros also have separate free distros (openSUSE and Fedora, for example), which
    are used as a testing ground for upcoming commercial releases.
  prefs: []
  type: TYPE_NORMAL
- en: A number of distros are based on other distros and simply add additional software,
    customization, and configuration. For example, Ubuntu is based on Debian, CentOS
    Stream is based on Red Hat Enterprise Linux, and Manjaro is based on Arch Linux.
    Some distros even are based on distros that are themselves based on another distro.
    For example, Linux Mint is based on Ubuntu, which is based on Debian.
  prefs: []
  type: TYPE_NORMAL
- en: There are also many specialty distributions that are typically based on another
    distro but built for a specific purpose. For example, Raspian is a distro for
    Raspberry Pi hardware, Kali Linux is designed for pentesting and forensics, Tails
    is designed for privacy and anonymity, and Android is designed for mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing which distro you’re analyzing is important because each one has slightly
    different forensic artifacts. The most common distributions are described in the
    following sections. See Distrowatch for a current list of popular Linux distributions
    (*[https://distrowatch.com/](https://distrowatch.com/)*).
  prefs: []
  type: TYPE_NORMAL
- en: '***Debian-Based Distributions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ian Murdock started Debian Linux in 1993 while a student at Purdue University.
    Debian was initially created out of Murdock’s dissatisfaction with SLS Linux,
    and grew to be one of the most popular distributions available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Debian distribution maintains three releases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stable** The latest production release, which is recommended for general
    use'
  prefs: []
  type: TYPE_NORMAL
- en: '**Testing** The next upcoming release candidate being tested and matured'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unstable** The current development snapshot (always has the code name *Sid*)'
  prefs: []
  type: TYPE_NORMAL
- en: Debian release code names are taken from characters in the Disney *Toy Story*
    movies and are assigned to major release numbers. New major versions are released
    roughly every two years. Minor updates or *point releases* happen every few months
    and contain security and bug fixes.
  prefs: []
  type: TYPE_NORMAL
- en: Debian is focused on freedom and is closely aligned with the GNU project (the
    documentation even refers to Debian as “GNU/Linux”). Debian has well-documented
    policies, standards, guidelines, and a social contract outlining the project philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: Many Debian-based distributions have been developed for non-technical end users.
    These distros are easy to install and use and have desktop environments on par
    with Windows and macOS (I present some of these in the lists that follow).
  prefs: []
  type: TYPE_NORMAL
- en: 'Ubuntu has been one of the more popular Debian-based distributions for Linux
    newcomers. It has a server version and a desktop version. Ubuntu has several flavors
    depending on the desktop environment used:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ubuntu** Uses the GNOME desktop environment (the main distro)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubuntu** Uses the KDE desktop environment'
  prefs: []
  type: TYPE_NORMAL
- en: '**Xubuntu** Uses the Xfce desktop environment'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lubuntu** Uses the LXDE desktop environment'
  prefs: []
  type: TYPE_NORMAL
- en: The underlying operating system is still Ubuntu (and is based on Debian), but
    the graphical interface varies with each flavor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux Mint, also based on Ubuntu (with one release based on Debian), was designed
    to look elegant and be comfortable to use, and it uses the traditional desktop
    metaphor. It comes in several flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mint Cinnamon** Based on Ubuntu with GNOME 3'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mint MATE** Based on Ubuntu with GNOME 2'
  prefs: []
  type: TYPE_NORMAL
- en: '**Mint Xfce** Based on Ubuntu with Xfce'
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux Mint Debian Edition (LMDE)** Based on Debian with GNOME 3'
  prefs: []
  type: TYPE_NORMAL
- en: The Raspberry Pi ships with a version of Debian called Raspian. It is designed
    to be lightweight and integrates with Raspberry Pi hardware.
  prefs: []
  type: TYPE_NORMAL
- en: '***SUSE-Based Distributions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In 1992, Roland Dyroff, Thomas Fehr, Burchard Steinbild, and Hubert Mantel formed
    the German company SUSE. SUSE was an abbreviation for *Software und System-Entwicklung*,
    which translates to “software and systems development.” SUSE initially sold a
    German version of SLS Linux, but produced its own SUSE Linux distribution for
    the German market in 1994\. Several years later, it expanded to other parts of
    Europe and then internationally. Today, it’s called SUSE Software Solutions Germany
    GmbH and is an independent company. OpenSUSE is a free community version of SUSE
    Linux and is sponsored by SUSE and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'The commercial and community releases of SUSE Linux are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SUSE Linux Enterprise Server (SLES)** Commercial product'
  prefs: []
  type: TYPE_NORMAL
- en: '**SUSE Linux Enterprise Desktop (SLED)** Commercial product'
  prefs: []
  type: TYPE_NORMAL
- en: '**openSUSE Leap** Regular release version'
  prefs: []
  type: TYPE_NORMAL
- en: '**openSUSE Tumbleweed** Regular release version'
  prefs: []
  type: TYPE_NORMAL
- en: Although SUSE has traditionally focused on the KDE desktop, it also has GNOME
    and other desktop versions. SUSE has a strong presence in German-speaking as well
    as other regions throughout Europe.
  prefs: []
  type: TYPE_NORMAL
- en: '***Red Hat–Based Distributions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Red Hat Linux (both a company and a Linux distribution) was created by Marc
    Ewing in 1994\. It had its own package manager (called *pm*) and installer. Another
    small company run by Canadian Bob Young managed the product distribution. The
    two companies merged, and later became the Red Hat as we know it today. Red Hat
    is a popular name known to the public (largely due to press surrounding the stock
    market IPO), but it is actually based on the Fedora distribution. Fedora is Red
    Hat’s community distribution, and Fedora releases become part of Red Hat’s commercial
    products.
  prefs: []
  type: TYPE_NORMAL
- en: 'Several Linux distributions are associated with Red Hat:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fedora** Workstation and server editions'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fedora Spins** Fedora workstation with alternative desktops'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fedora Rawhide** Rolling release development version'
  prefs: []
  type: TYPE_NORMAL
- en: '**Red Hat Enterprise Linux (RHEL)** Commercial product built from Fedora'
  prefs: []
  type: TYPE_NORMAL
- en: '**CentOS Stream** A community rolling-release distro based on RHEL'
  prefs: []
  type: TYPE_NORMAL
- en: The default Fedora and RHEL desktops use GNOME. Red Hat’s developers have taken
    a lead in developing various standards that other distros use, such as systemd,
    PulseAudio, and various GNOME components.
  prefs: []
  type: TYPE_NORMAL
- en: '***Arch-Based Distributions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Arch Linux was developed by Canadian Judd Vinet in 2001, with the first release
    in 2002\. Arch is a non-commercial Linux distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Arch is one of the first rolling-release distributions. The installation and
    configuration of Arch Linux is based on the command line (the install ISO boots
    to a root shell and waits for commands), and users are expected to follow instructions
    on the Arch wiki to install various components. Each component must be individually
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: The terse installation process of Arch was difficult for new Linux users, but
    there was a demand for a rolling release. Manjaro Linux addresses both
  prefs: []
  type: TYPE_NORMAL
- en: needs, as it’s based on Arch and has a friendly graphical installation process.
    Manjaro Linux installs as a fully operational system.
  prefs: []
  type: TYPE_NORMAL
- en: '***Other Distributions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This book largely covers the forensic analysis of Debian-, Fedora-, SUSE-, and
    Arch-based distributions. These four distros are the foundation for the vast majority
    of Linux installations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other independent Linux distributions also have active communities of users
    and developers; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gentoo** A distro built with scripts that compile packages from source'
  prefs: []
  type: TYPE_NORMAL
- en: '**Devuan** A fork of Debian that doesn’t use systemd'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solus** A distro designed for an aesthetic appearance and that uses the Budgie
    desktop'
  prefs: []
  type: TYPE_NORMAL
- en: '**Slackware** A distro started in 1993 that aims to be “Unix-like”'
  prefs: []
  type: TYPE_NORMAL
- en: You can forensically analyze all of these distros by employing the methods described
    in this book. The only differences will be with the distribution-specific areas,
    in particular the installers and package managers. In addition, the initialization
    process may be different on some distros and may use the traditional Unix sysvinit.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*As an aside, I’d like to highlight Linux From Scratch (LFS). LFS is not a
    traditional distro, but rather a book or instruction manual. The book describes
    the process of downloading packages directly from different developers, compiling
    and installing the source, and manually configuring the system. Anyone planning
    a technical career in Linux should install an LFS system once, as doing so provides
    a rich learning experience. You can find more information at* [https://linuxfromscratch.org/](https://linuxfromscratch.org/)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Forensic Analysis of Linux Systems**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Performing a forensic examination of a Linux system has many similarities to
    Windows or macOS systems. Some examples of forensic tasks common to all three
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: Partition table analysis (DOS or GPT)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reconstructing the boot process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding user desktop activity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking for photo and video directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking for recent documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attempting to recover deleted files from the filesystem or trash/recycle bins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building timelines to reconstruct events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing thumbnail images, clipboard data, and desktop information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying applications used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding configuration files, logs, and cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing installed software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main operating system differences are the locations and formats of the forensic
    artifacts on the drive image. Linux filesystems are different, file locations
    are different, and file formats can be different.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*When performing digital forensic examinations on Linux systems, it’s possible
    to mount suspect filesystems directly on a forensic analysis workstation. However,
    any symbolic links existing on a suspect system may point to files and directories
    on the investigator’s own system.*'
  prefs: []
  type: TYPE_NORMAL
- en: There are also several advantages when examining Linux systems compared to Windows
    or macOS. Linux distros use fewer proprietary tools and have a tendency to use
    open file formats and, in many cases, use plaintext files. Additionally, many
    free and open source tools are available for performing analysis. Many of these
    tools are included with the operating system and are intended for troubleshooting,
    debugging, data conversion, or data recovery.
  prefs: []
  type: TYPE_NORMAL
- en: I wrote this book with the expectation that many forensic examiners will be
    using commercial forensic tools under Windows or possibly macOS. Unfortunately,
    commercial forensic tools are lacking in some areas of Linux analysis. In those
    cases, using a Linux analysis system is advantageous and recommended.
  prefs: []
  type: TYPE_NORMAL
- en: The examples shown in this book use Linux tools, but only to illustrate the
    forensic artifacts that exist. You can extract or discover these same artifacts
    with other forensic tools, including commercial tools used by most forensic labs.
    The use of Linux tools here is not meant to imply that they are better or recommended
    (although sometimes no equivalent commercial tools exist). They are just different.
    All forensic examiners or forensic labs have their choice of tools and platforms
    that work best for them.
  prefs: []
  type: TYPE_NORMAL
- en: The forensic processes outlined in the rest of this book are conceptually the
    same as those on Windows or macOS. The details are different, but explaining those
    details is the intention of this book.
  prefs: []
  type: TYPE_NORMAL
