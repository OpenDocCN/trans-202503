- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: D THE BASH SHELL INTERPRETER
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D THE BASH SHELL INTERPRETER
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: The *Bourne-again shell*, otherwise known as the *Bourne shell* or *bash*, is
    a Unix shell interpreter. Bash is an upgraded version of the venerable Unix sh
    (shell) program, the default shell program in Unix System 7.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*Bourne-again shell*，也称为 *Bourne shell* 或 *bash*，是一个 Unix shell 解释器。Bash 是著名的
    Unix sh（shell）程序的升级版，后者是 Unix System 7 中的默认 shell 程序。'
- en: Bash is the typical shell used in Linux systems (though other shells are available,
    such as zsh and csh). Most Linux and macOS shell programs are roughly compatible
    with one another for simple command line activities, but they differ in their
    support for sophisticated shell programming purposes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 是 Linux 系统中典型的 shell（尽管还有其他 shell，如 zsh 和 csh）。大多数 Linux 和 macOS shell
    程序在进行简单命令行操作时大致兼容，但它们在支持复杂 shell 编程方面有所不同。
- en: All the programming examples throughout this text run GCC and the Gas assembler
    via shell commands given by a bash command line. Therefore, you should have at
    least a small amount of bash knowledge in order to understand the basic commands
    in this book. This appendix gives instructions for using bash, including descriptions
    of its more common commands, but this discussion largely applies to other shell
    interpreters as well.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本文中的所有编程示例通过 bash 命令行运行 GCC 和 Gas 汇编器。因此，你至少需要具备一些基本的 bash 知识，以便理解本书中的基本命令。本附录提供了使用
    bash 的说明，包括对其常用命令的描述，但这部分内容同样适用于其他 shell 解释器。
- en: To avoid having to refer to specific OS or distribution names, I’ll use the
    name *Unix* in this appendix to refer to the underlying system (at the time of
    this writing, Unix is a registered trademark of The Open Group).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免必须提及特定的操作系统或发行版名称，我将在本附录中使用 *Unix* 这个名称来指代底层系统（在撰写本文时，Unix 是 The Open Group
    的注册商标）。
- en: D.1 Running Bash
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.1 运行 Bash
- en: The bash shell interpreter is an application similar to other Unix applications.
    To use it, you must first execute the bash application. On text-based Unix systems,
    some sort of shell application will run after you log in to the system. You can
    set up your system to automatically run bash (or any other shell program).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: bash shell 解释器是一个类似于其他 Unix 应用程序的应用程序。要使用它，你必须首先执行 bash 应用程序。在基于文本的 Unix 系统中，在你登录系统后，会运行某种
    shell 应用程序。你可以设置你的系统，使其自动运行 bash（或任何其他 shell 程序）。
- en: 'On GUI-based Linux systems or on macOS systems, you usually have to run a terminal
    program to start a shell interpreter. In either case, you’ll typically be presented
    with a *command prompt* when the shell application runs. This should be $ or #,
    depending on whether you’re logged in as a normal user or root, respectively;
    some shells display a % prompt. After printing the command prompt, the shell will
    wait for you to type a command.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '在基于 GUI 的 Linux 系统或 macOS 系统中，通常需要运行终端程序来启动一个 shell 解释器。在这两种情况下，通常在 shell 应用程序运行时会呈现一个
    *命令提示符*。根据你是否以普通用户或 root 用户身份登录，提示符通常为 $ 或 #；某些 shell 显示 % 提示符。在打印出命令提示符后，shell
    将等待你输入命令。'
- en: 'At this point, you’re running a shell interpreter, though it might not be bash;
    it could be the standard sh shell or another shell (for example, the macOS *terminal*
    application runs zsh). Though most shells will behave approximately the same,
    to ensure you’re running bash, type the following line (followed by ENTER) after
    the command prompt:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你正在运行一个 shell 解释器，尽管它可能不是 bash；它可能是标准的 sh shell 或其他 shell（例如，macOS 的 *终端*
    应用程序运行 zsh）。尽管大多数 shell 的行为大致相同，但为了确保你正在运行 bash，请在命令提示符后输入以下行（然后按 ENTER）：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will ensure that you’re running the bash application so that all the comments
    in this appendix will apply. You can terminate this instance of bash and return
    to the original shell by executing the exit command from the command line.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保你正在运行 bash 应用程序，这样本附录中的所有注释都将适用。你可以通过在命令行中执行退出命令来终止这个 bash 实例并返回到原始 shell。
- en: D.2 Command Lines
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.2 命令行
- en: 'The previous example (bash) is an instance of a command given to a shell interpreter.
    *Commands* consist of a line of text entered after a command prompt (typically
    via the keyboard) and take the following form:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例（bash）是给 shell 解释器的命令实例。*命令* 由在命令提示符后输入的一行文本组成（通常通过键盘输入），并采取以下形式：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This whole line of code is known as a *command line*, which consists of three
    components: a command (usually a single word, such as bash in the previous example),
    followed by optional command line arguments, and, finally, optional redirection
    or piping operands.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这一整行代码被称为*命令行*，它由三个组件组成：一个命令（通常是一个单词，例如前面的 bash），后跟可选的命令行参数，最后是可选的重定向或管道操作数。
- en: The command is the name of a built-in bash command or the name of an executable
    application (or shell script). For example, the command could be the name of an
    assembled assembly language source file you’ve just created.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 命令是内置 bash 命令的名称，或者是可执行应用程序（或 shell 脚本）的名称。例如，命令可能是你刚刚创建的汇编语言源文件的名称。
- en: '### D.2.1 Command Line Arguments'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '### D.2.1 命令行参数'
- en: '*Command line arguments* are strings of characters separated by spaces or tabs
    that bash will pass along to the application. The exact syntax of these command
    line arguments is application dependent. Some simple applications (including the
    assembly language examples in this book) may completely ignore any command line
    arguments; others may require very specific arguments and report an error if they
    are not syntactically correct.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*命令行参数*是由空格或制表符分隔的字符字符串，bash 会将这些字符串传递给应用程序。这些命令行参数的确切语法依赖于应用程序。有些简单的应用程序（包括本书中的汇编语言示例）可能完全忽略任何命令行参数；而其他应用程序可能需要非常特定的参数，如果语法不正确，则会报告错误。'
- en: 'Some applications define two types of command line arguments: options and arguments.
    Historically, command line *options* consist of a dash (-) prefix followed by
    a single character, or a double dash (--) prefix followed by a sequence of characters.
    For example, the bash command supports the option'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序定义了两种类型的命令行参数：选项和参数。历史上，命令行*选项*由一个连字符（-）前缀跟随一个单字符，或者由一个双连字符（--）前缀跟随一系列字符。例如，bash
    命令支持该选项。
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: which displays help information and then terminates without running the bash
    interpreter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示帮助信息并终止，而不会运行 bash 解释器。
- en: 'In contrast, an actual command line *argument* is typically a filename or other
    word (or string) that the application will use as an input value. Consider the
    following command line:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，一个实际的命令行*参数*通常是一个文件名或其他应用程序将作为输入值使用的单词（或字符串）。考虑以下命令行：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, bash will start a second instance of itself and read a set
    of commands (one per line of text) from the *script* file and execute those commands
    as though they had been typed from the keyboard. The *build* script file that
    appeared on [page 38](chapter1.xhtml#pg_38) is a good example of a shell script.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，bash 将启动一个第二实例，并从*脚本*文件中读取一组命令（每行一个），然后像键盘输入一样执行这些命令。出现在[第38页](chapter1.xhtml#pg_38)的*构建*脚本文件是一个很好的
    shell 脚本示例。
- en: 'Because bash uses spaces or tabs to separate command line arguments, problems
    arise if you want to specify a single argument that contains such *delimiters*,
    characters that separate items on the command line. Fortunately, bash provides
    a syntax that allows you to include such delimiters on the command line: if you
    surround a command line argument with quotation marks, bash will pass everything
    within the quotes to the application as a single command line argument.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 bash 使用空格或制表符来分隔命令行参数，如果你想指定一个包含这些*定界符*（在命令行中分隔项目的字符）的单一参数，就会出现问题。幸运的是，bash
    提供了一种语法，允许你在命令行中包含这些定界符：如果你用引号括起命令行参数，bash 会将引号内的所有内容作为一个单一的命令行参数传递给应用程序。
- en: 'For example, if a command requires a filename and the filename you wish to
    use contains spaces, you can pass that filename to the command as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个命令需要一个文件名，而你希望使用的文件名包含空格，你可以像下面这样将该文件名传递给命令：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Bash will not include the quotes as part of the argument it passes to the command.
    If you need to pass a quote character as part of a command line argument, precede
    the quote with a backslash character (\). For example, consider the following
    command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 不会将引号包含为它传递给命令的参数的一部分。如果你需要将引号字符作为命令行参数的一部分传递，请在引号前加上反斜杠字符（\）。例如，考虑以下命令：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This passes argument containing "quotes" as a single argument to command.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这样将包含“引号”的参数作为一个单一参数传递给命令。
- en: As you will see later in this appendix, you can also surround a command line
    argument with single quotes (apostrophe characters). The difference has to do
    with variable expansion.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在本附录后面看到的，你还可以用单引号（撇号字符）括起命令行参数。这两者的区别在于变量扩展。
- en: D.2.2 Redirection and Piping Arguments
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.2.2 重定向和管道参数
- en: Bash programs (and Unix-like OSes in general) provide a standard input device,
    a standard output device, and a standard error device.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Bash程序（以及类Unix操作系统）提供了标准输入设备、标准输出设备和标准错误设备。
- en: The *standard input device* is usually the console keyboard. If a program reads
    data from the standard input device, the program will halt until the user types
    a line of text from the keyboard.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*标准输入设备*通常是控制台键盘。如果一个程序从标准输入设备读取数据，程序将会暂停，直到用户从键盘输入一行文本。'
- en: The *standard output device* is the console display. If an application writes
    data to the standard output device, the system will display it on the display
    screen. The standard error device also defaults to the console display, so data
    written to the standard error device is also written to the display.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*标准输出设备*是控制台显示器。如果一个应用程序将数据写入标准输出设备，系统会将其显示在屏幕上。标准错误设备也默认是控制台显示器，因此写入标准错误设备的数据也会显示在屏幕上。'
- en: The bash shell provides the ability to *redirect* input and output by using
    special arguments on the command line. I/O redirection typically allows you to
    specify a filename. When redirecting the standard input device, the application
    will read lines of text from a file (rather than from the keyboard). When redirecting
    the standard output, the application will write data to a text file rather than
    to the console display.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Bash shell提供了通过在命令行使用特殊参数来*重定向*输入和输出的能力。I/O重定向通常允许你指定一个文件名。当重定向标准输入设备时，应用程序将从文件中读取文本行（而不是从键盘）。当重定向标准输出时，应用程序将数据写入文本文件，而不是写入控制台显示器。
- en: To redirect the standard input from a file, use a command line argument of the
    form
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要从文件重定向标准输入，请使用如下命令行参数：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: where InputFile is the name of a file containing text to be read by the application.
    Whenever the application command would normally read a line of text from the keyboard,
    it will instead read that line of text from the specified file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 其中InputFile是一个包含将被应用程序读取的文本的文件名。每当应用程序命令通常会从键盘读取一行文本时，它将从指定的文件中读取该行文本。
- en: 'To redirect the standard output to a file, use the following command line syntax:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要将标准输出重定向到文件，请使用以下命令行语法：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Any output normally written to the standard output device (the display) will
    be written to the specified file (OutputFile). This syntax will delete the contents
    of any existing file named *OutputFile* and replace its contents with the output
    of the command application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 任何通常写入标准输出设备（显示器）的输出将会写入指定的文件（OutputFile）。该语法会删除任何名为*OutputFile*的现有文件内容，并将其内容替换为命令应用程序的输出。
- en: 'A variation of output redirection will append a program’s output to the end
    of an existing file rather than replacing its contents. To use output redirection
    this way, use this syntax:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一种输出重定向的变体是将程序的输出附加到现有文件的末尾，而不是替换其内容。要以这种方式使用输出重定向，请使用以下语法：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that redirecting the standard output device does not change the standard
    error output device. If you’ve redirected the standard output to a file and an
    application writes data to the standard error device, that output still appears
    on the console display. You can redirect the standard error device by using the
    following syntax:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，重定向标准输出设备不会改变标准错误输出设备。如果你已经将标准输出重定向到一个文件，并且某个应用程序将数据写入标准错误设备，那么该输出仍然会显示在控制台上。你可以使用以下语法来重定向标准错误设备：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The 2> tells bash to redirect the output sent to file handle 2\. Under Unix-style
    systems, handle 0 is reserved for the standard input, handle 1 is reserved for
    the standard output, and handle 2 is reserved for the standard error output device.
    Sticking the handle number in front of the > specifies which output to redirect.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 2>告诉bash将输出重定向到文件句柄2。 在类Unix系统中，句柄0保留用于标准输入，句柄1保留用于标准输出，而句柄2保留用于标准错误输出设备。将句柄号放在>符号前面，指定要重定向的输出。
- en: 'If you like, you can also redirect the standard output by using this syntax:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你也可以使用这种语法来重定向标准输出：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The final form of I/O redirection is the *pipe*, which connects the standard
    output from one application to the standard input of a second application. This
    allows the second application to read, as input, the output from the first application.
    Here’s the syntax for a pipe redirection:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最终形式的输入/输出重定向是*管道*，它将一个应用程序的标准输出连接到第二个应用程序的标准输入。这允许第二个应用程序将第一个应用程序的输出作为输入进行读取。以下是管道重定向的语法：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This tells bash to redirect the output from command1 as the input to command2.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 bash 将命令1的输出重定向为命令2的输入。
- en: D.3 Directories, Pathnames, and Filenames
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.3 目录、路径名和文件名
- en: When you run bash, it will default to a current directory in the OS’s file structure.
    Unix calls this the *current working directory*. Whenever you run bash (for example,
    when you first log in), the current working directory is typically your home directory
    (as determined by the OS). For example, on my Debian system, this is */home/rhyde*
    (under macOS, it’s */Users/rhyde*).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 bash 时，它会默认指向操作系统文件结构中的当前目录。Unix 称此为 *当前工作目录*。每当你运行 bash（例如，当你第一次登录时），当前工作目录通常是你的主目录（由操作系统决定）。例如，在我的
    Debian 系统中，这是 */home/rhyde*（在 macOS 下，它是 */Users/rhyde*）。
- en: When you specify a filename on the command line that does not contain any slash
    characters, bash or the application will assume that file exists in the executable
    path supplied to the system. A *pathname* consists of a sequence of one or more
    directory names, separated by slashes, ending with a filename. A relative pathname
    begins with a directory name; the system looks for that directory within the current
    working directory. For example, *dir1/dir2/filename* specifies a file (*filename*)
    appearing in *dir1* in the current working directory and within *dir2*, which
    is itself within *dir1*. An *absolute pathname* begins with a slash followed by
    the outermost root directory. For example, */home/rhyde/x.txt* specifies the file
    *x.txt* appearing in the */home/rhyde* directory (my home directory under Debian).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在命令行中指定的文件名不包含任何斜杠字符时，bash 或应用程序会假设该文件存在于系统提供的可执行路径中。*路径名* 是由一个或多个目录名组成的序列，目录名之间用斜杠分隔，最后是文件名。相对路径名以目录名开始；系统会在当前工作目录中查找该目录。例如，*dir1/dir2/filename*
    指定了当前工作目录下的 *dir1* 目录中的 *dir2* 中的文件 (*filename*)。*绝对路径名* 以斜杠开始，后面跟着最外层的根目录。例如，*/home/rhyde/x.txt*
    指定了在 */home/rhyde* 目录中的 *x.txt* 文件（这是我在 Debian 下的主目录）。
- en: The tilde special character (~) is shorthand for the current user’s home directory.
    Therefore, *~/x.txt* is another way for me to specify */home/rhyde/x.txt* on my
    Debian system. This scheme also works in macOS, so it’s a useful way to specify
    user directory paths in a system-independent fashion.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 波浪号特殊字符 (~) 是当前用户主目录的简写。因此，*~/x.txt* 是我在 Debian 系统中指定 */home/rhyde/x.txt* 的另一种方式。这个方案在
    macOS 中也适用，因此它是以系统独立的方式指定用户目录路径的一个有用方法。
- en: The special character period (.), by itself, is shorthand for the current working
    directory. The double-period sequence (..) is shorthand for the directory that
    contains the current working directory (the parent directory). For example, *../x.txt*
    refers to the file named *x.txt* in the parent directory. On Linux-based systems,
    to execute an application from the current working directory, you must specify
    *./filename* rather than just *filename* (unless you’ve placed *./* in your execution
    path).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 特殊字符句点 (.) 本身是当前工作目录的简写。双句点序列 (..) 是指当前工作目录的上级目录（父目录）。例如，*../x.txt* 指的是父目录中的名为
    *x.txt* 的文件。在基于 Linux 的系统中，要从当前工作目录执行应用程序，必须指定 *./filename*，而不能仅仅使用 *filename*（除非你已经将
    *./* 添加到执行路径中）。
- en: 'Some Unix commands allow you to specify multiple filenames on the command line.
    Such commands often allow the use of wildcard characters to specify multiple names.
    Unix supports a rich set of regular expressions when specifying wildcards, one
    of which you’ll commonly use: the asterisk (*). Bash will match any number of
    characters (zero or more) in place of the asterisk. Therefore, the filename **.txt*
    will match any file ending with the four-character sequence *.txt* (this includes
    *.txt* by itself).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Unix 命令允许你在命令行中指定多个文件名。这些命令通常允许使用通配符字符来指定多个名称。Unix 在指定通配符时支持一套丰富的正则表达式，其中你最常使用的是星号
    (*)。Bash 将匹配星号所代表的任意数量的字符（零个或多个）。因此，文件名 **.txt* 将匹配以四个字符序列 *.txt* 结尾的任何文件（包括仅为
    *.txt* 的文件）。
- en: D.4 Built-in and External Bash Commands
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.4 内置和外部 Bash 命令
- en: 'Bash supports two types of commands: built-in and external. *Built-in commands*
    exist as part of the bash application itself; a function inside the bash source
    code handles the given built-in command. *External commands* correspond to executable
    programs separate from bash that bash will load and execute (then take control
    back from those programs when they terminate). Built-in commands are always available
    when you run bash, but external commands may or may not be available, depending
    on the presence of the executable code for those commands. You can assume that
    the commands appearing in the following subsections are all external, unless otherwise
    noted.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 支持两种类型的命令：内建命令和外部命令。*内建命令*作为 bash 应用程序的一部分存在；一个位于 bash 源代码中的函数处理给定的内建命令。*外部命令*是指与
    bash 分开存在的可执行程序，bash 会加载并执行这些程序（然后在这些程序终止后重新接管控制）。内建命令在您运行 bash 时始终可用，但外部命令可能可用，也可能不可用，这取决于这些命令的可执行代码是否存在。除非另有说明，您可以假设以下小节中出现的命令都是外部命令。
- en: The assembly language example programs in this book are examples of external
    commands. When you enter something like
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的汇编语言示例程序是外部命令的示例。当您输入类似的命令时：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: at the command line, bash will locate the *Listing1-5* executable in the current
    working directory (./) and attempt to execute that code.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令行中，bash 会在当前工作目录 (./) 中找到 *Listing1-5* 可执行文件并尝试执行该代码。
- en: For security reasons, bash will not automatically execute a program in the current
    working directory unless you explicitly prepend the characters ./ to the executable’s
    name. Bash assumes that program names without explicit path information can be
    found in the *execution path*. The execution path (see section D.6.1, “Defining
    Shell Script Variables and Values,” on [page 961](appendix-D.xhtml#pg_961)) is
    a list of directories where bash will search for an executable program you specify
    without explicit path information. Usually, bash will look in places such as */bin*,
    */usr/bin*, and */sbin* for executable programs.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全原因，bash 不会自动执行当前工作目录中的程序，除非您明确地在可执行文件名前加上 ./ 字符。bash 假设没有显式路径信息的程序名可以在 *执行路径*
    中找到。执行路径（见第 D.6.1 节，“定义 Shell 脚本变量和值”，在[第 961 页](appendix-D.xhtml#pg_961)）是一个目录列表，bash
    会在这些目录中查找您指定的可执行程序，而无需显式的路径信息。通常，bash 会在 */bin*、*/usr/bin* 和 */sbin* 等地方查找可执行程序。
- en: To enable bash to execute programs from your current working directory without
    having to prefix the executable filename with the ./ characters, you can add ./
    to your execution path. However, there are some very good security reasons for
    not doing this. For more on this, see section D.8, “For More Information,” on
    [page 968](appendix-D.xhtml#pg_968).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 bash 能够从当前工作目录执行程序，而无需在可执行文件名前加上 ./ 字符，您可以将 ./ 添加到执行路径中。然而，出于安全原因，不建议这么做。有关更多信息，请参阅第
    D.8 节，“更多信息”，在[第 968 页](appendix-D.xhtml#pg_968)。
- en: '## D.5 Basic Unix Commands'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '## D.5 基本 Unix 命令'
- en: It would be impossible to describe all Unix commands in this appendix. That
    would take a large book by itself. This section describes several commands useful
    to those developing assembly language programs, along with some of their options
    and parameters. For information on additional bash commands, check out section
    D.8, “For More Information,” on [page 968](appendix-D.xhtml#pg_968).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中描述所有 Unix 命令是不可能的。这将单独需要一本大书。本节描述了对开发汇编语言程序有用的几个命令，以及它们的一些选项和参数。有关其他 bash
    命令的信息，请查看第 D.8 节，“更多信息”，在[第 968 页](appendix-D.xhtml#pg_968)。
- en: D.5.1 man
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.5.1 man
- en: If you know the name of the command but are unsure about the syntax for its
    command line parameters and options, you can use the man command to learn about
    it. This command brings up the manual page for a (supported) command, with the
    syntax
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道命令名称，但不确定其命令行参数和选项的语法，可以使用 man 命令来了解它。此命令会显示一个（支持的）命令的手册页面，语法如下：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'where CommandName is the name of the command whose manual page you would like
    to read. For example, the following brings up the manual page for the man command
    itself:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 CommandName 是您想要阅读其手册页面的命令名称。例如，下面的命令会显示 man 命令本身的手册页面：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can use man, with the command names listed in the following subsections,
    to learn additional information about each.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 man 命令，配合以下小节中列出的命令名称，来了解每个命令的更多信息。
- en: D.5.2 cd or chdir
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.5.2 cd 或 chdir
- en: You can set the current working directory by using the cd (change directory)
    command (chdir is an alias of this command). The standard syntax is
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 cd（改变目录）命令设置当前工作目录（chdir 是此命令的别名）。标准语法是
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: where DirectoryPath is a relative or absolute path to a directory in the filesystem.
    Unix will report an error if the directory does not exist or if this is the name
    of a file rather than a directory.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 DirectoryPath 是文件系统中某个目录的相对或绝对路径。如果目录不存在或指定的是文件而不是目录，Unix 会报告错误。
- en: 'If you specify the cd command without any arguments, it will switch to the
    current user’s home directory. This is equivalent to entering the following on
    the command line:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不提供任何参数而指定 cd 命令，它会切换到当前用户的主目录。这等同于在命令行中输入以下命令：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The cd and chdir commands are built into bash.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: cd 和 chdir 命令是内建在 bash 中的。
- en: D.5.3 pwd
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.5.3 pwd
- en: The pwd (print working directory) command prints the path to the current working
    directory. Bash is generally set up to print the current working directory as
    part of the command line prompt; if this is the case for your system, you probably
    won’t need to use pwd. This is also an internal bash command.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: pwd（打印工作目录）命令打印当前工作目录的路径。Bash 通常会在命令行提示符中显示当前工作目录；如果你的系统是这种配置，可能不需要使用 pwd。这个命令也是一个内建的
    bash 命令。
- en: D.5.4 ls
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.5.4 ls
- en: The ls (list directory) command prints a directory listing to the standard output.
    When used with no options, it displays the contents of the current directory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ls（列出目录）命令将目录列表打印到标准输出。没有选项时，它会显示当前目录的内容。
- en: When printing the directory listing to the display, ls defaults to a multicolumn
    format. If you direct the output to a file, by redirecting the standard output
    or by using a pipe, the command prints the listing in a single-column format.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当打印目录列表到显示器时，ls 默认使用多列格式。如果你将输出重定向到文件，或者通过管道使用，命令会以单列格式打印列表。
- en: If you supply a directory path as an argument, the ls command will display the
    contents of the specified directory (assuming it exists). If you specify a pathname
    to a file as an argument, the ls command will display only that filename (again,
    assuming that file exists in the specified path).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提供一个目录路径作为参数，ls 命令会显示指定目录的内容（假设该目录存在）。如果你提供一个文件的路径作为参数，ls 命令会只显示该文件名（同样，假设文件在指定路径下存在）。
- en: 'By default, the ls command will not display filenames that begin with a period.
    Unix treats such files as *hidden*. If you want to display such filenames, use
    the -a command line option:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，ls 命令不会显示以句点开头的文件名。Unix 将这些文件视为*隐藏文件*。如果你想显示这些文件名，可以使用 -a 命令行选项：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'By default, the ls command lists only the filenames and directory names in
    the specified directory. If you specify the -l (long) option, the ls command will
    display additional information about each file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，ls 命令只列出指定目录中的文件名和目录名。如果你指定了 -l（长格式）选项，ls 命令将显示每个文件的更多信息：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first column in the listing specifies the file permissions. The next three
    provide a link count and ownership information, followed by file size and modification
    date and time, followed by the filename.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的第一列指定文件权限。接下来的三列提供链接计数和所有权信息，接着是文件大小和修改日期与时间，最后是文件名。
- en: D.5.5 file
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.5.5 file
- en: 'Unlike macOS and Windows, Unix does not associate a specific data type with
    a file. You can use the Unix file command to determine a file type for a particular
    file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与 macOS 和 Windows 不同，Unix 不会将特定数据类型与文件关联。你可以使用 Unix 的 file 命令来确定某个文件的类型：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The file command will respond with its best guess as to the type of the file
    specified by pathname.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: file 命令会根据指定路径的文件类型做出最佳猜测并返回结果。
- en: D.5.6 cat, less, more, and tail
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.5.6 cat, less, more, 和 tail
- en: To view the contents of a text file, you can display that file in its entirety
    using the cat (catenate) command
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看文本文件的内容，可以使用 cat（连接）命令完整显示该文件内容。
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: where pathname is the path to the name of the file you wish to display.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 pathname 是你希望显示的文件的路径名。
- en: 'The problem with cat is that it tries to write the entire file to the display,
    all at once. Many files are larger than can be displayed on the screen at one
    time, so cat ends up displaying only the last few lines of the file; moreover,
    very large files may take a while to display their contents. If you would like
    to be able to page through a file one screenful at a time, you can use the more
    and less commands:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`命令的问题在于，它试图一次性将整个文件写入显示器。许多文件的大小超出了屏幕一次性显示的范围，因此`cat`最终只会显示文件的最后几行；此外，非常大的文件可能需要一段时间才能显示其内容。如果你希望能够逐屏翻阅文件，可以使用`more`和`less`命令：'
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The more command is now obsolete but is still available to handle older script
    files that contain it. It displays a pageful of text and allows you to scroll
    through the file a line at a time (by pressing ENTER) or a page at a time (by
    pressing the spacebar). The big drawback to more is that you can view only forward
    in a file; after information scrolls off the screen, it is lost.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`more`命令现在已经过时，但仍然可以处理包含该命令的旧脚本文件。它一次显示一屏的文本，并允许你按行（按ENTER键）或按页（按空格键）滚动文件。`more`的一个大缺点是你只能向前查看文件；当信息滚动出屏幕后，它就丢失了。'
- en: The less command (whose name comes from the phrase *less is more*) is an upgraded
    version of more that allows you to scroll forward and backward in a page. Most
    people use the less command rather than more because of the additional features
    (such as being able to use the arrow keys to consistently scroll up and down a
    line at a time).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`less`命令（其名称来自短语*less is more*）是`more`的升级版本，允许你在一页中向前和向后滚动。大多数人使用`less`命令而不是`more`，因为它有更多的功能（比如能够使用箭头键来持续按行上下滚动）。'
- en: 'If you want to view only the last few lines of a large file, use the tail command:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想查看大型文件的最后几行，可以使用`tail`命令：
- en: '[PRE22]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: By default, tail prints the last 10 lines of the file. You can use the -n xxxx
    command line option, where xxxx is a decimal numeric value, to specify a different
    line count. For example
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`tail`会打印文件的最后10行。你可以使用`-n xxxx`命令行选项，其中`xxxx`是一个十进制数值，用来指定不同的行数。例如
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: displays the last 20 lines of the file *x.txt.*
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 显示文件*x.txt.*的最后20行
- en: D.5.7 mv
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.5.7 mv
- en: 'The mv (move) command has the following syntax:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`mv`（移动）命令的语法如下：'
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: SourcePath is the pathname of the file you want to move or rename, and DestinationPath
    is the final destination path where you want the file moved (or the new name you
    want to use for the file).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: SourcePath是你想要移动或重命名的文件的路径，DestinationPath是你希望文件移动到的最终目标路径（或你希望用于文件的新名称）。
- en: To rename a file in the current directory, mv takes the form
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要在当前目录中重命名文件，`mv`命令的形式为
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: where OldName is the existing filename you want to change and NewName is the
    new filename you want to rename the file. These are both simple filenames (no
    directory path components). Note that NewName must be different from OldName.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，OldName是你想要更改的现有文件名，NewName是你想要为文件重命名的新文件名。这两个都是简单的文件名（没有目录路径成分）。请注意，NewName必须与OldName不同。
- en: To move a file from one directory to another, either the SourcePath or DestinationPath
    (or both) must contain a directory component. The SourcePath must contain a filename
    component at the end of the pathname (the name of the file to move). For the DestinationPath,
    a filename at the end is optional. If the DestinationPath is the name of a directory
    (rather than a file), mv will move the source file into the destination directory
    and use the same filename as the original source file. If there is a filename
    at the end of DestinationPath, then mv will change the filename while it is moving
    it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文件从一个目录移动到另一个目录，SourcePath或DestinationPath（或两者）必须包含目录成分。SourcePath必须在路径的末尾包含文件名成分（即要移动的文件名）。对于DestinationPath，末尾的文件名是可选的。如果DestinationPath是一个目录的名称（而不是文件），`mv`将把源文件移动到目标目录，并使用与原始源文件相同的文件名。如果DestinationPath末尾有文件名，那么`mv`会在移动文件时更改文件名。
- en: 'You can use wildcard characters with mv, subject to the following restrictions:
    wildcard characters may appear only in the source pathname, and the destination
    path must be a directory, not an actual filename.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用通配符字符与`mv`命令一起使用，但须遵守以下限制：通配符字符只能出现在源路径中，目标路径必须是一个目录，而不能是实际的文件名。
- en: D.5.8 cp
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.5.8 cp
- en: 'The cp command has the following syntax:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`cp`命令的语法如下：'
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This command will make a copy of the file specified by SourcePath, using the
    name DestinationPath for the copy. If both pathnames are simple filenames (that
    is, you’re making a copy of a file in the current directory), the two filenames
    must be different.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将指定的 SourcePath 文件复制，并使用 DestinationPath 作为复制文件的名称。如果两个路径名都是简单的文件名（即你正在复制当前目录中的文件），则两个文件名必须不同。
- en: The cp command accepts wildcard characters in the source operand. If wildcard
    characters are present, the destination must be a directory path. The cp command
    will copy all files matching the wildcard designation to the specified directory.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: cp 命令接受源操作数中的通配符字符。如果存在通配符字符，则目标必须是目录路径。cp 命令将把所有匹配通配符的文件复制到指定的目录中。
- en: If both source and destination operands specify a directory, use the -R (recursive)
    command line option. This will copy all the files from the source directory to
    a directory by the same name in the destination directory (creating the new directory
    in the destination if it is not already present); it will also recursively copy
    any subdirectories in the source directory into similarly named subdirectories
    in the destination.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果源和目标操作数都指定了目录，请使用 -R（递归）命令行选项。这将把源目录中的所有文件复制到目标目录中同名的目录（如果目标目录中尚不存在该目录，则会创建新目录）；它还将递归地将源目录中的任何子目录复制到目标目录中同名的子目录中。
- en: D.5.9 rm
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.5.9 rm
- en: 'The rm command removes (deletes) a file from a directory, using the following
    syntax:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: rm 命令从目录中移除（删除）一个文件，使用以下语法：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The pathname argument must be a path to an individual file, not a directory.
    To delete a directory and all the files in it, use the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: pathname 参数必须是指向单个文件的路径，而不是目录。要删除目录及其中的所有文件，请使用以下命令：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will recursively delete all files and subdirectories in DirectoryPath,
    then delete the directory specified by DirectoryPath.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将递归地删除 DirectoryPath 中的所有文件和子目录，然后删除由 DirectoryPath 指定的目录。
- en: 'To delete all the files in a directory without removing the directory itself,
    use the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除目录中的所有文件而不删除目录本身，请使用以下命令：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Be very careful when using wildcard characters in an rm command. Depending
    on the current working directory, the following command could delete everything
    on your storage devices:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 rm 命令时要非常小心通配符字符。根据当前工作目录，以下命令可能会删除存储设备上的所有内容：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: There is also an rmdir command you can use to remove empty directories. However,
    the rm -R directory command is easier to use for this purpose.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个 rmdir 命令可以用来删除空目录。然而，rm -R directory 命令更容易用于这个目的。
- en: D.5.10 mkdir
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.5.10 mkdir
- en: The mkdir command creates a new (empty) directory, using the syntax
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: mkdir 命令创建一个新的（空的）目录，使用以下语法：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: where DirectoryPath specifies the pathname to a directory that does not already
    exist. If DirectoryPath is an actual pathname, all subdirectory names up to the
    final name in the path must exist; the final directory name (after the last /)
    must not exist. If you specify a simple directory name (no path), bash will create
    the directory in the current working directory.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 DirectoryPath 指定一个尚不存在的目录的路径名。如果 DirectoryPath 是一个实际的路径名，则路径中的所有子目录名称必须存在，路径中的最后一个目录名称（在最后的
    / 之后）不能存在。如果指定的是简单的目录名（没有路径），bash 将在当前工作目录中创建该目录。
- en: The mkdir command supports a -p command line option that will create all nonexistent
    directories in the path.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: mkdir 命令支持 -p 命令行选项，可以创建路径中所有不存在的目录。
- en: D.5.11 date
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.5.11 date
- en: The date command displays the current date and time. You can also use this command
    to set the Unix real-time clock. Run man date for the details.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: date 命令显示当前日期和时间。你也可以使用此命令来设置 Unix 实时时钟。运行 man date 获取详细信息。
- en: D.5.12 echo
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.5.12 echo
- en: The echo command prints the text on the remainder of the command line (subject
    to some expansions by bash) to the standard output device. For example
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: echo 命令将命令行其余部分的文本（由 bash 扩展）打印到标准输出设备。例如：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: will write hello, world! to the standard output. You’ll use this command most
    often in scripts or to display the value of various shell variables.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将会把 hello, world! 写入标准输出。你将在脚本中或用来显示各种 shell 变量的值时最常使用此命令。
- en: D.5.13 chmod
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.5.13 chmod
- en: Although Unix files do not have a specific type, the directory does maintain
    whether a file is readable, writable, or executable by the owner of the file,
    a group associated with the file, or anyone (standard Unix permissions). The chmod
    command allows you to set (or clear) permission mode bits for a particular file.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Unix 文件没有具体类型，但目录确实会维护文件是否可以由文件所有者、与文件相关联的组或任何人读取、写入或执行（标准的 Unix 权限）。chmod
    命令允许你为特定文件设置（或清除）权限模式位。
- en: The basic syntax for chmod is
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: chmod 的基本语法是
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: where pathname is the path to the file whose mode you want to change, and the
    options parameter(s) specifies the new permissions.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 pathname 是你想要更改模式的文件路径，options 参数指定新的权限。
- en: 'The options argument is either an octal (base-8) number (typically three digits)
    or a special string to set the permissions. Unix has three permission categories:
    owner/user, group, and other. The *owner* category applies to the user who created
    the file in the first place. The *group* category covers any groups that the user
    belongs to (and other users may belong to). The *other* category covers everyone
    else.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: options 参数可以是一个八进制（基数 8）数字（通常为三位数），也可以是一个特殊字符串来设置权限。Unix 具有三类权限：所有者/用户、组和其他。*所有者*类别适用于最初创建文件的用户。*组*类别适用于用户所属的任何组（以及其他用户可能所属的组）。*其他*类别适用于所有其他人。
- en: 'In addition to the three categories, Unix has three main types of permissions:
    permission to *read* a file, permission to *write* data to a file (or delete it),
    and permission to *execute* a file (this generally applies to object code or shell
    scripts).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这三类权限外，Unix 还具有三种主要的权限类型：*读取*文件的权限、*写入*数据到文件的权限（或删除文件），以及*执行*文件的权限（通常适用于目标代码或
    Shell 脚本）。
- en: A typical chmod option consists of a string of one to three characters from
    the set {ugo} followed by a plus or minus character (+ or -, not ±), followed
    by a single character from the set {rwx}. For example, u+r enables user read access,
    u+x enables execution permission, and ugo-x removes execution privileges for all
    categories. Note that the ls -l command will list the user, group, and other permissions
    for a given file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的 chmod 选项由一个到三个字符组成，字符来自 {ugo} 集合，后面跟着一个加号或减号字符（+ 或 -，而不是 ±），再跟着一个来自 {rwx}
    集合的单一字符。例如，u+r 启用用户的读取权限，u+x 启用执行权限，ugo-x 移除所有类别的执行权限。注意，ls -l 命令会列出给定文件的用户、组和其他权限。
- en: You can also specify the permissions for the three categories as a three-digit
    octal number, where each digit represents the three rwx bits for users (HO digit),
    groups (middle digit), and other (LO digit). For example, 755 specifies read/write/execute
    permissions for the user (111[2] = 7[8]), read and execute permissions for the
    group, and other (101[2] = 5[8]). Note that 755 is a typical set of permissions
    you would assign to a publicly usable script file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过指定一个三位八进制数字来设置三类权限，其中每一位代表用户（高位数字）、组（中间数字）和其他（低位数字）的 rwx 权限。例如，755 表示用户具有读/写/执行权限（111[2]
    = 7[8]），组和其他用户具有读和执行权限（101[2] = 5[8]）。注意，755 是你通常会赋予一个公开可用的脚本文件的典型权限。
- en: D.6 Shell Scripts
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.6 Shell 脚本
- en: A *shell script* is a text file that bash will interpret as a sequence of commands
    to execute, exactly as though each line in the text file were entered from the
    keyboard while running bash. For those with Microsoft Windows experience, this
    is similar to a batch file. This section discusses using shell variables and values,
    using special built-in shell variables, and creating your own bash shell scripts.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*Shell 脚本*是一个文本文件，bash 将其解释为一系列要执行的命令，就像在运行 bash 时每行命令是从键盘输入的一样。对于有微软 Windows
    使用经验的人来说，这类似于批处理文件。本节讨论了如何使用 shell 变量和数值、使用内置的特殊 shell 变量，以及如何创建你自己的 bash Shell
    脚本。'
- en: The bash interpreter is a full-fledged programming language that supports conditional
    and looping constructs as well as the sequential execution of commands on the
    command line. It supports if...elif...else statements, a case statement (similar
    to C’s switch statement), and various loops (while, for, and so on). It also supports
    functions, local variables, and other features typically found in HLLs. Going
    into detail on these topics is beyond the scope of this book. See Ryan’s Tutorials
    in section D.8, “For More Information,” on [page 968](appendix-D.xhtml#pg_968)
    for details beyond what this section covers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: bash 解释器是一个完整的编程语言，支持条件判断和循环结构，以及命令行上命令的顺序执行。它支持 if...elif...else 语句、一个 case
    语句（类似于 C 的 switch 语句），以及各种循环（如 while、for 等）。它还支持函数、本地变量以及其他通常在高级语言中发现的特性。详细讨论这些内容超出了本书的范围。有关更多信息，请参阅
    D.8 节中的 Ryan’s Tutorials，[第 968 页](appendix-D.xhtml#pg_968)，以获取本节未涵盖的详细信息。
- en: '### D.6.1 Defining Shell Script Variables and Values'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '### D.6.1 定义 Shell 脚本变量和值'
- en: 'Bash allows you to define shell variables. A *shell variable* is a name (think:
    programming language identifier) to which you can assign some text. For example,
    the following bash command assigns the text ls to list:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 允许你定义 shell 变量。一个*shell 变量*是一个名称（类似于编程语言中的标识符），你可以为其赋值一些文本。例如，以下 bash 命令将文本
    ls 赋值给 list：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can tell bash to expand a shell variable name to its associated text by
    prefixing the name with a $ character. For example
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在变量名前加上 $ 符号来告诉 bash 扩展 shell 变量名为其关联的文本。例如
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: expands to
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 展开为
- en: '[PRE36]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: which will display the current directory listing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示当前目录列表。
- en: Normally, you would not use shell variables to create aliases of existing commands,
    as the alias command is better suited to the job. Instead, you would use shell
    variables to keep track of paths, options, and other information commonly used
    on the command line.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你不会使用 shell 变量来创建现有命令的别名，因为 alias 命令更适合这个工作。相反，你会使用 shell 变量来跟踪路径、选项以及命令行中常用的其他信息。
- en: 'Bash supplies several predefined shell variables, including the following:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 提供了多个预定义的 shell 变量，包括以下内容：
- en: $HOME    Contains the path to the current user’s home directory
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: $HOME    包含当前用户的主目录路径
- en: $HOSTNAME    Contains the machine’s name
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: $HOSTNAME    包含机器的名称
- en: $PATH    Contains a list of directory paths, separated by colons (:), that bash
    will search through when searching for an external command’s executable file
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: $PATH    包含一系列由冒号（:）分隔的目录路径，bash 在查找外部命令的可执行文件时会遍历这些路径
- en: $PS1    Contains a string that bash will print as the command line prompt
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: $PS1    包含 bash 将作为命令行提示符打印的字符串
- en: $PWD    Contains the current working directory
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: $PWD    包含当前工作目录
- en: For a complete list of predefined shell variables, and for more details on the
    $PS1 variable in particular, see section D.8, “For More Information,” on [page
    968](appendix-D.xhtml#pg_968).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有关预定义 shell 变量的完整列表，以及特别是关于 $PS1 变量的更多详细信息，请参阅 D.8 节，“更多信息”，见 [第 968 页](appendix-D.xhtml#pg_968)。
- en: 'Shell variables to which you assign values will retain those values during
    the execution of the current bash shell. Often, when executing shell scripts,
    a second bash shell begins execution, and any variable values created or modified
    in that execution will be lost when that shell terminates. To avoid this problem,
    use the built-in export command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你为 shell 变量赋的值将在当前 bash shell 执行期间保持不变。通常，在执行 shell 脚本时，会启动一个新的 bash shell，并且在该执行过程中创建或修改的任何变量值会在该
    shell 终止时丢失。为避免这个问题，可以使用内建的 export 命令：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This command will make the variable assignment visible to parent shells. Typically,
    you must use export when assigning values in a shell script that you want to retain
    after the shell script completes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将使变量赋值对父 shell 可见。通常情况下，你必须在赋值时使用 export，特别是当你希望在 shell 脚本执行完后保留变量值时。
- en: You can define shell variables in a script file, just as you can when interactively
    typing commands at the command line. As noted earlier, however, any variable values
    defined in a shell script are lost when the shell terminates. This is because
    bash will make a copy of the execution environment (including all the shell variable
    values) when it starts a shell script. Any changes or additions you make, such
    as creating new variables or modifying existing ones, affect only the copy of
    the environment. When the shell script terminates, it deletes the copy of the
    environment and reverts to the original environment. The export command tells
    bash to export the variable assignment to the parent environment (as well as applying
    to the current local environment).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像在命令行上交互输入命令时一样，在脚本文件中定义 shell 变量。然而，如前所述，任何在 shell 脚本中定义的变量值会在 shell 终止时丢失。这是因为
    bash 在启动脚本时会复制执行环境（包括所有 shell 变量的值）。你所做的任何更改或新增内容，例如创建新变量或修改现有变量，只会影响环境的副本。当脚本终止时，它会删除该副本并恢复原始环境。export
    命令会告诉 bash 将变量赋值导出到父环境（同时适用于当前的本地环境）。
- en: 'Values assigned to a shell variable are generally treated as text. Because
    the bash interpreter breaks up command lines by using spaces or other delimiters,
    the string of text you assign to a script variable must consist of a single *word*
    (that is, a sequence of characters surrounded by delimiters). If you want to include
    delimiter (and other) characters within the value, you must surround the text
    value with quotes or apostrophes, as in the following example:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给 shell 变量的值通常被当作文本处理。因为 bash 解释器通过空格或其他分隔符来分割命令行，所以你为脚本变量分配的文本值必须由一个单一的*单词*（即被分隔符包围的字符序列）组成。如果你希望在值中包含分隔符（以及其他）字符，必须使用引号或撇号将文本值括起来，如以下示例所示：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Bash will expand the text inside double quotes (") and will maintain the text
    as is inside single quotes (''). Consider the following example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 会扩展双引号（"）内的文本，并且会保持单引号（'）内的文本不变。考虑以下示例：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Executing this sequence will produce the following output:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此序列将产生以下输出：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Bash expands $aVariable inside the string enclosed in double quotes but will
    not expand it inside the string enclosed in single quotes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Bash 会在双引号内扩展 $aVariable，但不会在单引号内扩展它。
- en: 'You might see strings surrounded by grave accent characters (`), commonly called
    *backticks* in Unix. Originally, such strings surrounded a command that the shell
    would execute, then substitute the textual output of the program in place of the
    backticked string. This syntax has been deprecated in modern shells. To capture
    the output of a command and assign it to a variable, use $(command), as in the
    following example:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到被重音符号（`）包围的字符串，在 Unix 中通常被称为*反引号*。最初，这样的字符串用于包围一个命令，shell 会执行该命令，然后将程序的文本输出替换回反引号包围的字符串。这个语法在现代的
    shell 中已被弃用。要捕获命令的输出并将其赋值给变量，请使用 $(command)，如以下示例所示：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This creates a string consisting of the listing of the current working directory
    and assigns that string to the dirListing variable.  ### D.6.2 Defining Special
    Shell Variables'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这会创建一个包含当前工作目录列表的字符串，并将该字符串赋值给变量 dirListing。### D.6.2 定义特殊 Shell 变量
- en: In addition to the shell variables a script inherits from the parent environment,
    bash also defines certain shell variables that might prove useful in shell scripts
    you write. These special variables begin with $ and typically deal with command
    line parameters passed to the script (see [Table D-1](#tabD-1)).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 除了脚本从父环境继承的 shell 变量外，bash 还定义了某些可能在你编写的 shell 脚本中有用的特殊 shell 变量。这些特殊变量以 $ 开头，通常与传递给脚本的命令行参数相关（参见
    [表 D-1](#tabD-1)）。
- en: 'Table D-1: Special Shell Variables'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 表 D-1：特殊 Shell 变量
- en: '| Variable | Description |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| $0 | Expands to the pathname of the shell script file. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| $0 | 扩展为 shell 脚本文件的路径名。 |'
- en: '| $1 through $n | Expands to the first, second, ..., nth command line argument.
    |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| $1 到 $n | 扩展为第一个、第二个、...，第 n 个命令行参数。 |'
- en: '| $# | Expands to a decimal number specifying the parameter count. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| $# | 扩展为指定参数个数的十进制数字。 |'
- en: '| $* | Expands to a string containing all the command line parameters. Generally
    used to pass the parameters on to another command. To assign this command line
    parameter-list string to a shell variable, use $* to capture the text as a single
    string. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| $* | 扩展为包含所有命令行参数的字符串。通常用于将参数传递给另一个命令。要将此命令行参数列表字符串赋值给 shell 变量，请使用 $* 来捕获文本作为单个字符串。
    |'
- en: '| $@ | Similar to $*, except this variant puts quotes around each argument.
    Useful if the original arguments may have been quoted and could contain spaces
    or other delimiter characters. It’s best to invoke this as $@ as well. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| $@ | 类似于 $*，不过这个变体会将每个参数用引号括起来。如果原始参数可能已经被引用，并且可能包含空格或其他分隔符字符，这种方式特别有用。最好也以
    $@ 的形式调用它。 |'
- en: See the references in section D.8, “For More Information,” on [page 968](appendix-D.xhtml#pg_968)
    for more details on these features.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 有关这些功能的更多详细信息，请参见第 D.8 节“更多信息”中的参考资料，[第968页](appendix-D.xhtml#pg_968)。
- en: D.6.3 Writing Your Own Shell Scripts
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.6.3 编写你自己的 Shell 脚本
- en: 'Consider the following text, from a file named *lsPix*:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下来自名为*lsPix*的文件中的文本：
- en: '[PRE42]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you were to execute this shell script via the following command, bash would
    switch to the *Pictures* subdirectory in the user’s home directory, display the
    directory listing, and the return control to bash:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过以下命令执行这个 shell 脚本，bash 会切换到用户主目录下的*Pictures*子目录，显示目录列表，然后将控制权返回给 bash：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Entering bash in front of a shell script to execute it can become annoying
    if you commonly execute certain shell scripts. Fortunately, Unix (via shells such
    as sh, bash, or zsh) provides a mechanism to specify the shell script directly
    as a command: make the script file executable. You can use the chmod command to
    accomplish this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你常常执行某些 shell 脚本，在脚本前加上 bash 执行它可能会变得令人烦恼。幸运的是，Unix（通过 sh、bash 或 zsh 等 shell）提供了一种机制，可以直接将
    shell 脚本作为命令来执行：使脚本文件可执行。你可以使用 chmod 命令来完成这个操作：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This sets the permissions to RWX (readable, writable, and executable) for the
    owner and R-X (readable and executable) for members of the group and other users.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将所有者的权限设置为 RWX（可读、可写和可执行），将组成员和其他用户的权限设置为 R-X（可读和可执行）。
- en: Note that the *build* script (used throughout this book) has been made executable
    via a chmod 777 build command (this allows everyone to modify the file). That
    is why you need to enter only ./build at the beginning of the command line rather
    than bash build.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*build* 脚本（本书中使用的）已通过 chmod 777 build 命令使其可执行（这允许所有人修改文件）。因此，你只需在命令行开头输入
    ./build，而不是 bash build。
- en: 'When making a bash shell script executable, also add the following statement
    to the beginning of the shell script file:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在使 bash shell 脚本可执行时，还需要在脚本文件的开头添加以下语句：
- en: '[PRE45]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The *shebang* (#!) sequence tells bash that this is a shell script and provides
    the path to the shell interpreter to execute for this command. (The interpreter
    would be bash in this case, but you could specify a different shell interpreter,
    such as /bin/sh, if you really wanted.) If you don’t know the path to the bash
    interpreter, execute the Unix command which bash to print the path you need. The
    inclusion of the shebang on the first line also allows the file lspix command
    to identify the file as a shell script rather than a simple ASCII text file.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*shebang*（#!）序列告诉 bash 这是一个 shell 脚本，并提供要执行此命令的 shell 解释器的路径。（在这种情况下，解释器将是
    bash，但如果你想的话，也可以指定其他的 shell 解释器，如 /bin/sh。）如果你不知道 bash 解释器的路径，可以执行 Unix 命令 which
    bash 来打印所需的路径。在第一行包含 shebang 还允许文件 lspix 命令将文件识别为 shell 脚本，而不是简单的 ASCII 文本文件。'
- en: 'Once you’ve added this line to *lsPix* and made the file executable, you need
    to enter only the following at the command line to execute the script:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你将这一行添加到*lsPix*并使文件可执行，你只需在命令行中输入以下内容来执行脚本：
- en: '[PRE46]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The # character is normally used to create comments in a shell script. With
    the exception of the shebang in the first line, the bash interpreter will ignore
    all the text from a # symbol to the end of the line.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '# 字符通常用于在 shell 脚本中创建注释。除了第一行的 shebang 外，bash 解释器会忽略从 # 符号到行尾的所有文本。'
- en: It’s important to understand that shell scripts execute in their own copy of
    bash. Therefore, any changes they make to the bash environment—such as setting
    the current working directory with the cd command or changing shell variable values—are
    lost when the script terminates. For example, when this *lsPix* script terminates,
    the current working directory will return to its original directory; it will not
    be *$HOME/Pictures* (unless it happened to be *$HOME/Pictures* prior to executing
    *lsPix*).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，shell 脚本在它们自己的 bash 副本中执行。因此，它们对 bash 环境所做的任何更改——例如使用 cd 命令设置当前工作目录或更改
    shell 变量的值——在脚本终止时都会丢失。例如，当 *lsPix* 脚本终止时，当前工作目录将返回到原始目录；它不会是 *$HOME/Pictures*（除非在执行
    *lsPix* 之前它就已经是 *$HOME/Pictures*）。
- en: D.7 The build Script
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.7 构建脚本
- en: Shell scripts are useful for automating manual activities. For example, this
    book uses the *build* script to assemble/compile most of the example programs.
    The following listing presents the *build* script and describes how it works;
    I’ll explain the full script section by section.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 脚本对于自动化手动操作非常有用。例如，本书使用 *build* 脚本来组装/编译大部分示例程序。以下是 *build* 脚本，并将描述其工作原理；我将逐节解释完整的脚本。
- en: 'As with any good shell script, the build script begins with the shebang that
    defines the shell interpreter to use (bash in this case):'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何好的 shell 脚本一样，构建脚本以定义要使用的 shell 解释器（此例中为 bash）的 shebang 开头：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The script also defines several variables (filename, compileOnly, pie, cFile,
    and lib) that it will use to specify GCC command line options when assembling
    and compiling the source files.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本还定义了几个变量（filename、compileOnly、pie、cFile 和 lib），它们将用于在汇编和编译源文件时指定 GCC 命令行选项。
- en: 'The next section of the script processes command line parameters found on the
    build command line:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的下一个部分处理构建命令行中的命令行参数：
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The while loop processes each command line argument individually ❶. The Boolean
    expression $# -gt 0 returns true as long as there are one or more command line
    arguments ($# is the number of arguments).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: while 循环逐个处理每个命令行参数 ❶。布尔表达式 $# -gt 0 会在有一个或多个命令行参数时返回 true（$# 是参数的数量）。
- en: The body of the loop sets the key local variable equal to the value of the first
    command line parameter ($1). It then executes a case statement that compares this
    argument against the options -c, -pie, and -math. If the argument matches one
    of these, the script sets appropriate local variables to values that note the
    presence of these options. If the case expression doesn’t match any of these,
    the default case (*) sets the filename variable to the value of the command line
    argument.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 循环体将关键的局部变量设置为第一个命令行参数（$1）的值。接着它执行一个 case 语句，将该参数与选项 -c、-pie 和 -math 进行比较。如果参数匹配其中之一，脚本会将适当的局部变量设置为表示这些选项存在的值。如果
    case 表达式不匹配任何选项，默认的 case (*) 会将文件名变量设置为命令行参数的值。
- en: At the end of each case, you’ll notice a shift statement ❷. This statement shifts
    all the command line parameters to the left one position (deleting the original
    $1 argument), setting $1 = $2, $2 = $3, ... and decrementing the parameter count
    ($#) by one. This sets up the while loop for the next iteration to process the
    remaining command line parameters.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个 case 语句结束时，你会注意到一个 shift 语句 ❷。这个语句将所有命令行参数向左移一位（删除原来的 $1 参数），将 $1 = $2、$2
    = $3，依此类推，并将参数计数 ($#) 减少 1。这为 while 循环准备了下一次迭代，处理剩下的命令行参数。
- en: 'The next section sets up the objectFile variable that the script expands as
    part of the gcc command line:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分设置了脚本中作为 gcc 命令行的一部分扩展的 objectFile 变量：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This code sets objectFile to a string that will specify an object filename on
    the gcc command line. If -c is not present, this code will set cFile to expand
    to an empty string so that the gcc command does not also compile *c.cpp* (the
    default case).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将 objectFile 设置为一个字符串，该字符串会在 gcc 命令行中指定一个目标文件名。如果没有 -c 选项，该代码会将 cFile 设置为空字符串，这样
    gcc 命令就不会编译 *c.cpp*（默认情况）。
- en: 'The following section of the *build* script deletes any existing object files
    or executable files that this command would create:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 *build* 脚本部分会删除该命令可能创建的任何现有目标文件或可执行文件：
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The test built-in function returns true if the specified file exists. Therefore,
    these if statements will delete the object and executable files if they already
    exist.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: test 内建函数在指定文件存在时返回 true。因此，如果对象文件和可执行文件已经存在，这些 if 语句将删除它们。
- en: 'Next, the *aoaa.inc* header file requires the definition of either the isLinux
    or isMacOS symbols in order to determine the OS. The definition of these symbols
    allows *aoaa.inc* to select OS-specific code so that the example code will compile
    (portably) across the two OSes. Rather than force the user to manually define
    this symbol, the *build* script automatically defines one of these symbols when
    invoking GCC. To accomplish this, *build* uses the uname command, which returns
    the name of the OS kernel:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，*aoaa.inc* 头文件需要定义 isLinux 或 isMacOS 符号，以便确定操作系统。定义这些符号后，*aoaa.inc* 能够选择操作系统特定的代码，从而使示例代码能够在这两个操作系统上（便捷地）编译。为了避免强制用户手动定义该符号，*build*
    脚本在调用 GCC 时会自动定义其中一个符号。为此，*build* 使用 uname 命令，它返回操作系统内核的名称：
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Under Linux, uname returns the string Linux; under macOS, it returns the string
    Darwin.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 下，uname 返回字符串 Linux；在 macOS 下，它返回字符串 Darwin。
- en: 'Finally, the *build* script invokes the GCC compiler with command line arguments
    appropriate to the OS:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*build* 脚本根据操作系统的适当命令行参数调用 GCC 编译器：
- en: '[PRE52]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note the -D name=1 command line option that defines the isLinux or isMacOS symbols
    as appropriate. Also note that the pie (position-independent code) option appears
    only when compiling under Linux, as macOS code is always position-independent.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意命令行选项 -D name=1，它根据需要定义 isLinux 或 isMacOS 符号。还要注意，pie（位置无关代码）选项仅在 Linux 下编译时出现，因为
    macOS 的代码总是位置无关的。
- en: It’s easy to modify the *build* script to add more features, should you desire.
    For example, one limitation to this script is that it allows you to specify only
    a single assembly language source file (if you specify two or more names, it will
    use only the last name you specify). You can change this with three modifications
    to the file, in the case statement.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有需求，修改 *build* 脚本以添加更多功能是非常容易的。例如，脚本的一个限制是它只允许你指定单个汇编语言源文件（如果指定两个或更多名称，它只会使用你指定的最后一个名称）。你可以通过在
    case 语句中的三处修改来改变这一点。
- en: 'The first change is to append the filename and add a .S suffix to the fileName
    variable rather than replacing its value. You must also set the executable output
    filename to the first assembly file specified on the command line:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个修改是将文件名附加并为 fileName 变量添加 .S 后缀，而不是替换其值。你还必须将可执行输出文件名设置为命令行上指定的第一个汇编文件：
- en: '[PRE53]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The next change is to set objectFile to the empty string if specifying compile-only
    mode:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的修改是在指定编译模式时，将 objectFile 设置为空字符串：
- en: '[PRE54]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The original code set this to the specified filename; however, that is the default
    for compile-only mode, and specifying a single object name when assembling multiple
    source files is problematic.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 原始代码将其设置为指定的文件名；然而，这在仅编译模式下是默认设置，而在汇编多个源文件时，指定单个对象名称会存在问题。
- en: 'The final change is to modify the two gcc command lines to remove the .S suffix
    from the assembly filenames (since this was added in the case statement):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的修改是修改两个 gcc 命令行，将汇编文件名中的 .S 后缀去掉（因为这已经在 case 语句中添加了）：
- en: '[PRE55]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: However, if you’re going to do a complex assembly using multiple source files,
    you’re probably better off using makefiles rather than shell scripts to do the
    job.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你打算使用多个源文件进行复杂的汇编，可能还是使用 makefile 比使用 shell 脚本更合适。
- en: D.8 For More Information
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: D.8 更多信息
- en: For details on Unix regular expressions and wildcards, see the Bash Reference
    Manual at *[https://<wbr>www<wbr>.gnu<wbr>.org<wbr>/savannah<wbr>-checkouts<wbr>/gnu<wbr>/bash<wbr>/manual<wbr>/bash<wbr>.html](https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html)*.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 Unix 正则表达式和通配符的详细信息，请参见 Bash 参考手册 *[https://<wbr>www<wbr>.gnu<wbr>.org<wbr>/savannah<wbr>-checkouts<wbr>/gnu<wbr>/bash<wbr>/manual<wbr>/bash<wbr>.html](https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html)*。
- en: For more information on bash shell scripts, check out *The Linux Command Line*,
    2nd edition, by William Shotts (No Starch Press, 2019).
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 bash shell 脚本的更多信息，请查阅 William Shotts 编写的 *The Linux Command Line*，第二版（No
    Starch Press，2019年）。
- en: For an explanation of the risks of including ./ in your execution path, see
    the Unix & Linux Stack Exchange question at *[https://<wbr>unix<wbr>.stackexchange<wbr>.com<wbr>/questions<wbr>/65700<wbr>/is<wbr>-it<wbr>-safe<wbr>-to<wbr>-add<wbr>-to<wbr>-my<wbr>-path<wbr>-how<wbr>-come](https://unix.stackexchange.com/questions/65700/is-it-safe-to-add-to-my-path-how-come)*.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于在执行路径中包含 ./ 的风险，请参见 Unix & Linux Stack Exchange 上的问题 *[https://<wbr>unix<wbr>.stackexchange<wbr>.com<wbr>/questions<wbr>/65700<wbr>/is<wbr>-it<wbr>-safe<wbr>-to<wbr>-add<wbr>-to<wbr>-my<wbr>-path<wbr>-how<wbr>-come](https://unix.stackexchange.com/questions/65700/is-it-safe-to-add-to-my-path-how-come)*。
- en: A complete list of bash shell script variables appears at the Advanced Bash
    Scripting Guide site, *[https://<wbr>tldp<wbr>.org<wbr>/LDP<wbr>/abs<wbr>/html<wbr>/internalvariables<wbr>.html](https://tldp.org/LDP/abs/html/internalvariables.html)*.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: bash shell 脚本变量的完整列表可见于《高级 Bash 脚本编程指南》网站，*[https://tldp.org/LDP/abs/html/internalvariables.html](https://tldp.org/LDP/abs/html/internalvariables.html)*。
- en: For details on changing the command line prompt, see the phoenixNap site at
    *[https://<wbr>phoenixnap<wbr>.com<wbr>/kb<wbr>/change<wbr>-bash<wbr>-prompt<wbr>-linux](https://phoenixnap.com/kb/change-bash-prompt-linux)*.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关更改命令行提示符的详细信息，请参阅 phoenixNap 网站，*[https://phoenixnap.com/kb/change-bash-prompt-linux](https://phoenixnap.com/kb/change-bash-prompt-linux)*。
- en: 'Here are some websites that describe how to write bash scripts:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些描述如何编写 bash 脚本的网站：
- en: 'freeCodeCamp: *[https://<wbr>www<wbr>.freecodecamp<wbr>.org<wbr>/news<wbr>/shell<wbr>-scripting<wbr>-crash<wbr>-course<wbr>-how<wbr>-to<wbr>-write<wbr>-bash<wbr>-scripts<wbr>-in<wbr>-linux](https://www.freecodecamp.org/news/shell-scripting-crash-course-how-to-write-bash-scripts-in-linux)*'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'freeCodeCamp: *[https://www.freecodecamp.org/news/shell-scripting-crash-course-how-to-write-bash-scripts-in-linux](https://www.freecodecamp.org/news/shell-scripting-crash-course-how-to-write-bash-scripts-in-linux)*'
- en: 'Ryan’s Tutorials: *[https://<wbr>ryanstutorials<wbr>.net<wbr>/bash<wbr>-scripting<wbr>-tutorial<wbr>/bash<wbr>-script<wbr>.php](https://ryanstutorials.net/bash-scripting-tutorial/bash-script.php)*'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Ryan’s Tutorials: *[https://ryanstutorials.net/bash-scripting-tutorial/bash-script.php](https://ryanstutorials.net/bash-scripting-tutorial/bash-script.php)*'
- en: 'Linux Hint: *[https://<wbr>linuxhint<wbr>.com](https://linuxhint.com)*'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Linux Hint: *[https://linuxhint.com](https://linuxhint.com)*'
- en: 'Bash scripting cheat sheet: *[https://<wbr>devhints<wbr>.io<wbr>/bash](https://devhints.io/bash)*'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Bash 脚本备忘单: *[https://devhints.io/bash](https://devhints.io/bash)*'
