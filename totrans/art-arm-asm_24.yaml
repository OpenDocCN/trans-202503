- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: D THE BASH SHELL INTERPRETER
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The *Bourne-again shell*, otherwise known as the *Bourne shell* or *bash*, is
    a Unix shell interpreter. Bash is an upgraded version of the venerable Unix sh
    (shell) program, the default shell program in Unix System 7.
  prefs: []
  type: TYPE_NORMAL
- en: Bash is the typical shell used in Linux systems (though other shells are available,
    such as zsh and csh). Most Linux and macOS shell programs are roughly compatible
    with one another for simple command line activities, but they differ in their
    support for sophisticated shell programming purposes.
  prefs: []
  type: TYPE_NORMAL
- en: All the programming examples throughout this text run GCC and the Gas assembler
    via shell commands given by a bash command line. Therefore, you should have at
    least a small amount of bash knowledge in order to understand the basic commands
    in this book. This appendix gives instructions for using bash, including descriptions
    of its more common commands, but this discussion largely applies to other shell
    interpreters as well.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid having to refer to specific OS or distribution names, I’ll use the
    name *Unix* in this appendix to refer to the underlying system (at the time of
    this writing, Unix is a registered trademark of The Open Group).
  prefs: []
  type: TYPE_NORMAL
- en: D.1 Running Bash
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The bash shell interpreter is an application similar to other Unix applications.
    To use it, you must first execute the bash application. On text-based Unix systems,
    some sort of shell application will run after you log in to the system. You can
    set up your system to automatically run bash (or any other shell program).
  prefs: []
  type: TYPE_NORMAL
- en: 'On GUI-based Linux systems or on macOS systems, you usually have to run a terminal
    program to start a shell interpreter. In either case, you’ll typically be presented
    with a *command prompt* when the shell application runs. This should be $ or #,
    depending on whether you’re logged in as a normal user or root, respectively;
    some shells display a % prompt. After printing the command prompt, the shell will
    wait for you to type a command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you’re running a shell interpreter, though it might not be bash;
    it could be the standard sh shell or another shell (for example, the macOS *terminal*
    application runs zsh). Though most shells will behave approximately the same,
    to ensure you’re running bash, type the following line (followed by ENTER) after
    the command prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure that you’re running the bash application so that all the comments
    in this appendix will apply. You can terminate this instance of bash and return
    to the original shell by executing the exit command from the command line.
  prefs: []
  type: TYPE_NORMAL
- en: D.2 Command Lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous example (bash) is an instance of a command given to a shell interpreter.
    *Commands* consist of a line of text entered after a command prompt (typically
    via the keyboard) and take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This whole line of code is known as a *command line*, which consists of three
    components: a command (usually a single word, such as bash in the previous example),
    followed by optional command line arguments, and, finally, optional redirection
    or piping operands.'
  prefs: []
  type: TYPE_NORMAL
- en: The command is the name of a built-in bash command or the name of an executable
    application (or shell script). For example, the command could be the name of an
    assembled assembly language source file you’ve just created.
  prefs: []
  type: TYPE_NORMAL
- en: '### D.2.1 Command Line Arguments'
  prefs: []
  type: TYPE_NORMAL
- en: '*Command line arguments* are strings of characters separated by spaces or tabs
    that bash will pass along to the application. The exact syntax of these command
    line arguments is application dependent. Some simple applications (including the
    assembly language examples in this book) may completely ignore any command line
    arguments; others may require very specific arguments and report an error if they
    are not syntactically correct.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some applications define two types of command line arguments: options and arguments.
    Historically, command line *options* consist of a dash (-) prefix followed by
    a single character, or a double dash (--) prefix followed by a sequence of characters.
    For example, the bash command supports the option'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: which displays help information and then terminates without running the bash
    interpreter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, an actual command line *argument* is typically a filename or other
    word (or string) that the application will use as an input value. Consider the
    following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, bash will start a second instance of itself and read a set
    of commands (one per line of text) from the *script* file and execute those commands
    as though they had been typed from the keyboard. The *build* script file that
    appeared on [page 38](chapter1.xhtml#pg_38) is a good example of a shell script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because bash uses spaces or tabs to separate command line arguments, problems
    arise if you want to specify a single argument that contains such *delimiters*,
    characters that separate items on the command line. Fortunately, bash provides
    a syntax that allows you to include such delimiters on the command line: if you
    surround a command line argument with quotation marks, bash will pass everything
    within the quotes to the application as a single command line argument.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if a command requires a filename and the filename you wish to
    use contains spaces, you can pass that filename to the command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Bash will not include the quotes as part of the argument it passes to the command.
    If you need to pass a quote character as part of a command line argument, precede
    the quote with a backslash character (\). For example, consider the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This passes argument containing "quotes" as a single argument to command.
  prefs: []
  type: TYPE_NORMAL
- en: As you will see later in this appendix, you can also surround a command line
    argument with single quotes (apostrophe characters). The difference has to do
    with variable expansion.
  prefs: []
  type: TYPE_NORMAL
- en: D.2.2 Redirection and Piping Arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bash programs (and Unix-like OSes in general) provide a standard input device,
    a standard output device, and a standard error device.
  prefs: []
  type: TYPE_NORMAL
- en: The *standard input device* is usually the console keyboard. If a program reads
    data from the standard input device, the program will halt until the user types
    a line of text from the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: The *standard output device* is the console display. If an application writes
    data to the standard output device, the system will display it on the display
    screen. The standard error device also defaults to the console display, so data
    written to the standard error device is also written to the display.
  prefs: []
  type: TYPE_NORMAL
- en: The bash shell provides the ability to *redirect* input and output by using
    special arguments on the command line. I/O redirection typically allows you to
    specify a filename. When redirecting the standard input device, the application
    will read lines of text from a file (rather than from the keyboard). When redirecting
    the standard output, the application will write data to a text file rather than
    to the console display.
  prefs: []
  type: TYPE_NORMAL
- en: To redirect the standard input from a file, use a command line argument of the
    form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: where InputFile is the name of a file containing text to be read by the application.
    Whenever the application command would normally read a line of text from the keyboard,
    it will instead read that line of text from the specified file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To redirect the standard output to a file, use the following command line syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Any output normally written to the standard output device (the display) will
    be written to the specified file (OutputFile). This syntax will delete the contents
    of any existing file named *OutputFile* and replace its contents with the output
    of the command application.
  prefs: []
  type: TYPE_NORMAL
- en: 'A variation of output redirection will append a program’s output to the end
    of an existing file rather than replacing its contents. To use output redirection
    this way, use this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that redirecting the standard output device does not change the standard
    error output device. If you’ve redirected the standard output to a file and an
    application writes data to the standard error device, that output still appears
    on the console display. You can redirect the standard error device by using the
    following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The 2> tells bash to redirect the output sent to file handle 2\. Under Unix-style
    systems, handle 0 is reserved for the standard input, handle 1 is reserved for
    the standard output, and handle 2 is reserved for the standard error output device.
    Sticking the handle number in front of the > specifies which output to redirect.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you like, you can also redirect the standard output by using this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The final form of I/O redirection is the *pipe*, which connects the standard
    output from one application to the standard input of a second application. This
    allows the second application to read, as input, the output from the first application.
    Here’s the syntax for a pipe redirection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This tells bash to redirect the output from command1 as the input to command2.
  prefs: []
  type: TYPE_NORMAL
- en: D.3 Directories, Pathnames, and Filenames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you run bash, it will default to a current directory in the OS’s file structure.
    Unix calls this the *current working directory*. Whenever you run bash (for example,
    when you first log in), the current working directory is typically your home directory
    (as determined by the OS). For example, on my Debian system, this is */home/rhyde*
    (under macOS, it’s */Users/rhyde*).
  prefs: []
  type: TYPE_NORMAL
- en: When you specify a filename on the command line that does not contain any slash
    characters, bash or the application will assume that file exists in the executable
    path supplied to the system. A *pathname* consists of a sequence of one or more
    directory names, separated by slashes, ending with a filename. A relative pathname
    begins with a directory name; the system looks for that directory within the current
    working directory. For example, *dir1/dir2/filename* specifies a file (*filename*)
    appearing in *dir1* in the current working directory and within *dir2*, which
    is itself within *dir1*. An *absolute pathname* begins with a slash followed by
    the outermost root directory. For example, */home/rhyde/x.txt* specifies the file
    *x.txt* appearing in the */home/rhyde* directory (my home directory under Debian).
  prefs: []
  type: TYPE_NORMAL
- en: The tilde special character (~) is shorthand for the current user’s home directory.
    Therefore, *~/x.txt* is another way for me to specify */home/rhyde/x.txt* on my
    Debian system. This scheme also works in macOS, so it’s a useful way to specify
    user directory paths in a system-independent fashion.
  prefs: []
  type: TYPE_NORMAL
- en: The special character period (.), by itself, is shorthand for the current working
    directory. The double-period sequence (..) is shorthand for the directory that
    contains the current working directory (the parent directory). For example, *../x.txt*
    refers to the file named *x.txt* in the parent directory. On Linux-based systems,
    to execute an application from the current working directory, you must specify
    *./filename* rather than just *filename* (unless you’ve placed *./* in your execution
    path).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some Unix commands allow you to specify multiple filenames on the command line.
    Such commands often allow the use of wildcard characters to specify multiple names.
    Unix supports a rich set of regular expressions when specifying wildcards, one
    of which you’ll commonly use: the asterisk (*). Bash will match any number of
    characters (zero or more) in place of the asterisk. Therefore, the filename **.txt*
    will match any file ending with the four-character sequence *.txt* (this includes
    *.txt* by itself).'
  prefs: []
  type: TYPE_NORMAL
- en: D.4 Built-in and External Bash Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Bash supports two types of commands: built-in and external. *Built-in commands*
    exist as part of the bash application itself; a function inside the bash source
    code handles the given built-in command. *External commands* correspond to executable
    programs separate from bash that bash will load and execute (then take control
    back from those programs when they terminate). Built-in commands are always available
    when you run bash, but external commands may or may not be available, depending
    on the presence of the executable code for those commands. You can assume that
    the commands appearing in the following subsections are all external, unless otherwise
    noted.'
  prefs: []
  type: TYPE_NORMAL
- en: The assembly language example programs in this book are examples of external
    commands. When you enter something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: at the command line, bash will locate the *Listing1-5* executable in the current
    working directory (./) and attempt to execute that code.
  prefs: []
  type: TYPE_NORMAL
- en: For security reasons, bash will not automatically execute a program in the current
    working directory unless you explicitly prepend the characters ./ to the executable’s
    name. Bash assumes that program names without explicit path information can be
    found in the *execution path*. The execution path (see section D.6.1, “Defining
    Shell Script Variables and Values,” on [page 961](appendix-D.xhtml#pg_961)) is
    a list of directories where bash will search for an executable program you specify
    without explicit path information. Usually, bash will look in places such as */bin*,
    */usr/bin*, and */sbin* for executable programs.
  prefs: []
  type: TYPE_NORMAL
- en: To enable bash to execute programs from your current working directory without
    having to prefix the executable filename with the ./ characters, you can add ./
    to your execution path. However, there are some very good security reasons for
    not doing this. For more on this, see section D.8, “For More Information,” on
    [page 968](appendix-D.xhtml#pg_968).
  prefs: []
  type: TYPE_NORMAL
- en: '## D.5 Basic Unix Commands'
  prefs: []
  type: TYPE_NORMAL
- en: It would be impossible to describe all Unix commands in this appendix. That
    would take a large book by itself. This section describes several commands useful
    to those developing assembly language programs, along with some of their options
    and parameters. For information on additional bash commands, check out section
    D.8, “For More Information,” on [page 968](appendix-D.xhtml#pg_968).
  prefs: []
  type: TYPE_NORMAL
- en: D.5.1 man
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you know the name of the command but are unsure about the syntax for its
    command line parameters and options, you can use the man command to learn about
    it. This command brings up the manual page for a (supported) command, with the
    syntax
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'where CommandName is the name of the command whose manual page you would like
    to read. For example, the following brings up the manual page for the man command
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can use man, with the command names listed in the following subsections,
    to learn additional information about each.
  prefs: []
  type: TYPE_NORMAL
- en: D.5.2 cd or chdir
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can set the current working directory by using the cd (change directory)
    command (chdir is an alias of this command). The standard syntax is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: where DirectoryPath is a relative or absolute path to a directory in the filesystem.
    Unix will report an error if the directory does not exist or if this is the name
    of a file rather than a directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you specify the cd command without any arguments, it will switch to the
    current user’s home directory. This is equivalent to entering the following on
    the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The cd and chdir commands are built into bash.
  prefs: []
  type: TYPE_NORMAL
- en: D.5.3 pwd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pwd (print working directory) command prints the path to the current working
    directory. Bash is generally set up to print the current working directory as
    part of the command line prompt; if this is the case for your system, you probably
    won’t need to use pwd. This is also an internal bash command.
  prefs: []
  type: TYPE_NORMAL
- en: D.5.4 ls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ls (list directory) command prints a directory listing to the standard output.
    When used with no options, it displays the contents of the current directory.
  prefs: []
  type: TYPE_NORMAL
- en: When printing the directory listing to the display, ls defaults to a multicolumn
    format. If you direct the output to a file, by redirecting the standard output
    or by using a pipe, the command prints the listing in a single-column format.
  prefs: []
  type: TYPE_NORMAL
- en: If you supply a directory path as an argument, the ls command will display the
    contents of the specified directory (assuming it exists). If you specify a pathname
    to a file as an argument, the ls command will display only that filename (again,
    assuming that file exists in the specified path).
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the ls command will not display filenames that begin with a period.
    Unix treats such files as *hidden*. If you want to display such filenames, use
    the -a command line option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the ls command lists only the filenames and directory names in
    the specified directory. If you specify the -l (long) option, the ls command will
    display additional information about each file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The first column in the listing specifies the file permissions. The next three
    provide a link count and ownership information, followed by file size and modification
    date and time, followed by the filename.
  prefs: []
  type: TYPE_NORMAL
- en: D.5.5 file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unlike macOS and Windows, Unix does not associate a specific data type with
    a file. You can use the Unix file command to determine a file type for a particular
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The file command will respond with its best guess as to the type of the file
    specified by pathname.
  prefs: []
  type: TYPE_NORMAL
- en: D.5.6 cat, less, more, and tail
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To view the contents of a text file, you can display that file in its entirety
    using the cat (catenate) command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: where pathname is the path to the name of the file you wish to display.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with cat is that it tries to write the entire file to the display,
    all at once. Many files are larger than can be displayed on the screen at one
    time, so cat ends up displaying only the last few lines of the file; moreover,
    very large files may take a while to display their contents. If you would like
    to be able to page through a file one screenful at a time, you can use the more
    and less commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The more command is now obsolete but is still available to handle older script
    files that contain it. It displays a pageful of text and allows you to scroll
    through the file a line at a time (by pressing ENTER) or a page at a time (by
    pressing the spacebar). The big drawback to more is that you can view only forward
    in a file; after information scrolls off the screen, it is lost.
  prefs: []
  type: TYPE_NORMAL
- en: The less command (whose name comes from the phrase *less is more*) is an upgraded
    version of more that allows you to scroll forward and backward in a page. Most
    people use the less command rather than more because of the additional features
    (such as being able to use the arrow keys to consistently scroll up and down a
    line at a time).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to view only the last few lines of a large file, use the tail command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: By default, tail prints the last 10 lines of the file. You can use the -n xxxx
    command line option, where xxxx is a decimal numeric value, to specify a different
    line count. For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: displays the last 20 lines of the file *x.txt.*
  prefs: []
  type: TYPE_NORMAL
- en: D.5.7 mv
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The mv (move) command has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: SourcePath is the pathname of the file you want to move or rename, and DestinationPath
    is the final destination path where you want the file moved (or the new name you
    want to use for the file).
  prefs: []
  type: TYPE_NORMAL
- en: To rename a file in the current directory, mv takes the form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: where OldName is the existing filename you want to change and NewName is the
    new filename you want to rename the file. These are both simple filenames (no
    directory path components). Note that NewName must be different from OldName.
  prefs: []
  type: TYPE_NORMAL
- en: To move a file from one directory to another, either the SourcePath or DestinationPath
    (or both) must contain a directory component. The SourcePath must contain a filename
    component at the end of the pathname (the name of the file to move). For the DestinationPath,
    a filename at the end is optional. If the DestinationPath is the name of a directory
    (rather than a file), mv will move the source file into the destination directory
    and use the same filename as the original source file. If there is a filename
    at the end of DestinationPath, then mv will change the filename while it is moving
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use wildcard characters with mv, subject to the following restrictions:
    wildcard characters may appear only in the source pathname, and the destination
    path must be a directory, not an actual filename.'
  prefs: []
  type: TYPE_NORMAL
- en: D.5.8 cp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The cp command has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This command will make a copy of the file specified by SourcePath, using the
    name DestinationPath for the copy. If both pathnames are simple filenames (that
    is, you’re making a copy of a file in the current directory), the two filenames
    must be different.
  prefs: []
  type: TYPE_NORMAL
- en: The cp command accepts wildcard characters in the source operand. If wildcard
    characters are present, the destination must be a directory path. The cp command
    will copy all files matching the wildcard designation to the specified directory.
  prefs: []
  type: TYPE_NORMAL
- en: If both source and destination operands specify a directory, use the -R (recursive)
    command line option. This will copy all the files from the source directory to
    a directory by the same name in the destination directory (creating the new directory
    in the destination if it is not already present); it will also recursively copy
    any subdirectories in the source directory into similarly named subdirectories
    in the destination.
  prefs: []
  type: TYPE_NORMAL
- en: D.5.9 rm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The rm command removes (deletes) a file from a directory, using the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The pathname argument must be a path to an individual file, not a directory.
    To delete a directory and all the files in it, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This will recursively delete all files and subdirectories in DirectoryPath,
    then delete the directory specified by DirectoryPath.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete all the files in a directory without removing the directory itself,
    use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Be very careful when using wildcard characters in an rm command. Depending
    on the current working directory, the following command could delete everything
    on your storage devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: There is also an rmdir command you can use to remove empty directories. However,
    the rm -R directory command is easier to use for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: D.5.10 mkdir
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The mkdir command creates a new (empty) directory, using the syntax
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: where DirectoryPath specifies the pathname to a directory that does not already
    exist. If DirectoryPath is an actual pathname, all subdirectory names up to the
    final name in the path must exist; the final directory name (after the last /)
    must not exist. If you specify a simple directory name (no path), bash will create
    the directory in the current working directory.
  prefs: []
  type: TYPE_NORMAL
- en: The mkdir command supports a -p command line option that will create all nonexistent
    directories in the path.
  prefs: []
  type: TYPE_NORMAL
- en: D.5.11 date
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The date command displays the current date and time. You can also use this command
    to set the Unix real-time clock. Run man date for the details.
  prefs: []
  type: TYPE_NORMAL
- en: D.5.12 echo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The echo command prints the text on the remainder of the command line (subject
    to some expansions by bash) to the standard output device. For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: will write hello, world! to the standard output. You’ll use this command most
    often in scripts or to display the value of various shell variables.
  prefs: []
  type: TYPE_NORMAL
- en: D.5.13 chmod
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although Unix files do not have a specific type, the directory does maintain
    whether a file is readable, writable, or executable by the owner of the file,
    a group associated with the file, or anyone (standard Unix permissions). The chmod
    command allows you to set (or clear) permission mode bits for a particular file.
  prefs: []
  type: TYPE_NORMAL
- en: The basic syntax for chmod is
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: where pathname is the path to the file whose mode you want to change, and the
    options parameter(s) specifies the new permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The options argument is either an octal (base-8) number (typically three digits)
    or a special string to set the permissions. Unix has three permission categories:
    owner/user, group, and other. The *owner* category applies to the user who created
    the file in the first place. The *group* category covers any groups that the user
    belongs to (and other users may belong to). The *other* category covers everyone
    else.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the three categories, Unix has three main types of permissions:
    permission to *read* a file, permission to *write* data to a file (or delete it),
    and permission to *execute* a file (this generally applies to object code or shell
    scripts).'
  prefs: []
  type: TYPE_NORMAL
- en: A typical chmod option consists of a string of one to three characters from
    the set {ugo} followed by a plus or minus character (+ or -, not ±), followed
    by a single character from the set {rwx}. For example, u+r enables user read access,
    u+x enables execution permission, and ugo-x removes execution privileges for all
    categories. Note that the ls -l command will list the user, group, and other permissions
    for a given file.
  prefs: []
  type: TYPE_NORMAL
- en: You can also specify the permissions for the three categories as a three-digit
    octal number, where each digit represents the three rwx bits for users (HO digit),
    groups (middle digit), and other (LO digit). For example, 755 specifies read/write/execute
    permissions for the user (111[2] = 7[8]), read and execute permissions for the
    group, and other (101[2] = 5[8]). Note that 755 is a typical set of permissions
    you would assign to a publicly usable script file.
  prefs: []
  type: TYPE_NORMAL
- en: D.6 Shell Scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *shell script* is a text file that bash will interpret as a sequence of commands
    to execute, exactly as though each line in the text file were entered from the
    keyboard while running bash. For those with Microsoft Windows experience, this
    is similar to a batch file. This section discusses using shell variables and values,
    using special built-in shell variables, and creating your own bash shell scripts.
  prefs: []
  type: TYPE_NORMAL
- en: The bash interpreter is a full-fledged programming language that supports conditional
    and looping constructs as well as the sequential execution of commands on the
    command line. It supports if...elif...else statements, a case statement (similar
    to C’s switch statement), and various loops (while, for, and so on). It also supports
    functions, local variables, and other features typically found in HLLs. Going
    into detail on these topics is beyond the scope of this book. See Ryan’s Tutorials
    in section D.8, “For More Information,” on [page 968](appendix-D.xhtml#pg_968)
    for details beyond what this section covers.
  prefs: []
  type: TYPE_NORMAL
- en: '### D.6.1 Defining Shell Script Variables and Values'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bash allows you to define shell variables. A *shell variable* is a name (think:
    programming language identifier) to which you can assign some text. For example,
    the following bash command assigns the text ls to list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can tell bash to expand a shell variable name to its associated text by
    prefixing the name with a $ character. For example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: expands to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: which will display the current directory listing.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, you would not use shell variables to create aliases of existing commands,
    as the alias command is better suited to the job. Instead, you would use shell
    variables to keep track of paths, options, and other information commonly used
    on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bash supplies several predefined shell variables, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: $HOME    Contains the path to the current user’s home directory
  prefs: []
  type: TYPE_NORMAL
- en: $HOSTNAME    Contains the machine’s name
  prefs: []
  type: TYPE_NORMAL
- en: $PATH    Contains a list of directory paths, separated by colons (:), that bash
    will search through when searching for an external command’s executable file
  prefs: []
  type: TYPE_NORMAL
- en: $PS1    Contains a string that bash will print as the command line prompt
  prefs: []
  type: TYPE_NORMAL
- en: $PWD    Contains the current working directory
  prefs: []
  type: TYPE_NORMAL
- en: For a complete list of predefined shell variables, and for more details on the
    $PS1 variable in particular, see section D.8, “For More Information,” on [page
    968](appendix-D.xhtml#pg_968).
  prefs: []
  type: TYPE_NORMAL
- en: 'Shell variables to which you assign values will retain those values during
    the execution of the current bash shell. Often, when executing shell scripts,
    a second bash shell begins execution, and any variable values created or modified
    in that execution will be lost when that shell terminates. To avoid this problem,
    use the built-in export command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This command will make the variable assignment visible to parent shells. Typically,
    you must use export when assigning values in a shell script that you want to retain
    after the shell script completes.
  prefs: []
  type: TYPE_NORMAL
- en: You can define shell variables in a script file, just as you can when interactively
    typing commands at the command line. As noted earlier, however, any variable values
    defined in a shell script are lost when the shell terminates. This is because
    bash will make a copy of the execution environment (including all the shell variable
    values) when it starts a shell script. Any changes or additions you make, such
    as creating new variables or modifying existing ones, affect only the copy of
    the environment. When the shell script terminates, it deletes the copy of the
    environment and reverts to the original environment. The export command tells
    bash to export the variable assignment to the parent environment (as well as applying
    to the current local environment).
  prefs: []
  type: TYPE_NORMAL
- en: 'Values assigned to a shell variable are generally treated as text. Because
    the bash interpreter breaks up command lines by using spaces or other delimiters,
    the string of text you assign to a script variable must consist of a single *word*
    (that is, a sequence of characters surrounded by delimiters). If you want to include
    delimiter (and other) characters within the value, you must surround the text
    value with quotes or apostrophes, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Bash will expand the text inside double quotes (") and will maintain the text
    as is inside single quotes (''). Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Executing this sequence will produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Bash expands $aVariable inside the string enclosed in double quotes but will
    not expand it inside the string enclosed in single quotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might see strings surrounded by grave accent characters (`), commonly called
    *backticks* in Unix. Originally, such strings surrounded a command that the shell
    would execute, then substitute the textual output of the program in place of the
    backticked string. This syntax has been deprecated in modern shells. To capture
    the output of a command and assign it to a variable, use $(command), as in the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a string consisting of the listing of the current working directory
    and assigns that string to the dirListing variable.  ### D.6.2 Defining Special
    Shell Variables'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the shell variables a script inherits from the parent environment,
    bash also defines certain shell variables that might prove useful in shell scripts
    you write. These special variables begin with $ and typically deal with command
    line parameters passed to the script (see [Table D-1](#tabD-1)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table D-1: Special Shell Variables'
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| $0 | Expands to the pathname of the shell script file. |'
  prefs: []
  type: TYPE_TB
- en: '| $1 through $n | Expands to the first, second, ..., nth command line argument.
    |'
  prefs: []
  type: TYPE_TB
- en: '| $# | Expands to a decimal number specifying the parameter count. |'
  prefs: []
  type: TYPE_TB
- en: '| $* | Expands to a string containing all the command line parameters. Generally
    used to pass the parameters on to another command. To assign this command line
    parameter-list string to a shell variable, use $* to capture the text as a single
    string. |'
  prefs: []
  type: TYPE_TB
- en: '| $@ | Similar to $*, except this variant puts quotes around each argument.
    Useful if the original arguments may have been quoted and could contain spaces
    or other delimiter characters. It’s best to invoke this as $@ as well. |'
  prefs: []
  type: TYPE_TB
- en: See the references in section D.8, “For More Information,” on [page 968](appendix-D.xhtml#pg_968)
    for more details on these features.
  prefs: []
  type: TYPE_NORMAL
- en: D.6.3 Writing Your Own Shell Scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider the following text, from a file named *lsPix*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to execute this shell script via the following command, bash would
    switch to the *Pictures* subdirectory in the user’s home directory, display the
    directory listing, and the return control to bash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Entering bash in front of a shell script to execute it can become annoying
    if you commonly execute certain shell scripts. Fortunately, Unix (via shells such
    as sh, bash, or zsh) provides a mechanism to specify the shell script directly
    as a command: make the script file executable. You can use the chmod command to
    accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This sets the permissions to RWX (readable, writable, and executable) for the
    owner and R-X (readable and executable) for members of the group and other users.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the *build* script (used throughout this book) has been made executable
    via a chmod 777 build command (this allows everyone to modify the file). That
    is why you need to enter only ./build at the beginning of the command line rather
    than bash build.
  prefs: []
  type: TYPE_NORMAL
- en: 'When making a bash shell script executable, also add the following statement
    to the beginning of the shell script file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The *shebang* (#!) sequence tells bash that this is a shell script and provides
    the path to the shell interpreter to execute for this command. (The interpreter
    would be bash in this case, but you could specify a different shell interpreter,
    such as /bin/sh, if you really wanted.) If you don’t know the path to the bash
    interpreter, execute the Unix command which bash to print the path you need. The
    inclusion of the shebang on the first line also allows the file lspix command
    to identify the file as a shell script rather than a simple ASCII text file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve added this line to *lsPix* and made the file executable, you need
    to enter only the following at the command line to execute the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The # character is normally used to create comments in a shell script. With
    the exception of the shebang in the first line, the bash interpreter will ignore
    all the text from a # symbol to the end of the line.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to understand that shell scripts execute in their own copy of
    bash. Therefore, any changes they make to the bash environment—such as setting
    the current working directory with the cd command or changing shell variable values—are
    lost when the script terminates. For example, when this *lsPix* script terminates,
    the current working directory will return to its original directory; it will not
    be *$HOME/Pictures* (unless it happened to be *$HOME/Pictures* prior to executing
    *lsPix*).
  prefs: []
  type: TYPE_NORMAL
- en: D.7 The build Script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shell scripts are useful for automating manual activities. For example, this
    book uses the *build* script to assemble/compile most of the example programs.
    The following listing presents the *build* script and describes how it works;
    I’ll explain the full script section by section.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with any good shell script, the build script begins with the shebang that
    defines the shell interpreter to use (bash in this case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The script also defines several variables (filename, compileOnly, pie, cFile,
    and lib) that it will use to specify GCC command line options when assembling
    and compiling the source files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section of the script processes command line parameters found on the
    build command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The while loop processes each command line argument individually ❶. The Boolean
    expression $# -gt 0 returns true as long as there are one or more command line
    arguments ($# is the number of arguments).
  prefs: []
  type: TYPE_NORMAL
- en: The body of the loop sets the key local variable equal to the value of the first
    command line parameter ($1). It then executes a case statement that compares this
    argument against the options -c, -pie, and -math. If the argument matches one
    of these, the script sets appropriate local variables to values that note the
    presence of these options. If the case expression doesn’t match any of these,
    the default case (*) sets the filename variable to the value of the command line
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of each case, you’ll notice a shift statement ❷. This statement shifts
    all the command line parameters to the left one position (deleting the original
    $1 argument), setting $1 = $2, $2 = $3, ... and decrementing the parameter count
    ($#) by one. This sets up the while loop for the next iteration to process the
    remaining command line parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next section sets up the objectFile variable that the script expands as
    part of the gcc command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This code sets objectFile to a string that will specify an object filename on
    the gcc command line. If -c is not present, this code will set cFile to expand
    to an empty string so that the gcc command does not also compile *c.cpp* (the
    default case).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following section of the *build* script deletes any existing object files
    or executable files that this command would create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The test built-in function returns true if the specified file exists. Therefore,
    these if statements will delete the object and executable files if they already
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the *aoaa.inc* header file requires the definition of either the isLinux
    or isMacOS symbols in order to determine the OS. The definition of these symbols
    allows *aoaa.inc* to select OS-specific code so that the example code will compile
    (portably) across the two OSes. Rather than force the user to manually define
    this symbol, the *build* script automatically defines one of these symbols when
    invoking GCC. To accomplish this, *build* uses the uname command, which returns
    the name of the OS kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Under Linux, uname returns the string Linux; under macOS, it returns the string
    Darwin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the *build* script invokes the GCC compiler with command line arguments
    appropriate to the OS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note the -D name=1 command line option that defines the isLinux or isMacOS symbols
    as appropriate. Also note that the pie (position-independent code) option appears
    only when compiling under Linux, as macOS code is always position-independent.
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy to modify the *build* script to add more features, should you desire.
    For example, one limitation to this script is that it allows you to specify only
    a single assembly language source file (if you specify two or more names, it will
    use only the last name you specify). You can change this with three modifications
    to the file, in the case statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first change is to append the filename and add a .S suffix to the fileName
    variable rather than replacing its value. You must also set the executable output
    filename to the first assembly file specified on the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The next change is to set objectFile to the empty string if specifying compile-only
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The original code set this to the specified filename; however, that is the default
    for compile-only mode, and specifying a single object name when assembling multiple
    source files is problematic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final change is to modify the two gcc command lines to remove the .S suffix
    from the assembly filenames (since this was added in the case statement):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: However, if you’re going to do a complex assembly using multiple source files,
    you’re probably better off using makefiles rather than shell scripts to do the
    job.
  prefs: []
  type: TYPE_NORMAL
- en: D.8 For More Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For details on Unix regular expressions and wildcards, see the Bash Reference
    Manual at *[https://<wbr>www<wbr>.gnu<wbr>.org<wbr>/savannah<wbr>-checkouts<wbr>/gnu<wbr>/bash<wbr>/manual<wbr>/bash<wbr>.html](https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information on bash shell scripts, check out *The Linux Command Line*,
    2nd edition, by William Shotts (No Starch Press, 2019).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For an explanation of the risks of including ./ in your execution path, see
    the Unix & Linux Stack Exchange question at *[https://<wbr>unix<wbr>.stackexchange<wbr>.com<wbr>/questions<wbr>/65700<wbr>/is<wbr>-it<wbr>-safe<wbr>-to<wbr>-add<wbr>-to<wbr>-my<wbr>-path<wbr>-how<wbr>-come](https://unix.stackexchange.com/questions/65700/is-it-safe-to-add-to-my-path-how-come)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complete list of bash shell script variables appears at the Advanced Bash
    Scripting Guide site, *[https://<wbr>tldp<wbr>.org<wbr>/LDP<wbr>/abs<wbr>/html<wbr>/internalvariables<wbr>.html](https://tldp.org/LDP/abs/html/internalvariables.html)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For details on changing the command line prompt, see the phoenixNap site at
    *[https://<wbr>phoenixnap<wbr>.com<wbr>/kb<wbr>/change<wbr>-bash<wbr>-prompt<wbr>-linux](https://phoenixnap.com/kb/change-bash-prompt-linux)*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some websites that describe how to write bash scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'freeCodeCamp: *[https://<wbr>www<wbr>.freecodecamp<wbr>.org<wbr>/news<wbr>/shell<wbr>-scripting<wbr>-crash<wbr>-course<wbr>-how<wbr>-to<wbr>-write<wbr>-bash<wbr>-scripts<wbr>-in<wbr>-linux](https://www.freecodecamp.org/news/shell-scripting-crash-course-how-to-write-bash-scripts-in-linux)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ryan’s Tutorials: *[https://<wbr>ryanstutorials<wbr>.net<wbr>/bash<wbr>-scripting<wbr>-tutorial<wbr>/bash<wbr>-script<wbr>.php](https://ryanstutorials.net/bash-scripting-tutorial/bash-script.php)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux Hint: *[https://<wbr>linuxhint<wbr>.com](https://linuxhint.com)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bash scripting cheat sheet: *[https://<wbr>devhints<wbr>.io<wbr>/bash](https://devhints.io/bash)*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
