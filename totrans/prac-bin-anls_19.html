<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="appb"><span epub:type="pagebreak" id="page_392"/><span class="big">B</span><br/>IMPLEMENTING PT_NOTE OVERWRITING USING LIBELF</h2>&#13;
<p class="startpara">In <a href="ch07.xhtml#ch07">Chapter 7</a>, you learned how to inject a code section by overwriting the <span class="literal">PT_NOTE</span> segment at a high level. Here, you’ll see how the <span class="literal">elfinject</span> tool you’ll find on the virtual machine implements this technique. In the process of describing the <span class="literal">elfinject</span> source, you’ll also learn about <span class="literal">libelf</span>, a popular open source library for manipulating the contents of ELF binaries.</p>&#13;
<p class="indent">I’ll focus on the parts of the code that implement the steps from <a href="ch07.xhtml#ch07fig2">Figure 7-2</a> (<a href="ch07.xhtml#page_170">page 170</a>) using <span class="literal">libelf</span>, leaving out some parts of the code that are straightforward and don’t involve <span class="literal">libelf</span>. To learn more, you can find the rest of the <span class="literal">elfinject</span> source on the virtual machine located in the code directory for <a href="ch07.xhtml#ch07">Chapter 7</a>.</p>&#13;
<p class="indent">Be sure to read <a href="ch07.xhtml#ch07_3_2">Section 7.3.2</a> before reading this appendix, as knowing the inputs and outputs that <span class="literal">elfinject</span> expects will make the code easier to follow.</p>&#13;
<p class="indent">In this discussion, I’ll use only the parts of the <span class="literal">libelf</span> API that <span class="literal">elfinject</span> uses to give you a good working understanding of the essentials of <span class="literal">libelf</span>. <span epub:type="pagebreak" id="page_393"/>For more details, refer to the excellent <span class="literal">libelf</span> documentation or to “<span class="literal">libelf</span> by Example” by Joseph Koshy.<sup><a id="appbfn_1a" href="footnote.xhtml#appbfn_1">1</a></sup></p>&#13;
<h3 class="h3" id="appb_1">B.1 Required Headers</h3>&#13;
<p class="noindent">To parse ELF files, <span class="literal">elfinject</span> uses the popular open source library <span class="literal">libelf</span>, which is preinstalled on the virtual machine and is available as a package for most Linux distributions. To use <span class="literal">libelf</span>, you need to include a few header files, as shown in <a href="appb.xhtml#appblist1">Listing B-1</a>. You also need to link against <span class="literal">libelf</span> by providing the <span class="literal">-lelf</span> option to the linker.</p>&#13;
<p class="listing1" id="appblist1"><em>Listing B-1:</em> elfinject.c<em>:</em> <span class="codeitalic">libelf</span> <em>headers</em></p>&#13;
<p class="programs"><span class="ent">➊</span> #include &lt;libelf.h&gt;<br/><span class="ent">➋</span> #include &lt;gelf.h&gt;</p>&#13;
<p class="indent">For brevity, <a href="appb.xhtml#appblist1">Listing B-1</a> doesn’t show all the standard C/C++ headers <span class="literal">elfinject</span> uses, but only two related to <span class="literal">libelf</span>. The main one is <em>libelf.h</em> <span class="ent">➊</span>, which provides access to all of <span class="literal">libelf</span>’s data structures and API functions. The other is <em>gelf.h</em> <span class="ent">➋</span>, which provides access to <span class="literal">GElf</span>, a supporting API that provides easier access to some of <span class="literal">libelf</span>’s functionality. <span class="literal">GElf</span> allows you to access ELF files in a way that’s transparent to the ELF class and bit width (32-bit versus 64-bit) of the file. The benefit of this will become clear as you see more of the <span class="literal">elfinject</span> code.</p>&#13;
<h3 class="h3" id="appb_2">B.2 Data Structures Used in elfinject</h3>&#13;
<p class="noindent"><a href="appb.xhtml#appblist2">Listing B-2</a> shows two data structures that are central to <span class="literal">elfinject</span>. The rest of the code uses these data structures to manipulate the ELF file and the code to inject.</p>&#13;
<p class="listing1" id="appblist2"><em>Listing B-2:</em> elfinject.c<em>:</em> <span class="codeitalic">elfinject</span> <em>data structures</em></p>&#13;
<p class="programs"><span class="ent">➊</span> typedef struct {<br/>     int fd;          /* file descriptor */<br/>     Elf *e;          /* main elf descriptor */<br/>     int bits;        /* 32-bit or 64-bit */<br/>     GElf_Ehdr ehdr;  /* executable header */<br/>   } elf_data_t;<br/><br/><span class="ent">➋</span> typedef struct {<br/>     size_t pidx;     /* index of program header to overwrite */<br/>     GElf_Phdr phdr;  /* program header to overwrite */<br/>     size_t sidx;     /* index of section header to overwrite */<br/>     Elf_Scn *scn;    /* section to overwrite */<br/><span epub:type="pagebreak" id="page_394"/>     GElf_Shdr shdr;  /* section header to overwrite */<br/>     off_t shstroff;  /* offset to section name to overwrite */<br/>     char *code;      /* code to inject */<br/>     size_t len;      /* number of code bytes */<br/>     long entry;      /* code buffer offset to entry point (-1 for none) */<br/>     off_t off;       /* file offset to injected code */<br/>     size_t secaddr;  /* section address for injected code */<br/>     char *secname;   /* section name for injected code */<br/>   } inject_data_t;</p>&#13;
<p class="indent">The first data structure <span class="literal">elf_data_t</span> <span class="ent">➊</span> keeps track of data needed to manipulate the ELF binary in which the new code section is to be injected. It contains a file descriptor for the ELF file (<span class="literal">fd</span>), a <span class="literal">libelf</span> handle to the file, an integer denoting the binary’s bit width (<span class="literal">bits</span>), and a <span class="literal">GElf</span> handle to the binary’s executable header. I’ll omit the standard C code that opens <span class="literal">fd</span>, so from this point on, consider <span class="literal">fd</span> to be opened for reading and writing. I will show the code that opens the <span class="literal">libelf</span> and <span class="literal">GElf</span> handles shortly.</p>&#13;
<p class="indent">The <span class="literal">inject_data_t</span> structure <span class="ent">➋</span> tracks information about the code to inject and where and how to inject it in the binary. First, it contains data on which parts of the binary need to be modified to inject the new code. This data includes the index (<span class="literal">pidx</span>) and <span class="literal">GElf</span> handle (<span class="literal">phdr</span>) of the <span class="literal">PT_NOTE</span> program header to overwrite with the injected header. It also includes the index (<span class="literal">sidx</span>) and <span class="literal">libelf</span> and <span class="literal">GElf</span> handles (<span class="literal">scn</span> and <span class="literal">shdr</span>, respectively) of the section to overwrite as well as the file offset to the section name in the string table (<span class="literal">shstroff</span>) to change to a new name, like <span class="literal">.injected</span>.</p>&#13;
<p class="indent">Then comes the actual code to inject in the form of a buffer (<span class="literal">code</span>) and an integer describing the length of that buffer (<span class="literal">len</span>). This code is given by the <span class="literal">elfinject</span> user, so let’s consider <span class="literal">code</span> and <span class="literal">len</span> to be set from this point on. The <span class="literal">entry</span> field is an offset within the <span class="literal">code</span> buffer, pointing to the code location that should become the new entry point for the binary. If there’s no new entry point, then <span class="literal">entry</span> is set to <span class="literal">-1</span> to indicate this.</p>&#13;
<p class="indent">The <span class="literal">off</span> field is the file offset in the binary where the new code should be injected. This will point to the end of the binary because that’s where <span class="literal">elfinject</span> places the new code, as shown in <a href="ch07.xhtml#ch07fig2">Figure 7-2</a>. Finally, <span class="literal">secaddr</span> is the load address for the new code section, and <span class="literal">secname</span> is the name of the injected section. You can consider all the fields from <span class="literal">entry</span> to <span class="literal">secname</span> to be set as well, as they’re all user specified except for <span class="literal">off</span>, which <span class="literal">elfinject</span> computes when it loads the binary.</p>&#13;
<h3 class="h3" id="appb_3">B.3 Initializing libelf</h3>&#13;
<p class="noindent">At this point, let’s skip past the <span class="literal">elfinject</span> initialization code and assume that all initialization succeeded: the user arguments are parsed, a file descriptor to the host binary is opened, and the inject file is loaded into the code buffer in a <span class="literal">struct inject_data_t</span>. All of this initialization stuff takes place in the <span class="literal">main</span> function of <span class="literal">elfinject</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_395"/>After that, <span class="literal">main</span> passes control to a function called <span class="literal">inject_code</span>, which is the starting point for the actual code injection. Let’s take a look at <a href="appb.xhtml#appblist3">Listing B-3</a>, which shows the part of <span class="literal">inject_code</span> that opens the given ELF binary in <span class="literal">libelf</span>. Keep in mind that function names starting with <span class="literal">elf_</span> are <span class="literal">libelf</span> functions and names starting with <span class="literal">gelf_</span> are <span class="literal">GElf</span> functions.</p>&#13;
<p class="listing1" id="appblist3"><em>Listing B-3:</em> elfinject.c<em>:</em> <span class="codeitalic">inject_code</span> <em>function</em></p>&#13;
<p class="programs">   int<br/>   inject_code(int fd, inject_data_t *inject)<br/>   {<br/><span class="ent">➊</span>  elf_data_t elf;<br/>    int ret;<br/>    size_t n;<br/><br/>    elf.fd = fd;<br/>    elf.e = NULL;<br/><br/><span class="ent">➋</span>   if(elf_version(EV_CURRENT) == EV_NONE) {<br/>      fprintf(stderr, "Failed to initialize libelf\n");<br/>      goto fail;<br/>    }<br/><br/>     /* Use libelf to read the file, but do writes manually */<br/><span class="ent">➌</span>   elf.e = elf_begin(elf.fd, ELF_C_READ, NULL);<br/>     if(!elf.e) {<br/>       fprintf(stderr, "Failed to open ELF file\n");<br/>       goto fail;<br/>     }<br/><br/><span class="ent">➍</span>   if(elf_kind(elf.e) != ELF_K_ELF) {<br/>        fprintf(stderr, "Not an ELF executable\n");<br/>        goto fail;<br/>     }<br/><br/><span class="ent">➎</span>   ret = gelf_getclass(elf.e);<br/>     switch(ret) {<br/>     case ELFCLASSNONE:<br/>       fprintf(stderr, "Unknown ELF class\n");<br/>       goto fail;<br/>     case ELFCLASS32:<br/>       elf.bits = 32;<br/>       break;<br/>     default:<br/>       elf.bits = 64;<br/>       break;<br/>     }<br/><br/>   ...</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_396"/>An important local variable in the <span class="literal">inject_code</span> function, <span class="literal">elf</span> <span class="ent">➊</span> is an instance of the <span class="literal">elf_data_t</span> struct type defined previously, and it’s used to store all the important information about the loaded ELF binary to pass to other functions.</p>&#13;
<p class="indent">Before using any other <span class="literal">libelf</span> API functions, you must call <span class="literal">elf_version</span> <span class="ent">➋</span>, which takes the version number of the ELF specification you want to use as its only parameter. If the version is not supported, <span class="literal">libelf</span> will complain by returning the constant <span class="literal">EV_NONE</span>, in which case <span class="literal">inject_code</span> gives up and reports an error initializing <span class="literal">libelf</span>. If <span class="literal">libelf</span> doesn’t complain, it means the ELF version requested is supported, and it’s safe to make other <span class="literal">libelf</span> calls to load and parse the binary.</p>&#13;
<p class="indent">At the moment, all standard ELF binaries are formatted according to major version 1 of the specification, so this is the only legal value you can pass to <span class="literal">elf_version</span>. By convention, instead of passing a literal “1” to <span class="literal">elf_version</span>, you pass the constant value <span class="literal">EV_CURRENT</span>. Both <span class="literal">EV_NONE</span> and <span class="literal">EV_CURRENT</span> are specified in <em>elf.h</em>, which is the header that contains all the constants and data structures related to the ELF format, not <em>libelf.h</em>. If there’s a major revision of the ELF format, <span class="literal">EV_CURRENT</span> will be incremented to the next version on systems that use the new ELF version.</p>&#13;
<p class="indent">After <span class="literal">elf_version</span> returns successfully, it’s safe to start loading and parsing the binary to inject the new code into. The first step is to call <span class="literal">elf_begin</span> <span class="ent">➌</span>, which opens the ELF file and returns a handle to it of type <span class="literal">Elf*</span>. You can pass this handle to other <span class="literal">libelf</span> functions to perform operations on the ELF file.</p>&#13;
<p class="indent">The <span class="literal">elf_begin</span> function takes three parameters: an open file descriptor for the ELF file, a constant that indicates whether to open the file for reading or writing, and a pointer to an <span class="literal">Elf</span> handle. In this case, the file descriptor is <span class="literal">fd</span>, and <span class="literal">inject_code</span> passes the constant <span class="literal">ELF_C_READ</span> to indicate that it’s interested only in using <span class="literal">libelf</span> to read the ELF binary. For the final parameter (the <span class="literal">Elf</span> handle), <span class="literal">inject_code</span> passes <span class="literal">NULL</span> so that <span class="literal">libelf</span> automatically allocates and returns a handle.</p>&#13;
<p class="indent">Instead of <span class="literal">ELF_C_READ</span>, you can also pass <span class="literal">ELF_C_WRITE</span> or <span class="literal">ELF_C_RDWR</span> to indicate that you want to use <span class="literal">libelf</span> to write modifications to an ELF binary, or for a combination of read and write operations. For simplicity, <span class="literal">elfinject</span> only uses <span class="literal">libelf</span> to parse the ELF file. To write back any modifications, it circumvents <span class="literal">libelf</span> and simply uses the file descriptor <span class="literal">fd</span> directly.</p>&#13;
<p class="indent">After opening an ELF with <span class="literal">libelf</span>, you’ll typically pass the opened <span class="literal">Elf</span> handle to <span class="literal">elf_kind</span> to figure out what kind of ELF you’re dealing with <span class="ent">➍</span>. In this case, <span class="literal">inject_code</span> compares <span class="literal">elf_kind</span>’s return value to the constant <span class="literal">ELF_K_ELF</span> to verify that the ELF file is an executable. The other possible return values are <span class="literal">ELF_K_AR</span> for ELF archives or <span class="literal">ELF_K_NULL</span> if an error occurred. In both cases, <span class="literal">inject_code</span> cannot perform the code injection, so it returns with an error.</p>&#13;
<p class="indent">Next, <span class="literal">inject_code</span> uses a <span class="literal">GElf</span> function called <span class="literal">gelf_getclass</span> to find out the “class” of the ELF binary <span class="ent">➎</span>. This indicates whether the ELF is 32-bit (<span class="literal">ELFCLASS32</span>) or 64-bit (<span class="literal">ELFCLASS64</span>). In case of error, <span class="literal">gelf_getclass</span> returns <span class="literal">ELFCLASSNONE</span>. The <span class="literal">ELFCLASS*</span> constants are defined in <em>elf.h</em>. For now, <span epub:type="pagebreak" id="page_397"/><span class="literal">inject_code</span> just stores the bit width of the binary (32 or 64) in the <span class="literal">bits</span> field of the <span class="literal">elf</span> structure. Knowing the bit width is necessary when parsing the ELF binary.</p>&#13;
<p class="indent">That covers initializing <span class="literal">libelf</span> and retrieving basic information about the binary. Now let’s consider the rest of the <span class="literal">inject_code</span> function, shown in <a href="appb.xhtml#appblist4">Listing B-4</a>.</p>&#13;
<p class="listing1" id="appblist4"><em>Listing B-4:</em> elfinject.c<em>:</em> <span class="codeitalic">inject_code</span> <em>function (continued)</em></p>&#13;
<p class="programs">   ...<br/>   <br/><span class="ent">➊</span>  if(!gelf_getehdr(elf.e, &amp;elf.ehdr)) {<br/>      fprintf(stderr, "Failed to get executable header\n");<br/>      goto fail;<br/>   }<br/>   <br/>   /* Find a rewritable program header */<br/><span class="ent">➋</span>  if(find_rewritable_segment(&amp;elf, inject) &lt; 0) {<br/>     goto fail;<br/>   }<br/>   <br/>   /* Write the injected code to the binary */<br/><span class="ent">➌</span>  if(write_code(&amp;elf, inject) &lt; 0) {<br/>     goto fail;<br/>   }<br/>   <br/>   /* Align code address so it's congruent to the file offset modulo 4096 */<br/><span class="ent">➍</span>  n = (inject-&gt;off % 4096) - (inject-&gt;secaddr % 4096);<br/>   inject-&gt;secaddr += n;<br/>   <br/>   /* Rewrite a section for the injected code */<br/><span class="ent">➎</span>  if((rewrite_code_section(&amp;elf, inject) &lt; 0)<br/>        || <span class="ent">➏</span>(rewrite_section_name(&amp;elf, inject) &lt; 0)) {<br/>       goto fail;<br/>   }<br/>   <br/>   /* Rewrite a segment for the added code section */<br/><span class="ent">➐</span>  if(rewrite_code_segment(&amp;elf, inject) &lt; 0) {<br/>       goto fail;<br/>   }<br/>   <br/>   /* Rewrite entry point if requested */<br/><span class="ent">➑</span>  if((inject-&gt;entry &gt;= 0) &amp;&amp; (rewrite_entry_point(&amp;elf, inject) &lt; 0)) {<br/>     goto fail;<br/>   }<br/>   <br/>   ret = 0;<br/>   goto cleanup;<br/><span epub:type="pagebreak" id="page_398"/>&#13;
   fail:<br/>     ret = -1;<br/>   <br/>   cleanup:<br/>     if(elf.e) {<br/><span class="ent">➒</span>      elf_end(elf.e);<br/>     }<br/>   <br/>     return ret;<br/>   }</p>&#13;
<p class="indent">As you can see, the remainder of the <span class="literal">inject_code</span> function consists of several major steps, which correspond to the steps outlined in <a href="ch07.xhtml#ch07fig2">Figure 7-2</a> as well as some extra low-level steps not shown in the figure:</p>&#13;
<p class="bull">• Retrieve the binary’s executable header <span class="ent">➊</span>, needed for adjusting the entry point later.</p>&#13;
<p class="bull">• Find the <span class="literal">PT_NOTE</span> segment <span class="ent">➋</span> to overwrite and fail if there is no suitable segment.</p>&#13;
<p class="bull">• Write the injected code to the end of the binary <span class="ent">➌</span>.</p>&#13;
<p class="bull">• Adjust the injected section’s load address to meet alignment requirements <span class="ent">➍</span>.</p>&#13;
<p class="bull">• Overwrite the <span class="literal">.note.ABI-tag</span> section header <span class="ent">➎</span> with a header for the new injected section.</p>&#13;
<p class="bull">• Update the name of the section whose header was overwritten <span class="ent">➏</span>.</p>&#13;
<p class="bull">• Overwrite the <span class="literal">PT_NOTE</span> program header <span class="ent">➐</span>.</p>&#13;
<p class="bull">• Adjust the binary entry point if requested by the user <span class="ent">➑</span>.</p>&#13;
<p class="bull">• Clean up the <span class="literal">Elf</span> handle by calling <span class="literal">elf_end</span> <span class="ent">➒</span>.</p>&#13;
<p class="bull66">I’ll go over these steps in more detail next.</p>&#13;
<h3 class="h3" id="appb_4">B.4 Getting the Executable Header</h3>&#13;
<p class="noindent">In step <span class="ent">➊</span> in <a href="appb.xhtml#appblist4">Listing B-4</a>, <span class="literal">elfinject</span> gets the binary’s executable header. Recall from <a href="ch02.xhtml#ch02">Chapter 2</a> that the executable header contains the file offsets and sizes of these tables. The executable header also contains the binary’s entry point address, which <span class="literal">elfinject</span> modifies if requested by the user.</p>&#13;
<p class="indent">To get the ELF executable header, <span class="literal">elfinject</span> uses the <span class="literal">gelf_getehdr</span> function. This is a <span class="literal">GElf</span> function that returns an ELF class-agnostic representation of the executable header. The format of the executable header differs slightly between 32-bit and 64-bit binaries, but <span class="literal">GElf</span> hides these differences so that you don’t have to worry about them. It’s also possible to get the executable header using only pure <span class="literal">libelf</span>, without <span class="literal">GElf</span>. However, in that case, <span epub:type="pagebreak" id="page_399"/>you have to manually call <span class="literal">elf32_getehdr</span> or <span class="literal">elf64_getehdr</span> depending on the ELF class.</p>&#13;
<p class="indent">The <span class="literal">gelf_getehdr</span> function takes two parameters: the <span class="literal">Elf</span> handle and a pointer to a <span class="literal">GElf_Ehdr</span> structure where <span class="literal">GElf</span> can store the executable header. If all is well, <span class="literal">gelf_getehdr</span> returns a nonzero value. If there’s an error, it returns 0 and sets <span class="literal">elf_errno</span>, an error code that you can read by calling <span class="literal">libelf</span>’s <span class="literal">elf_errno</span> function. This behavior is standard for all <span class="literal">GElf</span> functions.</p>&#13;
<p class="indent">To convert <span class="literal">elf_errno</span> to a human-readable error message, you can use the <span class="literal">elf_errmsg</span> function, but <span class="literal">elfinject</span> doesn’t do this. The <span class="literal">elf_errmsg</span> function takes the return value of <span class="literal">elf_errno</span> as input and returns a <span class="literal">const char*</span> pointing to the appropriate error string.</p>&#13;
<h3 class="h3" id="appb_5">B.5 Finding the PT_NOTE Segment</h3>&#13;
<p class="noindent">After getting the executable header, <span class="literal">elfinject</span> loops over all the program headers in the binary to check whether the binary has a <span class="literal">PT_NOTE</span> segment that’s safe to overwrite (step <span class="ent">➋</span> in <a href="appb.xhtml#appblist4">Listing B-4</a>). All of this functionality is implemented in a separate function called <span class="literal">find_rewritable_segment</span>, shown in <a href="appb.xhtml#appblist5">Listing B-5</a>.</p>&#13;
<p class="listing1" id="appblist5"><em>Listing B-5:</em> elfinject.c<em>: finding the</em> <span class="codeitalic">PT_NOTE</span> <em>program header</em></p>&#13;
<p class="programs">   int<br/>   find_rewritable_segment(elf_data_t *elf, inject_data_t *inject)<br/>   {<br/>     int ret;<br/>     size_t i, n;<br/><br/><span class="ent">➊</span>  ret = elf_getphdrnum(elf-&gt;e, &amp;n);<br/>    if(ret != 0) {<br/>       fprintf(stderr, "Cannot find any program headers\n");<br/>       return -1;<br/>   }<br/><br/><span class="ent">➋</span>  for(i = 0; i &lt; n; i++) {<br/><span class="ent">➌</span>    if(!gelf_getphdr(elf-&gt;e, i, &amp;inject-&gt;phdr)) {<br/>        fprintf(stderr, "Failed to get program header\n");<br/>        return -1;<br/>    }<br/><br/><span class="ent">➍</span>  switch(inject-&gt;phdr.p_type) {<br/>    case <span class="ent">➎</span>PT_NOTE:<br/>      <span class="ent">➏</span>inject-&gt;pidx = i;<br/>      return 0;<br/>    default:<br/>      break;<br/>    }<br/>   }<br/><span class="ent">➐</span> fprintf(stderr, "Cannot find segment to rewrite\n");<br/>   return -1;<br/>  }</p>&#13;
<p class="indent">As <a href="appb.xhtml#appblist5">Listing B-5</a> shows, <span class="literal">find_rewritable_segment</span> takes two arguments: an <span class="literal">elf_data_t*</span> called <span class="literal">elf</span> and an <span class="literal">inject_data_t*</span> called <span class="literal">inject</span>. Recall that these are custom data types, defined in <a href="appb.xhtml#appblist2">Listing B-2</a>, which contain all the relevant information about the ELF binary and the inject.</p>&#13;
<p class="indent">To find the <span class="literal">PT_NOTE</span> segment, <span class="literal">elfinject</span> first looks up the number of program headers that the binary contains <span class="ent">➊</span>. This is done using a <span class="literal">libelf</span> function called <span class="literal">elf_getphdrnum</span>, which takes two arguments: the <span class="literal">Elf</span> handle and a pointer to a <span class="literal">size_t</span> integer where the number of program headers will be stored. If the return value is nonzero, it means an error occurred, and <span class="literal">elfinject</span> gives up because it cannot access the program header table. If there were no errors, <span class="literal">elf_getphdrnum</span> will have stored the number of program headers in the <span class="literal">size_t</span> called <span class="literal">n</span> in <a href="appb.xhtml#appblist5">Listing B-5</a>.</p>&#13;
<p class="indent">Now that <span class="literal">elfinject</span> knows the number of program headers <span class="literal">n</span>, it loops over each program header to find one of type <span class="literal">PT_NOTE</span> <span class="ent">➋</span>. To access each program header, <span class="literal">elfinject</span> uses the <span class="literal">gelf_getphdr</span> function <span class="ent">➌</span>, which allows you to access program headers in an ELF class-agnostic way. Its arguments are the <span class="literal">Elf</span> handle, the index number <span class="literal">i</span> of the program header to get, and a pointer to a <span class="literal">GElf_Phdr</span> struct (<span class="literal">inject-&gt;phdr</span> in this case) to store the program header in. As is usual for <span class="literal">GElf</span>, a nonzero return value indicates success, while return value 0 indicates failure.</p>&#13;
<p class="indent">After this step completes, <span class="literal">inject-&gt;phdr</span> contains the <span class="literal">i</span>-th program header. All that remains is to inspect the program header’s <span class="literal">p_type</span> field <span class="ent">➍</span> and check whether the type is <span class="literal">PT_NOTE</span> <span class="ent">➎</span>. If it is, <span class="literal">elfinject</span> stores the program header index in the <span class="literal">inject-&gt;pidx</span> field <span class="ent">➏</span>, and the <span class="literal">find_rewritable_segment</span> function returns successfully.</p>&#13;
<p class="indent">If, after looping over all program headers, <span class="literal">elfinject</span> failed to find a header of type <span class="literal">PT_NOTE</span>, it reports an error <span class="ent">➐</span> and exits without modifying the binary.</p>&#13;
<h3 class="h3" id="appb_6">B.6 Injecting the Code Bytes</h3>&#13;
<p class="noindent">After locating the overwritable <span class="literal">PT_NOTE</span> segment, it’s time to append the injected code to the binary (step <span class="ent">➌</span> in <a href="appb.xhtml#appblist4">Listing B-4</a>). Let’s look at the function that performs the actual inject, which is called <span class="literal">write_code</span>, as shown in <a href="appb.xhtml#appblist6">Listing B-6</a>.</p>&#13;
<p class="listing1" id="appblist6"><em>Listing B-6:</em> elfinject.c<em>: appending the injected code to the binary</em></p>&#13;
<p class="programs">   int<br/>   write_code(elf_data_t *elf, inject_data_t *inject)<br/>   {<br/>     off_t off;<br/>     size_t n;<br/><span class="ent">➊</span>   off = lseek(elf-&gt;fd, 0, SEEK_END);<br/>     if(off &lt; 0) {<br/>       fprintf(stderr, "lseek failed\n");<br/>       return -1;<br/>   }<br/><br/><span class="ent">➋</span>  n = write(elf-&gt;fd, inject-&gt;code, inject-&gt;len);<br/>    if(n != inject-&gt;len) {<br/>      fprintf(stderr, "Failed to inject code bytes\n");<br/>      return -1;<br/>   }<br/><span class="ent">➌</span>  inject-&gt;off = off;<br/><br/>    return 0;<br/>  }</p>&#13;
<p class="indent">Like the <span class="literal">find_rewritable_segment</span> function you saw in the previous section, <span class="literal">write_code</span> takes the <span class="literal">elf_data_t*</span> called <span class="literal">elf</span> and the <span class="literal">inject_data_t*</span> called <span class="literal">inject</span> as its arguments. The <span class="literal">write_code</span> function doesn’t involve <span class="literal">libelf</span>; it only uses standard C file operations on <span class="literal">elf-&gt;fd</span>, the file descriptor of the opened ELF binary.</p>&#13;
<p class="indent">First, <span class="literal">write_code</span> seeks to the end of the binary <span class="ent">➊</span>. It then appends the injected code bytes there <span class="ent">➋</span> and saves the byte offset where the code bytes were written into the <span class="literal">inject-&gt;off</span> field of the <span class="literal">inject</span> data structure <span class="ent">➌</span>.</p>&#13;
<p class="indent">Now that the code injection is done, all that remains is to update a section and program header (and optionally the binary entry point) to describe the new injected code section and ensure it gets loaded when the binary executes.</p>&#13;
<h3 class="h3" id="appb_7">B.7 Aligning the Load Address for the Injected Section</h3>&#13;
<p class="noindent">With the injected code bytes appended to the end of the binary, it’s almost time to overwrite a section header to point to those injected bytes. The ELF specification places certain requirements on the addresses of loadable segments and, by extension, the sections they contain. Specifically, the ELF standard requires that for each loadable segment, <span class="literal">p_vaddr</span> is congruent to <span class="literal">p_offset</span> modulo the page size, which is 4,096 bytes. The following equation summarizes this requirement:</p>&#13;
<p class="center">(<em>p</em>_<em>vaddr</em> mod 4096) =  (<em>p</em>_<em>offset</em> mod 4096)</p>&#13;
<p class="indent">Similarly, the ELF standard requires that <span class="literal">p_vaddr</span> be congruent to <span class="literal">p_offset</span> modulo <span class="literal">p_align</span>. Therefore, before overwriting the section header, <span class="literal">elfinject</span> adjusts the user-specified memory address for the injected section so that it meets these requirements. <a href="appb.xhtml#appblist7">Listing B-7</a> shows the code that aligns the address, which is the same code shown in step <span class="ent">➍</span> in <a href="appb.xhtml#appblist4">Listing B-4</a>.</p>&#13;
<p class="listing1" id="appblist7"><span epub:type="pagebreak" id="page_400"/><em>Listing B-7:</em> elfinject.c<em>: aligning the load address for the injected section</em></p>&#13;
<p class="programs">    /* Align code address so it's congruent to the file offset modulo 4096 */<br/><span class="ent">➊</span>  n = (inject-&gt;off % 4096) - (inject-&gt;secaddr % 4096);<br/><span class="ent">➋</span>  inject-&gt;secaddr += n;</p>&#13;
<p class="indent">The alignment code in <a href="appb.xhtml#appblist7">Listing B-7</a> consists of two steps. First, it computes the difference <span class="literal">n</span> between the injected code’s file offset modulo 4096 and the section address modulo 4096 <span class="ent">➊</span>. The ELF specification requires that the offset and address are congruent modulo 4096 in which case <span class="literal">n</span> will be zero. To ensure correct alignment, <span class="literal">elfinject</span> adds <span class="literal">n</span> to the section address so that the difference with the file offset becomes zero modulo 4096 if it wasn’t already <span class="ent">➋</span>.</p>&#13;
<h3 class="h3" id="appb_8">B.8 Overwriting the .note.ABI-tag Section Header</h3>&#13;
<p class="noindent">Now that the address for the injected section is known, <span class="literal">elfinject</span> moves on to overwriting the section header. Recall that it overwrites the <span class="literal">.note.ABI-tag</span> section header that’s part of the <span class="literal">PT_NOTE</span> segment. <a href="appb.xhtml#appblist8">Listing B-8</a> shows the function that handles the overwrite, called <span class="literal">rewrite_code_section</span>. It’s called in step <span class="ent">➎</span> in <a href="appb.xhtml#appblist4">Listing B-4</a>.</p>&#13;
<p class="listing1" id="appblist8"><em>Listing B-8:</em> elfinject.c<em>: overwriting the</em> <span class="codeitalic">.note.ABI-tag</span> <em>section header</em></p>&#13;
<p class="programs">  int<br/>  rewrite_code_section(elf_data_t *elf, inject_data_t *inject)<br/>  {<br/>    Elf_Scn *scn;<br/>    GElf_Shdr shdr;<br/>    char *s;<br/>    size_t shstrndx;<br/><br/><span class="ent">➊</span>   if(elf_getshdrstrndx(elf-&gt;e, &amp;shstrndx) &lt; 0) {<br/>      fprintf(stderr, "Failed to get string table section index\n");<br/>      return -1;<br/>    }<br/><br/>    scn = NULL;<br/><span class="ent">➋</span>   while((scn = elf_nextscn(elf-&gt;e, scn))) {<br/><span class="ent">➌</span>     if(!gelf_getshdr(scn, &amp;shdr)) {<br/>        fprintf(stderr, "Failed to get section header\n");<br/>        return -1;<br/>       }<br/><span class="ent">➍</span>     s = elf_strptr(elf-&gt;e, shstrndx, shdr.sh_name);<br/>      if(!s) {<br/>        fprintf(stderr, "Failed to get section name\n");<br/>        return -1;<br/>      }<br/><span epub:type="pagebreak" id="page_401"/>&#13;
<span class="ent">➎</span>     if(!strcmp(s, ".note.ABI-tag")) {<br/><span class="ent">➏</span>       shdr.sh_name      = shdr.sh_name;              /* offset into string table */<br/>        shdr.sh_type      = SHT_PROGBITS;               /* type */<br/>        shdr.sh_flags     = SHF_ALLOC | SHF_EXECINSTR;  /* flags */<br/>        shdr.sh_addr      = inject-&gt;secaddr;            /* address to load section at */<br/>        shdr.sh_offset    = inject-&gt;off;                /* file offset to start of section */<br/>        shdr.sh_size      = inject-&gt;len;                /* size in bytes */<br/>        shdr.sh_link      = 0;                          /* not used for code section */<br/>        shdr.sh_info      = 0;                          /* not used for code section */<br/>        shdr.sh_addralign = 16;                         /* memory alignment */<br/>        shdr.sh_entsize   = 0                           /* not used for code section */<br/><br/><span class="ent">➐</span>       inject-&gt;sidx = elf_ndxscn(scn);<br/>        inject-&gt;scn = scn;<br/>        memcpy(&amp;inject-&gt;shdr, &amp;shdr, sizeof(shdr));<br/><br/><span class="ent">➑</span>       if(write_shdr(elf, scn, &amp;shdr, elf_ndxscn(scn)) &lt; 0) {<br/>             return -1;<br/>        }<br/><br/><span class="ent">➒</span>       if(reorder_shdrs(elf, inject) &lt; 0) {<br/>             return -1;<br/>        }<br/><br/>        break;<br/>      }<br/>    }<br/><span class="ent">➓</span>   if(!scn) {<br/>      fprintf(stderr, "Cannot find section to rewrite\n");<br/>      return -1;<br/>     }<br/><br/>     return 0;<br/>   }</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_402"/>To find the <span class="literal">.note.ABI-tag</span> section header to overwrite, <span class="literal">rewrite_code _section</span> loops over all section headers and inspects the section names. Recall from <a href="ch02.xhtml#ch02">Chapter 2</a> that section names are stored in a special section called <span class="literal">.shstrtab</span>. To read the section names, <span class="literal">rewrite_code_section</span> first needs the index number of the section header describing the <span class="literal">.shstrtab</span> section. To get this index, you can read the <span class="literal">e_shstrndx</span> field of the executable header, or you can use the the function <span class="literal">elf_getshdrstrndx</span> provided by <span class="literal">libelf</span>. <a href="appb.xhtml#appblist8">Listing B-8</a> uses the latter option <span class="ent">➊</span>.</p>&#13;
<p class="indent">The <span class="literal">elf_getshdrstrndx</span> function takes two parameters: an <span class="literal">Elf</span> handle and a pointer to a <span class="literal">size_t</span> integer to store the section index in. The function returns 0 on success or sets <span class="literal">elf_errno</span> and returns −1 on failure.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_403"/>After getting the index of <span class="literal">.shstrtab</span>, <span class="literal">rewrite_code_section</span> loops over all section headers, inspecting each one as it goes along. To loop over the section headers, it uses the <span class="literal">elf_nextscn</span> function <span class="ent">➋</span>, which takes an <span class="literal">Elf</span> handle (<span class="literal">elf-&gt;e</span>) and <span class="literal">Elf_Scn*</span> (<span class="literal">scn</span>) as input. <span class="literal">Elf_Scn</span> is a struct defined by <span class="literal">libelf</span> that describes an ELF section. Initially, <span class="literal">scn</span> is <span class="literal">NULL</span>, causing <span class="literal">elf_nextscn</span> to return a pointer to the first section header at index 1 in the section header table.<sup><a id="appbfn_2a" href="footnote.xhtml#appbfn_2">2</a></sup> This pointer becomes the new value of <span class="literal">scn</span> and is handled in the loop body. In the next loop iteration, <span class="literal">elf_nextscn</span> takes the existing <span class="literal">scn</span> and returns a pointer to the section at index 2, and so on. In this way, you can use <span class="literal">elf_nextscn</span> to iterate over all sections until it returns <span class="literal">NULL</span>, indicating that there is no next section.</p>&#13;
<p class="indent">The loop body handles each section <span class="literal">scn</span> returned by <span class="literal">elf_nextscn</span>. The first thing that’s done for each section is to get an ELF class-agnostic representation of the section’s header, using the <span class="literal">gelf_getshdr</span> function <span class="ent">➌</span>. It works just like <span class="literal">gelf_getphdr</span>, which you learned about in Section B.5, except that <span class="literal">gelf_getshdr</span> takes an <span class="literal">Elf_Scn*</span> and a <span class="literal">GElf_Shdr*</span> as input. If all goes well, <span class="literal">gelf_getshdr</span> populates the given <span class="literal">GElf_Shdr</span> with the section header of the given <span class="literal">Elf_Scn</span> and returns a pointer to the header. If something goes wrong, it will return <span class="literal">NULL</span>.</p>&#13;
<p class="indent">Using the <span class="literal">Elf</span> handle stored in <span class="literal">elf-&gt;e</span>, the index <span class="literal">shstrndx</span> of the <span class="literal">.shstrtab</span> section, and the index <span class="literal">shdr.sh_name</span> of the current section’s name in the string table, <span class="literal">elfinject</span> now gets a pointer to the string describing the name of the current section. To that end, it passes all the required information to the <span class="literal">elf_strptr</span> function <span class="ent">➍</span>, which returns the pointer, or <span class="literal">NULL</span> in case of error.</p>&#13;
<p class="indent">Next, <span class="literal">elfinject</span> compares the just-obtained section name to the string <span class="literal">".note.ABI-tag"</span> <span class="ent">➎</span>. If it matches, it means the current section is the <span class="literal">.note.ABI-tag</span> section, and <span class="literal">elfinject</span> overwrites it as described next and then breaks out of the loop and returns successfully from <span class="literal">rewrite_code_section</span>. If the section name doesn’t match, the loop moves on to its next iteration to see whether the next section matches.</p>&#13;
<p class="indent">If the name of the current section is <span class="literal">.note.ABI-tag</span>, <span class="literal">rewrite_code_section</span> overwrites the fields in the section header to turn it into a header describing the injected section <span class="ent">➏</span>. As mentioned previously in the high-level overview in <a href="ch07.xhtml#ch07fig2">Figure 7-2</a>, this involves setting the section type to <span class="literal">SHT_PROGBITS</span>; marking the section as executable; and filling in the appropriate section address, file offset, size, and alignment.</p>&#13;
<p class="indent">Next, <span class="literal">rewrite_code_section</span> saves the index of the overwritten section header, the pointer to the <span class="literal">Elf_Scn</span> structure, and a copy of the <span class="literal">GElf_Shdr</span> in the <span class="literal">inject</span> structure <span class="ent">➐</span>. To get the section’s index, it uses the <span class="literal">elf_ndxscn</span> function, which takes an <span class="literal">Elf_Scn*</span> as input and returns the index of that section.</p>&#13;
<p class="indent">Once the header modifications are complete, <span class="literal">rewrite_code_section</span> writes the modified section header back into the ELF binary file using another <span class="literal">elfinject</span> function called <span class="literal">write_shdr</span> <span class="ent">➑</span> and then reorders the section headers by section address <span class="ent">➒</span>. I’ll discuss the <span class="literal">write_shdr</span> function next, skipping the <span epub:type="pagebreak" id="page_404"/>description of <span class="literal">reorder_shdrs</span>, the function that orders the sections, since it’s not central to understanding the <span class="literal">PT_NOTE</span> overwriting technique.</p>&#13;
<p class="indent">As mentioned previously, if <span class="literal">elfinject</span> succeeds in finding and overwriting the <span class="literal">.note.ABI-tag</span> section header, it breaks from the main loop iterating over all the section headers and returns successfully. If, on the other hand, the loop completes without finding a header to overwrite, then the inject cannot continue, and <span class="literal">rewrite_code_section</span> returns with an error <span class="ent">➓</span>.</p>&#13;
<p class="indent"><a href="appb.xhtml#appblist9">Listing B-9</a> shows the code for <span class="literal">write_shdr</span>, the function responsible for writing the modified section header back to the ELF file.</p>&#13;
<p class="listing1" id="appblist9"><em>Listing B-9:</em> elfinject.c<em>: writing the modified section header back to the binary</em></p>&#13;
<p class="programs">  int<br/>  write_shdr(elf_data_t *elf, Elf_Scn *scn, GElf_Shdr *shdr, size_t sidx)<br/>  {<br/>    off_t off;<br/>    size_t n, shdr_size;<br/>    void *shdr_buf;<br/><br/><span class="ent">➊</span>   if(!gelf_update_shdr(scn, shdr)) {<br/>      fprintf(stderr, "Failed to update section header\n");<br/>      return -1;<br/>    }<br/><br/><span class="ent">➋</span>   if(elf-&gt;bits == 32) {<br/><span class="ent">➌</span>     shdr_buf = elf32_getshdr(scn);<br/>       shdr_size = sizeof(Elf32_Shdr);<br/>    } else {<br/><span class="ent">➍</span>     shdr_buf = elf64_getshdr(scn);<br/>      shdr_size = sizeof(Elf64_Shdr);<br/>    }<br/><br/>    if(!shdr_buf) {<br/>      fprintf(stderr, "Failed to get section header\n");<br/>      return -1;<br/>    }<br/><br/><span class="ent">➎</span>   off = lseek(elf-&gt;fd, elf-&gt;ehdr.e_shoff + sidx*elf-&gt;ehdr.e_shentsize, SEEK_SET);<br/>    if(off &lt; 0) {<br/>      fprintf(stderr, "lseek failed\n");<br/>      return -1;<br/>    }<br/><br/><span class="ent">➏</span>   n = write(elf-&gt;fd, shdr_buf, shdr_size);<br/>    if(n != shdr_size) {<br/>      fprintf(stderr, "Failed to write section header\n");<br/>      return -1;<br/>    }<br/><br/>    return 0;<br/>  }</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_405"/>The <span class="literal">write_shdr</span> function takes three parameters: the <span class="literal">elf_data_t</span> structure called <span class="literal">elf</span> that stores all the important information needed to read and write the ELF binary, an <span class="literal">Elf_Scn*</span> (<span class="literal">scn</span>) and a <span class="literal">GElf_Shdr*</span> (<span class="literal">shdr</span>) corresponding to the section to overwrite, and the index (<span class="literal">sidx</span>) of that section in the section header table.</p>&#13;
<p class="indent">First, <span class="literal">write_shdr</span> calls <span class="literal">gelf_update_shdr</span> <span class="ent">➊</span>. Recall that <span class="literal">shdr</span> contains new, overwritten values in all the header fields. Because <span class="literal">shdr</span> is an ELF class-agnostic <span class="literal">GElf_Shdr</span> structure, which is part of the <span class="literal">GElf</span> API, writing to it doesn’t automatically update the underlying ELF data structures, <span class="literal">Elf32_Shdr</span> or <span class="literal">Elf64_Shdr</span>, depending on the ELF class. Yet those underlying data structures are the ones <span class="literal">elfinject</span> writes to the ELF binary, so it’s important that they’re updated. The <span class="literal">gelf_update_shdr</span> function takes an <span class="literal">Elf_Scn*</span> and a <span class="literal">GElf_Shdr*</span> as input and writes any changes made to the <span class="literal">GElf_Shdr</span> back to the underlying data structures, which are part of the <span class="literal">Elf_Scn</span> structure. The reason <span class="literal">elfinject</span> writes the underlying data structures to file, and not the <span class="literal">GElf</span> ones, is that the <span class="literal">GElf</span> data structures internally use a memory layout that doesn’t match the layout of the data structures in the file, so writing the <span class="literal">GElf</span> data structures would corrupt the ELF.</p>&#13;
<p class="indent">Now that <span class="literal">GElf</span> has written all pending updates back to the underlying native ELF data structures, <span class="literal">write_shdr</span> gets the native representation of the updated section header and writes it to the ELF file, overwriting the old <span class="literal">.note.ABI-tag</span> section header. First, <span class="literal">write_shdr</span> checks the bit width of the binary <span class="ent">➋</span>. If it’s 32 bits, then <span class="literal">write_shdr</span> calls <span class="literal">libelf</span>’s <span class="literal">elf32_getshdr</span> function (passing <span class="literal">scn</span> to it) to get a pointer to the <span class="literal">Elf32_Shdr</span> representation of the modified header <span class="ent">➌</span>. For 64-bit binaries, it uses <span class="literal">elf64_getshdr</span> <span class="ent">➍</span> instead of <span class="literal">elf32_getshdr</span>.</p>&#13;
<p class="indent">Next, <span class="literal">write_shdr</span> seeks the ELF file descriptor (<span class="literal">elf-&gt;fd</span>) to the offset in the ELF file where the updated header is to be written <span class="ent">➎</span>. Keep in mind that the <span class="literal">e_shoff</span> field in the executable header contains the file offset where the section header table starts, <span class="literal">sidx</span> is the index of the header to overwrite, and the <span class="literal">e_shentsize</span> field contains the size in bytes of each entry in the section header table. Thus, the following formula computes the file offset at which to write the updated section header:</p>&#13;
<p class="center"><em>e</em>_<em>shoff</em> + <em>sidx</em> × <em>e</em>_<em>shentsize</em></p>&#13;
<p class="indent">After seeking to this file offset, <span class="literal">write_shdr</span> writes the updated section header to the ELF file <span class="ent">➏</span>, overwriting the old <span class="literal">.note.ABI-tag</span> header with the new one describing the injected section. By this point, the new code bytes have been injected at the end of the ELF binary and there’s a new code section that contains those bytes, but this section doesn’t yet have a meaningful name in the string table. The next section explains how <span class="literal">elfinject</span> updates the section name.</p>&#13;
<h3 class="h3" id="appb_9"><span epub:type="pagebreak" id="page_406"/>B.9 Setting the Name of the Injected Section</h3>&#13;
<p class="noindent"><a href="appb.xhtml#appblist10">Listing B-10</a> shows the function that changes the name of the overwritten section, <span class="literal">.note.ABI-tag</span>, to something more meaningful, such as <span class="literal">.injected</span>. This is step <span class="ent">➏</span> in <a href="appb.xhtml#appblist4">Listing B-4</a>.</p>&#13;
<p class="listing1" id="appblist10"><em>Listing B-10:</em> elfinject.c<em>: setting the name of the injected section</em></p>&#13;
<p class="programs">  int<br/>  rewrite_section_name(elf_data_t *elf, inject_data_t *inject)<br/>  {<br/>    Elf_Scn *scn;<br/>    GElf_Shdr shdr;<br/>    char *s;<br/>    size_t shstrndx, stroff, strbase;<br/>  <br/><span class="ent">➊</span>   if(strlen(inject-&gt;secname) &gt; strlen(".note.ABI-tag")) {<br/>       fprintf(stderr, "Section name too long\n");<br/>       return -1;<br/>    }<br/>  <br/><span class="ent">➋</span>   if(elf_getshdrstrndx(elf-&gt;e, &amp;shstrndx) &lt; 0) {<br/>       fprintf(stderr, "Failed to get string table section index\n");<br/>       return -1;<br/>    }<br/>  <br/>    stroff = 0;<br/>    strbase = 0;<br/>    scn = NULL;<br/><span class="ent">➌</span>   while((scn = elf_nextscn(elf-&gt;e, scn))) {<br/><span class="ent">➍</span>     if(!gelf_getshdr(scn, &amp;shdr)) {<br/>         fprintf(stderr, "Failed to get section header\n");<br/>         return -1;<br/>      }<br/><span class="ent">➎</span>     s = elf_strptr(elf-&gt;e, shstrndx, shdr.sh_name);<br/>       if(!s) {<br/>         fprintf(stderr, "Failed to get section name\n");<br/>         return -1;<br/>      }<br/>  <br/><span class="ent">➏</span>     if(!strcmp(s, ".note.ABI-tag")) {<br/>         stroff = shdr.sh_name;    /* offset into shstrtab */<br/><span class="ent">➐</span>      } else if(!strcmp(s, ".shstrtab")) {<br/>         strbase = shdr.sh_offset; /* offset to start of shstrtab */<br/>       }<br/>    }<br/><span epub:type="pagebreak" id="page_407"/><br/><span class="ent">➑</span>   if(stroff == 0) {<br/>      fprintf(stderr, "Cannot find shstrtab entry for injected section\n");<br/>      return -1;<br/>    } else if(strbase == 0) {<br/>      fprintf(stderr, "Cannot find shstrtab\n");<br/>      return -1;<br/>    }<br/>  <br/><span class="ent">➒</span>   inject-&gt;shstroff = strbase + stroff;<br/>  <br/><span class="ent">➓</span>   if(write_secname(elf, inject) &lt; 0) {<br/>       return -1;<br/>    }<br/>  <br/>    return 0;<br/>  }</p>&#13;
<p class="indent">The function that overwrites the section name is called <span class="literal">rewrite_section _name</span>. The new name for this injected section cannot be longer than the old name, <span class="literal">.note.ABI-tag</span>, because all the strings in the string table are packed tightly together with no room for extra added characters. Therefore, the first thing <span class="literal">rewrite_section_name</span> does is check that the new section name, stored in the <span class="literal">inject-&gt;secname</span> field, will fit <span class="ent">➊</span>. If not, <span class="literal">rewrite_section_name</span> returns with an error.</p>&#13;
<p class="indent">The next steps are identical to the corresponding steps in the <span class="literal">rewrite _code_section</span> function I discussed previously, in <a href="appb.xhtml#appblist8">Listing B-8</a>: get the index of the string table section <span class="ent">➋</span> and then loop over all sections <span class="ent">➌</span> and inspect each section’s header <span class="ent">➍</span>, using the <span class="literal">sh_name</span> field in the header to obtain a string pointer to the section’s name <span class="ent">➎</span>. For details of these steps, refer to Section B.8.</p>&#13;
<p class="indent">Overwriting the old <span class="literal">.note.ABI-tag</span> section name requires two pieces of information: the file offset to the start of the <span class="literal">.shstrtab</span> section (the string table) and the offset to the <span class="literal">.note.ABI-tag</span> section’s name within the string table. Given these two offsets, <span class="literal">rewrite_section_name</span> knows where in the file to write the new section name string. The offset within the string table to the <span class="literal">.note.ABI-tag</span> section name is stored in the <span class="literal">sh_name</span> field of the <span class="literal">.note.ABI-tag</span> section header <span class="ent">➏</span>. Similarly, the <span class="literal">sh_offset</span> field in the section header contains the start of the <span class="literal">.shstrtab</span> section <span class="ent">➐</span>.</p>&#13;
<p class="indent">If all goes well, the loop locates both required offsets <span class="ent">➑</span>. If not, <span class="literal">rewrite _section_name</span> reports the error and gives up.</p>&#13;
<p class="indent">Finally, <span class="literal">rewrite_section_name</span> computes the file offset at which to write the new section name, saving it in the <span class="literal">inject-&gt;shstroff</span> field <span class="ent">➒</span>. It then calls another function, called <span class="literal">write_secname</span>, to write the new section name to the ELF binary at the just-computed offset <span class="ent">➓</span>. Writing the section name to file is straightforward and requires only standard C file I/O functions, so I omit a description of the <span class="literal">write_secname</span> function here.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_408"/>To recap, the ELF binary now contains the injected code, an overwritten section header, and a proper name for the injected section. The next step is to overwrite a <span class="literal">PT_NOTE</span> program header, creating a loadable segment that contains the injected section.</p>&#13;
<h3 class="h3" id="appb_10">B.10 Overwriting the PT_NOTE Program Header</h3>&#13;
<p class="noindent">As you may remember, <a href="appb.xhtml#appblist5">Listing B-5</a> showed the code that locates and saves the <span class="literal">PT_NOTE</span> program header to overwrite. All that’s left to do is to overwrite the relevant program header fields and save the updated program header to file. <a href="appb.xhtml#appblist11">Listing B-11</a> shows <span class="literal">rewrite_code_segment</span>, the function that updates and saves the program header. This was called in step <span class="ent">➐</span> from <a href="appb.xhtml#appblist4">Listing B-4</a>.</p>&#13;
<p class="listing1" id="appblist11"><em>Listing B-11:</em> elfinject.c<em>: overwriting the</em> <span class="codeitalic">PT_NOTE</span> <em>program header</em></p>&#13;
<p class="programs">  int<br/>  rewrite_code_segment(elf_data_t *elf, inject_data_t *inject)<br/>  {<br/><span class="ent">➊</span>   inject-&gt;phdr.p_type   = PT_LOAD;          /* type */<br/><span class="ent">➋</span>   inject-&gt;phdr.p_offset = inject-&gt;off;      /* file offset to start of segment */<br/>    inject-&gt;phdr.p_vaddr   = inject-&gt;secaddr;  /* virtual address to load segment at */<br/>    inject-&gt;phdr.p_paddr   = inject-&gt;secaddr;  /* physical address to load segment at */<br/>    inject-&gt;phdr.p_filesz  = inject-&gt;len;      /* byte size in file */<br/>    inject-&gt;phdr.p_memsz   = inject-&gt;len;      /* byte size in memory */<br/><span class="ent">➌</span>   inject-&gt;phdr.p_flags  = PF_R | PF_X;      /* flags */<br/><span class="ent">➍</span>   inject-&gt;phdr.p_align  = 0x1000;           /* alignment in memory and file */<br/><br/><span class="ent">➎</span>   if(write_phdr(elf, inject) &lt; 0) {<br/>       return -1;<br/>    }<br/><br/>    return 0;<br/>  }</p>&#13;
<p class="indent">Recall that the previously located <span class="literal">PT_NOTE</span> program header is stored in the <span class="literal">inject-&gt;phdr</span> field. Thus, <span class="literal">rewrite_code_segment</span> starts by updating the necessary fields in this program header: making it loadable by setting <span class="literal">p_type</span> to <span class="literal">PT_LOAD</span> <span class="ent">➊</span>; setting the file offset, memory addresses, and size of the injected code segment <span class="ent">➋</span>; making the segment readable and executable <span class="ent">➌</span>; and setting the proper alignment <span class="ent">➍</span>. These are the same modifications shown in the high-level overview in <a href="ch07.xhtml#ch07fig2">Figure 7-2</a>.</p>&#13;
<p class="indent">After making the necessary modifications, <span class="literal">rewrite_code_segment</span> calls another function called <span class="literal">write_phdr</span> to write the modified program header back to the ELF binary <span class="ent">➎</span>. <a href="appb.xhtml#appblist12">Listing B-12</a> shows the code of <span class="literal">write_phdr</span>. The code is similar to the <span class="literal">write_shdr</span> function that writes a modified section header to file, which you already saw in <a href="appb.xhtml#appblist9">Listing B-9</a>, so I’ll focus on the important differences between <span class="literal">write_phdr</span> and <span class="literal">write_shdr</span>.</p>&#13;
<p class="listing1" id="appblist12"><span epub:type="pagebreak" id="page_409"/><em>Listing B-12:</em> elfinject.c<em>: writing the overwritten program header back to the ELF file</em></p>&#13;
<p class="programs">   int<br/>   write_phdr(elf_data_t *elf, inject_data_t *inject)<br/>   {<br/>     off_t off;<br/>     size_t n, phdr_size;<br/>     Elf32_Phdr *phdr_list32;<br/>     Elf64_Phdr *phdr_list64;<br/>     void *phdr_buf;<br/><br/><span class="ent">➊</span>   if(!gelf_update_phdr(elf-&gt;e, inject-&gt;pidx, &amp;inject-&gt;phdr)) {<br/>       fprintf(stderr, "Failed to update program header\n");<br/>       return -1;<br/>     }<br/><br/>     phdr_buf = NULL;<br/><span class="ent">➋</span>   if(elf-&gt;bits == 32) {<br/><span class="ent">➌</span>     phdr_list32 = elf32_getphdr(elf-&gt;e);<br/>       if(phdr_list32) {<br/><span class="ent">➍</span>        phdr_buf = &amp;phdr_list32[inject-&gt;pidx];<br/>          phdr_size = sizeof(Elf32_Phdr);<br/>       }<br/>     } else {<br/>       phdr_list64 = elf64_getphdr(elf-&gt;e);<br/>       if(phdr_list64) {<br/>         phdr_buf = &amp;phdr_list64[inject-&gt;pidx];<br/>         phdr_size = sizeof(Elf64_Phdr);<br/>       }<br/>     }<br/>     if(!phdr_buf) {<br/>       fprintf(stderr, "Failed to get program header\n");<br/>       return -1;<br/>     }<br/><br/><span class="ent">➎</span>   off = lseek(elf-&gt;fd, elf-&gt;ehdr.e_phoff + inject-&gt;pidx*elf-&gt;ehdr.e_phentsize, SEEK_SET);<br/>     if(off &lt; 0) {<br/>       fprintf(stderr, "lseek failed\n");<br/>       return -1;<br/>    }<br/><br/><span class="ent">➏</span>  n = write(elf-&gt;fd, phdr_buf, phdr_size);<br/>    if(n != phdr_size) {<br/>      fprintf(stderr, "Failed to write program header\n");<br/>      return -1;<br/>    }<br/><br/>    return 0;<br/>  }<span epub:type="pagebreak" id="page_410"/></p>&#13;
<p class="indent">As in the <span class="literal">write_shdr</span> function, <span class="literal">write_phdr</span> begins by making sure all modifications to the <span class="literal">GElf</span> representation of the program header are written back to the underlying native <span class="literal">Elf32_Phdr</span> or <span class="literal">Elf64_Phdr</span> data structure <span class="ent">➊</span>. To this end, <span class="literal">write_phdr</span> calls the <span class="literal">gelf_update_phdr</span> function to flush the changes to the underlying data structures. This function takes an ELF handle, the index of the modified program header, and a pointer to the updated <span class="literal">GElf_Phdr</span> representation of the program header. As usual for <span class="literal">GElf</span> functions, it returns nonzero on success and 0 on failure.</p>&#13;
<p class="indent">Next, <span class="literal">write_phdr</span> gets a reference to the native representation of the program header in question (an <span class="literal">Elf32_Phdr</span> or <span class="literal">Elf64_Phdr</span> structure depending on the ELF class) to write it to file <span class="ent">➋</span>. Again, this is similar to what you saw in the <span class="literal">write_shdr</span> function, except that <span class="literal">libelf</span> doesn’t allow you to directly get a pointer to a particular program header. Instead, you must first get a pointer to the start of the program header table <span class="ent">➌</span> and then index it to get a pointer to the updated program header itself <span class="ent">➍</span>. To get a pointer to the program header table, you use the <span class="literal">elf32_getphdr</span> or <span class="literal">elf64_getphdr</span> function, depending on the ELF class. They both return the pointer on success or <span class="literal">NULL</span> on failure.</p>&#13;
<p class="indent">Given the native representation of the overwritten ELF program header, all that remains now is to seek to the correct file offset <span class="ent">➎</span> and write the updated program header there <span class="ent">➏</span>. That completes all the mandatory steps for injecting a new code section into an ELF binary! The only remaining step is optional: modifying the ELF entry point to point into the injected code.</p>&#13;
<h3 class="h3" id="appb_11">B.11 Modifying the Entry Point</h3>&#13;
<p class="noindent"><a href="appb.xhtml#appblist13">Listing B-13</a> shows the <span class="literal">rewrite_entry_point</span> function, which takes care of modifying the ELF entry point. It’s called only if requested by the user in step <span class="ent">➑</span> in <a href="appb.xhtml#appblist4">Listing B-4</a>.</p>&#13;
<p class="listing1" id="appblist13"><em>Listing B-13:</em> elfinject.c<em>: modifying the ELF entry point</em></p>&#13;
<p class="programs">   int<br/>   rewrite_entry_point(elf_data_t *elf, inject_data_t *inject)<br/>   {<br/><span class="ent">➊</span>   elf-&gt;ehdr.e_entry = inject-&gt;phdr.p_vaddr + inject-&gt;entry;<br/><span class="ent">➋</span>   return write_ehdr(elf);<br/>  }</p>&#13;
<p class="indent">Recall that <span class="literal">elfinject</span> allows the user to optionally specify a new entry point for the binary by giving a command line argument that contains an offset into the injected code. The offset specified by the user is saved in the <span class="literal">inject-&gt;entry</span> field. If the offset is negative, it means that the entry point should remain unchanged, in which case <span class="literal">rewrite_entry_point</span> is never called. <span epub:type="pagebreak" id="page_411"/>Thus, if <span class="literal">rewrite_entry_point</span> <em>is</em> called, <span class="literal">inject-&gt;entry</span> is guaranteed to be nonnegative.</p>&#13;
<p class="indent">The first thing <span class="literal">rewrite_entry_point</span> does is update the <span class="literal">e_entry</span> field in the ELF executable header <span class="ent">➊</span>, previously loaded into the <span class="literal">elf-&gt;ehdr</span> field. Next, it computes the new entry point address by adding the relative offset into the injected code (<span class="literal">inject-&gt;entry</span>) to the base address of the loadable segment that contains the injected code (<span class="literal">inject-&gt;phdr.p_vaddr</span>). Then, <span class="literal">rewrite_entry_point</span> calls the dedicated function <span class="literal">write_ehdr</span> <span class="ent">➋</span>, which writes the modified executable header back to the ELF file.</p>&#13;
<p class="indent">The code of <span class="literal">write_ehdr</span> is analogous to the <span class="literal">write_shdr</span> function shown in <a href="appb.xhtml#appblist9">Listing B-9</a>. The only difference is that it uses <span class="literal">gelf_update_ehdr</span> instead of <span class="literal">gelf_update_shdr</span> and <span class="literal">elf32_getehdr</span>/<span class="literal">elf64_getehdr</span> instead of <span class="literal">elf32_getshdr</span>/<span class="literal">elf64_getshdr</span>.</p>&#13;
<p class="indent">You now know how to use <span class="literal">libelf</span> to inject code into a binary, overwrite a section and program header to accommodate the new code, and modify the ELF entry point to jump to the injected code when the binary is loaded! Modifying the entry point is optional, and you may not always want to use the injected code immediately when the binary starts. Sometimes, you’ll want to use the injected code for different reasons, such as substituting a replacement for an existing function. <a href="ch07.xhtml#ch07_4">Section 7.4</a> discusses some techniques for transferring control to the injected code, other than modifying the ELF entry point.<span epub:type="pagebreak" id="page_412"/></p>&#13;
</div></body></html>