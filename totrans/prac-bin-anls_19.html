<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="appb"><span epub:type="pagebreak" id="page_392"/><span class="big">B</span><br/>IMPLEMENTING PT_NOTE OVERWRITING USING LIBELF</h2>&#13;
<p class="startpara">In <a href="ch07.xhtml#ch07">Chapter 7</a>, you learned how to inject a code section by overwriting the <code>PT_NOTE</code> segment at a high level. Here, you’ll see how the <code>elfinject</code> tool you’ll find on the virtual machine implements this technique. In the process of describing the <code>elfinject</code> source, you’ll also learn about <code>libelf</code>, a popular open source library for manipulating the contents of ELF binaries.</p>&#13;
<p class="indent">I’ll focus on the parts of the code that implement the steps from <a href="ch07.xhtml#ch07fig2">Figure 7-2</a> (<a href="ch07.xhtml#page_170">page 170</a>) using <code>libelf</code>, leaving out some parts of the code that are straightforward and don’t involve <code>libelf</code>. To learn more, you can find the rest of the <code>elfinject</code> source on the virtual machine located in the code directory for <a href="ch07.xhtml#ch07">Chapter 7</a>.</p>&#13;
<p class="indent">Be sure to read <a href="ch07.xhtml#ch07_3_2">Section 7.3.2</a> before reading this appendix, as knowing the inputs and outputs that <code>elfinject</code> expects will make the code easier to follow.</p>&#13;
<p class="indent">In this discussion, I’ll use only the parts of the <code>libelf</code> API that <code>elfinject</code> uses to give you a good working understanding of the essentials of <code>libelf</code>. <span epub:type="pagebreak" id="page_393"/>For more details, refer to the excellent <code>libelf</code> documentation or to “<code>libelf</code> by Example” by Joseph Koshy.<sup><a id="appbfn_1a" href="footnote.xhtml#appbfn_1">1</a></sup></p>&#13;
<h3 class="h3" id="appb_1">B.1 Required Headers</h3>&#13;
<p class="noindent">To parse ELF files, <code>elfinject</code> uses the popular open source library <code>libelf</code>, which is preinstalled on the virtual machine and is available as a package for most Linux distributions. To use <code>libelf</code>, you need to include a few header files, as shown in <a href="appb.xhtml#appblist1">Listing B-1</a>. You also need to link against <code>libelf</code> by providing the <code>-lelf</code> option to the linker.</p>&#13;
<p class="listing1" id="appblist1"><em>Listing B-1:</em> elfinject.c<em>:</em> <span class="codeitalic">libelf</span> <em>headers</em></p>&#13;
<pre><span class="ent">➊</span> #include &lt;libelf.h&gt;<br/><span class="ent">➋</span> #include &lt;gelf.h&gt;</pre>&#13;
<p class="indent">For brevity, <a href="appb.xhtml#appblist1">Listing B-1</a> doesn’t show all the standard C/C++ headers <code>elfinject</code> uses, but only two related to <code>libelf</code>. The main one is <em>libelf.h</em> <span class="ent">➊</span>, which provides access to all of <code>libelf</code>’s data structures and API functions. The other is <em>gelf.h</em> <span class="ent">➋</span>, which provides access to <code>GElf</code>, a supporting API that provides easier access to some of <code>libelf</code>’s functionality. <code>GElf</code> allows you to access ELF files in a way that’s transparent to the ELF class and bit width (32-bit versus 64-bit) of the file. The benefit of this will become clear as you see more of the <code>elfinject</code> code.</p>&#13;
<h3 class="h3" id="appb_2">B.2 Data Structures Used in elfinject</h3>&#13;
<p class="noindent"><a href="appb.xhtml#appblist2">Listing B-2</a> shows two data structures that are central to <code>elfinject</code>. The rest of the code uses these data structures to manipulate the ELF file and the code to inject.</p>&#13;
<p class="listing1" id="appblist2"><em>Listing B-2:</em> elfinject.c<em>:</em> <span class="codeitalic">elfinject</span> <em>data structures</em></p>&#13;
<pre><span class="ent">➊</span> typedef struct {<br/>     int fd;          /* file descriptor */<br/>     Elf *e;          /* main elf descriptor */<br/>     int bits;        /* 32-bit or 64-bit */<br/>     GElf_Ehdr ehdr;  /* executable header */<br/>   } elf_data_t;<br/><br/><span class="ent">➋</span> typedef struct {<br/>     size_t pidx;     /* index of program header to overwrite */<br/>     GElf_Phdr phdr;  /* program header to overwrite */<br/>     size_t sidx;     /* index of section header to overwrite */<br/>     Elf_Scn *scn;    /* section to overwrite */<br/><span epub:type="pagebreak" id="page_394"/>     GElf_Shdr shdr;  /* section header to overwrite */<br/>     off_t shstroff;  /* offset to section name to overwrite */<br/>     char *code;      /* code to inject */<br/>     size_t len;      /* number of code bytes */<br/>     long entry;      /* code buffer offset to entry point (-1 for none) */<br/>     off_t off;       /* file offset to injected code */<br/>     size_t secaddr;  /* section address for injected code */<br/>     char *secname;   /* section name for injected code */<br/>   } inject_data_t;</pre>&#13;
<p class="indent">The first data structure <code>elf_data_t</code> <span class="ent">➊</span> keeps track of data needed to manipulate the ELF binary in which the new code section is to be injected. It contains a file descriptor for the ELF file (<code>fd</code>), a <code>libelf</code> handle to the file, an integer denoting the binary’s bit width (<code>bits</code>), and a <code>GElf</code> handle to the binary’s executable header. I’ll omit the standard C code that opens <code>fd</code>, so from this point on, consider <code>fd</code> to be opened for reading and writing. I will show the code that opens the <code>libelf</code> and <code>GElf</code> handles shortly.</p>&#13;
<p class="indent">The <code>inject_data_t</code> structure <span class="ent">➋</span> tracks information about the code to inject and where and how to inject it in the binary. First, it contains data on which parts of the binary need to be modified to inject the new code. This data includes the index (<code>pidx</code>) and <code>GElf</code> handle (<code>phdr</code>) of the <code>PT_NOTE</code> program header to overwrite with the injected header. It also includes the index (<code>sidx</code>) and <code>libelf</code> and <code>GElf</code> handles (<code>scn</code> and <code>shdr</code>, respectively) of the section to overwrite as well as the file offset to the section name in the string table (<code>shstroff</code>) to change to a new name, like <code>.injected</code>.</p>&#13;
<p class="indent">Then comes the actual code to inject in the form of a buffer (<code>code</code>) and an integer describing the length of that buffer (<code>len</code>). This code is given by the <code>elfinject</code> user, so let’s consider <code>code</code> and <code>len</code> to be set from this point on. The <code>entry</code> field is an offset within the <code>code</code> buffer, pointing to the code location that should become the new entry point for the binary. If there’s no new entry point, then <code>entry</code> is set to <code>-1</code> to indicate this.</p>&#13;
<p class="indent">The <code>off</code> field is the file offset in the binary where the new code should be injected. This will point to the end of the binary because that’s where <code>elfinject</code> places the new code, as shown in <a href="ch07.xhtml#ch07fig2">Figure 7-2</a>. Finally, <code>secaddr</code> is the load address for the new code section, and <code>secname</code> is the name of the injected section. You can consider all the fields from <code>entry</code> to <code>secname</code> to be set as well, as they’re all user specified except for <code>off</code>, which <code>elfinject</code> computes when it loads the binary.</p>&#13;
<h3 class="h3" id="appb_3">B.3 Initializing libelf</h3>&#13;
<p class="noindent">At this point, let’s skip past the <code>elfinject</code> initialization code and assume that all initialization succeeded: the user arguments are parsed, a file descriptor to the host binary is opened, and the inject file is loaded into the code buffer in a <code>struct inject_data_t</code>. All of this initialization stuff takes place in the <code>main</code> function of <code>elfinject</code>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_395"/>After that, <code>main</code> passes control to a function called <code>inject_code</code>, which is the starting point for the actual code injection. Let’s take a look at <a href="appb.xhtml#appblist3">Listing B-3</a>, which shows the part of <code>inject_code</code> that opens the given ELF binary in <code>libelf</code>. Keep in mind that function names starting with <code>elf_</code> are <code>libelf</code> functions and names starting with <code>gelf_</code> are <code>GElf</code> functions.</p>&#13;
<p class="listing1" id="appblist3"><em>Listing B-3:</em> elfinject.c<em>:</em> <span class="codeitalic">inject_code</span> <em>function</em></p>&#13;
<pre>   int<br/>   inject_code(int fd, inject_data_t *inject)<br/>   {<br/><span class="ent">➊</span>  elf_data_t elf;<br/>    int ret;<br/>    size_t n;<br/><br/>    elf.fd = fd;<br/>    elf.e = NULL;<br/><br/><span class="ent">➋</span>   if(elf_version(EV_CURRENT) == EV_NONE) {<br/>      fprintf(stderr, "Failed to initialize libelf\n");<br/>      goto fail;<br/>    }<br/><br/>     /* Use libelf to read the file, but do writes manually */<br/><span class="ent">➌</span>   elf.e = elf_begin(elf.fd, ELF_C_READ, NULL);<br/>     if(!elf.e) {<br/>       fprintf(stderr, "Failed to open ELF file\n");<br/>       goto fail;<br/>     }<br/><br/><span class="ent">➍</span>   if(elf_kind(elf.e) != ELF_K_ELF) {<br/>        fprintf(stderr, "Not an ELF executable\n");<br/>        goto fail;<br/>     }<br/><br/><span class="ent">➎</span>   ret = gelf_getclass(elf.e);<br/>     switch(ret) {<br/>     case ELFCLASSNONE:<br/>       fprintf(stderr, "Unknown ELF class\n");<br/>       goto fail;<br/>     case ELFCLASS32:<br/>       elf.bits = 32;<br/>       break;<br/>     default:<br/>       elf.bits = 64;<br/>       break;<br/>     }<br/><br/>   ...</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_396"/>An important local variable in the <code>inject_code</code> function, <code>elf</code> <span class="ent">➊</span> is an instance of the <code>elf_data_t</code> struct type defined previously, and it’s used to store all the important information about the loaded ELF binary to pass to other functions.</p>&#13;
<p class="indent">Before using any other <code>libelf</code> API functions, you must call <code>elf_version</code> <span class="ent">➋</span>, which takes the version number of the ELF specification you want to use as its only parameter. If the version is not supported, <code>libelf</code> will complain by returning the constant <code>EV_NONE</code>, in which case <code>inject_code</code> gives up and reports an error initializing <code>libelf</code>. If <code>libelf</code> doesn’t complain, it means the ELF version requested is supported, and it’s safe to make other <code>libelf</code> calls to load and parse the binary.</p>&#13;
<p class="indent">At the moment, all standard ELF binaries are formatted according to major version 1 of the specification, so this is the only legal value you can pass to <code>elf_version</code>. By convention, instead of passing a literal “1” to <code>elf_version</code>, you pass the constant value <code>EV_CURRENT</code>. Both <code>EV_NONE</code> and <code>EV_CURRENT</code> are specified in <em>elf.h</em>, which is the header that contains all the constants and data structures related to the ELF format, not <em>libelf.h</em>. If there’s a major revision of the ELF format, <code>EV_CURRENT</code> will be incremented to the next version on systems that use the new ELF version.</p>&#13;
<p class="indent">After <code>elf_version</code> returns successfully, it’s safe to start loading and parsing the binary to inject the new code into. The first step is to call <code>elf_begin</code> <span class="ent">➌</span>, which opens the ELF file and returns a handle to it of type <code>Elf*</code>. You can pass this handle to other <code>libelf</code> functions to perform operations on the ELF file.</p>&#13;
<p class="indent">The <code>elf_begin</code> function takes three parameters: an open file descriptor for the ELF file, a constant that indicates whether to open the file for reading or writing, and a pointer to an <code>Elf</code> handle. In this case, the file descriptor is <code>fd</code>, and <code>inject_code</code> passes the constant <code>ELF_C_READ</code> to indicate that it’s interested only in using <code>libelf</code> to read the ELF binary. For the final parameter (the <code>Elf</code> handle), <code>inject_code</code> passes <code>NULL</code> so that <code>libelf</code> automatically allocates and returns a handle.</p>&#13;
<p class="indent">Instead of <code>ELF_C_READ</code>, you can also pass <code>ELF_C_WRITE</code> or <code>ELF_C_RDWR</code> to indicate that you want to use <code>libelf</code> to write modifications to an ELF binary, or for a combination of read and write operations. For simplicity, <code>elfinject</code> only uses <code>libelf</code> to parse the ELF file. To write back any modifications, it circumvents <code>libelf</code> and simply uses the file descriptor <code>fd</code> directly.</p>&#13;
<p class="indent">After opening an ELF with <code>libelf</code>, you’ll typically pass the opened <code>Elf</code> handle to <code>elf_kind</code> to figure out what kind of ELF you’re dealing with <span class="ent">➍</span>. In this case, <code>inject_code</code> compares <code>elf_kind</code>’s return value to the constant <code>ELF_K_ELF</code> to verify that the ELF file is an executable. The other possible return values are <code>ELF_K_AR</code> for ELF archives or <code>ELF_K_NULL</code> if an error occurred. In both cases, <code>inject_code</code> cannot perform the code injection, so it returns with an error.</p>&#13;
<p class="indent">Next, <code>inject_code</code> uses a <code>GElf</code> function called <code>gelf_getclass</code> to find out the “class” of the ELF binary <span class="ent">➎</span>. This indicates whether the ELF is 32-bit (<code>ELFCLASS32</code>) or 64-bit (<code>ELFCLASS64</code>). In case of error, <code>gelf_getclass</code> returns <code>ELFCLASSNONE</code>. The <code>ELFCLASS*</code> constants are defined in <em>elf.h</em>. For now, <span epub:type="pagebreak" id="page_397"/><code>inject_code</code> just stores the bit width of the binary (32 or 64) in the <code>bits</code> field of the <code>elf</code> structure. Knowing the bit width is necessary when parsing the ELF binary.</p>&#13;
<p class="indent">That covers initializing <code>libelf</code> and retrieving basic information about the binary. Now let’s consider the rest of the <code>inject_code</code> function, shown in <a href="appb.xhtml#appblist4">Listing B-4</a>.</p>&#13;
<p class="listing1" id="appblist4"><em>Listing B-4:</em> elfinject.c<em>:</em> <span class="codeitalic">inject_code</span> <em>function (continued)</em></p>&#13;
<pre>   ...<br/>   <br/><span class="ent">➊</span>  if(!gelf_getehdr(elf.e, &amp;elf.ehdr)) {<br/>      fprintf(stderr, "Failed to get executable header\n");<br/>      goto fail;<br/>   }<br/>   <br/>   /* Find a rewritable program header */<br/><span class="ent">➋</span>  if(find_rewritable_segment(&amp;elf, inject) &lt; 0) {<br/>     goto fail;<br/>   }<br/>   <br/>   /* Write the injected code to the binary */<br/><span class="ent">➌</span>  if(write_code(&amp;elf, inject) &lt; 0) {<br/>     goto fail;<br/>   }<br/>   <br/>   /* Align code address so it's congruent to the file offset modulo 4096 */<br/><span class="ent">➍</span>  n = (inject-&gt;off % 4096) - (inject-&gt;secaddr % 4096);<br/>   inject-&gt;secaddr += n;<br/>   <br/>   /* Rewrite a section for the injected code */<br/><span class="ent">➎</span>  if((rewrite_code_section(&amp;elf, inject) &lt; 0)<br/>        || <span class="ent">➏</span>(rewrite_section_name(&amp;elf, inject) &lt; 0)) {<br/>       goto fail;<br/>   }<br/>   <br/>   /* Rewrite a segment for the added code section */<br/><span class="ent">➐</span>  if(rewrite_code_segment(&amp;elf, inject) &lt; 0) {<br/>       goto fail;<br/>   }<br/>   <br/>   /* Rewrite entry point if requested */<br/><span class="ent">➑</span>  if((inject-&gt;entry &gt;= 0) &amp;&amp; (rewrite_entry_point(&amp;elf, inject) &lt; 0)) {<br/>     goto fail;<br/>   }<br/>   <br/>   ret = 0;<br/>   goto cleanup;<br/><span epub:type="pagebreak" id="page_398"/>&#13;
   fail:<br/>     ret = -1;<br/>   <br/>   cleanup:<br/>     if(elf.e) {<br/><span class="ent">➒</span>      elf_end(elf.e);<br/>     }<br/>   <br/>     return ret;<br/>   }</pre>&#13;
<p class="indent">As you can see, the remainder of the <code>inject_code</code> function consists of several major steps, which correspond to the steps outlined in <a href="ch07.xhtml#ch07fig2">Figure 7-2</a> as well as some extra low-level steps not shown in the figure:</p>&#13;
<p class="bull">• Retrieve the binary’s executable header <span class="ent">➊</span>, needed for adjusting the entry point later.</p>&#13;
<p class="bull">• Find the <code>PT_NOTE</code> segment <span class="ent">➋</span> to overwrite and fail if there is no suitable segment.</p>&#13;
<p class="bull">• Write the injected code to the end of the binary <span class="ent">➌</span>.</p>&#13;
<p class="bull">• Adjust the injected section’s load address to meet alignment requirements <span class="ent">➍</span>.</p>&#13;
<p class="bull">• Overwrite the <code>.note.ABI-tag</code> section header <span class="ent">➎</span> with a header for the new injected section.</p>&#13;
<p class="bull">• Update the name of the section whose header was overwritten <span class="ent">➏</span>.</p>&#13;
<p class="bull">• Overwrite the <code>PT_NOTE</code> program header <span class="ent">➐</span>.</p>&#13;
<p class="bull">• Adjust the binary entry point if requested by the user <span class="ent">➑</span>.</p>&#13;
<p class="bull">• Clean up the <code>Elf</code> handle by calling <code>elf_end</code> <span class="ent">➒</span>.</p>&#13;
<p class="bull66">I’ll go over these steps in more detail next.</p>&#13;
<h3 class="h3" id="appb_4">B.4 Getting the Executable Header</h3>&#13;
<p class="noindent">In step <span class="ent">➊</span> in <a href="appb.xhtml#appblist4">Listing B-4</a>, <code>elfinject</code> gets the binary’s executable header. Recall from <a href="ch02.xhtml#ch02">Chapter 2</a> that the executable header contains the file offsets and sizes of these tables. The executable header also contains the binary’s entry point address, which <code>elfinject</code> modifies if requested by the user.</p>&#13;
<p class="indent">To get the ELF executable header, <code>elfinject</code> uses the <code>gelf_getehdr</code> function. This is a <code>GElf</code> function that returns an ELF class-agnostic representation of the executable header. The format of the executable header differs slightly between 32-bit and 64-bit binaries, but <code>GElf</code> hides these differences so that you don’t have to worry about them. It’s also possible to get the executable header using only pure <code>libelf</code>, without <code>GElf</code>. However, in that case, <span epub:type="pagebreak" id="page_399"/>you have to manually call <code>elf32_getehdr</code> or <code>elf64_getehdr</code> depending on the ELF class.</p>&#13;
<p class="indent">The <code>gelf_getehdr</code> function takes two parameters: the <code>Elf</code> handle and a pointer to a <code>GElf_Ehdr</code> structure where <code>GElf</code> can store the executable header. If all is well, <code>gelf_getehdr</code> returns a nonzero value. If there’s an error, it returns 0 and sets <code>elf_errno</code>, an error code that you can read by calling <code>libelf</code>’s <code>elf_errno</code> function. This behavior is standard for all <code>GElf</code> functions.</p>&#13;
<p class="indent">To convert <code>elf_errno</code> to a human-readable error message, you can use the <code>elf_errmsg</code> function, but <code>elfinject</code> doesn’t do this. The <code>elf_errmsg</code> function takes the return value of <code>elf_errno</code> as input and returns a <code>const char*</code> pointing to the appropriate error string.</p>&#13;
<h3 class="h3" id="appb_5">B.5 Finding the PT_NOTE Segment</h3>&#13;
<p class="noindent">After getting the executable header, <code>elfinject</code> loops over all the program headers in the binary to check whether the binary has a <code>PT_NOTE</code> segment that’s safe to overwrite (step <span class="ent">➋</span> in <a href="appb.xhtml#appblist4">Listing B-4</a>). All of this functionality is implemented in a separate function called <code>find_rewritable_segment</code>, shown in <a href="appb.xhtml#appblist5">Listing B-5</a>.</p>&#13;
<p class="listing1" id="appblist5"><em>Listing B-5:</em> elfinject.c<em>: finding the</em> <span class="codeitalic">PT_NOTE</span> <em>program header</em></p>&#13;
<pre>   int<br/>   find_rewritable_segment(elf_data_t *elf, inject_data_t *inject)<br/>   {<br/>     int ret;<br/>     size_t i, n;<br/><br/><span class="ent">➊</span>  ret = elf_getphdrnum(elf-&gt;e, &amp;n);<br/>    if(ret != 0) {<br/>       fprintf(stderr, "Cannot find any program headers\n");<br/>       return -1;<br/>   }<br/><br/><span class="ent">➋</span>  for(i = 0; i &lt; n; i++) {<br/><span class="ent">➌</span>    if(!gelf_getphdr(elf-&gt;e, i, &amp;inject-&gt;phdr)) {<br/>        fprintf(stderr, "Failed to get program header\n");<br/>        return -1;<br/>    }<br/><br/><span class="ent">➍</span>  switch(inject-&gt;phdr.p_type) {<br/>    case <span class="ent">➎</span>PT_NOTE:<br/>      <span class="ent">➏</span>inject-&gt;pidx = i;<br/>      return 0;<br/>    default:<br/>      break;<br/>    }<br/>   }<br/><span class="ent">➐</span> fprintf(stderr, "Cannot find segment to rewrite\n");<br/>   return -1;<br/>  }</pre>&#13;
<p class="indent">As <a href="appb.xhtml#appblist5">Listing B-5</a> shows, <code>find_rewritable_segment</code> takes two arguments: an <code>elf_data_t*</code> called <code>elf</code> and an <code>inject_data_t*</code> called <code>inject</code>. Recall that these are custom data types, defined in <a href="appb.xhtml#appblist2">Listing B-2</a>, which contain all the relevant information about the ELF binary and the inject.</p>&#13;
<p class="indent">To find the <code>PT_NOTE</code> segment, <code>elfinject</code> first looks up the number of program headers that the binary contains <span class="ent">➊</span>. This is done using a <code>libelf</code> function called <code>elf_getphdrnum</code>, which takes two arguments: the <code>Elf</code> handle and a pointer to a <code>size_t</code> integer where the number of program headers will be stored. If the return value is nonzero, it means an error occurred, and <code>elfinject</code> gives up because it cannot access the program header table. If there were no errors, <code>elf_getphdrnum</code> will have stored the number of program headers in the <code>size_t</code> called <code>n</code> in <a href="appb.xhtml#appblist5">Listing B-5</a>.</p>&#13;
<p class="indent">Now that <code>elfinject</code> knows the number of program headers <code>n</code>, it loops over each program header to find one of type <code>PT_NOTE</code> <span class="ent">➋</span>. To access each program header, <code>elfinject</code> uses the <code>gelf_getphdr</code> function <span class="ent">➌</span>, which allows you to access program headers in an ELF class-agnostic way. Its arguments are the <code>Elf</code> handle, the index number <code>i</code> of the program header to get, and a pointer to a <code>GElf_Phdr</code> struct (<code>inject-&gt;phdr</code> in this case) to store the program header in. As is usual for <code>GElf</code>, a nonzero return value indicates success, while return value 0 indicates failure.</p>&#13;
<p class="indent">After this step completes, <code>inject-&gt;phdr</code> contains the <code>i</code>-th program header. All that remains is to inspect the program header’s <code>p_type</code> field <span class="ent">➍</span> and check whether the type is <code>PT_NOTE</code> <span class="ent">➎</span>. If it is, <code>elfinject</code> stores the program header index in the <code>inject-&gt;pidx</code> field <span class="ent">➏</span>, and the <code>find_rewritable_segment</code> function returns successfully.</p>&#13;
<p class="indent">If, after looping over all program headers, <code>elfinject</code> failed to find a header of type <code>PT_NOTE</code>, it reports an error <span class="ent">➐</span> and exits without modifying the binary.</p>&#13;
<h3 class="h3" id="appb_6">B.6 Injecting the Code Bytes</h3>&#13;
<p class="noindent">After locating the overwritable <code>PT_NOTE</code> segment, it’s time to append the injected code to the binary (step <span class="ent">➌</span> in <a href="appb.xhtml#appblist4">Listing B-4</a>). Let’s look at the function that performs the actual inject, which is called <code>write_code</code>, as shown in <a href="appb.xhtml#appblist6">Listing B-6</a>.</p>&#13;
<p class="listing1" id="appblist6"><em>Listing B-6:</em> elfinject.c<em>: appending the injected code to the binary</em></p>&#13;
<pre>   int<br/>   write_code(elf_data_t *elf, inject_data_t *inject)<br/>   {<br/>     off_t off;<br/>     size_t n;<br/><span class="ent">➊</span>   off = lseek(elf-&gt;fd, 0, SEEK_END);<br/>     if(off &lt; 0) {<br/>       fprintf(stderr, "lseek failed\n");<br/>       return -1;<br/>   }<br/><br/><span class="ent">➋</span>  n = write(elf-&gt;fd, inject-&gt;code, inject-&gt;len);<br/>    if(n != inject-&gt;len) {<br/>      fprintf(stderr, "Failed to inject code bytes\n");<br/>      return -1;<br/>   }<br/><span class="ent">➌</span>  inject-&gt;off = off;<br/><br/>    return 0;<br/>  }</pre>&#13;
<p class="indent">Like the <code>find_rewritable_segment</code> function you saw in the previous section, <code>write_code</code> takes the <code>elf_data_t*</code> called <code>elf</code> and the <code>inject_data_t*</code> called <code>inject</code> as its arguments. The <code>write_code</code> function doesn’t involve <code>libelf</code>; it only uses standard C file operations on <code>elf-&gt;fd</code>, the file descriptor of the opened ELF binary.</p>&#13;
<p class="indent">First, <code>write_code</code> seeks to the end of the binary <span class="ent">➊</span>. It then appends the injected code bytes there <span class="ent">➋</span> and saves the byte offset where the code bytes were written into the <code>inject-&gt;off</code> field of the <code>inject</code> data structure <span class="ent">➌</span>.</p>&#13;
<p class="indent">Now that the code injection is done, all that remains is to update a section and program header (and optionally the binary entry point) to describe the new injected code section and ensure it gets loaded when the binary executes.</p>&#13;
<h3 class="h3" id="appb_7">B.7 Aligning the Load Address for the Injected Section</h3>&#13;
<p class="noindent">With the injected code bytes appended to the end of the binary, it’s almost time to overwrite a section header to point to those injected bytes. The ELF specification places certain requirements on the addresses of loadable segments and, by extension, the sections they contain. Specifically, the ELF standard requires that for each loadable segment, <code>p_vaddr</code> is congruent to <code>p_offset</code> modulo the page size, which is 4,096 bytes. The following equation summarizes this requirement:</p>&#13;
<p class="center">(<em>p</em>_<em>vaddr</em> mod 4096) =  (<em>p</em>_<em>offset</em> mod 4096)</p>&#13;
<p class="indent">Similarly, the ELF standard requires that <code>p_vaddr</code> be congruent to <code>p_offset</code> modulo <code>p_align</code>. Therefore, before overwriting the section header, <code>elfinject</code> adjusts the user-specified memory address for the injected section so that it meets these requirements. <a href="appb.xhtml#appblist7">Listing B-7</a> shows the code that aligns the address, which is the same code shown in step <span class="ent">➍</span> in <a href="appb.xhtml#appblist4">Listing B-4</a>.</p>&#13;
<p class="listing1" id="appblist7"><span epub:type="pagebreak" id="page_400"/><em>Listing B-7:</em> elfinject.c<em>: aligning the load address for the injected section</em></p>&#13;
<pre>    /* Align code address so it's congruent to the file offset modulo 4096 */<br/><span class="ent">➊</span>  n = (inject-&gt;off % 4096) - (inject-&gt;secaddr % 4096);<br/><span class="ent">➋</span>  inject-&gt;secaddr += n;</pre>&#13;
<p class="indent">The alignment code in <a href="appb.xhtml#appblist7">Listing B-7</a> consists of two steps. First, it computes the difference <code>n</code> between the injected code’s file offset modulo 4096 and the section address modulo 4096 <span class="ent">➊</span>. The ELF specification requires that the offset and address are congruent modulo 4096 in which case <code>n</code> will be zero. To ensure correct alignment, <code>elfinject</code> adds <code>n</code> to the section address so that the difference with the file offset becomes zero modulo 4096 if it wasn’t already <span class="ent">➋</span>.</p>&#13;
<h3 class="h3" id="appb_8">B.8 Overwriting the .note.ABI-tag Section Header</h3>&#13;
<p class="noindent">Now that the address for the injected section is known, <code>elfinject</code> moves on to overwriting the section header. Recall that it overwrites the <code>.note.ABI-tag</code> section header that’s part of the <code>PT_NOTE</code> segment. <a href="appb.xhtml#appblist8">Listing B-8</a> shows the function that handles the overwrite, called <code>rewrite_code_section</code>. It’s called in step <span class="ent">➎</span> in <a href="appb.xhtml#appblist4">Listing B-4</a>.</p>&#13;
<p class="listing1" id="appblist8"><em>Listing B-8:</em> elfinject.c<em>: overwriting the</em> <span class="codeitalic">.note.ABI-tag</span> <em>section header</em></p>&#13;
<pre>  int<br/>  rewrite_code_section(elf_data_t *elf, inject_data_t *inject)<br/>  {<br/>    Elf_Scn *scn;<br/>    GElf_Shdr shdr;<br/>    char *s;<br/>    size_t shstrndx;<br/><br/><span class="ent">➊</span>   if(elf_getshdrstrndx(elf-&gt;e, &amp;shstrndx) &lt; 0) {<br/>      fprintf(stderr, "Failed to get string table section index\n");<br/>      return -1;<br/>    }<br/><br/>    scn = NULL;<br/><span class="ent">➋</span>   while((scn = elf_nextscn(elf-&gt;e, scn))) {<br/><span class="ent">➌</span>     if(!gelf_getshdr(scn, &amp;shdr)) {<br/>        fprintf(stderr, "Failed to get section header\n");<br/>        return -1;<br/>       }<br/><span class="ent">➍</span>     s = elf_strptr(elf-&gt;e, shstrndx, shdr.sh_name);<br/>      if(!s) {<br/>        fprintf(stderr, "Failed to get section name\n");<br/>        return -1;<br/>      }<br/><span epub:type="pagebreak" id="page_401"/>&#13;
<span class="ent">➎</span>     if(!strcmp(s, ".note.ABI-tag")) {<br/><span class="ent">➏</span>       shdr.sh_name      = shdr.sh_name;              /* offset into string table */<br/>        shdr.sh_type      = SHT_PROGBITS;               /* type */<br/>        shdr.sh_flags     = SHF_ALLOC | SHF_EXECINSTR;  /* flags */<br/>        shdr.sh_addr      = inject-&gt;secaddr;            /* address to load section at */<br/>        shdr.sh_offset    = inject-&gt;off;                /* file offset to start of section */<br/>        shdr.sh_size      = inject-&gt;len;                /* size in bytes */<br/>        shdr.sh_link      = 0;                          /* not used for code section */<br/>        shdr.sh_info      = 0;                          /* not used for code section */<br/>        shdr.sh_addralign = 16;                         /* memory alignment */<br/>        shdr.sh_entsize   = 0                           /* not used for code section */<br/><br/><span class="ent">➐</span>       inject-&gt;sidx = elf_ndxscn(scn);<br/>        inject-&gt;scn = scn;<br/>        memcpy(&amp;inject-&gt;shdr, &amp;shdr, sizeof(shdr));<br/><br/><span class="ent">➑</span>       if(write_shdr(elf, scn, &amp;shdr, elf_ndxscn(scn)) &lt; 0) {<br/>             return -1;<br/>        }<br/><br/><span class="ent">➒</span>       if(reorder_shdrs(elf, inject) &lt; 0) {<br/>             return -1;<br/>        }<br/><br/>        break;<br/>      }<br/>    }<br/><span class="ent">➓</span>   if(!scn) {<br/>      fprintf(stderr, "Cannot find section to rewrite\n");<br/>      return -1;<br/>     }<br/><br/>     return 0;<br/>   }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_402"/>To find the <code>.note.ABI-tag</code> section header to overwrite, <code>rewrite_code _section</code> loops over all section headers and inspects the section names. Recall from <a href="ch02.xhtml#ch02">Chapter 2</a> that section names are stored in a special section called <code>.shstrtab</code>. To read the section names, <code>rewrite_code_section</code> first needs the index number of the section header describing the <code>.shstrtab</code> section. To get this index, you can read the <code>e_shstrndx</code> field of the executable header, or you can use the the function <code>elf_getshdrstrndx</code> provided by <code>libelf</code>. <a href="appb.xhtml#appblist8">Listing B-8</a> uses the latter option <span class="ent">➊</span>.</p>&#13;
<p class="indent">The <code>elf_getshdrstrndx</code> function takes two parameters: an <code>Elf</code> handle and a pointer to a <code>size_t</code> integer to store the section index in. The function returns 0 on success or sets <code>elf_errno</code> and returns −1 on failure.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_403"/>After getting the index of <code>.shstrtab</code>, <code>rewrite_code_section</code> loops over all section headers, inspecting each one as it goes along. To loop over the section headers, it uses the <code>elf_nextscn</code> function <span class="ent">➋</span>, which takes an <code>Elf</code> handle (<code>elf-&gt;e</code>) and <code>Elf_Scn*</code> (<code>scn</code>) as input. <code>Elf_Scn</code> is a struct defined by <code>libelf</code> that describes an ELF section. Initially, <code>scn</code> is <code>NULL</code>, causing <code>elf_nextscn</code> to return a pointer to the first section header at index 1 in the section header table.<sup><a id="appbfn_2a" href="footnote.xhtml#appbfn_2">2</a></sup> This pointer becomes the new value of <code>scn</code> and is handled in the loop body. In the next loop iteration, <code>elf_nextscn</code> takes the existing <code>scn</code> and returns a pointer to the section at index 2, and so on. In this way, you can use <code>elf_nextscn</code> to iterate over all sections until it returns <code>NULL</code>, indicating that there is no next section.</p>&#13;
<p class="indent">The loop body handles each section <code>scn</code> returned by <code>elf_nextscn</code>. The first thing that’s done for each section is to get an ELF class-agnostic representation of the section’s header, using the <code>gelf_getshdr</code> function <span class="ent">➌</span>. It works just like <code>gelf_getphdr</code>, which you learned about in Section B.5, except that <code>gelf_getshdr</code> takes an <code>Elf_Scn*</code> and a <code>GElf_Shdr*</code> as input. If all goes well, <code>gelf_getshdr</code> populates the given <code>GElf_Shdr</code> with the section header of the given <code>Elf_Scn</code> and returns a pointer to the header. If something goes wrong, it will return <code>NULL</code>.</p>&#13;
<p class="indent">Using the <code>Elf</code> handle stored in <code>elf-&gt;e</code>, the index <code>shstrndx</code> of the <code>.shstrtab</code> section, and the index <code>shdr.sh_name</code> of the current section’s name in the string table, <code>elfinject</code> now gets a pointer to the string describing the name of the current section. To that end, it passes all the required information to the <code>elf_strptr</code> function <span class="ent">➍</span>, which returns the pointer, or <code>NULL</code> in case of error.</p>&#13;
<p class="indent">Next, <code>elfinject</code> compares the just-obtained section name to the string <code>".note.ABI-tag"</code> <span class="ent">➎</span>. If it matches, it means the current section is the <code>.note.ABI-tag</code> section, and <code>elfinject</code> overwrites it as described next and then breaks out of the loop and returns successfully from <code>rewrite_code_section</code>. If the section name doesn’t match, the loop moves on to its next iteration to see whether the next section matches.</p>&#13;
<p class="indent">If the name of the current section is <code>.note.ABI-tag</code>, <code>rewrite_code_section</code> overwrites the fields in the section header to turn it into a header describing the injected section <span class="ent">➏</span>. As mentioned previously in the high-level overview in <a href="ch07.xhtml#ch07fig2">Figure 7-2</a>, this involves setting the section type to <code>SHT_PROGBITS</code>; marking the section as executable; and filling in the appropriate section address, file offset, size, and alignment.</p>&#13;
<p class="indent">Next, <code>rewrite_code_section</code> saves the index of the overwritten section header, the pointer to the <code>Elf_Scn</code> structure, and a copy of the <code>GElf_Shdr</code> in the <code>inject</code> structure <span class="ent">➐</span>. To get the section’s index, it uses the <code>elf_ndxscn</code> function, which takes an <code>Elf_Scn*</code> as input and returns the index of that section.</p>&#13;
<p class="indent">Once the header modifications are complete, <code>rewrite_code_section</code> writes the modified section header back into the ELF binary file using another <code>elfinject</code> function called <code>write_shdr</code> <span class="ent">➑</span> and then reorders the section headers by section address <span class="ent">➒</span>. I’ll discuss the <code>write_shdr</code> function next, skipping the <span epub:type="pagebreak" id="page_404"/>description of <code>reorder_shdrs</code>, the function that orders the sections, since it’s not central to understanding the <code>PT_NOTE</code> overwriting technique.</p>&#13;
<p class="indent">As mentioned previously, if <code>elfinject</code> succeeds in finding and overwriting the <code>.note.ABI-tag</code> section header, it breaks from the main loop iterating over all the section headers and returns successfully. If, on the other hand, the loop completes without finding a header to overwrite, then the inject cannot continue, and <code>rewrite_code_section</code> returns with an error <span class="ent">➓</span>.</p>&#13;
<p class="indent"><a href="appb.xhtml#appblist9">Listing B-9</a> shows the code for <code>write_shdr</code>, the function responsible for writing the modified section header back to the ELF file.</p>&#13;
<p class="listing1" id="appblist9"><em>Listing B-9:</em> elfinject.c<em>: writing the modified section header back to the binary</em></p>&#13;
<pre>  int<br/>  write_shdr(elf_data_t *elf, Elf_Scn *scn, GElf_Shdr *shdr, size_t sidx)<br/>  {<br/>    off_t off;<br/>    size_t n, shdr_size;<br/>    void *shdr_buf;<br/><br/><span class="ent">➊</span>   if(!gelf_update_shdr(scn, shdr)) {<br/>      fprintf(stderr, "Failed to update section header\n");<br/>      return -1;<br/>    }<br/><br/><span class="ent">➋</span>   if(elf-&gt;bits == 32) {<br/><span class="ent">➌</span>     shdr_buf = elf32_getshdr(scn);<br/>       shdr_size = sizeof(Elf32_Shdr);<br/>    } else {<br/><span class="ent">➍</span>     shdr_buf = elf64_getshdr(scn);<br/>      shdr_size = sizeof(Elf64_Shdr);<br/>    }<br/><br/>    if(!shdr_buf) {<br/>      fprintf(stderr, "Failed to get section header\n");<br/>      return -1;<br/>    }<br/><br/><span class="ent">➎</span>   off = lseek(elf-&gt;fd, elf-&gt;ehdr.e_shoff + sidx*elf-&gt;ehdr.e_shentsize, SEEK_SET);<br/>    if(off &lt; 0) {<br/>      fprintf(stderr, "lseek failed\n");<br/>      return -1;<br/>    }<br/><br/><span class="ent">➏</span>   n = write(elf-&gt;fd, shdr_buf, shdr_size);<br/>    if(n != shdr_size) {<br/>      fprintf(stderr, "Failed to write section header\n");<br/>      return -1;<br/>    }<br/><br/>    return 0;<br/>  }</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_405"/>The <code>write_shdr</code> function takes three parameters: the <code>elf_data_t</code> structure called <code>elf</code> that stores all the important information needed to read and write the ELF binary, an <code>Elf_Scn*</code> (<code>scn</code>) and a <code>GElf_Shdr*</code> (<code>shdr</code>) corresponding to the section to overwrite, and the index (<code>sidx</code>) of that section in the section header table.</p>&#13;
<p class="indent">First, <code>write_shdr</code> calls <code>gelf_update_shdr</code> <span class="ent">➊</span>. Recall that <code>shdr</code> contains new, overwritten values in all the header fields. Because <code>shdr</code> is an ELF class-agnostic <code>GElf_Shdr</code> structure, which is part of the <code>GElf</code> API, writing to it doesn’t automatically update the underlying ELF data structures, <code>Elf32_Shdr</code> or <code>Elf64_Shdr</code>, depending on the ELF class. Yet those underlying data structures are the ones <code>elfinject</code> writes to the ELF binary, so it’s important that they’re updated. The <code>gelf_update_shdr</code> function takes an <code>Elf_Scn*</code> and a <code>GElf_Shdr*</code> as input and writes any changes made to the <code>GElf_Shdr</code> back to the underlying data structures, which are part of the <code>Elf_Scn</code> structure. The reason <code>elfinject</code> writes the underlying data structures to file, and not the <code>GElf</code> ones, is that the <code>GElf</code> data structures internally use a memory layout that doesn’t match the layout of the data structures in the file, so writing the <code>GElf</code> data structures would corrupt the ELF.</p>&#13;
<p class="indent">Now that <code>GElf</code> has written all pending updates back to the underlying native ELF data structures, <code>write_shdr</code> gets the native representation of the updated section header and writes it to the ELF file, overwriting the old <code>.note.ABI-tag</code> section header. First, <code>write_shdr</code> checks the bit width of the binary <span class="ent">➋</span>. If it’s 32 bits, then <code>write_shdr</code> calls <code>libelf</code>’s <code>elf32_getshdr</code> function (passing <code>scn</code> to it) to get a pointer to the <code>Elf32_Shdr</code> representation of the modified header <span class="ent">➌</span>. For 64-bit binaries, it uses <code>elf64_getshdr</code> <span class="ent">➍</span> instead of <code>elf32_getshdr</code>.</p>&#13;
<p class="indent">Next, <code>write_shdr</code> seeks the ELF file descriptor (<code>elf-&gt;fd</code>) to the offset in the ELF file where the updated header is to be written <span class="ent">➎</span>. Keep in mind that the <code>e_shoff</code> field in the executable header contains the file offset where the section header table starts, <code>sidx</code> is the index of the header to overwrite, and the <code>e_shentsize</code> field contains the size in bytes of each entry in the section header table. Thus, the following formula computes the file offset at which to write the updated section header:</p>&#13;
<p class="center"><em>e</em>_<em>shoff</em> + <em>sidx</em> × <em>e</em>_<em>shentsize</em></p>&#13;
<p class="indent">After seeking to this file offset, <code>write_shdr</code> writes the updated section header to the ELF file <span class="ent">➏</span>, overwriting the old <code>.note.ABI-tag</code> header with the new one describing the injected section. By this point, the new code bytes have been injected at the end of the ELF binary and there’s a new code section that contains those bytes, but this section doesn’t yet have a meaningful name in the string table. The next section explains how <code>elfinject</code> updates the section name.</p>&#13;
<h3 class="h3" id="appb_9"><span epub:type="pagebreak" id="page_406"/>B.9 Setting the Name of the Injected Section</h3>&#13;
<p class="noindent"><a href="appb.xhtml#appblist10">Listing B-10</a> shows the function that changes the name of the overwritten section, <code>.note.ABI-tag</code>, to something more meaningful, such as <code>.injected</code>. This is step <span class="ent">➏</span> in <a href="appb.xhtml#appblist4">Listing B-4</a>.</p>&#13;
<p class="listing1" id="appblist10"><em>Listing B-10:</em> elfinject.c<em>: setting the name of the injected section</em></p>&#13;
<pre>  int<br/>  rewrite_section_name(elf_data_t *elf, inject_data_t *inject)<br/>  {<br/>    Elf_Scn *scn;<br/>    GElf_Shdr shdr;<br/>    char *s;<br/>    size_t shstrndx, stroff, strbase;<br/>  <br/><span class="ent">➊</span>   if(strlen(inject-&gt;secname) &gt; strlen(".note.ABI-tag")) {<br/>       fprintf(stderr, "Section name too long\n");<br/>       return -1;<br/>    }<br/>  <br/><span class="ent">➋</span>   if(elf_getshdrstrndx(elf-&gt;e, &amp;shstrndx) &lt; 0) {<br/>       fprintf(stderr, "Failed to get string table section index\n");<br/>       return -1;<br/>    }<br/>  <br/>    stroff = 0;<br/>    strbase = 0;<br/>    scn = NULL;<br/><span class="ent">➌</span>   while((scn = elf_nextscn(elf-&gt;e, scn))) {<br/><span class="ent">➍</span>     if(!gelf_getshdr(scn, &amp;shdr)) {<br/>         fprintf(stderr, "Failed to get section header\n");<br/>         return -1;<br/>      }<br/><span class="ent">➎</span>     s = elf_strptr(elf-&gt;e, shstrndx, shdr.sh_name);<br/>       if(!s) {<br/>         fprintf(stderr, "Failed to get section name\n");<br/>         return -1;<br/>      }<br/>  <br/><span class="ent">➏</span>     if(!strcmp(s, ".note.ABI-tag")) {<br/>         stroff = shdr.sh_name;    /* offset into shstrtab */<br/><span class="ent">➐</span>      } else if(!strcmp(s, ".shstrtab")) {<br/>         strbase = shdr.sh_offset; /* offset to start of shstrtab */<br/>       }<br/>    }<br/><span epub:type="pagebreak" id="page_407"/><br/><span class="ent">➑</span>   if(stroff == 0) {<br/>      fprintf(stderr, "Cannot find shstrtab entry for injected section\n");<br/>      return -1;<br/>    } else if(strbase == 0) {<br/>      fprintf(stderr, "Cannot find shstrtab\n");<br/>      return -1;<br/>    }<br/>  <br/><span class="ent">➒</span>   inject-&gt;shstroff = strbase + stroff;<br/>  <br/><span class="ent">➓</span>   if(write_secname(elf, inject) &lt; 0) {<br/>       return -1;<br/>    }<br/>  <br/>    return 0;<br/>  }</pre>&#13;
<p class="indent">The function that overwrites the section name is called <code>rewrite_section _name</code>. The new name for this injected section cannot be longer than the old name, <code>.note.ABI-tag</code>, because all the strings in the string table are packed tightly together with no room for extra added characters. Therefore, the first thing <code>rewrite_section_name</code> does is check that the new section name, stored in the <code>inject-&gt;secname</code> field, will fit <span class="ent">➊</span>. If not, <code>rewrite_section_name</code> returns with an error.</p>&#13;
<p class="indent">The next steps are identical to the corresponding steps in the <code>rewrite _code_section</code> function I discussed previously, in <a href="appb.xhtml#appblist8">Listing B-8</a>: get the index of the string table section <span class="ent">➋</span> and then loop over all sections <span class="ent">➌</span> and inspect each section’s header <span class="ent">➍</span>, using the <code>sh_name</code> field in the header to obtain a string pointer to the section’s name <span class="ent">➎</span>. For details of these steps, refer to Section B.8.</p>&#13;
<p class="indent">Overwriting the old <code>.note.ABI-tag</code> section name requires two pieces of information: the file offset to the start of the <code>.shstrtab</code> section (the string table) and the offset to the <code>.note.ABI-tag</code> section’s name within the string table. Given these two offsets, <code>rewrite_section_name</code> knows where in the file to write the new section name string. The offset within the string table to the <code>.note.ABI-tag</code> section name is stored in the <code>sh_name</code> field of the <code>.note.ABI-tag</code> section header <span class="ent">➏</span>. Similarly, the <code>sh_offset</code> field in the section header contains the start of the <code>.shstrtab</code> section <span class="ent">➐</span>.</p>&#13;
<p class="indent">If all goes well, the loop locates both required offsets <span class="ent">➑</span>. If not, <code>rewrite _section_name</code> reports the error and gives up.</p>&#13;
<p class="indent">Finally, <code>rewrite_section_name</code> computes the file offset at which to write the new section name, saving it in the <code>inject-&gt;shstroff</code> field <span class="ent">➒</span>. It then calls another function, called <code>write_secname</code>, to write the new section name to the ELF binary at the just-computed offset <span class="ent">➓</span>. Writing the section name to file is straightforward and requires only standard C file I/O functions, so I omit a description of the <code>write_secname</code> function here.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_408"/>To recap, the ELF binary now contains the injected code, an overwritten section header, and a proper name for the injected section. The next step is to overwrite a <code>PT_NOTE</code> program header, creating a loadable segment that contains the injected section.</p>&#13;
<h3 class="h3" id="appb_10">B.10 Overwriting the PT_NOTE Program Header</h3>&#13;
<p class="noindent">As you may remember, <a href="appb.xhtml#appblist5">Listing B-5</a> showed the code that locates and saves the <code>PT_NOTE</code> program header to overwrite. All that’s left to do is to overwrite the relevant program header fields and save the updated program header to file. <a href="appb.xhtml#appblist11">Listing B-11</a> shows <code>rewrite_code_segment</code>, the function that updates and saves the program header. This was called in step <span class="ent">➐</span> from <a href="appb.xhtml#appblist4">Listing B-4</a>.</p>&#13;
<p class="listing1" id="appblist11"><em>Listing B-11:</em> elfinject.c<em>: overwriting the</em> <span class="codeitalic">PT_NOTE</span> <em>program header</em></p>&#13;
<pre>  int<br/>  rewrite_code_segment(elf_data_t *elf, inject_data_t *inject)<br/>  {<br/><span class="ent">➊</span>   inject-&gt;phdr.p_type   = PT_LOAD;          /* type */<br/><span class="ent">➋</span>   inject-&gt;phdr.p_offset = inject-&gt;off;      /* file offset to start of segment */<br/>    inject-&gt;phdr.p_vaddr   = inject-&gt;secaddr;  /* virtual address to load segment at */<br/>    inject-&gt;phdr.p_paddr   = inject-&gt;secaddr;  /* physical address to load segment at */<br/>    inject-&gt;phdr.p_filesz  = inject-&gt;len;      /* byte size in file */<br/>    inject-&gt;phdr.p_memsz   = inject-&gt;len;      /* byte size in memory */<br/><span class="ent">➌</span>   inject-&gt;phdr.p_flags  = PF_R | PF_X;      /* flags */<br/><span class="ent">➍</span>   inject-&gt;phdr.p_align  = 0x1000;           /* alignment in memory and file */<br/><br/><span class="ent">➎</span>   if(write_phdr(elf, inject) &lt; 0) {<br/>       return -1;<br/>    }<br/><br/>    return 0;<br/>  }</pre>&#13;
<p class="indent">Recall that the previously located <code>PT_NOTE</code> program header is stored in the <code>inject-&gt;phdr</code> field. Thus, <code>rewrite_code_segment</code> starts by updating the necessary fields in this program header: making it loadable by setting <code>p_type</code> to <code>PT_LOAD</code> <span class="ent">➊</span>; setting the file offset, memory addresses, and size of the injected code segment <span class="ent">➋</span>; making the segment readable and executable <span class="ent">➌</span>; and setting the proper alignment <span class="ent">➍</span>. These are the same modifications shown in the high-level overview in <a href="ch07.xhtml#ch07fig2">Figure 7-2</a>.</p>&#13;
<p class="indent">After making the necessary modifications, <code>rewrite_code_segment</code> calls another function called <code>write_phdr</code> to write the modified program header back to the ELF binary <span class="ent">➎</span>. <a href="appb.xhtml#appblist12">Listing B-12</a> shows the code of <code>write_phdr</code>. The code is similar to the <code>write_shdr</code> function that writes a modified section header to file, which you already saw in <a href="appb.xhtml#appblist9">Listing B-9</a>, so I’ll focus on the important differences between <code>write_phdr</code> and <code>write_shdr</code>.</p>&#13;
<p class="listing1" id="appblist12"><span epub:type="pagebreak" id="page_409"/><em>Listing B-12:</em> elfinject.c<em>: writing the overwritten program header back to the ELF file</em></p>&#13;
<pre>   int<br/>   write_phdr(elf_data_t *elf, inject_data_t *inject)<br/>   {<br/>     off_t off;<br/>     size_t n, phdr_size;<br/>     Elf32_Phdr *phdr_list32;<br/>     Elf64_Phdr *phdr_list64;<br/>     void *phdr_buf;<br/><br/><span class="ent">➊</span>   if(!gelf_update_phdr(elf-&gt;e, inject-&gt;pidx, &amp;inject-&gt;phdr)) {<br/>       fprintf(stderr, "Failed to update program header\n");<br/>       return -1;<br/>     }<br/><br/>     phdr_buf = NULL;<br/><span class="ent">➋</span>   if(elf-&gt;bits == 32) {<br/><span class="ent">➌</span>     phdr_list32 = elf32_getphdr(elf-&gt;e);<br/>       if(phdr_list32) {<br/><span class="ent">➍</span>        phdr_buf = &amp;phdr_list32[inject-&gt;pidx];<br/>          phdr_size = sizeof(Elf32_Phdr);<br/>       }<br/>     } else {<br/>       phdr_list64 = elf64_getphdr(elf-&gt;e);<br/>       if(phdr_list64) {<br/>         phdr_buf = &amp;phdr_list64[inject-&gt;pidx];<br/>         phdr_size = sizeof(Elf64_Phdr);<br/>       }<br/>     }<br/>     if(!phdr_buf) {<br/>       fprintf(stderr, "Failed to get program header\n");<br/>       return -1;<br/>     }<br/><br/><span class="ent">➎</span>   off = lseek(elf-&gt;fd, elf-&gt;ehdr.e_phoff + inject-&gt;pidx*elf-&gt;ehdr.e_phentsize, SEEK_SET);<br/>     if(off &lt; 0) {<br/>       fprintf(stderr, "lseek failed\n");<br/>       return -1;<br/>    }<br/><br/><span class="ent">➏</span>  n = write(elf-&gt;fd, phdr_buf, phdr_size);<br/>    if(n != phdr_size) {<br/>      fprintf(stderr, "Failed to write program header\n");<br/>      return -1;<br/>    }<br/><br/>    return 0;<br/>  }<span epub:type="pagebreak" id="page_410"/></pre>&#13;
<p class="indent">As in the <code>write_shdr</code> function, <code>write_phdr</code> begins by making sure all modifications to the <code>GElf</code> representation of the program header are written back to the underlying native <code>Elf32_Phdr</code> or <code>Elf64_Phdr</code> data structure <span class="ent">➊</span>. To this end, <code>write_phdr</code> calls the <code>gelf_update_phdr</code> function to flush the changes to the underlying data structures. This function takes an ELF handle, the index of the modified program header, and a pointer to the updated <code>GElf_Phdr</code> representation of the program header. As usual for <code>GElf</code> functions, it returns nonzero on success and 0 on failure.</p>&#13;
<p class="indent">Next, <code>write_phdr</code> gets a reference to the native representation of the program header in question (an <code>Elf32_Phdr</code> or <code>Elf64_Phdr</code> structure depending on the ELF class) to write it to file <span class="ent">➋</span>. Again, this is similar to what you saw in the <code>write_shdr</code> function, except that <code>libelf</code> doesn’t allow you to directly get a pointer to a particular program header. Instead, you must first get a pointer to the start of the program header table <span class="ent">➌</span> and then index it to get a pointer to the updated program header itself <span class="ent">➍</span>. To get a pointer to the program header table, you use the <code>elf32_getphdr</code> or <code>elf64_getphdr</code> function, depending on the ELF class. They both return the pointer on success or <code>NULL</code> on failure.</p>&#13;
<p class="indent">Given the native representation of the overwritten ELF program header, all that remains now is to seek to the correct file offset <span class="ent">➎</span> and write the updated program header there <span class="ent">➏</span>. That completes all the mandatory steps for injecting a new code section into an ELF binary! The only remaining step is optional: modifying the ELF entry point to point into the injected code.</p>&#13;
<h3 class="h3" id="appb_11">B.11 Modifying the Entry Point</h3>&#13;
<p class="noindent"><a href="appb.xhtml#appblist13">Listing B-13</a> shows the <code>rewrite_entry_point</code> function, which takes care of modifying the ELF entry point. It’s called only if requested by the user in step <span class="ent">➑</span> in <a href="appb.xhtml#appblist4">Listing B-4</a>.</p>&#13;
<p class="listing1" id="appblist13"><em>Listing B-13:</em> elfinject.c<em>: modifying the ELF entry point</em></p>&#13;
<pre>   int<br/>   rewrite_entry_point(elf_data_t *elf, inject_data_t *inject)<br/>   {<br/><span class="ent">➊</span>   elf-&gt;ehdr.e_entry = inject-&gt;phdr.p_vaddr + inject-&gt;entry;<br/><span class="ent">➋</span>   return write_ehdr(elf);<br/>  }</pre>&#13;
<p class="indent">Recall that <code>elfinject</code> allows the user to optionally specify a new entry point for the binary by giving a command line argument that contains an offset into the injected code. The offset specified by the user is saved in the <code>inject-&gt;entry</code> field. If the offset is negative, it means that the entry point should remain unchanged, in which case <code>rewrite_entry_point</code> is never called. <span epub:type="pagebreak" id="page_411"/>Thus, if <code>rewrite_entry_point</code> <em>is</em> called, <code>inject-&gt;entry</code> is guaranteed to be nonnegative.</p>&#13;
<p class="indent">The first thing <code>rewrite_entry_point</code> does is update the <code>e_entry</code> field in the ELF executable header <span class="ent">➊</span>, previously loaded into the <code>elf-&gt;ehdr</code> field. Next, it computes the new entry point address by adding the relative offset into the injected code (<code>inject-&gt;entry</code>) to the base address of the loadable segment that contains the injected code (<code>inject-&gt;phdr.p_vaddr</code>). Then, <code>rewrite_entry_point</code> calls the dedicated function <code>write_ehdr</code> <span class="ent">➋</span>, which writes the modified executable header back to the ELF file.</p>&#13;
<p class="indent">The code of <code>write_ehdr</code> is analogous to the <code>write_shdr</code> function shown in <a href="appb.xhtml#appblist9">Listing B-9</a>. The only difference is that it uses <code>gelf_update_ehdr</code> instead of <code>gelf_update_shdr</code> and <code>elf32_getehdr</code>/<code>elf64_getehdr</code> instead of <code>elf32_getshdr</code>/<code>elf64_getshdr</code>.</p>&#13;
<p class="indent">You now know how to use <code>libelf</code> to inject code into a binary, overwrite a section and program header to accommodate the new code, and modify the ELF entry point to jump to the injected code when the binary is loaded! Modifying the entry point is optional, and you may not always want to use the injected code immediately when the binary starts. Sometimes, you’ll want to use the injected code for different reasons, such as substituting a replacement for an existing function. <a href="ch07.xhtml#ch07_4">Section 7.4</a> discusses some techniques for transferring control to the injected code, other than modifying the ELF entry point.<span epub:type="pagebreak" id="page_412"/></p>&#13;
</div></body></html>