<html><head></head><body>
<h2 class="h2" id="ch2"><span epub:type="pagebreak" id="page_13"/><span class="big">2</span><br/>BASIC POWERSHELL CONCEPTS</h2>&#13;
<div class="image1"><img class="inline" src="../images/common.jpg" alt="Images"/></div>&#13;
<p class="noindent"><span class="bign">This chapter covers four basic concepts in PowerShell: variables, data types, objects, and data structures. These concepts are fundamental to just about every common programming language, but there’s something that makes PowerShell distinctive: everything in PowerShell is an object.</span></p>&#13;
<p class="indent">This may not mean much to you now, but keep it in mind as you move through the rest of this chapter. By the end of the chapter, you should have an idea of just how significant this is.</p>&#13;
<h3 class="h3" id="ch2lev1">Variables</h3>&#13;
<p class="noindent">A <em>variable</em> is a place to store <em>values</em>. You can think of a variable as a digital box. When you want to use a value multiple times, for example, you can put it in a box. Then, instead of typing the same number over and over in your code, you can put it in a variable and call that variable whenever you need the value. But as you might have guessed from the name, the real power of <span epub:type="pagebreak" id="page_14"/>a variable is that it can change: you can add stuff to a box, swap what’s in the box with something else, or take out whatever’s in there and show it off for a bit before putting it back.</p>&#13;
<p class="indent">As you’ll see later in the book, this variability lets you build code that can handle a general situation, as opposed to being tailored to one specific scenario. This section covers the basic ways to use a variable.</p>&#13;
<h4 class="h4" id="ch2lev1sec1">Displaying and Changing a Variable</h4>&#13;
<p class="noindent">All variables in PowerShell start with a dollar sign (<code>$</code>), which indicates to PowerShell that you are calling a variable and not a cmdlet, function, script file, or executable file. For example, if you want to display the value of the <code>MaximumHistoryCount</code> variable, you have to prepend it with a dollar sign and call it, as in <a href="ch02.xhtml#ch2list1">Listing 2-1</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$MaximumHistoryCount</span>&#13;
4096</pre>&#13;
<p class="caption" id="ch2list1"><em>Listing 2-1: Calling the <code>$MaximumHistoryCount</code> variable</em></p>&#13;
<p class="indent">The <code>$MaximumHistoryCount</code> variable is a built-in variable that determines the maximum number of commands PowerShell saves in its command history; the default is 4096 commands.</p>&#13;
<p class="indent">You can change a variable’s value by entering the variable name—starting with a dollar sign—and then using an equal sign (<code>=</code>) and the new value, as in <a href="ch02.xhtml#ch2list2">Listing 2-2</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$MaximumHistoryCount = 200</span>&#13;
PS&gt; <span class="codestrong1">$MaximumHistoryCount</span>&#13;
200</pre>&#13;
<p class="caption" id="ch2list2"><em>Listing 2-2: Changing the <code>$MaximumHistoryCount</code> variable’s value</em></p>&#13;
<p class="indent">Here you’ve changed the <code>$MaximumHistoryCount</code> variable’s value to <code>200</code>, meaning PowerShell will save only the previous 200 commands in its command history.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2list1">Listings 2-1</a> and <a href="ch02.xhtml#ch2list2">2-2</a> use a variable that already exists. Variables in PowerShell come in two broad classes: <em>user-defined variables</em>, which are created by the user, and <em>automatic variables</em>, which already exist in PowerShell. Let’s look at user-defined variables first.</p>&#13;
<h4 class="h4" id="ch2lev1sec2">User-Defined Variables</h4>&#13;
<p class="noindent">A variable needs to exist before you can use it. Try typing <span class="codestrong">$color</span> into your PowerShell console, as shown in <a href="ch02.xhtml#ch2list3">Listing 2-3</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$color</span>&#13;
The variable '$color' cannot be retrieved because it has not been set.&#13;
&#13;
At line:1 char:1&#13;
+ $color&#13;
+ ~~~~&#13;
<span epub:type="pagebreak" id="page_15"/>    + CategoryInfo          : InvalidOperation: (color:String) [], RuntimeException&#13;
    + FullyQualifiedErrorId : VariableIsUndefined</pre>&#13;
<p class="caption" id="ch2list3"><em>Listing 2-3: Entering an undefined variable results in an error.</em></p>&#13;
<div class="sidebar">&#13;
<p class="sidebart">TURNING ON STRICT MODE</p>&#13;
<p class="noindent">If you didn’t get the error in <a href="ch02.xhtml#ch2list3">Listing 2-3</a>, and your console shows no output, try running the following command to turn on strict mode:</p>&#13;
<pre>PS&gt;<span class="codestrong1"> Set-StrictMode -Version Latest</span></pre>&#13;
<p class="indent">Turning on strict mode tells PowerShell to throw errors when you violate good coding practices. For example, strict mode forces PowerShell to return an error when you reference an object property that doesn’t exist or an undefined variable. It’s considered best practice to turn on this mode when writing scripts, as it forces you to write cleaner, more predictable code. When simply running interactive code from the PowerShell console, this setting is typically not used. For more information about strict mode, run <code>Get-Help Set-StrictMode -Examples</code>.</p>&#13;
</div>&#13;
<p class="indent">In <a href="ch02.xhtml#ch2list3">Listing 2-3</a>, you tried to refer to the <code>$color</code> variable before it even existed, which resulted in an error. To create a variable, you need to <em>declare</em> it—say that it exists—and then <em>assign</em> a value to it (or <em>initialize</em> it). You can do these at the same time, as in <a href="ch02.xhtml#ch2list4">Listing 2-4</a>, which creates a variable <code>$color</code> that contains the value <code>blue</code>. You can assign a value to a variable by using the same technique you used to change the value of <code>$MaximumHistoryCount</code>—by entering the variable name, followed by the equal sign, and then the value.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$color = 'blue'</span></pre>&#13;
<p class="caption" id="ch2list4"><em>Listing 2-4: Creating a <code>color</code> variable with a value of <code>blue</code></em></p>&#13;
<p class="indent">Once you’ve created the variable and assigned it a value, you can reference it by typing the variable name in the console (<a href="ch02.xhtml#ch2list5">Listing 2-5</a>).</p>&#13;
<pre>PS&gt; <span class="codestrong1">$color</span>&#13;
blue</pre>&#13;
<p class="caption" id="ch2list5"><em>Listing 2-5: Checking the value of a variable</em></p>&#13;
<p class="indent">The value of a variable won’t change unless something, or someone, explicitly changes it. You can call the <code>$color</code> variable any number of times, and it will return the value <code>blue</code> each time until the variable is redefined.</p>&#13;
<p class="indent">When you use the equal sign to define a variable (<a href="ch02.xhtml#ch2list4">Listing 2-4</a>), you’re doing the same thing you’d do with the <code>Set-Variable</code> command. Likewise, when you type a variable into the console, and it prints out the value, as in <span epub:type="pagebreak" id="page_16"/><a href="ch02.xhtml#ch2list5">Listing 2-5</a>, you’re doing the same thing you’d do with the <code>Get-Variable</code> command. <a href="ch02.xhtml#ch2list6">Listing 2-6</a> recreates <a href="ch02.xhtml#ch2list4">Listings 2-4</a> and <a href="ch02.xhtml#ch2list5">2-5</a> by using these commands.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Set-Variable -Name color -Value blue</span>&#13;
&#13;
PS&gt; <span class="codestrong1">Get-Variable -Name color</span>&#13;
&#13;
Name                           Value&#13;
----                           -----&#13;
color                          blue</pre>&#13;
<p class="caption" id="ch2list6"><em>Listing 2-6: Creating a variable and displaying its value with the <code>Set-Variable</code> and <code>Get-Variable</code> commands</em></p>&#13;
<p class="indent">You can also use <code>Get-Variable</code> to return all available variables (as shown in <a href="ch02.xhtml#ch2list7">Listing 2-7</a>).</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Variable</span> &#13;
&#13;
Name                           Value&#13;
----                           -----&#13;
$                              Get-PSDrive&#13;
?                              True&#13;
^                              Get-PSDrive&#13;
args                           {}&#13;
color                          blue&#13;
<span class="codeitalic1">--snip--</span></pre>&#13;
<p class="caption" id="ch2list7"><em>Listing 2-7: Using <code>Get-Variable</code> to return all the variables.</em></p>&#13;
<p class="indent">This command will list all the variables currently in memory, but notice that there are some you haven’t defined. You’ll look at this type of variable in the next section.</p>&#13;
<h4 class="h4" id="ch2lev1sec3">Automatic Variables</h4>&#13;
<p class="noindent">Earlier I introduced automatic variables, the premade variables that PowerShell itself uses. Although PowerShell allows you to change some of these variables, as you did in <a href="ch02.xhtml#ch2list2">Listing 2-2</a>, I typically advise against it because unexpected consequences can arise. In general, you should treat automatic variables as <em>read-only</em>. (Now might be a good time to change <code>$MaximumHistoryCount</code> back to 4096!)</p>&#13;
<p class="indent">This section covers a few of the automatic variables that you’re likely to use: the <code>$null</code> variable, <code>$LASTEXITCODE</code>, and the preference variables.</p>&#13;
<h5 class="h5">The $null Variable</h5>&#13;
<p class="noindent">The <code>$null</code> variable is a strange one: it represents nothing. Assigning <code>$null</code> to a variable allows you to create that variable but not assign a real value to it, as in <a href="ch02.xhtml#ch2list8">Listing 2-8</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_17"/>PS&gt; <span class="codestrong1">$foo = $null</span>&#13;
PS&gt; <span class="codestrong1">$foo</span>&#13;
PS&gt; <span class="codestrong1">$bar</span>&#13;
The variable '$bar' cannot be retrieved because it has not been set.&#13;
At line:1 char:1&#13;
+ $bar&#13;
+ ~~~~&#13;
    + CategoryInfo          : InvalidOperation: (bar:String) [], RuntimeException&#13;
    + FullyQualifiedErrorId : VariableIsUndefined</pre>&#13;
<p class="caption" id="ch2list8"><em>Listing 2-8: Assigning variables to <code>$null</code></em></p>&#13;
<p class="indent">Here, you assign <code>$null</code> to the <code>$foo</code> variable. Then, when you call <code>$foo</code>, nothing is displayed, but no errors occur because PowerShell recognizes the variable.</p>&#13;
<p class="indent">You can see which variables PowerShell recognizes by passing parameters to the <code>Get-Variable</code> command. You can see in <a href="ch02.xhtml#ch2list9">Listing 2-9</a> that PowerShell knows that the <code>$foo</code> variable exists but does not recognize the <code>$bar</code> variable.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Variable -Name foo</span>&#13;
&#13;
Name                           Value&#13;
----                           -----&#13;
foo&#13;
&#13;
&#13;
PS&gt; Get-Variable -Name bar&#13;
Get-Variable : Cannot find a variable with the name 'bar'.&#13;
At line:1 char:1&#13;
+ Get-Variable -Name bar&#13;
+ ~~~~~~~~~~~~~~~~~~~~~~&#13;
    + CategoryInfo          : ObjectNotFound: (bar:String) [Get-Variable], ItemNotFoundException&#13;
    + FullyQualifiedErrorId : VariableNotFound,Microsoft.PowerShell.Commands.GetVariableCommand</pre>&#13;
<p class="caption" id="ch2list9"><em>Listing 2-9: Using <code>Get-Variable</code> to find variables</em></p>&#13;
<p class="indent">You may be wondering why we bother defining anything as <code>$null</code>. But <code>$null</code> is surprisingly useful. For example, as you’ll see later in this chapter, you often give a variable a value as a response to something else, like the output of a certain function. If you check that variable, and see that its value is still <code>$null</code>, you’ll know that something went wrong in the function and can act accordingly.</p>&#13;
<h5 class="h5">The LASTEXITCODE Variable</h5>&#13;
<p class="noindent">Another commonly used automatic variable is <code>$LASTEXITCODE</code>. PowerShell allows you to invoke external executable applications like the old-school <em>ping.exe</em>, which pings a website to get a response. When external applications finish running, they finish with an <em>exit code</em>, or <em>return code</em>, that <span epub:type="pagebreak" id="page_18"/>indicates a message. Typically, a 0 indicates success, and anything else means either a failure or another anomaly. For <em>ping.exe</em>, a 0 indicates it was able to successfully ping a node, and a 1 indicates it could not.</p>&#13;
<p class="indent">When <em>ping.exe</em> runs, as in <a href="ch02.xhtml#ch2list10">Listing 2-10</a>, you’ll see the expected output but not an exit code. That’s because the exit code is hidden inside <code>$LASTEXITCODE</code>. The value of <code>$LASTEXITCODE</code> is always the exit code of the last application that was executed. <a href="ch02.xhtml#ch2list10">Listing 2-10</a> pings <em><a href="http://google.com">google.com</a></em>, returns its exit code, and then pings a nonexistent domain and returns its exit code.</p>&#13;
<pre>PS&gt; <span class="codestrong1">ping.exe -n 1 dfdfdfdfd.com</span>&#13;
&#13;
Pinging dfdfdfdfd.com [14.63.216.242] with 32 bytes of data:&#13;
Request timed out.&#13;
&#13;
Ping statistics for 14.63.216.242:&#13;
    Packets: Sent = 1, Received = 0, Lost = 1 (100% loss),&#13;
PS&gt; <span class="codestrong1">$LASTEXITCODE</span>&#13;
1&#13;
PS&gt; <span class="codestrong1">ping.exe -n 1 google.com</span>&#13;
&#13;
Pinging google.com [2607:f8b0:4004:80c::200e] with 32 bytes of data:&#13;
Reply from 2607:f8b0:4004:80c::200e: time=47ms&#13;
&#13;
Ping statistics for 2607:f8b0:4004:80c::200e:&#13;
    Packets: Sent = 1, Received = 1, Lost = 0 (0% loss),&#13;
Approximate round trip times in milli-seconds:&#13;
    Minimum = 47ms, Maximum = 47ms, Average = 47ms&#13;
PS&gt; <span class="codestrong1">$LASTEXITCODE</span>&#13;
0</pre>&#13;
<p class="caption" id="ch2list10"><em>Listing 2-10: Using</em> ping.exe <em>to demonstrate the <code>$LASTEXITCODE</code> variable</em></p>&#13;
<p class="indent">The <code>$LASTEXITCODE</code> is 0 when you ping <em><a href="http://google.com">google.com</a></em> but has a value of 1 when you ping the bogus domain name <em>dfdfdfdfd.com</em>.</p>&#13;
<h5 class="h5">The Preference Variables</h5>&#13;
<p class="noindent">PowerShell has a type of automatic variable referred to as <em>preference variables</em>. These variables control the default behavior of various output streams: <code>Error</code>, <code>Warning</code>, <code>Verbose</code>, <code>Debug</code>, and <code>Information</code>.</p>&#13;
<p class="indent">You can find a list of all of the preference variables by running <code>Get-Variable</code> and filtering for all variables ending in <em>Preference</em>, as shown here:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Variable -Name *Preference</span>&#13;
&#13;
Name                           Value&#13;
----                           -----&#13;
ConfirmPreference              High&#13;
DebugPreference                SilentlyContinue&#13;
ErrorActionPreference          Continue&#13;
InformationPreference          SilentlyContinue&#13;
ProgressPreference             Continue&#13;
<span epub:type="pagebreak" id="page_19"/>VerbosePreference              SilentlyContinue&#13;
WarningPreference              Continue&#13;
WhatIfPreference               False</pre>&#13;
<p class="indent">These variables can be used to configure the various types of output PowerShell can return. For example, if you’ve ever made a mistake and seen that ugly red text, you’ve seen the <code>Error</code> output stream. Run the following command to generate an error message:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Variable -Name 'doesnotexist'</span>&#13;
Get-Variable : Cannot find a variable with the name 'doesnotexist'.&#13;
At line:1 char:1&#13;
+ Get-Variable -Name 'doesnotexist'&#13;
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~&#13;
    + CategoryInfo          : ObjectNotFound: (doesnotexist:String) [Get-Variable],&#13;
                              ItemNotFoundException&#13;
    + FullyQualifiedErrorId : VariableNotFound,Microsoft.PowerShell.Commands.GetVariableCommand</pre>&#13;
<p class="indent">You should have gotten a similar error message, as this is the default behavior for the <code>Error</code> stream. If for whatever reason you didn’t want to be bothered by this error text, and would rather nothing happen, you could redefine the <code>$ErrorActionPreference</code> variable to <code>SilentlyContinue</code> or <code>Ignore</code>, either of which will tell PowerShell not to output any error text:</p>&#13;
<pre>PS&gt; <span class="codestrong1">$ErrorActionPreference = 'SilentlyContinue'</span>&#13;
PS&gt; <span class="codestrong1">Get-Variable -Name 'doesnotexist'</span>&#13;
PS&gt;</pre>&#13;
<p class="indent">As you can see, no error text is output. Ignoring error output is generally considered bad practice, so change the value of <code>$ErrorActionPreference</code> back to <code>Continue</code> before proceeding. For more information on preference variables, check out the <code>about_help</code> content by running <span class="codestrong">Get-Help about_Preference_Variables.</span></p>&#13;
<h3 class="h3" id="ch2lev2">Data Types</h3>&#13;
<p class="noindent">PowerShell variables come in a variety of forms, or <em>types</em>. All the details of PowerShell’s data types are beyond the scope of this chapter. What you need to know is that PowerShell has several data types—including bools, strings, and integers—and you can change a variable’s data type without errors. The following code should run with no errors:</p>&#13;
<pre>PS&gt; <span class="codestrong1">$foo = 1</span>&#13;
PS&gt; <span class="codestrong1">$foo = 'one'</span>&#13;
PS&gt; <span class="codestrong1">$foo = $true</span></pre>&#13;
<p class="indent">This is because PowerShell can figure out data types based on the values you provide it. What’s happening under the hood is a little too complicated for this book, but it’s important you understand the basic types and how they interact.</p>&#13;
<h4 class="h4" id="ch2lev2sec4"><span epub:type="pagebreak" id="page_20"/>Boolean Values</h4>&#13;
<p class="noindent">Just about every programming language uses <em>booleans</em>, which have a true or false value (1 or 0). Booleans are used to represent binary conditions, like a light switch being on or off. In PowerShell, booleans are called <em>bools</em>, and the two boolean values are represented by the automatic variables <code>$true</code> and <code>$false</code>. These automatic variables are hardcoded into PowerShell and can’t be changed. <a href="ch02.xhtml#ch2list11">Listing 2-11</a> shows how to set a variable to be <code>$true</code> or <code>$false</code>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$isOn = $true</span>&#13;
PS&gt; <span class="codestrong1">$isOn</span> &#13;
True</pre>&#13;
<p class="caption" id="ch2list11"><em>Listing 2-11: Creating a bool variable</em></p>&#13;
<p class="indent">You’ll see a lot more of bools in <a href="ch04.xhtml#ch4">Chapter 4</a>.</p>&#13;
<h4 class="h4" id="ch2lev2sec5">Integers and Floating Points</h4>&#13;
<p class="noindent">You can represent numbers in PowerShell in two main ways: via integer or floating-point data types.</p>&#13;
<h5 class="h5">Integer types</h5>&#13;
<p class="noindent"><em>Integer</em> data types hold only whole numbers and will round any decimal input to the nearest integer. Integer data types come in <em>signed</em> and <em>unsigned</em> types. Signed data types can store both positive and negative numbers; unsigned data types store values with no sign.</p>&#13;
<p class="indent">By default, PowerShell stores integers by using the 32-bit signed <code>Int32</code> type. The bit count determines how big (or small) a number the variable can hold; in this case, anything in the range –2,147,483,648 to 2,147,483,647. For numbers outside that range, you can use the 64-bit signed <code>Int64</code> type, which has a range of –9,223,372,036,854,775,808 to 9,223,372,036,854,775,807.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2list12">Listing 2-12</a> shows an example of how PowerShell handles <code>Int32</code> types.</p>&#13;
<pre><span class="ent">❶</span> PS&gt; <span class="codestrong1">$num = 1</span>&#13;
   PS&gt; <span class="codestrong1">$num</span>&#13;
   1&#13;
<span class="ent">❷</span> PS&gt; <span class="codestrong1">$num.GetType().name</span>&#13;
   Int32&#13;
<span class="ent">❸</span> PS&gt; <span class="codestrong1">$num = 1.5</span>&#13;
   PS&gt; <span class="codestrong1">$num.GetType().name</span>&#13;
   Double&#13;
<span class="ent">❹</span> PS&gt; <span class="codestrong1">[Int32]$num</span>&#13;
   2</pre>&#13;
<p class="caption" id="ch2list12"><em>Listing 2-12: Using an <code>Int</code> type to store different values</em></p>&#13;
<p class="indent">Let’s walk through each of these steps. Don’t worry about all the syntax; for now, focus on the output. First, you create a variable <code>$num</code> and give it the value of 1 <span class="ent">❶</span>. Next, you check the type of <code>$num</code> <span class="ent">❷</span> and see that PowerShell interprets 1 as an <code>Int32</code>. You then change <code>$num</code> to hold a decimal value <span class="ent">❸</span> <span epub:type="pagebreak" id="page_21"/>and check the type again and see that PowerShell has changed the type to <code>Double</code>. This is because PowerShell will change a variable’s type depending on its value. But you can force PowerShell to treat a variable as a certain type by <em>casting</em> that variable, as you do at the end by using the <code>[Int32]</code> syntax in front of <code>$num</code> <span class="ent">❹</span>. As you can see, when forced to treat 1.5 as an integer, PowerShell rounds it up to 2.</p>&#13;
<p class="indent">Now let’s look at the <code>Double</code> type.</p>&#13;
<h5 class="h5">Floating-Point Types</h5>&#13;
<p class="noindent">The <code>Double</code> type belongs to the broader class of variables known as <em>floating-point</em> variables. Although they can be used to represent whole numbers, floating-point variables are most often used to represent decimals. The other main type of floating-point variable is <code>Float</code>. I won’t go into the internal representation of the <code>Float</code> and <code>Double</code> types. What you need to know is that although <code>Float</code> and <code>Double</code> are capable of representing decimal numbers, these types can be imprecise, as shown in <a href="ch02.xhtml#ch2list13">Listing 2-13</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$num = 0.1234567910</span>&#13;
PS&gt; <span class="codestrong1">$num.GetType().name</span>&#13;
Double&#13;
PS&gt; <span class="codestrong1">$num + $num</span>&#13;
0.2469135782 &#13;
PS&gt; <span class="codestrong1">[Float]$num + [Float]$num</span>&#13;
0.246913582086563</pre>&#13;
<p class="caption" id="ch2list13"><em>Listing 2-13: Precision errors with floating-point types</em></p>&#13;
<p class="indent">As you can see, PowerShell uses the <code>Double</code> type by default. But notice what happens when you add <code>$num</code> to itself but cast both as a <code>Float</code>—you get a strange answer. Again, the reasons are beyond the scope of this book, but be aware that errors like this can happen when using <code>Float</code> and <code>Double</code>.</p>&#13;
<h4 class="h4" id="ch2lev2sec6">Strings</h4>&#13;
<p class="noindent">You’ve already seen this type of variable. When you defined the <code>$color</code> variable in <a href="ch02.xhtml#ch2list4">Listing 2-4</a>, you didn’t just type <code>$color = blue</code>. Instead, you enclosed the value in single quotes, which indicates to PowerShell that the value is a series of letters, or a <em>string</em>. If you try to assign the <code>blue</code> value to <code>$color</code> without the quotes, PowerShell will return an error:</p>&#13;
<pre>PS&gt; <span class="codestrong1">$color = blue</span>&#13;
blue : The term 'blue' is not recognized as the name of a cmdlet, function, script file, or&#13;
operable program. Check the spelling of the name, or if a path was included, verify that the&#13;
path is correct and try again.&#13;
At line:1 char:10&#13;
+ $color = blue&#13;
+          ~~~~&#13;
    + CategoryInfo          : ObjectNotFound: (blue:String) [], CommandNotFoundException&#13;
    + FullyQualifiedErrorId : CommandNotFoundException</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_22"/>Without quotes, PowerShell interprets <code>blue</code> as a command and tries to execute it. Because the command <code>blue</code> doesn’t exist, PowerShell returns an error message that says so. To correctly define a string, you need to use quotes around your value.</p>&#13;
<h5 class="h5">Combining Strings and Variables</h5>&#13;
<p class="noindent">Strings aren’t restricted to words; they can be phrases and sentences as well. For instance, you can assign <code>$sentence</code> this string:</p>&#13;
<pre>PS&gt; <span class="codestrong1">$sentence = "Today, you learned that PowerShell loves the color blue"</span>&#13;
PS&gt; <span class="codestrong1">$sentence</span>&#13;
Today, you learned that PowerShell loves the color blue</pre>&#13;
<p class="indent">But maybe you want to use this same sentence, but with the words <em>PowerShell</em> and <em>blue</em> as the values of variables. For instance, what if you have a variable called <code>$name</code>, another called <code>$language</code>, and another called <code>$color</code>? <a href="ch02.xhtml#ch2list14">Listing 2-14</a> defines these variables by using other variables.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$language = 'PowerShell'</span>&#13;
PS&gt; <span class="codestrong1">$color = 'blue'</span>&#13;
&#13;
PS&gt; <span class="codestrong1">$sentence =</span> <span class="codestrong1">"Today, you learned that $language loves the color $color"</span>&#13;
PS&gt; <span class="codestrong1">$sentence</span>&#13;
Today, you learned that PowerShell loves the color blue</pre>&#13;
<p class="caption" id="ch2list14"><em>Listing 2-14: Inserting variables in strings</em></p>&#13;
<p class="indent">Notice the use of double quotes. Enclosing your sentence in single quotes doesn’t achieve the intended result:</p>&#13;
<pre>PS&gt; <span class="codestrong1">'Today, $name learned that $language loves the color $color'</span>&#13;
Today, $name learned that $language loves the color $color</pre>&#13;
<p class="indent">This isn’t just a weird bug. There’s an important difference between single and double quotes in PowerShell.</p>&#13;
<h5 class="h5">Using Double vs. Single Quotes</h5>&#13;
<p class="noindent">When you’re assigning a variable a simple string, you can use single or double quotes, as shown in <a href="ch02.xhtml#ch2list15">Listing 2-15</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$color = "yellow"</span>&#13;
PS&gt; <span class="codestrong1">$color</span>&#13;
yellow&#13;
PS&gt; <span class="codestrong1">$color = 'red'</span>&#13;
PS&gt; <span class="codestrong1">$color</span>&#13;
red&#13;
PS&gt; <span class="codestrong1">$color = ''</span>&#13;
PS&gt; <span class="codestrong1">$color</span>&#13;
<span epub:type="pagebreak" id="page_23"/>PS&gt; <span class="codestrong1">$color = "blue"</span>&#13;
PS&gt; <span class="codestrong1">$color</span>&#13;
blue</pre>&#13;
<p class="caption" id="ch2list15"><em>Listing 2-15: Changing variable values by using single and double quotes</em></p>&#13;
<p class="indent">As you can see, it doesn’t matter which quotes you use to define a simple string. So why did it matter when you had variables in your string? The answer has to do with <em>variable interpolation</em>, or <em>variable expansion</em>. Normally, when you enter <code>$color</code> by itself into the console and hit <span class="small">ENTER</span>, PowerShell <em>interpolates</em>, or <em>expands</em>, that variable. These are fancy terms that mean PowerShell is reading the value inside a variable, or opening the box so you can see inside. When you use double quotes to call a variable, the same thing happens: the variable is expanded, as you can see in <a href="ch02.xhtml#ch2list16">Listing 2-16</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">"$color"</span>&#13;
blue&#13;
PS&gt; <span class="codestrong1">'$color'</span>&#13;
$color</pre>&#13;
<p class="caption" id="ch2list16"><em>Listing 2-16: Variable behavior inside a string</em></p>&#13;
<p class="indent">But notice what happens when you use single quotes: the console outputs the variable itself, not its value. Single quotes tell PowerShell that you mean <em>exactly</em> what you’re typing, whether that’s a word like <em>blue</em> or what looks like a variable called <code>$color</code>. To PowerShell, it doesn’t matter. It won’t look past the value in single quotes. So when you use a variable inside single quotes, PowerShell doesn’t know to expand that variable’s value. This is why you need to use double quotes when inserting variables into your strings.</p>&#13;
<p class="indent">There’s much more to say about bools, integers, and strings. But for now, let’s take a step back and look at something more general: objects.</p>&#13;
<h3 class="h3" id="ch2lev3">Objects</h3>&#13;
<p class="noindent">In PowerShell, <em>everything</em> is an object. In technical terms, an <em>object</em> is an individual instance of a specific template, called a class. A <em>class</em> specifies the kinds of things an object will contain. An object’s class determines its <em>methods</em>, or actions that can be taken on that object. In other words, the methods are all the things an object can do. For example, a list object might have a <code>sort()</code> method that, when called, will sort the list. Likewise, an object’s class determines its <em>properties</em>, the object’s variables. You can think of the properties as all the data about the object. In the case of the list object, you might have a <code>length</code> property that stores the number of elements in the list. Sometimes, a class will provide default values for the object’s properties, but more often than not, these are values you will provide to the objects you work with.</p>&#13;
<p class="indent">But that’s all very abstract. Let’s consider an example: a car. The car starts out as a plan in the design phase. This plan, or template, defines how the car should look, what kind of engine it should have, what kind of chassis <span epub:type="pagebreak" id="page_24"/>it should have, and so on. The plan also lays out what the car will be able to do once it’s complete—move forward, move in reverse, and open and close the sunroof. You can think of this plan as the car’s class.</p>&#13;
<p class="indent">Each car is built from this class, and all of that particular car’s properties and methods are added to it. One car might be blue, while the same model car might be red, and another car may have a different transmission. These attributes are the properties of a specific car object. Likewise, each of the cars will drive forward, drive in reverse, and have the same method to open and close the sunroof. These actions are the car’s methods.</p>&#13;
<p class="indent">Now with that general understanding of how objects work, let’s get our hands dirty and work with PowerShell.</p>&#13;
<h4 class="h4" id="ch2lev3sec7">Inspecting Properties</h4>&#13;
<p class="noindent">First, let’s make a simple object so you can dissect it and uncover the various facets of a PowerShell object. <a href="ch02.xhtml#ch2list17">Listing 2-17</a> creates a simple string object called <code>$color</code>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$color = 'red'</span>&#13;
PS&gt; <span class="codestrong1">$color</span>&#13;
red</pre>&#13;
<p class="caption" id="ch2list17"><em>Listing 2-17: Creating a string object</em></p>&#13;
<p class="indent">Notice that when you call <code>$color</code>, you get only the variable’s value. But typically, because they’re objects, variables have more information than just their value. They also have properties.</p>&#13;
<p class="indent">To look at an object’s properties, you’ll use the <code>Select-Object</code> command and the <code>Property</code> parameter. You’ll pass the <code>Property</code> an asterisk argument, as in <a href="ch02.xhtml#ch2list18">Listing 2-18</a>, to tell PowerShell to return everything it finds.</p>&#13;
<pre>PS&gt;  <span class="codestrong1">Select-Object -InputObject $color -Property *</span>&#13;
&#13;
Length&#13;
------&#13;
     3</pre>&#13;
<p class="caption" id="ch2list18"><em>Listing 2-18: Investigating object properties</em></p>&#13;
<p class="indent">As you can see, the <code>$color</code> string has only a single property, called <code>Length</code>.</p>&#13;
<p class="indent">You can directly reference the <code>Length</code> property by using <em>dot notation</em>: you use the name of the object, followed by a dot and the name of the property you want to access (see <a href="ch02.xhtml#ch2list19">Listing 2-19</a>).</p>&#13;
<pre>PS&gt; <span class="codestrong1">$color.Length</span>&#13;
3</pre>&#13;
<p class="caption" id="ch2list19"><em>Listing 2-19: Using dot notation to check an object’s property</em></p>&#13;
<p class="indent">Referencing objects like this will become second nature over time.</p>&#13;
<h4 class="h4" id="ch2lev3sec8"><span epub:type="pagebreak" id="page_25"/>Using the Get-Member cmdlet</h4>&#13;
<p class="noindent">Using <code>Select-Object</code>, you discovered that the <code>$color</code> string has only a single property. But recall that objects sometimes have methods as well. To take a look at all the methods <em>and</em> properties that exist on this string object, you can use the <code>Get-Member</code> cmdlet (<a href="ch02.xhtml#ch2list20">Listing 2-20</a>); this cmdlet will be your best friend for a long time. It’s an easy way to quickly list all of a particular object’s properties and methods, collectively referred to as an object’s <em>members</em>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Member -InputObject $color</span>&#13;
&#13;
   TypeName: System.String&#13;
&#13;
Name             MemberType            Definition&#13;
----             ----------            ----------&#13;
Clone            Method                System.Object Clone(), System.Object ICloneable.Clone()&#13;
CompareTo        Method                int CompareTo(System.Object value),&#13;
                                       int CompareTo(string strB), int IComparab...&#13;
Contains         Method                bool Contains(string value)&#13;
CopyTo           Method                void CopyTo(int sourceIndex, char[] destination,&#13;
                                       int destinationIndex, int co...&#13;
EndsWith         Method                bool EndsWith(string value),&#13;
                                       bool EndsWith(string value, System.StringCompari...&#13;
Equals           Method                bool Equals(System.Object obj),&#13;
                                       bool Equals(string value), bool Equals(string...&#13;
--<span class="codeitalic1">snip</span>--&#13;
Length           Property              int Length {get;}</pre>&#13;
<p class="caption" id="ch2list20"><em>Listing 2-20: Using <code>Get-Member</code> to investigate object properties and methods</em></p>&#13;
<p class="indent">Now we’re talking! It turns out that your simple string object has quite a few methods associated with it. There are lots more to explore, but not all are shown here. The number of methods and properties an object will have depends on its parent class.</p>&#13;
<h4 class="h4" id="ch2lev3sec9">Calling Methods</h4>&#13;
<p class="noindent">You can reference methods with dot notation. However, unlike a property, a method will always end in a set of opening and closing parentheses and can take one or more parameters.</p>&#13;
<p class="indent">For example, suppose you want to remove a character in your <code>$color</code> variable. You can remove characters from a string by using the <code>Remove()</code> method. Let’s isolate <code>$color</code>’s <code>Remove()</code> method with the code in <a href="ch02.xhtml#ch2list21">Listing 2-21</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Member -InputObject $color –Name Remove</span>&#13;
Name   MemberType Definition&#13;
----   ---------- ----------&#13;
Remove Method     string Remove(int startIndex, int count), string Remove(int startIndex)</pre>&#13;
<p class="caption" id="ch2list21"><em>Listing 2-21: Looking at a string’s <code>Remove()</code> method</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_26"/>As you can see, there are two definitions. This means you can use the method in two ways: either with <code>startIndex</code> and the <code>count</code> parameter, or with just <code>startIndex</code>.</p>&#13;
<p class="indent">So to remove the second character in <code>$color</code>, you specify the place of the character where you’d like to start removing, which we call the <em>index</em>. Indexes start from 0, so the first letter has a starting place of 0, the second an index of 1, and so on. Along with an index, you can provide the number of characters you’d like to remove by using a comma to separate the parameter arguments, as in <a href="ch02.xhtml#ch2list22">Listing 2-22</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$color.Remove(1,1)</span>&#13;
Rd&#13;
PS&gt; $color&#13;
red</pre>&#13;
<p class="caption" id="ch2list22"><em>Listing 2-22: Calling methods</em></p>&#13;
<p class="indent">Using an index of 1, you’ve told PowerShell that you want to remove characters starting with the string’s second character; the second argument tells PowerShell to remove just one character. So you get <code>Rd</code>. But notice that the <code>Remove()</code> method doesn’t permanently change the value of a string variable. If you’d like to keep this change, you’d need to assign the output of the <code>Remove()</code> method to a variable, as shown in <a href="ch02.xhtml#ch2list23">Listing 2-23</a>.</p>&#13;
<pre>PS&gt; $newColor = <span class="codestrong1">$color.Remove(1,1)</span>&#13;
PS&gt; $newColor&#13;
Rd</pre>&#13;
<p class="caption" id="ch2list23"><em>Listing 2-23: Capturing output of the <code>Remove()</code> method on a string</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If you need to know whether a method returns an object (as <span class="codeitalic">Remove()</span> does) or modifies an existing object, you can check its description. As you can see in <a href="ch02.xhtml#ch2list21">Listing 2-21</a>, <span class="codeitalic">Remove()</span>’s definition has the word <span class="codeitalic">string</span> in front of it; this means that the function returns a new string. Functions with the word <span class="codeitalic">void</span> in front typically modify existing objects. <a href="ch06.xhtml#ch6">Chapter 6</a> covers this topic in more depth.</em></p>&#13;
</div>&#13;
<p class="indent">In these examples, you’ve used one of the simplest types of object, the string. In the next section, you’ll take a look at some more complex objects.</p>&#13;
<h3 class="h3" id="ch2lev4">Data Structures</h3>&#13;
<p class="noindent">A <em>data structure</em> is a way to organize multiple pieces of data. Like the data they organize, data structures in PowerShell are represented by objects stored in variables. They come in three main types: arrays, ArrayLists, and hashtables.</p>&#13;
<h4 class="h4" id="ch2lev4sec10">Arrays</h4>&#13;
<p class="noindent">So far, I’ve described a variable as a box. But if a simple variable (such as a <code>Float</code> type) is a single box, then an <em>array</em> is whole bunch of boxes taped together—a list of items represented by a single variable.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_27"/>Often you’ll need several related variables—say, a standard set of colors. Rather than storing each color as a separate string, and then referencing each of those individual variables, it’s much more efficient to store all of those colors in a single data structure. This section will show you how to create, access, modify, and add to an array.</p>&#13;
<h5 class="h5">Defining Arrays</h5>&#13;
<p class="noindent">First, let’s define a variable called <code>$colorPicker</code> and assign it an array that holds four colors as strings. To do this, you use the at sign (<code>@</code>) followed by the four strings (separated by commas) within parentheses, as in <a href="ch02.xhtml#ch2list24">Listing 2-24</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$colorPicker = @('blue','white','yellow','black')</span>&#13;
PS&gt; <span class="codestrong1">$colorPicker</span>&#13;
blue&#13;
white&#13;
yellow&#13;
black</pre>&#13;
<p class="caption" id="ch2list24"><em>Listing 2-24: Creating an array</em></p>&#13;
<p class="indent">The <code>@</code> sign followed by an opening parenthesis and zero or more elements separated by a comma signals to PowerShell that you’d like to create an array.</p>&#13;
<p class="indent">Notice that after calling <code>$colorPicker</code>, PowerShell displays each of the array’s elements on a new line. In the next section, you’ll learn how to access each element individually.</p>&#13;
<h5 class="h5">Reading Array Elements</h5>&#13;
<p class="noindent">To access an element in an array, you use the name of the array followed by a pair of square brackets (<code>[]</code>) that contain the index of the element you want to access. As with string characters, you start numbering arrays at 0, so the first element is at index 0, the second at index 1, and so on. In PowerShell, using –1 as the index will return the final element.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2list25">Listing 2-25</a> accesses several elements in our <code>$colorPicker</code> array.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$colorPicker[0]</span>&#13;
blue&#13;
PS&gt; <span class="codestrong1">$colorPicker[2]</span>&#13;
yellow&#13;
PS&gt; <span class="codestrong1">$colorPicker[3]</span>&#13;
black&#13;
PS&gt; <span class="codestrong1">$colorPicker[4]</span>&#13;
Index was outside the bounds of the array.&#13;
At line:1 char:1&#13;
+ $colorPicker[4]&#13;
+ ~~~~~~~~~~~~~~~&#13;
    + CategoryInfo          : OperationStopped: (:) [], IndexOutOfRangeException&#13;
    + FullyQualifiedErrorId : System.IndexOutOfRangeException</pre>&#13;
<p class="caption" id="ch2list25"><em>Listing 2-25: Reading array elements</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_28"/>As you can see, if you try to specify an index number that doesn’t exist in the array, PowerShell will return an error message.</p>&#13;
<p class="indent">To access multiple elements in an array at the same time, you can use the <em>range operator</em> (<code>..</code>) between two numbers. The range operator will make PowerShell return those two numbers and every number between them, like so:</p>&#13;
<pre>PS&gt; 1..3&#13;
1&#13;
2&#13;
3</pre>&#13;
<p class="indent">To use the range operator to access multiple items in an array, you use a range for an index, as shown here:</p>&#13;
<pre>PS&gt; $colorPicker[1..3]&#13;
white&#13;
yellow&#13;
black</pre>&#13;
<p class="indent">Now that you’ve seen how to access elements in an array, let’s look at how to change them.</p>&#13;
<h5 class="h5">Modifying Elements in an Array</h5>&#13;
<p class="noindent">If you want to change an element in an array, you don’t have to redefine the entire array. Instead, you can reference an item with its index and use the equal sign to assign a new value, as in <a href="ch02.xhtml#ch2list26">Listing 2-26</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$colorPicker[3]</span>&#13;
black&#13;
PS&gt; <span class="codestrong1">$colorPicker[3] = 'white'</span>&#13;
PS&gt; <span class="codestrong1">$colorPicker[3]</span>&#13;
white</pre>&#13;
<p class="caption" id="ch2list26"><em>Listing 2-26: Modifying elements in an array</em></p>&#13;
<p class="indent">Make sure you double-check that the index number is correct by displaying the element to your console before you modify an element.</p>&#13;
<h5 class="h5">Adding Elements to an Array</h5>&#13;
<p class="noindent">You can add items to an array with the addition operator (<code>+</code>), as in <a href="ch02.xhtml#ch2list27">Listing 2-27</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$colorPicker = $colorPicker + 'orange'</span>&#13;
PS&gt; <span class="codestrong1">$colorPicker</span>&#13;
blue&#13;
white&#13;
yellow&#13;
white&#13;
orange</pre>&#13;
<p class="caption" id="ch2list27"><em>Listing 2-27: Adding a single item to an array</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_29"/>Notice that you enter <code>$colorPicker</code> on both sides of the equal sign. This is because you are asking PowerShell to interpolate the <code>$colorPicker</code> variable and then add a new element.</p>&#13;
<p class="indent">The <code>+</code> method works, but there’s a quicker, more readable way. You can use the plus and equal signs together to form <code>+=</code> (see <a href="ch02.xhtml#ch2list28">Listing 2-28</a>).</p>&#13;
<pre>PS&gt; <span class="codestrong1">$colorPicker += 'brown'</span>&#13;
PS&gt; <span class="codestrong1">$colorPicker</span>&#13;
blue&#13;
white&#13;
yellow&#13;
white&#13;
orange&#13;
brown</pre>&#13;
<p class="caption" id="ch2list28"><em>Listing 2-28: Using the <code>+=</code> shortcut to add an item to an array</em></p>&#13;
<p class="indent">The <code>+=</code> operator tells PowerShell to <em>add this item to the existing array</em>. This shortcut prevents you from having to type out the array name twice and is much more common than using the full syntax.</p>&#13;
<p class="indent">You can also add arrays to other arrays. Say you’d like to add the colors pink and cyan to your <code>$colorPicker</code> example. <a href="ch02.xhtml#ch2list29">Listing 2-29</a> defines another array with just those two colors and adds them just as you did in <a href="ch02.xhtml#ch2list28">Listing 2-28</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$colorPicker += @('pink','cyan')</span>&#13;
PS&gt; <span class="codestrong1">$colorPicker</span>&#13;
blue&#13;
white&#13;
yellow&#13;
white&#13;
orange&#13;
brown&#13;
pink&#13;
cyan</pre>&#13;
<p class="caption" id="ch2list29"><em>Listing 2-29: Adding multiple elements to an array at once</em></p>&#13;
<p class="indent">Adding multiple items at once can save you a lot of time, especially if you’re creating an array with a large number of items. Note that PowerShell treats any comma-separated set of values as an array, and you don’t explicitly need the <code>@</code> or parentheses.</p>&#13;
<p class="indent">Unfortunately, there is no equivalent of <code>+=</code> to remove an element from an array. Removing elements from an array is more complicated than you might think, and we won’t cover it here. To understand why, read on!</p>&#13;
<h4 class="h4" id="ch2lev4sec11">ArrayLists</h4>&#13;
<p class="noindent">Something strange happens when you add to an array. Every time you add an element to an array, you’re actually creating a new array from your old (interpolated) array and the new element. The same thing happens when you remove an element from an array: PowerShell destroys your old array and makes a new one. This is because arrays in PowerShell have a fixed size. <span epub:type="pagebreak" id="page_30"/>When you change them, you can’t modify the size, so you have to create a new array. For small arrays like the ones we’ve been working with, you won’t notice this happening. But when you begin to work with <em>huge</em> arrays, with tens or hundreds of thousands of elements, you’ll see a big performance hit.</p>&#13;
<p class="indent">If you know you’ll have to remove or add many elements to an array, I suggest you use a different data structure called an <em>ArrayList</em>. ArrayLists behave nearly identically to the typical PowerShell array, but with one crucial difference: they don’t have a fixed size. They can dynamically adjust to added or removed elements, giving a much higher performance when working with large amounts of data.</p>&#13;
<p class="indent">Defining an ArrayList is exactly like defining an array, except that you need to cast it as an ArrayList. <a href="ch02.xhtml#ch2list30">Listing 2-30</a> re-creates the color picker array but casts it as a <code>System.Collections.ArrayList</code> type.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$colorPicker =</span> <span class="codestrong1">[System.Collections.ArrayList]@('blue','white','yellow','black')</span>&#13;
PS&gt; <span class="codestrong1">$colorPicker</span>&#13;
blue&#13;
white&#13;
yellow&#13;
black</pre>&#13;
<p class="caption" id="ch2list30"><em>Listing 2-30: Creating an ArrayList</em></p>&#13;
<p class="indent">As with an array, when you call an ArrayList, each item is displayed on a separate line.</p>&#13;
<h5 class="h5">Adding Elements to an ArrayList</h5>&#13;
<p class="noindent">To add or remove an element from an ArrayList without destroying it, you can use its methods. You can use the <code>Add()</code> and <code>Remove()</code> methods to add or remove items from an ArrayList. <a href="ch02.xhtml#ch2list31">Listing 2-31</a> uses the <code>Add()</code> method and enters the new element within the method’s parentheses.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$colorPicker.Add('gray')</span>&#13;
4</pre>&#13;
<p class="caption" id="ch2list31"><em>Listing 2-31: Adding a single item to an ArrayList</em></p>&#13;
<p class="indent">Notice the output: the number 4, which is the index of the new element you added. Typically, you won’t use this number, so you can send the <code>Add()</code> method output to the <code>$null</code> variable to prevent it from outputting anything, as shown in <a href="ch02.xhtml#ch2list32">Listing 2-32</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$null = $colorPicker.Add('gray')</span></pre>&#13;
<p class="caption" id="ch2list32"><em>Listing 2-32: Sending output to <code>$null</code></em></p>&#13;
<p class="indent">There are a few ways to negate output from PowerShell commands, but assigning output to <code>$null</code> gives the best performance, as the <code>$null</code> variable cannot be reassigned.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_31"/>Removing Elements from an ArrayList</h5>&#13;
<p class="noindent">You can remove elements in a similar way, using the <code>Remove()</code> method. For example, if you want to remove the value <code>gray</code> from the ArrayList, enter the value within the method’s parentheses, as in <a href="ch02.xhtml#ch2list33">Listing 2-33</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$colorPicker.Remove('gray')</span></pre>&#13;
<p class="caption" id="ch2list33"><em>Listing 2-33: Removing an item from an ArrayList</em></p>&#13;
<p class="indent">Notice that to remove an item, you don’t have to know the index number. You can reference the element by its actual value—in this case, <code>gray</code>. If the array has multiple elements with the same value, PowerShell will remove the element closest to the start of the ArrayList.</p>&#13;
<p class="indent">It’s hard to see the performance difference with small examples like these. But ArrayLists perform much better on large datasets than arrays. As with most programming choices, you’ll need to analyze your specific situation to determine whether it makes more sense to use an array or an ArrayList. The rule of thumb is the larger the collection of items you’re working with, the better off you’ll be using an ArrayList. If you’re working with small arrays of fewer than 100 elements or so, you’ll notice little difference between an array and an ArrayList.</p>&#13;
<h4 class="h4" id="ch2lev4sec12">Hashtables</h4>&#13;
<p class="noindent">Arrays and ArrayLists are great when you need your data associated with only a position in a list. But sometimes you’ll want something more direct: a way to correlate two pieces of data. For example, you might have a list of usernames you want to match to real names. In that case, you could use a <em>hashtable</em> (or <em>dictionary</em>), a PowerShell data structure that contains a list of <em>key-value pairs</em>. Instead of using a numeric index, you give PowerShell an input, called a <em>key</em>, and it returns the <em>value</em> associated with that key. So, in our example, you would index into the hashtable by using the username, and it would return that user’s real name.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2list34">Listing 2-34</a> defines a hashtable, called <code>$users</code>, that holds information about three users.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$users = @{</span>&#13;
<span class="codestrong1">    abertram = 'Adam Bertram'</span>&#13;
<span class="codestrong1">    raquelcer = 'Raquel Cerillo'</span>&#13;
<span class="codestrong1">    zheng21 = 'Justin Zheng'</span>&#13;
<span class="codestrong1">}</span>&#13;
PS&gt; <span class="codestrong1">$users</span>&#13;
Name                           Value&#13;
----                           -----&#13;
abertram                       Adam Bertram&#13;
raquelcer                      Raquel Cerillo&#13;
zheng21                        Justin Zheng</pre>&#13;
<p class="caption" id="ch2list34"><em>Listing 2-34: Creating a hashtable</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_32"/>PowerShell will not let you define a hashtable with duplicate keys. Each key has to uniquely point to a single value, which can be an array or even another hashtable!</p>&#13;
<h5 class="h5">Reading Elements from Hashtables</h5>&#13;
<p class="noindent">To access a specific value in a hashtable, you use its key. There are two ways to do this. Say you want to find out the real name of the user <code>abertram</code>. You could use either of the two approaches shown in <a href="ch02.xhtml#ch2list35">Listing 2-35</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$users['abertram']</span>&#13;
Adam Bertram&#13;
PS&gt; <span class="codestrong1">$users.abertram</span>&#13;
Adam Bertram</pre>&#13;
<p class="caption" id="ch2list35"><em>Listing 2-35: Accessing a hashtable’s value</em></p>&#13;
<p class="indent">The two options have subtle differences, but for now, you can choose whichever method you prefer.</p>&#13;
<p class="indent">The second command in <a href="ch02.xhtml#ch2list35">Listing 2-35</a> uses a property: <code>$users.abertram</code>. PowerShell will add each key to the object’s properties. If you want to see all the keys and values a hashtable has, you can access the <code>Keys</code> and <code>Values</code> properties, as in <a href="ch02.xhtml#ch2list36">Listing 2-36</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$users.Keys</span>&#13;
abertram                       &#13;
raquelcer                      &#13;
zheng21                        &#13;
PS&gt; <span class="codestrong1">$users.Values</span>&#13;
Adam Bertram&#13;
Raquel Cerillo&#13;
Justin Zheng</pre>&#13;
<p class="caption" id="ch2list36"><em>Listing 2-36: Reading hashtable keys and values</em></p>&#13;
<p class="indent">If you want to see <em>all</em> the properties of a hashtable (or any object), you can run this command:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Select-Object -InputObject $</span><span class="codeitalicst1">yourobject</span><span class="codestrong1"> -Property *</span></pre>&#13;
<h5 class="h5">Adding and Modifying Hashtable Items</h5>&#13;
<p class="noindent">To add an element to a hashtable, you can use the <code>Add()</code> method or create a new index by using square brackets and an equal sign. Both ways are shown in <a href="ch02.xhtml#ch2list37">Listing 2-37</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$users.Add('natice', 'Natalie Ice')</span>&#13;
PS&gt; <span class="codestrong1">$users['phrigo'] = 'Phil Rigo'</span></pre>&#13;
<p class="caption" id="ch2list37"><em>Listing 2-37: Adding an item to a hashtable</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_33"/>Now your hashtable stores five users. But what happens if you need to change one of the values in your hashtable?</p>&#13;
<p class="indent">When you’re modifying a hashtable, it’s always a good idea to check that the key-value pair you want exists. To check whether a key already exists in a hashtable, you can use the <code>ContainsKey()</code> method, part of every hashtable created in PowerShell. When the hashtable contains the key, it will return <code>True;</code> otherwise, it will return <code>False</code>, as shown in <a href="ch02.xhtml#ch2list38">Listing 2-38</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$users.ContainsKey('johnnyq')</span>&#13;
<span class="codestrong1">False</span></pre>&#13;
<p class="caption" id="ch2list38"><em>Listing 2-38: Checking items in a hashtable</em></p>&#13;
<p class="indent">Once you’ve confirmed the key is in the hashtable, you can modify its value by using a simple equal sign, as shown in <a href="ch02.xhtml#ch2list39">Listing 2-39</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$users['phrigo'] = 'Phoebe Rigo'</span>&#13;
PS&gt;<span class="codestrong1"> $users['phrigo']</span>&#13;
Phoebe Rigo</pre>&#13;
<p class="caption" id="ch2list39"><em>Listing 2-39: Modifying a hashtable value</em></p>&#13;
<p class="indent">As you’ve seen, you can add items to a hashtable in a couple of ways. As you’ll see in the next section, there’s only one way to remove an item from a hashtable.</p>&#13;
<h5 class="h5">Removing Items from a Hashtable</h5>&#13;
<p class="noindent">Like ArrayLists, hashtables have a <code>Remove()</code> method. Simply call it and pass in the key value of the item you want to remove, as in <a href="ch02.xhtml#ch2list40">Listing 2-40</a>.</p>&#13;
<pre>PS&gt; <span class="codestrong1">$users.Remove('natice')</span></pre>&#13;
<p class="caption" id="ch2list40"><em>Listing 2-40: Removing an item from a hashtable</em></p>&#13;
<p class="indent">One of your users should be gone, but you can call the hashtable to double-check. Remember that you can use the <code>Keys</code> property to remind yourself of any key name.</p>&#13;
<h3 class="h3" id="ch2lev5">Creating Custom Objects</h3>&#13;
<p class="noindent">So far in this chapter, you’ve been making and using types of objects built into PowerShell. Most of the time, you can stick with these types and save yourself the work of creating your own. But sometimes you’ll need to create a custom object with properties and methods that you define.</p>&#13;
<p class="indent"><a href="ch02.xhtml#ch2list41">Listing 2-41</a> uses the <code>New-Object</code> cmdlet to define a new object with a <code>PSCustomObject</code> type.</p>&#13;
<pre><span epub:type="pagebreak" id="page_34"/>PS&gt; $myFirstCustomObject = <span class="codestrong1">New-Object -TypeName PSCustomObject</span></pre>&#13;
<p class="caption" id="ch2list41"><em>Listing 2-41: Creating a custom object by using <code>New-Object</code></em></p>&#13;
<p class="indent">This example uses the <code>New-Object</code> command, but you could do the same thing by using an equal sign and a cast, as in <a href="ch02.xhtml#ch2list42">Listing 2-42</a>. You define a hashtable in which the keys are property names, and the values are property values, and then cast it as <code>PSCustomObject</code>.</p>&#13;
<pre>PS&gt; $myFirstCustomObject = <span class="codestrong1">[PSCustomObject]@{OSBuild = 'x'; OSVersion = 'y'}</span></pre>&#13;
<p class="caption" id="ch2list42"><em>Listing 2-42: Creating a custom object by using the <code>PSCustomObject</code> type accelerator</em></p>&#13;
<p class="indent">Notice that <a href="ch02.xhtml#ch2list42">Listing 2-42</a> uses a semicolon (<code>;</code>) to separate the key and value definitions.</p>&#13;
<p class="indent">Once you have a custom object, you use it as you would any other object. <a href="ch02.xhtml#ch2list43">Listing 2-43</a> passes our custom object to the <code>Get_Member</code> cmdlet to check that it is a <code>PSCustomObject</code> type.</p>&#13;
<pre>PS&gt; <span class="codestrong1">Get-Member  -InputObject $myFirstCustomObject</span>&#13;
&#13;
&#13;
   TypeName: System.Management.Automation.PSCustomObject&#13;
&#13;
Name        MemberType   Definition&#13;
----        ----------   ----------&#13;
Equals      Method       bool Equals(System.Object obj)&#13;
GetHashCode Method       int GetHashCode()&#13;
GetType     Method       type GetType()&#13;
ToString    Method       string ToString()&#13;
OSBuild     NoteProperty string OSBuild=OSBuild&#13;
OSVersion   NoteProperty string OSVersion=Version</pre>&#13;
<p class="caption" id="ch2list43"><em>Listing 2-43: Investigating properties and methods of a custom object</em></p>&#13;
<p class="indent">As you can see, your object already has some preexisting methods (for example, one that returns the object’s type!), along with the properties you defined when you created the object in <a href="ch02.xhtml#ch2list42">Listing 2-42</a>.</p>&#13;
<p class="indent">Let’s access those properties by using dot notation:</p>&#13;
<pre>PS&gt; <span class="codestrong1">$myFirstCustomObject.OSBuild</span>&#13;
x&#13;
PS&gt; <span class="codestrong1">$myFirstCustomObject.OSVersion</span>&#13;
y</pre>&#13;
<p class="indent">Looks good! You’ll use <code>PSCustomObject</code> objects a lot throughout the rest of the book. They’re powerful tools that let you create much more flexible code.</p>&#13;
<h3 class="h3" id="ch2lev6"><span epub:type="pagebreak" id="page_35"/>Summary</h3>&#13;
<p class="noindent">By now, you should have a general understanding of objects, variables, and data types. If you still don’t understand these concepts, please reread this chapter. This is some of the most foundational stuff we’ll be covering. A high-level understanding of these concepts will make the rest of this book much easier to understand.</p>&#13;
<p class="indent">The next chapter covers two ways to combine commands in PowerShell: the pipeline and scripts.<span epub:type="pagebreak" id="page_36"/></p>&#13;
</body></html>