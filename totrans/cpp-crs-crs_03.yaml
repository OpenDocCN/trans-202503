- en: '**1'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UP AND RUNNING**
  prefs: []
  type: TYPE_NORMAL
- en: '*. . . with such violence I fell to the ground that I found myself stunned,
    and in a hole nine fathoms under the grass. . . . Looking down, I observed that
    I had on a pair of boots with exceptionally sturdy straps. Grasping them firmly,
    I pulled (repeatedly) with all my might.'
  prefs: []
  type: TYPE_NORMAL
- en: —Rudolph Raspe*, The Singular Adventures of Baron Munchausen
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll begin by setting up a C++ *development environment*,
    which is the collection of tools that enables you to develop C++ software. You’ll
    use the development environment to compile your first C++ *console application*,
    a program that you can run from the command line. Then you’ll learn the main components
    of the development environment along with the role they play in generating the
    application you’ll write. The chapters that follow will cover enough C++ essentials
    to construct useful example programs.
  prefs: []
  type: TYPE_NORMAL
- en: C++ has a reputation for being hard to learn. It’s true that C++ is a big, complex,
    and ambitious language and that even veteran C++ programmers regularly learn new
    patterns, features, and usages.
  prefs: []
  type: TYPE_NORMAL
- en: A major source of nuance is that C++ features mesh together so tightly. Unfortunately,
    this often causes some distress to newcomers. Because C++ concepts are so tightly
    coupled, it’s just not clear where to jump in. [Part I](part01.xhtml#part01) of
    this book charts a deliberate, methodical course through the tumult, but it has
    to begin somewhere. This chapter covers just enough to get you started. Don’t
    sweat the details too much!
  prefs: []
  type: TYPE_NORMAL
- en: '**The Structure of a Basic C++ Program**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, you’ll write a simple C++ program and then compile and run
    it. You write C++ source code into human-readable text files called *source files*.
    Then you use a compiler to convert your C++ into executable machine code, which
    is a program that computers can run.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive in and create your first C++ source file.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating Your First C++ Source File***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Open your favorite text editor. If you don’t have a favorite just yet, try Vim,
    Emacs, or gedit on Linux; TextEdit on Mac; or Notepad on Windows. Enter the code
    in [Listing 1-1](ch01.xhtml#ch01ex01) and save the resulting file to your desktop
    as *main.cpp*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-1: Your first C++ program prints `Hello, world!` to the screen.*'
  prefs: []
  type: TYPE_NORMAL
- en: The [Listing 1-1](ch01.xhtml#ch01ex01) source file compiles to a program that
    prints the characters `Hello, world!` to the screen. By convention, C++ source
    files have a *.cpp* extension.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*In this book, listings will include any program output immediately after the
    program’s source; the output will appear in gray. Numerical annotations will correspond
    with the line that produced the output. The `printf` statement in [Listing 1-1](ch01.xhtml#ch01ex01),
    for example, is responsible for the output `Hello, world!`, so these share the
    same annotation* ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Main: A C++ Program’s Starting Point***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As shown in [Listing 1-1](ch01.xhtml#ch01ex01), C++ programs have a single entry
    point called the `main` function ➋. An *entry point* is a function that executes
    when a user runs a program. *Functions* are blocks of code that can take inputs,
    execute some instructions, and return results.
  prefs: []
  type: TYPE_NORMAL
- en: Within `main`, you call the function `printf`, which prints the characters `Hello,
    world!` to the console ➌. Then the program exits by returning the exit code `0`
    to the operating system ➍. *Exit codes* are integer values that the operating
    system uses to determine how well a program ran. Generally, a zero (`0`) exit
    code means the program ran successfully. Other exit codes might indicate a problem.
    Having a return statement in `main` is optional; the exit code defaults to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The `printf` function is not defined in the program; it’s in the `cstdio` library
    ➊.
  prefs: []
  type: TYPE_NORMAL
- en: '***Libraries: Pulling in External Code***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Libraries* are helpful code collections you can import into your programs
    to prevent having to reinvent the wheel. Virtually every programming language
    has some way of incorporating library functionality into a program:'
  prefs: []
  type: TYPE_NORMAL
- en: Python, Go, and Java have `import`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust, PHP, and C# have `use`/`using`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript, Lua, R, and Perl have `require`/`requires`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C and C++ have `#include`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Listing 1-1](ch01.xhtml#ch01ex01) included `cstdio` ➊, a library that performs
    input/output operations, such as printing to the console.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Compiler Tool Chain**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After writing the source code for a C++ program, the next step is to turn your
    source code into an executable program. The *compiler tool chain* (or *tool chain*)
    is a collection of three elements that run one after the other to convert source
    code into a program:'
  prefs: []
  type: TYPE_NORMAL
- en: The **preprocessor** performs basic source code manipulation. For example, `#include
    <cstdio>` ➊ is a directive that instructs the preprocessor to include information
    about the `cstdio` library directly into your program’s source code. When the
    preprocessor finishes processing a source file, it produces a single translation
    unit. Each translation unit is then passed to the compiler for further processing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **compiler** reads a translation unit and generates an *object file*. Object
    files contain an intermediate format called object code. These files contain data
    and instructions in an intermediate format that most humans wouldn’t understand.
    Compilers work on one translation unit at a time, so each translation unit corresponds
    to a single object file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **linker** generates programs from object files. Linkers are also responsible
    for finding the libraries you’ve included within your source code. When you compile
    [Listing 1-1](ch01.xhtml#ch01ex01), for example, the linker will find the `cstdio`
    library and include everything your program needs to use the `printf` function.
    Note that the `cstdio` header is distinct from the `cstdio` library. The header
    contains information about how to use the library. You’ll learn more about libraries
    and source code organization in [Chapter 21](ch21.xhtml#ch21).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Setting Up Your Development Environment***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: All C++ development environments contain a way to edit source code and a compiler
    tool chain to turn that source code into a program. Often, development environments
    also contain a *debugger*—an invaluable program that lets you step through a program
    line by line to find errors.
  prefs: []
  type: TYPE_NORMAL
- en: When all of these tools—the text editor, the compiler tool chain, and the debugger—are
    bundled into a single program, that program is called an *interactive development
    environment (IDE)*. For beginners and veterans alike, IDEs can be a huge productivity
    booster.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Unfortunately, C++ doesn’t have an interpreter with which to interactively
    execute C++ code snippets. This is different from other languages like Python,
    Ruby, and JavaScript, which do have interpreters. Some web applications exist
    that allow you to test and share small C++ code snippets. See Wandbox (*[https://wandbox.org/](https://wandbox.org/)*),
    which allows you to compile and run code, and Matt Godbolt’s Compiler Explorer
    (*[https://www.godbolt.org/](https://www.godbolt.org/)*), which allows you to
    inspect the assembly code that your code generates. Both work on a variety of
    compilers and systems.*'
  prefs: []
  type: TYPE_NORMAL
- en: Each operating system has its own source code editors and compiler tool chain,
    so this section is broken out by operating system. Skip to the one that is relevant
    to you.
  prefs: []
  type: TYPE_NORMAL
- en: '***Windows 10 and Later: Visual Studio***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At press time, the most popular C++ compiler for Microsoft Windows is the Microsoft
    Visual C++ Compiler (MSVC). The easiest way to obtain MSVC is to install the Visual
    Studio 2017 IDE as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the Community version of Visual Studio 2017\. A link is available at
    [*https://ccc.codes/*](https://ccc.codes/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the installer, allowing it to update if required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the Installing Visual Studio screen, ensure that **Desktop Development with
    C++ Workload** is selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Install** to install Visual Studio 2017 along with MSVC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Launch** to launch Visual Studio 2017\. The entire process might take
    several hours depending on the speed of your machine and your selections. Typical
    installations require 20GB to 50GB.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set up a new project:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **File ▸ New ▸ Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In **Installed**, click **Visual C++** and select **General**. Select **Empty
    Project** in the center panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter hello as the name of your project. Your window should look like [Figure
    1-1](ch01.xhtml#ch01fig01), but the Location will vary depending on your username.
    Click **OK**.![image](../images/fig1_1.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 1-1: The Visual Studio 2017 New Project wizard*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the **Solution Explorer** pane on the left side of the workspace, right-click
    the **Source Files** folder and select **Add ▸ Existing Item**. See [Figure 1-2](ch01.xhtml#ch01fig02).![image](../images/fig1_2.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 1-2: Adding an existing source file to a Visual Studio 2017 project*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the *main.cpp* file that you created earlier in [Listing 1-1](ch01.xhtml#ch01ex01).
    (Alternatively, if you haven’t yet created this file, select **New Item** instead
    of **Existing Item**. Name the file *main.cpp* and type the contents of [Listing
    1-1](ch01.xhtml#ch01ex01) into the resulting editor window.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Build ▸ Build Solution**. If any error messages appear in the output
    box, make sure you’ve typed [Listing 1-1](ch01.xhtml#ch01ex01) correctly. If you
    still get error messages, read them carefully for hints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Debug ▸ Start Without Debugging** or press CTRL-F5 to run your program.
    The letters `Hello, world!` should print to the console (followed by `Press Any
    Key to Continue`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***macOS: Xcode***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re running macOS, you should install the Xcode development environment.
  prefs: []
  type: TYPE_NORMAL
- en: Open the **App Store**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for and install the **Xcode** IDE. Installation might take more than
    an hour depending on the speed of your machine and internet connection. When installation
    is complete, open **Terminal** and navigate to the directory where you’ve saved
    *main.cpp*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter clang++ main.cpp -o hello in the Terminal to compile your program. The
    `-o` option tells the tool chain where to write the output. (If any compiler errors
    appear, check that you’ve entered the program correctly.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter ./hello in the Terminal to run your program. The text `Hello, world!`
    should appear onscreen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To compile and run your program, open the Xcode IDE and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **File ▸ New ▸ Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **macOS ▸ Command Line Tool** and click **Next**. In the next dialog,
    you can modify where to create the project’s file directory. For now, accept the
    defaults and click **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name your project hello and set its **Type** to **C++**. See [Figure 1-3](ch01.xhtml#ch01fig03).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You now need to import your code from [Listing 1-1](ch01.xhtml#ch01ex01) into
    your project. An easy way to do this is to copy and paste the contents of *main.cpp*
    into your project’s *main.cpp*. Another way is to use Finder to replace your *main.cpp*
    into your project’s *main.cpp*. (Normally you won’t have to handle this when creating
    new projects. It’s just an artifact of this tutorial having to handle multiple
    operating environments.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Run**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/fig1_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-3: The New Project dialog in Xcode*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Linux and GCC***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On Linux, you can choose between two main C++ compilers: GCC and Clang. At
    press time, the latest stable release is 9.1 and the latest major Clang release
    is 8.0.0\. In this section, you’ll install both. Some users find the error messages
    from one to be more helpful than the other.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: GCC *is an initialism for* GNU Compiler Collection. *GNU, pronounced “guh-NEW,”
    is a recursive acronym for “GNU’s Not Unix!” GNU is a Unix-like operating system
    and a collection of computer software.*
  prefs: []
  type: TYPE_NORMAL
- en: Try to install GCC and Clang from your operating system’s package manager, but
    beware. Your default repositories might have old versions that may or may not
    have C++ 17 support. If your version doesn’t have C++ 17 support, you won’t be
    able to compile some examples in the book, so you’ll need to install updated versions
    of GCC or Clang. For brevity, this chapter covers how to do this on Debian and
    from source. You can either investigate how to perform corollary actions on your
    chosen Linux flavor or set up a development environment with one of the operating
    systems listed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing GCC and Clang on Debian**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Depending on what software the Personal Package Archives contain when you’re
    reading this chapter, you might be able to install GCC 8.1 and Clang 6.0.0 directly
    using Advanced Package Tool (APT), which is Debian’s package manager. This section
    shows how to install GCC and Clang on Ubuntu 18.04, the latest LTS Ubuntu version
    at press time.
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update and upgrade your currently installed packages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install GCC 8 and Clang 6.0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test GCC and Clang:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If either command returns an error stating that the command wasn’t found, the
    corresponding compiler did not install correctly. Try searching for information
    on the error you receive, especially in the documentation and forums for your
    respective package manager.
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing GCC from Source**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'If you can’t find the latest GCC or Clang versions with your package manager
    (or your Unix variant doesn’t have one), you can always install GCC from source.
    Note that this takes a lot of time (as much as several hours), and you might need
    to get your hands dirty: installation often runs into errors that you’ll need
    to research to resolve. To install GCC, follow the instructions available at [*https://gcc.gnu.org/*](https://gcc.gnu.org/).
    This section summarizes the far more extensive documentation available on that
    site.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For brevity, this tutorial doesn’t detail Clang installation. Refer to* [https://clang.llvm.org/](https://clang.llvm.org/)
    *for more information.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install GCC 8.1 from source, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update and upgrade your currently installed packages. For example, with APT
    you would issue the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From one of the available mirrors at [*https://gcc.gnu.org/mirrors.html*](https://gcc.gnu.org/mirrors.html),
    download the files *gcc-8.1.0.tar.gz* and *gcc-8.1.0.tar.gz.sig*. These files
    can be found in *releases/gcc-8.1.0*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '(Optional) Verify the integrity of the package. First, import the relevant
    GnuPG keys. You can find these listed on the mirrors site. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify what you downloaded:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The warnings you see mean that I haven’t marked the signer’s certificate as
    trusted on my machine. To verify that the signature belongs to the owner, you’ll
    need to verify the signing key using some other means (for example, by meeting
    the owner in person or by verifying the primary key fingerprint out of band).
    For more information about GNU Privacy Guard (GPG), refer to *PGP & GPG: Email
    for the Practical Paranoid* by Michael W. Lucas or browse to [*https://gnupg.org/download/integrity_check.html*](https://gnupg.org/download/integrity_check.html)
    for specific information about GPG’s integrity-checking facilities.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Decompress the package (this command might take a few minutes):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the newly created *gcc-8.1.0* directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Download GCC’s prerequisites:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure GCC using the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Instructions are available at *[https://gcc.gnu.org/install/configure.html](https://gcc.gnu.org/install/configure.html)*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Build the GCC binaries (perhaps do this overnight, because it can take hours):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Full instructions are available at *[https://gcc.gnu.org/install/build.html](https://gcc.gnu.org/install/build.html)*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test whether your GCC binaries built correctly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Full instructions are available at *[https://gcc.gnu.org/install/test.html](https://gcc.gnu.org/install/test.html)*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Install GCC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command places a handful of binaries into your operating system’s default
    executable directory, which is usually */usr/local/bin*. Full instructions are
    available at *[https://gcc.gnu.org/install/](https://gcc.gnu.org/install/)*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Verify that GCC installed correctly by issuing the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you get an error indicating that the command was not found, your installation
    did not succeed. Refer to the gcc-help mailing list at *[https://gcc.gnu.org/ml/gcc-help/](https://gcc.gnu.org/ml/gcc-help/)*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*You might want to alias the cumbersome `x86_64-pc-linux-gnu-gcc-8.1.0` to
    something like `g++8`, for example, using a command like this:*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the directory where you’ve saved *main.cpp* and compile your program
    with GCC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `-o` flag is optional; it tells the compiler what to name the resulting
    program. Because you specified the program name as `hello`, you should be able
    to run your program by entering ./hello. If any compiler errors appear, ensure
    that you input the program’s text correctly. (The compiler errors should help
    you determine what went wrong.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Text Editors***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’d rather not work with one of the aforementioned IDEs, you can write
    C++ code using a simple text editor like Notepad (Windows), TextEdit (Mac), or
    Vim (Linux); however, a number of excellent editors are designed specifically
    for C++ development. Choose the environment that makes you most productive.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re running Windows or macOS, you already have a high-quality, fully featured
    IDE at your disposal, namely Visual Studio or Xcode. Linux options include Qt
    Creator (*[https://www.qt.io/ide/](https://www.qt.io/ide/)*), Eclipse CDT (*[https://eclipse.org/cdt/](https://eclipse.org/cdt/)*),
    and JetBrains’s CLion (*[https://www.jetbrains.com/clion/](https://www.jetbrains.com/clion/)*).
    If you’re a Vim or Emacs user, you’ll find plenty of C++ plug-ins.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If cross-platform C++ is important to you, I highly recommend taking a look
    at Jetbrains’s CLion. Although CLion is a paid product, unlike many of its competitors,
    at press time Jetbrains does offer reduced-price and free licenses for students
    and open source project maintainers.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bootstrapping C++**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This section gives you just enough context to support the example code in the
    chapters to come. You’ll have questions about the details, and the coming chapters
    will answer them. Until then, don’t panic!
  prefs: []
  type: TYPE_NORMAL
- en: '***The C++ Type System***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: C++ is an object-oriented language. Objects are abstractions with state and
    behavior. Think of a real-world object, such as a light switch. You can describe
    its *state* as the condition that the switch is in. Is it on or off? What is the
    maximum voltage it can handle? What room in the house is it in? You could also
    describe the switch’s *behavior*. Does it toggle from one state (on) to another
    state (off)? Or is it a dimmer switch, which can be set to many different states
    between on and off?
  prefs: []
  type: TYPE_NORMAL
- en: The collection of behaviors and states describing an object is called its *type*.
    C++ is a *strongly typed language*, meaning each object has a predefined data
    type.
  prefs: []
  type: TYPE_NORMAL
- en: C++ has a built-in integer type called `int`. An `int` object can store whole
    numbers (its state), and it supports many math operations (its behavior).
  prefs: []
  type: TYPE_NORMAL
- en: To perform any meaningful tasks with `int` types, you’ll create some `int` objects
    and name them. Named objects are called *variables*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Declaring Variables***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You declare variables by providing their type, followed by their name, followed
    by a semicolon. The following example declares a variable called `the_answer`
    with type `int`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The type, `int` ➊, is followed by the variable name, `the_answer` ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '***Initializing a Variable’s State***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When you declare variables, you initialize them. *Object initialization* establishes
    an object’s initial state, such as setting its value. We’ll delve into the details
    of initialization in [Chapter 2](ch02.xhtml#ch02). For now, you can use the equal
    sign (`=`) following a variable declaration to set the variable’s initial value.
    For example, you could declare and assign `the_answer` in one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'After running this line of code, you have a variable called `the_answer` with
    type `int` and value 42\. You can assign variables equal to the result of math
    expressions, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This line evaluates the expression `the_answer / 6` and assigns the result to
    `lucky_number`. The `int` type supports many other operations, such as addition
    `+`, subtraction `-`, multiplication `*`, and modulo division `%`.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you aren’t familiar with modulo division or are wondering what happens
    when you divide two integers and there’s a remainder, you’re asking great questions.
    And those great questions will be answered in detail in [Chapter 7](ch07.xhtml#ch07).*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Conditional Statements***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Conditional statements* allow you to make decisions in your programs. These
    decisions rest on Boolean expressions, which evaluate to true or false. For example,
    you can use *comparison operators*, such as “greater than” or “not equal to,”
    to build Boolean expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: Some basic comparison operators that work with `int` types appear in the program
    in [Listing 1-2](ch01.xhtml#ch01ex02).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-2: A program using comparison operators*'
  prefs: []
  type: TYPE_NORMAL
- en: This program produces no output (compile and run [Listing 1-2](ch01.xhtml#ch01ex02)
    to verify this). While the program doesn’t produce any output, compiling it helps
    to verify that you’ve written valid C++. To generate more interesting programs,
    you’d use a conditional statement like `if`.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `if` statement contains a Boolean expression and one or more nested statements.
    Depending on whether the Boolean evaluates to true or false, the program decides
    which nested statement to execute. There are several forms of `if` statements,
    but the basic usage follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If the Boolean expression ➊ is true, the nested statement ➋ executes; otherwise,
    it doesn’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you’ll want a group of statements to run rather than a single statement.
    Such a group is called a *compound statement*. To declare a compound statement,
    simply wrap the group of statements in braces `{ }`. You can use compound statements
    within `if` statements as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If the Boolean expression ➊ is true, all the statements in the compound statement
    ➋ execute; otherwise, none of them do.
  prefs: []
  type: TYPE_NORMAL
- en: You can elaborate the `if` statement using `else if` and `else` statements.
    These optional additions allow you to describe more complicated branching behavior,
    as shown in [Listing 1-3](ch01.xhtml#ch01ex03).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-3: An `if` statement with `else if` and `else` branches*'
  prefs: []
  type: TYPE_NORMAL
- en: First, boolean-expression-1 ➊ is evaluated. If boolean-expression-1 is true,
    statement-1 is evaluated, and the `if` statement stops executing. If boolean-expression-1
    is false, boolean-expression-2 ➋ is evaluated. If true, statement-2 is evaluated.
    Otherwise, statement-3 ➌ is evaluated. Note that statement-1, statement-2, and
    statement-3 are mutually exclusive and together they cover all possible outcomes
    of the `if` statement. Only one of the three will be evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: You can include any number of `else if` clauses or omit them entirely. As with
    the initial `if` statement, the Boolean expression for each `else if` clause is
    evaluated in order. When one of these Boolean expressions evaluates to `true`,
    evaluation stops and the corresponding statement executes. If no `else if` evaluates
    to `true`, the `else` clause’s statement-3 *always* executes. (As with the `else
    if` clauses, the `else` is optional.)
  prefs: []
  type: TYPE_NORMAL
- en: Consider [Listing 1-4](ch01.xhtml#ch01ex04), which uses an `if` statement to
    determine which statement to print.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-4: A program with conditional behavior*'
  prefs: []
  type: TYPE_NORMAL
- en: Compile the program and run it. Your result should also be `Zero`. Now change
    the `x` value ➊. What does the program print now?
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Notice that `main` in [Listing 1-4](ch01.xhtml#ch01ex04) omits a return statement.
    Because `main` is a special function, return statements are optional.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Functions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Functions are blocks of code that accept any number of input objects called
    *parameters* or *arguments* and can return output objects to their callers.
  prefs: []
  type: TYPE_NORMAL
- en: You declare functions according to the general syntax shown in [Listing 1-5](ch01.xhtml#ch01ex05).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-5: The general syntax for a C++ function*'
  prefs: []
  type: TYPE_NORMAL
- en: The first part of this function declaration is the type of the return variable
    ➊, such as `int`. When the function returns a value ➎, the type of `return-value`
    must match `return-type`.
  prefs: []
  type: TYPE_NORMAL
- en: Then you declare the function’s name ➋ after declaring the return type. A set
    of parentheses following the function name contains any number of comma-separated
    input parameters that the function requires. Each parameter also has a type and
    a name.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-5](ch01.xhtml#ch01ex05) has two parameters. The first parameter
    ➌ has type `par-type1` and is named `par_name1`, and the second parameter ➍ has
    type `par-type2` and is named `par_name2`. Parameters represent the objects passed
    into a function.'
  prefs: []
  type: TYPE_NORMAL
- en: A set of braces following that list contains the function’s body. This is a
    compound statement that contains the function’s logic. Within this logic, the
    function might decide to return a value to the function’s caller. Functions that
    return values will have one or more `return` statements. Once a function returns,
    it stops executing, and the flow of the program returns to whatever called the
    function. Let’s look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: '**Example: A Step Function**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For demonstration purposes, this section shows how to build a mathematical function
    called `step_function` that returns `-1` for all negative arguments, `0` for a
    zero-valued argument, and `1` for all positive arguments. [Listing 1-6](ch01.xhtml#ch01ex06)
    shows how you might write the `step_function`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-6: A step function that returns `-1` for negative values, `0` for
    zero, and `1` for positive values*'
  prefs: []
  type: TYPE_NORMAL
- en: The `step_function` takes a single argument `x` ➊. The `result` variable is
    declared and initialized to `0` ➋. Next, the `if` statement sets `result` to `-1`
    ➌ if `x` is less than `0`. If `x` is greater than `0`, the `if` statement sets
    `result` to `1` ➍. Finally, `result` is returned to the caller ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '**Calling Functions**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To call (or *invoke*) a function, you use the name of the desired function,
    parentheses, and a comma-separated list of the required parameters. The compiler
    reads files from top to bottom, so the function’s declaration must appear before
    its point of first use.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the program in [Listing 1-7](ch01.xhtml#ch01ex07), which uses the `step_function`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-7: A program using the `step_function`. (This program produces no
    output.)*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-7](ch01.xhtml#ch01ex07) calls `step_function` three times with different
    arguments and assigns the results to the variables `value1`, `value2`, and `value3`.'
  prefs: []
  type: TYPE_NORMAL
- en: Wouldn’t it be nice if you could print these values? Fortunately, you can use
    the `printf` function to build output from different variables. The trick is to
    use `printf` format specifiers.
  prefs: []
  type: TYPE_NORMAL
- en: '***printf Format Specifiers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In addition to printing constant strings (like `Hello, world!` in [Listing 1-1](ch01.xhtml#ch01ex01)),
    `printf` can combine multiple values into a nicely formatted string; it is a special
    kind of function that can take one or more arguments.
  prefs: []
  type: TYPE_NORMAL
- en: The first argument to `printf` is always a *format string*. The format string
    provides a template for the string to be printed, and it contains any number of
    special *format specifiers*. Format specifiers tell `printf` how to interpret
    and format the arguments following the format string. All format specifiers begin
    with `%`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the format specifier for an `int` is `%d`. Whenever `printf` sees
    a `%d` in the format string, it knows to expect an `int` argument following the
    format specifier. Then `printf` replaces the format specifier with the argument’s
    actual value.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The `printf` function is a derivative of the `writef` function offered in
    BCPL, a defunct programming language designed by Martin Richards in 1967\. Providing
    the specifiers `%H`, `%I`, and `%O` to `writef` resulted in hexadecimal, decimal,
    and octal output via the functions `WRITEHEX`, `WRITED`, and `WRITEOCT`. It’s
    unclear where the `%d` specifier comes from (perhaps the D in `WRITED`?), but
    we’re stuck with it.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following `printf` call, which prints the string `Ten 10, Twenty
    20, Thirty 30`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The first argument, `"Ten %d, Twenty %d, Thirty %d"`, is the format string.
    Notice that there are three format specifiers `%d` ➊ ➋ ➌. There are also three
    arguments after the format string ➍ ➎ ➏. When `printf` builds the output, it replaces
    the argument at ➊ with the one at ➍, the argument at ➋ with the one at ➎, and
    the argument at ➌ with the one at ➏.
  prefs: []
  type: TYPE_NORMAL
- en: '**IOSTREAMS, PRINTF, AND INPUT OUTPUT PEDAGOGY**'
  prefs: []
  type: TYPE_NORMAL
- en: 'People have really strong opinions about which standard output method to teach
    C++ newcomers. One option is `printf`, which has a lineage that traces back to
    C. Another option is `cout`, which is part of the C++ standard library’s `iostream`
    library. This book teaches both: `printf` in [Part I](part01.xhtml#part01) and
    `cout` in [Part II](part02.xhtml#part02). Here’s why.'
  prefs: []
  type: TYPE_NORMAL
- en: This book builds your C++ knowledge brick by brick. Each chapter is designed
    sequentially so you don’t need a leap of faith to understand code examples. More
    or less, you’ll know exactly what every line does. Because `printf` is fairly
    primitive, you’ll have enough knowledge by [Chapter 3](ch03.xhtml#ch03) to know
    exactly how it works.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, `cout` involves a whole lot of C++ concepts, and you won’t have
    sufficient background to understand how it works until the end of [Part I](part01.xhtml#part01).
    (What’s a stream buffer? What’s `operator<<`? What’s a method? How does `flush()`
    work? Wait, `cout` flushes automatically in the destructor? What’s a destructor?
    What’s `setf`? Actually, what’s a format flag? A `BitmaskType`? Oh my, what’s
    a manipulator? And so on.)
  prefs: []
  type: TYPE_NORMAL
- en: Of course, `printf` has issues, and once you’ve learned `cout`, you should prefer
    it. With `printf` you can easily introduce mismatches between format specifiers
    and arguments, and this can cause strange behavior, program crashes, and even
    security vulnerabilities. Using `cout` means you don’t need format strings, so
    you don’t need to remember format specifiers. You’ll never get mismatches between
    format strings and arguments. Iostreams are also *extensible*, meaning you can
    integrate input and output functionality into your own types.
  prefs: []
  type: TYPE_NORMAL
- en: This book teaches modern C++ directly, but on this particular topic it compromises
    a bit of modernist dogma in exchange for a deliberate, linear approach. As an
    ancillary benefit, you’ll be prepared to encounter `printf` specifiers, which
    is likely to happen at some point in your programming career. Most languages,
    such as C, Python, Java, and Ruby, have facilities for `printf` specifiers, and
    there are analogs in C#, JavaScript, and other languages.
  prefs: []
  type: TYPE_NORMAL
- en: '***Revisiting step_function***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s look at another example that uses `step_function`. [Listing 1-8](ch01.xhtml#ch01ex08)
    incorporates variable declarations, function calls, and `printf` format specifiers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-8: A program that prints the results of applying `step_function`
    to several integers*'
  prefs: []
  type: TYPE_NORMAL
- en: Because the program uses `printf`, `cstdio` ➊ is included. The `step_function`
    ➋ is defined so you can use it later in the program, and `main` ➌ establishes
    the defined entry point.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some listings in this book will build on one another. To save trees, you’ll
    see the use of the `--snip--` notation to denote no changes to the reused portion.*'
  prefs: []
  type: TYPE_NORMAL
- en: Inside `main`, you initialize a few `int` types, like `num1` ➍. Next, you pass
    these variables to `step_function` and initialize result variables to store the
    returned values, like `result1` ➎.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you print the returned values by invoking `printf`. Each invocation
    starts with a format string, like `"Num1: %d, Step: %d\n"` ➏. There are two `%d`
    format specifiers embedded in each format string. Per the requirements of `printf`,
    there are two parameters following the format string, `num1` and `result1`, that
    correspond to these two format specifiers.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Comments***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Comments* are human-readable annotations that you can place into your source
    code. You can add comments to your code using the notation `//` or `/**/`. The
    `//` symbol tells the compiler to ignore everything from the first forward slash
    to the next newline, which means you can put comments in-line with your code as
    well as on their own lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `/**/` notation to include multiline comments in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The comment starts with `/*` and ends with `*/`. (The asterisks on the lines
    between the starting and ending forward slash are optional but are commonly used.)
  prefs: []
  type: TYPE_NORMAL
- en: When to use comments is a matter of eternal debate. Some programming luminaries
    suggest that code should be so expressive and self-explanatory as to render comments
    largely unnecessary. They might say that descriptive variable names, short functions,
    and good tests are usually all the documentation you need. Other programmers like
    to place comments all over the place.
  prefs: []
  type: TYPE_NORMAL
- en: You can cultivate your own philosophy. The compiler will totally ignore whatever
    you do because it never interprets comments.
  prefs: []
  type: TYPE_NORMAL
- en: '**Debugging**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the most important skills for a software engineer is efficient, effective
    debugging. Most development environments have debugging tools. On Windows, macOS,
    and Linux, the debugging tools are excellent. Learning to use them well is an
    investment that pays off very quickly. This section provides a quick tour of how
    to use a debugger to step through the program in [Listing 1-8](ch01.xhtml#ch01ex08).
    You can skip to whichever environment is most relevant to you.
  prefs: []
  type: TYPE_NORMAL
- en: '***Visual Studio***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Visual Studio has an excellent, built-in debugger. I suggest that you debug
    programs in its *Debug* configuration. This causes the tool chain to build a target
    that enhances the debugging experience. The only reason to debug in *Release*
    mode is to diagnose some rare conditions that occur in Release mode but not in
    Debug mode.
  prefs: []
  type: TYPE_NORMAL
- en: Open *main.cpp* and locate the first line of `main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the margin just to the left of the line number corresponding to the first
    line of `main` to insert a breakpoint. A red circle appears where you clicked,
    as shown in [Figure 1-4](ch01.xhtml#ch01fig04).![image](../images/fig1_4.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 1-4: Inserting a breakpoint*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **Debug ▸ Start Debugging**. The program will run up to the line where
    you’ve inserted a breakpoint. The debugger will halt program execution, and a
    yellow arrow will appear to indicate the next instruction to be run, as shown
    in [Figure 1-5](ch01.xhtml#ch01fig05).![image](../images/fig1_5.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 1-5: The debugger halts execution at the breakpoint.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **Debug ▸ Step Over**. The step over operation executes the instruction
    without “stepping into” any function calls. By default, the keyboard shortcut
    for step over is F10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because the next line calls `step_function`, select **Debug ▸ Step Into** to
    call `step_function` and break on the first line. You can continue debugging this
    function by stepping into/over its instructions. By default, the keyboard shortcut
    for step into is F11.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To allow execution to return to `main`, select **Debug ▸ Step Out**. By default,
    the keyboard shortcut for this operation is SHIFT-F11.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inspect the Autos window by selecting **Debug ▸ Windows ▸ Auto**. You can see
    the current value of some of the important variables, as shown in [Figure 1-6](ch01.xhtml#ch01fig06).![image](../images/fig1_6.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 1-6: The Autos window shows the values of variables at the current
    breakpoint.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can see `num1` is set to 42 and `result1` is set to 1\. Why does `num2`
    have a gibberish value? Because the initialization to 0 hasn’t happened yet: it’s
    the next instruction to execute.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The debugger has just emphasized a very important low-level detail: allocating
    an object’s storage and initializing an object’s value are two distinct steps.
    You’ll learn more about storage allocation and object initialization in [Chapter
    4](ch04.xhtml#ch04).*'
  prefs: []
  type: TYPE_NORMAL
- en: The Visual Studio debugger supports many more features. For more information,
    check out the Visual Studio documentation link available at *[https://ccc.codes/](https://ccc.codes/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Xcode***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Xcode also has an excellent, built-in debugger that’s completely integrated
    into the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Open *main.cpp* and locate the first line of `main`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the first line and then select **Debug ▸ Breakpoints ▸ Add Breakpoint
    at Current Line**. A breakpoint appears, as shown in [Figure 1-7](ch01.xhtml#ch01fig07).![image](../images/fig1_7.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 1-7: Inserting a breakpoint*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **Run**. The program will run up to the line with the inserted breakpoint.
    The debugger will halt program execution, and a green arrow will appear to indicate
    the next instruction to be run, as shown in [Figure 1-8](ch01.xhtml#ch01fig08).![image](../images/fig1_8.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 1-8: The debugger halts execution at the breakpoint.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **Debug ▸ Step Over** to execute the instruction without “stepping into”
    any function calls. By default, the keyboard shortcut for step over is F6.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because the next line calls `step_function`, select **Debug ▸ Step Into** to
    call `step_function` and break on the first line. You can continue debugging this
    function by stepping into/over its instructions. By default, the keyboard shortcut
    for step into is F7.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To allow execution to return to `main`, select **Debug ▸ Step Out**. By default,
    the keyboard shortcut for step out is F8.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inspect the Autos window at the bottom of the *main.cpp* screen. You can see
    the current value of some of the important variables, as shown in [Figure 1-9](ch01.xhtml#ch01fig09).![image](../images/fig1_9.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 1-9: The Autos window shows the values of variables at the current
    breakpoint.*'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can see `num1` is set to 42 and `result1` is set to 1\. Why does `num2`
    have a gibberish value? Because the initialization to 0 hasn’t happened yet: it’s
    the next instruction to execute.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Xcode debugger supports many more features. For more information, check
    out the Xcode documentation link at *[https://ccc.codes/](https://ccc.codes/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '***GCC and Clang Debugging with GDB and LLDB***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The GNU Project Debugger (GDB) is a powerful debugger (*[https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/)*).
    You can interact with GDB using the command line. To enable debugging support
    during compilation with `g++` or `clang++`, you must add the `-g` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your package manager will most likely have GDB. For example, to install GDB
    with Advanced Package Tool (APT), enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Clang also has an excellent debugger called the Low Level Debugger (LLDB), which
    you can download at *[https://lldb.llvm.org/](https://lldb.llvm.org/)*. It was
    designed to work with the GDB commands in this section, so for brevity I won’t
    cover LLDB explicitly. You can debug programs compiled with GCC debug support
    using LLDB, and you can debug programs compiled with Clang debug support using
    GDB.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Xcode uses LLDB in the background.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'To debug the program in [Listing 1-8](ch01.xhtml#ch01ex08) (on [page 20](ch01.xhtml#page_20))
    using GDB, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In a command line, navigate to the folder where you’ve stored your header and
    source files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Compile your program with debug support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Debug your program using `gdb`; you should see the following interactive console
    session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To insert a breakpoint, use the command `break`, which takes a single argument
    corresponding to the name of the source file and the line where you want to break,
    separated by a colon (`:`). For example, suppose you want to break on the first
    line of *main.cpp*. In [Listing 1-8](ch01.xhtml#ch01ex08), that is on line 5 (although
    you might need to adjust placement depending on how you’ve written the source).
    You can create a breakpoint using the following command at the (`gdb`) prompt:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can also tell `gdb` to break at a particular function by name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Either way, you can now execute your program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To single step into an instruction, you use the `step` command to follow each
    line of the program, including steps into functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To continue stepping, press ENTER to repeat the last command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To step back out of a function invocation, you use the `finish` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To execute an instruction without stepping into a function call, you use the
    `next` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To inspect the current value of variables, you use the `info locals` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that any variables that have not yet been initialized will not have sensible
    values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To continue execution until the next breakpoint (or until the program completes),
    use the `continue` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the `quit` command to exit `gdb` at any time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: GDB supports many more features. For more information, check out the documentation
    at [*https://sourceware.org/gdb/current/onlinedocs/gdb/*](https://sourceware.org/gdb/current/onlinedocs/gdb/).
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter got you up and running with a working C++ development environment,
    and you compiled your first C++ program. You learned about the components of a
    build tool chain and the roles they play in the compilation process. Then you
    explored a few essential C++ topics, such as types, declaring variables, statements,
    conditionals, functions, and `printf`. The chapter wrapped up with a tutorial
    on setting up a debugger and stepping through your project.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you have problems setting up your environment, search on your error messages
    online. If that fails, post your question to Stack Overflow at* [https://stackoverflow.com/](https://stackoverflow.com/),
    *the C++ subreddit at* [https://www.reddit.com/r/cpp_questions/](https://www.reddit.com/r/cpp_questions/),
    *or the C++ Slack channel at* [https://cpplang.now.sh/](https://cpplang.now.sh/).'
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISES**'
  prefs: []
  type: TYPE_NORMAL
- en: Try these exercises to practice what you’ve learned in this chapter. (The book's
    companion code is available at [https://ccc.codes](https://ccc.codes).)
  prefs: []
  type: TYPE_NORMAL
- en: '**1-1.** Create a function called `absolute_value` that returns the absolute
    value of its single argument. The absolute value of an integer `x` is the following:
    `x` (itself) if `x` is greater than or equal to 0; otherwise, it is `x` times
    −1\. You can use the program in [Listing 1-9](ch01.xhtml#ch01ex09) as a template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 1-9: A template for a program that uses an `absolute_value` function*'
  prefs: []
  type: TYPE_NORMAL
- en: '**1-2.** Try running your program with different values. Did you see the values
    you expect?'
  prefs: []
  type: TYPE_NORMAL
- en: '**1-3.** Run your program with a debugger, stepping through each instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**1-4.** Write another function called `sum` that takes two `int` arguments
    and returns their sum. How can you modify the template in [Listing 1-9](ch01.xhtml#ch01ex09)
    to test your new function?'
  prefs: []
  type: TYPE_NORMAL
- en: '**1-5.** C++ has a vibrant online community, and the internet is awash with
    excellent C++ related material. Investigate the CppCast podcast at [*http://cppcast.com/*](http://cppcast.com/).
    Search for CppCon and C++Now videos available on YouTube. Add [*https://cppreference.com/*](https://cppreference.com/)
    and [*http://www.cplusplus.com/*](http://www.cplusplus.com/) to your browser’s
    bookmarks.'
  prefs: []
  type: TYPE_NORMAL
- en: '**1-6.** Finally, download a copy of the International Organization for Standardization
    (ISO) C++ 17 Standard from [*https://isocpp.org/std/the-standard/*](https://isocpp.org/std/the-standard/).
    Unfortunately, the official ISO standard is copyrighted and must be purchased.
    Fortunately, you can download a “draft,” free of charge, that differs only cosmetically
    from the official version.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Note** *Because the ISO standard’s page numbers differ from version to version,
    this book will refer to specific sections using the same naming schema as the
    standard itself. This schema cites sections by enclosing the section name with
    square brackets. Subsections are appended with period separation. For example,
    to cite the section on the C++ Object Model, which is contained in the Introduction
    section, you would write [intro.object].*'
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The Pragmatic Programmer: From Journeyman to Master* by Andrew Hunt and David
    Thomas (Addison-Wesley Professional, 2000)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Art of Debugging with GDB, DDD, and Eclipse* by Norman Matloff and Peter
    Jay Salzman (No Starch Press, 2008)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*PGP & GPG: Email for the Practical Paranoid* by Michael W. Lucas (No Starch
    Press, 2006)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The GNU Make Book* by John Graham-Cumming (No Starch Press, 2015)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
