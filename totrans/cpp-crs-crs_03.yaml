- en: '**1'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**1'
- en: UP AND RUNNING**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 启动并运行**
- en: '*. . . with such violence I fell to the ground that I found myself stunned,
    and in a hole nine fathoms under the grass. . . . Looking down, I observed that
    I had on a pair of boots with exceptionally sturdy straps. Grasping them firmly,
    I pulled (repeatedly) with all my might.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*. . . 由于如此猛烈的冲击，我摔倒在地，发现自己昏迷不醒，跌入草地下九寻深的坑中。. . . 低头一看，我发现自己穿着一双结实的靴子，带有异常坚固的绑带。我牢牢地抓住它们，用尽全力一再拉扯。*'
- en: —Rudolph Raspe*, The Singular Adventures of Baron Munchausen
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —鲁道夫·拉斯佩，《缪特豪森男爵的独特冒险》
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: In this chapter, you’ll begin by setting up a C++ *development environment*,
    which is the collection of tools that enables you to develop C++ software. You’ll
    use the development environment to compile your first C++ *console application*,
    a program that you can run from the command line. Then you’ll learn the main components
    of the development environment along with the role they play in generating the
    application you’ll write. The chapters that follow will cover enough C++ essentials
    to construct useful example programs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将首先设置一个C++ *开发环境*，这是一个工具集合，使你能够开发C++软件。你将使用开发环境编译你的第一个C++ *控制台应用程序*，这是一个可以从命令行运行的程序。接下来，你将了解开发环境的主要组件及其在生成你编写的应用程序中的作用。接下来的章节将涵盖足够的C++基础内容，帮助你构建有用的示例程序。
- en: C++ has a reputation for being hard to learn. It’s true that C++ is a big, complex,
    and ambitious language and that even veteran C++ programmers regularly learn new
    patterns, features, and usages.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: C++因其学习难度较大而声名显赫。的确，C++是一门庞大、复杂且富有雄心的语言，即便是经验丰富的C++程序员也经常学习新的模式、特性和用法。
- en: A major source of nuance is that C++ features mesh together so tightly. Unfortunately,
    this often causes some distress to newcomers. Because C++ concepts are so tightly
    coupled, it’s just not clear where to jump in. [Part I](part01.xhtml#part01) of
    this book charts a deliberate, methodical course through the tumult, but it has
    to begin somewhere. This chapter covers just enough to get you started. Don’t
    sweat the details too much!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个主要的细微差别在于，C++特性紧密结合在一起。不幸的是，这常常给新手带来困扰。由于C++概念之间紧密耦合，初学者很难明确从何处入手。[本书的第一部分](part01.xhtml#part01)通过有条理、系统化的方式引导你穿越这些复杂的内容，但它必须从某个地方开始。本章将介绍足够的内容，帮助你入门。不要过于担心细节！
- en: '**The Structure of a Basic C++ Program**'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**一个基本C++程序的结构**'
- en: In this section, you’ll write a simple C++ program and then compile and run
    it. You write C++ source code into human-readable text files called *source files*.
    Then you use a compiler to convert your C++ into executable machine code, which
    is a program that computers can run.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你将编写一个简单的C++程序，并进行编译和运行。你将C++源代码写入人类可读的文本文件中，这些文件称为*源文件*。然后，使用编译器将你的C++代码转换为可执行的机器代码，这就是计算机可以运行的程序。
- en: Let’s dive in and create your first C++ source file.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧，创建你的第一个C++源文件。
- en: '***Creating Your First C++ Source File***'
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建你的第一个C++源文件***'
- en: Open your favorite text editor. If you don’t have a favorite just yet, try Vim,
    Emacs, or gedit on Linux; TextEdit on Mac; or Notepad on Windows. Enter the code
    in [Listing 1-1](ch01.xhtml#ch01ex01) and save the resulting file to your desktop
    as *main.cpp*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你最喜欢的文本编辑器。如果你还没有偏好的编辑器，可以尝试Linux上的Vim、Emacs或gedit；Mac上的TextEdit；或者Windows上的Notepad。输入[列表1-1](ch01.xhtml#ch01ex01)中的代码，并将文件保存到桌面，命名为*main.cpp*。
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 1-1: Your first C++ program prints `Hello, world!` to the screen.*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表1-1：你的第一个C++程序将`Hello, world!`输出到屏幕上。*'
- en: The [Listing 1-1](ch01.xhtml#ch01ex01) source file compiles to a program that
    prints the characters `Hello, world!` to the screen. By convention, C++ source
    files have a *.cpp* extension.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表1-1](ch01.xhtml#ch01ex01)源文件编译成一个程序，该程序会将字符`Hello, world!`输出到屏幕上。根据惯例，C++源文件的扩展名为*.cpp*。'
- en: '**NOTE**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*In this book, listings will include any program output immediately after the
    program’s source; the output will appear in gray. Numerical annotations will correspond
    with the line that produced the output. The `printf` statement in [Listing 1-1](ch01.xhtml#ch01ex01),
    for example, is responsible for the output `Hello, world!`, so these share the
    same annotation* ➌.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本书中，代码列表会在程序源代码之后立即展示程序输出；输出部分将以灰色显示。数字标注将与产生输出的行对应。例如，[列表1-1](ch01.xhtml#ch01ex01)中的`printf`语句负责输出`Hello,
    world!`，因此它们共享相同的标注* ➌。'
- en: '***Main: A C++ Program’s Starting Point***'
  id: totrans-18
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***主程序：C++程序的起点***'
- en: As shown in [Listing 1-1](ch01.xhtml#ch01ex01), C++ programs have a single entry
    point called the `main` function ➋. An *entry point* is a function that executes
    when a user runs a program. *Functions* are blocks of code that can take inputs,
    execute some instructions, and return results.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [列表 1-1](ch01.xhtml#ch01ex01) 所示，C++ 程序有一个单一的入口点，叫做 `main` 函数 ➋。*入口点* 是在用户运行程序时执行的函数。*函数*
    是一段代码，它可以接受输入、执行一些指令并返回结果。
- en: Within `main`, you call the function `printf`, which prints the characters `Hello,
    world!` to the console ➌. Then the program exits by returning the exit code `0`
    to the operating system ➍. *Exit codes* are integer values that the operating
    system uses to determine how well a program ran. Generally, a zero (`0`) exit
    code means the program ran successfully. Other exit codes might indicate a problem.
    Having a return statement in `main` is optional; the exit code defaults to `0`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `main` 中，你调用了 `printf` 函数，它将字符 `Hello, world!` 打印到控制台 ➌。然后程序通过返回退出码 `0` 给操作系统退出
    ➍。*退出码* 是操作系统用来确定程序运行状况的整数值。通常，退出码 `0` 表示程序运行成功。其他退出码可能表示出现了问题。在 `main` 中包含返回语句是可选的；默认情况下，退出码为
    `0`。
- en: The `printf` function is not defined in the program; it’s in the `cstdio` library
    ➊.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf` 函数在程序中没有定义；它在 `cstdio` 库中 ➊。'
- en: '***Libraries: Pulling in External Code***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***库：引入外部代码***'
- en: '*Libraries* are helpful code collections you can import into your programs
    to prevent having to reinvent the wheel. Virtually every programming language
    has some way of incorporating library functionality into a program:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*库* 是可以导入到程序中的有用代码集合，避免重新发明轮子。几乎所有的编程语言都有某种方式将库功能集成到程序中：'
- en: Python, Go, and Java have `import`.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python、Go 和 Java 有 `import`。
- en: Rust, PHP, and C# have `use`/`using`.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rust、PHP 和 C# 有 `use`/`using`。
- en: JavaScript, Lua, R, and Perl have `require`/`requires`.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript、Lua、R 和 Perl 有 `require`/`requires`。
- en: C and C++ have `#include`.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C 和 C++ 有 `#include`。
- en: '[Listing 1-1](ch01.xhtml#ch01ex01) included `cstdio` ➊, a library that performs
    input/output operations, such as printing to the console.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 1-1](ch01.xhtml#ch01ex01) 包含了 `cstdio` ➊，这是一个执行输入/输出操作的库，例如打印到控制台。'
- en: '**The Compiler Tool Chain**'
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**编译器工具链**'
- en: 'After writing the source code for a C++ program, the next step is to turn your
    source code into an executable program. The *compiler tool chain* (or *tool chain*)
    is a collection of three elements that run one after the other to convert source
    code into a program:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写完 C++ 程序的源代码后，下一步是将源代码转化为可执行程序。*编译器工具链*（或 *工具链*）是由三个元素组成的集合，它们依次运行，将源代码转换为程序：
- en: The **preprocessor** performs basic source code manipulation. For example, `#include
    <cstdio>` ➊ is a directive that instructs the preprocessor to include information
    about the `cstdio` library directly into your program’s source code. When the
    preprocessor finishes processing a source file, it produces a single translation
    unit. Each translation unit is then passed to the compiler for further processing.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**预处理器** 执行基本的源代码处理。例如，`#include <cstdio>` ➊ 是一个指令，告诉预处理器将 `cstdio` 库的相关信息直接包含到程序的源代码中。当预处理器完成源文件的处理后，它会生成一个单一的翻译单元。每个翻译单元会被传递给编译器进行进一步处理。'
- en: The **compiler** reads a translation unit and generates an *object file*. Object
    files contain an intermediate format called object code. These files contain data
    and instructions in an intermediate format that most humans wouldn’t understand.
    Compilers work on one translation unit at a time, so each translation unit corresponds
    to a single object file.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编译器** 读取翻译单元并生成 *目标文件*。目标文件包含一种称为目标代码的中间格式。这些文件包含数据和指令的中间格式，大多数人无法理解。编译器一次处理一个翻译单元，因此每个翻译单元对应一个单独的目标文件。'
- en: The **linker** generates programs from object files. Linkers are also responsible
    for finding the libraries you’ve included within your source code. When you compile
    [Listing 1-1](ch01.xhtml#ch01ex01), for example, the linker will find the `cstdio`
    library and include everything your program needs to use the `printf` function.
    Note that the `cstdio` header is distinct from the `cstdio` library. The header
    contains information about how to use the library. You’ll learn more about libraries
    and source code organization in [Chapter 21](ch21.xhtml#ch21).
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**链接器**从目标文件生成程序。链接器还负责查找你在源代码中包含的库。例如，当你编译[列表 1-1](ch01.xhtml#ch01ex01)时，链接器会找到`cstdio`库，并包括程序所需的所有内容来使用`printf`函数。请注意，`cstdio`头文件与`cstdio`库是不同的。头文件包含了如何使用该库的信息。你将在[第
    21 章](ch21.xhtml#ch21)中进一步了解库和源代码的组织。'
- en: '***Setting Up Your Development Environment***'
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***设置你的开发环境***'
- en: All C++ development environments contain a way to edit source code and a compiler
    tool chain to turn that source code into a program. Often, development environments
    also contain a *debugger*—an invaluable program that lets you step through a program
    line by line to find errors.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 C++ 开发环境都包含编辑源代码的方法和将源代码转化为程序的编译器工具链。通常，开发环境还包含一个*调试器*——一个非常有价值的程序，它允许你逐行跟踪程序，以找到错误。
- en: When all of these tools—the text editor, the compiler tool chain, and the debugger—are
    bundled into a single program, that program is called an *interactive development
    environment (IDE)*. For beginners and veterans alike, IDEs can be a huge productivity
    booster.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有这些工具——文本编辑器、编译器工具链和调试器——被捆绑到一个程序中时，这个程序被称为*集成开发环境（IDE）*。对于初学者和老手来说，IDE 都能大大提高生产力。
- en: '**NOTE**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Unfortunately, C++ doesn’t have an interpreter with which to interactively
    execute C++ code snippets. This is different from other languages like Python,
    Ruby, and JavaScript, which do have interpreters. Some web applications exist
    that allow you to test and share small C++ code snippets. See Wandbox (*[https://wandbox.org/](https://wandbox.org/)*),
    which allows you to compile and run code, and Matt Godbolt’s Compiler Explorer
    (*[https://www.godbolt.org/](https://www.godbolt.org/)*), which allows you to
    inspect the assembly code that your code generates. Both work on a variety of
    compilers and systems.*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*不幸的是，C++没有一个可以用来交互式执行 C++ 代码片段的解释器。这与其他语言如 Python、Ruby 和 JavaScript 不同，它们有解释器。一些网络应用程序可以让你测试并共享小型
    C++ 代码片段。比如Wandbox（*[https://wandbox.org/](https://wandbox.org/)*），它允许你编译并运行代码，以及
    Matt Godbolt 的 Compiler Explorer（*[https://www.godbolt.org/](https://www.godbolt.org/)*），它允许你检查代码生成的汇编代码。这两者都支持多种编译器和系统。*'
- en: Each operating system has its own source code editors and compiler tool chain,
    so this section is broken out by operating system. Skip to the one that is relevant
    to you.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统都有自己的源代码编辑器和编译器工具链，因此本节按操作系统划分。跳到与你相关的部分。
- en: '***Windows 10 and Later: Visual Studio***'
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Windows 10 及更高版本：Visual Studio***'
- en: 'At press time, the most popular C++ compiler for Microsoft Windows is the Microsoft
    Visual C++ Compiler (MSVC). The easiest way to obtain MSVC is to install the Visual
    Studio 2017 IDE as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，微软 Windows 上最流行的 C++ 编译器是 Microsoft Visual C++ 编译器（MSVC）。获取 MSVC 的最简单方法是按照以下步骤安装
    Visual Studio 2017 IDE：
- en: Download the Community version of Visual Studio 2017\. A link is available at
    [*https://ccc.codes/*](https://ccc.codes/).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 Visual Studio 2017 的社区版。链接可以在[*https://ccc.codes/*](https://ccc.codes/)找到。
- en: Run the installer, allowing it to update if required.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行安装程序，如果需要，允许其进行更新。
- en: At the Installing Visual Studio screen, ensure that **Desktop Development with
    C++ Workload** is selected.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装 Visual Studio 屏幕中，确保选择了**C++ 桌面开发工作负载**。
- en: Click **Install** to install Visual Studio 2017 along with MSVC.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**安装**以安装 Visual Studio 2017 和 MSVC。
- en: Click **Launch** to launch Visual Studio 2017\. The entire process might take
    several hours depending on the speed of your machine and your selections. Typical
    installations require 20GB to 50GB.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**启动**以启动 Visual Studio 2017。整个过程可能需要几小时，具体取决于你的机器速度和所选内容。典型的安装需要 20GB 到 50GB
    的空间。
- en: 'Set up a new project:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个新项目：
- en: Select **File ▸ New ▸ Project**.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文件 ▸ 新建 ▸ 项目**。
- en: In **Installed**, click **Visual C++** and select **General**. Select **Empty
    Project** in the center panel.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**已安装**中，点击**Visual C++**并选择**常规**。在中间面板中选择**空项目**。
- en: Enter hello as the name of your project. Your window should look like [Figure
    1-1](ch01.xhtml#ch01fig01), but the Location will vary depending on your username.
    Click **OK**.![image](../images/fig1_1.jpg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 hello 作为项目名称。您的窗口应该像[图 1-1](ch01.xhtml#ch01fig01)一样，但位置会根据您的用户名有所不同。点击**确定**。![图片](../images/fig1_1.jpg)
- en: '*Figure 1-1: The Visual Studio 2017 New Project wizard*'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 1-1：Visual Studio 2017 新建项目向导*'
- en: In the **Solution Explorer** pane on the left side of the workspace, right-click
    the **Source Files** folder and select **Add ▸ Existing Item**. See [Figure 1-2](ch01.xhtml#ch01fig02).![image](../images/fig1_2.jpg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工作区左侧的**解决方案资源管理器**窗格中，右键点击**源文件**文件夹并选择**添加 ▸ 现有项**。请参见[图 1-2](ch01.xhtml#ch01fig02)。![图片](../images/fig1_2.jpg)
- en: '*Figure 1-2: Adding an existing source file to a Visual Studio 2017 project*'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 1-2：将现有源文件添加到 Visual Studio 2017 项目中*'
- en: Select the *main.cpp* file that you created earlier in [Listing 1-1](ch01.xhtml#ch01ex01).
    (Alternatively, if you haven’t yet created this file, select **New Item** instead
    of **Existing Item**. Name the file *main.cpp* and type the contents of [Listing
    1-1](ch01.xhtml#ch01ex01) into the resulting editor window.)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您之前在[清单 1-1](ch01.xhtml#ch01ex01)中创建的*main.cpp*文件。（或者，如果您尚未创建此文件，请选择**新建项**而不是**现有项**。将文件命名为*main.cpp*，并将[清单
    1-1](ch01.xhtml#ch01ex01)中的内容输入到编辑窗口中。）
- en: Select **Build ▸ Build Solution**. If any error messages appear in the output
    box, make sure you’ve typed [Listing 1-1](ch01.xhtml#ch01ex01) correctly. If you
    still get error messages, read them carefully for hints.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**生成 ▸ 生成解决方案**。如果输出框中出现任何错误信息，请确保您正确输入了[清单 1-1](ch01.xhtml#ch01ex01)。如果仍然收到错误信息，请仔细阅读以寻找提示。
- en: Select **Debug ▸ Start Without Debugging** or press CTRL-F5 to run your program.
    The letters `Hello, world!` should print to the console (followed by `Press Any
    Key to Continue`).
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**调试 ▸ 无调试启动**，或按 CTRL-F5 来运行您的程序。字母`Hello, world!`应该会打印到控制台上（接着会出现`Press
    Any Key to Continue`）。
- en: '***macOS: Xcode***'
  id: totrans-57
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***macOS: Xcode***'
- en: If you’re running macOS, you should install the Xcode development environment.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 macOS，应该安装 Xcode 开发环境。
- en: Open the **App Store**.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**App Store**。
- en: Search for and install the **Xcode** IDE. Installation might take more than
    an hour depending on the speed of your machine and internet connection. When installation
    is complete, open **Terminal** and navigate to the directory where you’ve saved
    *main.cpp*.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索并安装**Xcode** IDE。根据您的机器和网络连接的速度，安装可能需要超过一小时。安装完成后，打开**终端**并导航到您保存*main.cpp*的目录。
- en: Enter clang++ main.cpp -o hello in the Terminal to compile your program. The
    `-o` option tells the tool chain where to write the output. (If any compiler errors
    appear, check that you’ve entered the program correctly.)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中输入`clang++ main.cpp -o hello`来编译您的程序。`-o`选项告诉工具链输出结果的位置。（如果出现编译器错误，请检查您是否正确输入了程序。）
- en: Enter ./hello in the Terminal to run your program. The text `Hello, world!`
    should appear onscreen.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中输入`./hello`来运行您的程序。屏幕上应该会显示文本`Hello, world!`。
- en: 'To compile and run your program, open the Xcode IDE and follow these steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译并运行程序，请打开 Xcode IDE 并按照以下步骤操作：
- en: Select **File ▸ New ▸ Project**.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文件 ▸ 新建 ▸ 项目**。
- en: Select **macOS ▸ Command Line Tool** and click **Next**. In the next dialog,
    you can modify where to create the project’s file directory. For now, accept the
    defaults and click **Create**.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**macOS ▸ 命令行工具**，然后点击**下一步**。在下一个对话框中，您可以修改创建项目文件目录的位置。现在接受默认设置并点击**创建**。
- en: Name your project hello and set its **Type** to **C++**. See [Figure 1-3](ch01.xhtml#ch01fig03).
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目命名为 hello，并将其**类型**设置为**C++**。请参见[图 1-3](ch01.xhtml#ch01fig03)。
- en: You now need to import your code from [Listing 1-1](ch01.xhtml#ch01ex01) into
    your project. An easy way to do this is to copy and paste the contents of *main.cpp*
    into your project’s *main.cpp*. Another way is to use Finder to replace your *main.cpp*
    into your project’s *main.cpp*. (Normally you won’t have to handle this when creating
    new projects. It’s just an artifact of this tutorial having to handle multiple
    operating environments.)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您需要将代码从[清单 1-1](ch01.xhtml#ch01ex01)导入到您的项目中。一种简单的方法是将*main.cpp*的内容复制并粘贴到您的项目的*main.cpp*中。另一种方法是使用
    Finder 将您的*main.cpp*替换为项目中的*main.cpp*。（通常在创建新项目时不需要处理此问题。这只是本教程需要处理多种操作环境的一个产物。）
- en: Click **Run**.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**运行**。
- en: '![image](../images/fig1_3.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/fig1_3.jpg)'
- en: '*Figure 1-3: The New Project dialog in Xcode*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-3：Xcode 中的新建项目对话框*'
- en: '***Linux and GCC***'
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Linux 和 GCC***'
- en: 'On Linux, you can choose between two main C++ compilers: GCC and Clang. At
    press time, the latest stable release is 9.1 and the latest major Clang release
    is 8.0.0\. In this section, you’ll install both. Some users find the error messages
    from one to be more helpful than the other.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，您可以选择两种主要的C++编译器：GCC和Clang。截止目前，最新的稳定版是9.1，而最新的Clang主要版本是8.0.0。在本节中，您将安装这两种编译器。一些用户发现其中一个的错误信息比另一个更有帮助。
- en: '**NOTE**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: GCC *is an initialism for* GNU Compiler Collection. *GNU, pronounced “guh-NEW,”
    is a recursive acronym for “GNU’s Not Unix!” GNU is a Unix-like operating system
    and a collection of computer software.*
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: GCC *是GNU编译器集合*（GNU Compiler Collection）的缩写。*GNU发音为“guh-NEW”，是“GNU’s Not Unix!”的递归缩写。GNU是一个类Unix操作系统和一套计算机软件。*
- en: Try to install GCC and Clang from your operating system’s package manager, but
    beware. Your default repositories might have old versions that may or may not
    have C++ 17 support. If your version doesn’t have C++ 17 support, you won’t be
    able to compile some examples in the book, so you’ll need to install updated versions
    of GCC or Clang. For brevity, this chapter covers how to do this on Debian and
    from source. You can either investigate how to perform corollary actions on your
    chosen Linux flavor or set up a development environment with one of the operating
    systems listed in this chapter.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过操作系统的包管理器安装GCC和Clang，但要小心。您的默认仓库可能包含旧版本，这些版本可能没有C++ 17的支持。如果您的版本不支持C++ 17，您将无法编译书中的某些示例，因此您需要安装更新版本的GCC或Clang。为了简洁起见，本章介绍了如何在Debian上以及从源代码进行安装。您可以调查如何在您选择的Linux版本上执行类似操作，或者设置与本章列出的操作系统之一的开发环境。
- en: '**Installing GCC and Clang on Debian**'
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**在Debian上安装GCC和Clang**'
- en: Depending on what software the Personal Package Archives contain when you’re
    reading this chapter, you might be able to install GCC 8.1 and Clang 6.0.0 directly
    using Advanced Package Tool (APT), which is Debian’s package manager. This section
    shows how to install GCC and Clang on Ubuntu 18.04, the latest LTS Ubuntu version
    at press time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您在阅读本章节时，个人软件包档案（Personal Package Archives）中包含的软件，您可能能够直接使用Debian的高级包工具（APT）安装GCC
    8.1和Clang 6.0.0。本节展示了如何在Ubuntu 18.04（截至本书出版时的最新LTS版本）上安装GCC和Clang。
- en: Open a terminal.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端。
- en: 'Update and upgrade your currently installed packages:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新并升级当前安装的软件包：
- en: '[PRE1]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Install GCC 8 and Clang 6.0:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装GCC 8和Clang 6.0：
- en: '[PRE2]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Test GCC and Clang:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试GCC和Clang：
- en: '[PRE3]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If either command returns an error stating that the command wasn’t found, the
    corresponding compiler did not install correctly. Try searching for information
    on the error you receive, especially in the documentation and forums for your
    respective package manager.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何命令返回错误，提示命令未找到，则说明相应的编译器未正确安装。尝试搜索有关您收到的错误信息，尤其是在您的包管理器的文档和论坛中查找相关信息。
- en: '**Installing GCC from Source**'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**从源代码安装GCC**'
- en: 'If you can’t find the latest GCC or Clang versions with your package manager
    (or your Unix variant doesn’t have one), you can always install GCC from source.
    Note that this takes a lot of time (as much as several hours), and you might need
    to get your hands dirty: installation often runs into errors that you’ll need
    to research to resolve. To install GCC, follow the instructions available at [*https://gcc.gnu.org/*](https://gcc.gnu.org/).
    This section summarizes the far more extensive documentation available on that
    site.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法通过包管理器找到最新的GCC或Clang版本（或您的Unix变种没有包管理器），您始终可以从源代码安装GCC。请注意，这需要很长时间（可能长达几个小时），而且您可能需要动手解决安装过程中出现的错误。这些错误通常需要您自己进行研究来解决。要安装GCC，请按照[https://gcc.gnu.org/](https://gcc.gnu.org/)上的说明操作。本节总结了该网站上更为详细的文档。
- en: '**NOTE**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For brevity, this tutorial doesn’t detail Clang installation. Refer to* [https://clang.llvm.org/](https://clang.llvm.org/)
    *for more information.*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了简洁起见，本教程没有详细说明Clang的安装。有关更多信息，请参考* [https://clang.llvm.org/](https://clang.llvm.org/)
    *。*'
- en: 'To install GCC 8.1 from source, do the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要从源代码安装GCC 8.1，请执行以下操作：
- en: Open a terminal.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开终端。
- en: 'Update and upgrade your currently installed packages. For example, with APT
    you would issue the following command:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新并升级当前安装的软件包。例如，使用APT时，您可以执行以下命令：
- en: '[PRE4]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: From one of the available mirrors at [*https://gcc.gnu.org/mirrors.html*](https://gcc.gnu.org/mirrors.html),
    download the files *gcc-8.1.0.tar.gz* and *gcc-8.1.0.tar.gz.sig*. These files
    can be found in *releases/gcc-8.1.0*.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://gcc.gnu.org/mirrors.html](https://gcc.gnu.org/mirrors.html)上的可用镜像站点下载文件
    *gcc-8.1.0.tar.gz* 和 *gcc-8.1.0.tar.gz.sig*。这些文件可以在 *releases/gcc-8.1.0* 中找到。
- en: '(Optional) Verify the integrity of the package. First, import the relevant
    GnuPG keys. You can find these listed on the mirrors site. For example:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）验证包的完整性。首先，导入相关的 GnuPG 密钥。你可以在镜像站点上找到这些密钥。例如：
- en: '[PRE5]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Verify what you downloaded:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 验证你下载的内容：
- en: '[PRE6]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The warnings you see mean that I haven’t marked the signer’s certificate as
    trusted on my machine. To verify that the signature belongs to the owner, you’ll
    need to verify the signing key using some other means (for example, by meeting
    the owner in person or by verifying the primary key fingerprint out of band).
    For more information about GNU Privacy Guard (GPG), refer to *PGP & GPG: Email
    for the Practical Paranoid* by Michael W. Lucas or browse to [*https://gnupg.org/download/integrity_check.html*](https://gnupg.org/download/integrity_check.html)
    for specific information about GPG’s integrity-checking facilities.'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '你看到的警告意味着我没有在我的机器上将签名者的证书标记为可信。为了验证签名确实属于所有者，你需要通过其他方式验证签名密钥（例如，亲自见面或通过其他途径验证主密钥指纹）。有关
    GNU 隐私保护（GPG）的更多信息，请参考 Michael W. Lucas 的 *PGP & GPG: Email for the Practical
    Paranoid*，或者访问 [*https://gnupg.org/download/integrity_check.html*](https://gnupg.org/download/integrity_check.html)
    获取关于 GPG 完整性检查功能的具体信息。'
- en: 'Decompress the package (this command might take a few minutes):'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压缩包（此命令可能需要几分钟）：
- en: '[PRE7]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Navigate to the newly created *gcc-8.1.0* directory:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新创建的 *gcc-8.1.0* 目录：
- en: '[PRE8]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Download GCC’s prerequisites:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 GCC 的先决条件：
- en: '[PRE9]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Configure GCC using the following commands:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令配置 GCC：
- en: '[PRE10]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Instructions are available at *[https://gcc.gnu.org/install/configure.html](https://gcc.gnu.org/install/configure.html)*.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 说明文档可以在 *[https://gcc.gnu.org/install/configure.html](https://gcc.gnu.org/install/configure.html)*
    上找到。
- en: 'Build the GCC binaries (perhaps do this overnight, because it can take hours):'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 GCC 二进制文件（可能需要整晚时间，因为这可能需要几个小时）：
- en: '[PRE11]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Full instructions are available at *[https://gcc.gnu.org/install/build.html](https://gcc.gnu.org/install/build.html)*.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的说明文档可以在 *[https://gcc.gnu.org/install/build.html](https://gcc.gnu.org/install/build.html)*
    上找到。
- en: 'Test whether your GCC binaries built correctly:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试你的 GCC 二进制文件是否正确构建：
- en: '[PRE12]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Full instructions are available at *[https://gcc.gnu.org/install/test.html](https://gcc.gnu.org/install/test.html)*.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的说明文档可以在 *[https://gcc.gnu.org/install/test.html](https://gcc.gnu.org/install/test.html)*
    上找到。
- en: 'Install GCC:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 GCC：
- en: '[PRE13]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This command places a handful of binaries into your operating system’s default
    executable directory, which is usually */usr/local/bin*. Full instructions are
    available at *[https://gcc.gnu.org/install/](https://gcc.gnu.org/install/)*.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将一批二进制文件放入操作系统的默认可执行目录，通常是 */usr/local/bin*。完整的说明文档可以在 *[https://gcc.gnu.org/install/](https://gcc.gnu.org/install/)*
    上找到。
- en: 'Verify that GCC installed correctly by issuing the following command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令验证 GCC 是否正确安装：
- en: '[PRE14]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you get an error indicating that the command was not found, your installation
    did not succeed. Refer to the gcc-help mailing list at *[https://gcc.gnu.org/ml/gcc-help/](https://gcc.gnu.org/ml/gcc-help/)*.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你收到一个错误，指示找不到命令，说明你的安装没有成功。请参考 gcc-help 邮件列表，网址是 *[https://gcc.gnu.org/ml/gcc-help/](https://gcc.gnu.org/ml/gcc-help/)*。
- en: '**NOTE**'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You might want to alias the cumbersome `x86_64-pc-linux-gnu-gcc-8.1.0` to
    something like `g++8`, for example, using a command like this:*'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*你可能想将繁琐的 `x86_64-pc-linux-gnu-gcc-8.1.0` 别名为类似 `g++8` 的简短名称，例如，可以使用以下命令：*'
- en: '[PRE15]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Navigate to the directory where you’ve saved *main.cpp* and compile your program
    with GCC:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你保存 *main.cpp* 的目录，并使用 GCC 编译你的程序：
- en: '[PRE16]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `-o` flag is optional; it tells the compiler what to name the resulting
    program. Because you specified the program name as `hello`, you should be able
    to run your program by entering ./hello. If any compiler errors appear, ensure
    that you input the program’s text correctly. (The compiler errors should help
    you determine what went wrong.)
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-o` 标志是可选的；它告诉编译器输出程序的名称。因为你指定了程序名称为 `hello`，你应该可以通过输入 ./hello 来运行你的程序。如果出现编译错误，确保你正确输入了程序的代码。（编译错误应该能帮助你找出问题所在。）'
- en: '***Text Editors***'
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***文本编辑器***'
- en: If you’d rather not work with one of the aforementioned IDEs, you can write
    C++ code using a simple text editor like Notepad (Windows), TextEdit (Mac), or
    Vim (Linux); however, a number of excellent editors are designed specifically
    for C++ development. Choose the environment that makes you most productive.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想使用前面提到的 IDE，你可以使用简单的文本编辑器来编写 C++ 代码，比如 Notepad（Windows）、TextEdit（Mac）或
    Vim（Linux）；不过，也有一些优秀的编辑器是专门为 C++ 开发设计的。选择一个让你最有效率的开发环境。
- en: If you’re running Windows or macOS, you already have a high-quality, fully featured
    IDE at your disposal, namely Visual Studio or Xcode. Linux options include Qt
    Creator (*[https://www.qt.io/ide/](https://www.qt.io/ide/)*), Eclipse CDT (*[https://eclipse.org/cdt/](https://eclipse.org/cdt/)*),
    and JetBrains’s CLion (*[https://www.jetbrains.com/clion/](https://www.jetbrains.com/clion/)*).
    If you’re a Vim or Emacs user, you’ll find plenty of C++ plug-ins.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Windows 或 macOS，你已经有了一个高质量、功能齐全的 IDE，即 Visual Studio 或 Xcode。Linux 系统的选择包括
    Qt Creator (*[https://www.qt.io/ide/](https://www.qt.io/ide/)*), Eclipse CDT (*[https://eclipse.org/cdt/](https://eclipse.org/cdt/)*),
    和 JetBrains 的 CLion (*[https://www.jetbrains.com/clion/](https://www.jetbrains.com/clion/)*).
    如果你是 Vim 或 Emacs 用户，你会发现有很多 C++ 插件。
- en: '**NOTE**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If cross-platform C++ is important to you, I highly recommend taking a look
    at Jetbrains’s CLion. Although CLion is a paid product, unlike many of its competitors,
    at press time Jetbrains does offer reduced-price and free licenses for students
    and open source project maintainers.*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果跨平台 C++ 对你很重要，我强烈推荐你看看 JetBrains 的 CLion。虽然 CLion 是一款付费产品，但与许多竞争对手不同，JetBrains
    在发布时确实为学生和开源项目维护者提供了折扣和免费许可证。*'
- en: '**Bootstrapping C++**'
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**引导 C++**'
- en: This section gives you just enough context to support the example code in the
    chapters to come. You’ll have questions about the details, and the coming chapters
    will answer them. Until then, don’t panic!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本节为你提供了足够的上下文，以支持接下来的章节中的示例代码。你可能会有关于细节的问题，接下来的章节会为你解答。在此之前，不必慌张！
- en: '***The C++ Type System***'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***C++ 类型系统***'
- en: C++ is an object-oriented language. Objects are abstractions with state and
    behavior. Think of a real-world object, such as a light switch. You can describe
    its *state* as the condition that the switch is in. Is it on or off? What is the
    maximum voltage it can handle? What room in the house is it in? You could also
    describe the switch’s *behavior*. Does it toggle from one state (on) to another
    state (off)? Or is it a dimmer switch, which can be set to many different states
    between on and off?
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 是一种面向对象的语言。对象是具有状态和行为的抽象。想象一个现实世界中的物体，比如开关。你可以描述它的 *状态*，例如开关当前的状态。它是开着还是关着？它能承受的最大电压是多少？它在房子的哪个房间？你还可以描述开关的
    *行为*。它是从一种状态（开）切换到另一种状态（关）吗？还是它是一个调光开关，可以在开和关之间设定多个状态？
- en: The collection of behaviors and states describing an object is called its *type*.
    C++ is a *strongly typed language*, meaning each object has a predefined data
    type.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 描述一个对象的行为和状态的集合称为它的 *类型*。C++ 是一种 *强类型语言*，意味着每个对象都有一个预定义的数据类型。
- en: C++ has a built-in integer type called `int`. An `int` object can store whole
    numbers (its state), and it supports many math operations (its behavior).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 有一种内建的整数类型，叫做 `int`。一个 `int` 对象可以存储整数（它的状态），并且支持许多数学运算（它的行为）。
- en: To perform any meaningful tasks with `int` types, you’ll create some `int` objects
    and name them. Named objects are called *variables*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `int` 类型执行任何有意义的任务，你需要创建一些 `int` 对象并命名它们。命名的对象称为 *变量*。
- en: '***Declaring Variables***'
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***声明变量***'
- en: 'You declare variables by providing their type, followed by their name, followed
    by a semicolon. The following example declares a variable called `the_answer`
    with type `int`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过提供变量的类型，然后是变量名，最后加上分号来声明变量。以下示例声明了一个名为 `the_answer` 的变量，类型为 `int`：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The type, `int` ➊, is followed by the variable name, `the_answer` ➋.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 类型 `int` ➊ 后面跟着变量名 `the_answer` ➋。
- en: '***Initializing a Variable’s State***'
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***初始化变量的状态***'
- en: 'When you declare variables, you initialize them. *Object initialization* establishes
    an object’s initial state, such as setting its value. We’ll delve into the details
    of initialization in [Chapter 2](ch02.xhtml#ch02). For now, you can use the equal
    sign (`=`) following a variable declaration to set the variable’s initial value.
    For example, you could declare and assign `the_answer` in one line:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明变量时，你是在初始化它们。*对象初始化* 确定了对象的初始状态，例如设置它的值。我们将在[第二章](ch02.xhtml#ch02)中详细讨论初始化的细节。现在，你可以使用等号
    (`=`) 在变量声明后面设置变量的初始值。例如，你可以在一行中声明并赋值 `the_answer`：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After running this line of code, you have a variable called `the_answer` with
    type `int` and value 42\. You can assign variables equal to the result of math
    expressions, such as:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这一行代码后，你将得到一个名为 `the_answer` 的变量，类型为 `int`，值为 42。你可以将变量赋值为数学表达式的结果，例如：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This line evaluates the expression `the_answer / 6` and assigns the result to
    `lucky_number`. The `int` type supports many other operations, such as addition
    `+`, subtraction `-`, multiplication `*`, and modulo division `%`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行计算表达式 `the_answer / 6` 并将结果赋值给 `lucky_number`。`int` 类型支持许多其他操作，如加法 `+`、减法
    `-`、乘法 `*` 和模除运算 `%`。
- en: '**NOTE**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you aren’t familiar with modulo division or are wondering what happens
    when you divide two integers and there’s a remainder, you’re asking great questions.
    And those great questions will be answered in detail in [Chapter 7](ch07.xhtml#ch07).*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你不熟悉模除运算，或者想知道当你将两个整数相除并且有余数时会发生什么，说明你提出了很好的问题。这些问题将在[第7章](ch07.xhtml#ch07)中详细解答。*'
- en: '***Conditional Statements***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***条件语句***'
- en: '*Conditional statements* allow you to make decisions in your programs. These
    decisions rest on Boolean expressions, which evaluate to true or false. For example,
    you can use *comparison operators*, such as “greater than” or “not equal to,”
    to build Boolean expressions.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*条件语句* 允许你在程序中做出决策。这些决策依赖于布尔表达式，布尔表达式的值为真或假。例如，你可以使用 *比较运算符*，例如“大于”或“不等于”，来构建布尔表达式。'
- en: Some basic comparison operators that work with `int` types appear in the program
    in [Listing 1-2](ch01.xhtml#ch01ex02).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一些与 `int` 类型配合使用的基本比较运算符出现在[清单 1-2](ch01.xhtml#ch01ex02)中的程序里。
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 1-2: A program using comparison operators*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-2：使用比较运算符的程序*'
- en: This program produces no output (compile and run [Listing 1-2](ch01.xhtml#ch01ex02)
    to verify this). While the program doesn’t produce any output, compiling it helps
    to verify that you’ve written valid C++. To generate more interesting programs,
    you’d use a conditional statement like `if`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序没有输出（编译并运行[清单 1-2](ch01.xhtml#ch01ex02)来验证这一点）。虽然程序没有输出，但编译它有助于验证你编写了有效的
    C++ 代码。要生成更有趣的程序，你可以使用条件语句，如 `if`。
- en: 'An `if` statement contains a Boolean expression and one or more nested statements.
    Depending on whether the Boolean evaluates to true or false, the program decides
    which nested statement to execute. There are several forms of `if` statements,
    but the basic usage follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `if` 语句包含一个布尔表达式和一个或多个嵌套语句。根据布尔表达式的值是为真还是为假，程序决定执行哪个嵌套语句。`if` 语句有几种形式，但基本用法如下：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If the Boolean expression ➊ is true, the nested statement ➋ executes; otherwise,
    it doesn’t.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果布尔表达式 ➊ 为真，则执行嵌套语句 ➋；否则不执行。
- en: 'Sometimes, you’ll want a group of statements to run rather than a single statement.
    Such a group is called a *compound statement*. To declare a compound statement,
    simply wrap the group of statements in braces `{ }`. You can use compound statements
    within `if` statements as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你会希望一组语句一起执行，而不是单个语句。这样的语句组称为 *复合语句*。要声明一个复合语句，只需将语句组用大括号 `{ }` 包围即可。你可以在
    `if` 语句中使用复合语句，如下所示：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If the Boolean expression ➊ is true, all the statements in the compound statement
    ➋ execute; otherwise, none of them do.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果布尔表达式 ➊ 为真，则复合语句 ➋ 中的所有语句都执行；否则，它们都不执行。
- en: You can elaborate the `if` statement using `else if` and `else` statements.
    These optional additions allow you to describe more complicated branching behavior,
    as shown in [Listing 1-3](ch01.xhtml#ch01ex03).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过 `else if` 和 `else` 语句来扩展 `if` 语句。这些可选的附加语句让你可以描述更复杂的分支行为，如[清单 1-3](ch01.xhtml#ch01ex03)所示。
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 1-3: An `if` statement with `else if` and `else` branches*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-3：带有 `else if` 和 `else` 分支的 `if` 语句*'
- en: First, boolean-expression-1 ➊ is evaluated. If boolean-expression-1 is true,
    statement-1 is evaluated, and the `if` statement stops executing. If boolean-expression-1
    is false, boolean-expression-2 ➋ is evaluated. If true, statement-2 is evaluated.
    Otherwise, statement-3 ➌ is evaluated. Note that statement-1, statement-2, and
    statement-3 are mutually exclusive and together they cover all possible outcomes
    of the `if` statement. Only one of the three will be evaluated.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，布尔表达式 ➊ 会被求值。如果布尔表达式 ➊ 为真，则求值语句 1，`if` 语句停止执行。如果布尔表达式 ➊ 为假，则布尔表达式 ➋ 被求值。如果为真，则求值语句
    2。否则，求值语句 3。请注意，语句 1、语句 2 和语句 3 是互斥的，它们共同覆盖了 `if` 语句的所有可能结果。三者中只会执行一个。
- en: You can include any number of `else if` clauses or omit them entirely. As with
    the initial `if` statement, the Boolean expression for each `else if` clause is
    evaluated in order. When one of these Boolean expressions evaluates to `true`,
    evaluation stops and the corresponding statement executes. If no `else if` evaluates
    to `true`, the `else` clause’s statement-3 *always* executes. (As with the `else
    if` clauses, the `else` is optional.)
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以包含任何数量的`else if`子句，也可以完全省略它们。与最初的`if`语句一样，评估每个`else if`子句时的布尔表达式按顺序进行。当某个布尔表达式评估为`true`时，评估停止，执行相应的语句。如果没有`else
    if`表达式评估为`true`，则`else`子句中的语句-3*总是*执行。（与`else if`子句一样，`else`也是可选的。）
- en: Consider [Listing 1-4](ch01.xhtml#ch01ex04), which uses an `if` statement to
    determine which statement to print.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[示例 1-4](ch01.xhtml#ch01ex04)，它使用`if`语句来确定打印哪一条语句。
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 1-4: A program with conditional behavior*'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 1-4：一个具有条件行为的程序*'
- en: Compile the program and run it. Your result should also be `Zero`. Now change
    the `x` value ➊. What does the program print now?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 编译程序并运行。你的结果应该是`Zero`。现在改变`x`的值 ➊。程序现在打印什么？
- en: '**NOTE**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Notice that `main` in [Listing 1-4](ch01.xhtml#ch01ex04) omits a return statement.
    Because `main` is a special function, return statements are optional.*'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意，[示例 1-4](ch01.xhtml#ch01ex04)中的`main`函数省略了返回语句。由于`main`是一个特殊函数，返回语句是可选的。*'
- en: '***Functions***'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***函数***'
- en: Functions are blocks of code that accept any number of input objects called
    *parameters* or *arguments* and can return output objects to their callers.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是接受任意数量输入对象的代码块，这些输入对象被称为*参数*或*实参*，并且可以向调用者返回输出对象。
- en: You declare functions according to the general syntax shown in [Listing 1-5](ch01.xhtml#ch01ex05).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你按照[示例 1-5](ch01.xhtml#ch01ex05)中展示的一般语法声明函数。
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 1-5: The general syntax for a C++ function*'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 1-5：C++ 函数的一般语法*'
- en: The first part of this function declaration is the type of the return variable
    ➊, such as `int`. When the function returns a value ➎, the type of `return-value`
    must match `return-type`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数声明的第一部分是返回变量的类型 ➊，例如`int`。当函数返回一个值 ➎ 时，`return-value`的类型必须与`return-type`匹配。
- en: Then you declare the function’s name ➋ after declaring the return type. A set
    of parentheses following the function name contains any number of comma-separated
    input parameters that the function requires. Each parameter also has a type and
    a name.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在声明返回类型之后，声明函数的名称 ➋。紧跟在函数名称后的圆括号中包含了函数所需的任何数量的以逗号分隔的输入参数。每个参数也都有类型和名称。
- en: '[Listing 1-5](ch01.xhtml#ch01ex05) has two parameters. The first parameter
    ➌ has type `par-type1` and is named `par_name1`, and the second parameter ➍ has
    type `par-type2` and is named `par_name2`. Parameters represent the objects passed
    into a function.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 1-5](ch01.xhtml#ch01ex05)有两个参数。第一个参数 ➌ 的类型是`par-type1`，名称为`par_name1`，第二个参数
    ➍ 的类型是`par-type2`，名称为`par_name2`。参数表示传递给函数的对象。'
- en: A set of braces following that list contains the function’s body. This is a
    compound statement that contains the function’s logic. Within this logic, the
    function might decide to return a value to the function’s caller. Functions that
    return values will have one or more `return` statements. Once a function returns,
    it stops executing, and the flow of the program returns to whatever called the
    function. Let’s look at an example.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 紧随其后的花括号包含函数的主体。这是一个复合语句，包含函数的逻辑。在该逻辑中，函数可能会决定向调用者返回一个值。返回值的函数会有一个或多个`return`语句。一旦函数返回，执行停止，程序的控制流返回到调用该函数的地方。让我们看一个例子。
- en: '**Example: A Step Function**'
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**示例：阶跃函数**'
- en: For demonstration purposes, this section shows how to build a mathematical function
    called `step_function` that returns `-1` for all negative arguments, `0` for a
    zero-valued argument, and `1` for all positive arguments. [Listing 1-6](ch01.xhtml#ch01ex06)
    shows how you might write the `step_function`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，本节展示了如何构建一个名为`step_function`的数学函数，该函数对于所有负数参数返回`-1`，对于零值参数返回`0`，对于所有正数参数返回`1`。[示例
    1-6](ch01.xhtml#ch01ex06)展示了你如何编写`step_function`。
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 1-6: A step function that returns `-1` for negative values, `0` for
    zero, and `1` for positive values*'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 1-6：一个阶跃函数，对于负值返回 `-1`，对于零返回 `0`，对于正值返回 `1`*'
- en: The `step_function` takes a single argument `x` ➊. The `result` variable is
    declared and initialized to `0` ➋. Next, the `if` statement sets `result` to `-1`
    ➌ if `x` is less than `0`. If `x` is greater than `0`, the `if` statement sets
    `result` to `1` ➍. Finally, `result` is returned to the caller ➎.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`step_function`接受一个单一的参数`x` ➊。`result`变量被声明并初始化为`0` ➋。接下来，`if`语句会将`result`设置为`-1`
    ➌，如果`x`小于`0`。如果`x`大于`0`，`if`语句会将`result`设置为`1` ➍。最后，`result`被返回给调用者 ➎。'
- en: '**Calling Functions**'
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**调用函数**'
- en: To call (or *invoke*) a function, you use the name of the desired function,
    parentheses, and a comma-separated list of the required parameters. The compiler
    reads files from top to bottom, so the function’s declaration must appear before
    its point of first use.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用（或*调用*）一个函数，你需要使用所需函数的名称、括号和以逗号分隔的所需参数列表。编译器按从上到下的顺序读取文件，因此函数的声明必须出现在第一次使用它之前。
- en: Consider the program in [Listing 1-7](ch01.xhtml#ch01ex07), which uses the `step_function`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑[清单 1-7](ch01.xhtml#ch01ex07)中的程序，它使用了`step_function`。
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 1-7: A program using the `step_function`. (This program produces no
    output.)*'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-7：使用`step_function`的程序。（该程序没有输出。）*'
- en: '[Listing 1-7](ch01.xhtml#ch01ex07) calls `step_function` three times with different
    arguments and assigns the results to the variables `value1`, `value2`, and `value3`.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 1-7](ch01.xhtml#ch01ex07)调用`step_function`三次，传入不同的参数，并将结果赋给`value1`、`value2`和`value3`变量。'
- en: Wouldn’t it be nice if you could print these values? Fortunately, you can use
    the `printf` function to build output from different variables. The trick is to
    use `printf` format specifiers.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能打印这些值，那该有多好呢？幸运的是，你可以使用`printf`函数通过不同的变量构建输出。诀窍在于使用`printf`格式说明符。
- en: '***printf Format Specifiers***'
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***printf格式说明符***'
- en: In addition to printing constant strings (like `Hello, world!` in [Listing 1-1](ch01.xhtml#ch01ex01)),
    `printf` can combine multiple values into a nicely formatted string; it is a special
    kind of function that can take one or more arguments.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 除了打印常量字符串（如[清单 1-1](ch01.xhtml#ch01ex01)中的`Hello, world!`），`printf`还可以将多个值组合成格式良好的字符串；它是一种特殊的函数，可以接受一个或多个参数。
- en: The first argument to `printf` is always a *format string*. The format string
    provides a template for the string to be printed, and it contains any number of
    special *format specifiers*. Format specifiers tell `printf` how to interpret
    and format the arguments following the format string. All format specifiers begin
    with `%`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf`的第一个参数始终是*格式字符串*。格式字符串为要打印的字符串提供了模板，并且包含任意数量的特殊*格式说明符*。格式说明符告诉`printf`如何解释和格式化跟随在格式字符串后的参数。所有格式说明符都以`%`开头。'
- en: For example, the format specifier for an `int` is `%d`. Whenever `printf` sees
    a `%d` in the format string, it knows to expect an `int` argument following the
    format specifier. Then `printf` replaces the format specifier with the argument’s
    actual value.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`int`的格式说明符是`%d`。每当`printf`在格式字符串中看到`%d`时，它就知道格式说明符后面需要一个`int`类型的参数。然后，`printf`会用参数的实际值替换格式说明符。
- en: '**NOTE**'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The `printf` function is a derivative of the `writef` function offered in
    BCPL, a defunct programming language designed by Martin Richards in 1967\. Providing
    the specifiers `%H`, `%I`, and `%O` to `writef` resulted in hexadecimal, decimal,
    and octal output via the functions `WRITEHEX`, `WRITED`, and `WRITEOCT`. It’s
    unclear where the `%d` specifier comes from (perhaps the D in `WRITED`?), but
    we’re stuck with it.*'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '*`printf`函数是`writef`函数的衍生版，`writef`函数最初出现在BCPL中，这是一种已废弃的编程语言，由Martin Richards于1967年设计。向`writef`提供`%H`、`%I`和`%O`说明符会通过`WRITEHEX`、`WRITED`和`WRITEOCT`函数输出十六进制、十进制和八进制。`%d`说明符的来源尚不清楚（也许来自`WRITED`中的D？），但我们只能使用它。*'
- en: 'Consider the following `printf` call, which prints the string `Ten 10, Twenty
    20, Thirty 30`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`printf`调用，它打印字符串`Ten 10, Twenty 20, Thirty 30`：
- en: '[PRE28]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The first argument, `"Ten %d, Twenty %d, Thirty %d"`, is the format string.
    Notice that there are three format specifiers `%d` ➊ ➋ ➌. There are also three
    arguments after the format string ➍ ➎ ➏. When `printf` builds the output, it replaces
    the argument at ➊ with the one at ➍, the argument at ➋ with the one at ➎, and
    the argument at ➌ with the one at ➏.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`"Ten %d, Twenty %d, Thirty %d"`是格式字符串。请注意，这里有三个格式说明符`%d` ➊ ➋ ➌。格式字符串后面也有三个参数
    ➍ ➎ ➏。当`printf`构建输出时，它会将位置➊的参数替换为位置➍的参数，将位置➋的参数替换为位置➎的参数，将位置➌的参数替换为位置➏的参数。
- en: '**IOSTREAMS, PRINTF, AND INPUT OUTPUT PEDAGOGY**'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**IOSTREAMS、PRINTF 和输入输出教学法**'
- en: 'People have really strong opinions about which standard output method to teach
    C++ newcomers. One option is `printf`, which has a lineage that traces back to
    C. Another option is `cout`, which is part of the C++ standard library’s `iostream`
    library. This book teaches both: `printf` in [Part I](part01.xhtml#part01) and
    `cout` in [Part II](part02.xhtml#part02). Here’s why.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 人们对教C++新手使用哪种标准输出方法有非常强烈的意见。一个选择是`printf`，它的历史可以追溯到C语言。另一个选择是`cout`，它是C++标准库中`iostream`库的一部分。本书教授两者：在[第一部分](part01.xhtml#part01)中讲解`printf`，在[第二部分](part02.xhtml#part02)中讲解`cout`。原因如下。
- en: This book builds your C++ knowledge brick by brick. Each chapter is designed
    sequentially so you don’t need a leap of faith to understand code examples. More
    or less, you’ll know exactly what every line does. Because `printf` is fairly
    primitive, you’ll have enough knowledge by [Chapter 3](ch03.xhtml#ch03) to know
    exactly how it works.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书是通过一点一点地建立你的C++知识的。每一章都是按顺序设计的，因此你无需凭空猜测就能理解代码示例。或多或少，你会清楚每一行代码的作用。因为`printf`相当原始，到了[第3章](ch03.xhtml#ch03)，你会有足够的知识来准确了解它是如何工作的。
- en: In contrast, `cout` involves a whole lot of C++ concepts, and you won’t have
    sufficient background to understand how it works until the end of [Part I](part01.xhtml#part01).
    (What’s a stream buffer? What’s `operator<<`? What’s a method? How does `flush()`
    work? Wait, `cout` flushes automatically in the destructor? What’s a destructor?
    What’s `setf`? Actually, what’s a format flag? A `BitmaskType`? Oh my, what’s
    a manipulator? And so on.)
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`cout`涉及大量的C++概念，直到[第一部分](part01.xhtml#part01)的结尾，你才有足够的背景知识理解它是如何工作的。（什么是流缓冲区？什么是`operator<<`？什么是方法？`flush()`是如何工作的？等一下，`cout`在析构函数中自动刷新？什么是析构函数？什么是`setf`？实际上，什么是格式标志？`BitmaskType`是什么？天哪，什么是操控器？等等。）
- en: Of course, `printf` has issues, and once you’ve learned `cout`, you should prefer
    it. With `printf` you can easily introduce mismatches between format specifiers
    and arguments, and this can cause strange behavior, program crashes, and even
    security vulnerabilities. Using `cout` means you don’t need format strings, so
    you don’t need to remember format specifiers. You’ll never get mismatches between
    format strings and arguments. Iostreams are also *extensible*, meaning you can
    integrate input and output functionality into your own types.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`printf`有一些问题，一旦你学会了`cout`，你应该更倾向于使用它。使用`printf`时，容易在格式说明符和参数之间引入不匹配，这可能导致奇怪的行为、程序崩溃，甚至安全漏洞。使用`cout`意味着你不需要格式化字符串，因此无需记住格式说明符。你再也不会遇到格式字符串和参数之间的不匹配。I/O流也是*可扩展的*，这意味着你可以将输入和输出功能集成到你自己的类型中。
- en: This book teaches modern C++ directly, but on this particular topic it compromises
    a bit of modernist dogma in exchange for a deliberate, linear approach. As an
    ancillary benefit, you’ll be prepared to encounter `printf` specifiers, which
    is likely to happen at some point in your programming career. Most languages,
    such as C, Python, Java, and Ruby, have facilities for `printf` specifiers, and
    there are analogs in C#, JavaScript, and other languages.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 本书直接教授现代C++，但在这一特定话题上，它有意稍微妥协了一些现代主义的教条，以采取一种有条理的线性方法。作为附带的好处，你将为遇到`printf`说明符做好准备，而这在你的编程生涯中很可能会发生。大多数语言，如C、Python、Java和Ruby，都有`printf`说明符的功能，而C#、JavaScript等语言中也有类似的功能。
- en: '***Revisiting step_function***'
  id: totrans-210
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重新审视step_function***'
- en: Let’s look at another example that uses `step_function`. [Listing 1-8](ch01.xhtml#ch01ex08)
    incorporates variable declarations, function calls, and `printf` format specifiers.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个使用`step_function`的例子。[清单1-8](ch01.xhtml#ch01ex08)包含了变量声明、函数调用和`printf`格式说明符。
- en: '[PRE29]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 1-8: A program that prints the results of applying `step_function`
    to several integers*'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单1-8：一个应用`step_function`处理多个整数并打印结果的程序*'
- en: Because the program uses `printf`, `cstdio` ➊ is included. The `step_function`
    ➋ is defined so you can use it later in the program, and `main` ➌ establishes
    the defined entry point.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于程序使用了`printf`，因此包含了`cstdio` ➊。`step_function` ➋已经定义好，可以在程序后续使用，而`main` ➌则定义了程序的入口点。
- en: '**NOTE**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Some listings in this book will build on one another. To save trees, you’ll
    see the use of the `--snip--` notation to denote no changes to the reused portion.*'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '*本书中的某些清单将相互依赖。为了节省纸张，你将看到使用`--snip--`符号来表示重复部分没有更改。*'
- en: Inside `main`, you initialize a few `int` types, like `num1` ➍. Next, you pass
    these variables to `step_function` and initialize result variables to store the
    returned values, like `result1` ➎.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，你初始化了一些`int`类型的变量，比如`num1` ➍。接着，你将这些变量传递给`step_function`，并初始化结果变量来存储返回的值，比如`result1`
    ➎。
- en: 'Finally, you print the returned values by invoking `printf`. Each invocation
    starts with a format string, like `"Num1: %d, Step: %d\n"` ➏. There are two `%d`
    format specifiers embedded in each format string. Per the requirements of `printf`,
    there are two parameters following the format string, `num1` and `result1`, that
    correspond to these two format specifiers.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，您通过调用 `printf` 打印返回的值。每次调用都以格式字符串开始，例如 `"Num1: %d, Step: %d\n"` ➏。每个格式字符串中都嵌入了两个
    `%d` 格式说明符。根据 `printf` 的要求，格式字符串后面有两个参数，`num1` 和 `result1`，它们分别对应这两个格式说明符。'
- en: '***Comments***'
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***注释***'
- en: '*Comments* are human-readable annotations that you can place into your source
    code. You can add comments to your code using the notation `//` or `/**/`. The
    `//` symbol tells the compiler to ignore everything from the first forward slash
    to the next newline, which means you can put comments in-line with your code as
    well as on their own lines:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '*注释* 是人类可读的注释，您可以将其添加到源代码中。您可以使用 `//` 或 `/**/` 符号来添加注释。`//` 符号告诉编译器忽略从第一个斜杠到下一个换行符之间的所有内容，这意味着您可以将注释嵌入到代码行内或单独放在新的一行：'
- en: '[PRE30]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You can use the `/**/` notation to include multiline comments in your code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `/**/` 符号在代码中包含多行注释：
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The comment starts with `/*` and ends with `*/`. (The asterisks on the lines
    between the starting and ending forward slash are optional but are commonly used.)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注释以 `/*` 开始，以 `*/` 结束。（起始和结束斜杠之间的星号是可选的，但通常会使用它们。）
- en: When to use comments is a matter of eternal debate. Some programming luminaries
    suggest that code should be so expressive and self-explanatory as to render comments
    largely unnecessary. They might say that descriptive variable names, short functions,
    and good tests are usually all the documentation you need. Other programmers like
    to place comments all over the place.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用注释是一个永恒的争论话题。一些编程界的名人建议，代码应当具有足够的表现力和自解释性，以至于注释几乎不再必要。他们可能会说，描述性的变量名、简短的函数和良好的测试通常就是您所需的所有文档。其他程序员则喜欢到处放置注释。
- en: You can cultivate your own philosophy. The compiler will totally ignore whatever
    you do because it never interprets comments.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以培养自己的哲学。编译器会完全忽略您所做的任何事情，因为它从不解释注释。
- en: '**Debugging**'
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**调试**'
- en: One of the most important skills for a software engineer is efficient, effective
    debugging. Most development environments have debugging tools. On Windows, macOS,
    and Linux, the debugging tools are excellent. Learning to use them well is an
    investment that pays off very quickly. This section provides a quick tour of how
    to use a debugger to step through the program in [Listing 1-8](ch01.xhtml#ch01ex08).
    You can skip to whichever environment is most relevant to you.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程师最重要的技能之一就是高效、有效的调试。大多数开发环境都有调试工具。在 Windows、macOS 和 Linux 上，调试工具都非常优秀。学会好好使用它们是一项快速回报的投资。本节提供了如何使用调试器逐步执行程序的快速指南，您可以参考[清单
    1-8](ch01.xhtml#ch01ex08)。您可以跳到最相关的环境。
- en: '***Visual Studio***'
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Visual Studio***'
- en: Visual Studio has an excellent, built-in debugger. I suggest that you debug
    programs in its *Debug* configuration. This causes the tool chain to build a target
    that enhances the debugging experience. The only reason to debug in *Release*
    mode is to diagnose some rare conditions that occur in Release mode but not in
    Debug mode.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 拥有一款优秀的内置调试器。我建议您在 *Debug* 配置下调试程序。这会导致工具链构建一个增强调试体验的目标。唯一需要在
    *Release* 模式下调试的原因是诊断一些仅在 Release 模式下发生，而在 Debug 模式下不会发生的罕见情况。
- en: Open *main.cpp* and locate the first line of `main`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 *main.cpp* 并找到 `main` 的第一行。
- en: Click the margin just to the left of the line number corresponding to the first
    line of `main` to insert a breakpoint. A red circle appears where you clicked,
    as shown in [Figure 1-4](ch01.xhtml#ch01fig04).![image](../images/fig1_4.jpg)
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击 `main` 的第一行对应的行号左侧的边距以插入断点。您点击的位置会出现一个红色圆圈，如[图 1-4](ch01.xhtml#ch01fig04)所示。![image](../images/fig1_4.jpg)
- en: '*Figure 1-4: Inserting a breakpoint*'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 1-4：插入断点*'
- en: Select **Debug ▸ Start Debugging**. The program will run up to the line where
    you’ve inserted a breakpoint. The debugger will halt program execution, and a
    yellow arrow will appear to indicate the next instruction to be run, as shown
    in [Figure 1-5](ch01.xhtml#ch01fig05).![image](../images/fig1_5.jpg)
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **调试 ▸ 开始调试**。程序将运行到您插入断点的那一行。调试器将暂停程序执行，并出现一个黄色箭头指示下一条将要执行的指令，如[图 1-5](ch01.xhtml#ch01fig05)所示。![image](../images/fig1_5.jpg)
- en: '*Figure 1-5: The debugger halts execution at the breakpoint.*'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 1-5：调试器在断点处暂停执行。*'
- en: Select **Debug ▸ Step Over**. The step over operation executes the instruction
    without “stepping into” any function calls. By default, the keyboard shortcut
    for step over is F10.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**调试 ▸ 步过**。步过操作执行指令而不“进入”任何函数调用。默认情况下，步过的快捷键是F10。
- en: Because the next line calls `step_function`, select **Debug ▸ Step Into** to
    call `step_function` and break on the first line. You can continue debugging this
    function by stepping into/over its instructions. By default, the keyboard shortcut
    for step into is F11.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为下一行调用了`step_function`，选择**调试 ▸ 步入**来调用`step_function`并在第一行处中断。你可以通过进入/跳过它的指令继续调试这个函数。默认情况下，步入的快捷键是F11。
- en: To allow execution to return to `main`, select **Debug ▸ Step Out**. By default,
    the keyboard shortcut for this operation is SHIFT-F11.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使执行返回到`main`，请选择**调试 ▸ 步出**。默认情况下，这个操作的快捷键是SHIFT-F11。
- en: Inspect the Autos window by selecting **Debug ▸ Windows ▸ Auto**. You can see
    the current value of some of the important variables, as shown in [Figure 1-6](ch01.xhtml#ch01fig06).![image](../images/fig1_6.jpg)
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择**调试 ▸ 窗口 ▸ Autos**来检查Autos窗口。你可以看到一些重要变量的当前值，如[图1-6](ch01.xhtml#ch01fig06)所示。![image](../images/fig1_6.jpg)
- en: '*Figure 1-6: The Autos window shows the values of variables at the current
    breakpoint.*'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图1-6：Autos窗口显示当前断点处变量的值。*'
- en: 'You can see `num1` is set to 42 and `result1` is set to 1\. Why does `num2`
    have a gibberish value? Because the initialization to 0 hasn’t happened yet: it’s
    the next instruction to execute.'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以看到`num1`被设置为42，`result1`被设置为1。为什么`num2`有一个乱码值？因为初始化为0的操作还没有发生：它是下一个要执行的指令。
- en: '**NOTE**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*The debugger has just emphasized a very important low-level detail: allocating
    an object’s storage and initializing an object’s value are two distinct steps.
    You’ll learn more about storage allocation and object initialization in [Chapter
    4](ch04.xhtml#ch04).*'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*调试器刚刚强调了一个非常重要的低级细节：分配对象的存储和初始化对象的值是两个不同的步骤。你将在[第4章](ch04.xhtml#ch04)中了解更多关于存储分配和对象初始化的内容。*'
- en: The Visual Studio debugger supports many more features. For more information,
    check out the Visual Studio documentation link available at *[https://ccc.codes/](https://ccc.codes/)*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio调试器支持更多的功能。欲了解更多信息，请查看*Visual Studio文档链接：[https://ccc.codes/](https://ccc.codes/)*。
- en: '***Xcode***'
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Xcode***'
- en: Xcode also has an excellent, built-in debugger that’s completely integrated
    into the IDE.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode也有一个优秀的内置调试器，完全集成到IDE中。
- en: Open *main.cpp* and locate the first line of `main`.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开*main.cpp*并定位到`main`的第一行。
- en: Click the first line and then select **Debug ▸ Breakpoints ▸ Add Breakpoint
    at Current Line**. A breakpoint appears, as shown in [Figure 1-7](ch01.xhtml#ch01fig07).![image](../images/fig1_7.jpg)
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击第一行，然后选择**调试 ▸ 断点 ▸ 在当前行添加断点**。断点出现，如[图1-7](ch01.xhtml#ch01fig07)所示。![image](../images/fig1_7.jpg)
- en: '*Figure 1-7: Inserting a breakpoint*'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图1-7：插入断点*'
- en: Select **Run**. The program will run up to the line with the inserted breakpoint.
    The debugger will halt program execution, and a green arrow will appear to indicate
    the next instruction to be run, as shown in [Figure 1-8](ch01.xhtml#ch01fig08).![image](../images/fig1_8.jpg)
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**运行**。程序将运行到插入的断点所在的行。调试器将暂停程序执行，出现一个绿色箭头表示下一个要执行的指令，如[图1-8](ch01.xhtml#ch01fig08)所示。![image](../images/fig1_8.jpg)
- en: '*Figure 1-8: The debugger halts execution at the breakpoint.*'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图1-8：调试器在断点处暂停执行。*'
- en: Select **Debug ▸ Step Over** to execute the instruction without “stepping into”
    any function calls. By default, the keyboard shortcut for step over is F6.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**调试 ▸ 步过**来执行指令，而不“进入”任何函数调用。默认情况下，步过的快捷键是F6。
- en: Because the next line calls `step_function`, select **Debug ▸ Step Into** to
    call `step_function` and break on the first line. You can continue debugging this
    function by stepping into/over its instructions. By default, the keyboard shortcut
    for step into is F7.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为下一行调用了`step_function`，选择**调试 ▸ 步入**来调用`step_function`并在第一行处中断。你可以通过进入/跳过它的指令继续调试这个函数。默认情况下，步入的快捷键是F7。
- en: To allow execution to return to `main`, select **Debug ▸ Step Out**. By default,
    the keyboard shortcut for step out is F8.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使执行返回到`main`，请选择**调试 ▸ 步出**。默认情况下，步出的快捷键是F8。
- en: Inspect the Autos window at the bottom of the *main.cpp* screen. You can see
    the current value of some of the important variables, as shown in [Figure 1-9](ch01.xhtml#ch01fig09).![image](../images/fig1_9.jpg)
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*main.cpp*屏幕底部检查Autos窗口。你可以看到一些重要变量的当前值，如[图1-9](ch01.xhtml#ch01fig09)所示。![image](../images/fig1_9.jpg)
- en: '*Figure 1-9: The Autos window shows the values of variables at the current
    breakpoint.*'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*图 1-9：自动窗口显示当前断点处变量的值。*'
- en: 'You can see `num1` is set to 42 and `result1` is set to 1\. Why does `num2`
    have a gibberish value? Because the initialization to 0 hasn’t happened yet: it’s
    the next instruction to execute.'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以看到 `num1` 被设置为 42，`result1` 被设置为 1。为什么 `num2` 有一个乱码值？因为初始化为 0 的操作还没有发生：它是下一个要执行的指令。
- en: The Xcode debugger supports many more features. For more information, check
    out the Xcode documentation link at *[https://ccc.codes/](https://ccc.codes/)*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 调试器支持更多功能。欲了解更多信息，请查看 Xcode 文档链接 *[https://ccc.codes/](https://ccc.codes/)*。
- en: '***GCC and Clang Debugging with GDB and LLDB***'
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用 GDB 和 LLDB 调试 GCC 和 Clang***'
- en: The GNU Project Debugger (GDB) is a powerful debugger (*[https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/)*).
    You can interact with GDB using the command line. To enable debugging support
    during compilation with `g++` or `clang++`, you must add the `-g` flag.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: GNU 项目调试器（GDB）是一个强大的调试器（*[https://www.gnu.org/software/gdb/](https://www.gnu.org/software/gdb/)*）。你可以使用命令行与
    GDB 交互。要在编译时启用调试支持，使用 `g++` 或 `clang++` 编译时，必须添加 `-g` 标志。
- en: 'Your package manager will most likely have GDB. For example, to install GDB
    with Advanced Package Tool (APT), enter the following command:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你的包管理器很可能已经包含 GDB。例如，要使用高级包工具（APT）安装 GDB，可以输入以下命令：
- en: '[PRE32]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Clang also has an excellent debugger called the Low Level Debugger (LLDB), which
    you can download at *[https://lldb.llvm.org/](https://lldb.llvm.org/)*. It was
    designed to work with the GDB commands in this section, so for brevity I won’t
    cover LLDB explicitly. You can debug programs compiled with GCC debug support
    using LLDB, and you can debug programs compiled with Clang debug support using
    GDB.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Clang 还拥有一个出色的调试器，称为低级调试器（LLDB），你可以在 *[https://lldb.llvm.org/](https://lldb.llvm.org/)*
    下载。它被设计用来与本节中的 GDB 命令一起使用，因此为了简洁起见，我不会详细介绍 LLDB。你可以使用 LLDB 调试使用 GCC 调试支持编译的程序，也可以使用
    GDB 调试使用 Clang 调试支持编译的程序。
- en: '**NOTE**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Xcode uses LLDB in the background.*'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*Xcode 在后台使用 LLDB。*'
- en: 'To debug the program in [Listing 1-8](ch01.xhtml#ch01ex08) (on [page 20](ch01.xhtml#page_20))
    using GDB, follow these steps:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 GDB 调试 [Listing 1-8](ch01.xhtml#ch01ex08)（在 [page 20](ch01.xhtml#page_20)
    页）中的程序，按照以下步骤操作：
- en: In a command line, navigate to the folder where you’ve stored your header and
    source files.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，导航到你存储头文件和源文件的文件夹。
- en: 'Compile your program with debug support:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用调试支持编译程序：
- en: '[PRE33]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Debug your program using `gdb`; you should see the following interactive console
    session:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `gdb` 调试程序，你应该会看到以下交互式控制台会话：
- en: '[PRE34]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To insert a breakpoint, use the command `break`, which takes a single argument
    corresponding to the name of the source file and the line where you want to break,
    separated by a colon (`:`). For example, suppose you want to break on the first
    line of *main.cpp*. In [Listing 1-8](ch01.xhtml#ch01ex08), that is on line 5 (although
    you might need to adjust placement depending on how you’ve written the source).
    You can create a breakpoint using the following command at the (`gdb`) prompt:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要插入断点，可以使用 `break` 命令，它接受一个参数，该参数是源文件的名称和你想要断点的行号，两者之间用冒号（`:`）分隔。例如，假设你想要在 *main.cpp*
    的第一行设置断点。在 [Listing 1-8](ch01.xhtml#ch01ex08) 中，这在第 5 行（虽然你可能需要根据你的源代码位置调整）。你可以在（`gdb`）提示符下使用以下命令设置断点：
- en: '[PRE35]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can also tell `gdb` to break at a particular function by name:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以告诉 `gdb` 在特定函数处按名称设置断点：
- en: '[PRE36]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Either way, you can now execute your program:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论哪种方式，你现在都可以执行你的程序：
- en: '[PRE37]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'To single step into an instruction, you use the `step` command to follow each
    line of the program, including steps into functions:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要单步执行一条指令，可以使用 `step` 命令逐行跟踪程序的执行，包括进入函数：
- en: '[PRE38]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To continue stepping, press ENTER to repeat the last command:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要继续单步执行，按 ENTER 重复上一个命令：
- en: '[PRE39]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To step back out of a function invocation, you use the `finish` command:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从函数调用中回退出来，可以使用 `finish` 命令：
- en: '[PRE40]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To execute an instruction without stepping into a function call, you use the
    `next` command:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要执行一条指令而不进入函数调用，可以使用 `next` 命令：
- en: '[PRE41]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To inspect the current value of variables, you use the `info locals` command:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查当前变量的值，可以使用 `info locals` 命令：
- en: '[PRE42]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice that any variables that have not yet been initialized will not have sensible
    values.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，任何尚未初始化的变量将没有合理的值。
- en: 'To continue execution until the next breakpoint (or until the program completes),
    use the `continue` command:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要继续执行直到下一个断点（或者程序完成），可以使用 `continue` 命令：
- en: '[PRE43]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Use the `quit` command to exit `gdb` at any time.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `quit` 命令可以随时退出 `gdb`。
- en: GDB supports many more features. For more information, check out the documentation
    at [*https://sourceware.org/gdb/current/onlinedocs/gdb/*](https://sourceware.org/gdb/current/onlinedocs/gdb/).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: GDB支持更多功能。有关详细信息，请查阅文档：[*https://sourceware.org/gdb/current/onlinedocs/gdb/*](https://sourceware.org/gdb/current/onlinedocs/gdb/)。
- en: '**Summary**'
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: This chapter got you up and running with a working C++ development environment,
    and you compiled your first C++ program. You learned about the components of a
    build tool chain and the roles they play in the compilation process. Then you
    explored a few essential C++ topics, such as types, declaring variables, statements,
    conditionals, functions, and `printf`. The chapter wrapped up with a tutorial
    on setting up a debugger and stepping through your project.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 本章带你搭建了一个有效的C++开发环境，并编译了你的第一个C++程序。你了解了构建工具链的组成部分以及它们在编译过程中的作用。接着，你探索了一些C++的基本主题，如数据类型、声明变量、语句、条件语句、函数和`printf`。本章最后通过一个教程指导你设置调试器，并逐步调试你的项目。
- en: '**NOTE**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you have problems setting up your environment, search on your error messages
    online. If that fails, post your question to Stack Overflow at* [https://stackoverflow.com/](https://stackoverflow.com/),
    *the C++ subreddit at* [https://www.reddit.com/r/cpp_questions/](https://www.reddit.com/r/cpp_questions/),
    *or the C++ Slack channel at* [https://cpplang.now.sh/](https://cpplang.now.sh/).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你在设置环境时遇到问题，可以在线搜索错误信息。如果仍然无法解决，可以将问题发布到Stack Overflow：[https://stackoverflow.com/](https://stackoverflow.com/)，C++子版块：[https://www.reddit.com/r/cpp_questions/](https://www.reddit.com/r/cpp_questions/)，或C++
    Slack频道：[https://cpplang.now.sh/](https://cpplang.now.sh/)。*'
- en: '**EXERCISES**'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: Try these exercises to practice what you’ve learned in this chapter. (The book's
    companion code is available at [https://ccc.codes](https://ccc.codes).)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这些练习来巩固本章所学内容。（本书的配套代码可在[https://ccc.codes](https://ccc.codes)获取。）
- en: '**1-1.** Create a function called `absolute_value` that returns the absolute
    value of its single argument. The absolute value of an integer `x` is the following:
    `x` (itself) if `x` is greater than or equal to 0; otherwise, it is `x` times
    −1\. You can use the program in [Listing 1-9](ch01.xhtml#ch01ex09) as a template:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**1-1.** 创建一个名为`absolute_value`的函数，它返回其单个参数的绝对值。整数`x`的绝对值定义为：如果`x`大于或等于0，则返回`x`本身；否则，返回`x`乘以−1。你可以使用[清单
    1-9](ch01.xhtml#ch01ex09)中的程序作为模板：'
- en: '[PRE44]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '*Listing 1-9: A template for a program that uses an `absolute_value` function*'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1-9：使用`absolute_value`函数的程序模板*'
- en: '**1-2.** Try running your program with different values. Did you see the values
    you expect?'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**1-2.** 尝试使用不同的值运行程序。你是否看到了预期的结果？'
- en: '**1-3.** Run your program with a debugger, stepping through each instruction.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**1-3.** 使用调试器运行程序，逐步执行每条指令。'
- en: '**1-4.** Write another function called `sum` that takes two `int` arguments
    and returns their sum. How can you modify the template in [Listing 1-9](ch01.xhtml#ch01ex09)
    to test your new function?'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**1-4.** 编写另一个名为`sum`的函数，它接受两个`int`类型的参数并返回它们的和。你如何修改[清单 1-9](ch01.xhtml#ch01ex09)中的模板来测试你的新函数？'
- en: '**1-5.** C++ has a vibrant online community, and the internet is awash with
    excellent C++ related material. Investigate the CppCast podcast at [*http://cppcast.com/*](http://cppcast.com/).
    Search for CppCon and C++Now videos available on YouTube. Add [*https://cppreference.com/*](https://cppreference.com/)
    and [*http://www.cplusplus.com/*](http://www.cplusplus.com/) to your browser’s
    bookmarks.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**1-5.** C++拥有一个活跃的在线社区，互联网上充满了许多优秀的C++相关资源。可以查看CppCast播客：[*http://cppcast.com/*](http://cppcast.com/)。搜索CppCon和C++Now的YouTube视频。将[*https://cppreference.com/*](https://cppreference.com/)和[*http://www.cplusplus.com/*](http://www.cplusplus.com/)添加到浏览器的书签中。'
- en: '**1-6.** Finally, download a copy of the International Organization for Standardization
    (ISO) C++ 17 Standard from [*https://isocpp.org/std/the-standard/*](https://isocpp.org/std/the-standard/).
    Unfortunately, the official ISO standard is copyrighted and must be purchased.
    Fortunately, you can download a “draft,” free of charge, that differs only cosmetically
    from the official version.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**1-6.** 最后，从[*https://isocpp.org/std/the-standard/*](https://isocpp.org/std/the-standard/)下载国际标准化组织（ISO）C++
    17标准的副本。不幸的是，官方ISO标准是有版权的，需要购买。幸运的是，你可以免费下载“草案”版本，它与正式版的唯一区别是外观上的。'
- en: '**Note** *Because the ISO standard’s page numbers differ from version to version,
    this book will refer to specific sections using the same naming schema as the
    standard itself. This schema cites sections by enclosing the section name with
    square brackets. Subsections are appended with period separation. For example,
    to cite the section on the C++ Object Model, which is contained in the Introduction
    section, you would write [intro.object].*'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** *由于ISO标准的页码会因版本不同而有所差异，本书将使用与标准本身相同的命名规则来引用特定章节。该命名规则通过将章节名称用方括号括起来来引用章节。子章节则通过句点分隔。例如，要引用包含在引言部分的C++对象模型章节，应写作
    [intro.object]。*'
- en: '**FURTHER READING**'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*The Pragmatic Programmer: From Journeyman to Master* by Andrew Hunt and David
    Thomas (Addison-Wesley Professional, 2000)'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实用程序员：从学徒到大师* 由Andrew Hunt和David Thomas编写（Addison-Wesley Professional, 2000）'
- en: '*The Art of Debugging with GDB, DDD, and Eclipse* by Norman Matloff and Peter
    Jay Salzman (No Starch Press, 2008)'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用GDB、DDD和Eclipse进行调试艺术* 由Norman Matloff和Peter Jay Salzman编写（No Starch Press,
    2008）'
- en: '*PGP & GPG: Email for the Practical Paranoid* by Michael W. Lucas (No Starch
    Press, 2006)'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PGP与GPG: 实用偏执者的电子邮件* 由Michael W. Lucas编写（No Starch Press, 2006）'
- en: '*The GNU Make Book* by John Graham-Cumming (No Starch Press, 2015)'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GNU Make书籍* 由John Graham-Cumming编写（No Starch Press, 2015）'
