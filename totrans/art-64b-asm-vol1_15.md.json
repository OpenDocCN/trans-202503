["```\n; Listing 13-1\n\n; CTL \"Hello, world!\" program.\n\necho    Listing 13-1: Hello, world!\nend\n```", "```\nml64 /c listing13-1.asm\n```", "```\nListing 13-1: Hello, world! \n```", "```\necho \"Hello World\"\n\ncall print\nbyte \"Hello World\", nl,0 \n```", "```\n.err <Statement must have exactly one operand>\n```", "```\ninc_by equ 1\nctlVar = 0\nctlVar = ctlVar + inc_by\n```", "```\nnum10   =        10\ntext10  textequ  <10>\ntn11    textequ  %num10 + 1\n```", "```\nnum10  . . . . . . . . . . . . .        Number   0000000Ah\ntext10 . . . . . . . . . . . . .        Text     10\ntn11 . . . . . . . . . . . . . .        Text     11\n```", "```\n`identifier`   catstr  `string1`, `string2`, ...\n```", "```\nhelloWorld catstr <Hello>, <, >, <World!!>\n```", "```\n`identifier`  instr  `start`, `source`, `search`\n```", "```\nWorldPosn  instr 1, <Hello World>, <World>\n```", "```\n`identifier`  sizestr  `string`\n```", "```\nhwLen sizestr <Hello World>\n```", "```\n`identifier` substr `source`, `start`, `len`\n```", "```\nhString substr <Hello World>, 1, 5\n```", "```\nif `constant_boolean_expression`  \n      `Text`  \nendif \n```", "```\nif `constant_boolean_expression1`\n      `Text`  \nelseif `constant_boolean_expression2`\n      `Text`  \nelse \n      `Text`  \nendif \n```", "```\n; Set true (1) to use FCOMI`xx` instrs.\n\nPentProOrLater = 0\n          . \n          . \n          . \n        if PentProOrLater\n\n          fcomip st(0), st(1) ; Compare ST1 to ST0 and set flags\n\n        else \n\n          fcomp               ; Compare ST1 to ST0\n          fstsw ax            ; Move the FPU condition code bits\n          sahf                ; into the FLAGS register\n\n        endif \n```", "```\n; Note: uncomment the following line if you are compiling this \n; code for a Pentium Pro or later CPU. \n\n; PentProOrLater = 0       ; Value and type are irrelevant\n          . \n          . \n          . \nifdef PentProOrLater \n\n     fcomip st(0), st(1)   ; Compare ST1 to ST0 and set flags\n\nelse \n\n     fcomp                 ; Compare ST1 to ST0\n     fstsw ax              ; Move the FPU condition code bits\n     sahf                  ; into the FLAGS register\n\nendif \n```", "```\n; Set to true to activate debug output.\n\ndebug   =    0\n . \n          . \n          . \n     if debug\n\n        echo *** DEBUG build\n\n        mov  edx, i\n        call print\n        byte \"At point A, i=%d\", nl, 0 \n\n     else\n\n     echo *** RELEASE build\n\n     endif \n```", "```\nwhile `constant_boolean_expression`\n      `Text` \nendm \n```", "```\n; Listing 13-2\n\n; CTL while loop demonstration program.\n\n        option  casemap:none\n\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 13-2\", 0\n\n            .data\nary         dword   2, 3, 5, 8, 13\n\n            include getTitle.inc\n            include print.inc\n\n            .code\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbx\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 56           ; Shadow storage\n\ni           =       0            \n            while   i LT lengthof ary ; 5  \n\n            mov     edx, i            ; This is a constant!\n            mov     r8d, ary[i * 4]   ; Index is a constant\n            call    print\n            byte    \"array[%d] = %d\", nl, 0\n\ni           =       i + 1\n            endm \n\nallDone:    leave\n            pop     rbx\n            ret     ; Returns to caller\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing13-2**\n\nC:\\>**echo off**\n Assembling: listing13-2.asm\nc.cpp\n\nC:\\>**listing13-2**\nCalling Listing 13-2:\narray[0] = 2\narray[1] = 3\narray[2] = 5\narray[3] = 8\narray[4] = 13\nListing 13-2 terminated\n```", "```\n.\n.\n.\nmov     edx, 0          ; This is a constant!\nmov     r8d, ary[0]     ; Index is a constant\ncall    print\nbyte    \"array[%d] = %d\", nl, 0\n\nmov     edx, 1          ; This is a constant!\nmov     r8d, ary[4]     ; Index is a constant\ncall    print\nbyte    \"array[%d] = %d\", nl, 0\n\nmov     edx, 2          ; This is a constant!\nmov     r8d, ary[8]     ; Index is a constant\ncall    print\nbyte    \"array[%d] = %d\", nl, 0\n\nmov     edx, 3          ; This is a constant!\nmov     r8d, ary[12]    ; Index is a constant\ncall    print\nbyte    \"array[%d] = %d\", nl, 0\n\nmov     edx, 4          ; This is a constant!\nmov     r8d, ary[16]    ; Index is a constant\ncall    print\nbyte    \"array[%d] = %d\", nl, 0\n```", "```\nfor `identifier`, <`arg1`, `arg2`, ..., `argn`> \n  . \n  . \n  . \nendm \n\nforc `identifier`, <`string`>\n  . \n  . \n  . \nendm \n```", "```\nfor  reg, <rax, rbx, rcx, rdx>\npush reg\nendm\n```", "```\npush rax\npush rbx\npush rcx\npush rdx\n```", "```\n forc   hex, <0123456789ABCDEF>\nhexNum  catstr <0>,<hex>,<h>\n        byte   hexNum\n        endm\n```", "```\n`macro_name` macro `arguments` \n      `Macro body`\n          endm\n```", "```\nneg128 macro \n\n       neg rdx \n       neg rax \n       sbb rdx, 0 \n\n       endm \n```", "```\nmov    rax, qword ptr i128 \nmov    rdx, qword ptr i128[8] \nneg128 \n```", "```\nneg128p  proc \n\n         neg   rdx\n         neg   rax\n         sbb   rdx, 0\n         ret\n\nneg128p  endp\n```", "```\nneg128\ncall   neg128p \n```", "```\nneg  rdx\nneg  rax\nsbb  rdx, 0\n```", "```\ncall neg128p\n```", "```\nneg128  macro reg64HO, reg64LO\n\n        neg   reg64HO\n        neg   reg64LO\n        sbb   reg64HO, 0\n\n        endm \n```", "```\nneg128  rdx, rax\n```", "```\nneg128 rdx, rax\nneg128 rbx, rcx \n```", "```\n; neg128 rdx, rax \n\n     neg rdx \n     neg rax \n     sbb rdx, 0\n\n; neg128 rbx, rcx \n\n     neg rbx \n     neg rcx \n     sbb rbx, 0 \n```", "```\nreg64HO  textequ <rdx> \nreg64LO  textequ <rax> \n\n         neg    reg64HO  \n         neg    reg64LO  \n         sbb    reg64HO, 0 \n```", "```\nchkError macro instr, jump, target\n\n         instr \n         jump  target \n\n         endm\n\n     chkError <cmp eax, 0>, jnl, RangeError  ; Example 1\n          .\n          .\n          . \n chkError <test bl, 1>, jnz, ParityError ; Example 2\n\n; Example 1 expands to:\n\n     cmp  eax, 0 \n     jnl  RangeError \n\n; Example 2 expands to:\n\n     test bl, 1 \n     jnz  ParityError\n```", "```\n_print macro strToPrint \n\n       call print\n       byte strToPrint, nl, 0 \n\n      endm \n       . \n       . \n       . \n      _print \"Hello, world!\"\n```", "```\nEcho2nTimes macro n, theStr\nechoCnt     =     0\n            while echoCnt LT n * 2\n\n            call  print\n            byte  theStr, nl, 0\n\nechoCnt     =     echoCnt + 1\n            endm\n            endm\n . \n             . \n             . \n            Echo2nTimes  3 + 1, \"Hello\"\n```", "```\nwhile  echoCnt LT 3 + 1 * 2\n```", "```\nEcho2nTimes macro n, theStr\nechoCnt     =     0\n            while echoCnt LT (n) * 2\n\n            call  print\n            byte  theStr, nl, 0\n\nechoCnt     =     echoCnt + 1\n            endm  ; while\n            endm  ; macro\n```", "```\nwhile  echoCnt LT (3 + 1) * 2 \ncall   print\nbyte   theStr, nl, 0\nendm\n```", "```\nEcho2nTimes  %3 + 1, \"Hello\"\n```", "```\nneg128      macro   `arg1`, `arg2`      ; Line 6\n            neg     `arg1`            ; Line 7\n            neg     `arg2`            ; Line 8\n            sbb     `arg1`, 0         ; Line 9\n            endm                    ; Line 10\n                                    ; Line 11\n            neg128  rdx             ; Line 12\n```", "```\nlisting14.asm(12) : error A2008:syntax error : in instruction\n neg128(2): Macro Called From\n  listing14.asm(12): Main Line Code\n```", "```\nneg128  macro reg64HO, reg64LO\n\n        if   reg64LO eq <>\n        .err <neg128 requires 2 operands>\n        endif\n\n        neg  reg64HO\n        neg  reg64LO\n        sbb  reg64O, 0\n        endm\n         .\n         .\n         .\n        neg128 rdx \n```", "```\n if   eq\n```", "```\nneg128  macro reg64HO, reg64LO\n\n        ifb  <reg64LO>\n        .err <neg128 requires 2 operands>\n        endif\n\n neg  reg64HO\n        neg  reg64LO\n        sbb  reg64HO, 0\n        endm\n```", "```\nsymbol      textequ <>\n            neg128  rax, symbol     ; Generates an error\n```", "```\nneg128  macro reg64HO:req, reg64LO:req\n        neg   reg64HO\n        neg   reg64LO\n        sbb   reg64HO, 0\n        endm\n```", "```\nlisting14.asm(12) : error A2125:missing macro argument\n```", "```\nneg128  macro reg64HO:=<rdx>, reg64LO:=<rax>\n        neg   reg64HO\n        neg   reg64LO\n        sbb   reg64HO, 0\n        endm\n```", "```\nneg128       ; Defaults to \"RDX, RAX\" for the args\nneg128 rbx   ; Uses RBX:RAX for the 128-bit register pair\n```", "```\nvarParms  macro varying:vararg \n\n     ` Macro body`\n\n          endm \n           . \n           . \n           . \n          varParms 1 \n          varParms 1, 2 \n          varParms 1, 2, 3 \n          varParms \n```", "```\nvarParms  macro varying:vararg \n          for   curArg, <varying>\n          byte  curArg\n          endm  ; End of FOR loop\n          endm  ; End of macro\n\n          varParms 1 \n          varParms 1, 2 \n          varParms 1, 2, 3\n          varParms <5 dup (?)> \n```", "```\n 00000000                        .data\n                       varParms  macro varying:vararg\n                                 for   curArg, <varying>\n                                 byte  curArg\n                                 endm  ; End of FOR loop\n                                 endm  ; End of macro\n\n                                 varParms 1\n 00000000  01         2          byte  1\n                                 varParms 1, 2\n 00000001  01         2          byte  1\n 00000002  02         2          byte  2\n                                 varParms 1, 2, 3\n 00000003  01         2          byte  1\n 00000004  02         2          byte  2\n 00000005  03         2          byte  3\n                                 varParms <5 dup (?)>\n 00000006  00000005 [ 2          byte  5 dup (?)\n            00\n           ]\n```", "```\nexpand      macro   parm\n            byte    '&parm', 0\n            endm    \n\n            .data\n            expand  a\n```", "```\nbyte 'a', 0\n```", "```\nexpand      macro   parm\n            byte    '&', 'parm', 0\n            endm \n```", "```\njzc    macro  target\n\n       jnz    NotTarget \n       jc     target \nNotTarget: \n       endm \n```", "```\njzc Dest1 \n  . \n  . \n  . \njzc Dest2 \n  . \n  . \n  . \n```", "```\n jnz NotTarget \n         jc Dest1 \nNotTarget: \n          . \n          . \n          . \n         jnz NotTarget \n         jc Dest2 \nNotTarget: \n          . \n          . \n          . \n```", "```\n`macro_name`    macro  `optional_parameters` \n              local  `list_of_local_names`\n         `Macro body`\n              endm \n```", "```\njzc      macro   target\n         local   NotTarget\n\n         jnz     NotTarget\n         jc      target\nNotTarget: \n\n         endm \n```", "```\nneg128  macro reg64HO, reg64LO\n\n        ifb   <reg64LO>\n        .err  <neg128 requires 2 operands>\n        exitm\n        endif\n\n        neg   reg64HO\n        neg   reg64LO\n        sbb   reg64HO, 0\n        endm\n```", "```\nmov rax, `some_macro_invocation`(`arguments`)\n```", "```\n; Listing 13-4\n\n; CTL while loop demonstration program.\n\n        option  casemap:none\n\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 13-4\", 0\n\n; upperCase macro function.\n\n; Converts text argument to a string, converting\n; all lowercase characters to uppercase.\n\nupperCase   macro   theString\n            local   resultString, thisChar, sep\nresultStr   equ     <> ; Initialize function result with \"\"\nsep         textequ <> ; Initialize separator char with \"\"\n\n            forc    curChar, theString\n\n; Check to see if the character is lowercase.\n; Convert it to uppercase if it is, otherwise\n; output it to resultStr as is. Concatenate the\n; current character to the end of the result string\n; (with a \", \" separator, if this isn't the first\n; character appended to resultStr).\n\n if      ('&curChar' GE 'a') and ('&curChar' LE 'z')\nresultStr   catstr  resultStr, sep, %'&curChar'-32\n            else\nresultStr   catstr  resultStr, sep, %'&curChar'\n            endif\n\n; First time through, sep is the empty string. For all\n; other iterations, sep is the comma separator between\n; values.\n\nsep         textequ <, >\n            endm    ; End for\n\n            exitm   <resultStr>\n            endm    ; End macro\n\n; Demonstration of the upperCase macro function:\n\n            .data\nchars       byte    \"Demonstration of upperCase\"\n            byte    \"macro function:\"\n            byte    upperCase(<abcdEFG123>), nl, 0\n\n            .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbx\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 56         ; Shadow storage\n\n            lea     rcx, chars      ; Prints characters converted to uppercase\n            call    printf\n\nallDone:    leave\n            pop     rbx\n            ret     ; Returns to caller\nasmMain     endp\n            end\n```", "```\n; @sizestr - Replacement for the MASM @sizestr function\n;            that Microsoft removed from MASM.\n\n@sizestr    macro   theStr\n            local   theLen\ntheLen      sizestr <theStr>\n            exitm   <&theLen>\n            endm\n```", "```\nunique macro \n       local  theSym\n       exitm  <theSym>\n       endm\n```", "```\n; Listing 13-5\n\n; Creating lookup tables with macros.\n\n        option  casemap:none\n\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 13-5\", 0\nfmtStr1     byte    \"testString converted to UC:\", nl\n            byte    \"%s\", nl, 0\n\nfmtStr2     byte    \"testString converted to LC:\", nl\n            byte    \"%s\", nl, 0\n\ntestString  byte    \"This is a test string \", nl\n            byte    \"Containing UPPERCASE \", nl\n            byte    \"and lowercase chars\", nl, 0\n\nemitChRange macro   start, last\n            local   index, resultStr\nindex       =       start\n            while   index lt last\n            byte    index\nindex       =       index + 1\n            endm\n            endm\n\n; Lookup table that will convert lowercase\n; characters to uppercase. The byte at each\n; index contains the value of that index,\n; except for the bytes at indexes \"a\" to \"z\".\n; Those bytes contain the values \"A\" to \"Z\".\n; Therefore, if a program uses an ASCII\n; character's numeric value as an index\n; into this table and retrieves that byte,\n; it will convert the character to uppercase.\n\nlcToUC      equ             this byte\n            emitChRange     0, 'a'\n            emitChRange     'A', %'Z'+1\n            emitChRange     %'z'+1, 0ffh\n\n; As above, but this table converts uppercase\n; to lowercase characters.\n\nUCTolc      equ             this byte\n            emitChRange     0, 'A'\n            emitChRange     'a', %'z'+1\n            emitChRange     %'Z'+1, 0ffh\n\n            .data\n\n; Store the destination strings here:\n\ntoUC        byte    256 dup (0)\nTOlc        byte    256 dup (0)     \n\n            .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbx\n            push    rdi\n            push    rsi\n            push    rbp\n            mov     rbp, rsp\n sub     rsp, 56         ; Shadow storage\n\n; Convert the characters in testString to uppercase:\n\n            lea     rbx, lcToUC\n            lea     rsi, testString\n            lea     rdi, toUC\n            jmp     getUC\n\ntoUCLp:     xlat\n            mov     [rdi], al\n            inc     rsi\n            inc     rdi\ngetUC:      mov     al, [rsi]\n            cmp     al, 0\n            jne     toUCLp\n\n; Display the converted string:\n\n            lea     rcx, fmtStr1\n            lea     rdx, toUC\n            call    printf\n\n; Convert the characters in testString to lowercase:\n\n            lea     rbx, UCTolc\n            lea     rsi, testString\n            lea     rdi, TOlc\n            jmp     getLC\n\ntoLCLp:     xlat\n            mov     [rdi], al\n            inc     rsi\n            inc     rdi\ngetLC:      mov     al, [rsi]\n            cmp     al, 0\n            jne     toLCLp\n\n; Display the converted string:\n\n            lea     rcx, fmtStr2\n            lea     rdx, TOlc\n            call    printf\n\nallDone:    leave\n            pop     rsi\n            pop     rdi\n            pop     rbx\n            ret     ; Returns to caller\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing13-5**\n\nC:\\>**echo off**\n Assembling: listing13-5.asm\nc.cpp\n\nC:\\>**listing13-5**\nCalling Listing 13-5:\ntestString converted to UC:\nTHIS IS A TEST STRING\nCONTAINING UPPERCASE\nAND LOWERCASE CHARS\n\ntestString converted to LC:\nthis is a test string\ncontaining uppercase\nand lowercase chars\n\nListing 13-5 terminated\n```", "```\ncount = 0\nwhile count LT 10\n     call print\n     byte \"Hello World\", nl, 0 \n\ncount = count + 1\nendm\n```", "```\n xor eax, eax   ; Set EAX and RBX to 0\n        xor rbx, rbx\n        lea rcx, array\nwhlLp:  cmp rbx, 20\n        jae loopDone\n        mov [rcx][rbx * 4], eax\n        inc rbx\n        jmp whlLp\n\nloopDone: \n```", "```\nmov  [rcx][0 * 4], eax\nmov  [rcx][1 * 4], eax\nmov  [rcx][2 * 4], eax\nmov  [rcx][3 * 4], eax\nmov  [rcx][4 * 4], eax\nmov  [rcx][5 * 4], eax\nmov  [rcx][6 * 4], eax\nmov  [rcx][7 * 4], eax\nmov  [rcx][8 * 4], eax\nmov  [rcx][9 * 4], eax\nmov [rcx][10 * 4], eax \nmov [rcx][11 * 4], eax \nmov [rcx][12 * 4], eax \nmov [rcx][13 * 4], eax \nmov [rcx][14 * 4], eax \nmov [rcx][15 * 4], eax \nmov [rcx][16 * 4], eax \nmov [rcx][17 * 4], eax \nmov [rcx][18 * 4], eax \nmov [rcx][19 * 4], eax \n```", "```\niteration = 0\nwhile iteration LT 20 \n     mov [rcx][iteration * 4], eax\n     iteration = iteration + 1\nendm \n```", "```\niteration = 0\nwhile iteration LT 20 \n     mov array[iteration * 4], eax\n     iteration = iteration + 1\nendm \n```", "```\nsomeProc  macro\n          call    _someProc\n          endm\n\n_someProc proc\n            .\n            .\n            .\n_someProc endp\n            .\n            .\n            .\n          someProc   ; Call the procedure\n```", "```\nsomeProc  macro   parm1\n          mov     rcx, parm1\n          call    _someProc\n          endm\n           .\n           .\n           .\n          someProc Parm1Value\n```", "```\nlea     rcx, `parm1`\n```", "```\nmovss  xmm0, parm1  ; Use this for real4 parameters\nmovsd  xmm0, parm1  ; Use this for real8 parameters\n```", "```\ncprintf  macro  parm1\n         lea    rcx, parm1\n         call   printf\n         endm\n```", "```\ncprintf fmtStr\n```", "```\ncprintf \"This is a printf format string\"\n```", "```\nlea   rcx, \"This is a printf format string\"\n```", "```\ncprintf  macro  parm1\n         local  fmtStr\n         .data\nfmtStr   byte   parm1, nl, 0\n         .code\n         lea    rcx, fmtStr\n         call   printf\n         endm\n```", "```\n .data\nfmtStr   byte   \"This is a printf format string\", nl, 0\n         .code\n         lea    rcx, fmtStr  ; Technically, fmtStr will really be something\n         call   printf       ; like ??0001\n```", "```\ncprintf fmtStr\n```", "```\n; Listing 13-6\n\n; opattr demonstration.\n\n        option  casemap:none\n\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 13-6\", 0\n\nfmtStr      byte    nl, \"Hello, World! #2\", nl, 0\n\n            .code\n            externdef printf:proc\n\n; Return program title to C++ program:\n\n            public  getTitle\ngetTitle    proc\n            lea     rax, ttlStr\n            ret\ngetTitle    endp\n\n; cprintf macro:\n\n;           cprintf fmtStr\n;           cprintf \"Format String\"\n\ncprintf     macro   fmtStrArg\n            local   fmtStr, attr, isConst\n\nattr        =       opattr fmtStrArg\nisConst     =       (attr and 4) eq 4\n            if      (attr eq 0) or isConst\n            .data   \nfmtStr      byte    fmtStrArg, nl, 0\n            .code\n            lea     rcx, fmtStr\n\n            else\n\n lea     rcx, fmtStrArg\n\n            endif\n            call    printf\n            endm\n\natw         =       opattr \"Hello World\"\nbin         =       opattr \"abcdefghijklmnopqrstuvwxyz\"\n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbx\n            push    rdi\n            push    rsi\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 56         ; Shadow storage\n\n            cprintf \"Hello World!\"\n            cprintf fmtStr\n\nallDone:    leave\n            pop     rsi\n            pop     rdi\n            pop     rbx\n            ret     ; Returns to caller\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing13-6**\n\nC:\\>**echo off**\n Assembling: listing13-6.asm\nc.cpp\n\nC:\\>**listing13-6**\nCalling Listing 13-6:\nHello World!\nHello, World! #2\nListing 13-6 terminated\n```", "```\n .\n           .     ; About 1200 lines from Listing 9-10.\n           .\n\n; r10ToStr - Macro to create an HLL-like call for the \n;            _r10ToStr procedure.\n\n; Parameters:\n\n;   r10    - Must be the name of a real4, real8, or \n;            real10 variable.\n;   dest   - Must be the name of a byte buffer to hold \n;            string result.\n\n;   wdth   - Output width for the string. Either an\n;            integer constant or a dword variable.\n\n;   dPts   - Number of positions after the decimal\n;            point. Either an integer constant or\n;            a dword variable.\n\n;   fill   - Fill char. Either a character constant\n;            or a byte variable.\n\n;   mxLen  - Maximum length of output string. Either\n;            an integer constant or a dword variable.\n\nr10ToStr     macro   r10, dest, wdth, dPts, fill, mxLen\n             fld     r10\n\n; dest is a label associated with a string variable:\n\n             lea     rdi, dest\n\n; wdth is either a constant or a dword var:\n\n             mov     eax, wdth\n\n; dPts is either a constant or a dword var\n; holding the number of decimal point positions:\n\n            mov     edx, dPts\n\n; Process fill character. If it's a constant, \n; directly load it into ECX (which zero-extends\n; into RCX). If it's a variable, then move with\n; zero extension into ECX (which also zero-\n; extends into RCX).\n\n; Note: bit 2 from opattr is 1 if fill is \n; a constant.\n\n            if      ((opattr fill) and 4) eq 4\n            mov     ecx, fill\n            else\n            movzx   ecx, fill\n            endif\n\n; mxLen is either a constant or a dword var.\n\n            mov     r8d, mxLen\n            call    _r10ToStr\n            endm\n\n; e10ToStr - Macro to create an HLL-like call for the \n;            _e10ToStr procedure.\n\n; Parameters:\n\n;   e10   - Must be the name of a real4, real8, or \n;           real10 variable.\n;   dest  - Must be the name of a byte buffer to hold \n;           string result.\n\n;   wdth  - Output width for the string. Either an\n;           integer constant or a dword variable.\n\n;   xDigs - Number of exponent digits.\n\n;   fill  - Fill char. Either a character constant\n;           or a byte variable.\n\n;   mxLen - Maximum length of output string. Either\n;           an integer constant or a dword variable.\n\ne10ToStr    macro   e10, dest, wdth, xDigs, fill, mxLen\n            fld     e10\n\n; dest is a label associated with a string variable:\n\n            lea     rdi, dest\n\n; wdth is either a constant or a dword var:\n\n            mov     eax, wdth\n\n; xDigs is either a constant or a dword var\n; holding the number of decimal point positions:\n\n            mov     edx, xDigs\n\n; Process fill character. If it's a constant, \n; directly load it into ECX (which zero-extends\n; into RCX). If it's a variable, then move with\n; zero extension into ECX (which also zero-\n; extends into RCX).\n\n; Note: bit 2 from opattr is 1 if fill is \n; a constant.\n\n            if      ((opattr fill) and 4) eq 4\n            mov     ecx, fill\n            else\n            movzx   ecx, fill\n            endif\n\n; mxLen is either a constant or a dword var.\n\n            mov     r8d, mxLen\n            call    _e10ToStr\n            endm\n\n; puts - A macro to print a string using printf.\n\n; Parameters:\n\n;   fmt    - Format string (must be a byte\n;            variable or string constant).\n\n;   theStr - String to print (must be a\n;            byte variable, a register,\n;            or a string constant).\n\nputs         macro   fmt, theStr\n             local   strConst, bool\n\n             lea     rcx, fmt\n\n             if      ((opattr theStr) and 2)\n\n; If memory operand:\n\n             lea     rdx, theStr\n\n             elseif  ((opattr theStr) and 10h)\n\n; If register operand:\n\n             mov     rdx, theStr\n\n             else \n\n; Assume it must be a string constant.\n\n            .data\nstrConst    byte    theStr, 0\n            .code\n            lea     rdx, strConst\n\n            endif\n\n            call    printf\n            endm\n\n            public  asmMain\nasmMain     proc\n            push    rbx\n            push    rsi\n            push    rdi\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 64         ; Shadow storage\n\n; F output:\n\n            r10ToStr r10_1, r10str_1, 30, 16, '*', 32\n            jc      fpError\n            puts    fmtStr1, r10str_1\n\n            r10ToStr r10_1, r10str_1, 30, 15, '*', 32\n            jc      fpError\n            puts    fmtStr1, r10str_1\n             .\n             .    ; Similar code to Listing 9-10 with macro\n             .    ; invocations rather than procedure calls.\n; E output:\n\n            e10ToStr e10_1, r10str_1, 26, 3, '*', 32\n            jc      fpError\n            puts    fmtStr3, r10str_1\n\n            e10ToStr e10_2, r10str_1, 26, 3, '*', 32\n            jc      fpError\n            puts    fmtStr3, r10str_1\n             .\n             .    ; Similar code to Listing 9-10 with macro\n             .    ; invocations rather than procedure calls.\n```", "```\n; F output:\n\nfld     r10_1\nlea     rdi, r10str_1\nmov     eax, 30         ; fWidth\nmov     edx, 16         ; decimalPts\nmov     ecx, '*'        ; Fill\nmov     r8d, 32         ; maxLength\ncall    r10ToStr\njc      fpError\n\nlea     rcx, fmtStr1\nlea     rdx, r10str_1\ncall    printf\n\nfld     r10_1\nlea     rdi, r10str_1\nmov     eax, 30         ; fWidth\nmov     edx, 15         ; decimalPts\nmov     ecx, '*'        ; Fill\nmov     r8d, 32         ; maxLength\ncall    r10ToStr\njc      fpError\n\nlea     rcx, fmtStr1\nlea     rdx, r10str_1\ncall    printf\n.\n.   ; Additional code from Listing 9-10.\n.\n; E output:\n\nfld     e10_1\nlea     rdi, r10str_1\nmov     eax, 26         ; fWidth\nmov     edx, 3          ; expDigits\nmov     ecx, '*'        ; Fill\nmov     r8d, 32         ; maxLength\ncall    e10ToStr\njc      fpError\n\nlea     rcx, fmtStr3\nlea     rdx, r10str_1\ncall    printf\n\nfld     e10_2\nlea     rdi, r10str_1\nmov     eax, 26         ; fWidth\nmov     edx, 3          ; expDigits\nmov     ecx, '*'        ; Fill\nmov     r8d, 32         ; maxLength\ncall    e10ToStr\njc      fpError\n\nlea     rcx, fmtStr3\nlea     rdx, r10str_1\ncall    printf\n.\n.   ; Additional code from Listing 9-10.\n.\n```", "```\nprint       macro   arg\n            call    _print\n            byte    arg, 0\n            endm \n```", "```\nprint  \"Hello, World!\"\n```", "```\nprint  \"Hello, World!\", nl, \"It's a great day!\", nl\n```", "```\n; Listing 13-8\n\n; HLL-like procedure calls with\n; a varying parameter list.\n\n        option  casemap:none\n\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 13-8\", 0\n\n            .code\n            externdef printf:proc\n\n include getTitle.inc\n\n; Note: don't include print.inc here\n; because this code uses a macro for\n; print.\n\n; print macro - HLL-like calling sequence for the _print\n;               function (which is, itself, a shell for\n;               the printf function).\n\n; If print appears on a line by itself (no; arguments), \n; then emit a string consisting of a single newline \n; character (and zero-terminating byte). If there are \n; one or more arguments, emit each argument and append \n; a single 0 byte after all the arguments.\n\n; Examples:\n\n;           print\n;           print   \"Hello, World!\"\n;           print   \"Hello, World!\", nl\n\nprint       macro   arg1, optArgs:vararg\n            call    _print\n\n            ifb     <arg1>\n\n; If print is used by itself, print a\n; newline character:\n\n            byte    nl, 0\n\n            else\n\n; If we have one or more arguments, then\n; emit each of them:\n\n            byte    arg1\n\n            for     oa, <optArgs>\n\n            byte    oa\n\n            endm\n\n; Zero-terminate the string.\n\n            byte    0\n\n            endif\n            endm\n\n_print      proc\n            push    rax\n            push    rbx\n push    rcx\n            push    rdx\n            push    r8\n            push    r9\n            push    r10\n            push    r11\n\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 40\n            and     rsp, -16\n\n            mov     rcx, [rbp + 72]   ; Return address\n            call    printf\n\n            mov     rcx, [rbp + 72]\n            dec     rcx\nskipTo0:    inc     rcx\n            cmp     byte ptr [rcx], 0\n            jne     skipTo0\n            inc     rcx\n            mov     [rbp + 72], rcx\n\n            leave\n            pop     r11\n            pop     r10\n            pop     r9\n            pop     r8\n            pop     rdx\n            pop     rcx\n            pop     rbx\n            pop     rax\n            ret\n_print      endp\n\np           macro   arg\n            call    _print\n            byte    arg, 0\n            endm      \n\n; Here is the \"asmMain\" function.\n\n            public  asmMain\nasmMain     proc\n            push    rbx\n            push    rdi\n            push    rsi\n            push    rbp\n            mov     rbp, rsp\n            sub     rsp, 56         ; Shadow storage\n\n            print   \"Hello world\"\n            print\n            print   \"Hello, World!\", nl\n\nallDone:    leave\n            pop     rsi\n            pop     rdi\n            pop     rbx\n            ret     ; Returns to caller\nasmMain     endp\n            end\n```", "```\nC:\\>**build listing13-8**\n\nC:\\>**echo off**\n Assembling: listing13-8.asm\nc.cpp\n\nC:\\>**listing13-8**\nCalling Listing 13-8:\nHello world\nHello, World!\nListing 13-8 terminated\n```", "```\nprint \"Hello World\", nl, \"How are you today?\", nl\n```", "```\nprint \"Hello World\", nl\n```", "```\nprint <\"Hello World\", nl>\n```", "```\nopattr `expression`\n```", "```\ncodeLabel:\nopcl       =  opattr codeLabel ; Sets opcl to 25h or 0010_0101b\nopconst    =  opattr 0         ; Sets opconst to 36 or 0010_0100b\n```", "```\n; testStr is a macro function that tests its\n; operand to see if it is a string literal.\n\ntestStr     macro   strParm\n            local   firstChar\n\n            ifnb    <strParm>\nfirstChar   substr  <strParm>, 1, 1\n\n            ifidn   firstChar,<!\">\n\n; First character was \", so assume it's\n; a string.\n\n            exitm   <1>\n            endif   ; ifidn\n            endif   ; ifnb\n\n; If we get to this point in the macro,\n; we definitely do not have a string.\n\n            exitm   <0>\n            endm\n```", "```\nisAStr  = testStr(\"String Literal\")\nnotAStr = testStr(someLabel)\n```", "```\nSign     ::= (+|-) \nDigit    ::= [0-9]\nMantissa ::= (Digit)+ | '.' Digit)+ | (Digit)+ '.' Digit*\nExp      ::= (e|E) Sign? Digit? Digit? Digit?\nReal     ::= Sign? Mantissa Exp?\n```", "```\nisReal = getReal(`some_text`)\n```", "```\n; getReal - Parses a real constant.\n\n; Returns:\n;    true  - If the parameter contains a syntactically\n;            correct real number (and no extra characters).\n;    false - If there are any illegal characters or\n;            other syntax errors in the numeric string.\n\ngetReal      macro   origParm\n             local   parm, curChar, result\n\n; Make a copy of the parameter so we don't\n; delete the characters in the original string.\n\nparm         textequ &origParm\n\n; Must have at least one character:\n\n            ifb     parm\n            exitm   <0>\n            endif\n\n; Extract the optional sign:\n\n            if      isSign(parm)\ncurChar     textequ extract1st(parm)        ; Skip sign char\n            endif\n\n; Get the required mantissa:\n\n            if      getMant(parm) eq 0\n            exitm   <0>                     ; Bad mantissa\n            endif\n\n; Extract the optional exponent:\n\nresult      textequ getExp(parm)    \n            exitm   <&result>       \n\n            endm    ; getReal\n```", "```\n    curChar     textequ extract1st(parm)        ; Skip sign char\n    ```", "```\n; isSign - Macro function that returns true if the\n;          first character of its parameter is a\n;          \"+\" or \"-\".\n\nisSign      macro   parm\n            local   FirstChar\n            ifb     <parm>\n            exitm   <0>\n            endif\n\nFirstChar   substr  parm, 1, 1\n            ifidn   FirstChar, <+>\n            exitm   <1>\n            endif\n            ifidn   FirstChar, <->\n            exitm   <1>\n            endif\n            exitm   <0>\n            endm\n```", "```\nextract1st  macro   parm\n            local   FirstChar\n            ifb     <%parm>\n exitm   <>\n            endif\nFirstChar   substr  parm, 1, 1\n            if      @sizestr(%parm) GE 2\nparm        substr  parm, 2\n            else\nparm        textequ <>\n            endif\n\n            exitm   <FirstChar>\n            endm\n```", "```\ngetMant     macro   parm\n            local   curChar, sawDecPt, rpt\nsawDecPt    =       0\ncurChar     textequ extract1st(parm)        ; Get 1st char\n            ifidn   curChar, <.>            ; Check for dec pt\nsawDecPt    =       1\ncurChar     textequ extract1st(parm)        ; Get 2nd char\n            endif\n\n; Must have at least one digit:\n\n            if      isDigit(curChar) eq 0\n            exitm   <0>                     ; Bad mantissa\n            endif\n\n; Process zero or more digits. If we haven't already\n; seen a decimal point, allow exactly one of those.\n\n; Do loop at least once if there is at least one\n; character left in parm:\n\nrpt         =       @sizestr(%parm)\n            while   rpt\n\n; Get the 1st char from parm and see if\n; it is a decimal point or a digit:\n\ncurChar     substr  parm, 1, 1\n            ifidn   curChar, <.>\nrpt         =       sawDecPt eq 0\nsawDecPt    =       1\n            else\nrpt         =       isDigit(curChar)\n            endif\n\n; If char was legal, then extract it from parm:\n\n            if      rpt\ncurChar     textequ extract1st(parm)        ; Get next char\n            endif\n\n; Repeat as long as we have more chars and the\n; current character is legal:\n\nrpt         =       rpt and (@sizestr(%parm) gt 0)\n            endm    ; while\n\n; If we've seen at least one digit, we've got a valid\n; mantissa. We've stopped processing on the first \n; character that is not a digit or the 2nd \".\" char.\n\n            exitm   <1>\n            endm    ; getMant\n```", "```\nisDigit     macro   parm\n            local   FirstChar\n            if      @sizestr(%parm) eq 0\n            exitm   <0>\n            endif\n\nFirstChar   substr  parm, 1, 1\n            ifidn   FirstChar, <0>\n            exitm   <1>\n            endif\n            ifidn   FirstChar, <1>\n            exitm   <1>\n            endif\n            ifidn   FirstChar, <2>\n            exitm   <1>\n            endif\n            ifidn   FirstChar, <3>\n            exitm   <1>\n            endif\n            ifidn   FirstChar, <4>\n            exitm   <1>\n endif\n            ifidn   FirstChar, <5>\n            exitm   <1>\n            endif\n            ifidn   FirstChar, <6>\n            exitm   <1>\n            endif\n            ifidn   FirstChar, <7>\n            exitm   <1>\n            endif\n            ifidn   FirstChar, <8>\n            exitm   <1>\n            endif\n            ifidn   FirstChar, <9>\n            exitm   <1>\n            endif\n            exitm   <0>\n            endm\n```", "```\ngetExp      macro   parm\n            local   curChar\n\n; Return success if no exponent present.\n\n            if      @sizestr(%parm) eq 0\n            exitm   <1>\n            endif\n\n; Extract the next character, return failure\n; if it is not an \"e\" or \"E\" character:\n\ncurChar     textequ extract1st(parm)\n            if      isE(curChar) eq 0\n            exitm   <0>\n            endif\n\n; Extract the next character:\n\ncurChar     textequ extract1st(parm)\n\n; If an optional sign character appears,\n; remove it from the string:\n\n            if      isSign(curChar)\ncurChar     textequ extract1st(parm)        ; Skip sign char\n            endif                           ; isSign\n\n; Must have at least one digit:\n\n            if      isDigit(curChar) eq 0\n exitm   <0>\n            endif\n\n; Optionally, we can have up to three additional digits:\n\n            if      @sizestr(%parm) gt 0\ncurChar     textequ extract1st(parm)        ; Skip 1st digit\n            if      isDigit(curChar) eq 0\n            exitm   <0>\n            endif\n            endif\n\n            if      @sizestr(%parm) gt 0\ncurChar     textequ extract1st(parm)        ; Skip 2nd digit\n            if      isDigit(curChar) eq 0\n            exitm   <0>\n            endif\n            endif\n\n            if      @sizestr(%parm) gt 0\ncurChar     textequ extract1st(parm)        ; Skip 3rd digit\n            if      isDigit(curChar) eq 0\n            exitm   <0>\n            endif\n            endif\n\n; If we get to this point, we have a valid exponent.\n\n            exitm   <1>     \n            endm    ; getExp\n```", "```\nisE         macro   parm\n            local   FirstChar\n            if      @sizestr(%parm) eq 0\n            exitm   <0>\n            endif\n\nFirstChar   substr  parm, 1, 1\n            ifidni   FirstChar, <e>\n            exitm   <1>\n            endif\n            exitm   <0>\n            endm\n```", "```\n; Listing 13-9\n\n; This is a compile-time program.\n; It does not generate any executable code.\n\n; Several useful macro functions:\n\n; mout       - Like echo, but allows \"%\" operators.\n\n; testStr    - Tests an operand to see if it\n;              is a string literal constant.\n\n; @sizestr   - Handles missing MASM function.\n\n; isDigit    - Tests first character of its\n;              argument to see if it's a decimal\n;              digit.\n\n; isSign     - Tests first character of its\n;              argument to see if it's a \"+\"\n;              or a \"-\" character.\n\n; extract1st - Removes the first character\n;              from its argument (side effect)\n;              and returns that character as\n;              the function result.\n\n; getReal    - Parses the argument and returns\n;              true if it is a reasonable-\n;              looking real constant.\n\n; Test strings and invocations for the\n; getReal macro:\n\n `Note: actual macro code appears in previous code snippets`\n `and has been removed from this listing` `for brevity` \n\nmant1       textequ <1>\nmant2       textequ <.2>\nmant3       textequ <3.4>\nrv4         textequ <1e1>\nrv5         textequ <1.e1>\nrv6         textequ <1.0e1>\nrv7         textequ <1.0e + 1>\nrv8         textequ <1.0e - 1>\nrv9         textequ <1.0e12>\nrva         textequ <1.0e1234>\nrvb         textequ <1.0E123>\nrvc         textequ <1.0E + 1234>\nrvd         textequ <1.0E - 1234>\nrve         textequ <-1.0E - 1234>\nrvf         textequ <+1.0E - 1234>\nbadr1       textequ <>\nbadr2       textequ <a>\nbadr3       textequ <1.1.0>\nbadr4       textequ <e1>\nbadr5       textequ <1ea1>\nbadr6       textequ <1e1a>\n\n% echo get_Real(mant1) = getReal(mant1) \n% echo get_Real(mant2) = getReal(mant2)\n% echo get_Real(mant3) = getReal(mant3)\n% echo get_Real(rv4)   = getReal(rv4)\n% echo get_Real(rv5)   = getReal(rv5)\n% echo get_Real(rv6)   = getReal(rv6)\n% echo get_Real(rv7)   = getReal(rv7)\n% echo get_Real(rv8)   = getReal(rv8)\n% echo get_Real(rv9)   = getReal(rv9)\n% echo get_Real(rva)   = getReal(rva)\n% echo get_Real(rvb)   = getReal(rvb)\n% echo get_Real(rvc)   = getReal(rvc)\n% echo get_Real(rvd)   = getReal(rvd)\n% echo get_Real(rve)   = getReal(rve)\n% echo get_Real(rvf)   = getReal(rvf)\n% echo get_Real(badr1) = getReal(badr1)\n% echo get_Real(badr2) = getReal(badr2)\n% echo get_Real(badr3) = getReal(badr3)\n% echo get_Real(badr4) = getReal(badr4)\n% echo get_Real(badr5) = getReal(badr5)\n% echo get_Real(badr5) = getReal(badr5)\n        end\n```", "```\nC:\\>**ml64 /c listing13-9.asm**\nMicrosoft (R) Macro Assembler (x64) Version 14.15.26730.0\nCopyright (C) Microsoft Corporation.  All rights reserved.\n\n Assembling: listing13-9.asm\nget_Real(1) = 1\nget_Real(.2) = 1\nget_Real(3.4) = 1\nget_Real(1e1)  = 1\nget_Real(1.e1) = 1\nget_Real(1.0e1) = 1\nget_Real(1.0e + 1) = 1\nget_Real(1.0e - 1) = 1\nget_Real(1.0e12) = 1\nget_Real(1.0e1234) = 1\nget_Real(1.0E123) = 1\nget_Real(1.0E + 1234) = 1\nget_Real(1.0E - 1234) = 1\nget_Real(-1.0E - 1234) = 1\nget_Real(+1.0E - 1234) = 1\nget_Real() = 0\nget_Real(a) = 0\nget_Real(1.1.0) = 0\nget_Real(e1) = 0\nget_Real(1ea1) = 0\nget_Real(1ea1) = 0\n```", "```\nisReg       macro   parm\n            local   result\nresult      textequ %(((opattr &parm) and 10h) eq 10h)\n            exitm   <&result>\n            endm\n```", "```\nalVal  =       whichReg(al)\naxTxt  textequ <ax>\naxVal  =       whichReg(axTxt)\n\naMac   macro   parameter\n       local   regVal\nregVal =       whichReg(parameter)\n       if      regVal eq regNone\n       .err    <Expected a register argument>\n       exitm\n       endif\n         .\n         .\n         .\n       endm\n```", "```\nisWinParm  macro  theReg\n           local  regVal, isParm\nregVal      =     whichReg(theReg)\nisParm      =     (regVal eq regRCX) or (regVal eq regRDX)\nisParm      =     isParm or (regVal eq regR8)\nisParm      =     isParm or (regVal eq regR9)\n\n            if    isParm\n            exitm <%regVal>\n            endif\n            exitm <%regNone>\n            endm\n```", "```\nmov toReg(1), 0    ; Equivalent to mov al, 0\n```", "```\nalSize    =  regSize(regAL)   ; Returns 1\naxSize    =  regSize(regAX)   ; Returns 2\neaxSize   =  regSize(regEAX)  ; Returns 4\nraxSize   =  regSize(regRAX)  ; Returns 8\nstSize    =  regSize(regST0)  ; Returns 10\nmmSize    =  regSize(regMM0)  ; Returns 8\nxmmSize   =  regSize(regXMM0) ; Returns 16\nymmSize   =  regSize(regYMM0) ; Returns 32\n```", "```\n; Listing 13-12\n\n; Demonstration of putInt macro.\n\n; putInt - This macro expects an 8-, 16-, or 32-bit\n;          general-purpose register argument. It will\n;          print the value of that register as an\n;          integer.\n\nputInt      macro   theReg\n            local   regVal, sz\nregVal      =       isGPReg(theReg)\n\n; Before we do anything else, make sure\n; we were actually passed a register:\n\n            if      regVal eq regNone\n            .err    <Expected a register>\n            endif\n\n; Get the size of the register so we can\n; determine if we need to sign-extend its\n; value:\n\nsz          =       regSize(regVal)\n\n; If it was a 64-bit register, report an\n; error:\n\n            if      sz gt 4\n            .err    64-bit register not allowed\n            endif\n\n; If it's a 1- or 2-byte register, we will need\n; to sign-extend the value into EDX:\n\n            if      (sz eq 1) or (sz eq 2)\n            movsx   edx, theReg\n\n; If it's a 32-bit register, but is not EDX, we need\n; to move it into EDX (don't bother emitting\n; the instruction if the register is EDX;\n; the data is already where we want it):\n\n            elseif  regVal ne regEDX\n            mov     edx, theReg\n            endif\n\n; Print the value in EDX as an integer:\n\n            call    print\n            byte    \"%d\", 0\n            endm\n\n        option  casemap:none\n\nnl          =       10\n\n            .const\nttlStr      byte    \"Listing 13-12\", 0\n\n `Note: several thousand lines of code omitted here`\n `for brevity. This includes most of the text from`\n  `` `Listing 13-11 plus the putInt macro`              .code                          include getTitle.inc             include print.inc             public  asmMain asmMain     proc             push    rbx             push    rbp             mov     rbp, rsp             sub     rsp, 56         ; Shadow storage               call    print             byte    \"Value 1:\", 0             mov     al, 55             putInt  al                          call    print             byte    nl, \"Value 2:\", 0             mov     cx, 1234             putInt  cx                          call    print             byte    nl, \"Value 3:\", 0             mov     ebx, 12345678             putInt  ebx                          call    print             byte    nl, \"Value 4:\", 0             mov     edx, 1             putInt  edx             call    print             byte    nl, 0  allDone:    leave             pop     rbx             ret     ; Returns to caller asmMain     endp             end ``\n```", "```\nC:\\>**build listing13-12**\n\nC:\\>**echo off**\n Assembling: listing13-12.asm\nc.cpp\n\nC:\\>**listing13-11**\nCalling Listing 13-12:\nValue 1:55\nValue 2:1234\nValue 3:12345678\nValue 4:1\nListing 13-12 terminated\n```", "```\n; toUpper - Converts alphabetic characters to uppercase\n;           in a text string.\n\ntoUpper     macro   lcStr\n            local   result\n\n; Build the result string in \"result\":\n\nresult      textequ <>\n\n; For each character in the source string, \n; convert it to uppercase.\n\n            forc    eachChar, <lcStr>\n\n; See if we have a lowercase character:\n\n            if      ('&eachChar' ge 'a') and ('&eachChar' le 'z')\n\n; If lowercase, convert it to the symbol \"lc_*\" where \"*\"\n; is the lowercase character. The equates below will map\n; this character to uppercase:\n\neachChar    catstr  <lc_>,<eachChar>\nresult      catstr  result, &eachChar\n\n            else\n\n; If it wasn't a lowercase character, just append it\n; to the end of the string:\n\nresult      catstr  result, <eachChar>\n\n            endif\n            endm            ; forc\n exitm   result  ; Return result string\n            endm            ; toUpper\n```", "```\neachChar    catstr  <lc_>,<eachChar>\nresult      catstr  result, &eachChar\n```", "```\nlc_a        textequ <A>\nlc_b        textequ <B>\nlc_c        textequ <C>\nlc_d        textequ <D>\nlc_e        textequ <E>\nlc_f        textequ <F>\nlc_g        textequ <G>\nlc_h        textequ <H>\nlc_i        textequ <I>\nlc_j        textequ <J>\nlc_k        textequ <K>\nlc_l        textequ <L>\nlc_m        textequ <M>\nlc_n        textequ <N>\nlc_o        textequ <O>\nlc_p        textequ <P>\nlc_q        textequ <Q>\nlc_r        textequ <R>\nlc_s        textequ <S>\nlc_t        textequ <T>\nlc_u        textequ <U>\nlc_v        textequ <V>\nlc_w        textequ <W>\nlc_x        textequ <X>\nlc_y        textequ <Y>\nlc_z        textequ <Z>\n```", "```\nall16Regs   catstr <AX>,\n                   <BX>,\n                   <CX>,\n                   <DX>,\n                   <SI>,\n                   <DI>,\n                   <BP>,\n                   <SP>,\n                   <R8W>,\n                   <R10W>,\n                   <R11W>,\n                   <R12W>,\n                   <R13W>,\n                   <R14W>,\n                   <R15W>\n\nall16Lens   catstr <2>, <0>,           ; AX\n                   <2>, <0>,           ; BX\n                   <2>, <0>,           ; CX \n                   <2>, <0>,           ; DX\n                   <2>, <0>,           ; SI\n                   <2>, <0>,           ; DI\n                   <2>, <0>,           ; BP\n                   <2>, <0>,           ; SP\n                   <3>, <0>, <0>,      ; R8W\n                   <3>, <0>, <0>,      ; R9W\n                   <4>, <0>, <0>, <0>, ; R10W\n                   <4>, <0>, <0>, <0>, ; R11W\n                   <4>, <0>, <0>, <0>, ; R12W\n                   <4>, <0>, <0>, <0>, ; R13W\n                   <4>, <0>, <0>, <0>, ; R14W\n                   <4>, <0>, <0>, <0>  ; R15W\n\nis16BitReg  macro   parm\n            exitm   lookupReg(parm, all16Regs, all16Lens)\n            endm    ; is16BitReg\n```", "```\n; lookupReg - Given a (suspected) register and a lookup table, convert\n;             that register to the corresponding numeric form.\n\nlookupReg   macro   theReg, regList, regIndex\n            local   regUpper, regConst, inst, regLen, indexLen\n\n; Convert (possible) register to uppercase:\n\nregUpper    textequ toUpper(theReg)\nregLen      sizestr <&theReg>\n\n; Does it exist in regList? If not, it's not a register.\n\ninst        instr   1, regList, &regUpper\n            if      inst ne 0\n\nregConst    substr  &regIndex, inst, 1\n            if      &regConst eq regLen\n\n; It's a register (in text form). Create an identifier of\n; the form \"reg`XX`\" where \"`XX`\" represents the register name.\n\nregConst    catStr  <reg>,regUpper\n\n            ifdef   &regConst\n\n; Return \"reg`XX`\" as function result. This is the numeric value\n; for the register.\n\n            exitm   regConst\n            endif\n            endif\n            endif\n\n; If the parameter string wasn't in regList, then return\n; \"regNone\" as the function result:\n\n            exitm   <regNone>\n            endm    ; lookupReg\n```", "```\ngenArray    macro   arrayName, elements\n            local   index, eleName, getName\n\n; Loop over each element of the array:\n\nindex       =       0\n            while   index lt &elements\n\n; Generate a textequ statement to define a single\n; element of the array, for example:\n\n; ary`XX` = 0\n\n; where \"`XX`\" is the index (0 to (elements - 1)).\n\neleName     catstr  <&arrayName>,%index,< = 0>\n\n; Expand the text just created with the catstr directive.\n\n            eleName\n\n; Move on to next array index:\n\nindex       =       index + 1\n            endm    ; while\n\n            endm    ; genArray\n```", "```\ngenArray ary, 10\n```", "```\nary_get     macro   index\n            local   element\nelement     catstr  <ary>,%index\n            exitm   <element>\n            endm\n```", "```\nary_set     macro   index, value\n            local   assign\nassign      catstr  <ary>, %index, < = >, %value\n            assign\n            endm\n```", "```` ``` ; Listing 13-13  ; This is a compile-time program. ; It does not generate any executable code.          option  casemap:none  genArray    macro   arrayName, elements             local   index, eleName, getName              ; Loop over each element of the array:  index       =       0             while   index lt &elements              ; Generate a textequ statement to define a single ; element of the array, for example:  ; ary`XX` = 0  ; where \"`XX`\" is the index (0 to (elements - 1)).  eleName     catstr  <&arrayName>,%index,< = 0>  ; Expand the text just created with the catstr directive:              eleName              ; Move on to next array index:  index       =       index + 1             endm    ; while              ; Create a macro function to retrieve a value from ; the array:  getName     catstr  <&arrayName>,<_get>  getName     macro   theIndex             local   element element     catstr  <&arrayName>,%theIndex             exitm   <element>             endm              ; Create a macro to assign a value to ; an array element.  setName     catstr  <&arrayName>,<_set>  setName     macro   theIndex, theValue             local   assign assign      catstr  <&arrayName>, %theIndex, < = >, %theValue  assign             endm              endm    ; genArray  ; mout - Replacement for echo. Allows \"%\" operator ;        in operand field to expand text symbols.  mout        macro   valToPrint             local   cmd cmd         catstr  <echo >, <valToPrint>             cmd             endm  ; Create an array (\"ary\") with ten elements:              genArray ary, 10              ; Initialize each element of the array to ; its index value:  index       = 0             while   index lt 10             ary_set index, index index       =       index + 1             endm              ; Print out the array values:  index       =       0             while   index lt 10              value       =       ary_get(index)             mout    ary[%index] = %value index       =       index + 1             endm                          end ```    Listing 13-13: A macro that writes another pair of macros    Here’s the build command and sample output for the compile-time program in [Listing 13-13](#listing13-13):    ``` C:\\>**ml64 /c /Fl listing13-13.asm** Microsoft (R) Macro Assembler (x64) Version 14.15.26730.0 Copyright (C) Microsoft Corporation.  All rights reserved.   Assembling: listing13-13.asm ary[0] = 0 ary[1] = 1 ary[2] = 2 ary[3] = 3 ary[4] = 4 ary[5] = 5 ary[6] = 6 ary[7] = 7 ary[8] = 8 ary[9] = 9 ```    ## 13.19 Compile-Time Program Performance    When writing compile-time programs, keep in mind that MASM is interpreting these programs during assembly. This can have a huge impact on the time it takes MASM to assemble your source files. Indeed, it is quite possible to create infinite loops that will cause MASM to (seemingly) hang up during assembly. Consider the following trivial example:    ``` true        =     1             while true             endm ```    Any attempt to assemble a MASM source file containing this sequence will lock up the system until you press ctrl-C (or use another mechanism to abort the assembly process).    Even without infinite loops, it is easy to create macros that take a considerable amount of time to process. If you use such macros hundreds (or even thousands) of times in a source file (as is common for some complex print-type macros), it could take a while for MASM to process your source files. Be aware of this (and be patient if MASM seems to hang up—it could simply be your compile-time programs taking a while to do their job).    If you think a compile-time program has entered an infinite loop, the `echo` directive (or macros like `mout`, appearing throughout this chapter) can help you track down the infinite loop (or other bugs) in your compile-time programs.    ## 13.20 For More Information    Although this chapter has spent a considerable amount of time describing various features of MASM’s macro support and compile-time language features, the truth is this chapter has barely described what’s possible with MASM. Sadly, Microsoft’s documentation all but ignores the macro facilities of MASM. Probably the best place to learn about advanced macro programming with MASM is the MASM32 forum at [http://www.masm32.com/board/index.php](http://www.masm32.com/board/index.php).    Although it is an older book, covering MASM version 6, *The Waite Group’s Microsoft Macro Assembler Bible* by Nabajyoti Barkakati and this author (Sams, 1992) does go into detail about the use of MASM’s macro facilities (as well as other directives that are poorly documented these days). Also, the MASM 6.*x* manual can still be found online at various sites. While this manual is woefully outdated with respect to the latest versions of MASM (it does not, for example, cover any of the 64-bit instructions or addressing modes), it does a decent job of describing MASM’s macro facilities and many of MASM’s directives. Just keep in mind when reading the older documentation that Microsoft has *disabled* many features that used to be present in MASM.    ## 13.21 Test Yourself    1.  What does *CTL* stand for? 2.  When do CTL programs execute? 3.  What directive would you use to print a message (not an error) during assembly? 4.  What directive would you use to print an error message during assembly? 5.  What directive would you use to create a CTL variable? 6.  What is the MASM macro escape character operator? 7.  What does the MASM `%` operator do? 8.  What does the MASM macro `&` operator do? 9.  What does the `catstr` directive do? 10.  What does the MASM `instr` directive do? 11.  What does the `sizestr` directive do? 12.  What does the `substr` directive do? 13.  What are the main (four) conditional assembly directives? 14.  What directives could you use to create compile-time loops? 15.  What directive would you use to extract the characters from a MASM text object in a loop? 16.  What directives do you use to define a macro? 17.  How do you invoke a macro in a MASM source file? 18.  How do you specify macro parameters in a macro declaration? 19.  How do you specify that a macro parameter is required? 20.  How do you specify that a macro parameter is optional? 21.  How do you specify a variable number of macro arguments? 22.  Explain how you can manually test whether a macro parameter is present (without using the `:req` suffix). 23.  How can you define local symbols in a macro? 24.  What directive would you use (generally inside a conditional assembly sequence) to immediately terminate macro expansion without processing any additional statements in the macro? 25.  How would you return a textual value from a macro function? 26.  What operator could you use to test a macro parameter to see if it is a machine register versus a memory variable? ````"]