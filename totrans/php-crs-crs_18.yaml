- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 14 WORKING WITH SESSIONS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This chapter introduces browser sessions, which allow a web client and server
    to remember user information over time. When browsing an online store, for example,
    you expect to be able to add items into a shopping cart and for those items to
    be remembered a few minutes later, or even across browser tabs. Similarly, if
    you enter a username and password to access a web-based email system, you expect
    your successful login to be remembered as you click through pages to display email,
    draft messages, and so on. Sessions make this kind of memory possible.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter discusses how to work with browser sessions in PHP, including storing
    and retrieving values, and resetting or destroying sessions entirely. We’ll develop
    a general pattern for writing code that uses sessions, which will be applicable
    to most situations, such as shopping carts and login authentication.
  prefs: []
  type: TYPE_NORMAL
- en: A Web Browser Session
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *browser session* is a temporary information exchange between a web client,
    such as a browser or phone app, and a web server. A session begins at a certain
    point in time and will terminate at a later point in time. Sessions often begin
    when a user directs their web browser to a new website; the browser and server
    agree on a unique session ID, and this ID will be used in the subsequent HTTP
    requests and responses exchanged between the client and server to indicate that
    they are all part of the same session. [Figure 14-1](#fig14-1) illustrates a web
    client making repeated requests by continuing to use the session ID created after
    its first request.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure14-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-1: Repeated requests from a web client, each including the same session
    ID'
  prefs: []
  type: TYPE_NORMAL
- en: You can find the session IDs behind real-world web interactions by using your
    browser’s developer tools to examine HTTP requests. For example, [Figure 14-2](#fig14-2)
    shows the Amazon UK website agreeing on a session ID with my web browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure14-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-2: The Chrome browser tools showing a session ID from Amazon'
  prefs: []
  type: TYPE_NORMAL
- en: Both the server and the client need to keep a record of the agreed-upon session
    ID, since this unique token must be included in each HTTP request. This way, when
    the server receives an incoming request, it can immediately tell which session
    it belongs to out of the potentially thousands of sessions the server might be
    tracking. The server also uses the session ID to store and manage the data for
    each session, such as shopping carts, successful logins, and so on. PHP web servers
    automatically create these session IDs, and the PHP language provides several
    functions for working with sessions. Web clients usually use an HTTP cookie to
    temporarily store session IDs.
  prefs: []
  type: TYPE_NORMAL
- en: Sessions can be ended in several ways, depending on the web server settings,
    the PHP code, and sometimes additional JavaScript code running on the web clients.
    Sessions are closed when the user quits the browser application. Sessions can
    also be terminated by PHP server code, such as when a user chooses to log out
    of their account. Some websites have JavaScript running in the web browser to
    detect when the user closes or navigates away from the website browsing tab, at
    which point the JavaScript sends a message to the server requesting that the session
    be ended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sessions might also time out; the server can set a time limit that starts with
    the latest client request so that if no new request is received within the designated
    time period, the server will automatically terminate the session. Time-outs help
    keep sites secure: if a user walks away from their computer, the session can time
    out and prevent a nonauthorized person from continuing the authorized session.
    (Even with time-outs, though, logging out or quitting the browser *before* walking
    away from your computer is always a good idea.)'
  prefs: []
  type: TYPE_NORMAL
- en: The session_start() and session_id() Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PHP provides the session_start() function, which starts a new session if none
    currently exists, or renews an existing session if a valid session ID is included
    in the received HTTP request. When renewing an existing session, the function
    restarts the time-out timer. Although you rarely need to know the unique session
    ID when writing PHP scripts, the language does provide a function to retrieve
    it: session_id().'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 14-1 shows a two-statement PHP script that first calls session _start()
    and then prints the value returned by session_id().
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-1: Starting (or restarting) a session and printing its ID'
  prefs: []
  type: TYPE_NORMAL
- en: If you run this script, the output will be a long string of letters and numbers
    similar to d98rqmn9amvtf3cqbpifv95bdd. This is the unique session ID generated
    by session_start() and retrieved by session_id().
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*An alternative to using the* session_start() *function in your PHP code is
    to enable automatic session starting through a configuration setting for the PHP
    engine (*session.auto_start = 1 *in the* php.ini *file) or for the web server
    (*php_value session .auto_start 1 *in* .htaccess *for Apache web servers). However,
    when learning to use sessions or if your web hosting makes configuration changes
    difficult, the best approach is to use the* session_start() *function, as illustrated
    throughout this chapter.*  ### The $_SESSION Superglobal Array'
  prefs: []
  type: TYPE_NORMAL
- en: You don’t usually need to reference a specific session ID in your PHP code to
    work with sessions. Instead, you primarily work with session data through the
    built-in $_SESSION array. This is another of PHP’s *superglobals*, like $_GET
    and $_POST that we met in [Chapter 11](chapter11.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: The $_SESSION array holds data related to the current session using string keys.
    This array is automatically provided by the PHP engine when an HTTP request with
    a session ID is received from a client. It’s there so PHP web programmers have
    a variable for storing any values that need to be remembered for the current client’s
    session from one request to another.
  prefs: []
  type: TYPE_NORMAL
- en: One way to understand this is to consider that a typical web server might be
    maintaining tens, hundreds, or thousands of $_SESSION arrays, one for each session
    with each of the clients currently communicating with the server. (Think of the
    thousands of people using eBay or Amazon at any given time.) When the server executes
    a PHP script for a particular client request that has been received (containing
    a unique session ID), the PHP engine retrieves data stored on the server associated
    with that session ID and puts it in the $_SESSION array for that copy of the script
    to work with. (Many copies of the script may be being executed at any point in
    time, one for each of the clients using the website.) This process allows that
    copy of the script to remember any values from previous client/server interactions
    during the session.
  prefs: []
  type: TYPE_NORMAL
- en: To see how this all works, let’s write a script that attempts to both store
    and retrieve a value from the $_SESSION array. One common use of sessions is to
    store login authentication tokens, so we’ll work with the username of the currently
    logged-in user as an example. [Listing 14-2](#lis14-2) shows the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-2: Attempting to retrieve, then store, a value in the $_SESSION
    array'
  prefs: []
  type: TYPE_NORMAL
- en: After (re)starting the session with session_start(), we store the default string
    value (no username found in session) in the $message variable. Then we use the
    isset() function to test whether any value can be found in the $_SESSION array
    under the 'username' key. If a value is found, we update $message with a new string
    including that value. Next, we store the value 'matt' into $_SESSION['username'].
    This will overwrite any existing value in the $_SESSION array for the 'username'
    key. Finally, we print out whatever string is stored in $message. [Figure 14-3](#fig14-3)
    shows the result of visiting this web page twice in a row.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure14-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-3: Retrieving the username from the session on the second request'
  prefs: []
  type: TYPE_NORMAL
- en: The first time the page is visited, no value is found in the session for 'username'
    at the time the if statement is executed, so the default message is displayed.
    The second time the page is visited, however, the value 'matt' that was stored
    to the $_SESSION array the first time through the script is retrieved and displayed
    back. In this way, the session allows us to remember a value from one execution
    of the script to the next.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a Stored Value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One benefit of the $_SESSION array is that its values can be updated as needed.
    For example, if you were using the session to keep track of a user’s shopping
    cart, you’d need to make updates each time the user adds or removes an item. We’ll
    explore that exact scenario in [Chapter 15](chapter15.xhtml), but for now we’ll
    consider a simpler example of updating a value in the $_SESSION array: a hit counter
    that stores and displays the number of HTTP requests made to a website. When personal
    websites first became popular, having such a hit counter was common.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A caveat here: in reality, sessions aren’t an appropriate mechanism for storing
    data from different website visitors or for storing values for time periods of
    more than seconds or minutes. As we’ve discussed, a separate set of data is stored
    for each user’s session, so a session-based hit counter can count only the number
    of website visits made by the *same user*. Also, sessions are terminated when
    the user quits the browser or the session times out, so visiting the site later
    in the day (or on another day) will mean the session-based hit counter will restart
    at 1, having “forgotten” the previous visits. Still, a session-based hit counter
    is a helpful project for introducing some of the core logic involved in session
    storage operations.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 14-4](#fig14-4) illustrates the counter we’re aiming to create. The
    first time the page is visited, the counter is 1\. Then, with each page refresh,
    the previous total is remembered and incremented by one.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure14-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-4: A hit counter incrementing after each page refresh'
  prefs: []
  type: TYPE_NORMAL
- en: Listing 14-3 shows the *public/index.php* script needed to create the session-
    based hit counter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-3: Using a session variable to simulate a website hit counter'
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the script is HTML for a dummy favicon. Since modern browsers
    will send an extra request for a favicon image if one isn’t defined in the HTML
    received, adding this <link> element at the beginning of the script keeps the
    browser happy and prevents it from making twice as many requests, which would
    make the hit counter confusing.
  prefs: []
  type: TYPE_NORMAL
- en: This script hinges on the typical logic of first testing whether any value exists
    in the session before attempting to retrieve and update it. We use a local PHP
    variable called $pageHits to represent the number of page hits when the script
    is executed, while we use the 'counter' key to store the running total in the
    $_SESSION array. (The distinct names help avoid any confusion between these two
    values.)
  prefs: []
  type: TYPE_NORMAL
- en: After starting the session, we set $pageHits to a default value of 0 to represent
    the case when there’s no existing value stored in the session ❶. Next, we test
    whether any value can be found in the $_SESSION array under the 'counter' key
    ❷. If a value is found, we retrieve it from the array and store it in the $pageHits
    variable, overwriting the default value ❸.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, whether or not a value is found in the $_SESSION array, we know
    we have an appropriate value in the $pageHits variable: either 0 or the running
    total of hits up to but not including the current page visit. In either case,
    we add 1 to $pageHits to account for the current visit to the page ❹. Then we
    store the updated value of $pageHits into the $_SESSION array under the ''counter''
    key, either overwriting the key’s existing value or creating it if this is the
    first page visit ❺. Finally, we output a message stating the number of times the
    page has been visited ❻.'
  prefs: []
  type: TYPE_NORMAL
- en: The flowchart in [Figure 14-5](#fig14-5) illustrates the general logic behind
    our hit-counter script. You can correlate this flowchart with points ❶ through
    ❻ in [Listing 14-3](#lis14-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure14-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-5: How to update (or set) a session variable'
  prefs: []
  type: TYPE_NORMAL
- en: The logic in the flowchart generalizes to just about any work you may need to
    do with session values. First, you set a variable to a default value in the local
    script. Then you check whether a previously stored value can be found in the $_SESSION
    array and use that to overwrite the default if appropriate. Next, you update the
    local variable and store the updated value back in the $_SESSION array. Usually,
    you’ll also want to do something with the updated variable. This approach works
    whether it’s the beginning of the session (meaning nothing is stored in the $_SESSION
    array) or the code is being executed upon the second, third, or *n*th request
    during the session (meaning a value is stored in the $_SESSION array from a previous
    run of the script).
  prefs: []
  type: TYPE_NORMAL
- en: Unsetting a Value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: At times you’ll want to remove a particular value stored in the session. As
    we discussed in [Chapter 8](chapter8.xhtml), you can delete a value from an array
    by using the unset() function. This is different from setting an array element
    to something like NULL, an empty string, or 0, since unsetting an element removes
    *any* value associated with the string key. Using our hit-counter example, we
    would remove any session value associated with the 'counter' key by calling unset($_SESSION['counter']).
    We might do this, for example, if the page had a Reset button that cleared the
    hit counter.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s implement such a Reset button now, as well as add a link to revisit the
    hit-counter page (and therefore increment the counter). [Figure 14-6](#fig14-6)
    shows the page we’ll try to create.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure14-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-6: The hit-counter page with revisit and reset links'
  prefs: []
  type: TYPE_NORMAL
- en: To add this functionality, update your *index.php* script to match [Listing
    14-4](#lis14-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-4: Adding a reset link to the hit counter'
  prefs: []
  type: TYPE_NORMAL
- en: After (re)starting the session, we retrieve and test the value of the 'action'
    query-string variable. If its value is 'reset', we unset the 'counter' element
    in the $_SESSION array ❶. Then the script proceeds as before. In the event that
    the user has clicked the Reset button and the 'counter' element was unset, it
    will be as if this element never existed, so the isset() test ❷ will fail and
    the 'counter' element will end up with a fresh value of 1 (after the default value
    of 0 is incremented).
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the file, we add two links. The first is simply to revisit *index.php*
    (and so increment the counter). The second link is also to *index.php* but includes
    an 'action' query-string variable with a value of 'reset', which will trigger
    the script to reset the counter ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying the Session and Emptying the Session Array
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Sometimes you might want to destroy the entire session and so invalidate the
    session ID and delete all stored session data. The deletion may be a security
    requirement, for example, since destroying a session should result in the server
    session data being *immediately* destroyed rather than waiting for a garbage-collection
    process (such as after a session time-out). That said, completely destroying a
    session is generally not recommended, since it may interfere with ongoing concurrent
    requests, such as asynchronous JavaScript. If all you want to do is clear the
    $_SESSION array, you can do so without entirely killing the session: use unset($_SESSION)
    or $_SESSION = [] to turn $_SESSION into an empty array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you *do* need to completely destroy a session, take these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.   (Re)start the session with session_start().
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Set the $_SESSION array to an empty array.
  prefs: []
  type: TYPE_NORMAL
- en: 3.   If using cookies, invalidate (time out) the session cookie.
  prefs: []
  type: TYPE_NORMAL
- en: 4.   Destroy the PHP session by executing the session_destroy() function.
  prefs: []
  type: TYPE_NORMAL
- en: See the PHP documentation at *[https://www.php.net/manual/en/function.session-destroy.php](https://www.php.net/manual/en/function.session-destroy.php)*
    for more information about this process.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s add a link for killing the session to our hit-counter page. [Figure
    14-7](#fig14-7) shows the page with the added link, which passes the action=kill
    query-string variable when the user wants to completely destroy the session.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/figure14-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 14-7: The hit-counter page with a new link to kill the session'
  prefs: []
  type: TYPE_NORMAL
- en: To keep our *index.php* file from getting too complex, we’ll encapsulate the
    code to kill the session in a separate function. [Listing 14-5](#lis14-5) shows
    the code for this killSession() function; it implements steps 2 through 4 of the
    session-killing process outlined previously (step 1 happens at the beginning of
    the *index.php* file). Add a *src/usefulFunctions.php* file to your hit-counter
    project and enter the code in the listing.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-5: A function for killing a session'
  prefs: []
  type: TYPE_NORMAL
- en: 'The function starts by setting $_SESSION to an empty array (step 2) and ends
    by calling session_destroy() (step 4). In between, the if statement implements
    step 3 of the session-killing process: invalidating the session cookie. For this,
    we check whether cookies are in use, then change the cookie with the current session
    name to an empty string, also setting an expiring time that’s in the past (time()
    - 42000), effectively deleting the cookie.'
  prefs: []
  type: TYPE_NORMAL
- en: With the killSession() function declared, update the *public/index.php* script
    as shown in [Listing 14-6](#lis14-6) in order to offer a kill-session link to
    the hit- counter page.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 14-6: Adding a kill-session link to the hit-counter page'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we read in the declaration of the killSession() function from its source
    file. Then, since we need to check for multiple values of the ''action'' query-string
    variable, we use a switch statement ❶ to decide how to process the incoming HTTP
    request. If the action is ''reset'', we unset the ''counter'' key of the $_SESSION
    array as before, or if the action is ''kill'', we invoke killSession(). In the
    HTML at the end of the script, we add a kill-session link that passes the action=kill
    query-string variable to *index.php*. We also add a line displaying the current
    session ID to prove that the session is indeed being destroyed ❷; if you click
    the kill-session link, this field should come up blank, in addition to the hit
    counter resetting to 1.  ### Summary'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter introduced you to sessions, which provide a mechanism for a web
    server to remember information about a user across multiple HTTP requests. You
    learned how to start a session with session_start(), how to store and update values
    in the $_SESSION superglobal array, and how to clear values from this array or
    destroy a session entirely. We outlined a basic pattern for working with session
    data, whereby you first set a default value, then overwrite this default with
    a value from the $_SESSION array (if one exists) before updating the value and
    storing it back in the array.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 1.   Visit a website where you think sessions are being used, such as an e-commerce
    website with a shopping cart feature or a site with a login page. Use your browser
    developer tools to find the session ID that has been agreed upon by the server
    and client and is being stored as a cookie on your client device.
  prefs: []
  type: TYPE_NORMAL
- en: 2.   Write a PHP script that looks in the $_SESSION array for a value with the
    key 'guess'. If it isn’t found, store 0 for this key and display a message to
    the user stating no previous value was found. If a value *is* found in the session,
    add a random number from 1 to 10 to that value. Store the result back in the $_SESSION
    array and display it to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 3.   Write a script to display a form that has a text box in which the user
    can enter a number, along with two Submit buttons. One Submit button should take
    the value from the text box and store it in the session. The second button should
    simply display the current value stored in the session, or a message stating no
    value was found in the session, as appropriate.
  prefs: []
  type: TYPE_NORMAL
