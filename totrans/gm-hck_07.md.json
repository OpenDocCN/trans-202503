["```\nstruct PlayerVital {\n    int current, maximum;\n};\nPlayerVital health;\n--snip--\nprintString(\"Health: %d of %d\\n\", health.current, health.maximum);\n```", "```\nint currentHealth; // value at 0x403018\nint maxHealth;     // value at 0x40301C\n--snip--\nsomeFunction(\"Health: %d of %d\\n\",\n    currentHealth, maxHealth);\n```", "```\nPUSH EDI\nPUSH EAX \nLEA EAX,DWORD PTR SS:[EBP-C] \nMOV DWORD PTR FS:[0],EAX \nMOV DWORD PTR SS:[EBP-10],ESP \nMOV DWORD PTR SS:[EBP-220],-1 \nMOV DWORD PTR SS:[EBP-4],0\n```", "```\nclass string {\n    union {\n        char* dataP;\n        char dataA[16];\n    };\n    int length;\n};\n\n// point to a string in memory\nstring* _str = (string*)stringAddress;\n```", "```\nconst char* c_str() {\n    if (_str->length <= 15)\n        return (const char*)&_str->dataA[0];\n    else\n        return (const char*)_str->dataP;\n}\n```", "```\nstruct creatureInfo {\n    int uniqueID;\n    char name[16];\n    int nameLength;\n    int healthPercent;\n    int xPosition;\n    int yPosition;\n    int modelID;\n int creatureType;\n};\n```", "```\ntemplate<typename T>\nclass vector {\n    T* begin;\n    T* end;\n    T* reservationEnd;\n};\n```", "```\nstd::vector<DWORD> _vec;\n```", "```\nclass vector {\n    DWORD* begin;\n    DWORD* end;\n    DWORD* tail;\n};\n// point to a vector in memory\nvector* _vec = (vector*)vectorAddress;\n```", "```\nint length() {\n    return ((DWORD)_vec->end - (DWORD)_vec->begin) / sizeof(DWORD);\n}\n```", "```\nDWORD at(int index) {\n    if (index >= _vec->length())\n        throw new std::out_of_range();\n    return _vec->begin[index];\n}\n```", "```\nint capacity() {\n    return ((DWORD)_vec->tail - (DWORD)_vec->begin) / sizeof(DWORD);\n}\n```", "```\nint freeSpace() {\n    return ((DWORD)_vec->tail - (DWORD)_vec->end) / sizeof(DWORD);\n}\n```", "```\ntemplate<typename T>\nclass listItem {\n    listItem<T>* next;\n    listItem<T>* prev;\n    T value;\n};\n\ntemplate<typename T>\nclass list {\n    listItem<T>* root;\n    int size;\n};\n```", "```\nstd::list<DWORD> _lst;\n```", "```\n class listItem {\n    listItem* next;\n    listItem* prev;\n    DWORD value;\n};\nclass list {\n    listItem* root;\n    int size;\n};\n// point to a list\nlist* _lst = (list*)listAddress;\n```", "```\n// iterate forward\nlistItem* it = _lst->root->next;\nfor (; it != _lst->root; it = it->next)\n    printf(\"Value is %d\\n\", it->value);\n\n// iterate backward\nlistItem* it = _lst->root->prev;\nfor (; it != _lst->root; it = it->prev)\n    printf(\"Value is %d\\n\", it->value);\n```", "```\nfunction _verifyLinkedList(address)\n    local nextItem = readInteger(address) or 0\n    local previousItem = readInteger(address + 4) or 0\n    local nextItemBack = readInteger(nextItem + 4)\n    local previousItemForward = readInteger(previousItem)\n\n    return (address == nextItemBack\n            and address == previousItemForward)\nend\n\nfunction isValueInLinkedList(valueAddress)\n    for address = valueAddress - 8, valueAddress - 48, -4 do\n        if (_verifyLinkedList(address)) then\n            return address\n        end\n    end\n    return 0\nend\n\nlocal node = isValueInLinkedList(addressOfSomeValue)\nif (node > 0) then\n    print(string.format(\"Value in LL, top of node at 0x0%x\", node))\nend\n```", "```\nreturn (node->next->prev == node && node->prev->next == node)\n```", "```\nfunction countLinkedListNodes(nodeAddress)\n    local counter = 0\n    local next = readInteger(nodeAddress)\n    while (next ~= nodeAddress) do\n        counter = counter + 1\n        next = readInteger(next)\n    end\n    return counter\nend\n```", "```\ntemplate<typename keyT, typename valT>\nstruct mapItem {\n    mapItem<keyT, valT>* left;\n    mapItem<keyT, valT>* parent;\n    mapItem<keyT, valT>* right;\n    keyT key;\n    valT value;\n};\n\ntemplate<typename keyT, typename valT>\nstruct map {\n    DWORD irrelevant;\n    mapItem<keyT, valT>* rootNode;\n    int size;\n}\n```", "```\ntypedef int keyInt;\ntypedef int valInt;\nstd::map<keyInt, valInt> myMap;\n```", "```\nstruct mapItem {\n    mapItem* left;\n    mapItem* parent;\n    mapItem* right;\n    keyInt key;\n    valInt value;\n};\nstruct map {\n    DWORD irrelevant;\n    mapItem* rootNode;\n    int size;\n}\nmap* _map = (map*)mapAddress;\n```", "```\nvoid iterateMap(mapItem* node) {\n    if (node == _map->rootNode) return;\n    iterateMap(node->left);\n    printNode(node);\n    iterateMap(node->right);\n}\n```", "```\niterateMap(_map->rootNode->parent);\n```", "```\nmapItem* findItem(keyInt key, mapItem* node) {\n    if (node != _map->rootNode) {\n        if (key == node->key)\n            return node;\n        else if (key < node->key)\n            return findItem(key, node->left);\n        else\n            return findItem(key, node->right);\n    } else return NULL;\n}\n```", "```\nmapItem* ret = findItem(someKey, _map->rootNode->parent);\nif (ret)\n    printNode(ret);\n```", "```\n   function _verifyMap(address)\n       local parentItem = readInteger(address + 4) or 0\n\n       local parentLeftItem = readInteger(parentItem + 0) or 0\n       local parentRightItem = readInteger(parentItem + 8) or 0\n\n➊     local validParent =\n           parentLeftItem == address\n           or parentRightItem == address\n       if (not validParent) then return false end\n\n       local tries = 0\n       local lastChecked = parentItem\n       local parentsParent = readInteger(parentItem + 4) or 0\n➋     while (readInteger(parentsParent + 4) ~= lastChecked and tries < 200) do\n           tries = tries + 1\n           lastChecked = parentsParent\n           parentsParent = readInteger(parentsParent + 4) or 0\n       end\n\n       return readInteger(parentsParent + 4) == lastChecked\n   end\n```", "```\nfunction isValueInMap(valueAddress)\n    for address = valueAddress - 12, valueAddress - 52, -4 do\n        if (_verifyMap(address)) then\n            return address\n        end\n    end\n    return 0\nend\n\nlocal node = isValueInMap(addressOfSomeValue)\nif (node > 0) then\n    print(string.format(\"Value in map, top of node at 0x0%x\", node))\nend\n```"]