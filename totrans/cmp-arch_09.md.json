["```\n01: HLT\n```", "```\n01: HLT\n02: NUM 10\n03: NUM 5\n04: NUM 0\n```", "```\n01: LDN 20\n02: STO 21\n03: HLT\n20: NUM -10\n21: NUM 0\n```", "```\n01: LDN 20\n02: SUB 21\n03: STO 22\n04: LDN 22\n05: HLT\n20: NUM -10\n21: NUM 3\n22: NUM 0\n```", "```\n01: LDN 20\n02: SUB 21\n03: SUB 22\n04: STO 20\n05: JMP 23\n06: HLT\n20: NUM 0\n21: NUM 0\n22: NUM -1\n23: NUM 0\n```", "```\n01: LDN 20\n02: STO 23\n03: SKN\n04: JMP 21\n05: LDN 22\n06: SUB 23\n07: STO 23\n08: HLT\n20: NUM -10\n21: NUM 6\n22: NUM 0\n23: NUM 0\n```", "```\nimport re\nf = open(\"TuringLongDivision.asm\")\nfor_logisim = False #change to True to output hex for logisim RAM\ndct_inst = dict()\ndct_inst['JMP'] = 0\ndct_inst['JRP'] = 1\ndct_inst['LDN'] = 2\ndct_inst['STO'] = 3\ndct_inst['SUB'] = 4\ndct_inst['SKN'] = 6\ndct_inst['HLT'] = 7\nloc = 0\nif for_logisim:\n  print(\"v2.0 raw\")    #header for logisim RAM image format\ndef sext(num, width):\n    if num < 0:\n        return bin((1 << (width + 1)) + num)[3:]\n    return bin(num)[2:].zfill(width)\ndef out(binary):\n  if for_logisim:\n    print(hex(int(binary,2))[2:].zfill(8))\n  else:\n    print(binary[::-1]) #Baby convention: show bit 0 on the left\nfor line in f:\n    asm = re.split('\\s*--\\s*', line.strip())[0]\n    parts = asm.split()\n    thisloc = int(parts[0][:-1])\n    if parts[1] == 'NUM':      #data line\n        code2 = sext(int(parts[2], 10), 32)\n    else:                      #instruction line\n        inst2 = bin(dct_inst[parts[1]]).zfill(3)[2:]\n        if len(parts) < 3:\n            parts.append('0')\n        operand2 = sext(int(parts[2], 10), 13)\n        code2 = (inst2 + operand2).zfill(32)\n    for addr in range(loc, thisloc):\n      out('0'.zfill(32)) #fill in zeros where lines not given\n    out(code2)\n    loc = thisloc + 1\n```", "```\n00: NUM 19   -- jump address\n01: LDN 31   -- Accumulator := -A\n02: STO 31   -- Store as -A\n03: LDN 31   -- Accumulator := -(-A) i.e., +A\n04: SUB 30   -- Subtract B*2^n ; Accumulator = A - B*2^n\n05: SKN      -- Skip if (A-B*2^n) is Negative\n06: JMP 0    --   otherwise go to line 20 ( A-B*2^n >= 0 )\n07: LDN 31   -- Accumulator := -(-A)\n08: STO 31   -- Store as +A\n09: LDN 28   -- Accumulator := -Quotient\n10: SUB 28   -- Accumulator := -Quotient - Quotient (up-shift)\n11: STO 28   -- Store -2*Quotient as Quotient (up-shifted)\n12: LDN 31   -- Accumulator := -A\n13: SUB 31   -- Accumulator := -A-A (up-shift A)\n14: STO 31   -- Store -2*A (up-shifted A)\n15: LDN 28   -- Accumulator := -Quotient\n16: STO 28   -- Store as +Quotient (restore shifted Quotient)\n17: SKN      -- Skip if MSB of Quotient is 1 (at end)\n18: JMP 26   --   otherwise go to line 3 (repeat)\n19: HLT      -- Stop ; Quotient in line 28\n20: STO 31   -- From line 6 - Store A-B*2^n as A\n21: LDN 29   -- Routine to set bit d of Quotient\n22: SUB 28   --   and up-shift\n23: SUB 28   --   Quotient\n24: STO 28   -- Store -(2*Quotient)-1 as Quotient\n25: JMP 27   -- Go to line 12\n26: NUM 2    -- jump address\n27: NUM 11   -- jump address\n28: NUM 0    -- (Answer appears here, shifted up by d bits)\n29: NUM 536870912 -- 2^d where d=31-n, see line 30 for n\n30: NUM 20   -- B (Divisor*2^n) (example: 5*2^2=20)\n31: NUM 36   -- A (initial Dividend) (example: 36/5=7)\n```", "```\n11001000000000000000000000000000\n11111000000000100000000000000000\n11111000000001100000000000000000\n11111000000000100000000000000000\n01111000000000010000000000000000\n00000000000000110000000000000000\n00000000000000000000000000000000\n11111000000000100000000000000000\n11111000000001100000000000000000\n00111000000000100000000000000000\n00111000000000010000000000000000\n00111000000001100000000000000000\n11111000000000100000000000000000\n11111000000000010000000000000000\n11111000000001100000000000000000\n00111000000000100000000000000000\n00111000000001100000000000000000\n00000000000000110000000000000000\n01011000000000000000000000000000\n00000000000001110000000000000000\n11111000000001100000000000000000\n10111000000000100000000000000000\n00111000000000010000000000000000\n00111000000000010000000000000000\n00111000000001100000000000000000\n11011000000000000000000000000000\n01000000000000000000000000000000\n11010000000000000000000000000000\n00000000000000000000000000000000\n00000000000000000000000000000100\n00101000000000000000000000000000\n00100100000000000000000000000000\n```", "```\nt1: RAM_A <- PC\nt2: IR <- RAM_Dout\n```", "```\nt3, LDN: RAM_A <- IR[operand]\nt4, LDN: Acc <- -RAM_Dout\n```", "```\nt3, STO: RAM_A <- IR[operand]\nt3, STO: RAM_Din <- Acc\n```", "```\nt3, SUB: RAM_A <- IR[operand]\nt4, SUB: Acc <- Acc - RAM_Dout\n```", "```\nt0: PC <- PC + 1\nt4, JMP: RAM_A <- IR[operand]\nt4, JRP: RAM_A <- IR[operand]\nt5, SKN, (Acc<0): PC <- PC + 1\nt5, JMP: PC <- RAM_Dout\nt5, JRP: PC <- PC + RAM_Dout\n```", "```\nt0: PC <- PC + 1\nt1: RAM_A <- PC\nt2: IR <- RAM_Dout\nt3, LDN: RAM_A <- IR[operand]\nt3, STO: RAM_A <- IR[operand]\nt3, STO: RAM_Din <- Acc\nt3, SUB: RAM_A <- IR[operand]\nt4, SUB: Acc <- Acc - RAM_Dout\nt4, LDN: Acc <- -RAM_Dout\nt4, JMP: RAM_A <- IR[operand]\nt4, JRP: RAM_A <- IR[operand]\nt5, SKN, (Acc<0): PC <- PC + 1\nt5, JMP: PC <- RAM_Dout\nt5, JRP: PC <- PC + RAM_Dout\n```"]