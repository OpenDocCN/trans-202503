["```\n#include \"catch.hpp\"\n#include <vector>\n#include <string>\n\nusing namespace std;\n```", "```\nbool all_of([ep], ipt_begin, ipt_end, pred);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"all_of\") {\n  vector<string> words{ \"Auntie\", \"Anne's\", \"alligator\" }; ➊\n  const auto starts_with_a =\n    [](const auto& word➋) {\n      if (word.empty()) return false; ➌\n      return word[0] == 'A' || word[0] == 'a'; ➍\n    };\n  REQUIRE(all_of(words.cbegin(), words.cend(), starts_with_a)); ➎\n  const auto has_length_six = [](const auto& word) {\n    return word.length() == 6; ➏\n  };\n  REQUIRE_FALSE(all_of(words.cbegin(), words.cend(), has_length_six)); ➐\n}\n```", "```\nbool any_of([ep], ipt_begin, ipt_end, pred);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"any_of\") {\n  vector<string> words{ \"Barber\", \"baby\", \"bubbles\" }; ➊\n  const auto contains_bar = [](const auto& word) {\n    return word.find(\"Bar\") != string::npos;\n  }; ➋\n  REQUIRE(any_of(words.cbegin(), words.cend(), contains_bar)); ➌\n\n  const auto is_empty = [](const auto& word) { return word.empty(); }; ➍\n  REQUIRE_FALSE(any_of(words.cbegin(), words.cend(), is_empty)); ➎\n}\n```", "```\nbool none_of([ep], ipt_begin, ipt_end, pred);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"none_of\") {\n  vector<string> words{ \"Camel\", \"on\", \"the\", \"ceiling\" }; ➊\n  const auto is_hump_day = [](const auto& word) {\n    return word == \"hump day\";\n  }; ➋\n  REQUIRE(none_of(words.cbegin(), words.cend(), is_hump_day)); ➌\n\n  const auto is_definite_article = [](const auto& word) {\n    return word == \"the\" || word == \"ye\";\n  }; ➍\n  REQUIRE_FALSE(none_of(words.cbegin(), words.cend(), is_definite_article)); ➎\n}\n```", "```\nfor_each([ep], ipt_begin, ipt_end, fn);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"for_each\") {\n  vector<string> words{ \"David\", \"Donald\", \"Doo\" }; ➊\n  size_t number_of_Ds{}; ➋\n  const auto count_Ds = [&number_of_Ds➌](const auto& word➍) {\n    if (word.empty()) return; ➎\n    if (word[0] == 'D') ++number_of_Ds; ➏\n  };\n  for_each(words.cbegin(), words.cend(), count_Ds); ➐\n  REQUIRE(3 == number_of_Ds); ➑\n}\n```", "```\nInputIterator for_each_n([ep], ipt_begin, n, fn);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"for_each_n\") {\n  vector<string> words{ \"ear\", \"egg\", \"elephant\" }; ➊\n  size_t characters{}; ➋\n  const auto count_characters = [&characters➌](const auto& word➍) {\n    characters += word.size(); ➎\n  };\n  for_each_n(words.cbegin(), words.size(), count_characters); ➏\n  REQUIRE(14 == characters); ➐\n}}\n```", "```\nInputIterator find([ep], ipt_begin, ipt_end, value);\nInputIterator find_if([ep], ipt_begin, ipt_end, pred);\nInputIterator find_if_not([ep], ipt_begin, ipt_end, pred);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"find find_if find_if_not\") {\n  vector<string> words{ \"fiffer\", \"feffer\", \"feff\" }; ➊\n  const auto find_result = find(words.cbegin(), words.cend(), \"feff\"); ➋\n  REQUIRE(*find_result == words.back()); ➌\n\n  const auto defends_digital_privacy = [](const auto& word) {\n    return string::npos != word.find(\"eff\"); ➍\n  };\n\n  const auto find_if_result = find_if(words.cbegin(), words.cend(),\n                                      defends_digital_privacy); ➎\n  REQUIRE(*find_if_result == \"feffer\"); ➏\n\n  const auto find_if_not_result = find_if_not(words.cbegin(), words.cend(),\n                                              defends_digital_privacy); ➐\n  REQUIRE(*find_if_not_result == words.front()); ➑\n}\n```", "```\nInputIterator find_end([ep], fwd_begin1, fwd_end1,\n                       fwd_begin2, fwd_end2, [pred]);\n```", "```\ndistance(fwd_begin2, fwd_end2) * (distance(fwd_begin1, fwd_end1) -\n                                  distance(fwd_begin2, fwd_end2) + 1)\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"find_end\") {\n  vector<string> words1{ \"Goat\", \"girl\", \"googoo\", \"goggles\" }; ➊\n  vector<string> words2{ \"girl\", \"googoo\" }; ➋\n  const auto find_end_result1 = find_end(words1.cbegin(), words1.cend(),\n                                         words2.cbegin(), words2.cend()); ➌\n  REQUIRE(*find_end_result1 == words1[1]); ➍\n\n  const auto has_length = [](const auto& word, const auto& len) {\n    return word.length() == len; ➎\n  };\n  vector<size_t> sizes{ 4, 6 }; ➏\n  const auto find_end_result2 = find_end(words1.cbegin(), words1.cend(),\n                                         sizes.cbegin(), sizes.cend(),\n                                         has_length); ➐\n  REQUIRE(*find_end_result2 == words1[1]); ➑\n}\n```", "```\nInputIterator find_first_of([ep], ipt_begin1, ipt_end1,\n                            fwd_begin2, fwd_end2, [pred]);\n```", "```\ndistance(ipt_begin1, ipt_end1) * distance(fwd_begin2, fwd_end2)\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"find_first_of\") {\n  vector<string> words{ \"Hen\", \"in\", \"a\", \"hat\" }; ➊\n  vector<string> indefinite_articles{ \"a\", \"an\" }; ➋\n  const auto find_first_of_result = find_first_of(words.cbegin(),\n                                                  words.cend(),\n                                                  indefinite_articles.cbegin(),\n                                                  indefinite_articles.cend()); ➌\n  REQUIRE(*find_first_of_result == words[2]); ➍\n}\n```", "```\nForwardIterator adjacent_find([ep], fwd_begin, fwd_end, [pred]);\n```", "```\n min(distance(fwd_begin, i)+1, distance(fwd_begin, fwd_end)-1)\n```", "```\n#include <algorithm>\nTEST_CASE(\"adjacent_find\") {\n  vector<string> words{ \"Icabod\", \"is\", \"itchy\" }; ➊\n  const auto first_letters_match = [](const auto& word1, const auto& word2) { ➋\n    if (word1.empty() || word2.empty()) return false;\n    return word1.front() == word2.front();\n  };\n  const auto adjacent_find_result = adjacent_find(words.cbegin(), words.cend(),\n                                                  first_letters_match); ➌\n  REQUIRE(*adjacent_find_result == words[1]); ➍\n}\n```", "```\nDifferenceType count([ep], ipt_begin, ipt_end, value);\nDifferenceType count_if([ep], ipt_begin, ipt_end, pred);\n```", "```\n#include <algorithm>\nTEST_CASE(\"count\") {\n  vector<string> words{ \"jelly\", \"jar\", \"and\", \"jam\" }; ➊\n  const auto n_ands = count(words.cbegin(), words.cend(), \"and\"); ➋\n  REQUIRE(n_ands == 1); ➌\n\n  const auto contains_a = [](const auto& word) { ➍\n    return word.find('a') != string::npos;\n  };\n  const auto count_if_result = count_if(words.cbegin(), words.cend(),\n                                        contains_a); ➎\n  REQUIRE(count_if_result == 3); ➏\n}\n```", "```\npair<Itr, Itr> mismatch([ep], ipt_begin1, ipt_end1,\n                        ipt_begin2, [ipt_end2], [pred]);\n```", "```\nmin(distance(ipt_begin1, ipt_end1), distance(ipt_begin2, ipt_end2))\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"mismatch\") {\n  vector<string> words1{ \"Kitten\", \"Kangaroo\", \"Kick\" }; ➊\n  vector<string> words2{ \"Kitten\", \"bandicoot\", \"roundhouse\" }; ➋\n  const auto mismatch_result1 = mismatch(words1.cbegin(), words1.cend(),\n                                         words2.cbegin()); ➌\n  REQUIRE(*mismatch_result1.first == \"Kangaroo\"); ➍\n\n  REQUIRE(*mismatch_result1.second == \"bandicoot\"); ➎\n  const auto second_letter_matches = [](const auto& word1,\n                                        const auto& word2) { ➏\n    if (word1.size() < 2) return false;\n    if (word2.size() < 2) return false;\n    return word1[1] == word2[1];\n  };\n  const auto mismatch_result2 = mismatch(words1.cbegin(), words1.cend(),\n                                     words2.cbegin(), second_letter_matches); ➐\n  REQUIRE(*mismatch_result2.first == \"Kick\"); ➑\n  REQUIRE(*mismatch_result2.second == \"roundhouse\"); ➒\n}\n```", "```\nbool equal([ep], ipt_begin1, ipt_end1, ipt_begin2, [ipt_end2], [pred]);\n```", "```\nmin(distance(ipt_begin1, ipt_end1), distance(ipt_begin2, ipt_end2))\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"equal\") {\n  vector<string> words1{ \"Lazy\", \"lion\", \"licks\" }; ➊\n  vector<string> words2{ \"Lazy\", \"lion\", \"kicks\" }; ➋\n const auto equal_result1 = equal(words1.cbegin(), words1.cend(),\n                                    words2.cbegin()); ➌\n  REQUIRE_FALSE(equal_result1); ➍\n\n  words2[2] = words1[2]; ➎\n  const auto equal_result2 = equal(words1.cbegin(), words1.cend(),\n                                    words2.cbegin()); ➏\n  REQUIRE(equal_result2); ➐\n}\n```", "```\nbool is_permutation([ep], fwd_begin1, fwd_end1, fwd_begin2, [fwd_end2], [pred]);\n```", "```\ndistance(fwd_begin1, fwd_end1) * distance(fwd_begin2, fwd_end2)\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"is_permutation\") {\n  vector<string> words1{ \"moonlight\", \"mighty\", \"nice\" }; ➊\n vector<string> words2{ \"nice\", \"moonlight\", \"mighty\" }; ➋\n  const auto result = is_permutation(words1.cbegin(), words1.cend(),\n                                     words2.cbegin()); ➌\n  REQUIRE(result); ➍\n}\n```", "```\nForwardIterator search([ep], fwd_begin1, fwd_end1,\n                             fwd_begin2, fwd_end2, [pred]);\n```", "```\ndistance(fwd_begin1, fwd_end1) * distance(fwd_begin2, fwd_end2)\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"search\") {\n vector<string> words1{ \"Nine\", \"new\", \"neckties\", \"and\",\n                         \"a\", \"nightshirt\" }; ➊\n  vector<string> words2{ \"and\", \"a\", \"nightshirt\" }; ➋\n  const auto search_result_1 = search(words1.cbegin(), words1.cend(),\n                                      words2.cbegin(), words2.cend()); ➌\n  REQUIRE(*search_result_1 == \"and\"); ➍\n\n  vector<string> words3{ \"and\", \"a\", \"nightpant\" }; ➎\n  const auto search_result_2 = search(words1.cbegin(), words1.cend(),\n                                      words3.cbegin(), words3.cend()); ➏\n  REQUIRE(search_result_2 == words1.cend()); ➐\n}\n```", "```\nForwardIterator search_n([ep], fwd_begin, fwd_end, count, value, [pred]);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"search_n\") {\n  vector<string> words{ \"an\", \"orange\", \"owl\", \"owl\", \"owl\", \"today\" }; ➊\n  const auto result = search_n(words.cbegin(), words.cend(), 3, \"owl\"); ➋\n  REQUIRE(result == words.cbegin() + 2); ➌\n}\n```", "```\nOutputIterator copy([ep], ipt_begin, ipt_end, result);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"copy\") {\n  vector<string> words1{ \"and\", \"prosper\" }; ➊\n  vector<string> words2{ \"Live\", \"long\" }; ➋\n  copy(words1.cbegin(), words1.cend(), ➌\n       back_inserter(words2)➍);\n  REQUIRE(words2 == vector<string>{ \"Live\", \"long\", \"and\", \"prosper\" }); ➎\n}\n```", "```\nOutputIterator copy_n([ep], ipt_begin, n, result);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"copy_n\") {\n  vector<string> words1{ \"on\", \"the\", \"wind\" }; ➊\n  vector<string> words2{ \"I'm\", \"a\", \"leaf\" }; ➋\n  copy_n(words1.cbegin(), words1.size(), ➌\n         back_inserter(words2)); ➍\n  REQUIRE(words2 == vector<string>{ \"I'm\", \"a\", \"leaf\",\n                                    \"on\", \"the\", \"wind\" }); ➎\n}\n```", "```\nOutputIterator copy_backward([ep], ipt_begin1, ipt_end1, ipt_end2);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"copy_backward\") {\n vector<string> words1{ \"A\", \"man\", \"a\", \"plan\", \"a\", \"bran\", \"muffin\" }; ➊\n  vector<string> words2{ \"a\", \"canal\", \"Panama\" }; ➋\n  const auto result = copy_backward(words2.cbegin(), words2.cend(), ➌\n                                    words1.end()); ➍\n  REQUIRE(words1 == vector<string>{ \"A\", \"man\", \"a\", \"plan\",\n                                    \"a\", \"canal\", \"Panama\" }); ➎\n}\n```", "```\nOutputIterator move([ep], ipt_begin, ipt_end, result);\n```", "```\n#include <algorithm>\n\nstruct MoveDetector { ➊\n  MoveDetector() : owner{ true } {} ➋\n  MoveDetector(const MoveDetector&) = delete;\n  MoveDetector& operator=(const MoveDetector&) = delete;\n  MoveDetector(MoveDetector&& o) = delete;\n  MoveDetector& operator=(MoveDetector&&) { ➌\n o.owner = false;\n    owner = true;\n    return *this;\n  }\n  bool owner;\n};\n\nTEST_CASE(\"move\") {\n  vector<MoveDetector> detectors1(2); ➍\n  vector<MoveDetector> detectors2(2); ➎\n  move(detectors1.begin(), detectors1.end(), detectors2.begin()); ➏\n  REQUIRE_FALSE(detectors1[0].owner); ➐\n  REQUIRE_FALSE(detectors1[1].owner); ➑\n  REQUIRE(detectors2[0].owner); ➒\n  REQUIRE(detectors2[1].owner); ➓\n}\n```", "```\nOutputIterator move_backward([ep], ipt_begin, ipt_end, result);\n```", "```\n#include <algorithm>\n\nstruct MoveDetector { ➊\n--snip--\n};\n\nTEST_CASE(\"move_backward\") {\n  vector<MoveDetector> detectors1(2); ➋\n  vector<MoveDetector> detectors2(2); ➌\n  move_backward(detectors1.begin(), detectors1.end(), detectors2.end()); ➍\n  REQUIRE_FALSE(detectors1[0].owner); ➎\n  REQUIRE_FALSE(detectors1[1].owner); ➏\n  REQUIRE(detectors2[0].owner); ➐\n  REQUIRE(detectors2[1].owner); ➑\n}\n```", "```\nOutputIterator swap_ranges([ep], ipt_begin1, ipt_end1, ipt_begin2);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"swap_ranges\") {\n  vector<string> words1{ \"The\", \"king\", \"is\", \"dead.\" }; ➊\n  vector<string> words2{ \"Long\", \"live\", \"the\", \"king.\" }; ➋\n  swap_ranges(words1.begin(), words1.end(), words2.begin()); ➌\n  REQUIRE(words1 == vector<string>{ \"Long\", \"live\", \"the\", \"king.\" }); ➍\n  REQUIRE(words2 == vector<string>{ \"The\", \"king\", \"is\", \"dead.\" }); ➎\n}\n```", "```\nOutputIterator transform([ep], ipt_begin1, ipt_end1, result, unary_op);\nOutputIterator transform([ep], ipt_begin1, ipt_end1, ipt_begin2,\n                         result, binary_op);\n```", "```\n#include <algorithm>\n#include <boost/algorithm/string/case_conv.hpp>\n\nTEST_CASE(\"transform\") {\n  vector<string> words1{ \"farewell\", \"hello\", \"farewell\", \"hello\" }; ➊\n  vector<string> result1;\n  auto upper = [](string x) { ➋\n    boost::algorithm::to_upper(x);\n    return x;\n  };\n  transform(words1.begin(), words1.end(), back_inserter(result1), upper); ➌\n  REQUIRE(result1 == vector<string>{ \"FAREWELL\", \"HELLO\",\n                                     \"FAREWELL\", \"HELLO\" }); ➍\n\n  vector<string> words2{ \"light\", \"human\", \"bro\", \"quantum\" }; ➎\n  vector<string> words3{ \"radar\", \"robot\", \"pony\", \"bit\" }; ➏\n  vector<string> result2;\n  auto portmantize = [](const auto &x, const auto &y) { ➐\n    const auto x_letters = min(size_t{ 2 }, x.size());\n    string result{ x.begin(), x.begin() + x_letters };\n    const auto y_letters = min(size_t{ 3 }, y.size());\n    result.insert(result.end(), y.end() - y_letters, y.end() );\n    return result;\n  };\n  transform(words2.begin(), words2.end(), words3.begin(),\n            back_inserter(result2), portmantize); ➑\n  REQUIRE(result2 == vector<string>{ \"lidar\", \"hubot\", \"brony\", \"qubit\" }); ➒\n}\n```", "```\nvoid replace([ep], fwd_begin, fwd_end, old_ref, new_ref);\nvoid replace_if([ep], fwd_begin, fwd_end, pred, new_ref);\nvoid replace_copy([ep], fwd_begin, fwd_end, result, old_ref, new_ref);\nvoid replace_copy_if([ep], fwd_begin, fwd_end, result, pred, new_ref);\n```", "```\n#include <algorithm>\n#include <string_view>\n\nTEST_CASE(\"replace\") {\n  using namespace std::literals; ➊\n  vector<string> words1{ \"There\", \"is\", \"no\", \"try\" }; ➋\n  replace(words1.begin(), words1.end(), \"try\"sv, \"spoon\"sv); ➌\n  REQUIRE(words1 == vector<string>{ \"There\", \"is\", \"no\", \"spoon\" }); ➍\n\n  const vector<string> words2{ \"There\", \"is\", \"no\", \"spoon\" }; ➎\n vector<string> words3{ \"There\", \"is\", \"no\", \"spoon\" }; ➏\n  auto has_two_os = [](const auto& x) { ➐\n    return count(x.begin(), x.end(), 'o') == 2;\n  };\n  replace_copy_if(words2.begin(), words2.end(), words3.begin(), ➑\n                  has_two_os, \"try\"sv);\n  REQUIRE(words3 == vector<string>{ \"There\", \"is\", \"no\", \"try\" }); ➒\n}\n```", "```\nvoid fill([ep], fwd_begin, fwd_end, value);\nOutputIterator fill_n([ep], opt_begin, n, value);\n```", "```\n#include <algorithm>\n\n// If police police police police, who polices the police police?\nTEST_CASE(\"fill\") {\n  vector<string> answer1(6); ➊\n  fill(answer1.begin(), answer1.end(), \"police\"); ➋\n  REQUIRE(answer1 == vector<string>{ \"police\", \"police\", \"police\",\n                                     \"police\", \"police\", \"police\" }); ➌\n\n  vector<string> answer2; ➍\n  fill_n(back_inserter(answer2), 6, \"police\"); ➎\n  REQUIRE(answer2 == vector<string>{ \"police\", \"police\", \"police\",\n                                     \"police\", \"police\", \"police\" }); ➏\n}\n```", "```\nvoid generate([ep], fwd_begin, fwd_end, generator);\nOutputIterator generate_n([ep], opt_begin, n, generator);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"generate\") {\n  auto i{ 1 }; ➊\n  auto pow_of_2 = [&i]() { ➋\n    const auto tmp = i;\n    i *= 2;\n    return tmp;\n  };\n  vector<int> series1(6); ➌\n  generate(series1.begin(), series1.end(), pow_of_2); ➍\n  REQUIRE(series1 == vector<int>{ 1, 2, 4, 8, 16, 32 }); ➎\n\n  vector<int> series2; ➏\n  generate_n(back_inserter(series2), 6, pow_of_2); ➐\n  REQUIRE(series2 == vector<int>{ 64, 128, 256, 512, 1024, 2048 }); ➑\n}\n```", "```\nForwardIterator remove([ep], fwd_begin, fwd_end, value);\nForwardIterator remove_if([ep], fwd_begin, fwd_end, pred);\nForwardIterator remove_copy([ep], fwd_begin, fwd_end, result, value);\nForwardIterator remove_copy_if([ep], fwd_begin, fwd_end, result, pred);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"remove\") {\n  auto is_vowel = [](char x) { ➊\n    const static string vowels{ \"aeiouAEIOU\" };\n    return vowels.find(x) != string::npos;\n  };\n  string pilgrim = \"Among the things Billy Pilgrim could not change \"\n                   \"were the past, the present, and the future.\"; ➋\n  const auto new_end = remove_if(pilgrim.begin(), pilgrim.end(), is_vowel); ➌\n  REQUIRE(pilgrim == \"mng th thngs Blly Plgrm cld nt chng wr th pst, \"\n                     \"th prsnt, nd th ftr.present, and the future.\"); ➍\n\n  pilgrim.erase(new_end, pilgrim.end()); ➎\n  REQUIRE(pilgrim == \"mng th thngs Blly Plgrm cld nt chng wr th \"\n                     \"pst, th prsnt, nd th ftr.\"); ➏\n}\n```", "```\nForwardIterator unique([ep], fwd_begin, fwd_end, [pred]);\nForwardIterator unique_copy([ep], fwd_begin, fwd_end, result, [pred]);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"unique\") {\n  string without_walls = \"Wallless\"; ➊\n  const auto new_end = unique(without_walls.begin(), without_walls.end()); ➋\n  without_walls.erase(new_end, without_walls.end()); ➌\n  REQUIRE(without_walls == \"Wales\"); ➍\n}\n```", "```\nvoid reverse([ep], bi_begin, bi_end);\nOutputIterator reverse_copy([ep], bi_begin, bi_end, result);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"reverse\") {\n string stinky = \"diaper\"; ➊\n  reverse(stinky.begin(), stinky.end()); ➋\n  REQUIRE(stinky == \"repaid\"); ➌\n}\n```", "```\nOutputIterator sample([ep], ipt_begin, ipt_end, result, n, urb_generator);\n```", "```\n#include <algorithm>\n#include <map>\n#include <string>\n#include <iostream>\n#include <iomanip>\n#include <random>\n\nusing namespace std;\n\nconst string population = \"ABCD\"; ➊\nconst size_t n_samples{ 1'000'000 }; ➋\nmt19937_64 urbg; ➌\n\nvoid sample_length(size_t n) { ➍\n  cout << \"-- Length \" << n << \" --\\n\";\n map<string, size_t> counts; ➎\n  for (size_t i{}; i < n_samples; i++) {\n    string result;\n    sample(population.begin(), population.end(),\n           back_inserter(result), n, urbg); ➏\n    counts[result]++;\n  }\n  for (const auto[sample, n] : counts) { ➐\n    const auto percentage = 100 * n / static_cast<double>(n_samples);\n    cout << percentage << \" '\" << sample << \"'\\n\"; ➑\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(1); ➒\n  sample_length(0); ➓\n  sample_length(1);\n  sample_length(2);\n  sample_length(3);\n  sample_length(4);\n}\n-----------------------------------------------------------------------\n-- Length 0 --\n100.0 ''\n-- Length 1 --\n25.1 'A'\n25.0 'B'\n25.0 'C'\n24.9 'D'\n-- Length 2 --\n16.7 'AB'\n16.7 'AC'\n16.6 'AD'\n16.6 'BC'\n16.7 'BD'\n16.7 'CD'\n-- Length 3 --\n25.0 'ABC'\n25.0 'ABD'\n25.0 'ACD'\n25.0 'BCD'\n-- Length 4 --\n100.0 'ABCD'\n```", "```\nvoid shuffle(rnd_begin, rnd_end, urb_generator);\n```", "```\n#include <algorithm>\n#include <map>\n#include <string>\n#include <iostream>\n#include <random>\n#include <iomanip>\n\nusing namespace std;\n\nint main() {\n  const string population = \"ABCD\"; ➊\n  const size_t n_samples{ 1'000'000 }; ➋\n  mt19937_64 urbg; ➌\n map<string, size_t> samples; ➍\n  cout << fixed << setprecision(1); ➎\n  for (size_t i{}; i < n_samples; i++) {\n    string result{ population }; ➏\n    shuffle(result.begin(), result.end(), urbg); ➐\n    samples[result]++; ➑\n  }\n  for (const auto[sample, n] : samples) { ➒\n    const auto percentage = 100 * n / static_cast<double>(n_samples);\n    cout << percentage << \" '\" << sample << \"'\\n\"; ➓\n  }\n}\n-----------------------------------------------------------------------\n4.2 'ABCD'\n4.2 'ABDC'\n4.1 'ACBD'\n4.2 'ACDB'\n4.2 'ADBC'\n4.2 'ADCB'\n4.2 'BACD'\n4.2 'BADC'\n4.1 'BCAD'\n4.2 'BCDA'\n4.1 'BDAC'\n4.2 'BDCA'\n4.2 'CABD'\n4.2 'CADB'\n4.1 'CBAD'\n4.1 'CBDA'\n4.2 'CDAB'\n4.1 'CDBA'\n4.2 'DABC'\n4.2 'DACB'\n4.2 'DBAC'\n4.1 'DBCA'\n4.2 'DCAB'\n4.2 'DCBA'\n```", "```\nvoid sort([ep], rnd_begin, rnd_end, [comp]);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"sort\") {\n  string goat_grass{ \"spoilage\" }; ➊\n  sort(goat_grass.begin(), goat_grass.end()); ➋\n  REQUIRE(goat_grass == \"aegilops\"); ➌\n}\n```", "```\nvoid stable_sort([ep], rnd_begin, rnd_end, [comp]);\n```", "```\n#include <algorithm>\n\nenum class CharCategory { ➊\n  Ascender,\n  Normal,\n  Descender\n};\n\nCharCategory categorize(char x) { ➋\n  switch (x) {\n case 'g':\n    case 'j':\n    case 'p':\n    case 'q':\n    case 'y':\n      return CharCategory::Descender;\n    case 'b':\n    case 'd':\n    case 'f':\n    case 'h':\n    case 'k':\n    case 'l':\n    case 't':\n      return CharCategory::Ascender;\n  }\n  return CharCategory::Normal;\n}\n\nbool ascension_compare(char x, char y) { ➌\n  return categorize(x) < categorize(y);\n}\n\nTEST_CASE(\"stable_sort\") {\n  string word{ \"outgrin\" }; ➍\n  stable_sort(word.begin(), word.end(), ascension_compare); ➎\n  REQUIRE(word == \"touring\"); ➏\n}\n```", "```\nvoid partial_sort([ep], rnd_begin, rnd_middle, rnd_end, [comp]);\nRandomAccessIterator partial_sort_copy([ep], ipt_begin, ipt_end,\n                                       rnd_begin, rnd_end, [comp]);\n```", "```\n#include <algorithm>\n\nbool ascension_compare(char x, char y) {\n--snip--\n}\n\nTEST_CASE(\"partial_sort\") {\n  string word1{ \"nectarous\" }; ➊\n  partial_sort(word1.begin(), word1.begin() + 4, word1.end()); ➋\n  REQUIRE(word1 == \"acentrous\"); ➌\n\n  string word2{ \"pretanning\" }; ➍\n  partial_sort(word2.begin(), word2.begin() + 3, ➎\n               word2.end(), ascension_compare);\n  REQUIRE(word2 == \"trepanning\"); ➏\n}\n```", "```\nbool is_sorted([ep], rnd_begin, rnd_end, [comp]);\nForwardIterator is_sorted_until([ep], rnd_begin, rnd_end, [comp]);\n```", "```\n#include <algorithm>\n\nbool ascension_compare(char x, char y) {\n--snip--\n}\n\nTEST_CASE(\"is_sorted\") {\n  string word1{ \"billowy\" }; ➊\n  REQUIRE(is_sorted(word1.begin(), word1.end())); ➋\n\n  string word2{ \"floppy\" }; ➌\n  REQUIRE(word2.end() == is_sorted_until(word2.begin(), ➍\n                                         word2.end(), ascension_compare));\n}\n```", "```\nbool nth_element([ep], rnd_begin, rnd_nth, rnd_end, [comp]);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"nth_element\") {\n  vector<int> numbers{ 1, 9, 2, 8, 3, 7, 4, 6, 5 }; ➊\n  nth_element(numbers.begin(), numbers.begin() + 5, numbers.end()); ➋\n  auto less_than_6th_elem = [&elem=numbers[5]](int x) { ➌\n    return x < elem;\n  };\n  REQUIRE(all_of(numbers.begin(), numbers.begin() + 5, less_than_6th_elem)); ➍\n  REQUIRE(numbers[5] == 6 ); ➎\n}\n```", "```\nForwardIterator lower_bound(fwd_begin, fwd_end, value, [comp]);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"lower_bound\") {\n  vector<int> numbers{ 2, 4, 5, 6, 6, 9 }; ➊\n  const auto result = lower_bound(numbers.begin(), numbers.end(), 5); ➋\n  REQUIRE(result == numbers.begin() + 2); ➌\n}\n```", "```\nForwardIterator upper_bound(fwd_begin, fwd_end, value, [comp]);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"upper_bound\") {\n vector<int> numbers{ 2, 4, 5, 6, 6, 9 }; ➊\n  const auto result = upper_bound(numbers.begin(), numbers.end(), 5); ➋\n  REQUIRE(result == numbers.begin() + 3); ➌\n}\n```", "```\nForwardIteratorPair equal_range(fwd_begin, fwd_end, value, [comp]);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"equal_range\") {\n  vector<int> numbers{ 2, 4, 5, 6, 6, 9 }; ➊\n  const auto[rbeg, rend] = equal_range(numbers.begin(), numbers.end(), 6); ➋\n  REQUIRE(rbeg == numbers.begin() + 3); ➌\n  REQUIRE(rend == numbers.begin() + 5); ➍\n}\n```", "```\nbool binary_search(fwd_begin, fwd_end, value, [comp]);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"binary_search\") {\n  vector<int> numbers{ 2, 4, 5, 6, 6, 9 }; ➊\n  REQUIRE(binary_search(numbers.begin(), numbers.end(), 6)); ➋\n  REQUIRE_FALSE(binary_search(numbers.begin(), numbers.end(), 7)); ➌\n}\n```", "```\nbool is_partitioned([ep], ipt_begin, ipt_end, pred);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"is_partitioned\") {\n  auto is_odd = [](auto x) { return x % 2 == 1; }; ➊\n\n  vector<int> numbers1{ 9, 5, 9, 6, 4, 2 }; ➋\n  REQUIRE(is_partitioned(numbers1.begin(), numbers1.end(), is_odd)); ➌\n\n  vector<int> numbers2{ 9, 4, 9, 6, 4, 2 }; ➍\n  REQUIRE_FALSE(is_partitioned(numbers2.begin(), numbers2.end(), is_odd)); ➎\n}\n```", "```\nForwardIterator partition([ep], fwd_begin, fwd_end, pred);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"partition\") {\n  auto is_odd = [](auto x) { return x % 2 == 1; }; ➊\n  vector<int> numbers{ 1, 2, 3, 4, 5 }; ➋\n  const auto partition_point = partition(numbers.begin(),\n                                         numbers.end(), is_odd); ➌\n  REQUIRE(is_partitioned(numbers.begin(), numbers.end(), is_odd)); ➍\n  REQUIRE(partition_point == numbers.begin() + 3); ➎\n}\n```", "```\nForwardIteratorPair partition_copy([ep], ipt_begin, ipt_end,\n                                         opt_true, opt_false, pred);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"partition_copy\") {\n  auto is_odd = [](auto x) { return x % 2 == 1; }; ➊\n  vector<int> numbers{ 1, 2, 3, 4, 5 }, odds, evens; ➋\n  partition_copy(numbers.begin(), numbers.end(),\n                 back_inserter(odds), back_inserter(evens), is_odd); ➌\n  REQUIRE(all_of(odds.begin(), odds.end(), is_odd)); ➍\n  REQUIRE(none_of(evens.begin(), evens.end(), is_odd)); ➎\n}\n```", "```\nBidirectionalIterator stable_partition([ep], bid_begin, bid_end, pred);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"stable_partition\") {\n  auto is_odd = [](auto x) { return x % 2 == 1; }; ➊\n  vector<int> numbers{ 1, 2, 3, 4, 5 }; ➋\n  stable_partition(numbers.begin(), numbers.end(), is_odd); ➌\n  REQUIRE(numbers == vector<int>{ 1, 3, 5, 2, 4 }); ➍\n}\n```", "```\nOutputIterator merge([ep], ipt_begin1, ipt_end1,\n                     ipt_begin2, ipt_end2, opt_result, [comp]);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"merge\") {\n  vector<int> numbers1{ 1, 4, 5 }, numbers2{ 2, 3, 3, 6 }, result; ➊\n  merge(numbers1.begin(), numbers1.end(),\n        numbers2.begin(), numbers2.end(),\n        back_inserter(result)); ➋\n  REQUIRE(result == vector<int>{ 1, 2, 3, 3, 4, 5, 6 }); ➌\n}\n```", "```\nT min(obj1, obj2, [comp]);\nT min(init_list, [comp]);\nT max(obj1, obj2, [comp]);\nT max(init_list, [comp]);\nPair minmax(obj1, obj2, [comp]);\nPair minmax(init_list, [comp]);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"max and min\") {\n auto length_compare = [](const auto& x1, const auto& x2) { ➊\n    return x1.length() < x2.length();\n  };\n\nstring undisc=\"undiscriminativeness\", vermin=\"vermin\";\n  REQUIRE(min(undisc, vermin, length_compare) == \"vermin\"); ➋\n\nstring maxim=\"maxim\", ultra=\"ultramaximal\";\n  REQUIRE(max(maxim, ultra, length_compare) == \"ultramaximal\"); ➌\n\nstring mini=\"minimaxes\", maxi=\"maximin\";\n  const auto result = minmax(mini, maxi, length_compare); ➍\n  REQUIRE(result.first == maxi); ➎\n  REQUIRE(result.second == mini); ➏\n}\n```", "```\nForwardIterator min_element([ep], fwd_begin, fwd_end, [comp]);\nForwardIterator max_element([ep], fwd_begin, fwd_end, [comp]);\nPair minmax_element([ep], fwd_begin, fwd_end, [comp]);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"min and max element\") {\n  auto length_compare = [](const auto& x1, const auto& x2) { ➊\n    return x1.length() < x2.length();\n  };\n\n  vector<string> words{ \"civic\", \"deed\", \"kayak\",  \"malayalam\" }; ➋\n\n  REQUIRE(*min_element(words.begin(), words.end(),\n                       length_compare) == \"deed\"); ➌\n  REQUIRE(*max_element(words.begin(), words.end(),\n                       length_compare) == \"malayalam\"); ➍\n\n  const auto result = minmax_element(words.begin(), words.end(),\n                                     length_compare); ➎\n  REQUIRE(*result.first == \"deed\"); ➏\n  REQUIRE(*result.second == \"malayalam\"); ➐\n}\n```", "```\nT& clamp(obj, low, high, [comp]);\n```", "```\n#include <algorithm>\n\nTEST_CASE(\"clamp\") {\n  REQUIRE(clamp(9000, 0, 100) == 100); ➊\n  REQUIRE(clamp(-123, 0, 100) == 0); ➋\n  REQUIRE(clamp(3.14, 0., 100.) == Approx(3.14)); ➌\n}\n```", "```\n#include <functional>\n\nTEST_CASE(\"plus\") {\n  plus<short> adder; ➊\n  REQUIRE(3 == adder(1, 2)); ➋\n  REQUIRE(3 == plus<short>{}(1,2)); ➌\n}\n```", "```\nvoid iota(fwd_begin, fwd_end, start);\n```", "```\n#include <numeric>\n#include <array>\n\nTEST_CASE(\"iota\") {\n  array<int, 3> easy_as; ➊\n  iota(easy_as.begin(), easy_as.end(), 1); ➋\n  REQUIRE(easy_as == array<int, 3>{ 1, 2, 3 }); ➌\n}\n```", "```\nT accumulate(ipt_begin, ipt_end, start, [op]);\n```", "```\n#include <numeric>\n\nTEST_CASE(\"accumulate\") {\n  vector<int> nums{ 1, 2, 3 }; ➊\n  const auto result1 = accumulate(nums.begin(), nums.end(), -1); ➋\n  REQUIRE(result1 == 5); ➌\n\n  const auto result2 = accumulate(nums.begin(), nums.end(),\n                                  2, multiplies<>()); ➍\n  REQUIRE(result2 == 12); ➎\n}\n```", "```\nT reduce([ep], ipt_begin, ipt_end, start, [op]);\n```", "```\n#include <numeric>\n\nTEST_CASE(\"reduce\") {\n  vector<int> nums{ 1, 2, 3 }; ➊\n  const auto result1 = reduce(nums.begin(), nums.end(), -1); ➋\n  REQUIRE(result1 == 5); ➌\n\n  const auto result2 = reduce(nums.begin(), nums.end(),\n                                  2, multiplies<>()); ➍\n  REQUIRE(result2 == 12); ➎\n}\n```", "```\nT inner_product([ep], ipt_begin1, ipt_end1, ipt_begin2, start, [op1], [op2]);\n```", "```\n#include <numeric>\n\nTEST_CASE(\"inner_product\") {\n  vector<int> nums1{ 1, 2, 3, 4, 5 }; ➊\n  vector<int> nums2{ 1, 0,-1, 0, 1 }; ➋\n  const auto result = inner_product(nums1.begin(), nums1.end(),\n                                    nums2.begin(), 10); ➌\n  REQUIRE(result == 13); ➍\n}\n```", "```\nOutputIterator adjacent_difference([ep], ipt_begin, ipt_end, result, [op]);\n```", "```\n#include <numeric>\n\nTEST_CASE(\"adjacent_difference\") {\n  vector<int> fib{ 1, 1, 2, 3, 5, 8 }, fib_diff; ➊\n  adjacent_difference(fib.begin(), fib.end(), back_inserter(fib_diff)); ➋\n  REQUIRE(fib_diff == vector<int>{ 1, 0, 1, 1, 2, 3 }); ➌\n}\n```", "```\nOutputIterator partial_sum(ipt_begin, ipt_end, result, [op]);\n```", "```\n#include <numeric>\n\nTEST_CASE(\"partial_sum\") {\n  vector<int> num{ 1, 2, 3, 4 }, result; ➊\n  partial_sum(num.begin(), num.end(), back_inserter(result)); ➋\n  REQUIRE(result == vector<int>{ 1, 3, 6, 10 }); ➌\n}\n```"]