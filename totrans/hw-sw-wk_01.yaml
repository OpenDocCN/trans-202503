- en: '**1**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Encryption**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/common-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We rely on software to protect our data every day, but most of us know little
    about how this protection works. Why does a “lock” icon in the corner of your
    browser mean it’s safe to enter your credit card number? How does creating a password
    for your phone actually protect the data inside? What really prevents other people
    from logging into your online accounts?
  prefs: []
  type: TYPE_NORMAL
- en: '*Computer security* is the science of protecting data. In a way, computer security
    represents technology solving a problem that technology created. Not that long
    ago, most data wasn’t stored digitally. We had filing cabinets in our offices
    and shoeboxes of photographs under our beds. Of course, back then you couldn’t
    easily share your photographs with friends around the world or check your bank
    balance from a mobile phone, but neither could anyone steal your private data
    without physically taking it. Today, not only can you be robbed at a distance,
    but you might not even know you’ve been robbed—that is, until your bank calls
    to ask why you are buying thousands of dollars in gift cards.'
  prefs: []
  type: TYPE_NORMAL
- en: Over these first three chapters, we’ll discuss the most important concepts behind
    computer security. In this chapter, we talk about encryption. By itself, encryption
    provides us with the capability to lock our data so only *we* can unlock it. Additional
    techniques, discussed in the next two chapters, are needed to provide the full
    security suite that we depend on, but encryption is the core of computer security.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Goal of Encryption**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Think of a file on your computer: it might contain text, a photograph, a spreadsheet,
    audio, or video. You want to access the file but keep it secret from everyone
    else. This is the fundamental problem of computer security. To keep the file secret,
    you can use *encryption* to transform it into a new format that is unreadable
    until the file has been returned to its original form using *decryption*. The
    original file is the *plaintext* (even if the file isn’t text), and the encrypted
    file is the *ciphertext*.'
  prefs: []
  type: TYPE_NORMAL
- en: An *attacker* is someone who attempts to decrypt the ciphertext without authorization.
    The goal of encryption is to create a ciphertext that is easy for authorized users
    to decrypt, while practically impossible for attackers to decrypt. “Practically”
    is the source of many headaches for security researchers. Just as no lock is absolutely
    unbreakable, no encryption can be absolutely impossible to decrypt. With enough
    time and enough computing power, any encryption scheme can be broken in theory.
    The goal of computer security is to make an attacker’s job so difficult that successful
    attacks are impossible in practice, requiring computing resources beyond an attacker’s
    means.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than jump headfirst into the intricacies of software-based encryption,
    I’ll start this chapter with some simple examples from the pre-software days of
    codes and spies. Although the strength of encryption has vastly improved over
    the years, these same classic techniques form the basis of all encryption. Later,
    you’ll see how these ideas are combined in a modern digital encryption scheme.
  prefs: []
  type: TYPE_NORMAL
- en: '**Transposition: Same Data, Different Order**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the simplest ways to encrypt data is called *transposition*, which simply
    means “changing position.” Transposition is the kind of encryption my friends
    and I used when passing notes in grade school. Because these notes were passed
    through untrustworthy hands, it was imperative the notes were unintelligible to
    anyone but us.
  prefs: []
  type: TYPE_NORMAL
- en: To keep messages secret, we rearranged the order of the letters using a simple,
    easy-to-reverse scheme. Suppose I needed to share the vital intelligence that
    CATHY LIKES KEITH (the names have been changed to protect the innocent). To encrypt
    the message, I copied every third letter of the plaintext (ignoring any spaces).
    During the first pass through the message, I copied five letters, as shown in
    [Figure 1-1](ch01.html#ch1fig1).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f01-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-1: The first pass in the transposition of the sample message*'
  prefs: []
  type: TYPE_NORMAL
- en: Having reached the end of the message, I started back at the beginning and continued
    selecting every third remaining letter. The second pass got me to the state shown
    in [Figure 1-2](ch01.html#ch1fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f01-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-2: The second transposition pass*'
  prefs: []
  type: TYPE_NORMAL
- en: On the last pass I copied the remaining letters, as shown in [Figure 1-3](ch01.html#ch1fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f01-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-3: The final transposition pass*'
  prefs: []
  type: TYPE_NORMAL
- en: The resulting ciphertext is CHISIAYKKTTLEEH. My friends could read the message
    by reversing the transposition process. The first step is shown in [Figure 1-4](ch01.html#ch1fig4).
    Returning all the letters to their original position reveals the plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f01-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-4: The first pass in reversing the transposition for decryption*'
  prefs: []
  type: TYPE_NORMAL
- en: This basic transposition method was fun to use, but it’s terribly weak encryption.
    The biggest concern is a leak—one of my friends blabbing about the encryption
    method to someone outside the circle. Once that happens, sending encrypted messages
    won’t be secure anymore; it will just be more work. Leaks are sadly inevitable—and
    not just with schoolchildren. Every encryption method is vulnerable to leaks,
    and the more people use a particular method, the more likely it will leak.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, all good encryption systems follow a rule formulated by early
    Dutch cryptographer Auguste Kerckhoffs, known as *Kerckhoffs’s principle*: the
    security of data should not depend on the encryption method remaining a secret.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Cipher Keys***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This raises an obvious question. If the encryption method is not a secret, how
    do we securely encrypt data? The answer lies in following a general, publically
    disclosed encryption method, but varying the encryption of individual messages
    using a *cipher key* (or just *key*). To understand what a key is, let’s examine
    a more general transposition method.
  prefs: []
  type: TYPE_NORMAL
- en: In this method, senders and receivers share a secret number prior to sending
    any messages. Let’s say my friends and I agree on 374\. We’ll use this number
    to alter the transposition pattern in our ciphertexts. This pattern is shown in
    [Figure 1-5](ch01.html#ch1fig5) for the message CATHY LIKES KEITH. The digits
    of our secret number dictate which letter should be copied from the plaintext
    to the ciphertext. Because the first digit is 3, the third letter of the plaintext,
    *T*, becomes the first letter of the ciphertext. The next digit is 7, so the next
    letter is the seventh letter after the *T*, which is *S*. Next, we select the
    fourth letter from the *S*. The first three letters of the ciphertext are *TST*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-6](ch01.html#ch1fig6) shows how the next two letters are copied to
    the ciphertext. Starting from where we left off (indicated by the circled 1 in
    the figure), we count three positions, returning to the beginning of the plaintext
    when we reach the end, to select *A* as the fourth letter of the ciphertext. The
    next letter chosen is seven positions after the *A*, skipping letters that have
    already been copied: the *K*. The process continues until all of the letters of
    the plaintext have been transposed.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f01-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-5: The first pass in transposing using the key 374*'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f01-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-6: The second pass in transposing using the key 374*'
  prefs: []
  type: TYPE_NORMAL
- en: The secret number 374, then, is our cipher key. Someone who intercepts this
    message won’t be able to decrypt it without the key, even if they understand we’re
    using a transposition method. The code can be regularly changed to prevent blabbermouths
    and turncoats from compromising the encryption.
  prefs: []
  type: TYPE_NORMAL
- en: '***Attacking the Encryption***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Even without the key, attackers can still try to recover the plaintext through
    other means. Encrypted data can be attacked through *brute force*, trying all
    the possible ways of applying the encryption method to the ciphertext. For a message
    encrypted using transposition, a brute-force attack would examine all permutations
    of the ciphertext. Because brute force is almost always an option, the number
    of trials an attacker will need to find the plaintext is a good baseline for encryption
    strength. In our example, the message CATHY LIKES KEITH has around 40 billion
    permutations.
  prefs: []
  type: TYPE_NORMAL
- en: That’s a huge number, so instead of brute force, a smart attacker would apply
    some common sense to recover the plaintext faster. If the attacker can assume
    the plaintext is in English, then most of the permutations can be ruled out before
    they are tested. For example, the attacker can assume the plaintext won’t start
    with the letters *HT* because no English word starts with those letters. That’s
    a billion permutations the attacker won’t have to check.
  prefs: []
  type: TYPE_NORMAL
- en: An attacker with some idea of the words in the message can be even smarter about
    figuring out the plaintext. In our example, the attacker might guess the message
    includes the name of a classmate. They can see what names can be formed from the
    ciphertext letters and then determine what words can be formed from the leftover
    letters.
  prefs: []
  type: TYPE_NORMAL
- en: Guesses about the plaintext content are known as *cribs*. The strongest kind
    of crib is a *known-plaintext attack*. To carry out this type of attack, the attacker
    must have access to a plaintext A, its matching ciphertext A, and a ciphertext
    B that uses the same cipher key as ciphertext A. Although this scenario sounds
    unlikely, it does happen. People often leave documents unguarded when they are
    no longer considered secret without realizing they may aid attacks on other documents.
    Known-plaintext attacks are power ful; figuring out the transposition pattern
    is easy when you have both the plaintext and ciphertext in front of you.
  prefs: []
  type: TYPE_NORMAL
- en: The best defenses against known-plaintext attacks are good security practices,
    such as regularly changing passwords. Even with the best security practices, though,
    attackers will almost always have some idea of a plaintext’s contents (that’s
    why are they so interested in reading it). In many cases, they will know most
    of the plaintext and may have access to known plaintext-ciphertext pairs. A good
    encryption system should render cribs and known plaintexts useless to attackers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Substitution: Replacing Data**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The other fundamental encryption technique is more resistant to cribs. Instead
    of moving the data around, *substitution* methods systematically replace individual
    pieces of data. With text messages, the simplest form of substitution replaces
    every occurrence of one letter with another letter. For example, every *A* becomes
    a *D*, every *B* an *H*, and so on. A key for this type of encryption looks like
    [Table 1-1](ch01.html#ch1tab1).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 1-1:** A Substitution Cipher Key'
  prefs: []
  type: TYPE_NORMAL
- en: '| Original | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P
    | Q | R | S | T | U | V | W | X | Y | Z |'
  prefs: []
  type: TYPE_TB
- en: '| Replacement | M | N | B | V | C | X | Z | L | K | F | H | G | J | D | S |
    A | P | O | I | U | Y | T | R | E | W | Q |'
  prefs: []
  type: TYPE_TB
- en: 'Although *simple substitution*, as this method is called, is an improvement
    over transposition, it too has problems: there are only so many possible substitutions,
    so an attacker can sometimes decrypt ciphertext through brute force.'
  prefs: []
  type: TYPE_NORMAL
- en: Simple substitution is also vulnerable to *frequency analysis*, in which an
    attacker applies knowledge of how often letters or letter combinations occur in
    a given language. Stated broadly, knowing how often data items are likely to appear
    in a plaintext gives the attacker an advantage. For example, the letter *E* is
    the most common letter in English writing, and *TH* is the most common letter
    pair. Therefore, the most frequently occurring letter in a long ciphertext is
    likely to represent plaintext *E*, and the most frequently occurring letter pair
    is likely to represent plaintext *TH*.
  prefs: []
  type: TYPE_NORMAL
- en: The power of frequency analysis means that substitution encryption becomes more
    vulnerable as the text grows longer. Attacks are also easier when a collection
    of ciphertexts is known to have been encrypted with the same key; avoiding such
    *key reuse* is an important security practice.
  prefs: []
  type: TYPE_NORMAL
- en: '***Varying the Substitution Pattern***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To strengthen encryption against frequency analysis, we can vary the substitution
    pattern during encryption, so the first *E* in the plaintext might be replaced
    with *A*, but the second *E* in the plaintext is replaced with a *T*. This technique
    is known as *polyalphabetic substitution*. One method of polyalphabetic substitution
    uses a grid of alphabets known as a *tabula recta*, shown in [Figure 1-7](ch01.html#ch1fig7).
    In this table, each row and column is labeled with the letter of the alphabet
    that starts the row or column. Every location in the grid is located with two
    letters, such as row D, column H, which contains the letter *K*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f01-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-7: A tabula recta—the shaded first column and row are labels.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a tabula recta, the key is textual—letters are used to vary the
    encryption instead of numbers, as we used in our transposition example. The letters
    of the plaintext select rows in the tabula recta, and the letters of the key select
    columns. For example, suppose our plaintext message is the word *SECRET*, and
    our encryption key is the word *TOUGH*. Because the first letter of the plaintext
    is *S* and the first letter of the key is *T*, the first letter of the ciphertext
    is found at row S, column T in the tabula recta: the letter *L*. We then use the
    O column of the table to encrypt the second plaintext letter *E* (resulting in
    *S*), and so on, as shown in [Figure 1-8](ch01.html#ch1fig8). Because the plaintext
    is longer than the key, we must reuse the first letter of the key.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f01-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-8: Encryption using the tabula recta and cipher key* TOUGH'
  prefs: []
  type: TYPE_NORMAL
- en: Decryption reverses the process, as shown in [Figure 1-9](ch01.html#ch1fig9).
    The letters in the key indicate the columns, which are scanned to find the corresponding
    letter in the ciphertext. The row where the ciphertext letter is found indicates
    the plaintext letter. In our example, the first letter of our key is *T*, and
    the first letter of the ciphertext is *L*. We scan the T column of the tabula
    recta to find *L*; because *L* appears in row S, the plaintext letter is *S*.
    The process repeats for every letter of the ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f01-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-9: Decryption using the tabula recta and cipher key* TOUGH'
  prefs: []
  type: TYPE_NORMAL
- en: Polyalphabetic substitution is more effective than simple substitution because
    it varies the substitution pattern throughout the message. In our example, the
    two occurrences of *E* in the plaintext become different ciphertext letters, and
    the two occurrences of *L* in the ciphertext represent two different plaintext
    letters.
  prefs: []
  type: TYPE_NORMAL
- en: '***Key Expansion***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Although polyalphabetic substitution is a great improvement over simple substitution,
    it’s effective only when the key isn’t repeated too often; otherwise it has the
    same problems as simple substitution. With a key length of five, for example,
    each plaintext letter would be represented by only five different ciphertext letters,
    leaving long ciphertexts vulnerable to frequency analysis and cribs. An attacker
    would have to work harder, but given enough ciphertext to work with, an attacker
    could still break the encryption.
  prefs: []
  type: TYPE_NORMAL
- en: For maximum effectiveness, we need encryption keys that are as long as the plaintext,
    a technique known as a *one-time pad*. But that’s not a practical solution for
    most situations. Instead, a method called *key expansion* allows short keys to
    do the work of longer ones. One implementation of this idea frequently appears
    in spy novels. Instead of sharing a super-long key, two spies who need to exchange
    messages agree on a *code book*, which is used as a repository of long keys. To
    avoid arousing suspicion, the code book is an ordinary piece of literature, like
    a specific edition of Shakespeare’s plays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose a 50-letter message will be sent using this scheme. In addition
    to the ciphertext, the message sender also appends the unexpanded key. Using the
    works of Shakespeare as the code book, the unexpanded key might be 2.2.4.9\. The
    first 2 indicates the second of Shakespeare’s plays when listed alphabetically
    (*As You Like It*). The second 2 means Act II of the play. The 4 means Scene 4
    of that act. The 9 means the ninth sentence of that scene in the specified edition:
    “When I was at home, I was in a better place, but travelers must be content.”
    The number of letters in this sentence exceeds the number in the plaintext and
    could be used for encryption and decryption using a tabula recta as before. In
    this way, a relatively short key can be expanded to fit a particular message.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that this scheme doesn’t qualify as a one-time pad because the code book
    is finite, and therefore the sentence-keys would have to be reused eventually.
    But it does mean our spies only have to remember short cipher keys while encrypting
    their messages more securely with longer keys. As you’ll see, the key expansion
    concept is important in computer encryption because the cipher keys required are
    huge but need to be stored in smaller forms.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Advanced Encryption Standard**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve seen how transposition, substitution, and key expansion work
    individually, let’s see how secure digital encryption results from a careful combination
    of all three techniques.
  prefs: []
  type: TYPE_NORMAL
- en: The *Advanced Encryption Standard (AES)* is an open standard, which means the
    specifications may be implemented by anyone without paying a license fee. Whether
    you realize it or not, much of your data is protected by AES. If you have a secure
    wireless network at your home or office, if you have ever password-protected a
    file in a *.zip* archive, or if you use a credit card at a store or make a withdrawal
    from an ATM, you are probably relying, at least in part, on AES.
  prefs: []
  type: TYPE_NORMAL
- en: '***Binary Basics***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Up to now, I’ve used text encryption samples to keep the examples simple. The
    data encrypted by computers, though, is represented in the form of binary numbers.
    If you haven’t worked with these numbers before, here’s an introduction.
  prefs: []
  type: TYPE_NORMAL
- en: '**Decimal Versus Binary**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The number system we all grew up with is called the *decimal* system, *deci*
    meaning “ten,” because the system uses 10 digits, 0 through 9\. Each digit in
    a number represents the quantity of a unit 10 times greater than the digit to
    its right. The units and quantities for the decimal number 23,065 are shown in
    [Figure 1-10](ch01.html#ch1fig10). The 2 in the fifth position from the left means
    we have 2 “ten thousands,” for example, and the 6 means 6 “tens.”
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f01-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-10: Each digit in the decimal number 23,065 represents a different
    unit quantity.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *binary* number system, there are only two possible digits, 0 or 1,
    which are called *bits*, for *bi*nary digi*ts*. Each bit in a binary number represents
    a unit twice as large as the bit to the right. The units and quantities for the
    binary number 110101 are shown in [Figure 1-11](ch01.html#ch1fig11). As shown,
    we have one of each of the following units: 32, 16, 4, and 1\. Therefore, the
    binary number 110101 represents the sum of these four unit values, which is the
    decimal number 53.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f01-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-11: Each bit in the binary number 110101 represents a different unit
    quantity.*'
  prefs: []
  type: TYPE_NORMAL
- en: Binary numbers are often written with a fixed number of bits. The most common
    length for a binary number is eight bits, known as a *byte*. Although the decimal
    number 53 can be written as 110101 in binary, writing 53 as a byte requires eight
    bits, so leading 0 bits fill out the other positions to make 00110101\. The smallest
    byte value, 00000000, represents decimal 0; the largest possible byte, 11111111,
    represents decimal 255.
  prefs: []
  type: TYPE_NORMAL
- en: '**Bitwise Operations**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Along with the usual mathematical operations such as addition and multiplication,
    software also uses some operations unique to binary numbers. These are known as
    *bitwise operations* because they are applied individually to each bit rather
    than to the binary number as whole.
  prefs: []
  type: TYPE_NORMAL
- en: The bitwise operation known as *exclusive-or*, or *XOR*, is common in encryption.
    When two binary numbers are XORed together, the 1s in the second number flip the
    corresponding bits in the first number, as shown in [Figure 1-12](ch01.html#ch1fig12).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f01-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-12: The exclusive-or (XOR) operation. The 1 bits in the second byte
    indicate which bits are “flipped” in the first byte, as shown in the shaded columns.*'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, encryption must be reversible. XOR alters the bit patterns in a way
    that’s impossible to predict without knowing the binary numbers involved, but
    it’s easily reversed. XORing the result with the second number flips the same
    bits back to their original state, as shown in [Figure 1-13](ch01.html#ch1fig13).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f01-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-13: If we XOR a byte with the same byte twice, we’re back to where
    we started.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Converting Data to Binary Form**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Computers use binary numbers to represent all kinds of data. A plaintext file
    could be a text message, a spreadsheet, an image, an audio file, or anything else—but
    in the end, every file is a sequence of bytes. Most computer data is already numeric
    and can therefore be directly converted into binary numbers. In some cases, though,
    a special encoding system is needed to convert non-numeric data into binary form.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to see how a text message becomes a sequence of bytes, consider
    this message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This message has 16 characters, counting the letters, spaces, and exclamation
    point. We can turn each character into a byte using a system such as the *American
    Standard Code for Information Interchange*, which is always referred to by its
    acronym, *ASCII*, pronounced “as-key”. In ASCII, capital *A* is represented by
    the number 65, *B* by 66, and so on, through 90 for *Z*. [Table 1-2](ch01.html#ch1tab2)
    shows some selected entries from the ASCII table.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 1-2:** Selected Entries from the ASCII Table'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Character** | **Decimal number** | **Binary byte** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| (space) | 32 | 00100000 |'
  prefs: []
  type: TYPE_TB
- en: '| ! | 33 | 00100001 |'
  prefs: []
  type: TYPE_TB
- en: '| , | 44 | 00101100 |'
  prefs: []
  type: TYPE_TB
- en: '| . | 46 | 00101110 |'
  prefs: []
  type: TYPE_TB
- en: '| A | 65 | 01000001 |'
  prefs: []
  type: TYPE_TB
- en: '| B | 66 | 01000010 |'
  prefs: []
  type: TYPE_TB
- en: '| C | 67 | 01000011 |'
  prefs: []
  type: TYPE_TB
- en: '| D | 68 | 01000100 |'
  prefs: []
  type: TYPE_TB
- en: '| E | 69 | 01000101 |'
  prefs: []
  type: TYPE_TB
- en: '| a | 97 | 01100001 |'
  prefs: []
  type: TYPE_TB
- en: '| b | 98 | 01100010 |'
  prefs: []
  type: TYPE_TB
- en: '| c | 99 | 01100011 |'
  prefs: []
  type: TYPE_TB
- en: '| d | 100 | 01100100 |'
  prefs: []
  type: TYPE_TB
- en: '| e | 101 | 01100101 |'
  prefs: []
  type: TYPE_TB
- en: '***AES Encryption: The Big Picture***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we examine the details of AES encryption, here’s an overview of the process.
  prefs: []
  type: TYPE_NORMAL
- en: Cipher keys in AES are binary numbers. The size of the key can vary, but we’ll
    discuss the simplest version of AES, which uses a 128-bit key. Using mathematical
    key expansion, AES transforms the original 128-bit key into eleven 128-bit keys.
  prefs: []
  type: TYPE_NORMAL
- en: AES divides plaintext data into blocks of 16 bytes in a 4×4 grid; the grid for
    the sample message *Send more money!* is shown in [Figure 1-14](ch01.html#ch1fig14).
    Heavy lines separate the 16 bytes, and light lines separate the bits within the
    bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f01-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-14: The sample message* Send more money! *transformed into a grid
    of bytes, ready for encryption using AES*'
  prefs: []
  type: TYPE_NORMAL
- en: The plaintext data is divided into as many 16-byte blocks as necessary. If the
    last block isn’t full, the rest of the block is padded with random binary numbers.
  prefs: []
  type: TYPE_NORMAL
- en: AES then subjects each 16-byte block of plaintext data to 10 *rounds* of encryption.
    During a round, the bytes are transposed within the block and substituted using
    a table. Then, using the XOR operation, the bytes in the block are combined with
    each other and with one of the 128-bit keys.
  prefs: []
  type: TYPE_NORMAL
- en: That’s AES in a nutshell; now let’s look at some of these steps in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '***Key Expansion in AES***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Key expansion in a digital encryption system is a bit different than the “code
    book” concept we discussed earlier. Instead of just looking up a longer key in
    a book, AES expands the key using the same tools it will later use for the encryption
    itself: the binary XOR operation, transposition, and simple substitution.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 1-15](ch01.html#ch1fig15) shows the first few stages of the key expansion
    process. Each of the blocks in the figure is 32 bits, and one row in this figure
    represents one 128-bit key. The original 128-bit key makes up the first four blocks,
    which are shaded in the figure. Every other block is the result of an XOR between
    two previous blocks; the XOR operation is represented by a plus sign in a circle.
    Block 6, for example, results from the XOR of Block 2 and Block 5.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f01-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-15: Key expansion process for AES*'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see on the right of the figure, every fourth block passes through
    a box labeled “Extra Scrambling.” This process includes transposing the bytes
    inside the block and substituting each byte according to a table called the *S-box*.
  prefs: []
  type: TYPE_NORMAL
- en: The S-box table, which is used both in the key expansion and later in the encryption
    itself, is carefully designed to amplify differences in the plaintext. That is,
    two plaintext bytes that are similar will tend to have S-box replacements that
    are quite different. The first eight entries from the table are shown in [Table
    1-3](ch01.html#ch1tab3).
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 1-3:** Excerpts from the S-Box Table'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Original bit pattern** | **Replacement bit pattern** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 00000000 | 01100011 |'
  prefs: []
  type: TYPE_TB
- en: '| 00000001 | 01111100 |'
  prefs: []
  type: TYPE_TB
- en: '| 00000010 | 01110111 |'
  prefs: []
  type: TYPE_TB
- en: '| 00000011 | 01111011 |'
  prefs: []
  type: TYPE_TB
- en: '| 00000100 | 11110010 |'
  prefs: []
  type: TYPE_TB
- en: '| 00000101 | 01101011 |'
  prefs: []
  type: TYPE_TB
- en: '| 00000110 | 01101111 |'
  prefs: []
  type: TYPE_TB
- en: '| 00000111 | 11000101 |'
  prefs: []
  type: TYPE_TB
- en: '| 00001000 | 00110000 |'
  prefs: []
  type: TYPE_TB
- en: '| 00001001 | 00000001 |'
  prefs: []
  type: TYPE_TB
- en: '***AES Encryption Rounds***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once AES has all the required keys, the real encryption can begin. Recall that
    the binary plaintext is stored in a grid of 16 bytes or 128 bits, which is the
    same size as the original key. This is not a coincidence. The first step of the
    actual encryption is to XOR the 128-bit data grid with the original 128-bit key.
    Now the work begins in earnest, as the data grid is subjected to 10 rounds of
    number crunching. There are four steps in each round.
  prefs: []
  type: TYPE_NORMAL
- en: '**1\. Substitution.**'
  prefs: []
  type: TYPE_NORMAL
- en: Each of the 16 bytes in the grid is replaced using the same S-box table used
    in the key expansion process.
  prefs: []
  type: TYPE_NORMAL
- en: '**2\. Row Transposition.**'
  prefs: []
  type: TYPE_NORMAL
- en: Next, the bytes are moved to different positions within their row in the grid.
  prefs: []
  type: TYPE_NORMAL
- en: '**3\. Column Combination.**'
  prefs: []
  type: TYPE_NORMAL
- en: Next, for each byte in the grid, a new byte is calculated from a combination
    of all four bytes in that column. This computation involves the XOR operation
    again, but also a binary form of transposition. To give you the flavor of the
    process, [Figure 1-16](ch01.html#ch1fig16) shows the computation of the leftmost
    byte in the lowest row. The four bytes of the leftmost column are XORed together,
    but the top and bottom bytes in the column have their bits transposed first. This
    kind of transposition is known as *bitwise rotation*; the bits slide one position
    to the left, with the leftmost bit moving over to the right end.
  prefs: []
  type: TYPE_NORMAL
- en: Every byte in the new grid is computed in a similar way, by combining the bytes
    in the column using XOR; the only variation is which bytes have their bits rotated
    before the XOR.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f01-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-16: One part of the column-scrambling step in an AES round*'
  prefs: []
  type: TYPE_NORMAL
- en: '**4\. XOR with Cipher Key.**'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the grid that results from the previous step is XORed with the key
    for that round. This is why key expansion is needed, so that each round XORs with
    a different key.
  prefs: []
  type: TYPE_NORMAL
- en: The AES decryption process performs the same steps as the encryption process,
    in reverse. Because the only operations in the encryption are XORs, simple substitution
    from the S-box, and transpositions of bits and bytes, everything is reversible
    if the key is known.
  prefs: []
  type: TYPE_NORMAL
- en: '***Block Chaining***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: AES encryption could be applied individually to each 16-byte block in a file,
    but this would create vulnerabilities in the ciphertext. As we’ve discussed, the
    more times an encryption key is used, the more likely it is that attackers will
    discover and exploit patterns. Computer files are often enormous, and using the
    same key to encrypt millions of blocks is a form of large-scale key reuse that
    exposes the ciphertext to frequency analysis and related techniques.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, block-based encryption systems like AES are modified so that
    identical blocks in plaintext produce different ciphertext blocks. One such modification
    is called *block chaining*.
  prefs: []
  type: TYPE_NORMAL
- en: When block chaining, the first block of the plaintext is XORed with a random
    128-bit number before encryption. This random number is called the *starting variable*
    and is stored along with the ciphertext. Because each encryption is assigned a
    random starting variable, two files that begin with the same data will have different
    ciphertexts even when encrypted with the same key.
  prefs: []
  type: TYPE_NORMAL
- en: Every subsequent plaintext block is XORed with the previous ciphertext block
    before encryption, “chaining” the encryption as shown in [Figure 1-17](ch01.html#ch1fig17).
    Chaining ensures that duplicate blocks in a plaintext will result in different
    ciphertext blocks. This means files of any length can be encrypted without fear
    of frequency analysis.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](graphics/f01-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 1-17: AES encryption using block chaining*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Why AES Is Secure***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As you can see, although AES contains many steps, each individual step is just
    transposition or simple substitution. Why is AES considered strong enough to protect
    the world’s data? Remember, attackers use brute force or cribs, or exploit patterns
    in the ciphertext. AES has excellent defenses against all of these attack methods.
  prefs: []
  type: TYPE_NORMAL
- en: With AES, brute force means running the ciphertext through the decryption process
    with every possible key until the plaintext is produced. In AES, keys have 128,
    192, or 256 bits. Even the smallest key size offers around 300,000,000,000,000,000,000,000,000,000,000,000,000
    possible keys, and a brute-force attack would need to try about half of these
    before it could expect to hit the right one. An attacker with a computer that
    could try a million keys per second could, in a day, try 1,000,000 keys × 60 seconds
    × 60 minutes × 24 hours = 86,400,000,000 keys. In a year, the attacker could try
    31,536,000,000,000 keys. Although that’s a large number, it’s not even a billionth
    of a billionth of the possible combinations. An attacker might acquire more computing
    power, but trying that many keys still doesn’t seem feasible—and that’s just for
    the 128-bit version.
  prefs: []
  type: TYPE_NORMAL
- en: AES also makes using cribs or finding exploitable patterns difficult. During
    each encryption round, AES rotates the bytes in each row of the grid and combines
    the bytes in each column. After many rounds of this, the bytes are thoroughly
    mixed together so the final value of any one byte in the ciphertext grid depends
    on the initial plaintext values of all the bytes in a grid. This encryption property
    is called *diffusion*.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, passing the bytes through the S-box, round after round, amplifies
    the effect of diffusion, and block chaining passes the diffusion effects of each
    block on to the next. Together, these operations give AES the *avalanche* property,
    in which small changes in the plaintext result in sweeping changes throughout
    the ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: AES thwarts attackers no matter how much they know about the general layout
    of the plaintext. For example, a company may send emails to customers based on
    a common template, in which the only variables are the customers’ account numbers
    and outstanding balances. With diffusion, avalanches, and block chaining, the
    ciphertexts of these emails will be very different. Diffusion and avalanches also
    reduce patterns that could be exploited through frequency analysis. Even a huge
    plaintext file consisting of the same 16-byte block repeated over and over would
    result in a random-looking jumble of bits when run through AES encryption with
    block chaining.
  prefs: []
  type: TYPE_NORMAL
- en: '***Possible AES Attacks***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: AES appears to be strong against conventional encryption attacks, but are there
    hidden weaknesses that offer shortcuts to finding the right cipher key? The answer
    is unclear because proving a negative is difficult. Stating that no shortcuts,
    or *cracks*, are known to exist is one thing; proving they *couldn’t* exist is
    another. Cryptography is a science, and science is always expanding its boundaries.
    We simply don’t understand cryptography and its underlying mathematics to a point
    where we can say what’s impossible.
  prefs: []
  type: TYPE_NORMAL
- en: Part of the difficulty in analyzing the vulnerabilities of an open standard
    like AES is that programmers implementing the standard in code may unwittingly
    introduce security flaws. For example, some AES implementations are vulnerable
    to a *timing attack*, in which an attacker gleans information about the data being
    encrypted by measuring how long the encryption takes. The attacker must have access
    to the specific computer on which the encryption is performed, however, so this
    isn’t really a flaw in the underlying encryption, but that’s no comfort if security
    is compromised.
  prefs: []
  type: TYPE_NORMAL
- en: The best-understood vulnerability of AES is known as a *related-key attack*.
    When two keys are mathematically related in a specific way, an attacker can sometimes
    use knowledge gathered from messages encrypted using one key to recover a message
    encrypted using the other key. Researchers have discovered a way to recover the
    AES encryption key for a particular ciphertext in less time than a brute-force
    attack, but the method requires ciphertexts of the same plaintext encrypted with
    keys that are related to the original key in very specific ways.
  prefs: []
  type: TYPE_NORMAL
- en: Although this shortcut counts as a crack, it may not be of practical value to
    attackers. First of all, although it greatly reduces the amount of work to recover
    the original key, it may not be feasible for any existing computer or network
    of computers. Second, it’s not easy to obtain the other ciphertexts that have
    been encrypted with the related keys; it requires a breakdown in the implementation
    or use of the cipher. Therefore, this crack is currently considered theoretical,
    not a practical weakness of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps the most worrying aspect of this crack is that it’s believed to work
    only for the supposedly stronger 256-bit-key version of AES, not the simpler 128-bit-key
    version described in this chapter. This demonstrates perhaps the greatest weakness
    of modern encryption techniques: their complexity. Flaws can go undetected for
    years despite the efforts of expert reviewers; small changes in the design can
    have large ramifications for security; and features intended to increase security
    may have the opposite effect.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Limits of Private-Key Encryption**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The real limitation of an encryption method like AES, though, has nothing to
    do with a potential hidden flaw.
  prefs: []
  type: TYPE_NORMAL
- en: All the encryption methods in this chapter, AES included, are known as *symmetric-key*
    methods—this means the key that encrypts a message or file is the same key that
    is used to decrypt it. If you want to use AES to encrypt a file on your desktop’s
    hard drive or the contact list in your phone, that’s not a problem; only you are
    locking and unlocking the data. But what happens when you need to secure a data
    transmission, as when you enter your credit card number on a retail website? You
    could encrypt the data with AES and send it to the website, but the software on
    the website couldn’t decrypt the ciphertext without the key.
  prefs: []
  type: TYPE_NORMAL
- en: This is the *shared key problem*, and it’s one of the central problems of cryptography.
    Without a secure way to share keys, symmetric key encryption, by itself, is only
    useful for locking one’s own private data. Encrypting data for transmission requires
    a different approach, using different keys for encryption and decryption—you’ll
    see how this is done in [Chapter 3](ch03.html#ch03).
  prefs: []
  type: TYPE_NORMAL
- en: But there’s another problem we need to tackle first. AES requires an enormous
    binary number as a key, but users can’t be expected to memorize a string of 128
    bits. Instead, we memorize passwords. As it turns out, the secure storage and
    use of passwords presents its own quandaries. Those are the subject of the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
