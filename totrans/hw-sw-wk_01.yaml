- en: '**1**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**1**'
- en: '**Encryption**'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**加密**'
- en: '![image](graphics/common-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/common-01.jpg)'
- en: We rely on software to protect our data every day, but most of us know little
    about how this protection works. Why does a “lock” icon in the corner of your
    browser mean it’s safe to enter your credit card number? How does creating a password
    for your phone actually protect the data inside? What really prevents other people
    from logging into your online accounts?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们每天都依赖软件来保护我们的数据，但大多数人对这些保护是如何工作的知之甚少。为什么浏览器角落里的“锁”图标意味着可以安全地输入你的信用卡号码？为你的手机创建密码到底是如何保护里面的数据的？到底是什么防止别人登录你的在线账户？
- en: '*Computer security* is the science of protecting data. In a way, computer security
    represents technology solving a problem that technology created. Not that long
    ago, most data wasn’t stored digitally. We had filing cabinets in our offices
    and shoeboxes of photographs under our beds. Of course, back then you couldn’t
    easily share your photographs with friends around the world or check your bank
    balance from a mobile phone, but neither could anyone steal your private data
    without physically taking it. Today, not only can you be robbed at a distance,
    but you might not even know you’ve been robbed—that is, until your bank calls
    to ask why you are buying thousands of dollars in gift cards.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算机安全*是保护数据的科学。从某种程度上来说，计算机安全代表了技术解决技术所带来的问题。不久之前，大多数数据并没有以数字形式存储。我们有办公室里的文件柜和床下的照片鞋盒。当然，那时你不能轻松地与世界各地的朋友分享照片，也不能通过手机查看银行余额，但当时没有人能够在不亲自拿走数据的情况下窃取你的私人信息。今天，不仅可以在远距离被抢劫，而且你可能甚至不知道自己已经被抢劫——直到银行打电话问你为什么要买价值数千美元的礼品卡。'
- en: Over these first three chapters, we’ll discuss the most important concepts behind
    computer security. In this chapter, we talk about encryption. By itself, encryption
    provides us with the capability to lock our data so only *we* can unlock it. Additional
    techniques, discussed in the next two chapters, are needed to provide the full
    security suite that we depend on, but encryption is the core of computer security.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在这前三章中，我们将讨论计算机安全背后的最重要概念。在本章中，我们谈论加密。加密本身为我们提供了将数据锁定的能力，使得只有*我们*才能解锁它。为了提供我们依赖的完整安全套件，接下来两章中将讨论其他技术，但加密是计算机安全的核心。
- en: '**The Goal of Encryption**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**加密的目标**'
- en: 'Think of a file on your computer: it might contain text, a photograph, a spreadsheet,
    audio, or video. You want to access the file but keep it secret from everyone
    else. This is the fundamental problem of computer security. To keep the file secret,
    you can use *encryption* to transform it into a new format that is unreadable
    until the file has been returned to its original form using *decryption*. The
    original file is the *plaintext* (even if the file isn’t text), and the encrypted
    file is the *ciphertext*.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你电脑上的一个文件：它可能包含文本、照片、电子表格、音频或视频。你想访问这个文件，但又想让其他人无法看到。 这是计算机安全的基本问题。为了保持文件的秘密性，你可以使用*加密*将其转化为一种新的格式，直到通过*解密*将文件恢复到原始形式之前，它是无法读取的。原始文件是*明文*（即使文件不是文本），而加密后的文件是*密文*。
- en: An *attacker* is someone who attempts to decrypt the ciphertext without authorization.
    The goal of encryption is to create a ciphertext that is easy for authorized users
    to decrypt, while practically impossible for attackers to decrypt. “Practically”
    is the source of many headaches for security researchers. Just as no lock is absolutely
    unbreakable, no encryption can be absolutely impossible to decrypt. With enough
    time and enough computing power, any encryption scheme can be broken in theory.
    The goal of computer security is to make an attacker’s job so difficult that successful
    attacks are impossible in practice, requiring computing resources beyond an attacker’s
    means.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*攻击者*是试图在未授权的情况下解密密文的人。加密的目标是创建一个对授权用户来说容易解密的密文，同时对攻击者来说几乎不可能解密。“几乎”是安全研究人员头疼的源泉。正如没有任何锁是绝对不可破解的，没有任何加密能够绝对不被解密。只要有足够的时间和计算能力，任何加密方案理论上都可以被破解。计算机安全的目标是让攻击者的工作变得如此困难，以至于成功的攻击在实践中是不可能的，需要超出攻击者能力的计算资源。'
- en: Rather than jump headfirst into the intricacies of software-based encryption,
    I’ll start this chapter with some simple examples from the pre-software days of
    codes and spies. Although the strength of encryption has vastly improved over
    the years, these same classic techniques form the basis of all encryption. Later,
    you’ll see how these ideas are combined in a modern digital encryption scheme.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会直接跳入基于软件的加密复杂性中，而是从一些简单的例子开始，这些例子来自于加密和间谍活动的前软件时代。虽然多年来加密的强度有了巨大的提升，但这些经典技术仍然是所有加密的基础。稍后你将看到这些思想是如何在现代数字加密方案中结合使用的。
- en: '**Transposition: Same Data, Different Order**'
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**转置：相同的数据，不同的顺序**'
- en: One of the simplest ways to encrypt data is called *transposition*, which simply
    means “changing position.” Transposition is the kind of encryption my friends
    and I used when passing notes in grade school. Because these notes were passed
    through untrustworthy hands, it was imperative the notes were unintelligible to
    anyone but us.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 加密数据的最简单方法之一被称为*转置*，它的意思就是“改变位置”。转置是我和朋友们在小学时用来传递纸条时采用的加密方法。因为这些纸条会通过不可信的手传递，所以确保纸条对我们之外的人是无法理解的至关重要。
- en: To keep messages secret, we rearranged the order of the letters using a simple,
    easy-to-reverse scheme. Suppose I needed to share the vital intelligence that
    CATHY LIKES KEITH (the names have been changed to protect the innocent). To encrypt
    the message, I copied every third letter of the plaintext (ignoring any spaces).
    During the first pass through the message, I copied five letters, as shown in
    [Figure 1-1](ch01.html#ch1fig1).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持信息的机密性，我们使用一个简单、易于反转的方案重新排列字母的顺序。假设我需要传达一个重要信息：“CATHY LIKES KEITH”（名字已更改以保护无辜）。为了加密该信息，我复制了明文中的每第三个字母（忽略空格）。在第一次操作中，我复制了五个字母，如[图
    1-1](ch01.html#ch1fig1)所示。
- en: '![image](graphics/f01-01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f01-01.jpg)'
- en: '*Figure 1-1: The first pass in the transposition of the sample message*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-1：样本信息转置的第一次操作*'
- en: Having reached the end of the message, I started back at the beginning and continued
    selecting every third remaining letter. The second pass got me to the state shown
    in [Figure 1-2](ch01.html#ch1fig2).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 到达信息末尾后，我从头开始，继续选择每第三个剩余字母。第二次操作后，我得到了如[图 1-2](ch01.html#ch1fig2)所示的结果。
- en: '![image](graphics/f01-02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f01-02.jpg)'
- en: '*Figure 1-2: The second transposition pass*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-2：第二次转置操作*'
- en: On the last pass I copied the remaining letters, as shown in [Figure 1-3](ch01.html#ch1fig3).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一次操作中，我复制了剩余的字母，如[图 1-3](ch01.html#ch1fig3)所示。
- en: '![image](graphics/f01-03.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f01-03.jpg)'
- en: '*Figure 1-3: The final transposition pass*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-3：最终的转置操作*'
- en: The resulting ciphertext is CHISIAYKKTTLEEH. My friends could read the message
    by reversing the transposition process. The first step is shown in [Figure 1-4](ch01.html#ch1fig4).
    Returning all the letters to their original position reveals the plaintext.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 得到的密文是CHISIAYKKTTLEEH。我的朋友们可以通过反向转置过程读取这个信息。第一步如[图 1-4](ch01.html#ch1fig4)所示。将所有字母恢复到原位后，就能还原出明文。
- en: '![image](graphics/f01-04.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f01-04.jpg)'
- en: '*Figure 1-4: The first pass in reversing the transposition for decryption*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-4：解密时转置操作的第一次回退*'
- en: This basic transposition method was fun to use, but it’s terribly weak encryption.
    The biggest concern is a leak—one of my friends blabbing about the encryption
    method to someone outside the circle. Once that happens, sending encrypted messages
    won’t be secure anymore; it will just be more work. Leaks are sadly inevitable—and
    not just with schoolchildren. Every encryption method is vulnerable to leaks,
    and the more people use a particular method, the more likely it will leak.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基本的转置方法使用起来很有趣，但它的加密强度非常弱。最大的担忧是泄密——我的一个朋友把加密方法透露给了圈外的人。一旦发生这种情况，发送加密信息就不再安全，反而会变得更麻烦。泄密是不可避免的——不仅仅是在学童之间。每种加密方法都会面临泄密的风险，而且使用某种方法的人越多，泄密的可能性就越大。
- en: 'For this reason, all good encryption systems follow a rule formulated by early
    Dutch cryptographer Auguste Kerckhoffs, known as *Kerckhoffs’s principle*: the
    security of data should not depend on the encryption method remaining a secret.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，所有好的加密系统都遵循荷兰早期密码学家奥古斯特·凯尔科夫（Auguste Kerckhoffs）提出的一个规则，称为*凯尔科夫原则*：数据的安全性不应依赖于加密方法本身的保密性。
- en: '***Cipher Keys***'
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***密码密钥***'
- en: This raises an obvious question. If the encryption method is not a secret, how
    do we securely encrypt data? The answer lies in following a general, publically
    disclosed encryption method, but varying the encryption of individual messages
    using a *cipher key* (or just *key*). To understand what a key is, let’s examine
    a more general transposition method.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个显而易见的问题。如果加密方法并不是秘密的，那我们如何才能安全地加密数据呢？答案在于遵循一种通用的、公开披露的加密方法，但使用*密码钥匙*（或简称*钥匙*）来变化每条消息的加密方式。为了理解什么是钥匙，我们可以先看一个更通用的置换方法。
- en: In this method, senders and receivers share a secret number prior to sending
    any messages. Let’s say my friends and I agree on 374\. We’ll use this number
    to alter the transposition pattern in our ciphertexts. This pattern is shown in
    [Figure 1-5](ch01.html#ch1fig5) for the message CATHY LIKES KEITH. The digits
    of our secret number dictate which letter should be copied from the plaintext
    to the ciphertext. Because the first digit is 3, the third letter of the plaintext,
    *T*, becomes the first letter of the ciphertext. The next digit is 7, so the next
    letter is the seventh letter after the *T*, which is *S*. Next, we select the
    fourth letter from the *S*. The first three letters of the ciphertext are *TST*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，发送者和接收者在发送任何消息之前会共享一个秘密数字。假设我和我的朋友们约定使用374。我们将使用这个数字来改变我们密文中的置换模式。此模式在[图1-5](ch01.html#ch1fig5)中展示了消息“CATHY
    LIKES KEITH”的加密过程。我们秘密数字的每一位都指示应该从明文中复制哪个字母到密文中。因为第一个数字是3，所以明文中的第三个字母*T*变成密文的第一个字母。下一个数字是7，因此下一个字母是从*T*往后数七个字母，也就是*S*。接下来我们选择从*S*开始的第四个字母。密文的前三个字母是*TST*。
- en: '[Figure 1-6](ch01.html#ch1fig6) shows how the next two letters are copied to
    the ciphertext. Starting from where we left off (indicated by the circled 1 in
    the figure), we count three positions, returning to the beginning of the plaintext
    when we reach the end, to select *A* as the fourth letter of the ciphertext. The
    next letter chosen is seven positions after the *A*, skipping letters that have
    already been copied: the *K*. The process continues until all of the letters of
    the plaintext have been transposed.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1-6](ch01.html#ch1fig6)展示了接下来的两个字母如何被复制到密文中。从我们上次停止的地方开始（图中由圆圈标出的1），我们数三个位置，当到达末尾时返回到明文的开始处，选择*A*作为密文的第四个字母。接下来选择的字母是从*A*开始往后数七个位置，跳过已经复制的字母：*K*。这个过程继续进行，直到所有明文的字母都被置换完成。'
- en: '![image](graphics/f01-05.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f01-05.jpg)'
- en: '*Figure 1-5: The first pass in transposing using the key 374*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-5：使用密钥374进行置换的第一步*'
- en: '![image](graphics/f01-06.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f01-06.jpg)'
- en: '*Figure 1-6: The second pass in transposing using the key 374*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-6：使用密钥374进行置换的第二步*'
- en: The secret number 374, then, is our cipher key. Someone who intercepts this
    message won’t be able to decrypt it without the key, even if they understand we’re
    using a transposition method. The code can be regularly changed to prevent blabbermouths
    and turncoats from compromising the encryption.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，秘密数字374就是我们的密码钥匙。即便有人截获了这条消息，如果没有密钥，他们也无法解密，即使他们知道我们使用的是置换加密方法。密码可以定期更换，以防止泄密者或叛徒泄露加密信息。
- en: '***Attacking the Encryption***'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***攻击加密***'
- en: Even without the key, attackers can still try to recover the plaintext through
    other means. Encrypted data can be attacked through *brute force*, trying all
    the possible ways of applying the encryption method to the ciphertext. For a message
    encrypted using transposition, a brute-force attack would examine all permutations
    of the ciphertext. Because brute force is almost always an option, the number
    of trials an attacker will need to find the plaintext is a good baseline for encryption
    strength. In our example, the message CATHY LIKES KEITH has around 40 billion
    permutations.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有密钥，攻击者仍然可以尝试通过其他手段恢复明文。加密数据可以通过*暴力破解*进行攻击，尝试所有可能的加密方法来处理密文。对于使用置换加密的消息，暴力破解攻击会检查密文的所有排列组合。因为暴力破解几乎总是可行的，所以攻击者需要进行的试验次数是衡量加密强度的一个良好基准。在我们的示例中，消息“CATHY
    LIKES KEITH”大约有400亿种排列方式。
- en: That’s a huge number, so instead of brute force, a smart attacker would apply
    some common sense to recover the plaintext faster. If the attacker can assume
    the plaintext is in English, then most of the permutations can be ruled out before
    they are tested. For example, the attacker can assume the plaintext won’t start
    with the letters *HT* because no English word starts with those letters. That’s
    a billion permutations the attacker won’t have to check.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个庞大的数字，因此聪明的攻击者会采用一些常识来加速恢复明文的过程，而不是依赖暴力破解。如果攻击者能假设明文是英文，那么在测试之前，大部分排列组合都可以被排除。例如，攻击者可以假设明文不会以*HT*开头，因为没有英文单词以这两个字母开头。这样，攻击者就不需要检查十亿种排列组合了。
- en: An attacker with some idea of the words in the message can be even smarter about
    figuring out the plaintext. In our example, the attacker might guess the message
    includes the name of a classmate. They can see what names can be formed from the
    ciphertext letters and then determine what words can be formed from the leftover
    letters.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 了解消息中某些单词的攻击者可以更聪明地推断出明文。在我们的例子中，攻击者可能猜测消息中包含某个同学的名字。他们可以查看密文字母中可以组成哪些名字，然后通过剩余字母推测出可能的单词。
- en: Guesses about the plaintext content are known as *cribs*. The strongest kind
    of crib is a *known-plaintext attack*. To carry out this type of attack, the attacker
    must have access to a plaintext A, its matching ciphertext A, and a ciphertext
    B that uses the same cipher key as ciphertext A. Although this scenario sounds
    unlikely, it does happen. People often leave documents unguarded when they are
    no longer considered secret without realizing they may aid attacks on other documents.
    Known-plaintext attacks are power ful; figuring out the transposition pattern
    is easy when you have both the plaintext and ciphertext in front of you.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关于明文内容的猜测被称为*字典攻击*。最强的字典攻击形式是*已知明文攻击*。为了实施这种攻击，攻击者必须能够访问一个明文A，其对应的密文A，以及一个使用与密文A相同的密钥加密的密文B。虽然这种情况听起来不太可能，但确实会发生。人们经常在文件不再被视为机密时，将其置于无保护状态，而没有意识到这可能会帮助攻击其他文件。已知明文攻击是非常强大的；当你面前同时有明文和密文时，破解置换模式非常容易。
- en: The best defenses against known-plaintext attacks are good security practices,
    such as regularly changing passwords. Even with the best security practices, though,
    attackers will almost always have some idea of a plaintext’s contents (that’s
    why are they so interested in reading it). In many cases, they will know most
    of the plaintext and may have access to known plaintext-ciphertext pairs. A good
    encryption system should render cribs and known plaintexts useless to attackers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对抗已知明文攻击的最佳防御措施是良好的安全实践，例如定期更改密码。然而，即使采取了最好的安全实践，攻击者几乎总是能大致了解明文的内容（这也是他们为何如此感兴趣于读取它的原因）。在许多情况下，他们会知道大部分明文内容，并且可能拥有已知明文-密文对。一个好的加密系统应该使得明文和已知的密文对对攻击者无效。
- en: '**Substitution: Replacing Data**'
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**替代：数据替换**'
- en: The other fundamental encryption technique is more resistant to cribs. Instead
    of moving the data around, *substitution* methods systematically replace individual
    pieces of data. With text messages, the simplest form of substitution replaces
    every occurrence of one letter with another letter. For example, every *A* becomes
    a *D*, every *B* an *H*, and so on. A key for this type of encryption looks like
    [Table 1-1](ch01.html#ch1tab1).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种基本的加密技术对“字典攻击”更具抵抗力。与其移动数据，不如*替代*方法有系统地替换数据的各个部分。对于文本消息，最简单的替代形式是将每个字母替换为另一个字母。例如，将每个*A*替换为*D*，每个*B*替换为*H*，依此类推。该类型加密的密钥如[表
    1-1](ch01.html#ch1tab1)所示。
- en: '**Table 1-1:** A Substitution Cipher Key'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-1:** 一种替代密码密钥'
- en: '| Original | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P
    | Q | R | S | T | U | V | W | X | Y | Z |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 原始 | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q |
    R | S | T | U | V | W | X | Y | Z |'
- en: '| Replacement | M | N | B | V | C | X | Z | L | K | F | H | G | J | D | S |
    A | P | O | I | U | Y | T | R | E | W | Q |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 替换 | M | N | B | V | C | X | Z | L | K | F | H | G | J | D | S | A | P |
    O | I | U | Y | T | R | E | W | Q |'
- en: 'Although *simple substitution*, as this method is called, is an improvement
    over transposition, it too has problems: there are only so many possible substitutions,
    so an attacker can sometimes decrypt ciphertext through brute force.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种方法被称为*简单替代*，它比置换加密有所改进，但它也有问题：可能的替代方式是有限的，因此攻击者有时可以通过暴力破解来解密密文。
- en: Simple substitution is also vulnerable to *frequency analysis*, in which an
    attacker applies knowledge of how often letters or letter combinations occur in
    a given language. Stated broadly, knowing how often data items are likely to appear
    in a plaintext gives the attacker an advantage. For example, the letter *E* is
    the most common letter in English writing, and *TH* is the most common letter
    pair. Therefore, the most frequently occurring letter in a long ciphertext is
    likely to represent plaintext *E*, and the most frequently occurring letter pair
    is likely to represent plaintext *TH*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的替代加密同样容易受到*频率分析*的攻击，攻击者通过应用对特定语言中字母或字母组合出现频率的了解来进行攻击。广义而言，了解数据项在明文中出现的频率会给攻击者带来优势。例如，字母*E*是英语写作中最常见的字母，而*TH*是最常见的字母组合。因此，在较长的密文中，最常出现的字母很可能代表明文中的*E*，而最常出现的字母组合则很可能代表明文中的*TH*。
- en: The power of frequency analysis means that substitution encryption becomes more
    vulnerable as the text grows longer. Attacks are also easier when a collection
    of ciphertexts is known to have been encrypted with the same key; avoiding such
    *key reuse* is an important security practice.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 频率分析的威力意味着，随着文本长度的增加，替代加密变得更加脆弱。当已知一组密文是使用相同密钥加密时，攻击也会变得更加容易；因此，避免*密钥重用*是一个重要的安全实践。
- en: '***Varying the Substitution Pattern***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***变化的替代模式***'
- en: To strengthen encryption against frequency analysis, we can vary the substitution
    pattern during encryption, so the first *E* in the plaintext might be replaced
    with *A*, but the second *E* in the plaintext is replaced with a *T*. This technique
    is known as *polyalphabetic substitution*. One method of polyalphabetic substitution
    uses a grid of alphabets known as a *tabula recta*, shown in [Figure 1-7](ch01.html#ch1fig7).
    In this table, each row and column is labeled with the letter of the alphabet
    that starts the row or column. Every location in the grid is located with two
    letters, such as row D, column H, which contains the letter *K*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加强对频率分析的加密防护，我们可以在加密过程中改变替代模式，因此明文中的第一个*E*可能会被替换成*A*，而第二个*E*则替换成*T*。这种技术被称为*多字母替代*。多字母替代的一种方法使用了一个字母表网格，称为*塔布拉·雷克塔*，如[图1-7](ch01.html#ch1fig7)所示。在这个表格中，每一行和每一列都用开始该行或列的字母标记。网格中的每个位置由两个字母定位，例如行D，列H，该位置包含字母*K*。
- en: '![image](graphics/f01-07.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f01-07.jpg)'
- en: '*Figure 1-7: A tabula recta—the shaded first column and row are labels.*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-7：塔布拉·雷克塔——阴影部分的第一列和第一行是标签。*'
- en: 'When using a tabula recta, the key is textual—letters are used to vary the
    encryption instead of numbers, as we used in our transposition example. The letters
    of the plaintext select rows in the tabula recta, and the letters of the key select
    columns. For example, suppose our plaintext message is the word *SECRET*, and
    our encryption key is the word *TOUGH*. Because the first letter of the plaintext
    is *S* and the first letter of the key is *T*, the first letter of the ciphertext
    is found at row S, column T in the tabula recta: the letter *L*. We then use the
    O column of the table to encrypt the second plaintext letter *E* (resulting in
    *S*), and so on, as shown in [Figure 1-8](ch01.html#ch1fig8). Because the plaintext
    is longer than the key, we must reuse the first letter of the key.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用塔布拉·雷克塔时，密钥是文本形式的——使用字母来变化加密，而不是像我们在置换示例中使用的数字。明文的字母选择塔布拉·雷克塔中的行，密钥的字母选择列。例如，假设我们的明文信息是单词*SECRET*，而我们的加密密钥是单词*TOUGH*。因为明文的第一个字母是*S*，而密钥的第一个字母是*T*，所以密文的第一个字母位于塔布拉·雷克塔的行S列T的位置：字母*L*。接着我们使用表格中的O列来加密第二个明文字母*E*（得到*S*），依此类推，如[图1-8](ch01.html#ch1fig8)所示。由于明文比密钥长，我们必须重复使用密钥的第一个字母。
- en: '![image](graphics/f01-08.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f01-08.jpg)'
- en: '*Figure 1-8: Encryption using the tabula recta and cipher key* TOUGH'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-8：使用塔布拉·雷克塔和密码密钥* TOUGH'
- en: Decryption reverses the process, as shown in [Figure 1-9](ch01.html#ch1fig9).
    The letters in the key indicate the columns, which are scanned to find the corresponding
    letter in the ciphertext. The row where the ciphertext letter is found indicates
    the plaintext letter. In our example, the first letter of our key is *T*, and
    the first letter of the ciphertext is *L*. We scan the T column of the tabula
    recta to find *L*; because *L* appears in row S, the plaintext letter is *S*.
    The process repeats for every letter of the ciphertext.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 解密过程是逆向操作，如[图1-9](ch01.html#ch1fig9)所示。密钥中的字母表示列，扫描列以找到对应的密文字母。找到密文字母所在的行即为明文字母。在我们的示例中，密钥的第一个字母是*T*，密文的第一个字母是*L*。我们扫描塔布拉矩阵的T列找到*L*；因为*L*出现在S行，所以明文字母是*S*。这个过程对每个密文字母都重复进行。
- en: '![image](graphics/f01-09.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f01-09.jpg)'
- en: '*Figure 1-9: Decryption using the tabula recta and cipher key* TOUGH'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-9：使用塔布拉矩阵和密码键的解密* TOUGH'
- en: Polyalphabetic substitution is more effective than simple substitution because
    it varies the substitution pattern throughout the message. In our example, the
    two occurrences of *E* in the plaintext become different ciphertext letters, and
    the two occurrences of *L* in the ciphertext represent two different plaintext
    letters.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 多表替代法比简单替代法更有效，因为它在整个消息中变化替代模式。在我们的示例中，明文中两个*E*的出现会变成不同的密文字母，而密文中两个*L*的出现代表了两个不同的明文字母。
- en: '***Key Expansion***'
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***密钥扩展***'
- en: Although polyalphabetic substitution is a great improvement over simple substitution,
    it’s effective only when the key isn’t repeated too often; otherwise it has the
    same problems as simple substitution. With a key length of five, for example,
    each plaintext letter would be represented by only five different ciphertext letters,
    leaving long ciphertexts vulnerable to frequency analysis and cribs. An attacker
    would have to work harder, but given enough ciphertext to work with, an attacker
    could still break the encryption.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管多表替代法相对于简单替代法有了很大改进，但只有当密钥不被过于频繁地重复时，它才有效；否则，它就会和简单替代法一样存在问题。例如，当密钥长度为五时，每个明文字母只能由五个不同的密文字母表示，这使得长密文容易受到频率分析和潜文本的攻击。攻击者需要更加努力地工作，但只要有足够的密文，攻击者仍然能够破解加密。
- en: For maximum effectiveness, we need encryption keys that are as long as the plaintext,
    a technique known as a *one-time pad*. But that’s not a practical solution for
    most situations. Instead, a method called *key expansion* allows short keys to
    do the work of longer ones. One implementation of this idea frequently appears
    in spy novels. Instead of sharing a super-long key, two spies who need to exchange
    messages agree on a *code book*, which is used as a repository of long keys. To
    avoid arousing suspicion, the code book is an ordinary piece of literature, like
    a specific edition of Shakespeare’s plays.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最大程度地提高效果，我们需要与明文等长的加密密钥，这种技术被称为*一次性密码本*。但对于大多数情况来说，这并不是一个实用的解决方案。相反，一种叫做*密钥扩展*的方法可以让短密钥完成长密钥的工作。这个思路的一种实现常出现在间谍小说中。两位需要交换信息的间谍并不共享超长的密钥，而是约定使用一个*密码书*，该密码书作为长密钥的存储库。为了避免引起怀疑，密码书是一本普通的文学作品，比如莎士比亚戏剧的某一版。
- en: 'Let’s suppose a 50-letter message will be sent using this scheme. In addition
    to the ciphertext, the message sender also appends the unexpanded key. Using the
    works of Shakespeare as the code book, the unexpanded key might be 2.2.4.9\. The
    first 2 indicates the second of Shakespeare’s plays when listed alphabetically
    (*As You Like It*). The second 2 means Act II of the play. The 4 means Scene 4
    of that act. The 9 means the ninth sentence of that scene in the specified edition:
    “When I was at home, I was in a better place, but travelers must be content.”
    The number of letters in this sentence exceeds the number in the plaintext and
    could be used for encryption and decryption using a tabula recta as before. In
    this way, a relatively short key can be expanded to fit a particular message.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设将发送一个50个字母的消息，使用此方案。除了密文，消息发送者还附加上未扩展的密钥。以莎士比亚的作品作为密码书，未扩展的密钥可能是2.2.4.9。第一个2表示莎士比亚的第二部戏剧（按字母顺序排列，*如你所愿*）。第二个2表示第二幕。4表示该幕的第四场。9表示该场的第九句话：“当我在家时，我在一个更好的地方，但旅行者必须知足。”
    这句话的字母数超过了明文的字母数，可以像之前一样使用塔布拉矩阵进行加密和解密。通过这种方式，一个相对较短的密钥可以扩展到适应特定的消息。
- en: Note that this scheme doesn’t qualify as a one-time pad because the code book
    is finite, and therefore the sentence-keys would have to be reused eventually.
    But it does mean our spies only have to remember short cipher keys while encrypting
    their messages more securely with longer keys. As you’ll see, the key expansion
    concept is important in computer encryption because the cipher keys required are
    huge but need to be stored in smaller forms.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种方案不符合一次性密钥的要求，因为密码本是有限的，因此句子密钥最终必须被重复使用。但这意味着我们的间谍在加密消息时，只需记住较短的密码密钥，同时使用更长的密钥来更安全地加密消息。正如你将看到的，密钥扩展概念在计算机加密中非常重要，因为所需的密码密钥非常庞大，但必须以较小的形式存储。
- en: '**The Advanced Encryption Standard**'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**高级加密标准**'
- en: Now that we’ve seen how transposition, substitution, and key expansion work
    individually, let’s see how secure digital encryption results from a careful combination
    of all three techniques.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到转置、替换和密钥扩展是如何单独工作的，让我们看看如何通过巧妙地结合这三种技术来实现安全的数字加密。
- en: The *Advanced Encryption Standard (AES)* is an open standard, which means the
    specifications may be implemented by anyone without paying a license fee. Whether
    you realize it or not, much of your data is protected by AES. If you have a secure
    wireless network at your home or office, if you have ever password-protected a
    file in a *.zip* archive, or if you use a credit card at a store or make a withdrawal
    from an ATM, you are probably relying, at least in part, on AES.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*高级加密标准（AES）* 是一种开放标准，这意味着任何人都可以在不支付许可费的情况下实现其规范。无论你是否意识到，你的大部分数据都由AES保护。如果你在家里或办公室有一个安全的无线网络，如果你曾经在*.zip*压缩文件中设置过密码，或者如果你在商店使用信用卡或从ATM机取款，你可能至少在某种程度上依赖于AES。'
- en: '***Binary Basics***'
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***二进制基础***'
- en: Up to now, I’ve used text encryption samples to keep the examples simple. The
    data encrypted by computers, though, is represented in the form of binary numbers.
    If you haven’t worked with these numbers before, here’s an introduction.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我一直使用文本加密示例来保持示例简单。然而，计算机加密的数据是以二进制数的形式表示的。如果你以前没有处理过这些数字，这里有一个介绍。
- en: '**Decimal Versus Binary**'
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**十进制与二进制**'
- en: The number system we all grew up with is called the *decimal* system, *deci*
    meaning “ten,” because the system uses 10 digits, 0 through 9\. Each digit in
    a number represents the quantity of a unit 10 times greater than the digit to
    its right. The units and quantities for the decimal number 23,065 are shown in
    [Figure 1-10](ch01.html#ch1fig10). The 2 in the fifth position from the left means
    we have 2 “ten thousands,” for example, and the 6 means 6 “tens.”
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从小就使用的数字系统叫做*十进制*系统，*deci*意为“十”，因为该系统使用10个数字，从0到9。数字中的每一位表示比右侧数字大10倍的单位数量。十进制数字23,065的单位和数量如[图
    1-10](ch01.html#ch1fig10)所示。左起第五位的2表示我们有2个“万”，例如，6表示6个“十”。
- en: '![image](graphics/f01-10.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f01-10.jpg)'
- en: '*Figure 1-10: Each digit in the decimal number 23,065 represents a different
    unit quantity.*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-10：十进制数字23,065中的每一位代表不同的单位数量。*'
- en: 'In the *binary* number system, there are only two possible digits, 0 or 1,
    which are called *bits*, for *bi*nary digi*ts*. Each bit in a binary number represents
    a unit twice as large as the bit to the right. The units and quantities for the
    binary number 110101 are shown in [Figure 1-11](ch01.html#ch1fig11). As shown,
    we have one of each of the following units: 32, 16, 4, and 1\. Therefore, the
    binary number 110101 represents the sum of these four unit values, which is the
    decimal number 53.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在*二进制*数字系统中，只有两个可能的数字，0或1，它们被称为*位*，即*bi*nary digi*ts*。二进制数字中的每一位代表一个单位，其大小是右边位数的两倍。二进制数字110101的单位和数量如[图
    1-11](ch01.html#ch1fig11)所示。如图所示，我们有以下每个单位：32、16、4和1。因此，二进制数字110101表示这四个单位值的总和，即十进制数字53。
- en: '![image](graphics/f01-11.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f01-11.jpg)'
- en: '*Figure 1-11: Each bit in the binary number 110101 represents a different unit
    quantity.*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-11：二进制数字110101中的每一位代表不同的单位数量。*'
- en: Binary numbers are often written with a fixed number of bits. The most common
    length for a binary number is eight bits, known as a *byte*. Although the decimal
    number 53 can be written as 110101 in binary, writing 53 as a byte requires eight
    bits, so leading 0 bits fill out the other positions to make 00110101\. The smallest
    byte value, 00000000, represents decimal 0; the largest possible byte, 11111111,
    represents decimal 255.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数字通常以固定数量的位表示。二进制数最常见的长度是八位，称为*字节*。虽然十进制数字53可以写作110101的二进制形式，但将53写成字节需要八位，因此前导0位填充其他位置，形成00110101。最小的字节值00000000表示十进制0；最大的字节值11111111表示十进制255。
- en: '**Bitwise Operations**'
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**按位操作**'
- en: Along with the usual mathematical operations such as addition and multiplication,
    software also uses some operations unique to binary numbers. These are known as
    *bitwise operations* because they are applied individually to each bit rather
    than to the binary number as whole.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常见的数学运算，如加法和乘法，软件还使用一些独特于二进制数字的操作。这些操作被称为*按位操作*，因为它们是单独应用于每一位，而不是整个二进制数。
- en: The bitwise operation known as *exclusive-or*, or *XOR*, is common in encryption.
    When two binary numbers are XORed together, the 1s in the second number flip the
    corresponding bits in the first number, as shown in [Figure 1-12](ch01.html#ch1fig12).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 按位操作中称为*异或*（*XOR*）的操作在加密中很常见。当两个二进制数字进行XOR运算时，第二个数字中的1位会反转第一个数字中相应的位，如[图1-12](ch01.html#ch1fig12)所示。
- en: '![image](graphics/f01-12.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f01-12.jpg)'
- en: '*Figure 1-12: The exclusive-or (XOR) operation. The 1 bits in the second byte
    indicate which bits are “flipped” in the first byte, as shown in the shaded columns.*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-12：异或（XOR）操作。第二个字节中的1位表示在第一个字节中被“反转”的位，如阴影列所示。*'
- en: Remember, encryption must be reversible. XOR alters the bit patterns in a way
    that’s impossible to predict without knowing the binary numbers involved, but
    it’s easily reversed. XORing the result with the second number flips the same
    bits back to their original state, as shown in [Figure 1-13](ch01.html#ch1fig13).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，密码学必须是可逆的。XOR操作通过改变位模式，使得在不知道参与的二进制数字的情况下，难以预测其结果，但它是可以轻松逆转的。将结果与第二个数字进行XOR运算，可以将相同的位反转回原始状态，如[图1-13](ch01.html#ch1fig13)所示。
- en: '![image](graphics/f01-13.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f01-13.jpg)'
- en: '*Figure 1-13: If we XOR a byte with the same byte twice, we’re back to where
    we started.*'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-13：如果我们将一个字节与相同的字节进行两次XOR运算，结果将回到我们开始的地方。*'
- en: '**Converting Data to Binary Form**'
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**将数据转换为二进制形式**'
- en: Computers use binary numbers to represent all kinds of data. A plaintext file
    could be a text message, a spreadsheet, an image, an audio file, or anything else—but
    in the end, every file is a sequence of bytes. Most computer data is already numeric
    and can therefore be directly converted into binary numbers. In some cases, though,
    a special encoding system is needed to convert non-numeric data into binary form.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机使用二进制数字表示各种数据。一个纯文本文件可以是文本消息、电子表格、图像、音频文件或其他任何东西——但最终，每个文件都是字节的序列。大多数计算机数据已经是数字形式，因此可以直接转换为二进制数。但在某些情况下，需要一个特殊的编码系统来将非数字数据转换为二进制形式。
- en: 'For example, to see how a text message becomes a sequence of bytes, consider
    this message:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要查看一条文本消息是如何转换成一系列字节的，可以考虑以下消息：
- en: '[PRE0]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This message has 16 characters, counting the letters, spaces, and exclamation
    point. We can turn each character into a byte using a system such as the *American
    Standard Code for Information Interchange*, which is always referred to by its
    acronym, *ASCII*, pronounced “as-key”. In ASCII, capital *A* is represented by
    the number 65, *B* by 66, and so on, through 90 for *Z*. [Table 1-2](ch01.html#ch1tab2)
    shows some selected entries from the ASCII table.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 该消息包含16个字符，计算时包括字母、空格和感叹号。我们可以使用像*美国信息交换标准代码*（*ASCII*，发音为“as-key”）这样的系统，将每个字符转换为一个字节。在ASCII中，大写字母*A*表示数字65，*B*表示66，依此类推，到*Z*的90。[表1-2](ch01.html#ch1tab2)展示了来自ASCII表的一些选定条目。
- en: '**Table 1-2:** Selected Entries from the ASCII Table'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**表1-2：ASCII表中的部分条目**'
- en: '| **Character** | **Decimal number** | **Binary byte** |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **字符** | **十进制数** | **二进制字节** |'
- en: '| --- | --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| (space) | 32 | 00100000 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| (space) | 32 | 00100000 |'
- en: '| ! | 33 | 00100001 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| ! | 33 | 00100001 |'
- en: '| , | 44 | 00101100 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| , | 44 | 00101100 |'
- en: '| . | 46 | 00101110 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| . | 46 | 00101110 |'
- en: '| A | 65 | 01000001 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| A | 65 | 01000001 |'
- en: '| B | 66 | 01000010 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| B | 66 | 01000010 |'
- en: '| C | 67 | 01000011 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| C | 67 | 01000011 |'
- en: '| D | 68 | 01000100 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| D | 68 | 01000100 |'
- en: '| E | 69 | 01000101 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| E | 69 | 01000101 |'
- en: '| a | 97 | 01100001 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| a | 97 | 01100001 |'
- en: '| b | 98 | 01100010 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| b | 98 | 01100010 |'
- en: '| c | 99 | 01100011 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| c | 99 | 01100011 |'
- en: '| d | 100 | 01100100 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| d | 100 | 01100100 |'
- en: '| e | 101 | 01100101 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| e | 101 | 01100101 |'
- en: '***AES Encryption: The Big Picture***'
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***AES 加密：大致过程***'
- en: Before we examine the details of AES encryption, here’s an overview of the process.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们详细查看 AES 加密之前，这里是该过程的概述。
- en: Cipher keys in AES are binary numbers. The size of the key can vary, but we’ll
    discuss the simplest version of AES, which uses a 128-bit key. Using mathematical
    key expansion, AES transforms the original 128-bit key into eleven 128-bit keys.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: AES 中的密码密钥是二进制数字。密钥的大小可以变化，但我们将讨论最简单版本的 AES，使用的是 128 位密钥。通过数学密钥扩展，AES 将原始的 128
    位密钥转换为 11 个 128 位的密钥。
- en: AES divides plaintext data into blocks of 16 bytes in a 4×4 grid; the grid for
    the sample message *Send more money!* is shown in [Figure 1-14](ch01.html#ch1fig14).
    Heavy lines separate the 16 bytes, and light lines separate the bits within the
    bytes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: AES 将明文数据分为 16 字节的块，并以 4×4 网格的形式呈现；示例消息 *发送更多钱！* 的网格如 [图 1-14](ch01.html#ch1fig14)
    所示。重线分隔 16 字节，轻线则分隔字节内部的位。
- en: '![image](graphics/f01-14.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f01-14.jpg)'
- en: '*Figure 1-14: The sample message* Send more money! *transformed into a grid
    of bytes, ready for encryption using AES*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-14：示例消息* 发送更多钱！*转化为字节网格，准备使用 AES 进行加密*'
- en: The plaintext data is divided into as many 16-byte blocks as necessary. If the
    last block isn’t full, the rest of the block is padded with random binary numbers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 明文数据被分割为尽可能多的 16 字节块。如果最后一个块不满，剩余部分会使用随机二进制数进行填充。
- en: AES then subjects each 16-byte block of plaintext data to 10 *rounds* of encryption.
    During a round, the bytes are transposed within the block and substituted using
    a table. Then, using the XOR operation, the bytes in the block are combined with
    each other and with one of the 128-bit keys.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，AES 将每个 16 字节的明文数据块进行 10 *轮* 加密。在每一轮中，字节会在块内进行置换，并使用表格进行替换。然后，使用 XOR 操作，块内的字节与其他字节及
    128 位密钥之一进行组合。
- en: That’s AES in a nutshell; now let’s look at some of these steps in more detail.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 AES 的基本概念；现在让我们更详细地看看这些步骤。
- en: '***Key Expansion in AES***'
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***AES 中的密钥扩展***'
- en: 'Key expansion in a digital encryption system is a bit different than the “code
    book” concept we discussed earlier. Instead of just looking up a longer key in
    a book, AES expands the key using the same tools it will later use for the encryption
    itself: the binary XOR operation, transposition, and simple substitution.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 数字加密系统中的密钥扩展与我们之前讨论的“密码本”概念有所不同。AES 不仅仅是查找书中的一个更长密钥，而是利用它稍后用于加密的相同工具进行密钥扩展：二进制
    XOR 操作、置换和简单替换。
- en: '[Figure 1-15](ch01.html#ch1fig15) shows the first few stages of the key expansion
    process. Each of the blocks in the figure is 32 bits, and one row in this figure
    represents one 128-bit key. The original 128-bit key makes up the first four blocks,
    which are shaded in the figure. Every other block is the result of an XOR between
    two previous blocks; the XOR operation is represented by a plus sign in a circle.
    Block 6, for example, results from the XOR of Block 2 and Block 5.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 1-15](ch01.html#ch1fig15) 展示了密钥扩展过程的前几个阶段。图中的每个块为 32 位，图中的一行代表一个 128 位的密钥。原始的
    128 位密钥构成了前四个块，这些块在图中被着色。每个其他块是通过对两个前一个块进行 XOR 运算得到的；XOR 操作用圆圈中的加号表示。例如，块 6 是通过块
    2 和块 5 的 XOR 运算得到的。'
- en: '![image](graphics/f01-15.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f01-15.jpg)'
- en: '*Figure 1-15: Key expansion process for AES*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-15：AES 密钥扩展过程*'
- en: As you can see on the right of the figure, every fourth block passes through
    a box labeled “Extra Scrambling.” This process includes transposing the bytes
    inside the block and substituting each byte according to a table called the *S-box*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如图右侧所示，每四个块中就有一个通过一个标记为“额外扰乱”的盒子。这一过程包括对块内的字节进行置换，并根据一个叫做 *S-box* 的表进行字节替换。
- en: The S-box table, which is used both in the key expansion and later in the encryption
    itself, is carefully designed to amplify differences in the plaintext. That is,
    two plaintext bytes that are similar will tend to have S-box replacements that
    are quite different. The first eight entries from the table are shown in [Table
    1-3](ch01.html#ch1tab3).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: S-box 表被精心设计，用于加密过程中放大明文之间的差异。也就是说，两个相似的明文字节将趋向于拥有完全不同的 S-box 替代值。表中的前八个条目展示在
    [表 1-3](ch01.html#ch1tab3) 中。
- en: '**Table 1-3:** Excerpts from the S-Box Table'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 1-3：S-Box 表中的摘录**'
- en: '| **Original bit pattern** | **Replacement bit pattern** |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| **原始位模式** | **替换位模式** |'
- en: '| --- | --- |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 00000000 | 01100011 |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 00000000 | 01100011 |'
- en: '| 00000001 | 01111100 |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 00000001 | 01111100 |'
- en: '| 00000010 | 01110111 |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 00000010 | 01110111 |'
- en: '| 00000011 | 01111011 |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 00000011 | 01111011 |'
- en: '| 00000100 | 11110010 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 00000100 | 11110010 |'
- en: '| 00000101 | 01101011 |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 00000101 | 01101011 |'
- en: '| 00000110 | 01101111 |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 00000110 | 01101111 |'
- en: '| 00000111 | 11000101 |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 00000111 | 11000101 |'
- en: '| 00001000 | 00110000 |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 00001000 | 00110000 |'
- en: '| 00001001 | 00000001 |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 00001001 | 00000001 |'
- en: '***AES Encryption Rounds***'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***AES 加密轮次***'
- en: Once AES has all the required keys, the real encryption can begin. Recall that
    the binary plaintext is stored in a grid of 16 bytes or 128 bits, which is the
    same size as the original key. This is not a coincidence. The first step of the
    actual encryption is to XOR the 128-bit data grid with the original 128-bit key.
    Now the work begins in earnest, as the data grid is subjected to 10 rounds of
    number crunching. There are four steps in each round.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 AES 获得了所有所需的密钥，真正的加密过程就可以开始了。回想一下，二进制明文存储在一个 16 字节或 128 位的网格中，这与原始密钥的大小相同。这并非巧合。实际加密的第一步是将
    128 位的数据网格与原始的 128 位密钥进行异或操作。现在，工作开始真正展开，因为数据网格将经过 10 轮的数值处理。每一轮有四个步骤。
- en: '**1\. Substitution.**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**1\. 替代。**'
- en: Each of the 16 bytes in the grid is replaced using the same S-box table used
    in the key expansion process.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 网格中的每个 16 字节都使用与密钥扩展过程中相同的 S-盒表进行替换。
- en: '**2\. Row Transposition.**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**2\. 行置换。**'
- en: Next, the bytes are moved to different positions within their row in the grid.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，字节将被移动到网格中它们所在行的不同位置。
- en: '**3\. Column Combination.**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**3\. 列组合。**'
- en: Next, for each byte in the grid, a new byte is calculated from a combination
    of all four bytes in that column. This computation involves the XOR operation
    again, but also a binary form of transposition. To give you the flavor of the
    process, [Figure 1-16](ch01.html#ch1fig16) shows the computation of the leftmost
    byte in the lowest row. The four bytes of the leftmost column are XORed together,
    but the top and bottom bytes in the column have their bits transposed first. This
    kind of transposition is known as *bitwise rotation*; the bits slide one position
    to the left, with the leftmost bit moving over to the right end.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，对于网格中的每个字节，通过结合该列中的所有四个字节计算出一个新字节。这个计算再次涉及到异或操作，但也涉及到一种二进制形式的置换。为了让你理解这个过程，[图
    1-16](ch01.html#ch1fig16)展示了最左边列的最低行左侧字节的计算方法。最左列的四个字节会先进行异或运算，但列中的最上面和最下面的字节会先进行位置换。这种置换被称为*按位旋转*；字节的位会向左滑动一个位置，最左边的位会移动到右侧。
- en: Every byte in the new grid is computed in a similar way, by combining the bytes
    in the column using XOR; the only variation is which bytes have their bits rotated
    before the XOR.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 新网格中的每个字节都通过类似的方式计算，方法是将列中的字节通过异或运算结合起来；唯一的变化是哪些字节在异或之前先进行位旋转。
- en: '![image](graphics/f01-16.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f01-16.jpg)'
- en: '*Figure 1-16: One part of the column-scrambling step in an AES round*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1-16：AES 一轮中列置换步骤的一个部分*'
- en: '**4\. XOR with Cipher Key.**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**4\. 与密文密钥进行异或。**'
- en: Finally, the grid that results from the previous step is XORed with the key
    for that round. This is why key expansion is needed, so that each round XORs with
    a different key.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将前一步得到的网格与该轮的密钥进行异或运算。这就是为何需要密钥扩展的原因，以便每一轮都与不同的密钥进行异或。
- en: The AES decryption process performs the same steps as the encryption process,
    in reverse. Because the only operations in the encryption are XORs, simple substitution
    from the S-box, and transpositions of bits and bytes, everything is reversible
    if the key is known.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: AES 解密过程执行与加密过程相同的步骤，只不过是反向操作。由于加密过程中的操作只有异或、简单的 S-盒替换以及位和字节的置换，若已知密钥，所有操作都是可逆的。
- en: '***Block Chaining***'
  id: totrans-151
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***块链链接***'
- en: AES encryption could be applied individually to each 16-byte block in a file,
    but this would create vulnerabilities in the ciphertext. As we’ve discussed, the
    more times an encryption key is used, the more likely it is that attackers will
    discover and exploit patterns. Computer files are often enormous, and using the
    same key to encrypt millions of blocks is a form of large-scale key reuse that
    exposes the ciphertext to frequency analysis and related techniques.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: AES 加密可以单独应用于文件中的每个 16 字节块，但这会在密文中留下漏洞。正如我们之前讨论过的，密钥使用的次数越多，攻击者发现并利用模式的可能性就越大。计算机文件通常非常庞大，使用相同的密钥加密数百万个块，这是一种大规模的密钥重用形式，会使密文暴露于频率分析及相关技术。
- en: For this reason, block-based encryption systems like AES are modified so that
    identical blocks in plaintext produce different ciphertext blocks. One such modification
    is called *block chaining*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，像AES这样的基于块的加密系统经过修改，使得明文中相同的块生成不同的密文块。其中一种修改方法称为*块链式加密*。
- en: When block chaining, the first block of the plaintext is XORed with a random
    128-bit number before encryption. This random number is called the *starting variable*
    and is stored along with the ciphertext. Because each encryption is assigned a
    random starting variable, two files that begin with the same data will have different
    ciphertexts even when encrypted with the same key.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在块链式加密中，明文的第一个块在加密前会与一个随机的128位数进行异或（XOR）运算。这个随机数称为*起始变量*，并与密文一起存储。由于每次加密都会分配一个随机的起始变量，因此即使两个文件以相同的数据开始，在使用相同密钥加密时，它们的密文也会不同。
- en: Every subsequent plaintext block is XORed with the previous ciphertext block
    before encryption, “chaining” the encryption as shown in [Figure 1-17](ch01.html#ch1fig17).
    Chaining ensures that duplicate blocks in a plaintext will result in different
    ciphertext blocks. This means files of any length can be encrypted without fear
    of frequency analysis.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每个后续的明文块在加密前都会与前一个密文块进行异或（XOR）运算，从而实现加密的“链式”作用，如[图1-17](ch01.html#ch1fig17)所示。链式加密确保了明文中的重复块会生成不同的密文块。这意味着任何长度的文件都可以在不担心频率分析的情况下进行加密。
- en: '![image](graphics/f01-17.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![image](graphics/f01-17.jpg)'
- en: '*Figure 1-17: AES encryption using block chaining*'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1-17：使用块链式加密的AES加密过程*'
- en: '***Why AES Is Secure***'
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***为什么AES是安全的***'
- en: As you can see, although AES contains many steps, each individual step is just
    transposition or simple substitution. Why is AES considered strong enough to protect
    the world’s data? Remember, attackers use brute force or cribs, or exploit patterns
    in the ciphertext. AES has excellent defenses against all of these attack methods.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，尽管AES包含许多步骤，但每个步骤都只是置换或简单的替代。为什么AES被认为足够强大，能够保护世界的数据？记住，攻击者通常会使用暴力破解、已知明文或利用密文中的模式。AES在防范这些攻击方法方面表现得非常出色。
- en: With AES, brute force means running the ciphertext through the decryption process
    with every possible key until the plaintext is produced. In AES, keys have 128,
    192, or 256 bits. Even the smallest key size offers around 300,000,000,000,000,000,000,000,000,000,000,000,000
    possible keys, and a brute-force attack would need to try about half of these
    before it could expect to hit the right one. An attacker with a computer that
    could try a million keys per second could, in a day, try 1,000,000 keys × 60 seconds
    × 60 minutes × 24 hours = 86,400,000,000 keys. In a year, the attacker could try
    31,536,000,000,000 keys. Although that’s a large number, it’s not even a billionth
    of a billionth of the possible combinations. An attacker might acquire more computing
    power, but trying that many keys still doesn’t seem feasible—and that’s just for
    the 128-bit version.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于AES，暴力破解意味着通过所有可能的密钥将密文传递到解密过程，直到明文被恢复。在AES中，密钥长度有128、192或256位。即使是最小的密钥长度，也有大约300,000,000,000,000,000,000,000,000,000,000,000,000个可能的密钥，暴力破解攻击需要尝试其中一半的密钥才能找到正确的密钥。假设攻击者的计算机每秒可以尝试百万个密钥，那么在一天内，攻击者可以尝试1,000,000密钥
    × 60秒 × 60分钟 × 24小时 = 86,400,000,000个密钥。在一年内，攻击者可以尝试31,536,000,000,000个密钥。虽然这个数字很大，但它甚至不到可能组合数的十亿分之一。即使攻击者获取了更多的计算能力，尝试这么多的密钥仍然不现实——而这仅仅是针对128位版本。
- en: AES also makes using cribs or finding exploitable patterns difficult. During
    each encryption round, AES rotates the bytes in each row of the grid and combines
    the bytes in each column. After many rounds of this, the bytes are thoroughly
    mixed together so the final value of any one byte in the ciphertext grid depends
    on the initial plaintext values of all the bytes in a grid. This encryption property
    is called *diffusion*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: AES还使得使用已知明文或寻找可利用的模式变得困难。在每一轮加密过程中，AES会旋转每行的字节并合并每列的字节。经过多轮操作后，字节被彻底混合，因此密文网格中任意一个字节的最终值都依赖于网格中所有字节的初始明文值。这种加密特性被称为*扩散*。
- en: Furthermore, passing the bytes through the S-box, round after round, amplifies
    the effect of diffusion, and block chaining passes the diffusion effects of each
    block on to the next. Together, these operations give AES the *avalanche* property,
    in which small changes in the plaintext result in sweeping changes throughout
    the ciphertext.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，经过S盒的多轮处理，扩散效果会得到放大，而块链式加密将每个块的扩散效应传递到下一个块。所有这些操作共同赋予了AES*雪崩效应*，即明文中的微小变化会导致密文中的大范围变化。
- en: AES thwarts attackers no matter how much they know about the general layout
    of the plaintext. For example, a company may send emails to customers based on
    a common template, in which the only variables are the customers’ account numbers
    and outstanding balances. With diffusion, avalanches, and block chaining, the
    ciphertexts of these emails will be very different. Diffusion and avalanches also
    reduce patterns that could be exploited through frequency analysis. Even a huge
    plaintext file consisting of the same 16-byte block repeated over and over would
    result in a random-looking jumble of bits when run through AES encryption with
    block chaining.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 无论攻击者对明文的大致布局了解多少，AES 都能抵挡住攻击。例如，一家公司可能基于一个共同的模板向客户发送电子邮件，唯一的变量是客户的账户号码和未结余额。通过扩散、雪崩和块链技术，这些电子邮件的密文将会非常不同。扩散和雪崩还会减少可能通过频率分析被利用的模式。即使是一个包含重复相同16字节块的巨大明文文件，通过
    AES 加密和块链处理后，也会得到看起来完全随机的比特串。
- en: '***Possible AES Attacks***'
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***可能的 AES 攻击***'
- en: AES appears to be strong against conventional encryption attacks, but are there
    hidden weaknesses that offer shortcuts to finding the right cipher key? The answer
    is unclear because proving a negative is difficult. Stating that no shortcuts,
    or *cracks*, are known to exist is one thing; proving they *couldn’t* exist is
    another. Cryptography is a science, and science is always expanding its boundaries.
    We simply don’t understand cryptography and its underlying mathematics to a point
    where we can say what’s impossible.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: AES 看似能有效抵御传统的加密攻击，但是否存在一些隐藏的弱点能提供破解密码的捷径？答案尚不明了，因为证明一个否定命题是很困难的。说没有已知的捷径或*破解*方法是其中一回事，而证明它们*不可能*存在又是另一回事。密码学是一门科学，而科学总是在不断扩展边界。我们对密码学及其基础数学的理解还不到可以断言什么是不可能的程度。
- en: Part of the difficulty in analyzing the vulnerabilities of an open standard
    like AES is that programmers implementing the standard in code may unwittingly
    introduce security flaws. For example, some AES implementations are vulnerable
    to a *timing attack*, in which an attacker gleans information about the data being
    encrypted by measuring how long the encryption takes. The attacker must have access
    to the specific computer on which the encryption is performed, however, so this
    isn’t really a flaw in the underlying encryption, but that’s no comfort if security
    is compromised.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 分析像 AES 这样的开放标准的漏洞的困难部分在于，程序员在实现该标准时可能无意中引入安全漏洞。例如，一些 AES 实现容易受到*时间攻击*的影响，攻击者通过测量加密所需的时间来获取关于加密数据的信息。然而，攻击者必须能够访问执行加密的特定计算机，因此这实际上并不是底层加密的缺陷，但如果安全性受到威胁，这也并不能让人安心。
- en: The best-understood vulnerability of AES is known as a *related-key attack*.
    When two keys are mathematically related in a specific way, an attacker can sometimes
    use knowledge gathered from messages encrypted using one key to recover a message
    encrypted using the other key. Researchers have discovered a way to recover the
    AES encryption key for a particular ciphertext in less time than a brute-force
    attack, but the method requires ciphertexts of the same plaintext encrypted with
    keys that are related to the original key in very specific ways.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: AES 最为人知的漏洞是*相关密钥攻击*。当两个密钥以特定方式数学相关时，攻击者有时可以利用通过一个密钥加密的消息中收集到的信息，恢复使用另一个密钥加密的消息。研究人员发现了一种方法，可以在比暴力破解攻击更短的时间内恢复特定密文的
    AES 加密密钥，但该方法要求使用与原始密钥在非常特定的方式上相关联的密钥加密的同一明文的密文。
- en: Although this shortcut counts as a crack, it may not be of practical value to
    attackers. First of all, although it greatly reduces the amount of work to recover
    the original key, it may not be feasible for any existing computer or network
    of computers. Second, it’s not easy to obtain the other ciphertexts that have
    been encrypted with the related keys; it requires a breakdown in the implementation
    or use of the cipher. Therefore, this crack is currently considered theoretical,
    not a practical weakness of the system.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这一捷径算作一个破解方法，但对攻击者来说可能并没有实际价值。首先，尽管它大大减少了恢复原始密钥所需的工作量，但对现有计算机或计算机网络而言，这可能是不可行的。其次，获取已用相关密钥加密的其他密文并不容易；这需要加密方法或使用方式出现故障。因此，这一破解方法目前被认为是理论性的，而非系统的实际弱点。
- en: 'Perhaps the most worrying aspect of this crack is that it’s believed to work
    only for the supposedly stronger 256-bit-key version of AES, not the simpler 128-bit-key
    version described in this chapter. This demonstrates perhaps the greatest weakness
    of modern encryption techniques: their complexity. Flaws can go undetected for
    years despite the efforts of expert reviewers; small changes in the design can
    have large ramifications for security; and features intended to increase security
    may have the opposite effect.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 也许这种破解方式最令人担忧的一点是，它被认为只对所谓更强的 256 位密钥版本的 AES 有效，而不适用于本章描述的更简单的 128 位密钥版本。这可能展示了现代加密技术的最大弱点：它们的复杂性。即便有专家审查，缺陷可能依然在多年后未被发现；设计中的小变化也可能对安全性产生重大影响；而本应增强安全性的特性，可能会产生相反的效果。
- en: '**The Limits of Private-Key Encryption**'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**私钥加密的局限性**'
- en: The real limitation of an encryption method like AES, though, has nothing to
    do with a potential hidden flaw.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，像 AES 这样的加密方法的真正局限性与潜在的隐藏漏洞无关。
- en: All the encryption methods in this chapter, AES included, are known as *symmetric-key*
    methods—this means the key that encrypts a message or file is the same key that
    is used to decrypt it. If you want to use AES to encrypt a file on your desktop’s
    hard drive or the contact list in your phone, that’s not a problem; only you are
    locking and unlocking the data. But what happens when you need to secure a data
    transmission, as when you enter your credit card number on a retail website? You
    could encrypt the data with AES and send it to the website, but the software on
    the website couldn’t decrypt the ciphertext without the key.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有加密方法，包括 AES，都被称为*对称密钥*方法——这意味着加密消息或文件的密钥与解密它所使用的密钥是相同的。如果你想用 AES 加密桌面硬盘上的文件或手机中的联系人列表，这没有问题；只有你自己在加锁和解锁数据。但是，当你需要保护数据传输时，比如在零售网站上输入信用卡号码时会发生什么呢？你可以用
    AES 加密数据并发送到网站，但网站上的软件在没有密钥的情况下无法解密密文。
- en: This is the *shared key problem*, and it’s one of the central problems of cryptography.
    Without a secure way to share keys, symmetric key encryption, by itself, is only
    useful for locking one’s own private data. Encrypting data for transmission requires
    a different approach, using different keys for encryption and decryption—you’ll
    see how this is done in [Chapter 3](ch03.html#ch03).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*共享密钥问题*，也是密码学的核心问题之一。没有一种安全的方式来共享密钥，对称密钥加密仅对锁定自己的私人数据有用。为了进行数据传输加密，必须采取不同的方法，使用不同的密钥进行加密和解密——你将在[第
    3 章](ch03.html#ch03)中看到这是如何实现的。
- en: But there’s another problem we need to tackle first. AES requires an enormous
    binary number as a key, but users can’t be expected to memorize a string of 128
    bits. Instead, we memorize passwords. As it turns out, the secure storage and
    use of passwords presents its own quandaries. Those are the subject of the next
    chapter.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们首先需要解决另一个问题。AES 需要一个巨大的二进制数作为密钥，但用户不可能记住 128 位的字符串。相反，我们记住的是密码。事实证明，密码的安全存储和使用本身就会带来一些难题。这些将是下章的内容。
