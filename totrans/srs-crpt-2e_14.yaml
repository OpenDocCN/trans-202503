- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp> <samp class="SANS_Dogma_OT_Bold_B_11">RSA</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Rivest–Shamir–Adleman (RSA) cryptosystem revolutionized cryptography when
    it emerged in 1977 as the first public-key encryption scheme. Whereas classical,
    symmetric-key encryption schemes use the same secret key to encrypt and decrypt
    messages, *public-key encryption* (or *asymmetric* encryption) uses two keys:
    a public key, which anyone who wants to encrypt messages for you can use, and
    a private key, which is required to decrypt messages encrypted using the public
    key. This magic is the reason why RSA was a real breakthrough, and 40 years later,
    it’s still the paragon of public-key encryption and a workhorse of internet security.
    (One year prior to RSA, Whitfield Diffie and Martin Hellman introduced the concept
    of public-key cryptography, but their scheme was able to perform key distribution
    only in a public-key setting.)'
  prefs: []
  type: TYPE_NORMAL
- en: RSA works by creating a *trapdoor permutation*, a function that transforms a
    number *x* to a number *y* in the same range, such that computing *y* from *x*
    is easy using the public key, but computing *x* from *y* is practically impossible
    unless you know the private key—the trapdoor. (Think of *x* as a plaintext and
    *y* as a ciphertext.)
  prefs: []
  type: TYPE_NORMAL
- en: In addition to encryption, you can also use RSA to build digital signatures,
    wherein only the owner of the private key is able to sign a message, and the public
    key enables anyone to verify the signature’s validity.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how the RSA trapdoor permutation works and why
    this permutation alone isn’t enough to build *secure* encryption and signatures.
    I also discuss RSA’s security relative to the factoring problem (see [Chapter
    9](chapter9.xhtml)), ways to implement RSA securely, and how to attack it.
  prefs: []
  type: TYPE_NORMAL
- en: We begin with an explanation of the basic mathematical notions behind RSA.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Math Behind RSA</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When processing a message, whether encrypting or signing it, RSA first creates
    a big number from that message and processes it by performing multiplications
    between big numbers. Therefore, to understand how RSA works, you need to know
    what kind of big numbers it manipulates and how multiplication works on those
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: To encrypt or sign, RSA transforms a positive integer between 1 and *n* – 1,
    where *n* is a large number called the *modulus*. Such numbers, when multiplied
    together, yield another number that satisfies these criteria. These numbers form
    a group, which you denote **Z**n^* and call the multiplicative group of integers
    modulo *n*. (See the mathematical definition of a group in “[Groups](chapter9.xhtml#sec12)”
    on page 189.)
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the group **Z**[4]^* of integers modulo 4\. Recall from
    [Chapter 9](chapter9.xhtml) that a group must include an identity element (that
    is, 1) and that each number *x* in the group must have an inverse, a number *y*
    such that *x* × *y* = 1\. How do you determine the set that makes up **Z**[4]^*?
    Based on the definitions, you know that 0 is not in the group **Z**[4]^* because
    multiplying any number by 0 can never give 1, so 0 has no inverse. The number
    1 belongs to **Z**[4]^* because 1 × 1 = 1, so 1 is its own inverse. However, the
    number 2 doesn’t belong in this group because you can’t obtain 1 by multiplying
    2 with another element of **Z**[4]^* (note that 2 isn’t coprime with 4, because
    4 and 2 share the factor of 2). The number 3 belongs in the group **Z**[4]^* because
    it is its own inverse within **Z**[4]^*. Thus, you have **Z**[4]^* = {1, 3}.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider **Z**[5]^*, the multiplicative group of integers modulo 5\. As
    in [Chapter 9](chapter9.xhtml), **Z**[5]^* = {1, 2, 3, 4}. Indeed, 5 being prime,
    1, 2, 3, and 4 are all coprime with 5, so the set of **Z**[5]^* includes all of
    them. Let’s verify this: 2 × 3 mod 5 = 1; therefore, 2 is 3’s inverse, and 3 is
    2’s inverse; note that 4 is its own inverse because 4 × 4 mod 5 = 1; and finally,
    1 is again its own inverse in the group.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the number of elements in a group **Z**n^* when *n* isn’t prime, you
    can use *Euler’s totient function*, which we write as φ(*n*), with φ representing
    the Greek letter phi. This function gives the number of elements coprime with
    *n*, which is the number of elements in **Z**n^*. As a rule, if *n* is a product
    of prime numbers *n* = *p*[1] × *p*[2] × . . . × *p*m, the number of elements
    in the group **Z**n^* is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg197-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: RSA deals only with numbers *n* that are the product of two large primes, usually
    noted as *n* = *pq*. The associated group **Z**n^* then contains φ(*n*) = (*p*
    – 1)(*q* – 1) elements. By expanding this expression, you get the equivalent definition
    φ(*n*) = *n* – *p* – *q* + 1, or φ(*n*) = (*n* + 1) – (*p* + *q*), which expresses
    more intuitively the value of φ(*n*) relative to *n*.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The RSA Trapdoor Permutation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The RSA trapdoor permutation is the core algorithm behind RSA-based encryption
    and signatures. Given a modulus *n* and a number *e*, which you call the *public
    exponent*, the RSA trapdoor permutation transforms a number *x* from the set **Z**n^*
    into a number *y* = *x**^e* mod *n*. In other words, it calculates the value that’s
    equal to *x* multiplied by itself *e –* 1 times modulo *n* and then returns the
    result. When you use the RSA trapdoor permutation to encrypt, the modulus *n*
    and the exponent *e* make up the RSA public key.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get *x* back from *y*, you can use another number, *d*, to compute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg197-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because *d* is the trapdoor that allows you to decrypt, it’s part of the private
    key in an RSA key pair, meaning it should always be kept secret. The number *d*
    is also called the *secret exponent*.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, *d* isn’t just any number; it’s the number such that *e* multiplied
    by *d* is equivalent to 1 and therefore such that *x**^(ed)* mod *n* = *x* for
    any *x*. More precisely, you must have *ed* mod φ(*n*) = 1 to get *x**^(ed)* =
    *x*¹ = *x* and to decrypt the message correctly. Note that you compute modulo
    φ(*n*) and not modulo *n* here because exponents behave like *indexes* of elements
    of **Z**n^* rather than as the elements themselves. Because **Z**n^* has φ*(n*)
    elements, the index must be less than φ*(n*).
  prefs: []
  type: TYPE_NORMAL
- en: The number φ(*n*) is crucial to RSA’s security. In fact, finding φ(*n*) for
    an RSA modulus *n* is equivalent to breaking RSA because you can easily derive
    the secret exponent *d* from φ(*n*) and *e* by computing *e*’s inverse. Hence
    *p* and *q* should also be secret, since knowing *p* or *q* gives φ(*n*) by computing
    (*p* – 1)(*q* – 1) = φ(*n*).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*φ(*n*) is called the* order *of the group* **Z**[n]*^***; the order is an
    important characteristic of a group, which is essential to other public-key systems
    such as Diffie–Hellman and elliptic curve cryptography.*'
  prefs: []
  type: TYPE_NORMAL
- en: '### <samp class="SANS_Futura_Std_Bold_B_11">RSA Key Generation and Security</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Key generation* is the process by which an RSA key pair is created, namely,
    a public key (modulus *n* and public exponent *e*) and its private key (secret
    exponent *d*). As the numbers *p* and *q* (such that *n* = *pq*) and the order
    φ(*n*) should also be secret, you will often include them as part of the private
    key.'
  prefs: []
  type: TYPE_NORMAL
- en: To generate an RSA key pair, first pick two random prime numbers, *p* and *q*,
    and compute φ(*n*) from them. Then compute *d* as the inverse of *e*. [Listing
    10-1](chapter10.xhtml#Lis10-1) shows how this works using SageMath (*[https://<wbr>www<wbr>.sagemath<wbr>.org](https://www.sagemath.org)*),
    an open source Python-esque environment that includes many mathematical packages.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-1: Generating RSA
    parameters using SageMath</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Here you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">random_prime()</samp>
    function to pick random primes <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>, which are lower than
    a given argument. Next, you multiply <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> to get the modulus
    <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> and φ(*n*), which is the
    <samp class="SANS_TheSansMonoCd_W5Regular_11">phi</samp> variable. You then generate
    a random public exponent, <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>,
    by picking a random prime less than <samp class="SANS_TheSansMonoCd_W5Regular_11">phi</samp>
    to ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp> has an inverse
    modulo <samp class="SANS_TheSansMonoCd_W5Regular_11">phi</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: You use the <samp class="SANS_TheSansMonoCd_W5Regular_11">xgcd()</samp> function
    from Sage to generate the associated private exponent *d*. This function computes
    the numbers *s* and *t* given two numbers, *a* and *b*, with the extended Euclidean
    algorithm such that *as* + *bt* = **GCD**(*a*, *b*). Finally, you check that *ed*
    mod φ(*n*) = 1 to ensure that *d* correctly inverts the RSA permutation.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*I’ve used a 64-bit modulus* n *in [Listing 10-1](chapter10.xhtml#Lis10-1)
    to avoid multiple pages of output, but in practice an RSA modulus should be at
    least 2,048 bits to be secure.*'
  prefs: []
  type: TYPE_NORMAL
- en: Now you can apply the trapdoor permutation, as [Listing 10-2](chapter10.xhtml#Lis10-2)
    shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-2: Computing the
    RSA trapdoor permutation back and forth</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You assign the integer 1,234,567 to *x* and then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">power_mod(x,
    e, n)</samp> function, the exponentiation modulo *n*, or *x**^e* mod *n* in equation
    form, to calculate *y*. After computing *y* = *x**^e* mod *n*, you calculate *y**^d*
    mod *n* with the trapdoor *d* to return the original *x*.
  prefs: []
  type: TYPE_NORMAL
- en: How hard is it to find *x* without the trapdoor *d*? An attacker able to factor
    big numbers could break RSA by recovering *p* and *q* and then φ(*n*) to compute
    *d* from *e*. Another risk to RSA lies in an attacker’s ability to compute *x*
    from *x**^e* mod *n*, or *e*th roots modulo *n*, without necessarily factoring
    *n*. While both risks seem closely connected, we don’t know for sure that they’re
    equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that factoring and finding *e*th roots are about equally hard, RSA’s
    security level depends on three factors: the size of *n*, the choice of *p* and
    *q*, and how the trapdoor permutation is used. If *n* is too small, one could
    factor it in a realistic amount of time, revealing the private key. To be safe,
    *n* should be at least 2,048 bits long (a security level of about 90 bits, requiring
    a computational effort of about 2^(90) operations) but preferably 4,096 bits long
    (a security level of approximately 128 bits). The values *p* and *q* should be
    unrelated random prime numbers of similar size. If they’re too small or too close
    together, it’s easier to determine their value from *n*. Finally, you shouldn’t
    use the RSA trapdoor permutation directly for encryption or signing, as I’ll discuss
    shortly.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Encrypting with RSA</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Typically, RSA is used in combination with a symmetric encryption scheme, where
    RSA encrypts a symmetric key that serves to encrypt a message with a symmetric
    cipher, such as AES-GCM. But encrypting a message or symmetric key with RSA is
    more complicated than simply converting the target to a number *x* and computing
    *x**^e* mod *n*.
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsections, I explain why a naive application of the RSA trapdoor
    permutation is insecure and how strong RSA-based encryption works.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Textbook RSA Encryption’s
    Malleability</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The phrase *textbook RSA encryption* describes the simplistic RSA encryption
    scheme wherein the number exponentiated contains only the message you want to
    encrypt. For example, to encrypt the string *RSA*, you first convert it to a number—for
    example, by concatenating the ASCII encodings of each of the three letters as
    a byte: *R* (byte <samp class="SANS_TheSansMonoCd_W5Regular_11">52</samp>), *S*
    (byte <samp class="SANS_TheSansMonoCd_W5Regular_11">53</samp>), and *A* (byte
    <samp class="SANS_TheSansMonoCd_W5Regular_11">41</samp>). The resulting byte string
    <samp class="SANS_TheSansMonoCd_W5Regular_11">525341</samp> is equal to 5,395,265
    when converted to decimal, which you might then encrypt by computing 5,395,265*^e*
    mod *n*. Without knowing the secret key, there’s no way to decrypt the message—at
    least in theory.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, textbook RSA encryption is deterministic: if you encrypt the same
    plaintext twice, you’ll get the same ciphertext twice. And there’s an even bigger
    problem: given two textbook RSA ciphertexts *y*[1] = *x*[1]*^e* mod *n* and *y*[2]
    = *x*[2]*^e* mod *n*, you can derive the ciphertext of *x*[1] × *x*[2] by multiplying
    these ciphertexts together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg200-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The result is (*x*[1] × *x*[2])*^e* mod *n*, the ciphertext of the message *x*[1]
    × *x*[2] mod *n*. An attacker could create a new valid ciphertext from two RSA
    ciphertexts, compromising the security of your encryption by allowing them to
    deduce information about the original message. This weakness makes textbook RSA
    encryption *malleable*. (If you know *x*[1] and *x*[2], you can compute (*x*[1]
    × *x*[2])*^e* mod *n*, too, but if you know only *y*[1] and *y*[2], you shouldn’t
    be able to multiply ciphertexts and get the ciphertext of the multiplied plaintexts.)
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with the naive textbook RSA encryption is the existence of “special”
    messages. Whatever *n* and *e* are, 1*^e* = 1\. Thus, the message 1 is left unchanged
    through encryption. Textbook RSA has many other problems, but you’ll learn to
    avoid them by using a strong RSA encryption.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Strong RSA Encryption
    with OAEP</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To make RSA ciphertexts nonmalleable, the number exponentiated during encryption
    should combine message data with additional data called *padding*, as [Figure
    10-1](chapter10.xhtml#fig10-1) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig10-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-1: Encrypting a symmetric
    key,</samp> <samp class="SANS_Futura_Std_Book_11">K</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,
    with RSA using (</samp><samp class="SANS_Futura_Std_Book_11">n</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,</samp>
    <samp class="SANS_Futura_Std_Book_11">e</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">)
    as a public key</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The standard way to encrypt with RSA in this fashion is to use Optimal Asymmetric
    Encryption Padding (OAEP), a combination commonly called RSA-OAEP. This scheme
    involves creating a bit string as large as the modulus by padding the message
    with extra data and randomness before applying the RSA function.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Official documents such as the PKCS#1 standard and NIST’s Special Publication
    800-56B refer to OAEP as RSAES-OAEP. OAEP improves on the earlier method* *PKCS#1
    v1.5, which is one of the first in a series of Public-Key Cryptography Standards
    (PKCS) by RSA. It is markedly less secure than OAEP yet has remained in use in
    many systems after OAEP’s introduction.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: OAEP uses a PRNG to ensure the indistinguishability and nonmalleability of ciphertexts
    by making the encryption probabilistic. It’s been proven secure as long as the
    RSA function and the PRNG are secure and, to a lesser extent, the hash functions
    aren’t too weak. You should use OAEP when encrypting with RSA, rather than its
    predecessor, the standard PKCS#1 v1.5.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Encryption</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Encrypting with RSA in OAEP mode requires a message (such as a symmetric key,
    *K*), a PRNG, and two hash functions. To create the ciphertext, use a given modulus
    *n* long of *m* bytes (that is, 8*m* bits and therefore an *n* lower than 2⁸*^m*).
    To encrypt *K*, form the *encoded message* as
  prefs: []
  type: TYPE_NORMAL
- en: '*M* = *H* || <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> . . .
    <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> || <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    || *K*'
  prefs: []
  type: TYPE_NORMAL
- en: where *H* is an *h*-byte constant defined by the OAEP scheme, followed by as
    many <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> bytes as necessary
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> byte. [Figure 10-2](chapter10.xhtml#fig10-2)
    shows how to process this encoded message, *M*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig10-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-2: Encrypting a symmetric
    key,</samp> <samp class="SANS_Futura_Std_Book_11">K</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,
    with RSA-OAEP, where</samp> <samp class="SANS_Futura_Std_Book_11">H</samp> <samp
    class="SANS_Futura_Std_Book_Oblique_I_11">is a fixed parameter and</samp> <samp
    class="SANS_Futura_Std_Book_11">R</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">is
    random bits</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: You generate an *h*-byte random string *R* and set *M* = *M* ⊕ **Hash1**(*R*),
    where **Hash1**(*R*) is as long as *M*. Next, set *R* = *R* ⊕ **Hash2**(*M*),
    where **Hash2**(*M*) is as long as *R*. Now use these new values of *M* and *R*
    to form an *m*-byte string *P* = <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    || *M* || *R*, which is as long as the modulus *n* and which you can convert to
    an integer number less than *n*. This conversion results in the number *x*, which
    you then use to compute the RSA function *x**^e* mod *n* to get the ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: To decrypt a ciphertext *y*, first compute *x* = *y**^d* mod *n* and, from this,
    recover the final values of *M* and *R*. Next, retrieve *M*’s initial value by
    calculating *M* ⊕ **Hash1**(*R* ⊕ **Hash2**(*M*)). Finally, verify that *M* is
    of the form *H* || <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> . .
    . <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> || <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    || *K*, with an *h*-byte *H* and <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp>
    bytes followed by a <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> byte.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, the parameters *m* and *h* (the length of the modulus and the length
    of **Hash2**’s output, respectively) are typically *m* = 256 bytes (for 2,048-bit
    RSA) and *h* = 32 (using SHA-256 as **Hash2**). This leaves *m* – *h* – 1 = 223
    bytes for *M*, of which up to *m* – 2*h* – 2 = 190 bytes are available for *K*
    (the “– 2” is due to the <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    byte separator in *M*). The **Hash1** hash value is then composed of *m* – *h*
    – 1 = 223 bytes, which is longer than the hash value of any common hash function.
    To build a hash with such an unusual output length, the RSA standard specification
    defines a *mask generating function* technique to create hash functions that return
    arbitrarily large hash values from any hash function. As another approach, use
    an extendable output function (XOF) such as SHAKE or BLAKE3, although this differs
    from the standard specifications.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Signing with RSA</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Digital signatures can prove that the holder of the private key tied to a particular
    digital signature signed some message, typically to endorse its content. Because
    only the private key holder knows the private exponent *d*, no one else can compute
    a signature *y* = *x**^d* mod *n* from some value *x*, but everyone can verify
    *y**^e* mod *n* = *x* given the public exponent *e*. In principle, one can use
    that verified signature as evidence to demonstrate that the private-key holder
    signed some particular message; this is a property called *nonrepudiation*.
  prefs: []
  type: TYPE_NORMAL
- en: It’s tempting to see RSA signatures as the converse of encryption, but they
    aren’t. Signing with RSA isn’t the same as encrypting with the private key. Encryption
    provides confidentiality, whereas digital signatures help prevent forgeries. The
    most salient example of this difference is that it’s OK for a signature scheme
    to leak information on the message signed, because the message isn’t secret. For
    example, a scheme that reveals parts of the messages could be a secure signature
    scheme but not a secure encryption scheme.
  prefs: []
  type: TYPE_NORMAL
- en: Because of the necessary processing overhead, public-key encryption can process
    only short messages, which are usually secret keys rather than actual messages.
    A signature scheme, however, can process messages of arbitrary sizes by using
    their hash values **Hash**(*M*) as a proxy, and it can be deterministic yet secure.
    Like RSA-OAEP, RSA-based signature schemes can use a padding scheme, but they
    can also use the maximal message space allowed by the RSA modulus.
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Textbook RSA
    Signatures</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *textbook RSA signature* is the method that signs a message, *x*, by directly
    computing *y* = *x**^d* mod *n*, where *x* can be any number between 1 and *n*
    – 1\. Like textbook encryption, textbook RSA signing is simple to specify and
    implement but insecure in the face of several attacks. One such attack involves
    a trivial forgery: upon noticing that 1*^d* mod *n* = 1 and (*n* – 1)*^d* mod
    *n* = *n* – 1, regardless of the value of the private key *d*, an attacker can
    forge signatures of 1 or *n* – 1 without knowing *d*.'
  prefs: []
  type: TYPE_NORMAL
- en: More worrying is the *blinding attack*. For example, say you want to get a third
    party’s signature on some message, *M*, that you know they’d never knowingly sign.
    To launch this attack, first find some value, *R*, such that *R**^e**M* mod *n*
    is a message that your victim would knowingly sign. Next, you’d convince them
    to sign that message and to show you their signature, which is equal to *S* =
    (*R**^e**M*)*^d* mod *n*, or the message raised to the power *d*. Given that signature,
    you can derive the signature of *M*, namely, *M**^d*, with the aid of some straightforward
    computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because you can write *S* as (*R* *^e**M*)*^d* = *R**^(ed)**M**^d*, and because
    *R**^(ed)* = *R* (by definition), you have *S* = (*R**^e**M*)*^d* = *RM**^d*.
    To obtain the signature *M**^d*, divide *S* by *R* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg203-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is often a practical and powerful attack.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The PSS Signature
    Standard</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The RSA *Probabilistic Signature Scheme (PSS)* is to RSA signatures what OAEP
    is to RSA encryption. It was designed to make message signing more secure, thanks
    to the addition of padding data.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 10-3](chapter10.xhtml#fig10-3) demonstrates that PSS combines a message
    narrower than the modulus with some random and fixed bits before RSAing the results
    of this padding process.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig10-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-3: Signing a message,</samp>
    <samp class="SANS_Futura_Std_Book_11">M</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,
    with RSA and with the PSS standard, where (</samp><samp class="SANS_Futura_Std_Book_11">n</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">,</samp> <samp class="SANS_Futura_Std_Book_11">d</samp><samp
    class="SANS_Futura_Std_Book_Oblique_I_11">) is the private key</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Like all public-key signature schemes, PSS works on a message’s hash rather
    than on the message itself. Signing **Hash**(*M*) is secure only if the hash function
    is collision resistant. You can thus sign messages of any length because after
    hashing a message, you’ll obtain a hash value of the same fixed length regardless
    of the message’s original length.
  prefs: []
  type: TYPE_NORMAL
- en: Why not sign by just applying the OAEP encryption to **Hash**(*M*)? Unfortunately,
    you can’t. Although similar to PSS, OAEP has been proven secure only for encryption,
    not for signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Like OAEP, PSS also requires a PRNG and two hash functions. One, **Hash1**,
    is a typical hash with a standard output length, such as SHA-256\. The other,
    **Hash2**, is a wide-output hash like OAEP’s **Hash2**. Like OAEP, PSS can use
    the mask-generating function (MGF) construction to build such a hash.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PSS signing procedure works as follows (where *h* is **Hash1**’s output
    length):'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Pick an *r*-byte random string *R* using the PRNG.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Form an encoded message *M* ′ = <samp class="SANS_TheSansMonoCd_W5Regular_11">0000000000000000</samp>
    || **Hash1**(*M*) || *R*, long of *h* + *r* + 8 bytes (with 8 zero bytes at the
    beginning).
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Compute the *h*-byte string *H* = **Hash1**(*M*′).
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Set *L* = <samp class="SANS_TheSansMonoCd_W5Regular_11">00\. . .00</samp>
    || <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> || *R*, or a sequence
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> bytes followed by a
    <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> byte and then *R*, with
    a number of <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> bytes such
    that *L* is long of *m* – *h* – 1 bytes (the byte width *m* of the modulus minus
    the hash length *h* minus 1).
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Set *L* = *L* ⊕ **Hash2**(*H*) to replace the previous value of *L* with
    a new value.
  prefs: []
  type: TYPE_NORMAL
- en: 6.  Convert the *m*-byte string *P* = *L* || *H* || <samp class="SANS_TheSansMonoCd_W5Regular_11">BC</samp>
    to a number, *x*, lower than *n*. Here, the byte <samp class="SANS_TheSansMonoCd_W5Regular_11">BC</samp>
    is a fixed value appended after *H*.
  prefs: []
  type: TYPE_NORMAL
- en: 7.  Given the value of *x* just obtained, compute the RSA function *x**^d* mod
    *n* to obtain the signature.
  prefs: []
  type: TYPE_NORMAL
- en: 8.  To verify a signature given a message, *M*, compute **Hash1**(*M*) and use
    the public exponent *e* to inverse the RSA function and retrieve *L*, *H*, and
    then *M*′ from the signature, checking the padding’s correctness at each step.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, the random string *R* (called a *salt t* in the RSA-PSS standard)
    is usually as long as the hash value. For example, if you use *n* = 2,048 bits
    and SHA-256 as the hash, the value *L* is *m* – *h* – 1 = 256 – 32 – 1 = 223 bytes,
    and the random string *R* would typically be 32 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like OAEP, PSS is provably secure, standardized, and available in many cryptographic
    software utilities and libraries, including OpenSSL and the Go language’s cryptography
    module. Also like OAEP, it looks needlessly complex and is prone to implementation
    errors and mishandled corner cases. Unlike RSA encryption, there’s a simpler alternative
    to PSS for signing: without a PRNG, with a single hash function, and without padding.'
  prefs: []
  type: TYPE_NORMAL
- en: '#### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Full Domain
    Hash Signatures</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '*Full Domain Hash (FDH)* is the simplest signature scheme you can imagine.
    To implement it, convert the byte string **Hash**(*M*) to a number, *x*, and create
    the signature *y* = *x**^d* mod *n*, as in [Figure 10-4](chapter10.xhtml#fig10-4).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig10-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-4: Signing a message
    with RSA using the Full Domain Hash technique</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Signature verification is straightforward, too. Given a signature that’s a number
    *y*, compute *x* = *y**^e* mod *n* and compare the result with **Hash**(*M*).
    It’s boringly simple, deterministic, yet secure. So why bother with the complexity
    of PSS?
  prefs: []
  type: TYPE_NORMAL
- en: PSS was released *after* FDH, in 1996, and it has a security proof that inspires
    more confidence than FDH. Specifically, its proof offers slightly higher security
    guarantees than the proof of FDH, and its use of randomness helped strengthen
    that proof.
  prefs: []
  type: TYPE_NORMAL
- en: These stronger theoretical guarantees are the main reason why many cryptographers
    prefer PSS over FDH, but most applications using PSS today could switch to FDH
    with no meaningful security loss. In some contexts, however, it’s viable to use
    PSS instead of FDH because PSS’s randomness protects it from some attacks on its
    implementation, such as the fault attacks we’ll discuss in “How Things Can Go
    Wrong” on [page 211](#sec17).
  prefs: []
  type: TYPE_NORMAL
- en: In any case, RSA signatures (PSS or FDH) are less and less used. Signatures
    based on elliptic curves, such as ECDSA and EdDSA, have gained in popularity,
    not least because their calculation of a signature is much faster (although signature
    verification is often faster with RSA).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">RSA Implementations</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I hope you’ll never have to implement RSA from scratch. If you’re asked to,
    run as fast as you can and question the sanity of the person who asked you to
    do so. It took decades for cryptographers and engineers to develop RSA implementations
    that are fast, sufficiently secure, and ideally free of debilitating bugs, so
    it isn’t wise to reinvent RSA. Even with all the documentation available, it would
    take months to complete this daunting task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, when using RSA in software, you’ll use a library or API that provides
    the necessary functions to carry out RSA operations. For example, the Go language
    has the following function in its <samp class="SANS_TheSansMonoCd_W5Regular_11">crypto</samp>
    package (from *[https://<wbr>go<wbr>.dev<wbr>/src<wbr>/crypto<wbr>/rsa<wbr>/rsa<wbr>.go](https://go.dev/src/crypto/rsa/rsa.go)*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The function <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptOAEP()</samp>
    takes a hash function, a PRNG, a public key, a message, and a label (an optional
    parameter of OAEP) and returns a ciphertext and an error code. When you call <samp
    class="SANS_TheSansMonoCd_W5Regular_11">EncryptOAEP()</samp>, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">encrypt()</samp>
    to compute the RSA function given the padded data, as [Listing 10-3](chapter10.xhtml#Lis10-3)
    shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-3: The implementation
    of the core RSA encryption function from the Go language cryptography library</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The main operation here is <samp class="SANS_TheSansMonoCd_W5Regular_11">c.Exp(m,
    e, pub.N)</samp>, which raises a message, <samp class="SANS_TheSansMonoCd_W5Regular_11">m</samp>,
    to the power <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp> modulo <samp
    class="SANS_TheSansMonoCd_W5Regular_11">pub.N</samp>, and assigns the result to
    the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: If you choose to implement RSA instead of using a readily available library
    function, be sure to rely on an existing *big-number* library, which is a set
    of functions and types that allow you to define and compute arithmetic operations
    on large numbers thousands of bits long. For example, you might use the GNU Multiple
    Precision (GMP) arithmetic library in C or in Go’s <samp class="SANS_TheSansMonoCd_W5Regular_11">big</samp>
    package. (Believe me, you don’t want to implement big-number arithmetic yourself.)
  prefs: []
  type: TYPE_NORMAL
- en: Even if you just use a library function when implementing RSA, ensure you understand
    how the internals work so you can assess the risk and whether it matches the application’s
    security requirements.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Fast Exponentiation
    Algorithm</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Exponentiation* is the operation of raising *x* to the power *e*, when computing
    *x**^e* mod *n*. When working with big numbers, as with RSA, this operation can
    be extremely slow if naively implemented. How to efficiently compute exponentiations?'
  prefs: []
  type: TYPE_NORMAL
- en: The naive way to compute *x**^e* mod *n* takes *e* – 1 multiplications, as the
    pseudocode algorithm in [Listing 10-4](chapter10.xhtml#Lis10-4) demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-4: A naive exponentiation
    algorithm in pseudocode, raising</samp> <samp class="SANS_Futura_Std_Book_11">x</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">to the power</samp> <samp class="SANS_Futura_Std_Book_11">e</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">modulo</samp> <samp class="SANS_Futura_Std_Book_11">n</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is simple but highly inefficient. You can get the same result
    exponentially faster by squaring rather than multiplying intermediate values *y*
    until you reach the correct value. This family of methods is called *square-and-multiply*,
    *exponentiation by squaring*, or *binary exponentiation*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you want to compute 3^(65,537) mod 36,567,232,109,354,321, for example.
    (The number 65,537 is the public exponent in most RSA implementations.) You could
    multiply the number 3 by itself 65,536 times, or you could approach this problem
    knowing that you can write 65,537 as 2^(16) + 1 and use a series of squaring operations
    instead. Essentially, you initialize a variable, *y* = 3, and then compute the
    following squaring (*y*²) operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Set *y* = *y*² mod *n* (now *y* = 3² mod *n*).
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Set *y* = *y*² mod *n* (now *y* = (3²)² mod *n* = 3⁴ mod *n*).
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Set *y* = *y*² mod *n* (now *y* = (3⁴)² = 3⁸ mod *n*).
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Set *y* = *y*² mod *n* (now *y* = (3⁸)² = 3^(16) mod *n*).
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Set *y* = *y*² mod *n* (now *y* = (3^(16))² = 3^(32) mod *n*).
  prefs: []
  type: TYPE_NORMAL
- en: And so on until *y* = 3^(65,536), by performing 16 squarings.
  prefs: []
  type: TYPE_NORMAL
- en: To get the final result, you would return 3 × *y* mod *n* = 3^(65,537) mod *n*
    = 26,652,909,283,612,267\. In other words, you compute the result with only 17
    multiplications rather than 65,536 with the naive method.
  prefs: []
  type: TYPE_NORMAL
- en: More generally, a square-and-multiply method works by scanning the exponent’s
    bits one by one, computing the square for each exponent’s bit to double the exponent’s
    value, and multiplying by the original number for each bit with a value of 1 encountered.
    In the preceding example, the exponent 65,537 is 10000000000000001 in binary,
    and you squared *y* for each new bit and multiplied by the original number 3 only
    for the very first and last bits.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-5](chapter10.xhtml#Lis10-5) shows how this works as a general algorithm
    in pseudocode to compute *x**^e* mod *n* when the exponent *e* consists of bits
    *e*m – [1]*e*m – [2] . . . *e*[1]*e*[0], where *e*[0] is the least significant
    bit.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-5: A fast exponentiation
    algorithm in pseudocode, raising</samp> <samp class="SANS_Futura_Std_Book_11">x</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">to the power</samp> <samp class="SANS_Futura_Std_Book_11">e</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">modulo</samp> <samp class="SANS_Futura_Std_Book_11">n</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">expMod()</samp> algorithm
    runs in time *O*(*m*), whereas the naive algorithm runs in time *O*(2*^m*), where
    *m* is the bit length of the exponent. Here, *O*() is the asymptotic complexity
    notation introduced in [Chapter 9](chapter9.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: All serious systems implement some variant of this simplest square-and-multiply
    method. One such variant is the *sliding window* method, which considers blocks
    of bits rather than individual bits to perform a given multiplication operation.
    For example, see the function <samp class="SANS_TheSansMonoCd_W5Regular_11">expNN()</samp>
    of the Go language, whose source code is available at *[https://<wbr>go<wbr>.dev<wbr>/src<wbr>/math<wbr>/big<wbr>/nat<wbr>.go](https://go.dev/src/math/big/nat.go)*.
  prefs: []
  type: TYPE_NORMAL
- en: How secure are these square-and-multiply exponentiation algorithms? Unfortunately,
    the tricks to speed the process up often result in increased vulnerability against
    some attacks.
  prefs: []
  type: TYPE_NORMAL
- en: The weakness of these algorithms stems from the fact that the exponentiation
    operations are heavily dependent on the exponent’s value. The <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    operation in [Listing 10-5](chapter10.xhtml#Lis10-5) takes a different branch
    based on whether an exponent’s bit is 0 or 1\. If a bit is 1, an iteration of
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is slower than
    it is for 0, and attackers who monitor the execution time of the RSA operation
    can exploit this time difference to recover a private exponent. This is called
    a *timing attack*. Attacks on hardware can distinguish 1 bit from 0 bits by monitoring
    the device’s power consumption and observing which iterations perform an extra
    multiplication to reveal which bits of the private exponent are 1.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the type of platform, the information channel may not be execution
    time. For example, you might distinguish 1-bits in the exponent from 0-bits by
    measuring the device’s power consumption and observing which iterations perform
    additional multiplication, revealing the private exponent bits at 1\. This is
    a *power-analysis attack*. Few open source cryptographic libraries contain effective
    defenses against these types of attacks.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Small Exponents for
    Faster Public-Key Operations</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Because an RSA computation is essentially the computation of an exponentiation,
    its performance depends on the value of the numbers involved, in particular the
    exponent. Smaller exponents require fewer multiplications and can therefore make
    the exponentiation computation much faster.
  prefs: []
  type: TYPE_NORMAL
- en: In principle, the public exponent *e* can be any value between 3 and φ(*n*)
    – 1, as long as *e* and φ(*n*) are coprime. But in practice you’ll find only small
    values of *e*, and most of the time *e* = 65,537 due to concerns with encryption
    and signature verification speed. For example, the Microsoft Windows CryptoAPI
    supports only public exponents that fit in a 32-bit integer. The larger the *e*,
    the slower it is to compute *x**^e* mod *n.*
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the size of the public exponent, the private exponent *d* is inevitably
    about as large as *n*, making decryption much slower than encryption, and signing
    much slower than verification. Because *d* is secret, it must be unpredictable
    and therefore can’t be restricted to a small value. For example, if *e* is fixed
    to 65,537, the corresponding *d* is usually of the same order of magnitude as
    the modulus *n*, which would be close to 2^(2,048) if *n* is 2,048 bits long.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in “A Fast Exponentiation Algorithm” on [page 206](#sec14), raising
    a number to the power 65,537 takes 17 multiplications, whereas raising a number
    to the power of some 2,048-bit number takes on the order of 3,000 multiplications.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can estimate the speed of RSA by using the OpenSSL toolkit. For example,
    [Listing 10-6](chapter10.xhtml#Lis10-6) shows the results of 512-, 1,024-, 2,048-,
    and 4,096-bit RSA operations on a MacBook equipped with an M2 chipset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-6: Example benchmarks
    of RSA operations using the OpenSSL toolkit (version 3.2.0)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To get an idea of how much slower verification is compared to signature generation,
    compute the ratio of the verification time over signature time. The benchmarks
    in [Listing 10-6](chapter10.xhtml#Lis10-6) show that I’ve got verification-over-signature
    speed ratios of approximately 21.6, 40.1, and 68.7 for 1,024-, 2,048-, and 4,096-bit
    moduli, respectively. The gap grows with the modulus size because the number of
    multiplications for *e* operations remains constant with respect to the modulus
    size (for example, 17 operations when *e* = 65,537), while private-key operations
    always need more multiplications for a greater modulus because *d* grows accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'If small exponents are so nice, why use 65,537 and not something like 3? It
    would actually be fine (and faster) to use 3 as an exponent when implementing
    RSA with a secure scheme such as OAEP, PSS, or FDH. Cryptographers avoid doing
    so, however, because when *e* = 3, less secure schemes make certain types of mathematical
    attacks possible. The number 65,537 is large enough to avoid such *low-exponent
    attacks*, and it has only two nonzero bits, which decreases the computation time
    when computing *x*^(65,537). The number 65,537 is also special for mathematicians:
    it’s the fourth Fermat number, or a number of the form'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg209-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'because it’s equal to 2^(16) + 1, where 16 = 2⁴, but that’s a curiosity irrelevant
    to most cryptographic engineers.  #### <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The
    Chinese Remainder Theorem</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The most common trick to speed up decryption and signature generation (that
    is, the computation of *y**^d* mod *n*) is the *Chinese remainder theorem (CRT)*,
    which makes RSA about four times faster.
  prefs: []
  type: TYPE_NORMAL
- en: The CRT allows for faster decryption by computing two exponentiations, modulo
    *p* and modulo *q*, rather than a single one modulo *n*. Because *p* and *q* are
    much smaller than *n*, it’s faster to perform two “small” exponentiations than
    a single “big” one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Chinese remainder theorem isn’t specific to RSA. It’s a general arithmetic
    result that, in its simplest form, states that if *n* = *n*[1]*n*[2]*n*[3] . .
    . , where the *n*is are pairwise coprime (that is, **GCD**(*n*i, *n*j) = 1 for
    any distinct *i* and *j*), then one can compute the value *x* mod *n* from the
    values *x* mod *n*[1], *x* mod *n*[2], *x* mod *n*[3], . . . For example, say
    you have *n* = 1,155, which is the product of prime factors 3 × 5 × 7 × 11, and
    say you want to determine *x* that satisfies *x* mod 3 = 2, *x* mod 5 = 1, *x*
    mod 7 = 6, and *x* mod 11 = 8\. (I’ve chosen 2, 1, 6, and 8 arbitrarily.) To find
    *x* using the Chinese remainder theorem, compute the sum *P*(*n*[1]) + *P*(*n*[2])
    + . . . , where *P*(*n*i) is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg210-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the second term, *n*/*n*i, is equal to the product of all factors
    other than this *n*i.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply this formula to this example and recover *x* mod 1155, compute *P*(3),
    *P*(5), *P*(7), and *P*(11); then add them together to get the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg210-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, I’ve just applied the preceding definition of *P*(*n*i). (The math behind
    finding each number is straightforward, but I won’t detail it here.) You can then
    reduce this expression to [770 + 231 + 1980 + 1680] mod *n* = 41\. As 41 is the
    number I’d picked for this example, you’ve got the correct result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying the CRT to RSA is simpler than the previous example because there
    are only two factors for each *n* (namely, *p* and *q*). Given a ciphertext *y*
    to decrypt, instead of computing *y**^d* mod *n*, use the CRT to compute *x*p
    = *y**^s* mod *p*, where *s* = *d* mod (*p* – 1) and *x*q = *y**^t* mod *q*, where
    *t* = *d* mod (*q* – 1). Combine these two expressions and compute *x* to be the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg210-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That’s it. This is faster than a single exponentiation even with the square-and-multiply
    trick because the multiplication-heavy operations are carried out on modulo *p*
    and *q*, numbers that are twice as small as *n*, whereas the complexity of exponentiation
    increases faster than linearly. When you double the size of the number, you don’t
    just double the cost of exponentiation—it grows faster.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In the final operation, you can compute the two numbers* q *× (1/*q *mod*
    p*) and* p *× (1/*p *mod* q*) in advance, which means you need to compute only
    two multiplications and an addition of modulo* n *to find* x.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there’s a security caveat attached to these techniques.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even more elegant than the RSA scheme itself is the range of attacks that work
    either because the implementation leaks (or can be made to leak) information on
    its internals or because RSA is used insecurely. I discuss two classic examples
    of these types of attacks in the sections that follow.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Bellcore Attack
    on RSA-CRT</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The Bellcore attack on RSA is one of the most important attacks in the history
    of RSA. First discovered in 1996, it stood out because it exploited RSA’s vulnerability
    to *fault injections*—attacks that force part of the algorithm to misbehave and
    potentially yield incorrect results. For example, one may temporarily perturb
    hardware circuits or embedded systems by suddenly altering their voltage supply
    or beaming a laser pulse to a carefully chosen part of a chip. Attackers can then
    exploit the resulting faults in an algorithm’s internals by observing the impact
    on the result. Comparing the correct result with a faulty one can provide information
    on the algorithm’s internal values, including secret values. Likewise, attempts
    to learn whether the result is valid might leak exploitable information.
  prefs: []
  type: TYPE_NORMAL
- en: The Bellcore attack is such a fault attack. It works on RSA signature schemes
    that use the Chinese remainder theorem and that are deterministic—meaning it works
    on FDH but not on PSS, which is probabilistic.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand the Bellcore attack, recall from the previous section that with
    CRT, you obtain the result that’s equal to *x**^d* mod *n* by computing the following,
    where *x*p = *y**^s* mod *p* and *x*q = *y**^t* mod *q*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg211-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now assume that an attacker induces a fault in the computation of *x*q so that
    you end up with some incorrect value, which differs from the actual *x*q. Let’s
    call this incorrect value *x*q′ and the final result obtained *x*′. The attacker
    can then subtract the incorrect signature *x*′ from the correct signature *x*
    to factor *n*, which results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg211-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The value *x* – *x*′ is therefore a multiple of *p*, so *p* is a divisor of
    *x* – *x*′. Because *p* is also a divisor of *n*, the greatest common divisor
    of *n* and *x* – *x*′ yields *p*, **GCD**(*x* – *x*′, *n*) = *p*. You can then
    compute *q* = *n*/*p* and *d*, resulting in a total break of RSA signatures.
  prefs: []
  type: TYPE_NORMAL
- en: A variant of this attack works when you know only that the message is signed,
    and not the correct signature. There’s also a similar fault attack on the modulus
    value, rather than on the CRT values computation, but I won’t go into detail on
    that here.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Shared Private Exponents
    or Moduli</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now I’ll show you why your public key shouldn’t have the same modulus *n* as
    that of someone else.
  prefs: []
  type: TYPE_NORMAL
- en: Private keys belonging to different systems or people should have different
    private exponents, *d*, even if the keys use different moduli. Or you could try
    your own value of *d* to decrypt messages encrypted for other entities, until
    you hit one that shares the same *d*. By the same token, different key pairs should
    have different *n* modulus values, even if they have different *d*s, because *p*
    and *q* are usually part of the private key. Hence, if I share the same *n* and
    thus the same *p* and *q*, I can compute your private key from your public key
    *e* using *p* and *q*.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you know your private exponent *d*[1] and the public exponent *e*[2]
    of another person with whom you share the same modulus *n*, but without knowing
    its factors *p* and *q*. How can you calculate *p* and *q* from your private exponent
    *d*[1] to find the private exponent *d*[2] of the other person? The solution is
    a bit technical but elegant.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that *d* and *e* satisfy *ed* = *k*φ(*n*) + 1, where φ(*n*) is secret
    and could reveal *p* and *q*. You don’t know *k* or φ(*n*), but you can compute
    *k*φ(*n*) = *ed* – 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'What can you do with *k*φ(*n*)? According to *Euler’s theorem*, for any number
    *a* coprime with *n*, you have *a*^(φ()*^n*^) = 1 mod *n*. Therefore, modulo *n*
    you have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg212-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because *k*φ(*n*) is an even number, you can write it as 2*^s**t* for some numbers
    *s* and *t*. That is, you’ll be able to write *a**^k*^(φ()*^n*^) = 1 mod *n* under
    the form *x*² = 1 mod *n* for some *x* easily computed from *k*φ(*n*). You can
    call such an *x* a *root of unity*.
  prefs: []
  type: TYPE_NORMAL
- en: The key observation is that *x*² = 1 mod *n* is equivalent to saying that the
    value *x*² – 1 = (*x* – 1)(*x* + 1) divides *n*. In other words, *x* – 1 or *x*
    + 1 must have a common factor with *n*, which can give you the factorization of
    *n*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 10-7](chapter10.xhtml#Lis10-7) shows a Python implementation of this
    method where, to find the factors *p* and *q* from *n* and *d*, I use small, 64-bit
    numbers for the sake of simplicity.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-7: A Python program
    that computes the prime factors</samp> <samp class="SANS_Futura_Std_Book_11">p</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_11">q</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">from the private exponent</samp>
    <samp class="SANS_Futura_Std_Book_11">d</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'This program determines *k*φ(*n*) from *e* and *d* ❶ by finding the number
    *t* such that *k*φ(*n*) = 2*^s**t*, for some *s* ❷. Then it looks for *a* and
    *k* such that (*a**^k*)² = 1 mod *n* ❸, using *t* as a starting point for *k*
    ❹. When this condition is satisfied ❺, you’ve found a solution. It then determines
    the factor *p* ❻ and verifies ❼ that the value of *pq* equals the value of *n.*
    It then prints the resulting values of *p* and *q*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The program correctly returns the two factors.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RSA deserves a book by itself. I had to omit many important and interesting
    topics, such as Daniel Bleichenbacher’s padding oracle attack on OAEP’s predecessor
    (the standard PKCS#1 v1.5) or Manger’s padding oracle attack on OAEP, both attacks
    being similar in spirit to the padding oracle attack on block ciphers in [Chapter
    4](chapter4.xhtml). There’s also Michael Wiener’s attack on RSA with low private
    exponents, and attacks using Coppersmith’s method on RSA with small exponents
    that potentially also have insecure padding.
  prefs: []
  type: TYPE_NORMAL
- en: To see research results related to side-channel attacks and defenses, view the
    CHES workshop proceedings that have run since 1999 at *[https://<wbr>ches<wbr>.iacr<wbr>.org](https://ches.iacr.org)*.
    One of the most useful references while writing this chapter was Dan Boneh’s “Twenty
    Years of Attacks on the RSA Cryptosystem,” a survey that reviews and explains
    the most important attacks on RSA. For reference on timing attacks, the paper
    “Remote Timing Attacks Are Practical” by Billy Bob Brumley and Dan Boneh is a
    must-read, both for its analytical and experimental contributions. To learn more
    about fault attacks, read the full version of the Bellcore attack paper “On the
    Importance of Eliminating Errors in Cryptographic Computations” by Dan Boneh,
    Richard DeMillo, and Richard Lipton.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to learn how RSA implementations work, though sometimes painful
    and frustrating, is to review the source code of widely used implementations.
    For example, see RSA and its underlying big-number arithmetic implementations
    in OpenSSL, NSS (the library used by the Mozilla Firefox browser), Crypto++, or
    other popular software, and examine their implementations of arithmetic operations
    as well as their defenses against timing and fault attacks.
  prefs: []
  type: TYPE_NORMAL
