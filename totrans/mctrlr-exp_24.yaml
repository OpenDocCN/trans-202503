- en: '**24  Clipper Chip Diffusion ROM**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the Nineties, the Clinton administration had an obsession with key escrow
    cryptography. They wanted to provide American citizens with cryptography that
    the US government itself could break, but in a way that excluded foreign governments
    from the same privilege. This was called the Clipper chip in general, and in this
    chapter we’ll focus on the PCMCIA generation of that chip, known as the MYK82
    or Fortezza card. We’ll dump its firmware and extract it into useful bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'It worked roughly like this: suppose that Monica calls Bill for a private conversation.
    As she hits the *encrypt* button, the two telephones perform a key exchange. After
    the keys are exchanged, her phone will send Bill’s phone a bundle called the Law
    Enforcement Access Field (LEAF) containing (1) their session key encrypted with
    Monica’s personal key and (2) a checksum of the session key. The LEAF is encrypted
    with a “family key” that every Clipper device contains but which was not given
    to consumers. Every unit has the family key, but only spooky agencies with a warrant
    were able to look up Monica’s personal key and decrypt the session key.'
  prefs: []
  type: TYPE_NORMAL
- en: Astute readers will notice that these keys are all symmetric and that the scheme
    does not hold up to an attacker with control of firmware. If you had the family
    key, things might work differently. Bill could call Monica, perform the key exchange,
    and then send along a tampered LEAF with (1) a random number and (2) the checksum
    of the real session key. Her phone would validate the checksum and allow the call
    to proceed, but any spooky agencies listening in would not be able to decrypt
    the random number into a session key. Monica’s phone does not have access to the
    key escrow database, so it’s unable to know that the authorities are being tricked.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0228-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 24.1: MYK82 Chip in a Fortezza PCMCIA Card'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0229-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 24.2: MYK82 Die'
  prefs: []
  type: TYPE_NORMAL
- en: It’s also worth noting that Bill does not strictly need to know the family key.
    Without a tampered device, Bill might simply call Monica a few tens of thousands
    of times while corrupting the LEAF bundle, until the 16-bit checksum collides
    and her phone believes that the LEAF was not corrupted. Blaze (1994) describes
    such an attack, as well as a detailed explanation of the Escrowed Encryption Standard.
  prefs: []
  type: TYPE_NORMAL
- en: The MYK82 chip contained in the Fortezza card implements this protocol, with
    handy library functions for using the card in Windows and Solaris. [Figure 24.1](ch24.xhtml#ch24fig1)
    shows this chip on the card in a QFP package. This package is a little weird in
    that the lead frame is *above* the die, and the die faces downward into the PCB.
    Perhaps this is to frustrate RF emissions, as the die sits between two ground
    planes.
  prefs: []
  type: TYPE_NORMAL
- en: The die is shown in its entirety in [Figure 24.2](ch24.xhtml#ch24fig2). The
    CPU can be seen in the southwest, including an ARM6 logo that tells us we can
    expect 32-bit ARM instructions without the shortened Thumb instruction set that
    came later in ARM7\. There are three ROMs on this chip, with the largest holding
    code in the east. Two smaller ROMs hold the same Skipjack F-Table in the south
    of the chip, just a little east of center; these are exactly 256 bytes and match
    up to those in the Skipjack documentation, which has since been declassified.
  prefs: []
  type: TYPE_NORMAL
- en: The MYK82 chip, like its predecessor the MYK78, uses diffusion ROMs. These shape
    the diffusion layer beneath the transistors so that a working transistor will
    produce a one and a broken transistor will produce a zero.
  prefs: []
  type: TYPE_NORMAL
- en: Because bits are not surface visible, a delayering procedure like that in [Chapter
    22](ch22.xhtml#ch22) is needed to remove the upper layers that cover the diffusion
    layer. My usual procedure for this chip is to first burn off the packaging with
    63% nitric acid and then to delayer the chip in 5% hydrofluoric acid. Both of
    these run on a hot plate in my fume hood, but I do the HF reaction in a sealed
    plastic test tube to minimize the fumes.
  prefs: []
  type: TYPE_NORMAL
- en: Before delayering, bits can just barely be seen in aggregate at low magnification.
    This has something to do with optics and a little bit of exposure, as individual
    bits can hardly be seen at all. After delayering, bits dramatically jump out,
    visible at both high and low magnifications.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 24.3](ch24.xhtml#ch24fig3) is the ROM as a whole, and because that’s
    still a bit hard to see in print, [Figure 24.5](ch24.xhtml#ch24fig5) shows just
    the six most significant bits at the far right of the ROM. [Figure 24.4](ch24.xhtml#ch24fig4)
    shows a close up of bits. To figure out the decoding, I took those two photos
    on a flight to Bogota with no local friends and no local responsibilities. By
    the time I left, I had decoded the ROM into 32-bit words and made a few friends.^([1](footnotes.xhtml#ch24fn1))'
  prefs: []
  type: TYPE_NORMAL
- en: Our first clue was the ARM6 logo elsewhere on the die. ARM6 predates Thumb,
    so all instructions are 32 bits wide and aligned to 32-bits. We can see that the
    bottom of the ROM is quite sparse, filled in with the same color in every bit.
    These happen to be zeroes, and they correctly imply that the code is built up
    from rows at the top of the ROM.
  prefs: []
  type: TYPE_NORMAL
- en: ARM reverse engineers will tell you that 32-bit code stands out because most
    instructions begin with an `E` as the most significant nybble. If you look at
    the right six bits in [Figure 24.5](ch24.xhtml#ch24fig5), you will see that the
    each major column holds two bits. (You might also figure that out from [Figure
    24.3](ch24.xhtml#ch24fig3), where 16 major columns represent 32 bits.) The rightmost
    major column is mostly filled with ones, while the major column to its left has
    ones on the right half and zeroes on the left half. This is our `E` nybble, formed
    from the right as one, one, one, zero!
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0232-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 24.3: MYK82 Code ROM'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0232-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 24.4: MYK82 ROM Bits'
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/f0233-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 24.5: Right six bits of the MYK82 Code ROM'
  prefs: []
  type: TYPE_NORMAL
- en: Sure enough, we can find 32-bit words by taking a bit from each of the 32 minor
    columns—that’s two from each major column—with the most significant bit on the
    far right and the least significant bit on the far left. We already know that
    the program begins on the first row because of the empty, zeroed rows at the end.
    All that is left is to understand the order of the words within a given row.
  prefs: []
  type: TYPE_NORMAL
- en: Each of the rows has 512 bits to it, so we know that they contain 16 words apiece.
    To learn the order, I simply wrote a decoder that output them in order and piped
    this into a disassembler. The correct ordering was from right to left, just as
    the bits are best read from right to left.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it’s clear how to decode the ROM into 32-bit words, but to get
    them into bytes, we would like to understand the endianness. Does the most significant
    byte come first or last? This is where things get weird.
  prefs: []
  type: TYPE_NORMAL
- en: Endianness is not a matter of byte order in words, but a matter of how words
    are seen as bytes or vice versa. The internal ROM is only composed of 32-bit words
    that are never fetched in smaller sizes, so it has no endianness. The ARM6 CPU
    has no instruction to fetch bytes from ROM, but there is a wiring decision of
    the external EEPROM memory. That EEPROM contains code as big-endian bytes, and
    it is only from that that we can say the machine as a whole is big-endian.
  prefs: []
  type: TYPE_NORMAL
