<html><head></head><body>
<h2 class="h2" id="ch20"><span epub:type="pagebreak" id="page_275"/><span class="big">20</span><br/>CREATING AND CONFIGURING AN IIS WEB SERVER</h2>&#13;
<div class="image1"><img class="inline" src="../images/common.jpg" alt="Images"/></div>&#13;
<p class="noindent"><span class="bign">You’re at the last step in your automation journey: the web server. In this chapter, you’ll use <em>IIS</em>, a built-in Windows service that provides web services to clients. IIS is a server type you’ll run into often enough when you’re doing IT work—in other words, it’s an area ripe for automation!</span> As in previous chapters, first you’ll deploy an IIS web server from scratch; then you’ll focus on getting the service installed and some basic configuration applied.</p>&#13;
<h3 class="h3" id="ch20lev1">Prerequisites</h3>&#13;
<p class="noindent">By now, you should be familiar with how to get a fresh virtual machine created and set up, so we won’t be covering those steps. I’m assuming that you already have a virtual machine up and running with Windows Server <span epub:type="pagebreak" id="page_276"/>installed. If you don’t, you could leverage our existing work in the PowerLab module by running this command:</p>&#13;
<pre>PS&gt; <span class="codestrong1">New-PowerLabServer -ServerType Generic</span> &#13;
<span class="codestrong1">-DomainCredential (Import-Clixml -Path C:\PowerLab\DomainCredential.xml)</span>&#13;
<span class="codestrong1">-VMCredential (Import-Clixml -Path C:\PowerLab\VMCredential.xml) -Name WEBSRV</span></pre>&#13;
<p class="indent">Notice that you specify a <span class="literal">Generic</span> server type this time; this is because you haven’t yet added full support for web servers (the task for this chapter!).</p>&#13;
<h3 class="h3" id="ch20lev2">Installation and Setup</h3>&#13;
<p class="noindent">Once you’ve created a VM, it’s time to set up IIS. IIS is a Windows feature, and fortunately, PowerShell has a built-in command to install Windows features called <span class="literal">Add-WindowsFeature</span>. If you were doing this as a one-off test, you <em>could</em> use a single line to install IIS, but since you’re building this automation into a bigger project, you’ll install IIS just as you did SQL: by creating a function. Let’s call it <span class="literal">Install-PowerLabWebServer</span>.</p>&#13;
<p class="indent">You’ll have this function adhere to the model you created earlier when you made the <span class="literal">Install-PowerLabSqlServer</span> function. As you begin to add further server support to this project, you’ll see how creating a function for even just a single line of code will make using the module, and changing it, much, much easier!</p>&#13;
<p class="indent">The easiest way to mirror the <span class="literal">Install-PowerLabSqlServer</span> function as closely as possible is to take the “skeleton” of the function by removing any of the SQL Server–specific code. Normally, I’d recommend reusing an existing function instead of building another one, but in this case, you have a completely different “object:” a SQL Server versus an IIS server. It makes more sense to have a different function. In <a href="ch20.xhtml#ch20list1">Listing 20-1</a>, you simply copy the <span class="literal">Install-PowerLabSqlServer</span> function but remove the “guts” while keeping all of the common parameters (you exclude the <span class="literal">AnswerFilePath</span> and <span class="literal">IsoFilePath</span> parameters since IIS doesn’t need them).</p>&#13;
<pre>function Install-PowerLabWebServer {&#13;
    param&#13;
    (&#13;
&#13;
        [Parameter(Mandatory)]&#13;
        [string]$ComputerName,&#13;
&#13;
        [Parameter(Mandatory)]&#13;
        [pscredential]$DomainCredential&#13;
    )&#13;
&#13;
    $session = New-PSSession -VMName $ComputerName -Credential $DomainCredential&#13;
&#13;
    $session | Remove-PSSession&#13;
}</pre>&#13;
<p class="caption" id="ch20list1"><em>Listing 20-1: The “skeleton” <span class="literal">Install-PowerLabWebServer</span> function</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_277"/>As for actually setting up the IIS service, that’s a piece of cake: you simply need to run one command that installs the <span class="literal">Web-Server</span> feature. Go ahead and add that line into your <span class="literal">Install-PowerLabWebServer</span> function (<a href="ch20.xhtml#ch20list2">Listing 20-2</a>).</p>&#13;
<pre>function Install-PowerLabWebServer {&#13;
    param&#13;
    (&#13;
&#13;
        [Parameter(Mandatory)]&#13;
        [string]$ComputerName,&#13;
&#13;
        [Parameter(Mandatory)]&#13;
        [pscredential]$DomainCredential&#13;
    )&#13;
&#13;
    $session = New-PSSession -VMName $ComputerName -Credential $DomainCredential&#13;
&#13;
    $null = Invoke-Command -Session $session -ScriptBlock { Add-WindowsFeature -Name 'Web-Server' }&#13;
&#13;
    $session | Remove-PSSession&#13;
}</pre>&#13;
<p class="caption" id="ch20list2"><em>Listing 20-2: The <span class="literal">Install-PowerLabWebServer</span> function</em></p>&#13;
<p class="indent">The start of your <span class="literal">Install-PowerLabWebServer</span> function is complete! Let’s add more code to it.</p>&#13;
<h3 class="h3" id="ch20lev3">Building Web Servers from Scratch</h3>&#13;
<p class="noindent">Now that you have an install function for IIS, it’s time to update your <span class="literal">New-PowerLabServer</span> function. Recall in <a href="ch19.xhtml#ch19">Chapter 19</a> that when you were refactoring your <span class="literal">New-PowerLabServer</span> function, you were forced to use placeholder code for the web server parts because you didn’t have the functionality needed. You used the line <span class="literal">Write-Host 'Web server deployments are not</span> <span class="literal">supported</span><span class="literal"> at this</span> <span class="literal">time'</span> as filler code. Now’s let’s replace that text with a call to your newly created <span class="literal">Install-PowerLabWebServer</span> function:</p>&#13;
<pre>PS&gt; <span class="codestrong1">Install-PowerLabWebServer –ComputerName $Name –DomainCredential $DomainCredential</span></pre>&#13;
<p class="indent">Once you do this, you can bring up web servers the same way you do SQL servers!</p>&#13;
<h3 class="h3" id="ch20lev4">The WebAdministration Module</h3>&#13;
<p class="noindent">Once you have a web server up and running, you need to do something with it. When the <span class="literal">Web-Server</span> feature is enabled on a server, a PowerShell module called <span class="literal">WebAdministration</span> is installed. This module contains the many commands needed to handle IIS objects. The <span class="literal">Web-Server</span> feature also creates a PowerShell drive called IIS that allows you to manage common IIS objects (websites, application pools, and so forth).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_278"/>A <em>PowerShell drive</em> allows you to navigate data sources just like a filesystem. You’ll see next that you can manipulate websites, application pools, and many other IIS objects exactly as you would files and folders by using common cmdlets like <span class="literal">Get-Item</span>, <span class="literal">Set-Item</span>, and <span class="literal">Remove-Item</span>.</p>&#13;
<p class="indent">To make the IIS drive available, you first have to import the <span class="literal">WebAdministration</span> module. Let’s remote into your newly created web server and play around with the module a bit to see what you can do.</p>&#13;
<p class="indent">First, you’ll create a new PowerShell Direct session and enter it interactively. Previously, you were mostly using <span class="literal">Invoke-Command</span> to send commands to VMs. Now, since you’re just investigating what’s possible with IIS, you use <span class="literal">Enter-PSSession</span> to interactively work inside of the session:</p>&#13;
<pre>PS&gt; <span class="codestrong1">$session = New-PSSession -VMName WEBSRV</span> &#13;
<span class="codestrong1">-Credential (Import-Clixml -Path C:\PowerLab\DomainCredential.xml)</span>&#13;
PS&gt; <span class="codestrong1">Enter-PSSession -Session $session</span>&#13;
[WEBSRV]: PS&gt; <span class="codestrong1">Import-Module WebAdministration</span></pre>&#13;
<p class="indent">Notice the <span class="literal">[WEBSRV]</span> in front of the final prompt. This is a signal that you’re now working on the WEBSRV host and can import the <span class="literal">WebAdministration</span> module. Once the module is imported into the session, you can verify that the IIS drive is created by running <span class="literal">Get-PSDrive</span>:</p>&#13;
<pre>[WEBSRV]: PS&gt; <span class="codestrong1">Get-PSDrive -Name IIS | Format-Table -AutoSize</span>&#13;
&#13;
Name Used (GB) Free (GB) Provider          Root     CurrentLocation&#13;
---- --------- --------- --------          ----     ---------------&#13;
IIS                      WebAdministration \\WEBSRV</pre>&#13;
<p class="indent">You can peruse this drive as you can any other PowerShell drive: by treating it like a filesystem and using commands such as <span class="literal">Get-ChildItem</span> to list items in the drive, <span class="literal">New-Item</span> to create new items, and <span class="literal">Set-Item</span> to modify items. But doing all that work isn’t automating; it’s just managing IIS via the command line. And you’re here to automate stuff! The only reason I’m mentioning the IIS drive now is that it will come in handy for automation tasks later, and it’s always good to know how to do things manually, in case you need to troubleshoot automation when it goes awry.</p>&#13;
<h4 class="h4" id="ch20lev4sec1">Websites and Application Pools</h4>&#13;
<p class="noindent">The commands in the <span class="literal">WebAdministration</span> module manage and automate just about every facet of IIS. You’ll begin by looking at how to handle websites and applications, as websites and application pools are two of the most common components that system administrators work with in the real world.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_279"/>Websites</h5>&#13;
<p class="noindent">You’ll start with a simple command: <span class="literal">Get-Website</span>, which lets you query IIS and returns all websites that currently exist on a web server:</p>&#13;
<pre>[WEBSRV]: PS&gt; <span class="codestrong1">Get-Website -Name 'Default Web Site'</span>&#13;
&#13;
Name             ID   State      Physical Path                  Bindings&#13;
----             --   -----      -------------                  --------&#13;
Default Web Site 1    Started    %SystemDrive%\inetpub\wwwroot  http *:80:</pre>&#13;
<p class="indent">You’ll notice that you already created a website. This is because IIS has a website called Default Web Site when it is installed. But let’s say you don’t want this default website and would rather create your own. You can remove it by piping the output of <span class="literal">Get-Website</span> to <span class="literal">Remove-Website</span>:</p>&#13;
<pre>[WEBSRV]: PS&gt; <span class="codestrong1">Get-Website -Name 'Default Web Site' | Remove-Website</span>&#13;
[WEBSRV]: PS&gt; <span class="codestrong1">Get-Website</span>&#13;
[WEBSRV]: PS&gt;</pre>&#13;
<p class="indent">If you want to create a website, you can do so just as easily by using the <span class="literal">New-Website</span> command:</p>&#13;
<pre>[WEBSRV]: PS&gt; <span class="codestrong1">New-Website -Name PowerShellForSysAdmins</span>&#13;
<span class="codestrong1">-PhysicalPath C:\inetpub\wwwroot\</span>&#13;
&#13;
Name             ID   State      Physical Path                  Bindings&#13;
----             --   -----      -------------                  --------&#13;
PowerShellForSys 1052 Stopped    C:\inetpub\wwwroot\            http *:80:&#13;
Admins           6591</pre>&#13;
<p class="indent">If the website’s bindings are off, and you want to change them (say you want to bind to a nonstandard port), you can use the <span class="literal">Set-WebBinding</span> command:</p>&#13;
<pre>[WEBSRV]: PS&gt; <span class="codestrong1">Set-WebBinding -Name 'PowerShellForSysAdmins'</span>&#13;
<span class="codestrong1">-BindingInformation "*:80:" -PropertyName Port -Value 81</span>&#13;
[WEBSRV]: PS&gt; <span class="codestrong1">Get-Website -Name PowerShellForSysAdmins</span>&#13;
&#13;
Name             ID   State      Physical Path                  Bindings&#13;
----             --   -----      -------------                  --------&#13;
PowerShellForSys 1052 Started    C:\inetpub\wwwroot\            http *:81:&#13;
Admins           6591&#13;
                 05</pre>&#13;
<p class="indent">You’ve seen a lot of what you can do with websites. Let’s check out what’s possible with application pools.</p>&#13;
<h5 class="h5"><span epub:type="pagebreak" id="page_280"/>Application Pools</h5>&#13;
<p class="noindent"><em>Application pools</em> allow you to isolate your applications from one another, even if they are running on the same server. This way, if an error exists in one app, it won’t take down other applications.</p>&#13;
<p class="indent">The commands for application pools are similar to those for websites, as you can see in the following code. Since I have only a single application pool, only the <span class="literal">DefaultAppPool</span> shows up for me. If you run this command on your own web server, you may see more:</p>&#13;
<pre>[WEBSRV]: PS&gt; <span class="codestrong1">Get-IISAppPool</span>&#13;
&#13;
Name                 Status       CLR Ver  Pipeline Mode  Start Mode&#13;
----                 ------       -------  -------------  ----------&#13;
DefaultAppPool       Started      v4.0     Integrated     OnDemand&#13;
&#13;
[WEBSRV]: PS&gt; <span class="codestrong1">Get-Command -Name *apppool*</span>&#13;
&#13;
CommandType     Name                              Version    Source&#13;
-----------     ----                              -------    ------&#13;
Cmdlet          Get-IISAppPool                    1.0.0.0    IISAdministration&#13;
Cmdlet          Get-WebAppPoolState               1.0.0.0    WebAdministration&#13;
Cmdlet          New-WebAppPool                    1.0.0.0    WebAdministration&#13;
Cmdlet          Remove-WebAppPool                 1.0.0.0    WebAdministration&#13;
Cmdlet          Restart-WebAppPool                1.0.0.0    WebAdministration&#13;
Cmdlet          Start-WebAppPool                  1.0.0.0    WebAdministration&#13;
Cmdlet          Stop-WebAppPool                   1.0.0.0    WebAdministration</pre>&#13;
<p class="indent">Since you already created a website, let’s see how to create an app pool and assign it to your website. To create an app pool, use the <span class="literal">New-WebAppPool</span> command, as shown in <a href="ch20.xhtml#ch20list3">Listing 20-3</a>.</p>&#13;
<pre>[WEBSRV]: PS&gt; <span class="codestrong1">New-WebAppPool -Name 'PowerShellForSysAdmins'</span>&#13;
&#13;
Name                     State        Applications&#13;
----                     -----        ------------&#13;
PowerShellForSysAdmins   Started</pre>&#13;
<p class="caption" id="ch20list3"><em>Listing 20-3: Creating an app pool</em></p>&#13;
<p class="indent">Unfortunately, not all IIS tasks have a built-in cmdlet. To assign the app pool to an existing website, you have to use <span class="literal">Set-ItemProperty</span> and change the website in the IIS drive <span class="ent">❶</span> (as shown next). To apply that update, you need to stop <span class="ent">❷</span> and restart <span class="ent">❸</span> the website.</p>&#13;
<pre><span class="ent">❶</span> [WEBSRV]: PS&gt; <span class="codestrong1">Set-ItemProperty -Path 'IIS:\Sites\PowerShellForSysAdmins'</span>&#13;
   <span class="codestrong1">-Name 'ApplicationPool' -Value 'PowerShellForSysAdmins'</span>&#13;
<span class="ent">❷</span> [WEBSRV]: PS&gt; <span class="codestrong1">Get-Website -Name PowerShellForSysAdmins | Stop-WebSite</span>&#13;
<span class="ent">❸</span> [WEBSRV]: PS&gt; <span class="codestrong1">Get-Website -Name PowerShellForSysAdmins | Start-WebSite</span>&#13;
   [WEBSRV]: PS&gt; <span class="codestrong1">Get-Website -Name PowerShellForSysAdmins |</span> &#13;
   <span class="codestrong1">   Select-Object -Property applicationPool</span>&#13;
   <span epub:type="pagebreak" id="page_281"/>applicationPool&#13;
   ---------------&#13;
   PowerShellForSysAdmins</pre>&#13;
<p class="indent">You can also see that you can confirm that the app pool was changing by looking at the <span class="literal">applicationPool</span> property returned from running <span class="literal">Get-Website</span>.</p>&#13;
<h3 class="h3" id="ch20lev5">Configuring SSL on a Website</h3>&#13;
<p class="noindent">Now that you’ve seen the commands for working with IIS, let’s go back to your PowerLab module and write a function that will install an IIS certificate and change the binding to port 443.</p>&#13;
<p class="indent">You can either get a “real” certificate from a valid certificate authority or create a self-signed certificate by using the <span class="literal">New-SelfSignedCertificate</span> function. Because I’m just demonstrating this concept, let’s create a self-signed certificate for now and use that.</p>&#13;
<p class="indent">First, lay out the function and specify all the parameters you need (<a href="ch20.xhtml#ch20list4">Listing 20-4</a>).</p>&#13;
<pre>function New-IISCertificate {&#13;
    param(&#13;
&#13;
            [Parameter(Mandatory)]&#13;
            [string]$WebServerName,&#13;
&#13;
            [Parameter(Mandatory)]&#13;
            [string]$PrivateKeyPassword,&#13;
&#13;
            [Parameter()]&#13;
            [string]$CertificateSubject = 'PowerShellForSysAdmins',&#13;
&#13;
            [Parameter()]&#13;
            [string]$PublicKeyLocalPath = 'C:\PublicKey.cer',&#13;
&#13;
            [Parameter()]&#13;
            [string]$PrivateKeyLocalPath = 'C:\PrivateKey.pfx',&#13;
&#13;
            [Parameter()]&#13;
            [string]$CertificateStore = 'Cert:\LocalMachine\My'&#13;
    )&#13;
    ## The code covered in the following text will go here&#13;
&#13;
}</pre>&#13;
<p class="caption" id="ch20list4"><em>Listing 20-4: The start of <span class="literal">New-IISCertificate</span></em></p>&#13;
<p class="indent">The first thing this function needs to do is create a self-signed certificate. You can do so with the <span class="literal">New-SelfSignedCertificate</span> command, which imports the certificate into the local computer’s <span class="literal">LocalMachine</span> <em>certificate store</em>, where all the computer’s certificates are housed. When you call <span class="literal">New-Self</span><span class="literal">SignedCertificate</span>, you can pass a <span class="literal">Subject</span> parameter to store a string that will <span epub:type="pagebreak" id="page_282"/>give you information about what the certificate is. Generating the certificate will also import it into the local computer.</p>&#13;
<p class="indent"><a href="ch20.xhtml#ch20list5">Listing 20-5</a> provides the line you’ll use to generate the certificate using the passed-in subject (<span class="literal">$CertificateSubject</span>). Remember that you can use the <span class="literal">$null</span> variable to store the results of a command so that it doesn’t output anything to the console.</p>&#13;
<pre>$null = New-SelfSignedCertificate -Subject $CertificateSubject</pre>&#13;
<p class="caption" id="ch20list5"><em>Listing 20-5: Creating a self-signed certificate</em></p>&#13;
<p class="indent">Once the certificate is created, you need to do two things: get the thumbprint of the certificate, and export the private key from the certificate. A certificate <em>thumbprint</em> is a string that uniquely identifies the certificate; the certificate’s <em>private key</em> is used to encrypt and decrypt the data sent to your server (I won’t go into the details here).</p>&#13;
<p class="indent">You could have gotten the thumbprint from <span class="literal">New-SelfSignedCertificate</span>’s output, but we’re assuming that this certificate is going to be used on a computer other than the one you created it on, as that’s the more realistic scenario. To handle this, you first need to export the public key from your self-signed certificate, which you can do by using the <span class="literal">Export-Certificate</span> command:</p>&#13;
<pre>$tempLocalCert = Get-ChildItem -Path $CertificateStore | &#13;
    Where-Object {$_.Subject -match $CertificateSubject } &#13;
$null = $tempLocalCert | Export-Certificate -FilePath $PublicKeyLocalPath</pre>&#13;
<p class="indent">The preceding command will give you a <em>.cer</em> public key file, which you can use, along with some .NET magic, to temporarily import the certificate and retrieve the thumbprint:</p>&#13;
<pre>$certPrint = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2&#13;
$certPrint.Import($PublicKeyLocalPath)&#13;
$certThumbprint = $certprint.Thumbprint</pre>&#13;
<p class="indent">Now that you have the certificate’s thumbprint, you need to export the private key, which you’ll use to attach to the SSL binding on the web server. Here are the commands for exporting the private key:</p>&#13;
<pre>$privKeyPw = ConvertTo-SecureString -String $PrivateKeyPassword -AsPlainText -Force&#13;
$null = $tempLocalCert | Export-PfxCertificate -FilePath $PrivateKeyLocalPath -Password $privKeyPw</pre>&#13;
<p class="indent">Once you have a private key, you can import your certificate into a certificate store on the web server by using the <span class="literal">Import-PfxCertificate</span> command. First, though, you need to check whether it was already imported. This is why you had to get the thumbprint earlier. You can use a certificate’s unique thumbprints to verify whether it already exists on the web server.</p>&#13;
<p class="indent">To import your certificate, you need to use a few of the commands you saw earlier in the chapter: you’ll create a PowerShell direct session, import the <span class="literal">WebAdministration</span> module, check whether the certificate exists, and then <span epub:type="pagebreak" id="page_283"/>add it if it doesn’t. You’ll leave the last step out for now, and write up the code to do the rest in <a href="ch20.xhtml#ch20list6">Listing 20-6</a>.</p>&#13;
<pre>$session = New-PSSession –VMName $WebServerName &#13;
–Credential (Import-CliXml –Path C:\PowerLab\DomainCredential.xml)&#13;
&#13;
Invoke-Command –Session $session –ScriptBlock {Import-Module –Name&#13;
WebAdministration}&#13;
&#13;
if (Invoke-Command –Session $session –ScriptBlock { $using:certThumbprint –in&#13;
(Get-ChildItem –Path Cert:\LocalMachine\My).Thumbprint}) {&#13;
      Write-Warning –Message 'The Certificate has already been imported.'&#13;
} else {&#13;
      # Code for importing the certificate&#13;
}</pre>&#13;
<p class="caption" id="ch20list6"><em>Listing 20-6: Checking whether the certificate already exists</em></p>&#13;
<p class="indent">The first two lines of code should be familiar from earlier in the chapter, but notice that you have to use <span class="literal">Invoke-Command</span> to import the module remotely. Likewise, since you’re using a local variable inside the scriptblock in your <span class="literal">if</span> statement, you need to use the <span class="literal">$using:</span> prefix to expand the variable on the remote machine.</p>&#13;
<p class="indent">Let’s fill in the code for the <span class="literal">else</span> statement in <a href="ch20.xhtml#ch20list7">Listing 20-7</a>. You need to do four things to finish setting up the IIS certificate. First, you need to copy the private key to the web server. Then you need to import the private key by using <span class="literal">Import-PfxCertificate</span>. Lastly, you need to set the SSL binding and then force it to use the private key:</p>&#13;
<pre>Copy-Item -Path $PrivateKeyLocalPath -Destination 'C:\' -ToSession $session&#13;
&#13;
Invoke-Command -Session $session -ScriptBlock { Import-PfxCertificate &#13;
-FilePath $using:PrivateKeyLocalPath -CertStoreLocation&#13;
$using:CertificateStore -Password $using:privKeyPw }&#13;
&#13;
Invoke-Command -Session $session -ScriptBlock { Set-ItemProperty "IIS:\Sites&#13;
\PowerShellForSysAdmins" -Name bindings&#13;
-Value @{protocol='https';bindingInformation='*:443:*'} }&#13;
&#13;
Invoke-Command -Session $session -ScriptBlock {&#13;
    $cert = Get-ChildItem -Path $CertificateStore | &#13;
        Where-Object { $_.Subject -eq "CN=$CertificateSubject" }&#13;
    $cert | New-Item 'IIS:\SSLBindings\0.0.0.0!443' &#13;
}</pre>&#13;
<p class="caption" id="ch20list7"><em>Listing 20-7: Binding an SSL certificate to an IIS</em></p>&#13;
<p class="indent">One thing to point out about this code is that you set the site binding on your website to use port 443 instead of port 80. You do this to ensure that the website adheres to the typical SSL port of 443, allowing web browsers to understand that you’re using encrypting web traffic.</p>&#13;
<p class="indent">At this point, you’re finished! You have successfully installed a self-signed certificate on the web server, created the SSL binding for your site, <span epub:type="pagebreak" id="page_284"/>and forced the SSL binding to use your certificate! The only thing left to do is clean up the session you’ve been working in:</p>&#13;
<pre>$session | Remove-PSSession</pre>&#13;
<p class="indent">After your session is cleaned up, you can browse to <em>https://&lt;webservername</em><em>&gt;</em> and you’ll be prompted to trust the certificate. All browsers will do this because you issued a self-signed certificate, and not one issued by a public certificate authority. Once you trust the certificate, you’ll be presented with the default IIS web page.</p>&#13;
<p class="indent">Be sure to check out the <span class="literal">New-IISCertificate</span> function inside the PowerLab module to see all these commands in one place.</p>&#13;
<h3 class="h3" id="ch20lev6">Summary</h3>&#13;
<p class="noindent">This chapter covered yet another type of server, the web server. You learned how to create a web server from scratch, exactly the same way as you create SQL servers. You also learned some of the commands inside the <span class="literal">WebAdministration</span> module that comes with IIS. You learned how to use built-in commands to perform many basic tasks as well as looked at the IIS PowerShell drive that’s created. To wrap up the chapter, you followed, in detail, a real-world scenario that required piecing together many of the commands and techniques covered earlier.</p>&#13;
<p class="indent">If you’ve made it through this entire book, congratulations! We covered a lot of ground and I’m glad you stuck around. The skills you’ve learned and the projects you built should give you a foundation to solve problems with PowerShell. Take what you’ve learned here, close the book, and get to scripting. Just start somewhere and automate it with PowerShell. The only way you’ll truly master the concepts covered in this book is by practicing. There’s no better than time than now!</p>&#13;
</body></html>