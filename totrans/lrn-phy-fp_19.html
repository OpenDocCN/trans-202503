<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch17"><span epub:type="pagebreak" id="page_307"/><span class="big">17</span><br/>SATELLITE, PROJECTILE, AND PROTON MOTION</h2>&#13;
<div class="image1"><img src="Images/common.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">This chapter discusses three extended examples that use the ideas and code from <a href="ch16.xhtml">Chapter 16</a> to express and solve Newtonian mechanics problems that involve one object. The examples are satellite motion, projectile motion with air resistance, and a proton in a uniform magnetic field. We’ll show how to make plots and animations for each of these examples. Note that we will not begin a new module in this chapter; instead, we’ll add to the <span class="literal">Mechanics3D</span> module we started in the last chapter.</p>&#13;
<h3 class="h3" id="ch17lev1">Satellite Motion</h3>&#13;
<p class="noindent">As an initial example of satellite motion, consider the following: Earth orbits the sun because of the attractive force of gravity between them. Strictly speaking, Earth and the sun each orbit a point located between the two bodies. This point, called the <em>center of mass</em>, is much closer to the more massive sun than it is to the less massive Earth, so it’s a decent approximation to <span epub:type="pagebreak" id="page_308"/>say that Earth orbits the sun. In <a href="ch19.xhtml">Chapter 19</a>, we’ll treat universal gravity as a two-body force: both the sun and Earth will accelerate in response to it, and both bodies will orbit about the center of mass. In this chapter, however, we’re interested in the motion of a single object, say Earth, and we’ll treat the force of gravity on Earth by the sun as a one-body force. This means we’ll regard the sun as merely a piece of furniture whose role is to produce a force of gravity on Earth, but it will not partake in the full dance by feeling a force and exhibiting changed motion as a result.</p>&#13;
<p class="indent">For the satellite motion in this chapter, we’ll only pay attention to the satellite. The larger planet or star around which the satellite orbits is imagined to be fixed in place; its only job is creating a force of gravity on the satellite.</p>&#13;
<p class="indent">Halley’s comet orbits the sun, making one orbit every 75 years or so. The orbit is quite elliptical, with the comet traveling quickly when it’s close to the sun and slowly when it’s far away. In 1986, Halley’s comet was close to the sun, and consequently close enough to Earth to be seen without a telescope. It is expected again in our neighborhood in 2061.</p>&#13;
<p class="indent">Let’s animate the orbit of Halley’s comet around the sun. In <a href="ch16.xhtml">Chapter 16</a>, we described how to produce an animation. We need five pieces of information for the <span class="literal">simulateGloss</span> or <span class="literal">simulateVis</span> function: a time-scale factor, an animation rate, an initial state, a display function, and a state-update function. We’ll describe these now, starting with the pieces of information that have the most physical content.</p>&#13;
<h4 class="h4" id="ch17lev2">State-Update Function</h4>&#13;
<p class="noindent">The state-update function <span class="literal">halleyUpdate</span> can be written using <span class="literal">updatePS</span>, shown in <a href="ch16.xhtml#ch16fig3">Figure 16-3</a> and defined in <a href="ch16.xhtml">Chapter 16</a>, which requires a numerical method and a list of one-body forces. The function <span class="literal">halleyUpdate</span>, and all of the code in this chapter and the next that is not part of a stand-alone program, is part of the <span class="literal">Mechanics3D</span> module we began in <a href="ch16.xhtml">Chapter 16</a> and should be in the same source code file.</p>&#13;
<pre>halleyUpdate :: TimeStep&#13;
             -&gt; ParticleState -&gt; ParticleState&#13;
halleyUpdate dt&#13;
    = updatePS (eulerCromerPS dt) [sunGravity]</pre>&#13;
<p class="indent">For our numerical method, we’ll choose the Euler-Cromer method. Recall that for animation, we won’t choose the time step of the numerical method directly but rather through the time-scale factor and animation rate we choose later. The time step <span class="literal">dt</span> appears as an input to <span class="literal">halleyUpdate</span>, and we pass <span class="literal">dt</span> along to <span class="literal">eulerCromerPS</span> to form the numerical method. The list of one-body forces contains only the sun’s force of gravity.</p>&#13;
<h4 class="h4" id="ch17lev3"><span epub:type="pagebreak" id="page_309"/>Initial State</h4>&#13;
<p class="noindent">The initial state <span class="literal">halleyInitial</span> determines whether we get a circular orbit, an elliptical orbit, or a satellite moving so fast that it escapes the gravitational pull of the sun. The mass of Halley’s comet is 2.2 × 10<sup>14</sup> kg. The net charge of the comet is zero, and we start our clock at zero as well. It’s the initial position and velocity that will determine the subsequent orbit. I’ve chosen the initial position to be on the positive x-axis at the closest distance that the comet comes to the sun, which is 8.766 × 10<sup>10</sup> m. When Halley’s comet is closest to the sun, it’s moving the fastest it will move in the course of its orbit, 54,569 m/s, in a direction perpendicular to the line connecting the comet with the sun. We call this direction the y-direction. Placing all of this information into the <span class="literal">ParticleState</span> data type, we arrive at the following expression for the initial state <span class="literal">halleyInitial</span>:</p>&#13;
<pre>halleyInitial :: ParticleState&#13;
halleyInitial = ParticleState { mass     = 2.2e14            -- kg&#13;
                              , charge   = 0&#13;
                              , time     = 0&#13;
                              , posVec   = 8.766e10 *^ iHat  -- m&#13;
                              , velocity = 54569 *^ jHat }   -- m/s</pre>&#13;
<h4 class="h4" id="ch17lev4">Time-Scale Factor</h4>&#13;
<p class="noindent"><a href="ch17.xhtml#ch17list1">Listing 17-1</a> shows the time-scale factor, animation rate, and display function and gives a stand-alone program for a 2D animation of satellite motion using <span class="literal">gloss</span>.</p>&#13;
<pre id="ch17list1">{-# OPTIONS -Wall #-}&#13;
&#13;
import SimpleVec&#13;
    ( xComp, yComp )&#13;
import Mechanics3D&#13;
    ( ParticleState(..), simulateGloss, disk, halleyInitial, halleyUpdate )&#13;
import Graphics.Gloss&#13;
    ( Picture(..), pictures, translate, red, yellow )&#13;
&#13;
diskComet :: Picture&#13;
diskComet = Color red (disk 10)&#13;
&#13;
diskSun :: Picture&#13;
diskSun = Color yellow (disk 20)&#13;
&#13;
halleyPicture :: ParticleState -&gt; Picture&#13;
&#13;
halleyPicture (ParticleState _m _q _t r _v)&#13;
    = pictures [diskSun, translate xPixels yPixels diskComet]&#13;
          where&#13;
            pixelsPerMeter = 1e-10&#13;
            xPixels = pixelsPerMeter * realToFrac (xComp r)&#13;
            yPixels = pixelsPerMeter * realToFrac (yComp r)&#13;
&#13;
main :: IO ()&#13;
main = simulateGloss (365.25 * 24 * 60 * 60) 400&#13;
       halleyInitial halleyPicture halleyUpdate</pre>&#13;
<p class="listing"><em>Listing 17-1: Stand-alone program for a 2D animation of Halley’s comet in orbit around the sun</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_310"/>We begin by turning on warnings. Then we import the functions we need from the <span class="literal">SimpleVec</span> module of <a href="ch10.xhtml">Chapter 10</a>, the <span class="literal">Mechanics3D</span> module we began in <a href="ch16.xhtml">Chapter 16</a> and continue to add to in this chapter and the next, and the <span class="literal">Graphics.Gloss</span> module. The pictures <span class="literal">diskComet</span> and <span class="literal">diskSun</span> are markers for Halley’s comet and the sun, respectively. The display function <span class="literal">halleyPicture</span> is one of the five ingredients needed for an animation, and it uses the comet’s state to translate the comet marker to the appropriate position. The sun is displayed at the origin and does not move. In the <span class="literal">main</span> function, we choose a time-scale factor of <span class="literal">365.25 * 24 * 60 * 60</span> so that one year of physical time is one second of animation time. Since the period of Halley’s comet is about 75 years, it will take about a minute and 15 seconds for the animation to show a complete orbit.</p>&#13;
<h4 class="h4" id="ch17lev5">Animation Rate</h4>&#13;
<p class="noindent">For animations in general, I recommend starting with an animation rate of about 20 frames/second. For Halley’s comet, that gives a time step of 1/20 of a year, much smaller than 75 years, which appears to be the important time scale of the situation. If you use 20 frames/second instead of the 400 frames/second shown in <a href="ch17.xhtml#ch17list1">Listing 17-1</a>, you’ll notice that the orbit has some funny properties. Halley’s comet just wanders off the screen and doesn’t come back to go around the sun, at least not in anything close to 75 seconds. The trouble is that the comet moves very quickly when it is close to the sun, and relatively slowly when it is far away.</p>&#13;
<p class="indent">An accurate calculation requires a relatively small time step when the comet is close to the sun, moving rapidly, and changing direction quickly. The time step for the rest of the orbit could be substantially larger without doing any damage. There are some numerical methods that use a variable time step, but they are beyond the scope of this book. We need to increase the animation rate or decrease the time-scale factor in order to use a time step small enough to maintain accuracy during the short period of closest approach. Trying out different animation rates suggests that 400 frames/second is probably sufficient to give reasonably accurate results.</p>&#13;
<h4 class="h4" id="ch17lev6"><span epub:type="pagebreak" id="page_311"/>Display Function</h4>&#13;
<p class="noindent"><a href="ch17.xhtml#ch17fig1">Figure 17-1</a> shows one frame of the animation of Halley’s comet around the sun. In this snapshot, the sun is shown in gray at the right of the figure, while Halley’s comet moves to the left, away from the sun. The animation we are writing produces a yellow sun and and a red comet.</p>&#13;
<div class="imagel" id="ch17fig1"><img src="Images/311fig01.jpg" alt="Image" width="557" height="315"/></div>&#13;
<p class="figcap"><em>Figure 17-1: Halley’s comet moving away from the sun</em></p>&#13;
<p class="indent">The display function <span class="literal">halleyPicture</span> needs to describe how to produce a picture from a state. The main thing we want to show is the position of the comet. The comet moves in the <em>z</em> = 0 plane, so we just need to deal with the x- and y-components of position in this function. The <span class="literal">halleyPicture</span> function in <a href="ch17.xhtml#ch17list1">Listing 17-1</a> uses pattern matching on the input to assign the local variable <span class="literal">r</span> to the position of the current state of the comet. Position is the only state variable that the display function cares about; velocity or mass play no role in determining how the picture looks. We use the <span class="literal">xComp</span> and <span class="literal">yComp</span> functions from the <span class="literal">SimpleVec</span> module of <a href="ch10.xhtml">Chapter 10</a> to extract the x- and y-components of the position.</p>&#13;
<p class="indent">The <span class="literal">where</span> keyword is similar to the <span class="literal">let</span> keyword, allowing the code writer to define local variables and functions; however, <span class="literal">where</span> and its local names come after the body of the principal function rather than before it.</p>&#13;
<p class="indent">The <span class="literal">realToFrac</span> function converts real numbers with type <span class="literal">R</span> into real numbers with type <span class="literal">Float</span> because <span class="literal">gloss</span>’s <span class="literal">translate</span> function requires <span class="literal">Float</span>s as input. The final picture produced contains a yellow disk to represent the sun and a red disk, translated to the appropriate place, to represent the comet. The <span class="literal">pictures</span> function in <span class="literal">gloss</span> produces a single picture from a list of pictures.</p>&#13;
<p class="indent">Spatial scaling needs to take place in the display function. Physical sizes are expressed in meters, while <span class="literal">gloss</span> sizes are expressed in pixels. Thus, we need to specify how this conversion is to be done. One natural scaling strategy is to show everything to scale, using a single overall scaling factor to convert meters to pixels. The <span class="literal">scale</span> function in <span class="literal">gloss</span> is excellent for this purpose because it can take as input a picture with all lengths in meters and produce <span epub:type="pagebreak" id="page_312"/>another picture scaled by the number of pixels per meter that we want. But in the Halley animation, if we try to show everything to scale, using accurate values in meters for the two radii and the position of the comet and one overall scaling factor from meters to pixels, we will not be able to see the comet or the sun because the distance over which the comet roams is so vast.</p>&#13;
<p class="indent">Since we can’t show the sizes of the sun and comet to scale, the yellow and red disks act only as markers for the location of the sun and comet; the sizes of these disks are not to scale with the orbital motion or with each other. It is easiest to specify the radii of the sun and comet in pixels rather than in meters, which would need to be scaled to pixels and scaled by a different factor than the comet position. The pictures <span class="literal">diskComet</span> and <span class="literal">diskSun</span> specify the radii for these two disks to be 10 pixels and 20 pixels, respectively. We won’t scale these radii any more. These two pictures make use of the <span class="literal">disk</span> function, which we defined in <a href="ch13.xhtml">Chapter 13</a> and repeat here:</p>&#13;
<pre>disk :: Float -&gt; G.Picture&#13;
disk radius = G.ThickCircle (radius/2) radius</pre>&#13;
<p class="indent">Another reason I’d rather specify the radii in pixels is that spatial scaling is often determined by trial and error, reducing or expanding the size of an animation that’s working. If this trial-and-error scaling is done on the entire picture, involving both the orbit size and the radii, it’s easy to shrink the radii too much so that the disks can’t be seen, or to expand the radii too much so that they fill the entire screen. In either of these cases, it’s sometimes difficult to know what the problem is.</p>&#13;
<p class="indent">In the Halley animation, there is only one thing that needs to be scaled, and that’s the position of the comet. We use a factor of 10<sup>–10</sup> pixels/meter to scale the x- and y-components of the position.</p>&#13;
<h3 class="h3" id="ch17lev7">Projectile Motion with Air Resistance</h3>&#13;
<p class="noindent">For our next example, let’s look at a batted baseball. This is an example of projectile motion with air resistance. We’ll consider two forces that act on the baseball: Earth’s surface gravity and air resistance. We’ll use a 145-g baseball with a diameter of 74 mm and a drag coefficient of 0.3. The list <span class="literal">baseballForces</span> contains the two one-body forces that act on the baseball. The list <span class="literal">baseballForces</span>, and all of the code in this chapter and the next that is not part of a stand-alone program, is part of the <span class="literal">Mechanics3D</span> module.</p>&#13;
<pre>baseballForces :: [OneBodyForce]&#13;
baseballForces&#13;
    = let area = pi * (0.074 / 2) ** 2&#13;
      in [earthSurfaceGravity&#13;
         ,airResistance 0.3 1.225 area]</pre>&#13;
<p class="indent">The first force is Earth surface gravity and the second force is air resistance. We define a local variable <span class="literal">area</span> to hold the cross-sectional area of the <span epub:type="pagebreak" id="page_313"/>baseball. The number 0.074 is the diameter of the ball in meters, 0.3 is the drag coefficient, and 1.225 is the density of air in kg/m<sup>3</sup>.</p>&#13;
<p class="indent">For situations that take place on or near Earth’s surface, I like to use a coordinate system in which <em>x</em> and <em>y</em> are the horizontal coordinates and <em>z</em> is the vertical coordinate, with positive <em>z</em> pointing away from Earth’s center. Projectile motion with air resistance takes place in a plane. It would be reasonable to choose the xz-plane or the yz-plane for this motion. We’ll choose the yz-plane because the default coordinate system for the <span class="literal">simulateVis</span> function, should we choose to use it, has <em>y</em> to the right and <em>z</em> up the screen.</p>&#13;
<h4 class="h4" id="ch17lev8">Calculating a Trajectory</h4>&#13;
<p class="noindent">The function <span class="literal">baseballTrajectory</span>, defined below, produces a list of (y, z) pairs, where <em>y</em> and <em>z</em> are the horizontal and vertical components of position, respectively. We give this function a time step, an initial speed, and an angle in degrees. The angle is the angle above the horizontal at which the ball leaves the bat.</p>&#13;
<pre>baseballTrajectory :: R  -- time step&#13;
                   -&gt; R  -- initial speed&#13;
                   -&gt; R  -- launch angle in degrees&#13;
                   -&gt; [(R,R)]  -- (y,z) pairs&#13;
baseballTrajectory dt v0 thetaDeg&#13;
    = let thetaRad = thetaDeg * pi / 180&#13;
          vy0 = v0 * cos thetaRad&#13;
          vz0 = v0 * sin thetaRad&#13;
          initialState&#13;
              = ParticleState { mass     = 0.145&#13;
                              , charge   = 0&#13;
                              , time     = 0&#13;
                              , posVec   = zeroV&#13;
                              , velocity = vec 0 vy0 vz0 }&#13;
      in trajectory $ zGE0 $&#13;
         statesPS (eulerCromerPS dt) baseballForces initialState</pre>&#13;
<p class="indent">We’ve defined several local variables to hold the angle in radians, the horizontal and vertical components of initial velocity, and the initial state of the ball. We use <span class="literal">statesPS</span> to make an infinite list of states, using the Euler-Cromer method with the given step size, the list of forces (<span class="literal">baseballForces</span>), and the initial state. The function <span class="literal">zGE0</span>, defined below, truncates the infinite list to a finite list consisting only of states with a vertical position greater than or equal to zero. The function <span class="literal">trajectory</span>, also defined below, transforms a list of states into a list of (y, z) pairs suitable for plotting.</p>&#13;
<p class="indent">The infinite list produced by <span class="literal">statesPS</span> is truncated to a finite list with the function <span class="literal">zGE0</span>, which takes elements of the infinite list with a vertical position component greater than or equal to zero. As soon as it finds a vertical component less than zero, it stops checking list items and returns the finite list.</p>&#13;
<span epub:type="pagebreak" id="page_314"/>&#13;
<pre>zGE0 :: [ParticleState] -&gt; [ParticleState]&#13;
zGE0 = takeWhile (\(ParticleState _ _ _ r _) -&gt; zComp r &gt;= 0)</pre>&#13;
<p class="indent">By returning a finite list of states, we are one step closer to plotting the trajectory since we can’t plot an infinite list.</p>&#13;
<p class="indent">The <span class="literal">trajectory</span> function returns the horizontal and vertical components of position for each state in the input list. This would be a natural thing to plot, so we are again one step closer to plotting the trajectory.</p>&#13;
<pre>trajectory :: [ParticleState] -&gt; [(R,R)]&#13;
trajectory sts = [(yComp r,zComp r) | (ParticleState _ _ _ r _) &lt;- sts]</pre>&#13;
<h4 class="h4" id="ch17lev9">Finding the Angle for Maximum Range</h4>&#13;
<p class="noindent">Let’s go a little further with our baseball analysis. The function <span class="literal">baseballRange</span> computes the horizontal range of the ball for a given initial speed and angle.</p>&#13;
<pre>baseballRange :: R  -- time step&#13;
              -&gt; R  -- initial speed&#13;
              -&gt; R  -- launch angle in degrees&#13;
              -&gt; R  -- range&#13;
baseballRange dt v0 thetaDeg&#13;
    = let (y,_) = last $ baseballTrajectory dt v0 thetaDeg&#13;
      in y</pre>&#13;
<p class="indent">To accomplish this, we use the <span class="literal">baseballTrajectory</span> function from earlier, take the last pair with a nonnegative vertical position component, and return the horizontal position component of that pair.</p>&#13;
<p class="indent">Now let’s make a graph of baseball range as a function of the angle at which the ball is hit. In the absence of air resistance, the maximum range is achieved at an angle of 45<sup>∘</sup>. Perhaps the presence of air resistance, which we are including, will produce different results. The function <span class="literal">baseballRangeGraph</span> in <a href="ch17.xhtml#ch17list2">Listing 17-2</a> makes such a graph for a baseball batted at 45 m/s (101 mph).</p>&#13;
<pre id="ch17list2">baseballRangeGraph :: IO ()&#13;
baseballRangeGraph&#13;
    = plotFunc [Title "Range for baseball hit at 45 m/s"&#13;
               ,XLabel "Angle above horizontal (degrees)"&#13;
               ,YLabel "Horizontal range (m)"&#13;
               ,PNG "baseballrange.png"&#13;
               ,Key Nothing&#13;
               ] [10,11..80] $ baseballRange 0.01 45</pre>&#13;
<p class="listing"><em>Listing 17-2: Code to produce the graph “Range for baseball hit at 45 m/s”</em></p>&#13;
<p class="indent"><a href="ch17.xhtml#ch17fig2">Figure 17-2</a> shows the horizontal range of a batted baseball as a function of the angle at which it leaves the bat. We assume an initial speed of 45 m/s (101 mph) at every angle. Notice that the longest range occurs at an angle less than 45<sup>∘</sup> above the horizontal.</p>&#13;
<div class="imagel" id="ch17fig2"><img src="Images/315fig01.jpg" alt="Image" width="530" height="393"/></div>&#13;
<p class="figcap"><em>Figure 17-2: Range for a batted baseball. Because of air resistance, the longest range does not occur at an angle of 45<sup>∘</sup> leaving the bat.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_315"/>We can search for the angle that produces the longest range. The value <span class="literal">bestAngle</span> looks through all of the angles from 30<sup>∘</sup> to 60<sup>∘</sup> in 1<sup>∘</sup> steps to find the angle that produces the longest range.</p>&#13;
<pre>bestAngle :: (R,R)&#13;
bestAngle&#13;
    = maximum [(baseballRange 0.01 45 thetaDeg,thetaDeg) |&#13;
               thetaDeg &lt;- [30,31..60]]</pre>&#13;
<p class="indent">To find the longest range, we want to compare <span class="literal">baseballRange 0.01 45</span> <span class="literal">thetaDeg</span>, the range for an initial speed of 45 m/s at an angle of <span class="literal">thetaDeg</span>, for different values of the angle. But we want the <span class="literal">bestAngle</span> function to return the angle at which we achieve the longest range, so we cannot merely ask for the maximum of <span class="literal">baseballRange 0.01 45 thetaDeg</span> because that would return only the range and not the angle that achieved that range.</p>&#13;
<p class="indent">We can get what we want, the longest range and the angle at which it is achieved, by comparing pairs and asking for the maximum pair. The <span class="literal">maximum</span> function uses dictionary order when comparing pairs, so the maximum pair is the one with the largest first element. If there is a tie in comparing first elements, the function compares second elements to break the tie. By choosing the first element of the pair to be the range, the comparison will be done on the range, and by choosing the second element of the pair to be the angle, the function will return the angle as well. Here is the value of <span class="literal">bestAngle</span> reported by GHCi:</p>&#13;
<pre>Prelude&gt; <span class="codestrong1">:l Mechanics3D</span>&#13;
[1 of 4] Compiling Newton2         ( Newton2.hs, interpreted )&#13;
[2 of 4] Compiling Mechanics1D     ( Mechanics1D.hs, interpreted )&#13;
[3 of 4] Compiling SimpleVec       ( SimpleVec.hs, interpreted )&#13;
[4 of 4] Compiling Mechanics3D     ( Mechanics3D.hs, interpreted )&#13;
Ok, four modules loaded.&#13;
*Mechanics3D&gt; <span class="codestrong1">bestAngle</span>&#13;
(116.77499158246208,41.0)</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_316"/>We see that, to within an accuracy of 1<sup>∘</sup>, the angle that produces the longest range is 41<sup>∘</sup> above the horizontal.</p>&#13;
<h4 class="h4" id="ch17lev10">2D Animation</h4>&#13;
<p class="noindent">Let’s turn now to making an animation of the motion of the baseball. The motion takes place in a plane, so we’ll use the two-dimensional <span class="literal">gloss</span> package. We’ll make a stand-alone program to do the animation, and then we’ll show how the program can take arguments that specify the initial speed and angle.</p>&#13;
<h5 class="h5" id="ch17lev11">Main Program</h5>&#13;
<p class="noindent"><a href="ch17.xhtml#ch17list3">Listing 17-3</a> gives a stand-alone program for a 2D animation of projectile motion using <span class="literal">gloss</span>.</p>&#13;
<pre id="ch17list3">{-# OPTIONS -Wall #-}&#13;
&#13;
import SimpleVec&#13;
    ( yComp, zComp )&#13;
import Mechanics3D&#13;
    ( ParticleState(..), simulateGloss, disk&#13;
    , projectileInitial, projectileUpdate )&#13;
import Graphics.Gloss&#13;
    ( Picture(..), red, scale, translate )&#13;
import System.Environment&#13;
    ( getArgs )&#13;
&#13;
projectilePicture :: ParticleState -&gt; Picture&#13;
projectilePicture (ParticleState _m _q _t r _v)&#13;
    = scale 0.2 0.2 $ translate yFloat zFloat redDisk&#13;
      where&#13;
        yFloat = realToFrac (yComp r)&#13;
        zFloat = realToFrac (zComp r)&#13;
        redDisk :: Picture&#13;
        redDisk = Color red (disk 50)&#13;
&#13;
mainWithArgs :: [String] -&gt; IO ()&#13;
mainWithArgs args&#13;
    = simulateGloss 3 20&#13;
      (projectileInitial args) projectilePicture projectileUpdate&#13;
&#13;
main :: IO ()&#13;
main = getArgs &gt;&gt;= mainWithArgs</pre>&#13;
<p class="listing"><em>Listing 17-3: Stand-alone program for a 2D animation of projectile motion. Initial speed and angle can be specified on the command line when the program is run.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_317"/>As usual, the first line asks for warnings and the next several lines import functions and types we want to use in the program.</p>&#13;
<p class="indent">A new feature of this program is that we pass information to the program using command line arguments. A <em>command line argument</em> is a piece of information given after the name of the program you execute on the command line. For example, for a stand-alone program called <em>GlossProjectile</em>, obtained by compiling a source code file called <em>GlossProjectile.hs</em>, we might run the program by entering the following instruction at the command line:</p>&#13;
<pre><span class="codestrong1">$ ./GlossProjectile 30 40</span></pre>&#13;
<p class="indent">We give the name of the executable program we want to run (preceded by a dot-slash to indicate its location in the current directory) followed by some command line arguments that allow us to pass information to the program. We want to pass the initial speed and angle in degrees.</p>&#13;
<p class="indent">How does the program receive and use this information? The standard module <span class="literal">System.Environment</span>, which is included when you initially install the GHC compiler, provides a function <span class="literal">getArgs</span> that returns the command line arguments as a list of strings. For example, the <span class="literal">getArgs</span> function, if used in the program <em>GlossProjectile</em> executed with the command just shown, would return the list <span class="literal">["30","40"]</span>. We can then use these strings to determine what the program does. The function <span class="literal">getArgs</span> is simple and sufficient for our purposes, but if you find yourself getting more serious about using command line arguments in your Haskell programs, you may want to look at the standard module <span class="literal">System.Console.GetOpt</span>, also included with the GHC compiler, as it provides functions to handle command line arguments in a more sophisticated way.</p>&#13;
<p class="indent">Knowing that we will have access to a list of strings containing the command line arguments, we write a function that does the work our <span class="literal">main</span> function did in previous animations, namely calling <span class="literal">simulateGloss</span>, but takes a list of strings as input. The function <span class="literal">mainWithArgs</span> in <a href="ch17.xhtml#ch17list3">Listing 17-3</a> does exactly that. As before, <span class="literal">simulateGloss</span> requires five pieces of information: a time-scale factor, an animation rate, an initial state, a display function, and a state-update function.</p>&#13;
<p class="indent">We chose a time-scale factor of 3 (so the animation takes place more rapidly than the physical evolution) and an animation rate of 20 frames per second. We named the list of strings from the command line <span class="literal">args</span> in <span class="literal">mainWithArgs</span> and fed it to the function <span class="literal">projectileInitial</span>, which creates the initial state based on these strings. We will write the function <span class="literal">projectileInitial</span> shortly.</p>&#13;
<p class="indent">The display function <span class="literal">projectilePicture</span> in <a href="ch17.xhtml#ch17list3">Listing 17-3</a> describes the picture we want to produce for a given particle state. In this display function, we create a picture and then scale the entire picture by a factor of 0.2 pixels/meter. The <span class="literal">scale 0.2 0.2</span> function shrinks the picture by a factor of five in both the horizontal and vertical dimensions.</p>&#13;
<p class="indent">The <span class="literal">main</span> program uses the function <span class="literal">getArgs</span> to get any command line arguments specified when the program is run. The function <span class="literal">getArgs</span> is not a pure function; it is an <em>effectful</em> function. An effect is a computation that is <span epub:type="pagebreak" id="page_318"/>not purely functional (that is, it depends on or changes the world in some way). Computations that depend on program input, randomness, or the current time are effects. Sending information to a display or writing to the hard drive are also effects. An effect produced by a function is sometimes called a side effect, presumably to distinguish it from the main purpose of a function, which is to produce an output. A pure function is one that involves no effects; its output depends only on its inputs and unchanging global values. An effectful function is one whose output depends on something other than its inputs (such as user input, command line arguments, or randomness) or that has a side effect in addition to its output. In Haskell, an effectful function must have a type that involves the <span class="literal">IO</span> type constructor.</p>&#13;
<p class="indent">To see this, let’s load the module <span class="literal">System.Environment</span> prefixed by a plus sign so that the <span class="literal">Mechanics3D</span> module will not be unloaded, which is the default behavior.</p>&#13;
<pre>*Mechanics3D&gt; <span class="codestrong1">:m +System.Environment</span>&#13;
*Mechanics3D System.Environment&gt; <span class="codestrong1">:t getArgs</span>&#13;
getArgs :: IO [String]</pre>&#13;
<p class="indent">The fact that <span class="literal">getArgs</span> is an effectful function is indicated by the <span class="literal">IO</span> type constructor. While a pure function’s output can depend only on its inputs and unchanging global values, the output of <span class="literal">getArgs</span> depends on command line arguments, which are not function inputs or global values. For this reason, <span class="literal">getArgs</span> must have type <span class="literal">IO [String]</span> rather than <span class="literal">[String]</span>. The <span class="literal">IO</span> tag on data means that the data may have been acquired through some effect. The absence of an <span class="literal">IO</span> tag on data is a promise that the data has not been acquired through any effect.</p>&#13;
<p class="indent">The <span class="literal">IO</span> type constructor that labels an effectful function is one example of a collection of type constructors known as <em>monads</em>. The idea of a monad has been around in the mathematics of category theory for several decades; its use in functional programming is more recent, where it represents a computational abstraction. Haskell has a type class <span class="literal">Monad</span> for type constructors, such as <span class="literal">IO</span>, that can implement certain functions. Since the <span class="literal">IO</span> type constructor is an instance of type class <span class="literal">Monad</span>, it is also referred to as the <span class="literal">IO</span> monad. It is not the intent of this book to say much about monads. Monads are an interesting abstraction, but I don’t think physics has a strong need for them. The books <em>Real World Haskell</em> [<strong><a href="bib.xhtml#bib2"><span class="green">2</span></a></strong>] and <em>Learn You a Haskell for Great Good</em> [<strong><a href="bib.xhtml#bib1"><span class="green">1</span></a></strong>] have nice discussions of monads. Stephen Diehl’s “What I Wish I Knew When Learning Haskell” at <a href="http://dev.stephendiehl.com/hask">http://dev.stephendiehl.com/hask</a> also has a nice discussion of monads.</p>&#13;
<p class="indent">The operator <span class="literal">&gt;&gt;=</span>, called “bind,” is the most important of the monad functions. In the context of the <span class="literal">IO</span> monad we have here, it provides a way to use information arising from an effectful function. To understand its use, let’s take a look at its type.</p>&#13;
<pre>*Mechanics3D System.Environment&gt; <span class="codestrong1">:t (&gt;&gt;=)</span>&#13;
(&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_319"/>The type variables <span class="literal">a</span> and <span class="literal">b</span> stand for types, while the type variable <span class="literal">m</span> stands for a type constructor. The type class <span class="literal">Monad</span> has type constructors as instances. Haskell’s notion of <em>kind</em>, introduced in <a href="ch09.xhtml">Chapter 9</a>, helps to classify the possibilities of what a type variable can stand for.</p>&#13;
<p class="indent">For our purpose, the type variable <span class="literal">m</span> can be replaced with <span class="literal">IO</span>, which is an instance of type class <span class="literal">Monad</span>. Specializing the bind operator to the <span class="literal">IO</span> type constructor, bind has the following type:</p>&#13;
<pre>IO a -&gt; (a -&gt; IO b) -&gt; IO b</pre>&#13;
<p class="indent">We see that bind takes two things: a value with type <span class="literal">a</span> “tagged” by the <span class="literal">IO</span> type constructor and an effectful function whose input has type <span class="literal">a</span>, which produces a value of type <span class="literal">b</span> “tagged” by the <span class="literal">IO</span> type constructor. We can think of this <span class="literal">IO</span> type constructor as a tag on the value that indicates its origin and/or effect. The bind operator allows an <span class="literal">IO</span>-tagged value to be used as a regular value in a function that promises to return an <span class="literal">IO</span>-tagged result. Since <span class="literal">IO</span> acts as a tag for effects, it is important that the <span class="literal">IO</span> tag is not removable once applied. However, if a function returns a tagged output, the bind operator provides a way for a tagged input to be temporarily untagged and used, knowing that the function will retag the output.</p>&#13;
<p class="indent">We are using the bind operator (<span class="literal">&gt;&gt;=</span>) in a setting where type variable <span class="literal">a</span> is <span class="literal">[String]</span> and type variable <span class="literal">b</span> is unit, so the concrete type of bind in our program is the following:</p>&#13;
<pre>IO [String] -&gt; ([String] -&gt; IO()) -&gt; IO ()</pre>&#13;
<p class="indent">The bind operator is just what we need to connect the output of <span class="literal">getArgs</span> with the input of <span class="literal">mainWithArgs</span>. In fact, the <span class="literal">main</span> program does nothing other than pass the output of <span class="literal">getArgs</span> to the function <span class="literal">mainWithArgs</span>.</p>&#13;
<h5 class="h5" id="ch17lev12">State-Update Function and Initial State</h5>&#13;
<p class="noindent">The state-update function <span class="literal">projectileUpdate</span> is written using <span class="literal">updatePS</span>, just as in satellite motion.</p>&#13;
<pre>projectileUpdate :: TimeStep&#13;
                 -&gt; ParticleState  -- old state&#13;
                 -&gt; ParticleState  -- new state&#13;
projectileUpdate dt&#13;
    = updatePS (eulerCromerPS dt) baseballForces</pre>&#13;
<p class="indent">Again, for our numerical method, we chose the Euler-Cromer method. We used the same list of one-body forces, <span class="literal">baseballForces</span>, that we used to make the graph shown earlier.</p>&#13;
<p class="indent">Knowing that we want to pass the initial speed and angle to our program as command line arguments, and that these will be available as a list of strings, we’ll write the function <span class="literal">projectileInitial</span> to take a list of strings, which will come from the command line when we run the program, and use these strings to determine the initial velocity. We want the list of strings <span epub:type="pagebreak" id="page_320"/>to have two elements: the first string gives the initial speed and the second gives the initial angle in degrees.</p>&#13;
<pre>projectileInitial :: [String] -&gt; ParticleState&#13;
projectileInitial []        = error "Please supply initial speed and angle."&#13;
projectileInitial [_]       = error "Please supply initial speed and angle."&#13;
projectileInitial (_:_:_:_)&#13;
    = error "First argument is speed.  Second is angle in degrees."&#13;
projectileInitial (arg1:arg2:_)&#13;
    = let v0       = read arg1 :: R       -- initial speed, m/s&#13;
          angleDeg = read arg2 :: R       -- initial angle, degrees&#13;
          theta    = angleDeg * pi / 180  -- in radians&#13;
      in defaultParticleState&#13;
             { mass     = 0.145  -- kg&#13;
             , posVec   = zeroV&#13;
             , velocity = vec 0 (v0 * cos theta) (v0 * sin theta)&#13;
             }</pre>&#13;
<p class="indent">We use pattern matching on the input to give a helpful error message if exactly two arguments are not provided. The first line responds to the empty list, the case in which no command line arguments are given. The second line responds to the case in which only one command line argument is given. The third line responds to the case in which three or more command line arguments are given. Finally, the fourth line treats the case of exactly two command line arguments, which is what we want.</p>&#13;
<p class="indent">We use the <span class="literal">read</span> function to convert the strings to real numbers. The <span class="literal">read</span> function takes a string as input and produces an output that is one of many types. We need to give a type annotation to specify what type we want the string converted to. Here is an example of what <span class="literal">read</span> does:</p>&#13;
<pre>*Mechanics3D System.Environment&gt; <span class="codestrong1">:t read</span>&#13;
read :: Read a =&gt; String -&gt; a&#13;
*Mechanics3D System.Environment&gt; <span class="codestrong1">read "56" :: R</span>&#13;
56.0</pre>&#13;
<h4 class="h4" id="ch17lev13">3D Animation</h4>&#13;
<p class="noindent">Several of the items needed to create a 3D animation are the same as those needed for a 2D animation, but one is different. To compare the process of making a 3D animation with that of making a 2D animation, let’s animate the projectile motion using our 3D animation tools. <a href="ch17.xhtml#ch17list4">Listing 17-4</a> gives a stand-alone program for a 3D animation of projectile motion using <span class="literal">not-gloss</span>.</p>&#13;
<pre id="ch17list4">{-# OPTIONS -Wall #-}&#13;
&#13;
import SimpleVec ( R, (*^) )&#13;
import Mechanics3D&#13;
    ( ParticleState(..), simulateVis<span epub:type="pagebreak" id="page_321"/>&#13;
    , projectileInitial, projectileUpdate, v3FromVec )&#13;
import Vis&#13;
    ( VisObject(..), Flavour(..), red )&#13;
import System.Environment&#13;
    ( getArgs )&#13;
&#13;
projectileVisObject :: ParticleState -&gt; VisObject R&#13;
projectileVisObject st&#13;
    = let r = posVec st&#13;
      in Trans (v3FromVec (0.01 *^ r)) (Sphere 0.1 Solid red)&#13;
&#13;
mainWithArgs :: [String] -&gt; IO ()&#13;
mainWithArgs args&#13;
    = simulateVis 3 20&#13;
      (projectileInitial args) projectileVisObject projectileUpdate&#13;
&#13;
main :: IO ()&#13;
main = getArgs &gt;&gt;= mainWithArgs</pre>&#13;
<p class="listing"><em>Listing 17-4: Stand-alone program for a 3D animation of projectile motion</em></p>&#13;
<p class="indent">The <span class="literal">main</span> function is exactly the same as in the 2D animation. The <span class="literal">main</span> <span class="literal">WithArgs</span> function uses <span class="literal">simulateVis</span> instead of <span class="literal">simulateGloss</span>, but it uses the same time-scale factor, animation rate, initial-state function, and state-update function we used for the 2D animation.</p>&#13;
<p class="indent">The only new piece we need is a display function, <span class="literal">projectileVisObject</span>. In this display function, the state is named <span class="literal">st</span>, and we define a local variable <span class="literal">r</span> for the position of the object. We use a solid red sphere with radius 0.1 to represent the projectile. The <span class="literal">not-gloss</span> package does not measure distances in pixels; instead, a length of 1 is initially about 20 percent of the height of the screen. You can then zoom in or out by pressing E or Q, or by using the mouse. Before we translate the red sphere to its appropriate position, we need to scale the position <span class="literal">r</span> from meters to <span class="literal">Vis</span> units, and we need to convert the position to <span class="literal">Vis</span>’s vector type. We multiply the position by a factor of 0.01 <span class="literal">Vis</span> units per meter so the range of the animation is not too big and not too small. We use the <span class="literal">v3FromVec</span> function, defined in <a href="ch16.xhtml">Chapter 16</a>, to convert to <span class="literal">Vis</span>’s vector type before using the <span class="literal">Trans</span> function.</p>&#13;
<p class="indent">Having seen an example of projectile motion with air resistance, the technique of using command line arguments to pass information into a program, and a comparison of 2D and 3D animation, let’s turn to an example that really requires 3D animation.</p>&#13;
<h3 class="h3" id="ch17lev14">Proton in a Magnetic Field</h3>&#13;
<p class="noindent">Magnetic fields are used in particle accelerators to get protons or electrons to move in a circular ring to bring them to high speed and slam them into each other. This lets experimentalists look at the particles created in such <span epub:type="pagebreak" id="page_322"/>high-energy collisions and learn things about the nature of particles and their interactions.</p>&#13;
<p class="indent">A charged particle in a uniform magnetic field will move in a circle or a helix. This is not obvious, but it is a consequence of the Lorentz force law, given as Equation 16.8 for uniform fields. Luckily for us, a helix is a nice motion for showing off our 3D animation tools.</p>&#13;
<p class="indent">According to the Lorentz force law, the magnetic force on a particle is proportional to the cross product <strong>v</strong>(<em>t</em>) ×<strong>B</strong>, which means that the force is perpendicular to both the particle’s velocity and the magnetic field. Since the magnetic force is always perpendicular to the velocity of the particle, it can’t make the particle speed up or slow down; it can only make the particle turn (change direction).</p>&#13;
<p class="indent">To produce an animation of this, we’ll need a state-update function, an initial state, and a display function. Here is a state-update function for a particle in a uniform magnetic field of strength 3 × 10<sup>–8</sup> Tesla.</p>&#13;
<pre>protonUpdate :: TimeStep -&gt; ParticleState -&gt; ParticleState&#13;
protonUpdate dt&#13;
    = updatePS (rungeKutta4 dt) [uniformLorentzForce zeroV (3e-8 *^ kHat)]</pre>&#13;
<p class="indent">We’re using fourth-order Runge-Kutta as our numerical method because it produces good results with a fairly large step size, while Euler-Cromer requires a rather small step size to produce good results. There’s no way to know this in advance. It’s always a good idea to check that results are stable with changes in step size. The list of forces has only one item, the Lorentz force of a uniform magnetic field. The <span class="literal">zeroV</span> is for zero electric field.</p>&#13;
<p class="indent">Here is the initial state of the proton on which the magnetic field acts:</p>&#13;
<pre>protonInitial :: ParticleState&#13;
protonInitial&#13;
    = defaultParticleState { mass     = 1.672621898e-27  -- kg&#13;
                           , charge   = 1.602176621e-19  -- C&#13;
                           , posVec   = zeroV&#13;
                           , velocity = 1.5*^jHat ^+^ 0.3*^kHat  -- m/s&#13;
                           }</pre>&#13;
<p class="indent">By giving the proton an initial component of velocity in both the y- and z-directions, we’ll get a helix for the motion. If either of these components is set to 0, a different kind of motion will ensue. Play around and see what happens.</p>&#13;
<p class="indent">Here is the display function for the proton in the magnetic field:</p>&#13;
<pre>protonPicture :: ParticleState -&gt; V.VisObject R&#13;
protonPicture st&#13;
    = let r0 = v3FromVec (posVec st)&#13;
      in V.Trans r0 (V.Sphere 0.1 V.Solid V.red)</pre>&#13;
<p class="indent">A red ball is used to mark the location of the proton.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_323"/><a href="ch17.xhtml#ch17list5">Listing 17-5</a> shows a stand-alone Haskell program to animate a proton in a magnetic field. The time-scale factor is set to one, so this is a real-time animation. Note that the magnetic field is very small in this example and that a larger magnetic field would cause the proton to complete a turn of the helix in much less time. The animation rate is set to 60 frames/second.</p>&#13;
<pre id="ch17list5">{-# OPTIONS -Wall #-}&#13;
&#13;
import Mechanics3D (simulateVis, protonInitial, protonPicture, protonUpdate)&#13;
&#13;
main :: IO ()&#13;
main = simulateVis 1 60 protonInitial protonPicture protonUpdate</pre>&#13;
<p class="listing"><em>Listing 17-5: Stand-alone Haskell program for 3D animation of a proton in a uniform magnetic field</em></p>&#13;
<h3 class="h3" id="ch17lev15">Summary</h3>&#13;
<p class="noindent">In this chapter, we used the ideas and code from <a href="ch16.xhtml">Chapter 16</a> to study three examples of the motion of a single particle in three dimensions subject to different forces. We gave examples of 2D or 3D animation for satellite motion, projectile motion with air resistance, and a particle in a magnetic field. In the next chapter, we’ll show how the ideas and code from <a href="ch16.xhtml">Chapter 16</a> can be used or modified slightly to treat single-particle mechanics problems with the theory of relativity instead of Newton’s second law.</p>&#13;
<h3 class="h3" id="ch17lev16">Exercises</h3>&#13;
<p class="noindentts"><strong>Exercise 17.1.</strong> Modify the <span class="literal">halleyPicture</span> function in <a href="ch17.xhtml#ch17list1">Listing 17-1</a> to include x- and y-axes in the animation. You will be able to see that the comet’s aphelion (point of greatest distance from the sun) is not quite aligned with the x-axis. This is an indication of inaccuracy in the numerical method, which can be reduced by decreasing the time-scale factor and reducing the time step of the numerical method.</p>&#13;
<p class="noindentts"><strong>Exercise 17.2.</strong> Let’s treat Earth as being fixed at the origin of our coordinate system. Consider the gravitational force on a satellite of mass <em>m</em>, initial position <strong>r</strong><sub>0</sub>, and initial velocity <strong>v</strong><sub>0</sub>. Since the motion of the satellite will take place in a plane, we can use vectors that lie in the xy-plane. Plot trajectories of orbits resulting from various initial conditions. Choose some values for initial conditions that give nearly circular orbits and some others that give elliptical orbits. You will find that the Euler method produces orbits that don’t close on themselves. Make one plot comparing the Euler and Euler-Cromer methods for one orbit that you like (elliptical or circular). Indicate the step size you used for the Euler and Euler-Cromer methods as well as your choice of initial conditions.</p>&#13;
<p class="noindentts"><strong>Exercise 17.3.</strong> The Lorentz force law, Equation 16.8, describes the force exerted on a particle with charge <em>q</em> and velocity <strong>v</strong>(<em>t</em>) by an electric field <strong>E</strong> and <span epub:type="pagebreak" id="page_324"/>a magnetic field <strong>B</strong>. Consider a uniform magnetic field in the z-direction. You may already know that a charged particle with initial velocity in the x-direction will go in circles in this magnetic field. Choose some values for the strength of the magnetic field, the charge of the particle, the mass of the particle, and the initial velocity. Confirm, using the Euler-Cromer method, that the particle does indeed go in circles. Plot <em>y</em> versus <em>x</em> for different time steps. Even the Euler-Cromer method will not produce circles that close on themselves if the time step is too big. One of your time steps should be small enough that the orbit appears to close.</p>&#13;
<p class="noindentts"><strong>Exercise 17.4.</strong> Return to the satellite orbiting Earth. Write a Haskell program to animate your satellite’s motion around Earth. Show that by using different initial conditions, you can achieve circular orbits and elliptical orbits.</p>&#13;
<p class="noindentts"><strong>Exercise 17.5.</strong> Suppose the wind is blowing horizontally at 10 m/s and you launch a Ping-Pong ball straight up into the air with an initial speed of 5 m/s. How far from the launch point will it hit the ground? You can come up with pretty good estimates for the density of air and the mass and cross-sectional area of the ball, but an estimate for the drag coefficient is more of a guess. Try the calculation for drag coefficients of 0.5, 1.0, and 2.0 to see how they compare. Repeat the calculation for a golf ball launched upward with the same speed.</p>&#13;
<p class="noindentts"><strong>Exercise 17.6.</strong> Make the necessary modifications to the code presented in this chapter so that the initial position of the baseball is 1 meter above the ground. Make a plot of the trajectory for a line drive with a speed of 40 m/s at an angle 5<sup>∘</sup> above horizontal.</p>&#13;
<p class="noindentts"><strong>Exercise 17.7.</strong> Investigate the effect of a 30-mph crosswind on a batted baseball. Assuming the wind is perpendicular to the plane in which the ball would otherwise travel, how far does the wind displace the ball from the place where it would land without the wind? Choose some reasonable values for initial speed and angle of the ball.</p>&#13;
<p class="noindentts"><strong>Exercise 17.8.</strong> Given an initial speed and a drag coefficient, the optimal angle is the angle that produces the longest range for the baseball. Make a graph of the optimal angle as a function of drag coefficient for an initial speed of 45 m/s.</p>&#13;
<p class="noindentts"><strong>Exercise 17.9.</strong> If you can produce uniform electric and magnetic fields, you can make a device called a <em>velocity selector</em>. The purpose of a velocity selector is to allow charged particles that are traveling at a specific velocity to proceed in a straight line, while similar particles traveling faster or slower get deflected. From a beam of charged particles moving with a range of speeds, the velocity selector can produce a beam of particles that all have very close to the same speed. In this way, the experimentalist has access to a beam of charged particles with a known velocity that can be used for some experiment.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_325"/>Let’s model a velocity selector using a uniform electric field of 300 N/C in the positive z-direction and a uniform magnetic field of 0.3 T in the positive x-direction. We’re interested in the motion of a singly ionized particle with mass 1.00 × 10<sup>–22</sup> kg. (Singly ionized means that one electron has been removed so the particle has the charge of a proton.) We’ll give this particle an initial velocity in the positive y-direction. If the particle is moving too fast, it will deflect one way; if it’s moving too slowly, it will deflect another way.</p>&#13;
<p class="indent">Using the <span class="literal">Vis</span> module, make a stand-alone program that takes the initial speed of the particle as input (similar to how our projectile motion program took initial speed and angle as input) and produces an animation for the particle in the velocity selector. To judge whether and how much the particle is deflecting, include a coordinate system in your picture (similar to the coordinate system we displayed in <a href="ch13.xhtml">Chapter 13</a>), so you can tell when the particle departs from the y-axis. Use a time-scale factor of 5 × 10<sup>–4</sup> and an animation rate of 60 frames/second. Run this program with different initial speeds between 0 and 5,000 m/s.</p>&#13;
<p class="alphats">(a) Confirm that the particle deflects one way for slow speeds.</p>&#13;
<p class="alphats">(b) Confirm that the particle deflects another way for fast speeds.</p>&#13;
<p class="alphats">(c) Extend your program to include a circular aperture at <em>y</em> = 1 m that allows particles to pass through. Start with an aperture radius of 4 cm.</p>&#13;
<pre class="pre3a">apR :: R&#13;
apR = 0.04  -- meters</pre>&#13;
<p class="noindente1">Particles outside this radius will be blocked by a wall and not allowed to pass through. Modify your state-update function to include a wall force that blocks particles outside the aperture radius when they get to <em>y</em> = 1 m. You can use the following wall force:</p>&#13;
<pre class="pre3a">wallForce :: OneBodyForce&#13;
wallForce ps&#13;
    = let m = mass ps&#13;
          r = posVec ps&#13;
          x = xComp r&#13;
          y = yComp r&#13;
          z = zComp r&#13;
          v = velocity ps&#13;
          timeStep = 5e-4 / 60&#13;
      in if y &gt;= 1 &amp;&amp; y &lt; 1.1 &amp;&amp; sqrt (x**2 + z**2) &gt; apR&#13;
         then (-m) *^ (v ^/ timeStep)&#13;
         else zeroV</pre>&#13;
<p class="noindente1">This wall force applies a dissipative force that will slow the particle to a crawl in just a few time steps if its y-value is between 100 cm and 110 cm and it is outside the aperture radius. You could think of the wall as 10 cm of lead, but the real reason for the 10 cm is to catch particles that are moving very quickly; the wall thickness could be reduced if the time step was reduced. (You may notice that particles <span epub:type="pagebreak" id="page_326"/>crawl along the wall at a slow speed or move through the 10 cm–long aperture “tube” because the electric field still acts on them.) Modify your display function to include a circle for the aperture. Find the range of velocities allowed through the 4-cm aperture. What range of velocities are allowed through a 1 cm–radius aperture? How about a 1 mm–radius aperture?</p>&#13;
<p class="indent">Try to guess how the target velocity (velocity of particle when undeflected) is related to the numeric values of electric and magnetic fields.</p>&#13;
<p class="noindentts"><strong>Exercise 17.10.</strong> Use the <span class="literal">Vis</span> module to animate the motion of Halley’s comet. Instead of Euler-Cromer, use fourth-order Runge-Kutta because the <span class="literal">Vis</span> module can’t achieve an animation rate of 400 frames/second (although it won’t tell you this and it will do the best it can). Try animation rates of 20 frames/second (too small, the orbits spiral inward toward the sun), 60 frames/second (pretty good), and 400 frames/second (really good, even though 400 frames/second is not being achieved). You may want to use the following function as the last transformation of your picture before handing it off to <span class="literal">simulateVis</span>:</p>&#13;
<pre>zOut :: V.VisObject R -&gt; V.VisObject R&#13;
zOut = V.RotEulerDeg (Euler 90 0 90)</pre>&#13;
<p class="indent">The function <span class="literal">zOut</span> orients the display so that the xy-plane is more or less the plane of the screen, and <em>z</em> points out from the screen. The default orientation has <em>x</em> pointing out of the screen, <em>y</em> to the right, and <em>z</em> up the screen.</p>&#13;
<p class="noindentts"><strong>Exercise 17.11.</strong> Use <span class="literal">gnuplot</span> to make plots of the Halley’s comet orbit using different numerical methods. Use Euler, Euler-Cromer, and fourth-order Runge-Kutta, each with time steps of 1/20 year, 1/60 year, and 1/400 year. The results should look <a href="ch17.xhtml#ch17fig3">Figure 17-3</a>, where the left column is Euler, the middle column is Euler-Cromer, and the right column is fourth-order Runge-Kutta. The top row uses a time step of 1/20 year, the middle row 1/60 year, and the bottom row 1/400 year.</p>&#13;
<div class="imagel" id="ch17fig3"><img src="Images/326fig01.jpg" alt="Image" width="517" height="290"/></div>&#13;
<p class="figcap"><em>Figure 17-3: Halley’s comet orbit using Euler, Euler-Cromer, and fourth-order Runge-Kutta, with time steps of 1/20 year, 1/60 year, and 1/400 year, respectively.</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_327"/>When calculating orbits, we can take advantage of energy conservation to check the numerical accuracy of the integration scheme. The particle state structure has the position of the comet, from which we can find the potential energy, and the velocity, from which we can compute the kinetic energy. Write a function</p>&#13;
<pre>energy :: ParticleState -&gt; R&#13;
energy ps = undefined ps</pre>&#13;
<p class="noindentts">that computes the total energy of Halley’s comet in a given <span class="literal">ParticleState</span>. We know that the total energy of Halley’s comet is conserved, so any change in the energy we calculate is due to inaccuracies in the numerical method we are using. We can use the fractional change in energy over a period of one orbit as a measure of how good our numerical method is.</p>&#13;
<p class="indent">For numerical methods that are reasonably good, such as the three in the lower-right corner of <a href="ch17.xhtml#ch17fig3">Figure 17-3</a>, we can use the following predicate with <span class="literal">takeWhile</span> to truncate the list of states after one orbit has occurred:</p>&#13;
<pre>firstOrbit :: ParticleState -&gt; Bool&#13;
firstOrbit st&#13;
    = let year = 365.25 * 24 * 60 * 60&#13;
      in time st &lt; 50 * year || yComp (posVec st) &lt;= 0</pre>&#13;
<p class="indent">This predicate works by accepting the first 50 years of orbit data (recall the period is about 75 years), at which point the y-component of position is negative, and continuing to accept data until the y-component becomes positive, which indicates the beginning of the second orbit.</p>&#13;
<p class="indent">Calculate the fractional change in energy over a period of one orbit for (a) the Euler-Cromer method with step size 1/400 year (you should get about one percent), (b) the fourth-order Runge-Kutta method with step size 1/60 year, and (c) the fourth-order Runge-Kutta method with step size 1/400 year. For an extra challenge, label each <span class="literal">gnuplot</span> graph with the fractional change in energy over a single orbit.<span epub:type="pagebreak" id="page_328"/></p>&#13;
</div></body></html>