<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_3" aria-label="3"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch1">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">REPRESENTING GRAPHS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" role="presentation" alt="" width="386" height="386"/>&#13;
</figure>&#13;
<p class="ChapterIntro">A <i>graph</i> is an abstract data type that can be implemented with a variety of data structures. This chapter introduces the fundamental components of a graph, nodes and edges, then shows how to build the two most common graph representations: adjacency lists and adjacency matrices. Understanding the structure and composition of graphs is critical to harnessing their power and designing algorithms to use them efficiently.</p>&#13;
<p class="TX">To implement the graphs, we define the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> classes upon which almost every algorithm in this book relies. We discuss what information the classes store and provide functions for interacting with these objects. We also discuss the trade-offs involved in different implementations, along with possible alternatives and hybrids.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_4" aria-label="4"/>&#13;
<h3 class="H1" id="sec1"><span id="h-6"/><samp class="SANS_Futura_Std_Bold_B_11">Graph Structure</samp></h3>&#13;
<p class="TNI1">A graph consists of two components: nodes and edges. A <i>node</i> (also called a <i>vertex</i>) represents a location or item within the graph. Nodes are often used to model concrete entities like people, cities, or computers. <i>Edges</i> (also called <i>links</i> or <i>arcs</i>) link together pairs of nodes, defining the relative connections within the graph. They are used to represent both concrete items, such as roads between cities, and abstract concepts, such as the friendship of two people.</p>&#13;
<p class="TX"><a href="#fig1-1">Figure 1-1</a> shows an example graph with five nodes and seven edges. We use the standard graphical representation with nodes as circles and edges as lines connecting two circles. Many figures in the book also include a label within each circle to identify individual nodes.</p>&#13;
<figure class="IMG"><img id="fig1-1" class="img30" src="../images/f01001.jpg" alt="Seven lines, representing edges, join pairs of circles." width="482" height="273"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: A graph with five nodes and seven edges</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To describe graphs in mathematical notation, we use <i>V</i> to represent the set of nodes and <i>E</i> to represent the set of edges. The number of nodes and edges are represented using the mathematical notation for the size of a set, meaning the number of nodes is |<i>V</i> | and the number of edges is |<i>E</i>|.</p>&#13;
<p class="TX">Using these simple components, we can represent a surprisingly large number of real-world systems and answer a range of real-world practical questions. For example, graphs allow us to model the following scenarios:</p>&#13;
<p class="RunInPara"><b>Transportation networks </b>Nodes are cities, and edges represent paths. We can compute the shortest path between points or look for single points of failure that would cut off one part of the network from another.</p>&#13;
<p class="RunInPara"><b>Mazes </b>Nodes are intersections, and edges are the halls linking them. We can search for paths through the maze.</p>&#13;
<p class="RunInPara"><b>Educational topics </b>Each node is a topic, and the edges link two related topics. We can sort topics by prerequisite knowledge.</p>&#13;
<p class="RunInPara"><b>Social networks </b>Nodes are people, and edges are their friendship connections. We can model information flow through the network to predict how rumors will travel.</p>&#13;
<p class="TX">We can further increase the power of our graphs by allowing the edges to provide additional information like directionality and weight, as discussed in the following subsections and in later chapters.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_5" aria-label="5"/>&#13;
<h4 class="H2" id="sec2"><span id="h-7"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Weighted Edges</samp></h4>&#13;
<p class="TNI1">In almost every real-world transportation network, there is a different <i>cost</i> for traversing different edges. We might measure this cost in distance or the price of gas, for example; either way, it is cheaper to drive from Boston to New York than it is to drive from Boston to Los Angeles. Cost measures can also be more complicated, such as factoring in the stress of navigating a narrow, winding road through the mountains. Alternatively, for some problems, we want to consider the inverse of a cost, such as the strength of a connection between nodes or the benefit of following a particular edge. Accounting for the edge’s costs or benefits is critical in accurately solving many graph problems, such as finding the shortest (or least scary) path between two locations.</p>&#13;
<p class="TX"><i>Weighted edges</i> capture not only the links between nodes but also the costs or benefits of traversing those links. For some applications, the weightings are obvious and easy to obtain, such as the distance between cities. For example, we could assign an edge between Pittsburgh and Cleveland the weighting of 133 to reflect 133 miles of highway between the two cities. In other contexts, we might use weightings to represent more abstract concepts like the strength of a friendship. A weighting of 10 for the connection between Tina and Bob could indicate that the two are best friends, while a weighting of 1 for Tina’s connection with Alice would indicate that they are mere acquaintances. It is usually obvious from context whether a weight represents a cost or benefit.</p>&#13;
<p class="TX">We call graphs with weighted edges <i>weighted graphs</i> and those without such edges <i>unweighted graphs</i>. We visually represent edge weights as numeric labels adjacent to the line representing the edge itself. In <a href="#fig1-2">Figure 1-2</a>, for example, three of the edges have weight 1.0, one edge has weight 2.0, and the remaining three have weight 3.0.</p>&#13;
<figure class="IMG"><img id="fig1-2" class="img40" src="../images/f01002.jpg" alt="This graph has five nodes and seven edges. Each edge is labeled with a numerical weight. The top two edges have weights 1.0 and 2.0." width="593" height="382"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-2: A weighted graph</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">If necessary, we can use weighted graphs to model unweighted edges by either using a single weight for all edges, such as 1.0, or ignoring the weight attribute in our algorithms.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h-8"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Directed Edges</samp></h4>&#13;
<p class="TNI1">In some systems, connections between nodes are not symmetric. For example, consider the pipe from a building’s water heater to the kitchen faucet. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_6" aria-label="6"/>Unless the plumbing is very broken, it is not possible for the water to flow into the faucet and back to the water heater.</p>&#13;
<p class="TX"><i>Directed edges</i> indicate such directionality in the connection between two nodes. We use terminology that mirrors real-world transportation networks: the node from which a directed edge begins is the <i>origin</i> or <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>, while the node to which the directed edge points is the <i>destination</i> or <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp>.</p>&#13;
<p class="TX">While directed edges can represent physical directionality, such as a one-way road, we can also use them to model more abstract directionality, such as prerequisite courses in an educational institution. If each node is a course, a directed edge might indicate that we need to take Introduction to Computer Science before Advanced Graph Algorithms, as shown in <a href="#fig1-3">Figure 1-3</a>.</p>&#13;
<figure class="IMG"><img id="fig1-3" class="img100" src="../images/f01003.jpg" alt="Two boxes representing course descriptions. The first box is CS100: Introduction to Computer Science and has no prerequisites. The second box is CS401: Advanced Graph Algorithms with CS100 and CS201 listed as prerequisites. An arrow goes from the first box to the second. Two more arrows to CS401 represent the two other prerequisites with ellipses." width="1287" height="424"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-3: Arrows showing the directionality of course prerequisites</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We call graphs with directed edges <i>directed graphs</i>. Graphs without directed edges (such as those in <a href="#fig1-1">Figures 1-1</a> and <a href="#fig1-2">1-2</a>) are known as <i>undirected graphs</i> with <i>undirected edges</i>.</p>&#13;
<p class="TX">We can use directed edges to extend our earlier social network model. While it would be ideal if all friendships were reciprocated, this is sadly not always the case. Tina and Bob might call each other best friends. However, while Alice considers Tina a dear friend, Tina thinks of Alice simply as an acquaintance from work.</p>&#13;
<p class="TX"><a href="#fig1-4">Figure 1-4</a> shows an example graph with directed edges, where each directed edge is shown as a single arrow indicating its direction.</p>&#13;
<figure class="IMG"><img id="fig1-4" class="img30" src="../images/f01004.jpg" alt="A graph with five nodes and eight directed edges. Each edge is shown as one or two arrows." width="482" height="273"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-4: A directed graph</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We can represent symmetric or undirected relationships between nodes in a directed graph by using pairs of directed edges, one in each direction, as shown between the bottom two nodes in <a href="#fig1-4">Figure 1-4</a>. This allows us <span role="doc-pagebreak" epub:type="pagebreak" id="pg_7" aria-label="7"/>to model systems with a mix of directed and undirected relationships. For example, real-world transportation networks contain a mix of one-way and two-way roads, and many social networks contain mutual friendships. By using a directed graph and corresponding edge pairs, we can fully model these systems.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
&#13;
<h4 class="H2" id="sec4"><span id="h-9"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Edges with Both Weight and Direction</samp></h4>&#13;
<p class="TNI1">To maximize the representational power of the graph, we can combine the use of weighted edges and directed edges, as shown in <a href="#fig1-5">Figure 1-5</a>. This representation allows the graph to capture both the directionality and the cost versus benefit of each connection.</p>&#13;
<figure class="IMG"><img id="fig1-5" class="img40" src="../images/f01005.jpg" alt="A graph with five nodes and eight directed edges. Each edge is shown as one or two arrows and each arrow is labeled with a number representing the weight." width="601" height="403"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-5: A directed and weighted graph</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">We must specify a separate weight for each directed edge between two nodes, but, as with the bottom pair of nodes in <a href="#fig1-5">Figure 1-5</a>, these weights need not be equal. When modeling the cost of traversing a road, for example, we might choose a much higher cost for the uphill direction than for the downhill one. Depending on the application, such as planning a cycling trip, the cost of uphill roads might be significantly higher. Similarly, Tina and Alice assign different levels of importance to their friendship.</p>&#13;
<p class="TX">Throughout this book, we will use graph implementations that support both weighting and directionality. If necessary, these data structures can still be used to store simpler graphs without weighted or directed edges. While this generality adds some small complexity to the data structure and may potentially add overhead to algorithms that do not use all the information, this approach results in a flexible data structure that can be used by a range of algorithms.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h3 class="H1" id="sec5"><span id="h-10"/><samp class="SANS_Futura_Std_Bold_B_11">The Adjacency List Representation</samp></h3>&#13;
<p class="TNI1">The graph representation used throughout the majority of this book is the <i>adjacency list representation</i>, which stores a graph’s structure as a set of individual lists of neighbors for each node. This allows us to mirror real-world phenomena where each node maintains information on its local connections, such as in a social network where individuals maintain contact information for their immediate friends.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_8" aria-label="8"/>There are a variety of ways to implement the adjacency list representation. Nodes and edges can be represented implicitly through associations or explicitly as data structures in their own right. In the simplest implementation, we could implicitly store a graph using a single list of lists, where each node has a numeric ID and each entry in the list corresponds to a given node’s neighbors. For example, consider the following line of code:</p>&#13;
<pre><code>g: list = [[1,3,4], [0,2,4], [1,4], [0,4], [0,1,2,3]]&#13;
</code></pre>&#13;
<p class="TX">This list of lists <samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp> represents the undirected, unweighted graph with five nodes and seven edges shown in <a href="#fig1-6">Figure 1-6</a>. The first entry in the list on the right-hand side of the figure indicates that node 0 has three neighbors: nodes 1, 3, and 4. Each undirected edge is represented in two different neighbor lists, one for the node on each end.</p>&#13;
<figure class="IMG"><img id="fig1-6" class="img80" src="../images/f01006.jpg" alt="The left figure shows a graph with seven edges and five nodes given labels 0 through 4. Node 0 in the graph is connected to nodes 1, 3, and 4. The right figure shows an array where each element points to a list, indicating that node’s neighbors. Element 0 in the array points to a list of the numbers 1, 3, and 4." width="952" height="419"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-6: A graph (left) and its adjacency list representation (right)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Alternatively, we could create a <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> data structure that contains not only the adjacency list but also supplementary information. This might include a label to identify the node, a Boolean indicating whether the node has been processed, or an integer indicating the time at which we first saw the node. We could also make the representation more detailed by defining an <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> data structure with information about directionality and weight, then storing a list of adjacent edges within each node.</p>&#13;
<p class="TX">The optimal representation for any given use case depends highly on the purpose of the data structure. For large graphs in limited memory environments, a sparser representation like the list of lists in <a href="#fig1-6">Figure 1-6</a> might be ideal. However, when modeling more complex problems, such as directional traffic flows over different road conditions, we may need to store more information.</p>&#13;
<p class="TX">The rest of this section introduces a highly structured adjacency list representation that prioritizes generality and understandability so that we can reuse it throughout the different algorithms in this book. We use both <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> objects to facilitate the storage of a variety of auxiliary information for both pieces. Each <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> object maintains its own list of adjacent <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> objects that store the information needed to encode weights and directionality.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_9" aria-label="9"/>An important aspect of this implementation is that each node has a unique <i>numeric index</i> that indicates its location within the overall <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> data structure. Throughout this book, we will refer to a node and its index relatively interchangeably. For example, we refer to the node at index 0 as node 0. We might also say that a function returns a list of nodes visited when the implementation returns a list of indices.</p>&#13;
<p class="TX">As we will see throughout the book, this graph representation lends itself to algorithms that traverse the graph node by node, such as the majority of algorithms in this book. While this implementation is effective for illustrating a range of graph algorithms, the reader may want to use more memory-efficient or computationally efficient representations that are better optimized for specific problems.</p>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h-11"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Edges</samp></h4>&#13;
<p class="TNI1">We define an <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> object as little more than a container that stores information for directed and weighted edges:</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">to_node</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp><b>) </b>Stores the node index of the edge’s destination</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">from_node</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp><b>) </b>Stores the node index of the edge’s origin</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">weight</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">float</samp><b>) </b>Stores the edge’s weight. Where necessary for a particular use case, we’ll use a value of 1 to represent unweighted edges</p>&#13;
<p class="TX">As shown in <a href="#fig1-7">Figure 1-7</a>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> object stores all the information we may need to work with an edge independent from other classes. The inclusion of <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp> in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> class may seem redundant because we are storing the edges in a list at each node and thus can retrieve that information from the node. However, explicitly storing this information will enable us to use algorithms later in the book that work with sets of edges independent of the nodes.</p>&#13;
<figure class="IMG"><img id="fig1-7" class="img30" src="../images/f01007.jpg" alt="A pair of circles joined by an arrow from left to right. The left circle is labeled “from_node”; the right circle is labeled “to_node.” The arrow is labeled “weight.”" width="459" height="139"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-7: The information contained in the</samp> <samp class="SANS_TheSansMonoCd_W7Italic">Edge</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">class</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Using the attributes of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> class, we define a constructor that copies in the data:</p>&#13;
<pre><code>class Edge: &#13;
    def __init__(self, from_node: int, to_node: int, weight: float):&#13;
        self.from_node: int = from_node&#13;
        self.to_node: int = to_node&#13;
        self.weight: float = weight&#13;
</code></pre>&#13;
<p class="TX">Since the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> class is used primarily for storage, it does not include any additional functions. Attributes are accessed directly. We can model undirected edges in the graph by storing a pair of directed edges from each <span role="doc-pagebreak" epub:type="pagebreak" id="pg_10" aria-label="10"/>node. That is, an undirected edge between nodes A and B would materialize as a directed edge from node A to node B and a directed edge from node B to node A. While this doubles the number of edges stored in an undirected graph, it emphasizes flexibility and allows us to use the same class for a range of applications.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> class illustrates how we use the numeric node identifier throughout the code. Instead of storing an explicit link to the node, <samp class="SANS_TheSansMonoCd_W5Regular_11">to_node</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">from_node</samp>, we store the integer index of the corresponding nodes. When we need to access additional attributes within the node, we use these indices to directly look up the <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> object from the graph’s <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes</samp> list.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h-12"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Nodes</samp></h4>&#13;
<p class="TNI1">We define a <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> object to both store the information relevant to the node and provide basic operations on that information. Each <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> object contains the following attributes:</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">index</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp><b>) </b>Stores the numeric index of the node</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">edges</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">dict</samp><b>) </b>Stores the edges out of the node</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">label</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp><b>,</b> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">string</samp><b>, or</b> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">object</samp><b>) </b>An optional label used to identify the node or mark its current state</p>&#13;
<p class="TX">Instead of using a list to store the edges, we use a dictionary keyed by the destination node’s integer index and with <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> objects as values. This representation allows us to efficiently ask questions like “Is there an edge between node A and node B?” without iterating through all of node A’s edges.</p>&#13;
<p class="TX">We can visualize the <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> object as part of a high school social network. Each student is represented as a node with their student ID number as their index. The <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp> dictionary represents that student’s personal list of friends. As noted earlier, each <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> object can be directional and weighted to fully capture the complexities of high school alliances and feuds. The <samp class="SANS_TheSansMonoCd_W5Regular_11">label</samp> string can be used to store information about each student, such as whether they have heard the latest rumor.</p>&#13;
<p class="TX">As with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> classes, we define a constructor to set up the initial state of the node, as well as a series of helper functions:</p>&#13;
<pre><code>class Node:&#13;
    def __init__(self, index: int, label=None): &#13;
        self.index: int = index&#13;
        self.edges: dict = {}&#13;
        self.label = label&#13;
&#13;
    def num_edges(self) -&gt; int: &#13;
        return len(self.edges)&#13;
&#13;
    def get_edge(self, neighbor: int) -&gt; Union[Edge, None]: &#13;
        if neighbor in self.edges:&#13;
            return self.edges[neighbor]&#13;
        return None<span role="doc-pagebreak" epub:type="pagebreak" id="pg_11" aria-label="11"/>&#13;
&#13;
    def add_edge(self, neighbor: int, weight: float): &#13;
        self.edges[neighbor] = Edge(self.index, neighbor, weight)&#13;
&#13;
    def remove_edge(self, neighbor: int): &#13;
        if neighbor in self.edges:&#13;
            del self.edges[neighbor]&#13;
&#13;
    def get_edge_list(self) -&gt; list: &#13;
        return list(self.edges.values())&#13;
&#13;
    def get_sorted_edge_list(self) -&gt; list: &#13;
        result = []&#13;
        neighbors = (list)(self.edges.keys())&#13;
        neighbors.sort()&#13;
&#13;
        for n in neighbors:&#13;
            result.append(self.edges[n])&#13;
        return result&#13;
</code></pre>&#13;
<p class="TX">The constructor sets the integer index (<samp class="SANS_TheSansMonoCd_W5Regular_11">index</samp>) to the given value. It creates an empty dictionary (<samp class="SANS_TheSansMonoCd_W5Regular_11">self.edges</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">{}</samp>) to store future edges and starts with an empty label (<samp class="SANS_TheSansMonoCd_W5Regular_11">self.label</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>).</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> class contains a variety of helper functions to facilitate working with it. When implementing the graph, the <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> class needs to be defined before the <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> class. We also need to import <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp> from Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library (by adding <samp class="SANS_TheSansMonoCd_W5Regular_11">from typing import Union</samp> at the start of the file) to support the optional type hints used in the example code.</p>&#13;
<p class="TX">The first two functions provide access to the node’s edges. The <samp class="SANS_TheSansMonoCd_W5Regular_11">num_edges()</samp> function returns the number of edges. The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp> function returns a given edge, or <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> if no such edge exists. This allows us to combine lookups and existence checks into a single function.</p>&#13;
<p class="TX">The next two functions modify the node’s connections. The <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edge()</samp> function takes a destination index and weight, then creates and inserts the corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">Edge</samp> object. It overwrites the existing edge if the neighbor’s index already appears in the dictionary, allowing us to update edge weights. The function <samp class="SANS_TheSansMonoCd_W5Regular_11">remove_edge()</samp> drops an edge from the dictionary if it exists.</p>&#13;
<p class="TX">The final two functions are convenience functions for returning the node’s edges as lists. The function <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge_list()</samp> returns the edges in their dictionary ordering and is used whenever an algorithm needs access to the list. The function <samp class="SANS_TheSansMonoCd_W5Regular_11">get_sorted_edge_list()</samp> returns the edges in order of increasing neighbor index and is primarily used throughout this book to provide a consistent ordering for examples.</p>&#13;
<p class="TX">While these functions use dictionaries to store a node’s edges (indexed by the destination node), it’s possible to adapt each function to store the node’s edges as a list instead. Compact lists of just the outgoing edges prioritize memory usage over the time it takes to look up a specific edge. In contrast, to prioritize lookup speed for specific edges, each node could store a list of length |<i>V</i> | with a space for each possible edge and store <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> for edges that do not occur. The dictionary-based approach balances these two competing aspects.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_12" aria-label="12"/>&#13;
<h4 class="H2" id="sec8"><span id="h-13"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Graph Class</samp></h4>&#13;
<p class="TNI1">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class used in the majority of this book consists of a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> objects and some utility information that simplifies common computations:</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">nodes</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp><b>) </b>Stores the graph’s nodes</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">num_nodes</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp><b>) </b>Stores the total number of nodes in the graph</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">undirected</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">bool</samp><b>) </b>Indicates whether this is a directed or undirected graph</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">num_nodes</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp> values can be computed from the structure of the graph itself but are stored for convenience.</p>&#13;
<p class="TX">We always store directed edges and use the Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp> to modify behavior when working with directed and undirected graphs. Most notably, as demonstrated later in the section “Accessing, Building, and Modifying the Graph,” we’ll use <samp class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp> to insert a pair of directed edges when the graph itself is undirected. Other common implementations either use separate functions, such as an <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_undirected_edge()</samp> function, or create entirely different implementations for directed and undirected graphs. Again, we are prioritizing generality of the data structure over pure optimization.</p>&#13;
<p class="TX">Given this information, we can create a simple constructor for building a graph with a given number of nodes and no edges:</p>&#13;
<pre><code>class Graph:&#13;
    def __init__(self, num_nodes: int, undirected: bool=False): &#13;
        self.num_nodes: int = num_nodes&#13;
        self.undirected: bool = undirected&#13;
        self.nodes: list = [Node(j) for j in range(num_nodes)]&#13;
</code></pre>&#13;
<p class="TX">The constructor initializes the convenience variables, then creates a list of <samp class="SANS_TheSansMonoCd_W5Regular_11">Node</samp> objects. The function does not create any edges. Implicit in this implementation is the existence of a unique numeric identifier for each node that corresponds to its location in the graph’s <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes</samp> list.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class also includes a variety of functions to create, search, access, and otherwise process graphs. Instead of providing a huge block of code for all graph functions in this section, we’ll introduce the general functions throughout this section.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h5 class="H3" id="sec9"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Accessing, Building, and Modifying the Graph</samp></h5>&#13;
<p class="TNI1">To facilitate accessing edges, we next define a series of helper functions within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class:</p>&#13;
<pre><code>def get_edge(self, from_node: int, to_node: int) -&gt; Union[Edge, None]: &#13;
    if from_node &lt; 0 or from_node &gt;= self.num_nodes:&#13;
        raise IndexError&#13;
    if to_node &lt; 0 or to_node &gt;= self.num_nodes:&#13;
        raise IndexError&#13;
    return self.nodes[from_node].get_edge(to_node)<span role="doc-pagebreak" epub:type="pagebreak" id="pg_13" aria-label="13"/>&#13;
&#13;
def is_edge(self, from_node: int, to_node: int) -&gt; bool: &#13;
    return self.get_edge(from_node, to_node) is not None&#13;
&#13;
def make_edge_list(self) -&gt; list:&#13;
    all_edges: list = []&#13;
    for node in self.nodes:&#13;
        for edge in node.edges.values():&#13;
            all_edges.append(edge)&#13;
    return all_edges&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp> function takes an origin index and a destination index and returns the corresponding edge, if it exists. It performs basic bounds checking for validity, then uses the origin node’s corresponding <samp class="SANS_TheSansMonoCd_W5Regular_11">get_edge()</samp> function to retrieve an edge if one exists and return <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> otherwise. The <samp class="SANS_TheSansMonoCd_W5Regular_11">is_edge()</samp> function simply checks for the existence of any edge with the given origin and destination. Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">make_edge_list()</samp> function dynamically constructs and returns a list of all edges in the graph.</p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class’s constructor allocates a given number of nodes but does not create any edges. Obviously, this does not produce a remotely useful graph. To model any interesting problem, our graph needs to include both nodes and edges. We therefore add a few additional functions for creating and modifying our adjacency graph representation. First, in the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class, we provide the ability to add and remove edges given the indices of the origin and destination nodes:</p>&#13;
<pre><code>def insert_edge(self, from_node: int, to_node: int, weight: float): &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if from_node &lt; 0 or from_node &gt;= self.num_nodes:&#13;
        raise IndexError&#13;
    if to_node &lt; 0 or to_node &gt;= self.num_nodes:&#13;
        raise IndexError&#13;
&#13;
    self.nodes[from_node].add_edge(to_node, weight)&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if self.undirected:&#13;
        self.nodes[to_node].add_edge(from_node, weight)&#13;
&#13;
def remove_edge(self, from_node: int, to_node: int): &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if from_node &lt; 0 or from_node &gt;= self.num_nodes:&#13;
        raise IndexError&#13;
    if to_node &lt; 0 or to_node &gt;= self.num_nodes:&#13;
        raise IndexError&#13;
&#13;
    self.nodes[from_node].remove_edge(to_node)&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> if self.undirected:&#13;
        self.nodes[to_node].remove_edge(from_node)&#13;
</code></pre>&#13;
<p class="TX">Both the <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">remove_edge()</samp> functions follow the same flow: they start by checking that both the origin and destination indices correspond to nodes included in the graph <span class="CodeAnnotationCode" aria-label="annotation1">❶</span> <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. If the node indices are invalid, the functions raise an <samp class="SANS_TheSansMonoCd_W5Regular_11">IndexError</samp>.</p>&#13;
<p class="TX">If the indices are valid, the functions modify the adjacency list of the origin node. The insertion function uses the node’s <samp class="SANS_TheSansMonoCd_W5Regular_11">add_edge()</samp> function. <span role="doc-pagebreak" epub:type="pagebreak" id="pg_14" aria-label="14"/>The removal function uses the node’s <samp class="SANS_TheSansMonoCd_W5Regular_11">remove_edge()</samp> function. Because we are using a single class to represent both directed and undirected graphs, the functions also need to add <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> or remove <span class="CodeAnnotationCode" aria-label="annotation4">❹</span> the corresponding inverse edge in the case of an undirected graph.</p>&#13;
<p class="TX">We can use these functions together to dynamically create graphs. For example, we can use the following code to create a directed graph with five nodes and then insert eight weighted edges:</p>&#13;
<pre><code>g: Graph = Graph(5, undirected=False)&#13;
g.insert_edge(0, 1, 1.0)&#13;
g.insert_edge(0, 3, 1.0)&#13;
g.insert_edge(0, 4, 3.0)&#13;
g.insert_edge(1, 2, 2.0)&#13;
g.insert_edge(1, 4, 1.0)&#13;
g.insert_edge(3, 4, 3.0)&#13;
g.insert_edge(4, 2, 3.0)&#13;
g.insert_edge(4, 3, 3.0)&#13;
</code></pre>&#13;
<p class="TX">This generates the graph shown in <a href="#fig1-8">Figure 1-8</a>.</p>&#13;
<figure class="IMG"><img id="fig1-8" class="img40" src="../images/f01008.jpg" alt="a five-node graph with arrows linking the nodes. Each arrow is labeled with a number. For example, Node 0 has an arrow to node 1 with weight 1.0, an arrow to node 3 with weight 1.0, and an arrow to node 4 with weight 3.0." width="586" height="369"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-8: A directed and weighted graph with nodes labeled by their indices</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">While we provide the ability to pre-allocate nodes in the constructor, for some algorithms, we need to insert new nodes as we explore a graph. To facilitate this, we also provide a function for inserting new nodes:</p>&#13;
<pre><code>def insert_node(self, label=None) -&gt; Node: &#13;
    new_node: Node = Node(self.num_nodes, label=label)&#13;
    self.nodes.append(new_node)&#13;
    self.num_nodes += 1&#13;
    return new_node&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_node()</samp> function creates a new node and automatically assigns the identification number to the next index. The node is then appended to the <samp class="SANS_TheSansMonoCd_W5Regular_11">nodes</samp> list, the count of nodes is incremented, and the new node is returned.</p>&#13;
<p class="TX">While the functions in this section provide the building blocks for constructing graphs, it would be tedious to manually specify graphs with a long sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_node()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">insert_edge()</samp> calls. <span class="Xref"><a href="appendix_A.xhtml">Appendix A</a></span> examines a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_15" aria-label="15"/>few sample algorithms that build off these initial functions to programmatically create graphs from files or common problem specifications.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h5 class="H3" id="sec10"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Copying the Graph</samp></h5>&#13;
<p class="TNI1">Finally, we also define a helper function within the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class that produces a new copy of the graph for use with algorithms that modify the graph:</p>&#13;
<pre><code>def make_copy(self): &#13;
    g2: Graph = Graph(self.num_nodes, undirected=self.undirected)&#13;
    for node in self.nodes:&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> g2.nodes[node.index].label = node.label&#13;
        for edge in node.edges.values():&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> g2.insert_edge(edge.from_node, edge.to_node, edge.weight)&#13;
    return g2&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">make_copy()</samp> code starts by creating a new <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> object (<samp class="SANS_TheSansMonoCd_W5Regular_11">g2</samp>) with the same number of nodes and undirected setting as the current graph. It then uses two nested <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loops to iterate through each node and its outgoing edges. For each node, it copies the label <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. For each edge, it inserts an equivalent edge into <samp class="SANS_TheSansMonoCd_W5Regular_11">g2</samp> <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">Copying the graph will allow us to employ algorithms that destructively modify the graph. For example, in <span class="Xref"><a href="chapter16.xhtml">Chapter 16</a></span> we will introduce an algorithm for assigning colors that iteratively removes nodes from the graph.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1" id="sec11"><span id="h-14"/><samp class="SANS_Futura_Std_Bold_B_11">The Adjacency Matrix Representation</samp></h3>&#13;
<p class="TNI1">Another powerful graph representation is the <i>adjacency matrix</i>. While we will primarily rely on the previous adjacency list representation for most of the algorithms in this book, the adjacency matrix representation is important for an entire class of mathematically based algorithms. Many algorithms can be described or analyzed via matrix operations. We will make use of the matrix formulation in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span> when considering random walks on graphs.</p>&#13;
<p class="TX">The <i>adjacency matrix</i> representation of a graph uses a single matrix to indicate the edge weights between each pair of nodes. The value in row <i>i</i>, column <i>j</i>, represents the weight of the edge from node <i>i</i> to node <i>j</i>. A value of 0 indicates that no such edge exists. Represented as a list of lists, the following matrix would create an undirected, unweighted graph with five nodes and seven edges:</p>&#13;
<pre><code>g = [[0, 1, 0, 1, 1],&#13;
     [1, 0, 1, 0, 1],&#13;
     [0, 1, 0, 0, 1],&#13;
     [1, 0, 0, 0, 1],&#13;
     [1, 1, 1, 1, 0]]&#13;
</code></pre>&#13;
<p class="TX">This corresponds to the graph shown in <a href="#fig1-9">Figure 1-9</a>, where node 0’s three connections are represented by the corresponding nonzero entries in the matrix.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_16" aria-label="16"/>&#13;
<figure class="IMG"><img id="fig1-9" class="img80" src="../images/f01009.jpg" alt="The left figure shows a graph with five nodes given labels 0 through 4. Node 0 is connected to nodes 1, 3, and 4. The right figure shows a 5 × 5 matrix filled with values of 0 and 1. The top row, indicating connections from node 0 reads 0, 1, 0, 1, 1." width="1056" height="460"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-9: A graph (left) and its adjacency matrix representation (right)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The matrix of connection can use any setting of values. Floating-point entries can be used to represent weighted edges. Undirected edges are represented by a matching pair of values, making undirected graphs symmetric.</p>&#13;
<p class="TX">To create and store adjacency graphs, we’ll use the basic <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp> class presented in this section. As with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class, we optimize the representation for understandability rather than computational cost or memory usage.</p>&#13;
<p class="TX">Our <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp> class contains three pieces of information:</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">connections</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp> <b>of</b> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">list</samp><b>) </b>Stores the adjacency matrix</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">num_nodes</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp><b>) </b>Stores the total number of nodes in the graph</p>&#13;
<p class="RunInPara"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">undirected</samp> <b>(</b><samp class="SANS_TheSansMonoCd_W7Bold_B_11">bool</samp><b>) </b>Indicates whether this is a directed or undirected graph</p>&#13;
<p class="TX">As with the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> data structure, we allow <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp> to represent both directed and undirected graphs. We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">undirected</samp> attribute to specify which type of edges are included. We define a simple constructor for building a graph with a given number of nodes and no edges:</p>&#13;
<pre><code>class GraphMatrix:&#13;
    def __init__(self, num_nodes: int, undirected: bool=False): &#13;
        self.num_nodes: int = num_nodes&#13;
        self.undirected: bool = undirected&#13;
        self.connections = [[0.0] * num_nodes for _ in range(num_nodes)]&#13;
</code></pre>&#13;
<p class="TX">The code initializes every entry in <samp class="SANS_TheSansMonoCd_W5Regular_11">connections</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>, creating a graph without any edges.</p>&#13;
<p class="TX">We also define a getter function to retrieve the weight of a connection between two nodes:</p>&#13;
<pre><code>def get_edge(self, from_node: int, to_node: int) -&gt; float: &#13;
    if from_node &lt; 0 or from_node &gt;= self.num_nodes:&#13;
        raise IndexError<span role="doc-pagebreak" epub:type="pagebreak" id="pg_17" aria-label="17"/>&#13;
    if to_node &lt; 0 or to_node &gt;= self.num_nodes:&#13;
        raise IndexError&#13;
    return self.connections[from_node][to_node]&#13;
</code></pre>&#13;
<p class="TX">The code checks that both the origin and destination indices are valid. If so, the core returns the corresponding floating-point value from the array.</p>&#13;
<p class="TX">While we store the adjacency matrix in a list of lists to keep this illustration simple, it is often preferable to use a representation optimized for matrix operations, such as that provided in the popular numpy package. Such numerical packages will be faster and provide a range of helper functions. We leave the implementation of a <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp> in numpy or a similar mathematical package as an exercise for the reader.</p>&#13;
<p class="TX">Unlike the <samp class="SANS_TheSansMonoCd_W5Regular_11">Graph</samp> class, a new <samp class="SANS_TheSansMonoCd_W5Regular_11">GraphMatrix</samp> object pre-allocates all the space to store edge information in the main <samp class="SANS_TheSansMonoCd_W5Regular_11">connections</samp> matrix. We can directly set entries in this matrix to add or remove edges:</p>&#13;
<pre><code>def set_edge(self, from_node: int, to_node: int, weight: float):&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if from_node &lt; 0 or from_node &gt;= self.num_nodes:&#13;
        raise IndexError&#13;
    if to_node &lt; 0 or to_node &gt;= self.num_nodes:&#13;
        raise IndexError&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> self.connections[from_node][to_node] = weight&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if self.undirected:&#13;
        self.connections[to_node][from_node] = weight&#13;
</code></pre>&#13;
<p class="TX">The code checks that both the origin and destination indices are valid and, if not, raises an error <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. If the indices are valid, the function sets the matrix entry corresponding to this edge <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. If the graph is undirected, the function modifies the symmetric entry in the matrix <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>.</p>&#13;
<p class="TX">We can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">set_edge()</samp> function to add, remove, or modify edges. We add new edges by setting the entries to nonzero weights. If an edge already exists between those two nodes, the function updates the weight. We remove edges by setting an entry to 0. For example, we could create the graph in <a href="#fig1-8">Figure 1-8</a> as:</p>&#13;
<pre><code>g: GraphMatrix = GraphMatrix(5, undirected=False)&#13;
g.set_edge(0, 1, 1.0)&#13;
g.set_edge(0, 3, 1.0)&#13;
g.set_edge(0, 4, 3.0)&#13;
g.set_edge(1, 2, 2.0)&#13;
g.set_edge(1, 4, 1.0)&#13;
g.set_edge(3, 4, 3.0)&#13;
g.set_edge(4, 2, 3.0)&#13;
g.set_edge(4, 3, 3.0)  &#13;
</code></pre>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_18" aria-label="18"/>&#13;
<h3 class="H1" id="sec12"><span id="h-15"/><samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp></h3>&#13;
<p class="TNI1">The graph structure and its underlying implementations form the foundation of all algorithms in this book and drive their development. Deciding which representation to use requires us to consider trade-offs in memory usage, computational efficiency, and complexity, depending on what makes sense for the task at hand. In cases where we want only to iterate over a node’s immediate neighbors, for example, the best choice might be an adjacency list representation because we can access the neighbor lists independently. In contrast, for algorithms that are more mathematical, we might prefer a matrix representation that can make use of existing mathematical libraries.</p>&#13;
<p class="TX">The goal of introducing the implementations in this chapter is not to provide a single canonical approach, but rather to introduce the different ways of thinking about graphs and the different trade-offs inherent in their representations. There are a huge variety of hybrid approaches or further adaptations we can make to the implementations presented in this chapter to optimize a graph representation to the problem of interest.</p>&#13;
<p class="TX">In the following chapters, we’ll introduce a series of problems we can solve using graphs, building on the concepts and code introduced in this chapter as we do so. For each problem, we present a few practical algorithms that can readily be applied in real-world situations. We’ll start in the next chapter by introducing the concept of neighboring nodes and using algorithms to construct neighborhoods.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>