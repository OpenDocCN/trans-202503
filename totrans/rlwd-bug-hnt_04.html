<html><head></head><body>
<h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_29"/><strong><span class="big">4</span><br/>CROSS-SITE REQUEST FORGERY</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/common.jpg"/></div>&#13;
<p class="noindent">A <em>cross-site request forgery (CSRF)</em> attack occurs when an attacker can make a target’s browser send an HTTP request to another website. That website then performs an action as though the request were valid and sent by the target. Such an attack typically relies on the target being previously authenticated on the vulnerable website where the action is submitted and occurs without the target’s knowledge. When a CSRF attack is successful, the attacker is able to modify server-side information and might even take over a user’s account. Here is a basic example, which we’ll walk through shortly:</p>&#13;
<ol>&#13;
<li class="noindent">Bob logs into his banking website to check his balance.</li>&#13;
<li class="noindent">When he’s finished, Bob checks his email account on a different domain.</li>&#13;
<li class="noindent">Bob has an email with a link to an unfamiliar website and clicks the link to see where it leads.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_30"/>When loaded, the unfamiliar site instructs Bob’s browser to make an HTTP request to Bob’s banking website, requesting a money transfer from his account to the attacker’s.</li>&#13;
<li class="noindent">Bob’s banking website receives the HTTP request initiated from the unfamiliar (and malicious) website. But because the banking website doesn’t have any CSRF protections, it processes the transfer.</li>&#13;
</ol>&#13;
<h3 class="h3" id="ch04lev1sec1"><strong>Authentication</strong></h3>&#13;
<p class="noindent">CRSF attacks, like the one I just described, take advantage of weaknesses in the process websites use to authenticate requests. When you visit a website that requires you to log in, usually with a username and password, that site will typically authenticate you. The site will then store that authentication in your browser so you don’t have to log in every time you visit a new page on that site. It can store the authentication in two ways: using the basic authentication protocol or a cookie.</p>&#13;
<p class="indent">You can identify a site that uses basic authorization when HTTP requests include a header that looks like this: <span class="literal">Authorization: Basic QWxhZGRpbjpPcGVuU2VzYW1l</span>. The random-looking string is a base64-encoded username and password separated by a colon. In this case, <span class="literal">QWxhZGRpbjpPcGVuU2VzYW1l</span> decodes to <span class="literal">Aladdin:OpenSesame</span>. We won’t focus on basic authentication in this chapter, but you can use many of the techniques covered here to exploit CSRF vulnerabilities that use basic authentication.</p>&#13;
<p class="indent"><em>Cookies</em> are small files that websites create and store in the user’s browser. Websites use cookies for various purposes, such as for storing information like user preferences or the user’s history of visiting a website. Cookies have certain <em>attributes</em>, which are standardized pieces of information. Those details tell browsers about the cookies and how to treat them. Some cookie attributes can include <span class="literal">domain</span>, <span class="literal">expires</span>, <span class="literal">max-age</span>, <span class="literal">secure</span>, and <span class="literal">httponly</span>, which you’ll learn about later in this chapter. In addition to attributes, cookies can contain a <em>name/value pair</em>, which consists of an identifier and an associated value that is passed to a website (the cookie’s <span class="literal">domain</span> attribute defines the site to pass this information to).</p>&#13;
<p class="indent">Browsers define the number of cookies that a site can set. But typically, single sites can set anywhere from 50 to 150 cookies in common browsers, and some reportedly support upward of 600. Browsers generally allow sites to use a maximum of 4KB per cookie. There is no standard for cookie names or values: sites are free to choose their own name/value pairs and purposes. For example, a site could use a cookie named <span class="literal">sessionId</span> to remember who a user is rather than having them enter their username and password for every page they visit or action they perform. (Recall that HTTP requests are stateless, as described in <a href="ch01.xhtml#ch01">Chapter 1</a>. Stateless means that with every HTTP request, a website doesn’t know who a user is, so it must reauthenticate that user for every request.)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_31"/>As an example, a name/value pair in a cookie could be <span class="literal">sessionId=9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08</span> and the cookie could have a <span class="literal">domain</span> of <span class="literal">.</span><span class="codeitalic">site</span><span class="literal">.com</span>. Consequently, the <span class="literal">sessionId</span> cookie will be sent to every <em>.&lt;site&gt;.com</em> site a user visits, such as <em>foo.&lt;site&gt;.com</em>, <em>bar.&lt;site&gt;.com</em>, <em>www.&lt;site&gt;.com</em>, and so on.</p>&#13;
<p class="indent">The <span class="literal">secure</span> and <span class="literal">httponly</span> attributes tell browsers when and how to send and read cookies. These attributes don’t contain values; instead, they act as flags that are either present in the cookie or are not. When a cookie contains the <span class="literal">secure</span> attribute, browsers will only send that cookie when visiting HTTPS sites. For example, if you visited <em>http://www.&lt;site&gt;.com/</em> (an HTTP site) with a secure cookie, your browser wouldn’t send the cookie to that site. The reason is to protect your privacy, because HTTPS connections are encrypted and HTTP connections are not. The <span class="literal">httponly</span> attribute, which will become important when you learn about cross-site scripting in <a href="ch07.xhtml#ch07">Chapter 7</a>, tells the browser to read a cookie only through HTTP and HTTPS requests. Therefore, browsers won’t allow any scripting languages, such as JavaScript, to read that cookie’s value. When the <span class="literal">secure</span> and <span class="literal">httponly</span> attributes are not set in cookies, those cookies could be sent legitimately but read maliciously. A cookie without the <span class="literal">secure</span> attribute can be sent to a non-HTTPS site; likewise, a cookie without <span class="literal">httponly</span> set can be read by JavaScript.</p>&#13;
<p class="indent">The <span class="literal">expires</span> and <span class="literal">max-age</span> attributes indicate when a cookie should expire and the browser should destroy it. The <span class="literal">expires</span> attribute simply tells the browser to destroy a cookie on a specific date. For example, a cookie could set the attribute to <span class="literal">expires=Wed, 18 Dec 2019 12:00:00 UTC</span>. In contrast, the <span class="literal">max-age</span> is the number of seconds until the cookie expires and is formatted as an integer (<span class="literal">max-age=300</span>).</p>&#13;
<p class="indent">To summarize, if the banking site Bob visits uses cookies, the site will store his authentication with the following process. Once Bob visits the site and logs in, the bank will respond to his HTTP request with an HTTP response, which includes a cookie that identifies Bob. In turn, Bob’s browser will automatically send that cookie with all other HTTP requests to the banking website.</p>&#13;
<p class="indent">After finishing his banking, Bob doesn’t log out when he leaves the banking website. Note this important detail, because when you log out of a site, that site will typically respond with an HTTP response that expires your cookie. As a result, when you revisit the site, you’ll have to log in again.</p>&#13;
<p class="indent">When Bob checks his email and clicks the link to visit the unknown site, he is inadvertently visiting a malicious website. That website is designed to perform a CSRF attack by instructing Bob’s browser to make a request to his banking website. This request will also send cookies from his browser.</p>&#13;
<h3 class="h3" id="ch04lev1sec2"><strong>CSRF with GET Requests</strong></h3>&#13;
<p class="noindent">The way the malicious site exploits Bob’s banking site depends on whether the bank accepts transfers via <span class="literal">GET</span> or <span class="literal">POST</span> requests. If Bob’s banking site accepts transfers via <span class="literal">GET</span> requests, the malicious site will send the HTTP <span epub:type="pagebreak" id="page_32"/>request with either a hidden form or an <span class="literal">&lt;img&gt;</span> tag. The <span class="literal">GET</span> and <span class="literal">POST</span> methods both rely on HTML to make browsers send the required HTTP request, and both methods can use the hidden form technique, but only the <span class="literal">GET</span> method can use the <span class="literal">&lt;img&gt;</span> tag technique. In this section, we’ll look at how the attack works with the HTML <span class="literal">&lt;img&gt;</span> tag technique when using the <span class="literal">GET</span> request method, and we’ll look at the hidden form technique in the next section, “<a href="ch04.xhtml#ch04lev1sec3">CSRF with <span class="literal">POST</span> Requests</a>.”</p>&#13;
<p class="indent">The attacker needs to include Bob’s cookies in any transfer HTTP request to Bob’s banking website. But because the attacker has no way of reading Bob’s cookies, the attacker can’t just create an HTTP request and send it to the banking site. Instead, the attacker can use the HTML <span class="literal">&lt;img&gt;</span> tag to create a <span class="literal">GET</span> request that also includes Bob’s cookies. An <span class="literal">&lt;img&gt;</span> tag renders images on a web page and includes an <span class="literal">src</span> attribute, which tells browsers where to locate image files. When a browser renders an <span class="literal">&lt;img&gt;</span> tag, it will make an HTTP <span class="literal">GET</span> request to the <span class="literal">src</span> attribute in the tag and include any existing cookies in that request. So, let’s say that the malicious site uses a URL like the following that transfers $500 from Bob to Joe:</p>&#13;
<p class="programs">https://www.<span class="codeitalic1">bank</span>.com/transfer?from=bob&amp;to=joe&amp;amount=500</p>&#13;
<p class="indent">Then the malicious <span class="literal">&lt;img&gt;</span> tag would use this URL as its source value, as in the following tag:</p>&#13;
<p class="programs">&lt;img src="https://www.<span class="codeitalic1">bank</span>.com/transfer?from=bob&amp;to=joe&amp;amount=500"&gt;</p>&#13;
<p class="indent">As a result, when Bob visits the attacker-owned site, it includes the <span class="literal">&lt;img&gt;</span> tag in its HTTP response, and the browser then makes the HTTP <span class="literal">GET</span> request to the bank. The browser sends Bob’s authentication cookies to get what it thinks should be an image. But in fact, the bank receives the request, processes the URL in the tag’s <span class="literal">src</span> attribute, and creates the transfer request.</p>&#13;
<p class="indent">To avoid this vulnerability, developers should never use HTTP <span class="literal">GET</span> requests to perform any backend data-modifying requests, such as transferring money. But any request that is read-only should be safe. Many common web frameworks used to build websites, such as Ruby on Rails, Django, and so on, will expect developers to follow this principle, and so they’ll automatically add CSRF protections to <span class="literal">POST</span> requests but not <span class="literal">GET</span> requests.</p>&#13;
<h3 class="h3" id="ch04lev1sec3"><strong>CSRF with POST Requests</strong></h3>&#13;
<p class="noindent">If the bank performs transfers with <span class="literal">POST</span> requests, you’ll need to use a different approach to create a CSRF attack. An attacker couldn’t use an <span class="literal">&lt;img&gt;</span> tag, because an <span class="literal">&lt;img&gt;</span> tag can’t invoke a <span class="literal">POST</span> request. Instead, the attacker’s strategy will depend on the contents of the <span class="literal">POST</span> request.</p>&#13;
<p class="indent">The simplest situation involves a <span class="literal">POST</span> request with the content-type <span class="literal">application/x-www-form-urlencoded</span> or <span class="literal">text/plain</span>. The content-type is a header <span epub:type="pagebreak" id="page_33"/>that browsers might include when sending HTTP requests. The header tells the recipient how the body of the HTTP request is encoded. Here is an example of a <span class="literal">text/plain</span> content-type request:</p>&#13;
<p class="programs">   POST / HTTP/1.1<br/>&#13;
   Host: www.google.ca<br/>&#13;
   User-Agent: Mozilla/5.0 (Windows NT 6.1; rv:50.0) Gecko/20100101 Firefox/50.0<br/>&#13;
   Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<br/>&#13;
   Content-Length: 5<br/>&#13;
<span class="ent">➊</span> Content-Type: text/plain;charset=UTF-8<br/>&#13;
   DNT: 1<br/>&#13;
   Connection: close<br/>&#13;
   hello</p>&#13;
<p class="indent">The content-type <span class="ent">➊</span> is labeled, and its type is listed along with the character encoding of the request. The content-type is important because browsers treat types differently (which I’ll get to in a second).</p>&#13;
<p class="indent">In this situation, it’s possible for a malicious site to create a hidden HTML form and submit it silently to the vulnerable site without the target’s knowledge. The form can submit a <span class="literal">POST</span> or <span class="literal">GET</span> request to a URL and can even submit parameter values. Here is an example of some harmful code in the website that the malicious link would direct Bob to:</p>&#13;
<p class="programs"><span class="ent">➊</span> &lt;iframe style="display:none" name="csrf-frame"&gt;&lt;/iframe&gt;<br/>&#13;
<span class="ent">➋</span> &lt;form method='POST' action='http://<span class="codeitalic1">bank</span>.com/transfer' target="csrf-frame"<br/>&#13;
   id="csrf-form"&gt;<br/>&#13;
  <span class="ent">➌</span> &lt;input type='hidden' name='from' value='Bob'&gt;<br/>&#13;
     &lt;input type='hidden' name='to' value='Joe'&gt;<br/>&#13;
     &lt;input type='hidden' name='amount' value='500'&gt;<br/>&#13;
     &lt;input type='submit' value='submit'&gt;<br/>&#13;
   &lt;/form&gt;<br/>&#13;
<span class="ent">➍</span> &lt;script&gt;document.getElementById("csrf-form").submit()&lt;/script&gt;</p>&#13;
<p class="indent">Here, we’re making an HTTP <span class="literal">POST</span> request <span class="ent">➋</span> to Bob’s bank with a form (which is denoted by the action attribute in the <span class="literal">&lt;form&gt;</span> tag). Because the attacker doesn’t want Bob to see the form, each of the <span class="literal">&lt;input&gt;</span> elements <span class="ent">➌</span> are given the type <span class="literal">'hidden'</span>, which makes them invisible on the web page Bob sees. As the final step, the attacker includes some JavaScript inside a <span class="literal">&lt;script&gt;</span> tag to automatically submit the form when the page is loaded <span class="ent">➍</span>. The JavaScript does this by calling the <span class="literal">getElementByID()</span> method on the HTML document with the ID of the form (<span class="literal">"csrf-form"</span>) that we set in the second line <span class="ent">➋</span> as an argument. As with a <span class="literal">GET</span> request, once the form is submitted, the browser makes the HTTP <span class="literal">POST</span> request to send Bob’s cookies to the bank site, which invokes a transfer. Because <span class="literal">POST</span> requests send an HTTP response back to the browser, the attacker hides the response in an iFrame using the <span class="literal">display:none</span> attribute <span class="ent">➊</span>. As a result, Bob doesn’t see it and doesn’t realize what has happened.</p>&#13;
<p class="indent">In other scenarios, a site might expect the <span class="literal">POST</span> request to be submitted with the content-type <span class="literal">application/json</span> instead. In some cases, a request that is an <span class="literal">application/json</span> type will have a <em>CSRF token</em>. This token is a value <span epub:type="pagebreak" id="page_34"/>that is submitted with the HTTP request so the legitimate site can validate that the request originated from itself, not from another, malicious site. Sometimes the HTTP body of the <span class="literal">POST</span> request includes the token, but at other times the <span class="literal">POST</span> request has a custom header with a name like <span class="literal">X-CSRF-TOKEN</span>. When a browser sends an <span class="literal">application/json POST</span> request to a site, it will send an <span class="literal">OPTIONS</span> HTTP request before the <span class="literal">POST</span> request. The site then returns a response to the <span class="literal">OPTIONS</span> call indicating which types of HTTP requests it accepts and from what trusted origins. This is referred to as a preflight <span class="literal">OPTIONS</span> call. The browser reads this response and then makes the appropriate HTTP request, which in our bank example would be a <span class="literal">POST</span> request for the transfer.</p>&#13;
<p class="indent">If implemented correctly, the preflight <span class="literal">OPTIONS</span> call protects against some CSRF vulnerabilities: the malicious sites won’t be listed as trusted sites by the server, and browsers will only allow specific websites (known as <em>white-listed websites</em>) to read the HTTP <span class="literal">OPTIONS</span> response. As a result, because the malicious site can’t read the <span class="literal">OPTIONS</span> response, browsers won’t send the malicious <span class="literal">POST</span> request.</p>&#13;
<p class="indent">The set of rules defining when and how websites can read responses from each other is called <em>cross-origin resource sharing (CORS)</em>. CORS restricts resource access, including JSON response access, from a domain outside that which served the file or is allowed by the site being tested. In other words, when developers use CORS to protect a site, you can’t submit an <span class="literal">application/json</span> request to call the application being tested, read the response, and make another call unless the site being tested allows it. In some situations, you can bypass these protections by changing the <span class="literal">content-type</span> header to <span class="literal">application/x-www-form-urlencoded</span>, <span class="literal">multipart/form-data</span>, or <span class="literal">text/plain</span>. Browsers don’t send preflight <span class="literal">OPTIONS</span> calls for any of these three content-types when making a <span class="literal">POST</span> request, so a CSRF request might work. If it doesn’t, look at the <span class="literal">Access-Control-Allow-Origin</span> header in the server’s HTTP responses to double-check that the server is not trusting arbitrary origins. If that response header changes when requests are sent from arbitrary origins, the site might have bigger problems because it allows any origin to read responses from its server. This allows for CSRF vulnerabilities but might also allow malicious attackers to read any sensitive data returned in the server’s HTTP responses.</p>&#13;
<h3 class="h3" id="ch04lev1sec4"><strong>Defenses Against CSRF Attacks</strong></h3>&#13;
<p class="noindent">You can mitigate CSRF vulnerabilities in a number of ways. One of the most popular forms of protection against CSRF attacks is the CSRF token. Protected sites require the CSRF token when requests are submitted that could potentially alter data (that is, <span class="literal">POST</span> requests). In such a situation, a web application (like Bob’s bank) would generate a token with two parts: one that Bob would receive and one that the application would retain. When Bob attempts to make transfer requests, he would have to submit his token, which the bank would then validate with its side of the token. The design of these tokens makes them unguessable and only accessible to the specific user they’re assigned to (like Bob). In addition, they aren’t always obviously <span epub:type="pagebreak" id="page_35"/>named, but some potential examples of names include <span class="literal">X-CSRF-TOKEN</span>, <span class="literal">lia-token</span>, <span class="literal">rt</span>, or <span class="literal">form-id</span>. Tokens can be included in HTTP request headers, in an HTTP <span class="literal">POST</span> body, or as a hidden field, as in the following example:</p>&#13;
<p class="programs">&lt;form method='POST' action='http://<span class="codeitalic1">bank</span>.com/transfer'&gt;<br/>&#13;
  &lt;input type='text' name='from' value='Bob'&gt;<br/>&#13;
  &lt;input type='text' name='to' value='Joe'&gt;<br/>&#13;
  &lt;input type='text' name='amount' value='500'&gt;<br/>&#13;
  &lt;input type='hidden' name='csrf' value='lHt7DDDyUNKoHCC66BsPB8aN4p24hxNu6ZuJA+8l+YA='&gt;<br/>&#13;
  &lt;input type='submit' value='submit'&gt;<br/>&#13;
&lt;/form&gt;</p>&#13;
<p class="indent">In this example, the site could get the CSRF token from a cookie, an embedded script on the website, or as part of the content delivered from the site. Regardless of the method, only the target’s web browser would know and be able to read the value. Because the attacker couldn’t submit the token, they wouldn’t be able to successfully submit a <span class="literal">POST</span> request and wouldn’t be able to carry out a CSRF attack. However, just because a site uses CSRF tokens doesn’t mean it’s a dead end when you’re searching for vulnerabilities to exploit. Try removing the token, changing its value, and so on to confirm the token has been properly implemented.</p>&#13;
<p class="indent">The other way sites protect themselves is by using CORS; however, this isn’t foolproof because it relies on browser security and ensuring proper CORS configurations to determine when third-party sites can access responses. Attackers can sometimes bypass CORS by changing the content-type from <span class="literal">application/json</span> to <span class="literal">application/x-www-form-urlencoded</span> or by using a <span class="literal">GET</span> request instead of a <span class="literal">POST</span> request because of misconfigurations on the server side. The reason the bypass works is that browsers will automatically send an <span class="literal">OPTIONS HTTP</span> request when the content type is <span class="literal">application/json</span> but won’t automatically send an <span class="literal">OPTIONS HTTP</span> request if it’s a <span class="literal">GET</span> request or the content type is <span class="literal">application/x-www-form-urlencoded</span>.</p>&#13;
<p class="indent">Lastly, there are two additional and less common CSRF mitigation strategies. First, the site could check the value of the <span class="literal">Origin</span> or <span class="literal">Referer</span> header submitted with an HTTP request and ensure it contains the expected value. For example, in some cases, Twitter will check the <span class="literal">Origin</span> header and, if it’s not included, check the <span class="literal">Referer</span> header. This works because browsers control these headers and attackers can’t set or change them remotely (obviously, this excludes exploiting a vulnerability in browsers or browser plug-ins that might allow an attacker to control either header). Second, browsers are now beginning to implement support for a new cookie attribute called <span class="literal">samesite</span>. This attribute can be set as <span class="literal">strict</span> or <span class="literal">lax</span>. When set as <span class="literal">strict</span>, the browser will not send the cookie with any HTTP request that doesn’t originate from the site. This includes even simple HTTP <span class="literal">GET</span> requests. For example, if you were logged into Amazon and it used <span class="literal">strict samesite</span> cookies, the browser would not submit your cookies if you were following a link from another site. Also, Amazon would not recognize you as logged in until you visited another Amazon web page and the cookies were then submitted. In contrast, setting the <span class="literal">samesite</span> attribute as <span class="literal">lax</span> instructs browsers to send cookies with initial <span class="literal">GET</span> requests. This supports the design principle that <span class="literal">GET</span> requests <span epub:type="pagebreak" id="page_36"/>should never alter data on the server side. In this case, if you were logged into Amazon and it used <span class="literal">lax samesite</span> cookies, the browser would submit your cookies and Amazon would recognize you as logged in if you had been redirected there from another site.</p>&#13;
<h3 class="h3" id="ch04lev1sec5"><strong>Shopify Twitter Disconnect</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Low</p>&#13;
<p class="hang"><strong>URL:</strong> <em>https://twitter-commerce.shopifyapps.com/auth/twitter/disconnect/</em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://www.hackerone.com/reports/111216/">https://www.hackerone.com/reports/111216/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> January 17, 2016</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $500</p>&#13;
<p class="noindent">When you’re looking for potential CSRF vulnerabilities, be on the lookout for <span class="literal">GET</span> requests that modify server-side data. For example, a hacker discovered a vulnerability in a Shopify feature that integrated Twitter into the site to let shop owners tweet about their products. The feature also allowed users to disconnect a Twitter account from a connected shop. The URL to disconnect a Twitter account was the following:</p>&#13;
<p class="programs">https://twitter-commerce.shopifyapps.com/auth/twitter/disconnect/</p>&#13;
<p class="indent">As it turns out, visiting this URL would send a <span class="literal">GET</span> request to disconnect the account, as follows:</p>&#13;
<p class="programs">GET /auth/twitter/disconnect HTTP/1.1<br/>&#13;
Host: twitter-commerce.shopifyapps.com<br/>&#13;
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:43.0) Gecko/20100101 Firefox/43.0<br/>&#13;
Accept: text/html, application/xhtml+xml, application/xml<br/>&#13;
Accept-Language: en-US,en;q=0.5<br/>&#13;
Accept-Encoding: gzip, deflate<br/>&#13;
Referer: https://twitter-commerce.shopifyapps.com/account<br/>&#13;
Cookie: _twitter-commerce_session=REDACTED<br/>&#13;
Connection: keep-alive</p>&#13;
<p class="indent">In addition, when the link was originally implemented, Shopify wasn’t validating the legitimacy of the <span class="literal">GET</span> requests sent to it, making the URL vulnerable to CSRF.</p>&#13;
<p class="indent">The hacker WeSecureApp, who filed the report, provided the following proof-of-concept HTML document:</p>&#13;
<p class="programs">&lt;html&gt;<br/>&#13;
  &lt;body&gt;<br/>&#13;
  <span class="ent">➊</span> &lt;img src="https://twitter-commerce.shopifyapps.com/auth/twitter/disconnect"&gt;<br/>&#13;
  &lt;/body&gt;<br/>&#13;
&lt;/html&gt;</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_37"/>When opened, this HTML document would cause the browser to send an HTTP <span class="literal">GET</span> request to <em>https://twitter-commerce.shopifyapps.com</em> through the <span class="literal">&lt;img&gt;</span> tag’s <span class="literal">src</span> attribute <span class="ent">➊</span>. If someone with a Twitter account connected to Shopify visited a web page with this <span class="literal">&lt;img&gt;</span> tag, their Twitter account would be disconnected from Shopify.</p>&#13;
<h4 class="h4" id="ch04lev2sec1"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Keep an eye out for HTTP requests that perform some action on the server, such as disconnecting a Twitter account, via a <span class="literal">GET</span> request. As mentioned earlier, <span class="literal">GET</span> requests should never modify any data on the server. In this situation, you could have found the vulnerability by using a proxy server, such as Burp or OWASP’s ZAP, to monitor the HTTP requests being sent to Shopify.</p>&#13;
<h3 class="h3" id="ch04lev1sec6"><strong>Change Users Instacart Zones</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Low</p>&#13;
<p class="hang"><strong>URL:</strong> <em>https://admin.instacart.com/api/v2/zones/</em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/157993/">https://hackerone.com/reports/157993/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> August 9, 2015</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $100</p>&#13;
<p class="noindent">When you’re looking at the attack surface, remember to consider a website’s API endpoints as well as its web pages. Instacart is a grocery delivery app that allows its deliverers to define the zones they work in. The site updated these zones with a <span class="literal">POST</span> request to the Instacart admin subdomain. A hacker discovered that the zone’s endpoint on this subdomain was vulnerable to CSRF. For example, you could modify a target’s zone with the following code:</p>&#13;
<p class="programs">&lt;html&gt;<br/>&#13;
  &lt;body&gt;<br/>&#13;
  <span class="ent">➊</span> &lt;form action="https://admin.instacart.com/api/v2/zones" method="POST"&gt;<br/>&#13;
    <span class="ent">➋</span> &lt;input type="hidden" name="zip" value="10001" /&gt;<br/>&#13;
    <span class="ent">➌</span> &lt;input type="hidden" name="override" value="true" /&gt;<br/>&#13;
    <span class="ent">➍</span> &lt;input type="submit" value="Submit request" /&gt;<br/>&#13;
    &lt;/form&gt;<br/>&#13;
  &lt;/body&gt;<br/>&#13;
&lt;/html&gt;</p>&#13;
<p class="indent">In this example, the hacker created an HTML form to send an HTTP <span class="literal">POST</span> request to the <span class="literal">/api/v2/zones</span> endpoint <span class="ent">➊</span>. The hacker included two hidden inputs: one to set the user’s new zone to the ZIP code <span class="literal">10001</span> <span class="ent">➋</span> and one to set the API’s <span class="literal">override</span> parameter to <span class="literal">true</span> <span class="ent">➌</span> so the user’s current <span class="literal">zip</span> value was replaced with the hacker’s submitted value. Additionally, the hacker included a submit button to make the <span class="literal">POST</span> request <span class="ent">➍</span>, unlike the Shopify example, which used an auto-submitting JavaScript function.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_38"/>Although this example is still successful, the hacker could improve the exploit by using the techniques described earlier, such as using a hidden iFrame to auto-submit the request on the target’s behalf. This would demonstrate to the Instacart bug bounty triagers how an attacker could use this vulnerability with less target action; vulnerabilities that are entirely attacker controlled are more likely to be successfully exploited than those that aren’t.</p>&#13;
<h4 class="h4" id="ch04lev2sec2"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">When you’re looking for exploits, broaden your attack scope and look beyond just a website’s pages to include its API endpoints, which offer great potential for vulnerabilities. Occasionally, developers forget that hackers can discover and exploit API endpoints, because they aren’t readily available like web pages. For example, mobile applications often make HTTP requests to API endpoints, which you can monitor with Burp or ZAP just as you do websites.</p>&#13;
<h3 class="h3" id="ch04lev1sec7"><strong>Badoo Full Account Takeover</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Medium</p>&#13;
<p class="hang"><strong>URL:</strong> <em><a href="https://www.badoo.com/">https://www.badoo.com/</a></em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/127703/">https://hackerone.com/reports/127703/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> April 1, 2016</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $852</p>&#13;
<p class="noindent">Although developers often use CSRF tokens to protect against CSRF vulnerabilities, in some cases, attackers can steal the tokens, as you’ll see in this bug. If you explore the social networking website <em><a href="https://www.badoo.com/">https://www.badoo.com/</a></em>, you’ll see that it uses CSRF tokens. More specifically, it uses a URL parameter, <span class="literal">rt</span>, which is unique to each user. When Badoo’s bug bounty program went live on HackerOne, I couldn’t find a way to exploit it. However, the hacker Mahmoud Jamal did.</p>&#13;
<p class="indent">Jamal recognized the <span class="literal">rt</span> parameter and its significance. He also noticed that the parameter was returned in almost all JSON responses. Unfortunately, this wasn’t helpful because CORS protects Badoo from attackers reading those responses, since they’re encoded as <span class="literal">application/json</span> content types. But Jamal kept digging.</p>&#13;
<p class="indent">Jamal eventually found the JavaScript file <em><a href="https://eu1.badoo.com/worker-scope/chrome-service-worker.js">https://eu1.badoo.com/worker-scope/chrome-service-worker.js</a></em>, which contained a variable called <span class="literal">url_stats</span> and was set to the following value:</p>&#13;
<p class="programs">var url_stats = 'https://eu1.badoo.com/chrome-push-stats?ws=1&amp;rt=<span class="codeitalic1">&lt;</span><span class="ent">➊</span><span class="codeitalic1">rt_param_value&gt;</span>';</p>&#13;
<p class="indent">The <span class="literal">url_stats</span> variable stored a URL that contained the user’s unique <span class="literal">rt</span> value as a parameter when the user’s browser accessed the JavaScript file <span class="ent">➊</span>. Even better, to obtain the user’s <span class="literal">rt</span> value, an attacker would just need the target to visit a malicious web page that would access the JavaScript file. CORS does not block this because browsers are allowed to read and embed <span epub:type="pagebreak" id="page_39"/>remote JavaScript files from external sources. The attacker could then use the <span class="literal">rt</span> value to link any social media account with the user’s Badoo account. As a result, the attacker could invoke HTTP <span class="literal">POST</span> requests to modify the target’s account. Here’s the HTML page Jamal used to accomplish this exploit:</p>&#13;
<p class="programs">&lt;html&gt;<br/>&#13;
  &lt;head&gt;<br/>&#13;
    &lt;title&gt;Badoo account take over&lt;/title&gt;<br/>&#13;
  <span class="ent">➊</span> &lt;script src=https://eu1.badoo.com/worker-scope/chrome-service-worker.<br/>&#13;
    js?ws=1&gt;&lt;/script&gt;<br/>&#13;
  &lt;/head&gt;<br/>&#13;
  &lt;body&gt;<br/>&#13;
    &lt;script&gt;<br/>&#13;
    <span class="ent">➋</span> function getCSRFcode(str) {<br/>&#13;
        return str.split('=')[2];<br/>&#13;
      }<br/>&#13;
    <span class="ent">➌</span> window.onload = function(){<br/>&#13;
      <span class="ent">➍</span> var csrf_code = getCSRFcode(url_stats);<br/>&#13;
      <span class="ent">➎</span> csrf_url = 'https://eu1.badoo.com/google/verify.phtml?code=4/nprfspM3y<br/>&#13;
        fn2SFUBear08KQaXo609JkArgoju1gZ6Pc&amp;authuser=3&amp;session_state=7cb85df679<br/>&#13;
        219ce71044666c7be3e037ff54b560..a810&amp;prompt=none&amp;rt='+ csrf_code;<br/>&#13;
      <span class="ent">➏</span> window.location = csrf_url;<br/>&#13;
      };<br/>&#13;
    &lt;/script&gt;<br/>&#13;
  &lt;/body&gt;<br/>&#13;
&lt;/html&gt;</p>&#13;
<p class="indent">When a target loads this page, the page will load the Badoo JavaScript by referencing it as the <span class="literal">src</span> attribute in a <span class="literal">&lt;script&gt;</span> tag <span class="ent">➊</span>. Having loaded the script, the web page then calls the JavaScript function <span class="literal">window.onload</span>, which defines an anonymous JavaScript function <span class="ent">➌</span>. Browsers call the <span class="literal">onload</span> event handler when a web page loads; because the function Jamal defined is in the <span class="literal">window.onload</span> handler, his function will always be called when the page is loaded.</p>&#13;
<p class="indent">Next, Jamal created a <span class="literal">csrf_code</span> variable <span class="ent">➍</span> and assigned it the return value of a function he defined at <span class="ent">➋</span> called <span class="literal">getCSRFcode</span>. The <span class="literal">getCSRFcode</span> function takes and splits a string into an array of strings at each <span class="literal">'='</span> character. It then returns the value of the third member of the array. When the function parses the variable <span class="literal">url_stats</span> from Badoo’s vulnerable JavaScript file at <span class="ent">➍</span>, it splits the string into the following array value:</p>&#13;
<p class="programs">https://eu1.badoo.com/chrome-push-stats?ws,1&amp;rt,<span class="codeitalic1">&lt;rt_param_value&gt;</span></p>&#13;
<p class="indent">Then the function returns the third member of the array, which is the <span class="literal">rt</span> value, and assigns that to <span class="literal">csrf_code</span>.</p>&#13;
<p class="indent">Once he had the CSRF token, Jamal created the <span class="literal">csrf_url</span> variable, which stores a URL to Badoo’s <em>/google/verify.phtml</em> web page. The web page links his own Google account to the target’s Badoo account <span class="ent">➎</span>. This page requires some parameters, which are hardcoded into the URL string. I won’t cover them in detail here because they’re specific to Badoo. However, note the final <span class="literal">rt</span> parameter, which doesn’t have a hardcoded value. Instead, <span class="literal">csrf_code</span> <span epub:type="pagebreak" id="page_40"/>is concatenated to the end of the URL string so it’s passed as the <span class="literal">rt</span> parameter’s value. Jamal then makes an HTTP request by invoking <span class="literal">window.location</span> <span class="ent">➏</span> and assigns it to <span class="literal">csrf_url</span>, which redirects the visiting user’s browser to the URL at <span class="ent">➎</span>. This results in a <span class="literal">GET</span> request to Badoo, which validates the <span class="literal">rt</span> parameter and processes the request to link the target’s Badoo account to Jamal’s Google account, thereby completing the account takeover.</p>&#13;
<h4 class="h4" id="ch04lev2sec3"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Where there’s smoke, there’s fire. Jamal noticed that the <span class="literal">rt</span> parameter was being returned in different locations, particularly in JSON responses. For that reason, he rightly guessed that <span class="literal">rt</span> might show up someplace where an attacker could access and exploit it, which in this case was a JavaScript file. If you feel like a site might be vulnerable, keep digging. In this case, I thought it was odd that the CSRF token would only be five digits long and included in URLs. Normally, tokens are much longer, making them harder to guess, and included in HTTP <span class="literal">POST</span> request bodies, not URLs. Use a proxy and check all the resources that are being called when you visit a site or application. Burp allows you to search through all your proxy history to look for specific terms or values, which would have revealed the <span class="literal">rt</span> value included in the JavaScript files here. You might find an information leak with sensitive data, such as a CSRF token.</p>&#13;
<h3 class="h3" id="ch04lev1sec8"><strong>Summary</strong></h3>&#13;
<p class="noindent">CSRF vulnerabilities represent another attack vector that attackers can execute without the target even knowing or actively performing an action. Finding CSRF vulnerabilities can take some ingenuity and a willingness to test all functionality on a site.</p>&#13;
<p class="indent">Generally, application frameworks, such as Ruby on Rails, are increasingly protecting web forms if the site is performing <span class="literal">POST</span> requests; however, this isn’t the case for <span class="literal">GET</span> requests. Therefore, be sure to keep an eye out for any <span class="literal">GET</span> HTTP calls that change server-side user data (like disconnecting Twitter accounts). Also, although I didn’t include an example of it, if you see that a site is sending a CSRF token with a <span class="literal">POST</span> request, you can try changing the CSRF token value or removing it entirely to ensure the server is validating its existence.</p>&#13;
</body></html>