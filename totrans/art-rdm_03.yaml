- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3**'
- en: SIMULATE THE REAL WORLD**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟现实世界**
- en: '![Image](../images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: '*Computer simulations* are programs that use randomness to simulate real-world
    events and processes. More specifically, computer simulations manipulate *models*,
    programmatic stand-ins for the real world.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算机模拟* 是使用随机性来模拟现实世界事件和过程的程序。更具体地说，计算机模拟操控*模型*，即现实世界的编程替代物。'
- en: 'We’ll begin this chapter by defining what a model is. Then we’ll get our feet
    wet with two straightforward simulation examples: estimating *π* by throwing darts
    and gathering people together in a room to estimate the probability that at least
    two of them share a birthday. Once we’ve done that, we’ll wade in further to explore
    Darwinian evolution via simulation, capturing essential characteristics of natural
    selection and genetic drift.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从定义模型是什么开始。接着，我们将通过两个简单的模拟示例来初步入门：通过投掷飞镖来估算*π*，以及将人们聚集在一个房间里，估算至少有两人共享生日的概率。一旦完成这些示例，我们将进一步深入，通过模拟探索达尔文进化论，捕捉自然选择和基因漂变的本质特征。
- en: '**Introduction to Models**'
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**模型简介**'
- en: 'We can define a model in many ways, but I like this definition from Daniel
    L. Hartl in *A Primer of Population Genetics and Genomics* (Oxford University
    Press, 2020):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用许多方式定义模型，但我喜欢丹尼尔·L·哈特尔在《*群体遗传学与基因组学导论*》（牛津大学出版社，2020）中的定义：
- en: A model is an intentional simplification of a complex situation designed to
    eliminate extraneous detail in order to focus on the essentials.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是对复杂情境的有意简化，旨在消除不必要的细节，以便集中于本质部分。
- en: Think of a model as an approximation of something that we’re interested in exploring
    or characterizing. There are no requirements for what that something is or for
    how we model it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 把模型看作是我们希望探索或表征的事物的近似。对于那个事物是什么以及我们如何建模它，并没有具体的要求。
- en: In this chapter, a model is a piece of code that attempts to capture the essential
    character of a real-world process, like what happens to the probability of shared
    birthdays as more and more people gather in a room, or how natural selection and
    genetic drift affect the genomes of a population. Simulation lets us control the
    experimental world while allowing random behavior, to understand what has happened
    or might happen, especially as critical parameters (environmental factors) are
    varied.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，模型是一个代码片段，它试图捕捉现实世界过程的本质特征，例如，当越来越多的人聚集在一个房间里时，分享生日的概率如何变化，或者自然选择和基因漂变如何影响种群的基因组。模拟让我们控制实验世界，同时允许随机行为，理解已经发生的或可能发生的事情，特别是当关键参数（环境因素）变化时。
- en: 'Consider the following statement, which is attributed to British statistician
    George Box:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下陈述，这句话归功于英国统计学家乔治·博克斯：
- en: All models are wrong, but some are useful.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的模型都是错误的，但有些是有用的。
- en: Unless particularly trivial, all models are wrong in some way, especially those
    of the real world. If the model is well conceived and well implemented, it might
    lead to valuable conclusions about the modeled process. The word *process* implies
    a sequence of events, that is, time. Many models simulate processes unfolding
    in time; for example, we’ll explore fundamental evolutionary processes acting
    at a population level over time.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 除非特别琐碎，否则所有模型在某种程度上都是错误的，特别是那些关于现实世界的模型。如果模型设计得好并且实施得当，它可能会得出关于被建模过程的有价值的结论。*过程*一词意味着一系列事件，即时间。许多模型模拟的是随着时间展开的过程；例如，我们将探讨作用于种群层面的基本进化过程。
- en: A good model captures enough of the thing being modeled to generate conclusions
    worthy of confidence tempered with reality. Blind faith in a model’s output isn’t
    recommended. At best, a model falls into the “trust, but verify” category—a good
    rule of thumb for all scientific claims.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的模型能够捕捉到足够的被建模对象的特征，以得出值得信赖的结论，同时考虑现实的因素。对模型输出的盲目信任并不推荐。充其量，模型属于“信任，但验证”这一类别——这是所有科学主张的一个良好经验法则。
- en: Let’s slide into simulation by throwing darts to estimate *π*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过投掷飞镖来估算*π*，逐步进入模拟的世界。
- en: '**Estimate Pi**'
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**估算π**'
- en: We’ll generate an estimate of *π*, the ratio between the circumference of a
    circle and its diameter, by throwing darts at a board. Doing this in real life
    would be time consuming, so we’ll simulate the process instead; that is, we’ll
    make a model.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过向飞镖靶投掷飞镖来生成*π*的估算值，*π*是圆的周长与直径的比率。在现实生活中进行这项活动会非常耗时，因此我们将模拟这个过程；也就是说，我们将创建一个模型。
- en: '***Using a Dartboard***'
  id: totrans-17
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用飞镖靶***'
- en: First, let’s learn how throwing darts at a board tells us about the value of
    *π*. For that, we need a diagram ([Figure 3-1](ch03.xhtml#ch03fig01)).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解一下向靶子投掷飞镖是如何告诉我们*π*值的。为此，我们需要一个图示（[图 3-1](ch03.xhtml#ch03fig01)）。
- en: '![Image](../images/03fig01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig01.jpg)'
- en: '*Figure 3-1: Simulating dart throws*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：模拟飞镖投掷*'
- en: '[Figure 3-1](ch03.xhtml#ch03fig01) shows a square with a circle inside it.
    The circle’s diameter isn’t marked explicitly, but we’ll say it’s 2, meaning the
    radius is 1\. The diameter also matches the length of the sides of the square;
    therefore, the areas of the square and circle are'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-1](ch03.xhtml#ch03fig01)显示了一个内有圆形的正方形。圆的直径没有明确标出，但我们假设它是2，即半径是1。直径也与正方形的边长相同；因此，正方形和圆的面积是'
- en: '![Image](../images/f0075-01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0075-01.jpg)'
- en: 'implying:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 含义：
- en: '![Image](../images/f0075-02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0075-02.jpg)'
- en: We calculate *π* by dividing the area of the circle by the area of the square
    and multiplying that by 4.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将圆的面积除以正方形的面积，并乘以4来计算*π*。
- en: 'If we throw many darts, or pick many random points, they’ll eventually cover
    the circle and the square. We can use the number of darts that land inside each
    shape as a proxy for the areas. We now have an algorithm: throw darts and count
    the number that land inside the circle (*N*) and inside the square (*M*), then
    divide *N* by *M* and multiply by 4 to get an estimate of *π*.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们投掷许多飞镖，或选择许多随机点，它们最终会覆盖圆和正方形的区域。我们可以利用落在每个形状内部的飞镖数量作为面积的代理。我们现在有了一个算法：投掷飞镖并计算落在圆内（*N*）和落在正方形内（*M*）的数量，然后将*N*除以*M*并乘以4，从而估算出*π*。
- en: The previous figure’s example points are all in the first quadrant, which works
    well for our estimate because the ratio of the area of the square to the circle
    is the same as the ratio of the portion of each shape in the first quadrant. Specifically,
    the first quadrant is 1/4 the size of the full shapes, so the areas are divided
    by 4\. But both the circle and square areas are divided by 4, meaning their ratio
    remains the same, *π*/4\. This means we need only to throw darts that land in
    the first quadrant.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个图中的示例点都位于第一象限，这对我们的估算非常有效，因为正方形和圆的面积比例与它们在第一象限的部分比例相同。具体而言，第一象限是完整形状大小的1/4，因此面积需要除以4。但圆和正方形的面积都被除以4，这意味着它们的比例保持不变，*π*/4。这意味着我们只需要投掷落在第一象限的飞镖。
- en: Now that we understand how to estimate the respective areas and *π* by throwing
    darts, how should we actually “throw” them? The answer lies in the previous comment
    about the first quadrant.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了如何通过投掷飞镖来估算各自的面积和*π*，那么我们应该如何实际“投掷”它们呢？答案就在前面关于第一象限的评论中。
- en: 'Here’s the algorithm:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是算法：
- en: Randomly pick two numbers in [0, 1) and call them *x* and *y*. These become
    the point where the dart lands, (*x*, *y*).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机选择两个[0, 1)之间的数字，称它们为*x*和*y*。这将成为飞镖落点（*x*, *y*）。
- en: Increment *M*, the counter for the number of points in the square.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加*M*，即正方形内点数的计数器。
- en: If *x*² + *y*² ≤ 1, increment *N*, the number of points inside the circle.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*x*² + *y*² ≤ 1，则增加*N*，即圆内的点数。
- en: Repeat steps 1 through 3 for as many darts as desired.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对所有期望的飞镖，重复步骤1到3。
- en: Return (4*N*)/*M* as the estimate of *π*.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回(4*N*)/*M*作为*π*的估算值。
- en: We pick points in [0, 1) so that the points are all in the first quadrant and
    land inside the square. Therefore, if we throw *n* darts, *M* = *n*, and we need
    only ask if the same points are also inside the circle.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择[0, 1)中的点，这样所有点都位于第一象限并落在正方形内。因此，如果我们投掷*n*个飞镖，*M* = *n*，我们只需要判断这些点是否也在圆内。
- en: 'In step 2 we ask a question about the circle, with *x*² + *y*² ≤ 1 coming from
    the Pythagorean theorem: *a*² + *b*² = *c*², where *c* is the side opposite the
    right angle. Here the triangle sides are *x* and *y*, meaning the radius (*r*
    = 1) is the hypotenuse, *x*² + *y*². Any point forming a hypotenuse less than
    *r* = 1 is inside the circle.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，我们提出一个关于圆的问题，*x*² + *y*² ≤ 1源自勾股定理：*a*² + *b*² = *c*²，其中*c*是直角三角形的斜边。这里的三角形边是*x*和*y*，意味着半径（*r*
    = 1）是斜边，*x*² + *y*²。任何形成斜边小于*r* = 1的点都在圆内。
- en: 'Before we proceed, we should ask whether this is a fair model of the process
    of throwing darts, and whether we’ve made any unfair assumptions. After all, a
    model attempts to mimic *what’s most important* about a process. We’re using two
    uniformly selected random numbers in [0, 1) to represent the location where a
    dart might land, and we’ve made only one assumption: that *all* darts land in
    the first quadrant. Limiting the random values to [0, 1) eliminates out-of-range
    darts, so we count every dart throw as landing in at least the square.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们应该问一下，这是否是一个公正的飞镖投掷过程模型，以及我们是否做了任何不公平的假设。毕竟，一个模型的目的是模拟过程中的*最重要的部分*。我们使用两个均匀选取的随机数，位于[0,
    1)之间，来表示飞镖可能落的位置，我们只做了一个假设：*所有*飞镖都落在第一象限。将随机值限制在[0, 1)区间内可以排除超出范围的飞镖，因此我们将每次投掷飞镖都视为至少落在正方形内。
- en: With these questions answered, we’re ready to test.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 回答了这些问题后，我们准备好进行测试了。
- en: '***Simulating Random Darts***'
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模拟随机飞镖***'
- en: 'The code we want is in *sim_pi.py*. To run it, supply the number of simulated
    darts and the desired randomness source. For example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的代码在*sim_pi.py*中。要运行它，提供模拟的飞镖数量和所需的随机性来源。例如：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This throws 10,000 darts using PCG64\. The result is *π ≈* 3.1612\. The correct
    value rounded to four digits is 3.1416, so we’re in the ballpark. The estimate
    uses only four decimal places because we’re approximating *π* with a fraction
    that has a denominator of 10,000\. Ten more runs gives:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这次使用PCG64投掷了10,000次飞镖。结果是*π ≈* 3.1612。四位小数的正确值是3.1416，所以我们接近了正确值。这个估计只使用了四位小数，因为我们用一个分母为10,000的分数来逼近*π*。再进行十次运行得到：
- en: 3.1496, 3.1188, 3.1468, 3.1700, 3.1292, 3.1372, 3.0916, 3.1608, 3.1236, 3.1140
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 3.1496，3.1188，3.1468，3.1700，3.1292，3.1372，3.0916，3.1608，3.1236，3.1140
- en: Combining all 11 runs gives *π ≈* 3.1366, which is about 0.16 percent off from
    the four-digit value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 合并所有11次运行结果得到*π ≈* 3.1366，和四位小数的正确值相比偏差约为0.16%。
- en: 'Let’s increase the number of darts:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们增加掷飞镖的次数：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: That’s more like it. The correct value to six places is 3.141593.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 结果差不多了。六位小数的正确值是3.141593。
- en: 'Let’s go for broke—this should nail it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们孤注一掷——这样应该能搞定：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Odd. We threw 100 times as many darts as the previous run, but the result wasn’t
    as good. Nothing’s wrong with our approach; that’s how the random cookie crumbles.
    A second run using PCG64 and 100 million darts returned 3.14160636, which is better.
    Still, it raises the question: Why such variation? That’s the nature of a random
    generator, and it serves as a reminder to repeat simulations multiple times to
    convince ourselves that they’re producing reasonable output and to get numerous
    estimates.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 奇怪。我们投掷了前一次的100倍飞镖，但结果却不如前一次好。我们的方法没有问题；这就是随机数的特性。第二次使用PCG64和1亿次飞镖的运行结果是3.14160636，比之前好一些。不过，这也引出了一个问题：为什么会有如此大的变化？这就是随机生成器的特点，也提醒我们要多次重复模拟，以确认它们产生合理的输出并获得多个估计值。
- en: 'Individual runs using the other randomness sources supported by the `RE` class
    gave:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`RE`类支持的其他随机性来源进行的单独运行结果是：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The last run uses *RandomDotOrg.bin*, a 510MB file of random data from *[random.org](http://random.org)*.
    All randomness sources produce reasonable estimates of *π* but are still not satisfying.
    Why aren’t they closer to the actual value of 3.14159265 . . . ?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一轮使用的是*RandomDotOrg.bin*，一个来自*[random.org](http://random.org)*的510MB随机数据文件。所有的随机性来源都产生了合理的*π*估计值，但仍然不令人满意。为什么它们没有更接近实际值3.14159265…？
- en: '***Understanding the RE Class Output***'
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***理解RE类的输出***'
- en: Let’s reconsider what we want the random throwing of darts to simulate. We’re
    looking to compare *areas*, so we want the darts to cover the areas as evenly
    as possible.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新考虑我们希望随机投掷飞镖来模拟什么。我们希望比较*区域*，因此我们希望飞镖尽可能均匀地覆盖这些区域。
- en: '[Figure 3-2](ch03.xhtml#ch03fig02), which is a duplicate of [Figure 1-5](ch01.xhtml#ch01fig05),
    shows us what is happening. The middle plot in the figure shows the placement
    of points when using a random generator. There are gaps and places where the points
    are concentrated. It’s a reasonable coverage of the area, but not a uniformly
    dense one.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-2](ch03.xhtml#ch03fig02)，它是[图1-5](ch01.xhtml#ch01fig05)的重复，展示了发生了什么。图中的中间图表展示了使用随机生成器时点的位置。存在间隙和点集中的地方。尽管覆盖了区域，但并不是均匀密集的。'
- en: '![Image](../images/03fig02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/03fig02.jpg)'
- en: '*Figure 3-2: Bad quasirandom (left), pseudorandom (middle), and good quasirandom
    sequences (right)*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-2：差的准随机序列（左），伪随机序列（中），和好的准随机序列（右）*'
- en: 'The right plot in [Figure 3-2](ch03.xhtml#ch03fig02), from a pair of quasirandom
    sequences, is much more uniform over the area. Let’s try using that instead. The
    code we want for this case is in *sim_pi_quasi.py*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-2](ch03.xhtml#ch03fig02)中的右侧图，来自一对准随机序列，在区域上分布更为均匀。我们来尝试使用这个序列。我们需要的代码在
    *sim_pi_quasi.py* 中：'
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first argument is the number of darts; the other two are the bases for the
    quasirandom sequence. To cover a 2D plane, we need two different bases, here 2
    and 3\. As the number of darts increases, so does the quality of the estimate.
    With 1 million darts, it has already matched the first run of *sim_pi.py* with
    PCG64\. There’s no randomness here; every run with the same number of darts and
    the same bases results in the same output. Also, because we’re generating the
    quasirandom sequence in pure Python, the runtime increases dramatically with the
    number of darts. For example, this run
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是投掷的飞镖数；另外两个参数是准随机序列的基数。为了覆盖 2D 平面，我们需要两个不同的基数，这里是 2 和 3。当飞镖数增加时，估计的质量也会提高。在使用
    100 万个飞镖时，它已经与 PCG64 的 *sim_pi.py* 的第一次运行匹配。这里没有随机性；每次使用相同数量的飞镖和相同的基数运行都会得到相同的输出。此外，因为我们在纯
    Python 中生成准随机序列，飞镖数量增加时，运行时间会显著增加。例如，这次运行
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: is correct to five decimals but took 12 minutes to run on my reference Intel
    i7 system. Asking for 100 million samples produces *π ≈* 3.14159184 after a two-and-a-half-hour
    run.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 精确到五位小数，但在我的 Intel i7 参考系统上运行了 12 分钟。要求 1 亿个样本时，经过两个半小时的运行后，*π ≈* 3.14159184。
- en: Let’s focus momentarily on the performance of each pseudorandom generator supported
    by the `RE` class. The file *sim_pi_test.py* estimates *π* 50 times each for PCG64,
    MT19937, MINSTD, `urandom`, and `RDRAND` using 2 million simulated dart throws.
    The result is the box plot in [Figure 3-3](ch03.xhtml#ch03fig03).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂时关注每个伪随机生成器的性能，这些生成器由 `RE` 类支持。文件 *sim_pi_test.py* 使用 200 万次模拟飞镖投掷，分别为 PCG64、MT19937、MINSTD、`urandom`
    和 `RDRAND` 估算 *π* 50 次。结果就是 [图 3-3](ch03.xhtml#ch03fig03) 中的箱线图。
- en: '![Image](../images/03fig03.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig03.jpg)'
- en: '*Figure 3-3: A box plot showing the distribution of π estimates by randomness
    source*'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-3：箱线图展示了不同随机源的 π 估计分布*'
- en: A *box plot* is a diagram summarizing a set of data; in this case, the 50 estimates
    of *π*, that is, the 50 separate runs of *sim_pi.py* for each pseudorandom generator.
    Each generator’s output produces a box with a horizontal bar across it. The bar
    represents the median value, or the 50th percentile. Half the estimates were below
    this value and half above. The box’s lower and upper limits are the 25th and 75th
    percentiles, respectively. So, 75 percent of the estimates were below the upper
    part of the box and the remaining 25 percent were above it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*箱线图* 是一种总结数据集的图示；在这种情况下，是 50 个 *π* 的估计值，也就是每个伪随机生成器的 *sim_pi.py* 文件的 50 次独立运行。每个生成器的输出会生成一个带有横向条形的箱子。这个条形代表中位数值，或第
    50 百分位数。中位数以下的一半估计值与中位数以上的一半估计值相等。箱子的上下限分别是第 25 百分位数和第 75 百分位数。因此，75% 的估计值位于箱子的上限以下，剩下的
    25% 位于其上。'
- en: The *whiskers*, called fliers by Matplotlib, extend beyond the box. The height
    of the box, the difference between the 75th percentile and the 25th, is known
    as the *interquartile range (IQR)*. The whiskers are the box quartiles plus or
    minus 1.5 times the IQR. Any data values outside the whiskers are candidates for
    *outliers*, values that are atypical when compared to the rest of the data. Outliers
    might be errors or the exciting thing we’re looking for; context is everything.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*胡须线*，在 Matplotlib 中被称为飞行器，超出了盒子的范围。盒子的高度，即第 75 百分位数与第 25 百分位数之间的差，称为 *四分位距（IQR）*。胡须线是盒子四分位数加上或减去
    1.5 倍的 IQR。任何超出胡须线的数据值都是 *离群值* 的候选者，这些值与其余数据相比，具有典型的异常性。离群值可能是错误，也可能是我们在寻找的有趣现象；上下文才是关键。'
- en: The five boxes in [Figure 3-3](ch03.xhtml#ch03fig03) are statistically identical.
    There are two potential outliers for MINSTD, but another run of *sim_pi_test.py*
    generates a new plot with a different set of boxes and potential outliers, even
    from `RDRAND`, which is as close to a true source of randomness as we can get
    for repeated sampling. Random processes sometimes produce strange output; there’s
    no meaning attached to it. This phenomenon is partly why detecting true cancer
    clusters can be tricky.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-3](ch03.xhtml#ch03fig03)中的五个箱子在统计上是相同的。对于 MINSTD，有两个潜在的离群值，但另一次运行 *sim_pi_test.py*
    会生成一个新的图表，显示不同的箱子和潜在离群值，甚至来自 `RDRAND`，这是我们可以获得的最接近真实随机源的东西。随机过程有时会产生奇怪的输出；这没有任何意义。这个现象部分解释了为什么检测真实的癌症聚集区可能很棘手。'
- en: '***Implementing the Darts Model***'
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现飞镖模型***'
- en: 'Our dart-throwing simulation works. Now, let’s review the code to understand
    how:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的掷镖模拟已经完成。现在，让我们回顾一下代码，了解其工作原理：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code at the bottom parses the command line to get the number of darts to
    throw (`N`) and the type of randomness source to use (`kind`). A generator is
    created (`rng`) and passed, along with the number of darts, to `Simulate`, which
    returns an estimate of *π* that is then printed.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 底部的代码解析命令行，以获取投掷的镖数（`N`）和要使用的随机源类型（`kind`）。创建一个生成器（`rng`），并将其与镖数一起传递给`Simulate`，该函数返回一个*π*的估算值，然后将其打印出来。
- en: All the action is in `Simulate`. We need `N` points, the locations where our
    darts landed. We can either use `rng` twice—first to get *x*-coordinates and then
    again to get *y*-coordinates—or generate twice as many points as we need and partition
    them in pairs. I chose the latter. Therefore, `v` contains 2*N* values. The first
    and then every other point become `x`, while the second and every other after
    that become `y`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的操作都在`Simulate`中。我们需要`N`个点，即我们投掷的镖落地点。我们可以选择使用`rng`两次——第一次获取*x*坐标，再次获取*y*坐标——或者生成两倍于所需点数的点，然后将它们成对划分。我选择了后者。因此，`v`包含2*N*个值。第一个点以及随后的每个点成为`x`，而第二个点以及随后的每个点成为`y`。
- en: By design, all the points are inside the square. We need only to decide which
    are also inside the circle. For that, we need to know if *x*² + *y*² *≤ r*² for
    radius *r* = 1\. To this end, we set `d` to *x*² + *y*² and use NumPy’s `where`
    to find the indices that are less than or equal to 1\. The count of those indices
    tells us how many points are `inside` the circle. Finally, the function returns
    the estimate of *π* as four times the number inside divided by the number of darts
    thrown.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 根据设计，所有点都在正方形内部。我们只需决定哪些点也在圆内。为此，我们需要知道是否满足*x*² + *y*² *≤ r*²，其中半径*r* = 1。为此，我们将`d`设置为*x*²
    + *y*²，并使用NumPy的`where`来查找小于或等于1的索引。这些索引的计数告诉我们有多少点位于圆内。最后，函数返回*π*的估算值，即圆内的点数除以投掷的镖数，再乘以四。
- en: Our dart simulation is complete. Now, let’s simulate a party to see how many
    people we need in a room to have a better-than-50 percent chance that at least
    two of them share a birthday.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的掷镖模拟已经完成。现在，让我们模拟一个聚会，看看需要多少人才能使至少有两个人共享生日的概率超过50%。
- en: '**Birthday Paradox**'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**生日悖论**'
- en: 'How many people need to be in a room for the probability of at least two of
    them sharing a birthday to be above 50 percent? There’s a mathematical way to
    determine this probability, but if we don’t know the math, we can find it by extensive
    experimentation: we can throw many parties, with differing numbers of people invited,
    and at each one figure out if at least two of them share a birthday. While this
    approach will work, it’ll be terribly slow and expensive.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 需要多少人参加聚会，才能使至少有两个人共享生日的概率超过50%？有一种数学方法可以计算这个概率，但如果我们不懂数学，我们可以通过大量实验来找到答案：我们可以举行许多聚会，邀请不同人数的人，在每次聚会上判断是否有至少两个人共享生日。虽然这种方法可行，但它会非常缓慢且昂贵。
- en: '***Simulating 100,000 Parties***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***模拟100,000场聚会***'
- en: 'Assuming we aren’t willing to write a grant proposal for a million dollars
    to conduct this experiment with actual people, to say nothing of gaining review
    board approval and informed consent from thousands of people, is there any other
    way to approach the problem? You guessed it: simulation.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们不愿意写一份价值百万美元的资助提案来用实际的人进行这个实验，更不用说获得审查委员会的批准和成千上万人的知情同意，那么还有其他方法可以解决这个问题吗？你猜对了：模拟。
- en: Every person has a birthday, so we’ll simulate the number of people in the room
    and assign each a randomly selected birthday. Then we’ll look at each possible
    pair and ask if they have the same birthday. There are 365 days in a year, ignoring
    leap years, so we’ll represent birthdays by picking a day of the year as a proxy
    for an actual birthday. In other words, each simulated person is assigned an integer
    in [0, 364]. If any two have the same number, they share a birthday.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都有一个生日，因此我们将模拟房间里的人数，并为每个人随机分配一个生日。然后，我们将检查每一对可能的组合，看看他们是否有相同的生日。一年有365天（忽略闰年），所以我们将通过选择一年中的某一天作为实际生日的代表来表示生日。换句话说，每个模拟的人都会被分配一个在[0,
    364]范围内的整数。如果两个人的数字相同，则他们共享生日。
- en: We want the probability of a match for a given number of people, meaning one
    simulation isn’t sufficient. We need many, many simulations for a fixed number
    of people in the room. The number of times there’s a match divided by the number
    of simulations converges to the probability we seek.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要的是给定人数下的匹配概率，这意味着一次模拟是不够的。我们需要很多次模拟，针对固定人数的房间。匹配次数与模拟次数之比趋近于我们所寻求的概率。
- en: 'Here’s our algorithm:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的算法：
- en: Fix the number of people in the room (*K*).
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 固定房间中的人数（*K*）。
- en: Assign each of the *K* people a birthday ([0, 364]).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给每个*K*个人分配一个生日（[0, 364]）。
- en: Check each possible pair. If they share a birthday, increment *M*.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查每一对可能的组合。如果他们的生日相同，增加*M*的值。
- en: Repeat from step 2 *N* times.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从步骤2开始，重复*N*次。
- en: The estimated probability for *K* people in a room is *M*/*N*.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于房间中*K*个人，估算的概率是*M*/*N*。
- en: We’ll vary *K* from 2 to 50\. *N* should be a large number, like *N* = 100,000
    to simulate 100,000 parties with *K* people. We can always make *N* larger and
    try again, as varying simulation parameters and observing what happens is part
    of what makes simulations worthwhile. If things blow up when we make a subtle
    change, we might have a bug in our code or, worse yet, a logic flaw in our design.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将*K*的值从2变化到50。*N*应该是一个大数，比如*N* = 100,000，用于模拟100,000个有*K*个人的派对。我们总是可以将*N*增大并重新尝试，因为变化模拟参数并观察结果是模拟的一个重要部分。如果我们在稍微改变时遇到问题，可能是代码有
    bug，或者更糟的是，设计中存在逻辑缺陷。
- en: '***Testing the Birthday Model***'
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试生日模型***'
- en: 'The code we need is in *birthday.py*. Let’s run it to understand its output
    before walking through it. For example, here’s the output for a run asking for
    the probability of at least one match in a room with 11 people:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的代码在*birthday.py*中。让我们先运行它，了解输出结果，然后再逐步分析它。例如，以下是运行一个询问11人房间内至少有一对生日相同的概率时的输出：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’re told that the probability of at least one birthday match for a room of
    11 people is about 14 percent. The second argument is the randomness source to
    use, here MINSTD. Feel free to experiment with other sources.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，房间里11个人至少有一对生日相同的概率大约是14%。第二个参数是要使用的随机源，这里使用的是MINSTD。可以尝试其他随机源。
- en: 'If we add a third argument, we can store the output and bring it into Python
    to understand what it means:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加第三个参数，我们可以存储输出并将其导入Python，以便理解其含义：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The first line runs the code a second time. Notice that the probability changes
    slightly; random selection of birthdays will produce varying results that eventually
    converge to a mean after many repetitions of the simulation. We’ll experiment
    with this fact in a bit.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码再次运行。注意概率发生了轻微变化；随机选择生日会产生不同的结果，这些结果最终会在多次模拟后趋于均值。稍后我们会对此进行实验。
- en: Next, I ran Python (and ignored the startup message) before importing NumPy
    and the output file, *11.npy*. The `d` array contains a histogram of the number
    of times that many birthday matches were found for 100,000 simulations where the
    index into `d` is the number. [Table 3-1](ch03.xhtml#ch03tab01) shows the number
    of matches and how often they appeared.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我运行了Python（并忽略了启动消息），然后导入了NumPy和输出文件*11.npy*。`d`数组包含了100,000次模拟中找到相同生日的人数的直方图，其中`d`的索引表示数字。[表
    3-1](ch03.xhtml#ch03tab01)显示了匹配次数以及它们出现的频率。
- en: '**Table 3-1:** Number of Matches and Frequency of Appearance'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-1：** 匹配次数与出现频率'
- en: '| **Matches** | **Count** | **Percent** |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| **匹配** | **次数** | **百分比** |'
- en: '| --- | --- | --- |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 85,739 | 85.739 |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 85,739 | 85.739 |'
- en: '| 1 | 13,462 | 13.462 |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 13,462 | 13.462 |'
- en: '| 2 | 663 | 0.663 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 663 | 0.663 |'
- en: '| 3 | 125 | 0.125 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 125 | 0.125 |'
- en: '| 4 | 10 | 0.010 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 10 | 0.010 |'
- en: '| 5 | 0 | 0.000 |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 0 | 0.000 |'
- en: '| 6 | 0 | 0.000 |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 0 | 0.000 |'
- en: '| 7 | 1 | 0.001 |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 1 | 0.001 |'
- en: 'In 85.7 percent of the cases, when 11 people were in the room no two shared
    a birthday. Likewise, 13.5 percent of the cases resulted in a single pair sharing
    a birthday. Finally, in one run out of 100,000, seven pairs of people shared a
    birthday. This is the nature of randomness: sometimes remarkable things happen.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在85.7%的情况下，当房间里有11个人时，没人有相同的生日。同样，在13.5%的情况下，出现了一对生日相同的人。最后，在100,000次运行中，有一次出现了七对生日相同的人。这就是随机性的本质：有时会发生一些令人惊讶的事情。
- en: Next, I ran *birthday.py* five times, once for each of the randomness sources
    built into `RE`, and always with 23 people in the room. The average probability
    returned was 0.507478 or 50.7 percent. This is the first number of people to return
    a probability greater than 50 percent; therefore, to answer the question at the
    beginning of this section, we need 23 people in a room, on average, to have a
    greater than 50 percent chance that at least two of them share a birthday.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我运行了五次*birthday.py*，每次使用`RE`内置的随机数源，并且每次房间里都有23个人。返回的平均概率是0.507478，即50.7%。这是第一个返回大于50%概率的人员数量；因此，为了回答本节开头的问题，我们平均需要23个人在一个房间里，才能有超过50%的机会至少有两个人共享生日。
- en: Let’s try to visualize what’s happening here ([Figure 3-4](ch03.xhtml#ch03fig04)).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着可视化这里发生的事情（[图3-4](ch03.xhtml#ch03fig04)）。
- en: '![Image](../images/03fig04.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig04.jpg)'
- en: '*Figure 3-4: The probability of at least one match as a function of number
    of people (left) and the histogram of matches by people in the room (right)*'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-4：至少一个匹配的概率与房间内人数的关系（左）以及按房间内人数统计的匹配直方图（右）*'
- en: The left-hand side of [Figure 3-4](ch03.xhtml#ch03fig04) shows the probability
    of one or more matches as a function of the number of people in the room. The
    vertical line is 23 people, and the dashed horizontal line is 50 percent. As claimed,
    23 people is the minimum number needed to exceed 50 percent.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-4](ch03.xhtml#ch03fig04)的左侧展示了至少一个匹配的概率与房间内人数的关系。垂直线表示23个人，虚线水平线表示50%的概率。正如所述，23个人是超过50%概率的最小人数。'
- en: The right side of [Figure 3-4](ch03.xhtml#ch03fig04) presents three histograms
    showing the fraction of runs returning the indicated number of matches. The bars
    are offset to prevent overlapping, but the leftmost bar is on the actual number
    of matches. When there are only 10 people in the room, the probability of no match
    is high and more than one match is essentially zero. For 23 people, one match
    is relatively common, two less so, and three pairs happen about 3 percent of the
    time. With 40 people, we’re past the 23-person transition, so it’s more likely
    than not to have multiple matches.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-4](ch03.xhtml#ch03fig04)的右侧展示了三个直方图，显示返回特定匹配次数的运行比例。条形图有偏移，以防止重叠，但最左边的条形图代表实际的匹配次数。当房间里只有10个人时，没有匹配的概率很高，而多个匹配的概率几乎为零。对于23个人，出现一个匹配的情况相对常见，两个匹配较少，三个匹配大约发生3%的时间。对于40个人，已经过了23人的临界点，因此出现多个匹配的概率大于没有匹配的概率。'
- en: '***Implementing the Birthday Model***'
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***实现生日模型***'
- en: Let’s take a walk through *birthday.py*, shown in [Listing 3-1](ch03.xhtml#ch03list01).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过*birthday.py*来走一遍，见[清单3-1](ch03.xhtml#ch03list01)。
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 3-1: Simulate checking birthdays for multiple people in a room*'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单3-1：模拟检查房间内多个人的生日*'
- en: As with *sim_pi.py*, all the action is in `Simulate`. The code at the bottom
    of [Listing 3-1](ch03.xhtml#ch03list01) parses the command line to get the number
    of people in the room along with the randomness source, one of those supported
    by `RE` or a filename, and, if specified, the name of an output file (a NumPy
    array). Note that `rng` is configured to return integers in [0, 365).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 与*sim_pi.py*一样，所有的操作都在`Simulate`中。清单[3-1](ch03.xhtml#ch03list01)底部的代码解析命令行，以获取房间里的人数和随机数源，随机数源可以是`RE`支持的任何一个，或者是一个文件名，并且如果指定了，还会获取输出文件的名称（一个NumPy数组）。请注意，`rng`配置为返回[0,
    365]区间的整数。
- en: The randomness source (`rng`) and the number of people in the room are passed
    to `Simulate`. The return value is a histogram of the number of times that many
    matches occurred in the fixed 100,000 simulations (`matches`). The first element
    of `matches` is the number of times there were no matches, so the sum of all remaining
    elements divided by the sum of all elements is the probability of one or more
    matches (`prob`). The code then displays the probability and writes the histogram
    to disk if requested.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数源（`rng`）和房间内的人数被传递给`Simulate`。返回值是一个直方图，表示在固定的100,000次模拟中发生特定次数匹配的频率（`matches`）。`matches`的第一个元素是没有匹配的次数，因此，所有剩余元素的总和除以所有元素的总和就是一个或多个匹配的概率（`prob`）。然后，代码会显示该概率，并在请求时将直方图写入磁盘。
- en: In `Simulate`, `M` is the number of people in the room, fixed for all 100,000
    simulations. `Matches` will hold the outcome of each simulation, or the number
    of matches found.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Simulate`中，`M`是房间内的人数，在所有100,000次模拟中保持固定。`Matches`将保存每次模拟的结果，即找到的匹配次数。
- en: The first `for` loop covers the simulations. For each simulation, a random set
    of birthdays is selected (`bdays`), one for each of the `M` persons in the room.
    Then, the double loop over `i` and `j` compares the `i`th person’s birthday with
    all others, counting each `match`. The loop limits for `i` and `j` avoid double-counting;
    if the `i`th person’s birthday matches the `j`th person’s, then the `j`th person’s
    will match the `i`th person’s, which has already been counted. When all pairs
    of people have been compared, the count in `match` is appended to `matches`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`for`循环涵盖了模拟过程。对于每次模拟，随机选择一组生日（`bdays`），每个人（共`M`人）都有一个生日。然后，`i`和`j`的双重循环比较第`i`个人的生日与所有其他人的生日，统计每次的`match`。`i`和`j`的循环限制避免了重复计数；如果第`i`个人的生日与第`j`个人的生日匹配，那么第`j`个人的生日也会与第`i`个人的匹配，而这个已经被计数过了。所有人的生日都比较完毕后，`match`中的计数会被追加到`matches`中。
- en: Finally, after all 100,000 simulations, the list `matches` is turned into a
    NumPy array and passed to `np.bincount` to count the occurrences of each number
    of matches.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在所有100,000次模拟结束后，`matches`列表会转化为一个NumPy数组，并传递给`np.bincount`来统计每个匹配次数的出现频率。
- en: Is *birthday.py* a fair simulation? Does it do what we expect? As Hartl says,
    does it “eliminate extraneous detail in order to focus on the essentials”? The
    essential task here is to pick birthdays fairly once the number of people in the
    room is fixed. We assumed that birthdays are uniformly distributed throughout
    the year—a reasonable assumption.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*birthday.py*是一个公平的模拟吗？它是否做了我们所期望的事？正如Hartl所说，它是否“消除了多余的细节，集中精力关注本质”？这里的核心任务是，在人数固定的情况下，公平地选择生日。我们假设生日在一年中的分布是均匀的——这是一个合理的假设。'
- en: 'The simulations we’ve discussed so far are warm-ups. Let’s kick things up a
    notch and explore what is, surely, the most important process in the world, at
    least to the myriad of lifeforms on this planet: evolution.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们讨论的模拟是热身。让我们进一步提升难度，探索世界上最重要的过程——至少对地球上无数生物来说——进化。
- en: '**Simulating Evolution**'
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**模拟进化**'
- en: 'The evolution of organisms is a complex process affected by genetic and environmental
    factors. In this section, we’ll explore two factors: natural selection and genetic
    drift.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 生物的进化是一个复杂的过程，受到遗传和环境因素的影响。在这一部分，我们将探索两个因素：自然选择和基因漂变。
- en: '*Natural selection*, described by Darwin in the 19th century, is often characterized
    as “survival of the fittest.” It posits that in an environment, organisms whose
    *genotype* (genetic code) leads to an increased likelihood of survival and reproduction
    are those more likely to pass their genes on to succeeding generations. In this
    way, over time, the characteristics of the organism are modified, often eventually
    leading to organisms that can no longer breed with each other—that is, new species.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*自然选择*，由达尔文在19世纪描述，通常被称为“适者生存”。它认为，在某个环境中，基因型（遗传代码）能够提高生存和繁殖可能性的生物，更有可能将它们的基因传递给后代。通过这种方式，随着时间的推移，生物的特征发生改变，通常最终导致物种之间无法相互繁殖——也就是说，产生了新物种。'
- en: While natural selection relates to improved likelihood of survival and reproduction,
    *genetic drift* is an effect caused by environmental changes that isolate a small
    population of organisms from the larger population. In genetic drift, the subpopulation
    of organisms present during the time of isolation will have a different mix of
    genes that can cause rapid changes in the overall gene pool, often leading to
    new species.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自然选择与提高生存和繁殖的可能性有关，*基因漂变*是由环境变化引起的效应，环境变化使得一小部分生物种群与更大的种群隔离。在基因漂变中，隔离期间存在的亚种群会有不同的基因组合，这可能导致整体基因库的迅速变化，通常会导致新物种的出现。
- en: We want to simulate the essential components of natural selection and genetic
    drift. Let’s begin with the former; once we simulate natural selection, simulating
    genetic drift becomes that much clearer.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望模拟自然选择和基因漂变的核心要素。我们先从自然选择开始；一旦模拟了自然选择，模拟基因漂变将变得更加清晰。
- en: '***Natural Selection***'
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***自然选择***'
- en: 'Here are the requirements for simulating natural selection:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是模拟自然选择的要求：
- en: We need a population of organisms, each consisting of a collection of genes.
    An organism’s genes determine its fitness to the environment.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一群生物，每个生物由一组基因组成。一个生物的基因决定了它对环境的适应能力。
- en: We need an environment and some way to characterize it in terms of how well
    organisms are adapted to it. Additionally, we need a measure of fitness for this
    environment.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个环境，并以某种方式描述它，说明生物体如何适应这个环境。此外，我们还需要一个衡量该环境适应度的标准。
- en: 'We need to simulate natural selection’s two most important tools: breeding
    between organisms (*crossover*) and random *mutation*. This simulation must be
    affected by an organism’s level of fitness to the environment.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要模拟自然选择的两个最重要工具：生物体之间的繁殖（*交叉*）和随机*变异*。这个模拟必须受到生物体与环境适应度水平的影响。
- en: We need to step from generation to generation so we can monitor the population
    over time.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要从一代跨越到另一代，这样我们才能随着时间的推移监控种群。
- en: Finally, we need to easily visualize the characteristics of the population as
    it evolves across generations.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要轻松地可视化种群在代际演化中的特征。
- en: Let’s work through each statement.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一处理这些声明。
- en: '**The Organisms**'
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**生物体**'
- en: Our organisms have six genes in their genomes, each with 16 possible variants
    or *alleles*. Therefore, an organism is a vector of six elements, each [0, 15].
    These numbers will become clear as we proceed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的生物体在其基因组中有六个基因，每个基因有16种可能的变种或*等位基因*。因此，生物体是一个六维向量，每个元素的值都在[0, 15]之间。这些数字在我们继续讲解时将变得更加明确。
- en: '**The Environment**'
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**环境**'
- en: We’ll define our environment by a set of genes that correspond to the “ideal”
    organism, the one best suited to the environment. In nature, most organisms are
    well suited to their environment; if they weren’t, they’d quickly go extinct.
    However, in the spirit of simulation, we’ll pick a set of genes to be the “best”
    and use them as a proxy for the environment.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一组基因来定义我们的环境，这些基因对应于“理想”生物体，即最适应环境的生物体。在自然界中，大多数生物体都非常适应自己的环境；如果不适应，它们会迅速灭绝。然而，基于模拟的精神，我们将选择一组基因作为“最佳”基因，并用它们作为环境的代理。
- en: 'We’ll use the distance between the environment’s gene vector and an organism’s
    gene vector as a measure of the organism’s fitness. The smaller this distance,
    the fitter the organism. While there are many possible definitions of “distance”
    when discussing vectors (points), we’ll use the *Euclidean distance*: the straight
    line distance between two points. We’ll imagine each gene vector to be the coordinates
    of a point in a six-dimensional space.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用环境基因向量与生物体基因向量之间的距离作为衡量生物体适应度的标准。这个距离越小，生物体越适应环境。虽然在讨论向量（点）时有许多可能的“距离”定义，我们将使用*欧几里得距离*：两个点之间的直线距离。我们将假设每个基因向量是六维空间中某个点的坐标。
- en: 'If the environment’s gene vector is **e** = (*e*[0], *e*[1], *e*[2], *e*[3],
    *e*[4], *e*[5]) and the organism’s is **x** = (*x*[0], *x*[1], *x*[2], *x*[3],
    *x*[4], *x*[5]), then the Euclidean distance between them is:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果环境的基因向量是**e** = (*e*[0], *e*[1], *e*[2], *e*[3], *e*[4], *e*[5])，生物体的基因向量是**x**
    = (*x*[0], *x*[1], *x*[2], *x*[3], *x*[4], *x*[5])，那么它们之间的欧几里得距离是：
- en: '![Image](../images/f0086-01.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/f0086-01.jpg)'
- en: In other words, it’s the square root of the sum of the squares of the differences,
    coordinate by coordinate. Here, each coordinate is an integer in [0, 15] to represent
    the selected allele for that gene. In addition, we’ll define a minimum distance
    to interpret as “good enough.”
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，它是各坐标差异的平方和的平方根。这里，每个坐标是[0, 15]之间的整数，用来表示该基因的选定等位基因。此外，我们将定义一个最小距离，解释为“足够好”。
- en: '**Crossover and Mutation**'
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**交叉与变异**'
- en: Sexual reproduction is a brilliant method for mixing genes and creating diversity
    in the gene pool. Our organisms will breed by crossover, which picks a position
    along the genome and copies all the genes of the first parent up to that point,
    followed by all the remaining genes from the second parent. The new combination
    becomes the genetic code of the offspring. Finally, we’ll apply random mutation
    by picking a gene and randomly changing its value. [Figure 3-5](ch03.xhtml#ch03fig05)
    illustrates the crossover and mutation process.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有性繁殖是混合基因和创造基因库多样性的绝妙方法。我们的生物体将通过交叉繁殖，选择一个基因组位置，并复制第一个亲本所有基因，直到该位置，然后复制第二个亲本剩余的所有基因。新的组合将成为后代的遗传密码。最后，我们将通过随机选择一个基因并随机改变其值来应用随机变异。[图
    3-5](ch03.xhtml#ch03fig05)展示了交叉与变异的过程。
- en: '![Image](../images/03fig05.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig05.jpg)'
- en: '*Figure 3-5: Crossover and mutation producing a new offspring organism (frog
    image in the public domain, courtesy of Wikimedia Commons)*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-5：交叉与变异生成新后代生物体（青蛙图片来源于公共领域，感谢维基共享资源提供）*'
- en: Our organisms aren’t frogs, but you get the idea. Two organisms create an offspring
    using the first two genes of one and the final four of the other. Then, mutation
    changes one of the genes from 10 to 2.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的生物体不是青蛙，但你大概能理解。两个生物体通过第一个生物体的前两个基因和第二个生物体的最后四个基因来创造后代。然后，变异将改变其中一个基因，从10变为2。
- en: To simulate fitness influencing reproduction, we’ll bias the selection of organisms
    such that those with smaller fitness values are more likely to breed. We’ll do
    this with a *beta distribution*, which is included with NumPy. A beta distribution
    uses two parameters to affect the shape reflecting the overall histogram of samples.
    If both parameters, *a* and *b*, are equal to 1, the beta distribution mimics
    a uniform distribution. If the *b* parameter is increased slightly, the distribution
    is modified, making it more likely that values closer to zero will be selected.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟适应度对繁殖的影响，我们将偏向选择那些适应度较低的生物体，使其更有可能繁殖。我们将使用一个*贝塔分布*来实现这一点，NumPy中已包含该分布。贝塔分布通过两个参数影响样本的整体直方图形状。如果两个参数*a*和*b*都等于1，贝塔分布将模仿均匀分布。如果稍微增加*b*参数，分布会被修改，从而使得选择接近零的值的概率更高。
- en: Therefore, when breeding the next generation, we’ll select population members
    with indices closer to zero. We’ll sort the population by fitness, with fitter
    organisms nearer to the top of the 2D array of organisms, in which each row is
    an organism and each column a gene.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在培育下一代时，我们将选择与零较为接近的个体作为种群成员。我们将按适应度对种群进行排序，适应度较高的生物体排在二维数组的前面，其中每一行代表一个生物体，每一列代表一个基因。
- en: The net result is that fitter organisms are more likely to breed. Therefore,
    generation by generation, we expect the entire population to inch closer to the
    ideal fitness for the environment.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的结果是，适应度较高的生物体更可能繁殖。因此，随着代际的变化，我们预期整个种群会逐步接近环境的理想适应度。
- en: '**The Population from Generation to Generation**'
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**代际种群**'
- en: I previously alluded to keeping the population in a 2D array. We’ll fix the
    population size at 384 organisms; why will become apparent in time. Therefore,
    a population of organisms becomes a 2D array of 384 rows and 6 columns. Each generation
    will breed another 384 organisms. Put another way, our organisms are seasonal;
    they live a season (time step) and die after spawning the next generation. Population
    geneticists often use such a discrete model.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过将种群保持在二维数组中。我们将把种群规模固定为384个生物体；原因稍后会显现出来。因此，生物体种群变成了一个384行6列的二维数组。每一代将繁殖出另外384个生物体。换句话说，我们的生物体是季节性的；它们经历一个季节（时间步），并在繁殖下一代后死亡。种群遗传学家通常使用这样的离散模型。
- en: 'Therefore, a simulation implements each of these steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，模拟实现每个步骤如下：
- en: Select the initial population at random.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机选择初始种群。
- en: Select an environment at random.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机选择一个环境。
- en: For *N* generations, calculate the per-organism fitness, sort the population
    by fitness, and breed each member of the population using crossover and mutation.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于*N*代，计算每个生物体的适应度，按适应度排序种群，并通过交叉和变异繁殖每个种群成员。
- en: Create output based on the sequence of populations.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基于种群的序列创建输出。
- en: '**Visualization**'
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**可视化**'
- en: Every generation produces a population of 384 organisms, each with 6 genes represented
    by one of 16 alleles. Now we’ll learn why the population is always 384 organisms
    with 6 genes. We want to produce as output an image where each row of the image
    shows the population, one organism per pixel, along with the environment. Therefore,
    the output image will have 384 columns plus additional columns to show the environment.
    Each pixel gets its color from the genetic code of the corresponding organism
    with genes mapping to 4 bits of a 24-bit RGB color value, as in [Figure 3-6](ch03.xhtml#ch03fig06).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每一代产生一个384个生物体的种群，每个生物体有6个基因，由16种等位基因中的一种表示。现在我们将了解为什么种群总是384个生物体，且每个生物体有6个基因。我们希望输出的图像是每一行显示种群的图像，每个像素代表一个生物体，同时显示环境。因此，输出图像将有384列，并加上额外的列来展示环境。每个像素的颜色来自相应生物体的基因编码，基因映射到24位RGB颜色值的4位中，如[图
    3-6](ch03.xhtml#ch03fig06)所示。
- en: '![Image](../images/03fig06.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/03fig06.jpg)'
- en: '*Figure 3-6: Mapping genes to RGB colors*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-6：基因映射到RGB颜色*'
- en: In the figure, the gene vector becomes a forest green pixel. As the generations
    evolve, we expect the population to move closer to the color of the environment.
    Of course, random mutation will have some say in the matter, as well as fitness;
    we’ll experiment with both.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像中，基因向量变成了森林绿色的像素。随着代际的演化，我们预计种群会向环境的颜色靠近。当然，随机突变也会在其中起作用，适应度也会影响结果；我们将会对这两者进行实验。
- en: Let’s begin with a static environment.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从静态环境开始。
- en: '***Static World***'
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***静态世界***'
- en: 'We’ll dive into code after our experiments. To run an experiment with a static
    environment, use *darwin_static.py*:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在实验后深入研究代码。要在静态环境下运行实验，使用*darwin_static.py*：
- en: '[PRE10]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are several parameters, common to most of our experiments:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个参数，在我们的大多数实验中都很常见：
- en: 500   Number of generations (rows)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 500   代数（行数）
- en: 60   Fitness bias, [0, 1000]
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 60   适应度偏差，[0, 1000]
- en: 0.01   Mutation probability
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 0.01   突变概率
- en: 4   “Good enough” threshold
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 4   “足够好”阈值
- en: minstd   Generator name, or filename
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: minstd   生成器名称或文件名
- en: darwin_static.png   Output image name
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: darwin_static.png   输出图像文件名
- en: 73939133   Seed value (optional)
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 73939133   种子值（可选）
- en: While the simulation runs, you’ll see the average fitness per generation. As
    the generations evolve, the fitness decreases until it hovers around the “good
    enough” value. When the simulation ends, then take a look at *darwin_static.png*.
    Color is required, but the image begins something like [Figure 3-7](ch03.xhtml#ch03fig07).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当仿真运行时，你会看到每代的平均适应度。随着代际的演变，适应度逐渐降低，直到它接近“足够好”值。仿真结束后，请查看*darwin_static.png*。需要颜色，但图像开始时类似于[图3-7](ch03.xhtml#ch03fig07)。
- en: '![Image](../images/03fig07.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/03fig07.jpg)'
- en: '*Figure 3-7: Visualizing a static world*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-7：可视化静态世界*'
- en: Even with the seed specified, there will be variation between runs because we’re
    using the NumPy beta distribution function, and it doesn’t pay attention to our
    seed value.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 即使指定了种子，运行之间仍会有差异，因为我们使用的是NumPy的贝塔分布函数，而它并不考虑我们的种子值。
- en: Read the image from top to bottom. The top row is the initial, randomly generated
    population of 384 organisms. Each subsequent row is another generation bred from
    the one above, each time sorted by fitness so that fitter organisms are closer
    to the left edge. The stripe on the far left is the environment, represented by
    the ideal genome’s color.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从上到下读取图像。最上面一行是初始的、随机生成的384个生物的种群。每一行之后是从上一代繁殖出来的下一代，每次都会根据适应度进行排序，因此适应度更高的生物会靠近左边。最左边的条纹是环境，代表着理想基因组的颜色。
- en: 'As you follow down the rows of the image, the population becomes more like
    the ideal environment. However, it never collapses to match the environment exactly.
    Three command line arguments affect how quickly and consistently the population
    matches the environment: the fitness bias, the mutation probability, and the “good
    enough” threshold. Let’s understand each.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你逐行查看图像，种群变得更像理想环境。然而，它从未完全崩溃并精确匹配环境。三个命令行参数会影响种群与环境匹配的速度和一致性：适应度偏差、突变概率和“足够好”的阈值。我们来逐一理解每个参数。
- en: '**The Fitness Bias**'
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**适应度偏差**'
- en: The fitness bias is an integer in the range 0 to 1,000\. As we’ll learn in the
    code, this value is divided by 1,000 and added to the second beta distribution
    parameter. The purpose is to increase the fitness of organisms with genomes that
    are better suited to the environment. If the fitness bias is 0, there’s no reproductive
    benefit to being better suited to the environment. As the bias increases, the
    reproductive benefit increases to cause the population to approach the environment’s
    ideal more rapidly.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 适应度偏差是一个范围在0到1,000之间的整数。如我们在代码中所见，这个值会被1,000除后加到第二个贝塔分布参数上。其目的是增加适应环境更好的基因组的生物的适应度。如果适应度偏差为0，那么适应环境更好的生物不会获得生殖上的任何好处。随着偏差的增加，生殖上的好处也会增加，从而使得种群更快速地接近环境的理想状态。
- en: As an example, run *darwin_static.py* a second time and change only the fitness
    bias from 60 to 600\. The population should approach the environment’s ideal in
    only a few generations. Change the fitness bias to 0 and run again. What do you
    notice now? The population isn’t able to improve because a fitness bias of 0 means
    no reproductive benefit based on an organism’s genome. If you make the fitness
    bias 15, you might need about 1,500 generations, but you should see the population
    eventually adapt to the environment. Even a small reproductive advantage matters
    over the long haul.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，再次运行*darwin_static.py*，只改变适应度偏差从60改为600。种群应该在几代内接近环境的理想状态。将适应度偏差改为0并重新运行。现在你注意到什么了吗？种群无法改善，因为适应度偏差为0意味着没有基于基因组的繁殖优势。如果将适应度偏差设为15，你可能需要大约1500代，但最终你应该会看到种群适应环境。即使是微小的繁殖优势，在长期中也能产生影响。
- en: '**The Mutation Probability**'
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**变异概率**'
- en: Now, set the fitness bias to 60 and adjust the mutation rate, expressed as a
    probability. For example, a mutation rate of 0.01 gives each newly bred organism
    a 1 percent chance of undergoing random mutation. A 1 percent mutation rate is
    exceptionally high compared to living animals, but we need to see the effects
    we’re after without millions of generations.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将适应度偏差设为60，并调整变异率，以概率的形式表示。例如，变异率为0.01时，每个新繁殖出来的个体有1%的几率发生随机变异。1%的变异率相比于真实动物来说异常高，但我们需要在没有数百万代的情况下看到我们想要的效果。
- en: Change the mutation rate of *darwin_static.py* to 0; this means each new generation
    will be created by crossover only. Run a few times and look at the output. What
    do you notice? The population fitness should hit 4 (a distance of 4 from the ideal
    genome) and remain there indefinitely. It can’t do anything else because the genomes
    are already “ideal,” so there’s nothing left to change; pick any two for crossover,
    and, regardless of the crossover point, the offspring’s genome will still be identical
    to the parents’.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将*darwin_static.py*的变异率改为0；这意味着每一代将仅通过交叉遗传来产生。运行几次并观察输出。你注意到什么了吗？种群的适应度应该会停留在4（距离理想基因组4个单位的地方），并且会无限期地保持在那里。因为基因组已经“理想”，所以无法再发生其他变化；不论交叉点在哪里，选出任意两个个体进行交叉，它们的后代基因组仍然与父母完全相同。
- en: Let’s see how sensitive the population is to mutation. Alter the mutation rate
    from 0.01 to 0.1 (10 percent) and run a few more times. Notice that the population
    adapts to the environment, but never completely. Indeed, as you look down the
    rows of the output image, you’ll likely see regions where many members of the
    population were adapted, but a new mutation appeared and quickly altered the balance
    so that the population had to adapt again in the following generations.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看种群对变异的敏感性。将变异率从0.01调整为0.1（10%），并再运行几次。注意到种群适应了环境，但从未完全适应。实际上，当你向下查看输出图像的行时，你可能会看到一些区域，其中许多种群成员已经适应，但随后出现了新的突变，迅速改变了平衡，导致种群在随后的几代中再次适应。
- en: My runs that used a mutation rate of 0.1 generally ended with the population
    mean fitness in the 7.5 to 8.5 range, much higher than the 4 found by no mutation.
    If you change the mutation rate to 0.2 or even 0.8, the population should have
    a harder time adapting to the environment because mutations continually push the
    population away from the ideal. Changing the mutation to a lower rate, say 0.005,
    leads the population to adapt well, but over time (that is, moving down the rows
    of the output image), you’ll see that small groups of mutants appear, then adapt,
    then appear again with another mutation. In the output image, these groups appear
    as splashes of color on the right side of the image—the least fit organisms with
    the lowest probability of breeding.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我的实验中使用了0.1的变异率，最终种群的平均适应度通常在7.5到8.5之间，远高于没有变异时的4。如果将变异率改为0.2甚至0.8，种群将更难适应环境，因为变异不断将种群推离理想状态。如果将变异率调低，比如设为0.005，种群适应得很好，但随着时间推移（即输出图像的行数增加），你会看到小群体的突变体出现，然后适应，再次出现并发生新的突变。在输出图像中，这些群体表现为图像右侧的一片片颜色——适应性最差的生物，它们繁殖的概率最低。
- en: '**The “Good Enough” Threshold**'
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**“足够好”阈值**'
- en: The final command line argument is the mysterious “good enough” value, the minimum
    distance between the environment’s ideal genome and an organism’s. When calculating
    the population’s fitness, any distance less than this value is set to this value.
    Experiment by changing the “good enough” value while holding the fitness bias
    and mutation rate fixed (for example, at 60 and 0.01, respectively). The higher
    the “good enough” value, the coarser the population’s adaptation to the environment.
    Set it to 0 and the population will collapse to the ideal, quickly if the fitness
    bias is larger; if the mutation rate is 0, the population will stay there.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的命令行参数是神秘的“足够好”值，它表示环境理想基因组与有机体基因组之间的最小距离。在计算种群的适应度时，任何小于该值的距离都将被设定为该值。通过在保持适应度偏差和突变率固定（例如，分别为60和0.01）的情况下，改变“足够好”值进行实验。
    “足够好”值越高，种群对环境的适应就越粗糙。将其设置为0时，种群将快速崩溃到理想状态（如果适应度偏差较大）；如果突变率为0，种群将停留在那个状态。
- en: I recommend experimenting with *darwin_static.py* until you develop an intuitive
    feel for how changes to the fitness bias, mutation rate, and “good enough” value
    affect the outcome. Try to predict what you expect to see in the output image
    ahead of time. When using simulations, it’s vital to vary parameters, especially
    by pushing them to their limits. Not only does this help with understanding the
    processes the simulation is attempting to capture, it serves as a sanity check
    on the simulation itself, as a way to perhaps uncover weaknesses or errors making
    the results less valid.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在你对如何调整适应度偏差、突变率和“足够好”值来影响结果有了直观理解之后，再尝试*darwin_static.py*进行实验。在提前预测你期望在输出图像中看到什么。当使用模拟时，至关重要的一点是要改变参数，特别是要将它们推到极限。这不仅有助于理解模拟试图捕捉的过程，还能作为对模拟本身的理性检查，可能揭示出一些弱点或错误，使得结果的有效性受到影响。
- en: In the real world, environments are not static, at least not for timeframes
    over which evolution typically acts (though rapid evolution is possible). Let’s
    add a new feature to the simulation, allowing the environment to change slowly
    with time to understand how such change affects the population.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，环境并不是静态的，至少对于进化通常起作用的时间范围而言是如此（尽管快速进化是可能的）。让我们向模拟中加入一个新特性，使环境随着时间慢慢变化，以理解这种变化如何影响种群。
- en: '***Gradually Changing World***'
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***逐渐变化的世界***'
- en: 'The code in *darwin_slow.py* is almost identical to the code of the previous
    section, but it introduces a new feature: the environment will change, slightly,
    at an interval specified on the command line. For example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*darwin_slow.py*中的代码几乎与上一节的代码完全相同，但它引入了一个新特性：环境将在命令行指定的间隔内发生轻微变化。例如：'
- en: '[PRE11]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The new parameter is the 0.01 before the pseudorandom generator (`mt19937`).
    It says to slightly modify the environment on each generation with a probability
    of 1 percent. The *darwin_slow.py* example leads to an output image where the
    environment changes four times. The output image is similar to the static case,
    but each environment transition is marked with a black line on the left. For example,
    the first two transitions appear as in [Figure 3-8](ch03.xhtml#ch03fig08).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 新的参数是伪随机生成器（`mt19937`）前的0.01。它表示每次生成时以1%的概率略微修改环境。*darwin_slow.py*示例会生成一张输出图像，其中环境变化了四次。输出图像与静态情况相似，但每次环境过渡都在左侧用黑线标出。例如，前两次过渡如[图
    3-8](ch03.xhtml#ch03fig08)所示。
- en: '![Image](../images/03fig08.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig08.jpg)'
- en: '*Figure 3-8: The environment in transition*'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-8：环境的变化*'
- en: Detail will be visible only in the full-color image; see *darwin_slow.png* on
    the book’s GitHub repository. The initial, random population is adapting to the
    environment when the first transition occurs. The population then quickly adapts
    to the new environment when the environment changes again.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 细节仅在全彩图像中可见；请参阅书籍的GitHub仓库中的*darwin_slow.png*。当第一次过渡发生时，初始的随机种群正在适应环境。然后，当环境再次变化时，种群会迅速适应新的环境。
- en: If you look at the full *darwin_slow.png* image—hopefully using an image view
    allowing full resolution horizontally—you’ll notice that after the second change
    to the environment, the population adapts quite well, but it takes several generations.
    The visual effect is to smear the colors to the right, where the less fit organisms
    are listed. I recommend running the simulation several times without the fixed
    seed of 66 to observe the overall effect with different colors. Then, explore
    how modifications to the fitness bias and mutation rate play out as the smooth
    changes to the environment happen. To get you started, observe what happens on
    multiple runs with the parameters listed in [Table 3-2](ch03.xhtml#ch03tab02).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看完整的*darwin_slow.png*图像——最好使用可以全分辨率水平查看的图像查看工具——你会注意到，在第二次环境变化后，种群适应得相当好，但这需要几个代数的时间。视觉效果是颜色被涂抹到右边，那里的有机体适应性较差。我建议多次运行模拟，而不是使用固定的66种子，以观察不同颜色下的整体效果。然后，探索在平滑的环境变化发生时，适应性偏差和突变率的调整会如何影响结果。为了帮助你入门，观察在[表
    3-2](ch03.xhtml#ch03tab02)列出的参数下多次运行时的变化。
- en: '**Table 3-2:** Parameters to Try'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 3-2：** 尝试的参数'
- en: '| **Fitness bias** | **Mutation rate** | **Environment probability** |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **适应性偏差** | **突变率** | **环境概率** |'
- en: '| --- | --- | --- |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 600 | 0.01 | 0.300 |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| 600 | 0.01 | 0.300 |'
- en: '| 60 | 0.01 | 0.300 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 60 | 0.01 | 0.300 |'
- en: '| 1 | 0.01 | 0.005 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0.01 | 0.005 |'
- en: The first two parameter sets illustrate the effect of a rapidly changing environment
    with both strong and not so strong advantages to fitter organisms. The final set
    of parameters uses the weakest of reproductive advantages, but couples it with
    an almost static environment.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数集展示了一个快速变化的环境的效果，其中适应性强的有机体拥有较强的优势，而适应性较弱的则有较弱的优势。最后一组参数使用了最弱的生殖优势，但它与几乎静态的环境相结合。
- en: Slowly varying environments give organisms time to adapt. However, throughout
    the Earth’s long history, not all environmental changes were slow; some were quite
    sudden, even happening overnight. Let’s simulate a catastrophe.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 缓慢变化的环境给有机体足够的时间来适应。然而，在地球漫长的历史中，并非所有的环境变化都是缓慢的；有些变化非常突然，甚至可能在一夜之间发生。让我们模拟一场灾难。
- en: '***Catastrophic World***'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***灾难性世界***'
- en: One fine day, some 66 million years ago, the lifeforms of Earth were minding
    their own business when a giant asteroid rudely interrupted and, as a consequence,
    ended the 100-million-year-plus reign of the nonavian dinosaurs. Bad news for
    them; good news for us. A catastrophe happened, and life responded and appeared
    quite different after the impact. The same thing happened about 252 million years
    ago during The Great Dying when life nearly perished. The world after the extinction
    looked very different from the world before.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 大约6600万年前的一天，地球上的生命形式正在各自忙碌时，一颗巨大的小行星粗暴地打断了它们的生活，结果导致了非鸟类恐龙超过1亿年的统治结束。对它们来说是坏消息；对我们来说是好消息。一场灾难发生了，生命做出了回应，并在撞击之后表现出截然不同的样貌。大约2.52亿年前的“大灭绝”事件中，生命几乎灭绝了。同样的事情发生了，灭绝后的世界与灭绝前的世界看起来截然不同。
- en: 'We’ve simulated gradual environmental change; now, let’s give the simulation
    a hard knock and see what happens. We need *darwin_catastrophic.py*. Give it a
    go:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经模拟了渐进的环境变化；现在，让我们给模拟一个猛击，看看会发生什么。我们需要*darwin_catastrophic.py*。试试看：
- en: '[PRE12]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The parameters are identical to those of *darwin_slow.py*, the difference being
    that whenever the environment should change, it does so by picking an entirely
    new ideal environment genome. The transitions are stark. The image generated is
    similar to that of *darwin_slow.py*, but without the horizontal black line to
    mark the transitions. In this case, the transitions are, generally, quite obvious.
    To see what I mean, run the code, or look at *darwin_catastrophic.png* on the
    book’s GitHub page.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数与*darwin_slow.py*中的参数相同，不同之处在于每当环境变化时，它是通过选择一个全新的理想环境基因组来实现的。过渡变化十分明显。生成的图像与*darwin_slow.py*中的图像相似，但没有水平黑线标示过渡。在这种情况下，过渡变化通常非常明显。要理解我的意思，可以运行代码，或者查看本书GitHub页面上的*darwin_catastrophic.png*。
- en: Experiment with the simulation parameters to explore the consequences. For example,
    change the number of generations to 2,000 and look at the output image in its
    entirety by zooming out. The population’s delayed response to each environmental
    catastrophe is plain to see.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试调整模拟参数，探索结果。例如，将代数更改为2000代，通过缩小查看完整的输出图像。可以清楚地看到，种群对每次环境灾难的延迟反应。
- en: Our final simulation introduces genetic drift. How do suddenly split populations
    fare in adapting to new environments?
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终模拟引入了基因漂变。那么，突然分裂的种群在适应新环境时表现如何呢？
- en: '***Genetic Drift***'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***基因漂变***'
- en: A *population bottleneck* happens when a population experiences a sudden reduction
    in size. One kind of population bottleneck is the *founder effect*, which occurs
    when a small population splits from a larger population. The random mix of alleles
    in the new, smaller population might dramatically affect the long-term survival
    and evolution of the organisms. The code in *darwin_drift.py* simulates genetic
    drift due to the founding of a new, smaller population.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '*种群瓶颈*发生在种群经历了突然的数量减少时。一种种群瓶颈是*创始人效应*，它发生在一个小种群从一个较大的种群中分裂出来时。新较小种群中等位基因的随机组合可能会极大地影响有机体的长期生存和进化。*darwin_drift.py*
    中的代码模拟了由于创立一个新的较小种群而导致的基因漂变。'
- en: The code is similar to the previous examples, but with a twist. First, a larger
    population (all 384 organisms) evolves for generations trying to adapt to its
    environment. Then, a specified fraction of the whole population “splits off” to
    become a new population. The two populations now evolve separately. Imagine a
    colony of organisms stranded on an island and no longer able to breed with their
    mainland cousins. To make things interesting, after the split, a catastrophe happens,
    so we can observe how well (or poorly) the two populations cope with the sudden
    change in environment.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前的示例类似，但有所不同。首先，一个较大的种群（384 个有机体）经过多代进化，试图适应环境。然后，整个种群的一定比例“分裂”出来成为新的种群。这两个种群现在分别进化。想象一下，有机体的群落被困在一个岛上，无法再与大陆上的亲戚繁殖。为了增加趣味性，分裂后发生了一次灾难，因此我们可以观察两个种群如何应对环境的突变（适应得好或不好）。
- en: 'For example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE13]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The 0.2 before `pcg64` now refers to the fraction of the population that will
    split off to form the new population; that is, 20 percent of the population, randomly
    selected, breaks off to create the new population, leaving the other 80 percent
    as the larger population.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`pcg64` 前的 0.2 现在表示将会分裂出来形成新种群的种群比例；也就是说，随机选择 20% 的种群分裂出来形成新的种群，其余 80% 作为较大的种群保留。'
- en: Unlike our other simulations, *darwin_drift.py* expects a base filename (`darwin_drift`)
    instead of a complete filename. The code outputs an image, *darwin_drift.png*,
    along with a plot of the mean population fitness by generation, *darwin_drift_plot.png*.
    As before, there are 500 generations using a fitness bias of 60 and a mutation
    probability of 1 percent.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的其他模拟不同，*darwin_drift.py* 期望的是一个基础文件名（`darwin_drift`），而不是一个完整的文件名。代码输出一张图片，*darwin_drift.png*，以及一个按代数绘制的平均种群适应度图，*darwin_drift_plot.png*。与之前一样，使用了
    500 代，并且采用了 60 的适应度偏差和 1% 的突变概率。
- en: So what does our image look like? Yet again, I suggest you review the color
    image from the book’s GitHub repository, but part of the output is in [Figure
    3-9](ch03.xhtml#ch03fig09).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们的图像是什么样子的呢？再次建议你查看本书 GitHub 仓库中的彩色图像，但部分输出已在[图 3-9](ch03.xhtml#ch03fig09)中展示。
- en: '![Image](../images/03fig09.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig09.jpg)'
- en: '*Figure 3-9: Visualizing genetic drift*'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-9：可视化基因漂变*'
- en: This snippet of the larger image shows part of the simulation after the split.
    The smaller population is on the left, with the larger on the right. Also, if
    you examine the environment, there is a sudden catastrophe about one-sixth of
    the way down. The two populations respond differently to the disaster. This is
    particularly visible in the color version of the image.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这幅较大图像的片段显示了分裂后模拟的一部分。较小的种群在左边，较大的种群在右边。同时，如果你仔细观察环境，会发现大约在图像下方的六分之一处发生了突发灾难。两个种群对灾难的反应不同。这一点在彩色图像版本中尤为明显。
- en: Before the catastrophe, both populations were reasonably well adapted to their
    environment. However, the smaller population cannot recover after the catastrophe
    or successfully adjust to the new environment. The larger population does eventually
    adapt. The color version of the image clearly shows that the smaller population
    sometimes produces generations where organisms are adapting to the new environment,
    but they never last long. This effect mirrors reality; small populations are often
    very fragile and easily harmed by rapid environmental change because they lack
    the genetic diversity to adapt in time.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在灾难发生之前，两个种群都相对适应它们的环境。然而，较小的种群在灾难之后无法恢复或成功调整到新环境。较大的种群最终适应了新环境。彩色版本的图像清楚地显示，较小的种群有时会产生适应新环境的世代，但这种适应从未持续很久。这个效应反映了现实：小种群通常非常脆弱，容易受到快速环境变化的影响，因为它们缺乏足够的遗传多样性，无法及时适应。
- en: '[Figure 3-10](ch03.xhtml#ch03fig10) tracks mean population fitness as a function
    of generation.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[图3-10](ch03.xhtml#ch03fig10)追踪了平均种群适应度随世代变化的情况。'
- en: '![Image](../images/03fig10.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图像](../images/03fig10.jpg)'
- en: '*Figure 3-10: Mean population fitness by generation before and after the catastrophe*'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-10：灾难前后每代的平均种群适应度*'
- en: The founder effect event happens around generation 145, where two lines appear.
    The thicker line follows the smaller population. At first, both populations are
    relatively fit to the environment, which hasn’t yet changed, though it could be
    argued that there is more variation in fitness in the smaller population.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 创始人效应事件发生在第145代左右，出现了两条线。较粗的线表示较小的种群。一开始，两个种群都相对适应环境，环境尚未发生变化，尽管可以认为较小的种群在适应度上存在更多变异。
- en: The catastrophe occurs around generation 318\. Immediately afterward, both populations’
    fitness scores increase dramatically. Remember, a lower fitness score is better.
    Subsequent generations begin to adapt to the new environment, but not at the same
    rate. The larger population, still 80 percent of the original size, adapts to
    the new environment over time; however, the smaller population fails to do so,
    at least for the 500 generations simulated. For most runs of *darwin_drift.py*,
    the smaller population fails to adapt to the new environment as well as the larger
    population. Sometimes the reverse happens. We’ll talk about this effect in the
    discussion.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 灾难发生在第318代左右。紧接着，两个种群的适应度得分显著提高。记住，适应度得分越低越好。随后的几代开始适应新环境，但适应速度不同。较大的种群，仍然是原始种群的80％，随着时间的推移逐渐适应新环境；然而，较小的种群未能做到这一点，至少在模拟的500代内是如此。在大多数*darwin_drift.py*的运行中，较小的种群未能像较大的种群一样适应新环境。有时，情况正好相反。我们将在讨论中谈论这种效应。
- en: What happens if the population splits in half (0.5)? Or, what if the new population
    is a tiny fraction, say 5 or 10 percent? It’s probably easiest to experiment in
    these cases by fixing the fitness bias and mutation rate. Then, fix the population
    fraction and vary those parameters.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果种群分裂为一半（0.5）会发生什么？或者，如果新种群只是一个很小的部分，比如5％或10％呢？在这种情况下，最简单的实验方法是固定适应度偏差和突变率。然后，固定种群比例并调整这些参数。
- en: In [Figure 3-9](ch03.xhtml#ch03fig09), when the population splits, the members
    of the new, smaller population are selected at random. Therefore, they typically
    have an uneven representation of the genotypes in the larger population due to
    chance. That difference might mean that uncommon genotypes now have an opportunity
    to become more common.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图3-9](ch03.xhtml#ch03fig09)中，当种群分裂时，新生成的较小种群的成员是随机选取的。因此，由于偶然因素，它们通常在基因型的代表性上与较大种群不均衡。这种差异可能意味着不常见的基因型现在有机会变得更加常见。
- en: 'This effect is illustrated by the code in *drift.py*. First, a “population”
    of 10,000 digits, [0, 9], are selected. Then 20 subpopulations are constructed
    by choosing 50 members of the larger population at random. Finally, the mean of
    the larger population is displayed along with the mean of 20 subpopulations. If
    the mix of digits is the same in each, then the means will be quite close to each
    other. They are not:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个效应在*drift.py*代码中得到了体现。首先，选择一个10,000个数字的“种群”，范围是[0, 9]。然后，通过随机选择较大种群中的50个成员，构建20个子种群。最后，显示较大种群的平均值以及20个子种群的平均值。如果每个子种群的数字组合相同，那么它们的平均值将非常接近。然而，它们并不是：
- en: '[PRE14]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The subpopulation means range from a low of 3.60 to a high of 5.40\. Uniformly
    selected digits should give a population mean of 4.5, which is close to the larger
    population mean. The subpopulations, due to random chance, represent very different
    collections of digits (genomes). Now we understand why population bottlenecks
    lead to genetic drift.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 子群体的均值范围从3.60到5.40不等。均匀选择的数字应给出一个4.5的总体均值，这接近较大的总体均值。由于随机性，子群体代表了非常不同的数字集合（基因组）。现在我们明白了为什么种群瓶颈会导致基因漂变。
- en: '***Testing the Simulations***'
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***仿真测试***'
- en: We used four different sets of code for the previous simulations. Rather than
    detail each, thereby committing the literary equivalent of “death by PowerPoint,”
    let’s walk through one of them here and present snippets from the others as needed.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了四组不同的代码来进行前面的仿真。为了避免详细描述每一组，从而避免造成“死于PowerPoint”的效果，我们将在这里介绍其中一组，并根据需要展示其他组的代码片段。
- en: Look at [Listing 3-2](ch03.xhtml#ch03list02), which contains the critical parts
    of *darwin_static.py*.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看[列表 3-2](ch03.xhtml#ch03list02)，其中包含了*darwin_static.py*的关键部分。
- en: '[PRE15]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 3-2: Simulating a static environment*'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-2：模拟静态环境*'
- en: I’ve excluded comments and code related to generating the output image. Please
    review the file itself if you’re curious about how those parts work. I recommend
    reading through at least `MakeRGB` to understand the mapping from genes to RGB
    color values.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我已排除了与生成输出图像相关的注释和代码。如果你对这些部分的工作原理感兴趣，请查看文件本身。我建议至少阅读`MakeRGB`，以了解基因到RGB颜色值的映射。
- en: 'The code falls naturally into three parts: parsing the command line ➊, setting
    up the simulation ➋, and running the simulation ➍. In the first part, the randomness
    engine (`rng`) is configured, with or without a seed, to return floats in [0,
    1). The engine is used for different things, so it’s better to use only the basic
    range and adjust the bounds and data type as needed.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 代码自然地分为三个部分：解析命令行 ➊、设置仿真 ➋ 和运行仿真 ➍。在第一部分中，随机引擎（`rng`）被配置为返回[0, 1)范围内的浮点数，且可以选择是否使用种子。这个引擎用于不同的功能，因此最好仅使用基本范围，并根据需要调整边界和数据类型。
- en: Then the initial population (`pop`) of 384 organisms (`npop`) is created ➋.
    Each organism is given a randomly generated genome ➌. The `environment` is similarly
    defined. The final two variables, `hpop` and `henv`, track the evolution of the
    population and, for other variants of the code, the environment. Note the use
    of a 3D array imagined here as a vector of 2D arrays, each holding the population
    for that generation. The output image is produced using both `hpop` and `henv`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，初始种群（`pop`）包含384个生物体（`npop`） ➋。每个生物体都被赋予一个随机生成的基因组 ➌。`environment` 也类似地被定义。最后两个变量，`hpop`和`henv`，分别追踪种群的演化和其他代码变体中的环境。请注意，这里使用的是一个3D数组，想象它是由多个2D数组组成的，每个数组保存该代的种群。输出图像是通过同时使用`hpop`和`henv`生成的。
- en: 'The simulation is now ready; the initial population and environment have been
    defined. The main loop ➍ evaluates each generation. The loop body has four paragraphs:
    calculate the per-organism fitness ➎, sort the population by fitness ➏, keep a
    copy of the population for image generation ➐, and, finally, breed the next generation
    ➑.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 仿真现在已经准备好，初始种群和环境已经定义。主循环 ➍ 评估每一代的表现。循环体有四个步骤：计算每个生物体的适应度 ➎，按适应度对种群排序 ➏，保存种群副本以生成图像
    ➐，最后繁殖下一代 ➑。
- en: Let’s go through each of those steps. To calculate fitness, we subtract each
    organism’s genome from that of the environment and square and sum the result across
    all genes before applying the square root. This is the NumPy version of [Equation
    3.1](ch03.xhtml#ch03equ1). Fitness in hand, `idx` sorts both the population and
    the fitness vector so that fitter organisms are closer to the beginning of the
    population ➏. Then `hpop` stores the sorted population and environment for the
    output image ➐. The mean population fitness is also printed. As the population
    evolves, this mean value should decrease, depending on the mutation rate and the
    fitness bias.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解每个步骤。为了计算适应度，我们将每个生物体的基因组与环境的基因组进行差异计算，之后对所有基因的差值进行平方求和，再应用平方根。这是NumPy版本的[公式
    3.1](ch03.xhtml#ch03equ1)。获得适应度后，`idx`会对种群和适应度向量进行排序，使得适应度更高的生物体靠近种群的前面 ➏。然后，`hpop`存储排序后的种群和环境以供输出图像生成
    ➐。同时，种群的平均适应度也会被打印出来。随着种群的演化，这一平均值应该会减少，具体取决于突变率和适应度偏差。
- en: The last thing to do for this generation is replace it ➑. Repeated calls to
    `Mate` breed a new population of `npop` organisms from the existing population
    as shown in [Listing 3-3](ch03.xhtml#ch03list03).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 本代的最后一步是替换它 ➑。重复调用 `Mate` 函数从现有种群中繁殖出一个新的 `npop` 生物体群体，详见[示例 3-3](ch03.xhtml#ch03list03)。
- en: '[PRE16]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Listing 3-3: Producing the next generation*'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-3：产生下一代*'
- en: Here, `Mate` is given the current population and associated fitness (both sorted),
    along with the fitness bias (`advantage`). As mentioned, the fitness bias is divided
    by 1,000.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`Mate` 函数接受当前种群及其相关适应性（均已排序），以及适应性偏置（`advantage`）。如前所述，适应性偏置被除以 1,000。
- en: The function needs to select two distinct organisms, indices `i` and `j`, and
    then produce a new organism by crossover. A call to NumPy’s `beta` function returns
    a value in [0, 1), which, when scaled by the size of the population, will return
    an integer in [0, 383]. The `while` loop runs until a distinct second organism
    is selected (`j`).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数需要选择两个不同的生物体，索引 `i` 和 `j`，然后通过交叉生成一个新的生物体。调用 NumPy 的 `beta` 函数返回一个位于 [0,
    1) 区间的值，该值在根据种群大小进行缩放后，将返回 [0, 383] 范围内的一个整数。`while` 循环会持续运行，直到选中一个不同的第二个生物体（`j`）。
- en: '[Figure 3-11](ch03.xhtml#ch03fig11) shows beta distributions for different
    fitness bias values.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-11](ch03.xhtml#ch03fig11) 显示了不同适应性偏置值下的贝塔分布。'
- en: '![Image](../images/03fig11.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/03fig11.jpg)'
- en: '*Figure 3-11: Beta distribution as altered by fitness bias value. Fit organisms
    are more likely to breed if the left portion of the distribution is higher than
    the right.*'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-11：由适应性偏置值调整后的贝塔分布。如果分布的左侧高于右侧，适应性较强的生物体更可能繁殖后代。*'
- en: If the bias is 0, the beta distribution acts as a uniform distribution. There
    are 100 bins in the plot, so each will appear about 1 percent of the time (solid
    line). A relatively weak fitness bias of 60 favors small values, or fitter organisms,
    while strongly rejecting the least fit. Similarly, a bias of 900 selects most
    fit to least fit linearly.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果偏置为 0，贝塔分布就表现为均匀分布。图中有 100 个柱状图，因此每个柱状图大约会出现 1% 的时间（实线）。适应性偏置较弱（60）时，会偏好较小的值，即较适应的生物体，同时强烈排斥最不适应的个体。类似地，偏置为
    900 时，则线性选择最适应到最不适应的生物体。
- en: Crossover selects a gene position, [0, 5], and constructs the offspring (`org`)
    by keeping the first `c` genes of one parent and adding in the remaining genes
    from the second. Then, if a random value is less than the global `mutation` threshold,
    a randomly selected gene is given a new value, [0, 15]. Finally, the function
    returns the new organism’s genome.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉选择一个基因位置，[0, 5]，并通过保留一个父代的前 `c` 个基因，加入另一个父代的其余基因来构建后代（`org`）。然后，如果随机值小于全局的
    `mutation` 阈值，则随机选择一个基因赋予一个新值，[0, 15]。最后，该函数返回新生物体的基因组。
- en: 'To recap: configure, then loop over generations evaluating the population’s
    current fitness before using that information to breed the next generation. Once
    the dust settles, generate the output image.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下：首先配置，然后在代数中循环，评估当前种群的适应性，再利用这些信息来繁殖下一代。待尘埃落定后，生成输出图像。
- en: 'The file *darwin_slow.py*, which changes the environment as the population
    evolves, is nearly identical to *darwin_static.py*. The loop has one additional
    code paragraph after breeding the next generation:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 *darwin_slow.py* 通过种群的演化改变环境，几乎与 *darwin_static.py* 一模一样。这个循环在繁殖下一代后增加了一个额外的代码段：
- en: '[PRE17]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, `eprob` is the probability of the environment changing, read from the
    command line. If the environment is to change, we add an `offset` vector to alter
    the ideal genome by ±1 for each gene. Compare this with the catastrophic environmental
    change from *darwin_catastrophic.py*:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`eprob` 是环境变化的概率，从命令行读取。如果环境发生变化，我们会添加一个 `offset` 向量，逐基因地将理想基因组改变 ±1。将此与
    *darwin_catastrophic.py* 中的灾难性环境变化进行比较：
- en: '[PRE18]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The final program, *darwin_drift.py*, is structurally similar to *darwin_catastrophic.py*,
    but after a set number of generations, the population splits into two. After this
    split, the environment is altered catastrophically. Although bookkeeping is involved,
    conceptually nothing new is happening.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的程序 *darwin_drift.py* 结构上与 *darwin_catastrophic.py* 类似，但在经历一定代数后，种群会分裂成两部分。分裂之后，环境会发生灾难性的改变。尽管涉及了记账操作，但从概念上讲，并没有发生新的变化。
- en: '**Exercises**'
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**练习**'
- en: 'Use the following exercises as a springboard to expand your appreciation for
    the power of simulation. When working through them, entertain any “what if” questions
    that pop into your head:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下练习作为扩展你对模拟强大功能理解的跳板。在进行这些练习时，思考任何脑海中浮现的“假如”问题：
- en: Alter *sim_pi.py* to make two calls to `rng`, first to get the *x*-coordinates,
    then to get the *y*-coordinates. Do you notice any difference? Did you expect
    to?
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改*sim_pi.py*，使其分别调用两次`rng`，第一次获取*x*坐标，第二次获取*y*坐标。你注意到有什么不同吗？你预料到吗？
- en: Modify *birthday.py* to use *N* = 1,000,000 or *N* = 10,000\. Is there a noticeable
    difference?
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改*birthday.py*，使*N* = 1,000,000或*N* = 10,000。有什么显著的不同吗？
- en: We assumed that birthdays are uniformly distributed throughout the year. This
    isn’t strictly true, at least for Western countries. For those countries, September
    birthdays are more common. What happens to the true probability of two randomly
    selected people sharing a birthday in that case? Does it increase or decrease?
    You may wish to explore the file *birthday_true.py*, which uses data from the
    United Kingdom.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们假设生日在一年中均匀分布。这在西方国家并不完全成立，至少在这些国家中，9月的生日更为常见。那么，在这种情况下，随机选取的两人有相同生日的真实概率会发生什么变化？是增加还是减少？你可能希望探讨一下文件*birthday_true.py*，它使用了来自英国的数据。
- en: How many people need to be at the party to have a 99 percent probability of
    at least one birthday match?
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚会中至少需要多少人，才有99%的概率出现至少一个生日重合？
- en: Our evolution simulations assumed that all members of a generation bred and
    then died to produce a new generation that was the same size as the last. What
    happens if the least fit 10 percent die and do not reproduce while the fittest
    2 percent breed twice?
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的进化模拟假设每一代的所有成员都会繁殖并死亡，产生与上一代大小相同的新一代。如果最不适应的10%死亡且不繁殖，而最适应的2%繁殖两次，会发生什么？
- en: 'Bonus points:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 加分题：
- en: 'In his 1889 book, *Calcul des probabilités*, Joseph Bertrand outlined three
    approaches for calculating the probability that a randomly selected chord of a
    circle is longer than the side of an equilateral triangle inscribed in the circle.
    The files *bertrand0.py*, *bertrand1.py*, and *bertrand2.py* implement simulations
    corresponding to the three approaches:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在他1889年的书《*概率论*》中，约瑟夫·伯特朗概述了三种计算随机选取的圆弦长于圆内切正三角形边长的概率的方法。文件*bertrand0.py*、*bertrand1.py*和*bertrand2.py*实现了对应三种方法的模拟：
- en: '***bertrand0.py***   Use the chord defined by two randomly selected points
    on the circumference of the circle.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '***bertrand0.py***   使用圆上两个随机选取的点定义的弦。'
- en: '***bertrand1.py***   Use the chord perpendicular to a randomly selected point
    along a randomly selected radius of the circle.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '***bertrand1.py***   使用与随机选取的圆半径上某点垂直的弦。'
- en: '***bertrand2.py***   Use a randomly selected point inside the circle as the
    midpoint of the chord.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '***bertrand2.py***   使用圆内一个随机选择的点作为弦的中点。'
- en: Run all three approaches to select random chords of the circle. For example
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 运行三种方法来选择圆的随机弦。例如：
- en: '[PRE19]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: produces the estimated probability along with a plot showing the selected chords,
    as shown in [Figure 3-12](ch03.xhtml#ch03fig12).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 它们生成估算的概率，并附带展示所选弦的图形，如[图3-12](ch03.xhtml#ch03fig12)所示。
- en: '![Image](../images/03fig12.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/03fig12.jpg)'
- en: '*Figure 3-12: Selected chords when choosing points on the circumference of
    the circle*'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3-12：选择的圆弦，当选择圆周上的点时*'
- en: What is the estimated probability for each approach? Which one is correct? This
    is known as *Bertrand’s paradox*, and it serves as a cautionary tale to be careful
    when defining what we want to simulate and how we go about it. Review the code
    to see how the chords are selected.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法的估算概率是多少？哪一种是正确的？这被称为*伯特朗悖论*，它提醒我们在定义我们要模拟的内容及其方式时需要小心。检查代码，看看弦是如何被选取的。
- en: '**Summary**'
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: In this chapter, we began an introductory exploration of models and simulations;
    we’ll continue to encounter various models throughout the book.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们开始了对模型和模拟的初步探索；在本书中，我们将继续遇到各种模型。
- en: 'We started slowly, with simulations estimating the value of *π* by throwing
    darts and the number of people in a room, on average, necessary to have a better
    than 50 percent chance of at least two sharing a birthday. We then constructed
    a model to simulate two essential aspects of biological evolution: natural selection
    and genetic drift. We learned that even an incomplete model can be a useful tool
    that offers helpful insights.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从简单的模拟开始，估算通过掷飞镖的方法得到*π*的值，以及一个房间中平均需要多少人，才能有超过50%的概率至少两人有相同的生日。然后我们构建了一个模型来模拟生物进化的两个关键方面：自然选择和遗传漂变。我们发现，即使是不完整的模型，也可以成为有用的工具，提供有价值的见解。
- en: 'Our simulations captured some essence of important evolutionary mechanisms,
    like natural selection and genetic drift, but a huge part of reality was missing:
    death and extinction. For example, many small populations kept evolving when they
    ought to have gone extinct. Extinction is natural; virtually every species that
    has ever lived is extinct (though there’s no reason for us to hurry the process
    along). Adding death and extinction would create a level of complexity to the
    simulation that doesn’t fit with what we can accomplish in this book. Regardless,
    the simulations of this section are practical and illustrative as far as they
    go. All analogies fail at some point—that doesn’t make them useless.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模拟捕捉了一些重要进化机制的精髓，比如自然选择和基因漂变，但现实中有一大部分被忽略了：死亡和灭绝。例如，许多小型种群在应该灭绝的时候却继续进化。灭绝是自然的；几乎所有曾经存在的物种都已经灭绝（尽管我们没有理由急于加速这一过程）。加入死亡和灭绝将使模拟变得更加复杂，这超出了我们在本书中能够实现的范围。尽管如此，本节中的模拟在其范围内仍然具有实际意义和示范作用。所有的类比在某个点都会失败——这并不意味着它们毫无用处。
- en: The next chapter continues our investigation of useful randomness by diving
    into the world of optimization. Can randomness be put to work in service of locating
    the best of something?
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将继续探讨有用的随机性，通过深入优化的世界来展开。随机性能否在寻找最佳解的过程中发挥作用？
- en: '**NOTE**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There is no formal resolution to Bertrand’s paradox. Many people, including
    me, feel that p = 1/2 is the most reasonable answer.*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*没有正式的解答可以解决伯特兰悖论。包括我在内的许多人认为 p = 1/2 是最合理的答案。*'
