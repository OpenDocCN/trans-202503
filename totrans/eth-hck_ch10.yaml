- en: '**10'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**10  '
- en: BUILDING TROJANS**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 构建木马**
- en: '*Things are not always what they seem; the first appearance deceives many;
    the intelligence of a few perceives what has been carefully hidden.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*事物并非总是看起来那样；第一眼的印象欺骗了许多人；少数人的智慧看穿了那些精心隐藏的东西。*'
- en: –Phaedrus
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: –Phaedrus
- en: '![image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/common.jpg)'
- en: 'Consider the following scenario: an attacker, pretending to be the head of
    IT, sends an email to an employee. The email tells the victim to download the
    updated version of the Alpine email client. But, unbeknownst to the victim, the
    attacker has embedded an implant in the program. When the victim installs the
    client, the installer will install the implant, too.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下场景：一名攻击者伪装成 IT 部门负责人，向一名员工发送电子邮件。邮件告诉受害者下载更新版的 Alpine 邮件客户端。但受害者并不知道，攻击者已经将一个植入物嵌入到程序中。当受害者安装客户端时，安装程序也会安装该植入物。
- en: All ethical hackers should understand the mechanisms of implants like these.
    Implants concealed within legitimate files are called *trojans*. I’ll begin by
    discussing the Drovorub malware implant developed by Russian military intelligence
    (GRU) and re-create its general design using Metasploit. The implant, which was
    designed for Linux systems, provides a great case study on modern malware.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的伦理黑客都应该了解像这样的植入物机制。隐藏在合法文件中的植入物被称为*木马*。我将首先讨论由俄罗斯军事情报机构（GRU）开发的 Drovorub
    恶意软件植入物，并使用 Metasploit 重现其整体设计。这个为 Linux 系统设计的植入物为现代恶意软件提供了一个很好的案例研究。
- en: In this chapter, you’ll learn how to hide an implant in another file and obfuscate
    it to avoid detection using tools like `msfvenom`. You’ll also get some practice
    writing custom Metasploit modules by creating an encoder that can help your implant
    evade antivirus software.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何将植入物隐藏在另一个文件中，并使用诸如`msfvenom`等工具混淆它以避免被检测到。您还将通过编写自定义的 Metasploit
    模块来练习，创建一个编码器，帮助您的植入物逃避杀毒软件的检测。
- en: After exploring implants for Linux and Windows systems, I’ll also show you how
    to generate malicious implants for Android devices that can listen to a phone’s
    microphone, take pictures with the phone’s camera, find the phones location, read
    and send text messages, and download the phone’s call log. In this chapter’s exercise,
    you’ll build an implant that can steal a victim’s password by logging their keystrokes
    and take their picture by accessing their camera.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了 Linux 和 Windows 系统的植入物之后，我还将向您展示如何为 Android 设备生成恶意植入物，这些植入物可以监听手机的麦克风，使用手机的相机拍照，查找手机位置，读取并发送短信，并下载手机的通话记录。在本章的练习中，您将构建一个可以通过记录按键来窃取受害者密码，并通过访问其相机拍摄照片的植入物。
- en: '**Case Study: Re-Creating Drovorub by Using Metasploit**'
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**案例研究：使用 Metasploit 重建 Drovorub**'
- en: In 2020, the NSA released a report analyzing Drovorub. This section discusses
    the architecture of this implant, shown in [Figure 10-1](ch10.xhtml#ch10fig1),
    and describes how you can build something similar using open source tools like
    Meterpreter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 2020 年，NSA 发布了一份分析 Drovorub 的报告。本节讨论了该植入物的架构，如[图 10-1](ch10.xhtml#ch10fig1)所示，并描述了如何使用开源工具如
    Meterpreter 构建类似的东西。
- en: '![image](../images/ch10fig01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch10fig01.jpg)'
- en: '*Figure 10-1: The architecture of the Drovorub implant described by the NSA
    report*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-1：NSA 报告中描述的 Drovorub 植入物架构*'
- en: 'Drovorub consists of four key parts: the attacker’s server, the attacker’s
    agent, the malware client, and the malware kernel module. Once an attacker has
    compromised a victim’s machine, they install the malware client and malware kernel
    module. The kernel module helps the implant avoid detection by overriding the
    operating system’s malware detection functions. In a way, this is like pasting
    a picture of a room over a security camera. The malware client communicates with
    the attacker’s server, which manages connections from multiple machines and stores
    information on each connection in a central database, and allows the attacker
    to control the victim’s machine.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Drovorub 由四个关键部分组成：攻击者的服务器、攻击者的代理、恶意软件客户端和恶意软件内核模块。一旦攻击者攻破了受害者的机器，他们会安装恶意软件客户端和恶意软件内核模块。内核模块通过覆盖操作系统的恶意软件检测功能，帮助植入物避免被检测到。从某种程度上来说，这就像是在监控摄像头前贴上一张房间的照片。恶意软件客户端与攻击者的服务器进行通信，服务器管理来自多台机器的连接，并在中央数据库中存储每个连接的信息，同时允许攻击者控制受害者的机器。
- en: You could construct something similar to the Drovorub implant using open source
    tools. We’ll do so here using the *Metasploit Framework*, an open source collection
    of software libraries, hacker tools, and exploit code. The ethical hacking community
    regularly contributes to Metasploit, so it’s a great tool to have in your ethical
    hacking toolbox.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用开源工具构建类似 Drovorub 植入程序的东西。我们将在这里使用 *Metasploit 框架*，这是一个开源的软件库、黑客工具和漏洞代码的集合。伦理黑客社区经常为
    Metasploit 做出贡献，因此它是你伦理黑客工具箱中的一款好工具。
- en: '***Building the Attacker’s Server***'
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构建攻击者的服务器***'
- en: 'Let’s begin by setting up the attacker’s server, also called the command and
    control server, which will accept connections from implants installed on victim
    devices. The Metasploit Framework allows you to host such a server on an independent
    machine, but we’ll host it directly on our Kali Linux virtual machine. Run the
    following command to get the machine’s IP address:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先设置攻击者的服务器，也就是命令和控制服务器，它将接受来自安装在受害者设备上的植入的连接。Metasploit 框架允许你将这样的服务器托管在独立的机器上，但我们将直接在
    Kali Linux 虚拟机上托管它。运行以下命令获取机器的 IP 地址：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Write down this address; you’ll need it later.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 记下这个地址，你稍后会用到它。
- en: Next, you’ll need to start the PostgreSQL server, which comes preinstalled on
    Kali Linux. PostgreSQL is the database that will store implant connection metadata.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要启动 PostgreSQL 服务器，该服务器在 Kali Linux 中预装。PostgreSQL 是用来存储植入连接元数据的数据库。
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that the server is running, let’s start `msfconsole`, which allows you
    to access the features of the Metasploit Framework. Metasploit should be pre-installed
    in Kali Linux, so you shouldn’t have to install it yourself. Start `msfconsole`
    by opening a terminal and running the following command:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在服务器已经启动，让我们启动 `msfconsole`，它允许你访问 Metasploit 框架的功能。Metasploit 应该已经预装在 Kali
    Linux 中，所以你不需要自己安装。通过打开终端并运行以下命令来启动 `msfconsole`：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The console will take some time to boot up. After it has started, run the following
    command to begin the server setup process:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台启动需要一些时间。启动后，运行以下命令开始服务器设置过程：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `use` command allows you to select modules in the Metasploit Framework.
    *Modules* are pieces of software that perform specific tasks. We’ll use the handler
    modules in the *exploit/multi* folder to create the hacker’s server. These modules
    function like the TCP server we developed in [Chapter 4](ch04.xhtml#ch4). They
    will listen for connections from clients.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`use` 命令允许你选择 Metasploit 框架中的模块。*模块* 是执行特定任务的软件。我们将使用 *exploit/multi* 文件夹中的处理模块来创建黑客的服务器。这些模块类似于我们在[第
    4 章](ch04.xhtml#ch4)中开发的 TCP 服务器。它们将监听来自客户端的连接。'
- en: 'Once you’ve selected the modules, use the `set` command to assign them context-specific
    values. Start by setting the type of implant for which the server should listen.
    Metasploit has several implant types for Windows, Linux, iOS, and Android systems.
    We’ll be attacking a Linux system, so we’ll listen for Linux x86 implants. Run
    the following command to set the type:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 选择模块后，使用 `set` 命令为它们分配特定上下文的值。首先设置服务器应该监听的植入类型。Metasploit 有多个适用于 Windows、Linux、iOS
    和 Android 系统的植入类型。我们将攻击一个 Linux 系统，因此我们会监听 Linux x86 植入。运行以下命令来设置类型：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `PAYLOAD` flag specifies the type of implant to listen for. Fun fact: the
    term *payload* has its origins in military terminology, where it is often used
    when referring to the contents of a bomb.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`PAYLOAD` 标志指定了要监听的植入类型。有趣的是，*payload* 这个词源于军事术语，通常用来指代炸弹的内容。'
- en: 'Next, set the server’s IP address by passing it your Kali Linux machine’s IP
    address:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过传递 Kali Linux 机器的 IP 地址来设置服务器的 IP 地址：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`LHOST` stands for *listening host*. Now set the listening port (`LPORT`):'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`LHOST` 代表 *监听主机*。现在设置监听端口 (`LPORT`)：'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We chose port 443 because it is associated with the HTTPS protocol and makes
    the network traffic appear less suspicious. Some implants even communicate over
    the DNS protocol to avoid raising suspicion. Run the following command to start
    the server you’ve configured:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了端口 443，因为它与 HTTPS 协议相关联，并且能使网络流量看起来不那么可疑。有些植入程序甚至通过 DNS 协议进行通信，以避免引起怀疑。运行以下命令启动你配置的服务器：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `exploit` command runs the module. If you’ve successfully started the server,
    you should see the following output:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`exploit` 命令运行模块。如果你已经成功启动了服务器，应该能看到以下输出：'
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Leave this terminal open so that the server will continue to run.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 保持这个终端打开，以便服务器继续运行。
- en: '***Building the Victim Client***'
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构建受害者客户端***'
- en: 'Now let’s create the implant that we’ll install on the victim’s machine. Create
    a new folder on your Kali Linux desktop called *Malware*:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建要安装到受害者机器上的植入物。在你的Kali Linux桌面上创建一个名为*Malware*的新文件夹：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Open a new terminal and run the following command to navigate to that folder:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的终端，运行以下命令以导航到该文件夹：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We’ll use the `msfvenom` tool to create the malicious implant. Run the following
    command to do so:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`msfvenom`工具来创建恶意植入物。运行以下命令来创建：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `-a` flag represents the architecture being targeted, in this case `x86`.
    The `--platform` flag specifies the target platform, and the `-p` flag specifies
    the payload type, in this case a reverse TCP shell like the one we implemented
    in [Chapter 4](ch04.xhtml#ch4). The `--smallest` flag generates the smallest possible
    payload. The `-i` flag helps us to avoid antivirus detection, and I’ll discuss
    it more later. The `-f` flag presents the file type we need to output. We chose
    `elf` because it’s used by Linux executables. (The *exe* format is used by Windows
    executables.) The `-o` flag specifies the name of the output file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`-a`标志代表目标架构，这里是`x86`。`--platform`标志指定目标平台，`-p`标志指定有效载荷类型，这里是像我们在[第4章](ch04.xhtml#ch4)中实现的反向TCP
    shell。`--smallest`标志生成最小可能的有效载荷。`-i`标志有助于我们避免防病毒检测，我稍后会详细讨论。`-f`标志表示我们需要输出的文件类型。我们选择了`elf`，因为它是Linux可执行文件使用的格式。（*exe*格式是Windows可执行文件使用的格式。）`-o`标志指定输出文件的名称。'
- en: '***Uploading the Implant***'
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***上传植入物***'
- en: 'We’ll deliver the implant the same way we delivered the reverse shell in [Chapter
    4](ch04.xhtml#ch4): by downloading it onto the victim machine. Start a Python
    server inside the Malware folder by running the following command.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以与在[第4章](ch04.xhtml#ch4)中交付反向shell相同的方式交付植入物：通过将其下载到受害者机器上。在Malware文件夹中启动一个Python服务器，运行以下命令。
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In previous chapters, we looked at several ways to gain access to a system.
    For simplicity, instead of using the backdoor like we did before, we’ll assume
    that a hacker has stolen the credentials for the system. Start up the Metasploitable
    server and log in using username **msfadmin** and password **msfadmin**. Then,
    use the utility `wget` to download the implant:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们讨论了几种获得系统访问权限的方法。为简化起见，我们不再使用之前的后门，而是假设黑客已经窃取了系统的凭据。启动Metasploitable服务器并使用用户名**msfadmin**和密码**msfadmin**登录。然后，使用`wget`工具下载植入物：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Make the implant executable (`+x`) by running the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令使植入物可执行（`+x`）：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the malicious program by executing the following command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下命令运行恶意程序：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `&` option runs the process in the background.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`&`选项将在后台运行该进程。'
- en: 'Open the Kali terminal running the hacker’s server. If the implant has successfully
    connected, you should see output like the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 打开运行黑客服务器的Kali终端。如果植入物成功连接，你应该看到如下输出：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Congratulations. You’ve just installed your first open source malware implant.
    Yes, it really is that easy. Now let’s interact with the implant using the attacker
    agent.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你！你刚刚安装了第一个开源恶意软件植入物。是的，它真的这么简单。现在，让我们使用攻击者代理与植入物进行交互。
- en: '***Using the Attacker Agent***'
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用攻击者代理***'
- en: 'This agent supports a variety of commands that allow you to interact with the
    implant. For example, you could list all the files on the machine using the `ls`
    command. Here, the Meterpreter interface represents the hacker agent:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该代理支持多种命令，允许你与植入物进行交互。例如，你可以使用`ls`命令列出机器上的所有文件。这里，Meterpreter界面代表黑客代理：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can download or edit any of these files using the `download` and `edit`
    commands, and you can list all available commands by running the `help` command.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`download`和`edit`命令下载或编辑这些文件，且可以通过运行`help`命令列出所有可用命令。
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can gain access to the victim’s shell by running the `shell` command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行`shell`命令访问受害者的shell：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Try interacting with the shell by running the command `whoami`. When you’re
    done, type `**exit**` to return to the Meterpreter interface.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行命令`whoami`尝试与shell进行交互。完成后，输入`**exit**`返回Meterpreter界面。
- en: '***Why We Need a Victim Kernel Module***'
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***为什么我们需要受害者的内核模块***'
- en: 'If a system administrator on our Metasploitable machine views the running processes
    with the following command, the malicious program will show the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Metasploitable机器上的系统管理员使用以下命令查看运行中的进程，恶意程序将显示如下：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `ps` command lists all (`a`) processes for all users (`u`). This command
    is equivalent to the task manager on Windows.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps`命令列出了所有用户(`u`)的所有进程(`a`)。此命令相当于Windows中的任务管理器。'
- en: As you can see, the malicious program shows up ➊. How do hackers avoid detection?
    They do so using a *rootkit*, software that provides the implant access to functionality
    of the operating system’s kernel, which is the highest possible access. The implant
    can use this access to make itself virtually undetectable. For instance, Meterpreter
    will attempt to evade detection by pretending to be another process. On Windows,
    you can use Meterpreter’s `migrate` command to hide your malicious process inside
    another process. We discuss the process of hiding in detail in [Chapter 11](ch11.xhtml#ch11).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，恶意程序显示在 ➊ 处。黑客如何避免被检测？他们通过使用*rootkit*，这是一种为植入物提供操作系统内核功能访问的软件，内核是最高级别的访问权限。植入物可以利用此访问权限使自己几乎无法被检测到。例如，Meterpreter将尝试通过伪装成另一个进程来躲避检测。在Windows上，你可以使用Meterpreter的`migrate`命令将恶意进程隐藏在另一个进程中。我们将在[第11章](ch11.xhtml#ch11)中详细讨论隐藏过程。
- en: '**Hiding an Implant in a Legitimate File**'
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**隐藏植入物于合法文件中**'
- en: Attackers often use social engineering techniques to get implants onto a victim’s
    machine. For example, they might send a victim a phishing email that encourages
    them to download a *trojan*, a program that carefully hides a malicious implant
    inside another program. The term *trojan* comes from the Trojan wars, during which
    (legend has it) the Greeks gained access to the city of Troy by hiding in a large
    statue of a horse called the Trojan Horse. We’ll execute a similar attack here
    by sending a phishing email encouraging a victim to download an updated version
    of the company’s email client, Alpine, from a fake site. You’ll execute this attack
    on the Ubuntu desktop machine in your virtual environment. Let’s begin by creating
    the Trojan.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者经常使用社交工程技术将植入物植入受害者的机器。例如，他们可能会向受害者发送钓鱼邮件，鼓励他们从一个假网站下载公司的电子邮件客户端Alpine的更新版本，木马程序会小心地将恶意植入物隐藏在另一个程序中。*木马*这一术语源自特洛伊战争，据传，希腊人通过藏在一个巨大的马形雕像“特洛伊木马”中，成功攻入了特洛伊城。我们将在这里执行类似的攻击，通过发送钓鱼邮件，鼓励受害者从假网站下载公司的电子邮件客户端Alpine的更新版本。你将在虚拟环境中的Ubuntu桌面机器上执行此攻击。现在开始创建木马。
- en: '***Creating a Trojan***'
  id: totrans-74
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***创建木马***'
- en: Create a folder called *trojans* inside of your *Malicious* folder and navigate
    to it. This is where you’ll place the trojan you’ll create.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的*Malicious*文件夹内创建一个名为*trojans*的文件夹并进入该文件夹。这是你将创建的木马存放的地方。
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We’ll create our trojan by modifying the Alpine installer, the *.deb* file,
    so that it installs the implant as well as Alpine. Download the legitimate Alpine
    installer by running the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过修改Alpine安装程序中的*.deb*文件来创建木马，使其安装植入物和Alpine。运行以下命令下载合法的Alpine安装程序：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After you’ve downloaded the client, extract the contents of the file to the
    *mailTrojan* folder by running the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下载客户端后，通过运行以下命令将文件内容提取到*mailTrojan*文件夹：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Open the *mailTrojan* folder. [Figure 10-2](ch10.xhtml#ch10fig2) shows its contents.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*mailTrojan*文件夹。[图10-2](ch10.xhtml#ch10fig2)显示了它的内容。
- en: '![image](../images/ch10fig02.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch10fig02.jpg)'
- en: '*Figure 10-2: The files in the* trojans/mailTrojan *folder contain the extracted.deb
    file.*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-2：* trojans/mailTrojan *文件夹中的文件包含提取的.deb文件。*'
- en: '**Editing Your.deb File**'
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**编辑你的.deb文件**'
- en: You’ll need to edit the Alpine installer’s *.deb* installation file so that
    it includes your malicious implant, so let’s walk through the installer’s structure.
    All installation files must contain a *DEBIAN* folder, which contains the files
    that describe the program and how to install it. The installation file can also
    contain other folders such as *var* for files or *usr* for binaries. These folders
    are copied to a location relative to the */home* directory during installation.
    For example, the installer would copy the *usr* folder to */home/usr*. The installer
    then will read the contents of the *DEBIAN* folder.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要编辑Alpine安装程序的*.deb*安装文件，使其包含你的恶意植入物。现在让我们了解安装程序的结构。所有安装文件必须包含一个*DEBIAN*文件夹，里面包含描述程序及其安装方法的文件。安装文件还可以包含其他文件夹，如*var*文件夹用于文件，或*usr*文件夹用于二进制文件。这些文件夹将在安装过程中相对于*/home*目录的位置进行复制。例如，安装程序会将*usr*文件夹复制到*/home/usr*。然后安装程序会读取*DEBIAN*文件夹的内容。
- en: Click the *DEBIAN* folder. You should see the files shown in [Figure 10-3](ch10.xhtml#ch10fig3).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 点击*DEBIAN*文件夹。你应该能看到[图10-3](ch10.xhtml#ch10fig3)中所示的文件。
- en: '![image](../images/ch10fig03.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch10fig03.jpg)'
- en: '*Figure 10-3: The contents of the* DEBIAN *folder*'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-3：* DEBIAN *文件夹的内容*'
- en: 'As you can see, this folder contains three files (*control*, *md5sums*, and
    *postint*). Let’s look at each of these and alter them as required. The following
    is a snippet from the Alpine control file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个文件夹包含三个文件（*control*、*md5sums*和*postint*）。让我们查看其中的每个文件，并根据需要进行修改。以下是Alpine控制文件的一部分：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The control file is required for all Debian packages and must contain information
    on the program. For example, this file contains the name of the package ➊, the
    hardware architecture that it supports ➋, the name of the maintainer ➌, and its
    dependencies ➍.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 控制文件是所有Debian包所必需的，必须包含程序的相关信息。例如，这个文件包含包的名称➊、它支持的硬件架构➋、维护者的姓名➌以及它的依赖项➍。
- en: 'The *md5sums* file contains the MD5 hashes of the files included in the installation.
    These hashes aren’t checked during installation. Instead, they’re used to verify
    the integrity of the files after installation. If you want, you can add an MD5
    hash of your malicious implant. You don’t have to, but it’s an extra stealthy
    step. The following is a snippet from the *md5sum* file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*md5sums*文件包含安装中包含的文件的MD5哈希值。安装过程中不会检查这些哈希值，而是用来验证安装后文件的完整性。如果你愿意，可以添加你恶意植入程序的MD5哈希值。虽然不是必需的，但这是一个额外的隐蔽步骤。以下是*md5sum*文件的一部分：'
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The *postint* file is run after the installation has completed. Debian packages
    normally contain *preint* and *postint* files that the original package developer
    placed to instruct the Debian package manager what to do before and after installation.
    We’ll add the code that will activate our implant to the *postint* file. The *postint*
    file is a great candidate because it will be run after the application has been
    installed, thus the implantation process won’t interfere with the installation.
    If the file doesn’t exist, create it by using the file manager or by running the
    following command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*postint*文件在安装完成后运行。Debian包通常包含*preint*和*postint*文件，这些文件是原始包开发者放置的，用来指示Debian包管理器在安装前后需要执行的操作。我们将把激活植入程序的代码添加到*postint*文件中。*postint*文件是一个理想的选择，因为它会在应用程序安装后运行，这样植入过程就不会干扰安装。如果该文件不存在，可以通过文件管理器创建它，或者运行以下命令：'
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Open the *postint* file and copy in the following code snippet.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*postint*文件并复制以下代码段。
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will add execute permissions to the malicious file ➊ and then executes
    it with root privileges ➋.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为恶意文件添加执行权限➊，并用root权限执行它➋。
- en: 'Next, make *postint* executable by running the following command:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令使*postint*文件可执行：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Adding the Implant**'
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**添加植入程序**'
- en: 'Now we’ll create the implant and add it to the */usr/bin* folder, to ensure
    that the installer will copy it to the */home/usr/bin* folder on the victim’s
    machine during installation. Start by navigating to *usr/bin* inside the *mailTrojan*
    folder:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建植入程序，并将其添加到*/usr/bin*文件夹中，以确保安装程序在安装过程中将其复制到受害者机器上的*/home/usr/bin*文件夹。首先，导航到*mailTrojan*文件夹中的*usr/bin*文件夹：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, use the `msfvenom` command to create the malicious file, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`msfvenom`命令创建恶意文件，如下所示：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We’ll use `msfvenom` with the same options as before to generate a malicious
    implant. However, instead of copying the implant directly onto the victim’s machine,
    we’ll hide it inside Alpine’s installation folder. Copy the resulting *malicous*
    binary to the *usr* folder. Now the contents of your *usr/bin/* folder should
    resemble [Figure 10-4](ch10.xhtml#ch10fig4).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`msfvenom`，并使用与之前相同的选项生成恶意植入程序。不过，除了直接将植入程序复制到受害者的机器上，我们还将它隐藏在Alpine的安装文件夹中。将生成的*malicous*二进制文件复制到*usr*文件夹中。现在，你的*usr/bin/*文件夹内容应该类似于[图10-4](ch10.xhtml#ch10fig4)。
- en: '![image](../images/ch10fig04.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch10fig04.jpg)'
- en: '*Figure 10-4: The contents of the* usr/bin/ *folder*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-4：* usr/bin/*文件夹的内容*'
- en: 'Now you’re ready to repackage your files into your final *.deb* installation
    file. Run the following command to start the repacking process:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以准备将文件重新打包成最终的*.deb*安装文件。运行以下命令开始重新打包过程：
- en: '[PRE31]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Voilà! You’ve created your first trojan. You can view it by navigating to the
    */Desktop/Malware/trojans* folder and running the `**ls**` command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了！你已经创建了第一个特洛伊木马。你可以通过导航到*/Desktop/Malware/trojans*文件夹并运行`**ls**`命令查看它：
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The file beginning with *alpine* is the unmodified Alpine installer. The *mailTrojan*
    folder is the folder to which we’ve just added the malicious files, and *mailTrojan.deb*
    is our newly repackaged trojan containing the implant. One suggested improvement:
    an attacker might pick a stealthier name.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以*alpine*开头的文件是未修改的Alpine安装程序。*mailTrojan*文件夹是我们刚刚添加恶意文件的文件夹，*mailTrojan.deb*是我们重新包装的包含植入物的木马。一个建议的改进是：攻击者可能会选择一个更隐蔽的名字。
- en: Attacks like this really do work, often at a large scale. Take Solarwinds, which
    makes software that governments and large corporations use to manage and secure
    their networks. In 2020, hackers were able to break into Solarwinds computers
    and modified one of their software libraries to include a malicious implant. When
    Solarwinds installed their software update, it also installed the infected library.
    This attack affected several corporations and government agencies that used Solarwinds
    software. The implant was carefully crafted, even containing a strategy for avoiding
    detection. For example, it waited two weeks before activating and wouldn’t start
    if it detected security-related software like Wireshark.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的攻击确实有效，而且通常规模很大。以Solarwinds为例，Solarwinds生产的软件是政府和大型企业用来管理和保护其网络的。2020年，黑客成功入侵Solarwinds的计算机，并修改了其中一个软件库，加入了恶意植入物。当Solarwinds安装其软件更新时，恶意植入库也被一同安装。此次攻击影响了多个使用Solarwinds软件的公司和政府机构。这个植入物经过精心设计，甚至包含了一种避免被发现的策略。例如，它在激活之前等待了两周，并且如果检测到如Wireshark等安全相关软件，它就不会启动。
- en: '***Hosting the Trojan***'
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***托管木马***'
- en: 'An attacker could host the trojan we’ve just created on GitHub or on a faked
    website. In this section, we’ll host the trojan on our Kali Linux virtual machine
    and serve it from a local webserver. Ensure that you’re in the folder containing
    your trojan and run the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可以将我们刚刚创建的木马托管在GitHub或伪造的网站上。在这一部分，我们将在我们的Kali Linux虚拟机上托管木马，并通过本地Web服务器提供服务。确保你处于包含木马的文件夹中，并运行以下命令：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, you’ll need to start the attacker server that will listen for connections
    from your implant. Instead of performing one step at a time as we did earlier,
    we can run all of the commands on one line in a new terminal:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要启动攻击者服务器，监听来自植入物的连接。我们可以不再像之前那样一步一步执行命令，而是在新终端中将所有命令放在一行中执行：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we have two servers running: one that serves the implant and another that
    accepts incoming connections from all installed implants. The next thing we must
    do is test the trojan by downloading the implant onto our Ubuntu virtual machine.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个服务器在运行：一个提供植入物，另一个接收来自所有已安装植入物的连接。接下来我们必须做的就是通过将植入物下载到我们的Ubuntu虚拟机上来测试木马。
- en: '***Downloading the Infected File***'
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***下载感染文件***'
- en: 'Start the Ubuntu virtual machine and then simulate a user clicking an email
    link by copying and pasting the following link into the browser, making sure to
    specify the IP address of your Kali Linux machine: *http://<Kali IP address>/mailTrojan.deb*.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Ubuntu虚拟机，然后通过复制并粘贴以下链接到浏览器中来模拟用户点击电子邮件链接，确保指定你的Kali Linux机器的IP地址：*http://<Kali
    IP地址>/mailTrojan.deb*。
- en: Select the **Save File** option when presented with a download window, as shown
    in [Figure 10-5](ch10.xhtml#ch10fig5).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现下载窗口时，选择**保存文件**选项，如[图10-5](ch10.xhtml#ch10fig5)所示。
- en: '![image](../images/ch10fig05.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch10fig05.jpg)'
- en: '*Figure 10-5: Downloading the* mailTrojan.deb *file*'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-5：下载* mailTrojan.deb *文件*'
- en: This will save the *.deb* installer file to your *Downloads* folder. Open the
    *Downloads* folder in the file explorer and then install the file by right-clicking
    and selecting **Open with** ▶ **Install Software**.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把*.deb*安装文件保存到你的*下载*文件夹。打开文件资源管理器中的*下载*文件夹，然后通过右键点击文件并选择**打开方式** ▶ **安装软件**来安装文件。
- en: You might be wondering if an actual user would really do all of this. But consider
    all the packages you’ve installed by running `sudo apt-get`. Can you be sure that
    none of those *.deb* files contained implants? Once you’ve started the package
    installer, you should see the screen in [Figure 10-6](ch10.xhtml#ch10fig6). Select
    **Install**.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，真实用户真的会做这些操作吗？但想想你通过运行`sudo apt-get`安装的所有软件包。你能确保这些*.deb*文件中没有植入物吗？一旦你启动了包管理器，应该会看到[图10-6](ch10.xhtml#ch10fig6)中的界面。选择**安装**。
- en: '![image](../images/ch10fig06.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch10fig06.jpg)'
- en: '*Figure 10-6: The install screen for the Alpine email client*'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-6：Alpine电子邮件客户端的安装界面*'
- en: 'Enter your Ubuntu password. Once the installation process has completed, run
    the following command to start the Alpine terminal email client:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 输入你的 Ubuntu 密码。安装过程完成后，运行以下命令启动 Alpine 终端邮件客户端：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If Alpine was installed correctly, you will see a terminal interface. Now let’s
    check whether our implant was installed, too.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Alpine 安装正确，你将看到一个终端界面。现在让我们检查一下我们的植入程序是否也已安装。
- en: '***Controlling the Implant***'
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***控制植入程序***'
- en: 'Reopen the terminal running the attacker server you started earlier. If the
    implant was correctly installed, you should see the following, indicating the
    implant has connected to the server:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 重新打开之前启动的攻击者服务器的终端。如果植入程序已正确安装，你应该会看到以下内容，表示植入程序已经连接到服务器：
- en: '[PRE36]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Great! Run the following command to see all the things you can do with your
    implant:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！运行以下命令查看你可以使用植入程序做的所有事情：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now what could you do to go further? How about installing a backdoor so that
    you can easily get back in? The Meterpreter implant will disconnect if someone
    restarts the machine or deletes the malicious file. You could attempt to maintain
    access by recompromising the machine, but if the victim changes their password
    or patches the program you originally exploited, all your effort would have been
    for nothing. This is why hackers install backdoors; they allow an attacker to
    regain access to a machine through an alternate route. When I discuss rookits
    in [Chapter 11](ch11.xhtml#ch11), I’ll show you how to design your own backdoor.
    But if you want to install one now, consider using the *dbd backdoor* designed
    by Kyle Barnthouse and available at *[https://github.com/gitdurandal/dbd/](https://github.com/gitdurandal/dbd/)*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 那么接下来你能做什么呢？如何安装一个后门，方便你随时重新进入呢？如果有人重启机器或删除恶意文件，Meterpreter 植入程序将会断开连接。你可以尝试重新攻破机器以保持访问，但如果受害者更改了密码或修补了你最初利用的漏洞，所有的努力都将付诸东流。这就是为什么黑客安装后门；它们允许攻击者通过替代路径重新进入机器。当我在[第11章](ch11.xhtml#ch11)中讨论
    rootkit 时，我会展示如何设计自己的后门。但如果你现在想安装一个，考虑使用 Kyle Barnthouse 设计的*dbd 后门*，可以在 *[https://github.com/gitdurandal/dbd/](https://github.com/gitdurandal/dbd/)*
    上找到。
- en: '**Evading Antivirus by Using Encoders**'
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**通过使用编码器避开杀毒软件**'
- en: Won’t antivirus software detect these malicious programs? Not always. You can
    see which antivirus software will detect your implant by uploading it to Virus
    Total at *[https://www.virustotal.com/gui/](https://www.virustotal.com/gui/)*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 杀毒软件不会检测到这些恶意程序吗？并不总是。你可以通过将其上传到 Virus Total 来查看哪些杀毒软件会检测到你的植入程序，网址是 *[https://www.virustotal.com/gui/](https://www.virustotal.com/gui/)*。
- en: 'Antivirus systems use *signature detection* to attempt to find malware. A malware’s
    signature is a unique sequence of bytes that represents it. You can see our malicious
    implant’s byte sequence by running the `xxd` command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 杀毒系统使用*特征检测*来尝试查找恶意软件。恶意软件的特征是其独特的字节序列。你可以通过运行 `xxd` 命令查看我们恶意植入程序的字节序列：
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Antivirus software detects malware by scanning memory for these signatures,
    so you can avoid detection by ensuring that your malware has a signature not already
    known to antivirus systems.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 杀毒软件通过扫描内存中的这些特征来检测恶意软件，因此你可以通过确保你的恶意软件具有一个尚未被杀毒系统识别的特征来避免被检测。
- en: 'One way to do this is by running the malware through an *encoder*. Encoders
    change a program’s signature by modifying its bytes without changing its functionality.
    You might be wondering: Wouldn’t changing the bytes change both the instructions
    and the program’s functionality? Well, two programs can have the same functionality
    even if they don’t use the same instructions. For example, both of these programs
    multiply a number by 2:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是通过运行恶意软件并使用*编码器*。编码器通过修改程序的字节而不改变其功能来改变程序的特征。你可能会想：改变字节难道不会改变指令和程序的功能吗？其实，两个程序即使使用不同的指令，只要它们实现相同的功能，也能有相同的效果。例如，以下两个程序都将数字乘以
    2：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let’s make this idea concrete by applying a simple encoder. Msfvenom supports
    several encoders. You can view a list of them by starting `msfconsole` and running
    the `show encoders` command.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过应用一个简单的编码器来具体化这个想法。Msfvenom 支持多个编码器。你可以通过启动 `msfconsole` 并运行 `show encoders`
    命令查看它们的列表。
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Let’s take a closer look at the two encoders shown in this output, starting
    with the easiest one.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看输出中显示的两个编码器，从最简单的开始。
- en: '***The Base64 Encoder***'
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Base64 编码器***'
- en: The `powershell_base64` encoder uses the base64 encoding scheme, which converts
    binary sequences to text, just like the ASCII encoding scheme mentioned in [Chapter
    5](ch05.xhtml#ch5). However, unlike ASCII, which converts 8-bit sequences, the
    base64 encoder converts 6-bit sequences to one of 64 possible printable characters.
    Consider the example in [Table 10-1](ch10.xhtml#ch10tab1), which converts the
    Linux `ls` command from ASCII to base64.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`powershell_base64` 编码器使用 base64 编码方案，它将二进制序列转换为文本，类似于 [第 5 章](ch05.xhtml#ch5)
    中提到的 ASCII 编码方案。然而，与将 8 位序列转换为字符的 ASCII 不同，base64 编码器将 6 位序列转换为 64 个可能的可打印字符之一。考虑
    [表 10-1](ch10.xhtml#ch10tab1) 中的示例，它将 Linux 的 `ls` 命令从 ASCII 转换为 base64。'
- en: '**Table 10-1:** The Conversion of ASCII to base64'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**表 10-1：** ASCII 转换为 base64'
- en: '| ASCII | l | s |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| ASCII | l | s |'
- en: '| --- | --- | --- |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Binary | 0 | 1 | 1 | 0 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 二进制 | 0 | 1 | 1 | 0 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 |'
- en: '| Decimal (0-64) | 27 | 7 | 12 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 十进制（0-64） | 27 | 7 | 12 |'
- en: '| Base64 | b | H | M |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| Base64 | b | H | M |'
- en: 'The last section has only four bits, so the remaining two bits are assumed
    to be 0, and the padding character (`=`) is added to the end. Here is the base64encoded
    result: `bHM=`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分只有四个比特，因此剩下的两个比特假定为 0，并在末尾添加填充字符（`=`）。以下是 base64 编码后的结果：`bHM=`.
- en: 'Can we execute this base64-encoded value? Yes, if we decode it and pass it
    to the shell before we run the program:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行这个 base64 编码后的值吗？是的，如果我们解码它并在运行程序之前将其传递给 shell：
- en: '[PRE41]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This command passes the base64-encoded string to the base64 decoder (`-d`),
    which converts the string back to ASCII encoding before piping (|) it to the shell
    (`sh`) to be executed. [Figure 10-7](ch10.xhtml#ch10fig7) shows an overview of
    this encoding and decoding pipeline.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将 base64 编码后的字符串传递给 base64 解码器（`-d`），解码器会将字符串转换回 ASCII 编码，然后通过管道（|）传递给 shell（`sh`）执行。[图
    10-7](ch10.xhtml#ch10fig7) 显示了该编码和解码流程的概述。
- en: '![image](../images/ch10fig07.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch10fig07.jpg)'
- en: '*Figure 10-7: The encoding and decoding pipeline*'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-7：编码和解码流程*'
- en: A Bash script containing the `ls` command will have a different signature from
    a file containing base64-encoded values of the `base64 -d <<< bHM= | sh` command,
    even though they are functionally equivalent. This is because both files are stored
    using ASCII encoding. Because the signatures are different, an antivirus program
    may fail to detect the malicious file containing the base64 values, as described
    in [Figure 10-8](ch10.xhtml#ch10fig8).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含 `ls` 命令的 Bash 脚本将与一个包含 `base64 -d <<< bHM= | sh` 命令的 base64 编码值的文件具有不同的签名，即使它们在功能上是等效的。这是因为两个文件都是使用
    ASCII 编码存储的。由于签名不同，防病毒程序可能无法检测到包含 base64 值的恶意文件，如 [图 10-8](ch10.xhtml#ch10fig8)
    中所描述。
- en: '![image](../images/ch10fig08.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch10fig08.jpg)'
- en: '*Figure 10-8: The binary signature of two functionally equivalent files can
    differ.*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-8：两个功能上等效的文件的二进制签名可能不同。*'
- en: However, there is a weakness to this technique. Once the signature detection
    algorithm captures an encoded implant with the new signature, it will be able
    to detect all future instances of the encoded implants because the base64 encoding
    never changes. In the Shikata Ga Nai Encoder section of this chapter, we’ll explore
    how to create a polymorphic encoder that generates a new signature each time it
    runs.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种技术存在一个弱点。一旦签名检测算法捕获到一个带有新签名的编码植入物，它将能够检测到所有未来的编码植入物实例，因为 base64 编码从不改变。在本章的
    Shikata Ga Nai 编码器部分，我们将探讨如何创建一个多态编码器，每次运行时都生成一个新的签名。
- en: For now, let’s complete the discussion of the base64 encoder by writing an implant
    and then, as an exercise, we’ll create a Metasploit module to encode it. Create
    a new file in the *Malware* folder called *implant.sh* and copy in the code snippet
    that follows. The script will use telnet to establish two connections. It will
    receive commands from the first connection on port 80 and upload the results using
    the second connection on port 443.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过编写一个植入物来完成对 base64 编码器的讨论，作为练习，我们将创建一个 Metasploit 模块来编码它。在 *Malware*
    文件夹中创建一个新文件，命名为 *implant.sh*，并复制以下代码片段。该脚本将使用 telnet 建立两个连接。它将从第一个连接的 80 端口接收命令，并通过第二个连接的
    443 端口上传结果。
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Use the netcat (`nc`) utility to create two TCP servers in separate terminals:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 netcat（`nc`）工具在不同的终端中创建两个 TCP 服务器：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***Writing a Metasploit Module***'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写一个 Metasploit 模块***'
- en: Let’s write a Metasploit module that will base64 encode the implant. Metasploit
    modules are written in the Ruby program language. Don’t worry. Ruby looks a lot
    like Python, so you’ll pick it up easily. Also, the Metasploit Framework is open
    source, and you can view the *cmd/powershell_base64* encoder by visiting *[https://github.com/rapid7/metasploit-framework/blob/master/modules/encoders/cmd/powershell_base64.rb](https://github.com/rapid7/metasploit-framework/blob/master/modules/encoders/cmd/powershell_base64.rb)*.
    This encoder is used to encode PowerShell scripts for Windows machines.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个 Metasploit 模块，用于对植入物进行 base64 编码。Metasploit 模块是用 Ruby 编程语言编写的。别担心，Ruby
    看起来很像 Python，所以你很容易上手。而且，Metasploit 框架是开源的，你可以通过访问 *[https://github.com/rapid7/metasploit-framework/blob/master/modules/encoders/cmd/powershell_base64.rb](https://github.com/rapid7/metasploit-framework/blob/master/modules/encoders/cmd/powershell_base64.rb)*
    来查看 *cmd/powershell_base64* 编码器。这个编码器用于对 Windows 机器的 PowerShell 脚本进行编码。
- en: 'Take some time to look at the *powershell_base64* encoder before we begin to
    write our own version that encodes Bash scripts for Linux machines. Create a new
    folder in your *Malware* folder called *Encoders* and then create a new file called
    *bash_base64.rb* inside the *Encoders* folder. We’ll implement our base64 encoder
    in this file, so copy in the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写自己的版本以对 Linux 机器的 Bash 脚本进行编码之前，花点时间查看 *powershell_base64* 编码器。在你的 *Malware*
    文件夹中创建一个名为 *Encoders* 的新文件夹，然后在 *Encoders* 文件夹中创建一个名为 *bash_base64.rb* 的新文件。我们将在这个文件中实现我们的
    base64 编码器，因此请复制以下内容：
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We inherit (`::`) from the encoder superclass and then specify the rank, or
    quality, of the module ➊. Modules range in quality from Manual to Excellent, depending
    on the reliability and amount of human intervention needed. We use the `super`
    ➋ keyword to call the superclass’s constructor and provide information on our
    module. After our module has initialized, the Metasploit Framework will split
    the input into blocks and call the `encode_block()` function ➌ on each block.
    We convert the values to ASCII Unicode before base64 encoding them.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从编码器超类继承（`::`），然后指定模块的排名或质量 ➊。模块的质量从手动到优秀不等，具体取决于可靠性和所需的人为干预量。我们使用 `super`
    ➋ 关键字来调用超类的构造函数，并提供有关我们模块的信息。在模块初始化之后，Metasploit 框架会将输入分成块，并对每个块调用 `encode_block()`
    函数 ➌。我们在进行 base64 编码之前，将值转换为 ASCII Unicode。
- en: To test your new encoder, add it to the Metasploit Framework by copying it into
    the *encoders* folder, which you can find by opening your file explorer and navigating
    to */usr/share/metasploit-framework/modules/encoders*. Create a new folder called
    *bash* and save your *bash_base64.rb* encoder file here.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的新编码器，将它添加到 Metasploit 框架中，方法是将其复制到 *encoders* 文件夹中。你可以通过打开文件资源管理器并导航到 */usr/share/metasploit-framework/modules/encoders*
    来找到该文件夹。在这里创建一个名为 *bash* 的新文件夹，并将你的 *bash_base64.rb* 编码器文件保存在其中。
- en: 'Open a new terminal and run the `show encoder` command in the `msfconsole`
    to ensure that your module was added correctly:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的终端，并在 `msfconsole` 中运行 `show encoder` 命令，以确保你的模块已正确添加：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If your module is present, use `msfvenom` and your module to encode your implant.
    Run the following command to create your encoded implant and save it as *implantEncoded*:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的模块存在，使用 `msfvenom` 和你的模块对植入物进行编码。运行以下命令来创建你的编码植入物并将其保存为 *implantEncoded*：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Test your encoded implant by making it executable and running it:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使编码后的植入物可执行并运行它来测试：
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Great, you’ve written a simple base64 encoder. However, it has some limitations.
    In addition to the fact that it will always produce the same signature, it can’t
    encode compiled binaries. As an ethical hacker, you’ll often load binary versions
    of the tools you create onto target machines. If you want to avoid detection,
    it’s a good idea to encode these binaries themselves. The Shikata Ga Nai encoder
    allows you to encode binaries.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，你已经编写了一个简单的 base64 编码器。然而，它存在一些限制。除了总是产生相同的签名外，它还无法编码已编译的二进制文件。作为一名道德黑客，你经常会将你创建的工具的二进制版本加载到目标机器上。如果你想避免被检测到，编码这些二进制文件本身是一个好主意。Shikata
    Ga Nai 编码器允许你对二进制文件进行编码。
- en: '***Shikata Ga Nai Encoder***'
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Shikata Ga Nai 编码器***'
- en: The *Shikata Ga Nai (SGN) encoder* encodes payloads by XOR-ing the bytes in
    the payload with a randomly selected number called an *initialization vector*.
    The strategy is similar to the one-time pad encryption algorithm discussed in
    [Chapter 5](ch05.xhtml#ch5). However, the SGN encoder includes the initialization
    vector and decoder code as part of the payload, so it loads the initialization
    vector and then starts the decoder when the payload runs. The decoder loops through
    the memory addresses associated with the encoded part of the payload and decodes
    an instruction by XOR-ing it with the initialization vector at each iteration
    of the loop. The decoder then replaces the encoded instruction with the decoded
    instruction in memory.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*Shikata Ga Nai (SGN) 编码器*通过将有效载荷中的字节与一个随机选择的数字（称为*初始化向量*）进行异或操作来对有效载荷进行编码。这一策略类似于[第
    5 章](ch05.xhtml#ch5)讨论的一次性密码本加密算法。然而，SGN 编码器将初始化向量和解码器代码作为有效载荷的一部分，因此它在有效载荷运行时加载初始化向量，然后启动解码器。解码器循环遍历与编码部分有效载荷相关的内存地址，并通过在每次迭代中将其与初始化向量异或来解码指令。然后，解码器在内存中用解码后的指令替换编码指令。'
- en: Once all instructions have been decoded and replaced, the decoding loop ends
    and the CPU executes the decoded region. Because the decoder is usually partially
    encoded, it’s difficult for an antivirus program’s signature detection algorithm
    to identify the payload based solely on the decoder’s signature.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有指令都被解码并替换，解码循环结束，CPU 执行解码后的区域。由于解码器通常是部分编码的，因此仅凭解码器的签名，病毒扫描程序的签名检测算法很难识别有效载荷。
- en: The SGN encoder can make the reverse engineering process more difficult by calculating
    a new initialization vector for each instruction. For example, it can add the
    newly decoded bytes to the previous initialization vector, as shown in [Figure
    10-9](ch10.xhtml#ch10fig9).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: SGN 编码器可以通过为每条指令计算一个新的初始化向量，使逆向工程过程变得更加困难。例如，它可以将新解码的字节添加到先前的初始化向量中，如[图 10-9](ch10.xhtml#ch10fig9)所示。
- en: '![image](../images/ch10fig09.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch10fig09.jpg)'
- en: '*Figure 10-9: The process of encoding bytes with the SGN encoder*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10-9：使用 SGN 编码器编码字节的过程*'
- en: The SGN encoder further complicates the reverse engineering process by using
    additional arithmetic (addition and subtraction) to compute the initialization
    vector.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: SGN 编码器通过使用额外的算术运算（加法和减法）来计算初始化向量，从而进一步复杂化了逆向工程过程。
- en: 'The SGN encoder is often referred to as a *polymorphic encoder*. A polymorphic
    encoder will generate a new signature each time it runs, as long as a hacker selects
    a new initialization vector and runs the encoder for multiple iterations. The
    following command generates an SGN-encoded payload; remember to replace `<Kali-IP>`
    with the IP address of your Kali Linux machine:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: SGN 编码器通常被称为*多态编码器*。多态编码器每次运行时都会生成一个新的签名，只要黑客选择一个新的初始化向量，并运行编码器多个迭代。以下命令生成一个
    SGN 编码的有效载荷；记得将 `<Kali-IP>` 替换为你 Kali Linux 机器的 IP 地址：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We’ve used the `--encoder` option to specify the SGN encoder ➊.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 `--encoder` 选项指定了 SGN 编码器 ➊。
- en: '**Creating a Windows Trojan**'
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建一个 Windows 木马**'
- en: 'So far, we’ve discussed how to create a trojan for Linux. The process of creating
    a Windows trojan is similar, as you can do it with `msfvenom`, too. We’ll cover
    two methods of hiding your implant: in a fun, open source implementation of the
    game Minesweeper by Humaeed Ahmed, and in a document using the Social Engineering
    Toolkit (more on this in a moment).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了如何为 Linux 创建一个木马。创建 Windows 木马的过程类似，你也可以使用 `msfvenom` 来实现。我们将介绍两种隐藏植入的方法：通过
    Humaeed Ahmed 的 Minesweeper 游戏的一个有趣的开源实现，以及通过使用社会工程工具包（稍后将详细讲解）。
- en: '***Hiding the Trojan in Minesweeper***'
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***在扫雷游戏中隐藏木马***'
- en: 'I’ve forked Ahmed’s repository, and you can download a copy of the executable
    from the following link: *[https://github.com/The-Ethical-Hacking-Book/Minesweeper/blob/master/Minesweeper/bin/Debug/Minesweeper.exe](https://github.com/The-Ethical-Hacking-Book/Minesweeper/blob/master/Minesweeper/bin/Debug/Minesweeper.exe)*.
    Save it to your *Malware* folder on your Kali desktop.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经分叉了 Ahmed 的库，你可以通过以下链接下载可执行文件：[https://github.com/The-Ethical-Hacking-Book/Minesweeper/blob/master/Minesweeper/bin/Debug/Minesweeper.exe](https://github.com/The-Ethical-Hacking-Book/Minesweeper/blob/master/Minesweeper/bin/Debug/Minesweeper.exe)*。将其保存到你
    Kali 桌面上的*恶意软件*文件夹中。
- en: '**NOTE**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Do you trust this executable? Now you’re thinking like a hacker. The repository
    also contains the source code needed to build it yourself if you don’t trust me.*'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*你信任这个可执行文件吗？现在你开始像黑客一样思考了。这个库还包含了需要自己构建的源代码，如果你不信任我，可以自己构建。*'
- en: 'After you’ve downloaded the executable, use `msfvenom` to transform it into
    a malicious trojan by running the following command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下载了可执行文件后，使用 `msfvenom` 通过运行以下命令将其转换为恶意 Trojan：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, the `-e` flag specifies that we’ll use the SGN encoder we just discussed.
    Many of these options are the same as when we first ran `msfvenom`, with the exception
    of the `-k` flag, which tells `msfvenom` to keep regular execution of the program
    and run the payload in a separate thread. You don’t need to memorize these options;
    you can view their documentation by running `msfvenom` with the `**--help**` option:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`-e` 标志指定我们将使用之前讨论过的 SGN 编码器。许多选项与我们第一次运行 `msfvenom` 时相同，唯一的例外是 `-k` 标志，它告诉
    `msfvenom` 保持程序的常规执行，并在一个单独的线程中运行有效载荷。你不需要记住这些选项；你可以通过运行 `msfvenom` 并加上 `**--help**`
    选项来查看它们的文档：
- en: '[PRE50]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***Hiding the Trojan in a Word Document (or Another Innocent File)***'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***将 Trojan 隐藏在 Word 文档（或其他无害文件）中***'
- en: 'There’s a problem: Windows users rarely install new programs, and they’re incredibly
    suspicious of programs they’re asked to install via email. However, users open
    Word documents, PowerPoint presentations, and PDF files almost daily. You could
    embed implants in these files, too. The *Social Engineering Toolkit (SET)* abstracts
    the Metasploit Framework’s details and makes it easy to send and generate this
    kind of infected media. Run the following command to start SET:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个问题：Windows 用户很少安装新程序，他们对通过电子邮件要求安装的程序极度怀疑。然而，用户几乎每天都会打开 Word 文档、PowerPoint
    演示文稿和 PDF 文件。你也可以将植入物嵌入这些文件中。*社会工程工具包（SET）* 抽象化了 Metasploit Framework 的细节，并使发送和生成这种感染媒体变得更加容易。运行以下命令启动
    SET：
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After the toolkit starts, you should see the following menu. Select the **Social-Engineering
    Attacks** option by entering `**1**` in the terminal:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 启动工具包后，你应该会看到以下菜单。通过在终端中输入 `**1**` 来选择 **社会工程攻击** 选项：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, select the **Infectious Media Generator** option:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，选择 **感染媒体生成器** 选项：
- en: '[PRE53]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, select the **File-Format Exploits** option. This will let you embed implants
    in different kinds of files:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，选择 **文件格式漏洞** 选项。这将允许你在不同类型的文件中嵌入植入物：
- en: '[PRE54]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Enter the IP address of the attacker server; in this case, your Kali Linux
    machine. Once you’ve done so, you should see a list of the available infection
    media attacks. This list of file formats will change as companies patch vulnerabilities
    and attackers discover new ones. Many of these attacks work only on a specific
    software version, so use the information you collected during your OSINT operations
    to carefully select one that your target uses:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 输入攻击者服务器的 IP 地址；在这个例子中，是你的 Kali Linux 机器。一旦完成，你应该能看到可用感染媒体攻击的列表。随着公司修补漏洞和攻击者发现新漏洞，这个文件格式列表会发生变化。许多攻击只在特定的软件版本上有效，因此请使用你在
    OSINT 操作中收集的信息，仔细选择目标所使用的攻击方法：
- en: '[PRE55]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Microsoft Office documents, like Word, Excel, and PowerPoint files, support
    *macros*, which are small programs that users can write to automate tasks in Office
    documents. Macros run when you open a document; however, Microsoft Office disables
    macros by default because they are a security risk. Whenever a document contains
    a macro, Microsoft Office will display a banner that allows the user to enable
    macros. An attacker could embed a malicious macro into a document that downloads
    and executes a shell when a user opens it. In 2021, a state-sponsored attacker
    used a malicious Word document to break into a Russian defense contractor. You
    can read about this attack by the Lazarus group on the Kaspersky website.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 微软 Office 文档，如 Word、Excel 和 PowerPoint 文件，支持 *宏*，这是用户可以编写的小程序，用于自动化 Office 文档中的任务。宏会在你打开文档时运行；然而，由于宏存在安全风险，微软
    Office 默认禁用宏。每当文档包含宏时，微软 Office 会显示一个横幅，允许用户启用宏。攻击者可以将恶意宏嵌入文档中，当用户打开文档时，宏会下载并执行一个
    shell。在 2021 年，一名国家支持的攻击者利用一个恶意的 Word 文档入侵了一个俄罗斯国防承包商。你可以在卡巴斯基网站上阅读 Lazarus 组织对该攻击的详细介绍。
- en: Now that we’ve examined techniques for creating trojans for desktops and servers,
    let’s create trojans for mobile and embedded devices.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经研究了为桌面和服务器创建 Trojan 的技术，接下来让我们为移动和嵌入式设备创建 Trojan。
- en: '**Creating an Android Trojan**'
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**创建 Android Trojan**'
- en: The process of creating trojans for Android devices is almost identical to that
    of creating Linux trojans. The directory structure might differ, but as you did
    earlier in this chapter, you’ll modify an installation package to install your
    implant.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Android 设备创建 Trojan 的过程几乎与为 Linux 设备创建 Trojan 的过程相同。目录结构可能有所不同，但正如你在本章中之前所做的，你将修改一个安装包来安装你的植入物。
- en: 'The Android installation package is called an *Android Package (APK)* file.
    This file contains everything the Android operating system needs to install a
    new app. Let’s begin by using `msfvenom` to generate a malicious APK. Create a
    new Desktop folder called *AndroidTrojan* and then navigate to it:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Android 安装包称为*Android 包（APK）*文件。该文件包含 Android 操作系统安装新应用所需的所有内容。首先，我们将使用`msfvenom`生成一个恶意
    APK。创建一个名为*AndroidTrojan*的新桌面文件夹，并导航到该文件夹：
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, generate a new malicious APK that contains a reverse shell implant:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，生成一个包含反向 shell 植入的恶意 APK：
- en: '[PRE57]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This command generates a new Android APK with malicious code embedded within
    it. In the next section, we’ll disassemble this application and discuss its structure
    so that you can create your own Android trojan.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令生成一个新的 Android APK，并将恶意代码嵌入其中。在接下来的章节中，我们将反汇编这个应用并讨论它的结构，以便你能够创建自己的 Android
    木马。
- en: '***Deconstructing the APK to View the Implant***'
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***反构 APK 以查看植入代码***'
- en: 'The command in the preceding example did all the work for you. To understand
    how it hid the implant, let’s decompile the *malicious.apk* install file and explore
    its directory structure. We’ll use `apktool`, a reverse engineering tool, to decompile
    the APK. Run the following command to download and install `apktool`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的命令为你完成了所有工作。为了理解它是如何隐藏植入代码的，让我们反编译*malicious.apk*安装文件并探索它的目录结构。我们将使用`apktool`这个逆向工程工具来反编译
    APK。运行以下命令来下载并安装`apktool`：
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To decompile (`d`) the file, run the following command:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要反编译（`d`）该文件，运行以下命令：
- en: '[PRE59]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The tool will create a folder called *malicious* that contains the decompiled
    files. Navigate to this folder and list all the files and folders in the directory
    using the following commands:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具将创建一个名为*malicious*的文件夹，其中包含反编译后的文件。导航到该文件夹，并使用以下命令列出目录中的所有文件和文件夹：
- en: '[PRE60]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You should see the following files and folders: *AndroidManifest.xml*, *apktool.yml*,
    *original*, *res*, and *smali*. The *AndroidManifest.xml* file describes your
    app. The following is a snippet from it:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下文件和文件夹：*AndroidManifest.xml*、*apktool.yml*、*original*、*res* 和 *smali*。*AndroidManifest.xml*文件描述了你的应用。下面是其中的一个片段：
- en: '[PRE61]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This file includes your app’s permissions, like camera access or access to your
    call log ➊. It also contains information about your app’s entry point ➋, which
    is the first file your app runs when it starts.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含你的应用权限，如访问摄像头或访问通话记录➊。它还包含有关应用入口点➋的信息，这是应用启动时运行的第一个文件。
- en: The *apktool.yml* file contains information on the APK, including its version
    number and type of compression. The *original* folder contains a compiled version
    of *AndroidManifest.xml*, a file containing its hash, and files containing information
    on the signatures. (These signatures are similar to the ones we discussed in [Chapter
    6](ch06.xhtml#ch6). I’ll discuss these in more detail in the next subsection.)
    The *res* folder contains the application’s resources, such as images or strings.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*apktool.yml*文件包含有关 APK 的信息，包括其版本号和压缩类型。*original*文件夹包含已编译的*AndroidManifest.xml*文件、包含哈希值的文件以及包含签名信息的文件。（这些签名与我们在[第6章](ch06.xhtml#ch6)中讨论的类似。我将在下一个子节中更详细地讨论这些内容。）*res*文件夹包含应用程序的资源，例如图像或字符串。'
- en: 'Lastly, the *smali* folder contains assembly files associated with the app.
    It is also where we have put the implant. You can view the assembly files associated
    with the Metasploit implant by running `ls` on the *smali/com/ metasploit/stage/*
    directory:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*smali*文件夹包含与应用相关的汇编文件。这也是我们放置植入代码的地方。你可以通过在*smali/com/metasploit/stage/*目录中运行`ls`来查看与
    Metasploit 植入相关的汇编文件：
- en: '[PRE62]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If you’ve spent time working with mobile apps, you might have expected to see
    a *.dex* file. These files contain the byte code that the Android Runtime (ART)
    executes. The reason there isn’t one is that *smali* is the assembly representation
    and *.dex* is the machine representation of the app’s code. The *Payload.smali*
    file contains the code associated with our malicious implant, and we’ll transfer
    this file into another APK to create a trojan later.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾花时间处理移动应用，你可能会期待看到一个*.dex*文件。这些文件包含 Android Runtime（ART）执行的字节码。没有该文件的原因是*smali*是应用代码的汇编表示，而*.dex*是机器表示。*Payload.smali*文件包含与我们恶意植入相关的代码，我们稍后会将该文件转移到另一个
    APK 中以创建木马。
- en: 'For now, let’s inspect the *MainActivity.smali* file:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查一下*MainActivity.smali*文件：
- en: '[PRE63]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The malicious APK starts `MainService` ➊, a malicious Android service written
    by the developers of the Metasploit Framework. This service will eventually load
    the payload in the background. If you wanted to start the malicious payload activity
    immediately, you could add the following snippet at ➋ in the preceding example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意APK启动`MainService` ➊，这是一个由Metasploit Framework的开发者编写的恶意Android服务。该服务最终会在后台加载有效载荷。如果你希望立即启动恶意有效载荷活动，可以在前面的示例中在➋位置添加以下代码片段：
- en: '[PRE64]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Similarly, you can create your own trojan by decompiling an existing APK, copying
    the *Metasploit* folder to the *smali* folder, and then adding the preceding snippet
    to *MainActivity.smali* to start the payload.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以通过反编译现有的APK，复制*Metasploit*文件夹到*smali*文件夹，然后将前面的代码片段添加到*MainActivity.smali*中以启动有效载荷，从而创建自己的特洛伊木马。
- en: '***Rebuilding and Signing the APK***'
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***重新构建并签署APK***'
- en: 'Now that we’ve inspected the file, we can rebuild it by running the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了文件，可以通过运行以下命令重新构建它：
- en: '[PRE65]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: All Android apps must be signed before they can be run on an Android device.
    You can do this with the *Java Keystore*, which stores and protects key material
    such as the public and private keys used for signing. Key material never leaves
    the Keystore. Instead, an application sends the Keystore its data, and the Keystore
    uses the protected key material to sign or encrypt data and returns the results,
    as illustrated in [Figure 10-10](ch10.xhtml#ch10fig10). Some systems even store
    key material in a separate piece of secure hardware called a trusted execution
    environment.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Android应用程序必须在运行在Android设备上之前进行签名。你可以使用*Java Keystore*来完成这项工作，它存储并保护用于签名的公钥和私钥等密钥材料。密钥材料永远不会离开Keystore。相反，应用程序将数据发送到Keystore，Keystore使用受保护的密钥材料进行签名或加密数据，并返回结果，如[图10-10](ch10.xhtml#ch10fig10)所示。一些系统甚至将密钥材料存储在一个称为受信执行环境的单独安全硬件中。
- en: '![image](../images/ch10fig10.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch10fig10.jpg)'
- en: '*Figure 10-10: Key material never leaves the Keystore.*'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-10：密钥材料永远不会离开Keystore。*'
- en: 'Run the following command to install the Java Development Kit (JDK), which
    contains the tools we’ll use to sign the trojan APK:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令安装Java开发工具包（JDK），该工具包包含我们将用于签署特洛伊木马APK的工具：
- en: '[PRE66]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Generate the RSA key we’ll use to sign the trojan by using this command:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令生成我们将用于签署特洛伊木马的RSA密钥：
- en: '[PRE67]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We use Java’s `keytool` utility to generate a new key (`-genkey`). Instead of
    displaying the key pair, we store them in a Keystore file (`-keystore`) called
    `my-malicious.keystore`. The Keystore can store multiple entries, each of which
    is identified by an alias (`-alias`). Our entry is called `alias_name_malicious`.
    The next option specifies the cryptographic key algorithm (`-keyalg`). Here, we
    select `RSA` and set the key size (`-keysize`) to be `3072`. We also set the key
    to be valid (`-validity`) for 10,000 days.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Java的`keytool`工具生成一个新的密钥（`-genkey`）。我们将密钥对存储在名为`my-malicious.keystore`的Keystore文件中，而不是显示密钥对。Keystore可以存储多个条目，每个条目都由别名（`-alias`）标识。我们的条目被称为`alias_name_malicious`。下一个选项指定加密密钥算法（`-keyalg`）。在这里，我们选择`RSA`并将密钥大小（`-keysize`）设置为`3072`。我们还将密钥的有效期（`-validity`）设置为10,000天。
- en: 'Now use Java’s `jarsigner` utility to sign the APK file:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用Java的`jarsigner`工具签署APK文件：
- en: '[PRE68]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: First, we select the signature algorithm, using SHA2 with RSA (`-sigalg SHA2withRSA)`.
    Then we use SHA2 as our hash/digest function (`-digestalg SHA2`). Lastly, we specify
    the Keystore (`-keystore`) and the key alias. In this case, we’ll use the Keystore
    we just created (`my-malicious.keystore`) and the entry with the alias (`alias_name_malicious`).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们选择签名算法，使用SHA2和RSA（`-sigalg SHA2withRSA`）。然后，我们使用SHA2作为哈希/摘要函数（`-digestalg
    SHA2`）。最后，我们指定Keystore（`-keystore`）和密钥别名。在这种情况下，我们将使用刚刚创建的Keystore（`my-malicious.keystore`）和带有别名（`alias_name_malicious`）的条目。
- en: '***Testing the Android Trojan***'
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***测试Android特洛伊木马***'
- en: Now let’s see our malicious APK in action. We don’t want the malicious program
    on our phones, so let’s create a new virtual machine that emulates an Android
    phone. Google has developed an emulator that is bundled with Android Studio, its
    Android development environment. Follow the instructions at *[https://developer.android.com/studio/install/](https://developer.android.com/studio/install/)*
    to download Android Studio on your host system, outside of your current virtual
    lab environment.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们的恶意APK是如何运作的。我们不希望恶意程序出现在我们的手机上，因此让我们创建一个新的虚拟机来模拟Android手机。Google开发了一个模拟器，它与Android
    Studio捆绑在一起，后者是其Android开发环境。按照* [https://developer.android.com/studio/install/](https://developer.android.com/studio/install/)*上的说明，在主机系统中下载Android
    Studio，外部于当前的虚拟实验室环境。
- en: After you’ve installed Android Studio, create an empty project by clicking the
    **Start New Android Studio project** and following the instructions presented.
    As rule of thumb, select the default options. Once you’ve created your project,
    create a new Android virtual device by selecting **Tools** ▶ **AVD Manager** or
    by clicking the Android Virtual Device Manager icon ➊, as shown in [Figure 10-11](ch10.xhtml#ch10fig11).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完Android Studio后，通过点击**开始新的Android Studio项目**并按照指示操作来创建一个空项目。作为经验法则，选择默认选项。创建项目后，通过选择**工具**
    ▶ **AVD管理器**或点击Android虚拟设备管理器图标➊来创建一个新的Android虚拟设备，如[图10-11](ch10.xhtml#ch10fig11)所示。
- en: '![image](../images/ch10fig11.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch10fig11.jpg)'
- en: '*Figure 10-11: The Android Virtual Device manager*'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-11：Android虚拟设备管理器*'
- en: Create a new virtual device ➋ with the specifications of the device you’re targeting.
    Then click the play button ➌ to start it. It will take some time to start the
    virtual machine. When it’s started, you should see an emulated device.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的虚拟设备➋，其规格与您目标设备相匹配。然后点击播放按钮➌以启动它。启动虚拟机需要一些时间。当虚拟机启动后，您应该看到一个仿真设备。
- en: Your Kali Linux virtual machine can’t interact with your Android emulator because
    the emulator runs outside your virtual lab environment. Change the Kali connection
    settings in VirtualBox to **Bridged Adapter** so that it connects to the same
    local network as your Android emulator ([Figure 10-12](ch10.xhtml#ch10fig12)).
    See [Chapter 1](ch01.xhtml#ch1) for instructions on changing the Kali Linux network
    configuration, and remember to restore the previous settings after you complete
    this exercise.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 由于仿真器在虚拟实验环境外运行，您的Kali Linux虚拟机无法与Android仿真器进行交互。将VirtualBox中的Kali连接设置更改为**桥接适配器**，使其与Android仿真器连接到同一局域网([图10-12](ch10.xhtml#ch10fig12))。有关更改Kali
    Linux网络配置的说明，请参见[第1章](ch01.xhtml#ch1)，并在完成本练习后记得恢复之前的设置。
- en: '![image](../images/ch10fig12.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch10fig12.jpg)'
- en: '*Figure 10-12: Setting the Kali Linux virtual machine to Bridged Adapter*'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-12：将Kali Linux虚拟机设置为桥接适配器*'
- en: 'Run the `**ifconfig**` command to get the new IP address of the Kali Linux
    machine:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`**ifconfig**`命令以获取Kali Linux机器的新IP地址：
- en: '[PRE69]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Next, start a web server in the folder containing your signed malicious APK:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在包含已签名恶意APK的文件夹中启动Web服务器：
- en: '[PRE70]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This is the web server that we’ll use to serve our malicious APK file. Now
    start the attacker server in a new terminal:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将用来提供恶意APK文件的Web服务器。现在，在一个新的终端中启动攻击者服务器：
- en: '[PRE71]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Open your emulated device, navigate to the web server running on the Kali Linux
    machine, and download the trojan, as shown in [Figure 10-13](ch10.xhtml#ch10fig13).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的仿真设备，导航到运行在Kali Linux机器上的Web服务器，并下载木马，如[图10-13](ch10.xhtml#ch10fig13)所示。
- en: '![image](../images/ch10fig13.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch10fig13.jpg)'
- en: '*Figure 10-13: Downloading the trojan on Android*'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-13：在Android上下载木马*'
- en: Ignore the warnings following the instructions and allow the installation of
    third-party apps.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略指令中的警告，并允许安装第三方应用。
- en: 'At this point, you should have successfully installed and connected to your
    implant. You should see the following Meterpreter shell. Try typing `geolocate`
    to get the phone location. (Remember, the phone is running in a virtual machine
    and doesn’t have access to GPS, so this location will be simulated.) Also run
    the `help` command to see all of your options. Meterpreter isn’t perfect, so some
    options might not work:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该已经成功安装并连接到您的植入设备。您应该会看到以下的Meterpreter Shell。尝试输入`geolocate`命令来获取手机位置。（记住，手机运行在虚拟机中并且无法访问GPS，因此这个位置将被模拟。）还可以运行`help`命令查看所有可用选项。Meterpreter并不完美，因此有些选项可能无法正常工作：
- en: '[PRE72]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: An attacker could encourage a user to download the malicious APK by sending
    them a phishing email or text message linking to a cloned version of the Google
    Play Store website (see [Chapter 7](ch07.xhtml#ch7) for information on cloning
    web pages). Alternatively, a hacker could use a QR code. You see QR codes all
    over the place; for example, at conferences and in parks. A hacker could easily
    make the QR code link to a fake website that contains a malicious trojan. [Figure
    10-14](ch10.xhtml#ch10fig14) shows an example QR code that links to the No Starch
    Press website. You can scan it by opening your phone’s camera app and pointing
    at the QR code.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击者可能会通过发送钓鱼电子邮件或短信，诱使用户下载恶意APK，链接到一个克隆版的Google Play商店网站（有关网页克隆的信息，请参见[第7章](ch07.xhtml#ch7)）。或者，黑客也可能使用二维码。你会在各处看到二维码；例如，在会议和公园里。黑客可以轻松制作二维码，链接到一个包含恶意木马的假网站。[图10-14](ch10.xhtml#ch10fig14)展示了一个二维码示例，指向No
    Starch Press网站。你可以通过打开手机的相机应用并对准二维码来扫描它。
- en: '![image](../images/ch10fig14.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/ch10fig14.jpg)'
- en: '*Figure 10-14: This QR code takes you to* [https://nostarch.com/catalog/security](https://nostarch.com/catalog/security)*.*'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '*图10-14：此二维码将带你到* [https://nostarch.com/catalog/security](https://nostarch.com/catalog/security)*。*'
- en: Some of the best mobile attacks exploit *zero-click vulnerabilities*. A zeroclick
    vulnerability allows an attacker to compromise a mobile device without any action
    on the user’s part. These are really rare and very valuable.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最好的移动攻击利用了*零点击漏洞*。零点击漏洞允许攻击者在用户不做任何操作的情况下攻破移动设备。这些漏洞非常罕见且极具价值。
- en: 'A final note on mobile devices: although iOS devices are generally considered
    more secure, they aren’t safe either. For example, a vulnerability in Facebook’s
    WhatsApp platform allowed hackers to install malware on an iPhone by sending WhatsApp
    users a link. A state hacker group later used this vulnerability to hack Amazon
    CEO Jeff Bezos’ iPhone.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 关于移动设备的最后说明：虽然iOS设备通常被认为更安全，但它们也并不完全安全。例如，Facebook的WhatsApp平台中的一个漏洞允许黑客通过发送链接给WhatsApp用户，从而在iPhone上安装恶意软件。后来，一个国家级黑客组织利用这个漏洞攻击了亚马逊CEO杰夫·贝佐斯的iPhone。
- en: '**Exercises**'
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**练习**'
- en: These exercises will bolster your understanding of trojans. You’ll begin by
    exploring a tool that automates the process of creating and signing Android trojans.
    In the second exercise, you’ll write an implant in Python. Your implant should
    stream video from the victim’s webcam and transmit it back to the attacker’s server.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习将增强你对木马的理解。你将首先探索一个自动化创建和签名Android木马的工具。在第二个练习中，你将用Python编写一个植入物。你的植入物应该从受害者的网络摄像头实时播放视频，并将其传输回攻击者的服务器。
- en: '***Evil-Droid***'
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Evil-Droid***'
- en: '*Evil-droid* is a Bash script that automates the APK implantation and signing
    process. You can download it from GitHub by running the following command:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*Evil-droid*是一个Bash脚本，用于自动化APK植入和签名过程。你可以通过运行以下命令从GitHub下载它：'
- en: '[PRE73]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Next, you’ll need to download the APK of the app you’d like to transform into
    a trojan. In this example, we’ll use the APK file of the Signal app, an encrypted
    messaging service that you can find at *[https://signal.org/android/apk/](https://signal.org/android/apk/)*.
    To choose any other APK available from the Google Play Store, use `gplaycli`,
    a free and open source utility that allows you to download APK files from the
    store. You can install it from *[https://github.com/matlink/gplaycli](https://github.com/matlink/gplaycli)*.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要下载你想要转换为木马的应用的APK文件。在这个例子中，我们将使用Signal应用的APK文件，这是一种加密消息服务，你可以在*[https://signal.org/android/apk/](https://signal.org/android/apk/)*找到它。要选择来自Google
    Play商店的其他APK，请使用`gplaycli`，这是一款免费的开源工具，允许你从商店下载APK文件。你可以从*[https://github.com/matlink/gplaycli](https://github.com/matlink/gplaycli)*安装它。
- en: 'After you’ve downloaded an APK file, navigate to the Bash script in the *Evil-Droid*
    folder and change the script’s permissions to make it executable:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 下载APK文件后，导航到*Evil-Droid*文件夹中的Bash脚本，并更改脚本的权限，使其可执行：
- en: '[PRE74]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Start the Evil-Droid script by running the following command:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令来启动Evil-Droid脚本：
- en: '[PRE75]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Once the Evil-Droid script has started, you should see the following:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Evil-Droid脚本启动，你应该会看到以下内容：
- en: '[PRE76]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Select **[3]** to inject the implant into the original APK. As you can see
    from the output, Evil-Droid has two options for injecting an implant: the old
    option and the new option. The new option provides additional features, such as
    signing the APK, which is required for apps running on modern Android platforms.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**[3]**将植入物注入到原始的APK中。从输出中可以看到，Evil-Droid提供了两种注入植入物的选项：旧选项和新选项。新选项提供了额外的功能，比如签名APK，这对于在现代Android平台上运行的应用程序是必需的。
- en: 'Evil-Droid is implemented by using a single open source Bash script. Here is
    a link to the script:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Evil-Droid是通过使用一个开源的Bash脚本实现的。以下是该脚本的链接：
- en: '[PRE77]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Once you’ve selected **[3]**, follow the instructions and prompts to create
    your trojan, providing it with the original APK you want to modify.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你选择了**[3]**，按照指示和提示创建你的木马，并提供你想要修改的原始APK。
- en: '***Writing Your Own Python Implant***'
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***编写你自己的Python植入物***'
- en: In this chapter, we used implants available through Metasploit. As an exercise,
    write your own implant that takes pictures with a victim’s camera.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了Metasploit提供的植入物。作为练习，编写你自己的植入物，使用受害者的摄像头拍照。
- en: Use the Python *OpenCV* library to capture and display the images from the webcam.
    You install this library with `pip3`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python的*OpenCV*库捕获并显示来自网络摄像头的图像。你可以通过`pip3`安装这个库。
- en: '[PRE78]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Copy the following into a new file called *implant.py*.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容复制到一个名为*implant.py*的新文件中。
- en: '[PRE79]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The script will take several pictures (frames) and stitch them together to create
    a video. First, we’ll select a video capture device ➊. A machine could have multiple
    cameras attached to it and the operating system assigns each camera to an interface.
    Here, we’ll choose the camera assigned to interface 0, which is the first interface.
    Next, we set the display window, which will show each frame. Showing each frame
    is excellent for debugging, but you wouldn’t display this in a stealthy trojan.
    As long as the window is open, we’ll capture/read new frames ➋. The variable `status`
    is a Boolean variable that indicates whether the frame was correctly captured.
    We’ll then pass each of these frames to the window to be displayed and printed
    to the console. Lastly, if the user presses the ESCAPE key, we’ll close the window
    and stop the process.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将拍摄几张图片（帧）并将它们拼接成一个视频。首先，我们将选择一个视频捕获设备➊。一个机器可能连接多个摄像头，操作系统将每个摄像头分配到一个接口。在这里，我们选择分配给接口0的摄像头，即第一个接口。接下来，我们设置显示窗口，该窗口将显示每一帧。显示每一帧非常适合调试，但在隐蔽木马中不应显示这个窗口。只要窗口打开，我们就会捕获/读取新的帧➋。变量`status`是一个布尔变量，用于指示帧是否正确捕获。然后，我们将每一帧传递到窗口显示并打印到控制台。最后，如果用户按下ESC键，我们将关闭窗口并停止进程。
- en: 'Test the program by opening a new terminal and navigating to the folder containing
    your *implant.py* file. On the top menu in Kali Linux, select **Devices** ▶ **Webcam**
    to attach your webcam to the virtual machine. Now run your implant:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打开一个新的终端并导航到包含*implant.py*文件的文件夹来测试程序。在Kali Linux的顶部菜单中，选择**设备** ▶ **网络摄像头**，将你的网络摄像头连接到虚拟机。现在运行你的植入物：
- en: '[PRE80]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Extend your implant’s functionality by allowing it to send frames to a hacker’s
    server over a TCP connection. After you’ve extended and tested it, you can make
    the implant more stealthy by removing the lines that display the feed to the victim.
    And remember that you want your implant to communicate securely. See [Chapter
    6](ch06.xhtml#ch6) for examples of how to establish a secure communication channel.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 通过允许植入物通过TCP连接向黑客的服务器发送帧，来扩展植入物的功能。在你扩展并测试后，你可以通过删除显示给受害者的画面来让植入物更加隐蔽。并且记住，你希望你的植入物能够安全地通信。请参见[第6章](ch06.xhtml#ch6)了解如何建立安全通信通道的示例。
- en: 'Extend your implant even further by allowing it to take screenshots. Install
    and use the *python-mss* library to do so. Here, I have provided example code
    that imports the library `mss` and takes a screenshot:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步扩展你的植入物，使其能够截取屏幕截图。安装并使用*python-mss*库来实现这一功能。这里，我提供了一个示例代码，导入了`mss`库并拍摄了一个屏幕截图：
- en: '[PRE81]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: You’ll also need to create and implement a basic protocol for controlling your
    implant. See [Chapter 4](ch04.xhtml#ch4) for examples of how to do so. As a final
    note, the *pynput* library is great for adding keylogger functionality. You’ll
    need to install it before using it.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要创建并实现一个基本协议，用于控制你的植入物。请参见[第4章](ch04.xhtml#ch4)了解如何操作的示例。最后，*pynput*库非常适合添加键盘记录功能。在使用之前，你需要先安装它。
- en: '***Obfuscate Your Implant***'
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***混淆你的植入物***'
- en: Now that you’ve developed an implant, let’s obfuscate it. Remember, obfuscation
    makes detection and reverse engineering more difficult. We’ll use the `pyarmor`
    tool to obfuscate the *implant.py* file. Details on the `pyarmor` obfuscation
    process can be found in its documentation at *[https://pyarmor.readthedocs.io/en/latest/how-to-do.html](https://pyarmor.readthedocs.io/en/latest/how-to-do.html)*.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经开发了一个implant，让我们对其进行加密。记住，加密可以使检测和逆向工程变得更加困难。我们将使用`pyarmor`工具来加密*implant.py*文件。有关`pyarmor`加密过程的详细信息，可以在其文档中找到，网址是*[https://pyarmor.readthedocs.io/en/latest/how-to-do.html](https://pyarmor.readthedocs.io/en/latest/how-to-do.html)*。
- en: 'Use `pip3` to install `pyarmor`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pip3`安装`pyarmor`：
- en: '[PRE82]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now obfuscate your implant by running the following command:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过运行以下命令来加密你的implant：
- en: '[PRE83]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'You can view the obfuscated script by navigating to the folder *dist*:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过导航到*dist*文件夹来查看加密后的脚本：
- en: '[PRE84]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: You also need all the files in the *dist* folder, including those in the *pytransform*
    folder. Run your newly obfuscated file by running *implant.py* in the *dist* folder.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要*dist*文件夹中的所有文件，包括*pytransform*文件夹中的文件。通过运行*dist*文件夹中的*implant.py*文件来运行你新加密的文件。
- en: '**NOTE**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Alternatively, you can use* `*pyminifier*` *to generate a minified version
    of the code.*'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '*或者，你可以使用*`*pyminifier*`*来生成代码的压缩版本。*'
- en: '***Build a Platform-Specific Executable***'
  id: totrans-323
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***构建平台特定的可执行文件***'
- en: 'To run the implant you just wrote, a computer must have Python installed. However,
    a hacker can’t assume that Python will be available on the victim’s machine. Instead,
    we need to convert the Python program into an executable using the `pyinstaller`
    utility, which you can install as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行你刚刚编写的implant，计算机必须安装Python。然而，黑客不能假设受害者的计算机上会有Python。相反，我们需要使用`pyinstaller`工具将Python程序转换为可执行文件，你可以按以下方式安装：
- en: '[PRE85]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'To create a Linux executable from the original, unobfuscated file, run the
    following command:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要从原始未加密的文件创建Linux可执行文件，请运行以下命令：
- en: '[PRE86]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'To create an obfuscated executable, run the following command on the original
    file:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个加密的可执行文件，请对原始文件运行以下命令：
- en: '[PRE87]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: You can embed the resulting Linux executable in a Trojan using the same techniques
    discussed earlier in the chapter. Now try generating a Windows executable (*.exe*)
    by running `pyinstaller` on a Windows machine. The commands are the same, and
    running them on a Windows device will generate a Windows executable.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用本章之前讨论的相同技术将生成的Linux可执行文件嵌入到木马中。现在尝试在Windows机器上运行`pyinstaller`生成一个Windows可执行文件（*.exe*）。命令是一样的，在Windows设备上运行它们将生成一个Windows可执行文件。
