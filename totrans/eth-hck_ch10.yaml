- en: '**10'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BUILDING TROJANS**
  prefs: []
  type: TYPE_NORMAL
- en: '*Things are not always what they seem; the first appearance deceives many;
    the intelligence of a few perceives what has been carefully hidden.*'
  prefs: []
  type: TYPE_NORMAL
- en: –Phaedrus
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Consider the following scenario: an attacker, pretending to be the head of
    IT, sends an email to an employee. The email tells the victim to download the
    updated version of the Alpine email client. But, unbeknownst to the victim, the
    attacker has embedded an implant in the program. When the victim installs the
    client, the installer will install the implant, too.'
  prefs: []
  type: TYPE_NORMAL
- en: All ethical hackers should understand the mechanisms of implants like these.
    Implants concealed within legitimate files are called *trojans*. I’ll begin by
    discussing the Drovorub malware implant developed by Russian military intelligence
    (GRU) and re-create its general design using Metasploit. The implant, which was
    designed for Linux systems, provides a great case study on modern malware.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to hide an implant in another file and obfuscate
    it to avoid detection using tools like `msfvenom`. You’ll also get some practice
    writing custom Metasploit modules by creating an encoder that can help your implant
    evade antivirus software.
  prefs: []
  type: TYPE_NORMAL
- en: After exploring implants for Linux and Windows systems, I’ll also show you how
    to generate malicious implants for Android devices that can listen to a phone’s
    microphone, take pictures with the phone’s camera, find the phones location, read
    and send text messages, and download the phone’s call log. In this chapter’s exercise,
    you’ll build an implant that can steal a victim’s password by logging their keystrokes
    and take their picture by accessing their camera.
  prefs: []
  type: TYPE_NORMAL
- en: '**Case Study: Re-Creating Drovorub by Using Metasploit**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In 2020, the NSA released a report analyzing Drovorub. This section discusses
    the architecture of this implant, shown in [Figure 10-1](ch10.xhtml#ch10fig1),
    and describes how you can build something similar using open source tools like
    Meterpreter.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch10fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-1: The architecture of the Drovorub implant described by the NSA
    report*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Drovorub consists of four key parts: the attacker’s server, the attacker’s
    agent, the malware client, and the malware kernel module. Once an attacker has
    compromised a victim’s machine, they install the malware client and malware kernel
    module. The kernel module helps the implant avoid detection by overriding the
    operating system’s malware detection functions. In a way, this is like pasting
    a picture of a room over a security camera. The malware client communicates with
    the attacker’s server, which manages connections from multiple machines and stores
    information on each connection in a central database, and allows the attacker
    to control the victim’s machine.'
  prefs: []
  type: TYPE_NORMAL
- en: You could construct something similar to the Drovorub implant using open source
    tools. We’ll do so here using the *Metasploit Framework*, an open source collection
    of software libraries, hacker tools, and exploit code. The ethical hacking community
    regularly contributes to Metasploit, so it’s a great tool to have in your ethical
    hacking toolbox.
  prefs: []
  type: TYPE_NORMAL
- en: '***Building the Attacker’s Server***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s begin by setting up the attacker’s server, also called the command and
    control server, which will accept connections from implants installed on victim
    devices. The Metasploit Framework allows you to host such a server on an independent
    machine, but we’ll host it directly on our Kali Linux virtual machine. Run the
    following command to get the machine’s IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Write down this address; you’ll need it later.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll need to start the PostgreSQL server, which comes preinstalled on
    Kali Linux. PostgreSQL is the database that will store implant connection metadata.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the server is running, let’s start `msfconsole`, which allows you
    to access the features of the Metasploit Framework. Metasploit should be pre-installed
    in Kali Linux, so you shouldn’t have to install it yourself. Start `msfconsole`
    by opening a terminal and running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The console will take some time to boot up. After it has started, run the following
    command to begin the server setup process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `use` command allows you to select modules in the Metasploit Framework.
    *Modules* are pieces of software that perform specific tasks. We’ll use the handler
    modules in the *exploit/multi* folder to create the hacker’s server. These modules
    function like the TCP server we developed in [Chapter 4](ch04.xhtml#ch4). They
    will listen for connections from clients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve selected the modules, use the `set` command to assign them context-specific
    values. Start by setting the type of implant for which the server should listen.
    Metasploit has several implant types for Windows, Linux, iOS, and Android systems.
    We’ll be attacking a Linux system, so we’ll listen for Linux x86 implants. Run
    the following command to set the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PAYLOAD` flag specifies the type of implant to listen for. Fun fact: the
    term *payload* has its origins in military terminology, where it is often used
    when referring to the contents of a bomb.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, set the server’s IP address by passing it your Kali Linux machine’s IP
    address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`LHOST` stands for *listening host*. Now set the listening port (`LPORT`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We chose port 443 because it is associated with the HTTPS protocol and makes
    the network traffic appear less suspicious. Some implants even communicate over
    the DNS protocol to avoid raising suspicion. Run the following command to start
    the server you’ve configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `exploit` command runs the module. If you’ve successfully started the server,
    you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Leave this terminal open so that the server will continue to run.
  prefs: []
  type: TYPE_NORMAL
- en: '***Building the Victim Client***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now let’s create the implant that we’ll install on the victim’s machine. Create
    a new folder on your Kali Linux desktop called *Malware*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Open a new terminal and run the following command to navigate to that folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll use the `msfvenom` tool to create the malicious implant. Run the following
    command to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `-a` flag represents the architecture being targeted, in this case `x86`.
    The `--platform` flag specifies the target platform, and the `-p` flag specifies
    the payload type, in this case a reverse TCP shell like the one we implemented
    in [Chapter 4](ch04.xhtml#ch4). The `--smallest` flag generates the smallest possible
    payload. The `-i` flag helps us to avoid antivirus detection, and I’ll discuss
    it more later. The `-f` flag presents the file type we need to output. We chose
    `elf` because it’s used by Linux executables. (The *exe* format is used by Windows
    executables.) The `-o` flag specifies the name of the output file.
  prefs: []
  type: TYPE_NORMAL
- en: '***Uploading the Implant***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ll deliver the implant the same way we delivered the reverse shell in [Chapter
    4](ch04.xhtml#ch4): by downloading it onto the victim machine. Start a Python
    server inside the Malware folder by running the following command.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In previous chapters, we looked at several ways to gain access to a system.
    For simplicity, instead of using the backdoor like we did before, we’ll assume
    that a hacker has stolen the credentials for the system. Start up the Metasploitable
    server and log in using username **msfadmin** and password **msfadmin**. Then,
    use the utility `wget` to download the implant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Make the implant executable (`+x`) by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the malicious program by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `&` option runs the process in the background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Kali terminal running the hacker’s server. If the implant has successfully
    connected, you should see output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations. You’ve just installed your first open source malware implant.
    Yes, it really is that easy. Now let’s interact with the implant using the attacker
    agent.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using the Attacker Agent***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This agent supports a variety of commands that allow you to interact with the
    implant. For example, you could list all the files on the machine using the `ls`
    command. Here, the Meterpreter interface represents the hacker agent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can download or edit any of these files using the `download` and `edit`
    commands, and you can list all available commands by running the `help` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can gain access to the victim’s shell by running the `shell` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Try interacting with the shell by running the command `whoami`. When you’re
    done, type `**exit**` to return to the Meterpreter interface.
  prefs: []
  type: TYPE_NORMAL
- en: '***Why We Need a Victim Kernel Module***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a system administrator on our Metasploitable machine views the running processes
    with the following command, the malicious program will show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `ps` command lists all (`a`) processes for all users (`u`). This command
    is equivalent to the task manager on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the malicious program shows up ➊. How do hackers avoid detection?
    They do so using a *rootkit*, software that provides the implant access to functionality
    of the operating system’s kernel, which is the highest possible access. The implant
    can use this access to make itself virtually undetectable. For instance, Meterpreter
    will attempt to evade detection by pretending to be another process. On Windows,
    you can use Meterpreter’s `migrate` command to hide your malicious process inside
    another process. We discuss the process of hiding in detail in [Chapter 11](ch11.xhtml#ch11).
  prefs: []
  type: TYPE_NORMAL
- en: '**Hiding an Implant in a Legitimate File**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Attackers often use social engineering techniques to get implants onto a victim’s
    machine. For example, they might send a victim a phishing email that encourages
    them to download a *trojan*, a program that carefully hides a malicious implant
    inside another program. The term *trojan* comes from the Trojan wars, during which
    (legend has it) the Greeks gained access to the city of Troy by hiding in a large
    statue of a horse called the Trojan Horse. We’ll execute a similar attack here
    by sending a phishing email encouraging a victim to download an updated version
    of the company’s email client, Alpine, from a fake site. You’ll execute this attack
    on the Ubuntu desktop machine in your virtual environment. Let’s begin by creating
    the Trojan.
  prefs: []
  type: TYPE_NORMAL
- en: '***Creating a Trojan***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Create a folder called *trojans* inside of your *Malicious* folder and navigate
    to it. This is where you’ll place the trojan you’ll create.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll create our trojan by modifying the Alpine installer, the *.deb* file,
    so that it installs the implant as well as Alpine. Download the legitimate Alpine
    installer by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'After you’ve downloaded the client, extract the contents of the file to the
    *mailTrojan* folder by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Open the *mailTrojan* folder. [Figure 10-2](ch10.xhtml#ch10fig2) shows its contents.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch10fig02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-2: The files in the* trojans/mailTrojan *folder contain the extracted.deb
    file.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Editing Your.deb File**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You’ll need to edit the Alpine installer’s *.deb* installation file so that
    it includes your malicious implant, so let’s walk through the installer’s structure.
    All installation files must contain a *DEBIAN* folder, which contains the files
    that describe the program and how to install it. The installation file can also
    contain other folders such as *var* for files or *usr* for binaries. These folders
    are copied to a location relative to the */home* directory during installation.
    For example, the installer would copy the *usr* folder to */home/usr*. The installer
    then will read the contents of the *DEBIAN* folder.
  prefs: []
  type: TYPE_NORMAL
- en: Click the *DEBIAN* folder. You should see the files shown in [Figure 10-3](ch10.xhtml#ch10fig3).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch10fig03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-3: The contents of the* DEBIAN *folder*'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, this folder contains three files (*control*, *md5sums*, and
    *postint*). Let’s look at each of these and alter them as required. The following
    is a snippet from the Alpine control file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The control file is required for all Debian packages and must contain information
    on the program. For example, this file contains the name of the package ➊, the
    hardware architecture that it supports ➋, the name of the maintainer ➌, and its
    dependencies ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *md5sums* file contains the MD5 hashes of the files included in the installation.
    These hashes aren’t checked during installation. Instead, they’re used to verify
    the integrity of the files after installation. If you want, you can add an MD5
    hash of your malicious implant. You don’t have to, but it’s an extra stealthy
    step. The following is a snippet from the *md5sum* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The *postint* file is run after the installation has completed. Debian packages
    normally contain *preint* and *postint* files that the original package developer
    placed to instruct the Debian package manager what to do before and after installation.
    We’ll add the code that will activate our implant to the *postint* file. The *postint*
    file is a great candidate because it will be run after the application has been
    installed, thus the implantation process won’t interfere with the installation.
    If the file doesn’t exist, create it by using the file manager or by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Open the *postint* file and copy in the following code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This will add execute permissions to the malicious file ➊ and then executes
    it with root privileges ➋.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, make *postint* executable by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '**Adding the Implant**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Now we’ll create the implant and add it to the */usr/bin* folder, to ensure
    that the installer will copy it to the */home/usr/bin* folder on the victim’s
    machine during installation. Start by navigating to *usr/bin* inside the *mailTrojan*
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use the `msfvenom` command to create the malicious file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use `msfvenom` with the same options as before to generate a malicious
    implant. However, instead of copying the implant directly onto the victim’s machine,
    we’ll hide it inside Alpine’s installation folder. Copy the resulting *malicous*
    binary to the *usr* folder. Now the contents of your *usr/bin/* folder should
    resemble [Figure 10-4](ch10.xhtml#ch10fig4).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch10fig04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-4: The contents of the* usr/bin/ *folder*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you’re ready to repackage your files into your final *.deb* installation
    file. Run the following command to start the repacking process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Voilà! You’ve created your first trojan. You can view it by navigating to the
    */Desktop/Malware/trojans* folder and running the `**ls**` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The file beginning with *alpine* is the unmodified Alpine installer. The *mailTrojan*
    folder is the folder to which we’ve just added the malicious files, and *mailTrojan.deb*
    is our newly repackaged trojan containing the implant. One suggested improvement:
    an attacker might pick a stealthier name.'
  prefs: []
  type: TYPE_NORMAL
- en: Attacks like this really do work, often at a large scale. Take Solarwinds, which
    makes software that governments and large corporations use to manage and secure
    their networks. In 2020, hackers were able to break into Solarwinds computers
    and modified one of their software libraries to include a malicious implant. When
    Solarwinds installed their software update, it also installed the infected library.
    This attack affected several corporations and government agencies that used Solarwinds
    software. The implant was carefully crafted, even containing a strategy for avoiding
    detection. For example, it waited two weeks before activating and wouldn’t start
    if it detected security-related software like Wireshark.
  prefs: []
  type: TYPE_NORMAL
- en: '***Hosting the Trojan***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'An attacker could host the trojan we’ve just created on GitHub or on a faked
    website. In this section, we’ll host the trojan on our Kali Linux virtual machine
    and serve it from a local webserver. Ensure that you’re in the folder containing
    your trojan and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you’ll need to start the attacker server that will listen for connections
    from your implant. Instead of performing one step at a time as we did earlier,
    we can run all of the commands on one line in a new terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have two servers running: one that serves the implant and another that
    accepts incoming connections from all installed implants. The next thing we must
    do is test the trojan by downloading the implant onto our Ubuntu virtual machine.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Downloading the Infected File***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Start the Ubuntu virtual machine and then simulate a user clicking an email
    link by copying and pasting the following link into the browser, making sure to
    specify the IP address of your Kali Linux machine: *http://<Kali IP address>/mailTrojan.deb*.'
  prefs: []
  type: TYPE_NORMAL
- en: Select the **Save File** option when presented with a download window, as shown
    in [Figure 10-5](ch10.xhtml#ch10fig5).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch10fig05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-5: Downloading the* mailTrojan.deb *file*'
  prefs: []
  type: TYPE_NORMAL
- en: This will save the *.deb* installer file to your *Downloads* folder. Open the
    *Downloads* folder in the file explorer and then install the file by right-clicking
    and selecting **Open with** ▶ **Install Software**.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering if an actual user would really do all of this. But consider
    all the packages you’ve installed by running `sudo apt-get`. Can you be sure that
    none of those *.deb* files contained implants? Once you’ve started the package
    installer, you should see the screen in [Figure 10-6](ch10.xhtml#ch10fig6). Select
    **Install**.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch10fig06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-6: The install screen for the Alpine email client*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter your Ubuntu password. Once the installation process has completed, run
    the following command to start the Alpine terminal email client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If Alpine was installed correctly, you will see a terminal interface. Now let’s
    check whether our implant was installed, too.
  prefs: []
  type: TYPE_NORMAL
- en: '***Controlling the Implant***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Reopen the terminal running the attacker server you started earlier. If the
    implant was correctly installed, you should see the following, indicating the
    implant has connected to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Great! Run the following command to see all the things you can do with your
    implant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now what could you do to go further? How about installing a backdoor so that
    you can easily get back in? The Meterpreter implant will disconnect if someone
    restarts the machine or deletes the malicious file. You could attempt to maintain
    access by recompromising the machine, but if the victim changes their password
    or patches the program you originally exploited, all your effort would have been
    for nothing. This is why hackers install backdoors; they allow an attacker to
    regain access to a machine through an alternate route. When I discuss rookits
    in [Chapter 11](ch11.xhtml#ch11), I’ll show you how to design your own backdoor.
    But if you want to install one now, consider using the *dbd backdoor* designed
    by Kyle Barnthouse and available at *[https://github.com/gitdurandal/dbd/](https://github.com/gitdurandal/dbd/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Evading Antivirus by Using Encoders**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Won’t antivirus software detect these malicious programs? Not always. You can
    see which antivirus software will detect your implant by uploading it to Virus
    Total at *[https://www.virustotal.com/gui/](https://www.virustotal.com/gui/)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Antivirus systems use *signature detection* to attempt to find malware. A malware’s
    signature is a unique sequence of bytes that represents it. You can see our malicious
    implant’s byte sequence by running the `xxd` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Antivirus software detects malware by scanning memory for these signatures,
    so you can avoid detection by ensuring that your malware has a signature not already
    known to antivirus systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to do this is by running the malware through an *encoder*. Encoders
    change a program’s signature by modifying its bytes without changing its functionality.
    You might be wondering: Wouldn’t changing the bytes change both the instructions
    and the program’s functionality? Well, two programs can have the same functionality
    even if they don’t use the same instructions. For example, both of these programs
    multiply a number by 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Let’s make this idea concrete by applying a simple encoder. Msfvenom supports
    several encoders. You can view a list of them by starting `msfconsole` and running
    the `show encoders` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a closer look at the two encoders shown in this output, starting
    with the easiest one.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Base64 Encoder***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `powershell_base64` encoder uses the base64 encoding scheme, which converts
    binary sequences to text, just like the ASCII encoding scheme mentioned in [Chapter
    5](ch05.xhtml#ch5). However, unlike ASCII, which converts 8-bit sequences, the
    base64 encoder converts 6-bit sequences to one of 64 possible printable characters.
    Consider the example in [Table 10-1](ch10.xhtml#ch10tab1), which converts the
    Linux `ls` command from ASCII to base64.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 10-1:** The Conversion of ASCII to base64'
  prefs: []
  type: TYPE_NORMAL
- en: '| ASCII | l | s |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Binary | 0 | 1 | 1 | 0 | 1 | 1 | 0 | 0 | 0 | 1 | 1 | 1 | 0 | 0 | 1 | 1 |'
  prefs: []
  type: TYPE_TB
- en: '| Decimal (0-64) | 27 | 7 | 12 |'
  prefs: []
  type: TYPE_TB
- en: '| Base64 | b | H | M |'
  prefs: []
  type: TYPE_TB
- en: 'The last section has only four bits, so the remaining two bits are assumed
    to be 0, and the padding character (`=`) is added to the end. Here is the base64encoded
    result: `bHM=`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Can we execute this base64-encoded value? Yes, if we decode it and pass it
    to the shell before we run the program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This command passes the base64-encoded string to the base64 decoder (`-d`),
    which converts the string back to ASCII encoding before piping (|) it to the shell
    (`sh`) to be executed. [Figure 10-7](ch10.xhtml#ch10fig7) shows an overview of
    this encoding and decoding pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch10fig07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-7: The encoding and decoding pipeline*'
  prefs: []
  type: TYPE_NORMAL
- en: A Bash script containing the `ls` command will have a different signature from
    a file containing base64-encoded values of the `base64 -d <<< bHM= | sh` command,
    even though they are functionally equivalent. This is because both files are stored
    using ASCII encoding. Because the signatures are different, an antivirus program
    may fail to detect the malicious file containing the base64 values, as described
    in [Figure 10-8](ch10.xhtml#ch10fig8).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch10fig08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-8: The binary signature of two functionally equivalent files can
    differ.*'
  prefs: []
  type: TYPE_NORMAL
- en: However, there is a weakness to this technique. Once the signature detection
    algorithm captures an encoded implant with the new signature, it will be able
    to detect all future instances of the encoded implants because the base64 encoding
    never changes. In the Shikata Ga Nai Encoder section of this chapter, we’ll explore
    how to create a polymorphic encoder that generates a new signature each time it
    runs.
  prefs: []
  type: TYPE_NORMAL
- en: For now, let’s complete the discussion of the base64 encoder by writing an implant
    and then, as an exercise, we’ll create a Metasploit module to encode it. Create
    a new file in the *Malware* folder called *implant.sh* and copy in the code snippet
    that follows. The script will use telnet to establish two connections. It will
    receive commands from the first connection on port 80 and upload the results using
    the second connection on port 443.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the netcat (`nc`) utility to create two TCP servers in separate terminals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '***Writing a Metasploit Module***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s write a Metasploit module that will base64 encode the implant. Metasploit
    modules are written in the Ruby program language. Don’t worry. Ruby looks a lot
    like Python, so you’ll pick it up easily. Also, the Metasploit Framework is open
    source, and you can view the *cmd/powershell_base64* encoder by visiting *[https://github.com/rapid7/metasploit-framework/blob/master/modules/encoders/cmd/powershell_base64.rb](https://github.com/rapid7/metasploit-framework/blob/master/modules/encoders/cmd/powershell_base64.rb)*.
    This encoder is used to encode PowerShell scripts for Windows machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take some time to look at the *powershell_base64* encoder before we begin to
    write our own version that encodes Bash scripts for Linux machines. Create a new
    folder in your *Malware* folder called *Encoders* and then create a new file called
    *bash_base64.rb* inside the *Encoders* folder. We’ll implement our base64 encoder
    in this file, so copy in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We inherit (`::`) from the encoder superclass and then specify the rank, or
    quality, of the module ➊. Modules range in quality from Manual to Excellent, depending
    on the reliability and amount of human intervention needed. We use the `super`
    ➋ keyword to call the superclass’s constructor and provide information on our
    module. After our module has initialized, the Metasploit Framework will split
    the input into blocks and call the `encode_block()` function ➌ on each block.
    We convert the values to ASCII Unicode before base64 encoding them.
  prefs: []
  type: TYPE_NORMAL
- en: To test your new encoder, add it to the Metasploit Framework by copying it into
    the *encoders* folder, which you can find by opening your file explorer and navigating
    to */usr/share/metasploit-framework/modules/encoders*. Create a new folder called
    *bash* and save your *bash_base64.rb* encoder file here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new terminal and run the `show encoder` command in the `msfconsole`
    to ensure that your module was added correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'If your module is present, use `msfvenom` and your module to encode your implant.
    Run the following command to create your encoded implant and save it as *implantEncoded*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Test your encoded implant by making it executable and running it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Great, you’ve written a simple base64 encoder. However, it has some limitations.
    In addition to the fact that it will always produce the same signature, it can’t
    encode compiled binaries. As an ethical hacker, you’ll often load binary versions
    of the tools you create onto target machines. If you want to avoid detection,
    it’s a good idea to encode these binaries themselves. The Shikata Ga Nai encoder
    allows you to encode binaries.
  prefs: []
  type: TYPE_NORMAL
- en: '***Shikata Ga Nai Encoder***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *Shikata Ga Nai (SGN) encoder* encodes payloads by XOR-ing the bytes in
    the payload with a randomly selected number called an *initialization vector*.
    The strategy is similar to the one-time pad encryption algorithm discussed in
    [Chapter 5](ch05.xhtml#ch5). However, the SGN encoder includes the initialization
    vector and decoder code as part of the payload, so it loads the initialization
    vector and then starts the decoder when the payload runs. The decoder loops through
    the memory addresses associated with the encoded part of the payload and decodes
    an instruction by XOR-ing it with the initialization vector at each iteration
    of the loop. The decoder then replaces the encoded instruction with the decoded
    instruction in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Once all instructions have been decoded and replaced, the decoding loop ends
    and the CPU executes the decoded region. Because the decoder is usually partially
    encoded, it’s difficult for an antivirus program’s signature detection algorithm
    to identify the payload based solely on the decoder’s signature.
  prefs: []
  type: TYPE_NORMAL
- en: The SGN encoder can make the reverse engineering process more difficult by calculating
    a new initialization vector for each instruction. For example, it can add the
    newly decoded bytes to the previous initialization vector, as shown in [Figure
    10-9](ch10.xhtml#ch10fig9).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch10fig09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-9: The process of encoding bytes with the SGN encoder*'
  prefs: []
  type: TYPE_NORMAL
- en: The SGN encoder further complicates the reverse engineering process by using
    additional arithmetic (addition and subtraction) to compute the initialization
    vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SGN encoder is often referred to as a *polymorphic encoder*. A polymorphic
    encoder will generate a new signature each time it runs, as long as a hacker selects
    a new initialization vector and runs the encoder for multiple iterations. The
    following command generates an SGN-encoded payload; remember to replace `<Kali-IP>`
    with the IP address of your Kali Linux machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: We’ve used the `--encoder` option to specify the SGN encoder ➊.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a Windows Trojan**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, we’ve discussed how to create a trojan for Linux. The process of creating
    a Windows trojan is similar, as you can do it with `msfvenom`, too. We’ll cover
    two methods of hiding your implant: in a fun, open source implementation of the
    game Minesweeper by Humaeed Ahmed, and in a document using the Social Engineering
    Toolkit (more on this in a moment).'
  prefs: []
  type: TYPE_NORMAL
- en: '***Hiding the Trojan in Minesweeper***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'I’ve forked Ahmed’s repository, and you can download a copy of the executable
    from the following link: *[https://github.com/The-Ethical-Hacking-Book/Minesweeper/blob/master/Minesweeper/bin/Debug/Minesweeper.exe](https://github.com/The-Ethical-Hacking-Book/Minesweeper/blob/master/Minesweeper/bin/Debug/Minesweeper.exe)*.
    Save it to your *Malware* folder on your Kali desktop.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Do you trust this executable? Now you’re thinking like a hacker. The repository
    also contains the source code needed to build it yourself if you don’t trust me.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'After you’ve downloaded the executable, use `msfvenom` to transform it into
    a malicious trojan by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the `-e` flag specifies that we’ll use the SGN encoder we just discussed.
    Many of these options are the same as when we first ran `msfvenom`, with the exception
    of the `-k` flag, which tells `msfvenom` to keep regular execution of the program
    and run the payload in a separate thread. You don’t need to memorize these options;
    you can view their documentation by running `msfvenom` with the `**--help**` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '***Hiding the Trojan in a Word Document (or Another Innocent File)***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There’s a problem: Windows users rarely install new programs, and they’re incredibly
    suspicious of programs they’re asked to install via email. However, users open
    Word documents, PowerPoint presentations, and PDF files almost daily. You could
    embed implants in these files, too. The *Social Engineering Toolkit (SET)* abstracts
    the Metasploit Framework’s details and makes it easy to send and generate this
    kind of infected media. Run the following command to start SET:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'After the toolkit starts, you should see the following menu. Select the **Social-Engineering
    Attacks** option by entering `**1**` in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, select the **Infectious Media Generator** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, select the **File-Format Exploits** option. This will let you embed implants
    in different kinds of files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the IP address of the attacker server; in this case, your Kali Linux
    machine. Once you’ve done so, you should see a list of the available infection
    media attacks. This list of file formats will change as companies patch vulnerabilities
    and attackers discover new ones. Many of these attacks work only on a specific
    software version, so use the information you collected during your OSINT operations
    to carefully select one that your target uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Microsoft Office documents, like Word, Excel, and PowerPoint files, support
    *macros*, which are small programs that users can write to automate tasks in Office
    documents. Macros run when you open a document; however, Microsoft Office disables
    macros by default because they are a security risk. Whenever a document contains
    a macro, Microsoft Office will display a banner that allows the user to enable
    macros. An attacker could embed a malicious macro into a document that downloads
    and executes a shell when a user opens it. In 2021, a state-sponsored attacker
    used a malicious Word document to break into a Russian defense contractor. You
    can read about this attack by the Lazarus group on the Kaspersky website.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve examined techniques for creating trojans for desktops and servers,
    let’s create trojans for mobile and embedded devices.
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating an Android Trojan**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The process of creating trojans for Android devices is almost identical to that
    of creating Linux trojans. The directory structure might differ, but as you did
    earlier in this chapter, you’ll modify an installation package to install your
    implant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Android installation package is called an *Android Package (APK)* file.
    This file contains everything the Android operating system needs to install a
    new app. Let’s begin by using `msfvenom` to generate a malicious APK. Create a
    new Desktop folder called *AndroidTrojan* and then navigate to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, generate a new malicious APK that contains a reverse shell implant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This command generates a new Android APK with malicious code embedded within
    it. In the next section, we’ll disassemble this application and discuss its structure
    so that you can create your own Android trojan.
  prefs: []
  type: TYPE_NORMAL
- en: '***Deconstructing the APK to View the Implant***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The command in the preceding example did all the work for you. To understand
    how it hid the implant, let’s decompile the *malicious.apk* install file and explore
    its directory structure. We’ll use `apktool`, a reverse engineering tool, to decompile
    the APK. Run the following command to download and install `apktool`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To decompile (`d`) the file, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The tool will create a folder called *malicious* that contains the decompiled
    files. Navigate to this folder and list all the files and folders in the directory
    using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following files and folders: *AndroidManifest.xml*, *apktool.yml*,
    *original*, *res*, and *smali*. The *AndroidManifest.xml* file describes your
    app. The following is a snippet from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This file includes your app’s permissions, like camera access or access to your
    call log ➊. It also contains information about your app’s entry point ➋, which
    is the first file your app runs when it starts.
  prefs: []
  type: TYPE_NORMAL
- en: The *apktool.yml* file contains information on the APK, including its version
    number and type of compression. The *original* folder contains a compiled version
    of *AndroidManifest.xml*, a file containing its hash, and files containing information
    on the signatures. (These signatures are similar to the ones we discussed in [Chapter
    6](ch06.xhtml#ch6). I’ll discuss these in more detail in the next subsection.)
    The *res* folder contains the application’s resources, such as images or strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, the *smali* folder contains assembly files associated with the app.
    It is also where we have put the implant. You can view the assembly files associated
    with the Metasploit implant by running `ls` on the *smali/com/ metasploit/stage/*
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: If you’ve spent time working with mobile apps, you might have expected to see
    a *.dex* file. These files contain the byte code that the Android Runtime (ART)
    executes. The reason there isn’t one is that *smali* is the assembly representation
    and *.dex* is the machine representation of the app’s code. The *Payload.smali*
    file contains the code associated with our malicious implant, and we’ll transfer
    this file into another APK to create a trojan later.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let’s inspect the *MainActivity.smali* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The malicious APK starts `MainService` ➊, a malicious Android service written
    by the developers of the Metasploit Framework. This service will eventually load
    the payload in the background. If you wanted to start the malicious payload activity
    immediately, you could add the following snippet at ➋ in the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, you can create your own trojan by decompiling an existing APK, copying
    the *Metasploit* folder to the *smali* folder, and then adding the preceding snippet
    to *MainActivity.smali* to start the payload.
  prefs: []
  type: TYPE_NORMAL
- en: '***Rebuilding and Signing the APK***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we’ve inspected the file, we can rebuild it by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: All Android apps must be signed before they can be run on an Android device.
    You can do this with the *Java Keystore*, which stores and protects key material
    such as the public and private keys used for signing. Key material never leaves
    the Keystore. Instead, an application sends the Keystore its data, and the Keystore
    uses the protected key material to sign or encrypt data and returns the results,
    as illustrated in [Figure 10-10](ch10.xhtml#ch10fig10). Some systems even store
    key material in a separate piece of secure hardware called a trusted execution
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch10fig10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-10: Key material never leaves the Keystore.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to install the Java Development Kit (JDK), which
    contains the tools we’ll use to sign the trojan APK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Generate the RSA key we’ll use to sign the trojan by using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We use Java’s `keytool` utility to generate a new key (`-genkey`). Instead of
    displaying the key pair, we store them in a Keystore file (`-keystore`) called
    `my-malicious.keystore`. The Keystore can store multiple entries, each of which
    is identified by an alias (`-alias`). Our entry is called `alias_name_malicious`.
    The next option specifies the cryptographic key algorithm (`-keyalg`). Here, we
    select `RSA` and set the key size (`-keysize`) to be `3072`. We also set the key
    to be valid (`-validity`) for 10,000 days.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now use Java’s `jarsigner` utility to sign the APK file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: First, we select the signature algorithm, using SHA2 with RSA (`-sigalg SHA2withRSA)`.
    Then we use SHA2 as our hash/digest function (`-digestalg SHA2`). Lastly, we specify
    the Keystore (`-keystore`) and the key alias. In this case, we’ll use the Keystore
    we just created (`my-malicious.keystore`) and the entry with the alias (`alias_name_malicious`).
  prefs: []
  type: TYPE_NORMAL
- en: '***Testing the Android Trojan***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now let’s see our malicious APK in action. We don’t want the malicious program
    on our phones, so let’s create a new virtual machine that emulates an Android
    phone. Google has developed an emulator that is bundled with Android Studio, its
    Android development environment. Follow the instructions at *[https://developer.android.com/studio/install/](https://developer.android.com/studio/install/)*
    to download Android Studio on your host system, outside of your current virtual
    lab environment.
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve installed Android Studio, create an empty project by clicking the
    **Start New Android Studio project** and following the instructions presented.
    As rule of thumb, select the default options. Once you’ve created your project,
    create a new Android virtual device by selecting **Tools** ▶ **AVD Manager** or
    by clicking the Android Virtual Device Manager icon ➊, as shown in [Figure 10-11](ch10.xhtml#ch10fig11).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch10fig11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-11: The Android Virtual Device manager*'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new virtual device ➋ with the specifications of the device you’re targeting.
    Then click the play button ➌ to start it. It will take some time to start the
    virtual machine. When it’s started, you should see an emulated device.
  prefs: []
  type: TYPE_NORMAL
- en: Your Kali Linux virtual machine can’t interact with your Android emulator because
    the emulator runs outside your virtual lab environment. Change the Kali connection
    settings in VirtualBox to **Bridged Adapter** so that it connects to the same
    local network as your Android emulator ([Figure 10-12](ch10.xhtml#ch10fig12)).
    See [Chapter 1](ch01.xhtml#ch1) for instructions on changing the Kali Linux network
    configuration, and remember to restore the previous settings after you complete
    this exercise.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch10fig12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-12: Setting the Kali Linux virtual machine to Bridged Adapter*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `**ifconfig**` command to get the new IP address of the Kali Linux
    machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, start a web server in the folder containing your signed malicious APK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the web server that we’ll use to serve our malicious APK file. Now
    start the attacker server in a new terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Open your emulated device, navigate to the web server running on the Kali Linux
    machine, and download the trojan, as shown in [Figure 10-13](ch10.xhtml#ch10fig13).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch10fig13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-13: Downloading the trojan on Android*'
  prefs: []
  type: TYPE_NORMAL
- en: Ignore the warnings following the instructions and allow the installation of
    third-party apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you should have successfully installed and connected to your
    implant. You should see the following Meterpreter shell. Try typing `geolocate`
    to get the phone location. (Remember, the phone is running in a virtual machine
    and doesn’t have access to GPS, so this location will be simulated.) Also run
    the `help` command to see all of your options. Meterpreter isn’t perfect, so some
    options might not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: An attacker could encourage a user to download the malicious APK by sending
    them a phishing email or text message linking to a cloned version of the Google
    Play Store website (see [Chapter 7](ch07.xhtml#ch7) for information on cloning
    web pages). Alternatively, a hacker could use a QR code. You see QR codes all
    over the place; for example, at conferences and in parks. A hacker could easily
    make the QR code link to a fake website that contains a malicious trojan. [Figure
    10-14](ch10.xhtml#ch10fig14) shows an example QR code that links to the No Starch
    Press website. You can scan it by opening your phone’s camera app and pointing
    at the QR code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/ch10fig14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 10-14: This QR code takes you to* [https://nostarch.com/catalog/security](https://nostarch.com/catalog/security)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: Some of the best mobile attacks exploit *zero-click vulnerabilities*. A zeroclick
    vulnerability allows an attacker to compromise a mobile device without any action
    on the user’s part. These are really rare and very valuable.
  prefs: []
  type: TYPE_NORMAL
- en: 'A final note on mobile devices: although iOS devices are generally considered
    more secure, they aren’t safe either. For example, a vulnerability in Facebook’s
    WhatsApp platform allowed hackers to install malware on an iPhone by sending WhatsApp
    users a link. A state hacker group later used this vulnerability to hack Amazon
    CEO Jeff Bezos’ iPhone.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These exercises will bolster your understanding of trojans. You’ll begin by
    exploring a tool that automates the process of creating and signing Android trojans.
    In the second exercise, you’ll write an implant in Python. Your implant should
    stream video from the victim’s webcam and transmit it back to the attacker’s server.
  prefs: []
  type: TYPE_NORMAL
- en: '***Evil-Droid***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Evil-droid* is a Bash script that automates the APK implantation and signing
    process. You can download it from GitHub by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Next, you’ll need to download the APK of the app you’d like to transform into
    a trojan. In this example, we’ll use the APK file of the Signal app, an encrypted
    messaging service that you can find at *[https://signal.org/android/apk/](https://signal.org/android/apk/)*.
    To choose any other APK available from the Google Play Store, use `gplaycli`,
    a free and open source utility that allows you to download APK files from the
    store. You can install it from *[https://github.com/matlink/gplaycli](https://github.com/matlink/gplaycli)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you’ve downloaded an APK file, navigate to the Bash script in the *Evil-Droid*
    folder and change the script’s permissions to make it executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the Evil-Droid script by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the Evil-Droid script has started, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Select **[3]** to inject the implant into the original APK. As you can see
    from the output, Evil-Droid has two options for injecting an implant: the old
    option and the new option. The new option provides additional features, such as
    signing the APK, which is required for apps running on modern Android platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Evil-Droid is implemented by using a single open source Bash script. Here is
    a link to the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Once you’ve selected **[3]**, follow the instructions and prompts to create
    your trojan, providing it with the original APK you want to modify.
  prefs: []
  type: TYPE_NORMAL
- en: '***Writing Your Own Python Implant***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In this chapter, we used implants available through Metasploit. As an exercise,
    write your own implant that takes pictures with a victim’s camera.
  prefs: []
  type: TYPE_NORMAL
- en: Use the Python *OpenCV* library to capture and display the images from the webcam.
    You install this library with `pip3`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Copy the following into a new file called *implant.py*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The script will take several pictures (frames) and stitch them together to create
    a video. First, we’ll select a video capture device ➊. A machine could have multiple
    cameras attached to it and the operating system assigns each camera to an interface.
    Here, we’ll choose the camera assigned to interface 0, which is the first interface.
    Next, we set the display window, which will show each frame. Showing each frame
    is excellent for debugging, but you wouldn’t display this in a stealthy trojan.
    As long as the window is open, we’ll capture/read new frames ➋. The variable `status`
    is a Boolean variable that indicates whether the frame was correctly captured.
    We’ll then pass each of these frames to the window to be displayed and printed
    to the console. Lastly, if the user presses the ESCAPE key, we’ll close the window
    and stop the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test the program by opening a new terminal and navigating to the folder containing
    your *implant.py* file. On the top menu in Kali Linux, select **Devices** ▶ **Webcam**
    to attach your webcam to the virtual machine. Now run your implant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Extend your implant’s functionality by allowing it to send frames to a hacker’s
    server over a TCP connection. After you’ve extended and tested it, you can make
    the implant more stealthy by removing the lines that display the feed to the victim.
    And remember that you want your implant to communicate securely. See [Chapter
    6](ch06.xhtml#ch6) for examples of how to establish a secure communication channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extend your implant even further by allowing it to take screenshots. Install
    and use the *python-mss* library to do so. Here, I have provided example code
    that imports the library `mss` and takes a screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: You’ll also need to create and implement a basic protocol for controlling your
    implant. See [Chapter 4](ch04.xhtml#ch4) for examples of how to do so. As a final
    note, the *pynput* library is great for adding keylogger functionality. You’ll
    need to install it before using it.
  prefs: []
  type: TYPE_NORMAL
- en: '***Obfuscate Your Implant***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you’ve developed an implant, let’s obfuscate it. Remember, obfuscation
    makes detection and reverse engineering more difficult. We’ll use the `pyarmor`
    tool to obfuscate the *implant.py* file. Details on the `pyarmor` obfuscation
    process can be found in its documentation at *[https://pyarmor.readthedocs.io/en/latest/how-to-do.html](https://pyarmor.readthedocs.io/en/latest/how-to-do.html)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `pip3` to install `pyarmor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Now obfuscate your implant by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'You can view the obfuscated script by navigating to the folder *dist*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: You also need all the files in the *dist* folder, including those in the *pytransform*
    folder. Run your newly obfuscated file by running *implant.py* in the *dist* folder.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Alternatively, you can use* `*pyminifier*` *to generate a minified version
    of the code.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Build a Platform-Specific Executable***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To run the implant you just wrote, a computer must have Python installed. However,
    a hacker can’t assume that Python will be available on the victim’s machine. Instead,
    we need to convert the Python program into an executable using the `pyinstaller`
    utility, which you can install as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a Linux executable from the original, unobfuscated file, run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an obfuscated executable, run the following command on the original
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: You can embed the resulting Linux executable in a Trojan using the same techniques
    discussed earlier in the chapter. Now try generating a Windows executable (*.exe*)
    by running `pyinstaller` on a Windows machine. The commands are the same, and
    running them on a Windows device will generate a Windows executable.
  prefs: []
  type: TYPE_NORMAL
