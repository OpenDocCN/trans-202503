- en: Chapter 6. Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you’ve built an application, let’s put it on the Web for everyone to
    see. Rails applications can be deployed in many ways. Rails runs on everything
    from simple shared hosting to dedicated servers to virtual servers in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: The cloud application platform known as Heroku is one of the easiest ways to
    deploy your application, and I cover it in this chapter. Heroku uses the Git version
    control system to deploy applications, so we need to talk about version control
    systems first.
  prefs: []
  type: TYPE_NORMAL
- en: Version Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *version control system (VCS)* records changes to files over time so you can
    easily go back to a specific version later. The *repository* is the data structure,
    usually stored on a server, that holds a copy of the files in the VCS and a historical
    list of changes to those files. With a VCS, you can make changes to your source
    code knowing that you can always go back to the last working version.
  prefs: []
  type: TYPE_NORMAL
- en: Originally, version control systems were *centralized*. That is, the source
    code repository was stored on a single server. Developers could connect to that
    server and check out files to make changes to the code. But centralized systems
    also have a single point of failure. Examples of centralized version control systems
    include the Concurrent Version System (CVS) and Subversion.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular type of version control system today is *distributed*. With
    a distributed version control system, each client stores a complete copy of the
    source code repository. That way, if a single client fails, everyone else can
    continue to work with no loss of data.
  prefs: []
  type: TYPE_NORMAL
- en: In a distributed system, a central server is still commonly used. Developers
    *push* their changes to this server and *pull* changes made by other developers.
    Popular distributed version control systems include Git and Mercurial. Because
    Heroku uses Git to deploy applications, I’ll focus on Git.
  prefs: []
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git was originally developed by Linus Torvalds in 2005 for use with the Linux
    kernel. The word *git* is British slang for a despicable person. Torvalds once
    joked that he names all of his projects after himself.
  prefs: []
  type: TYPE_NORMAL
- en: Git quickly spread beyond the Linux community, and most Ruby projects now use
    Git, including Ruby on Rails. If you don’t already have Git, installation instructions
    can be found in [Ruby, Rails, and Git](pr03.html#rubycomma_railscomma_and_git
    "Ruby, Rails, and Git").
  prefs: []
  type: TYPE_NORMAL
- en: Setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before you start using Git, set your name and email address. Open a terminal
    window and enter the following command to set your name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--global` flag tells Git to apply this change to your global configuration.
    Without this flag, the change would only apply to the current repository. Also,
    set your email address:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now every time you commit a change, your name and email address is included,
    making it easy to see who made which changes when working with a team.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now you’re ready to create a repository for the blog. Move to your *code/blog*
    directory and enter this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This initializes an empty Git repository in the hidden *.git* subdirectory.
    Next, let’s add all of the application’s files to the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `add` command accepts a filename or directory path and adds it to Git’s
    staging area. Files in the staging area are ready to be committed to the repository.
    The dot in the command represents the current directory. So after you run this
    command, all files in the current directory and any subdirectories are ready to
    be committed. When you commit, Git takes a snapshot of the current state of your
    project and stores it in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now commit all staged files to the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that I specified the commit message `"Initial commit"` with the `-m` flag
    ➊. If you leave off this flag, Git will open your default editor so you can type
    a commit message. If you do not type a commit message, the commit fails.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to view the current repository’s commit history, enter the `git
    log` command. The list shows previous commits in order from newest to oldest.
    Each entry includes who made the commit and when, along with the commit message.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Each commit is represented by a unique 40-character hexadecimal hash ➊. These
    hashes can be abbreviated to the first seven characters—in this case, e393590—if
    you need to refer to this particular commit again.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you work on a project using Git, follow this basic workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: Edit local files as needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stage files to be committed with the `git add` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit the changes to the repository with the `git commit` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can commit changes to Git as often as you like, but I find it helpful to
    commit changes related to a single simple feature or bug fix together. That way,
    all of the changes are tied to one commit, making it easier to revert and remove
    a feature if necessary. It’s also a good idea to commit any outstanding changes
    at the end of a working session.
  prefs: []
  type: TYPE_NORMAL
- en: Other Useful Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Git contains many additional commands; enter `git --help` to see a list of those
    you’ll use most often. You’ve already seen the `init`, `add`, `commit`, and `log`
    commands, but here are a few more that you’ll find particularly useful as you
    navigate Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `git status` command displays a list of changed and new files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, nothing has changed. Edit a file in your project, *README.rdoc,*
    for example, and then enter the `git status` command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `git status` command shows the current state of your working directory and
    staging area. Here, it lists all files that have been staged for commit and files
    with changes that have not been staged for commit ➊.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `git diff` command shows detailed changes to files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, I changed the word *README* to *Blog* ➊ on the first line of the file.
    Use this command before `git add` to see exactly what changes will be staged for
    commit. You can also pass a filename to this command if you only care about changes
    to a single file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `git checkout` command can undo changes to a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, I’ve discarded the changes to the file *README.rdoc* by using `git checkout`
    followed by two dashes and the filename ➊. This command does not produce any output.
    Then I used `git status` to confirm that the change had been discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `git clone` command makes a local copy of a remote repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The remote repository is represented by *`<url>`*. Git is a great tool for collaboration
    and is used by many open-source projects. This command makes that possible. Before
    you start working on an existing project, you *clone* a copy of the repository
    to your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Branches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that the `git status` command includes the phrase, “On
    branch master.” In Git, a *branch* is a named set of changes. The default branch
    is called *master*. It represents the main line of development. The changes I’ve
    made so far have all been committed to the master branch.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re working on a large feature that may take some time to complete, you
    can create a separate branch to store changes you’re working on without affecting
    the master branch. This way, you can work on your own branch without impacting
    the rest of your team. Once the new feature is complete, you’ll *merge* your new
    branch back into the master branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `git branch` command followed by a branch name of your choice to create
    a new branch. In this example, I’ll call my branch *testing*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Enter the `git branch` command without specifying a name to see a list of the
    branches that currently exist in the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The star shows the currently selected branch. I created a new branch, but I’m
    still looking at the master branch. To switch to a different branch, use the `git
    checkout` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I’m on the testing branch. Changes committed here will not affect the master
    branch. Once you are finished making changes, `checkout` the master branch and
    merge your changes into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the changes from the testing branch are now also in the master branch.
    You can confirm this with the `git log` command. Now that you’re finished with
    the testing branch, add the `-d` flag to the `git branch` command to delete it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You don’t have to delete branches after they have been merged, but doing so
    keeps the list of branches clean.
  prefs: []
  type: TYPE_NORMAL
- en: Remotes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, all of our changes have been stored locally, but you should store an
    additional copy of your repository on another server as a backup and to make it
    easier for others to clone your repository. To do this, you need to set up a remote.
    A *remote* is simply a nickname for another repository at a specific URL. Use
    the `git remote add` command to associate a nickname with a URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Once you have added a remote, use the `git push` command to send changes to
    the URL and the `git pull` command to retrieve changes made remotely. You’ll see
    a real-world example of this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Heroku is a cloud application platform for deploying web applications. This
    type of platform is sometimes referred to as a *Platform as a Service (PaaS)*,
    meaning Heroku takes care of server configuration and management so you can focus
    on application development. The service also includes an extensive collection
    of add-ons. Getting started is free, but large applications requiring more processor
    resources and memory can get expensive.
  prefs: []
  type: TYPE_NORMAL
- en: After some initial setup, you can use a `git push` command to deploy your application
    and access it on the Web.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, sign up for a free account at *[http://www.heroku.com](http://www.heroku.com)*.
    Remember the password you select; you’ll need it again to log in.
  prefs: []
  type: TYPE_NORMAL
- en: Next, install the Heroku Toolbelt if you haven’t already (see *[http://toolbelt.heroku.com/](http://toolbelt.heroku.com/)*
    for instructions). The Toolbelt is Heroku’s set of tools for deploying your application
    to its platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open a terminal window, navigate to your blog directory, and log in to
    Heroku:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This command prompts you for your email address and the password you created
    earlier, and then it checks your computer for an existing secure shell (SSH) public
    key. Your public key is one half of the public/private key pair used to authenticate
    over SSH. When you attempt to log on, your private key is used to make a cryptographic
    digital signature. Heroku then uses your public key to verify this digital signature
    and confirm your identity.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t already have a public key, press **Y** to create one when prompted.
    Your public key is automatically uploaded to Heroku after it is created. Heroku
    uses your public key for authentication so you don’t have to type your password
    every time you deploy your application.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve logged in to Heroku, you need to prepare your application for
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Your Gemfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No matter what kind of application you’re building, you need to install certain
    gems to interface with Heroku and deploy your application. In this section, we’ll
    look at the two gems you need to add to your application’s *Gemfile*.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku’s servers use the PostgreSQL database server. Rather than install PostgreSQL
    locally, we used SQLite for development. You’ll need to ensure that the PostgreSQL
    gem, called simply pg, is installed in the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Heroku also requires the rails_12factor gem, which ensures that your application’s
    assets can be served by Heroku’s servers and that your application’s log files
    are sent to the correct place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the file *Gemfile* in the root of your Rails application and locate the
    line `gem ''sqlite3''`. You’ll use the PostgreSQL gem in production, but you still
    need the SQLite gem for development and testing, so update this line by adding
    `group: [:development, :test]` as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This instructs the `bundle` command to install this gem only in the development
    and test environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you need to install the pg and rails_12factor gems just mentioned. You
    only need these gems in the production environment, so add these next lines below
    the line you just updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once you’ve made these changes, save and close the *Gemfile*. Because you’ve
    changed your application’s *Gemfile*, run the `bundle` command again to update
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Because you’re running this command locally, where you develop and test your
    application, you don’t need to install production environment gems, so add the
    `--without production` flag. Bundler remembers flags passed to `bundle install`,
    so `--without production` is assumed every time you run the command from now on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you need to add and commit these changes to your Git repository. Enter
    these commands to update Git with your changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You could enter any message in place of *Update Gemfile for Heroku*, but commit
    messages are more helpful when they describe what you’ve changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, your account is set up, and your application is nearly ready to deploy.
    The last step is to create an application on Heroku:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This command ➊ creates a new application on Heroku’s servers with a randomly
    generated name. You could have specified a name after the `create` command, but
    the name must be unique. You can always change the name later if you want. The
    `create` command also ➋ sets up a Git remote named `heroku` for you automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Your Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Everything is ready now, so you can finally deploy your application. Use the
    `git push` command to push the current state of your master branch to Heroku:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Heroku recognizes this `git push` command and automatically detects that a Ruby
    on Rails application is being deployed, installs the production gems specified
    in your *Gemfile*, updates your application’s database configuration, precompiles
    your application’s assets, and launches your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you deploy any application for the first time, you also need to run database
    migrations to create the database tables needed by your application in Heroku’s
    database server. Use the `heroku run` command to execute the `rake db:migrate`
    command on Heroku’s server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If you make more database changes to your application, remember to commit the
    changes to the master branch in Git, push the master branch to Heroku, and run
    this command again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can open your web browser to the URL Heroku created for you earlier,
    or you can let Heroku handle that for you by entering this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Your default web browser should open and load your blog application automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Now that your application is set up on Heroku, you can deploy any time you want
    by committing changes to your Git repository and pushing the changes to Heroku.
  prefs: []
  type: TYPE_NORMAL
- en: Github
  prefs: []
  type: TYPE_NORMAL
- en: Any discussion of Git in a Rails book is incomplete without at least a mention
    of GitHub. *GitHub* is the number one source code host in the world. GitHub provides
    project management features such as wikis, issue tracking, and code review via
    pull requests.
  prefs: []
  type: TYPE_NORMAL
- en: The Rails community has embraced GitHub as the best place for collaborating
    on open-source software. Rails itself is hosted on GitHub at *[https://github.com/rails/rails/](https://github.com/rails/rails/)*.
    Sign up for a free account, if you don’t already have one, and join the community!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your blog is now safely stored in the Git distributed version control system.
    Changes to your source code are being tracked and can be easily undone. You blog
    is also available to the world via Heroku. Now you can deploy new features with
    a `git push` command.
  prefs: []
  type: TYPE_NORMAL
- en: Part I Remarks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter marks the end of the first part of this book. We’ve covered the
    fundamentals of Ruby and Rails. Models represent your application’s data; views
    are the user interface for your application; and controllers are the glue that
    holds them together. You’ll use these concepts to build any application you want.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the application you built in [Part I](pt01.html "Part I. Ruby on
    Rails Fundamentals"), you’ll find plenty of areas to improve. For example, anyone
    can edit or even delete posts on your blog. Also, what happens if you write thousands
    of posts? The index page will probably time out before it can display them all!
    You may not quite have the tools to fix those problems right now, but once you
    dive into [Part II](pt02.html "Part II. Building A Social Net Working App"), that
    will change.
  prefs: []
  type: TYPE_NORMAL
- en: In the next part of this book, we’ll build a new social network application
    and cover advanced topics such as more complex data modeling, authentication,
    testing, security, performance optimizations, and debugging.
  prefs: []
  type: TYPE_NORMAL
- en: After learning these concepts, you’ll be able to solve these problems with the
    blog and build a variety of other applications.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '| Q: | 1\. Practice making changes to your application, adding and committing
    those changes to your local Git repository, and then pushing the changes to Heroku.
    Many Rails developers deploy multiple times per day, so familiarize yourself with
    this process. |'
  prefs: []
  type: TYPE_TB
- en: '| Q: | 2\. Create an account on GitHub, learn how create a new repository on
    its servers, and push your application. GitHub has an online help area that walks
    you through the process if you have any trouble. Also, use GetHub’s Explore feature
    to see the repositories of popular projects on its servers. |'
  prefs: []
  type: TYPE_TB
- en: '| Q: | 3\. Finally, see if you can “scratch your own itch.” Create a simple
    Rails application based on one of your interests. Create a catalog of your favorite
    books, or maybe an application to track your vinyl collection. |'
  prefs: []
  type: TYPE_TB
