- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 16 DIGITAL SEARCH TREES
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 16 数字搜索树
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: In the previous four chapters, we explored different types of trees, including
    binary trees, general trees, heaps, and more. All of those trees are based on
    storing and comparing keys. With the digital search trees we’ll consider in this
    chapter, we won’t associate keys with nodes. Instead, the node’s position in the
    tree will define the key with which it is associated. In other words, you won’t
    store keys in a single place in the tree; they’ll be distributed across the whole
    structure, starting at the tree’s root. The leaves will mark where the keys end.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在前四章中，我们探索了不同类型的树，包括二叉树、普通树、堆等。所有这些树都是基于存储和比较键的。而在本章我们将要考虑的数字搜索树中，我们不会将键与节点关联。相反，节点在树中的位置将决定它所关联的键。换句话说，你不会将键存储在树的某个单一位置；它们会分布在整个结构中，从树的根部开始。叶子节点将标记键的结束位置。
- en: This might look like merely changing the way we work, in the same way that the
    radix sort changed the way we sorted ([Chapter 6](chapter6.xhtml)). With radix
    sort, instead of sorting by comparing keys, we worked with the keys character
    by character (or digit by digit, for numbers). With digital search trees, instead
    of storing and comparing keys, we’ll work with paths in trees.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能只是改变了我们的工作方式，就像基数排序改变了我们排序的方式一样（见[第6章](chapter6.xhtml)）。在基数排序中，我们不是通过比较键来排序，而是逐字符（或者逐位，对于数字）处理键。在数字搜索树中，我们不是存储和比较键，而是处理树中的路径。
- en: 'We’ll focus on three different data structures: *tries*, which can do searches
    in time proportional to a key’s length; *radix trees*, which are optimized versions
    of tries; and *ternary search tries*, an extension of binary search trees. These
    structures are particularly effective when we’re searching for strings, just as
    we search in a dictionary for words.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点关注三种不同的数据结构：*trie*，它能在与键长度成正比的时间内进行搜索；*基数树*，它是trie的优化版本；以及*三元搜索trie*，它是二叉搜索树的扩展。这些结构在我们搜索字符串时特别有效，就像我们在字典中查找单词一样。
- en: The Classic Version of Tries
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tries的经典版本
- en: Tries often are used simply to store words, allowing for easy, fast searches
    where users can enter a few letters, and words starting with those letters appear.
    Tries also are used as generic search trees where keys and data are stored and
    then a search is conducted for a key to provide the associated data.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Tries通常只是用来存储单词，允许用户快速且轻松地进行搜索，用户只需输入几个字母，以这些字母开头的单词就会显示出来。Tries也用作通用搜索树，存储键和值，然后对键进行搜索以提供相关数据。
- en: NOTE
  id: totrans-9
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Trie originally was pronounced like the word tree, but it’s also pronounced
    like the word try to distinguish it from tree. You can pronounce it either way.*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*Trie最初的发音与单词tree相似，但它也可以发音为try，以区别于tree。你可以选择任意一种发音。*'
- en: Think of tries as a bit like old telephone indexes that had a set of buttons,
    one for each letter. If you wanted to find a name starting with *F*, you’d press
    that key, and the index would open on the F page. The analogy doesn’t stop there.
    Assume the index had another set of buttons for the name’s second letter, and
    pressing that button led you to yet another page with a new set of buttons. If
    you clicked all the buttons in order, you’d arrive at the name you were looking
    for or an empty page, meaning the name wasn’t in the index. This analogy may be
    hard to understand (I wonder how many readers have ever seen such a phone index!
    Maybe think of how autocomplete works instead?), so let’s consider the actual
    definition of a trie.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将尝试视为有点像旧电话目录那样，目录上有一组按钮，每个字母对应一个按钮。如果你想查找以*F*开头的名字，你只需按下该按钮，目录就会打开F页。类比并不仅限于此。假设目录上有另一组按钮用于名字的第二个字母，按下这个按钮会带你到另一个页面，页面上有一组新的按钮。如果你按照顺序点击所有按钮，你将找到你想要的名字，或者看到一个空白页，意味着名字不在目录中。这个类比可能很难理解（我想知道有多少读者曾经见过这样的电话目录！也许可以考虑自动完成的工作方式？），所以让我们考虑一下trie的实际定义。
- en: A trie has a link for each possible character (the same way the previous phone
    index example has a button for each letter in a name), but for simplicity, we’ll
    work with only the letters from A to E, plus an end of word (EOW) character to
    indicate where each word ends. We’ll use ■ for this. (Other languages, such as
    C, use the NULL \0 character for EOW, but the square symbol is more visible.)
    Suppose the words are ACE, AD, BADE, BE, BED, and BEE. In the trie, you’ll actually
    see ACE■, AD■, and so on. This trie looks like the diagram in [Figure 16-1](chapter16.xhtml#fig16-1),
    and for clarity, I’ve placed the root on the left instead of at the top, so you
    can read the words horizontally.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 字典树有一个链接对应每个可能的字符（就像前面电话索引的例子一样，每个名字字母都有一个按钮），但为了简化，我们仅使用 A 到 E 字母，再加上一个表示单词结束的结束符（EOW）字符。我们用
    ■ 来表示这个符号。（其他语言，如 C，使用 NULL \0 字符作为 EOW，但方块符号更为显眼。）假设单词是 ACE、AD、BADE、BE、BED 和
    BEE。在字典树中，你会看到 ACE■、AD■ 等。这个字典树看起来像 [图 16-1](chapter16.xhtml#fig16-1)中的示意图，为了清晰起见，我将根节点放在左边，而不是在顶部，这样你可以水平阅读单词。
- en: '![](../images/Figure16-1.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure16-1.jpg)'
- en: 'Figure 16-1: A sample trie for words using only letters from A to E'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16-1：使用字母 A 到 E 的单词的字典树示例
- en: Each node in the trie consists of an array of links, one for each possible letter
    (A–E) plus the EOW character. (You could say it’s a six-ary tree; see [Chapter
    13](chapter13.xhtml).) The empty links have a white background in the diagram,
    and actual links have a gray background. Each word in a little box represents
    some extra data or value associated with the corresponding key (we’ll get to that
    in the next section).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 字典树中的每个节点由一个链接数组组成，每个可能的字母（A–E）加上结束符（EOW）字符都有一个链接。 （你可以说这是一个六叉树；参见 [第13章](chapter13.xhtml)）图中的空链接有白色背景，实际链接则有灰色背景。每个小框中的单词表示与相应键相关的额外数据或值（我们将在下一节中讨论）。
- en: 'You can define the basic functions to create a trie as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义基本函数来创建一个字典树，如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, define the EOW character; you’ll use the same definition throughout this
    chapter. The ALPHABET constant includes all the characters we’ll accept; for this
    example, you’re using only five letters, but for a real application, you’d most
    likely include at least the whole alphabet, A to Z. A new trie is just a null
    value, and a new node is an object with a links property, which is an array with
    one null link for each character in ALPHABET. Finally, to recognize an empty trie,
    simply check for “falsey” values on the last line.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，定义结束符（EOW）字符；你将在本章中使用相同的定义。ALPHABET 常量包括我们接受的所有字符；在这个例子中，你只使用了五个字母，但在实际应用中，你很可能会包括整个字母表，从
    A 到 Z。一个新的字典树只是一个空值，而一个新的节点是一个具有链接属性的对象，这个属性是一个数组，每个字符在 ALPHABET 中都有一个空链接。最后，为了识别空字典树，只需检查最后一行是否为“假值”。
- en: You can also associate some value with every key, as shown next.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将某些值与每个键关联，如下所示。
- en: Storing Extra Data in a Trie
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在字典树中存储额外的数据
- en: 'When we studied trees in previous chapters, we were concerned only with storing
    keys and searching for keys, because adding extra data was simple. Instead of
    a single key field, we could have a record with a key field and an extra data
    field. If we wanted to modify the algorithms to include extra fields, the changes
    were minor: searches would return the extra data instead of just a boolean value,
    and adding a key would also add the extra fields in the same object.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在前面的章节中研究树时，我们只关心存储键和查找键，因为添加额外的数据很简单。我们可以将记录替换成一个有键字段和额外数据字段的记录。如果我们想修改算法以包括额外的字段，变动也很小：搜索会返回额外的数据，而不仅仅是布尔值，添加键时也会在同一个对象中添加额外的字段。
- en: But in a trie, keys aren’t stored in a single place and instead are distributed
    throughout the trie’s branches. There is a solution to this, but because the changes
    needed in the algorithms aren’t so minor, we’ll work with keys plus data.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在字典树中，键不会存储在单一的位置，而是分布在字典树的各个分支中。对此有一个解决方案，但由于算法中所需的更改不那么简单，我们将处理键加数据的情况。
- en: The dictionary abstract data type (ADT) will change slightly, specifically the
    add and find operations, as shown in [Table 16-1](chapter16.xhtml#tab16-1).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 字典抽象数据类型（ADT）会略微变化，特别是添加和查找操作，如 [表 16-1](chapter16.xhtml#tab16-1)所示。
- en: 'Table 16-1: Operations on Tries'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16-1：字典树操作
- en: '| Operation | Signature | Description |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 签名 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Create | → D | Create a new dictionary. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | → D | 创建一个新的字典。 |'
- en: '| Empty? | D → boolean | Determine whether the dictionary is empty. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 空？ | D → 布尔值 | 判断字典是否为空。 |'
- en: '| Add | D × key × data → D | Given a new key and data, add them to the dictionary.
    |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
- en: '| Remove | D × key → D | Given a key, remove it from the dictionary. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
- en: '| Find | D × key → data &#124; null | Given a key, return its data or return
    null if not found. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
- en: As in other chapters, we’ll study the performance of the structures for this
    ADT. Now that we’ve defined the full structure for a trie and looked at how to
    create one, let’s consider the rest of the needed functions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Searching a Trie
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How do you look for a word? For example, if you want to know whether BED is
    a valid word, [Figure 16-2](chapter16.xhtml#fig16-2) shows the path you’d take.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-2.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-2: Searching successfully for BED in a trie'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: 'The search for BED starts at the root. You look at the B link and find it’s
    not null, so you follow it to the next level. There, you look at the E link and
    again follow it. The next step is similar: look at the D link and follow it. Finally,
    you arrive at the EOW, and finding a link to some data in the corresponding link,
    call it a successful search and return the found data.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: A failed search looks different. For example, if you want to find the word DAB,
    the search would fail at the beginning, since no word starts with D. What about
    ACED? This time, you’d start the search at the A link, then the C link, and finally
    the E link, but you’d arrive at a node with no D link, meaning ACED isn’t in the
    trie. [Figure 16-3](chapter16.xhtml#fig16-3) shows this failed search.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-3.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-3: Searching (unsuccessfully) for ACED in a trie'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Consider one last case and search for BAD. Remember, you’re adding an EOW character,
    so in reality, you’re trying to find BAD■. [Figure 16-4](chapter16.xhtml#fig16-4)
    shows what happens.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-4.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-4: Searching unsuccessfully for BAD: BADE is in the trie, but BAD
    isn’t.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: This search starts at the root and follows the B link first, then the A link,
    and then the D link. BAD is a prefix of at least one word, but the EOW link is
    missing, so BAD isn’t considered to be in the trie.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this logic, first create an auxiliary _find() function that actually
    does the searches:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The i variable ❶ selects the proper value from the links property, and now
    you’re ready to start searching. If the trie is empty (maybe it was empty from
    the beginning, or maybe you traveled down a null link), the search has obviously
    failed ❷. If you arrive at the end of the word (marked by the EOW character),
    do a simple test: if the corresponding link is null, the search fails as before;
    if not, the link points to an object with a data property, which you return ❸.
    Otherwise, if you haven’t yet reached a null link or the EOW character ❹, go down
    the right link and keep searching recursively.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'The find() function just calls the earlier _find(), but it adds the needed
    EOW character at the end of the string you’re trying to find:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Test for an empty word to find ❶, and if it’s empty, return null without any
    further ado.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 检查空单词以查找 ❶，如果为空，则直接返回 null，不做其他操作。
- en: Searching tries isn’t complex, and it’s similar to searches in other types of
    trees we looked at in previous chapters.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索 trie 并不复杂，类似于我们在前几章讨论过的其他树的搜索方式。
- en: Adding a Key to a Trie
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向 Trie 中添加一个键
- en: Adding a new key (plus data) to an existing trie follows the same strategy used
    for searches. Go down the links, letter by letter, and if the link exists, follow
    it, and if it doesn’t, add a new empty node. For instance, in the trie diagram
    shown in [Figure 16-5](chapter16.xhtml#fig16-5), if you want to add a BAD key,
    you just need to add a link at the last node with the data.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 向现有的 trie 中添加新键（及数据）遵循与搜索相同的策略。逐字查找链接，如果链接存在，就跟随它；如果不存在，就添加一个新的空节点。例如，在 [Figure
    16-5](chapter16.xhtml#fig16-5) 中的 trie 图示，如果你想添加一个 BAD 键，只需在最后一个节点添加一个指向数据的链接。
- en: '![](../images/Figure16-5.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure16-5.jpg)'
- en: 'Figure 16-5: Adding BAD to a trie'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 16-5: 向 trie 添加 BAD'
- en: The only change in the trie is that the (so far) empty EOW link now points to
    the data associated with the BAD key.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: trie 中唯一的变化是（到目前为止）空的 EOW 链接现在指向与 BAD 键关联的数据。
- en: As another example, to add ABE, you would start by following the A link at the
    root, but then you’d need to add two new nodes, as shown in [Figure 16-6](chapter16.xhtml#fig16-6).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，想要添加 ABE，你需要从根节点开始，跟随 A 的链接，但随后需要添加两个新节点，如 [Figure 16-6](chapter16.xhtml#fig16-6)
    所示。
- en: '![](../images/Figure16-7.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure16-7.jpg)'
- en: 'Figure 16-6: Adding ABE to the trie requires new nodes.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 16-6: 向 trie 添加 ABE 需要新节点。'
- en: 'The code for this addition is similar to other insertion functions we’ve discussed
    in previous chapters:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个添加操作的代码与我们在前几章讨论的其他插入函数类似：
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: An _add() auxiliary function ❶ actually does the insertion. While you haven’t
    reached the end of the string (including the added EOW) ❷, advance, following
    the links corresponding to successive letters. If you find an empty link ❸, create
    a new node and keep advancing until you reach the EOW character. At each step,
    decide what link to follow ❹, and when you reach the EOW, add a link to the extra
    data ❺; otherwise, recursively keep adding the rest of the string ❻.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 _add() 辅助函数 ❶ 实际上执行插入操作。当你还没有到达字符串的结尾（包括已添加的 EOW）❷时，继续前进，按照连续字母的链接进行跟踪。如果找到一个空链接
    ❸，则创建一个新节点并继续前进，直到到达 EOW 字符。在每一步，决定跟随哪个链接 ❹，当到达 EOW 时，添加指向额外数据的链接 ❺；否则，递归地继续添加剩余的字符串
    ❻。
- en: 'Finally, the add() function just invokes _add():'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，add() 函数只调用 _add()：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This function also ensures that the EOW character is added.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数还确保添加了 EOW 字符。
- en: Removing a Key from a Trie
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从 Trie 中删除一个键
- en: Now we’ll look at deleting a key, which is a bit more complex than adding keys
    to a trie. First, try to find the key; if you can’t find it, you’re finished,
    since there’s nothing else to do. If you find the key (and arrived at an EOW character),
    just delete the associated data, making the pointer null. If doing that left the
    current node empty of pointers, then delete the node and fix the parent’s pointer,
    which may again leave an all-empty node, so keep going up, back to the root, possibly
    deleting more nodes on the way.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看删除一个键，这比向 Trie 中添加键要复杂一些。首先，尝试查找该键；如果找不到，就结束了，因为没有其他事情可做。如果找到了该键（并且到达了
    EOW 字符），只需删除关联的数据，将指针设为 null。如果这样做后当前节点没有指针了，就删除该节点并修正父节点的指针，这可能又会导致父节点成为空节点，因此继续向上遍历，直到根节点，途中可能会删除更多节点。
- en: Let’s consider a few cases. Returning to the example trie, if you want to delete
    BE, you’d clear its EOW link as shown in [Figure 16-7](chapter16.xhtml#fig16-7),
    and you’d be done.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑几个情况。返回到示例 trie，如果你想删除 BE，你只需清除其 EOW 链接，如 [Figure 16-7](chapter16.xhtml#fig16-7)
    所示，完成删除。
- en: '![](../images/Figure16-8.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure16-8.jpg)'
- en: 'Figure 16-7: Deleting BE from the trie'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 16-7: 从 trie 中删除 BE'
- en: To make it more difficult, after deleting BE, what if you want to delete BADE?
    First you clear the EOW link, but then the whole node has only null links, as
    shown in [Figure 16-8](chapter16.xhtml#fig16-8).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加难度，在删除 BE 后，如果你想删除 BADE，首先清除 EOW 链接，但此时整个节点仅包含 null 链接，如 [Figure 16-8](chapter16.xhtml#fig16-8)
    所示。
- en: '![](../images/Figure16-6.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure16-6.jpg)'
- en: 'Figure 16-8: Deleting BADE implies removing several (now empty) nodes from
    the trie.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 'Figure 16-8: 删除 BADE 意味着从 trie 中移除几个（现在为空的）节点。'
- en: However, removing that node (and clearing the E link at its parent) repeats
    the situation, so you also delete the parent, and then the parent’s parent, until
    you arrive at a not all-empty node. The final situation looks like [Figure 16-9](chapter16.xhtml#fig16-9).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，删除该节点（并清除其父节点的 E 链接）会重复相同的情况，因此你还需要删除父节点，然后删除父节点的父节点，直到遇到一个非空节点。最终的情况如[图
    16-9](chapter16.xhtml#fig16-9)所示。
- en: '![](../images/Figure16-9.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure16-9.jpg)'
- en: 'Figure 16-9: The final trie after removing BADE'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16-9：删除 BADE 后的最终字典树
- en: 'As with searching and adding, you need an auxiliary function to implement this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与搜索和添加类似，你需要一个辅助函数来实现这一点：
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The _remove() function does the actual removal ❶. You search, link by link,
    and when you reach a null link, you know you’re done ❷. If you reach the end of
    the word (past the EOW character), set the current link to null ❸. If you’re still
    in the middle of the word, decide what link to follow ❹. Then recursively remove
    the rest of the word ❺ and do a final check to see whether the node is totally
    empty (all null), in which case, you also set the node to null ❻. At the end,
    just return the modified trie ❼.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: _remove() 函数执行实际的删除操作 ❶。你逐一搜索，每当你遇到一个空链接时，就知道操作完成 ❷。如果到达单词的末尾（越过 EOW 字符），将当前链接设为
    null ❸。如果你仍在单词中间，决定接下来应该跟随哪个链接 ❹。然后递归地删除剩余的单词 ❺，并做最后检查，看该节点是否完全为空（全部为 null），如果是的话，你也将该节点设为
    null ❻。最后，只需返回修改后的字典树 ❼。
- en: 'The final code you need is the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要的最终代码如下：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The remove() function just calls _remove(), and it adds the needed EOW character
    to the string you want to remove.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: remove() 函数仅调用 _remove()，并将需要的 EOW 字符添加到你想要删除的字符串中。
- en: Considering Performance for Tries
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 考虑字典树的性能
- en: How do the different operations perform? [Table 16-2](chapter16.xhtml#tab16-2)
    is almost the simplest table in this book; can you see why?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 不同操作的性能如何？[表 16-2](chapter16.xhtml#tab16-2)几乎是本书中最简单的表格，你能看出为什么吗？
- en: 'Table 16-2: Performance of Operations for Tries'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 表 16-2：字典树操作的性能
- en: '| Operation | Performance |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 性能 |'
- en: '| --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Create | O(1) |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | O(1) |'
- en: '| Empty? | O(1) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 为空？ | O(1) |'
- en: '| Add | O(k) |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 添加 | O(k) |'
- en: '| Remove | O(k) |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | O(k) |'
- en: '| Find | O(k) |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 查找 | O(k) |'
- en: Creating a trie and checking whether it’s empty are *O*(1) constant operations.
    And, given the structure, if keys are *k* characters long, all the other operations
    take (at most) *k* steps, which is the maximum height of a trie with such keys—excellent
    constant results! Note that the *O*(*k*) performance, with constant *k*, should
    be written as *O*(1). I wrote it as *O*(*k*) here just as a reminder that *k*
    steps will be taken, but in performance terms, any constant implies *O*(1).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建字典树并检查它是否为空是 *O*(1) 的常数操作。并且，根据该结构，如果键长为 *k* 个字符，所有其他操作最多需要 *k* 步，这就是具有该键的字典树的最大高度——非常优秀的常数结果！请注意，*O*(*k*)
    性能在 *k* 为常数时应该写作 *O*(1)。我在这里将其写为 *O*(*k*)，只是为了提醒你需要执行 *k* 步，但在性能上，任何常数都意味着 *O*(1)。
- en: However, despite having a very good performance, notice that this structure
    is quite wasteful. All the nodes have many links (as many characters as possible
    in the keys), making for a lot of unused space. Even worse with this structure,
    if you want to distinguish between uppercase and lowercase characters, or deal
    with the entire alphabet, or store words in foreign languages, the space requirements
    for nodes will grow wildly, because of the many links that each node will require.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管这种结构有着非常好的性能，但需要注意的是，这种结构相当浪费空间。所有节点都有许多链接（每个键中尽可能多的字符），导致大量未使用的空间。如果你需要区分大写和小写字符，或处理整个字母表，或存储外语单词，由于每个节点需要的许多链接，节点的空间需求将急剧增加。
- en: This situation isn’t quite favorable, so let’s consider another approach to
    tries and aim for a more modern (and less wasteful) implementation, which JavaScript
    fortunately lets you do easily.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况并不理想，因此让我们考虑另一种字典树的方法，旨在实现一个更现代（且更节省空间）的实现，幸运的是，JavaScript 可以轻松实现这一点。
- en: An Enhanced Version of Tries
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典树的增强版
- en: Consider again how to represent a trie. At each node, you need a link for each
    character in a string, but if only a few of those characters are actually necessary,
    you don’t need to waste space for the rest. In fact, it sounds like you need some
    kind of set here, and that’s indeed the solution.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑如何表示字典树。在每个节点中，你需要为字符串中的每个字符创建一个链接，但如果只有少数字符实际上是必需的，就不需要为其余部分浪费空间。实际上，这听起来你需要某种集合，而这正是解决方案。
- en: If you have a large varying number of possible links, you should use some of
    the structures discussed in [Chapter 13](chapter13.xhtml). However, because alphabets
    are limited, you can use an object with characters for keys and links for values.
    (For yet another solution, see question 16.1.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有大量不同的可能链接，你应该使用[第13章](chapter13.xhtml)中讨论的一些结构。然而，由于字母表是有限的，你可以使用一个以字符为键、以链接为值的对象。（有关另一种解决方案，请参见问题16.1。）
- en: With the same six strings as in the previous trie (ACE, AD, BADE, BE, BED, and
    BEE), the structure looks like [Figure 16-10](chapter16.xhtml#fig16-10).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与前面字典树相同的六个字符串（ACE、AD、BADE、BE、BED和BEE），结构如[图16-10](chapter16.xhtml#fig16-10)所示。
- en: '![](../images/Figure16-10.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure16-10.jpg)'
- en: 'Figure 16-10: An enhanced object-based version of a trie with fewer links'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-10：具有更少链接的增强型基于对象的字典树
- en: The main difference is now the nodes can be much smaller, including only the
    strictly necessary links and nothing more.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于现在的节点可以小得多，只包含严格必要的链接，没有其他内容。
- en: Defining an Object-Based Trie
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义基于对象的字典树
- en: 'Instead of having an array of links, you can define this new style of space-saving
    tries using an object:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用一个链接数组，你可以使用对象来定义这种节省空间的新型字典树：
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You need to make only one simple change from the previous trie (shown in bold):
    a new node now has an object named links instead of an array with that name.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要对之前的字典树做一个简单的修改（以粗体显示）：现在一个新节点有一个名为links的对象，而不是一个同名的数组。
- en: Searching an Object-Based Trie
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 搜索基于对象的字典树
- en: 'The process for searching an object-based trie for a key is similar to searching
    a classic trie: start at the root and follow the links that correspond to each
    character in the string, one by one. Instead of an array with links to all possible
    characters, you have an object with only the links actually required. For instance,
    revisit the BED search in [Figure 16-11](chapter16.xhtml#fig16-11).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索基于对象的字典树的过程类似于搜索经典的字典树：从根节点开始，逐个跟随与字符串中每个字符对应的链接。不同的是，你不是使用一个包含所有可能字符链接的数组，而是使用一个仅包含实际需要链接的对象。例如，重新访问[图16-11](chapter16.xhtml#fig16-11)中的BED搜索。
- en: '![](../images/Figure16-11.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure16-11.jpg)'
- en: 'Figure 16-11: Searching successfully for BED in an object-based trie'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-11：在基于对象的字典树中成功搜索BED
- en: Starting at the root in the links object, follow the B link. At the next node,
    follow the E link, and so on, until reaching the EOW link. Then you know the key
    was found and can return the associated data, whatever it is.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从links对象中的根节点开始，跟随B链接。到达下一个节点后，跟随E链接，依此类推，直到到达EOW链接。然后，你知道键已找到，可以返回相关数据，无论它是什么。
- en: Try redoing a failed search as well, as shown in [Figure 16-12](chapter16.xhtml#fig16-12).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 试着重新执行一个失败的搜索，如[图16-12](chapter16.xhtml#fig16-12)所示。
- en: '![](../images/Figure16-12.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure16-12.jpg)'
- en: 'Figure 16-12: Searching unsuccessfully for ACED in an object-based trie'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-12：在基于对象的字典树中搜索ACED失败
- en: If you search for ACED, the process stops after following the last E link. The
    node you arrive at doesn’t have a D link, so you can’t proceed, as the key you
    want isn’t in the trie.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你搜索ACED，过程会在跟随到最后一个E链接后停止。你到达的节点没有D链接，因此无法继续，因为你想要的键不在字典树中。
- en: 'Searching object-based tries isn’t really different from searching the original
    tries; the only change is how you choose the link to follow. The following logic
    shows the needed changes:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索基于对象的字典树并不真的与搜索原始字典树有所不同；唯一的变化是如何选择要跟随的链接。以下逻辑展示了所需的变化：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In comparison with the original trie search code, you have only two changes
    (shown in bold): you can access the needed link directly without having to check
    the alphabet first—for example, the link for the letter A is at links.A, (or,
    equivalently, links["A"]) with no further ado. The find() function itself is exactly
    the same as with the original tries.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始字典树的搜索代码相比，你只有两个变化（以粗体显示）：你可以直接访问所需的链接，而无需首先检查字母表—例如，字母A的链接是links.A，（或者，等价地，links["A"]），无需多做其他操作。find()函数本身与原始字典树中的完全相同。
- en: Adding a Key to an Object-Based Trie
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 向基于对象的字典树添加一个键
- en: Adding a key is also similar to the algorithm for the original tries. The changes
    you need to make work like those you made for searching. For instance, consider
    adding ABE, as shown in [Figure 16-13](chapter16.xhtml#fig16-13).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个键的过程也与原始字典树的算法类似。你需要做的修改与搜索时的修改类似。例如，考虑添加ABE，如[图16-13](chapter16.xhtml#fig16-13)所示。
- en: '![](../images/Figure16-13.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure16-13.jpg)'
- en: 'Figure 16-13: Adding ABE to an object-based trie'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-13：向基于对象的字典树添加ABE
- en: Start following links as you did with the search, and when links don’t appear,
    add them. In this case, the root already has an A link, so you follow it. The
    next node has no B link, so add it to the existing (C and D) links. From that
    point onward, start adding new nodes to the trie.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 像查找时一样开始跟踪链接，当链接不存在时，添加它们。在这个情况下，根节点已经有一个 A 链接，所以你跟踪它。下一个节点没有 B 链接，因此将其添加到现有的（C
    和 D）链接中。从那时起，开始向 trie 中添加新节点。
- en: 'It’s the same process as for the original tries; here’s the new logic:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程与原始 trie 相同；以下是新的逻辑：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Again, the only difference in the logic from the original tries is that you
    always know what link to use for a given character, so you don’t need to search
    the ALPHABET array (shown in bold).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始尝试的逻辑唯一区别是，你总是知道针对给定字符应该使用哪个链接，因此你不需要搜索 ALPHABET 数组（以**粗体**显示）。
- en: Removing a Key from an Object-Based Trie
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从基于对象的 trie 中移除一个键
- en: Finally, removing a key is also similar to the previous code for original tries,
    but deciding whether the node is empty requires a different approach. For example,
    if you want to remove BADE from the original trie, you’ll get the result shown
    in [Figure 16-14](chapter16.xhtml#fig16-14).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，移除一个键的过程与原始 trie 中的代码相似，但决定节点是否为空需要不同的方法。例如，如果你想从原始 trie 中删除 BADE，你将得到 [图
    16-14](chapter16.xhtml#fig16-14) 中显示的结果。
- en: '![](../images/Figure16-14.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure16-14.jpg)'
- en: 'Figure 16-14: Removing BADE from an object-based trie'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16-14：从基于对象的 trie 中移除 BADE
- en: 'As with the previous array-based trie implementation, when nodes become empty,
    you delete them. The updated logic is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的基于数组的 trie 实现一样，当节点变为空时，你会将其删除。更新后的逻辑如下：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Most of the differences with the logic for original tries ❶ ❷ are directly related
    to knowing what link to use, but in order to decide whether a node became empty,
    you need to see how many keys the links object has ❸.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与原始尝试 ❶ ❷ 的逻辑相比，大部分差异直接与知道使用哪个链接相关，但为了决定一个节点是否为空，你需要查看链接对象中有多少个键 ❸。
- en: Considering Performance for Object-Based Tries
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 考虑基于对象的 trie 性能
- en: 'What changes with this new version of a trie? Performance is exactly the same
    as for the array-based tries; the only difference is the amount of memory needed.
    Think of it this way: if you were using a trie for a dictionary of European languages
    (with all the tildes, accents, and special characters, like the Danish å, or the
    Czech eˇ, or the German ß), you would need an array with more than 200 links in
    each node, although most of them would be empty. Using an object saves a lot of
    space, which could be important in some cases.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新版本的 trie 有什么变化？性能与基于数组的 trie 完全相同；唯一的区别是所需的内存量。可以这样理解：如果你使用一个 trie 来表示包含所有重音符号、变音符号和特殊字符的欧洲语言字典（如丹麦语的
    å，捷克语的 eˇ，或德语的 ß），你将需要一个每个节点包含超过 200 个链接的数组，尽管大部分链接是空的。使用对象节省了大量空间，这在某些情况下可能很重要。
- en: However, using objects instead of arrays isn’t as efficient as it could be.
    After all, if the keys are long, you still need a very tall trie. As a border
    case, imagine having a trie with a single key that’s 20 characters long. You’d
    have a 20-level-high tree for one single key. Radix trees provide an enhanced
    solution.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用对象代替数组并不像想象中那样高效。毕竟，如果键很长，你仍然需要一个非常高的 trie。作为一个边界情况，假设有一个只包含一个 20 个字符长的键的
    trie。你将拥有一个 20 层高的树，只有一个键。基数树提供了一种改进的解决方案。
- en: Radix Trees
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基数树
- en: Both the tries so far work well, but they have many levels. For instance, when
    looking for BADE in the example trie, you have to go down one level for each letter,
    while there are no other words that start with A; see [Figure 16-15](chapter16.xhtml#fig16-15).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的两个 trie 都表现良好，但它们有很多层。例如，在示例 trie 中查找 BADE 时，你需要逐层向下搜索每个字母，而没有其他以 A 开头的单词；请参见
    [图 16-15](chapter16.xhtml#fig16-15)。
- en: '![](../images/Figure16-15.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure16-15.jpg)'
- en: 'Figure 16-15: Searching successfully for BADE in a trie requires many steps.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16-15：在 trie 中成功查找 BADE 需要许多步骤。
- en: The idea for radix trees is that if any level has a single link, we “push it
    up” and join it with its parent link to shorten future searches. [Figure 16-16](chapter16.xhtml#fig16-16)
    shows what a radix tree for the ACE, AD, BADE, BE, BED, and BEE sets of words
    looks like.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 基数树的想法是，如果某一层只有一个链接，我们就“将其推上去”并与父链接合并，以缩短未来的搜索时间。[图 16-16](chapter16.xhtml#fig16-16)
    显示了 ACE、AD、BADE、BE、BED 和 BEE 这些单词集合的基数树样式。
- en: '![](../images/Figure16-16.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure16-16.jpg)'
- en: 'Figure 16-16: A radix tree shortens searches by joining links.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 16-16：基数树通过连接链接来缩短搜索时间。
- en: Now, you would have found BADE in just two steps. This tree is shorter than
    all previous tries. Some paths (for example, B to E to BE) are still the same
    length, but most others are shorter, because some levels have multicharacter links.
    Let’s explore how these trees would be defined and used, because they’ll represent
    a more performant kind of digital tree.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你只需要两步就能找到BADE。这个树比之前的所有字典树都要短。一些路径（例如，从B到E到BE）仍然是相同的长度，但大多数路径更短，因为某些层次有多字符的链接。让我们来探讨这些树是如何定义和使用的，因为它们代表了一种更高效的数字树。
- en: Defining a Radix Tree
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义基数树
- en: 'If you use an object to store links, like you did with the object-based tries,
    you find that the logic for radix trees is exactly the same. The difference is
    in *how* you use the links (they won’t always be single-character links), but
    otherwise the structure is the same:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用对象来存储链接，就像在基于对象的字典树中那样，你会发现基数树的逻辑与之前完全相同。区别在于*如何*使用链接（它们不总是单字符链接），但结构是一样的：
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since there are no changes here with regard to the previous object-based tries
    code, let’s move on to working with these new trees.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于与之前的基于对象的字典树代码没有变化，我们继续处理这些新的树。
- en: Searching a Radix Tree
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 搜索基数树
- en: 'Doing searches is similar to what you did for object-based tries, but now that
    the links may correspond to many characters, you need to work a bit differently.
    Start with a simple case: searching for BED—or, more precisely, BED■. [Figure
    16-17](chapter16.xhtml#fig16-17) shows the path to follow.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 执行搜索与之前在基于对象的字典树中的操作类似，但由于链接可能对应多个字符，你需要稍作不同的处理。首先考虑一个简单的情况：搜索BED——或者更准确地说，搜索BED■。[图16-17](chapter16.xhtml#fig16-17)显示了要遵循的路径。
- en: '![](../images/Figure16-17.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure16-17.jpg)'
- en: 'Figure 16-17: Searching successfully for BED in a radix tree'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-17：在基数树中成功搜索BED
- en: At the root, you need to find a link that is a prefix of BED■. In this case,
    follow a B link to the next level. (If you don’t find such a link, declare the
    search unsuccessful right then.) Since you followed a B link, next search for
    ED■. Again, you find a link that matches the search and follow that E link to
    the third level, where you look for D■. At this point, you find a complete match,
    so you found the key and can return its data. You’re done!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在根节点，你需要找到一个BED■的前缀链接。在这种情况下，跟随B链接进入下一层。（如果你没有找到这样的链接，就立即声明搜索失败。）由于你跟随了B链接，接下来要搜索ED■。同样，你会找到一个与搜索匹配的链接，并跟随那个E链接进入第三层，在那里你查找D■。此时，你找到了完整的匹配，因此找到了键并可以返回它的数据。完成！
- en: As another example, look for ACED■, which will be a failed search (see [Figure
    16-18](chapter16.xhtml#fig16-18)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子，搜索ACED■，这将是一个失败的搜索（见[图16-18](chapter16.xhtml#fig16-18)）。
- en: '![](../images/Figure16-18.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure16-18.jpg)'
- en: 'Figure 16-18: Searching unsuccessfully for ACED in a radix tree'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-18：在基数树中未能成功搜索ACED
- en: What happens here? At the first level, you find an A link to follow, so you
    then look for CED■ at the second level. However, you don’t find any link that
    has the search string’s prefix, you fail. If you were searching for CAB■, you’d
    have the same problem, but at the root, because no link has a prefix with that
    string.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？在第一层，你找到了一个A链接可以跟随，于是你在第二层寻找CED■。然而，你没有找到任何具有搜索字符串前缀的链接，搜索失败。如果你在搜索CAB■，你也会遇到同样的问题，但这是在根节点，因为没有任何链接的前缀包含该字符串。
- en: The idea is that you move down the tree, level by level, matching prefixes to
    links. Given two strings, you first need an auxiliary function to find how many
    characters they have in common from the start. For example, if you have BEE and
    BADE, you’d have only one character in common (B). If you have ACED and ACAD,
    you’d have two characters in common (the initial AC characters).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 其基本思路是，逐层向下遍历树，匹配前缀与链接。给定两个字符串，你首先需要一个辅助函数来找出它们从开头起有多少个字符是相同的。例如，如果你有BEE和BADE，它们只有一个字符是相同的（B）。如果你有ACED和ACAD，它们有两个字符是相同的（最初的AC字符）。
- en: 'The auxiliary function looks like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助函数如下所示：
- en: '[PRE12]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Start by comparing characters from the beginning ❶ and count ❷ until the strings
    end or stop matching.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从开始处比较字符❶并计数❷，直到字符串结束或不再匹配。
- en: 'With this function, you can start searching:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数，你就可以开始搜索：
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the tree is empty, the key obviously can’t be there ❶. To see whether a link
    is a prefix of the search key, first find the (only) object key that matches the
    first character ❷, because you can’t have two or more keys with the same initial
    character in a node (it would break the structure). If you find such a link ❸,
    check whether it actually has the complete string you need ❹; if so, you’re done.
    If the link doesn’t match the whole string, find the common prefix ❺ and recursively
    search for the rest of the string ❻. On the other hand, if you don’t find a link
    matching the initial character of the string, the search fails ❼.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果树为空，显然键不可能在那里 ❶。为了查看一个链接是否是搜索键的前缀，首先找到与第一个字符匹配的（唯一）对象键 ❷，因为在一个节点中不能有两个或多个键具有相同的初始字符（这会破坏结构）。如果找到这样的链接
    ❸，检查它是否确实包含你需要的完整字符串 ❹；如果是，那么操作完成。如果链接与整个字符串不匹配，找到公共前缀 ❺ 并递归搜索其余的字符串 ❻。另一方面，如果没有找到与字符串的初始字符匹配的链接，搜索失败
    ❼。
- en: 'The main find() function is the same as with object-based tries:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的find()函数与基于对象的尝试相同：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The logic for searching radix tries is similar to the logic used for tries,
    except matching links is a bit more complex.  #### Adding a Key to a Radix Tree'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 基数树的搜索逻辑与尝试树的搜索逻辑类似，只是匹配链接要复杂一些。#### 向基数树中添加一个键
- en: 'The problem with adding new keys to radix trees is if there’s some previously
    added key that matches part of the key you want to add. Start with a simple case:
    adding ABE■ as with the original radix tree (see [Figure 16-19](chapter16.xhtml#fig16-19)).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 向基数树中添加新键的问题是，如果之前已经添加的键与你想要添加的键的部分匹配。我们从一个简单的情况开始：像原始基数树一样添加ABE■（见[图16-19](chapter16.xhtml#fig16-19)）。
- en: '![](../images/Figure16-19.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure16-19.jpg)'
- en: 'Figure 16-19: Adding ABE to a radix tree: initial structure'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-19：将ABE添加到基数树：初始结构
- en: First, search for the string as shown in the previous section, and after following
    the A link, you arrive at a node with no links matching the BE■ prefix. This means
    you simply can stop searching right here and add the new link in that place.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，按前一节所示搜索字符串，在跟随A链接之后，你到达一个没有匹配BE■前缀的节点。这意味着你可以在这里停止搜索，并在该位置添加新的链接。
- en: '[Figure 16-20](chapter16.xhtml#fig16-20) shows the more complex case of adding
    BAD to the tree updated in [Figure 16-19](chapter16.xhtml#fig16-19).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16-20](chapter16.xhtml#fig16-20)展示了将BAD添加到在[图16-19](chapter16.xhtml#fig16-19)中更新的树的更复杂情况。'
- en: '![](../images/Figure16-20.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure16-20.jpg)'
- en: 'Figure 16-20: Adding BAD to a radix tree requires splitting some links.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图16-20：将BAD添加到基数树需要拆分一些链接。
- en: 'The difference here is that after following the B link, you find there already
    was a partial match (ADE■), so now you need to do a split: the common prefix (AD)
    remains in the node, and you create a new node with the rest of the keys.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的不同之处在于，在跟随B链接之后，你会发现已经有一个部分匹配（ADE■），因此现在需要进行拆分：公共前缀（AD）保留在节点中，并创建一个新节点，包含其余的键。
- en: 'The logic thus needs to deal with two cases: not finding a prefix (as with
    ABE) or finding a partial match (as with BADE). Here’s the code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，逻辑需要处理两种情况：未找到前缀（如ABE）或找到部分匹配（如BADE）。以下是代码：
- en: '[PRE15]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: First check whether you are adding a nonempty string ❶; if not, return the trie
    unchanged ❾. If you have a string to insert, check whether the tree is empty ❷,
    because if it’s empty, create a new node with the single key, and you are done.
    If the tree isn’t empty, search for an existing key that matches at least the
    first character ❸ (as shown previously). If you don’t find one, create a new node
    ❽; otherwise, check whether the found key matches what you’re inserting in full
    or in part ❹ by splitting the key according to the common length you found. If
    the match is in full ❺, follow the link to insert the rest of the string; otherwise
    ❻, do a split, leaving the common prefix in the node by adding a new node and
    deleting the old key ❼.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先检查是否添加一个非空字符串 ❶；如果不是，返回未更改的trie ❾。如果你有一个字符串需要插入，检查树是否为空 ❷，因为如果为空，创建一个包含单个键的新节点，操作完成。如果树不为空，搜索是否有一个现有的键至少匹配第一个字符
    ❸（如前所示）。如果没有找到，创建一个新节点 ❽；否则，检查找到的键是否完全或部分匹配你正在插入的内容 ❹，根据你找到的公共长度拆分键。如果完全匹配 ❺，跟随链接插入剩余的字符串；否则
    ❻，进行拆分，将公共前缀留在节点中，通过添加一个新节点并删除旧键 ❼。
- en: 'The rest of the logic is the same as for the other tries:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的逻辑与其他尝试相同：
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You have now seen how to add a new key, which had two distinct cases; now see
    what happens with the reverse algorithm to remove a key from a radix tree.  ####
    Removing a Key from a Radix Tree'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with the same radix tree that was updated in [Figure 16-20](chapter16.xhtml#fig16-20),
    consider two cases for removing keys: removing a link from a node, leaving it
    with two or more links, and removing a link from a node, leaving it with a single
    link. Take a look at the simpler former case first ([Figure 16-21](chapter16.xhtml#fig16-21)).'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-21.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-21: The radix tree from which you’ll remove ACE'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: To remove ACE from the radix tree, search for it, and when you arrive at the
    final link, simply remove it. The tree would look like [Figure 16-22](chapter16.xhtml#fig16-22).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-22.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-22: Removing ACE requires removing only a link.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: However, what if you want to remove BADE? Remember, if you have a single link,
    you need to join it with the parent link, as shown in [Figure 16-23](chapter16.xhtml#fig16-23).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-23.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-23: Removing BADE requires more work.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: After searching for BADE and removing the last link (E■), the final node ended
    up with only an EOW link. You then push it up so that it joins with its parent,
    which is an AD link. Doing this reverses the kind of split you did when adding
    new keys.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the actual logic. You need an auxiliary _remove() function, as in
    the other cases, to remove the desired key:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Start by checking whether you’re done, which means reaching an empty link or
    the end of the word you’re removing ❶. If you aren’t finished, search for a link
    that has a common prefix with the word you’re removing ❷ as described earlier.
    If you don’t find one, you’re also done, because the word you’re removing isn’t
    in the trie. If you find a suitable prefix ❸, you have two possibilities: you’ve
    found the whole word or part of the word. In the former case ❹, delete the link;
    no more work is needed. In the latter case ❺, search for and remove the rest of
    the word, discounting the prefix already found (you’ll do this recursively). After
    that, check whether the trie ended with a single key ❻, in which case, join its
    only key with the prefix you found. Finally, return the updated trie ❼.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'With this function out of the way, you can code the remove() function:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the trie isn’t empty ❶, use the auxiliary function to remove the key from
    the tree ❷ and then a final check remains: if the root became empty ❸, the trie
    is null.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Considering Performance for Radix Trees
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Radix trees are like “compressed” versions of tries. They’re faster when nodes
    include longer strings, and at worst, they behave the same way as tries if all
    links are “single-character” links. This means you don’t need to do much analysis.
    [Table 16-3](chapter16.xhtml#tab16-3) shows the performance.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 16-3: Performance of Operations for Radix Trees'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Performance |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| Empty? | O(1) |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: '| Add | O(1) |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
- en: '| Remove | O(1) |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
- en: '| Find | O(1) |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
- en: 'The results for radix trees are the same as for tries: all operations are *O*(1).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Ternary Search Tries
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tries and radix trees are based on the idea of storing keys “down the links.”
    You can also apply this idea to *ternary trees*, a new structure that saves space
    and provides good performance. We mentioned ternary trees in [Chapter 13](chapter13.xhtml),
    as a generalization of binary trees having three links at each node instead of
    two, but we didn’t actually work with them. The idea is that with a ternary search
    tree, each node has a key (a single character) and three links:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: The left link is for strings whose current character is less than the node key.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The middle link is for strings whose current character is equal to the node
    key.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The right link is for strings whose current character is greater than the node
    key.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 16-24](chapter16.xhtml#fig16-24) shows a ternary search tree.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-24.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-24: A ternary search tree with seven words'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Try to follow the path to every word; you’ll then understand the difference
    between the middle links and the right and left links. The following sections
    explain this in detail.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Defining Ternary Tries
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve already considered binary search trees, and defining a ternary tree is
    similar. All you need to do is add a middle link:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Creating ternary trees is quite simple, but storing extra data and doing searches
    require some changes.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Storing Extra Data in a Ternary Trie
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With ternary tries, you have the same issue as with other common trees. You
    could store extra data next to the key, but again you have the problem that keys
    aren’t stored in any single place, as they are with search trees; the keys are
    spread all over the trie.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'To alleviate this complication, reapply the solution used for tries. When you
    reach the EOW character, use its middle pointer to store extra data:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Of course, if you’re using the ternary trie just to store the keys and don’t
    care about extra data (for example, if you were using a ternary trie to look up
    words to see whether they exist in a Scrabble application to check a weird-looking
    word your opponent entered), you can omit that line and modify the search function
    (which you’ll look at next) to return only true or false.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Searching a Ternary Trie
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Given how we designed ternary tries, it should be no surprise that searching
    for a key in a ternary trie is similar to the logic for binary search trees (see
    [Chapter 12](chapter12.xhtml)). As an example, [Figure 16-25](chapter16.xhtml#fig16-25)
    shows how to look for the word AD (you’ll actually search for AD■, with the appended
    EOW character).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-25.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-25: Searching successfully for AD in a ternary trie'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: The search starts at the root, which has a B. Since A (the first letter in AD■)
    is less than B, follow the left link. Then you find an A, so go down the middle
    link, looking for the rest of the string, which is D■. You find a C, so go down
    the right link. Then you find a D, so now go down the middle, looking for the
    EOW character. After finding it, successfully return the associated data.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: If you had been looking for ADD instead, you’d have found an empty link after
    the first D, so the search would have been a failure.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, the ternary trie search process is similar to that
    of binary search trees. The logic is as follows, and as with other cases, an auxiliary
    function comes in handy:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If the tree is empty or you reach an empty subtree in the search, the search
    has failed ❶. Otherwise, search recursively character by character. After passing
    the EOW character, you’ve found the key and can return its data ❷; if you aren’t
    storing any data, just return true. If the current tree key matches the first
    character of the word you’re searching ❸, go down the middle link to match the
    rest of the word. If it isn’t a match ❹, go down the left or right link as in
    a binary search tree.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'To do a search, you need the same find() function as with other tries:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, working with the ternary trie isn’t that different from working
    with regular tries, but things will change a bit more when adding or deleting
    keys from the structure.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Key to a Ternary Trie
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The logic for adding a key to a ternary trie is also similar to adding a key
    to binary search trees. Start at the root and compare the first character of the
    string to be added with the character at the root and decide whether to go left
    or right (if there’s no match) or down the middle (if the characters match). This
    process continues until you either find the key (and don’t need to do anything)
    or decide you need to add it.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Try to add ABE to the ternary trie from the previous section; [Figure 16-26](chapter16.xhtml#fig16-26)
    highlights the steps.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-26.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-26: Adding ABE to a ternary trie'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: You want to add ABE■ (remember the EOW), so a comparison with the root’s B makes
    you go down the left link. You find an A there, so you go down the middle link.
    Then, you find a C, and as you want to add BE■, again you go down the left link,
    but because it’s null, you add a new subtree with B at its root in that location,
    an E down the middle link, and finally an EOW pointing to the extra data for the
    key.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the actual logic:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, process the string you want to add character by character until the end
    ❶. If you reach an empty link, create a new tree ❷ and add the rest of the pending
    characters in the new key. If the current node’s key matches the first character
    of the string you are adding ❸, either add the data (if you’re already at the
    EOW character) or recursively add the rest of the string to the middle-link subtree
    ❹, which moves you down the tree. If there isn’t a match ❺, decide whether to
    go down the left or right link ❻ and use recursion to add the string there ❼.
    At the end, return the updated trie ❽.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, the actual add() function makes use of the auxiliary _add() function:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Addition didn’t end up being that different from binary tries, if you dismiss
    the logic dealing with the middle links. Deletion will be similar, but with some
    complications.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Key from a Ternary Trie
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Removing a key is harder than the other functions, but with the lessons from
    [Chapter 12](chapter12.xhtml) on how to deal with maintaining the proper data
    structure after removing any given node, you’ll get it done. (A spoiler: as with
    binary search trees, you’ll have to deal with deleting a node differently depending
    on how many children a node has.) Start with a more complex ternary trie, which
    will provide some unique cases, as shown in [Figure 16-27](chapter16.xhtml#fig16-27)
    (I replaced some subtrees with triangles for clarity).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-27.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-27: A ternary trie from which you’ll delete some words'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when deleting a word, you need to delete several nodes along the
    path from the root to the final EOW, because now the keys aren’t stored in a single
    node. However, you can’t delete the *entire* path; you stop wherever the path
    joins another different path.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a simple example: What if you want to delete BEAD, BEVY, or
    BELL? In each of those cases, just remove all nodes from the EOW backward until
    you get to a node that is part of a different path, and that’s it. Removing those
    three words results in the trie shown in [Figure 16-28](chapter16.xhtml#fig16-28).'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-28.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-28: Deleting words may require removing nodes upward.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: The “cut” is at the marked nodes, which still keep their middle link and (in
    the case of BEST) another side link. Now consider what happens if you want to
    remove BETS. You shouldn’t leave the T node, because that’s wasteful. Since that
    node has a single child, you can work as you did with binary search trees and
    just link the node’s parent to the non-null child (see [Figure 16-29](chapter16.xhtml#fig16-29)).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-29.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-29: Removing BETS from the ternary trie requires changing a link
    from the parent.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: The key problem happens when you need to delete a node that has both left and
    right links. Go back to the original trie and consider removing BED. To recap,
    [Figure 16-30](chapter16.xhtml#fig16-30) shows the original trie.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-30.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-30: A ternary trie from which you’ll remove BED'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'When removing BED, you can’t just remove the D node, because that would break
    the trie, losing many other words; however, you don’t want to leave it either,
    because it isn’t a part of any word. The solution is similar to what you did with
    binary search trees: you can find the next word in its right subtree and use it
    to replace the word you’re deleting. In this case, the next word is BEER, as shown
    in [Figure 16-31](chapter16.xhtml#fig16-31).'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-31.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-31: Put BEER in the place of BED to maintain the structure of the
    ternary trie.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: After finding the word that’s going to replace the deleted one (BEER replaces
    BED), you need to adjust several links to maintain the proper trie shape. If the
    right child has no left child, the changes are easier. See if you can figure out
    how to remove BEST and replace it with BEVY.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic is as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If the tree is empty, do nothing else ❶. If you reach the end of the word (past
    the EOW character, as in the search), set the tree to null, and you are done ❷.
    While the character you are looking for matches the current node’s key, follow
    its middle link recursively ❸, but if you reach the EOW, set that link to null.
    After doing the removal, see if you’re at a node with an empty middle link ❹,
    which is a situation you don’t want. If one of the two (left or right) links ❺
    is empty, choose the other link, but if both are non-null ❻, you need to find
    the leftmost node at the right ❼ and fix the links as described earlier ❽ ❾. (If
    prev === null, there was just one single node to the right; otherwise, you need
    to go down the left links.) If you don’t find the right character earlier, you
    need to go left or right ❿.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'With this function out of the way, removing a key is the same function as with
    other tries:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You have now seen all the functions that work with ternary tries, so now let’s
    consider their performance.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: Considering Performance for Ternary Tries
  id: totrans-275
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Ternary tries are different from the other tries we saw in this chapter in
    one way: the shape of the tree depends on the order of additions and removals,
    and that means you can have a worst case that behaves differently from the normal,
    average case. You may remember that this also happened with plain binary search
    trees. The worst-case performance differed from the average performance, and that
    depended on how the tree had been created.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: If you insert all keys in ascending order, adding, searching, and removing will
    all be *O*(*sk*) if you store keys that are *k* characters long, with an alphabet
    of *s* symbols, which is a far better result than *O*(*n*)! To be proper, *O*(*sk*)
    is actually *O*(1) because *sk* is constant, so the ternary tries have the same
    performance as other tries.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '### Summary'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we looked at several variants of search trees called tries
    that apply a different concept: instead of directly storing and comparing keys,
    tries work on a character-per-character basis, providing an enhanced performance
    in comparison to the search trees we looked at previously, without the need for
    complex operations, such as rotating or balancing nodes.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'The structures we studied here are frequently used for dictionaries (enabling
    quick look-up of words) or straightforward searches: given a key, find its related
    data. The assured performance of tries makes them a useful data structure, particularly
    if you are doing some kind of work where you need to be as fast as possible and
    don’t want to deal with unexpected worst cases that may take too long to process.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**16.1  Maps for Tries**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Can you implement a trie using a map instead of an array or an object?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '**16.2  Ever Empty?**'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: From the section “Adding a Key to a Radix Tree” on page 410, in the _add() function,
    can wordToAdd ever be empty, and if so, when?
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '**16.3  Rotate Your Tries**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Can you apply rotations to a ternary trie?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '**16.4  Empty Middle?**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'True or false: middle links can never be empty in a ternary trie.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '**16.5  Four-Letter Ternary Trie?**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you start with an empty ternary trie and add in order keys AAAA, AAAB,
    . . . AAAZ, BAAA, . . . BAAZ ... all the way to ZZZZ—with all possible combinations
    of four letters. How tall would that trie be?
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '**16.6  How Do They Look?**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: As a recap, how would all the structures in this chapter look (array-based tries,
    object-based tries, radix trees, and ternary tries) if you just added a single
    word, ALGORITHM, to them?
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
