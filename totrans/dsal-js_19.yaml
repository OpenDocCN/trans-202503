- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 16 DIGITAL SEARCH TREES
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous four chapters, we explored different types of trees, including
    binary trees, general trees, heaps, and more. All of those trees are based on
    storing and comparing keys. With the digital search trees we’ll consider in this
    chapter, we won’t associate keys with nodes. Instead, the node’s position in the
    tree will define the key with which it is associated. In other words, you won’t
    store keys in a single place in the tree; they’ll be distributed across the whole
    structure, starting at the tree’s root. The leaves will mark where the keys end.
  prefs: []
  type: TYPE_NORMAL
- en: This might look like merely changing the way we work, in the same way that the
    radix sort changed the way we sorted ([Chapter 6](chapter6.xhtml)). With radix
    sort, instead of sorting by comparing keys, we worked with the keys character
    by character (or digit by digit, for numbers). With digital search trees, instead
    of storing and comparing keys, we’ll work with paths in trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll focus on three different data structures: *tries*, which can do searches
    in time proportional to a key’s length; *radix trees*, which are optimized versions
    of tries; and *ternary search tries*, an extension of binary search trees. These
    structures are particularly effective when we’re searching for strings, just as
    we search in a dictionary for words.'
  prefs: []
  type: TYPE_NORMAL
- en: The Classic Version of Tries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tries often are used simply to store words, allowing for easy, fast searches
    where users can enter a few letters, and words starting with those letters appear.
    Tries also are used as generic search trees where keys and data are stored and
    then a search is conducted for a key to provide the associated data.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Trie originally was pronounced like the word tree, but it’s also pronounced
    like the word try to distinguish it from tree. You can pronounce it either way.*'
  prefs: []
  type: TYPE_NORMAL
- en: Think of tries as a bit like old telephone indexes that had a set of buttons,
    one for each letter. If you wanted to find a name starting with *F*, you’d press
    that key, and the index would open on the F page. The analogy doesn’t stop there.
    Assume the index had another set of buttons for the name’s second letter, and
    pressing that button led you to yet another page with a new set of buttons. If
    you clicked all the buttons in order, you’d arrive at the name you were looking
    for or an empty page, meaning the name wasn’t in the index. This analogy may be
    hard to understand (I wonder how many readers have ever seen such a phone index!
    Maybe think of how autocomplete works instead?), so let’s consider the actual
    definition of a trie.
  prefs: []
  type: TYPE_NORMAL
- en: A trie has a link for each possible character (the same way the previous phone
    index example has a button for each letter in a name), but for simplicity, we’ll
    work with only the letters from A to E, plus an end of word (EOW) character to
    indicate where each word ends. We’ll use ■ for this. (Other languages, such as
    C, use the NULL \0 character for EOW, but the square symbol is more visible.)
    Suppose the words are ACE, AD, BADE, BE, BED, and BEE. In the trie, you’ll actually
    see ACE■, AD■, and so on. This trie looks like the diagram in [Figure 16-1](chapter16.xhtml#fig16-1),
    and for clarity, I’ve placed the root on the left instead of at the top, so you
    can read the words horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-1: A sample trie for words using only letters from A to E'
  prefs: []
  type: TYPE_NORMAL
- en: Each node in the trie consists of an array of links, one for each possible letter
    (A–E) plus the EOW character. (You could say it’s a six-ary tree; see [Chapter
    13](chapter13.xhtml).) The empty links have a white background in the diagram,
    and actual links have a gray background. Each word in a little box represents
    some extra data or value associated with the corresponding key (we’ll get to that
    in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define the basic functions to create a trie as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: First, define the EOW character; you’ll use the same definition throughout this
    chapter. The ALPHABET constant includes all the characters we’ll accept; for this
    example, you’re using only five letters, but for a real application, you’d most
    likely include at least the whole alphabet, A to Z. A new trie is just a null
    value, and a new node is an object with a links property, which is an array with
    one null link for each character in ALPHABET. Finally, to recognize an empty trie,
    simply check for “falsey” values on the last line.
  prefs: []
  type: TYPE_NORMAL
- en: You can also associate some value with every key, as shown next.
  prefs: []
  type: TYPE_NORMAL
- en: Storing Extra Data in a Trie
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we studied trees in previous chapters, we were concerned only with storing
    keys and searching for keys, because adding extra data was simple. Instead of
    a single key field, we could have a record with a key field and an extra data
    field. If we wanted to modify the algorithms to include extra fields, the changes
    were minor: searches would return the extra data instead of just a boolean value,
    and adding a key would also add the extra fields in the same object.'
  prefs: []
  type: TYPE_NORMAL
- en: But in a trie, keys aren’t stored in a single place and instead are distributed
    throughout the trie’s branches. There is a solution to this, but because the changes
    needed in the algorithms aren’t so minor, we’ll work with keys plus data.
  prefs: []
  type: TYPE_NORMAL
- en: The dictionary abstract data type (ADT) will change slightly, specifically the
    add and find operations, as shown in [Table 16-1](chapter16.xhtml#tab16-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 16-1: Operations on Tries'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Signature | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | → D | Create a new dictionary. |'
  prefs: []
  type: TYPE_TB
- en: '| Empty? | D → boolean | Determine whether the dictionary is empty. |'
  prefs: []
  type: TYPE_TB
- en: '| Add | D × key × data → D | Given a new key and data, add them to the dictionary.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Remove | D × key → D | Given a key, remove it from the dictionary. |'
  prefs: []
  type: TYPE_TB
- en: '| Find | D × key → data &#124; null | Given a key, return its data or return
    null if not found. |'
  prefs: []
  type: TYPE_TB
- en: As in other chapters, we’ll study the performance of the structures for this
    ADT. Now that we’ve defined the full structure for a trie and looked at how to
    create one, let’s consider the rest of the needed functions.
  prefs: []
  type: TYPE_NORMAL
- en: Searching a Trie
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How do you look for a word? For example, if you want to know whether BED is
    a valid word, [Figure 16-2](chapter16.xhtml#fig16-2) shows the path you’d take.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-2: Searching successfully for BED in a trie'
  prefs: []
  type: TYPE_NORMAL
- en: 'The search for BED starts at the root. You look at the B link and find it’s
    not null, so you follow it to the next level. There, you look at the E link and
    again follow it. The next step is similar: look at the D link and follow it. Finally,
    you arrive at the EOW, and finding a link to some data in the corresponding link,
    call it a successful search and return the found data.'
  prefs: []
  type: TYPE_NORMAL
- en: A failed search looks different. For example, if you want to find the word DAB,
    the search would fail at the beginning, since no word starts with D. What about
    ACED? This time, you’d start the search at the A link, then the C link, and finally
    the E link, but you’d arrive at a node with no D link, meaning ACED isn’t in the
    trie. [Figure 16-3](chapter16.xhtml#fig16-3) shows this failed search.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-3: Searching (unsuccessfully) for ACED in a trie'
  prefs: []
  type: TYPE_NORMAL
- en: Consider one last case and search for BAD. Remember, you’re adding an EOW character,
    so in reality, you’re trying to find BAD■. [Figure 16-4](chapter16.xhtml#fig16-4)
    shows what happens.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-4: Searching unsuccessfully for BAD: BADE is in the trie, but BAD
    isn’t.'
  prefs: []
  type: TYPE_NORMAL
- en: This search starts at the root and follows the B link first, then the A link,
    and then the D link. BAD is a prefix of at least one word, but the EOW link is
    missing, so BAD isn’t considered to be in the trie.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement this logic, first create an auxiliary _find() function that actually
    does the searches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The i variable ❶ selects the proper value from the links property, and now
    you’re ready to start searching. If the trie is empty (maybe it was empty from
    the beginning, or maybe you traveled down a null link), the search has obviously
    failed ❷. If you arrive at the end of the word (marked by the EOW character),
    do a simple test: if the corresponding link is null, the search fails as before;
    if not, the link points to an object with a data property, which you return ❸.
    Otherwise, if you haven’t yet reached a null link or the EOW character ❹, go down
    the right link and keep searching recursively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The find() function just calls the earlier _find(), but it adds the needed
    EOW character at the end of the string you’re trying to find:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Test for an empty word to find ❶, and if it’s empty, return null without any
    further ado.
  prefs: []
  type: TYPE_NORMAL
- en: Searching tries isn’t complex, and it’s similar to searches in other types of
    trees we looked at in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Key to a Trie
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adding a new key (plus data) to an existing trie follows the same strategy used
    for searches. Go down the links, letter by letter, and if the link exists, follow
    it, and if it doesn’t, add a new empty node. For instance, in the trie diagram
    shown in [Figure 16-5](chapter16.xhtml#fig16-5), if you want to add a BAD key,
    you just need to add a link at the last node with the data.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-5: Adding BAD to a trie'
  prefs: []
  type: TYPE_NORMAL
- en: The only change in the trie is that the (so far) empty EOW link now points to
    the data associated with the BAD key.
  prefs: []
  type: TYPE_NORMAL
- en: As another example, to add ABE, you would start by following the A link at the
    root, but then you’d need to add two new nodes, as shown in [Figure 16-6](chapter16.xhtml#fig16-6).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-6: Adding ABE to the trie requires new nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this addition is similar to other insertion functions we’ve discussed
    in previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: An _add() auxiliary function ❶ actually does the insertion. While you haven’t
    reached the end of the string (including the added EOW) ❷, advance, following
    the links corresponding to successive letters. If you find an empty link ❸, create
    a new node and keep advancing until you reach the EOW character. At each step,
    decide what link to follow ❹, and when you reach the EOW, add a link to the extra
    data ❺; otherwise, recursively keep adding the rest of the string ❻.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the add() function just invokes _add():'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This function also ensures that the EOW character is added.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Key from a Trie
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we’ll look at deleting a key, which is a bit more complex than adding keys
    to a trie. First, try to find the key; if you can’t find it, you’re finished,
    since there’s nothing else to do. If you find the key (and arrived at an EOW character),
    just delete the associated data, making the pointer null. If doing that left the
    current node empty of pointers, then delete the node and fix the parent’s pointer,
    which may again leave an all-empty node, so keep going up, back to the root, possibly
    deleting more nodes on the way.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider a few cases. Returning to the example trie, if you want to delete
    BE, you’d clear its EOW link as shown in [Figure 16-7](chapter16.xhtml#fig16-7),
    and you’d be done.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-7: Deleting BE from the trie'
  prefs: []
  type: TYPE_NORMAL
- en: To make it more difficult, after deleting BE, what if you want to delete BADE?
    First you clear the EOW link, but then the whole node has only null links, as
    shown in [Figure 16-8](chapter16.xhtml#fig16-8).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-8: Deleting BADE implies removing several (now empty) nodes from
    the trie.'
  prefs: []
  type: TYPE_NORMAL
- en: However, removing that node (and clearing the E link at its parent) repeats
    the situation, so you also delete the parent, and then the parent’s parent, until
    you arrive at a not all-empty node. The final situation looks like [Figure 16-9](chapter16.xhtml#fig16-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-9: The final trie after removing BADE'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with searching and adding, you need an auxiliary function to implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The _remove() function does the actual removal ❶. You search, link by link,
    and when you reach a null link, you know you’re done ❷. If you reach the end of
    the word (past the EOW character), set the current link to null ❸. If you’re still
    in the middle of the word, decide what link to follow ❹. Then recursively remove
    the rest of the word ❺ and do a final check to see whether the node is totally
    empty (all null), in which case, you also set the node to null ❻. At the end,
    just return the modified trie ❼.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final code you need is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The remove() function just calls _remove(), and it adds the needed EOW character
    to the string you want to remove.
  prefs: []
  type: TYPE_NORMAL
- en: Considering Performance for Tries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: How do the different operations perform? [Table 16-2](chapter16.xhtml#tab16-2)
    is almost the simplest table in this book; can you see why?
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 16-2: Performance of Operations for Tries'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Performance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Empty? | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Add | O(k) |'
  prefs: []
  type: TYPE_TB
- en: '| Remove | O(k) |'
  prefs: []
  type: TYPE_TB
- en: '| Find | O(k) |'
  prefs: []
  type: TYPE_TB
- en: Creating a trie and checking whether it’s empty are *O*(1) constant operations.
    And, given the structure, if keys are *k* characters long, all the other operations
    take (at most) *k* steps, which is the maximum height of a trie with such keys—excellent
    constant results! Note that the *O*(*k*) performance, with constant *k*, should
    be written as *O*(1). I wrote it as *O*(*k*) here just as a reminder that *k*
    steps will be taken, but in performance terms, any constant implies *O*(1).
  prefs: []
  type: TYPE_NORMAL
- en: However, despite having a very good performance, notice that this structure
    is quite wasteful. All the nodes have many links (as many characters as possible
    in the keys), making for a lot of unused space. Even worse with this structure,
    if you want to distinguish between uppercase and lowercase characters, or deal
    with the entire alphabet, or store words in foreign languages, the space requirements
    for nodes will grow wildly, because of the many links that each node will require.
  prefs: []
  type: TYPE_NORMAL
- en: This situation isn’t quite favorable, so let’s consider another approach to
    tries and aim for a more modern (and less wasteful) implementation, which JavaScript
    fortunately lets you do easily.
  prefs: []
  type: TYPE_NORMAL
- en: An Enhanced Version of Tries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider again how to represent a trie. At each node, you need a link for each
    character in a string, but if only a few of those characters are actually necessary,
    you don’t need to waste space for the rest. In fact, it sounds like you need some
    kind of set here, and that’s indeed the solution.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a large varying number of possible links, you should use some of
    the structures discussed in [Chapter 13](chapter13.xhtml). However, because alphabets
    are limited, you can use an object with characters for keys and links for values.
    (For yet another solution, see question 16.1.)
  prefs: []
  type: TYPE_NORMAL
- en: With the same six strings as in the previous trie (ACE, AD, BADE, BE, BED, and
    BEE), the structure looks like [Figure 16-10](chapter16.xhtml#fig16-10).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-10: An enhanced object-based version of a trie with fewer links'
  prefs: []
  type: TYPE_NORMAL
- en: The main difference is now the nodes can be much smaller, including only the
    strictly necessary links and nothing more.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an Object-Based Trie
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Instead of having an array of links, you can define this new style of space-saving
    tries using an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to make only one simple change from the previous trie (shown in bold):
    a new node now has an object named links instead of an array with that name.'
  prefs: []
  type: TYPE_NORMAL
- en: Searching an Object-Based Trie
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The process for searching an object-based trie for a key is similar to searching
    a classic trie: start at the root and follow the links that correspond to each
    character in the string, one by one. Instead of an array with links to all possible
    characters, you have an object with only the links actually required. For instance,
    revisit the BED search in [Figure 16-11](chapter16.xhtml#fig16-11).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-11: Searching successfully for BED in an object-based trie'
  prefs: []
  type: TYPE_NORMAL
- en: Starting at the root in the links object, follow the B link. At the next node,
    follow the E link, and so on, until reaching the EOW link. Then you know the key
    was found and can return the associated data, whatever it is.
  prefs: []
  type: TYPE_NORMAL
- en: Try redoing a failed search as well, as shown in [Figure 16-12](chapter16.xhtml#fig16-12).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-12: Searching unsuccessfully for ACED in an object-based trie'
  prefs: []
  type: TYPE_NORMAL
- en: If you search for ACED, the process stops after following the last E link. The
    node you arrive at doesn’t have a D link, so you can’t proceed, as the key you
    want isn’t in the trie.
  prefs: []
  type: TYPE_NORMAL
- en: 'Searching object-based tries isn’t really different from searching the original
    tries; the only change is how you choose the link to follow. The following logic
    shows the needed changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In comparison with the original trie search code, you have only two changes
    (shown in bold): you can access the needed link directly without having to check
    the alphabet first—for example, the link for the letter A is at links.A, (or,
    equivalently, links["A"]) with no further ado. The find() function itself is exactly
    the same as with the original tries.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Key to an Object-Based Trie
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Adding a key is also similar to the algorithm for the original tries. The changes
    you need to make work like those you made for searching. For instance, consider
    adding ABE, as shown in [Figure 16-13](chapter16.xhtml#fig16-13).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-13: Adding ABE to an object-based trie'
  prefs: []
  type: TYPE_NORMAL
- en: Start following links as you did with the search, and when links don’t appear,
    add them. In this case, the root already has an A link, so you follow it. The
    next node has no B link, so add it to the existing (C and D) links. From that
    point onward, start adding new nodes to the trie.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s the same process as for the original tries; here’s the new logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Again, the only difference in the logic from the original tries is that you
    always know what link to use for a given character, so you don’t need to search
    the ALPHABET array (shown in bold).
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Key from an Object-Based Trie
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Finally, removing a key is also similar to the previous code for original tries,
    but deciding whether the node is empty requires a different approach. For example,
    if you want to remove BADE from the original trie, you’ll get the result shown
    in [Figure 16-14](chapter16.xhtml#fig16-14).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-14: Removing BADE from an object-based trie'
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the previous array-based trie implementation, when nodes become empty,
    you delete them. The updated logic is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Most of the differences with the logic for original tries ❶ ❷ are directly related
    to knowing what link to use, but in order to decide whether a node became empty,
    you need to see how many keys the links object has ❸.
  prefs: []
  type: TYPE_NORMAL
- en: Considering Performance for Object-Based Tries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What changes with this new version of a trie? Performance is exactly the same
    as for the array-based tries; the only difference is the amount of memory needed.
    Think of it this way: if you were using a trie for a dictionary of European languages
    (with all the tildes, accents, and special characters, like the Danish å, or the
    Czech eˇ, or the German ß), you would need an array with more than 200 links in
    each node, although most of them would be empty. Using an object saves a lot of
    space, which could be important in some cases.'
  prefs: []
  type: TYPE_NORMAL
- en: However, using objects instead of arrays isn’t as efficient as it could be.
    After all, if the keys are long, you still need a very tall trie. As a border
    case, imagine having a trie with a single key that’s 20 characters long. You’d
    have a 20-level-high tree for one single key. Radix trees provide an enhanced
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: Radix Trees
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both the tries so far work well, but they have many levels. For instance, when
    looking for BADE in the example trie, you have to go down one level for each letter,
    while there are no other words that start with A; see [Figure 16-15](chapter16.xhtml#fig16-15).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-15: Searching successfully for BADE in a trie requires many steps.'
  prefs: []
  type: TYPE_NORMAL
- en: The idea for radix trees is that if any level has a single link, we “push it
    up” and join it with its parent link to shorten future searches. [Figure 16-16](chapter16.xhtml#fig16-16)
    shows what a radix tree for the ACE, AD, BADE, BE, BED, and BEE sets of words
    looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-16: A radix tree shortens searches by joining links.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, you would have found BADE in just two steps. This tree is shorter than
    all previous tries. Some paths (for example, B to E to BE) are still the same
    length, but most others are shorter, because some levels have multicharacter links.
    Let’s explore how these trees would be defined and used, because they’ll represent
    a more performant kind of digital tree.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Radix Tree
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you use an object to store links, like you did with the object-based tries,
    you find that the logic for radix trees is exactly the same. The difference is
    in *how* you use the links (they won’t always be single-character links), but
    otherwise the structure is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since there are no changes here with regard to the previous object-based tries
    code, let’s move on to working with these new trees.
  prefs: []
  type: TYPE_NORMAL
- en: Searching a Radix Tree
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Doing searches is similar to what you did for object-based tries, but now that
    the links may correspond to many characters, you need to work a bit differently.
    Start with a simple case: searching for BED—or, more precisely, BED■. [Figure
    16-17](chapter16.xhtml#fig16-17) shows the path to follow.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-17: Searching successfully for BED in a radix tree'
  prefs: []
  type: TYPE_NORMAL
- en: At the root, you need to find a link that is a prefix of BED■. In this case,
    follow a B link to the next level. (If you don’t find such a link, declare the
    search unsuccessful right then.) Since you followed a B link, next search for
    ED■. Again, you find a link that matches the search and follow that E link to
    the third level, where you look for D■. At this point, you find a complete match,
    so you found the key and can return its data. You’re done!
  prefs: []
  type: TYPE_NORMAL
- en: As another example, look for ACED■, which will be a failed search (see [Figure
    16-18](chapter16.xhtml#fig16-18)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-18: Searching unsuccessfully for ACED in a radix tree'
  prefs: []
  type: TYPE_NORMAL
- en: What happens here? At the first level, you find an A link to follow, so you
    then look for CED■ at the second level. However, you don’t find any link that
    has the search string’s prefix, you fail. If you were searching for CAB■, you’d
    have the same problem, but at the root, because no link has a prefix with that
    string.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is that you move down the tree, level by level, matching prefixes to
    links. Given two strings, you first need an auxiliary function to find how many
    characters they have in common from the start. For example, if you have BEE and
    BADE, you’d have only one character in common (B). If you have ACED and ACAD,
    you’d have two characters in common (the initial AC characters).
  prefs: []
  type: TYPE_NORMAL
- en: 'The auxiliary function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Start by comparing characters from the beginning ❶ and count ❷ until the strings
    end or stop matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this function, you can start searching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If the tree is empty, the key obviously can’t be there ❶. To see whether a link
    is a prefix of the search key, first find the (only) object key that matches the
    first character ❷, because you can’t have two or more keys with the same initial
    character in a node (it would break the structure). If you find such a link ❸,
    check whether it actually has the complete string you need ❹; if so, you’re done.
    If the link doesn’t match the whole string, find the common prefix ❺ and recursively
    search for the rest of the string ❻. On the other hand, if you don’t find a link
    matching the initial character of the string, the search fails ❼.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main find() function is the same as with object-based tries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic for searching radix tries is similar to the logic used for tries,
    except matching links is a bit more complex.  #### Adding a Key to a Radix Tree'
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with adding new keys to radix trees is if there’s some previously
    added key that matches part of the key you want to add. Start with a simple case:
    adding ABE■ as with the original radix tree (see [Figure 16-19](chapter16.xhtml#fig16-19)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-19: Adding ABE to a radix tree: initial structure'
  prefs: []
  type: TYPE_NORMAL
- en: First, search for the string as shown in the previous section, and after following
    the A link, you arrive at a node with no links matching the BE■ prefix. This means
    you simply can stop searching right here and add the new link in that place.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 16-20](chapter16.xhtml#fig16-20) shows the more complex case of adding
    BAD to the tree updated in [Figure 16-19](chapter16.xhtml#fig16-19).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-20: Adding BAD to a radix tree requires splitting some links.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference here is that after following the B link, you find there already
    was a partial match (ADE■), so now you need to do a split: the common prefix (AD)
    remains in the node, and you create a new node with the rest of the keys.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic thus needs to deal with two cases: not finding a prefix (as with
    ABE) or finding a partial match (as with BADE). Here’s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: First check whether you are adding a nonempty string ❶; if not, return the trie
    unchanged ❾. If you have a string to insert, check whether the tree is empty ❷,
    because if it’s empty, create a new node with the single key, and you are done.
    If the tree isn’t empty, search for an existing key that matches at least the
    first character ❸ (as shown previously). If you don’t find one, create a new node
    ❽; otherwise, check whether the found key matches what you’re inserting in full
    or in part ❹ by splitting the key according to the common length you found. If
    the match is in full ❺, follow the link to insert the rest of the string; otherwise
    ❻, do a split, leaving the common prefix in the node by adding a new node and
    deleting the old key ❼.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the logic is the same as for the other tries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You have now seen how to add a new key, which had two distinct cases; now see
    what happens with the reverse algorithm to remove a key from a radix tree.  ####
    Removing a Key from a Radix Tree'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing with the same radix tree that was updated in [Figure 16-20](chapter16.xhtml#fig16-20),
    consider two cases for removing keys: removing a link from a node, leaving it
    with two or more links, and removing a link from a node, leaving it with a single
    link. Take a look at the simpler former case first ([Figure 16-21](chapter16.xhtml#fig16-21)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-21: The radix tree from which you’ll remove ACE'
  prefs: []
  type: TYPE_NORMAL
- en: To remove ACE from the radix tree, search for it, and when you arrive at the
    final link, simply remove it. The tree would look like [Figure 16-22](chapter16.xhtml#fig16-22).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-22: Removing ACE requires removing only a link.'
  prefs: []
  type: TYPE_NORMAL
- en: However, what if you want to remove BADE? Remember, if you have a single link,
    you need to join it with the parent link, as shown in [Figure 16-23](chapter16.xhtml#fig16-23).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-23: Removing BADE requires more work.'
  prefs: []
  type: TYPE_NORMAL
- en: After searching for BADE and removing the last link (E■), the final node ended
    up with only an EOW link. You then push it up so that it joins with its parent,
    which is an AD link. Doing this reverses the kind of split you did when adding
    new keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the actual logic. You need an auxiliary _remove() function, as in
    the other cases, to remove the desired key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Start by checking whether you’re done, which means reaching an empty link or
    the end of the word you’re removing ❶. If you aren’t finished, search for a link
    that has a common prefix with the word you’re removing ❷ as described earlier.
    If you don’t find one, you’re also done, because the word you’re removing isn’t
    in the trie. If you find a suitable prefix ❸, you have two possibilities: you’ve
    found the whole word or part of the word. In the former case ❹, delete the link;
    no more work is needed. In the latter case ❺, search for and remove the rest of
    the word, discounting the prefix already found (you’ll do this recursively). After
    that, check whether the trie ended with a single key ❻, in which case, join its
    only key with the prefix you found. Finally, return the updated trie ❼.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this function out of the way, you can code the remove() function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If the trie isn’t empty ❶, use the auxiliary function to remove the key from
    the tree ❷ and then a final check remains: if the root became empty ❸, the trie
    is null.'
  prefs: []
  type: TYPE_NORMAL
- en: Considering Performance for Radix Trees
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Radix trees are like “compressed” versions of tries. They’re faster when nodes
    include longer strings, and at worst, they behave the same way as tries if all
    links are “single-character” links. This means you don’t need to do much analysis.
    [Table 16-3](chapter16.xhtml#tab16-3) shows the performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 16-3: Performance of Operations for Radix Trees'
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | Performance |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Create | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Empty? | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Add | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Remove | O(1) |'
  prefs: []
  type: TYPE_TB
- en: '| Find | O(1) |'
  prefs: []
  type: TYPE_TB
- en: 'The results for radix trees are the same as for tries: all operations are *O*(1).'
  prefs: []
  type: TYPE_NORMAL
- en: Ternary Search Tries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Tries and radix trees are based on the idea of storing keys “down the links.”
    You can also apply this idea to *ternary trees*, a new structure that saves space
    and provides good performance. We mentioned ternary trees in [Chapter 13](chapter13.xhtml),
    as a generalization of binary trees having three links at each node instead of
    two, but we didn’t actually work with them. The idea is that with a ternary search
    tree, each node has a key (a single character) and three links:'
  prefs: []
  type: TYPE_NORMAL
- en: The left link is for strings whose current character is less than the node key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The middle link is for strings whose current character is equal to the node
    key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The right link is for strings whose current character is greater than the node
    key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Figure 16-24](chapter16.xhtml#fig16-24) shows a ternary search tree.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-24: A ternary search tree with seven words'
  prefs: []
  type: TYPE_NORMAL
- en: Try to follow the path to every word; you’ll then understand the difference
    between the middle links and the right and left links. The following sections
    explain this in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Ternary Tries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We’ve already considered binary search trees, and defining a ternary tree is
    similar. All you need to do is add a middle link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Creating ternary trees is quite simple, but storing extra data and doing searches
    require some changes.
  prefs: []
  type: TYPE_NORMAL
- en: Storing Extra Data in a Ternary Trie
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: With ternary tries, you have the same issue as with other common trees. You
    could store extra data next to the key, but again you have the problem that keys
    aren’t stored in any single place, as they are with search trees; the keys are
    spread all over the trie.
  prefs: []
  type: TYPE_NORMAL
- en: 'To alleviate this complication, reapply the solution used for tries. When you
    reach the EOW character, use its middle pointer to store extra data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Of course, if you’re using the ternary trie just to store the keys and don’t
    care about extra data (for example, if you were using a ternary trie to look up
    words to see whether they exist in a Scrabble application to check a weird-looking
    word your opponent entered), you can omit that line and modify the search function
    (which you’ll look at next) to return only true or false.
  prefs: []
  type: TYPE_NORMAL
- en: Searching a Ternary Trie
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Given how we designed ternary tries, it should be no surprise that searching
    for a key in a ternary trie is similar to the logic for binary search trees (see
    [Chapter 12](chapter12.xhtml)). As an example, [Figure 16-25](chapter16.xhtml#fig16-25)
    shows how to look for the word AD (you’ll actually search for AD■, with the appended
    EOW character).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-25: Searching successfully for AD in a ternary trie'
  prefs: []
  type: TYPE_NORMAL
- en: The search starts at the root, which has a B. Since A (the first letter in AD■)
    is less than B, follow the left link. Then you find an A, so go down the middle
    link, looking for the rest of the string, which is D■. You find a C, so go down
    the right link. Then you find a D, so now go down the middle, looking for the
    EOW character. After finding it, successfully return the associated data.
  prefs: []
  type: TYPE_NORMAL
- en: If you had been looking for ADD instead, you’d have found an empty link after
    the first D, so the search would have been a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned previously, the ternary trie search process is similar to that
    of binary search trees. The logic is as follows, and as with other cases, an auxiliary
    function comes in handy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If the tree is empty or you reach an empty subtree in the search, the search
    has failed ❶. Otherwise, search recursively character by character. After passing
    the EOW character, you’ve found the key and can return its data ❷; if you aren’t
    storing any data, just return true. If the current tree key matches the first
    character of the word you’re searching ❸, go down the middle link to match the
    rest of the word. If it isn’t a match ❹, go down the left or right link as in
    a binary search tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do a search, you need the same find() function as with other tries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, working with the ternary trie isn’t that different from working
    with regular tries, but things will change a bit more when adding or deleting
    keys from the structure.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Key to a Ternary Trie
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The logic for adding a key to a ternary trie is also similar to adding a key
    to binary search trees. Start at the root and compare the first character of the
    string to be added with the character at the root and decide whether to go left
    or right (if there’s no match) or down the middle (if the characters match). This
    process continues until you either find the key (and don’t need to do anything)
    or decide you need to add it.
  prefs: []
  type: TYPE_NORMAL
- en: Try to add ABE to the ternary trie from the previous section; [Figure 16-26](chapter16.xhtml#fig16-26)
    highlights the steps.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-26: Adding ABE to a ternary trie'
  prefs: []
  type: TYPE_NORMAL
- en: You want to add ABE■ (remember the EOW), so a comparison with the root’s B makes
    you go down the left link. You find an A there, so you go down the middle link.
    Then, you find a C, and as you want to add BE■, again you go down the left link,
    but because it’s null, you add a new subtree with B at its root in that location,
    an E down the middle link, and finally an EOW pointing to the extra data for the
    key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the actual logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: First, process the string you want to add character by character until the end
    ❶. If you reach an empty link, create a new tree ❷ and add the rest of the pending
    characters in the new key. If the current node’s key matches the first character
    of the string you are adding ❸, either add the data (if you’re already at the
    EOW character) or recursively add the rest of the string to the middle-link subtree
    ❹, which moves you down the tree. If there isn’t a match ❺, decide whether to
    go down the left or right link ❻ and use recursion to add the string there ❼.
    At the end, return the updated trie ❽.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, the actual add() function makes use of the auxiliary _add() function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Addition didn’t end up being that different from binary tries, if you dismiss
    the logic dealing with the middle links. Deletion will be similar, but with some
    complications.
  prefs: []
  type: TYPE_NORMAL
- en: Removing a Key from a Ternary Trie
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Removing a key is harder than the other functions, but with the lessons from
    [Chapter 12](chapter12.xhtml) on how to deal with maintaining the proper data
    structure after removing any given node, you’ll get it done. (A spoiler: as with
    binary search trees, you’ll have to deal with deleting a node differently depending
    on how many children a node has.) Start with a more complex ternary trie, which
    will provide some unique cases, as shown in [Figure 16-27](chapter16.xhtml#fig16-27)
    (I replaced some subtrees with triangles for clarity).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-27: A ternary trie from which you’ll delete some words'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when deleting a word, you need to delete several nodes along the
    path from the root to the final EOW, because now the keys aren’t stored in a single
    node. However, you can’t delete the *entire* path; you stop wherever the path
    joins another different path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a simple example: What if you want to delete BEAD, BEVY, or
    BELL? In each of those cases, just remove all nodes from the EOW backward until
    you get to a node that is part of a different path, and that’s it. Removing those
    three words results in the trie shown in [Figure 16-28](chapter16.xhtml#fig16-28).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-28: Deleting words may require removing nodes upward.'
  prefs: []
  type: TYPE_NORMAL
- en: The “cut” is at the marked nodes, which still keep their middle link and (in
    the case of BEST) another side link. Now consider what happens if you want to
    remove BETS. You shouldn’t leave the T node, because that’s wasteful. Since that
    node has a single child, you can work as you did with binary search trees and
    just link the node’s parent to the non-null child (see [Figure 16-29](chapter16.xhtml#fig16-29)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-29: Removing BETS from the ternary trie requires changing a link
    from the parent.'
  prefs: []
  type: TYPE_NORMAL
- en: The key problem happens when you need to delete a node that has both left and
    right links. Go back to the original trie and consider removing BED. To recap,
    [Figure 16-30](chapter16.xhtml#fig16-30) shows the original trie.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-30: A ternary trie from which you’ll remove BED'
  prefs: []
  type: TYPE_NORMAL
- en: 'When removing BED, you can’t just remove the D node, because that would break
    the trie, losing many other words; however, you don’t want to leave it either,
    because it isn’t a part of any word. The solution is similar to what you did with
    binary search trees: you can find the next word in its right subtree and use it
    to replace the word you’re deleting. In this case, the next word is BEER, as shown
    in [Figure 16-31](chapter16.xhtml#fig16-31).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/Figure16-31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16-31: Put BEER in the place of BED to maintain the structure of the
    ternary trie.'
  prefs: []
  type: TYPE_NORMAL
- en: After finding the word that’s going to replace the deleted one (BEER replaces
    BED), you need to adjust several links to maintain the proper trie shape. If the
    right child has no left child, the changes are easier. See if you can figure out
    how to remove BEST and replace it with BEVY.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If the tree is empty, do nothing else ❶. If you reach the end of the word (past
    the EOW character, as in the search), set the tree to null, and you are done ❷.
    While the character you are looking for matches the current node’s key, follow
    its middle link recursively ❸, but if you reach the EOW, set that link to null.
    After doing the removal, see if you’re at a node with an empty middle link ❹,
    which is a situation you don’t want. If one of the two (left or right) links ❺
    is empty, choose the other link, but if both are non-null ❻, you need to find
    the leftmost node at the right ❼ and fix the links as described earlier ❽ ❾. (If
    prev === null, there was just one single node to the right; otherwise, you need
    to go down the left links.) If you don’t find the right character earlier, you
    need to go left or right ❿.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this function out of the way, removing a key is the same function as with
    other tries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You have now seen all the functions that work with ternary tries, so now let’s
    consider their performance.
  prefs: []
  type: TYPE_NORMAL
- en: Considering Performance for Ternary Tries
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Ternary tries are different from the other tries we saw in this chapter in
    one way: the shape of the tree depends on the order of additions and removals,
    and that means you can have a worst case that behaves differently from the normal,
    average case. You may remember that this also happened with plain binary search
    trees. The worst-case performance differed from the average performance, and that
    depended on how the tree had been created.'
  prefs: []
  type: TYPE_NORMAL
- en: If you insert all keys in ascending order, adding, searching, and removing will
    all be *O*(*sk*) if you store keys that are *k* characters long, with an alphabet
    of *s* symbols, which is a far better result than *O*(*n*)! To be proper, *O*(*sk*)
    is actually *O*(1) because *sk* is constant, so the ternary tries have the same
    performance as other tries.
  prefs: []
  type: TYPE_NORMAL
- en: '### Summary'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we looked at several variants of search trees called tries
    that apply a different concept: instead of directly storing and comparing keys,
    tries work on a character-per-character basis, providing an enhanced performance
    in comparison to the search trees we looked at previously, without the need for
    complex operations, such as rotating or balancing nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The structures we studied here are frequently used for dictionaries (enabling
    quick look-up of words) or straightforward searches: given a key, find its related
    data. The assured performance of tries makes them a useful data structure, particularly
    if you are doing some kind of work where you need to be as fast as possible and
    don’t want to deal with unexpected worst cases that may take too long to process.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**16.1  Maps for Tries**'
  prefs: []
  type: TYPE_NORMAL
- en: Can you implement a trie using a map instead of an array or an object?
  prefs: []
  type: TYPE_NORMAL
- en: '**16.2  Ever Empty?**'
  prefs: []
  type: TYPE_NORMAL
- en: From the section “Adding a Key to a Radix Tree” on page 410, in the _add() function,
    can wordToAdd ever be empty, and if so, when?
  prefs: []
  type: TYPE_NORMAL
- en: '**16.3  Rotate Your Tries**'
  prefs: []
  type: TYPE_NORMAL
- en: Can you apply rotations to a ternary trie?
  prefs: []
  type: TYPE_NORMAL
- en: '**16.4  Empty Middle?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'True or false: middle links can never be empty in a ternary trie.'
  prefs: []
  type: TYPE_NORMAL
- en: '**16.5  Four-Letter Ternary Trie?**'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose you start with an empty ternary trie and add in order keys AAAA, AAAB,
    . . . AAAZ, BAAA, . . . BAAZ ... all the way to ZZZZ—with all possible combinations
    of four letters. How tall would that trie be?
  prefs: []
  type: TYPE_NORMAL
- en: '**16.6  How Do They Look?**'
  prefs: []
  type: TYPE_NORMAL
- en: As a recap, how would all the structures in this chapter look (array-based tries,
    object-based tries, radix trees, and ternary tries) if you just added a single
    word, ALGORITHM, to them?
  prefs: []
  type: TYPE_NORMAL
