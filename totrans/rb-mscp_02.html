<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Compilation"><div class="titlepage"><div><div><h1 class="title"><a id="compilation"/>Chapter 2. Compilation</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><div class="informalfigure"><div class="mediaobject"><a id="med_id00039"/><img alt="image with no caption" src="httpatomoreillycomsourcenostarchimages1853819.png.jpg"/></div></div><p><span class="emphasis"><em>The code Ruby actually runs looks nothing like your original code.</em></span></p></blockquote></div><p><a class="indexterm" id="iddle1176"/>Now that Ruby has tokenized and parsed your code, is it ready to run it? Will it finally get to work and iterate through the block 10 times in my simple <code class="literal">10.times do</code> example? If not, what else could Ruby possibly have to do first?</p><p>Starting with version 1.9, Ruby compiles your code before executing it. The word <span class="emphasis"><em>compile</em></span> means to translate your code from one programming language to another. Your programming language is easy for you to understand, while usually the target language is easy for the computer to understand.</p><p>For example, when you compile a C program, the compiler translates C code to machine language, a language your computer’s microprocessor hardware understands. When you compile a Java program, the compiler translates Java code to Java bytecode, a language the Java Virtual Machine understands.</p><p>Ruby’s compiler is no different. It translates your Ruby code into another language that Ruby’s virtual machine understands. The only difference is that you don’t use Ruby’s compiler directly; unlike in C or Java, <a class="indexterm" id="iddle1005"/><a class="indexterm" id="iddle1036"/><a class="indexterm" id="iddle1038"/>Ruby’s compiler runs automatically without you ever knowing. Here in <a class="xref" href="ch02.html" title="Chapter 2. Compilation">Chapter 2</a>, I’ll explain how Ruby does this and what language it translates your code into.</p><div class="sidebar"><a id="roadmap-id00005"/><p class="title">Roadmap</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch02.html#no_compiler_for_ruby_1dot8" title="No Compiler for Ruby 1.8">No Compiler for Ruby 1.8</a></p></li><li class="listitem"><p><a class="xref" href="ch02.html#ruby_1dot9_and_2dot0_introduce_a_compile" title="Ruby 1.9 and 2.0 Introduce a Compiler">Ruby 1.9 and 2.0 Introduce a Compiler</a></p></li><li class="listitem"><p><a class="xref" href="ch02.html#how_ruby_compiles_a_simple_script" title="How Ruby Compiles a Simple Script">How Ruby Compiles a Simple Script</a></p></li><li class="listitem"><p><a class="xref" href="ch02.html#compiling_a_call_to_a_block" title="Compiling a Call to a Block">Compiling a Call to a Block</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch02.html#how_ruby_iterates_through_the_ast" title="How Ruby Iterates Through the AST">How Ruby Iterates Through the AST</a></p></li></ul></div></li><li class="listitem"><p><span class="strong"><strong><a class="xref" href="ch02.html#experiment_2-1_displaying_yarv_instructi" title="Experiment 2-1: Displaying YARV Instructions">Experiment 2-1: Displaying YARV Instructions</a></strong></span></p></li><li class="listitem"><p><a class="xref" href="ch02.html#local_table" title="The Local Table">The Local Table</a></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><a class="xref" href="ch02.html#compiling_optional_arguments" title="Compiling Optional Arguments">Compiling Optional Arguments</a></p></li><li class="listitem"><p><a class="xref" href="ch02.html#compiling_keyword_arguments" title="Compiling Keyword Arguments">Compiling Keyword Arguments</a></p></li></ul></div></li><li class="listitem"><p><span class="strong"><strong><a class="xref" href="ch02.html#experiment_2-2_displaying_the_local_tabl" title="Experiment 2-2: Displaying the Local Table">Experiment 2-2: Displaying the Local Table</a></strong></span></p></li><li class="listitem"><p><a class="xref" href="ch02.html#summary-id00008" title="Summary">Summary</a></p></li></ul></div></div><div class="sect1" title="No Compiler for Ruby 1.8"><div class="titlepage"><div><div><h1 class="title"><a id="no_compiler_for_ruby_1dot8"/>No Compiler for Ruby 1.8</h1></div></div></div><p>The Ruby core team introduced a compiler with version 1.9. Ruby 1.8 and earlier versions of Ruby don’t contain a compiler. Instead, Ruby 1.8 immediately executes your code after the tokenizing and parsing processes are finished. It does this by walking through the nodes in the AST tree and executing each one. <a class="xref" href="ch02.html#in_ruby_1dot8comma_your_code_is_converte" title="Figure 2-1. In Ruby 1.8, your code is converted into AST nodes and then interpreted.">Figure 2-1</a> shows another way of looking at the Ruby 1.8 tokenizing and parsing processes.</p><p>The top of <a class="xref" href="ch02.html#in_ruby_1dot8comma_your_code_is_converte" title="Figure 2-1. In Ruby 1.8, your code is converted into AST nodes and then interpreted.">Figure 2-1</a> shows your Ruby code. Below this are the different internal formats Ruby converts your Ruby code into. These are the tokens and AST nodes we saw in <a class="xref" href="ch01.html" title="Chapter 1. Tokenization and Parsing">Chapter 1</a>—the different <a class="indexterm" id="iddle1091"/><a class="indexterm" id="iddle1182"/><a class="indexterm" id="iddle1958"/><a class="indexterm" id="iddle2108"/><a class="indexterm" id="iddle2134"/>forms your code takes when you run it using Ruby. The lower section of the diagram shows the code the Ruby core team wrote: the C source code for the Ruby language and the machine language it is converted into by the C compiler.</p><div class="figure"><a id="in_ruby_1dot8comma_your_code_is_converte"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00040"/><img alt="In Ruby 1.8, your code is converted into AST nodes and then interpreted." src="httpatomoreillycomsourcenostarchimages1853899.png.jpg"/></div></div><p class="title">Figure 2-1. In Ruby 1.8, your code is converted into AST nodes and then interpreted.</p></div><p>The dotted line between the two code sections indicates that Ruby interprets your code. The Ruby C code, the lower section, reads and executes your code, the top section. Ruby 1.8 doesn’t compile or translate your code into any form beyond AST nodes. After converting it into AST nodes, it proceeds to iterate over the nodes in the AST, taking whatever action each node represents as it executes each node.</p><p>The gap in the middle of the diagram shows that your code is never completely compiled into machine language. If you were to disassemble and inspect the machine language that your CPU actually runs, you would not see instructions that directly map to your original Ruby code. Instead, you would find instructions that tokenize, parse, and execute your code, or, in other words, that implement the Ruby interpreter.</p></div><div class="sect1" title="Ruby 1.9 and 2.0 Introduce a Compiler"><div class="titlepage"><div><div><h1 class="title"><a id="ruby_1dot9_and_2dot0_introduce_a_compile"/>Ruby 1.9 and 2.0 Introduce a Compiler</h1></div></div></div><p>If you’ve upgraded to Ruby 1.9 or 2.0, Ruby is still not quite ready to run your code. It needs to compile it first.</p><p>With Ruby 1.9, Koichi Sasada and the Ruby core team introduced Yet Another Ruby Virtual Machine (YARV), which actually executes your Ruby code. At a high level, this is the same idea behind the Java Virtual Machine (JVM) used by Java and many other languages. (I’ll cover YARV in more detail in <a class="xref" href="ch03.html" title="Chapter 3. How Ruby Executes Your Code">Chapter 3</a> and <a class="xref" href="ch04.html" title="Chapter 4. Control Structures and Method Dispatch">Chapter 4</a>.)</p><p>When using YARV (as with the JVM), you first compile your code into <span class="emphasis"><em>bytecode</em></span>, a series of low-level instructions that the virtual machine understands. The only differences between YARV and the JVM are the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Ruby doesn’t expose the compiler to you as a separate tool. Instead, it automatically compiles your Ruby code into bytecode instructions internally.</p></li><li class="listitem"><p>Ruby never compiles your Ruby code all the way to machine language. As you can see in <a class="xref" href="ch02.html#ruby_1dot9_and_2dot0_compile_the_ast_nod" title="Figure 2-2. Ruby 1.9 and 2.0 compile the AST nodes into YARV instructions before interpreting them.">Figure 2-2</a>, Ruby interprets the bytecode instructions. The JVM, on the other hand, can compile some of the bytecode instructions all the way into machine language using its “hotspot” or just-in-time (JIT) compiler.</p><p><a class="xref" href="ch02.html#ruby_1dot9_and_2dot0_compile_the_ast_nod" title="Figure 2-2. Ruby 1.9 and 2.0 compile the AST nodes into YARV instructions before interpreting them.">Figure 2-2</a> shows how Ruby 1.9 and 2.0 handle your code.</p></li></ul></div><p><a class="indexterm" id="iddle1046"/><a class="indexterm" id="iddle1049"/><a class="indexterm" id="iddle1181"/><a class="indexterm" id="iddle1441"/><a class="indexterm" id="iddle1725"/><a class="indexterm" id="iddle1728"/><a class="indexterm" id="iddle1969"/><a class="indexterm" id="iddle2110"/>Notice that this time, unlike in the process shown in <a class="xref" href="ch02.html#in_ruby_1dot8comma_your_code_is_converte" title="Figure 2-1. In Ruby 1.8, your code is converted into AST nodes and then interpreted.">Figure 2-1</a>, your code is translated into a third format. After parsing the tokens and producing the AST, Ruby 1.9 and 2.0 continue to compile your code into a series of low-level instructions called <span class="emphasis"><em>YARV instructions</em></span>.</p><p>The primary reason for using YARV is speed: Ruby 1.9 and 2.0 run much faster than Ruby 1.8 due to the use of YARV instructions. Like Ruby 1.8, YARV is an interpreter—just a faster one. Your Ruby code ultimately is still not converted directly into machine language by Ruby 1.9 or 2.0. There is still a gap in <a class="xref" href="ch02.html#ruby_1dot9_and_2dot0_compile_the_ast_nod" title="Figure 2-2. Ruby 1.9 and 2.0 compile the AST nodes into YARV instructions before interpreting them.">Figure 2-2</a> between the YARV instructions and Ruby’s C code.</p><div class="figure"><a id="ruby_1dot9_and_2dot0_compile_the_ast_nod"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00041"/><img alt="Ruby 1.9 and 2.0 compile the AST nodes into YARV instructions before interpreting them." src="httpatomoreillycomsourcenostarchimages1853901.png.jpg"/></div></div><p class="title">Figure 2-2. Ruby 1.9 and 2.0 compile the AST nodes into YARV instructions before interpreting them.</p></div></div><div class="sect1" title="How Ruby Compiles a Simple Script"><div class="titlepage"><div><div><h1 class="title"><a id="how_ruby_compiles_a_simple_script"/>How Ruby Compiles a Simple Script</h1></div></div></div><p>In this section, we’ll look at the last step along your code’s journey through Ruby: how Ruby compiles your code into the instructions that YARV expects. Let’s explore how Ruby’s compiler works by stepping through an example compilation. <a class="xref" href="ch02.html#one-line_ruby_program_we_will_compile" title="Example 2-1. A one-line Ruby program we will compile as an example">Example 2-1</a> shows a simple Ruby script that calculates 2 + 2 = 4.</p><div class="example"><a id="one-line_ruby_program_we_will_compile"/><p class="title">Example 2-1. A one-line Ruby program we will compile as an example</p><div class="example-contents"><pre class="programlisting">puts 2+2</pre></div></div><p><a class="xref" href="ch02.html#ast_ruby_produces_after_parsing_the" title="Figure 2-3. The AST Ruby produces after parsing the code in Example 2-1">Figure 2-3</a> shows the AST structure that Ruby will create after tokenizing and parsing this simple program. (This is a more detailed view of the AST than you would get from the Ripper tool that we saw in <a class="xref" href="ch01.html#experiment_1-2_using_ripper_to_parse_dif" title="Experiment 1-2: Using Ripper to Parse Different Ruby Scripts">Experiment 1-2: Using Ripper to Parse Different Ruby Scripts</a>.)</p><div class="note" title="Note"><h3 class="title"><a id="ch02note01"/>Note</h3><p><span class="emphasis"><em>The technical names shown in <a class="xref" href="ch02.html#ast_ruby_produces_after_parsing_the" title="Figure 2-3. The AST Ruby produces after parsing the code in Example 2-1">Figure 2-3</a> (<span class="emphasis"><em><code class="literal">NODE_SCOPE</code></em></span>, <span class="emphasis"><em><code class="literal">NODE_FCALL</code></em></span>, and so on) are taken from the actual Ruby C source code. To keep things simple, I’m omitting some AST nodes—specifically, ones that represent arrays of the arguments to each method call, which in this simple example would be arrays of only one element.</em></span></p></div><div class="figure"><a id="ast_ruby_produces_after_parsing_the"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00042"/><img alt="The AST Ruby produces after parsing the code in" src="httpatomoreillycomsourcenostarchimages1853903.png.jpg"/></div></div><p class="title">Figure 2-3. The AST Ruby produces after parsing the code in <a class="xref" href="ch02.html#one-line_ruby_program_we_will_compile" title="Example 2-1. A one-line Ruby program we will compile as an example">Example 2-1</a></p></div><p><a class="indexterm" id="iddle1044"/><a class="indexterm" id="iddle1723"/><a class="indexterm" id="iddle1967"/><a class="indexterm" id="iddle2015"/>Before we cover the details of how Ruby compiles the <code class="literal">puts 2+2</code> script, let’s look at one very important attribute of YARV: It’s a <span class="emphasis"><em>stack-oriented virtual machine</em></span>. That means when YARV executes your code, it maintains a stack of values—mainly arguments and return values for the YARV instructions. (I’ll explain this in more detail in <a class="xref" href="ch03.html" title="Chapter 3. How Ruby Executes Your Code">Chapter 3</a>.) Most of YARV’s instructions either push values onto the stack or operate on the values that they find on the stack, leaving a result value on the stack as well.</p><p>In order to compile the <code class="literal">puts 2+2</code> AST structure into YARV instructions, Ruby will iterate over the tree recursively from the top down, converting each AST node into instructions. <a class="xref" href="ch02.html#ruby_starts_the_compile_process_at_the_r" title="Figure 2-4. Ruby starts the compile process at the root of the AST.">Figure 2-4</a> shows how this works, beginning with <code class="literal">NODE_SCOPE</code>.</p><div class="figure"><a id="ruby_starts_the_compile_process_at_the_r"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00043"/><img alt="Ruby starts the compile process at the root of the AST." src="httpatomoreillycomsourcenostarchimages1853905.png.jpg"/></div></div><p class="title">Figure 2-4. Ruby starts the compile process at the root of the AST.</p></div><p><code class="literal">NODE_SCOPE</code> tells the Ruby compiler that it is starting to compile a new <span class="emphasis"><em>scope</em></span>, or section of Ruby code, which, in this case, is a whole new program. <a class="indexterm" id="iddle1303"/><a class="indexterm" id="iddle1817"/><a class="indexterm" id="iddle1844"/><a class="indexterm" id="iddle1889"/><a class="indexterm" id="iddle1978"/><a class="indexterm" id="iddle2048"/><a class="indexterm" id="iddle2124"/>This scope is indicated on the right with an empty box. (The <code class="literal">table</code> and <code class="literal">args</code> values are both empty, so we’ll ignore them for now.)</p><p>Next, the Ruby compiler steps down the AST tree and encounters <code class="literal">NODE_FCALL</code>, as shown in <a class="xref" href="ch02.html#to_compile_a_function_callcomma_ruby_fir" title="Figure 2-5. To compile a function call, Ruby first creates an instruction to push the receiver.">Figure 2-5</a>.</p><div class="figure"><a id="to_compile_a_function_callcomma_ruby_fir"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00044"/><img alt="To compile a function call, Ruby first creates an instruction to push the receiver." src="httpatomoreillycomsourcenostarchimages1853907.png.jpg"/></div></div><p class="title">Figure 2-5. To compile a function call, Ruby first creates an instruction to push the receiver.</p></div><p><code class="literal">NODE_FCALL</code> represents a <span class="emphasis"><em>function call</em></span>—in this case, the call to <code class="literal">puts</code>. (Function and method calls are very important and very common in Ruby programs.) Ruby compiles function calls for YARV according to the following pattern:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Push receiver.</p></li><li class="listitem"><p>Push arguments.</p></li><li class="listitem"><p>Call the method/function.</p></li></ul></div><p>In <a class="xref" href="ch02.html#to_compile_a_function_callcomma_ruby_fir" title="Figure 2-5. To compile a function call, Ruby first creates an instruction to push the receiver.">Figure 2-5</a>, the Ruby compiler first creates a YARV instruction called <code class="literal">putself</code> to indicate that the function call uses the current value of the <code class="literal">self</code> pointer as the receiver. Because I call <code class="literal">puts</code> from the top-level scope—that is, the top section—of this simple script, <code class="literal">self</code> is set to point to the <code class="literal">top self</code> object. (The <code class="literal">top self</code> object is an instance of the <code class="literal">Object</code> class that is automatically created when Ruby starts up. One purpose of <code class="literal">top self</code> is to serve as the receiver for function calls like this one in the top-level scope.)</p><div class="note" title="Note"><h3 class="title"><a id="ch02note02"/>Note</h3><p><span class="emphasis"><em>In Ruby all functions are actually methods. That is, functions are always associated with a Ruby class; there is always a receiver. Inside of Ruby, however, Ruby’s parser and compiler distinguish between functions and methods: Method calls have an explicit receiver, while function calls assume the receiver is the current value of <code class="literal">self</code></em></span>.</p></div><p>Next, Ruby needs to create instructions to push the arguments of the <code class="literal">puts</code> function call. But how? The argument to <code class="literal">puts</code> is <code class="literal">2+2</code>, which is the result of another method call. Although <code class="literal">2+2</code> is a simple expression, <code class="literal">puts</code> could instead be operating on some extremely complex Ruby expression involving many operators, method calls, and so on. How can Ruby know which instructions to create here?</p><p><a class="indexterm" id="iddle1890"/><a class="indexterm" id="iddle1991"/>The answer lies in the structure of the AST. By simply following the tree nodes down recursively, Ruby can take advantage of all the parser’s earlier work. In this case, it can now just step down to the <code class="literal">NODE_CALL</code> node, as shown in <a class="xref" href="ch02.html#nextcomma_ruby_writes_instructions_for_c" title="Figure 2-6. Next, Ruby writes instructions for calculating 2+2, the argument to puts.">Figure 2-6</a>.</p><div class="figure"><a id="nextcomma_ruby_writes_instructions_for_c"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00045"/><img alt="Next, Ruby writes instructions for calculating 2+2, the argument to puts." src="httpatomoreillycomsourcenostarchimages1853909.png.jpg"/></div></div><p class="title">Figure 2-6. Next, Ruby writes instructions for calculating <code class="literal">2+2</code>, the argument to <code class="literal">puts</code>.</p></div><p>Here Ruby will compile the <code class="literal">+</code> method call, which theoretically is the process of sending the <code class="literal">+</code> message to the <code class="literal">2</code> integer object. Again, following the same receiver, arguments, method call pattern, Ruby performs these actions in order:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>Creates a YARV instruction to push the receiver onto the stack (the object <code class="literal">2</code> in this case).</p></li><li class="listitem"><p>Creates a YARV instruction to push the argument or arguments onto the stack (again, <code class="literal">2</code> in this example).</p></li><li class="listitem"><p>Creates a method call YARV instruction <code class="literal">send &lt;callinfo!mid:+, argc:1, ARGS_SKIP&gt;</code> that means “send the + message” to the receiver, which is the object previously pushed onto the YARV stack (in this case, the first <code class="literal">Fixnum 2</code> object). <code class="literal">mid:+</code> means “method id = +” and is the name of the method we want to call. The <code class="literal">argc:1</code> parameter tells YARV there is one argument to this method call (the second <code class="literal">Fixnum 2</code> object). <code class="literal">ARGS_SKIP</code> indicates the arguments are simple values (not blocks or arrays of unnamed arguments), allowing YARV to skip some work it would have to do otherwise.</p></li></ol></div><p>When Ruby executes the <code class="literal">send &lt;callinfo!mid:+...</code> instruction it adds <code class="literal">2+2</code>, fetching those arguments from the stack, and leaves the result, <code class="literal">4</code>, as a new value on top of the stack. What’s fascinating about this is that YARV’s stack-oriented nature also helps Ruby compile the AST nodes more easily, as you can see when it finishes compiling the <code class="literal">NODE_FCALL</code>, as shown in <a class="xref" href="ch02.html#finallycomma_ruby_can_write_an_instructi" title="Figure 2-7. Finally, Ruby can write an instruction for the call to puts.">Figure 2-7</a>.</p><p>Now Ruby can assume that the return value of the <code class="literal">2+2</code> operation—that is, <code class="literal">4</code>—will be left at the top of the stack, just where it needs to be as the argument to the <code class="literal">puts</code> function call. Ruby’s stack-oriented virtual machine goes hand in hand with the way that it recursively compiles the AST nodes! As you can see at the right of <a class="xref" href="ch02.html#finallycomma_ruby_can_write_an_instructi" title="Figure 2-7. Finally, Ruby can write an instruction for the call to puts.">Figure 2-7</a>, Ruby has added the <code class="literal">send &lt;callinfo!mid:puts, argc:1</code> instruction, which calls <code class="literal">puts</code> and indicates that there is one argument to <code class="literal">puts</code>.</p><div class="figure"><a id="finallycomma_ruby_can_write_an_instructi"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00046"/><img alt="Finally, Ruby can write an instruction for the call to puts." src="httpatomoreillycomsourcenostarchimages1853911.png.jpg"/></div></div><p class="title">Figure 2-7. Finally, Ruby can write an instruction for the call to <code class="literal">puts</code>.</p></div><p><a class="indexterm" id="iddle1083"/><a class="indexterm" id="iddle1178"/><a class="indexterm" id="iddle1759"/><a class="indexterm" id="iddle1761"/><a class="indexterm" id="iddle1997"/><a class="indexterm" id="iddle2119"/><a class="indexterm" id="iddle2121"/>As it turns out, Ruby further modifies these YARV instructions before executing them as part of an optimize step. One of its optimizations is to replace some YARV instructions with <span class="emphasis"><em>specialized instructions</em></span>, which are YARV instructions that represent commonly used operations, such as <code class="literal">size</code>, <code class="literal">not</code>, <code class="literal">less than</code>, <code class="literal">greater than</code>, and so on. One such instruction, <code class="literal">opt_plus</code>, is used for adding two numbers together. During optimization, Ruby replaces <code class="literal">send &lt;callinfo!mid:+...</code> with <code class="literal">opt_plus</code>, as shown in <a class="xref" href="ch02.html#ruby_replaces_some_instructions_with_spe" title="Figure 2-8. Ruby replaces some instructions with specialized instructions.">Figure 2-8</a>.</p><div class="figure"><a id="ruby_replaces_some_instructions_with_spe"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00047"/><img alt="Ruby replaces some instructions with specialized instructions." src="httpatomoreillycomsourcenostarchimages1853913.png.jpg"/></div></div><p class="title">Figure 2-8. Ruby replaces some instructions with specialized instructions.</p></div><p>As you can see in <a class="xref" href="ch02.html#ruby_replaces_some_instructions_with_spe" title="Figure 2-8. Ruby replaces some instructions with specialized instructions.">Figure 2-8</a>, Ruby also replaces the second <code class="literal">send</code> with <code class="literal">opt_send_simple</code>, which runs a bit faster when all of the arguments are simple values.</p></div><div class="sect1" title="Compiling a Call to a Block"><div class="titlepage"><div><div><h1 class="title"><a id="compiling_a_call_to_a_block"/>Compiling a Call to a Block</h1></div></div></div><p>Next, let’s compile my <code class="literal">10.times do</code> example from <a class="xref" href="ch01.html#very_simple_ruby_program_left_parenthe" title="Example 1-1. A very simple Ruby program (simple.rb)">Example 1-1</a> in <a class="xref" href="ch01.html" title="Chapter 1. Tokenization and Parsing">Chapter 1</a> (see <a class="xref" href="ch02.html#simple_script_that_calls_a_block" title="Example 2-2. A simple script that calls a block">Example 2-2</a>).</p><div class="example"><a id="simple_script_that_calls_a_block"/><p class="title">Example 2-2. A simple script that calls a block</p><div class="example-contents"><pre class="programlisting">10.times do |n|
  puts n
end</pre></div></div><p><a class="indexterm" id="iddle1048"/><a class="indexterm" id="iddle1727"/>Notice that this example contains a block parameter to the <code class="literal">times</code> method. This is interesting because it will give us a chance to see how the Ruby compiler handles blocks. <a class="xref" href="ch02.html#ast_for_the_call_to_10dottimescomma" title="Figure 2-9. The AST for the call to 10.times, passing a block">Figure 2-9</a> shows the AST for the <code class="literal">10.times do</code> example again, using the actual node names rather than the simplified output from Ripper.</p><div class="figure"><a id="ast_for_the_call_to_10dottimescomma"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00048"/><img alt="The AST for the call to 10.times, passing a block" src="httpatomoreillycomsourcenostarchimages1853915.png.jpg"/></div></div><p class="title">Figure 2-9. The AST for the call to <code class="literal">10.times</code>, passing a block</p></div><p>This looks very different than <code class="literal">puts 2+2</code>, mostly because of the inner block shown at the right. (Ruby handles the inner block differently, as we’ll see shortly.)</p><p>Let’s break down how Ruby compiles the main portion of the script shown on the left of <a class="xref" href="ch02.html#ast_for_the_call_to_10dottimescomma" title="Figure 2-9. The AST for the call to 10.times, passing a block">Figure 2-9</a>. As before, Ruby starts with the first <code class="literal">NODE_SCOPE</code> and creates a new snippet of YARV instructions, as shown in <a class="xref" href="ch02.html#each_nodeunderscorescope_is_compiled_int" title="Figure 2-10. Each NODE_SCOPE is compiled into a new snippet of YARV instructions.">Figure 2-10</a>.</p><div class="figure"><a id="each_nodeunderscorescope_is_compiled_int"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00049"/><img alt="Each NODE_SCOPE is compiled into a new snippet of YARV instructions." src="httpatomoreillycomsourcenostarchimages1853917.png.jpg"/></div></div><p class="title">Figure 2-10. Each <code class="literal">NODE_SCOPE</code> is compiled into a new snippet of YARV instructions.</p></div><p>Next, Ruby steps down the AST nodes to <code class="literal">NODE_ITER</code>, as shown in <a class="xref" href="ch02.html#ruby_stepping_through_an_ast" title="Figure 2-11. Ruby stepping through an AST">Figure 2-11</a>.</p><div class="figure"><a id="ruby_stepping_through_an_ast"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00050"/><img alt="Ruby stepping through an AST" src="httpatomoreillycomsourcenostarchimages1853919.png.jpg"/></div></div><p class="title">Figure 2-11. Ruby stepping through an AST</p></div><p>At this point, there is still no code generated, but notice in <a class="xref" href="ch02.html#ast_for_the_call_to_10dottimescomma" title="Figure 2-9. The AST for the call to 10.times, passing a block">Figure 2-9</a> that two arrows lead from <code class="literal">NODE_ITER</code>: one to <code class="literal">NODE_CALL</code>, which represents the <code class="literal">10.times</code> call, and another to the inner block. Ruby will first continue down the AST and compile the nodes corresponding to the <code class="literal">10.times</code> code. The resulting YARV code, following the same receiver-arguments-message pattern we saw in <a class="xref" href="ch02.html#nextcomma_ruby_writes_instructions_for_c" title="Figure 2-6. Next, Ruby writes instructions for calculating 2+2, the argument to puts.">Figure 2-6</a>, is shown in <a class="xref" href="ch02.html#ruby_compiles_the_10dottimes_method_call" title="Figure 2-12. Ruby compiles the 10.times method call.">Figure 2-12</a>.</p><div class="figure"><a id="ruby_compiles_the_10dottimes_method_call"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00051"/><img alt="Ruby compiles the 10.times method call." src="httpatomoreillycomsourcenostarchimages1853921.png.jpg"/></div></div><p class="title">Figure 2-12. Ruby compiles the <code class="literal">10.times</code> method call.</p></div><p>Notice that the new YARV instructions shown in <a class="xref" href="ch02.html#ruby_compiles_the_10dottimes_method_call" title="Figure 2-12. Ruby compiles the 10.times method call.">Figure 2-12</a> push the receiver (the integer object <code class="literal">10</code>) onto the stack first, after which Ruby generates an instruction to execute the <code class="literal">times</code> method call. But notice, too, the <code class="literal">block:block in &lt;compiled&gt;</code> argument in the <code class="literal">send</code> instruction. This indicates that the method call also contains a block argument: my <code class="literal">do |n| puts n end</code> block. In this example, <code class="literal">NODE_ITER</code> has caused the Ruby compiler to include this block argument because the AST above shows an arrow from <code class="literal">NODE_ITER</code> to the second <code class="literal">NODE_SCOPE</code>.</p><p><a class="indexterm" id="iddle1045"/><a class="indexterm" id="iddle1047"/><a class="indexterm" id="iddle1724"/><a class="indexterm" id="iddle1726"/>Ruby continues by compiling the inner block, beginning with the second <code class="literal">NODE_SCOPE</code> shown at right in <a class="xref" href="ch02.html#ast_for_the_call_to_10dottimescomma" title="Figure 2-9. The AST for the call to 10.times, passing a block">Figure 2-9</a>. <a class="xref" href="ch02.html#branch_of_the_ast_for_the_contents_o" title="Figure 2-13. The branch of the AST for the contents of the block">Figure 2-13</a> shows what the AST for that inner block looks like.</p><p>This looks simple enough—just a single function call and a single argument <code class="literal">n</code>. But notice the value for <code class="literal">table</code> and <code class="literal">args</code> in <code class="literal">NODE_SCOPE</code>. These values were empty in the parent <code class="literal">NODE_SCOPE</code>, but they’re set here in the inner <code class="literal">NODE_SCOPE</code>. As you might guess, these values indicate the presence of the block parameter <code class="literal">n</code>.</p><div class="figure"><a id="branch_of_the_ast_for_the_contents_o"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00052"/><img alt="The branch of the AST for the contents of the block" src="httpatomoreillycomsourcenostarchimages1853923.png.jpg"/></div></div><p class="title">Figure 2-13. The branch of the AST for the contents of the block</p></div><p>Also notice that the Ruby parser created <code class="literal">NODE_DVAR</code> instead of <code class="literal">NODE_LIT</code>, which we saw earlier in <a class="xref" href="ch02.html#ast_for_the_call_to_10dottimescomma" title="Figure 2-9. The AST for the call to 10.times, passing a block">Figure 2-9</a>. This is the case because <code class="literal">n</code> is not just a literal string; it’s a block parameter passed in from the parent scope.</p><p>From a relatively high level, <a class="xref" href="ch02.html#how_ruby_compiles_a_call_to_a_block" title="Figure 2-14. How Ruby compiles a call to a block">Figure 2-14</a> shows how Ruby compiles the inner block.</p><div class="sidebar"><a id="how_ruby_iterates_through_the_ast"/><p class="title">How Ruby Iterates Through the AST</p><p><a class="indexterm" id="iddle1177"/><a class="indexterm" id="iddle1456"/><a class="indexterm" id="iddle1457"/><a class="indexterm" id="iddle1891"/>Let’s look more closely at how Ruby actually iterates through the AST structure, converting each node into YARV instructions. The MRI C source code file that implements the Ruby compiler is called <span class="emphasis"><em>compile.c</em></span>. To learn how the code in <span class="emphasis"><em>compile.c</em></span> works, we first look for the function <code class="literal">iseq_compile_each</code>. <a class="xref" href="ch02.html#this_c_function_compiles_each_node_in_th" title="Example 2-3. This C function compiles each node in the AST.">Example 2-3</a> shows the beginning of that function.</p><div class="example"><a id="this_c_function_compiles_each_node_in_th"/><p class="title">Example 2-3. This C function compiles each node in the AST.</p><div class="example-contents"><pre class="programlisting">/**
  compile each node

  self:  InstructionSequence
  node:  Ruby compiled node
  poped: This node will be poped
 */
static int
iseq_compile_each(rb_iseq_t *iseq, LINK_ANCHOR *ret, NODE * node,
                  int poped)
{</pre></div></div><p>This function is very long, with a very, very long <code class="literal">switch</code> statement that runs to thousands of lines! The <code class="literal">switch</code> statement branches based on the type of the current AST node and generates the corresponding YARV code. <a class="xref" href="ch02.html#this_c_switch_statement_looks_at_the_typ" title="Example 2-4. This C switch statement looks at the type of each AST node.">Example 2-4</a> shows the start of the <code class="literal">switch</code> statement <span class="inlinemediaobject"><a id="inline_id00028"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>.</p><div class="example"><a id="this_c_switch_statement_looks_at_the_typ"/><p class="title">Example 2-4. This C <code class="literal">switch</code> statement looks at the type of each AST node.</p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> type = nd_type(node);
    --<span class="emphasis"><em>snip</em></span>--
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> switch (type) {</pre></div></div><p>In this statement, <code class="literal">node</code> <span class="inlinemediaobject"><a id="inline_id00031"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> is a parameter passed into <code class="literal">iseq_compile_each</code>, and <code class="literal">nd_type</code> is a C macro that returns the type from the given node structure.</p><p>Now we’ll look at how Ruby compiles function or method call nodes into YARV instructions using the receiver-arguments-function call pattern. First, search <span class="emphasis"><em>compile.c</em></span> for the C <code class="literal">case</code> statement shown in <a class="xref" href="ch02.html#this_case_of_the_switch_compiles_method" title="Example 2-5. This case of the switch compiles method calls in your Ruby code.">Example 2-5</a>.</p><div class="example"><a id="this_case_of_the_switch_compiles_method"/><p class="title">Example 2-5. This case of the switch compiles method calls in your Ruby code.</p><div class="example-contents"><pre class="programlisting">case NODE_CALL:
case NODE_FCALL:
case NODE_VCALL:{                /* VCALL: variable or call */
  /*
    call:  obj.method(...)
    fcall: func(...)
    vcall: func
  */</pre></div></div><p><code class="literal">NODE_CALL</code> represents a real method call (like <code class="literal">10.times</code>), <code class="literal">NODE_FCALL</code> is a function call (like <code class="literal">puts</code>), and <code class="literal">NODE_VCALL</code> is a variable or function call. Skipping over some of the C <a class="indexterm" id="iddle1362"/><a class="indexterm" id="iddle2032"/>code details (including the optional <code class="literal">SUPPORT_JOKE</code> code used for implementing the <code class="literal">goto</code> statement), <a class="xref" href="ch02.html#this_c_code_compiles_the_receiver_value" title="Example 2-6. This C code compiles the receiver value for a method call.">Example 2-6</a> shows what Ruby does next to compile these AST nodes.</p><div class="example"><a id="this_c_code_compiles_the_receiver_value"/><p class="title">Example 2-6. This C code compiles the receiver value for a method call.</p><div class="example-contents"><pre class="programlisting">    /* receiver */
    if (type == NODE_CALL) {
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>     COMPILE(recv, "recv", node-&gt;nd_recv);
    }
    else if (type == NODE_FCALL || type == NODE_VCALL) {
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>     ADD_CALL_RECEIVER(recv, nd_line(node));
    }</pre></div></div><p>Here, Ruby calls either <code class="literal">COMPILE</code> or <code class="literal">ADD_CALL_RECEIVER</code> as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>In the case of real method calls (like <code class="literal">NODE_CALL</code>), Ruby calls <code class="literal">COMPILE</code> <span class="inlinemediaobject"><a id="inline_id00034"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> to recursively call into <code class="literal">iseq_compile_each</code> again, processing the next AST node down the tree that corresponds to the receiver of the method call or message. This will create YARV instructions to evaluate whatever expression was used to specify the target object.</p></li><li class="listitem"><p>If there is no receiver (<code class="literal">NODE_FCALL</code> or <code class="literal">NODE_VCALL</code>), Ruby calls <code class="literal">ADD_CALL_RECEIVER</code> <span class="inlinemediaobject"><a id="inline_id00035"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>, which creates a <code class="literal">putself</code> YARV instruction.</p></li></ul></div><p>Next, as shown in <a class="xref" href="ch02.html#this_snippet_of_c_code_compiles_the_argu" title="Example 2-7. This snippet of C code compiles the arguments to every Ruby method call.">Example 2-7</a>, Ruby creates YARV instructions to push each argument of the method/function call onto the stack.</p><div class="example"><a id="this_snippet_of_c_code_compiles_the_argu"/><p class="title">Example 2-7. This snippet of C code compiles the arguments to every Ruby method call.</p><div class="example-contents"><pre class="programlisting">    /* args */
    if (nd_type(node) != NODE_VCALL) {
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/>     argc = setup_args(iseq, args, node-&gt;nd_args, &amp;flag);
    }
    else {
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/>     argc = INT2FIX(0);
    }</pre></div></div><p>For <code class="literal">NODE_CALL</code> and <code class="literal">NODE_FCALL</code>, Ruby calls into the <code class="literal">setup_args</code> function <span class="inlinemediaobject"><a id="inline_id00038"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>, which will recursively call into <code class="literal">iseq_compile_each</code> again as needed in order to compile each argument to the method/function call. For <code class="literal">NODE_VCALL</code>, there are no arguments, so Ruby simply sets <code class="literal">argc</code> to 0 <span class="inlinemediaobject"><a id="inline_id00039"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>.</p><p>Finally, Ruby creates YARV instructions to execute the actual method or function call, as shown here:</p><a id="pro_id00001"/><pre class="programlisting">ADD_SEND_R(ret, nd_line(node), ID2SYM(mid),
           argc, parent_block, LONG2FIX(flag));</pre><p>This C macro will create the new <code class="literal">send</code> YARV instruction, which will cause the actual method call to occur when YARV executes it.</p></div><div class="figure"><a id="how_ruby_compiles_a_call_to_a_block"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00053"/><img alt="How Ruby compiles a call to a block" src="httpatomoreillycomsourcenostarchimages1853925.png.jpg"/></div></div><p class="title">Figure 2-14. How Ruby compiles a call to a block</p></div><p><a class="indexterm" id="iddle1144"/><a class="indexterm" id="iddle1289"/><a class="indexterm" id="iddle1952"/><a class="indexterm" id="iddle2113"/>You can see the parent <code class="literal">NODE_SCOPE</code> at the top, along with the YARV code from <a class="xref" href="ch02.html#ruby_compiles_the_10dottimes_method_call" title="Figure 2-12. Ruby compiles the 10.times method call.">Figure 2-12</a>. Below that I’ve listed the YARV code compiled from the inner block’s AST.</p><p>The key point here is that Ruby compiles each distinct scope in your Ruby program—methods, blocks, classes, or modules, for example—into a separate snippet of YARV instructions.</p></div><div class="sect1" title="Experiment 2-1: Displaying YARV Instructions"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_2-1_displaying_yarv_instructi"/>Experiment 2-1: Displaying YARV Instructions</h1></div></div></div><p>One easy way to see how Ruby compiles your code is with the <code class="literal">RubyVM::InstructionSequence</code> object, which gives you access to Ruby’s YARV engine from your Ruby program! Like the Ripper tool, its use is very straightforward, as you can see in <a class="xref" href="ch02.html#how_to_view_the_yarv_instructions_for_pu" title="Example 2-8. How to view the YARV instructions for puts 2+2">Example 2-8</a>.</p><div class="example"><a id="how_to_view_the_yarv_instructions_for_pu"/><p class="title">Example 2-8. How to view the YARV instructions for <code class="literal">puts 2+2</code></p><div class="example-contents"><pre class="programlisting">code = &lt;&lt;END
puts 2+2
END
puts RubyVM::InstructionSequence.compile(code).disasm</pre></div></div><p>The challenge lies in understanding what the output actually means. For example, <a class="xref" href="ch02.html#yarv_instructions_for_puts_2plus2" title="Example 2-9. The YARV instructions for puts 2+2">Example 2-9</a> shows the output for <code class="literal">puts 2+2</code>.</p><div class="example"><a id="yarv_instructions_for_puts_2plus2"/><p class="title">Example 2-9. The YARV instructions for <code class="literal">puts 2+2</code></p><div class="example-contents"><pre class="programlisting">    == disasm: &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;==========
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> 0000 trace            1                                               (   1)
    0002 putself
    0003 putobject        2
    0005 putobject        2
    0007 opt_plus         &lt;callinfo!mid:+, argc:1, ARGS_SKIP&gt;
    0009 opt_send_simple  &lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SKIP&gt;
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> 0011 leave</pre></div></div><p><a class="indexterm" id="iddle1533"/><a class="indexterm" id="iddle1652"/><a class="indexterm" id="iddle1987"/><a class="indexterm" id="iddle2054"/><a class="indexterm" id="iddle2116"/><a class="indexterm" id="iddle2132"/>As you can see in <a class="xref" href="ch02.html#yarv_instructions_for_puts_2plus2" title="Example 2-9. The YARV instructions for puts 2+2">Example 2-9</a>, the output contains all of the same instructions from <a class="xref" href="ch02.html#to_compile_a_function_callcomma_ruby_fir" title="Figure 2-5. To compile a function call, Ruby first creates an instruction to push the receiver.">Figure 2-5</a> to <a class="xref" href="ch02.html#ruby_replaces_some_instructions_with_spe" title="Figure 2-8. Ruby replaces some instructions with specialized instructions.">Figure 2-8</a> and two new ones: <code class="literal">trace</code> <span class="inlinemediaobject"><a id="inline_id00042"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> and <code class="literal">leave</code> <span class="inlinemediaobject"><a id="inline_id00043"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>. The <code class="literal">trace</code> instruction is used to implement the <code class="literal">set_trace_func</code> feature, which will call a given function for each Ruby statement executed in your program. The <code class="literal">leave</code> function is like a return statement. The line numbers on the left show the position of each instruction in the bytecode array that the compiler actually produces.</p><p><code class="literal">RubyVM::InstructionSequence</code> makes it easy to explore how Ruby compiles different Ruby scripts. For example, <a class="xref" href="ch02.html#displaying_the_yarv_instructions_for_a_c" title="Example 2-10. Displaying the YARV instructions for a call to a block">Example 2-10</a> shows how to compile my <code class="literal">10.times do</code> example.</p><div class="example"><a id="displaying_the_yarv_instructions_for_a_c"/><p class="title">Example 2-10. Displaying the YARV instructions for a call to a block</p><div class="example-contents"><pre class="programlisting">code = &lt;&lt;END
10.times do |n|
  puts n
end
END
puts RubyVM::InstructionSequence.compile(code).disasm</pre></div></div><p>The output that I get now is shown below in <a class="xref" href="ch02.html#yarv_instructions_for_a_call_to_a_bl" title="Example 2-11. The YARV instructions for a call to a block and for the block itself">Example 2-11</a>. Notice that the <code class="literal">send &lt;callinfo!mid:times</code> YARV instruction shows <code class="literal">block:block in &lt;compiled&gt;</code> <span class="inlinemediaobject"><a id="inline_id00044"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>, which indicates that I’m passing a block to the <code class="literal">10.times</code> method call.</p><div class="example"><a id="yarv_instructions_for_a_call_to_a_bl"/><p class="title">Example 2-11. The YARV instructions for a call to a block and for the block itself</p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> == disasm: &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;==========
    == catch table
    | catch type: break  st: 0002 ed: 0006 sp: 0000 cont: 0006
    |------------------------------------------------------------------------
    0000 trace            1                                               (   1)
    0002 putobject        10
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> 0004 send             &lt;callinfo!mid:times, argc:0, block:block in &lt;compiled&gt;&gt;
    0006 leave
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/> == disasm: &lt;RubyVM::InstructionSequence:block in &lt;compiled&gt;@&lt;compiled&gt;&gt;=
    == catch table
    | catch type: redo   st: 0000 ed: 0011 sp: 0000 cont: 0000
    | catch type: next   st: 0000 ed: 0011 sp: 0000 cont: 0011
    |------------------------------------------------------------------------
    local table (size: 2, argc: 1 [opts: 0, rest: -1, post: 0, block: -1] s3)
    [ 2] n&lt;Arg&gt;
    0000 trace            256                                             (   1)
    0002 trace            1                                               (   2)
    0004 putself
    0005 getlocal_OP__WC__0 2
    0007 opt_send_simple  &lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SKIP&gt;
    0009 trace            512                                             (   3)
    0011 leave                                                            (   2)</pre></div></div><p>As you can see, Ruby displays the two YARV instruction snippets separately. The first corresponds to the global scope <span class="inlinemediaobject"><a id="inline_id00048"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span> and the second to the inner block scope <span class="inlinemediaobject"><a id="inline_id00049"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span>.</p></div><div class="sect1" title="The Local Table"><div class="titlepage"><div><div><h1 class="title"><a id="local_table"/>The Local Table</h1></div></div></div><p><a class="indexterm" id="iddle1050"/><a class="indexterm" id="iddle1553"/><a class="indexterm" id="iddle1729"/>In <a class="xref" href="ch02.html#ast_ruby_produces_after_parsing_the" title="Figure 2-3. The AST Ruby produces after parsing the code in Example 2-1">Figure 2-3</a> through <a class="xref" href="ch02.html#how_ruby_compiles_a_call_to_a_block" title="Figure 2-14. How Ruby compiles a call to a block">Figure 2-14</a>, you may have noticed that each <code class="literal">NODE_SCOPE</code> element in the AST contained information I labeled <code class="literal">table</code> and <code class="literal">args</code>. These values in the inner <code class="literal">NODE_SCOPE</code> structure contain information about the block’s parameter <code class="literal">n</code> (see <a class="xref" href="ch02.html#ast_for_the_call_to_10dottimescomma" title="Figure 2-9. The AST for the call to 10.times, passing a block">Figure 2-9</a>).</p><p>Ruby generated the information about this block parameter during the parsing process. As I discussed in <a class="xref" href="ch01.html" title="Chapter 1. Tokenization and Parsing">Chapter 1</a>, Ruby parses the block parameter along with the rest of my Ruby code using grammar rules. In fact, I showed the specific rule for parsing block parameters back in <a class="xref" href="ch01.html#entire_block_matches_the_braceunders" title="Figure 1-30. The entire block matches the brace_block rule.">Figure 1-30</a>: <code class="literal">opt_block_param</code>.</p><p>Once Ruby’s compiler runs, however, the information about the block parameter is copied out of the AST and into another data structure called the <span class="emphasis"><em>local table</em></span>, saved nearby the newly generated YARV instructions. Each snippet of YARV instructions, each scope in your Ruby program, has its own local table.</p><p><a class="xref" href="ch02.html#snippet_of_yarv_instructions_with_a_lo" title="Figure 2-15. A snippet of YARV instructions with a local table">Figure 2-15</a> shows the local table attached to the YARV instructions that Ruby generated for the sample block code from <a class="xref" href="ch02.html#simple_script_that_calls_a_block" title="Example 2-2. A simple script that calls a block">Example 2-2</a>.</p><div class="figure"><a id="snippet_of_yarv_instructions_with_a_lo"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00054"/><img alt="A snippet of YARV instructions with a local table" src="httpatomoreillycomsourcenostarchimages1853927.png.jpg"/></div></div><p class="title">Figure 2-15. A snippet of YARV instructions with a local table</p></div><p>Notice on the right side of <a class="xref" href="ch02.html#snippet_of_yarv_instructions_with_a_lo" title="Figure 2-15. A snippet of YARV instructions with a local table">Figure 2-15</a> that Ruby has associated the number 2 with the block parameter <code class="literal">n</code>. As we’ll see in <a class="xref" href="ch03.html" title="Chapter 3. How Ruby Executes Your Code">Chapter 3</a>, the YARV instructions that refer to <code class="literal">n</code> will use this index 2. The <code class="literal">getlocal</code> instruction is an example of this. The <code class="literal">&lt;Arg&gt;</code> notation indicates that this value is an argument to the block.</p><p>As it turns out, Ruby also saves information about local variables in this table, hence the name <span class="emphasis"><em>local table</em></span>. <a class="xref" href="ch02.html#this_local_table_contains_one_local_vari" title="Figure 2-16. This local table contains one local variable and two arguments.">Figure 2-16</a> shows the YARV instructions and local table Ruby will generate when compiling a method that uses one local variable and takes two arguments.</p><div class="figure"><a id="this_local_table_contains_one_local_vari"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00055"/><img alt="This local table contains one local variable and two arguments." src="httpatomoreillycomsourcenostarchimages1853929.png.jpg"/></div></div><p class="title">Figure 2-16. This local table contains one local variable and two arguments.</p></div><p><a class="indexterm" id="iddle1001"/><a class="indexterm" id="iddle1003"/><a class="indexterm" id="iddle1017"/><a class="indexterm" id="iddle1024"/><a class="indexterm" id="iddle1224"/><a class="indexterm" id="iddle2008"/><a class="indexterm" id="iddle2062"/><a class="indexterm" id="iddle2071"/>Here, you can see that Ruby lists all three values in the local table. As we’ll see in <a class="xref" href="ch03.html" title="Chapter 3. How Ruby Executes Your Code">Chapter 3</a>, Ruby treats local variables and method arguments in the same way. (Notice that the local variable <code class="literal">sum</code> does not have the <code class="literal">&lt;Arg&gt;</code> label.)</p><p>Think of the local table as a key to help you understand what the YARV instructions do, similar to the legend on a map. As you can see in <a class="xref" href="ch02.html#this_local_table_contains_one_local_vari" title="Figure 2-16. This local table contains one local variable and two arguments.">Figure 2-16</a>, local variables have no label, but Ruby uses the following labels to describe different types of method and block arguments:</p><div class="informaltable"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col/><col/></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><span class="strong"><strong><code class="literal">&lt;Arg&gt;</code></strong></span></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>A standard method or block argument</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><span class="strong"><strong><code class="literal">&lt;Rest&gt;</code></strong></span></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>An array of unnamed arguments that are passed together using a splat (<code class="literal">*</code>) operator</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><span class="strong"><strong><code class="literal">&lt;Post&gt;</code></strong></span></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>A standard argument that appears after the splat array</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; " valign="top"><p><span class="strong"><strong><code class="literal">&lt;Block&gt;</code></strong></span></p></td><td style="border-bottom: 0.5pt solid ; " valign="top"><p>A Ruby proc object that is passed using the <code class="literal">&amp;</code> operator</p></td></tr><tr><td style="border-right: 0.5pt solid ; " valign="top"><p><span class="strong"><strong><code class="literal">&lt;Opt=i&gt;</code></strong></span></p></td><td style="" valign="top"><p>A parameter defined with a default value. The integer value <code class="literal">i</code> is an index into a table that stores the actual default value. This table is stored along with the YARV snippet but not in the local table itself.</p></td></tr></tbody></table></div><p>Understanding the information displayed by the local table can help you understand how Ruby’s complex argument syntax works and how to take full advantage of the language.</p><p>To help you understand what I mean, let’s look at how Ruby compiles a method call that uses an array of unnamed arguments, as shown <a class="xref" href="ch02.html#method_that_takes_standard_arguments_a" title="Example 2-12. A method that takes standard arguments and an array of unnamed arguments">Example 2-12</a>.</p><div class="example"><a id="method_that_takes_standard_arguments_a"/><p class="title">Example 2-12. A method that takes standard arguments and an array of unnamed arguments</p><div class="example-contents"><pre class="programlisting">def complex_formula(a, b, *args, c)
  a + b + args.size + c
end</pre></div></div><p><a class="indexterm" id="iddle1021"/><a class="indexterm" id="iddle1180"/><a class="indexterm" id="iddle1756"/>Here <code class="literal">a</code>, <code class="literal">b</code>, and <code class="literal">c</code> are standard arguments, and <code class="literal">args</code> is an array of other arguments that appear between <code class="literal">b</code> and <code class="literal">c</code>. <a class="xref" href="ch02.html#ruby_saves_information_about_special_arg" title="Figure 2-17. Ruby saves information about special arguments in the local table.">Figure 2-17</a> shows how the local table saves all of this information.</p><p>As in <a class="xref" href="ch02.html#this_local_table_contains_one_local_vari" title="Figure 2-16. This local table contains one local variable and two arguments.">Figure 2-16</a>, <code class="literal">&lt;Arg&gt;</code> refers to a standard argument. But now Ruby uses <code class="literal">&lt;Rest&gt;</code> to indicate that value 3 contains the “rest” of the arguments and <code class="literal">&lt;Post&gt;</code> to indicate that value 2 contains the argument that appears after the unnamed array, the last one.</p><div class="figure"><a id="ruby_saves_information_about_special_arg"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00056"/><img alt="Ruby saves information about special arguments in the local table." src="httpatomoreillycomsourcenostarchimages1853931.png.jpg"/></div></div><p class="title">Figure 2-17. Ruby saves information about special arguments in the local table.</p></div><div class="sect2" title="Compiling Optional Arguments"><div class="titlepage"><div><div><h2 class="title"><a id="compiling_optional_arguments"/>Compiling Optional Arguments</h2></div></div></div><p>As you probably know, you can make an argument optional by specifying a default value for it in the argument list. Later, Ruby will use the default value if you don’t provide a value for that argument when you call the method or block. <a class="xref" href="ch02.html#method_that_takes_an_optional_argument" title="Example 2-13. A method that takes an optional argument">Example 2-13</a> shows a simple example.</p><div class="example"><a id="method_that_takes_an_optional_argument"/><p class="title">Example 2-13. A method that takes an optional argument</p><div class="example-contents"><pre class="programlisting">def add_two_optional(a, b = 5)
  sum = a+b
end</pre></div></div><p><a class="indexterm" id="iddle1018"/><a class="indexterm" id="iddle1179"/><a class="indexterm" id="iddle1497"/>If you provide a value for <code class="literal">b</code>, the method will use that value as follows:</p><a id="pro_id00002"/><pre class="programlisting">puts add_two_optional(2, 2)
 =&gt; 4</pre><p>But if you don’t, Ruby will assign the default value of 5 to <code class="literal">b</code>:</p><a id="pro_id00003"/><pre class="programlisting">puts add_two_optional(2)
 =&gt; 7</pre><p>Ruby has a bit more work to do in this situation. Where does the default value go? Where does the Ruby compiler put it? <a class="xref" href="ch02.html#rubyapostrophes_compiler_generates_extra" title="Figure 2-18. Ruby’s compiler generates extra code to handle optional arguments.">Figure 2-18</a> shows how Ruby generates a few extra YARV instructions during the compile process that set the default value.</p><div class="figure"><a id="rubyapostrophes_compiler_generates_extra"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00057"/><img alt="Ruby’s compiler generates extra code to handle optional arguments." src="httpatomoreillycomsourcenostarchimages1853933.png.jpg"/></div></div><p class="title">Figure 2-18. Ruby’s compiler generates extra code to handle optional arguments.</p></div><p>Ruby’s compiler generates the bolded YARV instructions, <code class="literal">putobject</code> and <code class="literal">setlocal</code>, to set the value of <code class="literal">b</code> to 5 when you call the method. (As we’ll see in <a class="xref" href="ch03.html" title="Chapter 3. How Ruby Executes Your Code">Chapter 3</a>, YARV will call these instructions if you don’t provide a value for <code class="literal">b</code> but skip them if you do.) You can also see that Ruby lists the optional argument <code class="literal">b</code> in the local table as <code class="literal">b&lt;Opt=0&gt;</code>. The <code class="literal">0</code> here is an index into a table that stores the default values for all the arguments. Ruby stores this data near the YARV snippet but not in the local table itself.</p></div><div class="sect2" title="Compiling Keyword Arguments"><div class="titlepage"><div><div><h2 class="title"><a id="compiling_keyword_arguments"/>Compiling Keyword Arguments</h2></div></div></div><p>In Ruby 2.0, we can specify a name along with a default value for each method or block argument. Arguments written this way are known as <span class="emphasis"><em>keyword arguments</em></span>. For example, <a class="xref" href="ch02.html#method_that_takes_a_keyword_argument" title="Example 2-14. A method that takes a keyword argument">Example 2-14</a> shows the same argument <code class="literal">b</code> declared using Ruby 2.0’s new keyword argument syntax.</p><div class="example"><a id="method_that_takes_a_keyword_argument"/><p class="title">Example 2-14. A method that takes a keyword argument</p><div class="example-contents"><pre class="programlisting">def add_two_keyword(a, b: 5)
  sum = a+b
end</pre></div></div><p>Now to provide a value for <code class="literal">b</code>, I need to use its name:</p><a id="pro_id00004"/><pre class="programlisting">puts add_two_keyword(2, b: 2)
 =&gt; 4</pre><p>Or, if I don’t specify <code class="literal">b</code> at all, Ruby will use the default value:</p><a id="pro_id00005"/><pre class="programlisting">puts add_two_keyword(2)
 =&gt; 7</pre><p>How does Ruby compile keyword arguments? <a class="xref" href="ch02.html#ruby_compiler_generates_many_more_in" title="Figure 2-19. The Ruby compiler generates many more instructions to handle keyword arguments.">Figure 2-19</a> shows Ruby needs to add quite a bit of additional code to the method’s YARV snippet.</p><div class="figure"><a id="ruby_compiler_generates_many_more_in"/><div class="figure-contents"><div class="mediaobject"><a id="med_id00058"/><img alt="The Ruby compiler generates many more instructions to handle keyword arguments." src="httpatomoreillycomsourcenostarchimages1853935.png.jpg"/></div></div><p class="title">Figure 2-19. The Ruby compiler generates many more instructions to handle keyword arguments.</p></div><p><a class="indexterm" id="iddle1145"/><a class="indexterm" id="iddle1236"/><a class="indexterm" id="iddle1279"/><a class="indexterm" id="iddle1953"/>The Ruby compiler generates all of the YARV instructions in bold—13 new instructions—to implement the keyword argument <code class="literal">b</code>. In <a class="xref" href="ch03.html" title="Chapter 3. How Ruby Executes Your Code">Chapter 3</a> and <a class="xref" href="ch04.html" title="Chapter 4. Control Structures and Method Dispatch">Chapter 4</a>, I’ll cover how YARV works in detail and what these instructions actually mean, but for now, we can guess what’s going on here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>In the local table, we can see a new mystery value shown as <code class="literal">[ 3]?</code>.</p></li><li class="listitem"><p>To the left of <a class="xref" href="ch02.html#ruby_compiler_generates_many_more_in" title="Figure 2-19. The Ruby compiler generates many more instructions to handle keyword arguments.">Figure 2-19</a>, new YARV instructions call the <code class="literal">key?</code> and <code class="literal">delete</code> methods.</p></li></ul></div><p>Which Ruby class contains the <code class="literal">key?</code> and <code class="literal">delete</code> methods? The <code class="literal">Hash</code>. <a class="xref" href="ch02.html#ruby_compiler_generates_many_more_in" title="Figure 2-19. The Ruby compiler generates many more instructions to handle keyword arguments.">Figure 2-19</a> shows evidence that Ruby must implement keyword arguments using an internal, hidden hash object. All of these additional YARV instructions automatically add some logic to my method that checks this hash for the argument <code class="literal">b</code>. If Ruby finds the value of <code class="literal">b</code> in the hash, it uses it. If not, it uses the default value of 5. The mystery element <code class="literal">[3]?</code> in the local table must be this hidden hash object.</p></div></div><div class="sect1" title="Experiment 2-2: Displaying the Local Table"><div class="titlepage"><div><div><h1 class="title"><a id="experiment_2-2_displaying_the_local_tabl"/>Experiment 2-2: Displaying the Local Table</h1></div></div></div><p>Along with YARV instructions, <code class="literal">RubyVM::InstructionSequence</code> will also display the local table associated with each YARV snippet or scope. Finding and understanding the local table for your code will help you to understand what the corresponding YARV instructions do. In this experiment, we’ll look at where the local table appears in the output generated by the <code class="literal">RubyVM::InstructionSequence</code> object.</p><p><a class="xref" href="ch02.html#displaying_the_yarv_instructions-id00006" title="Example 2-15. Displaying the YARV instructions for a call to a block">Example 2-15</a> repeats <a class="xref" href="ch02.html#displaying_the_yarv_instructions_for_a_c" title="Example 2-10. Displaying the YARV instructions for a call to a block">Example 2-10</a> from <a class="xref" href="ch02.html#experiment_2-1_displaying_yarv_instructi" title="Experiment 2-1: Displaying YARV Instructions">Experiment 2-1: Displaying YARV Instructions</a>.</p><div class="example"><a id="displaying_the_yarv_instructions-id00006"/><p class="title">Example 2-15. Displaying the YARV instructions for a call to a block</p><div class="example-contents"><pre class="programlisting">code = &lt;&lt;END
10.times do |n|
  puts n
end
END

puts RubyVM::InstructionSequence.compile(code).disasm</pre></div></div><p>And <a class="xref" href="ch02.html#along_with_the_yarv_instructionscomma_ru" title="Example 2-16. Along with the YARV instructions, RubyVM::InstructionSequence displays the local table.">Example 2-16</a> repeats the output we saw earlier in <a class="xref" href="ch02.html#experiment_2-1_displaying_yarv_instructi" title="Experiment 2-1: Displaying YARV Instructions">Experiment 2-1: Displaying YARV Instructions</a>.</p><div class="example"><a id="along_with_the_yarv_instructionscomma_ru"/><p class="title">Example 2-16. Along with the YARV instructions, <code class="literal">RubyVM::InstructionSequence</code> displays the local table.</p><div class="example-contents"><pre class="programlisting">    == disasm: &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;==========
    == catch table
    | catch type: break  st: 0002 ed: 0006 sp: 0000 cont: 0006
    |------------------------------------------------------------------------
    0000 trace            1                                               (   1)
    0002 putobject        10
    0004 send             &lt;callinfo!mid:times, argc:0, block:block in &lt;compiled&gt;&gt;
    0006 leave
    == disasm: &lt;RubyVM::InstructionSequence:block in &lt;compiled&gt;@&lt;compiled&gt;&gt;=
    == catch table
    | catch type: redo   st: 0000 ed: 0011 sp: 0000 cont: 0000
    | catch type: next   st: 0000 ed: 0011 sp: 0000 cont: 0011
    |------------------------------------------------------------------------
<img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> local table (size: 2, argc: 1 [opts: 0, rest: -1, post: 0, block: -1] s3)
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> [ 2] n&lt;Arg&gt;
    0000 trace            256                                             (   1)
    0002 trace            1                                               (   2)
    0004 putself
    0005 getlocal_OP__WC__0 2
    0007 opt_send_simple  &lt;callinfo!mid:puts, argc:1, FCALL|ARGS_SKIP&gt;
    0009 trace            512                                             (   3)
    0011 leave                                                            (   2)</pre></div></div><p>Just above the YARV snippet for the inner scope—the block—we see information about its local table at <span class="inlinemediaobject"><a id="inline_id00052"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>. This displays the total size of the table (<code class="literal">size: 2</code>), the argument count (<code class="literal">argc: 1</code>), and other information about the types of parameters (<code class="literal">opts: 0, rest: -1, post: 0</code>).</p><p>The second line <span class="inlinemediaobject"><a id="inline_id00053"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span> shows the actual contents of the local table. In this example, we have just one argument, <code class="literal">n</code>.</p><p><a class="xref" href="ch02.html#this_method_uses_unnamed_arguments_with" title="Example 2-17. This method uses unnamed arguments with a splat operator.">Example 2-17</a> shows how to use <code class="literal">RubyVM::InstructionSequence</code> in the same way to compile my unnamed arguments example from <a class="xref" href="ch02.html#method_that_takes_standard_arguments_a" title="Example 2-12. A method that takes standard arguments and an array of unnamed arguments">Example 2-12</a>.</p><div class="example"><a id="this_method_uses_unnamed_arguments_with"/><p class="title">Example 2-17. This method uses unnamed arguments with a splat operator.</p><div class="example-contents"><pre class="programlisting">code = &lt;&lt;END
def complex_formula(a, b, *args, c)
  a + b + args.size + c
end
END

puts RubyVM::InstructionSequence.compile(code).disasm</pre></div></div><p>And <a class="xref" href="ch02.html#displaying_the_yarv_instructions-id00007" title="Example 2-18. Displaying the YARV instructions for a call to a block">Example 2-18</a> shows the output.</p><div class="example"><a id="displaying_the_yarv_instructions-id00007"/><p class="title">Example 2-18. Displaying the YARV instructions for a call to a block</p><div class="example-contents"><pre class="programlisting"><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/> == disasm: &lt;RubyVM::InstructionSequence:&lt;compiled&gt;@&lt;compiled&gt;&gt;==========
    0000 trace            1                                               (   1)
    0002 putspecialobject 1
    0004 putspecialobject 2
    0006 putobject        :complex_formula
    0008 putiseq          complex_formula
<img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/> 0010 opt_send_simple  &lt;callinfo!mid:core#define_method, argc:3, ARGS_SKIP&gt;
    0012 leave
    == disasm: &lt;RubyVM::InstructionSequence:complex_formula@&lt;compiled&gt;&gt;=====
<img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/> local table (size: 5, argc: 2 [opts: 0, rest: 2, post: 1, block: -1] s0)
<img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/> [ 5] a&lt;Arg&gt;     [ 4] b&lt;Arg&gt;     [ 3] args&lt;Rest&gt; [ 2] c&lt;Post&gt;
    0000 trace            8                                               (   1)
    0002 trace            1                                               (   2)
    0004 getlocal_OP__WC__0 5
    0006 getlocal_OP__WC__0 4
    0008 opt_plus         &lt;callinfo!mid:+, argc:1, ARGS_SKIP&gt;
    0010 getlocal_OP__WC__0 3
    0012 opt_size         &lt;callinfo!mid:size, argc:0, ARGS_SKIP&gt;
    0014 opt_plus         &lt;callinfo!mid:+, argc:1, ARGS_SKIP&gt;
    0016 getlocal_OP__WC__0 2
    0018 opt_plus         &lt;callinfo!mid:+, argc:1, ARGS_SKIP&gt;
    0020 trace            16                                              (   3)
    0022 leave                                                            (   2)</pre></div></div><p><a class="indexterm" id="iddle1211"/><a class="indexterm" id="iddle1624"/>The top YARV scope, around <span class="inlinemediaobject"><a id="inline_id00058"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853843.png.jpg"/></span>, shows the instructions YARV uses to define a new method. Notice the call to <code class="literal">core#define_method</code> at <span class="inlinemediaobject"><a id="inline_id00059"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853845.png.jpg"/></span>, an internal C function that YARV uses to create new Ruby methods. This corresponds to calling <code class="literal">def complex_formula</code> in my script. (I’ll discuss how Ruby implements methods in more detail in <a class="xref" href="ch05.html" title="Chapter 5. Objects and Classes">Chapter 5</a>, <a class="xref" href="ch06.html" title="Chapter 6. Method Lookup and Constant Lookup">Chapter 6</a>, and <a class="xref" href="ch09.html" title="Chapter 9. Metaprogramming">Chapter 9</a>.)</p><p>Notice the local table for the lower YARV snippet at <span class="inlinemediaobject"><a id="inline_id00060"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853847.png.jpg"/></span>. This line now shows more information about the unnamed arguments (<code class="literal">rest: 2</code>) and the last standard argument following them (<code class="literal">post: 1</code>). Finally, the line at <span class="inlinemediaobject"><a id="inline_id00061"/><img alt="" src="httpatomoreillycomsourcenostarchimages1853937.png.jpg"/></span> shows the contents of the local table that I showed back in <a class="xref" href="ch02.html#ruby_saves_information_about_special_arg" title="Figure 2-17. Ruby saves information about special arguments in the local table.">Figure 2-17</a>.</p></div><div class="sect1" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="summary-id00008"/>Summary</h1></div></div></div><p>In this chapter, we learned how Ruby compiles our code. You may think of Ruby as a dynamic scripting language, but, in fact, it uses a compiler just like C, Java, and many other programming languages. The obvious difference is that Ruby’s compiler runs automatically behind the scenes; you never need to worry about compiling your Ruby code.</p><p>We’ve learned that Ruby’s compiler works by iterating through the AST produced by the tokenizing and parsing processes, generating a series of bytecode instructions along the way. Ruby translates your code from Ruby into a language tailored for the YARV virtual machine, and it compiles every scope or section of your Ruby program into a different snippet or set of these YARV instructions. Every block, method, lambda, or other scope in your program has a corresponding set of bytecode instructions.</p><p>We’ve also seen how Ruby handles different types of arguments. We were able to use the local table as a key or legend for understanding which YARV instructions accessed which arguments or local variables. And we saw how Ruby’s compiler generates additional, special YARV instructions to handle optional and keyword parameters.</p><p>In <a class="xref" href="ch03.html" title="Chapter 3. How Ruby Executes Your Code">Chapter 3</a>, I’ll begin to explain how YARV executes the instructions produced by the compiler—that is, how YARV executes your Ruby program.</p></div></div></body></html>