["```\ndata class Solution(\n    val chromosome: String,\n    val fitness: Int\n)\n\n❶ val TARGET = \"To be, or not to be: that is the question.\"\n❷ val VALID_GENES: String =\n \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\" + // letters\n            \"1234567890\" +                                   // numbers\n            \", .-;:_!/?#%&()={[]}$*@\\\"\\'\"                    // symbols\nval chromosomeLength = TARGET.length\nval POP_SIZE = 100\nval MAX_GEN = 1000\nval ELITISM = 0.15\nval eliteSize = (POP_SIZE * ELITISM).toInt()\n❸ val MUTATION_THRESHOLD = 1.0/chromosomeLength\n\nval population: MutableList<Solution> = mutableListOf()\nval nextgen: MutableList<Solution> = mutableListOf()\n```", "```\nfun initPopulation() {\n    // Initialize a population of POP_SIZE individuals.\n    for (i in 0 until POP_SIZE) {\n        var chromosome = \"\"\n        for (j in 0 until chromosomeLength) {\n           ❶ chromosome += VALID_GENES.random()\n        }\n        // Calculate fitness of the new chromosome.\n        val fitness = getFitness(chromosome)\n        // Add the new individual to the population.\n      ❷ population += Solution(chromosome, fitness)\n    }\n // Sort population (in place) in descending order.\n    population.sortByDescending {it.fitness}\n    println(\"\\nBest solution from initial population:\")\n    println(population[0].toString())\n    println(\"\\n... initPopulation done ...\\n\")\n}\n\nfun getFitness(chromosome: String): Int {\n    var fitness = 0\n    val pairs = TARGET.zip(chromosome)\n    for (pair in pairs) {\n      ❸ if (pair.first == pair.second)\n                 fitness += 1\n    }\n    return fitness\n}\n```", "```\nfun runGA() {\n\n    // Iterate for a specified number of generations.\n  ❶ for (generation in 1 .. MAX_GEN) {\n\n        // Step 1: Check for termination condition.\n      ❷ if (population[0].fitness >= chromosomeLength) {\n            println(\"\\n*** Target reached at generation = \" +\n                    \"${generation - 1} ***\\n\")\n break\n        }\n\n        // Step 2: Implement elitism.\n      ❸ selectElites()\n\n        // Step 3: Implement crossover and mutation.\n      ❹ for (i in eliteSize until POP_SIZE) {\n            // Select parents for crossover.\n            val parent1 = tournament()\n            val parent2 = tournament()\n\n            // Produce a child by using crossover and mutation.\n            val child = crossover(parent1, parent2)\n\n            // Add the child to nextgen.\n            nextgen += child\n        }\n\n        // Step 4: Transfer nextgen to the current population.\n      ❺ for (i in nextgen.indices)\n            population[i] = nextgen[i].copy()\n\n        // Step 5: Clear nextgen for the next iteration.\n        nextgen.clear()\n\n        // Step 6: Sort population in descending order (in place).\n       ❻ population.sortByDescending {it.fitness}\n\n        // Step 7 (optional): Print the best solution per generation.\n        val formatString = \"%5d %44s %4d\"\n      ❼ println(formatString.format(generation,\n            population[0].chromosome, population[0].fitness))\n    }\n}\n```", "```\nfun selectElites() {\n    // Assign top eliteSize individuals to nextgen.\n  ❶ for (i in 0 until eliteSize)\n         nextgen += population[i].copy()\n}\n\nfun tournament(): Solution {\n    // random sampling with replacement\n    // Use the entire population, including elites.\n    val candidate1 = population.random().copy()\n    val candidate2 = population.random().copy()\n    // Return the winner of the tournament.\n  ❷ return if (candidate1.fitness >= candidate2.fitness) candidate1\n               else candidate2\n}\n\nfun crossover(parent1: Solution, parent2: Solution): Solution {\n    // random single-point split crossover\n    val split = (1 until chromosomeLength).random()\n\n    // Use slice to extract segments from a string.\n  ❸ val crossChromosome =\n        parent1.chromosome.slice(0 until split) +\n                parent2.chromosome.slice(split until chromosomeLength)\n\n    // Apply mutation to crossChromosome.\n  ❹ val newChromosome = mutation(crossChromosome)\n\n  ❺ return Solution(newChromosome, getFitness(newChromosome))\n}\n\nfun mutation(crossChromosome: String): String {\n    // A String object is immutable in Kotlin.\n    // Create a char array whose elements can be modified.\n    val chars = crossChromosome.toCharArray()\n    for (i in 0 until chromosomeLength) {\n      ❻ if ((0..1000).random()/1000.0 <= MUTATION_THRESHOLD)\n            chars[i] = VALID_GENES.random()\n    }\n  ❼ return String(chars)\n}\n```", "```\nfun main() {\n    println(\"\\n*** Text-matching using the genetic algorithm ***\\n\")\n    println(\"Target string: $TARGET\")\n    println(\"Population size: $POP_SIZE, Generations: $MAX_GEN, \" +\n            \"Chromosome length: $chromosomeLength\")\n    println(\"Mutation threshold: $MUTATION_THRESHOLD\")\n\n    // Initialize the population.\n    initPopulation()\n    // Run the genetic algorithm.\n    runGA()\n}\n```", "```\n*** Text-matching using the genetic algorithm ***\n\nTarget string: To be, or not to be: that is the question.\nPopulation size: 100, Generations: 1000, Chromosome length: 42\nMutation threshold: 0.023809523809523808\n\nBest solution from initial population:\nSolution(chromosome=u[n_ebJvtj=J[h5j{bNx:BhPch'qyM/)3RVz\"K_]P:, fitness=3)\n\n... initPopulation done ...\n\n    1   u[n_ebJvtj=J[h5j{bNx:BhPch'qyM/)3RVz\"K_]P:   3\n    2   c_g-i1KpZQn[[qXq%hwp:,shb]7k?PEL_ol @izl.    4\n    3   C@eSnKo7T_b6o@thqvgL Kh=FU[(&bCF{veDP\"4/d    5\n    4   C@eSnKo7T_b6o@thqvgL Kh=FU[(&bCF{veDP\"4/d    5\n    5   rnkFi6Z8U /NP An%d]m&vSZSS{&6F/e=qJ9*iio#k   6\n    6   yT;_e}Jvtj=J[h5j{bNx:BhPch[(&bF qJS @iz/d    7\n    7   yT;_e}Jvtj=J[h5j{bNx:BhPch[(&bF qJS @iz/d    7\n    8   342y\"BZo@_b6o@thqvgL Kh=FD[(&bCFqJSq@izl.    8\n    9   342y\"BZo@_b6o@thqvgL Kh=FD[(&bCFqJSq@izl.    8\n   10   p42y\"BZo;bTcXxD?{bNL BhPcU[(&bCF{veDPiol.    9\n   11   342y\"aZo@_b6o@thqvgL Kh=FD[(?/e qJ9*iio#k   10\n   12   =[eSnKo8U XNP thqvgL Kh=FD[(?/e qJ9*iio#k   11\n\n`--snip--`\n\n  370   To be, or not to be: that i(the question.   41\n  371   To be, or not to be: that i(the question.   41\n  372   To be, or not to be: that i(the question.   41\n  373   To be, or not to be: that i(the question.   41\n  374   To be, or not to be: that i(the question.   41\n  375   To be, or not to be: that i(the question.   41\n  376   To be, or not to be: that i(the question.   41\n  377   To be, or not to be: that i(the question.   41\n  378   To be, or not to be: that i(the question.   41\n  379   To be, or not to be: that is the question.  42\n\n*** Target reached at generation = 379 ***\n```", "```\nimport kotlin.math.roundToInt\n\n// Define required data classes.\ndata class Solution(val chromosome: IntArray, val fitness: Int)\ndata class Item(val value: Int, val weight: Int)\n\n// Define the basket of items.\n❶ private val items: List<Item> = listOf(\n    Item(75, 15),\n    Item(55, 32),\n    Item(50, 30),\n    Item(68, 43),\n    Item(62, 54),\n Item(45, 38),\n    Item(68, 62),\n    Item(84, 85),\n    Item(87, 87),\n    Item(95, 83),\n    Item(35, 21),\n    Item(63, 53)\n)\nval chromosomeLength = items.size\n❷ val maxWeight = 175\n\n// global parameters and declarations\nval POP_SIZE = 25\nval MAX_GEN = 30\nval ELITISM = 0.1\nval eliteSize = (POP_SIZE * ELITISM).toInt()\n\n// Limit the mutation threshold value to three decimal places.\n❸ val MUTATION_THRESHOLD =\n       ((1.0/chromosomeLength)*1000.0).roundToInt() / 1000.0\n\nval population: MutableList<Solution> = mutableListOf()\nval nextgen: MutableList<Solution> = mutableListOf()\nval bestSolutions: MutableList<Solution> = mutableListOf()\n```", "```\nfun initPopulation() {\n    // Initialize a population of valid solutions (of nonzero fitness).\n    // Each solution is represented by a chromosome.\n\n    for (person in 0 until POP_SIZE) {\n      ❶ val chromosome = IntArray(chromosomeLength)\n\n        var not_done = true\n      ❷ while (not_done) {\n            for (gene in 0 until chromosomeLength) {\n                chromosome[gene] = (0..1).random()\n            }\n            val fitness = getFitness(chromosome)\n          ❸ if (fitness > 0) {\n                population += Solution(chromosome, fitness)\n                not_done = false\n            }\n        }\n    }\n    // Sort population (in place) in descending order.\n    population.sortByDescending {it.fitness}\n\n    println(\"\\nBest solution from initial population:\")\n    print(population[0].chromosome.contentToString())\n    println(\" \" + (-population[0].fitness).toString())\n    println(\"\\n... initPopulation done ...\\n\")\n}\n\nfun getFitness(chromosome: IntArray): Int {\n    // Get sum of values and weights.\n  ❹ val sumValue  = (chromosome.zip(items) {c, item -> c * item.value}).sum()\n  ❺ val sumWeight = (chromosome.zip(items) {c, item -> c * item.weight}).sum()\n\n    return if (sumWeight <= maxWeight) sumValue else 0\n}\n```", "```\nfun runGA() {\n    // Run the algorithm for a specified number of generations.\n    for (generation in 1 .. MAX_GEN) {\n\n        // Step 1: Implement elitism.\n        selectElites()\n\n        // Step 2: Implement crossover and mutation.\n        for (i in eliteSize until POP_SIZE) {\n            // Select parents for crossover.\n            val parent1 = tournament()\n            val parent2 = tournament()\n\n            // Produce a child by using crossover and mutation.\n            val child = crossover(parent1, parent2)\n            // Add child to nextgen.\n            nextgen += child\n        }\n // Step 3: Transfer nextgen to the current population.\n        for (i in nextgen.indices)\n            population[i] = nextgen[i].copy()\n\n        // Step 4: Clear nextgen for the next iteration.\n        nextgen.clear()\n\n        // Step 5: Sort the population in descending order (in place).\n        population.sortByDescending {it.fitness}\n\n        // Step 6: Add the fittest solution to bestSolutions.\n      ❶ bestSolutions += population[0]\n\n        // Step 7 (optional): Print the fittest solution.\n      ❷ printSolution(generation, population[0])\n    }\n}\n```", "```\nfun printSolution(generation: Int, solution: Solution) {\n    val str1 = \"%04d\".format(generation).padEnd(10, ' ')\n    val (c, f) = solution\n    val str2 = c.contentToString()\n    val str3 = f.toString().padStart(6, ' ')\n    println(str1 + str2 + str3)\n}\n```", "```\nfun crossover(parent1: Solution, parent2: Solution): Solution {\n    // random single-point split and crossover\n  ❶ val split = (1 until chromosomeLength).random()\n\n    // Use copyOfRange() to extract elements from an array.\n    // .copyOfRange(a,b): a = start index, b = not inclusive\n    val arr1 = parent1.chromosome.copyOfRange(0, split)\n    val arr2 = parent2.chromosome.copyOfRange(split, chromosomeLength)\n\n  ❷ val newChromosome = arr1 + arr2\n\n    // Apply in-place mutation to the new chromosome.\n  ❸ mutation(newChromosome)\n\n  ❹ return Solution(newChromosome, getFitness(newChromosome))\n}\n\nfun mutation(newChromosome: IntArray) {\n    // Carry out in-place mutation.\n    for (i in 0 until chromosomeLength) {\n        if ((0..1000).random()/1000.0 <= MUTATION_THRESHOLD) {\n            // Simplest way to flip values between 0 and 1 is i = 1 - i.\n          ❺ newChromosome[i] = (1 - newChromosome[i])\n        }\n    }\n    // nothing to return\n}\n```", "```\nfun main() {\n    println(\"\\n*** Solving the 0-1 knapsack problem \" +\n            \"using the genetic algorithm ***\\n\")\n    println(\"Population size: $POP_SIZE, Generations: $MAX_GEN\")\n    println(\"Number of items to pick from: $chromosomeLength\")\n    println(\"Mutation threshold: $MUTATION_THRESHOLD\")\n\n    // Initialize the population.\n    initPopulation()\n    // Run the genetic algorithm.\n    runGA()\n    // Print the best overall solution.\n    printBestSolution()\n}\n\nfun printBestSolution() {\n  ❶ bestSolutions.sortByDescending {it.fitness}\n    println(\"\\nBest solution found after $MAX_GEN generations:\")\n\n  ❷ val (chromosome, fitness) = bestSolutions[0]\n  ❸ val sumWeight = (chromosome.zip(items)\n                       {c, item -> c * item.weight}).sum()\n    println(bestSolutions[0].toString())\n    println(\"Sum of weights: $sumWeight   Sum of values: $fitness\")\n}\n```", "```\n*** Solving the 0-1 knapsack problem using the genetic algorithm ***\n\nPopulation size: 25, Generations: 30\nNumber of items to pick from: 12\nMutation threshold: 0.083\n\nBest solution from initial population:\nSolution(chromosome=[1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1], fitness=285)\n\n... initPopulation done\n\n0001      [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1]   285\n0002      [1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1]   285\n0003      [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0]   296\n0004      [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0]   296\n0005      [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0]   296\n0006      [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0]   296\n0007      [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0]   296\n0008      [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0]   296\n0009      [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0]   296\n0010      [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0]   296\n0011      [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0]   296\n0012      [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0]   296\n0013      [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0]   296\n0014      [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0]   296\n0015      [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0]   296\n0016      [1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0]   296\n0017      [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1]   311\n0018      [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1]   311\n0019      [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1]   311\n0020      [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1]   311\n0021      [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1]   311\n0022      [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1]   311\n0023      [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1]   311\n0024      [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1]   311\n0025      [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1]   311\n0026      [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1]   311\n0027      [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1]   311\n0028      [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1]   311\n0029      [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1]   311\n0030      [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1]   311\n\nBest solution found after 30 generations:\nSolution(chromosome=[1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1], fitness=311)\nSum of weights: 173   Sum of values: 311\n```", "```\n// import block\nimport kotlin.math.sin\nimport kotlin.math.sqrt\nimport kotlin.math.abs\nimport kotlin.math.pow\nimport kotlin.math.min\nimport kotlin.math.max\nimport kotlin.random.Random\n\n// Define required data classes.\ndata class Solution(\n  ❶ val chromosome: DoubleArray,\n    val fitness: Double)\n\n// global parameters and declarations\n❷ val getFitness = :: eggHolder\n\n❸ val chromosomeLength = 2    // number of independent variables\nval bounds = arrayOf(doubleArrayOf(-512.0, 512.0),\n                     doubleArrayOf(-512.0, 512.0))\nval varRange = doubleArrayOf(bounds[0][1] - bounds[0][0],\n                             bounds[1][1] - bounds[1][0])\nval POP_SIZE = 100\nval MAX_GEN = 200\n❹ val MUTATION_THRESHOLD = 0.5    // On average, 1 of 2 genes will mutate.\nval MUTATION_FACTOR = 0.02\nval ELITISM = 0.1\nval eliteSize = (POP_SIZE * ELITISM).toInt()\n\nval population: MutableList<Solution> = mutableListOf()\nval nextgen: MutableList<Solution> = mutableListOf()\nval bestSolutions: MutableList<Solution> = mutableListOf()\n```", "```\nfun initPopulation() {\n    // Initialize a population of valid solutions (genes within bounds).\n    // Each solution is represented by a chromosome.\n\n    for (person in 0 until POP_SIZE) {\n      ❶ val x = DoubleArray(chromosomeLength)\n        for (i in 0 until chromosomeLength) {\n            // The first argument is inclusive, but the second one is not.\n            // It's possible to add a small bias term to the upper bounds.\n          ❷ x[i] = Random.nextDouble(bounds[i][0], bounds[i][1])\n        }\n        population += Solution(x, getFitness(x))\n    }\n\n    // Sort the population (in place) in descending order.\n    population.sortByDescending {it.fitness}\n\n    println(\"\\nBest solution from initial population:\")\n  ❸ println(population[0].toString())\n    println(\"\\n... initPopulation done ...\\n\")\n}\nfun eggHolder(x: DoubleArray): Double {\n    val c1 = (x[1] + 47)\n    val c2 = sin(sqrt(abs(0.5 * x[0] + c1)))\n    val c3 = x[0] * sin(sqrt(abs(x[0] - c1)))\n\n    // Multiply by -1 ONLY for minimization problems.\n  ❹ return -1.0 * (-c1 * c2 - c3)\n}\n```", "```\nfun crossover(parent1: Solution, parent2: Solution): Solution {\n    // Select a random weight within (0-1).\n    // This could be generated separately for x- and y-components.\n  ❶ val s = (0..1000).random()/1000.0\n\n    // Generate randomly weighted genes.\n    var x1 = parent1.chromosome[0]*s + parent2.chromosome[0]*(1-s)\n    var x2 = parent1.chromosome[1]*s + parent2.chromosome[1]*(1-s)\n\n    // Check that new genes stay within bounds (decision space).\n    x1 = min(max(x1, bounds[0][0]), bounds[0][1])\n    x2 = min(max(x2, bounds[1][0]), bounds[1][1])\n\n    // Compose the new chromosome.\n  ❷ val xNew = doubleArrayOf(x1, x2)\n    // Mutate the new chromosome.\n  ❸ mutation(xNew)\n\n  ❹ return Solution(xNew, getFitness(xNew))\n}\n\nfun mutation(xNew: DoubleArray) {\n    for (i in 0 until chromosomeLength) {\n        if (((0..1000).random() / 1000.0) <= MUTATION_THRESHOLD) {\n            // Get the random sign factor.\n          ❺ val sign = if ((0..100).random()/100.0 <= 0.5) -1 else 1\n          ❻ xNew[i] += sign * varRange[i] * MUTATION_FACTOR\n            xNew[i] =  min(max(xNew[i], bounds[i][0]), bounds[i][1])\n        }\n    }\n    // nothing to return\n}\n```", "```\nfun printSolution(generation: Int, solution: Solution) {\n    val str1 = \"%04d\".format(generation).padEnd(10, ' ')\n    val (c, f) = solution\n    val str2 = \"%5.7f\".format(c[0]).padEnd(14, ' ')\n    val str3 = \"%5.7f\".format(c[1]).padEnd(14, ' ')\n\n    // Multiply f (fitness) by -1 for minimization (for display only).\n    val str4 = \"%5.4f\".format(-f)\n\n    println(str1 + str2 + str3 + str4)\n}\n```", "```\nfun main() {\n    println(\"\\n*** Real-valued function optimization using \" +\n            \"the genetic algorithm ***\\n\")\n    println(\"Number of dimensions: $chromosomeLength\")\n    println(\"Population size: $POP_SIZE, Generations: $MAX_GEN\")\n    println(\"Elitism: $ELITISM\")\n    println(\"Mutation threshold: $MUTATION_THRESHOLD\")\n    println(\"Mutation factor: $MUTATION_FACTOR\")\n\n    // Initialize the population.\n    initPopulation()\n    // Run the genetic algorithm.\n    runGA()\n    // Print the best overall solution.\n    printBestSolution()\n}\n\nfun printBestSolution() {\n    // Sort the bestSolutions to get the best-so-far solution.\n    bestSolutions.sortByDescending {it.fitness}\n    println(\"\\nBest solution found after $MAX_GEN generations:\")\n\n    // Deconstruct for printing with formatting.\n    val (chromosome, fitness) = bestSolutions[0]\n\n    // Format and print the best-so-far properties.\n    for (i in chromosome.indices) {\n        print(\"chromosome[$i]: \")\n        println(\"%5.8f\".format(chromosome[i]))\n    }\n    println(\"Fitness: \" + \"%5.5f\".format(-fitness))\n}\n```", "```\n*** Real-valued function optimization using a genetic algorithm ***\n\nNumber of dimensions: 2\nPopulation size: 100, Generations: 200\nElitism: 0.1\nMutation threshold: 0.5\nMutation factor: 0.02\n\nBest solution from initial population:\n[439.9192360610284, 466.3475628354653] -809.6304961876202\n\n... initPopulation done ...\n\n0001      439.91923606   466.34756284   -809.63050\n0002      439.91923606   466.34756284   -809.63050\n0003      439.91923606   466.34756284   -809.63050\n0004      421.26042117   431.81770471   -838.23597\n0005      421.26042117   431.81770471   -838.23597\n\n`--snip--`\n\n0190      512.00000000   404.23184036   -959.64066\n0191      512.00000000   404.23184036   -959.64066\n0192      512.00000000   404.23184036   -959.64066\n0193      512.00000000   404.23184036   -959.64066\n0194      512.00000000   404.23184036   -959.64066\n0195      512.00000000   404.23184036   -959.64066\n0196      512.00000000   404.23184036   -959.64066\n0197      512.00000000   404.23184036   -959.64066\n0198      512.00000000   404.23184036   -959.64066\n0199      512.00000000   404.23184036   -959.64066\n0200      512.00000000   404.23184036   -959.64066\n\nBest solution found after 200 generations:\nchromosome[0]: 512.00000000\nchromosome[1]: 404.23184036\nFitness: -959.64066\n```"]