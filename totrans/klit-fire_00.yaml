- en: 'We build our computer systems the way we build our cities: over time, without
    a plan, on top of ruins.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Ellen Ullman
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In 1975, renowned physicist David L. Goodstein published his book *States of
    Matter* with the following introduction:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Ludwig Boltzmann, who spent much of his life studying statistical mechanics,
    died in 1906, by his own hand. Paul Ehrenfest, carrying on the work, died similarly
    in 1933\. Now it is our turn to study statistical mechanics.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is a book about how to run legacy modernizations, a topic many software
    engineers regard as slow-moving career suicide, if not the prologue to a literal
    one. This book is for people who work at large organizations with aging technology,
    but it is also a book for people who work at small startups still building their
    technology. Restoring legacy systems to operational excellence is ultimately about
    resuscitating an iterative development process so that the systems are being maintained
    and evolving as time goes on.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the advice in this book can just as easily be used for building new
    technology, but legacy systems hold a special place in my heart. I spent the first
    10 years of my professional career traveling around the world, looking for work
    in applied anthropology while programming computers for fun on the side. I knew
    how to program because my father was a computer programmer, and I grew up in a
    house filled with computers at a time when that was rare.
  prefs: []
  type: TYPE_NORMAL
- en: I never became the swashbuckling international aid worker I imagined myself
    to be, but I ended up finding my applied anthropology work in legacy modernizations.
    Like pottery sherds, old computer programs are artifacts of human thought. There’s
    so much you can tell about an organization’s past by looking at its code.
  prefs: []
  type: TYPE_NORMAL
- en: To understand legacy systems, you have to be able to define how the original
    requirements were determined. You have to excavate an entire thought process and
    figure out what the trade-offs look like now that the options are different.
  prefs: []
  type: TYPE_NORMAL
- en: Simply being old is not enough to make something legacy. The subtext behind
    the phrase *legacy technology* is that it’s also bad, barely functioning maybe,
    but legacy technology exists only if it is successful. These old programs are
    perhaps less efficient than they were before, but technology that isn’t used doesn’t
    survive decades.
  prefs: []
  type: TYPE_NORMAL
- en: We are past the point where all technical conversations and knowledge sharing
    can be about building new things. We have too many old things. People from my
    father’s generation wrote a lot of programs, and every year they are shocked by
    how much of their work survives, still running in a production system somewhere.
    My generation has programmed exponentially more, infecting every aspect of life
    with a computer chip and some runtime instructions. We will be similarly shocked
    when those systems are still in place 30, 40, or 50 years from now.
  prefs: []
  type: TYPE_NORMAL
- en: Because we don’t talk about modernizing old tech, organizations fall into the
    same traps over and over again. Failure is predictable because so many software
    engineers think the conversations about modernizing legacy technology are not
    relevant to their careers. Some of them are honestly surprised to find out that
    COBOL still runs much of the financial sector, that the majority of the web is
    still written in PHP, or that people are still looking to hire software engineers
    with ActionScript, Flash, and Visual Basic skills.
  prefs: []
  type: TYPE_NORMAL
- en: Failure can be so predictable that after a year or two of doing this work, I
    found that with a little basic information about the technology deployed, I could
    predict a series of problems the organization was facing and how its solutions
    had failed. Occasionally, I would perform this parlor trick for the amusement
    of other engineers and the advancement of my career, including once during a job
    interview at the *New York Times*.
  prefs: []
  type: TYPE_NORMAL
- en: When I left government to go back to the private sector, I discovered that the
    same techniques that had worked for old systems also worked really well with relatively
    new systems. I moved to a six-year-old company and did legacy modernization work.
    Then I moved to a six-month-old company and still did legacy modernization work.
    At one point, exasperated, I complained to my boss, “Why am I running a legacy
    modernization on a three-month-old system?” To which he retorted, “Serves you
    right for not showing up three months ago.”
  prefs: []
  type: TYPE_NORMAL
- en: That being said, there is little downside to maintaining all systems as if they
    are legacy systems. It is easy to build things, but it is difficult to rethink
    them once they are in place. Legacy modernizations are hard not because they are
    technically hard—the problems and the solutions are usually well understood—it’s
    the people side of the modernization effort that is hard. Getting the time and
    resources to actually implement the change, building an appetite for change to
    happen and keeping that momentum, managing the intra-organizational communication
    necessary to move a system that any number of other systems connect to or rely
    upon—those things are hard.
  prefs: []
  type: TYPE_NORMAL
- en: And yet, as an industry, we do not talk about these challenges. We assume the
    sun, moon, stars, and the board of directors will all magically reconfigure themselves
    around the right technical answer simply because it’s the right technical answer.
    We are horrified to discover that most people do not actually care how healthy
    a piece of technology is as long as it performs the function they need it to with
    a reasonable degree of accuracy in a timeframe that doesn’t exhaust their patience.
    In technology, “good enough” reigns supreme.
  prefs: []
  type: TYPE_NORMAL
- en: 'In trying to explain how to approach a legacy modernization, I first go back
    and explore how technology changes over time. Chapters 1 and 2 both explore the
    mechanics of computing trends and best practices: How did we settle on the technology
    that is legacy today, and what can we learn from that process to guide our modernization
    plans?'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Chapter 3, I discuss the three broad problems that make organizations feel
    like they need to modernize: technical debt, performance issues, and system stability.
    I give an example of each type of problem on a real (though anonymous) system
    and how the plan to modernize it might come together.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 4 discusses why legacy modernization is so hard and fails so often.
    I address the great myth of cross-platform compatibility and the role of abstraction
    in manipulating what we see as easy or hard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chapter 5 talks about the most critical feature of any legacy modernization:
    momentum. How do you get it, and how do you keep it? I outline a whole series
    of conditions—some of them momentum killers, some of them momentum growers.'
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 6 deals with coming into a modernization project that has already started
    and how to fix the most common problems that might be stalling it.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 7 provides as thorough of an overview as possible into design thinking
    and how we can use design to direct and ultimately improve the outcomes of technical
    conversations.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 8 is all about breaking stuff and the value of not being afraid of failure.
    I explore how chaos testing complements legacy modernization and how to work with
    an organization where the suggestion that you should break things on purpose might
    seem like a bridge too far.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 9 discusses why success is not as obvious or self-evident as you might
    assume and how to define criteria to determine when a project is finished.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Chapter 10 lays out strategies to keep you from ever having to do a
    modernization on the same system again. How do you know if your software is maintainable?
    What can you do if it is not?
  prefs: []
  type: TYPE_NORMAL
- en: The language in this book is deliberate. I use the term *organization* instead
    of *company* or *business*. The vast majority of my work experience in this space
    is with governments and nonprofits, but legacy is everywhere. The organizations
    that need to build and maintain good technology are not exclusively in the private
    sector. The US federal government is one of the single largest producers of technology,
    for example. The conversation about legacy systems crosses from businesses to
    governments to hospitals to nonprofits. For that reason, when I mention the “business”
    side of the organization, I mean that in terms of the mission-focused components
    that engineering is building technology to support. An organization doesn’t have
    to make a profit to have a business side.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book, I use the word *system* to refer to a grouping of technologies
    that work together for a common set of tasks. System is a troublesome word in
    technology conversations as it seems you can never find a group of engineers who
    agree where its boundaries are. For my purposes, though, that vagueness is beneficial.
    It allows me to talk about legacy modernizations in general.
  prefs: []
  type: TYPE_NORMAL
- en: To describe parts of a system, I frequently use the words *component* or occasionally
    *service*. While many of the techniques in this book are applicable to any type
    of technology, examples and discussions are heavily slanted toward software engineering
    and web-based development in particular. I couldn’t write a book about legacy
    systems without mainframes, data centers, and old operating systems, but most
    of my experience is with upgrading these systems to more internet-friendly options,
    and this book reflects that. I look forward to technologists with other backgrounds
    supplementing the material in this book with essays on whether my advice also
    applies to them.
  prefs: []
  type: TYPE_NORMAL
- en: My sincere hope is that as you read this, you find inspiration for your own
    technical projects, regardless of the age of your technology. I’ve tried my best
    to pack as many resources, exercises, and frameworks into this book as possible,
    to be as detailed as possible, and to ground as many assertions with real-world
    stories as I can.
  prefs: []
  type: TYPE_NORMAL
- en: We are reaching a tipping point with legacy systems. The generation that built
    the oldest of them is gradually dying off, and we are piling more and more layers
    of society on top of these old, largely undocumented and unmaintained computer
    programs. While I don’t believe society is going to crumble at our feet over it,
    there’s a lot of good, interesting work for people willing to jump in.
  prefs: []
  type: TYPE_NORMAL
