- en: Chapter 3. Integrating Charts on a Page
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might expect a data visualization for the Web to be featured very prominently
    on the page, or even make up the entire web page. That’s not always the right
    approach, though. The best visualizations are effective because they help the
    user understand the data, not because they “look pretty” on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Some data may be straightforward enough to present without context, but meaningful
    data probably isn’t. And if our presentation requires context, its visualizations
    are likely sharing the page with other content. When we design web pages, we should
    take care to balance any individual component with the page as a whole. If a single
    visualization is not the entire story, it shouldn’t take up all (or even most)
    of the space on the page. It can be challenging, however, to minimize the space
    a traditional chart requires. There are, after all, axes, labels, titles, legends,
    and more to place.
  prefs: []
  type: TYPE_NORMAL
- en: Edward Tufte considered this problem in his groundbreaking work *The Visual
    Display of Quantitative Information* (Graphics Press, 1983), and he proposed a
    novel solution he called sparklines. *Sparklines* are charts stripped to their
    bare essentials, presented without the aforementioned elements we often see in
    a chart. Sparklines can present a lot of information in very little space, even
    to the point where it is possible to include a chart right in the middle of a
    sentence. There is no need for “See figure below” or “Click for larger view.”
    One of Tufte’s earliest examples presents the glucose level of a medical patient;
    [Figure 3-1](ch03.html#tufteapostrophes_classic_sparkline_examp "Figure 3-1. Tufte’s
    classic sparkline example shows a lot of information in a small space.") shows
    a reproduction.
  prefs: []
  type: TYPE_NORMAL
- en: '![Tufte’s classic sparkline example shows a lot of information in a small space.](figs/web/03fig01.png.jpg)Figure 3-1. Tufte’s
    classic sparkline example shows a lot of information in a small space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a mere 154×20 pixels, we’ve shown the patient’s current glucose level, its
    trend for more than two months, high and low values, and the range of normal values.
    This high information density makes sparklines effective anytime space is a premium—inline
    in textual paragraphs, as cells in tables, or as part of information dashboards.
    Sparklines do have disadvantages, of course. They cannot provide as much fine-grained
    detail as a full-size chart with axes and labels. They also cannot support significant
    interactivity, so we can’t give users a lot of flexibility in selecting data or
    zooming in for detail. But for many visualizations, these aren’t major concerns.
    Plus, as we’ll see in this chapter’s examples, the Web gives us the chance to
    augment sparklines in ways that aren’t possible in print. There are a few JavaScript
    libraries and toolkits for creating sparklines, but we’ll focus on the most popular
    of them: jQuery sparklines (*[http://omnipotent.net/jquery.sparkline/](http://omnipotent.net/jquery.sparkline/)*).
    As the name implies, this open source library is an extension to jQuery. The examples
    in this chapter look closely at how to use these tools to incorporate dense visualizations
    into your web page. Here’s what you’ll learn:'
  prefs: []
  type: TYPE_NORMAL
- en: How to create a classic sparkline for integration directly into text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to combine multiple sparklines to show comparisons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to annotate sparklines with additional details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create composite charts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to respond to click events on the page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to update charts in real time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a Classic Sparkline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As later examples will demonstrate, the sparklines library is both flexible
    and powerful, and we can use it in many different contexts. As a start, though,
    we’ll use the library to create a sparkline exactly as Edward Tufte first defined
    it. The process is quite straightforward and takes only four simple steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Include the Required JavaScript Libraries'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since we’re using the jQuery sparklines library to create the chart, we need
    to include that library in our web pages, along with jQuery. Both jQuery and sparklines
    are available on public CDNs. For this example (and the others in this chapter),
    we’ll use the CloudFlare CDN. For some notes on the advantages and disadvantages
    of using CDNs, see [Step 1: Include the Required JavaScript Libraries](ch02.html#step_1_include_the_required_javascript_l
    "Step 1: Include the Required JavaScript Libraries").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the skeleton with which we start:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we’re including the JavaScript libraries at the end of the document.
    This approach lets the browser load all of the document’s HTML markup and begin
    laying out the page while waiting for the server to provide the JavaScript libraries.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the jQuery library, sparklines rely on the HTML *canvas* feature.
    Since Internet Explorer didn’t support canvas until version 9, we use some special
    markup at ➊ to ensure that IE 8 and earlier will load an additional library (excanvas
    .min.js), just like we did in [Chapter 2](ch02.html "Chapter 2. Making Charts
    Interactive").
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Create the HTML Markup for the Sparkline'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because we’re closely integrating the sparkline chart with other elements,
    we simply use a `<span>` tag to hold the HTML markup for our visualization, rather
    than using a `<div>`. In addition to the chart itself, we include the final value
    and a label as standard HTML. Here is the HTML for the glucose sparkline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Compared to other visualizations, two characteristics of our sparkline chart
    are unusual.
  prefs: []
  type: TYPE_NORMAL
- en: We include the data right in the HTML itself, not in the JavaScript that creates
    the chart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<span>` for the chart does not have a unique `id` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both of these differences are optional; we could construct the chart as in other
    visualizations by passing data to a JavaScript function and identifying its container
    with a unique `id`. For sparklines, however, the approach we’re using here often
    makes more sense. By including the chart data directly in the HTML, we can easily
    see the data’s relation to other content on the page. It’s clear, for example,
    that the final value of our chart (`128`) is the same as the value we’re using
    for the label. If we had made a mistake and used a different value for the label,
    the error would be much easier to spot and correct. Using a common `class` for
    all sparklines instead of unique `id`s simplifies how we might use the library
    to create multiple charts on one page. With unique `id`s, we would have to call
    a library function for every chart. With a common `class`, on the other hand,
    we need only call a single library function to create multiple charts. That’s
    especially helpful when a web page contains a lot of sparklines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Draw the Sparkline'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we’ve included the necessary libraries and set up our HTML, it’s remarkably
    easy to draw the charts. In fact, a single line of JavaScript is sufficient. We
    simply select the containing element(s) using jQuery—`$(".sparkline")`—and call
    the sparklines plug-in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in [Figure 3-2](ch03.html#default_sparkline_options_differ_slightl
    "Figure 3-2. The default sparkline options differ slightly from the classic example."),
    the sparklines library creates a standard sparkline from our data.
  prefs: []
  type: TYPE_NORMAL
- en: '![The default sparkline options differ slightly from the classic example.](figs/web/03fig02.png.jpg)Figure 3-2. The
    default sparkline options differ slightly from the classic example.'
  prefs: []
  type: TYPE_NORMAL
- en: The library’s default options differ from Tufte’s classic sparkline in color,
    chart type, and density. We’ll tweak those next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Adjust the Chart Style'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make our sparkline match Tufte’s definition exactly, we can specify new values
    for some of the default options. To pass these options to sparklines, we construct
    a JavaScript object and include it as the second parameter in the `sparkline`
    function call. The function’s first parameter is the data itself, which here we
    specify with `"html"` because our data is included in the HTML markup.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To complete our transformation to Tufte’s original, we can style the HTML content
    as well. Making the final value the same color as the key data points clarifies
    that connection, and making the chart label bold emphasizes it as a title.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s walk through the changes we just made:'
  prefs: []
  type: TYPE_NORMAL
- en: Tufte’s classic sparklines are black and white except for key data points (minimum,
    maximum, and final values). His color scheme adds extra emphasis to those points.
    To change the library’s default (blue), we can set a `lineColor`. For screen displays,
    we might choose a dark gray rather than pure black. That’s what we’re using at
    ➊.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tufte doesn’t fill the area below the line so that he can use shading to indicate
    a normal range. To eliminate the library’s light blue shading, we set `fillColor`
    to `false` ➋.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, the library uses 3 pixels as the width for each data point. To maximize
    information density, Tufte would likely suggest using only a single pixel. Setting
    the `defaultPixelsPerValue` option at ➌ makes that change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tufte uses red for key data points. To change the library’s default (orange),
    we set `spotColor`, `minSpotColor`, and `maxSpotColor` at ➍.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, Tufte’s sparklines can include shading to mark the normal range for
    a value. To show, for example, a range of 82–180 mg/dL, we set the `normalRangeMin`
    and `normalRangeMax` options at ➎.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these changes, we have the classic Tufte sparkline on our web page. We
    can even include it within a text paragraph, like this, ![](figs/web/094fig01.png.jpg),
    so that the visualization enhances the content of the text.
  prefs: []
  type: TYPE_NORMAL
- en: Charting Many Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By design, sparklines take up very little space on a page, and that makes them
    ideal for another visualization challenge: showing many variables at once. Of
    course, regular line charts and bar charts can plot multiple data sets simultaneously;
    however, these multiple-series charts rapidly grow unwieldy if the number of data
    sets exceeds four or five. Some visualization projects show dozens of different
    variables, far beyond what a multiple-series chart can accommodate. A *small-multiples*
    approach turns the standard chart approach completely around. Instead of showing
    one chart with multiple data sets, we can show multiple charts, each with a single
    data set. Placing lots of charts on a page means that each individual chart cannot
    take up much space. That is exactly the problem that sparklines solve.'
  prefs: []
  type: TYPE_NORMAL
- en: We won’t go too crazy here, to keep the code examples manageable, but it’s easy
    to extend this approach to many more variables. In our case, we’ll construct a
    visualization for analyzing stock market performance. The companies in our analysis
    will include the 10 largest American companies in 2012 (*[http://money.cnn.com/magazines/fortune/fortune500/2012/full_list/](http://money.cnn.com/magazines/fortune/fortune500/2012/full_list/)*),
    also known as the Fortune 500 Top 10; Barclay’s best technology stocks for 2012
    (*[http://www.marketwatch.com/story/barclays-best-tech-stocks-for-2012-2011-12-20/](http://www.marketwatch.com/story/barclays-best-tech-stocks-for-2012-2011-12-20/)*),
    as identified in December 2011; and Bristol-Myers Squibb, which *CR Magazine*
    named the top company in America for corporate responsibility (*[http://www.thecro.com/files/100Best2012_List_3.8.pdf/](http://www.thecro.com/files/100Best2012_List_3.8.pdf/)*).
    Those selections are completely arbitrary, but the example is designed to include
    three different cases that we will style differently in our visualization. We’ll
    treat one as a general case (the Fortune 500 Top 10 list), one as a special class
    (the Barclay’s list), and one as a unique variable (Bristol-Myers Squibb). Just
    as in this chapter’s first example, we need to include the sparklines and jQuery
    libraries in our web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Prepare the HTML Markup'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sparklines library makes it easy to embed the data directly inside the HTML
    markup. For this example, an HTML table is the most appropriate structure for
    the data. Here’s how such a table could begin. (For brevity’s sake, the following
    excerpt doesn’t include the full HTML, but the complete example is available in
    the book’s source code at *[http://jsDataV.is/source/](http://jsDataV.is/source/)*.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The table has three important characteristics relevant to our visualization.
  prefs: []
  type: TYPE_NORMAL
- en: Each stock is a single table row (`<tr>`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stocks from Barclay’s technology list have the class attribute `"barclays"`
    added to that `<tr>` element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The top corporate responsibility stock has no special attributes or characteristics
    (yet).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Step 2: Draw the Charts'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just as in this chapter’s first example, creating the sparklines using default
    options is amazingly simple: it takes only a single line of JavaScript. We use
    jQuery to select all the elements that contain sparkline data, and we call the
    `sparkline()` function to generate the charts.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we only have to make one call to `sparkline()`, even though each
    chart has unique data. That’s a major benefit of placing the data within the HTML
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting charts, shown in [Figure 3-3](ch03.html#sparklines_can_be_a_good_visualization_t
    "Figure 3-3. Sparklines can be a good visualization to include within page elements
    such as tables."), all have identical styles, but we’ll fix that in the next few
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: '![Sparklines can be a good visualization to include within page elements such
    as tables.](figs/web/03fig03.png.jpg)Figure 3-3. Sparklines can be a good visualization
    to include within page elements such as tables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Establish a Default Style for the Charts'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we don’t like the sparklines library’s default style, it’s easy to change
    it using an options object, as shown next.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The object is the second parameter to the `sparkline()` function, and here it
    changes the color for the charts and disables the highlights on the minimum, maximum,
    and final values. The first parameter, the string `"html"`, indicates to the library
    that the data is already present in our HTML.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-4](ch03.html#sparkline_options_let_us_adjust_the_char "Figure 3-4. The
    sparkline options let us adjust the chart styles.") shows the result for one row.
    We’ll use this style as the default for all our charts.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The sparkline options let us adjust the chart styles.](figs/web/03fig04.png.jpg)Figure 3-4. The
    sparkline options let us adjust the chart styles.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Modify the Default Style for Special Classes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With a default style in place, we can turn our attention to the special class
    of charts for stocks in Barclay’s technology list. For our example, let’s change
    the color of the chart without any other changes to our default style. That final
    clause is important. We could just copy and paste the options, but that would
    be setting ourselves up for problems in the future. You can see why in the following
    example code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the second call to `sparklines()` duplicates options from the first
    call that haven’t changed, specifically for the spot colors. This makes the code
    harder to maintain if, in the future, we decide to turn spot colors back on for
    all our charts, since we would have to make changes to our code in two places.
    There is a better way.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid duplication, we first define a variable that holds our default options.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Next we create a new variable for the Barclay’s styles. To create this new variable,
    we can use the jQuery `.extend()` function to avoid duplication.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we pass three parameters to `.extend()`. The first parameter is
    the target. It’s an object that the function will modify, and we start with an
    empty object (`{}`). The next parameters are objects that `.extend()` will merge
    into the target. The merge process adds new properties to the target and updates
    any properties in the target object with new values. Since we’re passing two additional
    parameters, we’re asking for two merges.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of the call to `.extend()` as a two-stage process.
  prefs: []
  type: TYPE_NORMAL
- en: Since our target is initially empty, the first merge will add all of the properties
    from `sparkline_default` to the target.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our target now has the same properties as `sparkline_default`, and the second
    merge will modify it by updating the two properties in the last parameter, `lineColor`
    and `fillColor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resulting object will hold the options we want for charts of Barclay’s technology
    stocks. Here’s a complete code listing, using these objects to create the charts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice at ➊ that we create the nontechnology sparklines by selecting table rows
    (`<tr>`) that don’t have the `"barclays"` class. At ➋ we create the technology
    sparklines. Because we’ve defined the technology options based on the default,
    we have an easy way to maintain both default styles and styles for special classes.
    The chart colors in [Figure 3-5](ch03.html#different_visual_styles_distinguish_diff
    "Figure 3-5. Different visual styles distinguish different types of data.") clearly
    distinguish the stock types in our table.
  prefs: []
  type: TYPE_NORMAL
- en: '![Different visual styles distinguish different types of data.](figs/web/03fig05.png.jpg)Figure 3-5. Different
    visual styles distinguish different types of data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Create a Unique Style for a Specific Chart'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the final step in this example, let’s consider the single stock at the top
    of *CR Magazine*’s list. Suppose we want to add distinct styles to its chart,
    and we know those styles only when we’re generating the HTML, not when we’re writing
    the JavaScript. How can we adjust the chart style if we can’t modify any JavaScript?
  prefs: []
  type: TYPE_NORMAL
- en: Sparklines let you add special attributes directly to the HTML element containing
    a chart. To set the line color, for example, you need to specify the attribute
    `sparkLineColor`. The problem is that if we were to enter this attribute directly
    in the HTML, the result wouldn’t be valid HTML, because the HTML specification
    doesn’t recognize the `sparkLineColor` attribute. To conform to the HTML standard,
    custom attributes must have names that begin with the prefix `data-`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To use HTML-compliant names to refer to sparklines’ custom attributes, we just
    need to tell the sparklines library how to find those names. For our HTML, we
    use the standard `data-` prefix instead of `spark` in at ➊.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have to add a couple more options in our call to `sparkline()`. First
    we set `enableTagOptions` to `true` to tell the library that we’re including options
    directly in the HTML. Then we set `tagOptionsPrefix` to `"data-"` to specify the
    prefix we’re using for those attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**As of this writing, the jQuery sparklines documentation for `tagOptionsPrefix`
    is not correct. The documentation lists the option as `tagOptionPrefix`, where
    *option* is singular instead of plural. The library’s code, however, expects the
    plural form.**'
  prefs: []
  type: TYPE_NORMAL
- en: If we use these options correctly, one of our charts will have the distinct
    color in [Figure 3-6](ch03.html#sparklines_library_supports_unique_styli "Figure 3-6. The
    sparklines library supports unique styling options for individual charts.").
  prefs: []
  type: TYPE_NORMAL
- en: '![The sparklines library supports unique styling options for individual charts.](figs/web/03fig06.png.jpg)Figure 3-6. The
    sparklines library supports unique styling options for individual charts.'
  prefs: []
  type: TYPE_NORMAL
- en: To pass the appropriate options to `sparkline()`, we can take advantage of the
    work we did in Step 5\. Since we created a special object for default options,
    that’s the only object we have to change.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We only need to make the change in one place, and all of our calls to `sparkline()`
    use the new options. Here is the final, complete JavaScript code for this example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 3-7](ch03.html#complete_example_distinguishes_different "Figure 3-7. A
    complete example distinguishes different individual data sets in a larger collection.")
    shows the final result. We have a table that integrates text and charts, and we
    can style those charts appropriately and efficiently for the default case, for
    a special class, and for a unique value.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A complete example distinguishes different individual data sets in a larger
    collection.](figs/web/03fig07.png.jpg)Figure 3-7. A complete example distinguishes
    different individual data sets in a larger collection.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Tracking Data Values](ch02.html#tracking_data_values "Tracking Data Values")
    uses a full-featured charting package for a similar result. If you don’t need
    the space efficiency of sparklines, consider that approach as an alternative.'
  prefs: []
  type: TYPE_NORMAL
- en: Annotating Sparklines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because they’re designed to maximize information density, sparklines omit many
    traditional chart components such as axes and labels. This approach certainly
    focuses on the data itself, but it can sometimes leave users without enough context
    to understand the data. Print versions usually rely on traditional text to supply
    this context, but on the Web we have more flexibility. We can present the data
    by itself in a sparkline, and we can give users the chance to explore the data’s
    context through interactions. *Tool tips*, which show additional information as
    a user hovers their mouse pointer over sections of a web page, can be an effective
    way to annotate a sparkline, so long as the users are accessing the page from
    a desktop computer. (Touch-based devices such as smartphones and tablets don’t
    typically support the concept of hover.) We’ll walk through a visualization that
    includes tool tips in this example; other examples in the chapter consider alternative
    approaches that may be more effective for touch devices. Let’s see how we can
    use a customized form of tool tips by enhancing the charts in the previous example.
    Just as in this chapter’s first example, we need to include the sparklines and
    jQuery libraries in our web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Prepare the Data'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous examples, we’ve embedded the data directly in the HTML markup.
    That’s convenient since it lets us separate the data from our code. In this example,
    however, the JavaScript code will need more-detailed knowledge of the data so
    it can present the right tool tip information. This time we’ll use a JavaScript
    array to store our data so that all the relevant information is in one place.
    For this example, we can focus on a single stock. And even though we’re graphing
    only the adjusted closing price, the array will track additional data that we
    can include in the tool tips. Here’s an excerpt of the data for one of the stocks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 2: Prepare the HTML Markup'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our visualization will include three distinct areas, each in a `<div>` element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The primary `<div>` created at ➊ will hold the chart. Underneath the chart we’ll
    add the primary tool tip information in its own `<div>` ➋, and we’ll include supplementary
    details to the right ➌. This example uses inline styles for clarity; a production
    site might prefer to use CSS style sheets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Add the Chart'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding the chart to our markup is easy with the sparklines library. We can use
    the jQuery `.map()` function to extract the adjusted close value from our `stock`
    array. The `minSpotColor` and `maxSpotColor` options tell the library how to highlight
    the lowest and highest values for the year.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The static chart of [Figure 3-8](ch03.html#static_sparkline_shows_the_change_in_the
    "Figure 3-8. A static sparkline shows the change in the data set over time.")
    shows the stock performance nicely.
  prefs: []
  type: TYPE_NORMAL
- en: '![A static sparkline shows the change in the data set over time.](figs/web/03fig08.png.jpg)Figure 3-8. A
    static sparkline shows the change in the data set over time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Add the Primary Annotation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sparklines library adds a simple tool tip to all of its charts by default.
    Although that tool tip shows the value over which the user’s mouse is hovering,
    the presentation isn’t particularly elegant, and, more importantly, it doesn’t
    provide as much information as we would like. Let’s enhance the default behavior
    to meet our needs.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the library’s defaults, we can retain the vertical marker, but we
    don’t want the default tool tip. Adding the option `disableTooltips` with a value
    of `true` will turn off the undesired tool tip.
  prefs: []
  type: TYPE_NORMAL
- en: For our own custom tool tip, we can rely on a handy feature of the sparklines
    library. The library generates a custom event whenever the user’s mouse moves
    over a chart region. That event is the `sparklineRegionChange` event. The library
    attaches a custom property, `sparklines`, to those events. By analyzing that property,
    we can determine the mouse’s location relative to the data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As the comment at ➊ indicates, the library sometimes generates the event when
    the mouse leaves the chart area. In those cases, a defined value for the offset
    will not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the mouse position, we can place our tool tip information in the
    `<div>` we set aside for it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We get the information at ➊ and ➋ from the `stock` array using the index value
    from the `sparklineRegionChange` event.
  prefs: []
  type: TYPE_NORMAL
- en: The sparklines library isn’t completely reliable in generating events when the
    mouse leaves the chart area. Instead of using the custom event, therefore, we
    can use the standard JavaScript `mouseout` event. When the user moves the mouse
    off the chart, we’ll turn off the custom tool tip by setting its content to a
    blank space. We use the HTML nonbreaking space (`&nbsp;`) so the browser doesn’t
    think the `<div>` is completely empty. If we used a standard space character,
    the browser would treat the `<div>` as empty and recalculate the height of the
    page, causing an annoying jump in the page contents. (For the same reason, we
    should initialize that `<div>` with `&nbsp;` instead of leaving it blank.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For the cleanest implementation, we combine all of these steps using method
    chaining. (To keep it concise, I’ve omitted the chart styling options in the following
    excerpt.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Now with [Figure 3-9](ch03.html#interactive_sparkline_tracks_the_userapo "Figure 3-9. An
    interactive sparkline tracks the user’s mouse and provides information relevant
    to the mouse position.") we have a nice, interactive tool tip that tracks the
    user’s mouse as it moves across the chart.
  prefs: []
  type: TYPE_NORMAL
- en: '![An interactive sparkline tracks the user’s mouse and provides information
    relevant to the mouse position.](figs/web/03fig09.png.jpg)Figure 3-9. An interactive
    sparkline tracks the user’s mouse and provides information relevant to the mouse
    position.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 5: Provide Additional Information'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The tool tip information we’ve added so far shows the immediately relevant
    information to the user: the week and the adjusted closing price of the stock.
    Our data, however, contains additional information that might be useful to the
    user. We can expand on the original tool tip by displaying that as well.'
  prefs: []
  type: TYPE_NORMAL
- en: At the same time we update the primary tool tip region, let’s add the extra
    data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When we clear the primary tool tip region, we’ll clear this area as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Because it won’t affect the vertical size of the page, we don’t need to fill
    this `<div>` with a dummy `&nbsp;`.
  prefs: []
  type: TYPE_NORMAL
- en: With [Figure 3-10](ch03.html#interactive_sparklines_can_show_addition "Figure 3-10. Interactive
    sparklines can show additional information in many ways.") we have the visualization
    we want. The chart clearly shows the overall trend for the stock during the year,
    but it takes up only a small amount of space on the web page. At first glance
    the chart is also free of distracting elements such as labels and axes. For users
    who just want a general sense of the stock’s performance, those elements are superfluous.
    Users who want the full details need only hover their mouse over the chart, and
    it reveals the complete market information.
  prefs: []
  type: TYPE_NORMAL
- en: '![Interactive sparklines can show additional information in many ways.](figs/web/03fig10.png.jpg)Figure 3-10. Interactive
    sparklines can show additional information in many ways.'
  prefs: []
  type: TYPE_NORMAL
- en: Because we’ve managed to display the information while retaining the compact
    nature of sparklines, the technique in this example works well when combined with
    the small-multiples approach of this chapter’s second example. The next example
    includes an alternate method for showing the extra details.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing Composite Charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far in this chapter, we’ve seen how sparklines can provide a lot of visual
    information in a very small space. That characteristic makes them perfect for
    integrating charts in a complete web page that includes text, tables, and other
    elements. We haven’t yet exhausted the capabilities of sparklines, however. We
    can increase the information density of our visualizations still further by creating
    composite charts—in effect, drawing multiple charts in the same space.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see an example of this technique, we can build on the previous example.
    In that example we used a sparkline to show the closing price of a stock over
    an entire year. Price is indeed the most relevant data about a stock, but there’s
    another quantity that many investors like to see: the stock’s trading volume.
    And just as with price, it can be important to understand the trend for trading
    volume at a glance. That makes the value an excellent candidate for a chart.'
  prefs: []
  type: TYPE_NORMAL
- en: Just as in this chapter’s first example, we need to include the sparklines and
    jQuery libraries in our web page. Because we’re visualizing the same data as in
    the previous example, we’ll also want to set up the data array and the HTML markup
    exactly as in that example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 1: Draw the Trading Volume Chart'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though we’re including a chart of trading volume, the most important quantity
    is the stock price. To keep the emphasis on stock price, we want to draw that
    chart *on top of* the chart for trading volume. That means we need to draw the
    trading volume chart first.
  prefs: []
  type: TYPE_NORMAL
- en: The code for trading volume is very similar to that of the stock price from
    the previous example. Instead of an area chart, however, we’ll use a bar chart.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We use the jQuery `.map()` function to extract the `volume` property from our
    data array. Setting the `type` option to `"bar"` at ➊ is all it takes to tell
    the sparklines library to create a bar chart.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-11](ch03.html#sparklines_library_can_create_bar_charts "Figure 3-11. The
    sparklines library can create bar charts as well as line charts.") shows the results.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The sparklines library can create bar charts as well as line charts.](figs/web/03fig11.png.jpg)Figure 3-11. The
    sparklines library can create bar charts as well as line charts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Add the Closing Price Chart'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To add the price chart on top of the volume chart, we can call the sparklines
    library once again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We give it the same containing element and, most importantly, set the `composite`
    option to `true` at ➊. This parameter tells the library not to erase any existing
    chart in the element but to simply draw over it.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the way we specify the fill color for the second chart. We set a transparency
    (or *alpha*) value of `0.3`. This value makes the chart area nearly transparent,
    so the volume chart will show through. Note, though, that some older web browsers,
    notably IE8 and earlier, do not support the transparency standard. If your site
    has a significant number of users with those browsers, you might consider simply
    setting the `fillColor` option to `false`, which will disable filling the area
    entirely.
  prefs: []
  type: TYPE_NORMAL
- en: As [Figure 3-12](ch03.html#multiple_charts_may_be_combined_in_the_s "Figure 3-12. Multiple
    charts may be combined in the same space.") shows, the result combines both charts
    in the same space.
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple charts may be combined in the same space.](figs/web/03fig12.png.jpg)Figure 3-12. Multiple
    charts may be combined in the same space.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Add the Annotations'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can add annotations to the chart using the same approach as in the previous
    example. Because our charts now include the trading volume, it’s appropriate to
    move that value from the details area into the primary annotation `<div>`. The
    code to do that is a simple adjustment from the prior example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In addition to moving the text from one area to the other, we’ve made two significant
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: We get the `idx` value from the second element of the event’s `sparklines` array
    (`sparklines[1]`) at ➊. That’s because the first element of that array is the
    first chart. The sparklines library doesn’t really return any useful information
    about bar charts in the `sparklineRegionChange` event. Fortunately, we can get
    all the information we need from the line bchart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We show the trading volume in millions, rounded to two decimal places. The calculation
    is in at ➋. It’s much easier for users to quickly grasp “24.4M” than “24402100.”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As in the previous example, the annotations in our chart (shown in [Figure 3-13](ch03.html#tracking_the_mouse_position_makes_it_pos
    "Figure 3-13. Tracking the mouse position makes it possible to interactively annotate
    the charts.")) provide additional details.
  prefs: []
  type: TYPE_NORMAL
- en: '![Tracking the mouse position makes it possible to interactively annotate the
    charts.](figs/web/03fig13.png.jpg)Figure 3-13. Tracking the mouse position makes
    it possible to interactively annotate the charts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Show Details as a Chart'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far we’ve shown the additional details for the stock (open, close, high,
    and low) as text values. As long as we’re drawing multiple charts, we can show
    those values graphically as well. The statistical box plot serves as a useful
    model for us. Traditionally, that plot type shows the range of a distribution,
    including deviations, quartiles, and medians. Visually, however, it provides a
    perfect model of a stock’s trading performance. We can use it to show the opening
    and closing prices, as well as the high and low values during the period.
  prefs: []
  type: TYPE_NORMAL
- en: 'The sparklines library can draw a box plot for us, but normally it calculates
    the values to display given the distribution as input data. In our case we don’t
    want to use the standard statistical calculations. Instead, we can use an option
    that tells the library to use precomputed values. The library expects at least
    five values:'
  prefs: []
  type: TYPE_NORMAL
- en: The lowest sample value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first quartile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The median
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third quartile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The highest sample value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For our example, we’ll provide the following values instead:'
  prefs: []
  type: TYPE_NORMAL
- en: The lowest price
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whichever is less of the opening and closing prices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The adjusted closing price
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whichever is greater of the opening and closing prices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The highest price
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll also color the median bar red or green depending on whether the stock
    gained or lost value during the period.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code creates that chart in response to the `sparklineRegionChange` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The data for the chart (shown at ➊) is simply the five values extracted from
    the stock data for the appropriate week. As ➋ and ➌ demonstrate, we can change
    the color of the median bar depending on whether the stock finished higher or
    lower for the day.
  prefs: []
  type: TYPE_NORMAL
- en: When the mouse leaves the chart region, we can remove the box plot by emptying
    its container.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now as our users mouse over the chart area, they can see a visual representation
    of the stock’s price range during each period ([Figure 3-14](ch03.html#interactive_annotations_can_be_charts_th
    "Figure 3-14. Interactive annotations can be charts themselves in addition to
    text.")).
  prefs: []
  type: TYPE_NORMAL
- en: '![Interactive annotations can be charts themselves in addition to text.](figs/web/03fig14.png.jpg)Figure 3-14. Interactive
    annotations can be charts themselves in addition to text.'
  prefs: []
  type: TYPE_NORMAL
- en: Responding to Click Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this chapter we’ve looked at how to include a lot of visual information
    in a small space, making it easier to integrate a visualization within a web page.
    The basic sparkline by itself is very efficient, and previous examples have added
    annotations and composites to increase the information density further. Sometimes,
    however, there’s just no way to fit all the possible data in a small enough space.
    Even in these cases, though, the interactive nature of the Web can help us out.
    Our web page can start with a compact visualization but expand to a different
    view—one with richer details—with a simple click or tap.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, the compact quality of sparklines seems to invite interaction. In every
    usability test I’ve performed that included sparklines on a web page, the participants
    invariably clicked on the chart. That was true even when there were no other details
    that the page could provide and the participants had no idea what to expect in
    response to their clicks. They clicked just to see what would happen.
  prefs: []
  type: TYPE_NORMAL
- en: This example continues our stock market example. We’ll begin with the same basic
    stock price chart we’ve seen before, but enhance it to provide details when users
    click on the chart region.
  prefs: []
  type: TYPE_NORMAL
- en: Just as in this chapter’s first example, we need to include the sparklines and
    jQuery libraries in our web page. Because we’re visualizing the same data as in
    the previous example, we’ll also want to set up the data array exactly as in that
    example. The HTML markup, however, can be much simpler. All we need is a `<div>`
    to hold the chart.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 1: Add the Chart'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Adding the chart to our markup is easy with the sparklines library. We can use
    the jQuery `.map()` function to extract the adjusted close value from our `stock`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The static chart of [Figure 3-15](ch03.html#starting_with_a_static_chart_ensures_tha
    "Figure 3-15. Starting with a static chart ensures that the visualization is sound."),
    which shows the stock performance, probably looks familiar by now.
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting with a static chart ensures that the visualization is sound.](figs/web/03fig15.png.jpg)Figure 3-15. Starting
    with a static chart ensures that the visualization is sound.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Handle Click Events'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The sparklines library makes it easy for us to handle click events. When users
    click on a chart region, the library generates a custom `sparklineClick` event.
    The event data includes all of the normal click properties, plus information about
    where on the chart the user clicked. To be notified of clicks, we define a handler
    for that custom event.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’re set up to receive `sparklineClick` events, we can write the code
    to respond to them. For our example, let’s reveal a detailed financial analysis
    widget. Many web services, including Yahoo and Google, have similar widgets, but
    we’ll use one from WolframAlpha. As is typical, WolframAlpha provides code for
    the widget as an HTML `<iframe>`. We can wrap that `<iframe>` in our own `<div>`
    and place it immediately after the chart. We set a `display` property of `none`
    so that the contents are initially hidden. (The following snippet omits the details
    of the `<iframe>` element for clarity.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now our event handling code can reveal the widget using the jQuery `show()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: That works to reveal the details, but as [Figure 3-16](ch03.html#mouse_clicks_can_reveal_more_details_for
    "Figure 3-16. Mouse clicks can reveal more details for a chart.") shows, the resulting
    presentation isn’t as elegant as it could be since the details appear so abruptly.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mouse clicks can reveal more details for a chart.](figs/web/03fig16.png.jpg)Figure 3-16. Mouse
    clicks can reveal more details for a chart.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 3: Improve the Transitions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Instead of simply revealing the widget beneath the chart, it would be better
    to have the widget replace the chart. And if we’re going to do that, we’ll also
    want to give users a chance to restore the chart and hide the widget.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, we include a `"widget-control" <div>` ➊ for controlling the widget’s visibility.
    The only content we need for this controller is a close symbol floated right.
    Just like the widget itself, the controller is initially hidden.
  prefs: []
  type: TYPE_NORMAL
- en: Now when the user clicks on the chart, we reveal the widget, reveal the controller,
    and hide the chart.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Next we intercept clicks on the close symbol in the widget controller. We first
    prevent default event handling; otherwise, the browser will jump disconcertingly
    to the top of the page. Then we hide the widget and its controller while revealing
    the chart again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we need to give the user some indication that this interaction is possible.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: On the chart, we override the sparklines library’s default tool tip at ➊ to
    let users know that more details are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now for the widget controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, we simply add a `title` attribute at ➊ to tell users how to hide the widget.
  prefs: []
  type: TYPE_NORMAL
- en: These additions give us the simple sparkline chart in [Figure 3-17](ch03.html#mouse_clicks_can_reveal_more_det-id00013
    "Figure 3-17. Mouse clicks can reveal more details for a chart."), which expands
    to offer a wealth of details with a single click. The close symbol in the upper-right
    corner lets users return to the more compact sparkline.
  prefs: []
  type: TYPE_NORMAL
- en: '![Mouse clicks can reveal more details for a chart.](figs/web/03fig17.png.jpg)Figure 3-17. Mouse
    clicks can reveal more details for a chart.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 4: Animate'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the final touch to our visualization, let’s do something about the abrupt
    hiding and revealing of the visualization components. A smoother animation will
    help our users follow the transition, and jQuery makes it easy enough to implement.
    There are lots of animation effects available in the jQuery UI library, but the
    basic functionality of jQuery’s core is fine for this example. We simply replace
    the `show()` and `hide()` functions with `slideDown()` and `slideUp()`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: At this point we can call our visualization complete; the final product is shown
    in [Figure 3-18](ch03.html#animating_transitions_can_make_the_visua "Figure 3-18. Animating
    transitions can make the visualization less jarring to users."). The compact sparkline
    smoothly transitions to reveal detailed information when the user clicks, and
    those details transition back to the sparkline when the user closes them.
  prefs: []
  type: TYPE_NORMAL
- en: '![Animating transitions can make the visualization less jarring to users.](figs/web/03fig18.png.jpg)Figure 3-18. Animating
    transitions can make the visualization less jarring to users.'
  prefs: []
  type: TYPE_NORMAL
- en: Updating Charts in Real Time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve seen in this chapter’s other examples, sparklines are great for integrating
    visualizations in a complete web page. They can be embedded in text content or
    used as table elements. Another application that suits sparklines well is an information
    dashboard. Effective dashboards summarize the health of the underlying system
    *at a glance*. When users don’t have the time to read through pages of texts or
    detailed graphics, the information density of sparklines makes them an ideal tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to high information density, most dashboards have another requirement:
    they must be up-to-date. For web-based dashboards, that means the contents should
    be continuously updated, even while users are viewing the page. There is no excuse
    for requiring users to refresh their browsers. Fortunately, the sparklines library
    makes it easy to accommodate this requirement as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Just as in this chapter’s first example, we need to include the sparklines and
    jQuery libraries in our web page. For this visualization we’ll show both a chart
    and the most recent value of the data. We define `<div>` elements for each and
    place both in a containing `<div>`. The following code includes some styles inline,
    but you could place them in an external style sheet. Here the styles are just
    meant to position the value immediately to the right of the chart rather than
    on a separate line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Step 1: Retrieve the Data'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a real dashboard example, the server would provide the data to display and
    updates to that data. As long as the frequency of the updates was modest (not
    faster than once every five seconds or so), we could simply poll the server for
    updates on a regular interval. It’s probably not a good idea, however, to use
    the JavaScript `setInterval()` function to control the polling interval. That
    may seem strange at first because `setInterval()` executes a function periodically,
    which would seem to meet the requirements exactly. The situation is not quite
    that simple, however. If the server or network encounters a problem, then requests
    triggered by `setInterval()` will continue unabated, stacking up in a queue. Then,
    when communication with the server is restored, all of the pending requests will
    immediately finish, and we’d have a flood of data to handle.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this problem, we can use the `setTimeout()` function instead. That
    function executes only once, so we’ll have to keep calling it explicitly. By doing
    that, though, we can make sure that we send a request to the server only after
    the current one finishes. This approach avoids stacking up a queue of requests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the structure of the code defines the `getData()` function and immediately
    executes it. The closing pair of parentheses at ➋ triggers the immediate execution.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `success` callback, we set up a recursive call to `getData()` at
    ➊ so the function executes again whenever the server responds with data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step 2: Update the Visualization'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever we receive updated information from the server, we can simply update
    the chart and value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The code needs only a straightforward call to the sparklines library and a jQuery
    function to update the value. We’ve added that to the code here at ➊ and ➋.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-19](ch03.html#live_updating_chart_can_show_real-time_d "Figure 3-19. A
    live updating chart can show real-time data.") shows what a default chart looks
    like. Of course, you can specify both the chart and text styles as appropriate
    for your own dashboard.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A live updating chart can show real-time data.](figs/web/03fig19.png.jpg)Figure 3-19. A
    live updating chart can show real-time data.'
  prefs: []
  type: TYPE_NORMAL
- en: Summing Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’ve considered various techniques for integrating visualizations
    within a web page. We’ve seen that sparklines are an excellent tool. Because they
    provide a lot of visual information in a small space, they leave room for other
    elements of the page, including text blocks, tables, and dashboards. We’ve considered
    several ways to increase the information density even further with annotations,
    composite charts, and click events. Finally, we looked at how to create charts
    that update in real time, accurately visualizing the up-to-the-minute status of
    an underlying system.
  prefs: []
  type: TYPE_NORMAL
