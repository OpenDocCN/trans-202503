<html><head></head><body><section class="chapter" title="Chapter&#xA0;2.&#xA0;Spacing" epub:type="chapter" id="spacing"><div class="titlepage"><div><div><h2 class="title">Chapter 2. Spacing</h2></div></div></div><p><a id="idx00056" class="indexterm"/><a id="idx00083" class="indexterm"/><a id="idx00243" class="indexterm"/><a id="idx00366" class="indexterm"/><a id="idx00415" class="indexterm"/><a id="idx00554" class="indexterm"/>In this chapter, we look at various one-liners that change line and word spacing, performing such tasks as double- and triple-spacing lines in a file, removing blank lines, and double-spacing words. You’ll also learn about various command-line arguments, such as <code class="literal">-p</code>, <code class="literal">-e</code>, <code class="literal">-n</code>, and special variables, such as <code class="literal">$_</code> and <code class="literal">$\</code>.</p><div class="sect1" title="2.1 Double-space a file"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="two_1_2_1_double-space_a_file">2.1 Double-space a file</h2></div></div></div><a id="I_programlisting2_id301337"/><pre class="programlisting">perl -pe '$\ = "\n"' <span class="emphasis"><em>file</em></span></pre><p>This one-liner double-spaces a file. I need to explain three things here: the <code class="literal">-p</code> and <code class="literal">-e</code> command-line options and the short <code class="literal">$\ = "\n"</code> Perl program.</p><p><a id="idx00022" class="indexterm"/><a id="idx00031" class="indexterm"/><a id="idx00124" class="indexterm"/><a id="idx00142" class="indexterm"/><a id="idx00188" class="indexterm"/><a id="idx00477" class="indexterm"/><a id="idx00633" class="indexterm"/><a id="idx00642" class="indexterm"/>Use the <code class="literal">-e</code> option to enter a Perl program directly at the command line. Typically you won’t want to create source files for every small program; with <code class="literal">-e</code> you can easily write a program directly at the command line as a one-liner. In this case, the entire Perl program contained in this one-liner is <code class="literal">$\ = "\n"</code>. Be sure to use single quotes (<code class="literal">'</code>) around the program, or your shell will interpret things like <code class="literal">$\</code> as shell variables, which have no value, effectively removing them!</p><p>Now let’s look at the <code class="literal">-p</code> switch. Specifying <code class="literal">-p</code> tells Perl to assume the following loop around your program:</p><a id="I_programlisting2_id301450"/><pre class="programlisting">while (&lt;&gt;) {
    # your program goes here (specified by -e)
} continue {
    print or die "-p failed: $!\n";
}</pre><p>Broadly speaking, this construct loops over all the input, executes your code, and prints the value of <code class="literal">$_</code> (the <code class="literal">print</code> statement prints the value of <code class="literal">$_</code>), which allows you to modify all or some lines of the input quickly. The <code class="literal">$_</code> variable is a special variable that gets replaced with the current line of text. It can be replaced with other stuff as well. You’ll learn all about <code class="literal">$_</code> as you work through the book. (See <a class="xref" href="apa.html" title="Appendix A. Perl’s Special Variables">Appendix A</a> for a summary of its use cases.)</p><p>But understanding what is going on in this loop in more detail is important. First, the <code class="literal">while (&lt;&gt;)</code> loop takes each line from the standard input and puts it in the <code class="literal">$_</code> variable. Next, the code specified by <code class="literal">-e</code> is executed, followed by the <code class="literal">print or die</code> portion.</p><p>The <code class="literal">continue</code> statement executes the <code class="literal">print or die</code> statement after each line, which attempts to print the contents of the <code class="literal">$_</code> variable. If the attempt fails (for example, the terminal is not writable or standard output has been redirected to something that isn’t writable), <code class="literal">die</code> makes Perl exit (die) with an error message.</p><p>In this one-liner, the code specified by <code class="literal">-e</code> is <code class="literal">$\ = "\n"</code>, so the program that Perl executes looks like this:</p><a id="I_programlisting2_id301538"/><pre class="programlisting">while (&lt;&gt;) {
    $\ = "\n";
} continue {
    print or die "-p failed: $!\n";
}</pre><p><a id="idx00041" class="indexterm"/><a id="idx00081" class="indexterm"/><a id="idx00084" class="indexterm"/><a id="idx00446" class="indexterm"/>This Perl program reads each line into the <code class="literal">$_</code> variable and then sets <code class="literal">$\</code> to a newline and calls <code class="literal">print</code>. Another special variable is <code class="literal">$\</code>. It is similar to the <code class="literal">ORS</code> (Output Record Separator) variable in Awk in that it is appended after every <code class="literal">print</code> operation. A <code class="literal">print</code> statement with no arguments prints the contents of <code class="literal">$_</code> and appends <code class="literal">$\</code> at the end of the output. As a result, each line is printed unmodified, followed by the <code class="literal">$\</code>, which was set to newline. The input is now double-spaced.</p><p>In fact, you actually do not need to set <code class="literal">$\</code> to newline for every line; you can set it just once at the beginning of the program:</p><a id="I_programlisting2_id301621"/><pre class="programlisting">perl -pe 'BEGIN { $\ = "\n" }' <span class="emphasis"><em>file</em></span></pre><p>This one-liner sets <code class="literal">$\</code> to the newline character just once before Perl does anything in the <code class="literal">BEGIN</code> code block. The <code class="literal">BEGIN</code> block is a special code block that is executed before everything else in a Perl program. Here’s what the expanded Perl program looks like, and it works exactly the same way as the previous one-liner:</p><a id="I_programlisting2_id301645"/><pre class="programlisting">BEGIN { $\ = "\n" }
while (&lt;&gt;) {
} continue {
    print or die "-p failed: $!\n";
}</pre><p>Here is another way to double-space a file. This one-liner appends another newline character at the end of each line and then <code class="literal">print</code>s the line:</p><a id="I_programlisting2_id301657"/><pre class="programlisting">perl -pe '$_ .= "\n"' <span class="emphasis"><em>file</em></span></pre><p>This one-liner is equivalent to</p><a id="I_programlisting2_id301667"/><pre class="programlisting">while (&lt;&gt;) {
    $_ = $_ . "\n"
} continue {
    print or die "-p failed: $!\n";
}</pre><p>Writing <code class="literal">$_ = $_ . "\n"</code> is the same as writing <code class="literal">$_ .= "\n"</code>. This expression simply concatenates <code class="literal">$_</code> with <code class="literal">"\n"</code>. (The period (<code class="literal">.</code>) is the string concatenation operator.)</p><p>But probably the cleanest way to double-space a file is to use the substitution operator <code class="literal">s</code>:</p><a id="I_programlisting2_id301703"/><pre class="programlisting">perl -pe 's/$/\n/' <span class="emphasis"><em>file</em></span></pre><p>This one-liner replaces the regular expression <code class="literal">$</code> that matches the end of a line with a newline, effectively adding a newline at the end.</p><p><a id="idx00125" class="indexterm"/><a id="idx00189" class="indexterm"/><a id="idx00463" class="indexterm"/><a id="idx00545" class="indexterm"/>If you’re running Perl 5.10 or later, you can use the <code class="literal">say</code> operator. The <code class="literal">say</code> operator acts much like <code class="literal">print</code>, but it always adds a newline at the end of the line. In Perl 5.10, this same one-liner can be written like this:</p><a id="I_programlisting2_id301762"/><pre class="programlisting">perl -nE 'say' <span class="emphasis"><em>file</em></span></pre><p>The <code class="literal">-E</code> command-line argument works exactly the same way as the <code class="literal">-e</code> command-line argument, but it also enables Perl 5.10 features, including the <code class="literal">say</code> operator. The <code class="literal">-n</code> argument is similar to <code class="literal">-p</code>, but you have to print the line yourself. (I explain the <code class="literal">-n</code> argument in more detail in one-liner 2.6.) This one-liner prints the line, followed by another newline that’s appended by the <code class="literal">say</code> operator.</p><p>For example, if a file contains four lines:</p><a id="I_programlisting2_id301803"/><pre class="programlisting">line1
line2
line3
line4</pre><p>running any of these one-liners outputs the following:</p><a id="I_programlisting2_id301811"/><pre class="programlisting">line1

line2

line3

line4</pre><p>In these first few examples, I passed a filename as the last argument to the one-liners. When I do that, the one-liners operate on the contents of that file. If I didn’t pass a filename to the one-liners, they’d operate on the data from the standard input. From now on I won’t specify a file at the end of the one-liners, but you can always add it back if you want to run the one-liners on files. When writing one-liners, it’s a good idea to quickly test if they’re correct by typing something directly to the standard input. Then when you’re sure the one-liner works, you can pass one or more filenames at the end.</p><p>Again, don’t forget about Perl’s handy documentation system, <span class="emphasis"><em>perldoc</em></span>. Just type <code class="literal">perldoc perlrun</code> at the command line to display information about how to run Perl and all the command-line arguments.</p></div><div class="sect1" title="2.2 Double-space a file, excluding the blank lines"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="two_2_double-space_a_file_excluding_the">2.2 Double-space a file, excluding the blank lines</h2></div></div></div><a id="I_programlisting2_id301843"/><pre class="programlisting">perl -pe '$_ .= "\n" unless /^$/'</pre><p><a id="idx00055" class="indexterm"/><a id="idx00146" class="indexterm"/><a id="idx00615" class="indexterm"/>This one-liner double-spaces all lines that are not completely empty by appending a newline character at the end of each nonblank line. The <code class="literal">unless</code> means “if not,” and <code class="literal">unless /^$/</code> means “if not ‘beginning then end of line.’” The condition “beginning then end of line” is true only for blank lines.</p><p>Here’s how this one-liner looks when expanded:</p><a id="I_programlisting2_id301882"/><pre class="programlisting">while (&lt;&gt;) {
    unless (/^$/) {
        $_ .= "\n"
    }
} continue {
    print or die "-p failed: $!\n";
}</pre><p>Here is a better test, which takes into account spaces and tabs on a line:</p><a id="I_programlisting2_id301890"/><pre class="programlisting">perl -pe '$_ .= "\n" if /\S/'</pre><p>Here, the line is matched against <code class="literal">\S</code>—a regular expression sequence that is the inverse of <code class="literal">\s</code>, which matches any whitespace character (including tab, vertical tab, space, newline, and carriage return). The inverse of <code class="literal">\s</code> is any nonwhitespace character. The result is that every line with at least one nonwhitespace character is double-spaced.</p></div><div class="sect1" title="2.3 Triple-space a file"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="two_3_triple-space_a_file">2.3 Triple-space a file</h2></div></div></div><p>You can also triple-space a file simply by outputting more newlines at the end of each line:</p><a id="I_programlisting2_id301926"/><pre class="programlisting">perl -pe '$\ = "\n\n"'</pre><p>Or</p><a id="I_programlisting2_id301933"/><pre class="programlisting">perl -pe '$_ .= "\n\n"'</pre><p>Or</p><a id="I_programlisting2_id301940"/><pre class="programlisting">perl -pe 's/$/\n\n/'</pre><p>These one-liners are similar to the first one-liner in this chapter, except that two newlines are appended after each line.</p></div><div class="sect1" title="2.4 N-space a file"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="two_4_n-space_a_file">2.4 N-space a file</h2></div></div></div><a id="I_programlisting2_id301959"/><pre class="programlisting">perl -pe '$_ .= "\n"x7'</pre><p><a id="idx00139" class="indexterm"/><a id="idx00174" class="indexterm"/><a id="idx00346" class="indexterm"/><a id="idx00413" class="indexterm"/><a id="idx00467" class="indexterm"/><a id="idx00470" class="indexterm"/><a id="idx00537" class="indexterm"/><a id="idx00560" class="indexterm"/><a id="idx00675" class="indexterm"/>This one-liner inserts seven newlines after each line. Notice how I’ve used <code class="literal">"\n" x 7</code> to repeat the newline character seven times. The <code class="literal">x</code> operator repeats the value on the left <span class="emphasis"><em>N</em></span> times.</p><p>For example, the line</p><a id="I_programlisting2_id302048"/><pre class="programlisting">perl -e 'print "foo"x5'</pre><p>prints <code class="literal">foofoofoofoofoo</code>.</p><p>As a side note, sometimes when you need to generate a certain amount of data, the <code class="literal">x</code> operator comes in really handy. For example, to generate 1KB of data, you could do this:</p><a id="I_programlisting2_id302069"/><pre class="programlisting">perl -e 'print "a"x1024'</pre><p>This one-liner prints the <span class="emphasis"><em>a</em></span> character 1024 times.</p></div><div class="sect1" title="2.5 Add a blank line before every line"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="two_5_add_a_blank_line_before_every_line">2.5 Add a blank line before every line</h2></div></div></div><a id="I_programlisting2_id302089"/><pre class="programlisting">perl -pe 's/^/\n/'</pre><p>This one-liner uses the <code class="literal">s/regex/replace/</code> operator. It substitutes the given regular expression with the replacement. In this one-liner, the operator is <code class="literal">s/^/\n/</code>, the regular expression is <code class="literal">^</code>, and the replacement is <code class="literal">\n</code>. The <code class="literal">^</code> pattern matches the beginning position of the text, and the <code class="literal">s</code> operator replaces it with <code class="literal">\n</code>, a newline. As a result, the newline character is inserted before the line. To insert something else before the line, simply replace <code class="literal">\n</code> with the bit to be inserted.</p></div><div class="sect1" title="2.6 Remove all blank lines"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="two_6_remove_all_blank_lines">2.6 Remove all blank lines</h2></div></div></div><a id="I_programlisting2_id302142"/><pre class="programlisting">perl -ne 'print unless /^$/'</pre><p>This one-liner uses the <code class="literal">-n</code> flag, which tells Perl to assume a different loop, other than <code class="literal">-p</code>, around the program:</p><a id="I_programlisting2_id302157"/><pre class="programlisting">while (&lt;&gt;) {
    # your program goes here
}</pre><p><a id="idx00008" class="indexterm"/><a id="idx00135" class="indexterm"/><a id="idx00178" class="indexterm"/><a id="idx00263" class="indexterm"/><a id="idx00333" class="indexterm"/><a id="idx00339" class="indexterm"/><a id="idx00343" class="indexterm"/><a id="idx00437" class="indexterm"/>Compare this loop to the one that Perl assumes when you specify <code class="literal">-p</code>, and you’ll see that this loop has no <code class="literal">continue { print or die }</code> part. In this loop, each line is read by the diamond operator <code class="literal">&lt;&gt;</code> and is placed in the special variable <code class="literal">$_</code>, but it’s not printed! You have to print the line yourself—a useful feature if you want to print, modify, or delete lines selectively.</p><p>In this one-liner, the code is <code class="literal">print unless /^$/</code>, so the entire Perl program becomes</p><a id="I_programlisting2_id302245"/><pre class="programlisting">while (&lt;&gt;) {
    print unless /^$/
}</pre><p>Unraveling this a bit further, you get this:</p><a id="I_programlisting2_id302253"/><pre class="programlisting">while (&lt;&gt;) {
    print $_ unless $_ =~ /^$/
}</pre><p>This one-liner prints all nonblank lines. (You saw the <code class="literal">/^$/</code> regular expression in one-liner 2.2 on page 11.)</p><p>This one-liner also removes all blank lines:</p><a id="I_programlisting2_id302269"/><pre class="programlisting">perl -lne 'print if length'</pre><p>This one-liner uses the <code class="literal">-l</code> command-line argument, which automatically chomps the input line (basically removes the newline at the end) and appends it back at the end of the line when printing. The code specified to the <code class="literal">-e</code> argument is <code class="literal">'print if length'</code>, which says “print the line if it has some length.” Empty lines have a length of 0, so they’re not printed (0 is a false value in Perl, so the <code class="literal">if length</code> condition evaluates to false). All other lines have length and are printed. Without <code class="literal">-l</code>, the string would still have the newline at the end and thus be 1 or 2 characters long!<sup>[<a id="id338042" href="#ftn.id338042" epub:type="noteref" class="footnote">1</a>]</sup></p><p>Here’s another one-liner to remove all blank lines:</p><a id="I_programlisting2_id302308"/><pre class="programlisting">perl -ne 'print if /\S/'</pre><p>This one-liner behaves slightly differently from the previous two. Both <code class="literal">print unless /^$/</code> and <code class="literal">print if length</code> also print the lines that consist of only spaces and/or tabs. Such lines appear to be empty to the eye, and you may want to filter them. This one-liner uses <code class="literal">\S</code> (explained in one-liner 2.2 on page 11), a regular expression sequence that matches nonblank characters. Lines containing only spaces and/or tabs don’t match <code class="literal">\S</code> and therefore are not printed.</p><p><a id="idx00001" class="indexterm"/><a id="idx00003" class="indexterm"/><a id="idx00116" class="indexterm"/><a id="idx00118" class="indexterm"/><a id="idx00482" class="indexterm"/><a id="idx00550" class="indexterm"/><a id="idx00595" class="indexterm"/><a id="idx00603" class="indexterm"/><a id="idx00604" class="indexterm"/><a id="idx00647" class="indexterm"/>As you can see, you can write the same program in many different ways. In fact, Perl’s motto is <span class="emphasis"><em>There’s More Than One Way To Do It</em></span>, which is abbreviated as <span class="emphasis"><em>TIMTOWTDI</em></span> and pronounced “Tim Toady.” (Fun trivia: Larry Wall, the inventor of Perl, uses the handle @TimToady on Twitter and IRC.)</p></div><div class="sect1" title="2.7 Remove all consecutive blank lines, leaving only one"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="two_7_remove_all_consecutive_blank_lines">2.7 Remove all consecutive blank lines, leaving only one</h2></div></div></div><a id="I_programlisting2_id302426"/><pre class="programlisting">perl -00 -pe ''</pre><p>This one-liner is really tricky, isn’t it? First, it doesn’t have any code! The <code class="literal">-e</code> is empty. Next, it has a silly <code class="literal">-00</code> command-line option that turns <span class="emphasis"><em>paragraph slurp mode</em></span> on, meaning Perl reads text paragraph by paragraph, rather than line by line. (A paragraph is text between two or more newlines.) The paragraph is put into <code class="literal">$_</code>, and the <code class="literal">-p</code> option prints it out.</p><p>You can even write this in a shorter fashion:</p><a id="I_programlisting2_id302457"/><pre class="programlisting">perl -00pe0</pre><p>Here, the code specified to <code class="literal">-e</code> is <code class="literal">0</code>, which does nothing.</p><p>This is one of my favorite one-liners because if you haven’t seen it before, it can be tricky to figure out, and I love mind games. (There’s no code specified to <code class="literal">-e</code>! How can it possibly do something?)</p></div><div class="sect1" title="2.8 Compress/expand all blank lines into N consecutive lines"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="two_8_compress_expand_all_blank_lines_in">2.8 Compress/expand all blank lines into N consecutive lines</h2></div></div></div><p>Say you have a file with two blank lines after each paragraph, and you wish to expand the line spacing between the paragraphs to three lines. To do so, you can simply combine one-liners 2.4 and 2.7 like this:</p><a id="I_programlisting2_id302498"/><pre class="programlisting">perl -00 -pe '$_ .= "\n"x2'</pre><p>This one-liner slurps lines paragraph-wise via the <code class="literal">-00</code> option and then appends three newline characters after each paragraph. The code <code class="literal">"\n"x2</code> prints two newlines, which are added to the blank line already at the end of the paragraph.</p><p>In a similar vein, you can also reduce the spacing between paragraphs. Say you’ve got a file that for some crazy reason has ten blank lines between paragraphs, and you want to compress these blank lines to just three. You can use the same one-liner again!</p></div><div class="sect1" title="2.9 Double-space between all words"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="two_9_double-space_between_all_words">2.9 Double-space between all words</h2></div></div></div><a id="I_programlisting2_id302529"/><pre class="programlisting">perl -pe 's/ /  /g'</pre><p><a id="idx00176" class="indexterm"/><a id="idx00555" class="indexterm"/><a id="idx00583" class="indexterm"/><a id="idx00674" class="indexterm"/>Here, you use the substitution operator <code class="literal">s</code> to replace one space “ ” with two spaces “ ” globally on each line (the <code class="literal">/g</code> flag makes the replacement global), and you’re done. It’s that simple!</p><p>Here’s an example. Let’s say you have this line of text:</p><a id="I_programlisting2_id302581"/><pre class="programlisting">this line doesn't have enough whitespace!</pre><p>Running this one-liner increases the spacing between words:</p><a id="I_programlisting2_id302589"/><pre class="programlisting">this  line  doesn't  have  enough  whitespace!</pre></div><div class="sect1" title="2.10 Remove all spacing between words"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="two_10_remove_all_spacing_between_words">2.10 Remove all spacing between words</h2></div></div></div><a id="I_programlisting2_id302604"/><pre class="programlisting">perl -pe 's/ +//g'</pre><p>This one-liner uses the “<code class="literal">+</code>” regular expression to match one or more spaces. When it finds a match, it substitutes it with nothing, globally, which deletes all spaces between words.</p><p>If you also want to get rid of tabs and other special characters that might add spacing, use the <code class="literal">\s+</code> regular expression, which means “match a space, a tab, a vertical tab, a newline, or a carriage return”:</p><a id="I_programlisting2_id302626"/><pre class="programlisting">perl -pe 's/\s+//g'</pre><p>Here’s an example. Let’s say you have this line of text:</p><a id="I_programlisting2_id302633"/><pre class="programlisting">this line has too much whitespace said cowboy neal</pre><p>Running this one-liner removes all spaces:</p><a id="I_programlisting2_id302642"/><pre class="programlisting">thislinehastoomuchwhitespacesaidcowboyneal</pre></div><div class="sect1" title="2.11 Change all spacing between words to one space"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="two_11_change_all_spacing_between_words">2.11 Change all spacing between words to one space</h2></div></div></div><a id="idx00059" class="indexterm"/><a id="idx00110" class="indexterm"/><a id="idx00345" class="indexterm"/><a id="idx00553" class="indexterm"/><a id="I_programlisting2_id302690"/><pre class="programlisting">perl -pe 's/ +/ /g'</pre><p>This one-liner is similar to the previous one, except that it replaces one or more spaces with just one space.</p><p>For example, if you have this line:</p><a id="I_programlisting2_id302702"/><pre class="programlisting">this   line has really           messed-up                    spacing</pre><p>running this one-liner normalizes the spacing between words to one space:</p><a id="I_programlisting2_id302709"/><pre class="programlisting">this line has really messed-up spacing</pre></div><div class="sect1" title="2.12 Insert a space between all characters"><div class="titlepage"><div><div><h2 class="title" style="clear: both" id="two_12_insert_a_space_between_all_charac">2.12 Insert a space between all characters</h2></div></div></div><a id="I_programlisting2_id302725"/><pre class="programlisting">perl -lpe 's// /g'</pre><p>Here you match seemingly nothing and replace it with a single space. The nothingness actually means “match between characters,” with the result that you insert a space between all characters. (The matching includes the beginning and end of the text.)</p><p>For example, given this line:</p><a id="I_programlisting2_id302738"/><pre class="programlisting">today was a great day</pre><p>running this one-liner produces this result:</p><a id="I_programlisting2_id302746"/><pre class="programlisting">t o d a y   w a s   a   g r e a t   d a y</pre><p>It might be difficult to see where all the spaces are added, so let’s illustrate that by modifying this one-liner to insert a colon between all characters:</p><a id="I_programlisting2_id302755"/><pre class="programlisting">perl -lpe 's//:/g'</pre><p>This will output:</p><a id="I_programlisting2_id302762"/><pre class="programlisting">:t:o:d:a:y: :w:a:s: :a: :g:r:e:a:t: :d:a:y:</pre><p>As you can see, spaces (or colons) are also inserted at the beginning and end of the text. Also note that the existing spaces count as characters, so they’re triple-spaced.</p></div><div class="footnotes" epub:type="footnotes"><br/><hr style="width: 100; align: left;"/><div class="footnote" epub:type="footnote" id="ftn.id338042"><p><sup>[<a href="#id338042" class="para">1</a>] </sup>Windows uses two characters for the newline.</p></div></div></section></body></html>