- en: '3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Cheater’s Dice Roller by John Baichtal
  prefs: []
  type: TYPE_NORMAL
- en: In this project, you’ll build a digital dice roller with a twist.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0065-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Do you suffer from polyhedral dice elbow from playing too much *Dungeons & Dragons*
    or other tabletop role-playing games? (I’m talking about the dice with lots of
    different shapes. A player might strain a ligament throwing those dice so often!)
    Or maybe you just want the convenience of generating your die rolls electronically?
    Either way, this dice roller is the solution, and then some.
  prefs: []
  type: TYPE_NORMAL
- en: 'You have the option to switch between a D&D standard 20-sided die and the two
    10-sided dice of *Warhammer Fantasy Roleplay* and other systems, though I’ll show
    you how to customize this to any two-digit variety. However, this is no ordinary
    dice roller: built-in cheats set it apart. I’ll show you how to trigger a high
    roll or a low roll without any of your hapless gaming friends ever knowing, using
    nothing but magnets, sensors, and some sleight of hand.'
  prefs: []
  type: TYPE_NORMAL
- en: I built the project enclosure as a medieval castle made out of laser-cut wood.
    The last section of this chapter will talk more about the idea behind my enclosure
    and ways to make your own.
  prefs: []
  type: TYPE_NORMAL
- en: '**GET THE PARTS**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Grab the following parts to build your dice roller. I ordered most of the parts
    from Adafruit and SparkFun.
  prefs: []
  type: TYPE_NORMAL
- en: '**Components**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*See “[Getting Started with the Arduino and the Arduino IDE](intro.xhtml#lev17)”
    on [page 15](intro.xhtml#page_15) for setup instructions.*'
  prefs: []
  type: TYPE_NORMAL
- en: Arduino Uno (Adafruit P/N 50 or SparkFun P/N 11021)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: USB A-B cable (Adafruit P/N 62)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two 8 × 8 LED matrices with I²C backpacks (Adafruit P/N 872)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two reed switches (SparkFun P/N 8642)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large push button (for example, SparkFun P/N 9336)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Double-throw switch (Adafruit P/N 805)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wall wart or 9 V battery clip (Adafruit P/N 63 or Adafruit P/N 80)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Piezo buzzer (Adafruit P/N 1739)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 10 kΩ resistors (SparkFun P/N 10969 is a good multipack)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Magnet, powerful enough to trigger the sensor reliably (for example, Adafruit
    P/N 9)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Optional) Breadboard (SparkFun P/N 12002)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Power the project with either a 9 V wall wart (such as Adafruit P/N 63) or
    a 9 V jack adapter (such as Adafruit P/N 80) plugged into the power jack on the
    Arduino.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tools**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Laser cutter or saw (such as a jigsaw or band saw)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soldering iron
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wire snips and pliers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hot glue gun
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wood glue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spray paint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**INTRODUCING THE LED MATRIX**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’re using 8 × 8 LED matrices to display the results of the dice throws. Every
    pixel of an LED matrix is independent, and you selectively trigger them, lighting
    up or dimming each LED to make a pattern. The simplest way to do this is to store
    the status of each pixel in an array. For instance, [Figure 3-1](ch03.xhtml#ch03fig1)
    shows an array of LEDs selectively lit to make a smiley face.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0067-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 3-1:** Use arrays to store smiles.'
  prefs: []
  type: TYPE_NORMAL
- en: You can control your LED matrix with code on an Arduino. The Arduino sketch
    looks at the array to see the status of each LED, lighting or turning them off
    every time the sketch loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet gives you a sense of how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Each line represents a row on the matrix, and each digit represents one LED.
    When the LED value is set to `1`, it’s lit. When it’s set to `0`, it’s unlit.
    You can design any graphic you want with this method.
  prefs: []
  type: TYPE_NORMAL
- en: However, typing this out for every design can be tedious, so there’s a convenient
    database of shapes controlled by an Arduino library for the matrix used in this
    project. The library stores functions that draw letters and numbers, as well as
    basic shapes like squares and circles, so you don’t need to design these shapes
    from scratch. In “[Code It](ch03.xhtml#lev60)” on [page 71](ch03.xhtml#page_71),
    I’ll explain how the sketch interacts with the library to draw those default shapes.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you need instructions on soldering, see the appendix.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**BUILD IT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Follow these steps to build a dice roller that can secretly do your bidding:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Solder the matrices to their boards.** The matrices come with mini control
    boards known as *backpacks* that manage the complexity of running 64 LEDs with
    just a few wires. You need to solder these backpacks to your matrices: add the
    matrix to the backpack with the IC (*integrated circuit*, also known as a *microchip*)
    on the underside and solder the pins in place in the holes. The end result should
    look like [Figure 3-2](ch03.xhtml#ch03fig2). There is no up or down to the matrix,
    as long as you add it to the correct side of the board. If you need more guidance,
    refer to the page for this product (P/N 872) on *[http://www.adafruit.com/](http://www.adafruit.com/)*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0068-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 3-2:** Solder in one or two of these jumpers to change the matrix’s
    I²C address.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Solder in pins or wires.** There are four pins that connect the matrix to
    the rest of the project. If you plan to use the matrices with a breadboard, solder
    in the accompanying header pins. If you want to use wires instead, leave them
    off.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Solder board pin A1.** Of particular importance are the two A0 and A1 solder
    pads, seen in [Figure 3-2](ch03.xhtml#ch03fig2), which allow you to daisy-chain
    up to four matrices by selectively soldering the pads. This is known as “changing
    the I²C address.” If you solder none of the pads, the I²C address for that matrix
    defaults to 0x70\. Soldering A0 sets the value to 0x71, soldering A1 sets it to
    0x72, and soldering both A0 and A1 identifies the matrix as 0x73\. Giving each
    matrix its own address allows us to talk to one matrix without the other responding
    even though they share wires. You need to add solder to just one of these pins
    on one board, so add solder to pin A1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Connect the matrices to the Arduino.** Add your matrices to a breadboard
    and connect the power and ground rails to 5V and GND, respectively, and then connect
    both power rails at either side of the board, as shown in [Figure 3-3](ch03.xhtml#ch03fig3).
    Connect power and ground of the first matrix to power and ground on the board,
    then connect up the ground and power pins of both matrices so they are both powered.
    You’ll also need to connect the data and clock wires. Connect pins A4 and A5 on
    the Arduino to the D and C pins, respectively, on one backpack, and with another
    pair of wires connect D and C of the first matrix to D and C of the second matrix.
    In [Figure 3-3](ch03.xhtml#ch03fig3) the data and clock wires are yellow and green,
    respectively.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0069-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 3-3:** Attach the matrices.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Depending on your project, you may need to connect the matrices with wires rather
    than plugging them into the breadboard in order to make them fit. If this is the
    case, you can still attach the matrices as shown in [Figure 3-3](ch03.xhtml#ch03fig3).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Attach the double-throw switch.** Next, connect the double-throw switch,
    as shown in [Figure 3-4](ch03.xhtml#ch03fig4), with the middle lead connected
    to 5V (pink wire) and the left and right leads connected to digital pins 10 and
    11 on the Arduino, respectively (brown wires). Also connect the left and right
    leads of the switch to ground via 10 kΩ resistors, shown in white in [Figure 3-4](ch03.xhtml#ch03fig4).
    This switch will determine whether this is in D&D d20 mode or Warhammer d100 mode:
    the Arduino can check the position of the switch by scanning pins 10 and 11.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0070-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 3-4:** Adding the double-throw switch'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Connect the reed switches.** The reed switches come next. As shown in [Figure
    3-5](ch03.xhtml#ch03fig5), connect the switches to pins 5 and 6 on the Arduino
    (purple wires) with the other leads going to ground (gray wires).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0070-02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 3-5:** The reed switches tell the Arduino when a magnet is near.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Add the reset button.** The reset button isn’t for starting over when you
    mess up; it’s really your roll button. The project software dictates that the
    dice roll once and then stop, and you must cycle the power or reset the Arduino
    in order to reroll. [Figure 3-6](ch03.xhtml#ch03fig6) shows the button installed.
    Connect one lead to Reset on the Arduino’s power bus (orange wire) and the other
    to GND (pink), soldering in wires to the button’s leads as needed. When the button
    is pressed, the Arduino restarts and automatically reruns the dice roller program.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0071-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 3-6:** Adding a button to reset the Arduino'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Install the buzzer.** The buzzer completes the project. It makes a sound
    to signal the completed die roll. The buzzer I included in the parts list features
    breadboard-friendly leads and is attached as shown in [Figure 3-7](ch03.xhtml#ch03fig7):
    connect the positive lead to pin 9 on the Arduino and the negative lead to GND.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0071-02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 3-7:** Wiring up the buzzer'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now it’s time to add code!
  prefs: []
  type: TYPE_NORMAL
- en: '**CODE IT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that the electronics are assembled, it’s time to test the project by uploading
    code to the Arduino.
  prefs: []
  type: TYPE_NORMAL
- en: The LEDBackpack library does most of the heavy lifting in this script. The backpack’s
    library has code for the full alphabet, as well as to draw shapes like lines,
    circles, and squares. You’ll need to download the library from the Adafruit product
    page (*[https://learn.adafruit.com/adafruit-led-backpack/0-8-8x8-matrix](https://learn.adafruit.com/adafruit-led-backpack/0-8-8x8-matrix)*)
    and save it to your Arduino libraries folder before you can make use of it. The
    product page also includes tutorials and tons of information if you want to learn
    more.
  prefs: []
  type: TYPE_NORMAL
- en: The code for the project is also in the book’s resources, so open that in the
    Arduino IDE now and let’s go through the code section by section.
  prefs: []
  type: TYPE_NORMAL
- en: The first part of the code consists of references to three libraries used in
    the sketch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the backpacks are formally initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We name the backpacks `matrix1` and `matrix2`. We then enable serial communications
    for debugging purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to communicate with the Serial Monitor. Next, we initialize
    some pins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The pins interacting with the double-throw switch, the buzzer, and the reed
    switches are initialized. In the latter case the pins are initialized so as to
    use the Arduino’s built-in resistors, ensuring no false positives trigger the
    cheat mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'This line seeds the random number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'By taking a reading from pin A0, we seed the random number we’ll use as our
    dice throw. Then we need to start up the matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This lets the Arduino know to power up the matrices, and makes sure all of
    the LEDs begin as off. These are the pin declarations for the switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember we have two settings for different types of dice. This is the number
    generation functionality for the d100 dice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use the throw switch to switch between d100 mode and D&D dice mode. Here,
    if the switch is set for d100, the Arduino rolls two random numbers, each between
    0 and 9\. Then it prints them to the Serial Monitor—but doesn’t print them to
    the matrices yet.
  prefs: []
  type: TYPE_NORMAL
- en: We then need to listen to the reed switches to see if they have been tripped
    by a magnet using two `if` statements—this is our cheat.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If a reed switch is tripped, the random value rolled up is superseded by either
    a maximum or minimum roll, depending which reed switch has been tripped. The two
    numbers are written to `matrix1` and `matrix2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have the random number generator for the d20:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If the switch is set to d20, the classic D&D die, the Arduino generates a random
    number between 0 and 19, adds 1, then sends the result to the Serial Monitor.
    The following series of `if` statements allows the sketch to supersede the rolled
    number with the cheats if a reed switch is tripped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Whatever the outcome, the number rolled needs to be displayed on the matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This displays the result. The program runs once and then stops.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Because we only want the code to run once, there is no need for a loop and it
    goes unused! The sketch is complete.
  prefs: []
  type: TYPE_NORMAL
- en: '**ASSEMBLE IT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, you’ll need a box of some sort that will enclose your project. You can
    approach this step in a few different ways.
  prefs: []
  type: TYPE_NORMAL
- en: '**Laser-Cut Your Own Enclosure**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: My first suggestion for anything usually involves designing and creating it
    yourself. My design resembles a small castle (see [Figure 3-8](ch03.xhtml#ch03fig8)),
    and this not only gets you in the mood for swordplay and magic spells, but also
    helps disguise the way you trigger the reed switches to swing the game your way.
    (More on that last bit after this section.) Here I’ll show you how I went about
    building my castle enclosure.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0076-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 3-8:** My castle-slash-dice roller, ready for action'
  prefs: []
  type: TYPE_NORMAL
- en: '**Design the case.** Design your case, using either a vector art program like
    Inkscape (*[https://inkscape.org/](https://inkscape.org/)*) or an online tool
    like MakerCase (*[http://www.makercase.com/](http://www.makercase.com/)*) that
    designs the case for you. You can also download my castle design in the book’s
    resources (*[https://nostarch.com/LEDHandbook/](https://nostarch.com/LEDHandbook/)*)
    and re-create or modify it as you see fit. [Figure 3-9](ch03.xhtml#ch03fig9) shows
    my case in Inkscape. Cut it out of quarter-inch plywood or the equivalent—I used
    a double-layer of eighth-inch plywood.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Output the design.** Cut out the design on a CNC router or laser cutter.
    [Figure 3-10](ch03.xhtml#ch03fig10) shows my design fresh from the laser cutter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0077-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 3-9:** I designed my castle design in Inkscape with help from *[makercase.com](http://makercase.com)*.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](../images/f0077-02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 3-10:** My design, freshly lasered'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Assemble the castle.** Clean up and assemble the castle, as shown in [Figure
    3-11](ch03.xhtml#ch03fig11). Few designs come out of the machine ready to assemble,
    so you should plan to work on the cut parts with files and sandpaper to get them
    to fit together. When you’re ready, glue the parts together.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0077-03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 3-11:** Assemble the lasered parts.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Paint and decorate the castle.** Paint the castle, as shown in [Figure 3-12](ch03.xhtml#ch03fig12).
    I suggest glossy spray paint to ward off dirt and fingerprints. Another good source
    of paint (given the subject matter) is your local hobby store, which doubtlessly
    offers innumerable shades of “dungeon gray” and “slime green” for adding details.
    What’s a proper dice roller without bloodstains and moss?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](../images/f0078-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**FIGURE 3-12:** A coat of silver paint adds sparkle to the castle.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Add electronics.** Place your project inside the enclosure, making sure the
    button is accessible. The arcade button has a deep footprint and may interfere
    with the Arduino’s placement. You also need to be mindful of the placement of
    the reed switches. Be sure to test the switches’ placement with a magnet before
    securing them to determine where you need to place the magnet so they can sense
    it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Alternate Enclosures**'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you don’t have access to a laser or mill, you’ll have to find something
    else to contain your project. Here are a couple of suggestions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Repurpose another box.** Simply find a sturdy box the right size to hold
    the components, and put them inside. Cut holes so the button, switch, and matrices
    can be installed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buy an enclosure.** You can also find a plethora of inexpensive project boxes
    on the web. One of my favorite sources is Jameco Electronics (*[https://www.jameco.com/](https://www.jameco.com/)*),
    which offers different sizes and levels of durability. As with the repurposed
    box, you’ll need to be aware of how much space the project’s guts will take up.
    An 8 × 6 × 3 project box like Jameco P/N 18869 does the trick.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build one out of LEGO bricks.** Chances are, you already have a great enclosure
    in your house, kept in a bucket in the basement next to the holiday boxes. I’m
    talking about LEGO! Simply build a box the right size, leaving holes for the switch,
    button, LED matrices, and power cord.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**USE IT**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Simply power the dice roller by plugging your wall wart or 9 V power adapter
    into the power jack, and press the button every time you want to roll a die, using
    the magnet on either reed switch depending on your diabolical goals.
  prefs: []
  type: TYPE_NORMAL
- en: I disguised my magnet by taking a gaming figure with a hollow plastic base and
    hot-gluing the magnet into the base, as shown in [Figure 3-13](ch03.xhtml#ch03fig13).
    The reed switches are positioned close to the top of the castle, and to trigger
    them you simply place the magnetized figure next to the battlements along with
    some innocuous figures. During the course of the game you move the figures around
    the “castle,” making sure to move the triggering figure to the correct spot as
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/f0079-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**FIGURE 3-13:** Hot-glue a magnet to the base of a gaming figure and use it
    to trigger your dice roller.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SUMMARY**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you complete the hardware and software portion of this project, it should
    look something like the photo on page 65, or a variation thereof with your own
    imaginative design.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, you’re also wrestling with the morals of hoodwinking your gaming
    associates. Good luck with this project!
  prefs: []
  type: TYPE_NORMAL
