["```\nanArray .space 256, 0  // 256 bytes, all initialize to 0\n```", "```\ninitializedArray: .word 1, 2, 3, 4, 5, 6, 7, 8\n```", "```\nstruct student\n    byte  sName, 65 // Includes zero-terminating byte\n    hword Major\n    byte  SSN, 12   // Includes zero-terminating byte\n    hword Midterm1\n    hword Midterm2\n    hword Final\n    hword Homework\n    hword Projects\nends student\n```", "```\nstp fp, lr, [sp, #-16]!   // Save LR and FP values.\nmov fp, sp                // Get activation record ptr in FP.\nsub sp, sp, #NumVars      // Allocate local storage.\n```", "```\nmov sp, fp    // Deallocate storage for all the local vars.\nldp fp, lr, [sp], #16  // Pop FP and return address.\nret                    // Return to caller.\n```", "```\nldr w0, [fp, #x]\nldr w1, [fp, #y]\nadd w0, w0, w1\nstr w0, [fp, #x]\n```", "```\nldr w0, [fp, #y]\nldr w1, [fp, #z]\nsub w0, w0, w1\nstr w0, [fp, #x]\n```", "```\nldr w0, [fp, #y]\nldr w1, [fp, #z]\nmul w0, w0, w1\nstr w0, [fp, #x]\n```", "```\nldr w0, [fp, #y]\nldr w1, [fp, #z]\nldr w2, [fp, #t]\nmul w1, w1, w2\nsub w0, w0, w1\nstr w0, [fp, #x]\n```", "```\nldr w0, [fp, #y]\nldr w1, [fp, #z]\nadd w0, w0, w1\nldr w1, [fp, #t]\nmul w0, w0, w1\nstr w0, [fp, #x]\n```", "```\nldr  w0, [fp, #x]\nldr  w1, [fp, #y]\nmul  w0, w0, w1\nldr  w1, [fp, #z]\nsdiv w0, w0, w1\nneg  w0, w0\nstr  w0, fp, #x]\n```", "```\nldr  w0, [fp, #y]\nldr  w1, [fp, #z]\ncmp  w0, w1\ncset w0, eq\nldr  w1, [fp, #t]\ncmp  w1, #0\ncset w1, ne\nand  w0, w0, w1\nstr  w0, [fp, #w]\n```", "```\nldr w0, [fp, #x]\nlsl w0, w0, #1\nstr w0, [fp, #x]\n```", "```\nldr w0, [fp, #y]\nlsl w1, w0, #2\nadd w0, w0, w1\nstr w0, [fp, #x]\n```", "```\nldr w0, [fp, #y]\nlsl w0, w0, #3\nstr w0, [fp, #x]\n```", "```\nldr x0, [fp, #x]\nlsr x0, #1\nstr x0, [fp, #x]\n```", "```\nldr x0, [fp, #y]\nlsr x0, #3\nstr x0, [fp, #x]\n```", "```\nldr x0, [fp, #z]\nldr x1, =6554    // 65,536/10\nmul x0, x0, x1\nlsr x0, x0, #16  // Divide by 65,535.\nstr x0, [fp, #x]\n```", "```\nldr  d0, [fp, #x]\nldr  d1, [fp, #y]\nfadd d0, d0, d1\nstr  d0, [fp, #x]\n```", "```\nldr  d0, [fp, #y]\nldr  d1, [fp, #z]\nfsub d0, d0, d1\nstr  d0, [fp, #x]\n```", "```\nldr  d0, [fp, #y]\nldr  d1, [fp, #z]\nfmul d0, d0, d1\nstr  d0, [fp, #x]\n```", "```\nldr  d0, [fp, #y]\nldr  d1, [fp, #z]\nldr  d2, [fp, #t]\nfmul d1, d1, d2\nfadd d0, d0, d1\nstr  d0, [fp, #x]\n```", "```\nldr  d0, [fp, #y]\nldr  d1, [fp, #z]\nfadd d0, d0, d1\nldr  d1, [fp, #t]\nfmul d0, d0, d1\nstr  d0, [fp, #x]\n```", "```\nldr  d0, [fp, #x]\nldr. d1, [fp, #y]\nfmul d0, d0, d1\nldr  d1, [fp, #z]\ndiv  d0, d0, d1\nfneg d0, d0\nstr  d0, [fp, #x]\n```", "```\nldr  d0, [fp, #x]\nldr  d1, [fp, #y]\nfcmp d0, d1\ncset x0, lo  // Less than, ordered\nstrb w0, [fp, #bb]\n```", "```\nldr  d0, [fp, #x]\nldr  d1, [fp, #y]\nfcmp d0, d1\ncset x0, ge  // Greater than or equal, ordered (HS is unordered)\nldr  d1, [fp, #z]\nfcmp d0, d1\ncset x1, lo // Less than, ordered (LT is unordered)\nand  x0, x1\nstrb w0, [fp, #bb]\n```", "```\nldr  w0, [fp, #x]\nldr  w1, [fp, #y]\ncmp  w0, w1\ncset w0, eq\nldr  w1, [fp, #z]\nldr  w2, [fp, #y]\ncmp  w0, w1\ncset w1, hi\norrs w0, w1\nbeq  skip\n\n     Do something.\nskip:\n```", "```\nldr  w0, [fp, #x]\nldr  w1, [fp, #y]\ncmp  w0, w1\ncset w0, ne\nldr  w1, [fp, #z]\nldr  w2, [fp, #t]\ncmp  w1, w2\ncset w1, lo\nands w0, w1\nbeq  doElse\n\n  `  then statements`\nb.al ifDone\n\ndoElse:\n    `else statements`\nifDone:\n```", "```\nldrsh w0, [fp, #x]\nldrsh w1, [fp, #y]\ncmp   w0, w1\nbne   skip\nldrsh w1, [fp, #z]\nldrsh w2, [fp, #t]\nbge   skip\n\n   Do something.\nskip:\n```", "```\nldrsh w0, [fp, #x]\nldrsh w1, [fp, #y]\ncmp   w0, w1\nbeq   doElse\nldrsh w1, [fp, #z]\nldrsh w2, [fp, #t]\ncmp   w1, w2\nbge   doElse\n\n then statements\nb.al  ifDone\n\ndoElse:\n    `else statements`\nifDone:\n```", "```\nldr  x0, [fp, #t]\ncmp  x0, #3\nbhi  default\nadr  x1, jmpTbl\nldr  x0, [x1, x0, lsl #3]\nadd  x0, x0, x1\nbr   x0\n\njmpTbl: .dword case0-jmpTbl, case1-jmpTbl, case2-jmpTbl, case3-jmpTbl\n```", "```\nldr  x0, [fp, #t]\ncmp  x0, #2\nblo  default\ncmp  x0, #6\nbhi  default\nadr  x1, jmpTbl\nldr  x0, [x1, x0, lsl #3]\nadd  x0, x0, x1\nbr   x0\n\njmpTbl: .dword case2-jmpTbl, default-jmpTbl, case4-jmpTbl\n        .dword case5-jmpTbl, case6-jmpTbl\n```", "```\nwhlLp:\n    ldr x0, [fp, #i]\n    ldr x1, [fp, #j]\n    cmp x0, x1\n    bgt endWhl\n\n    Code for loop body\n\n    b.al whlLp\nendWhl:\n```", "```\ndo...while:\n\nrptLp:\n    `Code for loop body`\n\n    ldr x0, [fp, #i]\n    ldr x1, [fp, #j]\n    cmp x0, x1\n    bne rptLp\n```", "```\n str  wzr [fp, #i]\nforLp:\n   ldr  x0, [fp, #i]\n   cmp  x0, #10\n   bge  forDone\n\n   Code for loop body\n\n   ldr  x0, [fp, #i]\n   add  x0, x0, #1\n   str  x0, [fp, #i]\n   b.al forLp\nforDone:\n```", "```\n ldp  x0, x1, [fp, #y]\n ldp  x2, x3, [fp, #z]\n adds x0, x0, x2\n adc  x1, x1, x3\n stp  x0, x1, [fp, #x]\n```", "```\n ldr  x0, [fp, #y]\n ldr  w1, [fp, #y+8]\n ldr  x2, [fp, #z]\n adds x0, x0, x2\n adc  w1, w1, wzr\n str  x0, [fp, #x]\n str  w1, [fp, #x+8]\n```", "```\n ldr  w0, [fp, #y]\n ldrh w1, [fp, #y+4]\n ldr  w2, [fp, #z]\n ldrh w3, [fp, #z+4]\n adds w0, w0, w2\n adc  w1, w1, w3\n str  w0, [fp, #x]\n strh w1, [fp, #x+4]\n```", "```\n ldp  x0, x1, [fp, #y]\n ldr  x2, [fp, #y+16]\n ldp  x3, x4, [fp, #z]\n ldr  x5, [fp, #z+16]\n subs x0, x0, x3\n sbc  x1, x1, x4\n sbc  x2, x2, x5\n stp  x0, x1, [fp, #x]\n str  x2, [fp, #x+16]\n```", "```\n ldr  x0, [fp, #y]\n ldr  w1, [fp, #y+8]\n ldp  x2, [fp, #z]\n ldr  w3, [fp, #z+8]\n subs x0, x0, x2\n sbc  w1, w1, w3\n str  x0, [fp, #x]\n str  w1, [fp, #x+8]\n```", "```\n ldr     x0, [fp, #y]\n            ldr     x1, [fp, #y + 8]\n            ldr     x2, [fp, #z]\n            ldr     x3, [fp, #z + 8]\n// X5:X4 = X0 * X2\n\n            mul     x4, x0, x2\n            umulh   x5, x0, x2\n\n// X6:X7 = X1 * X2, then X5 = X5 + X7 (and save carry for later):\n\n            mul     x7, x1, x2\n            umulh   x6, x1, x2\n            adds    x5, x5, x7\n\n// X7 = X0 * X3, then X5 = X5 + X7 + C (from earlier):\n\n mul     x7, x0, x3\n            adcs    x5, x5, x7\n            umulh   x7, x0, x3\n            adcs    x6, x6, x7  // Add in carry from adcs earlier.\n\n// X7:X2 = X3 * X1\n            mul     x2, x3, x1\n            umulh   x7, x3, x1\n\n            adc     x7, x7, xzr  // Add in C from previous adcs.\n            adds    x6, x6, x2   // X6 = X6 + X2\n            adc     x7, x7, xzr  // Add in carry from adds.\n\n// X7:X6:X5:X4 contains 256-bit result at this point, ignore overflow:\n            stp     x4, x5, [fp, #x]   // Save result to location.\n```", "```\n ldp x0, x1, [fp, #x]\n ldp x2, x3, [fp, #y]\n cmp x0, x2\n bne isFalse\n cmp x1, x3\n bne isFalse\n\n Code\n\nisFalse:\n```", "```\n ldp x0, x1, [fp, #x]\n ldp x2, x3, [fp, #y]\n cmp x1, x3\n bhi isFalse\n blo isTrue\n cmp x1, x3\n bhs isFalse\n\nisTrue:\n `Code`\n\nisFalse:\n```", "```\n ldp x0, x1, [fp, #x]\n ldp x2, x3, [fp, #y]\n cmp x1, x3\n blo isFalse\n bhi isTrue\n cmp x1, x3\n bls isFalse\n\nisTrue:\n `Code`\n\nisFalse:\n```", "```\n ldp x0, x1, [fp, #x]\n ldp x2, x3, [fp, #y]\n cmp x1, x3\n bne isTrue\n cmp x1, x3\n beq isFalse\n\nisTrue:\n `Code`\n\nisFalse:\n```", "```\n ldp  x0, x1, [fp, #x]\n subs x0, xzr, x0\n sbc  x1, xzr, x1\n stp  x0, x1, [fp, #x]\n```", "```\n ldp  x0, x1, [fp, #y]\n subs x0, xzr, x0\n sbc  x1, xzr, x1\n stp  x0, x1, [fp, #x]\n```", "```\n ldp x0, x1, [fp, #y]\n ldp x2, x3, [fp, #z]\n and x0, x0, x2\n and x1, x1, x3\n stp x0, x1, [fp, #x]\n```", "```\n ldp x0, x1, [fp, #y]\n ldp x2, x3, [fp, #z]\n orr x0, x0, x2\n orr x1, x1, x3\n stp x0, x1, [fp, #x]\n```", "```\n ldp x0, x1, [fp, #y]\n ldp x2, x3, [fp, #z]\n eor x0, x0, x2\n eor x1, x1, x3\n stp x0, x1, [fp, #x]\n```", "```\n ldp x0, x1, [fp, #y]\n not x0, x0\n not x1, x1\n stp x0, x1, [fp, #x]\n```", "```\n ldp  x0, x1, [fp, #y] // The easy way\n adds x0, x0, x0\n adc  x1, x1, x1\n stp  x0, x1, [fp, #x]\n```", "```\n ldp x0, x1, [fp, #y]  // The easy way\n ror x2, x1, #1\n and x2, x2, #1 << 63\n lsr x0, x0, #1\n orr x0, x0, x2\n lsr x1, x1, #1\n stp x0, x1, [fp, #x]\n```", "```\n ldp x0, x1, [fp, #y]  // The easy way\n ror x2, x1, #1\n and x2, x2, #1 << 63\n lsr x0, x0, #1\n orr x0, x0, x2\n asr x1, x1, #1\n stp x0, x1, [fp, #x]\n```", "```\n ldp  x0, x1, [fp, #x]  // The easy way\n adcs x0, x0, x0\n adcs x1, x1, x1\n stp  x0, x1, [fp, #x]\n```", "```\n // Assume \"input\" passed in X0.\n lea  x1, f        // Lookup table\n ldrb w0, [x1, x0] // Function result is left in W0.\n```", "```\n // Assume \"input\" passed in X0.\n lea  x1, f        // Lookup table\n ldrh w0, [x1, x0, uxtw #1] // Function result is left in W0.\n```", "```\n// Assume \"input\" passed in X0.\n lea  x1, f        // Lookup table\n ldrb w0, [x1, x0] // Function result is left in W0.\n```", "```\n // Assume \"input\" passed in X0.\n lea  x1, f        // Lookup table\n ldr w0, [x1, x0, uxtw #2] // Function result is left in W0.\n```", "```\n`target: dependencies`\n    commands\n```"]