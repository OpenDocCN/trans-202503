- en: Chapter 55. File Locking
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第55章. 文件锁定
- en: 'Previous chapters have covered various techniques that processes can use to
    synchronize their actions, including signals ([Chapter 20](ch20.html "Chapter 20. Signals:
    Fundamental Concepts") to [Chapter 22](ch22.html "Chapter 22. Signals: Advanced
    Features")) and semaphores ([Chapter 47](ch47.html "Chapter 47. System V Semaphores")
    and [Chapter 53](ch53.html "Chapter 53. POSIX Semaphores")). In this chapter,
    we look at further synchronization techniques designed specifically for use with
    files.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的章节已经介绍了进程可以用来同步其操作的各种技术，包括信号（[第20章](ch20.html "第20章. 信号：基本概念")至[第22章](ch22.html
    "第22章. 信号：高级特性")）和信号量（[第47章](ch47.html "第47章. System V信号量")和[第53章](ch53.html "第53章.
    POSIX信号量")）。本章将介绍更多专门用于文件的同步技术。
- en: Overview
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: 'A frequent application requirement is to read data from a file, make some change
    to that data, and then write it back to the file. As long as just one process
    at a time ever uses a file in this way, then there are no problems. However, problems
    can arise if multiple processes are simultaneously updating a file. Suppose, for
    example, that each process performs the following steps to update a file containing
    a sequence number:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的应用需求是从文件中读取数据，对数据进行一些修改，然后将其写回文件。只要每次只有一个进程以这种方式使用文件，就不会出现问题。然而，如果多个进程同时更新同一个文件，就可能会出现问题。假设例如，每个进程执行以下步骤来更新包含序列号的文件：
- en: Read the sequence number from the file.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从文件中读取序列号。
- en: Use the sequence number for some application-defined purpose.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将序列号用于某个应用定义的目的。
- en: Increment the sequence number and write it back to the file.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 增加序列号并将其写回文件。
- en: The problem here is that, in the absence of any synchronization technique, two
    processes could perform the above steps at the same time with (for example) the
    consequences shown in [Figure 55-1](ch55.html#two_processes_updating_a_file_at_the_sam
    "Figure 55-1. Two processes updating a file at the same time without synchronization")
    (here, we assume that the initial value of the sequence number is 1000).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是，在没有任何同步技术的情况下，两个进程可能同时执行上述步骤，结果如[图 55-1](ch55.html#two_processes_updating_a_file_at_the_sam
    "图 55-1. 两个进程在没有同步的情况下同时更新文件")所示（在这里，我们假设序列号的初始值为1000）。
- en: '![Two processes updating a file at the same time without synchronization](figs/web/55-1_FILELOCK-sync-problem.png.jpg)Figure 55-1. Two
    processes updating a file at the same time without synchronization'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '![两个进程在没有同步的情况下同时更新文件](figs/web/55-1_FILELOCK-sync-problem.png.jpg)图 55-1.
    两个进程在没有同步的情况下同时更新文件'
- en: 'The problem is clear: at the end of these steps, the file contains the value
    1001, when it should contain the value 1002\. (This is an example of a race condition.)
    To prevent such possibilities, we need some form of interprocess synchronization.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 问题很明显：在这些步骤结束时，文件中包含的值是1001，而它应该包含的是1002。（这就是竞态条件的一个例子。）为了防止这种情况的发生，我们需要某种形式的进程间同步。
- en: Although we could use (say) semaphores to perform the required synchronization,
    using file locks is usually preferable, because the kernel automatically associates
    locks with files.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用（例如）信号量来执行所需的同步操作，但通常更倾向于使用文件锁，因为内核会自动将锁与文件关联。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: '[Stevens & Rago, 2005] dates the first UNIX file locking implementation to
    1980, and notes that *fcntl()* locking, upon which we primarily focus in this
    chapter, appeared in System V Release 2 in 1984.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[Stevens & Rago, 2005]指出，UNIX文件锁的首次实现可追溯到1980年，并提到我们在本章中主要关注的*fcntl()*锁出现在1984年发布的System
    V版本2中。'
- en: 'In this chapter, we describe two different APIs for placing file locks:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了两种用于设置文件锁的不同API：
- en: '*flock()*, which places locks on entire files; and'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*flock()*，它会对整个文件加锁；以及'
- en: '*fcntl()*, which places locks on regions of a file.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*fcntl()*，它会对文件的某些区域加锁。'
- en: The *flock()* system call originated on BSD; *fcntl()* originated on System
    V.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*flock()*系统调用起源于BSD；*fcntl()*起源于System V。'
- en: 'The general method of using *flock()* and *fcntl()* is as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*flock()*和*fcntl()*的一般方法如下：
- en: Place a lock on the file.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对文件加锁。
- en: Perform file I/O.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行文件I/O。
- en: Unlock the file so that another process can lock it.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解锁文件，以便另一个进程可以加锁它。
- en: Although file locking is normally used in conjunction with file I/O, we can
    also use it as a more general synchronization technique. Cooperating processes
    can follow a convention that locking all or part of a file indicates access by
    a process to some shared resource other than the file itself (e.g., a shared memory
    region).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然文件锁定通常与文件I/O配合使用，但我们也可以将其作为一种更通用的同步技术。合作进程可以遵循一个约定，即锁定整个或部分文件表示进程访问除文件本身之外的某些共享资源（例如，共享内存区域）。
- en: Mixing locking and *stdio* functions
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 混合使用锁定和*stdio*函数
- en: 'Because of the user-space buffering performed by the *stdio* library, we should
    be cautious when using *stdio* functions with the locking techniques described
    in this chapter. The problem is that an input buffer might be filled before a
    lock is placed, or an output buffer may be flushed after a lock is removed. There
    are a few ways to avoid these problems:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*stdio*库执行的用户空间缓冲，我们在使用本章描述的锁定技术时应谨慎使用*stdio*函数。问题在于，在放置锁定之前，输入缓冲区可能已经被填充，或者在移除锁定之后，输出缓冲区可能会被刷新。可以通过几种方法避免这些问题：
- en: Perform file I/O using *read()* and *write()* (and related system calls) instead
    of the *stdio* library.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*read()*和*write()*（以及相关的系统调用）代替*stdio*库进行文件I/O操作。
- en: Flush the *stdio* stream immediately after placing a lock on the file, and flush
    it once more immediately before releasing the lock.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件上放置锁定后立即刷新*stdio*流，并在释放锁定之前再次刷新它。
- en: Perhaps at the cost of some efficiency, disable *stdio* buffering altogether
    using *setbuf()* (or similar).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能以牺牲一些效率为代价，通过使用*setbuf()*（或类似函数）完全禁用*stdio*缓冲区。
- en: Advisory and mandatory locking
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 建议性锁定和强制性锁定
- en: In the remainder of this chapter, we’ll distinguish locks as being either advisory
    or mandatory. By default, file locks are *advisory*. This means that a process
    can simply ignore a lock placed by another process. In order for an advisory locking
    scheme to be workable, each process accessing the file must cooperate, by placing
    a lock before performing file I/O. By contrast, a *mandatory* locking system forces
    a process performing I/O to abide by the locks held by other processes. We say
    more about this distinction in Section 55.4.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将区分建议性锁定和强制性锁定。默认情况下，文件锁定是*建议性*的。这意味着进程可以简单地忽略另一个进程放置的锁。为了使建议性锁定方案可行，每个访问文件的进程必须配合操作，在执行文件I/O之前放置锁。相反，*强制性*锁定系统强制执行进行I/O操作的进程遵守其他进程持有的锁。在55.4节中我们将进一步讨论这一区别。
- en: File Locking with *flock()*
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用*flock()*进行文件锁定
- en: Although *fcntl()* provides a superset of the functionality provided by *flock()*,
    we nevertheless describe *flock()* because it is still used in some applications,
    and because it differs from *fcntl()* in some of the semantics of inheritance
    and release of locks.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*fcntl()*提供了比*flock()*更多的功能，但我们仍然描述*flock()*，因为它在一些应用程序中仍被使用，并且它在锁的继承和释放语义上与*fcntl()*有所不同。
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Returns 0 on success, or -1 on error
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 返回0表示成功，返回-1表示出错
- en: The *flock()* system call places a single lock on an entire file. The file to
    be locked is specified via an open file descriptor passed in *fd*. The *operation*
    argument specifies one of the values `LOCK_SH`, `LOCK_EX`, or `LOCK_UN`, which
    are described in [Table 55-1](ch55.html#values_for_the_operation_argument_of_flo
    "Table 55-1. Values for the operation argument of flock()").
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*flock()*系统调用对整个文件施加一个锁。要锁定的文件通过传入*fd*的打开文件描述符来指定。*operation*参数指定`LOCK_SH`、`LOCK_EX`或`LOCK_UN`中的一个值，这些值在[表55-1](ch55.html#values_for_the_operation_argument_of_flo
    "表55-1. flock()操作参数的值")中进行了描述。'
- en: By default, *flock()* blocks if another process already holds an incompatible
    lock on a file. If we want to prevent this, we can OR (`|`) the value `LOCK_NB`
    into *operation*. In this case, if another process already holds an incompatible
    lock on the file, *flock()* doesn’t block, but instead returns -1, with *errno*
    set to `EWOULDBLOCK`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，*flock()*会阻塞，如果另一个进程已经持有不兼容的文件锁。若要防止这种情况发生，可以将`LOCK_NB`值通过OR（`|`）运算符添加到*operation*中。在这种情况下，如果另一个进程已经持有不兼容的锁，*flock()*不会阻塞，而是返回-1，并且*errno*会设置为`EWOULDBLOCK`。
- en: Table 55-1. Values for the *operation* argument of *flock()*
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 表55-1. *flock()*操作参数的值
- en: '| Value | Description |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 值 | 描述 |'
- en: '| --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `LOCK_SH` | Place a *shared* lock on the file referred to by *fd* |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `LOCK_SH` | 在由*fd*引用的文件上放置一个*共享*锁 |'
- en: '| `LOCK_EX` | Place an *exclusive* lock on the file referred to by *fd* |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `LOCK_EX` | 在由*fd*引用的文件上放置一个*独占*锁 |'
- en: '| `LOCK_UN` | Unlock the file referred to by *fd* |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `LOCK_UN` | 解锁由*fd*引用的文件 |'
- en: '| `LOCK_NB` | Make a nonblocking lock request |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `LOCK_NB` | 发起一个非阻塞锁请求 |'
- en: Any number of processes may simultaneously hold a shared lock on a file. However,
    only one process at a time can hold an exclusive lock on a file. (In other words,
    exclusive locks deny both exclusive and shared locks by other processes.) [Table 55-2](ch55.html#compatibility_of_flock_open_parenthesis
    "Table 55-2. Compatibility of flock() locking types") summarizes the compatibility
    rules for *flock()* locks. Here, we assume that process A is the first to place
    the lock, and the table indicates whether process B can then place a lock.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 任意数量的进程可以同时持有文件的共享锁。然而，文件一次只能有一个进程持有排他锁。（换句话说，排他锁会拒绝其他进程的排他锁和共享锁。）[表 55-2](ch55.html#compatibility_of_flock_open_parenthesis
    "表 55-2. *flock()* 锁类型的兼容性") 总结了 *flock()* 锁的兼容性规则。在此，我们假设进程 A 是第一个设置锁的，表格中显示进程
    B 是否可以设置锁。
- en: Table 55-2. Compatibility of *flock()* locking types
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 表 55-2. *flock()* 锁类型的兼容性
- en: '| Process A | Process B |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 进程 A | 进程 B |'
- en: '| --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `LOCK_SH` | `LOCK_EX` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `LOCK_SH` | `LOCK_EX` |'
- en: '| --- | --- |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `LOCK_SH` | Yes | No |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `LOCK_SH` | 是 | 否 |'
- en: '| `LOCK_EX` | No | No |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `LOCK_EX` | 否 | 否 |'
- en: A process can place a shared or exclusive lock regardless of the access mode
    (read, write, or read-write) of the file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 无论文件的访问模式（读取、写入或读写）如何，进程都可以设置共享锁或排他锁。
- en: An existing shared lock can be converted to an exclusive lock (and vice versa)
    by making another call to *flock()* specifying the appropriate value for *operation*.
    Converting a shared lock to an exclusive lock will block if another process holds
    a shared lock on the file, unless `LOCK_NB` was also specified.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 已存在的共享锁可以通过再次调用 *flock()* 并指定适当的 *operation* 值来转换为排他锁（反之亦然）。如果其他进程对文件持有共享锁，转换共享锁为排他锁时将会阻塞，除非指定了
    `LOCK_NB`。
- en: A lock conversion is *not* guaranteed to be atomic. During conversion, the existing
    lock is first removed, and then a new lock is established. Between these two steps,
    another process’s pending request for an incompatible lock may be granted. If
    this occurs, then the conversion will block, or, if `LOCK_NB` was specified, the
    conversion will fail and the process will lose its original lock. (This behavior
    occurred in the original BSD *flock()* implementation and also occurs on many
    other UNIX implementations.)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 锁的转换*不*保证是原子的。在转换过程中，现有的锁首先会被移除，然后再建立一个新的锁。在这两个步骤之间，另一个进程对不兼容锁的挂起请求可能会被授予。如果发生这种情况，转换将会阻塞，或者，如果指定了
    `LOCK_NB`，转换将失败，进程将失去原来的锁。（这种行为发生在原始的BSD *flock()* 实现中，也发生在许多其他UNIX实现中。）
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although it is not part of SUSv3, *flock()* appears on most UNIX implementations.
    Some implementations require the inclusion of either `<fcntl.h>` or `<sys/fcntl.h>`
    instead of `<sys/file.h>`. Because *flock()* originates on BSD, the locks that
    it places are sometimes known as *BSD file locks*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它不是SUSv3的一部分，*flock()* 在大多数UNIX实现中都可以使用。一些实现要求包含 `<fcntl.h>` 或 `<sys/fcntl.h>`，而不是
    `<sys/file.h>`。因为 *flock()* 起源于BSD，它所设置的锁有时被称为 *BSD文件锁*。
- en: '[Example 55-1](ch55.html#using_flock_open_parenthesis_close_paren "Example 55-1. Using
    flock()") demonstrates the use of *flock()*. This program locks a file, sleeps
    for a specified number of seconds, and then unlocks the file. The program takes
    up to three command-line arguments. The first of these is the file to lock. The
    second specifies the lock type (shared or exclusive) and whether or not to include
    the `LOCK_NB` (nonblocking) flag. The third argument specifies the number of seconds
    to sleep between acquiring and releasing the lock; this argument is optional and
    defaults to 10 seconds.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 55-1](ch55.html#using_flock_open_parenthesis_close_paren "示例 55-1. 使用 *flock()*)
    演示了 *flock()* 的使用。该程序锁定一个文件，休眠指定的秒数，然后解锁文件。程序最多可以接受三个命令行参数。第一个参数是要锁定的文件。第二个参数指定锁类型（共享锁或排他锁）以及是否包括
    `LOCK_NB`（非阻塞）标志。第三个参数指定获取和释放锁之间休眠的秒数；此参数是可选的，默认值为 10 秒。'
- en: Example 55-1. Using *flock()*
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 55-1. 使用 *flock()*
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using the program in [Example 55-1](ch55.html#using_flock_open_parenthesis_close_paren
    "Example 55-1. Using flock()"), we can conduct a number of experiments to explore
    the behavior of *flock()*. Some examples are shown in the following shell session.
    We begin by creating a file, and then start an instance of our program that sits
    in the background and holds a shared lock for 60 seconds:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[示例55-1](ch55.html#using_flock_open_parenthesis_close_paren "示例55-1. 使用 flock()")中的程序，我们可以进行一些实验来探索*flock()*的行为。以下的shell会话展示了几个示例。我们首先创建一个文件，然后启动我们的程序实例，该实例在后台运行并保持共享锁60秒：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we start another instance of the program that successfully requests a
    shared lock and then releases it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们启动另一个程序实例，该实例成功请求了共享锁并随后释放它：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, when we start another instance of the program that makes a nonblocking
    requests for an exclusive lock, the request immediately fails:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们启动程序的另一个实例，该实例发出非阻塞请求以获取独占锁时，请求会立即失败：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When we start another instance of the program that makes a blocking request
    for an exclusive lock, the program blocks. When the background process that was
    holding a shared lock for 60 seconds releases its lock, the blocked request is
    granted:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动另一个实例的程序，该程序发出阻塞请求以获取独占锁时，程序会被阻塞。当在后台运行的进程释放其持有的共享锁（持续60秒）时，阻塞的请求会被授予：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Semantics of Lock Inheritance and Release
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锁继承和释放的语义
- en: 'As shown in [Table 55-1](ch55.html#values_for_the_operation_argument_of_flo
    "Table 55-1. Values for the operation argument of flock()"), we can release a
    file lock via an *flock()* call that specifies *operation* as `LOCK_UN`. In addition,
    locks are automatically released when the corresponding file descriptor is closed.
    However, the story is more complicated than this. A file lock obtained via *flock()*
    is associated with the open file description ([Relationship Between File Descriptors
    and Open Files](ch05.html#relationship_between_file_descriptors_an "Relationship
    Between File Descriptors and Open Files")), rather than the file descriptor or
    the file (i-node) itself. This means that when a file descriptor is duplicated
    (via *dup()*, *dup2()*, or an *fcntl()* `F_DUPFD` operation), the new file descriptor
    refers to the same file lock. For example, if we have obtained a lock on the file
    referred to by *fd*, then the following code (which omits error checking) releases
    that lock:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如[表55-1](ch55.html#values_for_the_operation_argument_of_flo "表55-1. flock()操作参数的值")所示，我们可以通过指定*operation*为`LOCK_UN`的*flock()*调用释放文件锁。此外，当相应的文件描述符关闭时，锁会自动释放。然而，情况比这更复杂。通过*flock()*获取的文件锁是与打开文件描述（[文件描述符与打开文件之间的关系](ch05.html#relationship_between_file_descriptors_an
    "文件描述符与打开文件之间的关系")）相关联的，而不是与文件描述符或文件（i-node）本身相关联。这意味着，当文件描述符被复制（通过*dup()*、*dup2()*或*fcntl()*的`F_DUPFD`操作）时，新的文件描述符会指向相同的文件锁。例如，如果我们已经在由*fd*引用的文件上获取了锁，那么以下代码（省略了错误检查）将释放该锁：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If we have acquired a lock via a particular file descriptor, and we create one
    or more duplicates of that descriptor, then—if we don’t explicitly perform an
    unlock operation--the lock is released only when all of the duplicate descriptors
    have been closed.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过特定的文件描述符获取了一个锁，并且我们创建了一个或多个该描述符的副本，那么——如果我们没有显式地执行解锁操作——只有当所有副本描述符都被关闭时，锁才会被释放。
- en: 'However, if we use *open()* to obtain a second file descriptor (and associated
    open file description) referring to the same file, this second descriptor is treated
    independently by *flock()*. For example, a process executing the following code
    will block on the second *flock()* call:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用*open()*获取一个指向同一文件的第二个文件描述符（及相关的打开文件描述），那么这个第二个描述符会被*flock()*独立处理。例如，执行以下代码的进程将在第二次*flock()*调用时被阻塞：
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Thus, a process can lock itself out of a file using *flock()*. As we’ll see
    later, this can’t happen with record locks obtained by *fcntl()*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，进程可以通过*flock()*将自己锁定在文件之外。正如我们稍后会看到的，使用*fcntl()*获取的记录锁不能发生这种情况。
- en: 'When we create a child process using *fork()*, that child obtains duplicates
    of its parent’s file descriptors, and, as with descriptors duplicated via *dup()*
    and so on, these descriptors refer to the same open file descriptions and thus
    to the same locks. For example, the following code causes a child to remove a
    parent’s lock:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用*fork()*创建子进程时，子进程会获得父进程文件描述符的副本，正如通过*dup()*等复制的描述符一样，这些描述符指向相同的打开文件描述，因此也指向相同的锁。例如，以下代码会导致子进程删除父进程的锁：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'These semantics can sometimes be usefully exploited to (atomically) transfer
    a file lock from a parent process to a child process: after the *fork()*, the
    parent closes its file descriptor, and the lock is under sole control of the child
    process. As we’ll see later, this isn’t possible using record locks obtained by
    *fcntl()*.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些语义有时可以被有效利用来（原子地）将文件锁从父进程转移到子进程：在*fork()*之后，父进程关闭其文件描述符，锁定便完全由子进程控制。正如我们稍后将看到的，这种做法无法通过*fcntl()*获取的记录锁来实现。
- en: Locks created by *flock()* are preserved across an *exec()* (unless the close-on-exec
    flag was set for the file descriptor and that file descriptor was the last one
    referencing the underlying open file description).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由*flock()*创建的锁在*exec()*中会被保留（除非文件描述符设置了关闭执行标志，并且该文件描述符是最后一个引用底层打开文件描述符的）。
- en: The Linux semantics described above conform to the classical BSD implementation
    of *flock()*. On some UNIX implementations, *flock()* is implemented using *fcntl()*,
    and we’ll see later that the inheritance and release semantics of *fcntl()* locks
    differ from those of *flock()* locks. Because the interactions between locks created
    by *flock()* and *fcntl()* are undefined, an application should use only one of
    these locking methods on a file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 上述Linux语义符合经典的BSD实现的*flock()*。在某些UNIX实现中，*flock()*是通过*fcntl()*实现的，稍后我们将看到，*fcntl()*锁的继承和释放语义与*flock()*锁有所不同。由于由*flock()*和*fcntl()*创建的锁之间的交互未定义，应用程序应当仅在文件上使用这两种锁方法中的一种。
- en: Limitations of *flock()*
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '*flock()*的限制'
- en: 'Placing locks with *flock()* suffers from a number of limitations:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*flock()*加锁有若干限制：
- en: Only whole files can be locked. Such coarse locking limits the potential for
    concurrency among cooperating processes. If, for example, we have multiple processes,
    each of which would like to simultaneously access different parts of the same
    file, then locking via *flock()* would needlessly prevent these processes from
    operating concurrently.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能对整个文件加锁。这种粗粒度的加锁限制了合作进程之间的并发性。例如，如果我们有多个进程，每个进程都希望同时访问同一个文件的不同部分，那么使用*flock()*加锁将不必要地阻止这些进程并发操作。
- en: We can place only advisory locks with *flock()*.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们只能使用*flock()*设置建议性锁。
- en: Many NFS implementations don’t recognize locks granted by *flock()*.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多NFS实现不识别*flock()*授予的锁。
- en: All of these limitations are addressed by the locking scheme implemented by
    *fcntl()*, which we describe in the next section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些限制都可以通过*fcntl()*实现的加锁方案来解决，我们将在下一节中描述该方案。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Historically, the Linux NFS server did not support *flock()* locks. Since kernel
    2.6.12, the Linux NFS server supports *flock()* locks by implementing them as
    an *fcntl()* lock on the entire file. This can cause some strange effects when
    mixing BSD locks on the server and BSD locks on the client: the clients usually
    won’t see the server’s locks, and vice versa.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，Linux NFS 服务器不支持*flock()*锁。从内核版本2.6.12开始，Linux NFS 服务器通过将其实现为对整个文件的*fcntl()*锁来支持*flock()*锁。这会导致一些奇怪的效果，当服务器上和客户端上混合使用BSD锁时：客户端通常无法看到服务器的锁，反之亦然。
- en: Record Locking with *fcntl()*
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用*fcntl()*进行记录加锁
- en: 'Using *fcntl()* ([File Control Operations: *fcntl()*](ch05.html#file_control_operations_colon_fcntl_open
    "File Control Operations: fcntl()")), we can place a lock on any part of a file,
    ranging from a single byte to the entire file. This form of file locking is usually
    called *record locking*. However, this term is a misnomer, because files on the
    UNIX system are byte sequences, with no concept of record boundaries. Any notion
    of records within a file is defined purely within an application.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*fcntl()*（[文件控制操作：*fcntl()*](ch05.html#file_control_operations_colon_fcntl_open
    "文件控制操作：fcntl()")），我们可以对文件的任何部分加锁，从单个字节到整个文件。 这种文件加锁方式通常称为*记录加锁*。然而，这个术语并不准确，因为
    UNIX 系统中的文件是字节序列，并没有记录边界的概念。文件中的任何记录概念完全是在应用程序内部定义的。
- en: Typically, *fcntl()* is used to lock byte ranges corresponding to the application-defined
    record boundaries within the file; hence the origin of the term *record locking*.
    The terms *byte range*, *file region*, and *file segment* are less commonly used,
    but more accurate, descriptions of this type of lock. (Because this is the only
    kind of locking specified in the original POSIX.1 standard and in SUSv3, it is
    sometimes also called POSIX file locking.)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，*fcntl()* 用于锁定文件中与应用程序定义的记录边界相对应的字节范围；因此，产生了*记录锁*这一术语。术语*字节范围*、*文件区域*和*文件段*是较少使用但更为准确的对这种类型锁的描述。（因为这是原始
    POSIX.1 标准和 SUSv3 中唯一规定的锁定类型，它有时也被称为 POSIX 文件锁定。）
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: SUSv3 requires record locking to be supported for regular files, and permits
    it to be supported for other file types. Although it generally makes sense to
    apply record locks only to regular files (since, for most other file types, it
    isn’t meaningful to talk about byte ranges for the data contained in the file),
    on Linux, it is possible to apply a record lock to any type of file descriptor.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 要求常规文件必须支持记录锁，并允许对其他文件类型支持记录锁。尽管通常只有对常规文件应用记录锁才有意义（因为对于大多数其他文件类型，讨论文件中数据的字节范围没有意义），但在
    Linux 上，可以对任何类型的文件描述符应用记录锁。
- en: '[Figure 55-2](ch55.html#using_record_locks_to_synchronize_access "Figure 55-2. Using
    record locks to synchronize access to the same region of a file") shows how record
    locking might be used to synchronize access by two processes to the same region
    of a file. (In this diagram, we assume that all lock requests are blocking, so
    that they will wait if a lock is held by another process.)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 55-2](ch55.html#using_record_locks_to_synchronize_access "图 55-2. 使用记录锁来同步访问文件的相同区域")
    显示了如何使用记录锁来同步两个进程对文件相同区域的访问。（在该图中，我们假设所有的锁请求都是阻塞的，因此如果锁被另一个进程占用，进程将等待。）'
- en: 'The general form of the *fcntl()* call used to create or remove a file lock
    is as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建或移除文件锁的 *fcntl()* 调用的一般形式如下：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The *fd* argument is an open file descriptor referring to the file on which
    we wish to place a lock.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*fd* 参数是一个打开的文件描述符，指向我们希望在其上设置锁的文件。'
- en: Before discussing the *cmd* argument, we first describe the *flock* structure.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论 *cmd* 参数之前，我们首先描述 *flock* 结构。
- en: The *flock* structure
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*flock* 结构'
- en: 'The *flock* structure defines the lock that we wish to acquire or remove. It
    is defined as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '*flock* 结构定义了我们希望获取或移除的锁。其定义如下：'
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The *l_type* field indicates the type of lock we want to place. It is specified
    as one of the values in [Table 55-3](ch55.html#lock_types_for_fcntl_open_parenthesis_cl
    "Table 55-3. Lock types for fcntl() locking").
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*l_type* 字段指示我们希望设置的锁的类型。它被指定为 [表 55-3](ch55.html#lock_types_for_fcntl_open_parenthesis_cl
    "表 55-3. fcntl() 锁定类型") 中的一个值。'
- en: 'Semantically, read (`F_RDLCK`) and write (`F_WRLCK`) locks correspond to the
    shared and exclusive locks applied by *flock()*, and they follow the same compatibility
    rules ([Table 55-2](ch55.html#compatibility_of_flock_open_parenthesis "Table 55-2. Compatibility
    of flock() locking types")): any number of processes can hold read locks on a
    file region, but only one process can hold a write lock, and that lock excludes
    read and write locks by other processes. Specifying *l_type* as `F_UNLCK` is analogous
    to the *flock()* `LOCK_UN` operation.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在语义上，读锁（`F_RDLCK`）和写锁（`F_WRLCK`）与 *flock()* 应用的共享锁和排他锁相对应，并遵循相同的兼容性规则（[表 55-2](ch55.html#compatibility_of_flock_open_parenthesis
    "表 55-2. flock() 锁类型的兼容性")）：多个进程可以同时持有文件区域的读锁，但只有一个进程可以持有写锁，并且该锁会排除其他进程的读锁和写锁。将
    *l_type* 指定为 `F_UNLCK` 类似于 *flock()* 的 `LOCK_UN` 操作。
- en: Table 55-3. Lock types for *fcntl()* locking
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 表 55-3. *fcntl()* 锁定的锁类型
- en: '| Lock type | Description |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 锁类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `F_RDLCK` | Place a read lock |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `F_RDLCK` | 设置读锁 |'
- en: '| `F_WRLCK` | Place a write lock |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `F_WRLCK` | 设置写锁 |'
- en: '| `F_UNLCK` | Remove an existing lock |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `F_UNLCK` | 移除现有的锁 |'
- en: '![Using record locks to synchronize access to the same region of a file](figs/web/55-2_FILELOCK-record-locking-overview.png.jpg)Figure 55-2. Using
    record locks to synchronize access to the same region of a file'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![使用记录锁来同步访问文件的相同区域](figs/web/55-2_FILELOCK-record-locking-overview.png.jpg)
    图 55-2. 使用记录锁来同步访问文件的相同区域'
- en: In order to place a read lock on a file, the file must be open for reading.
    Similarly, to place a write lock, the file must be open for writing. To place
    both types of locks, we open the file read-write (`O_RDWR`). Attempting to place
    a lock that is incompatible with the file access mode results in the error `EBADF`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在文件上放置读取锁，文件必须以读取模式打开。类似地，为了放置写入锁，文件必须以写入模式打开。要放置两种类型的锁，我们需要以读写模式打开文件（`O_RDWR`）。尝试放置与文件访问模式不兼容的锁会导致错误
    `EBADF`。
- en: 'The *l_whence*, *l_start*, and *l_len* fields together specify the range of
    bytes to be locked. The first two of these fields are analogous to the *whence*
    and *offset* arguments to *lseek()* ([Changing the File Offset: *lseek()*](ch04.html#changing_the_file_offset_colon_lseek_ope
    "Changing the File Offset: lseek()")). The *l_start* field specifies an offset
    within the file that is interpreted with respect to one of the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*l_whence*、*l_start* 和 *l_len* 字段共同指定了要锁定的字节范围。这两个字段的前两个与 *lseek()* 的 *whence*
    和 *offset* 参数类似（[更改文件偏移：*lseek()*](ch04.html#changing_the_file_offset_colon_lseek_ope
    "Changing the File Offset: lseek()")）。*l_start* 字段指定一个文件中的偏移量，该偏移量相对于以下之一进行解释：'
- en: the start of the file, if *l_whence* is `SEEK_SET`;
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *l_whence* 为 `SEEK_SET`，则是文件的开始。
- en: the current file offset, if *l_whence* is `SEEK_CUR`; or
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *l_whence* 为 `SEEK_CUR`，则为当前文件偏移量；或者
- en: the end of the file, if *l_whence* is `SEEK_END`.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *l_whence* 为 `SEEK_END`，则是文件的结尾。
- en: In the last two cases, *l_start* can be a negative number, as long as the resulting
    file position doesn’t lie before the start of the file (byte 0).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后两种情况下，*l_start* 可以是负数，只要结果文件位置不在文件的起始位置之前（字节 0）。
- en: The *l_len* field contains an integer specifying the number of bytes to lock,
    starting from the position defined by *l_whence* and *l_start*. It is possible
    to lock nonexistent bytes past the end of the file, but it is not possible to
    lock bytes before the start of the file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*l_len* 字段包含一个整数，指定从 *l_whence* 和 *l_start* 定义的位置开始锁定的字节数。可以锁定文件末尾不存在的字节，但无法锁定文件起始位置之前的字节。'
- en: Since kernel 2.4.21, Linux allows a negative value to be supplied in *l_len*.
    This is a request to lock the *l_len* bytes preceding the position specified by
    *l_whence* and *l_start* (i.e., bytes in the range *(l_start - abs(l_len))* through
    to *(l_start - 1)*). SUSv3 permits, but doesn’t require, this feature. Several
    other UNIX implementations also provide it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核 2.4.21 开始，Linux 允许在 *l_len* 中提供负值。这是一个请求，要求锁定从 *l_whence* 和 *l_start* 指定的位置之前的
    *l_len* 字节（即范围为 *(l_start - abs(l_len))* 到 *(l_start - 1)* 的字节）。SUSv3 允许，但不强制要求使用此功能。其他一些
    UNIX 实现也提供此功能。
- en: In general, applications should lock the minimum range of bytes necessary. This
    allows greater concurrency for other processes simultaneously trying to lock different
    regions of the same file.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，应用程序应锁定必要的最小字节范围。这可以让其他进程同时尝试锁定同一文件的不同区域时，提供更大的并发性。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The term *minimum range* needs qualification in some circumstances. Mixing record
    locks and calls to *mmap()* can have unpleasant consequences on network file systems
    such as NFS and CIFS. The problem occurs because *mmap()* maps files in units
    of the system page size. If a file lock is page-aligned, then all is well, since
    the lock will cover the entire region corresponding to a dirty page. However,
    if the lock is not page-aligned, then there is a race condition--the kernel may
    write into the area that is not covered by the lock if any part of the mapped
    page has been modified.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，*最小范围* 这一术语需要进一步说明。混合使用记录锁和对 *mmap()* 的调用可能会对网络文件系统（如 NFS 和 CIFS）产生不良后果。问题出在
    *mmap()* 将文件映射为系统页面大小的单位。如果文件锁是页面对齐的，那么一切正常，因为锁会覆盖与脏页相对应的整个区域。然而，如果锁没有页面对齐，就会发生竞争条件——如果映射页面的任何部分已被修改，内核可能会写入未被锁定的区域。
- en: Specifying 0 in *l_len* has the special meaning “lock all bytes from the point
    specified by *l_start* and *l_whence* through to the end of the file, no matter
    how large the file grows.” This is convenient if we don’t know in advance how
    many bytes we are going to add to a file. To lock the entire file, we can specify
    *l_whence* as `SEEK_SET` and both *l_start* and *l_len* as 0.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *l_len* 中指定 0 具有特殊含义，即“锁定从 *l_start* 和 *l_whence* 指定的点到文件末尾的所有字节，无论文件增长多大”。如果我们事先不知道将要向文件添加多少字节，这将非常方便。要锁定整个文件，我们可以将
    *l_whence* 指定为 `SEEK_SET`，并将 *l_start* 和 *l_len* 都指定为 0。
- en: The *cmd* argument
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*cmd* 参数'
- en: 'When working with file locks, three possible values may be specified for the
    *cmd* argument of *fcntl()*. The first two are used for acquiring and releasing
    locks:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理文件锁时，*fcntl()*的*cmd*参数可以指定三种可能的值。前两个用于获取和释放锁：
- en: '`F_SETLK`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`F_SETLK`'
- en: Acquire (*l_type* is `F_RDLCK` or `F_WRLCK`) or release (*l_type* is `F_UNLCK`)
    a lock on the bytes specified by *flockstr*. If an incompatible lock is held by
    another process on any part of the region to be locked, *fcntl()* fails with the
    error `EAGAIN`. On some UNIX implementations, *fcntl()* fails with the error `EACCES`
    in this case. SUSv3 permits either possibility, and a portable application should
    test for both values.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 获取（*l_type*为`F_RDLCK`或`F_WRLCK`）或释放（*l_type*为`F_UNLCK`）*flockstr*指定的字节上的锁。如果另一个进程在要锁定的区域的任何部分上持有不兼容的锁，*fcntl()*将失败并返回错误`EAGAIN`。在某些UNIX实现中，*fcntl()*在这种情况下会返回错误`EACCES`。SUSv3允许这两种情况，便携式应用程序应该同时测试这两个值。
- en: '`F_SETLKW`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`F_SETLKW`'
- en: This is the same as `F_SETLK`, except that if another process holds an incompatible
    lock on any part of the region to be locked, then the call blocks until the lock
    can be granted. If we are handling signals and have not specified `SA_RESTART`
    ([Interruption and Restarting of System Calls](ch21.html#interruption_and_restarting_of_system_ca
    "Interruption and Restarting of System Calls")), then an `F_SETLKW` operation
    may be interrupted (i.e., fail with the error `EINTR`). We can take advantage
    of this behavior to use *alarm()* or *setitimer()* to set a timeout on the lock
    request.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`F_SETLK`相同，只是如果另一个进程在要锁定的区域的任何部分上持有不兼容的锁，则该调用会阻塞，直到可以授予锁。如果我们正在处理信号并且没有指定`SA_RESTART`（[系统调用的中断与重启](ch21.html#interruption_and_restarting_of_system_ca
    "Interruption and Restarting of System Calls")），那么`F_SETLKW`操作可能会被中断（即，因错误`EINTR`失败）。我们可以利用这种行为，使用*alarm()*或*setitimer()*来为锁请求设置超时。
- en: Note that *fcntl()* locks either the entire region specified or nothing at all.
    There is no notion of locking just those bytes of the requested region that are
    currently unlocked.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，*fcntl()*锁定的是指定的整个区域或根本不锁定。没有锁定当前解锁的请求区域字节的概念。
- en: 'The remaining *fcntl()* operation is used to determine whether we can place
    a lock on a given region:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的*fcntl()*操作用于确定我们是否可以在给定区域放置锁：
- en: '`F_GETLK`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`F_GETLK`'
- en: Check if it would be possible to acquire the lock specified in *flockstr*, but
    don’t actually acquire it. The *l_type* field must be `F_RDLCK` or `F_WRLCK`.
    The *flockstr* structure is treated as a value-result argument; on return, it
    contains information informing us whether or not the specified lock could be placed.
    If the lock would be permitted (i.e., no incompatible locks exist on the specified
    file region), then `F_UNLCK` is returned in the *l_type* field, and the remaining
    fields are left unchanged. If one or more incompatible locks exist on the region,
    then *flockstr* returns information about *one* of those locks (it is indeterminate
    which), including its type (*l_type*), range of bytes (*l_start* and *l_len*;
    *l_whence* is always returned as `SEEK_SET`), and the process ID of the process
    holding the lock (*l_pid*).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 检查是否可以获取在*flockstr*中指定的锁，但不要实际获取它。*l_type*字段必须是`F_RDLCK`或`F_WRLCK`。*flockstr*结构被视为一个值-结果参数；返回时，它包含有关是否可以放置指定锁的信息。如果允许放置锁（即，指定文件区域上没有不兼容的锁），则在*l_type*字段中返回`F_UNLCK`，其余字段保持不变。如果区域上存在一个或多个不兼容的锁，则*flockstr*返回关于*其中一个*锁的信息（无法确定是哪一个），包括其类型（*l_type*）、字节范围（*l_start*和*l_len*；*l_whence*始终返回`SEEK_SET`），以及持有该锁的进程的进程ID（*l_pid*）。
- en: Note that there are potential race conditions when combining the use of `F_GETLK`
    with a subsequent `F_SETLK` or `F_SETLKW`. By the time we perform the latter operation,
    the information returned by `F_GETLK` may already be out of date. Thus, `F_GETLK`
    is less useful than it first appears. Even if `F_GETLK` says that it is possible
    to place a lock, we must still be prepared for an error return from `F_SETLK`
    or for `F_SETLKW` to block.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当将`F_GETLK`与随后的`F_SETLK`或`F_SETLKW`结合使用时，可能会出现竞争条件。到我们执行后续操作时，`F_GETLK`返回的信息可能已经过时。因此，`F_GETLK`的实际用途不如它看起来那么有用。即使`F_GETLK`表示可以放置锁，我们仍然需要为`F_SETLK`返回错误或`F_SETLKW`阻塞做好准备。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The GNU C library also implements the function *lockf()*, which is just a simplified
    interface layered on top of *fcntl()*. (SUSv3 specifies *lockf()*, but doesn’t
    specify the relationship between *lockf()* and *fcntl()*. However, most UNIX systems
    implement *lockf()* on top of *fcntl()*.) A call of the form *lockf(fd, operation,
    size)* is equivalent to a call to *fcntl()* with *l_whence* set to `SEEK_CUR`,
    *l_start* set to 0, and *l_len* set to *size*; that is, *lockf()* locks a sequence
    of bytes starting at the current file offset. The *operation* argument to *lockf()*
    is analogous to the *cmd* argument to *fcntl()*, but different constants are used
    for acquiring, releasing, and testing for the presence of locks. The *lockf()*
    function places only exclusive (i.e., write) locks. See the *lockf(3)* manual
    page for further details.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: GNU C 库还实现了*lockf()*函数，它只是一个简化接口，位于*fcntl()*之上。（SUSv3指定了*lockf()*，但没有指定*lockf()*和*fcntl()*之间的关系。然而，大多数UNIX系统将*lockf()*实现为基于*fcntl()*的功能。）形式为*lockf(fd,
    operation, size)*的调用等同于调用*fcntl()*，其中* l_whence*设置为`SEEK_CUR`，*l_start*设置为0，*l_len*设置为*size*；也就是说，*lockf()*会锁定从当前文件偏移量开始的一段字节。*lockf()*的*operation*参数类似于*fcntl()*的*cmd*参数，但使用不同的常量来获取、释放和测试锁的存在。*lockf()*函数只放置独占（即写）锁。有关详细信息，请参阅*lockf(3)*手册页。
- en: Details of lock acquisition and release
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 锁的获取和释放的详细信息
- en: 'Note the following points regarding the acquisition and release of locks created
    with *fcntl()*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用*fcntl()*获取和释放锁的以下几点需要注意：
- en: Unlocking a file region always immediately succeeds. It is not an error to unlock
    a region on which we don’t currently hold a lock.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解锁文件区域总是立即成功。如果我们当前没有持有锁，解锁该区域也不会视为错误。
- en: At any time, a process can hold just one type of lock on a particular region
    of a file. Placing a new lock on a region we have already locked either results
    in no change (if the lock type is the same as the existing lock) or atomically
    converts the existing lock to the new mode. In the latter case, when converting
    a read lock to a write lock, we need to be prepared for the possibility that the
    call will yield an error (`F_SETLK`) or block (`F_SETLKW`). (This differs from
    *flock()*, whose lock conversions are not atomic.)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何时候，一个进程只能对文件的特定区域持有一种类型的锁。对一个我们已经加锁的区域再次加锁，要么没有变化（如果锁的类型与现有锁相同），要么会原子地将现有锁转换为新模式。在后者的情况下，当将读锁转换为写锁时，我们需要做好准备，可能会遇到错误（`F_SETLK`）或阻塞（`F_SETLKW`）。
    （这与*flock()*不同，*flock()*的锁转换不是原子的。）
- en: A process can never lock itself out of a file region, even when placing locks
    via multiple file descriptors referring to the same file. (This contrasts with
    *flock()*, and we say more on this point in [Lock Limits and Performance](ch55.html#lock_limits_and_performance
    "Lock Limits and Performance").)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使通过多个指向同一文件的文件描述符加锁，进程也永远不会将自己锁定在文件区域之外。（这与*flock()*不同，关于这一点我们会在[锁定限制和性能](ch55.html#lock_limits_and_performance
    "锁定限制和性能")中进一步讨论。）
- en: 'Placing a lock of a different mode in the middle of a lock we already hold
    results in three locks: two smaller locks in the previous mode are created on
    either side of the new lock (see [Figure 55-3](ch55.html#splitting_of_an_existing_read_lock_by_a
    "Figure 55-3. Splitting of an existing read lock by a write lock by the same process")).
    Conversely, acquiring a second lock adjacent to or overlapping an existing lock
    in the same mode results in a single coalesced lock covering the combined area
    of the two locks. Other permutations are possible. For example, unlocking a region
    in the middle of a larger existing lock leaves two smaller locked regions on either
    side of the unlocked region. If a new lock overlaps an existing lock with a different
    mode, then the existing lock is shrunk, because the overlapping bytes are incorporated
    into the new lock.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们已经持有的锁中间放置不同模式的锁会导致三个锁：在新锁的两侧会创建两个较小的锁，且锁的模式与之前的锁相同（参见[图 55-3](ch55.html#splitting_of_an_existing_read_lock_by_a
    "图 55-3：同一进程将现有的读锁拆分为写锁")）。相反，获取与现有锁相邻或重叠的第二个相同模式的锁会导致一个合并的锁，覆盖两个锁的合并区域。其他的排列方式也是可能的。例如，解锁较大现有锁中间的区域会在解锁区域的两侧留下两个较小的锁定区域。如果一个新锁与现有的不同模式的锁重叠，那么现有的锁会缩小，因为重叠的字节被纳入到新锁中。
- en: Closing a file descriptor has some unusual semantics with respect to file region
    locks. We describe these semantics in [Lock Limits and Performance](ch55.html#lock_limits_and_performance
    "Lock Limits and Performance").
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭文件描述符在文件区域锁方面有一些不寻常的语义。我们在[锁定限制和性能](ch55.html#lock_limits_and_performance
    "锁定限制和性能")中描述了这些语义。
- en: '![Splitting of an existing read lock by a write lock by the same process](figs/web/55-3_FILELOCK-lock-splitting-scale90.png.jpg)Figure 55-3. Splitting
    of an existing read lock by a write lock by the same process'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![同一进程通过写锁拆分现有的读锁](figs/web/55-3_FILELOCK-lock-splitting-scale90.png.jpg)图55-3.
    同一进程通过写锁拆分现有的读锁'
- en: Deadlock
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 死锁
- en: When using `F_SETLKW`, we need to be aware of the type of scenario illustrated
    in [Figure 55-4](ch55.html#deadlock_when_two_processes_deny_each_ot "Figure 55-4. Deadlock
    when two processes deny each other’s lock requests"). In this scenario, each process’s
    second lock request is blocked by a lock held by the other process. Such a scenario
    is referred to as a *deadlock*. If unchecked by the kernel, this would leave both
    processes blocked forever. To prevent this possibility, the kernel checks each
    new lock request made via `F_SETLKW` to see if it would result in a deadlock situation.
    If it would, then the kernel selects one of the blocked processes and causes its
    *fcntl()* call to unblock and fail with the error `EDEADLK`. (On Linux, the process
    making the most recent *fcntl()* call is selected, but this is not required by
    SUSv3, and may not hold true on future versions of Linux or on other UNIX implementations.
    Any process using `F_SETLKW` must be prepared to handle an `EDEADLK` error.)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`F_SETLKW`时，我们需要注意[图55-4](ch55.html#deadlock_when_two_processes_deny_each_ot
    "图55-4. 两个进程互相拒绝对方锁请求时的死锁")中展示的场景类型。在这个场景中，每个进程的第二个锁请求被另一个进程持有的锁所阻塞。这样的场景被称为*死锁*。如果内核没有加以检查，这将导致两个进程永远被阻塞。为了防止这种情况发生，内核会检查每一个通过`F_SETLKW`发出的新的锁请求，看看它是否会导致死锁。如果会，内核会选择其中一个被阻塞的进程，并使它的*fcntl()*调用解除阻塞，并返回`EDEADLK`错误。（在Linux中，会选择最近发出*fcntl()*调用的进程，但这并非SUSv3的要求，未来版本的Linux或其他UNIX实现上可能并不如此。任何使用`F_SETLKW`的进程都必须准备好处理`EDEADLK`错误。）
- en: '![Deadlock when two processes deny each other’s lock requests](figs/web/55-4_FILELOCK-deadlock.png.jpg)Figure 55-4. Deadlock
    when two processes deny each other’s lock requests'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![两个进程互相拒绝对方锁请求时的死锁](figs/web/55-4_FILELOCK-deadlock.png.jpg)图55-4. 两个进程互相拒绝对方锁请求时的死锁'
- en: Deadlock situations are detected even when placing locks on multiple different
    files, as are circular deadlocks involving multiple processes. (By *circular deadlock*,
    we mean, for example, process A waiting to acquire a lock on a region locked by
    process B, process B waiting on a lock held by process C, and process C waiting
    on a lock held by process A.)
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是在多个不同文件上放置锁时，也能检测到死锁情况，圆形死锁也能被检测到，圆形死锁涉及多个进程。（*圆形死锁*指的是，例如，进程A等待获取进程B持有的区域锁，进程B等待获取进程C持有的锁，进程C等待获取进程A持有的锁。）
- en: 'Example: An Interactive Locking Program'
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：一个交互式锁定程序
- en: 'The program shown in [Example 55-2](ch55.html#experimenting_with_record_locking
    "Example 55-2. Experimenting with record locking") allows us to interactively
    experiment with record locking. This program takes a single command-line argument:
    the name of a file on which we wish to place locks. Using this program, we can
    verify many of our previous statements regarding the operation of record locking.
    The program is designed to be used interactively and accepts commands of this
    form:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例55-2](ch55.html#experimenting_with_record_locking "示例55-2. 实验记录锁定")中所示的程序允许我们交互式地实验记录锁定。该程序接受一个命令行参数：我们希望在其上放置锁的文件名。通过这个程序，我们可以验证许多关于记录锁定操作的先前陈述。该程序设计为交互式使用，接受如下形式的命令：
- en: '[PRE11]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For *cmd*, we can specify *g* to perform an `F_GETLK`, *s* to perform an `F_SETLK`,
    or *w* to perform an `F_SETLKW`. The remaining arguments are used to initialize
    the *flock* structure passed to *fcntl()*. The *lock* argument specifies the value
    for the *l_type* field and is *r* for `F_RDLCK`, *w* for `F_WRLCK`, or *u* for
    `F_UNLCK`. The *start* and *length* arguments are integers specifying the values
    for the *l_start* and *l_len* fields. Finally, the optional *whence* argument
    specifies the value for the *l_whence* field, and may be *s* for `SEEK_SET` (the
    default), *c* for `SEEK_CUR`, or *e* for `SEEK_END`. (For an explanation of why
    we cast the *l_start* and *l_len* fields to *long long* in the *printf()* call
    in [Example 55-2](ch55.html#experimenting_with_record_locking "Example 55-2. Experimenting
    with record locking"), see [I/O on Large Files](ch05.html#i_solidus_o_on_large_files
    "I/O on Large Files").)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*cmd*，我们可以指定*g*来执行`F_GETLK`，*s*来执行`F_SETLK`，或*w*来执行`F_SETLKW`。其余参数用于初始化传递给*fcntl()*的*flock*结构。*lock*参数指定*l_type*字段的值，*r*表示`F_RDLCK`，*w*表示`F_WRLCK`，或*u*表示`F_UNLCK`。*start*和*length*参数是整数，用于指定*l_start*和*l_len*字段的值。最后，可选的*whence*参数指定*l_whence*字段的值，可以是*s*表示`SEEK_SET`（默认值），*c*表示`SEEK_CUR`，或*e*表示`SEEK_END`。（有关为什么我们在[示例 55-2](ch55.html#experimenting_with_record_locking
    "Example 55-2. Experimenting with record locking")中的*printf()*调用中将*l_start*和*l_len*字段强制转换为*long
    long*，请参阅[大文件I/O](ch05.html#i_solidus_o_on_large_files "I/O on Large Files")。）
- en: Example 55-2. Experimenting with record locking
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 55-2. 实验记录锁定
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the following shell session logs, we demonstrate the use of the program in
    [Example 55-2](ch55.html#experimenting_with_record_locking "Example 55-2. Experimenting
    with record locking") by running two instances to place locks on the same 100-byte
    file *(tfile)*. [Figure 55-5](ch55.html#state_of_granted_and_queued_lock_request
    "Figure 55-5. State of granted and queued lock requests while running i_fcntl_locking.c")
    shows the state of granted and queued lock requests at various points during this
    shell session log, as noted in the commentary below.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下的shell会话日志中，我们通过运行两个实例来展示如何使用[示例 55-2](ch55.html#experimenting_with_record_locking
    "Example 55-2. Experimenting with record locking")中的程序，对同一个100字节的文件*(tfile)*加锁。[图 55-5](ch55.html#state_of_granted_and_queued_lock_request
    "Figure 55-5. State of granted and queued lock requests while running i_fcntl_locking.c")展示了在这段shell会话日志中的不同时间点上，已授予和排队的锁请求的状态，如下面的评论所述。
- en: 'We start a first instance (process A) of the program in [Example 55-2](ch55.html#experimenting_with_record_locking
    "Example 55-2. Experimenting with record locking"), placing a read lock on bytes
    0 to 39 of the file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[示例 55-2](ch55.html#experimenting_with_record_locking "Example 55-2. Experimenting
    with record locking")中启动第一个实例（进程A），对文件的第0到第39字节加上读锁：
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then we start a second instance of the program (process B), placing a read
    lock on a bytes 70 through to the end of the file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们启动程序的第二个实例（进程B），对文件的第70字节到文件末尾加读锁：
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: At this point, things appear as shown in part *a* of [Figure 55-5](ch55.html#state_of_granted_and_queued_lock_request
    "Figure 55-5. State of granted and queued lock requests while running i_fcntl_locking.c"),
    where process A (process ID 790) and process B (process ID 800) hold locks on
    different parts of the file.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点，事情如[图 55-5](ch55.html#state_of_granted_and_queued_lock_request "Figure 55-5. State
    of granted and queued lock requests while running i_fcntl_locking.c")中*a*部分所示，进程A（进程ID
    790）和进程B（进程ID 800）分别在文件的不同部分持有锁。
- en: Now we return to process A, where we try to place a write lock on the entire
    file. We first employ `F_GETLK` to test whether the lock can be placed and are
    informed that there is a conflicting lock. Then we try placing the lock with `F_SETLK`,
    which also fails. Finally, we try placing the lock with `F_SETLKW`, which blocks.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们回到进程A，尝试对整个文件加写锁。我们首先使用`F_GETLK`测试是否可以加锁，系统提示有冲突的锁。然后我们尝试用`F_SETLK`加锁，但也失败了。最后，我们尝试用`F_SETLKW`加锁，这时程序被阻塞。
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: At this point, things appear as shown in part *b* of [Figure 55-5](ch55.html#state_of_granted_and_queued_lock_request
    "Figure 55-5. State of granted and queued lock requests while running i_fcntl_locking.c"),
    where process A and process B each hold a lock on different parts of the file,
    and process A has a queued lock request on the whole file.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点，事情如[图 55-5](ch55.html#state_of_granted_and_queued_lock_request "Figure 55-5. State
    of granted and queued lock requests while running i_fcntl_locking.c")中*b*部分所示，进程A和进程B分别在文件的不同部分持有锁，且进程A对整个文件有一个排队的锁请求。
- en: We continue in process B, by trying to place a write lock on the entire file.
    We first test whether the lock can be placed using `F_GETLK`, which informs us
    that there is a conflicting lock. We then try placing the lock using `F_SETLKW`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在进程 B 中继续，通过尝试对整个文件设置写锁。我们首先测试是否可以使用 `F_GETLK` 设置锁，这会通知我们存在冲突锁。然后，我们尝试使用 `F_SETLKW`
    设置锁。
- en: '[PRE16]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Part *c* of [Figure 55-5](ch55.html#state_of_granted_and_queued_lock_request
    "Figure 55-5. State of granted and queued lock requests while running i_fcntl_locking.c")
    shows what happened when process B made a blocking request to place a write lock
    on the entire file: a deadlock. At this point, the kernel selected one of the
    lock requests to fail--in this case, the request by process B, which then receives
    the `EDEADLK` error from its *fcntl()* call.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 55-5](ch55.html#state_of_granted_and_queued_lock_request "图 55-5. 运行 i_fcntl_locking.c
    时已授予和排队的锁请求状态") 的 *c* 部分展示了当进程 B 发出阻塞请求以在整个文件上设置写锁时发生的情况：死锁。在此时，内核选择了一个锁请求失败——在此情况下，是进程
    B 的请求，然后它从 *fcntl()* 调用中收到 `EDEADLK` 错误。'
- en: 'We continue in process B, by removing all of its locks on the file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在进程 B 中继续，通过移除它在文件上的所有锁：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we see from the last line of output, this allowed process A’s blocked lock
    request to be granted.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从输出的最后一行所看到的，这使得进程 A 的被阻塞锁请求得以授予。
- en: It is important to realize that even though process B’s deadlocked request was
    canceled, it still held its other lock, and so process A’s queued lock request
    remained blocked. Process A’s lock request is granted only when process B removes
    its other lock, bringing about the situation shown in part *d* of [Figure 55-5](ch55.html#state_of_granted_and_queued_lock_request
    "Figure 55-5. State of granted and queued lock requests while running i_fcntl_locking.c").
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 需要意识到的是，即使进程 B 的死锁请求被取消，它仍然持有其他锁，因此进程 A 的排队锁请求仍然被阻塞。只有当进程 B 移除其其他锁时，进程 A 的锁请求才会被授予，从而产生
    [图 55-5](ch55.html#state_of_granted_and_queued_lock_request "图 55-5. 运行 i_fcntl_locking.c
    时已授予和排队的锁请求状态") *d* 部分所示的情况。
- en: '![State of granted and queued lock requests while running i_fcntl_locking.c](figs/web/55-5_FILELOCK-fcntl-example.png)Figure 55-5. State
    of granted and queued lock requests while running `i_fcntl_locking.c`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '![运行 i_fcntl_locking.c 时已授予和排队的锁请求状态](figs/web/55-5_FILELOCK-fcntl-example.png)图
    55-5. 运行 `i_fcntl_locking.c` 时已授予和排队的锁请求状态'
- en: 'Example: A Library of Locking Functions'
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示例：锁定函数库
- en: '[Example 55-3](ch55.html#file_region_locking_functions "Example 55-3. File
    region locking functions") provides a set of locking functions that we can use
    in other programs. These functions are as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 55-3](ch55.html#file_region_locking_functions "示例 55-3. 文件区域锁定函数")提供了一组锁定函数，我们可以在其他程序中使用。这些函数如下：'
- en: The *lockRegion()* function uses `F_SETLK` to place a lock on the open file
    referred to by the file descriptor *fd*. The *type* argument specifies the lock
    type (`F_RDLCK` or `F_WRLCK`). The *whence*, *start*, and *len* arguments specify
    the range of bytes to lock. These arguments provide the values for the similarly
    named fields of the *flockstr* structure that is used to place the lock.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*lockRegion()* 函数使用 `F_SETLK` 在由文件描述符 *fd* 引用的打开文件上设置锁。*type* 参数指定锁的类型（`F_RDLCK`
    或 `F_WRLCK`）。*whence*、*start* 和 *len* 参数指定要锁定的字节范围。这些参数提供了用于设置锁的 *flockstr* 结构中同名字段的值。'
- en: The *lockRegionWait()* function is like *lockRegion()*, but makes a blocking
    lock request; that is, it uses `F_SETLKW`, rather than `F_SETLK`.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*lockRegionWait()* 函数类似于 *lockRegion()*，但它发出一个阻塞锁请求；也就是说，它使用 `F_SETLKW`，而不是
    `F_SETLK`。'
- en: The *regionIsLocked()* function tests whether a lock can be placed on a file.
    The arguments of this function are as for *lockRegion()*. This function returns
    0 (false) if no process holds a lock that conflicts with the lock specified in
    the call. If one of more processes hold conflicting locks, then this function
    returns a nonzero value (i.e., true)--the process ID of one the processes holding
    a conflicting lock.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*regionIsLocked()* 函数测试是否可以在文件上设置锁。该函数的参数与 *lockRegion()* 相同。如果没有进程持有与调用中指定的锁冲突的锁，则此函数返回
    0（假）。如果一个或多个进程持有冲突的锁，则此函数返回非零值（即真）——冲突锁的进程 ID。'
- en: Example 55-3. File region locking functions
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 55-3. 文件区域锁定函数
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Lock Limits and Performance
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锁定限制与性能
- en: SUSv3 allows an implementation to place fixed, system-wide upper limits on the
    number of record locks that can be acquired. When this limit is reached, *fcntl()*
    fails with the error `ENOLCK`. Linux doesn’t set a fixed upper limit on the number
    of record locks that may be acquired; we are merely limited by availability of
    memory. (Many other UNIX implementations are similar.)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 允许实现设置系统范围内的固定上限，限制可获得的记录锁数量。当达到此限制时，*fcntl()* 会因错误 `ENOLCK` 而失败。Linux
    并未设置固定的记录锁数量上限；我们仅受限于内存的可用性。（许多其他 UNIX 实现也类似。）
- en: 'How quickly can record locks be acquired and released? There is no fixed answer
    to this question, since the speed of these operations is a function of the kernel
    data structure used to maintain record locks and the location of a particular
    lock within that data structure. We look at this structure in a moment, but first
    we consider some requirements that influence its design:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 记录锁的获取和释放速度有多快？这个问题没有固定答案，因为这些操作的速度取决于用来维护记录锁的内核数据结构及特定锁在该数据结构中的位置。我们稍后将研究这个结构，但首先我们考虑一些影响其设计的要求：
- en: The kernel needs to be able to merge a new lock with any existing locks (held
    by the same process) of the same mode that may lie on either side of the new lock.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核需要能够将新锁与任何现有的相同模式的锁（由同一进程持有）合并，这些锁可能位于新锁的两侧。
- en: A new lock may completely replace one or more existing locks held by the calling
    process. The kernel needs to be able to easily locate all of these locks.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新锁可能完全替代调用进程持有的一个或多个现有锁。内核需要能够轻松地定位所有这些锁。
- en: When creating a new lock with a different mode in the middle of an existing
    lock, the job of splitting the existing lock ([Figure 55-3](ch55.html#splitting_of_an_existing_read_lock_by_a
    "Figure 55-3. Splitting of an existing read lock by a write lock by the same process"))
    should be simple.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在现有锁的中间创建一个不同模式的新锁时，拆分现有锁的工作（[图 55-3](ch55.html#splitting_of_an_existing_read_lock_by_a
    "图 55-3. 同一进程通过写锁拆分现有的读锁")）应该是简单的。
- en: The kernel data structure used to maintain information about locks is designed
    to satisfy these requirements. Each open file has an associated linked list of
    locks held against that file. Locks within the list are ordered, first by process
    ID, and then by starting offset. An example of such a list is shown in [Figure 55-6](ch55.html#example_of_a_record_lock_list_for_a_sing
    "Figure 55-6. Example of a record lock list for a single file").
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 用于维护锁信息的内核数据结构旨在满足这些要求。每个打开的文件都有一个与之关联的锁链表。链表中的锁按进程 ID 排序，其次按起始偏移量排序。此类列表的示例如
    [图 55-6](ch55.html#example_of_a_record_lock_list_for_a_sing "图 55-6. 单个文件的记录锁列表示例")
    中所示。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: The kernel also maintains *flock()* locks and file leases in the linked list
    of locks associated with an open file. (We briefly describe file leases when discussing
    the `/proc/locks` file in Section 55.5.) However, these types of locks are typically
    far fewer in number and therefore less likely to impact performance, so we ignore
    them in our discussion.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 内核还在与打开文件关联的锁链表中维护 *flock()* 锁和文件租约。（我们将在讨论 `/proc/locks` 文件时简要描述文件租约，见第 55.5
    节。）然而，这些类型的锁通常数量较少，因此不太可能影响性能，因此在本讨论中我们将忽略它们。
- en: '![Example of a record lock list for a single file](figs/web/55-6_FILELOCK-lock-list.png)Figure 55-6. Example
    of a record lock list for a single file'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![单个文件的记录锁列表示例](figs/web/55-6_FILELOCK-lock-list.png)图 55-6. 单个文件的记录锁列表示例'
- en: Whenever a new lock is added to this data structure, the kernel must check for
    conflicts with any existing lock on the file. This search is carried out sequentially,
    starting at the head of the list.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 每当向此数据结构中添加一个新锁时，内核必须检查是否与文件上的任何现有锁发生冲突。此搜索是顺序进行的，从列表头部开始。
- en: Assuming a large number of locks distributed randomly among many processes,
    we can say that the time required to add or remove a lock increases roughly linearly
    with the number of locks already held on the file.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有大量锁分布在多个进程之间，我们可以说，添加或删除一个锁所需的时间大致与文件上已持有的锁数量成线性增长关系。
- en: Semantics of Lock Inheritance and Release
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锁继承和释放的语义
- en: 'The semantics of *fcntl()* record lock inheritance and release differ substantially
    from those for locks created using *flock()*. Note the following points:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*fcntl()* 记录锁的继承和释放语义与使用 *flock()* 创建的锁有显著不同。请注意以下几点：'
- en: Record locks are not inherited across a *fork()* by a child process. This contrasts
    with *flock()*, where the child inherits a reference to the *same* lock and can
    release this lock, with the consequence that the parent also loses the lock.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录锁不会在子进程通过 *fork()* 继承。这与 *flock()* 不同，在 *flock()* 中，子进程继承对 *相同* 锁的引用，并可以释放此锁，导致父进程也失去该锁。
- en: Record locks are preserved across an *exec()*. (However, note the effect of
    the close-on-exec flag, described below.)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录锁在 *exec()* 过程中会被保留。（不过请注意下面描述的 close-on-exec 标志的效果。）
- en: All of the threads in a process share the same set of record locks.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程中的所有线程共享同一组记录锁。
- en: 'Record locks are associated with both a process and an i-node (refer to [Relationship
    Between File Descriptors and Open Files](ch05.html#relationship_between_file_descriptors_an
    "Relationship Between File Descriptors and Open Files")). An unsurprising consequence
    of this association is that when a process terminates, all of its record locks
    are released. Less expected is that whenever a process closes a file descriptor,
    *all* locks held by the process on the corresponding file are released, regardless
    of the file descriptor(s) through which the locks were obtained. For example,
    in the following code, the *close(fd2)* call releases the lock held by the calling
    process on `testfile`, even though the lock was obtained via the file descriptor
    *fd1*:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录锁与进程和 i-node 都相关联（参见 [文件描述符与打开文件之间的关系](ch05.html#relationship_between_file_descriptors_an
    "Relationship Between File Descriptors and Open Files")）。这种关联的一个不足为奇的结果是，当进程终止时，所有记录锁都会被释放。更意外的是，每当进程关闭一个文件描述符时，*所有*该进程在相应文件上持有的锁都会被释放，无论这些锁是通过哪些文件描述符获得的。例如，在以下代码中，*close(fd2)*
    调用会释放调用进程在 `testfile` 上持有的锁，即使该锁是通过文件描述符 *fd1* 获得的：
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The semantics described in the last point apply no matter how the various descriptors
    referring to the same file were obtained and no matter how the descriptor is closed.
    For example, *dup()*, *dup2()*, and *fcntl()* can all be used to obtain duplicates
    of an open file descriptor. And, as well as performing an explicit *close()*,
    a descriptor can be closed by an *exec()* call if the close-on-exec flag was set,
    or via a *dup2()* call, which closes its second file descriptor argument if that
    descriptor is already open.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一条中描述的语义适用于无论是如何获得的指向同一文件的不同描述符，以及无论描述符是如何被关闭的。例如，*dup()*、*dup2()* 和 *fcntl()*
    都可以用于获得一个打开文件描述符的副本。此外，除了显式调用 *close()* 外，如果设置了 close-on-exec 标志，描述符还可以通过 *exec()*
    调用关闭，或者通过 *dup2()* 调用关闭第二个文件描述符参数（如果该描述符已经打开）。
- en: The semantics of *fcntl()* lock inheritance and release are an architectural
    blemish. For example, they make the use of record locks from library packages
    problematic, since a library function can’t prevent the possibility that its caller
    will close a file descriptor referring to a locked file and thus remove a lock
    obtained by the library code. An alternative implementation scheme would have
    been to associate a lock with a file descriptor rather than with an i-node. However,
    the current semantics are the historical and now standardized behavior of record
    locks. Unfortunately, these semantics greatly limit the utility of *fcntl()* locking.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*fcntl()* 锁的继承和释放语义是一个架构上的缺陷。例如，它们使得从库包中使用记录锁变得问题重重，因为库函数无法防止其调用者关闭一个指向已锁定文件的文件描述符，从而移除库代码获得的锁。一个可行的替代实现方案是将锁与文件描述符关联，而不是与
    i-node 关联。然而，当前的语义是记录锁的历史行为，并且已经成为标准化的行为。不幸的是，这些语义大大限制了 *fcntl()* 锁的实用性。'
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: With *flock()*, a lock is associated only with an open file description, and
    remains in effect until either any process holding a reference to the lock explicitly
    releases the lock or all file descriptors referring to the open file description
    are closed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *flock()* 时，锁仅与一个打开的文件描述符关联，并且一直有效，直到持有锁的任何进程显式释放该锁，或者所有指向该打开文件描述符的文件描述符被关闭。
- en: Lock Starvation and Priority of Queued Lock Requests
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 锁饥饿和排队锁请求的优先级
- en: When multiple processes must wait in order to place a lock on a currently locked
    region, a couple of questions arise.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个进程必须等待才能对当前被锁定的区域加锁时，出现了几个问题。
- en: Can a process waiting to place a write lock be starved by a series of processes
    placing read locks on the same region? On Linux (as on many other UNIX implementations),
    a series of read locks can indeed starve a blocked write lock, possibly indefinitely.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一个等待写锁的进程是否会被一系列在同一区域上放置读取锁的进程饿死？在Linux（与许多其他UNIX实现一样）上，一系列的读取锁确实可能会饿死一个被阻塞的写锁，可能是无限期的。
- en: 'When two or more processes are waiting to place a lock, are there any rules
    that determine which process obtains the lock when it becomes available? For example,
    are lock requests satisfied in FIFO order? And do the rules depend on the types
    of locks being requested by each process (i.e., does a process requesting a read
    lock have priority over one requesting a write lock or vice versa, or neither)?
    On Linux, the rules are as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或多个进程等待获取锁时，是否有规则决定哪个进程在锁可用时获取锁？例如，锁请求是否按照FIFO顺序满足？规则是否取决于每个进程请求的锁类型（即，要求读取锁的进程是否优先于请求写入锁的进程，反之亦然，或者两者都不是）？在Linux上，规则如下：
- en: The order in which queued lock requests are granted is indeterminate. If multiple
    processes are waiting to place locks, then the order in which they are satisfied
    depends on how the processes are scheduled.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排队的锁请求的满足顺序是不可预测的。如果多个进程在等待获取锁，那么它们满足的顺序取决于进程调度方式。
- en: Writers don’t have priority over readers, and vice versa.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写入者并不优先于读取者，反之亦然。
- en: Such statements don’t necessarily hold true on other systems. On some UNIX implementations,
    lock requests are served in FIFO order, and readers have priority over writers.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的声明不一定适用于其他系统。在一些UNIX实现中，锁请求是按照FIFO顺序提供的，且读取器优先于写入器。
- en: Mandatory Locking
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制锁定
- en: 'The kinds of locks we have described so far are *advisory*. This means that
    a process is free to ignore the use of *fcntl()* (or *flock()*) and simply perform
    I/O on the file. The kernel doesn’t prevent this. When using advisory locking,
    it is up to the application designer to:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止描述的锁定种类是*建议性的*。这意味着进程可以自由地忽略使用*fcntl()*（或*flock()*)并直接对文件执行I/O操作。内核不会阻止这种行为。在使用建议性锁定时，由应用程序设计人员来：
- en: set appropriate ownership (or group ownership) and permissions for the file,
    so as to prevent noncooperating process from performing file I/O; and
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为文件设置适当的所有权（或组所有权）和权限，以防止不合作的进程执行文件I/O；
- en: ensure that the processes composing the application cooperate by obtaining the
    appropriate lock on the file before performing I/O.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保构成应用程序的进程通过在执行I/O操作之前获取适当的文件锁来协作。
- en: Linux, like many other UNIX implementations, also allows *fcntl()* record locks
    to be *mandatory*. This means that every file I/O operation is checked to see
    whether it is compatible with any locks held by other processes on the region
    of the file on which I/O is being performed.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Linux与许多其他UNIX实现一样，也允许*fcntl()*记录锁定为*强制性*。这意味着每个文件I/O操作都会检查是否与其他进程在执行I/O的文件区域上持有的任何锁兼容。
- en: Note
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Advisory mode locking is sometimes referred to as *discretionary locking*, while
    mandatory locking is sometimes referred to as *enforcement-mode locking*. SUSv3
    doesn’t specify mandatory locking, but it is available (with some variation in
    the details) on most modern UNIX implementations.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 建议模式锁定有时被称为*任意锁定*，而强制锁定有时被称为*强制模式锁定*。SUSv3没有指定强制锁定，但在大多数现代UNIX实现中它是可用的（尽管在细节上有所不同）。
- en: 'In order to use mandatory locking on Linux, we must enable it on the file system
    containing the files we wish to lock and on each file to be locked. We enable
    mandatory locking on a file system by mounting it with the (Linux-specific) *-o
    mand* option:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Linux上使用强制锁定，我们必须在包含要锁定文件的文件系统上启用它，并在每个要锁定的文件上启用强制锁定。我们通过使用(Linux特有的)*-o
    mand*选项挂载文件系统来启用强制锁定：
- en: '[PRE20]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'From a program, we can achieve the same result by specifying the `MS_MANDLOCK`
    flag when calling *mount(2)* ([Mounting a File System: *mount()*](ch14.html#mounting_a_file_system_colon_mount_open
    "Mounting a File System: mount()")).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '从程序中，我们可以通过在调用*mount(2)*时指定`MS_MANDLOCK`标志来实现相同的结果（[挂载文件系统：*mount()*](ch14.html#mounting_a_file_system_colon_mount_open
    "Mounting a File System: mount()")）。'
- en: 'We can check whether a mounted file system has mandatory locking enabled by
    looking at the output of the *mount(8)* command with no options:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看不带选项的*mount(8)*命令的输出，检查挂载的文件系统是否启用了强制锁定：
- en: '[PRE21]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Mandatory locking is enabled on a file by the combination of having the set-group-ID
    permission bit turned on and the group-execute permission turned off. This combination
    of permission bits was otherwise meaningless and unused in earlier UNIX implementations.
    In this way, later UNIX systems added mandatory locking without needing to change
    existing programs or add new system calls. From the shell, we can enable mandatory
    locking on a file as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 强制锁定通过启用设置组ID权限位并关闭组执行权限的组合来启用。这个权限位组合在早期的UNIX实现中是没有意义且未被使用的。通过这种方式，后来的UNIX系统在不需要更改现有程序或添加新系统调用的情况下就实现了强制锁定。从Shell中，我们可以按如下方式在文件上启用强制锁定：
- en: '[PRE22]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'From a program, we can enable mandatory locking for a file by setting permissions
    appropriately using *chmod()* or *fchmod()* ([Changing File Permissions: *chmod()*
    and *fchmod()*](ch15.html#changing_file_permissions_colon_chmod_op "Changing File
    Permissions: chmod() and fchmod()")).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，我们可以通过使用*chmod()*或*fchmod()*适当设置权限来启用文件的强制锁定（[更改文件权限：*chmod()*和*fchmod()*](ch15.html#changing_file_permissions_colon_chmod_op
    "更改文件权限：chmod()和fchmod()")）。
- en: 'When displaying permissions for a file whose permission bits are set for mandatory
    locking, *ls(1)* displays an *S* in the group-execute permission column:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当显示具有强制锁定权限位的文件的权限时，*ls(1)*会在组执行权限栏中显示一个*S*：
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Mandatory locking is supported for all native Linux and UNIX file systems, but
    may not be supported on some network file systems or on non-UNIX file systems.
    For example, Microsoft’s VFAT file system has no set-group-ID permission bit,
    so mandatory locking can’t be used on VFAT file systems.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 强制锁定支持所有本地的Linux和UNIX文件系统，但可能不支持某些网络文件系统或非UNIX文件系统。例如，Microsoft的VFAT文件系统没有设置组ID权限位，因此无法在VFAT文件系统上使用强制锁定。
- en: Effect of mandatory locking on file I/O operations
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 强制锁定对文件I/O操作的影响
- en: If mandatory locking is enabled for a file, what happens when a system call
    that performs data transfer (e.g., *read()* or *write()*) encounters a lock conflict
    (i.e., an attempt is made to write to a region that is currently read or write
    locked, or to read from a region that is currently write locked)? The answer depends
    on whether the file has been opened in blocking or nonblocking mode. If the file
    was opened in blocking mode, the system call blocks. If the file was opened with
    the `O_NONBLOCK` flag, the system call immediately fails with the error `EAGAIN`.
    Similar rules apply for *truncate()* and *ftruncate()*, if the bytes they are
    attempting to add or remove from the file overlap a region currently locked (for
    reading or writing) by another process.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件启用了强制锁定，当执行数据传输的系统调用（例如，*read()*或*write()*）遇到锁定冲突时会发生什么情况（即，尝试写入当前被读或写锁定的区域，或尝试从当前被写锁定的区域读取）？答案取决于文件是否以阻塞模式或非阻塞模式打开。如果文件是以阻塞模式打开的，系统调用将会阻塞。如果文件是以`O_NONBLOCK`标志打开的，系统调用会立即失败，并返回错误`EAGAIN`。对于*truncate()*和*ftruncate()*，如果它们尝试添加或删除的字节与当前被另一个进程锁定（用于读取或写入）的区域重叠，也适用类似规则。
- en: 'If we have opened a file in blocking mode (i.e., `O_NONBLOCK` is not specified
    in the *open()* call), then I/O system calls can be involved in deadlock situations.
    Consider the example shown in [Figure 55-7](ch55.html#deadlock_when_mandatory_locking_is_in_fo
    "Figure 55-7. Deadlock when mandatory locking is in force"), involving two processes
    that open the same file for blocking I/O, obtain write locks on different parts
    of the file, and then each attempt to write to the region locked by the other
    process. The kernel resolves this situation in the same way that deadlock between
    two *fcntl()* calls is resolved ([The *flock* structure](ch55.html#the_flock_structure-id1
    "The flock structure")): it selects one of the processes involved in the deadlock
    and causes its *write()* system call to fail with the error `EDEADLK`.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以阻塞模式打开文件（即，*open()*调用中未指定`O_NONBLOCK`），那么I/O系统调用可能会导致死锁情况。考虑[图55-7](ch55.html#deadlock_when_mandatory_locking_is_in_fo
    "图55-7. 强制锁定导致的死锁")中的示例，涉及两个进程，它们以阻塞I/O模式打开同一个文件，并在文件的不同部分获取写锁，然后每个进程尝试写入另一个进程锁定的区域。内核以与两个*fcntl()*调用之间死锁解决方式相同的方式解决这种情况（[*flock*结构](ch55.html#the_flock_structure-id1
    "flock结构")）：它选择其中一个死锁进程，并导致其*write()*系统调用失败，错误为`EDEADLK`。
- en: '![Deadlock when mandatory locking is in force](figs/web/55-7_FILELOCK-deadlock-mand.png.jpg)Figure 55-7. Deadlock
    when mandatory locking is in force'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '![强制锁定导致的死锁](figs/web/55-7_FILELOCK-deadlock-mand.png.jpg)图55-7. 强制锁定导致的死锁'
- en: Attempts to *open()* a file with the `O_TRUNC` flag always fail immediately
    (with the error `EAGAIN`) if any other process holds a read or write lock on any
    part of the file.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有其他进程在文件的任何部分上持有读锁或写锁，尝试使用`O_TRUNC`标志*打开()*文件总是会立即失败（并返回错误`EAGAIN`）。
- en: It is not possible to create a shared memory mapping (i.e., *mmap()* with the
    `MAP_SHARED` flag) on a file if any other process holds a mandatory read or write
    lock on *any* part of the file. Conversely, it is not possible to place a mandatory
    lock on *any* part of a file that is currently involved in a shared memory mapping.
    In both cases, the relevant system call fails immediately with the error `EAGAIN`.
    The reason for these restrictions becomes clear when we consider the implementation
    of memory mappings. In [Shared File Mappings](ch49.html#shared_file_mappings "Shared
    File Mappings"), we saw that a shared file mapping both reads from and writes
    to a file (and the latter operation, in particular, conflicts with any type of
    lock on the file). Furthermore, this file I/O is performed by the memory-management
    subsystem, which has no knowledge of the location of any file locks in the system.
    Thus, to prevent a mapping from updating a file on which a mandatory lock is held,
    the kernel performs a simple check--testing at the time of the *mmap()* call whether
    there are locks anywhere in the file to be mapped (and vice versa for *fcntl()*).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何其他进程在文件的*任何*部分上持有强制读锁或写锁，则无法对文件创建共享内存映射（即使用`MAP_SHARED`标志的*mmap()*）。反过来，如果文件的*任何*部分当前参与了共享内存映射，则无法对其进行强制锁定。在这两种情况下，相关的系统调用会立即失败，并返回错误`EAGAIN`。当我们考虑内存映射的实现时，这些限制的原因变得清晰。在[共享文件映射](ch49.html#shared_file_mappings
    "共享文件映射")中，我们看到共享文件映射既会读取文件也会写入文件（特别是后者操作与文件上的任何类型的锁定冲突）。此外，文件I/O由内存管理子系统执行，而该子系统并不了解系统中任何文件锁的位置。因此，为了防止映射更新持有强制锁定的文件，内核进行了一项简单的检查——在*mmap()*调用时测试是否存在文件中任何部分的锁定（*fcntl()*也有类似的检查）。
- en: Mandatory locking caveats
  id: totrans-230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 强制锁定的注意事项
- en: 'Mandatory locks do less for us than we might at first expect, and have some
    potential shortcomings and problems:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 强制锁定对我们而言的作用可能没有最初想象的那么大，并且存在一些潜在的缺点和问题：
- en: Holding a mandatory lock on a file doesn’t prevent another process from deleting
    it, since all that is required to unlink a file is suitable permissions on the
    parent directory.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持有文件的强制锁定并不会阻止其他进程删除该文件，因为删除文件所需的只是父目录上适当的权限。
- en: Careful consideration should be applied before enabling mandatory locks on a
    publicly accessible file, since not even privileged processes can override a mandatory
    lock. A malicious user could continuously hold a lock on the file in order to
    create a denial-of-service attack. (While in most cases, we could make the file
    accessible once more by turning off the set-group-ID bit, this may not be possible
    if, for example, the mandatory file lock is causing the system to hang.)
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在启用强制锁定之前，应该谨慎考虑，尤其是在公开可访问的文件上，因为即便是特权进程也无法覆盖强制锁定。恶意用户可能会持续持有文件的锁，从而造成拒绝服务攻击。（尽管在大多数情况下，我们可以通过关闭设置组ID位来重新使文件可访问，但如果强制文件锁定导致系统挂起，例如，这可能就不再可行。）
- en: There is a performance cost associated with the use of mandatory locking. For
    each I/O system call made on a file with mandatory locking enabled, the kernel
    must check for lock conflicts on the file. If the file has a large number of locks,
    this check can slow I/O system calls significantly.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用强制锁定会带来性能开销。每次对启用了强制锁定的文件进行I/O系统调用时，内核必须检查文件上的锁定冲突。如果文件有大量的锁定，这种检查可能会显著减慢I/O系统调用的速度。
- en: Mandatory locking also incurs a cost in application design. We need to handle
    the possibility that each I/O system call can return EAGAIN (for nonblocking I/O)
    or `EDEADLK` (for blocking I/O).
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制锁定在应用设计中也会带来一定的成本。我们需要处理每个I/O系统调用可能返回EAGAIN（对于非阻塞I/O）或`EDEADLK`（对于阻塞I/O）的情况。
- en: As a consequence of some kernel race conditions in the current Linux implementation,
    there are circumstances in which system calls that perform I/O operations can
    succeed despite the presence of mandatory locks that should deny those operations.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于当前Linux实现中的一些内核竞态条件，存在某些情况下，即便存在强制锁定应该拒绝这些操作，执行I/O操作的系统调用仍然会成功。
- en: In summary, the use of mandatory locks is best avoided.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，最好避免使用强制锁定。
- en: The `/proc/locks` File
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`/proc/locks` 文件'
- en: 'We can view the set of locks currently held in the system by examining the
    contents of the Linux-specific `/proc/locks` file. Here is an example of the information
    we can see in this file (in this case, for four locks):'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看 Linux 特有的 `/proc/locks` 文件的内容来查看系统中当前持有的锁集合。以下是我们可以在该文件中看到的信息示例（在此例中，涉及四个锁）：
- en: '[PRE24]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `/proc/locks` file displays information about locks created by both *flock()*
    and *fcntl()*. The eight fields shown for each lock are as follows (from left
    to right):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc/locks` 文件显示了由 *flock()* 和 *fcntl()* 创建的锁的信息。每个锁的八个字段如下所示（从左到右）：'
- en: 'The ordinal number of the lock within the set of all locks held for this file.
    (Refer to [Example: A Library of Locking Functions](ch55.html#example_colon_a_library_of_locking_funct
    "Example: A Library of Locking Functions").)'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有为该文件持有的锁中，锁的序号。请参见 [示例：锁定函数库](ch55.html#example_colon_a_library_of_locking_funct
    "示例：锁定函数库")。
- en: The type of lock. Here, `FLOCK` indicates a lock created by *flock()*, and `POSIX`
    indicates a lock created by *fcntl()*.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 锁的类型。这里，`FLOCK` 表示通过 *flock()* 创建的锁，`POSIX` 表示通过 *fcntl()* 创建的锁。
- en: The mode of the lock, either `ADVISORY` or `MANDATORY`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 锁的模式，可以是 `ADVISORY` 或 `MANDATORY`。
- en: The type of lock, either `READ` or `WRITE` (corresponding to shared and exclusive
    locks for *fcntl()*).
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 锁的类型，可以是 `READ` 或 `WRITE`（对应于 *fcntl()* 的共享锁和独占锁）。
- en: The process ID of the process holding the lock.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 持有锁的进程的进程 ID。
- en: Three colon-separated numbers that identify the file on which the lock is held.
    These numbers are the major and minor device numbers of the file system on which
    the file resides, followed by the i-node number of the file.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个用冒号分隔的数字，用来标识锁定的文件。这些数字是文件所在文件系统的主设备号和次设备号，后跟文件的 i-node 号。
- en: The starting byte of the lock. This is always 0 for *flock()* locks.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 锁的起始字节。对于 *flock()* 锁来说，这个值总是 0。
- en: The ending byte of the lock. Here, `EOF` indicates that the lock runs to the
    end of the file (i.e., *l_len* was specified as 0 for a lock created by *fcntl()*).
    For *flock()* locks, this column is always `EOF`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 锁的结束字节。这里，`EOF` 表示锁一直延伸到文件末尾（即 *fcntl()* 创建的锁的 *l_len* 被指定为 0）。对于 *flock()*
    锁来说，这一列总是 `EOF`。
- en: Note
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Linux 2.4 and earlier, each line of `/proc/locks` includes five additional
    hexadecimal values. These are pointer addresses used by the kernel to record locks
    in various lists. These values are not useful in application programs.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Linux 2.4 及更早版本中，`/proc/locks` 的每一行都会包括五个附加的十六进制值。这些是内核用来记录锁在各种列表中的指针地址。这些值对于应用程序没有用处。
- en: 'Using the information in `/proc/locks`, we can find out which process is holding
    a lock, and on what file. The following shell session shows how to do this for
    lock number 3 in the list above. This lock is held by process ID 312, on the i-node
    133853 on the device with major ID 3 and minor ID 7\. We begin by using *ps(1)*
    to list information about the process with process ID 312:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `/proc/locks` 中的信息，我们可以找出哪个进程持有锁，以及该锁对应的文件。下面的 Shell 会话展示了如何为上面列表中的锁号 3 找到相应的信息。该锁由进程
    ID 312 持有，锁定的文件对应设备 ID 为 3 和次设备 ID 为 7 的设备上的 i-node 133853。我们首先使用 *ps(1)* 命令列出进程
    ID 为 312 的进程信息：
- en: '[PRE25]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The above output shows that the program holding the lock is *atd*, the daemon
    that executes scheduled batch jobs.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示，持有锁的程序是 *atd*，即执行计划批处理任务的守护进程。
- en: 'In order to find the locked file, we first search the files in the `/dev` directory,
    and thus determine that the device with ID 3:7 is `/dev/sda7`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到被锁定的文件，我们首先搜索 `/dev` 目录下的文件，因此可以确定设备 ID 为 3:7 的设备是 `/dev/sda7`：
- en: '[PRE26]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We then determine the mount point for the device `/dev/sda7` and search that
    part of the file system for the file whose i-node number is 133853:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们确定设备 `/dev/sda7` 的挂载点，并在该文件系统中查找 i-node 号为 133853 的文件：
- en: '[PRE27]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The *find -mount* option prevents *find* from descending into subdirectories
    under `/` that are mount points for other file systems.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*find -mount* 选项可以防止 *find* 命令进入 `/` 下的子目录，这些子目录是其他文件系统的挂载点。'
- en: 'Finally, we display the contents of the locked file:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们显示锁定文件的内容：
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Thus, we see that the *atd* daemon is holding a lock on the file `/var/run/atd.pid`,
    and that the content of this file is the process ID of the process running *atd*.
    This daemon is employing a technique to ensure that only one instance of the daemon
    is running at a time. We describe this technique in Section 55.6.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到 *atd* 守护进程正在持有文件 `/var/run/atd.pid` 的锁，并且该文件的内容是正在运行 *atd* 的进程 ID。这个守护进程采用了一种技术，确保在任何时候只有一个实例在运行。我们在
    55.6 节中描述了这一技术。
- en: 'We can also use `/proc/locks` to obtain information about blocked lock requests,
    as demonstrated in the following output:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `/proc/locks` 来获取关于被阻塞的锁请求的信息，如以下输出所示：
- en: '[PRE29]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Lines shown with the characters `->` immediately after a lock number represent
    lock requests blocked by the corresponding lock number. Thus, we see one request
    blocked on lock 1 (an advisory lock created with *fcntl()*), two requests blocked
    on lock 2 (a mandatory lock created with *fcntl()*), and one request blocked on
    lock 3 (a lock created with *flock()*).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 显示为 `->` 字符的行紧跟在锁编号后面，表示被相应锁编号阻塞的锁请求。因此，我们可以看到一个请求被锁 1（通过 *fcntl()* 创建的建议性锁）阻塞，两个请求被锁
    2（通过 *fcntl()* 创建的强制性锁）阻塞，一个请求被锁 3（通过 *flock()* 创建的锁）阻塞。
- en: Note
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `/proc/locks` file also displays information about any file leases that
    are held by processes on the system. File leases are a Linux-specific mechanism
    available in Linux 2.4 and later. If a process takes out a lease on a file, then
    it is notified (by delivery of a signal) if another process tries to *open()*
    or *truncate()* that file. (The inclusion of *truncate()* is necessary because
    it is the only system call that can be used to change the contents of a file without
    first opening it.) File leases are provided in order to allow Samba to support
    the *opportunistic locks* (*oplocks*) functionality of the Microsoft SMB protocol
    and to allow NFS version 4 to support *delegations* (which are similar to SMB
    oplocks). Further details about file leases can be found under the description
    of the `F_SETLEASE` operation in the *fcntl(2)* manual page.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`/proc/locks` 文件还显示系统中任何进程持有的文件租约信息。文件租约是一个特定于 Linux 的机制，适用于 Linux 2.4 及更高版本。如果一个进程对文件进行租约操作，那么如果另一个进程尝试
    *open()* 或 *truncate()* 该文件，它将收到通知（通过信号传递）。之所以包含 *truncate()*，是因为它是唯一可以在不先打开文件的情况下改变文件内容的系统调用。文件租约的提供是为了支持
    Samba 支持微软 SMB 协议中的 *opportunistic locks*（*oplocks*）功能，并且允许 NFS 版本 4 支持 *delegations*（类似于
    SMB oplocks）。关于文件租约的更多详细信息可以在 *fcntl(2)* 手册页中找到 `F_SETLEASE` 操作的描述。'
- en: Running Just One Instance of a Program
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅运行一个程序实例
- en: Some programs—in particular, many daemons—need to ensure that only one instance
    of the program is running on the system at a time. A common method of doing this
    is to have the daemon create a file in a standard directory and place a write
    lock on it. The daemon holds the file lock for the duration of its execution and
    deletes the file just before terminating. If another instance of the daemon is
    started, it will fail to obtain a write lock on the file. Consequently, it will
    realize that another instance of the daemon must already be running, and terminate.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 一些程序——特别是许多守护进程——需要确保系统上同时只有一个程序实例在运行。实现这一目标的常见方法是让守护进程在标准目录中创建一个文件，并对其加写锁。守护进程在执行期间保持该文件锁，并在终止前删除该文件。如果启动了另一个守护进程实例，它将无法对该文件获取写锁。因此，它将意识到另一个守护进程实例可能已经在运行，并终止。
- en: Note
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Many network servers use an alternative convention of assuming that a server
    instance is already running if the well-known socket port to which the server
    binds is already in use ([The *SO_REUSEADDR* Socket Option](ch61.html#the_so_underscore_reuseaddr_socket_optio
    "The SO_REUSEADDR Socket Option")).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 许多网络服务器使用一种替代惯例，即假设如果服务器绑定的知名套接字端口已经在使用中，那么服务器实例已经在运行（[*SO_REUSEADDR* 套接字选项](ch61.html#the_so_underscore_reuseaddr_socket_optio
    "The SO_REUSEADDR Socket Option")）。
- en: The `/var/run` directory is the usual location for such lock files. Alternatively,
    the location of the file may be specified by a line in the daemon’s configuration
    file.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`/var/run` 目录通常是此类锁文件的存放位置。或者，也可以通过守护进程的配置文件中的一行指定文件的位置。'
- en: Conventionally, a daemon writes its own process ID into the lock file, and hence
    the file is often named with an extension `.pid` (for example, *syslogd* creates
    the file `/var/run/syslogd.pid`). This is useful if some application needs to
    find the process ID of the daemon. It also allows an extra sanity check—we can
    verify whether that process ID exists using *kill(pid, 0)*, as described in Section
    20.5\. (In older UNIX implementations that did not provide file locking, this
    was used as an imperfect, but usually practicable, way of assessing whether an
    instance of the daemon really was still running, or whether an earlier instance
    had simply failed to delete the file before terminating.)
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 按惯例，守护进程会将其进程 ID 写入锁文件，因此该文件通常会以 `.pid` 作为扩展名（例如，*syslogd* 会创建 `/var/run/syslogd.pid`
    文件）。如果某些应用程序需要查找守护进程的进程 ID，这非常有用。它还提供了一种额外的合理性检查——我们可以通过 *kill(pid, 0)* 来验证该进程
    ID 是否存在，如第 20.5 节所述。（在一些不提供文件锁定的旧 UNIX 实现中，这被用作一种不完美但通常可行的方式来评估守护进程实例是否真的仍在运行，或者是早期实例在终止前未能删除文件。）
- en: 'There are many minor variations in the code used to create and lock a process
    ID lock file. [Example 55-4](ch55.html#creating_a_pid_lock_file_to_ensure_just
    "Example 55-4. Creating a PID lock file to ensure just one instance of a program
    is started") is based on ideas presented in [Stevens, 1999] and provides a function,
    *createPidFile()*, that encapsulates the steps described above. We would typically
    call this function with a line such as the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和锁定进程 ID 锁文件的代码有许多细微的变化。[示例 55-4](ch55.html#creating_a_pid_lock_file_to_ensure_just
    "示例 55-4. 创建 PID 锁文件以确保只启动一个程序实例") 基于 [Stevens, 1999] 中提出的思想，并提供了一个封装上述步骤的函数 *createPidFile()*。我们通常会使用类似以下的代码调用此函数：
- en: '[PRE30]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: One subtlety in the *createPidFile()* function is the use of *ftruncate()* to
    erase any previous string in the lock file. This is done because the last instance
    of the daemon may have failed to delete the file, perhaps because of a system
    crash. In this case, if the process ID of the new daemon instance is small, we
    might otherwise not completely overwrite the previous contents of the file. For
    example, if our process ID is 789, then we would write just `789\n` to the file,
    but a previous daemon instance might have written `12345\n`. If we did not truncate
    the file, then the resulting content would be `789\n5\n`. Erasing any existing
    string may not be strictly necessary, but it is tidier and removes any potential
    for confusion.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*createPidFile()* 函数中的一个细节是使用 *ftruncate()* 来删除锁文件中之前的任何字符串。这样做是因为上一个守护进程实例可能没有成功删除文件，可能是因为系统崩溃。在这种情况下，如果新守护进程实例的进程
    ID 较小，我们可能无法完全覆盖文件中之前的内容。例如，如果我们的进程 ID 是 789，那么我们只会写入 `789\n` 到文件，但先前的守护进程实例可能写入了
    `12345\n`。如果我们不截断文件，最终的内容可能是 `789\n5\n`。删除现有字符串可能不是严格必要的，但它更整洁，避免了潜在的混淆。'
- en: The *flags* argument can specify the constant `CPF_CLOEXEC`, which causes *createPidFile()*
    to set the close-on-exec flag ([File Descriptors and *exec()*](ch27.html#file_descriptors_and_exec_open_parenthes
    "File Descriptors and exec()")) for the file descriptor. This is useful for servers
    that restart themselves by calling *exec()*. If the file descriptor was not closed
    during the *exec()*, then the restarted server would think that a duplicate instance
    of the server is already running.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '*flags* 参数可以指定常量 `CPF_CLOEXEC`，该常量使 *createPidFile()* 为文件描述符设置关闭执行标志（[文件描述符和
    *exec()*](ch27.html#file_descriptors_and_exec_open_parenthes "文件描述符和 exec()")）。这对于通过调用
    *exec()* 重启自己的服务器非常有用。如果文件描述符在 *exec()* 期间未关闭，则重启的服务器会认为服务器的重复实例已经在运行。'
- en: Example 55-4. Creating a PID lock file to ensure just one instance of a program
    is started
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 55-4. 创建 PID 锁文件以确保只启动一个程序实例
- en: '[PRE31]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Older Locking Techniques
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旧的锁定技术
- en: In older UNIX implementations that lacked file locking, a number of *ad hoc*
    locking techniques were employed. Although all of these have been superseded by
    *fcntl()* record locking, we describe them here since they still appear in some
    older programs. All of these techniques are advisory in nature.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在较旧的 UNIX 实现中，由于缺乏文件锁定，采用了多种 *临时* 锁定技术。尽管这些技术都已经被 *fcntl()* 记录锁定所取代，但我们仍在此描述它们，因为它们在一些旧程序中仍然存在。这些技术本质上都是建议性的。
- en: '`open(file, O_CREAT | O_EXCL,...)` **plus** `unlink(file)`'
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`open(file, O_CREAT | O_EXCL,...)` **加上** `unlink(file)`'
- en: 'SUSv3 requires that an *open()* call with the flags `O_CREAT` and `O_EXCL`
    perform the steps of checking for the existence of a file and creating it atomically
    ([Atomicity and Race Conditions](ch05.html#atomicity_and_race_conditions "Atomicity
    and Race Conditions")). This means that if two processes attempt to create a file
    specifying these flags, it is guaranteed that only one of them will succeed. (The
    other process will receive the error `EEXIST` from *open()*.) Used in conjunction
    with the *unlink()* system call, this provides the basis for a locking mechanism.
    Acquiring the lock is performed by successfully opening the file with the `O_CREAT`
    and `O_EXCL` flags, followed by an immediate *close()*. Releasing the lock is
    performed using *unlink()*. Although workable, this technique has several limitations:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: SUSv3 要求具有 `O_CREAT` 和 `O_EXCL` 标志的 *open()* 调用必须执行检查文件是否存在并原子性地创建文件的步骤（[原子性与竞争条件](ch05.html#atomicity_and_race_conditions
    "原子性与竞争条件")）。这意味着，如果两个进程尝试创建指定这些标志的文件，则保证只有一个会成功。（另一个进程将从 *open()* 中收到 `EEXIST`
    错误。）与 *unlink()* 系统调用配合使用时，这为锁机制提供了基础。获取锁是通过使用 `O_CREAT` 和 `O_EXCL` 标志成功打开文件，然后立即执行
    *close()* 完成的。释放锁则通过使用 *unlink()* 来执行。尽管这种方法可行，但它有几个限制：
- en: If the *open()* fails, indicating that some other process has the lock, then
    we must retry the *open()* in some kind of loop, either polling continuously (which
    wastes CPU time) or with a delay between each attempt (which means that there
    may be some delay between the time the lock becomes available and when we actually
    acquire it). With *fcntl()*, we can use `F_SETLKW` to block until the lock becomes
    free.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *open()* 失败，表示另一个进程已经持有锁，那么我们必须在某种循环中重试 *open()*，要么不断轮询（这会浪费 CPU 时间），要么在每次尝试之间有延迟（这意味着锁变得可用和我们实际获取锁之间可能会有一些延迟）。使用
    *fcntl()* 时，我们可以使用 `F_SETLKW` 来阻塞直到锁释放。
- en: Acquiring and releasing locks using *open()* and *unlink()* involves file-system
    operations that are rather slower than the use of record locks. (On one of the
    author’s x86-32 systems running Linux 2.6.31, acquiring and releasing 1 million
    locks on an *ext3* file using the technique described here required 44 seconds.
    Acquiring and releasing 1 million record locks on the same byte of a file required
    2.5 seconds.)
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *open()* 和 *unlink()* 获取和释放锁涉及的文件系统操作比使用记录锁要慢得多。（在作者的一台运行 Linux 2.6.31 的
    x86-32 系统上，使用此方法获取和释放 100 万个锁的时间为 44 秒。而在同一个文件的同一个字节上获取和释放 100 万个记录锁所需的时间仅为 2.5
    秒。）
- en: If a process accidentally exits without deleting the lock file, the lock is
    not released. There are *ad hoc* techniques for handling this problem, including
    checking the last modification time of the file and having the lock holder write
    its process ID to the file so that we can check if the process still exists, but
    none of these techniques is foolproof. By comparison, record locks are released
    automatically when a process terminates.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个进程在没有删除锁文件的情况下意外退出，则锁不会被释放。处理这个问题有一些 *临时* 技巧，包括检查文件的最后修改时间，并让锁持有者将其进程 ID
    写入文件，以便我们可以检查进程是否仍然存在，但这些技术都不是万无一失的。相比之下，记录锁在进程终止时会自动释放。
- en: If we are placing multiple locks (i.e., using multiple lock files), deadlocks
    are not detected. If a deadlock arises, the processes involved in the deadlock
    will remain blocked indefinitely. (Each process will be spinning, checking to
    see if it can obtain the lock it requires.) By contrast, the kernel provides deadlock
    detection for *fcntl()* record locks.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们放置多个锁（即使用多个锁文件），则不会检测到死锁。如果发生死锁，参与死锁的进程将无限期地保持阻塞状态。（每个进程将处于旋转状态，检查是否能够获得所需的锁。）相比之下，内核为
    *fcntl()* 记录锁提供了死锁检测。
- en: NFS version 2 doesn’t support `O_EXCL` semantics. Linux 2.4 NFS clients also
    fail to implement `O_EXCL` correctly, even for NFS version 3 and later.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NFS 版本 2 不支持 `O_EXCL` 语义。Linux 2.4 NFS 客户端即使在 NFS 版本 3 及以后的版本中，也未能正确实现 `O_EXCL`。
- en: '`link(file, lockfile)` **plus** `unlink(lockfile)`'
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`link(file, lockfile)` **加上** `unlink(lockfile)`'
- en: The fact that the *link()* system call fails if the new link already exists
    has also been used as a locking mechanism, again employing *unlink()* to perform
    the unlock function. The usual approach is to have each process that needs to
    acquire the lock create a unique temporary filename, typically one including the
    process ID (and possibly the hostname, if the lock file is created on a network
    file system). To acquire the lock, this temporary file is linked to some agreed-upon
    standard pathname. (The semantics of hard links require that the two pathnames
    reside in the same file system.) If the *link()* call succeeds, we have obtained
    the lock. If it fails (`EEXIST`), then another process has the lock and we must
    try again later. This technique suffers the same limitations as the *open(file*,
    *O_CREAT* | *O_EXCL*,...) technique described above.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '*link()* 系统调用在新链接已存在时失败的事实也被用作锁机制，再次利用 *unlink()* 来执行解锁功能。通常的方法是让每个需要获取锁的进程创建一个唯一的临时文件名，通常包括进程
    ID（如果锁文件是在网络文件系统上创建，可能还会包括主机名）。为了获取锁，这个临时文件被链接到一个预定的标准路径名。（硬链接的语义要求两个路径名必须在同一文件系统中。）如果
    *link()* 调用成功，我们就获得了锁。如果失败（`EEXIST`），则表示另一个进程已持有锁，我们必须稍后重试。这种技术与上述的 *open(file*,
    *O_CREAT* | *O_EXCL*，...) 技术存在相同的限制。'
- en: '`open(file, O_CREAT | O_TRUNC | O_WRONLY, 0)` plus `unlink(file)`'
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`open(file, O_CREAT | O_TRUNC | O_WRONLY, 0)` 加上 `unlink(file)`'
- en: 'The fact that calling *open()* on an existing file fails if `O_TRUNC` is specified
    and write permission is denied on the file can be used as the basis of a locking
    technique. To obtain a lock, we use the following code (which omits error checking)
    to create a new file:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 *open()* 时，如果文件已存在并且指定了 `O_TRUNC` 并且没有写入权限，则会失败，这一事实可以作为一种锁定技术的基础。为了获取锁，我们使用以下代码（省略了错误检查）来创建一个新文件：
- en: '[PRE32]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释
- en: For an explanation of why we use the *(mode_t)* cast in the *open()* call above,
    see [Appendix C](apc.html "Appendix C. Casting the NULL Pointer").
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 关于为什么在上述 *open()* 调用中使用 *(mode_t)* 强制转换的解释，请参阅 [附录 C](apc.html "附录 C. 强制转换 NULL
    指针")。
- en: If the *open()* call succeeds (i.e., the file didn’t previously exist), we have
    the lock. If it fails with `EACCES` (i.e., the file exists and has no permissions
    for anyone), then another process has the lock, and we must try again later. This
    technique suffers the same limitations as the previous techniques, with the added
    caveat that we can’t employ it in a program with superuser privileges, since the
    *open()* call will always succeed, regardless of the permissions that are set
    on the file.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *open()* 调用成功（即文件之前不存在），则我们已获得锁。如果失败并且出现 `EACCES` 错误（即文件存在但没有任何权限），则表示另一个进程已持有锁，我们必须稍后重试。这种技术存在与之前相同的限制，额外的警告是，如果我们在具有超级用户权限的程序中使用它，由于
    *open()* 调用总是成功的（无论文件权限如何设置），我们就无法使用此技术。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'File locks allow processes to synchronize access to a file. Linux provides
    two file locking system calls: the BSD-derived *flock()* and the System V-derived
    *fcntl()*. Although both system calls are available on most UNIX implementations,
    only *fcntl()* locking is standardized in SUSv3.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 文件锁允许进程同步访问文件。Linux 提供了两种文件锁系统调用：源自 BSD 的 *flock()* 和源自 System V 的 *fcntl()*。尽管大多数
    UNIX 实现都提供这两个系统调用，但只有 *fcntl()* 锁定在 SUSv3 中是标准化的。
- en: 'The *flock()* system call locks an entire file. Two types of locks may be placed:
    shared locks, which are compatible with shared locks held by other processes,
    and exclusive locks, which prevent other processes from placing any type of lock.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*flock()* 系统调用锁定整个文件。可以放置两种类型的锁：共享锁，与其他进程持有的共享锁兼容；独占锁，防止其他进程放置任何类型的锁。'
- en: 'The *fcntl()* system call places locks (“record locks”) on any region of a
    file, ranging from a single byte to the entire file. Two types of locks may be
    placed: read locks and write locks, which have similar compatibility semantics
    to the shared and exclusive locks placed via *flock()*. If a blocking (`F_SETLKW`)
    lock request would bring about a deadlock situation, then the kernel causes *fcntl()*
    to fail (with the error `EDEADLK`) in one of the affected processes.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*fcntl()* 系统调用可以在文件的任意区域上放置锁（“记录锁”），这些区域可以是一个字节到整个文件。可以放置两种类型的锁：读锁和写锁，这两种锁的兼容性语义与通过
    *flock()* 放置的共享锁和独占锁相似。如果一个阻塞的 (`F_SETLKW`) 锁请求会导致死锁情况，那么内核会使得 *fcntl()* 在受影响的进程之一中失败（错误为
    `EDEADLK`）。'
- en: Locks placed using *flock()* and *fcntl()* are invisible to one another (except
    on systems that implement *flock()* using *fcntl()*). The locks placed via *flock()*
    and *fcntl()* have different semantics with respect to inheritance across *fork()*
    and release when file descriptors are closed.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*flock()*和*fcntl()*放置的锁彼此之间是不可见的（除了在实现*flock()*的系统中，*flock()*是通过*fcntl()*实现的）。通过*flock()*和*fcntl()*放置的锁在*fork()*继承和文件描述符关闭时的释放方面具有不同的语义。
- en: The Linux-specific `/proc/locks` file displays the file locks currently held
    by all processes on the system.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 特定于Linux的`/proc/locks`文件显示当前系统中所有进程持有的文件锁。
- en: Further information
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 进一步信息
- en: An extensive discussion of *fcntl()* record locking can be found in [Stevens
    & Rago, 2005] and [Stevens, 1999]. Some details of the implementation of *flock()*
    and *fcntl()* locking on Linux are provided in [Bovet & Cesati, 2005]. [Tanenbaum,
    2007] and [Deitel et al., 2004] describe deadlocking concepts in general, including
    coverage of deadlock detection, avoidance, and prevention.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 关于*fcntl()*记录锁的详细讨论可以参考[Stevens & Rago, 2005]和[Stevens, 1999]。关于Linux上*flock()*和*fcntl()*锁的实现的某些细节可以参考[Bovet
    & Cesati, 2005]。关于死锁概念的描述，包括死锁检测、避免和预防，可以参考[Tanenbaum, 2007]和[Deitel et al., 2004]。
- en: Exercises
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: 'Experiment by running multiple instances of the program in [Example 55-1](ch55.html#using_flock_open_parenthesis_close_paren
    "Example 55-1. Using flock()") (`t_flock.c`) to determine the following points
    about the operation of *flock()*:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行[示例 55-1](ch55.html#using_flock_open_parenthesis_close_paren "示例 55-1. 使用
    flock()") (`t_flock.c`)的多个实例来实验，以确定关于*flock()*操作的以下几点：
- en: Can a series of processes acquiring shared locks on a file starve a process
    attempting to place an exclusive lock on the file?
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一系列进程对文件获取共享锁会不会饿死一个尝试对文件进行独占锁的进程？
- en: Suppose that a file is locked exclusively, and other processes are waiting to
    place both shared and exclusive locks on the file. When the first lock is released,
    are there any rules determining which process is next granted a lock? For example,
    do shared locks have priority over exclusive locks or vice versa? Are locks granted
    in FIFO order?
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设文件被独占锁定，其他进程正在等待对文件进行共享锁和独占锁。当第一个锁释放时，是否有任何规则决定下一个获得锁的进程？例如，共享锁是否优先于独占锁，或者相反？锁是否按FIFO顺序授予？
- en: If you have access to some other UNIX implementation that provides *flock()*,
    try to determine the rules on that implementation.
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您可以访问某些提供*flock()*的其他UNIX实现，尝试确定该实现的规则。
- en: Write a program to determine whether *flock()* detects deadlock situations when
    being used to lock two different files in two processes.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序来确定*flock()*是否检测到死锁情况，当它被用于在两个进程中锁定两个不同的文件时。
- en: Write a program to verify the statements made in [Semantics of Lock Inheritance
    and Release](ch55.html#semantics_of_lock_inheritance_and_releas "Semantics of
    Lock Inheritance and Release") regarding the semantics of inheritance and release
    of *flock()* locks.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序来验证[锁继承和释放的语义](ch55.html#semantics_of_lock_inheritance_and_releas "锁继承和释放的语义")中关于*flock()*锁的继承和释放的语义的声明。
- en: Experiment by running the programs in [Example 55-1](ch55.html#using_flock_open_parenthesis_close_paren
    "Example 55-1. Using flock()") (`t_flock.c`) and [Example 55-2](ch55.html#experimenting_with_record_locking
    "Example 55-2. Experimenting with record locking") (`i_fcntl_locking.c`) to see
    whether locks granted by *flock()* and *fcntl()* have any effect on one another.
    If you have access to other UNIX implementations, try the same experiment on those
    implementations.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行[示例 55-1](ch55.html#using_flock_open_parenthesis_close_paren "示例 55-1. 使用
    flock()") (`t_flock.c`)和[示例 55-2](ch55.html#experimenting_with_record_locking
    "示例 55-2. 记录锁实验") (`i_fcntl_locking.c`)的程序，查看*flock()*和*fcntl()*授予的锁是否会互相影响。如果您可以访问其他UNIX实现，尝试在这些实现上进行相同的实验。
- en: 'In [Example: A Library of Locking Functions](ch55.html#example_colon_a_library_of_locking_funct
    "Example: A Library of Locking Functions"), we noted that, on Linux, the time
    required to add or check for the existence of a lock is a function of the position
    of the lock in the list of all locks on the file. Write two programs to verify
    this:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[示例：锁函数库](ch55.html#example_colon_a_library_of_locking_funct "示例：锁函数库")中，我们提到，在Linux上，添加或检查锁是否存在所需的时间是文件上所有锁的位置的函数。编写两个程序来验证这一点：
- en: The first program should acquire (say) 40,001 write locks on a file. These locks
    are placed on alternating bytes of the file; that is, locks are placed on bytes
    0, 2, 4, 6, and so on through to (say) byte 80,000\. Having acquired these locks,
    the process then goes to sleep.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个程序应该在文件上获取（假设）40,001个写锁。这些锁将被放置在文件的交替字节上；即，锁定字节0、2、4、6，以此类推，直到（假设）字节80,000。获取这些锁后，进程将进入休眠状态。
- en: While the first program is sleeping, the second program loops (say) 10,000 times,
    using `F_SETLK` to try to lock one of the bytes locked by the previous program
    (these lock attempts always fail). In any particular execution, the program always
    tries to lock byte *N * 2* of the file.
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当第一个程序处于休眠状态时，第二个程序循环（假设）10,000次，使用`F_SETLK`尝试锁定前一个程序锁定的某个字节（这些锁定尝试总是失败）。在任何特定的执行中，程序总是尝试锁定文件的字节*N
    * 2*。
- en: Using the shell built-in *time* command, measure the time required by the second
    program for *N* equals 0, 10,000, 20,000, 30,000, and 40,000\. Do the results
    match the expected linear behavior?
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用shell内置的*time*命令，测量第二个程序在*N*等于0、10,000、20,000、30,000和40,000时所需的时间。结果是否符合预期的线性行为？
- en: Experiment with the program in [Example 55-2](ch55.html#experimenting_with_record_locking
    "Example 55-2. Experimenting with record locking") (`i_fcntl_locking.c`) to verify
    the statements made in [Semantics of Lock Inheritance and Release](ch55.html#semantics_of_lock_inheritance_and_re
    "Semantics of Lock Inheritance and Release") regarding lock starvation and priority
    for *fcntl()* record locks.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[示例 55-2](ch55.html#experimenting_with_record_locking "示例 55-2. 记录锁定实验")（`i_fcntl_locking.c`）中的程序，验证[锁继承和释放的语义](ch55.html#semantics_of_lock_inheritance_and_re
    "锁继承和释放的语义")中关于*fcntl()*记录锁的锁饿死和优先级的陈述。
- en: If you have access to other UNIX implementations, use the program in [Example 55-2](ch55.html#experimenting_with_record_locking
    "Example 55-2. Experimenting with record locking") (`i_fcntl_locking.c`) to see
    if you can establish any rules for *fcntl()* record locking regarding starvation
    of writers and regarding the order in which multiple queued lock requests are
    granted.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你可以访问其他UNIX实现，请使用[示例 55-2](ch55.html#experimenting_with_record_locking "示例 55-2.
    记录锁定实验")（`i_fcntl_locking.c`）中的程序，看看是否能建立关于*fcntl()*记录锁的任何规则，特别是关于写操作的饿死情况以及多个排队锁请求的授予顺序。
- en: Use the program in [Example 55-2](ch55.html#experimenting_with_record_locking
    "Example 55-2. Experimenting with record locking") (`i_fcntl_locking.c`) to demonstrate
    that the kernel detects circular deadlocks involving three (or more) processes
    locking the same file.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[示例 55-2](ch55.html#experimenting_with_record_locking "示例 55-2. 记录锁定实验")（`i_fcntl_locking.c`）中的程序，演示内核如何检测到涉及三个（或更多）进程锁定同一文件的循环死锁。
- en: Write a pair of programs (or a single program that uses a child process) to
    bring about the deadlock situation with mandatory locks described in Section 55.4.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一对程序（或使用子进程的单个程序）来引发第55.4节中描述的强制锁的死锁情况。
- en: Read the manual page of the *lockfile(1)* utility that is supplied with *procmail*.
    Write a simple version of this program.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 阅读随*procmail*提供的*lockfile(1)*实用程序的手册页。编写该程序的简化版本。
