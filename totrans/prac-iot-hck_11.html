<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="189" id="Page_189"/>8</span><br/>
<span class="ChapterTitle">SPI and I<sup>2</sup>C </span>
</h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="204" height="204"/>
</figure>
<p class="ChapterIntro">This chapter introduces you to the <em>Serial Peripheral Interface (SPI)</em> and the <em>Inter-Integrated Circuit (I<sup>2</sup>C)</em>, two common communication protocols in IoT devices that use microcontrollers and peripheral devices. As you learned in Chapter 7, sometimes simply connecting to interfaces, such as UART and JTAG, gives us direct access to a system shell, maybe one that the manufacturers left purposely. But what if the device’s JTAG or UART interfaces require authentication? Or worse, what if they’re not implemented? In those cases, you’ll still likely find older protocols like SPI and I<sup>2</sup>C built into the microcontrollers. </p>
<p>In this chapter, you’ll use SPI to extract data from EEPROM and other flash memory chips, which often contain firmware and other important secrets, such as API keys, private passphrases, and service endpoints. You’ll also build your own I<sup>2</sup>C architecture and then practice sniffing and manipulating its serial communications to force the peripherals to perform actions. </p>
<h2 id="h1-500907c08-0001"><span epub:type="pagebreak" title="190" id="Page_190"/>Hardware for Communicating with SPI and I<sup>2</sup>C</h2>
<p class="BodyFirst">To communicate with SPI and I<sup>2</sup>C, you’ll need some specific hardware. You could use a breakout board or programmer for EEPROM/flash memory chips if you’re willing to desolder the chips (which should be your last resort). But if you prefer to not desolder anything from the circuit board, you can use either test hook clips or small outline integrated (SOIC) clips, which are cheap and handy. </p>
<p>For the SPI project in this chapter, you’ll need an eight-pin SOIC clip cable or hook clips to connect to the flash memory chips. SOIC clips (<a id="figureanchor8-1" href="#figure8-1">Figure 8-1</a>) might be tricky to use, because you need to align the pads perfectly when connecting the clip to the chip. Hook clips might work better for some people.</p>
<figure>
<img src="Images/f08001.png" alt="f08001" width="563" height="628"/>
<figcaption><p><a id="figure8-1">Figure 8-1:</a> An eight-pin SOIC cable</p></figcaption>
</figure>
<p>You’ll also need a USB-to-serial interface. Although you could use the adapter used in Chapter 7, we recommend the <em>Bus Pirate</em> (<a href="http://dangerousprototypes.com/docs/Bus_Pirate" class="LinkURL">http://dangerousprototypes.com/docs/Bus_Pirate</a>), a robust open source device that supports multiple protocols. It has built-in macros for IoT hacking, including <span epub:type="pagebreak" title="191" id="Page_191"/>scanning and sniffing capabilities for I<sup>2</sup>C and many other protocols. You could also try more expensive tools that can parse I<sup>2</sup>C messages in more formats, like the Beagle (<a href="https://www.totalphase.com/products/beagle-i2cspi/" class="LinkURL">https://www.totalphase.com/products/beagle-i2cspi/</a>) or Aardvark (<a href="https://www.totalphase.com/products/aardvark-i2cspi/" class="LinkURL">https://www.totalphase.com/products/aardvark-i2cspi/</a>). In this chapter, you’ll learn how to use Bus Pirate’s built-in macros to perform common attacks. </p>
<p>Additionally, to run the I<sup>2</sup>C lab exercise later in this chapter, you’ll need an Arduino Uno (<a href="https://store.arduino.cc/usa/arduino-uno-rev3/" class="LinkURL">https://store.arduino.cc/usa/arduino-uno-rev3/</a>), at least one BlinkM LED (<a href="https://www.sparkfun.com/products/8579/" class="LinkURL">https://www.sparkfun.com/products/8579/</a>), a breadboard, and some jumper cables.</p>
<p>You might also use Helping Hands, devices that help you hold multiple hardware parts. They have a wide range of prices. Refer to “Tools for IoT Hacking” for a complete list of tools along with descriptions of some of their strengths and weaknesses.</p>
<h2 id="h1-500907c08-0002">SPI</h2>
<p class="BodyFirst">SPI is a communication protocol that transmits data between peripherals and microcontrollers. Found in popular hardware like the Raspberry Pi and Arduino, it’s a <em>synchronous communication protocol</em>, which means it can transfer data faster than I<sup>2</sup>C and UART. Often, it’s used for short-distance communications in places where read and write speeds matter, such as in Ethernet peripherals, LCD displays, SD card readers, and the memory chips on almost any IoT device. </p>
<h3 id="h2-500907c08-0001">How SPI Works</h3>
<p class="BodyFirst">SPI uses four wires to transmit data. In full duplex mode, when data transmissions happen simultaneously in both directions, it relies on a controller-peripheral architecture. In such an architecture, the device that serves as the <em>controller</em> generates and controls a clock that regulates the data transfer, and all devices that serve as <em>peripherals</em> listen and send messages. SPI uses the following four lines (not counting the ground): </p>
<ol class="none">
<li><span class="RunInHead"><b>Controller In, Peripheral Out (CIPO)</b></span>  For messages sent by peripherals to the controller </li>
<li><span class="RunInHead"><b>Controller Out, Peripheral In (COPI)</b></span>  For messages from the controller to peripherals</li>
<li><span class="RunInHead"><b>Serial Clock (SCK)</b></span>  For an oscillating signal that indicates when devices should read lines of data </li>
<li><span class="RunInHead"><b>Chip Select (CS)</b></span>  To select the peripheral that should receive a communication </li>
</ol>
<p>Notice that, unlike UART, SPI uses separate lines for sending and receiving data (<em>COPI</em> and <em>CIPO</em>, respectively). Also note that the hardware required to implement SPI is cheaper and simpler than UART, and it can achieve higher data rates. For these reasons, many microcontrollers used in the IoT world support it. You can learn more about SPI implementations at <a href="https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all/." class="LinkURL">https://learn.sparkfun.com/tutorials/serial-peripheral-interface-spi/all/.</a></p>
<h3 id="h2-500907c08-0002"><span epub:type="pagebreak" title="192" id="Page_192"/>Dumping EEPROM Flash Memory Chips with SPI</h3>
<p class="BodyFirst">Flash memory chips often contain the device’s firmware and other important secrets, so extracting data from them can yield interesting security findings, such as backdoors, encryption keys, secret accounts, and so on. To locate the memory chips in an IoT device, open its external case and remove the PCB. </p>
<h4 id="h3-500907c08-0001">Identifying the Chip and Pins</h4>
<p class="BodyFirst">Locate your device’s flash memory chip. Products that have been hardened for security will usually delete the chip labels on the device, but flash memory chips commonly have 8 or 16 pins. You can also find the chip by looking up the microcontroller’s datasheet online, as we did in Chapter 7. The datasheet should contain a diagram showing the pins’ configuration and descriptions. The datasheet will likely also contain information confirming whether the chip supports SPI. Other information, such as protocol version, speeds supported, and memory size, will also prove useful when configuring the tools for interacting with SPI. </p>
<p>Once you’ve identified the memory chip, find the small dot at one of the chip’s corners that labels pin #1 (<a id="figureanchor8-2" href="#figure8-2">Figure 8-2</a>).</p>
<figure>
<img src="Images/f08002.png" alt="f08002" width="750" height="457"/>
<figcaption><p><a id="figure8-2">Figure 8-2:</a> The flash memory chip</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="193" id="Page_193"/>Now connect the first pin of an eight-pin SOIC cable to pin #1. The first pin of the SOIC clip often has a different color than the others, making it easier to find. Use the pin configuration pulled from the datasheet to align the rest of the SOIC pads correctly. <a id="figureanchor8-3" href="#figure8-3">Figure 8-3</a> shows a common alignment. For example, the WinBond 25Q64 memory chip uses this alignment.</p>
<figure>
<img src="Images/f08003.png" alt="f08003" width="654" height="565"/>
<figcaption><p><a id="figure8-3">Figure 8-3:</a> A memory chip’s pin configuration diagram</p></figcaption>
</figure>
<p>When you’ve connected all parts of the SOIC clip to the memory flash chip, your setup should look like the one in <a id="figureanchor8-4" href="#figure8-4">Figure 8-4</a>. Be careful connecting the SOIC clip because you can easily damage the pins. </p>
<figure>
<img src="Images/f08004.png" alt="f08004" width="563" height="750"/>
<figcaption><p><a id="figure8-4">Figure 8-4:</a> SOIC clip connected to the flash memory chip</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="194" id="Page_194"/>If you’re having trouble aligning the pads, test hook clips (<a id="figureanchor8-5" href="#figure8-5">Figure 8-5</a>) work too; you might find them easier to connect.</p>
<figure>
<img src="Images/f08005.png" alt="f08005" width="652" height="750"/>
<figcaption><p><a id="figure8-5">Figure 8-5:</a> Hook clips connect to the SPI pins </p></figcaption>
</figure>
<h4 id="h3-500907c08-0002">Communicating with the SPI Chip</h4>
<p class="BodyFirst">You’ll need a USB-to-serial adapter to read the memory chip’s contents. We’ll use the Bus Pirate in this example, but you could use any adapter, because most support read operations. If you use the Bus Pirate, make sure you upgrade its firmware to the latest stable release. </p>
<p>Make sure the device whose memory you’re extracting is powered off; then make the connections. Connect the Bus Pirate’s pins and the chip’s pins using the SOIC clip, as the datasheet indicates. For example, we’d connect the pins for the WinBond 25Q64 chip as shown in <a href="#table8-1" id="tableanchor8-1">Table 8-1</a>. </p>
<figure>
<figcaption class="TableTitle"><p><a id="table8-1">Table 8-1</a>: Connecting the Pins</p></figcaption>
<table id="table-500907c08-0001" border="1">
<thead>
<tr>
<td><b>Device/Bus Pirate</b></td></tr>
</thead>
<tbody>
<tr>
<td>Pin #1 (CS) <span class="Wingdings">→</span> CS</td></tr>
<tr>
<td>Pin #2 (DO) <span class="Wingdings">→</span> CIPO (MISO)</td></tr>
<tr>
<td>Pin #4 (GND) <span class="Wingdings">→</span> GND</td></tr>
<tr>
<td>Pin #5 (DI) <span class="Wingdings">→</span> COPI (MOSI)</td></tr>
<tr>
<td>Pin #6 (CLK) <span class="Wingdings">→</span> CLK</td></tr>
<tr>
<td>Pin #8 (VCC) <span class="Wingdings">→</span> 3V3</td></tr>
</tbody>
</table>
</figure>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<span epub:type="pagebreak" title="195" id="Page_195"/>
<h2><span class="NoteHead">NOTE</span></h2>
<p>Your board or diagrams could be labeled using the old SPI signal names MISO and MOSI instead of CIPO and COPI, respectively. You might also encounter the outdated master/slave terms instead of controller/peripheral in diagrams and boards for I<sup>2</sup>C. </p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<p>When you’re done, your connections should look like those in <a id="figureanchor8-6" href="#figure8-6">Figure 8-6</a>. </p>
<figure>
<img src="Images/f08006.png" alt="f08006" width="750" height="563"/>
<figcaption><p><a id="figure8-6">Figure 8-6:</a> The Bus Pirate connected to the SPI chip with hook clips. We used Helping Hands to hold the different components.</p></figcaption>
</figure>
<p>Now, while the device whose memory you’ll read is powered off, connect the Bus Pirate’s USB cable to your computer. You can test your communication with the SPI chip using the <code>flashrom</code> Linux utility, which you can download from<em> </em><a href="https://flashrom.org/Flashrom" class="LinkURL">https://flashrom.org/Flashrom</a> (or most package managers). The following command will identify the memory chipset:</p>
<pre><code><em>#</em><em> </em><b>flashrom -p buspirate_spi:dev=/dev/</b><var class="bold">ttyUSB0</var></code></pre>
<p>Make sure you replace <code>ttyUSB0</code> with the device descriptor to which the USB-to-serial adapter has been assigned. It will usually be something like <code>ttyUSB</code><em>&lt;number&gt;</em>, and you can issue the <code>ls /dev/tty*</code> command to see the descriptors on your system. The utility will either identify the SPI chip or return the message <code>No EEPROM/flash device found</code>.</p>
<h4 id="h3-500907c08-0003"><span epub:type="pagebreak" title="196" id="Page_196"/>Reading the Memory Chip Contents</h4>
<p class="BodyFirst">Once you’ve established communication with the chip, you can perform a read operation to obtain its contents. Issue a read operation using the following <code>flashrom</code> command:</p>
<pre><code># <b>flashrom</b><b> -p </b><b>buspirate_</b><b>spi:dev</b><b>=/dev/</b><var class="bold">ttyUSB0</var><b> -r </b><b>out.bin</b><b> </b></code></pre>
<p>The <code>-r</code> flag issues a read operation that saves the contents in the specified file. The <code>-p</code> flag specifies the adapter’s name. The Bus Pirate’s name in this context is <code>buspirate_spi</code>, but you should change this name if you’re using another adapter. You should see output similar to the following: </p>
<pre><code>Found Winbond flash chip “W25Q64.V” (8192 kB, SPI).
Block protection is disabled.
Reading flash…</code></pre>
<p>Once the command is done running, the output file should match the chip storage size listed in the command output. For this chipset, it was 8MB.</p>
<p>Alternatively, you can get the chip’s contents using the popular <em>spiflash.py</em> script from libmpsse. Download the library, created by devttys0, from <a href="https://github.com/devttys0/libmpsse/" class="LinkURL">https://github.com/devttys0/libmpsse/</a>, then compile and install it: </p>
<pre><code># <b>cd libmpsse</b>
# <b>./configure &amp;&amp; make</b>
# <b>make install</b></code></pre>
<p>If everything worked, you should be able to run <em>spiflash.py</em>. To make sure the tool detects the chip correctly and that all your pin connections are correct, execute <em>spiflash.py</em> and look for the chipset name in the output. To extract the memory stored in the chip, enter the following command:</p>
<pre><code># <b>spiflash.py -r </b><b>out.bin</b><b> -s </b><b><i>&lt;size to read&gt;</i></b> </code></pre>
<p>For example, to read 8MB, run this command:</p>
<pre><code># <b>spiflash.py -r </b><b>out.bin</b><b> -s $((0x800000))</b></code></pre>
<p>If you don’t know the size of the flash memory to extract, choose a random value large enough to hold the entire flash memory’s contents. </p>
<p>Now that you’ve extracted the flash memory, you could run the <code>strings</code> utility to begin looking at the information or perform further analysis with tools like binwalk. You can learn more about firmware security testing in Chapter 9.</p>
<h2 id="h1-500907c08-0003"><span epub:type="pagebreak" title="197" id="Page_197"/>I<sup>2</sup>C</h2>
<p class="BodyFirst">Pronounced “I squared C,” <em>I<sup>2</sup>C</em> is a serial communication protocol for low-speed devices. Phillips Semiconductors developed I<sup>2</sup>C in the 1980s for communications between components on the same circuit board, but you can also use it between components connected via cable. In the IoT world, you’ll often find it in microcontrollers, I/O interfaces like keyboards and buttons, common household and enterprise devices, and sensors of all types. Crucially, even the sensors in many Industrial Control Systems (ICS) use I<sup>2</sup>C, making its exploitation high stakes. </p>
<p>The main advantage of this protocol is its simplicity. Instead of the four wires that SPI uses, I<sup>2</sup>C has a two-wire interface. In addition, the protocol allows hardware without built-in I<sup>2</sup>C support to use I<sup>2</sup>C through general purpose I/O pins. But its simplicity, and the fact that all data travels over the same bus, makes it an easy target if you want to sniff or inject your own data. The reason is that no authentication occurs between components in IoT devices sharing the same I<sup>2</sup>C bus.</p>
<h3 id="h2-500907c08-0003">How I<sup>2</sup>C Works</h3>
<p class="BodyFirst"><span class="ColorText" style="color:#000000"> I<sup>2</sup>C</span>’s simplicity allows hardware to exchange data with no strict speed requirements. The protocol uses three lines: the serial data line (SDA) for transmitting data, the serial clock line (SCL) to determine when the data gets read, and the ground line (GND). SDA and SCL lines are connected to the peripherals and they’re <em>open drain drivers</em>, meaning that both lines need to be connected to resistors. (You’ll need only one resistor for each line, not one for every peripheral.) Voltages vary from 1.8 V, 3.3 V, and 5.0 V, and transfers can occur at four different speeds: 100 kHz, or the initial speed according to I<sup>2</sup>C specifications; 400 kHz, which is the fast mode; 1 MHz, called high speed mode; and 3.2 MHz, called ultrafast mode.</p>
<p>Like SPI, I<sup>2</sup>C uses a controller-peripheral configuration. The components transfer data over the SDA line, bit by bit, in eight-bit sequences. The controller, or multiple controllers, manages the SCL line. An I<sup>2</sup>C architecture supports more than one controller and one or more peripherals, each with unique addresses used for communication. <a href="#table8-2" id="tableanchor8-2">Table 8-2</a> shows the structure of a message sent from a controller to a peripheral.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table8-2">Table 8-2</a>: An I<sup>2</sup>C Message Sent to a Peripheral over SDA</p></figcaption>
<table id="table-500907c08-0002" border="1">
<tbody>
<tr>
<td>START</td><td>I<sup>2</sup>C address<br/>
(7 or 10 bits)</td><td>Read/Write bit</td><td>ACK/NACK bit</td><td>Data<br/>
(8 bits)</td><td>ACK/NACK bit</td><td>Data<br/>
(8 bits)</td><td>STOP</td></tr>
</tbody>
</table>
</figure>
<p><span epub:type="pagebreak" title="198" id="Page_198"/>The controller begins each message with a START condition that signals the beginning of the message. Then it sends the peripheral’s address, which is usually 7 bits long but can be as long as 10 bits. This allows for up to 128 (if using 7-bit addresses) or 1024 peripherals (if using 10-bit addresses) on the same bus. The controller also appends a Read/Write bit that indicates the kind of operation to perform. An ACK/NACK bit indicates what the following data segment will be. SPI divides the actual data into eight-bit sequences, each of which ends in another ACK/NACK bit. The controller ends the message by sending the STOP condition. For more information about the protocol, visit <a href="https://www.i2c-bus.org/" class="LinkURL">https://www.i2c-bus.org/.</a></p>
<p>As mentioned previously, the I<sup>2</sup>C protocol supports multiple controllers on the same bus. This is important, because by connecting to the bus, we could act as another controller, and then read and send data to the peripherals. In the next section, we’ll set up our own I<sup>2</sup>C bus architecture so we can do exactly that.</p>
<h3 id="h2-500907c08-0004">Setting Up a Controller-Peripheral I<sup>2</sup>C Bus Architecture</h3>
<p class="BodyFirst">To demonstrate how to sniff I<sup>2</sup>C communications and write data to peripherals on the bus, let’s set up a classic controller-peripheral architecture with some help from the following open source hardware:</p>
<ul>
<li>The Arduino Uno microcontroller (<a href="https://store.arduino.cc/usa/arduino-uno-rev3/" class="LinkURL">https://store.arduino.cc/usa/arduino-uno-rev3/</a><em>)</em> to act as the controller.</li>
<li>One or more BlinkM I<sup>2</sup>C-controlled RGB LEDs (<a href="https://www.sparkfun.com/products/8579/" class="LinkURL">https://www.sparkfun.com/products/8579/</a>) to act as peripherals. You can find the complete BlinkM documentation, including examples of other ways to program them, at <a href="https://thingm.com/products/blinkm/" class="LinkURL">https://thingm.com/products/blinkm/</a>.</li>
</ul>
<p>We chose to use the Arduino Uno because the analog pins it uses for SDA and SCL have built-in resistors, so we won’t need to add pull-up resistors to the circuit. Also, this lets us use Arduino’s official <em>Wire</em> library<em> </em>to manage the I<sup>2</sup>C bus as the controller and send commands to the I<sup>2</sup>C peripherals. <a href="#table8-3" id="tableanchor8-3">Table 8-3</a> lists the Arduino Uno analog pins that support I<sup>2</sup>C.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table8-3">Table 8-3</a>: Arduino Uno Pins for I<sup>2</sup>C Communications</p></figcaption>
<table id="table-500907c08-0003" border="1">
<thead>
<tr>
<td><b>Arduino analog pin</b></td><td><b>I<sup>2</sup>C pin</b></td></tr>
</thead>
<tbody>
<tr>
<td>A2</td><td>GND</td></tr>
<tr>
<td>A3</td><td>PWR</td></tr>
<tr>
<td>A4</td><td>SDA</td></tr>
<tr>
<td>A5</td><td>SCL</td></tr>
</tbody>
</table>
</figure>
<p>Identify pins A2, A3, A4, and A5 on the Arduino Uno and then connect male-to-male Dupont cables to them, as shown in <a id="figureanchor8-7" href="#figure8-7">Figure 8-7</a>.</p>
<span epub:type="pagebreak" title="199" id="Page_199"/><figure>
<img src="Images/f08007.png" alt="f08007" width="750" height="563"/>
<figcaption><p><a id="figure8-7">Figure 8-7:</a> The analog pins are located in the bottom-right corner of the Arduino Uno.</p></figcaption>
</figure>
<p>Next, identify the GND (-), PWR (+), SDA (d), and SCL (c) pins on the BlinkM LED by checking the label at the top of each pin, as shown in <a id="figureanchor8-8" href="#figure8-8">Figure 8-8</a>.</p>
<figure>
<img src="Images/f08008.png" alt="f08008" width="750" height="563"/>
<figcaption><p><a id="figure8-8">Figure 8-8:</a> The BlinkM GND, PWR, data, and clock pins are clearly labeled.</p></figcaption>
</figure>
<p><span epub:type="pagebreak" title="200" id="Page_200"/>Now, use a breadboard to connect the BlinkM LED and cables to the corresponding pins on the Arduino, as described in <a href="#table8-4" id="tableanchor8-4"/>.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table8-4">Table 8-4</a>: Arduino/BlinkM Connections</p></figcaption>
<table id="table-500907c08-0004" border="1">
<thead>
<tr>
<td><b>Arduino Uno/BlinkM RGB LED</b></td></tr>
</thead>
<tbody>
<tr>
<td>Pin A2 (GND) <span class="Wingdings">→</span> PWR -</td></tr>
<tr>
<td>Pin A3 (PWR) <span class="Wingdings">→</span> PWR +</td></tr>
<tr>
<td>Pin A4 (SDA) <span class="Wingdings">→</span> d (for data)</td></tr>
<tr>
<td>Pin A5 (SCL) <span class="Wingdings">→</span> c (for clock)</td></tr>
</tbody>
</table>
</figure>
<p><a id="figureanchor8-9" href="#figure8-9">Figure 8-9</a> shows these connections.</p>
<figure>
<img src="Images/f08009.png" alt="f08009" width="750" height="647"/>
<figcaption><p><a id="figure8-9">Figure 8-9:</a> We can connect SDA and SCL without resistors because the Arduino pins include built-in resistors.</p></figcaption>
</figure>
<p>If you have more than one I<sup>2</sup>C peripheral, connect them to the same SDA and SCL lines. Choose one line of the breadboard for SDA and another one for SCL; then connect the devices to those lines. For example, <a id="figureanchor8-10" href="#figure8-10">Figure 8-10</a> shows two connected BlinkMs. BlinkM LEDs of the same type all come with the same I<sup>2</sup>C address (0x09) by default, which is programmable, as indicated in the product datasheet available at <a href="https://www.infinite-electronic.kr/datasheet/e0-COM-09000.pdf" class="LinkURL">https://www.infinite-electronic.kr/datasheet/e0-COM-09000.pdf</a>. (This illustrates why you should always consult the datasheet, if it’s available; the information you find could save you reverse engineering efforts. In black box assessments, you might not be so lucky.)</p>
<span epub:type="pagebreak" title="201" id="Page_201"/><figure>
<img src="Images/f08010.png" alt="f08010" width="750" height="563"/>
<figcaption><p><a id="figure8-10">Figure 8-10:</a> An I<sup>2</sup>C bus supports up to 128 peripherals with 7-bit addresses.</p></figcaption>
</figure>
<p>Once you’ve connected the controller (Arduino) and peripheral (BlinkM LED), program the Arduino to join the bus and send some commands to the peripherals. We’ll use the Arduino IDE to write the program. See Chapter 7 for an introduction to the Arduino, as well as installation instructions. In the IDE, select the Arduino board you’re using by clicking <b>Tools</b><span class="MenuArrow">▶</span><b>Board</b><span class="MenuArrow">▶</span><b>Arduino/Genuino UNO</b>, and then upload the code in <a id="listinganchor8-1" href="#listing8-1">Listing 8-1</a>.</p>
<pre><code>#include &lt;Wire.h&gt;

void setup() {
  <span class="CodeAnnotationHang">1</span> pinMode(13, OUTPUT); //Disables Arduino LED
  pinMode(A3, OUTPUT); //Sets pin A3 as OUTPUT
  pinMode(A2, OUTPUT); //Sets pin A2 as OUTPUT
  digitalWrite(A3, HIGH); //A3 is PWR 
  digitalWrite(A2, LOW); //A2 is GND
  <span class="CodeAnnotationHang">2</span> Wire.begin(); // Join I<sup>2</sup>C bus as the controller
}

byte x = 0; 

void loop() {
  <span class="CodeAnnotationHang">3</span> Wire.beginTransmission(0x09);<span class="CodeAnnotation">4</span> Wire.write('c'); 
  Wire.write(0xff); 
  Wire.write(0xc4); 
  <span class="CodeAnnotationHang">5</span> Wire.endTransmission();

<span epub:type="pagebreak" title="202" id="Page_202"/>  x++;
  delay(5000);
} </code></pre>
<p class="CodeListingCaption"><a id="listing8-1">Listing 8-1:</a> The I<sup>2</sup>C controller code that will administer the BlinkM RGB LED</p>
<p>The code configures the Arduino pins for I<sup>2</sup>C communication <span class="CodeAnnotation">1</span>, joins the I<sup>2</sup>C bus as the controller <span class="CodeAnnotation">2</span>, and, using a loop, periodically sends a message to the peripherals with the address 0x09 <span class="CodeAnnotation">3</span>. The message contains commands to light up the LEDs <span class="CodeAnnotation">4</span>. You can find lengthier descriptions of these commands in the BlinkM’s datasheet. Finally, the code sends a STOP sequence to indicate the end of the message <span class="CodeAnnotation">5</span>.</p>
<p>Now connect the Arduino Uno to the computer to power the circuit and upload your code. The BlinkM RGB LEDs should receive the commands and blink accordingly (<a id="figureanchor8-11" href="#figure8-11">Figure 8-11</a>). </p>
<figure>
<img src="Images/f08011.png" alt="f08011" width="624" height="750"/>
<figcaption><p><a id="figure8-11">Figure 8-11:</a> The BlinkM LEDs receiving signals via I<sup>2</sup>C from the Arduino Uno</p></figcaption>
</figure>
<h3 id="h2-500907c08-0005">Attacking I<sup>2</sup>C with the Bus Pirate</h3>
<p class="BodyFirst">Let’s connect the Bus Pirate to our I<sup>2</sup>C bus and start sniffing communications. The Bus Pirate’s firmware has built-in support for I<sup>2</sup>C. It also has a couple of useful macros that we can use to analyze and attack I<sup>2</sup>C communications. </p>
<p>We’ll use the following pins on the Bus Pirate: COPI (MOSI), which corresponds to the I<sup>2</sup>C SDA pin; CLK, which corresponds to the SCL pin; and GND. Connect these three lines from the Bus Pirate to the I<sup>2</sup>C bus (<a href="#table8-5" id="tableanchor8-5">Table 8-5</a>) using jumper cables.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table8-5">Table 8-5</a>: Connections from the Bus Pirate to the I<sup>2</sup>C Bus <span epub:type="pagebreak" title="203" id="Page_203"/></p></figcaption>
<table id="table-500907c08-0005" border="1">
<thead>
<tr>
<td><b>Bus Pirate/Breadboard</b></td></tr>
</thead>
<tbody>
<tr>
<td>COPI (MOSI) <span class="Wingdings">→</span> SDA</td></tr>
<tr>
<td>CLK <span class="Wingdings">→</span> SCL</td></tr>
<tr>
<td>GND <span class="Wingdings">→</span> GND</td></tr>
</tbody>
</table>
</figure>
<p>Once the pins are all connected, plug the Bus Pirate into your computer. To interact with it, you’ll need to connect it to the serial communication (COM) port using the default speed of 115,200 bauds. On Linux, do this using the <code>screen</code> or <code>minicom</code> utilities: </p>
<pre><code>$ <b>screen /dev/</b><var class="bold">ttyUSB0</var><b> 115200</b></code></pre>
<p>On Windows, open the Device Manager to see the COM port number. Then use PuTTY with the configuration shown in <a id="figureanchor8-12" href="#figure8-12">Figure 8-12</a>.</p>
<figure>
<img src="Images/f08012.png" alt="f08012" width="444" height="437"/>
<figcaption><p><a id="figure8-12">Figure 8-12:</a> Configuring PuTTY to connect to the Bus Pirate</p></figcaption>
</figure>
<p>Once you’ve set the configuration in PuTTY, click <b>Open</b>. You should now have an established connection.</p>
<h4 id="h3-500907c08-0004">Detecting I<sup>2</sup>C Devices</h4>
<p class="BodyFirst">To enumerate all the I<sup>2</sup>C devices connected to the bus, use the Bus Pirate’s <em>I</em><sup>2</sup><em>C</em> library to search the entire address space. This yields all I<sup>2</sup>C chips <span epub:type="pagebreak" title="204" id="Page_204"/>connected, as well as undocumented access addresses. We begin by setting the Bus Pirate’s mode using the <code>m</code> command: </p>
<pre><code>I2C&gt;<b>m</b>
1. HiZ
2. 1-WIRE
3. UART
4. I2C
5. SPI
6. 2WIRE
7. 3WIRE
8. LCD
9. DIO
x. exit(without change)</code></pre>
<p>Select <code class="bold">4</code> to choose the I<sup>2</sup>C mode, and then set the desired speed:</p>
<pre><code>(1)&gt;<b>4</b>
Set speed:
 1. ~5KHz
 2. ~50KHz
 3. ~100KHz
 4. ~400KHz

(1)&gt;<b>4</b>
Ready</code></pre>
<p>We set a speed of <code>4</code><b>,</b> which corresponds to approximately 400 kHz, or the I<sup>2</sup>C fast rate, because the controller, the Arduino Uno, operates on that speed.</p>
<p>The <em>I</em><sup>2</sup><em>C</em> library supports two macros. The first is the <em>address search macro</em>, which will automatically try every I<sup>2</sup>C address. Then it looks for a response to determine how many peripherals are connected and if you can use any other addresses, such as broadcast addresses. Execute the macro by entering the <code>(1)</code> macro command:</p>
<pre><code>I2C&gt;<b>(</b><b>1)</b>
Searching I2C address space. Found devices at:
0x00(0x00 W) 0xFF(0x7F R)</code></pre>
<p>This macro displays the addresses, followed by the 7-bit address with a bit indicating whether the address is for reading or writing. In this case, we see the addresses 0x00(W), the BlinkM broadcast address, and 0x7F, which belongs to the BlinkM LED. </p>
<h4 id="h3-500907c08-0005">Sniffing and Sending Messages</h4>
<p class="BodyFirst">The second macro built into the Bus Pirate’s <em>I</em><sup>2</sup><em>C</em> library is the sniffer. This macro displays all <code>START/STOP</code> sequences, <code>ACK/NACK</code> bits, and data shared through <span epub:type="pagebreak" title="205" id="Page_205"/>the I<sup>2</sup>C bus. Once again, we need to put the Bus Pirate in I<sup>2</sup>C mode, select the speed, and then execute macro number two using the command <code class="bold">(2)</code>:</p>
<pre><code>I2C&gt;<b>(</b><b>2)</b>
Sniffer
Any key to exit
[0x12][0x12+0x63+]][0x12+0x63+0xFF+0xC4+][0x12+0x63+]][0x12+0x63+]][0x12+0x63+]][0x12+0x63+]][0x12+0x63+0xFF+0xC4+][0x12+0x63+0xFF+0xC4+][0x12+0xC6-0xFD-][0x12+0x63+0xFF+]]</code></pre>
<p>The captured data appears on the screen using Bus Pirate’s message format for I<sup>2</sup>C, allowing us to copy and paste the message to replay it, if desired. <a href="#table8-6" id="tableanchor8-6">Table 8-6</a> shows the syntax Bus Pirate uses to represent I<sup>2</sup>C characters.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table8-6">Table 8-6</a>: Bus Pirate Symbols Corresponding to I<sup>2</sup>C Message Components</p></figcaption>
<table id="table-500907c08-0006" border="1">
<thead>
<tr>
<td><b>I<sup>2</sup>C characters</b></td><td><b>Bus Pirate symbols</b></td></tr>
</thead>
<tbody>
<tr>
<td>START sequence</td><td>[ or {</td></tr>
<tr>
<td>STOP sequence</td><td>] or }</td></tr>
<tr>
<td>ACK</td><td>+</td></tr>
<tr>
<td>NACK</td><td>-</td></tr>
</tbody>
</table>
</figure>
<p>Corroborate that your sniffer is working correctly by matching the sniffer data with the data sent by the Arduino Uno. </p>
<p>Now, to send data to any of the peripherals on the bus, enter the message on Bus Pirate’s prompt directly or copy any message you want to replay. We can see the command structure for changing color in the traffic, and by looking at the datasheet, we can deduce its structure. Now we can test it by replaying the command:</p>
<pre><code>I2C&gt;<b>[0x12+0x63+0xFF+0xC4+]</b>
I2C START BIT
WRITE: 0x12 NACK
WRITE: 0x63 NACK
WRITE: 0xFF NACK
WRITE: 0xC4 NACK
I2C STOP BIT</code></pre>
<p>The output shows the sequence bits and data you’ve written on the bus. Analyze the bus traffic on your own devices to identify patterns, then try sending your own commands. If you used the demo I<sup>2</sup>C bus shown in this chapter, you can find more valid commands on the BlinkM’s datasheet.</p>
<p>The stakes of replaying this command are fairly low; we’re only flashing lights in patterns. But in real-world attacks, you could use the same technique to write MAC addresses, flags, or factory settings, including serial numbers. Using the same approach as we used here, you should be able <span epub:type="pagebreak" title="206" id="Page_206"/>identify I<sup>2</sup>C buses on any IoT device and then analyze the communications between components to read and send your own data. In addition, due to this protocol’s simplicity, it’s very likely you’ll find it in all kinds of devices. </p>
<h2 id="h1-500907c08-0004">Conclusion</h2>
<p class="BodyFirst">In this chapter, you learned about two of the most common protocols found in IoT devices at the hardware level: SPI and I<sup>2</sup>C. Fast peripherals are likely to implement SPI, whereas I<sup>2</sup>C can be implemented even in microcontrollers that don’t have it embedded by design, due its simplicity and cheap hardware requirements. The techniques and tools we discussed allow you to take apart devices and analyze them to understand their functionality for identifying security weaknesses. Throughout the chapter, we used the Bus Pirate, one of the many great tools available for interacting with SPI and I<sup>2</sup>C. This open source board has robust support for most communication protocols in IoT, including built-in macros for analyzing and attacking a wide variety of IoT devices.</p>
</section>
</div></body></html>