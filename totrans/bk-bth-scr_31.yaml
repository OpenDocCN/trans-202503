- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 28 COMPACT CONDITIONAL EXECUTION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, I’ll discuss conditional execution ... and no, this isn’t a
    chapter about the if command. It’s true that the if command is the quintessential
    example of executing code conditionally, and this chapter will revisit that discussion
    from [Chapter 4](chapter4.xhtml), but with a very different take. Batch has a
    funky construct simply called *conditional execution* that executes one or more
    commands based on the success or failure of a prior command. It’s a compact and
    streamlined alternative to the if...else construct, but there are striking differences,
    and it’s crucial that you understand them before using it.
  prefs: []
  type: TYPE_NORMAL
- en: I’ll introduce the two operators used in the conditional execution syntax, and
    you’ll see something that’s very similar to, but not identical to, an if...else
    construct. I’ll demonstrate how to successively execute several commands where
    if any one command fails, the rest won’t execute. Flipping the script, I’ll then
    show how to successively execute several commands where if any one command *succeeds*,
    the rest won’t execute.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Execution Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In many languages, the double ampersand (&&) is the and operator and the double
    pipe (||) is the or operator, and in [Chapter 27](chapter27.xhtml), I detailed
    how Batch doesn’t support this functionality. Instead, the conditional execution
    syntax employs the double ampersand and the double pipe as operators, which produces
    a level of cognitive dissonance for coders versed in other languages, but these
    operators offer a unique and very succinct alternative to the if command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The **&&** Operator**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following general syntax, command1 always executes, and command2 executes
    only if the value of errorlevel is 0 after the completion of command1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: A single ampersand separates two commands that execute unconditionally, but
    the extra ampersand invokes the conditional logic. For lack of a better term,
    this is the positive conditional execution operator.
  prefs: []
  type: TYPE_NORMAL
- en: '**The **||** Operator**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Replacing the ampersands with pipes negates the logic. In the following example,
    command2 executes only if the value of errorlevel is *not* 0 after the completion
    of the first command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A single pipe (appropriately enough) pipes the output of one command to another,
    but here nothing is being piped to the second command, which might not even execute
    at all because of the negative conditional operator.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Single Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an alternative to an if command, you can often use a single conditional execution
    operator to streamline your code, but first you need to compare and contrast the
    two methods.
  prefs: []
  type: TYPE_NORMAL
- en: Positive Conditional Execution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To demonstrate, [Listing 28-1](#Lis28-1) offers this straightforward and easy-to-read
    example that creates an empty file and checks the return code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-1: Empty file creation with error handling'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using conditional execution, this one line of code is functionally equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the copy command creates the empty file and returns 0, the echo command writes
    the message to the console. In essence, the && is synonymous with if %errorlevel%
    equ 0. If the copy command fails to create the empty file, it returns a value
    other than 0 as the return code, and the echo command doesn’t execute.
  prefs: []
  type: TYPE_NORMAL
- en: Because errorlevel is only implied in the conditional execution syntax, its
    value doesn’t find its way into stdout, sometimes obscuring whether certain code
    ever executed. If it’s important that you can find the value of the return code
    in the trace file, the more verbose option is the wise choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The conditional execution syntax can be a very succinct (some may say cryptic)
    alternative to an if command, but when you rewrite it to span multiple lines,
    it’s more readable and more closely resembles an if command. You can initiate
    a code block by placing an open parenthesis after the && operator. Then you can
    make your code block out of one or more commands before terminating it with a
    trailing close parenthesis. The following is functionally equivalent to both of
    the prior listings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Comparing this to [Listing 28-1](#Lis28-1), I’ve reduced the code by one line
    and replaced the if command along with its conditional clause with the && operator.
    The code is clearly condensed, but whether it’s simplified depends on the reader’s
    knowledge of conditional execution.
  prefs: []
  type: TYPE_NORMAL
- en: Negative Conditional Execution
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now, let’s make some modifications to this logic to experiment with the negative
    conditional execution operator. First, let’s use a folder that doesn’t exist.
    (Spoiler alert: the copy command fails to create an empty file.) Second, let’s
    change && to the || operator and make the message reflect a failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now the echo command executes only when the copy command fails, because when
    it fails, it also sets errorlevel to 1. If the command creates the file successfully,
    it sets the return code to 0, and the interpreter writes nothing to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Real-World Applications
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: There’s no shortage of applications; I’ll detail a couple here that use a single
    conditional execution operator.
  prefs: []
  type: TYPE_NORMAL
- en: Text Searches
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One scenario starts with a variable holding a program name. If you can find
    a particular server name in its path, you might want to call a certain process
    contained in an internal routine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code searches the contents of progName for the value of svrName,
    calling a routine if it finds the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The echo command pipes the program name into the findstr command, which sets
    errorlevel to 0 if it finds the server name in the input text. Don’t be fooled
    by the single pipe; that’s not conditional execution, but the double ampersands
    do represent this technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, using the || operator instead results in the following code calling
    a different routine, but only when it doesn’t find the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This example also starkly illustrates the difference between a pipe and double
    pipes.
  prefs: []
  type: TYPE_NORMAL
- en: Calling Another Bat File
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: One popular usage of conditional execution is the validation of a call command
    when the argument is a variable containing the name of a bat file to invoke, but
    there are some common pitfalls to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this demonstration, the calledBat variable might contain the path and name
    of a valid bat file, but it might also contain junk resulting in a failed call
    command. A failure triggers the interpreter to set errorlevel to a value of 1,
    so it’s quite understandable if you were to use the || operator with the following
    error handling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: However, if the call command successfully calls the bat file, the interpreter
    doesn’t set errorlevel to 0—in fact, it doesn’t change the return code at all.
    It’s probably a bug, but that doesn’t change the coder’s plight. If the call command
    is successful, the return code holds the value returned by the last command to
    update it.
  prefs: []
  type: TYPE_NORMAL
- en: I’m making note of this because it’s very easily overlooked. You can test this
    code with a bad bat file, and it’ll work—that is, it’ll write out the error message.
    Then you can test it again with a good bat file, and it’ll probably appear to
    work—that is, it won’t write the message—but it *worked* only because errorlevel
    just happened to be set to 0 before the call command executed, which is something
    you might not always be able to count on. Earlier, I had suggested against using
    conditional execution with the robocopy command because of its unconventional
    return code. I’m not suggesting the same when using commands that don’t universally
    reset the return code, such as the call command, but I do recommend a certain
    level of diligence. There’s a potential, yet very correctable, problem lurking
    with this type of command and conditional execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The return code issue should in no way preclude your use of this technique.
    In fact, the same issue exists if you were to evaluate the return code in a traditional
    if command after the execution of the call command. Remember that this technique
    is a glorified way of comparing the contents of errorlevel to a specific value,
    namely, 0. To make this work, you need the value of the return code to be 0 before
    the call command executes. The following cmd command ensures that you reset the
    return code just before the call command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The final concern here is that some command in the called bat file might set
    errorlevel to a nonzero value upon its completion. Unfortunately, this error handling
    treats the bad return code no differently than a failed call of the bat file.
    In this context, both present simply as a nonzero errorlevel after the call command,
    resulting in the possibility of an unrelated failure in the called bat file incorrectly
    triggering the echo command stating that the bat file is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: The best solution is an agreement between the two bat files. The called bat
    file can use an exit /B 0 command to ensure that it always returns 0 at the end
    of a successful invocation. Error handling between the two bat files might take
    on another form, perhaps a parameter containing a descriptive error message, where
    the called bat file sets it to null as an indication of a successful execution.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a very useful tool, but you must consider all possible values of errorlevel
    at different stages of the process flow. This advice is even more critical when
    multiple conditional execution operators are used in tandem.
  prefs: []
  type: TYPE_NORMAL
- en: Using Multiple Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Alone, these operators are fairly straightforward, but it gets interesting and
    useful when you use them together.
  prefs: []
  type: TYPE_NORMAL
- en: A Pseudo if...else Construct
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You’ve learned that a pseudo-random number isn’t random, but it’s close; likewise,
    a pseudo if...else construct isn’t really an if...else construct, but it’s close.
    The following code looks remarkably similar to just such a construct, and it acts
    quite a bit like one as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: I’m using the && operator in place of the if command and its conditional clause;
    even more oddly, the || operator is taking the place of the else keyword (and
    looking a little like a failed attempt at an emoji nestled in between the close
    and open parentheses). In practice, this usually behaves like an if...else construct.
    The copy command tries to create an empty file; if successful, the first echo
    command executes, and if not, the second echo writes a different message. That’s
    exactly what an if...else construct would do, but this technique has a major batveat.
  prefs: []
  type: TYPE_NORMAL
- en: If something inside the first code block sets errorlevel to a nonzero value
    upon its completion, this construct also triggers the second code block. In this
    example, each code block consists of a single echo command, but it isn’t hard
    to imagine more complex logic between the parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: This is incredibly counterintuitive; if this code successfully creates *Empty.dat*,
    the first echo command executes, but if that command fails, the echo command from
    what might be thought of as the else code block also executes. An if...else construct
    that can execute both code blocks isn’t a true if...else construct.
  prefs: []
  type: TYPE_NORMAL
- en: In this particular instance, this behavior might be perfectly acceptable because
    it’s unlikely if not impossible for a simple echo command to the console to produce
    a failure, but anything complex enough to reset errorlevel in the first code block
    is ill-advised. Because of this batveat, I don’t use this particular technique
    often, but the next couple of examples demonstrate its true usefulness.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple && Operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Conditional execution is most powerful and useful when you execute multiple
    similar commands consecutively and want to address the error handling en masse.
    For instance, you can copy four distinct files to a target path with four distinct
    xcopy commands. The goal might be to abort the execution if any one of the four
    copies fails, but it doesn’t matter which one fails. At the same time, I don’t
    want to redundantly interrogate the return code four different times. You can
    accomplish that with two different methods, one with and one without conditional
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'In lieu of conditional execution, this method concatenates the value of the
    errorlevel variable from each copy attempt. For this demonstration, I’ll just
    write an error message to the console instead of aborting. Assuming that the four
    source files and the target path are defined earlier in the code, this listing
    performs the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: After the first xcopy command, I set cmlRC (cumulative return code) to the value
    of errorlevel. Then I concatenate the errorlevel returned from the next two commands
    onto the end of cmlRC. Finally, I concatenate the three return codes of cmlRC
    with the errorlevel from the last xcopy command and compare it to 0 in the conditional
    clause of the if command. The interpreter is smart enough to perform a numeric
    compare—four zeros are considered to be equal to one zero. (If each side of the
    conditional clause had been encased in double quotes, Batch would’ve treated them
    like strings, unequal strings to be precise—that is, 0000 equals 0, but "0000"
    doesn’t equal "0".)
  prefs: []
  type: TYPE_NORMAL
- en: If only the second xcopy fails, the left side of the conditional clause might
    resolve to 0400. Since that isn’t equal to 0, the error handling logic initiates.
    This works, it’s readable, and it has its place in the Batch canon, but now let’s
    compare it to a solution using conditional execution.
  prefs: []
  type: TYPE_NORMAL
- en: The syntax has a couple variants. The first requires all of the commands to
    be on one line, which we can make more readable with carets acting as continuation
    characters, as shown in [Listing 28-2](#Lis28-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-2: Multiple && operators followed by a || operator'
  prefs: []
  type: TYPE_NORMAL
- en: Conditional execution allows us to streamline this logic quite a bit compared
    to the prior method, but it isn’t nearly as intuitive.
  prefs: []
  type: TYPE_NORMAL
- en: Each && operator separates a pair of xcopy commands, meaning that if the first
    command succeeds, the next one executes, and if it succeeds, the third executes,
    and if all of these did not fail, the final xcopy command also executes. The ||
    operator at the front of the last line of code indicates that the echo command
    executes only if—and immediately after—any one of the xcopy commands fails. This
    is a subtle and important point resulting in these two methods *not* being functionally
    equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: In the concatenation method, all four xcopy commands execute before we examine
    the complete set of return codes, regardless of any earlier failures. In the conditional
    execution method, if one command fails, execution skips immediately to the error
    handling after the two pipes. But how exactly does it work?
  prefs: []
  type: TYPE_NORMAL
- en: Assume for a moment that the first xcopy works. Seeing the && operator before
    the next xcopy command, the interpreter checks the return code. It’s 0, so that
    second command also executes, but assume that it fails because of a lack of disk
    space. The && operator in front of the third command again tells the interpreter
    to check the return code. This time it isn’t 0; the interpreter skips over the
    third command to find the third and last && operator. Since errorlevel is still
    nonzero, the fourth command doesn’t execute. Next, the interpreter finds the ||
    operator and executes the echo command precisely because errorlevel isn’t equal
    to 0. Only if all four xcopy commands execute successfully (that is, each returns
    0) will the echo command not execute.
  prefs: []
  type: TYPE_NORMAL
- en: So, if there’s any value in executing all of the commands even if one fails,
    the return code concatenation method is preferred. But typically, if one failed
    copy means that you will abort the execution, it’s pointless to even attempt the
    other copies. In this instance, it’s more efficient to not bother with the other
    attempts; hence, the conditional execution method is optimal. Choose the one that
    works best for your situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'I hinted earlier about an alternate syntax for this application of conditional
    execution. For those who appreciate the aesthetics of parentheses over carets,
    the following version of the code is functionally equivalent to the prior listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Which one is easier to read is subject to debate. I like both and don’t have
    a strong opinion on the matter (which in itself may be as odd as either syntax).
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*When using conditional execution with multiple operators, I usually indent
    the continued line just two spaces to differentiate it from a code block, which
    I usually indent three spaces. Sometimes I’ll indent a continued line more than
    three spaces, but I never indent it exactly three.*'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple || Operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s turn the last scenario on its head. We’ll have the same xcopy commands,
    and we don’t necessarily want all of them to execute. The difference is that we
    need just one of the copies to work. Perhaps a resource file has multiple possible
    locations, with a hierarchy dictating the order of selection. If we successfully
    copy one file, we’ll want to skip over the later copy attempts and call some process
    that uses the file, but to keep this as simple as possible an echo command will
    simply declare the success instead.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, assuming that the source files and the target path are defined earlier
    in the code, the code in [Listing 28-3](#Lis28-3) copies at most one file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 28-3: Multiple || operators followed by a && operator'
  prefs: []
  type: TYPE_NORMAL
- en: Compared to [Listing 28-2](#Lis28-2), the most striking difference here is that
    multiple || operators separate the xcopy commands and a && operator comes before
    the trailing command. A more subtle difference is that the xcopy commands make
    up the entirety of a code block.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s step through the logic assuming that none of the source files exists.
    The first xcopy command executes unconditionally, and it fails, setting errorlevel
    to 4; the nonzero return code and the first || operator trigger the second xcopy
    command, which also fails; two more || operators and two more failures result
    in the final two xcopy commands executing and failing. The last failure sets errorlevel
    to 4 as control exits the first code block. The interpreter immediately finds
    the && operator, quickly checks errorlevel, sees that it isn’t 0, and does *not*
    execute the echo command.
  prefs: []
  type: TYPE_NORMAL
- en: It gets even more interesting when one of the copies works. Imagine that the
    first xcopy command successfully copies the file denoted by sorc1 to the target
    path. Because of the good return code and the first || operator, the interpreter
    doesn’t execute the next xcopy command. Furthermore, it doesn’t even recognize
    the third and fourth commands. This is easier to visualize when you consider that
    the four xcopy commands are really all part of the same line of continued code.
    Once the interpreter determines that the command after a || operator won’t execute,
    nothing that comes after it will execute.
  prefs: []
  type: TYPE_NORMAL
- en: More interesting yet, control now exits the first code block after the one successful
    copy where the interpreter finds the && operator. Since errorlevel equals 0 from
    the first xcopy command, which was successful, the code block with the echo command
    executes.
  prefs: []
  type: TYPE_NORMAL
- en: If the first xcopy command fails and the second is successful, the third and
    fourth don’t execute because of the second || operator, but the echo command executes
    because of the && operator trailing the first code block. Likewise, if the third
    or fourth xcopy commands are the first to copy a file successfully, the echo command
    also executes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The parentheses are crucial in this example. In the prior section, four commands
    were separated by && operators, with the last command coming after the || operator.
    In this example, the operators are reversed, demonstrating a significant difference
    between them. I’ll address why the parentheses are in place momentarily, but first,
    since one of the primary reasons to use this conditional execution syntax is to
    condense the code, notice the following five lines of code are functionally equivalent
    to the prior listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: I’m not fond of this syntax, because it does violate my convention concerning
    the alignment of the open and close parentheses of a naked code block ([Chapter
    16](chapter16.xhtml)). However, it’s nothing if not concise, but I find the version
    with more whitespace more readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the same basic logic with a pseudo if...else construct to write a message
    indicating either the success or failure to copy one file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This does come with the obligatory batveat that if the first echo command somehow
    manages to reset errorlevel to a nonzero value, the second echo command will also
    execute.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple && vs. Multiple || Operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: I promised more details on why the parentheses are in place when using multiple
    || operators in [Listing 28-3](#Lis28-3) but not with the multiple && operators
    in [Listing 28-2](#Lis28-2).
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand, first take this generic syntax of multiple commands separated
    by && operators with a trailing || operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Assume that command1 returns 0. If so, command2 executes; assume it fails to
    return 0. Because of the && operator prior to command3, the interpreter doesn’t
    execute the command, skipping over it instead to find another && operator; errorlevel
    is still nonzero, so it also skips command4. It finds yet another && operator,
    so command5 doesn’t execute. But then the interpreter finds the || operator, and
    the nonzero errorlevel from the second command triggers the execution of command6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s flip each of the conditional execution operators. This is more like
    the scenario where we wanted a single command to execute successfully, but no
    more than one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This time let’s assume that command1 returns something other than 0. Because
    of the || operator before command2, the second command also executes; now assume
    it executes successfully and returns 0. Because of the || operator after it, the
    logical flow skips command3. This is where it gets interesting.
  prefs: []
  type: TYPE_NORMAL
- en: The interpreter does *not* continue to look for another operator. The line is
    abandoned right there, regardless of the subsequent commands and operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s significant and the reason why I included the parentheses in [Listing
    28-3](#Lis28-3) along with the multiple || operators. Consider this apparently
    minor tweak to the prior syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: With a set of parentheses surrounding the commands separated by || operators,
    the first command again executes unconditionally. The other commands in the parentheses
    execute only if the one prior to it fails. It doesn’t matter how many execute;
    after any one of these commands succeeds or after they all fail, control exits
    the logic inside the parentheses. The interpreter immediately encounters the &&
    operator, where command6 executes only if one command (the last command to execute)
    returned 0.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t assume anything when using multiple conditional execution operators; always
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If nothing else is to be taken away from this chapter, && isn’t an and operator
    and || isn’t an or operator. They are the conditional execution operators that
    evaluate errorlevel being equal to 0 or not equal to 0, respectively. I’ve detailed
    in depth how each works alone, together, and in series.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional execution is similar to the if command, but you’ve learned the important
    differences that you must know before you can use this technique successfully.
    Although it isn’t ideal in all situations, it does offer a very concise alternative
    syntax. I also explained an important difference between how the interpreter handles
    both operators and demonstrated some real-world applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I’ll return to the concept of building tools in Batch that
    were not imagined at its onset, namely, arrays and hash tables.
  prefs: []
  type: TYPE_NORMAL
