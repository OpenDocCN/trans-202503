- en: APPENDIX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: INSTALLING HASKELL
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This appendix explains how to install the Glasgow Haskell Compiler and libraries
    other people have written.
  prefs: []
  type: TYPE_NORMAL
- en: Installing GHC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Glasgow Haskell Compiler (GHC) is the Haskell compiler we use in this book.
    It is free, open source software anyone can download and install.
  prefs: []
  type: TYPE_NORMAL
- en: The installation procedure depends on which operating system you use. For GNU/Linux
    and macOS users, I recommend going to [*https://www.haskell.org*](https://www.haskell.org)
    and choosing **Downloads**. Follow the instructions for your operating system.
    You will know you have succeeded when you can start the GHCi interactive compiler,
    usually by typing `ghci` at the command prompt. At this point, you are ready to
    get started with [Chapter 1](ch01.xhtml). In addition to GHC itself, the installation
    method you use will install either Cabal or Stack. Cabal and Stack are the two
    most common tools for installing additional library packages. I describe their
    use later in this appendix.
  prefs: []
  type: TYPE_NORMAL
- en: For Microsoft Windows users, I recommend following the instructions at [https://www.fpcomplete.com/haskell/get-started/windows](https://www.fpcomplete.com/haskell/get-started/windows).
    FPComplete is a company that provides services for industrial Haskell users. The
    installer they provide will install both the Glasgow Haskell Compiler and the
    Stack library package manager. You will know you have succeeded when you can start
    the GHCi interactive compiler and obtain a GHCi prompt by typing `stack ghci`
    at the PowerShell prompt. At this point, you are ready to get started with [Chapter
    1](ch01.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Text Editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To write source code files, you will need a text editor. You can use a basic
    text editor like Notes on macOS or gedit on Linux, or you can choose from a number
    of more sophisticated text editors available. These more sophisticated editors
    often have helpful features for programmers, like text highlighting, that can
    often be configured to be sensitive to the language you are programming in.
  prefs: []
  type: TYPE_NORMAL
- en: You can find advice for getting your Haskell environment to work smoothly with
    your editor on the Haskell wiki at [*https://wiki.haskell.org/Haskell*](https://wiki.haskell.org/Haskell).
    Good editors for Haskell are Emacs, Vim, Visual Studio Code, and Atom. Simple
    text editors like Notes are typically included with the operating system. Emacs
    is available at [https://www.gnu.org/software/emacs](https://www.gnu.org/software/emacs),
    Vim is available at [https://www.vim.org](https://www.vim.org), Atom is available
    at [https://atom.io](https://atom.io), and Visual Studio Code is available at
    [https://code.visualstudio.com](https://code.visualstudio.com). Follow the instructions
    for your operating system. (Users who want to run Emacs on macOS should download
    it from [https://emacsforosx.com](https://emacsforosx.com). This link provides
    standard Emacs built to run in the macOS environment. Since it is standard Emacs,
    it is possible to reliably customize it according to the advice you find online.
    The first stop in customization is [https://www.emacswiki.org](https://www.emacswiki.org).)
  prefs: []
  type: TYPE_NORMAL
- en: Installing Gnuplot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Beginning in [Chapter 7](ch07.xhtml), we use `gnuplot` to make graphs. `Gnuplot`
    is a stand-alone graphing program, independent of Haskell, with a web page at
    [*http://gnuplut.info*](http://gnuplut.info). Installing `gnuplot` so that it
    can be used with Haskell is a two-step process. First, you must install the `gnuplot`
    program so that it works independently from Haskell. Second, you must install
    the Haskell `gnuplot` package so that Haskell code can access `gnuplot`’s functionality.
    This section deals with installing the `gnuplot` program, while the following
    section explains how to install the Haskell `gnuplot` package.
  prefs: []
  type: TYPE_NORMAL
- en: The process for installing the `gnuplot` program depends on your operating system.
    For GNU/Linux, you can usually use your package manager. For example, on Ubuntu
    Linux, the command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: will install the `gnuplot` program.
  prefs: []
  type: TYPE_NORMAL
- en: 'On macOS, I recommend the Homebrew package manager at [https://brew.sh](https://brew.sh).
    After you follow the instructions to install Homebrew, you can issue the following
    command to install the `gnuplot` program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'On Microsoft Windows, follow the instructions at [*http://www.gnuplot.info*](http://www.gnuplot.info)
    to download the `gnuplot` installer for Windows. Run the installer, which asks
    a series of questions about where to install things and other installation details.
    Make a note of the directory in which `gnuplot` gets installed (perhaps *C:*\*Program
    Files*\*gnuplot*\*bin*). You can accept the default settings for all of the installer’s
    questions except one: when the installer gives the opportunity to “Add application
    directory to your PATH environment variable,” check that box. After the installer
    has completed its work, there is one more thing you must do. Using a file browser,
    navigate to the directory where `gnuplot` is installed and find the file named
    *wgnuplot*_*pipes*. Copy this file to a new file in the same directory called
    *pgnuplot*. If the file is named *wgnuplot*_*pipes.exe*, copy it to a new file
    in the same directory called *pgnuplot.exe*. This will allow Haskell to use `gnuplot`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, whatever your operating system, you should be able to run the
    `gnuplot` program independently from Haskell. From a command line, you would type
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After starting `gnuplot`, you should be able to issue a command at the `gnuplot`
    prompt, such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: and a window containing a plot should pop open. Once you succeed in installing
    the `gnuplot` program, you are ready to install the Haskell `gnuplot` package,
    which lets you control `gnuplot` from Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Haskell Library Packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are functions other people have written that we will want to use that
    are not included in the Prelude (the standard collection of functions available
    by default). Such functions exist in library modules that can be imported in our
    source code file or loaded directly into GHCi. There is a standard set of library
    modules that comes with GHC, and there are others you can install with Cabal or
    Stack. Library modules outside of the standard libraries are organized into *packages*,
    each containing one or more modules.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want access to the `plotFunc` function in the `Graphics.Gnuplot`
    `.Simple` module provided by the Haskell `gnuplot` package. We must install the
    `gnuplot` package.
  prefs: []
  type: TYPE_NORMAL
- en: The two major tools for installing Haskell library packages are Cabal and Stack.
    You need to use only one of these. At least one of them will be available by following
    the instructions for GHC installation.
  prefs: []
  type: TYPE_NORMAL
- en: Cabal (Common Architecture for Building Applications and Libraries) existed
    first. At the time it was written (around 2005), it was considered very important
    to minimize the number of required downloads, so Cabal was designed to install
    a global set of packages, and all applications were supposed to build against
    this common set of packages. And again, in the interest of efficiency, Cabal allowed
    only one version of each package to be installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This led to a problem: many libraries were evolving quickly, adding features
    and changing their interfaces. A common problem encountered was that an application
    might build against libraries that, in turn, depended on different versions of
    a common ancestor. This sometimes required uninstalling and reinstalling all of
    your packages, and occasionally reloading different versions of all your packages
    to build a new application. The problem was called “dependency hell” or “Cabal
    hell,” and the name tells you all you need to know about how painful it was.'
  prefs: []
  type: TYPE_NORMAL
- en: The solution was to allow multiple versions of packages to be installed, and
    Cabal now allows this.
  prefs: []
  type: TYPE_NORMAL
- en: The Stack system provides many of the same features as Cabal, and in fact can
    smoothly work alongside it, but its goals are slightly different. Stack is aimed
    at meeting the requirements of commercial users who need assurance that their
    applications will build even as the Haskell library infrastructure evolves. Stack
    calls this goal “reproducible builds.” To get reproducible builds, Stack’s default
    mode of operation is to let you specify a compiler version and a set of curated
    packages known to work properly with that compiler. The curated sets include more
    than 2,000 packages, so you are likely to find most of what you need there (and
    if you don’t, it’s not hard to specify the additional packages you want downloaded
    and built). The upside of this apparent complexity is that not only does your
    Haskell program build the same way each time, it runs the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Stack and Cabal are generally able to avoid the problem of inconsistent dependencies
    breaking the builds of large, complicated projects. There is a price for this,
    though. They may download many more packages than you expect. Stack, in particular,
    may download multiple compilers to ensure that the packages and compiler are known
    to produce consistent results. This may seem unnecessary, but it’s required by
    the way the GHC compiler works. For important, but fussy, technical reasons, the
    GHC compiler does not have a standardized “application binary interface” (ABI).
    This means you can’t use libraries compiled with one version of GHC with an application
    compiled by another. This is not a bug—it turns out that to get a pure functional
    language with lazy evaluation and decent performance, you need to give up something.
    And one of those somethings is a stable ABI.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cabal
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To load a module into GHCi, the working directory must have access to the module.
    For a module outside the standard modules provided by the GHC installation itself,
    the package that contains the module must be installed. There are two ways to
    install a package using Cabal: globally, so that the package can be accessed from
    any directory, and locally, so that it can be accessed only from the current working
    directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Cabal to Install a Package Globally
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To install the `gnuplot` package globally, issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'On my computer, this command creates or changes the file */home/walck/ .ghc/x86_64-linux-8.10.5/environments/default*,
    which contains the list of globally installed Haskell packages. After you have
    installed one or more packages globally, a Cabal command such as the one we just
    issued may fail to install a new package if Cabal cannot find a version of the
    requested package that is compatible with existing globally installed packages.
    One way to solve this problem is to rename the file containing the global package
    list and then try to install all of the packages you want simultaneously. For
    example, to install the `gnuplot`, `gloss`, and `cyclotomic` packages simultaneously,
    you would issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Because we renamed the global package list, Cabal will not find a global package
    list and consequently will make a new one.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cabal to Install a Package Locally
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To install the `gnuplot` package locally (in the current working directory),
    issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The dot at the end of the command refers to the current working directory.
    This command creates or changes a file with a name like *.ghc.environment .x86_64-linux-8.10.5*
    in the current working directory. This file contains a list of packages installed
    locally (in the current working directory). After you have installed one or more
    packages locally in some directory, a Cabal command such as the one we just issued
    may fail to install a new package if Cabal cannot find a version of the requested
    package that is compatible with existing locally installed packages. One way to
    solve this problem is to rename the file containing the local package list and
    then try to install all of the packages you want simultaneously. For example,
    to install the `gnuplot`, `gloss`, and `cyclotomic` packages simultaneously, you
    would issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Because we renamed the local package list, Cabal will not find a local package
    list and consequently will make a new one.
  prefs: []
  type: TYPE_NORMAL
- en: Using Stack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To install the `gnuplot` package using Stack, issue the command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: at the command prompt. Stack keeps track of more things behind the scenes than
    Cabal does, and global installation with Stack is usually all you need.
  prefs: []
  type: TYPE_NORMAL
- en: After installing the `gnuplot` package, you can load the `Graphics.Gnuplot`
    `.Simple` module into GHCi. If you are using Stack, you should start GHCi with
    `stack ghci` rather than `ghci`. In this way, Stack will be able to find the modules
    of the packages you have installed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here we ask for the type of the function `plotFunc`, simply to show that it
    is available now that we’ve loaded the module that defines it.
  prefs: []
  type: TYPE_NORMAL
- en: To use the `plotFunc` function in a source code file, include the line
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: at the top of your source code file.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Gloss
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Beginning in [Chapter 13](ch13.xhtml) we use `gloss` to make animations. Unlike
    `gnuplot`, `gloss` is not a stand-alone program; it is only a Haskell package.
    However, `gloss` uses the freeglut graphics libraries to do its work, and the
    freeglut functionality is supplied by non-Haskell libraries that must be installed
    separately from the `gloss` package itself. So, like installing `gnuplot`, installing
    `gloss` is a two-step process. First, you must install the non-Haskell freeglut
    libraries. Second, you must install the Haskell `gloss` package.
  prefs: []
  type: TYPE_NORMAL
- en: The procedure for installing the freeglut libraries depends on your operating
    system. For a GNU/Linux system, a command such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: should do the trick. On macOS, a command like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: is what you want. You will need to install the `brew` package manager to use
    this command. On macOS, you may also need the `xquartz` package to use freeglut,
    which you can install with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For a Microsoft Windows system, search the web for “freeglut windows” and follow
    the instructions you find.
  prefs: []
  type: TYPE_NORMAL
- en: After you install the freeglut libraries, you can install the `gloss` package
    with a command like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: depending on whether you are using Cabal or Stack.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Diagrams
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Beginning in [Chapter 22](ch22.xhtml) we use the `diagrams` package to visualize
    vector fields. Actually, the `diagrams` package is just a wrapper around three
    packages called `diagrams-core`, `diagrams-lib`, and `diagrams-contrib`. The purpose
    of the wrapper is to make it easier to install because you can issue one command
    instead of three. We will use two of these three packages plus one other. We will
    use `diagrams-core`, `diagrams-lib`, and `diagrams-cairo`.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `gloss`, the `diagrams-cairo` package uses some graphics libraries
    to do its work, and you must install these non-Haskell libraries separately from
    the `diagrams-cairo` package itself. So, like installing `gnuplot` and `gloss`,
    installing `diagrams` is a two-step process. First, you must install the non-Haskell
    graphics libraries. Second, you must install the Haskell `diagrams` packages.
  prefs: []
  type: TYPE_NORMAL
- en: The graphics libraries needed are called `cairo` and `pango`. The procedure
    for installing these libraries depends on your operating system. For a GNU/Linux
    system, a command such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: should do the trick. On macOS, you can use a similar command with the `brew`
    package manager.
  prefs: []
  type: TYPE_NORMAL
- en: After you’ve installed the `cairo` and `pango` libraries, you can install the
    `diagrams` packages with a command like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: or
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: depending on whether you are using Cabal or Stack.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Your Coding Environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As this book progresses, our code gets more complicated because we use modules
    other people have written and modules that we have written ourselves. We want
    to load some of our code into GHCi, and we also want to write stand-alone programs.
    Thus, we need a way to stay organized so that we have access to the modules we
    need so we are empowered to do the things we want to do. There are two main ways
    to stay organized:'
  prefs: []
  type: TYPE_NORMAL
- en: (1) Keep all of your source code files in a single directory. This includes
    files intended for loading into GHCi as well as stand-alone programs. Install
    packages so that this directory has access to them. Arrange for this directory
    to have access to the modules from the book.
  prefs: []
  type: TYPE_NORMAL
- en: (2) Create a fresh directory for each project you work on. See that this directory
    has access to whatever modules and packages the project needs. Each directory
    might have a *.cabal* file and, if you are using `stack`, a *stack.yaml* file.
    These files describe the requirements for your project.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend method (1), at least until you see some advantage in making a new
    directory for a new project. For the purposes of this book, the exercises you
    are asked to do are not so large that each demands its own directory.
  prefs: []
  type: TYPE_NORMAL
- en: What We Want in a Coding Environment
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before I give two specific suggestions for organizing your coding environment,
    let’s lay out what we are trying to achieve. What follows are four desired properties
    we want our coding environment to have:'
  prefs: []
  type: TYPE_NORMAL
- en: (a) We want to be able to load a source code file we have written into GHCi
    with GHCi’s `:l` command. Such a source code file may or may not have a module
    name. Such a source code file also may or may not import modules using Haskell’s
    `import` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: (b) We want to be able to load a module that someone else has written, such
    as `Graphics.Gnuplot.Simple`, into GHCi with GHCi’s `:m` command.
  prefs: []
  type: TYPE_NORMAL
- en: (c) We want to be able to produce an executable program from a source code file
    we have written. Such a source code file may or may not import modules using Haskell’s
    `import` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: (d) We want to be able to use the modules defined in this book by loading them
    into GHCi and by writing source code to `import` them.
  prefs: []
  type: TYPE_NORMAL
- en: To load a source code file into GHCi, as desired in (a), we will need to start
    GHCi in the directory where our file lives. If our source code file imports modules,
    it needs access to them. If a module our source code file imports is provided
    by a package, the current working directory must have access to that package.
    This can be either local or global access, as defined earlier in this appendix.
    If the module is defined in a source code file, such as one of the modules written
    in this book, that file must live in the working directory, or in a place where
    GHC knows to look for it.
  prefs: []
  type: TYPE_NORMAL
- en: To load a module written by someone else into GHCi, as desired in (b), the working
    directory needs to have access to the package that provides the module we wish
    to load. This can be local or global access, as described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Producing a stand-alone program, as desired in (c), is the subject of [Chapter
    12](ch12.xhtml). There, we discuss three methods to produce a stand-alone program:
    one using GHC, one using Cabal, and one using Stack. Using Cabal or Stack as described
    in that chapter is a form of method (2) since we are allowed to have only one
    *.cabal* file in each directory. However, that *.cabal* file is allowed to specify
    multiple stand-alone programs, so it is possible to use Cabal or Stack with method
    (1).'
  prefs: []
  type: TYPE_NORMAL
- en: To achieve (d), the simplest thing is to put all of the module-defining *.hs*
    files (such as *Mechanics3D.hs*, which defines the `Mechanics3D` module) into
    your working directory. Since the source code file you write is also in this directory,
    GHC will look for modules your source code file imports in the working directory
    when you load your file into GHCi, or when you compile it with GHC.
  prefs: []
  type: TYPE_NORMAL
- en: The following two sections give specific suggestions about where to put the
    modules defined in this book, which you can download at [https://lpfp.io](https://lpfp.io).
    The two suggestions are alternatives, so you need to follow only one of them.
  prefs: []
  type: TYPE_NORMAL
- en: All Code in One Directory
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As suggested earlier, the simplest method for staying organized is to put everything
    in one directory. This includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Source code files you intend to load into GHCi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source code files you intend to compile into executable programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source code files, such as *Mechanics3D.hs*, for the modules defined in this
    book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This one directory will be your working directory for all of your Haskell work.
    If you continue to program in Haskell, you will outgrow this method. You will
    want to work on different projects with different purposes and different needs,
    and you won’t want all of your code in one directory. When you get to this point,
    there are many ways forward. The Cabal and Stack tools offer many ways to organize
    your work.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we need to make sure our one working directory has access to all of
    the packages we need for the projects in this book. The following command, to
    be entered as one long line at a command prompt, will locally install all the
    packages we need for this book.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: One disadvantage of this method is that we can load the book modules with GHCi’s
    `:l` command but not with GHCi’s `:m` command, and this means we can load only
    one book module into GHCi at a time. This could be inconvenient if we want access
    in GHCi to functions defined in different book modules. One way around this is
    to make a new source code file that imports all the modules we want, and then
    load that source code file into GHCi with `:l`.
  prefs: []
  type: TYPE_NORMAL
- en: Another way around this disadvantage is to use the Stack tool to manage the
    modules from this book, as explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: One Way to Use Stack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Cabal and Stack tools provide many (maybe too many) ways for you to organize
    your work in Haskell. Here we will look at one way in detail. In this method,
    we still have one directory that contains all of our Haskell work, but this directory
    has two subdirectories: one for the book modules, and one for stand-alone programs.
    So there are three places where source code files can exist. They can live in
    the main working directory, they can live in the module subdirectory, or they
    can live in the stand-alone program subdirectory. A source code file you intend
    to load into GHCi will probably live in the main working directory.'
  prefs: []
  type: TYPE_NORMAL
- en: Stack needs two configuration files to manage things. One is named *LPFP.cabal*,
    and the other is named *stack.yaml*. These two files will live in the main working
    directory. The file *LPFP.cabal* describes the modules we want to have access
    to, as well as the executable programs we want Stack to build for us. [Listing
    A-1](#app01ex01) gives this file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing A-1: The file* `LPFP.cabal` *describing the modules we want access
    to and the executables we want produced*'
  prefs: []
  type: TYPE_NORMAL
- en: After some introductory matter appear one library stanza and two executable
    stanzas. The library stanza lists all of the modules from this book that we want
    to have access to. It says that the source code for these modules is in the subdirectory
    *src* and that these modules depend on several packages, such as `gnuplot` and
    `gloss`. The `base` module contains most of the essential libraries for the simplest
    data types. The version specification means “version 4.7 or newer, but the major
    version must be less than 5.” The “default-language” specification tells us that
    we’re using the 2010 version of the Haskell language specification, which is the
    current version. The previous version was Haskell98, which gives you a hint of
    how much time elapses between major revisions to the language.
  prefs: []
  type: TYPE_NORMAL
- en: There is one executable stanza for each stand-alone program we want Stack to
    build for us. Two are listed here, but you can have as many as you like. The first
    executable stanza describes the stand-alone program for the source code file *VisTwoSprings.hs*
    in the subdirectory called *app*. The executable program will be called *LPFP-VisTwoSprings*
    and will be available globally to run from any directory. The packages required
    by this stand-alone program are listed as well.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the `diagrams` packages are not included in the curated
    list of packages Stack uses by default, so we must list some extra packages in
    a file called *stack.yaml*. [Listing A-2](#app01ex02) shows this file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing A-2: The file stack.yaml describing the extra dependencies the modules
    in this book need*'
  prefs: []
  type: TYPE_NORMAL
- en: For each version of the compiler, Stack supports a collection of curated packages
    that are known to build with that compiler and to be generally compatible with
    each other. A compiler and package set is specified by a version number. In [Listing
    A-2](#app01ex02), `lts-18.21` in the `resolver` field means “GHC 8.10.7 and packages
    compatible with it.” This particular compiler/package collection has long-term
    support (the `lts-` prefix). This means you can count on it being around for awhile,
    typically a few years.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to live on the bleeding edge to get the features you need, there
    are snapshot collections and, for the very latest, the nightly build.
  prefs: []
  type: TYPE_NORMAL
- en: The next field, `packages` refers to packages that *you* have written, typically
    libraries useful for your own project. In [Listing A-2](#app01ex02), the packages
    are simply files in the current directory, or “`.`” in Unix-speak.
  prefs: []
  type: TYPE_NORMAL
- en: The `extra-deps` are additional packages your application depends on that are
    not part of the curated set specified by the `resolver` field. (There is in fact
    not much difference between a `package` and an `extra-dep` except that it is possible
    to write test and benchmark targets for our own packages—very important parts
    of a large application—and these are not available for `extra-deps`.)
  prefs: []
  type: TYPE_NORMAL
- en: Your first stop for questions about the *stack.yaml* file should be [https://docs.haskellstack.org/en/stable/README](https://docs.haskellstack.org/en/stable/README).
  prefs: []
  type: TYPE_NORMAL
- en: You can see the packages `diagrams-core`, `diagrams-lib`, and `diagrams-cairo`
    we are interested in. The remaining packages are packages `diagrams` depends on.
    Specific versions of these packages are listed. By the time this book appears
    in print, newer versions of these packages may be available.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the executable programs, issue the following command in the main working
    directory (the directory in which the *stack.yaml* and *LPFP.cabal* files live):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To start a GHCi session in which all of the book modules are automatically
    loaded, you can issue the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'With this method, we can load any or all of the book modules into GHCi. To
    remove a module, you can use GHCi’s `:m` command with the module prefixed by a
    minus sign. To remove the `Newton2` module, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, to add an additional module, use a plus sign prefix. To add the
    `Graphics.Gnuplot.Simple` module, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Issuing `stack ghci` will also give you the option of loading one of the executable
    programs into GHCi if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This appendix described how to install the Haskell compiler and a text editor,
    and it went over methods for installing additional library packages using Cabal
    and Stack. It also showed different ways to organize libraries and source code
    files for building projects in Haskell.
  prefs: []
  type: TYPE_NORMAL
