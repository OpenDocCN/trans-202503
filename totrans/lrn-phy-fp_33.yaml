- en: APPENDIX
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录
- en: INSTALLING HASKELL
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 HASKELL
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/common.jpg)'
- en: This appendix explains how to install the Glasgow Haskell Compiler and libraries
    other people have written.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录解释了如何安装格拉斯哥哈斯克尔编译器以及其他人编写的库。
- en: Installing GHC
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 GHC
- en: The Glasgow Haskell Compiler (GHC) is the Haskell compiler we use in this book.
    It is free, open source software anyone can download and install.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 格拉斯哥哈斯克尔编译器（GHC）是本书中使用的哈斯克尔编译器。它是免费的开源软件，任何人都可以下载和安装。
- en: The installation procedure depends on which operating system you use. For GNU/Linux
    and macOS users, I recommend going to [*https://www.haskell.org*](https://www.haskell.org)
    and choosing **Downloads**. Follow the instructions for your operating system.
    You will know you have succeeded when you can start the GHCi interactive compiler,
    usually by typing `ghci` at the command prompt. At this point, you are ready to
    get started with [Chapter 1](ch01.xhtml). In addition to GHC itself, the installation
    method you use will install either Cabal or Stack. Cabal and Stack are the two
    most common tools for installing additional library packages. I describe their
    use later in this appendix.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程取决于你使用的操作系统。对于 GNU/Linux 和 macOS 用户，我推荐访问[*https://www.haskell.org*](https://www.haskell.org)，然后选择**下载**。根据你的操作系统，按照相应的说明进行操作。你将知道安装成功，当你可以启动
    GHCi 交互式编译器，通常通过在命令提示符下输入 `ghci` 来实现。此时，你已经准备好开始学习[第 1 章](ch01.xhtml)。除了 GHC 本身，你使用的安装方法还将安装
    Cabal 或 Stack。Cabal 和 Stack 是最常用的两种安装额外库包的工具。我将在本附录后面描述它们的使用。
- en: For Microsoft Windows users, I recommend following the instructions at [https://www.fpcomplete.com/haskell/get-started/windows](https://www.fpcomplete.com/haskell/get-started/windows).
    FPComplete is a company that provides services for industrial Haskell users. The
    installer they provide will install both the Glasgow Haskell Compiler and the
    Stack library package manager. You will know you have succeeded when you can start
    the GHCi interactive compiler and obtain a GHCi prompt by typing `stack ghci`
    at the PowerShell prompt. At this point, you are ready to get started with [Chapter
    1](ch01.xhtml).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于微软 Windows 用户，我推荐按照[https://www.fpcomplete.com/haskell/get-started/windows](https://www.fpcomplete.com/haskell/get-started/windows)上的说明进行操作。FPComplete
    是一家为工业哈斯克尔用户提供服务的公司。他们提供的安装程序将同时安装格拉斯哥哈斯克尔编译器和 Stack 库包管理器。当你能够启动 GHCi 交互式编译器，并在
    PowerShell 提示符下输入 `stack ghci` 后看到 GHCi 提示符时，说明你已经成功安装。在此时，你已经准备好开始学习[第 1 章](ch01.xhtml)。
- en: Installing a Text Editor
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装文本编辑器
- en: To write source code files, you will need a text editor. You can use a basic
    text editor like Notes on macOS or gedit on Linux, or you can choose from a number
    of more sophisticated text editors available. These more sophisticated editors
    often have helpful features for programmers, like text highlighting, that can
    often be configured to be sensitive to the language you are programming in.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写源代码文件，你需要一个文本编辑器。你可以使用像 macOS 上的 Notes 或 Linux 上的 gedit 这样的基本文本编辑器，或者选择多个更复杂的文本编辑器。这些更复杂的编辑器通常具有对程序员有帮助的功能，例如文本高亮显示，且通常可以配置为根据你编写的编程语言进行敏感处理。
- en: You can find advice for getting your Haskell environment to work smoothly with
    your editor on the Haskell wiki at [*https://wiki.haskell.org/Haskell*](https://wiki.haskell.org/Haskell).
    Good editors for Haskell are Emacs, Vim, Visual Studio Code, and Atom. Simple
    text editors like Notes are typically included with the operating system. Emacs
    is available at [https://www.gnu.org/software/emacs](https://www.gnu.org/software/emacs),
    Vim is available at [https://www.vim.org](https://www.vim.org), Atom is available
    at [https://atom.io](https://atom.io), and Visual Studio Code is available at
    [https://code.visualstudio.com](https://code.visualstudio.com). Follow the instructions
    for your operating system. (Users who want to run Emacs on macOS should download
    it from [https://emacsforosx.com](https://emacsforosx.com). This link provides
    standard Emacs built to run in the macOS environment. Since it is standard Emacs,
    it is possible to reliably customize it according to the advice you find online.
    The first stop in customization is [https://www.emacswiki.org](https://www.emacswiki.org).)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Haskell 维基页面[*https://wiki.haskell.org/Haskell*](https://wiki.haskell.org/Haskell)找到关于如何使你的
    Haskell 环境与编辑器顺利配合的建议。适合 Haskell 的编辑器有 Emacs、Vim、Visual Studio Code 和 Atom。像 Notes
    这样的简单文本编辑器通常会随操作系统一起提供。Emacs 可以在[https://www.gnu.org/software/emacs](https://www.gnu.org/software/emacs)下载，Vim
    可以在[https://www.vim.org](https://www.vim.org)下载，Atom 可以在[https://atom.io](https://atom.io)下载，Visual
    Studio Code 可以在[https://code.visualstudio.com](https://code.visualstudio.com)下载。按照你操作系统的说明进行操作。（想要在
    macOS 上运行 Emacs 的用户应从[https://emacsforosx.com](https://emacsforosx.com)下载。这一链接提供了为
    macOS 环境定制的标准 Emacs。由于它是标准的 Emacs，因此可以根据你在网上找到的建议，可靠地对其进行定制。定制的第一个步骤是[https://www.emacswiki.org](https://www.emacswiki.org)。）
- en: Installing Gnuplot
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Gnuplot
- en: Beginning in [Chapter 7](ch07.xhtml), we use `gnuplot` to make graphs. `Gnuplot`
    is a stand-alone graphing program, independent of Haskell, with a web page at
    [*http://gnuplut.info*](http://gnuplut.info). Installing `gnuplot` so that it
    can be used with Haskell is a two-step process. First, you must install the `gnuplot`
    program so that it works independently from Haskell. Second, you must install
    the Haskell `gnuplot` package so that Haskell code can access `gnuplot`’s functionality.
    This section deals with installing the `gnuplot` program, while the following
    section explains how to install the Haskell `gnuplot` package.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第 7 章](ch07.xhtml)开始，我们使用`gnuplot`来制作图表。`Gnuplot`是一个独立的图形程序，与 Haskell 无关，官网为[*http://gnuplut.info*](http://gnuplut.info)。安装`gnuplot`使其可以与
    Haskell 一起使用是一个两步过程。首先，你需要安装`gnuplot`程序，使其能独立于 Haskell 运行。其次，你需要安装 Haskell 的`gnuplot`包，使得
    Haskell 代码能够访问`gnuplot`的功能。本节内容涉及安装`gnuplot`程序，接下来的章节将解释如何安装 Haskell 的`gnuplot`包。
- en: The process for installing the `gnuplot` program depends on your operating system.
    For GNU/Linux, you can usually use your package manager. For example, on Ubuntu
    Linux, the command
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`gnuplot`程序的过程取决于你的操作系统。对于 GNU/Linux，你通常可以使用包管理器。例如，在 Ubuntu Linux 上，使用以下命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: will install the `gnuplot` program.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将会安装`gnuplot`程序。
- en: 'On macOS, I recommend the Homebrew package manager at [https://brew.sh](https://brew.sh).
    After you follow the instructions to install Homebrew, you can issue the following
    command to install the `gnuplot` program:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 macOS 上，我推荐使用 Homebrew 包管理器，网址为[https://brew.sh](https://brew.sh)。按照安装 Homebrew
    的说明操作后，你可以执行以下命令来安装`gnuplot`程序：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'On Microsoft Windows, follow the instructions at [*http://www.gnuplot.info*](http://www.gnuplot.info)
    to download the `gnuplot` installer for Windows. Run the installer, which asks
    a series of questions about where to install things and other installation details.
    Make a note of the directory in which `gnuplot` gets installed (perhaps *C:*\*Program
    Files*\*gnuplot*\*bin*). You can accept the default settings for all of the installer’s
    questions except one: when the installer gives the opportunity to “Add application
    directory to your PATH environment variable,” check that box. After the installer
    has completed its work, there is one more thing you must do. Using a file browser,
    navigate to the directory where `gnuplot` is installed and find the file named
    *wgnuplot*_*pipes*. Copy this file to a new file in the same directory called
    *pgnuplot*. If the file is named *wgnuplot*_*pipes.exe*, copy it to a new file
    in the same directory called *pgnuplot.exe*. This will allow Haskell to use `gnuplot`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在Microsoft Windows上，按照[*http://www.gnuplot.info*](http://www.gnuplot.info)的说明下载Windows版`gnuplot`安装程序。运行安装程序，它会询问一系列问题，比如安装位置和其他安装细节。记下`gnuplot`安装的目录（可能是*C:*\*Program
    Files*\*gnuplot*\*bin*）。除了一个问题外，你可以接受安装程序的所有默认设置：当安装程序询问是否“将应用程序目录添加到你的PATH环境变量”时，勾选该选项。安装程序完成工作后，还有一件事需要做。使用文件浏览器，导航到`gnuplot`安装的目录，找到名为*wgnuplot*_*pipes*的文件。将此文件复制为同一目录下名为*pgnuplot*的新文件。如果文件名是*wgnuplot*_*pipes.exe*，将其复制为同一目录下名为*pgnuplot.exe*的新文件。这将允许Haskell使用`gnuplot`。
- en: 'At this point, whatever your operating system, you should be able to run the
    `gnuplot` program independently from Haskell. From a command line, you would type
    the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，不管你的操作系统是什么，你应该能够独立于Haskell运行`gnuplot`程序。在命令行中，你需要输入以下内容：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After starting `gnuplot`, you should be able to issue a command at the `gnuplot`
    prompt, such as
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 启动`gnuplot`后，你应该能够在`gnuplot`提示符下发出命令，比如
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: and a window containing a plot should pop open. Once you succeed in installing
    the `gnuplot` program, you are ready to install the Haskell `gnuplot` package,
    which lets you control `gnuplot` from Haskell.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 应该会弹出一个包含图形的窗口。一旦你成功安装了`gnuplot`程序，你就可以准备安装Haskell的`gnuplot`包，它允许你从Haskell控制`gnuplot`。
- en: Installing Haskell Library Packages
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Haskell库包
- en: There are functions other people have written that we will want to use that
    are not included in the Prelude (the standard collection of functions available
    by default). Such functions exist in library modules that can be imported in our
    source code file or loaded directly into GHCi. There is a standard set of library
    modules that comes with GHC, and there are others you can install with Cabal or
    Stack. Library modules outside of the standard libraries are organized into *packages*,
    each containing one or more modules.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他人编写的函数，我们希望使用，但这些函数没有包含在Prelude（默认可用的标准函数集合）中。这些函数存在于可以在源代码文件中导入或直接加载到GHCi中的库模块中。GHC附带了一组标准库模块，还有一些你可以通过Cabal或Stack安装的模块。标准库之外的库模块被组织成*包*，每个包包含一个或多个模块。
- en: Suppose we want access to the `plotFunc` function in the `Graphics.Gnuplot`
    `.Simple` module provided by the Haskell `gnuplot` package. We must install the
    `gnuplot` package.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望访问Haskell `gnuplot`包提供的`Graphics.Gnuplot` `.Simple`模块中的`plotFunc`函数。我们必须安装`gnuplot`包。
- en: The two major tools for installing Haskell library packages are Cabal and Stack.
    You need to use only one of these. At least one of them will be available by following
    the instructions for GHC installation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Haskell库包的两个主要工具是Cabal和Stack。你只需要使用其中一个。至少按照GHC安装说明，你会有其中一个工具可用。
- en: Cabal (Common Architecture for Building Applications and Libraries) existed
    first. At the time it was written (around 2005), it was considered very important
    to minimize the number of required downloads, so Cabal was designed to install
    a global set of packages, and all applications were supposed to build against
    this common set of packages. And again, in the interest of efficiency, Cabal allowed
    only one version of each package to be installed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Cabal（构建应用程序和库的通用架构）最早出现。在它编写时（大约2005年），为了最小化所需的下载量，Cabal被设计为安装一组全局包，所有应用程序都应该针对这组通用包进行构建。同样，为了提高效率，Cabal只允许安装每个包的一个版本。
- en: 'This led to a problem: many libraries were evolving quickly, adding features
    and changing their interfaces. A common problem encountered was that an application
    might build against libraries that, in turn, depended on different versions of
    a common ancestor. This sometimes required uninstalling and reinstalling all of
    your packages, and occasionally reloading different versions of all your packages
    to build a new application. The problem was called “dependency hell” or “Cabal
    hell,” and the name tells you all you need to know about how painful it was.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一个问题：许多库迅速发展，添加了新特性并改变了它们的接口。一个常见的问题是，应用程序可能会依赖那些又依赖于不同版本的共同祖先的库。这有时需要卸载并重新安装所有包，偶尔还需要重新加载所有包的不同版本来构建一个新的应用程序。这个问题被称为“依赖地狱”或“Cabal
    地狱”，这个名字足以让你了解它有多痛苦。
- en: The solution was to allow multiple versions of packages to be installed, and
    Cabal now allows this.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法是允许安装多个版本的包，Cabal 现在允许这样做。
- en: The Stack system provides many of the same features as Cabal, and in fact can
    smoothly work alongside it, but its goals are slightly different. Stack is aimed
    at meeting the requirements of commercial users who need assurance that their
    applications will build even as the Haskell library infrastructure evolves. Stack
    calls this goal “reproducible builds.” To get reproducible builds, Stack’s default
    mode of operation is to let you specify a compiler version and a set of curated
    packages known to work properly with that compiler. The curated sets include more
    than 2,000 packages, so you are likely to find most of what you need there (and
    if you don’t, it’s not hard to specify the additional packages you want downloaded
    and built). The upside of this apparent complexity is that not only does your
    Haskell program build the same way each time, it runs the same way.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Stack 系统提供了与 Cabal 类似的许多功能，事实上，它可以与 Cabal 平稳共存，但它的目标略有不同。Stack 的目标是满足商业用户的需求，这些用户需要确保他们的应用程序即使在
    Haskell 库基础设施不断发展的情况下也能正常构建。Stack 将这一目标称为“可重复构建”。为了实现可重复构建，Stack 的默认操作模式是让你指定一个编译器版本和一组已知与该编译器正常工作的精选包。精选包集包含超过
    2000 个包，因此你很可能会在其中找到大部分需要的内容（如果没有，也不难指定你希望下载和构建的其他包）。这种看似复杂的方式的好处是，你的 Haskell
    程序不仅每次都以相同的方式构建，而且以相同的方式运行。
- en: Stack and Cabal are generally able to avoid the problem of inconsistent dependencies
    breaking the builds of large, complicated projects. There is a price for this,
    though. They may download many more packages than you expect. Stack, in particular,
    may download multiple compilers to ensure that the packages and compiler are known
    to produce consistent results. This may seem unnecessary, but it’s required by
    the way the GHC compiler works. For important, but fussy, technical reasons, the
    GHC compiler does not have a standardized “application binary interface” (ABI).
    This means you can’t use libraries compiled with one version of GHC with an application
    compiled by another. This is not a bug—it turns out that to get a pure functional
    language with lazy evaluation and decent performance, you need to give up something.
    And one of those somethings is a stable ABI.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Stack 和 Cabal 通常能够避免不一致的依赖项破坏大型复杂项目构建的问题。然而，这也有代价。它们可能会下载比你预期更多的包。特别是 Stack，可能会下载多个编译器，以确保包和编译器已知能产生一致的结果。这看起来似乎不必要，但这是
    GHC 编译器工作方式所要求的。出于一些重要但繁琐的技术原因，GHC 编译器没有标准化的“应用二进制接口”（ABI）。这意味着你不能将用一个版本的 GHC
    编译的库与用另一个版本编译的应用程序一起使用。这不是一个 bug——事实证明，为了得到一个纯粹的函数式语言、惰性求值和良好的性能，你需要放弃某些东西。而其中之一就是稳定的
    ABI。
- en: Using Cabal
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 Cabal
- en: 'To load a module into GHCi, the working directory must have access to the module.
    For a module outside the standard modules provided by the GHC installation itself,
    the package that contains the module must be installed. There are two ways to
    install a package using Cabal: globally, so that the package can be accessed from
    any directory, and locally, so that it can be accessed only from the current working
    directory.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要将模块加载到 GHCi 中，工作目录必须能够访问该模块。对于 GHC 安装本身提供的标准模块以外的模块，必须安装包含该模块的包。有两种使用 Cabal
    安装包的方式：全局安装，这样包可以从任何目录访问；本地安装，这样它只能从当前工作目录访问。
- en: Using Cabal to Install a Package Globally
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Cabal 全局安装一个包
- en: 'To install the `gnuplot` package globally, issue the following command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要全局安装 `gnuplot` 包，请执行以下命令：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On my computer, this command creates or changes the file */home/walck/ .ghc/x86_64-linux-8.10.5/environments/default*,
    which contains the list of globally installed Haskell packages. After you have
    installed one or more packages globally, a Cabal command such as the one we just
    issued may fail to install a new package if Cabal cannot find a version of the
    requested package that is compatible with existing globally installed packages.
    One way to solve this problem is to rename the file containing the global package
    list and then try to install all of the packages you want simultaneously. For
    example, to install the `gnuplot`, `gloss`, and `cyclotomic` packages simultaneously,
    you would issue the following command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的计算机上，此命令会创建或更改文件*/home/walck/ .ghc/x86_64-linux-8.10.5/environments/default*，该文件包含全局安装的Haskell包列表。在您全局安装了一个或多个包后，类似我们刚刚发出的Cabal命令，可能会无法安装新包，因为Cabal找不到与已安装全局包兼容的请求包版本。解决此问题的一种方法是重命名包含全局包列表的文件，然后尝试同时安装所有需要的包。例如，要同时安装`gnuplot`、`gloss`和`cyclotomic`包，您可以发出以下命令：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Because we renamed the global package list, Cabal will not find a global package
    list and consequently will make a new one.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们重命名了全局包列表，Cabal将找不到全局包列表，因此会创建一个新的包列表。
- en: Using Cabal to Install a Package Locally
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用Cabal本地安装包
- en: 'To install the `gnuplot` package locally (in the current working directory),
    issue the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本地（当前工作目录）安装`gnuplot`包，请发出以下命令：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The dot at the end of the command refers to the current working directory.
    This command creates or changes a file with a name like *.ghc.environment .x86_64-linux-8.10.5*
    in the current working directory. This file contains a list of packages installed
    locally (in the current working directory). After you have installed one or more
    packages locally in some directory, a Cabal command such as the one we just issued
    may fail to install a new package if Cabal cannot find a version of the requested
    package that is compatible with existing locally installed packages. One way to
    solve this problem is to rename the file containing the local package list and
    then try to install all of the packages you want simultaneously. For example,
    to install the `gnuplot`, `gloss`, and `cyclotomic` packages simultaneously, you
    would issue the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 命令末尾的点表示当前工作目录。此命令会在当前工作目录中创建或更改一个名为*.ghc.environment .x86_64-linux-8.10.5*的文件。该文件包含本地安装的包列表（位于当前工作目录）。当您在某个目录中本地安装了一个或多个包后，类似我们刚刚发出的Cabal命令，可能会无法安装新包，因为Cabal找不到与已安装本地包兼容的请求包版本。解决此问题的一种方法是重命名包含本地包列表的文件，然后尝试同时安装所有需要的包。例如，要同时安装`gnuplot`、`gloss`和`cyclotomic`包，您可以发出以下命令：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Because we renamed the local package list, Cabal will not find a local package
    list and consequently will make a new one.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们重命名了本地包列表，Cabal将找不到本地包列表，因此会创建一个新的包列表。
- en: Using Stack
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Stack
- en: To install the `gnuplot` package using Stack, issue the command
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Stack安装`gnuplot`包，请发出以下命令：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: at the command prompt. Stack keeps track of more things behind the scenes than
    Cabal does, and global installation with Stack is usually all you need.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令提示符下。Stack比Cabal跟踪更多的幕后事项，全局安装通过Stack通常就是您所需要的。
- en: After installing the `gnuplot` package, you can load the `Graphics.Gnuplot`
    `.Simple` module into GHCi. If you are using Stack, you should start GHCi with
    `stack ghci` rather than `ghci`. In this way, Stack will be able to find the modules
    of the packages you have installed.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完`gnuplot`包后，您可以将`Graphics.Gnuplot` `.Simple`模块加载到GHCi中。如果您使用的是Stack，应该通过`stack
    ghci`启动GHCi，而不是`ghci`。这样，Stack就能找到您已安装的包的模块。
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we ask for the type of the function `plotFunc`, simply to show that it
    is available now that we’ve loaded the module that defines it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们请求`plotFunc`函数的类型，仅仅是为了展示它在我们加载了定义它的模块之后已经可以使用。
- en: To use the `plotFunc` function in a source code file, include the line
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要在源代码文件中使用`plotFunc`函数，请包含以下行：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: at the top of your source code file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的源代码文件顶部。
- en: Installing Gloss
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Gloss
- en: Beginning in [Chapter 13](ch13.xhtml) we use `gloss` to make animations. Unlike
    `gnuplot`, `gloss` is not a stand-alone program; it is only a Haskell package.
    However, `gloss` uses the freeglut graphics libraries to do its work, and the
    freeglut functionality is supplied by non-Haskell libraries that must be installed
    separately from the `gloss` package itself. So, like installing `gnuplot`, installing
    `gloss` is a two-step process. First, you must install the non-Haskell freeglut
    libraries. Second, you must install the Haskell `gloss` package.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第13章](ch13.xhtml)开始，我们使用`gloss`来制作动画。与`gnuplot`不同，`gloss`不是一个独立的程序；它只是一个 Haskell
    包。然而，`gloss`使用 freeglut 图形库来完成工作，freeglut 的功能由非 Haskell 库提供，这些库必须与`gloss`包本身分开安装。因此，像安装`gnuplot`一样，安装`gloss`是一个两步过程。首先，你需要安装非
    Haskell 的 freeglut 库。其次，你需要安装 Haskell 的`gloss`包。
- en: The procedure for installing the freeglut libraries depends on your operating
    system. For a GNU/Linux system, a command such as
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 freeglut 库的过程取决于你的操作系统。对于 GNU/Linux 系统，可以使用类似下面的命令：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: should do the trick. On macOS, a command like
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 应该可以解决问题。在 macOS 上，你可以使用类似的命令，借助`brew`包管理器。
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: is what you want. You will need to install the `brew` package manager to use
    this command. On macOS, you may also need the `xquartz` package to use freeglut,
    which you can install with
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 是你所需要的。你需要安装`brew`包管理器才能使用此命令。在 macOS 上，你可能还需要安装`xquartz`包来使用 freeglut，你可以通过下面的命令来安装：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For a Microsoft Windows system, search the web for “freeglut windows” and follow
    the instructions you find.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Microsoft Windows 系统，请在网上搜索“freeglut windows”并按照找到的说明操作。
- en: After you install the freeglut libraries, you can install the `gloss` package
    with a command like
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了 freeglut 库后，你可以通过类似下面的命令来安装`gloss`包：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: or
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: depending on whether you are using Cabal or Stack.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于你是使用 Cabal 还是 Stack。
- en: Installing Diagrams
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Diagrams
- en: Beginning in [Chapter 22](ch22.xhtml) we use the `diagrams` package to visualize
    vector fields. Actually, the `diagrams` package is just a wrapper around three
    packages called `diagrams-core`, `diagrams-lib`, and `diagrams-contrib`. The purpose
    of the wrapper is to make it easier to install because you can issue one command
    instead of three. We will use two of these three packages plus one other. We will
    use `diagrams-core`, `diagrams-lib`, and `diagrams-cairo`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从[第22章](ch22.xhtml)开始，我们使用`diagrams`包来可视化向量场。实际上，`diagrams`包只是对三个包的封装，分别是`diagrams-core`、`diagrams-lib`和`diagrams-contrib`。封装的目的是简化安装过程，因为你只需要发出一个命令而不是三个。我们将使用这三个包中的两个，再加上另一个。我们将使用`diagrams-core`、`diagrams-lib`和`diagrams-cairo`。
- en: Similar to `gloss`, the `diagrams-cairo` package uses some graphics libraries
    to do its work, and you must install these non-Haskell libraries separately from
    the `diagrams-cairo` package itself. So, like installing `gnuplot` and `gloss`,
    installing `diagrams` is a two-step process. First, you must install the non-Haskell
    graphics libraries. Second, you must install the Haskell `diagrams` packages.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与`gloss`类似，`diagrams-cairo`包使用一些图形库来完成工作，必须将这些非 Haskell 库与`diagrams-cairo`包本身分开安装。因此，像安装`gnuplot`和`gloss`一样，安装`diagrams`也是一个两步过程。首先，你需要安装非
    Haskell 的图形库。其次，你需要安装 Haskell 的`diagrams`包。
- en: The graphics libraries needed are called `cairo` and `pango`. The procedure
    for installing these libraries depends on your operating system. For a GNU/Linux
    system, a command such as
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的图形库是`cairo`和`pango`。安装这些库的过程取决于你的操作系统。对于 GNU/Linux 系统，可以使用类似下面的命令：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: should do the trick. On macOS, you can use a similar command with the `brew`
    package manager.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 应该可以解决问题。在 macOS 上，你可以使用类似的命令，借助`brew`包管理器。
- en: After you’ve installed the `cairo` and `pango` libraries, you can install the
    `diagrams` packages with a command like
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了`cairo`和`pango`库后，你可以通过类似下面的命令来安装`diagrams`包：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: or
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: depending on whether you are using Cabal or Stack.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于你是使用 Cabal 还是 Stack。
- en: Setting Up Your Coding Environment
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置你的编码环境
- en: 'As this book progresses, our code gets more complicated because we use modules
    other people have written and modules that we have written ourselves. We want
    to load some of our code into GHCi, and we also want to write stand-alone programs.
    Thus, we need a way to stay organized so that we have access to the modules we
    need so we are empowered to do the things we want to do. There are two main ways
    to stay organized:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本书的进展，我们的代码变得越来越复杂，因为我们开始使用其他人编写的模块以及我们自己编写的模块。我们希望将一些代码加载到 GHCi 中，同时我们还希望编写独立的程序。因此，我们需要一种方法来保持代码的组织性，以便能够访问我们所需的模块，从而使我们能够做我们想做的事情。保持组织性的主要方法有两种：
- en: (1) Keep all of your source code files in a single directory. This includes
    files intended for loading into GHCi as well as stand-alone programs. Install
    packages so that this directory has access to them. Arrange for this directory
    to have access to the modules from the book.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: (1) 将所有源代码文件保存在一个目录中。这包括用于加载到 GHCi 中的文件以及独立的程序。安装软件包，以便该目录能够访问它们。确保该目录能够访问书中的模块。
- en: (2) Create a fresh directory for each project you work on. See that this directory
    has access to whatever modules and packages the project needs. Each directory
    might have a *.cabal* file and, if you are using `stack`, a *stack.yaml* file.
    These files describe the requirements for your project.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: (2) 为你正在进行的每个项目创建一个新的目录。确保该目录能够访问项目所需的模块和软件包。每个目录可能会有一个 *.cabal* 文件，如果你使用 `stack`，还可能有一个
    *stack.yaml* 文件。这些文件描述了你项目的需求。
- en: I recommend method (1), at least until you see some advantage in making a new
    directory for a new project. For the purposes of this book, the exercises you
    are asked to do are not so large that each demands its own directory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议采用方法 (1)，至少在你没有看到为新项目创建新目录的任何优势之前。就本书的目的而言，你需要做的练习并不大，每个练习并不需要自己的目录。
- en: What We Want in a Coding Environment
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 我们对编码环境的需求
- en: 'Before I give two specific suggestions for organizing your coding environment,
    let’s lay out what we are trying to achieve. What follows are four desired properties
    we want our coding environment to have:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在给出关于如何组织你的编码环境的两条具体建议之前，让我们先明确我们想要实现的目标。以下是我们希望编码环境具备的四个期望特性：
- en: (a) We want to be able to load a source code file we have written into GHCi
    with GHCi’s `:l` command. Such a source code file may or may not have a module
    name. Such a source code file also may or may not import modules using Haskell’s
    `import` keyword.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: (a) 我们希望能够通过 GHCi 的 `:l` 命令将我们编写的源代码文件加载到 GHCi 中。这样的源代码文件可能有模块名，也可能没有模块名。这样的源代码文件也可能会使用
    Haskell 的 `import` 关键字导入模块，也可能不会导入模块。
- en: (b) We want to be able to load a module that someone else has written, such
    as `Graphics.Gnuplot.Simple`, into GHCi with GHCi’s `:m` command.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: (b) 我们希望能够通过 GHCi 的 `:m` 命令将他人编写的模块，如 `Graphics.Gnuplot.Simple`，加载到 GHCi 中。
- en: (c) We want to be able to produce an executable program from a source code file
    we have written. Such a source code file may or may not import modules using Haskell’s
    `import` keyword.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: (c) 我们希望能够从我们编写的源代码文件生成可执行程序。这样的源代码文件可能会使用 Haskell 的 `import` 关键字导入模块，也可能不会导入模块。
- en: (d) We want to be able to use the modules defined in this book by loading them
    into GHCi and by writing source code to `import` them.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: (d) 我们希望能够通过将模块加载到 GHCi 中以及编写源代码 `import` 这些模块来使用本书中定义的模块。
- en: To load a source code file into GHCi, as desired in (a), we will need to start
    GHCi in the directory where our file lives. If our source code file imports modules,
    it needs access to them. If a module our source code file imports is provided
    by a package, the current working directory must have access to that package.
    This can be either local or global access, as defined earlier in this appendix.
    If the module is defined in a source code file, such as one of the modules written
    in this book, that file must live in the working directory, or in a place where
    GHC knows to look for it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如需将源代码文件加载到 GHCi 中，如 (a) 所述，我们需要在源代码文件所在的目录中启动 GHCi。如果我们的源代码文件导入了模块，它需要能够访问这些模块。如果源代码文件导入的模块由某个包提供，则当前工作目录必须能够访问该包。这可以是本地访问，也可以是全局访问，如本附录前文所定义。如果该模块是在源代码文件中定义的，例如本书中编写的模块之一，那么该文件必须位于工作目录中，或者位于
    GHC 知道要查找的位置。
- en: To load a module written by someone else into GHCi, as desired in (b), the working
    directory needs to have access to the package that provides the module we wish
    to load. This can be local or global access, as described earlier.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如需将他人编写的模块加载到 GHCi 中，如 (b) 所述，工作目录需要能够访问提供我们希望加载的模块的包。这可以是本地访问，也可以是全局访问，如前文所述。
- en: 'Producing a stand-alone program, as desired in (c), is the subject of [Chapter
    12](ch12.xhtml). There, we discuss three methods to produce a stand-alone program:
    one using GHC, one using Cabal, and one using Stack. Using Cabal or Stack as described
    in that chapter is a form of method (2) since we are allowed to have only one
    *.cabal* file in each directory. However, that *.cabal* file is allowed to specify
    multiple stand-alone programs, so it is possible to use Cabal or Stack with method
    (1).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 生产一个独立的程序，如(c)所需的内容，是[第12章](ch12.xhtml)的主题。在那里，我们讨论了三种生成独立程序的方法：一种使用GHC，一种使用Cabal，另一种使用Stack。如该章所述，使用Cabal或Stack是一种方法(2)，因为我们每个目录中只能拥有一个*.cabal*文件。然而，该*.cabal*文件允许指定多个独立程序，因此可以使用Cabal或Stack与方法(1)结合使用。
- en: To achieve (d), the simplest thing is to put all of the module-defining *.hs*
    files (such as *Mechanics3D.hs*, which defines the `Mechanics3D` module) into
    your working directory. Since the source code file you write is also in this directory,
    GHC will look for modules your source code file imports in the working directory
    when you load your file into GHCi, or when you compile it with GHC.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现(d)，最简单的方法是将所有定义模块的*.hs*文件（例如*Mechanics3D.hs*，它定义了`Mechanics3D`模块）放入你的工作目录。由于你编写的源代码文件也在此目录中，GHC在你加载该文件到GHCi时，或在你使用GHC编译它时，会在工作目录中查找你的源代码文件所导入的模块。
- en: The following two sections give specific suggestions about where to put the
    modules defined in this book, which you can download at [https://lpfp.io](https://lpfp.io).
    The two suggestions are alternatives, so you need to follow only one of them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个部分将提供关于将本书中定义的模块放置在哪些位置的具体建议，你可以在[https://lpfp.io](https://lpfp.io)下载相关文件。这两个建议是替代方案，你只需遵循其中一个即可。
- en: All Code in One Directory
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 所有代码放在一个目录中
- en: 'As suggested earlier, the simplest method for staying organized is to put everything
    in one directory. This includes:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，保持组织最简单的方法是将所有内容放在一个目录中。这包括：
- en: Source code files you intend to load into GHCi
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你打算加载到GHCi中的源代码文件
- en: Source code files you intend to compile into executable programs
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你打算编译成可执行程序的源代码文件
- en: Source code files, such as *Mechanics3D.hs*, for the modules defined in this
    book
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书中定义的模块的源代码文件，例如*Mechanics3D.hs*
- en: This one directory will be your working directory for all of your Haskell work.
    If you continue to program in Haskell, you will outgrow this method. You will
    want to work on different projects with different purposes and different needs,
    and you won’t want all of your code in one directory. When you get to this point,
    there are many ways forward. The Cabal and Stack tools offer many ways to organize
    your work.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个目录将是你所有Haskell工作的工作目录。如果你继续编程Haskell，你会逐渐超越这种方法。你将希望处理不同目的和需求的不同项目，而不希望将所有代码放在一个目录中。当你到达这个阶段时，有很多前进的方式。Cabal和Stack工具提供了许多组织工作的方式。
- en: For now, we need to make sure our one working directory has access to all of
    the packages we need for the projects in this book. The following command, to
    be entered as one long line at a command prompt, will locally install all the
    packages we need for this book.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们需要确保我们的工作目录可以访问本书项目所需的所有包。以下命令需要在命令提示符下以一行输入，它将本地安装我们本书所需的所有包。
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: One disadvantage of this method is that we can load the book modules with GHCi’s
    `:l` command but not with GHCi’s `:m` command, and this means we can load only
    one book module into GHCi at a time. This could be inconvenient if we want access
    in GHCi to functions defined in different book modules. One way around this is
    to make a new source code file that imports all the modules we want, and then
    load that source code file into GHCi with `:l`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个缺点是我们可以通过GHCi的`:l`命令加载书中的模块，但无法通过GHCi的`:m`命令加载，这意味着我们一次只能加载一个书中的模块。如果我们希望在GHCi中访问不同模块中定义的函数，这可能会很不方便。一种解决方法是创建一个新的源代码文件，将我们需要的所有模块导入其中，然后使用`:l`命令将该源代码文件加载到GHCi中。
- en: Another way around this disadvantage is to use the Stack tool to manage the
    modules from this book, as explained in the next section.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决此缺点的方法是使用Stack工具来管理本书中的模块，如下一节所述。
- en: One Way to Use Stack
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Stack的一种方式
- en: 'The Cabal and Stack tools provide many (maybe too many) ways for you to organize
    your work in Haskell. Here we will look at one way in detail. In this method,
    we still have one directory that contains all of our Haskell work, but this directory
    has two subdirectories: one for the book modules, and one for stand-alone programs.
    So there are three places where source code files can exist. They can live in
    the main working directory, they can live in the module subdirectory, or they
    can live in the stand-alone program subdirectory. A source code file you intend
    to load into GHCi will probably live in the main working directory.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Cabal 和 Stack 工具提供了许多（可能太多）方法来组织你的 Haskell 工作。在这里，我们将详细探讨一种方法。在这种方法中，我们仍然有一个目录来存放所有的
    Haskell 工作，但这个目录有两个子目录：一个用于书籍模块，另一个用于独立程序。因此，源代码文件可以存在三个地方。它们可以存放在主工作目录中，也可以存放在模块子目录中，或者可以存放在独立程序子目录中。你打算加载到
    GHCi 中的源代码文件可能会存放在主工作目录中。
- en: Stack needs two configuration files to manage things. One is named *LPFP.cabal*,
    and the other is named *stack.yaml*. These two files will live in the main working
    directory. The file *LPFP.cabal* describes the modules we want to have access
    to, as well as the executable programs we want Stack to build for us. [Listing
    A-1](#app01ex01) gives this file.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Stack 需要两个配置文件来管理事务。一个名为 *LPFP.cabal*，另一个名为 *stack.yaml*。这两个文件将位于主工作目录中。文件 *LPFP.cabal*
    描述了我们希望访问的模块，以及我们希望 Stack 为我们构建的可执行程序。[列表 A-1](#app01ex01) 给出了这个文件。
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing A-1: The file* `LPFP.cabal` *describing the modules we want access
    to and the executables we want produced*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 A-1：描述我们希望访问的模块和我们希望生成的可执行程序的文件* `LPFP.cabal`'
- en: After some introductory matter appear one library stanza and two executable
    stanzas. The library stanza lists all of the modules from this book that we want
    to have access to. It says that the source code for these modules is in the subdirectory
    *src* and that these modules depend on several packages, such as `gnuplot` and
    `gloss`. The `base` module contains most of the essential libraries for the simplest
    data types. The version specification means “version 4.7 or newer, but the major
    version must be less than 5.” The “default-language” specification tells us that
    we’re using the 2010 version of the Haskell language specification, which is the
    current version. The previous version was Haskell98, which gives you a hint of
    how much time elapses between major revisions to the language.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些介绍性内容之后，出现了一个库段和两个可执行段。库段列出了我们希望访问的本书中的所有模块。它说明了这些模块的源代码位于 *src* 子目录中，并且这些模块依赖于几个包，例如
    `gnuplot` 和 `gloss`。`base` 模块包含了大多数简单数据类型所需的基础库。版本规范表示“版本 4.7 或更新，但主版本必须小于 5。”
    “default-language” 规范告诉我们我们使用的是 2010 版本的 Haskell 语言规范，这是当前版本。之前的版本是 Haskell98，这让你对语言的主要版本修订间隔有个概念。
- en: There is one executable stanza for each stand-alone program we want Stack to
    build for us. Two are listed here, but you can have as many as you like. The first
    executable stanza describes the stand-alone program for the source code file *VisTwoSprings.hs*
    in the subdirectory called *app*. The executable program will be called *LPFP-VisTwoSprings*
    and will be available globally to run from any directory. The packages required
    by this stand-alone program are listed as well.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每个我们希望 Stack 为我们构建的独立程序都有一个可执行段。这里列出了两个，但你可以根据需要列出任意数量的程序。第一个可执行段描述了位于名为 *app*
    的子目录中的源代码文件 *VisTwoSprings.hs* 的独立程序。该可执行程序将被命名为 *LPFP-VisTwoSprings*，并可以在任何目录下全局运行。此独立程序所需的包也在此列出。
- en: At the time of writing, the `diagrams` packages are not included in the curated
    list of packages Stack uses by default, so we must list some extra packages in
    a file called *stack.yaml*. [Listing A-2](#app01ex02) shows this file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`diagrams` 包不包括在 Stack 默认使用的精选包列表中，因此我们必须在名为 *stack.yaml* 的文件中列出一些额外的包。[列表
    A-2](#app01ex02) 显示了这个文件。
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing A-2: The file stack.yaml describing the extra dependencies the modules
    in this book need*'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 A-2：描述本书中模块所需额外依赖的文件 stack.yaml*'
- en: For each version of the compiler, Stack supports a collection of curated packages
    that are known to build with that compiler and to be generally compatible with
    each other. A compiler and package set is specified by a version number. In [Listing
    A-2](#app01ex02), `lts-18.21` in the `resolver` field means “GHC 8.10.7 and packages
    compatible with it.” This particular compiler/package collection has long-term
    support (the `lts-` prefix). This means you can count on it being around for awhile,
    typically a few years.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个编译器版本，Stack支持一组已知能与该编译器一起构建并且通常互相兼容的精选软件包。通过版本号指定编译器和软件包集。在[示例A-2](#app01ex02)中，`resolver`字段中的`lts-18.21`表示“GHC
    8.10.7及其兼容的软件包”。这个特定的编译器/软件包集合有长期支持（`lts-`前缀）。这意味着你可以依赖它会持续一段时间，通常是几年。
- en: If you need to live on the bleeding edge to get the features you need, there
    are snapshot collections and, for the very latest, the nightly build.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在前沿技术中生活以获取所需的功能，可以使用快照集合，若需要最新的功能，则可以使用夜间构建版本。
- en: The next field, `packages` refers to packages that *you* have written, typically
    libraries useful for your own project. In [Listing A-2](#app01ex02), the packages
    are simply files in the current directory, or “`.`” in Unix-speak.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个字段`packages`指的是*你*自己编写的包，通常是对你自己项目有用的库。在[示例A-2](#app01ex02)中，包只是当前目录中的文件，或者用Unix术语表示为“`.`”。
- en: The `extra-deps` are additional packages your application depends on that are
    not part of the curated set specified by the `resolver` field. (There is in fact
    not much difference between a `package` and an `extra-dep` except that it is possible
    to write test and benchmark targets for our own packages—very important parts
    of a large application—and these are not available for `extra-deps`.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`extra-deps`是你的应用程序所依赖的额外包，这些包不属于`resolver`字段指定的精选包集合。（事实上，`package`和`extra-dep`之间没有太大区别，除了我们可以为自己的包编写测试和基准目标——这是大型应用程序中非常重要的部分——而这些对于`extra-deps`来说是不可用的。）'
- en: Your first stop for questions about the *stack.yaml* file should be [https://docs.haskellstack.org/en/stable/README](https://docs.haskellstack.org/en/stable/README).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有关于*stack.yaml*文件的问题，首先可以访问[https://docs.haskellstack.org/en/stable/README](https://docs.haskellstack.org/en/stable/README)。
- en: You can see the packages `diagrams-core`, `diagrams-lib`, and `diagrams-cairo`
    we are interested in. The remaining packages are packages `diagrams` depends on.
    Specific versions of these packages are listed. By the time this book appears
    in print, newer versions of these packages may be available.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们感兴趣的包`diagrams-core`、`diagrams-lib`和`diagrams-cairo`。其余的包是`diagrams`所依赖的包。具体版本的这些包也列出了。在本书出版时，这些包的更新版本可能已经发布。
- en: 'To build the executable programs, issue the following command in the main working
    directory (the directory in which the *stack.yaml* and *LPFP.cabal* files live):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建可执行程序，在主工作目录中输入以下命令（该目录包含*stack.yaml*和*LPFP.cabal*文件）：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To start a GHCi session in which all of the book modules are automatically
    loaded, you can issue the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动一个GHCi会话，其中所有的书籍模块都会自动加载，你可以输入以下命令：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With this method, we can load any or all of the book modules into GHCi. To
    remove a module, you can use GHCi’s `:m` command with the module prefixed by a
    minus sign. To remove the `Newton2` module, type the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以将任何或所有的书籍模块加载到GHCi中。要移除一个模块，你可以使用GHCi的`:m`命令，模块名前加上减号。要移除`Newton2`模块，输入以下命令：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Similarly, to add an additional module, use a plus sign prefix. To add the
    `Graphics.Gnuplot.Simple` module, type the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，要添加一个额外的模块，使用加号前缀。要添加`Graphics.Gnuplot.Simple`模块，输入以下命令：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Issuing `stack ghci` will also give you the option of loading one of the executable
    programs into GHCi if you wish.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`stack ghci`命令还可以为你提供将可执行程序之一加载到GHCi中的选项，如果你愿意的话。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: This appendix described how to install the Haskell compiler and a text editor,
    and it went over methods for installing additional library packages using Cabal
    and Stack. It also showed different ways to organize libraries and source code
    files for building projects in Haskell.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本附录介绍了如何安装Haskell编译器和文本编辑器，并讲解了使用Cabal和Stack安装额外库包的方法。它还展示了组织库和源代码文件以便在Haskell中构建项目的不同方式。
