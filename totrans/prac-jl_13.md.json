["```\nusing Agents, StatsBase, JLD2, Random\n\n@agent Prey ContinuousAgent{2} begin\n    mojo::Float64\n    moves::Vector{Float64}\nend\n\n@agent Predator ContinuousAgent{2} begin\n    victim::Int64\nend\n```", "```\nconst NPrey = 16 # Number of Prey agents\nconst NPred = 8 # Number of Predator agents\nconst PPR = 0.5 # Predator/prey ratio\nconst M = 8  # Number of turns\nconst SBT = 100 # Steps between turns\nconst TAD = 0.2 # Target acquisition distance\nconst KD = 0.01 # Kill distance\nconst LS = 2 # Litter size\nconst MIPS = 0.1 # Mojo increase per step\nconst MNFR = 50.0 # Mojo needed for reproduction\nconst SPEEDR = 1.5 # Ratio (predator speed)/(prey speed)\nconst LAA = π/128 # Limit of angular agility\nconst dt = 0.001\nconst SEED = 43\nconst rng = Random.MersenneTwister(SEED)\nconst LF = open(\"logfile\", \"a+\") # Logfile\nconst LI = 100 # Log interval\n```", "```\nfunction vnorm(v)\n    v ./ sqrt(v[1]^2 + v[2]^2)\nend\n\nfunction angle_between(a, b)\n    atan(b[2], b[1]) - atan(a[2], a[1])\nend\n\nfunction turn(v, θ)\n    M = [cos(θ) -sin(θ); sin(θ) cos(θ)]\n    M * [v...]\nend\n```", "```\nfunction rmutate!(moves, nms)\n    for ms in rand(rng, 1:M, nms) # nms random mutation sites\n        θ = moves[ms] + (2rand(rng) - 1) * π/4\n        # Keep within ±π:\n        if abs(θ) < 1π\n            moves[ms] = θ\n        else\n            moves[ms] = (θ - sign(θ) * 2.0π) % 2.0π\n        end\n    end\nend\n```", "```\narena = ContinuousSpace((1, 1); periodic=true)\nproperties = Dict(:stepno => 0, :total_step => 0)\nmodel = ABM(Union{Prey, Predator}, arena; properties)\n```", "```\nfor i in 1:NPrey # Initialize Prey agents\n    vel = vnorm(Tuple(rand(model.rng, 2).-0.5))\n ➊ moves = π*(2rand(model.rng, M) .- 1)\n    add_agent!(Prey, model, vel, 0.0, moves)\nend\n\nfor i in 1:NPred # Initialize Predator agents\n    add_agent!(Predator, model, (0.0, 0.0), 0)\nend\n```", "```\nfunction preys(model)\n    [a for a in allagents(model) if a isa Prey]\nend\n\nfunction predators(model)\n    [a for a in allagents(model) if a isa Predator]\nend\n```", "```\nfunction number_of_predators(model)\n    length(predators(model))\nend\n\nfunction number_of_preys(model)\n    length(preys(model))\nend\n```", "```\nfunction being_chased(model)\n    [a.victim for a in predators(model)]\nend\n```", "```\nfunction moves_dist_data(model)\n    moves_data = [m.moves for m in preys(model)]\n    all_angles = [i for a in moves_data for i in a]\n    fit(Histogram, all_angles, -π:2π/40:π)\nend\n```", "```\nfunction agent_step!(agent, model)\n    move_agent!(agent, model, dt)\n    if agent isa Predator && agent.victim > 0\n        if agent.victim in keys(model.agents)\n            if euclidean_distance(agent, model[agent.victim], model) < KD\n                kill_agent!(model[agent.victim], model)\n                agent.victim = 0\n                agent.vel = (0.0, 0.0) # Time to rest a bit ➊\n            else\n                θp = angle_between(agent.vel,\n                     get_direction(agent.pos, model[agent.victim].pos, model))\n                θf = min(abs(θp), LAA) * sign(θp) ➋\n                agent.vel = Tuple(turn(agent.vel, θf))\n            end\n        else\n            agent.victim = 0 # Already gone\n        end\n    end\n    victims = being_chased(model)\n    if agent isa Predator && agent.victim == 0\n        food = [a for a in nearby_agents(agent, model, TAD)\n                if (a isa Prey && !(a in victims))]\n        if !isempty(food)\n            agent.victim = food[1].id\n            append!(victims, food[1].id)\n           agent.vel = SPEEDR .* vnorm(get_direction(agent.pos, food[1].pos, model)) ➌\n        end\n    end\n    if agent isa Prey\n        if agent.mojo >= MNFR # Reproduce: add LS new Preys at my position\n            for c in 1:LS\n                child = add_agent!(agent.pos, Prey, model,\n                                   vnorm(Tuple(rand(model.rng, 2).-0.5)), 0, agent.moves)\n                rmutate!(child.moves, 2)\n            end\n            kill_agent!(agent, model) # Reproduction is fatal ➍\n        end\n        if model.stepno == 0\n            vel = turn(agent.vel, agent.moves[1])\n            agent.vel = Tuple(vel) ➎\n            agent.moves = circshift(agent.moves, -1)\n        end\n        agent.mojo += MIPS # I eat as I run\n    end\nend\n```", "```\nfunction model_step!(model)\n    model.stepno = (model.stepno + 1) % SBT\n    model.total_step += 1\n\n    # Maintain predator/prey ratio:\n    predators_pop = length(predators(model))\n    prey_pop = length(preys(model))\n    if predators_pop/prey_pop < PPR\n        for i in 1:Int(round(PPR*prey_pop - predators_pop))\n            add_agent!(Predator, model, (0.0, 0.0), 0)\n        end\n    end\n    if predators_pop/prey_pop > 1.05PPR\n        for i in 1:Int(round(predators_pop - PPR*prey_pop))\n         ➊ kill_agent!(random_agent(model, a -> a isa Predator), model)\n        end\n    end\n    # Logging and checkpointing:\n    if model.total_step % LI == 0\n        write(LF, \"$(model.total_step), $prey_pop, $predators_pop \\n\")\n        flush(LF)\n    end\nend\n```", "```\nfunction evolve!(model, nruns, nsteps_per_run)\n    for run in 1:nruns\n        adf, mdf = run!(model, agent_step!, model_step!, nsteps_per_run;\n                        adata=[:mojo],\n                        mdata=[:total_step, number_of_predators,\n                               number_of_preys, moves_dist_data])\n\n        jldsave(\"mdf$run\"; mdf)\n        jldsave(\"model$run\"; model)\n    end\nend\n\nevolve!(model, 10, 1000)\n```", "```\nmode = load(filepath, \"model\")\n```", "```\njulia> using InteractiveDynamics, CairoMakie\n```", "```\nfunction agent_color(agent)\n   if agent isa Prey\n       return :blue\n   end\n   if agent isa Predator && agent.victim > 0\n       return :red\n   end\n   return :green\nend\n\nfunction agent_shape(agent)\n   if agent isa Prey\n       return '•'\n   end\n   return '⊙'\nend\n```", "```\njulia> fig, _ = abmplot(model; ac=agent_color, as=20, am=agent_shape)\njulia> save(\"model_snapshot.pdf\", fig)\n```", "```\njulia> abmvideo(\"arena.mp4\", model, agent_step!, model_step!;\n         ac=agent_color, am=agent_shape,\n         frames=500, framerate=30)\n```", "```\njulia> mdf20 = load(\"mdf20\", \"mdf\")\n1001×5 DataFrame\n  Row | step   total_step  number_of_predators  number_of_preys  moves_dist_data\n      | Int64  Int64       Int64                Int64            ...Histogram\n----------------------------------------------------------------------------------------------\n    1 |     0       19000                 1787             3447  Histogram{Int64, 1, Tuple...\n    2 |     1       19001                 1787             3444  Histogram{Int64, 1, Tuple...\n    3 |     2       19002                 1787             3438  Histogram{Int64, 1, Tuple...\n    4 |     3       19003                 1787             3434  Histogram{Int64, 1, Tuple...\n  :   |   :        :                :                  :                         :\n  999 |   998       19998                 2559             5075  Histogram{Int64, 1, Tuple...\n 1000 |   999       19999                 2559             5072  Histogram{Int64, 1, Tuple...\n 1001 |  1000       20000                 2559             5069  Histogram{Int64, 1, Tuple...\n```", "```\njulia> using LinearAlgebra, Plots\n\njulia> Plots.plot(normalize(mdf20.moves_dist_data[end], mode=:pdf);\n                  xticks=([-π:π/2:π;], [\"-π\", \"-π/2\", \"0\", \"π/2\", \"π\"]),\n                  legend=false, xlabel=\"θ\", ylabel=\"PDF(θ)\")\n```"]