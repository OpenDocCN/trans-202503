<html><head></head><body>
<section aria-labelledby="appA" epub:type="appendix" role="doc-appendix">
<span aria-label="259" epub:type="pagebreak" id="pg_259" role="doc-pagebreak"/>
<hgroup>
<h1 class="CHAPTER" id="appA">
<span class="APN"><samp class="SANS_Dogma_OT_Bold_B_11">APPENDIX</samp></span>
<span class="APH"><samp class="SANS_Dogma_OT_Bold_B_11">THE FIFTH EDITION OF THE C STANDARD (C23)</samp></span>
</h1>
</hgroup>
<p class="CAU"><i>with Aaron Ballman</i></p>
<figure class="opener"><img alt="" class="opener" src="../images/opener.jpg"/>
</figure>
<p class="COS">The latest (fifth) edition of the C standard (ISO/IEC 9899:2024) is nicknamed C23. C23 maintains the <i>spirit of C</i>, while adding new features and functions to improve the safety, security, and capabilities of the language.</p>
<section aria-labelledby="sec1" epub:type="division">

<h2 class="H1" id="sec1"><span id="h1-99"/><samp class="SANS_Futura_Std_Bold_B_11">Attributes</samp></h2>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">[[attributes]]</samp> syntax was added to C23 to specify additional information for various source constructs such as types, objects, identifiers, or blocks (Ballman 2019). Prior to C23, similar features were provided in an implementation-defined (nonportable) manner:</p>

<pre><code>__declspec(deprecated)
__attribute__((warn_unused_result))
int func(const char *str)__attribute__((nonnull(1)));</code></pre>
<p class="TX"><span aria-label="260" epub:type="pagebreak" id="pg_260" role="doc-pagebreak"/>Starting with C23, attributes can be specified as follows:</p>

<pre><code>[[deprecated, nodiscard]]
int func(
  const char *str [[gnu::nonnull]]
);</code></pre>
<p class="TX">Like C++, syntactic location determines apportionment. Attributes include <samp class="SANS_TheSansMonoCd_W5Regular_11">deprecated</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">fallthrough</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">maybe_unused</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">nodiscard</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">unsequenced</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">reproducible</samp>. The attribute syntax supports both standard attributes and vendor-specific attributes. The <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_c_attribute</samp> conditional inclusion operator can be used for feature testing.</p>
</section>
<section aria-labelledby="sec2" epub:type="division">

<h2 class="H1" id="sec2"><span id="h1-100"/><samp class="SANS_Futura_Std_Bold_B_11">Keywords</samp></h2>
<p class="TNI">The C language is often ridiculed for having ugly keywords. C typically defines new keywords using reserved identifiers that begin with an underscore character (<samp class="SANS_TheSansMonoCd_W5Regular_11">_</samp>) followed by a capital letter.</p>
<p class="TX">C23 introduced more natural spellings for these keywords (Gustedt 2022). In Table A-1, C11 keywords using this convention are shown on the left, and the more natural spellings introduced in C23 are shown on the right.</p>
<p class="TT" id="tabA-1"><samp class="SANS_Futura_Std_Heavy_B_11">Table A-1:</samp> <samp class="SANS_Futura_Std_Book_11">Keyword Spellings</samp></p>
<table class="Basic-Table">
<thead>
<tr>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Value</samp></p></th>
<th class="TCH" scope="col"><p class="TCH1"><samp class="SANS_Futura_Std_Heavy_B_11">Type</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">_Bool</samp></p></td>
<td class="TBF"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">_Static_assert</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">static_assert</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">_Thread_local</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">thread_local</samp></p></td>
</tr>
<tr>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">_Alignof</samp></p></td>
<td class="TB"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">alignof</samp></p></td>
</tr>
<tr>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">_Alignas</samp></p></td>
<td class="TBL"><p class="TB1"><samp class="SANS_TheSansMonoCd_W5Regular_11">alignas</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">Another update is the introduction of the <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp> constant. The well-worn <samp class="SANS_TheSansMonoCd_W5Regular_11">NULL</samp> macro has a pointer type or maybe an integer type. It will implicitly convert to any scalar type, so it’s not particularly type safe. The <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr</samp> constant has type <samp class="SANS_TheSansMonoCd_W5Regular_11">nullptr_t</samp> and will implicitly convert only to a pointer type, <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp>, or <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>.</p>
</section>
<section aria-labelledby="sec3" epub:type="division">

<h2 class="H1" id="sec3"><span id="h1-101"/><samp class="SANS_Futura_Std_Bold_B_11">Integer Constant Expressions</samp></h2>
<p class="TNI">Integer constant expressions are not a portable construct; vendors can extend them. For example, the <samp class="SANS_TheSansMonoCd_W5Regular_11">array</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">func</samp> may or may not be a variable-length array (VLA):</p>

<pre><code>void func() {
  static const int size = 12;
  int array[size]; // might be a VLA
}</code></pre>
<p class="TX"><span aria-label="261" epub:type="pagebreak" id="pg_261" role="doc-pagebreak"/>C23 adds <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> variables (which imply the <samp class="SANS_TheSansMonoCd_W5Regular_11">const</samp> qualifier) when you really want something to be a constant (Gilding and Gustedt 2022a):</p>

<pre><code>void func() {
  static constexpr int Size = 12;
  int Array[Size]; // never a VLA
}</code></pre>
<p class="TX">C23 doesn’t support <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp> functions yet, only objects. Structure members cannot be <samp class="SANS_TheSansMonoCd_W5Regular_11">constexpr</samp>.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">

<h2 class="H1" id="sec4"><span id="h1-102"/><samp class="SANS_Futura_Std_Bold_B_11">Enumeration Types</samp></h2>
<p class="TNI">C enumeration types seem normal through C17 but have some strange behaviors. For example, the underlying integer type is implementation defined and could be either a signed or unsigned integer type. C23 now allows the programmer to specify the underlying type for enumerations (Meneide and Pygott 2022):</p>

<pre><code>enum E : unsigned short {
  Valid = 0, // has type unsigned short
  NotValid = 0x1FFFF // error, too big
};

// can forward declare with fixed type
enum F : int;</code></pre>
<p class="TX">You can also declare enumeration constants larger than <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>:</p>

<pre><code>// has underlying type unsigned long
enum G {
  BiggerThanInt = 0xFFFF'FFFF'0000L,
};</code></pre>
</section>
<section aria-labelledby="sec5" epub:type="division">

<h2 class="H1" id="sec5"><span id="h1-103"/><samp class="SANS_Futura_Std_Bold_B_11">Type Inference</samp></h2>
<p class="TNI">C23 enhanced the <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> type specifier for single object definitions using type inference (Gilding and Gustedt 2022b). It’s basically the same idea as in C++, but <samp class="SANS_TheSansMonoCd_W5Regular_11">auto</samp> cannot appear in function signatures:</p>

<pre><code>const auto l = 0L; // l is const long
auto huh = "test"; // huh is char *, not char[5] or const char *
void func();
auto f = func; // f is void (*)()
auto x = (struct S){  // x is struct S
  1, 2, 3.0
};
#define swap(a, b) \
  do {auto t = (a); (a) = (b); (b) = t;} \
  while (0)</code></pre>
</section>
<section aria-labelledby="sec6" epub:type="division">
<span aria-label="262" epub:type="pagebreak" id="pg_262" role="doc-pagebreak"/>
<h2 class="H1" id="sec6"><span id="h1-104"/><samp class="SANS_Futura_Std_Bold_B_11">typeof Operators</samp></h2>
<p class="TNI">C23 adds support for <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp> operators. These are like <samp class="SANS_TheSansMonoCd_W5Regular_11">decltype</samp> in C++ and are used to specify a type based on another type or the type of an expression. The <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof</samp> operator retains qualifiers, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">typeof_unqual</samp> strips qualifiers, including <samp class="SANS_TheSansMonoCd_W5Regular_11">_Atomic</samp>.</p>
<section aria-labelledby="sec7" epub:type="division">

<h3 class="H2" id="sec7"><span id="h2-121"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">K&amp;R C Functions</samp></h3>
<p class="TNI">K&amp;R C allowed functions to be declared without prototypes:</p>

<pre><code>int f();
int f(a, b) int a, b; {return 0;}</code></pre>
<p class="TX">K&amp;R C functions were deprecated 35 years ago and are finally being removed from the standard. All functions now have prototypes. An empty parameter list used to mean “takes any number of arguments” and now means “takes zero arguments,” the same as C++. It is possible to emulate “accepts zero or more args” via a variadic function signature: <samp class="SANS_TheSansMonoCd_W5Regular_11">int f(...);</samp> which is now possible because <samp class="SANS_TheSansMonoCd_W5Regular_11">va_start</samp> no longer requires passing the parameter before the <samp class="SANS_TheSansMonoCd_W5Regular_11">...</samp> to the call.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">

<h3 class="H2" id="sec8"><span id="h2-122"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Preprocessor</samp></h3>
<p class="TNI">New features have been added to C23 to improve preprocessing. The <samp class="SANS_TheSansMonoCd_W5Regular_11">#elifdef</samp> directive complements <samp class="SANS_TheSansMonoCd_W5Regular_11">#ifdef</samp> and also has an <samp class="SANS_TheSansMonoCd_W5Regular_11">#elifndef</samp> form. The <samp class="SANS_TheSansMonoCd_W5Regular_11">#warning</samp> directive complements <samp class="SANS_TheSansMonoCd_W5Regular_11">#error</samp> but does not halt translation. The <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_include</samp> operator tests for the existence of a header file, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">__has_c_attribute</samp> operator tests for the existence of a standard or vendor attribute.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">#embed</samp> directive embeds external data directly into the source code via the preprocessor:</p>

<pre><code>unsigned char buffer[] = {
#embed "/dev/urandom" limit(32) // embeds 32 chars from /dev/urandom
};
struct FileObject {
  unsigned int MagicNumber;
  unsigned _BitInt(8) RGBA[4];
  struct Point {
    unsigned int x, y;
  } UpperLeft, LowerRight;
} Obj = {
#if __has_embed(SomeFile.bin) == __STDC_EMBED_FOUND__
// embeds contents of file as struct
// initialization elements
#embed "SomeFile.bin"
#endif
};</code></pre>
</section>
<section aria-labelledby="sec9" epub:type="division">
<span aria-label="263" epub:type="pagebreak" id="pg_263" role="doc-pagebreak"/>
<h3 class="H2" id="sec9"><span id="h2-123"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Integer Types and Representations</samp></h3>
<p class="TNI">Starting in C23, two’s complement is the only allowed integer representation (Bastien and Gustedt 2019). Signed integer overflow remains undefined behavior. The <samp class="SANS_TheSansMonoCd_W5Regular_11">int8_t</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">int16_t</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">int32_t</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">int64_t</samp> types are now portably available everywhere. The <samp class="SANS_TheSansMonoCd_W5Regular_11">[u]intmax_t</samp> types are no longer maximal and are only required to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">long long</samp> values, not extended or bit-precise integer values.</p>
<p class="TX">C23 also introduces bit-precise integer types (Blower et al. 2020). These are signed and unsigned types that allow you to specify the bit-width. These integers do not undergo integer promotions, so they remain the size you requested. Bit-width includes the sign bit, so <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt(2)</samp> is the smallest signed bit-precise integer. <samp class="SANS_TheSansMonoCd_W5Regular_11">BITINT_MAXWIDTH</samp> specifies the maximum width of a bit-precise integer. It must be at least <samp class="SANS_TheSansMonoCd_W5Regular_11">ULLONG_WIDTH</samp> but can be much larger (Clang supports &gt; 2M bits).</p>
<p class="TX">In C17, adding two nibbles required some bit twiddling:</p>

<pre><code>unsigned int add(
  unsigned int L, unsigned int R)
{
  unsigned int LC = L &amp; 0xF;
  unsigned int RC = R &amp; 0xF;
  unsigned int Res = LC + RC;
  return Res &amp; 0xF;
}</code></pre>
<p class="TX">This is much simpler with <samp class="SANS_TheSansMonoCd_W5Regular_11">_BitInt</samp>:</p>

<pre><code>unsigned _BitInt(4) add(
  unsigned _BitInt(4) L,
  unsigned _BitInt(4) R)
{
  return L + R;
}</code></pre>
<p class="TX">C23 also added binary literals. The integer literals 0b00101010101, 0x155, 341, and 0525 all express the same value. You can also now use digit separators for improved readability, for example: <samp class="SANS_TheSansMonoCd_W5Regular_11">0b0000'1111'0000'1100</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">0xF'0C</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">3'852</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">07'414</samp>.</p>
<p class="TX">C23 finally has checked integer operations that will detect overflow and wraparound in addition, subtraction, and multiplication operations (Svoboda 2021):</p>

<pre><code>#include &lt;stdckdint.h&gt; // new header

bool ckd_add(Type1 *Result, Type2 L, Type3 R);
bool ckd_sub(Type1 *Result, Type2 L, Type3 R);
bool ckd_mul(Type1 *Result, Type2 L, Type3 R);</code></pre>
<p class="TX"><span aria-label="264" epub:type="pagebreak" id="pg_264" role="doc-pagebreak"/>Division is not supported, and it only works with integer types other than plain <samp class="SANS_TheSansMonoCd_W5Regular_11">char</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">bool</samp>, or bit-precise integers. <samp class="SANS_TheSansMonoCd_W5Regular_11">Type1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Type2</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Type3</samp> can be different types. These functions return <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp> if the mathematical result of the operation can be represented by <samp class="SANS_TheSansMonoCd_W5Regular_11">Type1</samp>; otherwise, they return <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>. These functions make it easier to comply with the CERT C Coding Standard and MISRA C guidelines, but it is still awkward to compose operations.</p>
</section>
</section>
<section aria-labelledby="sec10" epub:type="division">

<h2 class="H1" id="sec10"><span id="h1-105"/><samp class="SANS_Futura_Std_Bold_B_11">unreachable Function-Like Macro</samp></h2>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">unreachable</samp> function-like macro is provided in <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stddef.h&gt;</samp>. It expands to a void expression; reaching the expression during execution is undefined behavior. This allows you to give hints to the optimizer about flow control that is impossible to reach (Gustedt 2021).</p>
<p class="TX">As with anything you tell the optimizer to assume, use it with caution, because the optimizer will believe you even if you’re wrong. The following is a typical example of how <samp class="SANS_TheSansMonoCd_W5Regular_11">unreachable</samp> might be used in practice:</p>

<pre><code>#include &lt;stdlib.h&gt;
enum Color {Red, Green, Blue};
int func(enum Color C) {
  switch (C) {
    case Red: return do_red();
    case Green: return do_green();
    case Blue: return do_blue();
  }
  unreachable(); // unhandled value
}</code></pre>
</section>
<section aria-labelledby="sec11" epub:type="division">

<h2 class="H1" id="sec11"><span id="h1-106"/><samp class="SANS_Futura_Std_Bold_B_11">Bit and Byte Utilities</samp></h2>
<p class="TNI">C23 introduces a collection of bit and byte utilities in the <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;stdbit.h&gt;</samp> header (Meneide 2023). These include functions to:</p>
<ul class="ul">
<li class="ListBullet">Count the number of 1s or 0s in a bit pattern</li>
<li class="ListBullet">Count the number of leading or trailing 1s or 0s</li>
<li class="ListBullet">Find the first leading or trailing 1 or 0</li>
<li class="ListBullet">Test whether a single bit is set</li>
<li class="ListBullet">Determine the smallest number of bits required to represent a value</li>
<li class="ListBullet">Determine the next smallest or largest power of two based on a value</li>
</ul>
<p class="TX">For example, the following code can be used to count the number of consecutive 0 bits in a value, starting from the most significant bit:</p>

<pre><code>#include &lt;stdbit.h&gt;
void func(uint32_t V) {
  int N = stdc_leading_zeros(V);
  // use the leading zero count N
}</code></pre>
<p class="TX"><span aria-label="265" epub:type="pagebreak" id="pg_265" role="doc-pagebreak"/>Prior to C23, this operation is considerably more involved:</p>

<pre><code>void func(uint32_t V) {
  int N = 32;
  unsigned R;
  R = V &gt;&gt; 16;
  if (R != 0) {N --= 16; V = R;}
  R = V &gt;&gt; 8;
  if (R != 0) {N --= 8; V = R;}
  R = V &gt;&gt; 4;
  if (R != 0) {N --= 4; V = R;}
  R = V &gt;&gt; 2;
  if (R != 0) {N --= 2; V = R;}
  R = V &gt;&gt; 1;
  if (R != 0) N -= 2;
  else        N -= V;
  // use the leading zero count N
}</code></pre>
</section>
<section aria-labelledby="sec12" epub:type="division">

<h2 class="H1" id="sec12"><span id="h1-107"/><samp class="SANS_Futura_Std_Bold_B_11">IEEE Floating-Point Support</samp></h2>
<p class="TNI">C23 updates IEEE floating-point support by integrating TS 18661-1, 2, and 3 (ISO/IEC TS 18661-1 2014, ISO/IEC TS 18661-2 2015, ISO/IEC TS 18661-3 2015). Annex F now has parity with the IEEE standard for floating-point arithmetic (IEEE 754-2019). Annex F also applies to decimal floats: <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal32</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal64</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">_Decimal128</samp>. You cannot mix decimal operations with binary, complex, or imaginary floats, however. Annex H (previously the language-independent arithmetic annex) supports interchange, extended floating types, and nonarithmetic interchange formats. It allows for binary16, graphics processing unit (GPU) data, binary, or decimal representations.</p>
<p class="TX">Math library changes support <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;math.h&gt;</samp> operations on <samp class="SANS_TheSansMonoCd_W5Regular_11">_DecimalN</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">_FloatN</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">_FloatNx</samp> types. Special variants of exponents, logarithms, powers, and <span class="greek"><span lang="el" xml:lang="el">π</span></span>-based trig functions; improved functions for min/max, total ordering, and testing for numerical properties; and functions allowing fine-grained control of conversions between floating-point values and integers or strings have been added.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">memset_explicit</samp> function has been added for when you really need to clear memory. It’s the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">memset</samp>, except the optimizer cannot remove a call to it. The <samp class="SANS_TheSansMonoCd_W5Regular_11">strdup</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">strndup</samp> functions have been adopted from POSIX.</p>
</section>
</section>
</body></html>