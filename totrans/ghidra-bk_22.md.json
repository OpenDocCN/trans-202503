["```\n@Intel64_IA32_SoftwareDevelopersManual.pdf [Intel 64 and IA-32 Architectures\n\n     Software Developer's Manual Volume 2 (2A, 2B, 2C & 2D): Instruction Set\n\n     Reference, A-Z, Sep 2016 (325383-060US)]\n\nAAA, 120\n\nAAD, 122\n\nBLENDPS, 123\n\nAAM, 124\n```", "```\n@FilenameInGhidraManualDirectory [Description of manual file]\n```", "```\n# MFL: definitions for Intel IA hardware assisted virtualization instructions\n\ndefine pcodeop invept;   # Invalidate Translations Derived from extended page\n\n                         # tables (EPT); opcode 66 0f 38 80\n\n# -----CONTENT OMITTED HERE-----\n\ndefine pcodeop vmread;   # Read field from virtual-machine control structure;\n\n                         # opcode 0f 78\n\ndefine pcodeop vmwrite;  # Write field to virtual-machine control structure;\n\n                         # opcode 0f 79\n\ndefine pcodeop vmxoff;   # Leave VMX operation; opcode 0f 01 c4\n\ndefine pcodeop vmxon;    # Enter VMX operation; opcode f3 0f C7 /6\n```", "```\ndefine pcodeop vmxoff;   # Leave VMX operation; opcode 0f 01 c4\n\ndefine pcodeop vmxplode; # Explode (Fake) VMX operation; opcode 0f 01 c5\n\ndefine pcodeop vmxon;    # Enter VMX operation; opcode f3 0f C7 /6\n```", "```\n# Intel hardware assisted virtualization opcodes\n\n# -----CONTENT OMITTED HERE-----\n\n# TODO: invokes a VM function specified in EAX➊\n\n:VMFUNC EAX     is vexMode=0 & byte=0x0f; byte=0x01; byte=0xd4 & EAX     { vmfunc(EAX); }\n\n# TODO: this launches the VM managed by the current VMCS. How is the\n\n#       VMCS expressed for the emulator?  For Ghidra analysis?\n\n:VMLAUNCH       is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc2           { vmlaunch(); }\n\n# TODO: this resumes the VM managed by the current VMCS. How is the\n\n#       VMCS expressed for the emulator?  For Ghidra analysis?\n\n:VMRESUME       is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc3           { vmresume(); }\n\n# -----CONTENT OMITTED HERE-----\n\n:VMWRITE Reg32, rm32 is vexMode=0 & opsize=1 & byte=0x0f; byte=0x79;➋\n\n         rm32 & Reg32 ... & check_Reg32_dest ... { vmwrite(rm32,Reg32); build check_Reg32_dest; }\n\n@ifdef IA64➌\n\n:VMWRITE Reg64, rm64 is vexMode=0 & opsize=2 & byte=0x0f;  byte=0x79;\n\n         rm64 & Reg64 ...    { vmwrite(rm64,Reg64); }\n\n@endif\n\n:VMXOFF         is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc4         { vmxoff(); }➍\n\n :VMXPLODE       is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc5         { vmxplode(); }➎\n\n# -----CONTENT OMITTED HERE-----\n\n#END of changes for VMX opcodes\n```", "```\n  @define IA64 \"IA64\"         # Only in x86-64.slaspec\n\n➊ @include \"ia.sinc\"\n\n  @include \"avx.sinc\"\n\n  @include \"avx_manual.sinc\"\n\n  @include \"avx2.sinc\"\n\n  @include \"avx2_manual.sinc\"\n\n  @include \"rdrand.sinc\"      # Only in x86-64.slaspec\n\n  @include \"rdseed.sinc\"      # Only in x86-64.slaspec\n\n  @include \"sgx.sinc\"         # Only in x86-64.slaspec\n\n  @include \"adx.sinc\"\n\n  @include \"clwb.sinc\"\n\n  @include \"pclmulqdq.sinc\"\n\n  @include \"mpx.sinc\"\n\n  @include \"lzcnt.sinc\"\n\n  @include \"bmi1.sinc\"\n\n  @include \"bmi2.sinc\"\n\n  @include \"sha.sinc\"\n\n  @include \"smx.sinc\"\n\n  @include \"cet.sinc\"\n\n  @include \"fma.sinc\"         # Only in x86-64.slaspec\n```", "```\n#include <stdio.h>\n\n// The following function declares an assembly block and tells the\n\n// compiler that it should execute the code without moving or changing it.\n\nvoid do_vmx(int v) {\n\n   asm volatile (\n\n      \"vmxon %0;\"       // Enable hypervisor operation\n\n      \"vmxoff;\"         // Disable hypervisor operation\n\n      \"nop;\"            // Tiny nop slide to accommodate examples\n\n \"nop;\"\n\n      \"nop;\"\n\n      \"nop;\"\n\n      \"nop;\"\n\n      \"nop;\"\n\n      \"nop;\"\n\n      \"vmxoff;\"         // Disable hypervisor operation\n\n      :\n\n      :\"m\"(v)           // Holds the input variable\n\n      :\n\n   );\n\n}\n\nint main() {\n\n   int x;\n\n   printf(\"Enter an int: \");\n\n   scanf(\"%d\", &x);\n\n   printf(\"After input, x=%d\\n\", x);\n\n   do_vmx(x);\n\n   printf(\"After do_vmx, x=%d\\n\", x);\n\n   return 0;\n\n}\n```", "```\n  0010071a 55             PUSH     RBP\n\n  0010071b 48 89 e5       MOV      RBP,RSP\n\n  0010071e 89 7d fc       MOV      dword ptr [RBP + local_c],EDI\n\n  00100721 f3 0f c7       VMXON    qword ptr [RBP + local_c]\n\n           75 fc\n\n➊ 00100726 0f 01 c4       VMXOFF\n\n  00100729 90             NOP\n\n  0010072a 90             NOP\n\n  0010072b 90             NOP\n\n  0010072c 90             NOP\n\n  0010072d 90             NOP\n\n  0010072e 90             NOP\n\n  0010072f 90             NOP\n\n➋ 00100730 0f 01 c4       VMXOFF\n\n  00100733 90             NOP\n\n  00100734 5d             POP RBP\n\n  00100735 c3             RET\n```", "```\nvoid do_vmx(undefined4 param_1)\n\n{\n\n   undefined4 unaff_EBP;\n\n   vmxon(CONCAT44(unaff_EBP,param_1));\n\n   vmxoff();\n\n   vmxoff();\n\n   return;\n\n}\n```", "```\n   //\"vmxoff;\"                 // replace this line\n\n   \".byte 0x0f, 0x01, 0xc5;\"   // with this hand assembled one\n```", "```\n  0010071a 55 PUSH RBP\n\n  0010071b 48 89 e5 MOV RBP,RSP\n\n  0010071e 89 7d fc MOV dword ptr [RBP + local_c],EDI\n\n  00100721 f3 0f c7 VMXON qword ptr [RBP + local_c]\n\n           75 fc\n\n➊ 00100726 0f 01 c5 VMXPLODE\n\n  00100729 90 NOP\n\n  0010072a 90 NOP\n\n  0010072b 90 NOP\n\n  0010072c 90 NOP\n\n  0010072d 90 NOP\n\n  0010072e 90 NOP\n\n  0010072f 90 NOP\n\n  00100730 0f 01 c4 VMXOFF\n\n  00100733 90 NOP\n\n  00100734 5d POP RBP\n\n  00100735 c3 RET\n```", "```\nvoid do_vmx(undefined4 param_1)\n\n{\n\n   undefined4 unaff_EBP;\n\n   vmxon(CONCAT44(unaff_EBP,param_1));\n\n   vmxplode();\n\n   vmxoff();\n\n   return;\n\n}\n```", "```\n:VMXOFF         is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc4      { vmxoff(); }\n\n:VMXPLODE       is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc5      { vmxplode(); }\n```", "```\n:VMXOFF         is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc4      { vmxoff(); }\n\n:VMXPLODE       is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc5      { EAX=0xDAB; vmxplode(); }\n```", "```\nundefined4 do_vmx(undefined4 param_1)\n\n{\n\n   undefined4 unaff_EBP;\n\n   vmxon(CONCAT44(unaff_EBP,param_1));\n\n   vmxplode();\n\n   vmxoff();\n\n   return 0xdab;\n\n}\n```", "```\n00100726 0f 01 c5       VMXPLODE\n```", "```\ndefine pcodeop vmxplode\n```", "```\n0010071b 48 89 e5       MOV      RBP,RSP\n\n                                            RBP = COPY RSP\n\n                                            $U620:8 = INT_ADD RBP, -4:8\n\n                                            $U1fd0:4 = COPY EDI\n\n                                            STORE ram($U620), $U1fd0\n\n00100721 f3 0f c7 75 fc VMXON    qword ptr [RBP + local_c]\n\n                                            $U620:8 = INT_ADD RBP, -4:8\n\n                                            $Ua50:8 = LOAD ram($U620)\n\n                                            CALLOTHER \"vmxon\", $Ua50\n\n00100726 0f 01 c5       VMXPLODE\n\n                                            CALLOTHER \"vmxplode\"\n\n00100729 90             NOP\n```", "```\n00100726 0f 01 c5       VMXPLODE\n\n                                            ➊ EAX = COPY 0xdab:4\n\n                                               CALLOTHER \"vmxplode\"\n```", "```\n:VMXPLODE   Reg32➊ is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc5; Reg32➋\n\n         {  Reg32=0xDAB➋; vmxplode(); }\n```", "```\n# SLA specification file for Intel x86\n\n@ifdef IA64➊\n\n@define SIZE     \"8\"\n\n@define STACKPTR \"RSP\"\n\n@else\n\n@define SIZE     \"4\"\n\n@define STACKPTR \"ESP\"\n\n@endif\n\ndefine endian=little;➋\n\ndefine space ram type=ram_space size=$(SIZE) default;\n\ndefine space register type=register_space size=4;\n\n# General purpose registers➌\n\n@ifdef IA64\n\ndefine register offset=0 size=8 [ RAX    RCX    RDX    RBX    RSP    RBP    RSI    RDI ]➍;\n\ndefine register offset=0 size=4    [ EAX _  ECX _  EDX _  EBX _  ESP _  EBP _  ESI _  EDI ];\n\ndefine register offset=0 size=2    [ AX _ _ _ CX _ _ _ DX _ _ _ BX];       # truncated\n\ndefine register offset=0 size=1    [ AL AH _ _ _ _ _ _ CL CH _ _ _ _ _ _]; # truncated y\n\ndefine register offset=0x80 size=8 [ R8    R9    R10    R11    R12    R13    R14    R15 ]➎;\n\ndefine register offset=0x80 size=4 [ R8D _ R9D _ R10D _ R11D _ R12D _ R13D _ R14D _ R15D ];\n\ndefine register offset=0x80 size=2 [ R8W _ _ _ R9W _ _ _ R10W _ _ _ R11W ];  # truncated\n\ndefine register offset=0x80 size=1 [ R8B _ _ _ _ _ _ _ R9B _ _ _ _ _ _ _ ];  # truncated\n\n@else\n\ndefine register offset=0 size=4    [  EAX  ECX  EDX  EBX  ESP  EBP  ESI  EDI ];\n\ndefine register offset=0 size=2    [  AX _ CX _ DX _ BX _ SP _ BP _ SI _ DI ];\n\ndefine register offset=0 size=1    [  AL AH _ _ CL CH _ _ DL DH _ _ BL BH ];\n\n@endif\n```", "```\n➊ define token modrm (8)\n\n       mod           = (6,7)\n\n       reg_opcode    = (3,5)\n\n       reg_opcode_hb = (5,5)\n\n       r_m           = (0,2)\n\n       row           = (4,7)\n\n       col           = (0,2)\n\n       page          = (3,3)\n\n       cond          = (0,3)\n\n       reg8          = (3,5)\n\n       reg16         = (3,5)\n\n    ➋ reg32         = (3,5)\n\n       reg64         = (3,5)\n\n       reg8_x0       = (3,5)\n```", "```\n# attach variables fieldlist registerlist;\n\n  attach variables [ r32   reg32   base   index ]   [ EAX  ECX  EDX  EBX  ESP  EBP  ESI  EDI ];\n\n#                                                      0    1    2    3    4    5    6    7\n```", "```\nReg32:    reg32  is rexRprefix=0 & reg32   { export reg32; } #64-bit Reg32\n\nReg32:    reg32  is reg32                  { export reg32; } #32-bit Reg32\n```", "```\n:VMXPLODE Reg32➊is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc5; Reg32➋\n\n                                           { Reg32=0xDAB; vmxplode(); }\n```", "```\n\".byte 0x0f, 0x01, 0xc5, 0x08;\"            // hand assembled with operand\n```", "```\n00100721 f3 0f c7 75 fc VMXON    qword ptr [RBP + local_c]\n\n                                            $U620:8 = INT_ADD RBP, -4:8\n\n                                            $Ua50:8 = LOAD ram($U620)\n\n                                            CALLOTHER \"vmxon\", $Ua50\n\n00100726 0f 01 c5 08    VMXPLODE ECX\n\n                                            ECX = COPY 0xdab:4\n\n                                            CALLOTHER \"vmxplode\"\n\n0010072a 90 NOP\n```", "```\n:VMXPLODE Reg32,imm32 is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc5;\n\n          Reg32; imm32                     { Reg32=imm32; vmxplode(); }\n```", "```\n\".byte 0x0f, 0x01, 0xc5, 0x08, 0xb8, 0xdb, 0xee, 0x0f;\"\n\n\"nop;\"\n\n\"nop;\"\n```", "```\n00100726 0f 01 c5       VMXPLODE ECX,0xfeedbb8\n\n         08 b8 db\n\n         ee 0f\n\n                                            ECX = COPY 0xfeedbb8:4\n\n                                            CALLOTHER \"vmxplode\"\n```", "```\ndefine register offset=0  size=4  [EAX ECX EDX EBX ESP EBP ESI EDI];\n```", "```\n# Define VMID and VMVER\n\ndefine register offset=0x1500 size=4 [ VMID VMVER ];\n```", "```\n# Associate vmreg with a single bit in the modrm token.\n\nvmreg = (3, 3)\n```", "```\nattach variables [ vmreg ]   [ VMID  VMVER ];\n```", "```\n:VMXPLODE Reg32,imm32 is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc5;\n\n          Reg32, imm32                     { Reg32=imm32; vmxplode(); }\n\n:VMXPLODE vmreg,imm32 is vexMode=0 & byte=0x0f; byte=0x01; byte=0xc5;\n\n          vmreg, imm32                     { vmreg=imm32; vmxplode(); }\n```", "```\n00100726 0f 01 c5       VMXPLODE   VMVER,0xfeedbb8\n\n         08 b8 db\n\n         ee 0f\n\n                                              VMVER = COPY 0xfeedbb8:4\n\n                                              CALLOTHER \"vmxplode\"\n```"]