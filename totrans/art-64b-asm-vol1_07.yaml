- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Procedures
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In a procedural programming language, the basic unit of code is the procedure.
    A *procedure* is a set of instructions that compute a value or take an action
    (such as printing or reading a character value). This chapter discusses how MASM
    implements procedures, parameters, and local variables. By the end of this chapter,
    you should be well versed in writing your own procedures and functions, and fully
    understand parameter passing and the Microsoft ABI calling convention.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 Implementing Procedures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most procedural programming languages implement procedures by using the call/return
    mechanism. The code calls a procedure, the procedure does its thing, and then
    the procedure returns to the caller. The call and return instructions provide
    the x86-64’s *procedure invocation mechanism*. The calling code calls a procedure
    with the `call` instruction, and the procedure returns to the caller with the
    `ret` instruction. For example, the following x86-64 instruction calls the C Standard
    Library `printf()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alas, the C Standard Library does not supply all the routines you will ever
    need. Most of the time you’ll have to write your own procedures. To do this, you
    will use MASM’s procedure-declaration facilities. A basic MASM procedure declaration
    takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Procedure declarations appear in the `.code` section of your program. In the
    preceding syntax example, `proc_name` represents the name of the procedure you
    wish to define. This can be any valid (and unique) MASM identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a concrete example of a MASM procedure declaration. This procedure
    stores 0s into the 256 double words that RCX points at upon entry into the procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you’ve probably noticed, this simple procedure doesn’t bother with the “magic”
    instructions that add and subtract a value to and from the RSP register. Those
    instructions are a requirement of the Microsoft ABI when the procedure will be
    calling other C/C++ code (or other code written in a Microsoft ABI–compliant language).
    Because this little function doesn’t call any other procedures, it doesn’t bother
    executing such code. Also note that this code uses the loop index to count down
    from 256 to 0, filling in the 256 dword array backward (from end to beginning)
    rather than filling it in from beginning to end. This is a common technique in
    assembly language.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the x86-64 `call` instruction to call this procedure. When, during
    program execution, the code falls into the `ret` instruction, the procedure returns
    to whoever called it and begins executing the first instruction beyond the `call`
    instruction. The program in [Listing 5-1](#listing5-1) provides an example of
    a call to the `zeroBytes` routine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-1: Example of a simple procedure'
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.1 The call and ret Instructions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The x86-64 `call` instruction does two things. First, it pushes the (64-bit)
    address of the instruction immediately following the `call` onto the stack; then
    it transfers control to the address of the specified procedure. The value that
    `call` pushes onto the stack is known as the *return address*.
  prefs: []
  type: TYPE_NORMAL
- en: When the procedure wants to return to the caller and continue execution with
    the first statement following the `call` instruction, most procedures return to
    their caller by executing a `ret` (*return*) instruction. The `ret` instruction
    pops a (64-bit) return address off the stack and transfers control indirectly
    to that address.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of the minimal procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you call this procedure with the `call` instruction, `minimal` will simply
    pop the return address off the stack and return to the caller. If you fail to
    put the `ret` instruction in the procedure, the program will not return to the
    caller upon encountering the `endp` statement. Instead, the program will fall
    through to whatever code happens to follow the procedure in memory.
  prefs: []
  type: TYPE_NORMAL
- en: The example program in [Listing 5-2](#listing5-2) demonstrates this problem.
    The main program calls `noRet`, which falls straight through to `followingProc`
    (printing the message `followingProc was called`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-2: Effect of a missing `ret` instruction in a procedure'
  prefs: []
  type: TYPE_NORMAL
- en: Although this behavior might be desirable in certain rare circumstances, it
    usually represents a defect in most programs. Therefore, always remember to explicitly
    return from the procedure by using the `ret` instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 5.1.2 Labels in a Procedure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Procedures may contain statement labels, just like the main procedure in your
    assembly language program (after all, the main procedure, `asmMain` in most of
    the examples in this book, is just another procedure declaration as far as MASM
    is concerned). Note, however, that statement labels defined within a procedure
    are *local* to that procedure; such symbols are not *visible* outside the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: In most situations, having *scoped symbols* in a procedure is nice (see “Local
    (Automatic) Variables” on page 234 for a discussion of scope). You don’t have
    to worry about *namespace pollution* (conflicting symbol names) among the different
    procedures in your source file. Sometimes, however, MASM’s name scoping can create
    problems. You might actually want to refer to a statement label outside a procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to do this on a label-by-label basis is to use a global statement label
    declaration. *Global statement labels* are similar to normal statement labels
    in a procedure except you follow the symbol with two colons instead of a single
    colon, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Global statement labels are visible outside the procedure. You can use an unconditional
    or conditional jump instruction to transfer control to a global symbol from outside
    the procedure; you can even use a `call` instruction to call that global symbol
    (in which case, it becomes a second entry point to the procedure). Generally,
    having multiple entry points to a procedure is considered bad programming style,
    and the use of multiple entry points often leads to programming errors. As such,
    you should rarely use global symbols in assembly language procedures.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, for some reason, you don’t want MASM to treat all the statement labels
    in a procedure as local to that procedure, you can turn scoping on and off with
    the following statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `option noscoped` directive disables scoping in procedures (for all procedures
    following the directive). The `option scoped` directive turns scoping back on.
    Therefore, you can turn scoping off for a single procedure (or set of procedures)
    and turn it back on immediately afterward.
  prefs: []
  type: TYPE_NORMAL
- en: 5.2 Saving the State of the Machine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take a look at [Listing 5-3](#listing5-3). This program attempts to print 20
    lines of 40 spaces and an asterisk. Unfortunately, a subtle bug creates an infinite
    loop. The main program uses the `jnz printLp` instruction to create a loop that
    calls `PrintSpaces` 20 times. This function uses EBX to count off the 40 spaces
    it prints, and then returns with ECX containing 0\. The main program then prints
    an asterisk and a newline, decrements ECX, and then repeats because ECX isn’t
    0 (it will always contain 0FFFF_FFFFh at this point).
  prefs: []
  type: TYPE_NORMAL
- en: The problem here is that the `print40Spaces` subroutine doesn’t preserve the
    EBX register. *Preserving a register* means you save it upon entry into the subroutine
    and restore it before leaving. Had the `print40Spaces` subroutine preserved the
    contents of the EBX register, [Listing 5-3](#listing5-3) would have functioned
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-3: Program with an unintended infinite loop'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the x86-64’s `push` and `pop` instructions to preserve register
    values while you need to use them for something else. Consider the following code
    for `PrintSpaces`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`print40Spaces` saves and restores RBX by using `push` and `pop` instructions.
    Either the caller (the code containing the call instruction) or the callee (the
    subroutine) can take responsibility for preserving the registers. In the preceding
    example, the callee preserves the registers.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 5-4](#listing5-4) shows what this code might look like if the caller
    preserves the registers (for reasons that will become clear in “Saving the State
    of the Machine, Part II” on page 280, the main program saves the value of RBX
    in a static memory location rather than using the stack).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-4: Demonstration of caller register preservation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Callee preservation has two advantages: space and maintainability. If the callee
    (the procedure) preserves all affected registers, only one copy of the `push`
    and `pop` instructions exists—those the procedure contains. If the caller saves
    the values in the registers, the program needs a set of preservation instructions
    around every call. This makes your programs not only longer but also harder to
    maintain. Remembering which registers to save and restore on each procedure call
    is not easily done.'
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a subroutine may unnecessarily preserve some registers if
    it preserves all the registers it modifies. In the preceding examples, the `print40Spaces`
    procedure didn’t save RBX. Although `print40Spaces` changes RBX, this won’t affect
    the program’s operation. If the caller is preserving the registers, it doesn’t
    have to save registers it doesn’t care about.
  prefs: []
  type: TYPE_NORMAL
- en: One big problem with having the caller preserve registers is that your program
    may change over time. You may modify the calling code or the procedure to use
    additional registers. Such changes, of course, may change the set of registers
    that you must preserve. Worse still, if the modification is in the subroutine
    itself, you will need to locate *every* call to the routine and verify that the
    subroutine does not change any registers the calling code uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assembly language programmers use a common convention with respect to register
    preservation: unless there is a good reason (performance) for doing otherwise,
    most programmers will preserve all registers that a procedure modifies (and that
    doesn’t explicitly return a value in a modified register). This reduces the likelihood
    of defects occurring in a program because a procedure modifies a register the
    caller expects to be preserved. Of course, you could follow the rules concerning
    the Microsoft ABI with respect to volatile and nonvolatile registers; however,
    such calling conventions impose their own inefficiencies on programmers (and other
    programs).'
  prefs: []
  type: TYPE_NORMAL
- en: Preserving registers isn’t all there is to preserving the environment. You can
    also push and pop variables and other values that a subroutine might change. Because
    the x86-64 allows you to push and pop memory locations, you can easily preserve
    these values as well.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 Procedures and the Stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because procedures use the stack to hold the return address, you must exercise
    caution when pushing and popping data within a procedure. Consider the following
    simple (and defective) procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: At the point the program encounters the `ret` instruction, the x86-64 stack
    takes the form shown in [Figure 5-1](#figure5-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05001](image_fi/501089c05/f05001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-1: Stack contents before `ret` in the `MessedUp` procedure'
  prefs: []
  type: TYPE_NORMAL
- en: The `ret` instruction isn’t aware that the value on the top of the stack is
    not a valid address. It simply pops whatever value is on top and jumps to that
    location. In this example, the top of the stack contains the saved RAX value.
    Because it is very unlikely that RAX’s value pushed on the stack was the proper
    return address, this program will probably crash or exhibit another undefined
    behavior. Therefore, when pushing data onto the stack within a procedure, you
    must take care to properly pop that data prior to returning from the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Popping extra data off the stack prior to executing the `ret` statement can
    also create havoc in your programs. Consider the following defective procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Upon reaching the `ret` instruction in this procedure, the x86-64 stack looks
    something like [Figure 5-2](#figure5-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05002](image_fi/501089c05/f05002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-2: Stack contents before `ret` in `MessedUp2`'
  prefs: []
  type: TYPE_NORMAL
- en: Once again, the `ret` instruction blindly pops whatever data happens to be on
    the top of the stack and attempts to return to that address. Unlike the previous
    example, in which the top of the stack was unlikely to contain a valid return
    address (because it contained the value in RAX), there is a small possibility
    that the top of the stack in this example *does* contain a return address. However,
    this will not be the proper return address for the `messedUp2` procedure; instead,
    it will be the return address for the procedure that called `messedUp2`. To understand
    the effect of this code, consider the program in [Listing 5-5](#listing5-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-5: Effect of popping too much data off the stack'
  prefs: []
  type: TYPE_NORMAL
- en: Because a valid return address is sitting on the top of the stack when `proc1`
    is entered, you might think that this program will actually work (properly). However,
    when returning from the `proc1` procedure, this code returns directly to the `asmMain`
    program rather than to the proper return address in the `proc2` procedure. Therefore,
    all code in the `proc2` procedure that follows the call to `proc1` does not execute.
  prefs: []
  type: TYPE_NORMAL
- en: When reading the source code, you may find it very difficult to figure out why
    those statements are not executing, because they immediately follow the call to
    the `proc1` procedure. It isn’t clear, unless you look very closely, that the
    program is popping an extra return address off the stack and therefore doesn’t
    return to `proc2` but rather returns directly to whoever calls `proc2`. Therefore,
    you should always be careful about pushing and popping data in a procedure, and
    verify that a one-to-one relationship exists between the pushes in your procedures
    and the corresponding pops.^([1](#c05-footnote-1))
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.1 Activation Records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever you call a procedure, the program associates certain information with
    that procedure call, including the return address, parameters, and automatic local
    variables, using a data structure called an *activation record.*^([2](#c05-footnote-2))
    The program creates an activation record when calling (activating) a procedure,
    and the data in the structure is organized in a manner identical to records.
  prefs: []
  type: TYPE_NORMAL
- en: Construction of an activation record begins in the code that calls a procedure.
    The caller makes room for the parameter data (if any) on the stack and copies
    the data onto the stack. Then the `call` instruction pushes the return address
    onto the stack. At this point, construction of the activation record continues
    within the procedure itself. The procedure pushes registers and other important
    state information and then makes room in the activation record for local variables.
    The procedure might also update the RBP register so that it points at the base
    address of the activation record.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what a traditional activation record looks like, consider the following
    C++ procedure declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Whenever a program calls this `ARDemo` procedure, it begins by pushing the data
    for the parameters onto the stack. In the original C/C++ calling convention (ignoring
    the Microsoft ABI), the calling code pushes the parameters onto the stack in the
    opposite order that they appear in the parameter list, from right to left. Therefore,
    the calling code first pushes the value for the `k` parameter, then it pushes
    the value for the `j` parameter, and it finally pushes the data for the `i` parameter.
    After pushing the parameters, the program calls the `ARDemo` procedure. Immediately
    upon entry into the `ARDemo` procedure, the stack contains these four items arranged
    as shown in [Figure 5-3](#figure5-3). By pushing the parameters in the reverse
    order, they appear on the stack in the correct order (with the first parameter
    at the lowest address in memory).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05003](image_fi/501089c05/f05003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-3: Stack organization immediately upon entry into `ARDemo`'
  prefs: []
  type: TYPE_NORMAL
- en: The first few instructions in `ARDemo` will push the current value of RBP onto
    the stack and then copy the value of RSP into RBP.^([3](#c05-footnote-3)) Next,
    the code drops the stack pointer down in memory to make room for the local variables.
    This produces the stack organization shown in [Figure 5-4](#figure5-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05004](image_fi/501089c05/f05004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-4: Activation record for `ARDemo`'
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.1.1 Accessing Objects in the Activation Record
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To access objects in the activation record, you must use offsets from the RBP
    register to the desired object. The two items of immediate interest to you are
    the parameters and the local variables. You can access the parameters at positive
    offsets from the RBP register; you can access the local variables at negative
    offsets from the RBP register, as [Figure 5-5](#figure5-5) shows.
  prefs: []
  type: TYPE_NORMAL
- en: Intel specifically reserves the RBP (Base Pointer) register for use as a pointer
    to the base of the activation record. This is why you should avoid using the RBP
    register for general calculations. If you arbitrarily change the value in the
    RBP register, you could lose access to the current procedure’s parameters and
    local variables.
  prefs: []
  type: TYPE_NORMAL
- en: The local variables are aligned on offsets that are equal to their native size
    (chars are aligned on 1-byte addresses, shorts/words are aligned on 2-byte addresses,
    longs/ints/unsigneds/dwords are aligned on 4-byte addresses, and so forth). In
    the `ARDemo` example, all of the locals just happen to be allocated on appropriate
    addresses (assuming a compiler allocates storage in the order of declaration).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05005](image_fi/501089c05/f05005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-5: Offsets of objects in the `ARDemo` activation record'
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.1.2 Using Microsoft ABI Parameter Conventions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The Microsoft ABI makes several modifications to the activation record model,
    in particular:'
  prefs: []
  type: TYPE_NORMAL
- en: The caller passes the first four parameters in registers rather than on the
    stack (though it must still reserve storage on the stack for those parameters).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters are always 8-byte values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The caller must reserve (at least) 32 bytes of parameter data on the stack,
    even if there are fewer than five parameters (plus 8 bytes for each additional
    parameter if there are five or more parameters).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RSP must be 16-byte-aligned immediately before the `call` instruction pushes
    the return address onto the stack.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more information, see “Microsoft ABI Notes” in Chapter 1. You must follow
    these conventions only when calling Windows or other Microsoft ABI–compliant code.
    For assembly language procedures that you write and call, you can use any convention
    you like.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.2 The Assembly Language Standard Entry Sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The caller of a procedure is responsible for allocating storage for parameters
    on the stack and moving the parameter data to its appropriate location. In the
    simplest case, this just involves pushing the data onto the stack by using 64-bit
    `push` instructions. The `call` instruction pushes the return address onto the
    stack. It is the procedure’s responsibility to construct the rest of the activation
    record. You can accomplish this by using the following assembly language *standard
    entry sequence* code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If the procedure doesn’t have any local variables, the third instruction shown
    here, `sub rsp,` `num_vars`, isn’t necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '`num_vars` represents the number of *bytes* of local variables needed by the
    procedure, a constant that should be a multiple of 16 (so the RSP register remains
    aligned on a 16-byte boundary).^([4](#c05-footnote-4)) If the number of bytes
    of local variables in the procedure is not a multiple of 16, you should round
    up the value to the next higher multiple of 16 before subtracting this constant
    from RSP. Doing so will slightly increase the amount of storage the procedure
    uses for local variables but will not otherwise affect the operation of the procedure.'
  prefs: []
  type: TYPE_NORMAL
- en: If a Microsoft ABI–compliant program calls your procedure, the stack will be
    aligned on a 16-byte boundary immediately prior to the execution of the `call`
    instruction. As the return address adds 8 bytes to the stack, immediately upon
    entry into your procedure, the stack will be aligned on an (*RSP mod 16*) == *8*
    address (aligned on an 8-byte address but not on a 16-byte address). Pushing RBP
    onto the stack (to save the old value before copying RSP into RBP) adds another
    8 bytes to the stack so that RSP is now 16-byte-aligned. Therefore, assuming the
    stack was 16-byte-aligned prior to the call, and the number you subtract from
    RSP is a multiple of 16, the stack will be 16-byte-aligned after allocating storage
    for local variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you cannot ensure that RSP is 16-byte-aligned (*RSP mod 16 == 8*) upon entry
    into your procedure, you can always force 16-byte alignment by using the following
    sequence at the beginning of your procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The –16 is equivalent to 0FFFF_FFFF_FFFF_FFF0h. The `and` instruction sequence
    forces the stack to be aligned on a 16-byte boundary (it reduces the value in
    the stack pointer so that it is a multiple of 16).
  prefs: []
  type: TYPE_NORMAL
- en: The `ARDemo` activation record has only 12 bytes of local storage. Therefore,
    subtracting 12 from RSP for the local variables will not leave the stack 16-byte-aligned.
    The `and` instruction in the preceding sequence, however, guarantees that RSP
    is 16-byte-aligned regardless of RSP’s value upon entry into the procedure (this
    adds in the padding bytes shown in [Figure 5-5](#figure5-5)). The few bytes and
    CPU cycles needed to execute this instruction would pay off handsomely if RSP
    was not oword aligned. Of course, if you know that the stack was properly aligned
    before the call, you could dispense with the extra `and` instruction and simply
    subtract 16 from RSP rather than 12 (in other words, reserving 4 more bytes than
    the `ARDemo` procedure needs, to keep the stack aligned).
  prefs: []
  type: TYPE_NORMAL
- en: 5.3.3 The Assembly Language Standard Exit Sequence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before a procedure returns to its caller, it needs to clean up the activation
    record. Standard MASM procedures and procedure calls, therefore, assume that it
    is the procedure’s responsibility to clean up the activation record, although
    it is possible to share the cleanup duties between the procedure and the procedure’s
    caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a procedure does not have any parameters, the exit sequence is simple. It
    requires only three instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the Microsoft ABI (as opposed to pure assembly procedures), it is the caller’s
    responsibility to clean up any parameters pushed on the stack. Therefore, if you
    are writing a function to be called from C/C++ (or other Microsoft ABI–compliant
    code), your procedure doesn’t have to do anything at all about the parameters
    on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are writing procedures that will be called only from your assembly language
    programs, it is possible to have the callee (the procedure) rather than the caller
    clean up the parameters on the stack upon returning to the caller, using the following
    standard exit sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `parm_bytes` operand of the `ret` instruction is a constant that specifies
    the number of bytes of parameter data to remove from the stack after the return
    instruction pops the return address. For example, the `ARDemo` example code in
    the previous sections has three quad words reserved for the parameters (because
    we want to keep the stack qword aligned). Therefore, the standard exit sequence
    would take the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you do not specify a 16-bit constant operand to the `ret` instruction, the
    x86-64 will not pop the parameters off the stack upon return. Those parameters
    will still be sitting on the stack when you execute the first instruction following
    the `call` to the procedure. Similarly, if you specify a value that is too small,
    some of the parameters will be left on the stack upon return from the procedure.
    If the `ret` operand you specify is too large, the `ret` instruction will actually
    pop some of the caller’s data off the stack, usually with disastrous consequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the way, Intel has added a special instruction to the instruction set to
    shorten the standard exit sequence: `leave`. This instruction copies RBP into
    RSP and then pops RBP. The following is equivalent to the standard exit sequence
    presented thus far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The choice is up to you. Most compilers generate the `leave` instruction (because
    it’s shorter), so using it is the standard choice.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4 Local (Automatic) Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Procedures and functions in most high-level languages let you declare *local
    variables*. These are generally accessible only within the procedure; they are
    not accessible by the code that calls the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Local variables possess two special attributes in HLLs: scope and lifetime.The
    *scope* of an identifier determines where that identifier is visible (accessible)
    in the source file during compilation. In most HLLs, the scope of a procedure’s
    local variable is the body of that procedure; the identifier is inaccessible outside
    that procedure.'
  prefs: []
  type: TYPE_NORMAL
- en: Whereas scope is a compile-time attribute of a symbol, *lifetime* is a runtime
    attribute. The lifetime of a variable is from that point when storage is first
    bound to the variable until the point where the storage is no longer available
    for that variable. Static objects (those you declare in the `.data`, `.const`,
    `.data?`, and `.code` sections) have a lifetime equivalent to the total runtime
    of the application. The program allocates storage for such variables when the
    program first loads into memory, and those variables maintain that storage until
    the program terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Local variables (or, more properly, *automatic variables*) have their storage
    allocated upon entry into a procedure, and that storage is returned for other
    use when the procedure returns to its caller. The name *automatic* refers to the
    program automatically allocating and deallocating storage for the variable on
    procedure invocation and return.
  prefs: []
  type: TYPE_NORMAL
- en: A procedure can access any global `.data`, `.data?`, or `.const` object the
    same way the main program accesses such variables—by referencing the name (using
    the PC-relative addressing mode). Accessing global objects is convenient and easy.
    Of course, accessing global objects makes your programs harder to read, understand,
    and maintain, so you should avoid using global variables within procedures. Although
    accessing global variables within a procedure may sometimes be the best solution
    to a given problem, you likely won’t be writing such code at this point, so you
    should carefully consider your options before doing so.^([5](#c05-footnote-5))
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.1 Low-Level Implementation of Automatic (Local) Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your program accesses local variables in a procedure by using negative offsets
    from the activation record base address (RBP). Consider the following MASM procedure
    in [Listing 5-6](#listing5-6) (which admittedly doesn’t do much, other than demonstrate
    the use of local variables).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-6: Sample procedure that accesses local variables'
  prefs: []
  type: TYPE_NORMAL
- en: The standard entry sequence allocates 16 bytes of storage even though locals
    `a` and `b` require only 8\. This keeps the stack 16-byte-aligned. If this isn’t
    necessary for a particular procedure, subtracting 8 would work just as well.
  prefs: []
  type: TYPE_NORMAL
- en: The activation record for `localVars` appears in [Figure 5-6](#figure5-6).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, having to refer to the local variables by the offset from the RBP
    register is truly horrible. This code is not only difficult to read (is `[RBP-4]`
    the `a` or the `b` variable?) but also hard to maintain. For example, if you decide
    you no longer need the `a` variable, you’d have to go find every occurrence of
    `[RBP-8]` (accessing the `b` variable) and change it to `[RBP-4]`.
  prefs: []
  type: TYPE_NORMAL
- en: '![f05006](image_fi/501089c05/f05006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-6: Activation record for the `LocalVars` procedure'
  prefs: []
  type: TYPE_NORMAL
- en: A slightly better solution is to create equates for your local variable names.
    Consider the modification to [Listing 5-6](#listing5-6) shown here in [Listing
    5-7](#listing5-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-7: Local variables using equates'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is considerably easier to read and maintain than the former program in
    [Listing 5-6](#listing5-6). It’s possible to improve on this equate system. For
    example, the following four equates are perfectly legitimate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: MASM will associate `[RBP-4]` with `a`, `[RBP-8]` with `b`, `[RBP-12]` with
    `d`, and `[RBP-16]` with `e`. However, getting too crazy with fancy equates doesn’t
    pay; MASM provides a high-level-like declaration for local variables (and parameters)
    you can use if you really want your declarations to be as maintainable as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.2 The MASM Local Directive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating equates for local variables is a lot of work and error prone. It’s
    easy to specify the wrong offset when defining equates, and adding and removing
    local variables from a procedure is a headache. Fortunately, MASM provides a directive
    that lets you specify local variables, and MASM automatically fills in the offsets
    for the locals. That directive, `local`, uses the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `list_of_declarations` is a list of local variable declarations, separated
    by commas. A local variable declaration has two main forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, `type` is one of the usual MASM data types (`byte`, `word`, `dword`, and
    so forth), and `identifier` is the name of the local variable you are declaring.
    The second form declares local arrays, where `elements` is the number of array
    elements. `elements` must be a constant expression that MASM can resolve at assembly
    time.
  prefs: []
  type: TYPE_NORMAL
- en: '`local` directives, if they appear in a procedure, must be the first statement(s)
    after a procedure declaration (the `proc` directive). A procedure may have more
    than one local statement; if there is more than one `local` directive, all must
    appear together after the `proc` declaration. Here’s a code snippet with examples
    of local variable declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'MASM automatically associates appropriate offsets with each variable you declare
    via the `local` directive. MASM assigns offsets to the variables by subtracting
    the variable’s size from the current offset (starting at zero) and then rounding
    down to an offset that is a multiple of the object’s size. For example, if `userType`
    is `typedef`’d to `real8`, MASM assigns offsets to the local variables in `procWithLocals`
    as shown in the following MASM listing output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In addition to assigning an offset to each local variable, MASM associates the
    `[RBP-constant]` addressing mode with each of these symbols. Therefore, if you
    use a statement like `mov ax, local2` in the procedure, MASM will substitute `[RBP-4]`
    for the symbol `local2`.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, upon entry into the procedure, you must still allocate storage for
    the local variables on the stack; that is, you must still provide the code for
    the standard entry (and standard exit) sequence. This means you must add up all
    the storage needed for the local variables so you can subtract this value from
    RSP after moving RSP’s value into RBP. Once again, this is grunt work that could
    turn out to be a source of defects in the procedure (if you miscount the number
    of bytes of local variable storage), so you must take care when manually computing
    the storage requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'MASM does provide a solution (of sorts) for this problem: the `option` directive.
    You’ve seen the `option casemap:none`, `option noscoped`, and `option scoped`
    directives already; the `option` directive actually supports a wide array of arguments
    that control MASM’s behavior. Two option operands control procedure code generation
    when using the local directive: `prologue` and `epilogue`. These operands typically
    take the following two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: By default, MASM assumes `prologue:none` and `epilogue:none`. When you specify
    `none` as the `prologue` and `epilogue` values, MASM will not generate any extra
    code to support local variable storage allocation and deallocation in a procedure;
    you will be responsible for supplying the standard entry and exit sequences for
    the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: If you insert the `option prologue:``PrologueDef` (default prologue generation)
    and `option epilogue:``EpilogueDef` (default epilogue generation) into your source
    file, all following procedures will automatically generate the appropriate standard
    entry and exit sequences for you (assuming local directives are in the procedure).
    MASM will quietly generate the standard entry sequence (the *prologue*) immediately
    after the last local directive (and before the first machine instruction) in a
    procedure, consisting of the usual standard entry sequence instructions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: where `local_size` is a constant specifying the number of local variables plus
    a (possible) additional amount to leave the stack aligned on a 16-byte boundary.
    (MASM usually assumes the stack was aligned on a *mod 16 == 8* boundary prior
    to the `push rbp` instruction.)
  prefs: []
  type: TYPE_NORMAL
- en: 'For MASM’s automatically generated prologue code to work, the procedure must
    have exactly one entry point. If you define a global statement label as a second
    entry point, MASM won’t know that it is supposed to generate the prologue code
    at that point. Entering the procedure at that second entry point will create problems
    unless you explicitly include the standard entry sequence yourself. Moral of the
    story: procedures should have exactly one entry point.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generating the standard exit sequence for the epilogue is a bit more problematic.
    Although it is rare for an assembly language procedure to have more than a single
    *entry* point, it’s common to have multiple *exit* points. After all, the exit
    point is controlled by the programmer’s placement of a `ret` instruction, not
    by a directive (like `endp`). MASM deals with the issue of multiple exit points
    by automatically translating any `ret` instruction it finds into the standard
    exit sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Assuming, of course, that `option epilogue:EpilogueDef` is active.
  prefs: []
  type: TYPE_NORMAL
- en: You can control whether MASM generates prologues (standard entry sequences)
    and epilogues (standard exit sequences) independently of one another. So if you
    would prefer to write the `leave` instruction yourself (while having MASM generate
    the standard entry sequence), you can.
  prefs: []
  type: TYPE_NORMAL
- en: One final note about the `prologue:` and `epilogue:` options. In addition to
    specifying `prologue:PrologueDef` and `epilogue:EpilogueDef`, you can also supply
    a *macro identifier* after the `prologue:` or `epilogue:` options. If you supply
    a macro identifier, MASM will expand that macro for the standard entry or exit
    sequence. For more information on macros, see “Macros and the MASM Compile-Time
    Language” in Chapter 13.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the example programs throughout the remainder of this book continue
    to use `textequ` declarations for local variables rather than the `local` directive
    to make the use of the `[RBP-constant]` addressing mode and local variable offsets
    more explicit.
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.3 Automatic Allocation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One big advantage to automatic storage allocation is that it efficiently shares
    a fixed pool of memory among several procedures. For example, say you call three
    procedures in a row, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The first procedure (`ProcA` in this code) allocates its local variables on
    the stack. Upon return, `ProcA` deallocates that stack storage. Upon entry into
    `ProcB`, the program allocates storage for `ProcB`’s local variables by *using
    the same memory locations just freed by ProcA*. Likewise, when `ProcB` returns
    and the program calls `ProcC`, `ProcC` uses the same stack space for its local
    variables that `ProcB` recently freed up. This memory reuse makes efficient use
    of the system resources and is probably the greatest advantage to using automatic
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen how assembly language allocates and deallocates storage
    for local variables, it’s easy to understand why automatic variables do not maintain
    their values between two calls to the same procedure. Once the procedure returns
    to its caller, the storage for the automatic variable is lost, and, therefore,
    the value is lost as well. Thus, *you must always assume that a local* `var` *object
    is uninitialized upon entry into a procedure*. If you need to maintain the value
    of a variable between calls to a procedure, you should use one of the static variable
    declaration types.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5 Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although many procedures are totally self-contained, most require input data
    and return data to the caller. *Parameters* are values that you pass to and from
    a procedure. In straight assembly language, passing parameters can be a real chore.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to consider when discussing parameters is how we pass them
    to a procedure. If you are familiar with Pascal or C/C++, you’ve probably seen
    two ways to pass parameters: *pass by value* and *pass by reference*. Anything
    that can be done in an HLL can be done in assembly language (obviously, as HLL
    code compiles into machine code), but you have to provide the instruction sequence
    to access those parameters in an appropriate fashion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another concern you will face when dealing with parameters is *where* you pass
    them. There are many places to pass parameters: in registers, on the stack, in
    the code stream, in global variables, or in a combination of these. This chapter
    covers several of the possibilities.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.1 Pass by Value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A parameter passed by value is just that—the caller passes a value to the procedure.
    Pass-by-value parameters are input-only parameters. You can pass them to a procedure,
    but the procedure cannot return values through them. Consider this C/C++ function
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: If you pass `I` by value, `CallProc()` does not change the value of`I`, regardless
    of what happens to the parameter inside `CallProc()`.
  prefs: []
  type: TYPE_NORMAL
- en: Because you must pass a copy of the data to the procedure, you should use this
    method only for passing small objects like bytes, words, double words, and quad
    words. Passing large arrays and records by value is inefficient (because you must
    create and pass a copy of the object to the procedure).^([6](#c05-footnote-6))
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.2 Pass by Reference
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To pass a parameter by reference, you must pass the address of a variable rather
    than its value. In other words, you must pass a pointer to the data. The procedure
    must dereference this pointer to access the data. Passing parameters by reference
    is useful when you must modify the actual parameter or when you pass large data
    structures between procedures. Because pointers on the x86-64 are 64 bits wide,
    a parameter that you pass by reference will consist of a quad-word value.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can compute the address of an object in memory in two common ways: the
    `offset` operator or the `lea` instruction. You can use the `offset` operator
    to take the address of any static variable you’ve declared in your `.data`, `.data?`,
    `.const`, or `.code` sections. [Listing 5-8](#listing5-8) demonstrates how to
    obtain the address of a static variable (`staticVar`) and pass that address to
    a procedure (`someFunc`) in the RCX register.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-8: Using the `offset` operator to obtain the address of a static
    variable'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `offset` operator raises a couple of issues. First of all, it can
    compute the address of only a static variable; you cannot obtain the address of
    an automatic (local) variable or parameter, nor can you compute the address of
    a memory reference involving a complex memory addressing mode (for example, `[RBX+RDX*1-5]`).
    Another problem is that an instruction like `mov rcx, offset staticVar` assembles
    into a large number of bytes (because the `offset` operator returns a 64-bit constant).
    If you look at the assembly listing MASM produces (with the `/Fl` command line
    option), you can see how big this instruction is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see here, the `mov` instruction is 10 (0Ah) bytes long.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve seen numerous examples of the second way to obtain the address of a
    variable: the `lea` instruction (for example, when loading the address of a format
    string into RCX prior to calling `printf()`). [Listing 5-9](#listing5-9) shows
    the example in [Listing 5-8](#listing5-8) recoded to use the `lea` instruction.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-9: Obtaining the address of a variable using the `lea` instruction'
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the listing MASM produces for this code, we find that the `lea`
    instruction is only 7 bytes long:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: So, if nothing else, your programs will be shorter if you use the `lea` instruction
    rather than the `offset` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another advantage to using `lea` is that it will accept any memory addressing
    mode, not just the name of a static variable. For example, if `staticVar` were
    an array of 32-bit integers, you could load the current element address, indexed
    by the RDX register, in RCX by using an instruction such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Pass by reference is usually less efficient than pass by value. You must dereference
    all pass-by-reference parameters on each access; this is slower than simply using
    a value because it typically requires at least two instructions. However, when
    passing a large data structure, pass by reference is faster because you do not
    have to copy the large data structure before calling the procedure. Of course,
    you’d probably need to access elements of that large data structure (for example,
    an array) by using a pointer, so little efficiency is lost when you pass large
    arrays by reference.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.3 Low-Level Parameter Implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A parameter-passing mechanism is a contract between the caller and the callee
    (the procedure). Both parties have to agree on where the parameter data will appear
    and what form it will take (for example, value or address). If your assembly language
    procedures are being called only by other assembly language code that you’ve written,
    you control both sides of the contract negotiation and get to decide where and
    how you’re going to pass parameters.
  prefs: []
  type: TYPE_NORMAL
- en: However, if external code is calling your procedure, or your procedure is calling
    external code, your procedure will have to adhere to whatever *calling convention*
    that external code uses. On 64-bit Windows systems, that calling convention will,
    undoubtedly, be the Windows ABI.
  prefs: []
  type: TYPE_NORMAL
- en: Before discussing the Windows calling conventions, we’ll consider the situation
    of calling code that you’ve written (and, therefore, have complete control over
    the calling conventions). The following sections provide insight into the various
    ways you can pass parameters in pure assembly language code (without the overhead
    associated with the Microsoft ABI).
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.3.1 Passing Parameters in Registers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Having touched on *how* to pass parameters to a procedure, the next thing to
    discuss is *where* to pass parameters. This depends on the size and number of
    those parameters. If you are passing a small number of parameters to a procedure,
    the registers are an excellent place to pass them. If you are passing a single
    parameter to a procedure, you should use the registers listed in [Table 5-1](#table5-1)
    for the accompanying data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5-1: Parameter Location by Size'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data size** | **Pass in this register** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Byte | CL |'
  prefs: []
  type: TYPE_TB
- en: '| Word | CX |'
  prefs: []
  type: TYPE_TB
- en: '| Double word | ECX |'
  prefs: []
  type: TYPE_TB
- en: '| Quad word | RCX |'
  prefs: []
  type: TYPE_TB
- en: This is not a hard-and-fast rule. However, these registers are convenient because
    they mesh with the first parameter register in the Microsoft ABI (which is where
    most people will pass a single parameter).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are passing several parameters to a procedure in the x86-64’s registers,
    you should probably use up the registers in the following order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In general, you should pass integer and other non-floating-point values in the
    general-purpose registers, and floating-point values in the XMM*x*/YMM*x* registers.
    This is not a hard requirement, but Microsoft reserves these registers for passing
    parameters and for local variables (*volatile*), so using these registers to pass
    parameters won’t mess with Microsoft ABI nonvolatile registers. Of course, if
    you intend to have Microsoft ABI–compliant code call your procedure, you must
    exactly observe the Microsoft calling conventions (see “Calling Conventions and
    the Microsoft ABI” on page 261).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you’re writing pure assembly language code (no calls to or from
    any code you didn’t write), you can use most of the general-purpose registers
    as you see fit (RSP is an exception, and you should avoid RBP, but the others
    are fair game). Ditto for the XMM/YMM registers.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider the `strfill(s,c)` procedure that copies the character
    `c` (passed by value in AL) to each character position in `s` (passed by reference
    in RDI) up to a zero-terminating byte ([Listing 5-10](#listing5-10)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-10: Passing parameters in registers to the `strfill` procedure'
  prefs: []
  type: TYPE_NORMAL
- en: 'To call the `strfill` procedure, you would load the address of the string data
    into RDI and the character value into AL prior to the call. The following code
    fragment demonstrates a typical call to `strfill`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This code passes the string by reference and the character data by value.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.3.2 Passing Parameters in the Code Stream
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another place where you can pass parameters is in the code stream immediately
    after the `call` instruction. Consider the following `print` routine that prints
    a literal string constant to the standard output device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Normally, a subroutine returns control to the first instruction immediately
    following the `call` instruction. Were that to happen here, the x86-64 would attempt
    to interpret the ASCII codes for `"This..."` as an instruction. This would produce
    undesirable results. Fortunately, you can skip over this string before returning
    from the subroutine.
  prefs: []
  type: TYPE_NORMAL
- en: So how do you gain access to these parameters? Easy. The return address on the
    stack points at them. Consider the implementation of `print` appearing in [Listing
    5-11](#listing5-11).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-11: Print procedure implementation (using code stream parameters)'
  prefs: []
  type: TYPE_NORMAL
- en: One quick note about a machine idiom in [Listing 5-11](#listing5-11). The instruction
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: isn’t actually loading an address into R8, per se. This is really an arithmetic
    instruction that is computing R8 = RDX – 1 (with a single instruction rather than
    two as would normally be required). This is a common usage of the `lea` instruction
    in assembly language programs. Therefore, it’s a little programming trick that
    you should become comfortable with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides showing how to pass parameters in the code stream, the `print` routine
    also exhibits another concept: *variable-length parameters*. The string following
    the `call` can be any practical length. The zero-terminating byte marks the end
    of the parameter list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two easy ways to handle variable-length parameters: either use a special
    terminating value (like 0) or pass a special length value that tells the subroutine
    the number of parameters you are passing. Both methods have their advantages and
    disadvantages.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a special value to terminate a parameter list requires that you choose
    a value that never appears in the list. For example, `print` uses 0 as the terminating
    value, so it cannot print the NUL character (whose ASCII code is 0). Sometimes
    this isn’t a limitation. Specifying a length parameter is another mechanism you
    can use to pass a variable-length parameter list. While this doesn’t require any
    special codes, or limit the range of possible values that can be passed to a subroutine,
    setting up the length parameter and maintaining the resulting code can be a real
    nightmare.^([8](#c05-footnote-8))
  prefs: []
  type: TYPE_NORMAL
- en: Despite the convenience afforded by passing parameters in the code stream, passing
    parameters there has disadvantages. First, if you fail to provide the exact number
    of parameters the procedure requires, the subroutine will get confused. Consider
    the `print` example. It prints a string of characters up to a zero-terminating
    byte and then returns control to the first instruction following that byte. If
    you leave off the zero-terminating byte, the `print` routine happily prints the
    following opcode bytes as ASCII characters until it finds a zero byte. Because
    zero bytes often appear in the middle of an instruction, the `print` routine might
    return control into the middle of another instruction, which will probably crash
    the machine.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting an extra 0, which occurs more often than you might think, is another
    problem programmers have with the `print` routine. In such a case, the `print`
    routine would return upon encountering the first zero byte and attempt to execute
    the following ASCII characters as machine code. Problems notwithstanding, however,
    the code stream is an efficient place to pass parameters whose values do not change.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.3.3 Passing Parameters on the Stack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most high-level languages use the stack to pass a large number of parameters
    because this method is fairly efficient. Although passing parameters on the stack
    is slightly less efficient than passing parameters in registers, the register
    set is limited (especially if you’re limiting yourself to the four registers the
    Microsoft ABI sets aside for this purpose), and you can pass only a few value
    or reference parameters through registers. The stack, on the other hand, allows
    you to pass a large amount of parameter data without difficulty. This is the reason
    that most programs pass their parameters on the stack (at least, when passing
    more than about three to six parameters).
  prefs: []
  type: TYPE_NORMAL
- en: 'To manually pass parameters on the stack, push them immediately before calling
    the subroutine. The subroutine then reads this data from the stack memory and
    operates on it appropriately. Consider the following high-level language function
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Back in the days of 32-bit assembly language, you could have passed these parameters
    to `CallProc` by using an instruction sequence such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, with the advent of the x86-64 64-bit CPU, the 32-bit push instruction
    was removed from the instruction set (the 64-bit `push` instruction replaced it).
    If you want to pass parameters to a procedure by using the `push` instruction,
    they must be 64-bit operands.^([9](#c05-footnote-9))
  prefs: []
  type: TYPE_NORMAL
- en: Because keeping RSP aligned on an appropriate boundary (8 or 16 bytes) is crucial,
    the Microsoft ABI simply requires that every parameter consume 8 bytes on the
    stack, and thus doesn’t allow larger arguments on the stack. If you’re controlling
    both sides of the parameter contract (caller and callee), you can pass larger
    arguments to your procedures. However, it is a good idea to ensure that all parameter
    sizes are a multiple of 8 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: One simple solution is to make all your variables `qword` objects. Then you
    can directly push them onto the stack by using the `push` instruction prior to
    calling a procedure. However, not all objects fit nicely into 64 bits (characters,
    for example). Even those objects that could be 64 bits (for example, integers)
    often don’t require the use of so much storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'One sneaky way to use the `push` instruction on smaller objects is to use type
    coercion. Consider the following calling sequence for `CallProc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This sequence pushes the 64-bit values starting at the addresses associated
    with variables `i`, `j`, and `k`, regardless of the size of these variables. If
    the `i`, `j`, and `k` variables are smaller objects (perhaps 32-bit integers),
    these `push` instructions will push their values onto the stack along with additional
    data beyond these variables. As long as `CallProc` treats these parameter values
    as their actual size (say, 32 bits) and ignores the HO bits pushed for each argument
    onto the stack, this will usually work out properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pushing extra data beyond the bounds of the variable onto the stack creates
    one possible problem. If the variable is at the very end of a page in memory and
    the following page is not readable, then pushing data beyond the variable may
    attempt to push data from that next memory page, resulting in a memory access
    violation (which will crash your program). Therefore, if you use this technique,
    you must ensure that such variables do not appear at the very end of a memory
    page (with the possibility that the next page in memory is inaccessible). The
    easiest way to do this is to make sure the variables you push on the stack in
    this fashion are never the last variables you declare in your data sections; for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: While pushing extra data beyond a variable will work, it’s still a questionable
    programming practice. A better technique is to abandon the `push` instructions
    altogether and use a different technique to move the parameter data onto the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to “push” data onto the stack is to drop the RSP register down
    an appropriate amount in memory and then simply move data onto the stack by using
    a `mov` (or similar) instruction. Consider the following calling sequence for
    `CallProc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Although this takes twice as many instructions as the previous examples (eight
    versus four), this sequence is safe (no possibility of accessing inaccessible
    memory pages). Furthermore, it pushes exactly the amount of data needed for the
    parameters onto the stack (32 bits for each object, for a total of 12 bytes).
  prefs: []
  type: TYPE_NORMAL
- en: 'The major problem with this approach is that it is a really bad idea to have
    an address in the RSP register that is not aligned on an 8-byte boundary. In the
    worst case, having a nonaligned (to 8 bytes) stack will crash your program; in
    the very best case, it will affect the performance of your program. So even if
    you want to pass the parameters as 32-bit integers, you should always allocate
    a multiple of 8 bytes for parameters on the stack prior to a call. The previous
    example would be encoded as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Note that `CallProc` will simply ignore the extra 4 bytes allocated on the stack
    in this fashion (don’t forget to remove this extra storage from the stack on return).
  prefs: []
  type: TYPE_NORMAL
- en: 'To satisfy the requirement of the Microsoft ABI (and, in fact, of most application
    binary interfaces for the x86-64 CPUs) that each parameter consume exactly 8 bytes
    (even if their native data size is smaller), you can use the following code (same
    number of instructions, just uses a little more stack space):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `mov` instructions spread out the data on 8-byte boundaries. The HO dword
    of each 64-bit entry on the stack will contain garbage (whatever data was in stack
    memory prior to this sequence). That’s okay; the `CallProc` procedure (presumably)
    will ignore that extra data and operate only on the LO 32 bits of each parameter
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Upon entry into `CallProc`, using this sequence, the x86-64’s stack looks like
    [Figure 5-7](#figure5-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![f05007](image_fi/501089c05/f05007.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-7: Stack layout upon entry into `CallProc`'
  prefs: []
  type: TYPE_NORMAL
- en: 'If your procedure includes the standard entry and exit sequences, you may directly
    access the parameter values in the activation record by indexing off the RBP register.
    Consider the layout of the activation record for `CallProc` that uses the following
    declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Assuming you’ve pushed three quad-word parameters onto the stack, it should
    look something like [Figure 5-8](#figure5-8) immediately after the execution of
    `mov rbp, rsp` in `CallProc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can access the parameters by indexing off the RBP register:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '![f05008](image_fi/501089c05/f05008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-8: Activation record for `CallProc` after standard entry sequence
    execution'
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.3.4 Accessing Value Parameters on the Stack
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Accessing parameters passed by value is no different from accessing a local
    variable object. One way to accomplish this is by using equates, as was demonstrated
    for local variables earlier. [Listing 5-12](#listing5-12) provides an example
    program whose procedure accesses a parameter that the main program passes to it
    by value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-12: Demonstration of value parameters'
  prefs: []
  type: TYPE_NORMAL
- en: Although you could access the value of `theParm` by using the anonymous address
    `[RBP+16]` within your code, using the equate in this fashion makes your code
    more readable and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.4 Declaring Parameters with the proc Directive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MASM provides another solution for declaring parameters for procedures using
    the `proc` directive. You can supply a list of parameters as operands to the `proc`
    directive, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: where `parameter_list` is a list of one or more parameter declarations separated
    by commas. Each parameter declaration takes the form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'where `parm_name` is a valid MASM identifier, and `type` is one of the usual
    MASM types (`proc`, `byte`, `word`, `dword`, and so forth). With one exception,
    the parameter list declarations are identical to the local directive’s operands:
    the exception is that MASM doesn’t allow arrays as parameters. (MASM parameters
    assume that the Microsoft ABI is being used, and the Microsoft ABI allows only
    64-bit parameters.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter declarations appearing as `proc` operands assume that a standard
    entry sequence is executed and that the program will access parameters off the
    RBP register, with the saved RBP and return address values at offsets 0 and 8
    from the RBP register (so the first parameter will start at offset 16). MASM assigns
    offsets for each parameter that are 8 bytes apart (per the Microsoft ABI). As
    an example, consider the following parameter declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '`k` will have the offset `[RBP+16]`, `j` will have the offset `[RBP+24]`, and
    `i` will have the offset `[RBP+32]`. Again, the offsets are always 8 bytes, regardless
    of the parameter data type.'
  prefs: []
  type: TYPE_NORMAL
- en: As per the Microsoft ABI, MASM will allocate storage on the stack for the first
    four parameters, even though you would normally pass these parameters in RCX,
    RDX, R8, and R9\. These 32 bytes of storage (starting at `RBP+16`) are called
    *shadow storage* in Microsoft ABI nomenclature. Upon entry into the procedure,
    the parameter values do not appear in this shadow storage (instead, the values
    are in the registers). The procedure can save the register values in this preallocated
    storage, or it can use the shadow storage for any purpose it desires (such as
    for additional local variable storage). However, if the procedure refers to the
    parameter names declared in the `proc` operand field, expecting to access the
    parameter data, the procedure should store the values from these registers into
    that shadow storage (assuming the parameters were passed in the RCX, RDX, R8,
    and R9 registers). Of course, if you push these arguments on the stack prior to
    the call (in assembly language, ignoring the Microsoft ABI calling convention),
    then the data is already in place, and you don’t have to worry about shadow storage
    issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'When calling a procedure whose parameters you declare in the operand field
    of a `proc` directive, don’t forget that MASM assumes you push the parameters
    onto the stack in the reverse order they appear in the parameter list, to ensure
    that the first parameter in the list is at the lowest memory address on the stack.
    For example, if you call the `procWithParms` procedure from the previous code
    snippet, you’d typically use code like the following to push the parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Another possible solution (a few bytes longer, but often faster) is to use
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Don’t forget that if it is the callee’s responsibility to clean up the stack,
    you’d probably use an `add rsp, 24` instruction after the preceding two sequences
    to remove the parameters from the stack. Of course, you can also have the procedure
    itself clean up the stack by specifying the number to add to RSP as a `ret` instruction
    operand, as explained earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.5 Accessing Reference Parameters on the Stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because you pass the addresses of objects as reference parameters, accessing
    the reference parameters within a procedure is slightly more difficult than accessing
    value parameters because you have to dereference the pointers to the reference
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 5-13](#listing5-13), the `RefParm` procedure has a single pass-by-reference
    parameter. A pass-by-reference parameter is always a (64-bit) pointer to an object.
    To access the value associated with the parameter, this code has to load that
    quad-word address into a 64-bit register and access the data indirectly. The `mov
    rax, theParm` instruction in [Listing 5-13](#listing5-13) fetches this pointer
    into the RAX register, and then the procedure `RefParm` uses the `[RAX]` addressing
    mode to access the actual value of `theParm`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-13: Accessing a reference parameter'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the build commands and program output for [Listing 5-13](#listing5-13):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, accessing (small) pass-by-reference parameters is a little less
    efficient than accessing value parameters because you need an extra instruction
    to load the address into a 64-bit pointer register (not to mention you have to
    reserve a 64-bit register for this purpose). If you access reference parameters
    frequently, these extra instructions can really begin to add up, reducing the
    efficiency of your program. Furthermore, it’s easy to forget to dereference a
    reference parameter and use the address of the value in your calculations. Therefore,
    unless you really need to affect the value of the actual parameter, you should
    use pass by value to pass small objects to a procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Passing large objects, like arrays and records, is where using reference parameters
    becomes efficient. When passing these objects by value, the calling code has to
    make a copy of the actual parameter; if it is a large object, the copy process
    can be inefficient. Because computing the address of a large object is just as
    efficient as computing the address of a small scalar object, no efficiency is
    lost when passing large objects by reference. Within the procedure, you must still
    dereference the pointer to access the object, but the efficiency loss due to indirection
    is minimal when you contrast this with the cost of copying that large object.
    The program in [Listing 5-14](#listing5-14) demonstrates how to use pass by reference
    to initialize an array of records.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-14: Passing an array of records by referencing'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the build commands and output for [Listing 5-14](#listing5-14):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from this example, passing large objects by reference is very
    efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 5.6 Calling Conventions and the Microsoft ABI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in the days of 32-bit programs, different compilers and languages typically
    used completely different parameter-passing conventions. As a result, a program
    written in Pascal could not call a C/C++ function (at least, using the native
    Pascal parameter-passing conventions). Similarly, C/C++ programs couldn’t call
    FORTRAN, or BASIC, or functions written in other languages, without special help
    from the programmer. It was literally a Tower of Babel situation, as the languages
    were incompatible with one another.^([10](#c05-footnote-10))
  prefs: []
  type: TYPE_NORMAL
- en: To resolve these problems, CPU manufacturers, such as Intel, devised a set of
    protocols known as the *application binary interface* *(**ABI)* to provide conformity
    to procedure calls. Languages that conformed to the CPU manufacturer’s ABI were
    able to call functions and procedures written in other languages that also conformed
    to the same ABI. This brought a modicum of sanity to the world of programming
    language interoperability.
  prefs: []
  type: TYPE_NORMAL
- en: For programs running under Windows, Microsoft took a subset of the Intel ABI
    and created the Microsoft calling convention (which most people call the *Microsoft
    ABI*). The next section covers the Microsoft calling conventions in detail. However,
    first it’s worthwhile to discuss many of the other calling conventions that existed
    prior to the Microsoft ABI.^([11](#c05-footnote-11))
  prefs: []
  type: TYPE_NORMAL
- en: One of the older *formal* calling conventions is the *Pascal calling convention*.
    In thisconvention, a caller pushes parameters on the stack in the order that they
    appear in the actual parameter list (from left to right). On the 80x86/x86-64
    CPUs, where the stack grows down in memory, the first parameter winds up at the
    highest address on the stack, and the last parameter winds up at the lowest address
    on the stack.
  prefs: []
  type: TYPE_NORMAL
- en: While it might look like the parameters appear backward on the stack, the computer
    doesn’t really care. After all, the procedure will access the parameters by using
    a numeric offset, and it doesn’t care about the offset’s value.^([12](#c05-footnote-12))
    On the other hand, for simple compilers, it’s much easier to generate code that
    pushes the parameters in the order they appear in the source file, so the Pascal
    calling convention makes life a little easier for compiler writers (though optimizing
    compilers often rearrange the code anyway).
  prefs: []
  type: TYPE_NORMAL
- en: Another feature of the Pascal calling convention is that the callee (the procedure
    itself) is responsible for removing parameter data from the stack upon subroutine
    return. This localizes the cleanup code to the procedure so that parameter cleanup
    isn’t duplicated across every call to the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: The big drawback to the Pascal calling sequence is that handling variable parameter
    lists is difficult. If one call to a procedure has three parameters, and a second
    call has four parameters, the offset to the first parameter will vary depending
    on the actual number of parameters. Furthermore, it’s more difficult (though certainly
    not impossible) for a procedure to clean up the stack after itself if the number
    of parameters varies. This is not an issue for Pascal programs, as standard Pascal
    does not allow user-written procedures and functions to have varying parameter
    lists. For languages like C/C++, however, this is an issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because C (and other C-based programming languages) supports varying parameter
    lists (for example, the `printf()` function), C adopted a different calling convention:
    the *C calling convention*, also known as the *cdecl calling convention*. In C,
    the caller pushes parameters on the stack in the reverse order that they appear
    in the actual parameter list. So, it pushes the last parameter first and pushes
    the first parameter last. Because the stack is a LIFO data structure, the first
    parameter winds up at the lowest address on the stack (and at a fixed offset from
    the return address, typically right above it in memory; this is true regardless
    of how many actual parameters appear on the stack). Also, because C supports varying
    parameter lists, it is up to the caller to clean up the parameters on the stack
    after the return from the function.'
  prefs: []
  type: TYPE_NORMAL
- en: The third common calling convention in use on 32-bit Intel machines, *STDCALL*,
    is basically a combination of the Pascal and C/C++ calling conventions. Parameters
    are passed right to left (as in C/C++). However, the callee is responsible for
    cleaning up the parameters on the stack before returning.
  prefs: []
  type: TYPE_NORMAL
- en: One problem with these three calling conventions is that they all use only memory
    to pass their parameters to a procedure. Of course, the most efficient place to
    pass parameters is in machine registers. This led to a fourth common calling convention
    known as the *FASTCALL calling convention*. In thisconvention, the calling program
    passes parameters in registers to a procedure. However, as registers are a limited
    resource on most CPUs, the FASTCALL calling convention typically passes only the
    first three to six parameters in registers. If more parameters are needed, the
    FASTCALL passes the remaining parameters on the stack (typically in reverse order,
    like the C/C++ and STDCALL calling conventions).
  prefs: []
  type: TYPE_NORMAL
- en: 5.7 The Microsoft ABI and Microsoft Calling Convention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter has repeatedly referred to the Microsoft ABI. Now it’s time to
    formally describe the Microsoft calling convention.
  prefs: []
  type: TYPE_NORMAL
- en: 5.7.1 Data Types and the Microsoft ABI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted in “Microsoft ABI Notes” in Chapters 1, 3, and 4, the native data type
    sizes are 1, 2, 4, and 8 bytes (see [Table 1-6](c01.xhtml#table1-6) in Chapter
    1). All such variables should be aligned in memory on their native size.
  prefs: []
  type: TYPE_NORMAL
- en: For parameters, all procedure/function parameters must consume exactly 64 bits.
    If a data object is smaller than 64 bits, the HO bits of the parameter value (the
    bits beyond the actual parameter’s native size) are undefined (and not guaranteed
    to be zero). Procedures should access only the actual data bits for the parameter’s
    native type and ignore the HO bits.
  prefs: []
  type: TYPE_NORMAL
- en: If a parameter’s native type is larger than 64 bits, the Microsoft ABI requires
    the caller to pass the parameter by reference rather than by value (that is, the
    caller must pass the address of the data).
  prefs: []
  type: TYPE_NORMAL
- en: 5.7.2 Parameter Locations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Microsoft ABI uses a variant of the FASTCALL calling convention that requires
    the caller to pass the first four parameters in registers. [Table 5-2](#table5-2)
    lists the register locations for these parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5-2: FASTCALL Parameter Locations'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **If scalar/reference** | **If floating point** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | RCX | XMM0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | RDX | XMM1 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | R8 | XMM2 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | R9 | XMM3 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 to *n* | On stack, right to left | On stack, right to left |'
  prefs: []
  type: TYPE_TB
- en: 'If the procedure has floating-point parameters, the calling convention skips
    the use of the general-purpose register for that same parameter location. Say
    you have the following C/C++ function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then the Microsoft calling convention would expect the caller to pass `a` in
    (the LO 32 bits of) RCX, `b` in XMM1, a pointer to `c` in R8, and `d` in XMM3,
    skipping RDX, R9, XMM0, and XMM2\. This rule has an exception: for vararg (variable
    number of parameters) or unprototyped functions, floating-point values must be
    duplicated in the corresponding general-purpose register (see [https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160#parameter-passing/](https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160#parameter-passing/)).'
  prefs: []
  type: TYPE_NORMAL
- en: Although the Microsoft calling convention passes the first four parameters in
    registers, it still requires the caller to allocate storage on the stack for these
    parameters (*shadow storage*).^([13](#c05-footnote-13)) In fact, the Microsoft
    calling convention requires the caller to allocate storage for four parameters
    on the stack even if the procedure doesn’t have four parameters (or any parameters
    at all). The caller doesn’t need to copy the parameter data into this stack storage
    area—leaving the parameter data only in the registers is sufficient. However,
    that stack space must be present. Microsoft compilers assume the stack space is
    there and will use that stack space to save the register values (for example,
    if the procedure calls another procedure and needs to preserve the registers across
    that other call). Sometimes Microsoft’s compilers use this shadow storage as local
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re calling an external function (such as a C/C++ library function) that
    adheres to the Microsoft calling convention and you do not allocate the shadow
    storage, the application will almost certainly crash.
  prefs: []
  type: TYPE_NORMAL
- en: 5.7.3 Volatile and Nonvolatile Registers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted way back in Chapter 1, the Microsoft ABI declares certain registers
    to be volatile and others to be nonvolatile. *Volatile* means that a procedure
    can modify the contents of the register without preserving its value. *Nonvolatile*
    means that a procedure must preserve a register’s value if it modifies that value.
    [Table 5-3](#table5-3) lists the registers and their volatility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5-3: Register Volatility'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Register** | **Volatile/nonvolatile** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| RAX | Volatile |'
  prefs: []
  type: TYPE_TB
- en: '| RBX | Nonvolatile |'
  prefs: []
  type: TYPE_TB
- en: '| RCX | Volatile |'
  prefs: []
  type: TYPE_TB
- en: '| RDX | Volatile |'
  prefs: []
  type: TYPE_TB
- en: '| RDI | Nonvolatile |'
  prefs: []
  type: TYPE_TB
- en: '| RSI | Nonvolatile |'
  prefs: []
  type: TYPE_TB
- en: '| RBP | Nonvolatile |'
  prefs: []
  type: TYPE_TB
- en: '| RSP | Nonvolatile |'
  prefs: []
  type: TYPE_TB
- en: '| R8 | Volatile |'
  prefs: []
  type: TYPE_TB
- en: '| R9 | Volatile |'
  prefs: []
  type: TYPE_TB
- en: '| R10 | Volatile |'
  prefs: []
  type: TYPE_TB
- en: '| R11 | Volatile |'
  prefs: []
  type: TYPE_TB
- en: '| R12 | Nonvolatile |'
  prefs: []
  type: TYPE_TB
- en: '| R13 | Nonvolatile |'
  prefs: []
  type: TYPE_TB
- en: '| R14 | Nonvolatile |'
  prefs: []
  type: TYPE_TB
- en: '| R15 | Nonvolatile |'
  prefs: []
  type: TYPE_TB
- en: '| XMM0/YMM0 | Volatile |'
  prefs: []
  type: TYPE_TB
- en: '| XMM1/YMM1 | Volatile |'
  prefs: []
  type: TYPE_TB
- en: '| XMM2/YMM2 | Volatile |'
  prefs: []
  type: TYPE_TB
- en: '| XMM3/YMM3 | Volatile |'
  prefs: []
  type: TYPE_TB
- en: '| XMM4/YMM4 | Volatile |'
  prefs: []
  type: TYPE_TB
- en: '| XMM5/YMM5 | Volatile |'
  prefs: []
  type: TYPE_TB
- en: '| XMM6/YMM6 | XMM6 Nonvolatile, upper half of YMM6 volatile |'
  prefs: []
  type: TYPE_TB
- en: '| XMM7/YMM7 | XMM7 Nonvolatile, upper half of YMM7 volatile |'
  prefs: []
  type: TYPE_TB
- en: '| XMM8/YMM8 | XMM8 Nonvolatile, upper half of YMM8 volatile |'
  prefs: []
  type: TYPE_TB
- en: '| XMM9/YMM9 | XMM9 Nonvolatile, upper half of YMM9 volatile |'
  prefs: []
  type: TYPE_TB
- en: '| XMM10/YMM10 | XMM10 Nonvolatile, upper half of YMM10 volatile |'
  prefs: []
  type: TYPE_TB
- en: '| XMM11/YMM11 | XMM11 Nonvolatile, upper half of YMM11 volatile |'
  prefs: []
  type: TYPE_TB
- en: '| XMM12/YMM12 | XMM12 Nonvolatile, upper half of YMM12 volatile |'
  prefs: []
  type: TYPE_TB
- en: '| XMM13/YMM13 | XMM13 Nonvolatile, upper half of YMM13 volatile |'
  prefs: []
  type: TYPE_TB
- en: '| XMM14/YMM14 | XMM14 Nonvolatile, upper half of YMM14 volatile |'
  prefs: []
  type: TYPE_TB
- en: '| XMM15/YMM15 | XMM15 Nonvolatile, upper half of YMM15 volatile |'
  prefs: []
  type: TYPE_TB
- en: '| FPU | Volatile, but FPU stack must be empty upon return |'
  prefs: []
  type: TYPE_TB
- en: '| Direction flag | Must be cleared upon return |'
  prefs: []
  type: TYPE_TB
- en: 'It is perfectly reasonable to use nonvolatile registers within a procedure.
    However, you must preserve those register values so that they are unchanged upon
    return from a function. If you’re not using the shadow storage for anything else,
    this is a good place to save and restore nonvolatile register values during a
    procedure call; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, if you’re using the shadow storage for another purpose, you can
    always save nonvolatile register values in local variables or can even push and
    pop the register values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 5.7.4 Stack Alignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I’ve mentioned many times now, the Microsoft ABI requires the stack to be
    aligned on a 16-byte boundary whenever you make a call to a procedure. When Windows
    transfers control to your assembly code (or when another Windows ABI–compliant
    code calls your assembly code), you’re guaranteed that the stack will be aligned
    on an 8-byte boundary that is not also a 16-byte boundary (because the return
    address consumed 8 bytes after the stack was 16-byte-aligned). If, within your
    assembly code, you don’t care about 16-byte alignment, you can do anything you
    like with the stack (however, you should keep it aligned on at least an 8-byte
    boundary).
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if you ever plan on calling code that uses the Microsoft
    calling conventions, you need to be able to ensure that the stack is properly
    aligned before the call. There are two ways to do this: carefully manage any modifications
    to the RSP register after entry into your code (so you know the stack is 16-byte-aligned
    whenever you make a call), or force the stack to an appropriate alignment prior
    to making a call. Forcing alignment to 16 bytes is easily achieved using this
    instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: However, you must execute this instruction *before* setting up parameters for
    a call. If you execute this instruction immediately before a call instruction
    (but after placing all the parameters on the stack), this could shift RSP down
    in memory, and then the parameters will not be at the expected offset upon entry
    into the procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you don’t know the state of RSP and need to make a call to a procedure
    that expects five parameters (40 bytes, which is not a multiple of 16 bytes).
    Here’s a typical calling sequence you would use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The only problem with this code is that it is hard to clean up the stack upon
    return (because you don’t know exactly how many bytes you reserved on the stack
    as a result of the `and` instruction). However, as you’ll see in the next section,
    you’ll rarely clean up the stack after an individual procedure call, so you don’t
    have to worry about the stack cleanup here.
  prefs: []
  type: TYPE_NORMAL
- en: 5.7.5 Parameter Setup and Cleanup (or “What’s with These Magic Instructions?”)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Microsoft ABI requires the caller to set up the parameters and then clean
    them up (remove them from the stack) upon return from the function. In theory,
    this means that a call to a Microsoft ABI–compliant function is going to look
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: This allocation and cleanup sequence has two problems. First, you have to repeat
    the sequence (`sub rsp``, parm_size` and `add rsp,` `parm_size`) for every call
    in your program (which can be rather inefficient). Second, as you saw in the preceding
    section, sometimes aligning the stack to a 16-byte boundary forces you to adjust
    the stack downward by an unknown amount, so you don’t know how many bytes to add
    to RSP in order to clean up the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have several calls sprinkled through a given procedure, you can optimize
    the process of allocating and deallocating parameters on the stack by doing this
    operation just once. To understand how this works, consider the following code
    sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'If you study this code, you should be able to convince yourself that the first
    `add` and second `sub` are somewhat redundant. If you were to modify the first
    `sub` instruction to reduce the stack size by the greater of `parm_size` and `parm_size2`,
    and replace the final `add` instruction with this same value, you could eliminate
    the `add` and `sub` instructions appearing between the two calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: If you determine the maximum number of bytes of parameters needed by all calls
    within your procedure, you can eliminate all the individual stack allocations
    and cleanups throughout the procedure (don’t forget, the minimum parameter size
    is 32 bytes, even if the procedure has no parameters at all, because of the shadow
    storage requirements).
  prefs: []
  type: TYPE_NORMAL
- en: It gets even better, though. If your procedure has local variables, you can
    combine the `sub` instruction that allocates local variables with the one that
    allocates storage for your parameters. Similarly, if you’re using the standard
    entry/exit sequence, the `leave` instruction at the end of your procedure will
    automatically deallocate all the parameters (as well as the local variables) when
    you exit your procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this book, you’ve seen lots of “magic” add and subtract instructions
    that have been offered without much in the way of explanation. Now you know what
    those instructions have been doing: they’ve been allocating storage for local
    variables and all the parameter space for the procedures being called as well
    as keeping the stack 16-byte-aligned.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one last example of a procedure that uses the standard entry/exit procedure
    to set up locals and parameter space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: However, if you use this trick to allocate storage for your procedures’ parameters,
    you will not be able to use the `push` instructions to move the data onto the
    stack. The storage has already been allocated on the stack for the parameters;
    you must use `mov` instructions to copy the data onto the stack (using the `[RSP+``constant``]`
    addressing mode) when copying the fifth and greater parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 5.8 Functions and Function Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Functions* are procedures that return a result to the caller. In assembly
    language, few syntactical differences exist between a procedure and a function,
    which is why MASM doesn’t provide a specific declaration for a function. Nevertheless,
    there are some semantic differences; although you can declare them the same way
    in MASM, you use them differently.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Procedures* are a sequence of machine instructions that fulfill a task. The
    result of the execution of a procedure is the accomplishment of that activity.
    Functions, on the other hand, execute a sequence of machine instructions specifically
    to compute a value to return to the caller. Of course, a function can perform
    an activity as well, and procedures can undoubtedly compute values, but the main
    difference is that the purpose of a function is to return a computed result; procedures
    don’t have this requirement.'
  prefs: []
  type: TYPE_NORMAL
- en: In assembly language, you don’t specifically define a function by using special
    syntax. To MASM, everything is a `proc`. A section of code becomes a function
    by virtue of the fact that the programmer explicitly decides to return a function
    result somewhere (typically in a register) via the procedure’s execution.
  prefs: []
  type: TYPE_NORMAL
- en: The x86-64’s registers are the most common place to return function results.
    The `strlen()` routine in the C Standard Library is a good example of a function
    that returns a value in one of the CPU’s registers. It returns the length of the
    string (whose address you pass as a parameter) in the RAX register.
  prefs: []
  type: TYPE_NORMAL
- en: By convention, programmers try to return 8-, 16-, 32-, and 64-bit (nonreal)
    results in the AL, AX, EAX, and RAX registers, respectively. This is where most
    high-level languages return these types of results, and it’s where the Microsoft
    ABI states that you should return function results. The exception is floating-point
    values. The Microsoft ABI states that you should return floating-point values
    in the XMM0 register.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there is nothing particularly sacred about the AL, AX, EAX, and RAX
    registers. You could return function results in any register if it is more convenient
    to do so. Of course, if you’re calling a Microsoft ABI–compliant function (such
    as `strlen()`), you have no choice but to expect the function’s return result
    in the RAX register (`strlen()` returns a 64-bit integer in RAX, for example).
  prefs: []
  type: TYPE_NORMAL
- en: If you need to return a function result that is larger than 64 bits, you obviously
    must return it somewhere other than in RAX (which can hold only 64-bit values).
    For values slightly larger than 64 bits (for example, 128 bits or maybe even as
    many as 256 bits), you can split the result into pieces and return those parts
    in two or more registers. It is common to see functions returning 128-bit values
    in the RDX:RAX register pair. Of course, the XMM/YMM registers are another good
    place to return large values. Just remember that these schemes are not Microsoft
    ABI–compliant, so they’re practical only when calling code you’ve written.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to return a large object as a function result (say, an array of
    1000 elements), you obviously are not going to be able to return the function
    result in the registers. You can deal with large function return results in two
    common ways: either pass the return value as a reference parameter or allocate
    storage on the heap (for example, using the C Standard Library `malloc()` function)
    for the object and return a pointer to it in a 64-bit register. Of course, if
    you return a pointer to storage you’ve allocated on the heap, the calling program
    must free this storage when it has finished with it.'
  prefs: []
  type: TYPE_NORMAL
- en: 5.9 Recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Recursion* occurs when a procedure calls itself. The following, for example,
    is a recursive procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Of course, the CPU will never return from this procedure. Upon entry into `Recursive`,
    this procedure will immediately call itself again, and control will never pass
    to the end of the procedure. In this particular case, runaway recursion results
    in an infinite loop.^([14](#c05-footnote-14))
  prefs: []
  type: TYPE_NORMAL
- en: 'Like a looping structure, recursion requires a termination condition in order
    to stop infinite recursion. `Recursive` could be rewritten with a termination
    condition as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This modification to the routine causes `Recursive` to call itself the number
    of times appearing in the EAX register. On each call, `Recursive` decrements the
    EAX register by 1 and then calls itself again. Eventually, `Recursive` decrements
    EAX to 0 and returns from each call until it returns to the original caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, however, there hasn’t been a real need for recursion. After all, you
    could efficiently code this procedure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Both examples would repeat the body of the procedure the number of times passed
    in the EAX register.^([15](#c05-footnote-15)) As it turns out, there are only
    a few recursive algorithms that you cannot implement in an iterative fashion.
    However, many recursively implemented algorithms are more efficient than their
    iterative counterparts, and most of the time the recursive form of the algorithm
    is much easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: The *quicksort algorithm* is probably the most famous algorithm that usually
    appears in recursive form. A MASM implementation of this algorithm appears in
    [Listing 5-15](#listing5-15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 5-15: Recursive quicksort program'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the build command and sample output for the quicksort program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Note that this quicksort procedure uses registers for all local variables. The
    quicksort function is a *leaf function*; it doesn’t call any other functions.
    Therefore, it doesn’t need to align the stack on a 16-byte boundary. Also, as
    is a good idea for any pure-assembly procedure (that will be called only by other
    assembly language procedures), this quicksort procedure preserves all the registers
    whose values it modifies (even the volatile registers). That’s just good programming
    practice even if it is a little less efficient.
  prefs: []
  type: TYPE_NORMAL
- en: 5.10 Procedure Pointers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The x86-64 call instruction allows three basic forms: PC-relative calls (via
    a procedure name), indirect calls through a 64-bit general-purpose register, and
    indirect calls through a quad-word pointer variable. The `call` instruction supports
    the following (low-level) syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: We’ve been using the first form throughout this book, so there is little need
    to discuss it here. The second form, the register indirect call, calls the procedure
    whose address is held in the specified 64-bit register. The address of a procedure
    is the byte address of the first instruction to execute within that procedure.
    On a von Neumann architecture machine (like the x86-64), the system stores machine
    instructions in memory along with other data. The CPU fetches the instruction
    opcode values from memory prior to executing them. When you execute the register
    indirect `call` instruction, the x86-64 first pushes the return address onto the
    stack and then begins fetching the next opcode byte (instruction) from the address
    specified by the register’s value.
  prefs: []
  type: TYPE_NORMAL
- en: The third form of the preceding `call` instruction fetches the address of a
    procedure’s first instruction from a quad-word variable in memory. Although this
    instruction suggests that the call uses the direct addressing of the procedure,
    you should realize that any legal memory addressing mode is also legal here. For
    example, `call procPtrTable[rbx*8]` is perfectly legitimate; this statement fetches
    the quad word from the array of quad words (`procPtrTable`) and calls the procedure
    whose address is the value contained within that quad word.
  prefs: []
  type: TYPE_NORMAL
- en: 'MASM treats procedure names like static objects. Therefore, you can compute
    the address of a procedure by using the `offset` operator along with the procedure’s
    name or by using the `lea` instruction. For example, `offset` `proc_name` is the
    address of the very first instruction of the `proc_name` procedure. So, all three
    of the following code sequences wind up calling the `proc_name` procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the address of a procedure fits in a 64-bit object, you can store such
    an address into a quad-word variable; in fact, you can initialize a quad-word
    variable with the address of a procedure by using code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'As with all pointer objects, you should not attempt to indirectly call a procedure
    through a pointer variable unless you’ve initialized that variable with an appropriate
    address. You can initialize a procedure pointer variable in two ways: `.data`
    and `.const` objects allow an initializer, or you can compute the address of a
    routine (as a 64-bit value) and store that 64-bit address directly into the procedure
    pointer at runtime. The following code fragment demonstrates both ways to initialize
    a procedure pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Although all the examples in this section use static variable declarations (`.data`,
    `.const`, `.data?`), don’t think you can declare simple procedure pointers only
    in the static variable declaration sections. You can also declare procedure pointers
    (which are just qword variables) as local variables, pass them as parameters,
    or declare them as fields of a record or a union.
  prefs: []
  type: TYPE_NORMAL
- en: 5.11 Procedural Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One place where procedure pointers are quite invaluable is in parameter lists.
    Selecting one of several procedures to call by passing the address of a procedure
    is a common operation. Of course, a *procedural parameter* is just a quad-word
    parameter containing the address of a procedure, so this is really no different
    from using a local variable to hold a procedure pointer (except, of course, that
    the caller initializes the parameter with the address of the procedure to call
    indirectly).
  prefs: []
  type: TYPE_NORMAL
- en: 'When using parameter lists with the MASM `proc` directive, you can specify
    a procedure pointer type by using the `proc` type specifier; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'You can call the procedure pointed at by this parameter by using the following
    call instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 5.12 Saving the State of the Machine, Part II
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: “Saving the State of the Machine” on page 220 described the use of the `push`
    and `pop` instructions to save the state of the registers across a procedure call
    (callee register preservation). While this is certainly one way to preserve registers
    across a procedure call, it certainly isn’t the only way, nor is it always (or
    even usually) the best way to save and restore registers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `push` and `pop` instructions have a couple of major benefits: they are
    short (pushing or popping a 64-bit register uses a 1-byte instruction opcode),
    and they work with constant and memory operands. These instructions do have drawbacks,
    however: they modify the stack pointer, they work with only 2- or 8-byte registers,
    they work only with the general-purpose integer registers (and the FLAGS register),
    and they might be slower than an equivalent instruction that moves the register
    data onto the stack. Often, a better solution is to reserve storage in the local
    variable space and simply move the registers to/from those local variables on
    the stack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following procedure declaration that preserves registers by using
    `push` and `pop` instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'You can achieve the same thing with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The disadvantage to this code is that two extra instructions are needed to allocate
    (and deallocate) storage on the stack for the local variables that hold the register
    values. The `push` and `pop` instructions automatically allocate this storage,
    sparing you from having to supply these extra instructions. For a simple situation
    such as this, the `push` and `pop` instructions probably are the better solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more complex procedures, especially those that expect parameters on the
    stack or have local variables, the procedure is already setting up the activation
    record, and subtracting a larger number from RSP doesn’t require any additional
    instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: MASM automatically generates the code to allocate the storage for `saveRAX`,
    `saveRBX`, and `saveRCX` (along with all the other local variables) on the stack,
    as well as clean up the local storage on return.
  prefs: []
  type: TYPE_NORMAL
- en: 'When allocating local variables on the stack along with storage for any parameters
    a procedure might pass to functions it calls, pushing and popping registers to
    preserve them becomes problematic. For example, consider the following procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Had this function pushed RAX, RBX, and RCX on the stack after subtracting 48
    from RSP, those save registers would have wound up on the stack where the function
    passes `parm1`, `parm2`, and `parm3` to `theFunction`. That’s why the `push` and
    `pop` instructions don’t work well when working with functions that build an activation
    record containing local storage.
  prefs: []
  type: TYPE_NORMAL
- en: 5.13 Microsoft ABI Notes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter has all but completed the discussion of the Microsoft calling
    conventions. Specifically, a Microsoft ABI–compliant function must follow these
    rules:'
  prefs: []
  type: TYPE_NORMAL
- en: (Scalar) parameters must be passed in RCX, RDX, R8, and R9, then pushed on the
    stack. Floating-point parameters substitute XMM0, XMM1, XMM2, and XMM3 for RCX,
    RDX, R8, and R9, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Varargs functions (functions with a variable number of parameters, such as `printf()`)
    and unprototyped functions must pass floating-point values in both the general-purpose
    (integer) registers and in the XMM registers. (For what it’s worth, `printf()`
    seems to be happy with just passing the floating-point values in the integer registers,
    though that might be a happy accident with the version of MSVC used in the preparation
    of this book.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All parameters must be less than or equal to 64 bits in size; larger parameters
    must be passed by reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the stack, parameters always consume 64 bits (8 bytes) regardless of their
    actual size; the HO bits of smaller objects are undefined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immediately before a `call` instruction, the stack must be aligned on a 16-byte
    boundary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registers RAX, RCX, RDX, R8, R9, R10, R11, and XMM0/YMM0 to XMM5/YMM5 are volatile.
    The caller must preserve the registers across a call if it needs their values
    to be saved across the call. Also note that the HO 128 bits of YMM0 to YMM15 are
    volatile, and the caller must preserve these registers if it needs these bits
    to be preserved across a call.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registers RBX, RSI, RDI, RBP, RSP, R12 to R15, and XMM6 to XMM15 are nonvolatile.
    The callee must preserve these registers if it changes their values. As noted
    earlier, while YMM0L to YMM15L (the LO 128 bits) are nonvolatile, the upper 128
    bits of these registers can be considered volatile. However, if a procedure is
    saving the LO 128 bits of YMM0 to YMM15, it may as well preserve all the bits
    (this inconsistency in the Microsoft ABI is to support legacy code running on
    CPUs that don’t support the YMM registers).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalar function returns (64 bits or fewer) come back in the RAX register. If
    the data type is smaller than 64 bits, the HO bits of RAX are undefined.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions that return values larger than 64 bits must allocate storage for the
    return value and pass the address of that storage in the first parameter (RCX)
    to the function. On return, the function must return this pointer in the RAX register.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions return floating-point results (double or single) in the XMM0 register.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.14 For More Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The electronic edition of the 32-bit edition this book (found at [https://artofasm.randallhyde.com/](https://artofasm.randallhyde.com/))contains
    a whole “volume” on advanced and intermediate procedures. Though that book covers
    32-bit assembly language programming, the concepts apply directly to 64-bit assembly
    by simply using 64-bit addresses rather than 32-bit addresses.
  prefs: []
  type: TYPE_NORMAL
- en: While the information appearing in this chapter covers 99 percent of the material
    that assembly programmers typically use, there is additional information on procedures
    and parameters that you may find interesting. In particular, the electronic edition
    covers additional parameter-passing mechanisms (pass by value/result, pass by
    result, pass by name, and pass by lazy evaluation) and goes into greater detail
    about the places you can pass parameters. The electronic version also covers iterators,
    thunks, and other advanced procedure types. Finally, a good compiler construction
    textbook will cover additional details about runtime support for procedures.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the Microsoft ABI, search for *Microsoft calling conventions*
    on the Microsoft website (or on the internet).
  prefs: []
  type: TYPE_NORMAL
- en: 5.15 Test Yourself
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Explain, step by step, how the `call` instruction works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain, step by step, how the `ret` instruction works.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `ret` instruction, with a numeric constant operand, do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What value is pushed on the stack for a return address?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is namespace pollution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you define a single global symbol in a procedure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you make all symbols in a procedure non-scoped (that is, all the symbols
    in a procedure would be global)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain how to use the `push` and `pop` instructions to preserve registers in
    a function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main disadvantage of caller preservation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main problem with callee preservation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if you fail to pop a value in a function that you pushed on the
    stack at the beginning of the function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if you pop extra data off the stack in a function (data that you
    did not push on the stack in the function)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an activation record?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What register usually points at an activation record, providing access to the
    data in that record?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many bytes are reserved for a typical parameter on the stack when using
    the Microsoft ABI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the standard entry sequence for a procedure (the instructions)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the standard exit sequence for a procedure (the instructions)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What instruction can you use to force 16-byte alignment of the stack pointer
    if the current value in RSP is unknown?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the scope of a variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the lifetime of a variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an automatic variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When does the system allocate storage for an automatic variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain two ways to declare local/automatic variables in a procedure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Given the following procedure source code snippet, provide the offsets for
    each of the local variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What statement(s) would you insert in the source file to tell MASM to automatically
    generate the standard entry and standard exit sequences for a procedure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When MASM automatically generates a standard entry sequence for a procedure,
    how does it determine where to put the code sequence?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When MASM automatically generates a standard exit sequence for a procedure,
    how does it determine where to put the code sequence?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What value does a pass-by-value parameter pass to a function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What value does a pass-by-reference parameter pass to a function?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When passing four integer parameters to a function, where does the Windows ABI
    state those parameters are to be passed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When passing a floating-point value as one of the first four parameters, where
    does the Windows ABI insist the values will be passed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When passing more than four parameters to a function, where does the Windows
    ABI state the parameters will be passed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a volatile and nonvolatile register in the Windows
    ABI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which registers are volatile in the Windows ABI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which registers are nonvolatile in the Windows ABI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When passing parameters in the code stream, how does a function access the parameter
    data?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a shadow parameter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many bytes of shadow storage will a function require if it has a single
    32-bit integer parameter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many bytes of shadow storage will a function require if it has two 64-bit
    integer parameters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many bytes of shadow storage will a function require if it has six 64-bit
    integer parameters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What offsets will MASM associate with each of the parameters in the following
    `proc` declaration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Suppose that `parm4` in the preceding question is a pass-by-reference character
    parameter. How would you load that character into the AL register (provide a code
    sequence)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What offsets will MASM associate with each of the local variables in the following
    `proc` snippet?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the best way to pass a large array to a procedure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does *ABI* stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where is the most common place to return a function result?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a procedural parameter?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you call a procedure passed as a parameter to a function/procedure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a procedure has local variables, what is the best way to preserve registers
    within that procedure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
