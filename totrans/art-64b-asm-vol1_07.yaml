- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Procedures
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 过程
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In a procedural programming language, the basic unit of code is the procedure.
    A *procedure* is a set of instructions that compute a value or take an action
    (such as printing or reading a character value). This chapter discusses how MASM
    implements procedures, parameters, and local variables. By the end of this chapter,
    you should be well versed in writing your own procedures and functions, and fully
    understand parameter passing and the Microsoft ABI calling convention.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程式编程语言中，代码的基本单元是过程。*过程* 是一组计算值或执行动作（如打印或读取字符值）的指令。本章讨论了 MASM 如何实现过程、参数和局部变量。通过本章内容的学习，您应该能够熟练编写自己的过程和函数，并完全理解参数传递和
    Microsoft ABI 调用约定。
- en: 5.1 Implementing Procedures
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 实现过程
- en: 'Most procedural programming languages implement procedures by using the call/return
    mechanism. The code calls a procedure, the procedure does its thing, and then
    the procedure returns to the caller. The call and return instructions provide
    the x86-64’s *procedure invocation mechanism*. The calling code calls a procedure
    with the `call` instruction, and the procedure returns to the caller with the
    `ret` instruction. For example, the following x86-64 instruction calls the C Standard
    Library `printf()` function:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数过程式编程语言通过使用调用/返回机制来实现过程。代码调用一个过程，过程执行其任务，然后返回给调用者。调用和返回指令提供了 x86-64 的 *过程调用机制*。调用代码通过
    `call` 指令调用一个过程，过程通过 `ret` 指令返回给调用者。例如，以下 x86-64 指令调用 C 标准库的 `printf()` 函数：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alas, the C Standard Library does not supply all the routines you will ever
    need. Most of the time you’ll have to write your own procedures. To do this, you
    will use MASM’s procedure-declaration facilities. A basic MASM procedure declaration
    takes the following form:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜的是，C 标准库并没有提供你永远需要的所有例程。大多数时候，您需要自己编写过程。为此，您将使用 MASM 的过程声明功能。一个基本的 MASM 过程声明形式如下：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Procedure declarations appear in the `.code` section of your program. In the
    preceding syntax example, `proc_name` represents the name of the procedure you
    wish to define. This can be any valid (and unique) MASM identifier.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 过程声明出现在程序的 `.code` 部分。在前面的语法示例中，`proc_name` 代表您希望定义的过程名称。这可以是任何有效（且唯一）的 MASM
    标识符。
- en: 'Here is a concrete example of a MASM procedure declaration. This procedure
    stores 0s into the 256 double words that RCX points at upon entry into the procedure:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个 MASM 过程声明的具体示例。该过程在进入过程中时，将 0 填充到 RCX 指向的 256 个双字中：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you’ve probably noticed, this simple procedure doesn’t bother with the “magic”
    instructions that add and subtract a value to and from the RSP register. Those
    instructions are a requirement of the Microsoft ABI when the procedure will be
    calling other C/C++ code (or other code written in a Microsoft ABI–compliant language).
    Because this little function doesn’t call any other procedures, it doesn’t bother
    executing such code. Also note that this code uses the loop index to count down
    from 256 to 0, filling in the 256 dword array backward (from end to beginning)
    rather than filling it in from beginning to end. This is a common technique in
    assembly language.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，这个简单的过程没有涉及添加和减去 RSP 寄存器值的“魔术”指令。当过程需要调用其他 C/C++ 代码（或其他使用 Microsoft
    ABI 兼容语言编写的代码）时，这些指令是 Microsoft ABI 的要求。因为这个小函数没有调用其他过程，所以它没有执行这些指令。还要注意，这段代码使用循环索引从
    256 递减到 0，倒序填充这 256 个双字数组（从末尾到开头），而不是从头到尾填充。这是汇编语言中的一种常见技术。
- en: You can use the x86-64 `call` instruction to call this procedure. When, during
    program execution, the code falls into the `ret` instruction, the procedure returns
    to whoever called it and begins executing the first instruction beyond the `call`
    instruction. The program in [Listing 5-1](#listing5-1) provides an example of
    a call to the `zeroBytes` routine.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 x86-64 的 `call` 指令来调用此过程。当程序执行时，代码遇到 `ret` 指令时，过程会返回给调用者，并开始执行 `call`
    指令后的第一条指令。[示例 5-1](#listing5-1) 中的程序提供了调用 `zeroBytes` 例程的示例。
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 5-1: Example of a simple procedure'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-1：一个简单过程的示例
- en: 5.1.1 The call and ret Instructions
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 调用和返回指令
- en: The x86-64 `call` instruction does two things. First, it pushes the (64-bit)
    address of the instruction immediately following the `call` onto the stack; then
    it transfers control to the address of the specified procedure. The value that
    `call` pushes onto the stack is known as the *return address*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64的`call`指令执行两项操作。首先，它将紧接着`call`指令之后的（64位）指令地址压入栈中；然后它将控制转移到指定过程的地址。`call`指令压入栈中的值称为*返回地址*。
- en: When the procedure wants to return to the caller and continue execution with
    the first statement following the `call` instruction, most procedures return to
    their caller by executing a `ret` (*return*) instruction. The `ret` instruction
    pops a (64-bit) return address off the stack and transfers control indirectly
    to that address.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当过程想要返回调用者并继续执行紧跟在`call`指令后的第一条语句时，大多数过程通过执行`ret`（*返回*）指令返回给调用者。`ret`指令会从栈中弹出（64位）返回地址，并间接将控制转移到该地址。
- en: 'The following is an example of the minimal procedure:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最小化过程的示例：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you call this procedure with the `call` instruction, `minimal` will simply
    pop the return address off the stack and return to the caller. If you fail to
    put the `ret` instruction in the procedure, the program will not return to the
    caller upon encountering the `endp` statement. Instead, the program will fall
    through to whatever code happens to follow the procedure in memory.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过`call`指令调用这个过程，`minimal`将简单地从栈中弹出返回地址，并返回到调用者。如果你没有在过程里放入`ret`指令，程序将在遇到`endp`语句时不会返回到调用者。相反，程序会跳到在内存中紧接着过程后面的代码。
- en: The example program in [Listing 5-2](#listing5-2) demonstrates this problem.
    The main program calls `noRet`, which falls straight through to `followingProc`
    (printing the message `followingProc was called`).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例程序在 Listing 5-2](#listing5-2) 中演示了这个问题。主程序调用了`noRet`，该程序直接跳转到`followingProc`（打印消息`followingProc
    was called`）。'
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 5-2: Effect of a missing `ret` instruction in a procedure'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 5-2：缺少`ret`指令在过程中的影响
- en: Although this behavior might be desirable in certain rare circumstances, it
    usually represents a defect in most programs. Therefore, always remember to explicitly
    return from the procedure by using the `ret` instruction.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在某些少见的情况下这种行为可能是期望的，但在大多数程序中通常表现为缺陷。因此，始终记得通过使用`ret`指令显式地从过程返回。
- en: 5.1.2 Labels in a Procedure
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 过程中的标签
- en: Procedures may contain statement labels, just like the main procedure in your
    assembly language program (after all, the main procedure, `asmMain` in most of
    the examples in this book, is just another procedure declaration as far as MASM
    is concerned). Note, however, that statement labels defined within a procedure
    are *local* to that procedure; such symbols are not *visible* outside the procedure.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 过程可以包含语句标签，就像你程序中的主过程一样（毕竟，在MASM看来，书中大部分示例中的主过程`asmMain`只是另一个过程声明）。然而，请注意，在过程内定义的语句标签是*局部*的；这些符号在过程外部是*不可见*的。
- en: In most situations, having *scoped symbols* in a procedure is nice (see “Local
    (Automatic) Variables” on page 234 for a discussion of scope). You don’t have
    to worry about *namespace pollution* (conflicting symbol names) among the different
    procedures in your source file. Sometimes, however, MASM’s name scoping can create
    problems. You might actually want to refer to a statement label outside a procedure.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，过程中的*作用域符号*是很有用的（有关作用域的讨论，请参见第234页的“局部（自动）变量”）。你不必担心不同过程之间的*命名空间污染*（符号名称冲突）。然而，有时，MASM的名称作用域可能会导致问题。你实际上可能想要引用过程外的语句标签。
- en: 'One way to do this on a label-by-label basis is to use a global statement label
    declaration. *Global statement labels* are similar to normal statement labels
    in a procedure except you follow the symbol with two colons instead of a single
    colon, like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在标签逐个处理的基础上，一种方法是使用全局语句标签声明。*全局语句标签*与过程中的普通语句标签类似，不同之处在于符号后面跟的是两个冒号而不是一个冒号，像这样：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Global statement labels are visible outside the procedure. You can use an unconditional
    or conditional jump instruction to transfer control to a global symbol from outside
    the procedure; you can even use a `call` instruction to call that global symbol
    (in which case, it becomes a second entry point to the procedure). Generally,
    having multiple entry points to a procedure is considered bad programming style,
    and the use of multiple entry points often leads to programming errors. As such,
    you should rarely use global symbols in assembly language procedures.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 全局语句标签在程序外部是可见的。你可以使用无条件或有条件跳转指令将控制转移到外部程序的全局符号；你甚至可以使用`call`指令调用该全局符号（在这种情况下，它变成了该程序的第二个入口点）。通常，程序拥有多个入口点被认为是糟糕的编程风格，使用多个入口点往往会导致编程错误。因此，你应该很少在汇编语言程序中使用全局符号。
- en: 'If, for some reason, you don’t want MASM to treat all the statement labels
    in a procedure as local to that procedure, you can turn scoping on and off with
    the following statements:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，你不希望MASM将程序中的所有语句标签视为该程序的局部标签，可以通过以下语句打开或关闭作用域：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `option noscoped` directive disables scoping in procedures (for all procedures
    following the directive). The `option scoped` directive turns scoping back on.
    Therefore, you can turn scoping off for a single procedure (or set of procedures)
    and turn it back on immediately afterward.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`option noscoped`指令禁用程序中的作用域（适用于指令之后的所有程序）。`option scoped`指令重新启用作用域。因此，你可以为单个程序（或程序集合）关闭作用域，并立即将其重新启用。'
- en: 5.2 Saving the State of the Machine
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 保存机器的状态
- en: Take a look at [Listing 5-3](#listing5-3). This program attempts to print 20
    lines of 40 spaces and an asterisk. Unfortunately, a subtle bug creates an infinite
    loop. The main program uses the `jnz printLp` instruction to create a loop that
    calls `PrintSpaces` 20 times. This function uses EBX to count off the 40 spaces
    it prints, and then returns with ECX containing 0\. The main program then prints
    an asterisk and a newline, decrements ECX, and then repeats because ECX isn’t
    0 (it will always contain 0FFFF_FFFFh at this point).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下[清单 5-3](#listing5-3)。该程序试图打印20行40个空格和一个星号。不幸的是，一个微妙的错误导致了无限循环。主程序使用`jnz
    printLp`指令创建一个循环，调用`PrintSpaces` 20次。该函数使用EBX来计数它打印的40个空格，然后返回时ECX为0。主程序接着打印一个星号和换行符，递减ECX，然后重复，因为ECX不是0（此时它总是包含0FFFF_FFFFh）。
- en: The problem here is that the `print40Spaces` subroutine doesn’t preserve the
    EBX register. *Preserving a register* means you save it upon entry into the subroutine
    and restore it before leaving. Had the `print40Spaces` subroutine preserved the
    contents of the EBX register, [Listing 5-3](#listing5-3) would have functioned
    properly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是`print40Spaces`子程序没有保存EBX寄存器。*保存寄存器*意味着在进入子程序时保存寄存器的值，在离开时恢复它。如果`print40Spaces`子程序保存了EBX寄存器的内容，[清单
    5-3](#listing5-3)将能够正常工作。
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 5-3: Program with an unintended infinite loop'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-3：包含意外无限循环的程序
- en: 'You can use the x86-64’s `push` and `pop` instructions to preserve register
    values while you need to use them for something else. Consider the following code
    for `PrintSpaces`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用x86-64的`push`和`pop`指令来保存寄存器的值，暂时用于其他目的。考虑下面的`PrintSpaces`代码：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`print40Spaces` saves and restores RBX by using `push` and `pop` instructions.
    Either the caller (the code containing the call instruction) or the callee (the
    subroutine) can take responsibility for preserving the registers. In the preceding
    example, the callee preserves the registers.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`print40Spaces`通过使用`push`和`pop`指令保存和恢复RBX寄存器。可以由调用者（包含调用指令的代码）或被调用者（子程序）负责保存寄存器。在前面的例子中，被调用者负责保存寄存器。'
- en: '[Listing 5-4](#listing5-4) shows what this code might look like if the caller
    preserves the registers (for reasons that will become clear in “Saving the State
    of the Machine, Part II” on page 280, the main program saves the value of RBX
    in a static memory location rather than using the stack).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-4](#listing5-4)展示了如果调用者保存寄存器（出于“保存机器状态，第II部分”第280页的原因，主程序将RBX的值保存在静态内存位置，而不是使用栈）的代码可能是什么样子。'
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 5-4: Demonstration of caller register preservation'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-4：调用者保存寄存器的示例
- en: 'Callee preservation has two advantages: space and maintainability. If the callee
    (the procedure) preserves all affected registers, only one copy of the `push`
    and `pop` instructions exists—those the procedure contains. If the caller saves
    the values in the registers, the program needs a set of preservation instructions
    around every call. This makes your programs not only longer but also harder to
    maintain. Remembering which registers to save and restore on each procedure call
    is not easily done.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用者保留寄存器有两个优点：空间和可维护性。如果被调用者（子程序）保留所有受影响的寄存器，则只有一份`push`和`pop`指令——即子程序中包含的那些。如果调用者保存寄存器中的值，则程序需要在每个调用周围设置一组保留指令。这不仅让程序变得更长，而且也更难维护。记住在每次过程调用时需要保存和恢复哪些寄存器并非易事。
- en: On the other hand, a subroutine may unnecessarily preserve some registers if
    it preserves all the registers it modifies. In the preceding examples, the `print40Spaces`
    procedure didn’t save RBX. Although `print40Spaces` changes RBX, this won’t affect
    the program’s operation. If the caller is preserving the registers, it doesn’t
    have to save registers it doesn’t care about.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果一个子程序保留了它所修改的所有寄存器，它可能不必要地保留某些寄存器。在之前的示例中，`print40Spaces`过程没有保存RBX。尽管`print40Spaces`改变了RBX，但这不会影响程序的运行。如果调用者保留了寄存器，它就不必保存自己不关心的寄存器。
- en: One big problem with having the caller preserve registers is that your program
    may change over time. You may modify the calling code or the procedure to use
    additional registers. Such changes, of course, may change the set of registers
    that you must preserve. Worse still, if the modification is in the subroutine
    itself, you will need to locate *every* call to the routine and verify that the
    subroutine does not change any registers the calling code uses.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 保留寄存器的一个大问题是，随着时间的推移，程序可能会发生变化。你可能会修改调用代码或过程，以使用额外的寄存器。这样的变化，当然，可能会改变你必须保留的寄存器集合。更糟糕的是，如果修改发生在子程序本身，你将需要定位*每一个*调用该例程的地方，并验证该子程序不会更改调用代码所使用的任何寄存器。
- en: 'Assembly language programmers use a common convention with respect to register
    preservation: unless there is a good reason (performance) for doing otherwise,
    most programmers will preserve all registers that a procedure modifies (and that
    doesn’t explicitly return a value in a modified register). This reduces the likelihood
    of defects occurring in a program because a procedure modifies a register the
    caller expects to be preserved. Of course, you could follow the rules concerning
    the Microsoft ABI with respect to volatile and nonvolatile registers; however,
    such calling conventions impose their own inefficiencies on programmers (and other
    programs).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言程序员在寄存器保留方面有一个常见约定：除非有充分理由（性能原因）做出不同的选择，否则大多数程序员会保留子程序修改的所有寄存器（且这些寄存器不会显式返回一个修改后的值）。这减少了程序中发生缺陷的可能性，因为子程序修改了调用者期望保留的寄存器。当然，你也可以遵循与微软ABI相关的规则，关于易失性和非易失性寄存器；然而，这样的调用约定给程序员（以及其他程序）带来了效率上的弊端。
- en: Preserving registers isn’t all there is to preserving the environment. You can
    also push and pop variables and other values that a subroutine might change. Because
    the x86-64 allows you to push and pop memory locations, you can easily preserve
    these values as well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 保留寄存器并不是保留环境的全部。你还可以推入和弹出子程序可能更改的变量和其他值。由于x86-64允许你推入和弹出内存位置，你也可以轻松保留这些值。
- en: 5.3 Procedures and the Stack
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 过程与堆栈
- en: 'Because procedures use the stack to hold the return address, you must exercise
    caution when pushing and popping data within a procedure. Consider the following
    simple (and defective) procedure:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于过程使用堆栈来保存返回地址，在过程内推入和弹出数据时必须小心。考虑以下简单（但有缺陷的）过程：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At the point the program encounters the `ret` instruction, the x86-64 stack
    takes the form shown in [Figure 5-1](#figure5-1).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序遇到`ret`指令时，x86-64堆栈呈现出[图5-1](#figure5-1)所示的形式。
- en: '![f05001](image_fi/501089c05/f05001.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![f05001](image_fi/501089c05/f05001.png)'
- en: 'Figure 5-1: Stack contents before `ret` in the `MessedUp` procedure'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-1：`MessedUp`过程中的`ret`指令之前的堆栈内容
- en: The `ret` instruction isn’t aware that the value on the top of the stack is
    not a valid address. It simply pops whatever value is on top and jumps to that
    location. In this example, the top of the stack contains the saved RAX value.
    Because it is very unlikely that RAX’s value pushed on the stack was the proper
    return address, this program will probably crash or exhibit another undefined
    behavior. Therefore, when pushing data onto the stack within a procedure, you
    must take care to properly pop that data prior to returning from the procedure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`ret` 指令并不知道栈顶的值不是有效的地址。它只是弹出栈顶的任何值，并跳转到该位置。在这个例子中，栈顶包含了保存的 RAX 值。因为 RAX 推入栈中的值不太可能是正确的返回地址，所以这个程序可能会崩溃或表现出其他未定义的行为。因此，在过程内将数据推入栈时，必须确保在从过程返回之前正确弹出这些数据。'
- en: 'Popping extra data off the stack prior to executing the `ret` statement can
    also create havoc in your programs. Consider the following defective procedure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 `ret` 指令之前，从栈中弹出额外数据也可能会对程序造成严重影响。请考虑以下有缺陷的过程：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Upon reaching the `ret` instruction in this procedure, the x86-64 stack looks
    something like [Figure 5-2](#figure5-2).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行到该过程中的`ret`指令时，x86-64栈的状态大致如下图 [Figure 5-2](#figure5-2) 所示。
- en: '![f05002](image_fi/501089c05/f05002.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![f05002](image_fi/501089c05/f05002.png)'
- en: 'Figure 5-2: Stack contents before `ret` in `MessedUp2`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-2：`MessedUp2` 中 `ret` 前的栈内容
- en: Once again, the `ret` instruction blindly pops whatever data happens to be on
    the top of the stack and attempts to return to that address. Unlike the previous
    example, in which the top of the stack was unlikely to contain a valid return
    address (because it contained the value in RAX), there is a small possibility
    that the top of the stack in this example *does* contain a return address. However,
    this will not be the proper return address for the `messedUp2` procedure; instead,
    it will be the return address for the procedure that called `messedUp2`. To understand
    the effect of this code, consider the program in [Listing 5-5](#listing5-5).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`ret` 指令会盲目地弹出栈顶的任何数据，并尝试返回到那个地址。与前面的例子不同，在前者中栈顶的内容不太可能是有效的返回地址（因为它包含了
    RAX 的值），而在这个例子中，栈顶有可能包含有效的返回地址。然而，这个地址不会是 `messedUp2` 过程的正确返回地址；相反，它会是调用 `messedUp2`
    过程的过程的返回地址。为了理解这段代码的效果，可以参考 [Listing 5-5](#listing5-5) 中的程序。
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 5-5: Effect of popping too much data off the stack'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-5：从栈中弹出过多数据的影响
- en: Because a valid return address is sitting on the top of the stack when `proc1`
    is entered, you might think that this program will actually work (properly). However,
    when returning from the `proc1` procedure, this code returns directly to the `asmMain`
    program rather than to the proper return address in the `proc2` procedure. Therefore,
    all code in the `proc2` procedure that follows the call to `proc1` does not execute.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在进入 `proc1` 时栈顶有一个有效的返回地址，你可能会认为这个程序会正常运行（按预期）。然而，从 `proc1` 过程返回时，这段代码直接返回到
    `asmMain` 程序，而不是返回到 `proc2` 过程中的正确返回地址。因此，所有在调用 `proc1` 之后的 `proc2` 过程中的代码都不会执行。
- en: When reading the source code, you may find it very difficult to figure out why
    those statements are not executing, because they immediately follow the call to
    the `proc1` procedure. It isn’t clear, unless you look very closely, that the
    program is popping an extra return address off the stack and therefore doesn’t
    return to `proc2` but rather returns directly to whoever calls `proc2`. Therefore,
    you should always be careful about pushing and popping data in a procedure, and
    verify that a one-to-one relationship exists between the pushes in your procedures
    and the corresponding pops.^([1](#c05-footnote-1))
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读源代码时，你可能会发现很难理解为什么那些语句没有执行，因为它们紧跟在对 `proc1` 过程的调用之后。除非你仔细观察，否则并不明显，程序正从栈中弹出一个额外的返回地址，因此并没有返回到
    `proc2`，而是直接返回到调用 `proc2` 的地方。因此，在过程中操作栈时，你应该始终小心推入和弹出数据，并确保在你的过程中的每次推入和相应的弹出之间存在一对一的关系。^([1](#c05-footnote-1))
- en: 5.3.1 Activation Records
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 激活记录
- en: Whenever you call a procedure, the program associates certain information with
    that procedure call, including the return address, parameters, and automatic local
    variables, using a data structure called an *activation record.*^([2](#c05-footnote-2))
    The program creates an activation record when calling (activating) a procedure,
    and the data in the structure is organized in a manner identical to records.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你调用一个过程时，程序会为该过程调用关联某些信息，包括返回地址、参数和自动局部变量，这些信息是通过一种叫做*激活记录*的数据结构来管理的。^([2](#c05-footnote-2))
    程序在调用（激活）过程时创建激活记录，结构中的数据按照记录的方式组织。
- en: Construction of an activation record begins in the code that calls a procedure.
    The caller makes room for the parameter data (if any) on the stack and copies
    the data onto the stack. Then the `call` instruction pushes the return address
    onto the stack. At this point, construction of the activation record continues
    within the procedure itself. The procedure pushes registers and other important
    state information and then makes room in the activation record for local variables.
    The procedure might also update the RBP register so that it points at the base
    address of the activation record.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 激活记录的构建始于调用过程的代码。调用者在栈上为参数数据（如果有的话）腾出空间并将数据复制到栈上。然后，`call`指令将返回地址推送到栈上。此时，激活记录的构建在过程内部继续。过程会推送寄存器和其他重要的状态信息，然后为局部变量在激活记录中腾出空间。过程可能还会更新RBP寄存器，使其指向激活记录的基地址。
- en: 'To see what a traditional activation record looks like, consider the following
    C++ procedure declaration:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看传统的激活记录是什么样的，请考虑以下C++过程声明：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Whenever a program calls this `ARDemo` procedure, it begins by pushing the data
    for the parameters onto the stack. In the original C/C++ calling convention (ignoring
    the Microsoft ABI), the calling code pushes the parameters onto the stack in the
    opposite order that they appear in the parameter list, from right to left. Therefore,
    the calling code first pushes the value for the `k` parameter, then it pushes
    the value for the `j` parameter, and it finally pushes the data for the `i` parameter.
    After pushing the parameters, the program calls the `ARDemo` procedure. Immediately
    upon entry into the `ARDemo` procedure, the stack contains these four items arranged
    as shown in [Figure 5-3](#figure5-3). By pushing the parameters in the reverse
    order, they appear on the stack in the correct order (with the first parameter
    at the lowest address in memory).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每当程序调用`ARDemo`过程时，它会首先将参数数据推送到栈上。在原始的C/C++调用约定中（忽略Microsoft ABI），调用代码将参数按与其在参数列表中出现的顺序相反的顺序，从右到左推送到栈上。因此，调用代码首先将`k`参数的值推送到栈上，然后推送`j`参数的值，最后推送`i`参数的数据。在推送完参数后，程序调用`ARDemo`过程。进入`ARDemo`过程时，栈中包含这四个项目，排列方式如[图
    5-3](#figure5-3)所示。通过反向推送参数，它们在栈中的顺序是正确的（第一个参数位于内存中的最低地址）。
- en: '![f05003](image_fi/501089c05/f05003.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![f05003](image_fi/501089c05/f05003.png)'
- en: 'Figure 5-3: Stack organization immediately upon entry into `ARDemo`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-3：进入`ARDemo`时的栈组织
- en: The first few instructions in `ARDemo` will push the current value of RBP onto
    the stack and then copy the value of RSP into RBP.^([3](#c05-footnote-3)) Next,
    the code drops the stack pointer down in memory to make room for the local variables.
    This produces the stack organization shown in [Figure 5-4](#figure5-4).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARDemo`中的前几条指令会将当前的RBP值推送到栈上，然后将RSP的值复制到RBP寄存器中。^([3](#c05-footnote-3)) 接下来，代码将栈指针向下移动，以在内存中为局部变量腾出空间。这会产生如[图
    5-4](#figure5-4)所示的栈组织。'
- en: '![f05004](image_fi/501089c05/f05004.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![f05004](image_fi/501089c05/f05004.png)'
- en: 'Figure 5-4: Activation record for `ARDemo`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-4：`ARDemo`的激活记录
- en: 5.3.1.1 Accessing Objects in the Activation Record
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1.1 访问激活记录中的对象
- en: To access objects in the activation record, you must use offsets from the RBP
    register to the desired object. The two items of immediate interest to you are
    the parameters and the local variables. You can access the parameters at positive
    offsets from the RBP register; you can access the local variables at negative
    offsets from the RBP register, as [Figure 5-5](#figure5-5) shows.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问激活记录中的对象，必须使用从RBP寄存器到目标对象的偏移量。你需要特别关注的两个项目是参数和局部变量。你可以通过RBP寄存器的正偏移量访问参数；通过RBP寄存器的负偏移量访问局部变量，如[图
    5-5](#figure5-5)所示。
- en: Intel specifically reserves the RBP (Base Pointer) register for use as a pointer
    to the base of the activation record. This is why you should avoid using the RBP
    register for general calculations. If you arbitrarily change the value in the
    RBP register, you could lose access to the current procedure’s parameters and
    local variables.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔专门保留了RBP（基指针）寄存器，用作指向激活记录基址的指针。这就是为什么你应该避免将RBP寄存器用于常规计算的原因。如果你随意更改RBP寄存器中的值，可能会导致无法访问当前过程的参数和局部变量。
- en: The local variables are aligned on offsets that are equal to their native size
    (chars are aligned on 1-byte addresses, shorts/words are aligned on 2-byte addresses,
    longs/ints/unsigneds/dwords are aligned on 4-byte addresses, and so forth). In
    the `ARDemo` example, all of the locals just happen to be allocated on appropriate
    addresses (assuming a compiler allocates storage in the order of declaration).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量按其本地大小对齐（字符按1字节地址对齐，短整型/字按2字节地址对齐，长整型/整数/无符号整数/双字按4字节地址对齐，依此类推）。在`ARDemo`示例中，所有局部变量恰好都分配在适当的地址上（假设编译器按声明顺序分配存储空间）。
- en: '![f05005](image_fi/501089c05/f05005.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![f05005](image_fi/501089c05/f05005.png)'
- en: 'Figure 5-5: Offsets of objects in the `ARDemo` activation record'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-5：`ARDemo`激活记录中对象的偏移量
- en: 5.3.1.2 Using Microsoft ABI Parameter Conventions
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1.2 使用Microsoft ABI参数约定
- en: 'The Microsoft ABI makes several modifications to the activation record model,
    in particular:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft ABI对激活记录模型进行了若干修改，特别是：
- en: The caller passes the first four parameters in registers rather than on the
    stack (though it must still reserve storage on the stack for those parameters).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用者将前四个参数通过寄存器传递，而不是通过栈传递（尽管它仍然需要在栈上为这些参数保留存储空间）。
- en: Parameters are always 8-byte values.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数始终是8字节的值。
- en: The caller must reserve (at least) 32 bytes of parameter data on the stack,
    even if there are fewer than five parameters (plus 8 bytes for each additional
    parameter if there are five or more parameters).
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用者必须在栈上保留（至少）32字节的参数数据，即使参数少于五个（如果参数有五个或更多，则每个额外的参数还需要保留8字节）。
- en: RSP must be 16-byte-aligned immediately before the `call` instruction pushes
    the return address onto the stack.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`call`指令将返回地址压入栈之前，RSP必须是16字节对齐的。
- en: For more information, see “Microsoft ABI Notes” in Chapter 1. You must follow
    these conventions only when calling Windows or other Microsoft ABI–compliant code.
    For assembly language procedures that you write and call, you can use any convention
    you like.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参阅第1章中的“Microsoft ABI说明”。你只需在调用Windows或其他Microsoft ABI兼容代码时遵循这些约定。对于你自己编写并调用的汇编语言过程，你可以使用任何你喜欢的约定。
- en: 5.3.2 The Assembly Language Standard Entry Sequence
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 汇编语言标准入口序列
- en: 'The caller of a procedure is responsible for allocating storage for parameters
    on the stack and moving the parameter data to its appropriate location. In the
    simplest case, this just involves pushing the data onto the stack by using 64-bit
    `push` instructions. The `call` instruction pushes the return address onto the
    stack. It is the procedure’s responsibility to construct the rest of the activation
    record. You can accomplish this by using the following assembly language *standard
    entry sequence* code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 过程的调用者负责在栈上分配参数存储空间，并将参数数据移动到适当的位置。在最简单的情况下，这只是通过使用64位`push`指令将数据压入栈中。`call`指令将返回地址压入栈。构建其余的激活记录是过程的责任。你可以通过以下汇编语言的*标准入口序列*代码来实现这一点：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the procedure doesn’t have any local variables, the third instruction shown
    here, `sub rsp,` `num_vars`, isn’t necessary.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果过程没有任何局部变量，这里显示的第三条指令`sub rsp, num_vars`就不必要了。
- en: '`num_vars` represents the number of *bytes* of local variables needed by the
    procedure, a constant that should be a multiple of 16 (so the RSP register remains
    aligned on a 16-byte boundary).^([4](#c05-footnote-4)) If the number of bytes
    of local variables in the procedure is not a multiple of 16, you should round
    up the value to the next higher multiple of 16 before subtracting this constant
    from RSP. Doing so will slightly increase the amount of storage the procedure
    uses for local variables but will not otherwise affect the operation of the procedure.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`num_vars` 代表该过程所需的*局部变量*字节数，这是一个常数，应为16的倍数（以确保RSP寄存器在16字节边界上对齐）。^([4](#c05-footnote-4))
    如果过程中的局部变量字节数不是16的倍数，你应该将该值四舍五入到下一个更高的16的倍数，然后再从RSP中减去这个常数。这样做会略微增加该过程为局部变量分配的存储量，但不会影响过程的其他操作。'
- en: If a Microsoft ABI–compliant program calls your procedure, the stack will be
    aligned on a 16-byte boundary immediately prior to the execution of the `call`
    instruction. As the return address adds 8 bytes to the stack, immediately upon
    entry into your procedure, the stack will be aligned on an (*RSP mod 16*) == *8*
    address (aligned on an 8-byte address but not on a 16-byte address). Pushing RBP
    onto the stack (to save the old value before copying RSP into RBP) adds another
    8 bytes to the stack so that RSP is now 16-byte-aligned. Therefore, assuming the
    stack was 16-byte-aligned prior to the call, and the number you subtract from
    RSP is a multiple of 16, the stack will be 16-byte-aligned after allocating storage
    for local variables.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个符合Microsoft ABI的程序调用你的过程，栈将在执行`call`指令之前立即在16字节边界上对齐。由于返回地址向栈中添加了8个字节，进入你的过程时，栈将对齐到一个（*RSP
    mod 16*）== *8* 的地址（对齐到8字节地址，但未对齐到16字节地址）。将RBP推入栈中（以便在将RSP复制到RBP之前保存旧值）会再向栈中添加8个字节，因此RSP现在会是16字节对齐的。因此，假设在调用之前栈已经是16字节对齐的，并且从RSP中减去的数字是16的倍数，分配本地变量存储后，栈将是16字节对齐的。
- en: 'If you cannot ensure that RSP is 16-byte-aligned (*RSP mod 16 == 8*) upon entry
    into your procedure, you can always force 16-byte alignment by using the following
    sequence at the beginning of your procedure:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法确保在进入你的过程时RSP是16字节对齐的（*RSP mod 16 == 8*），你可以通过在过程开始时使用以下序列强制16字节对齐：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The –16 is equivalent to 0FFFF_FFFF_FFFF_FFF0h. The `and` instruction sequence
    forces the stack to be aligned on a 16-byte boundary (it reduces the value in
    the stack pointer so that it is a multiple of 16).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: –16等价于0FFFF_FFFF_FFFF_FFF0h。`and`指令序列强制栈对齐到16字节边界（它将栈指针中的值减少到16的倍数）。
- en: The `ARDemo` activation record has only 12 bytes of local storage. Therefore,
    subtracting 12 from RSP for the local variables will not leave the stack 16-byte-aligned.
    The `and` instruction in the preceding sequence, however, guarantees that RSP
    is 16-byte-aligned regardless of RSP’s value upon entry into the procedure (this
    adds in the padding bytes shown in [Figure 5-5](#figure5-5)). The few bytes and
    CPU cycles needed to execute this instruction would pay off handsomely if RSP
    was not oword aligned. Of course, if you know that the stack was properly aligned
    before the call, you could dispense with the extra `and` instruction and simply
    subtract 16 from RSP rather than 12 (in other words, reserving 4 more bytes than
    the `ARDemo` procedure needs, to keep the stack aligned).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARDemo` 激活记录只有12字节的本地存储。因此，从RSP中减去12来分配本地变量将无法保证栈是16字节对齐的。然而，前面序列中的`and`指令确保无论进入过程时RSP的值如何，RSP始终是16字节对齐的（这会在[图5-5](#figure5-5)中显示的那样，添加填充字节）。如果RSP没有按字节对齐，执行该指令所需的几个字节和CPU周期会得到丰厚的回报。当然，如果你知道栈在调用之前已经正确对齐，你可以省略额外的`and`指令，直接从RSP中减去16，而不是12（换句话说，保留比`ARDemo`过程需要的多4个字节，以保持栈对齐）。'
- en: 5.3.3 The Assembly Language Standard Exit Sequence
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 汇编语言标准退出序列
- en: Before a procedure returns to its caller, it needs to clean up the activation
    record. Standard MASM procedures and procedure calls, therefore, assume that it
    is the procedure’s responsibility to clean up the activation record, although
    it is possible to share the cleanup duties between the procedure and the procedure’s
    caller.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个过程返回到它的调用者之前，需要清理激活记录。因此，标准的MASM过程和过程调用假设清理激活记录是过程的责任，尽管可以在过程和过程的调用者之间共享清理任务。
- en: 'If a procedure does not have any parameters, the exit sequence is simple. It
    requires only three instructions:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个过程没有任何参数，则退出序列非常简单。它只需要三条指令：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the Microsoft ABI (as opposed to pure assembly procedures), it is the caller’s
    responsibility to clean up any parameters pushed on the stack. Therefore, if you
    are writing a function to be called from C/C++ (or other Microsoft ABI–compliant
    code), your procedure doesn’t have to do anything at all about the parameters
    on the stack.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在Microsoft ABI中（与纯汇编过程不同），清理栈上推送的任何参数是调用者的责任。因此，如果你编写的函数是从C/C++（或其他符合Microsoft
    ABI的代码）调用的，你的过程无需做任何关于栈上参数的事情。
- en: 'If you are writing procedures that will be called only from your assembly language
    programs, it is possible to have the callee (the procedure) rather than the caller
    clean up the parameters on the stack upon returning to the caller, using the following
    standard exit sequence:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写只会从汇编语言程序中调用的过程，可以让被调用方（即过程）在返回调用方时清理栈上的参数，使用以下标准退出序列：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `parm_bytes` operand of the `ret` instruction is a constant that specifies
    the number of bytes of parameter data to remove from the stack after the return
    instruction pops the return address. For example, the `ARDemo` example code in
    the previous sections has three quad words reserved for the parameters (because
    we want to keep the stack qword aligned). Therefore, the standard exit sequence
    would take the following form:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`ret`指令的`parm_bytes`操作数是一个常量，指定在返回指令弹出返回地址后，从栈上移除的参数数据的字节数。例如，前面章节中的`ARDemo`示例代码为参数保留了三个四字（因为我们希望保持栈的qword对齐）。因此，标准退出序列将采用以下形式：'
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you do not specify a 16-bit constant operand to the `ret` instruction, the
    x86-64 will not pop the parameters off the stack upon return. Those parameters
    will still be sitting on the stack when you execute the first instruction following
    the `call` to the procedure. Similarly, if you specify a value that is too small,
    some of the parameters will be left on the stack upon return from the procedure.
    If the `ret` operand you specify is too large, the `ret` instruction will actually
    pop some of the caller’s data off the stack, usually with disastrous consequences.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有为`ret`指令指定一个16位常量操作数，x86-64将不会在返回时从栈上弹出参数。执行完`call`到过程后的第一条指令时，这些参数仍然会留在栈上。类似地，如果你指定的值过小，某些参数将会在从过程返回时留在栈上。如果你指定的`ret`操作数过大，`ret`指令实际上会将一些调用者的数据从栈上弹出，通常会导致灾难性后果。
- en: 'By the way, Intel has added a special instruction to the instruction set to
    shorten the standard exit sequence: `leave`. This instruction copies RBP into
    RSP and then pops RBP. The following is equivalent to the standard exit sequence
    presented thus far:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，Intel在指令集中添加了一条特殊指令来缩短标准退出序列：`leave`。这条指令将RBP复制到RSP，然后弹出RBP。以下代码与之前介绍的标准退出序列等效：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The choice is up to you. Most compilers generate the `leave` instruction (because
    it’s shorter), so using it is the standard choice.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 选择权在你。大多数编译器会生成`leave`指令（因为它更简短），因此使用它是标准选择。
- en: 5.4 Local (Automatic) Variables
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 局部（自动）变量
- en: Procedures and functions in most high-level languages let you declare *local
    variables*. These are generally accessible only within the procedure; they are
    not accessible by the code that calls the procedure.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数高级语言中的过程和函数允许你声明*局部变量*。这些变量通常只能在过程内部访问；它们无法被调用该过程的代码访问。
- en: 'Local variables possess two special attributes in HLLs: scope and lifetime.The
    *scope* of an identifier determines where that identifier is visible (accessible)
    in the source file during compilation. In most HLLs, the scope of a procedure’s
    local variable is the body of that procedure; the identifier is inaccessible outside
    that procedure.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量在高级语言中具有两个特殊属性：作用域和生命周期。标识符的*作用域*决定了该标识符在编译期间源文件中的可见性（可访问性）。在大多数高级语言中，过程的局部变量的作用域是该过程的主体；标识符在该过程外部不可访问。
- en: Whereas scope is a compile-time attribute of a symbol, *lifetime* is a runtime
    attribute. The lifetime of a variable is from that point when storage is first
    bound to the variable until the point where the storage is no longer available
    for that variable. Static objects (those you declare in the `.data`, `.const`,
    `.data?`, and `.code` sections) have a lifetime equivalent to the total runtime
    of the application. The program allocates storage for such variables when the
    program first loads into memory, and those variables maintain that storage until
    the program terminates.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 而作用域是符号的编译时属性，*生命周期*是运行时属性。变量的生命周期是从存储首次绑定到该变量时开始，到存储不再可用时结束。静态对象（即你在`.data`、`.const`、`.data?`和`.code`段中声明的对象）具有与应用程序总运行时间相等的生命周期。程序在第一次加载到内存时为这些变量分配存储空间，这些变量在程序终止之前保持该存储空间。
- en: Local variables (or, more properly, *automatic variables*) have their storage
    allocated upon entry into a procedure, and that storage is returned for other
    use when the procedure returns to its caller. The name *automatic* refers to the
    program automatically allocating and deallocating storage for the variable on
    procedure invocation and return.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: A procedure can access any global `.data`, `.data?`, or `.const` object the
    same way the main program accesses such variables—by referencing the name (using
    the PC-relative addressing mode). Accessing global objects is convenient and easy.
    Of course, accessing global objects makes your programs harder to read, understand,
    and maintain, so you should avoid using global variables within procedures. Although
    accessing global variables within a procedure may sometimes be the best solution
    to a given problem, you likely won’t be writing such code at this point, so you
    should carefully consider your options before doing so.^([5](#c05-footnote-5))
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.1 Low-Level Implementation of Automatic (Local) Variables
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Your program accesses local variables in a procedure by using negative offsets
    from the activation record base address (RBP). Consider the following MASM procedure
    in [Listing 5-6](#listing5-6) (which admittedly doesn’t do much, other than demonstrate
    the use of local variables).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 5-6: Sample procedure that accesses local variables'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The standard entry sequence allocates 16 bytes of storage even though locals
    `a` and `b` require only 8\. This keeps the stack 16-byte-aligned. If this isn’t
    necessary for a particular procedure, subtracting 8 would work just as well.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: The activation record for `localVars` appears in [Figure 5-6](#figure5-6).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Of course, having to refer to the local variables by the offset from the RBP
    register is truly horrible. This code is not only difficult to read (is `[RBP-4]`
    the `a` or the `b` variable?) but also hard to maintain. For example, if you decide
    you no longer need the `a` variable, you’d have to go find every occurrence of
    `[RBP-8]` (accessing the `b` variable) and change it to `[RBP-4]`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![f05006](image_fi/501089c05/f05006.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-6: Activation record for the `LocalVars` procedure'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: A slightly better solution is to create equates for your local variable names.
    Consider the modification to [Listing 5-6](#listing5-6) shown here in [Listing
    5-7](#listing5-7).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 5-7: Local variables using equates'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'This is considerably easier to read and maintain than the former program in
    [Listing 5-6](#listing5-6). It’s possible to improve on this equate system. For
    example, the following four equates are perfectly legitimate:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: MASM will associate `[RBP-4]` with `a`, `[RBP-8]` with `b`, `[RBP-12]` with
    `d`, and `[RBP-16]` with `e`. However, getting too crazy with fancy equates doesn’t
    pay; MASM provides a high-level-like declaration for local variables (and parameters)
    you can use if you really want your declarations to be as maintainable as possible.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.2 The MASM Local Directive
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating equates for local variables is a lot of work and error prone. It’s
    easy to specify the wrong offset when defining equates, and adding and removing
    local variables from a procedure is a headache. Fortunately, MASM provides a directive
    that lets you specify local variables, and MASM automatically fills in the offsets
    for the locals. That directive, `local`, uses the following syntax:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为本地变量创建等式是一项繁琐且容易出错的工作。在定义等式时，很容易指定错误的偏移量，添加或删除过程中的本地变量也非常麻烦。幸运的是，MASM 提供了一条指令，让你能够指定本地变量，并且
    MASM 会自动为本地变量填充偏移量。这个指令是 `local`，其语法如下：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `list_of_declarations` is a list of local variable declarations, separated
    by commas. A local variable declaration has two main forms:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`list_of_declarations` 是一个本地变量声明的列表，声明之间用逗号分隔。一个本地变量声明有两种主要形式：'
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, `type` is one of the usual MASM data types (`byte`, `word`, `dword`, and
    so forth), and `identifier` is the name of the local variable you are declaring.
    The second form declares local arrays, where `elements` is the number of array
    elements. `elements` must be a constant expression that MASM can resolve at assembly
    time.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`type` 是常见的 MASM 数据类型之一（`byte`、`word`、`dword` 等），`identifier` 是你要声明的本地变量的名称。第二种形式声明本地数组，其中
    `elements` 是数组元素的数量。`elements` 必须是 MASM 在汇编时能够解析的常量表达式。
- en: '`local` directives, if they appear in a procedure, must be the first statement(s)
    after a procedure declaration (the `proc` directive). A procedure may have more
    than one local statement; if there is more than one `local` directive, all must
    appear together after the `proc` declaration. Here’s a code snippet with examples
    of local variable declarations:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`local` 指令，如果出现在一个过程（procedure）中，必须是紧跟在过程声明（`proc` 指令）之后的第一条语句。一个过程可以有多个 `local`
    语句；如果有多个 `local` 指令，它们必须紧随 `proc` 声明之后。下面是一个包含本地变量声明的代码片段示例：'
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'MASM automatically associates appropriate offsets with each variable you declare
    via the `local` directive. MASM assigns offsets to the variables by subtracting
    the variable’s size from the current offset (starting at zero) and then rounding
    down to an offset that is a multiple of the object’s size. For example, if `userType`
    is `typedef`’d to `real8`, MASM assigns offsets to the local variables in `procWithLocals`
    as shown in the following MASM listing output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 会自动为你通过 `local` 指令声明的每个变量关联适当的偏移量。MASM 通过将变量的大小从当前偏移量（从零开始）中减去，然后将其舍入到对象大小的倍数来为变量分配偏移量。例如，如果
    `userType` 被 `typedef` 定义为 `real8`，MASM 会像下面的 MASM 输出一样为 `procWithLocals` 中的本地变量分配偏移量：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In addition to assigning an offset to each local variable, MASM associates the
    `[RBP-constant]` addressing mode with each of these symbols. Therefore, if you
    use a statement like `mov ax, local2` in the procedure, MASM will substitute `[RBP-4]`
    for the symbol `local2`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为每个本地变量分配偏移量外，MASM 还将 `[RBP-constant]` 寻址模式与每个符号关联。因此，如果你在过程内使用像 `mov ax,
    local2` 这样的语句，MASM 将会用 `[RBP-4]` 替代符号 `local2`。
- en: Of course, upon entry into the procedure, you must still allocate storage for
    the local variables on the stack; that is, you must still provide the code for
    the standard entry (and standard exit) sequence. This means you must add up all
    the storage needed for the local variables so you can subtract this value from
    RSP after moving RSP’s value into RBP. Once again, this is grunt work that could
    turn out to be a source of defects in the procedure (if you miscount the number
    of bytes of local variable storage), so you must take care when manually computing
    the storage requirements.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在进入过程时，你仍然需要在堆栈上分配本地变量的存储空间；也就是说，你仍然需要提供标准的入口（和标准退出）序列的代码。这意味着你必须加总所有本地变量所需的存储空间，以便在将
    RSP 的值移动到 RBP 后从 RSP 中减去这个值。同样，这是重复性工作，如果你误算了本地变量存储的字节数，可能会成为过程中的缺陷源，因此在手动计算存储需求时必须小心。
- en: 'MASM does provide a solution (of sorts) for this problem: the `option` directive.
    You’ve seen the `option casemap:none`, `option noscoped`, and `option scoped`
    directives already; the `option` directive actually supports a wide array of arguments
    that control MASM’s behavior. Two option operands control procedure code generation
    when using the local directive: `prologue` and `epilogue`. These operands typically
    take the following two forms:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 确实为这个问题提供了一种解决方案（某种程度上）：`option` 指令。你已经看到过 `option casemap:none`、`option
    noscoped` 和 `option scoped` 指令；`option` 指令实际上支持许多参数，用于控制 MASM 的行为。使用 `local` 指令时，有两个操作数控制过程代码生成：`prologue`
    和 `epilogue`。这些操作数通常有以下两种形式：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By default, MASM assumes `prologue:none` and `epilogue:none`. When you specify
    `none` as the `prologue` and `epilogue` values, MASM will not generate any extra
    code to support local variable storage allocation and deallocation in a procedure;
    you will be responsible for supplying the standard entry and exit sequences for
    the procedure.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，MASM 假设 `prologue:none` 和 `epilogue:none`。当你将 `prologue` 和 `epilogue`
    的值设置为 `none` 时，MASM 不会生成任何额外的代码来支持过程中的本地变量存储分配和释放；你将负责为该过程提供标准的入口和退出序列。
- en: If you insert the `option prologue:``PrologueDef` (default prologue generation)
    and `option epilogue:``EpilogueDef` (default epilogue generation) into your source
    file, all following procedures will automatically generate the appropriate standard
    entry and exit sequences for you (assuming local directives are in the procedure).
    MASM will quietly generate the standard entry sequence (the *prologue*) immediately
    after the last local directive (and before the first machine instruction) in a
    procedure, consisting of the usual standard entry sequence instructions
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在源文件中插入 `option prologue:PrologueDef`（默认序言生成）和 `option epilogue:EpilogueDef`（默认尾声生成），所有后续过程将自动为你生成适当的标准入口和退出序列（前提是过程内有本地指令）。MASM
    会在过程的最后一个本地指令之后（在第一个机器指令之前）悄悄生成标准入口序列（*序言*），包括通常的标准入口序列指令。
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: where `local_size` is a constant specifying the number of local variables plus
    a (possible) additional amount to leave the stack aligned on a 16-byte boundary.
    (MASM usually assumes the stack was aligned on a *mod 16 == 8* boundary prior
    to the `push rbp` instruction.)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `local_size` 是一个常量，指定本地变量的数量，外加一个（可能的）额外量，用于保持栈对齐到16字节边界。（MASM 通常假设栈在 `push
    rbp` 指令之前是对齐到 *mod 16 == 8* 的边界。）
- en: 'For MASM’s automatically generated prologue code to work, the procedure must
    have exactly one entry point. If you define a global statement label as a second
    entry point, MASM won’t know that it is supposed to generate the prologue code
    at that point. Entering the procedure at that second entry point will create problems
    unless you explicitly include the standard entry sequence yourself. Moral of the
    story: procedures should have exactly one entry point.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 MASM 自动生成的序言代码正常工作，过程必须有且只有一个入口点。如果你定义了一个全局语句标签作为第二个入口点，MASM 就不知道在那个位置生成序言代码。除非你明确地自己包含标准入口序列，否则从第二个入口点进入过程会导致问题。这个故事的寓意是：过程应该有且只有一个入口点。
- en: 'Generating the standard exit sequence for the epilogue is a bit more problematic.
    Although it is rare for an assembly language procedure to have more than a single
    *entry* point, it’s common to have multiple *exit* points. After all, the exit
    point is controlled by the programmer’s placement of a `ret` instruction, not
    by a directive (like `endp`). MASM deals with the issue of multiple exit points
    by automatically translating any `ret` instruction it finds into the standard
    exit sequence:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 生成尾声的标准退出序列会更具挑战性。虽然一个汇编语言过程通常只有一个 *入口* 点，但常常有多个 *退出* 点。毕竟，退出点是由程序员通过放置 `ret`
    指令来控制的，而不是通过某个指令（如 `endp`）。MASM 通过自动将找到的任何 `ret` 指令转换为标准退出序列来处理多个退出点的问题。
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Assuming, of course, that `option epilogue:EpilogueDef` is active.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，假设 `option epilogue:EpilogueDef` 处于激活状态。
- en: You can control whether MASM generates prologues (standard entry sequences)
    and epilogues (standard exit sequences) independently of one another. So if you
    would prefer to write the `leave` instruction yourself (while having MASM generate
    the standard entry sequence), you can.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以控制 MASM 是否生成序言（标准入口序列）和尾声（标准退出序列），它们相互独立。因此，如果你希望自己编写 `leave` 指令（同时让 MASM
    生成标准入口序列），是完全可以的。
- en: One final note about the `prologue:` and `epilogue:` options. In addition to
    specifying `prologue:PrologueDef` and `epilogue:EpilogueDef`, you can also supply
    a *macro identifier* after the `prologue:` or `epilogue:` options. If you supply
    a macro identifier, MASM will expand that macro for the standard entry or exit
    sequence. For more information on macros, see “Macros and the MASM Compile-Time
    Language” in Chapter 13.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `prologue:` 和 `epilogue:` 选项的最后一点。在指定 `prologue:PrologueDef` 和 `epilogue:EpilogueDef`
    之外，你还可以在 `prologue:` 或 `epilogue:` 选项后提供一个 *宏标识符*。如果你提供了宏标识符，MASM 会为标准入口或退出序列展开该宏。有关宏的更多信息，请参见第13章中的《宏和MASM编译时语言》。
- en: Most of the example programs throughout the remainder of this book continue
    to use `textequ` declarations for local variables rather than the `local` directive
    to make the use of the `[RBP-constant]` addressing mode and local variable offsets
    more explicit.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 5.4.3 Automatic Allocation
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One big advantage to automatic storage allocation is that it efficiently shares
    a fixed pool of memory among several procedures. For example, say you call three
    procedures in a row, like so:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first procedure (`ProcA` in this code) allocates its local variables on
    the stack. Upon return, `ProcA` deallocates that stack storage. Upon entry into
    `ProcB`, the program allocates storage for `ProcB`’s local variables by *using
    the same memory locations just freed by ProcA*. Likewise, when `ProcB` returns
    and the program calls `ProcC`, `ProcC` uses the same stack space for its local
    variables that `ProcB` recently freed up. This memory reuse makes efficient use
    of the system resources and is probably the greatest advantage to using automatic
    variables.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen how assembly language allocates and deallocates storage
    for local variables, it’s easy to understand why automatic variables do not maintain
    their values between two calls to the same procedure. Once the procedure returns
    to its caller, the storage for the automatic variable is lost, and, therefore,
    the value is lost as well. Thus, *you must always assume that a local* `var` *object
    is uninitialized upon entry into a procedure*. If you need to maintain the value
    of a variable between calls to a procedure, you should use one of the static variable
    declaration types.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 5.5 Parameters
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although many procedures are totally self-contained, most require input data
    and return data to the caller. *Parameters* are values that you pass to and from
    a procedure. In straight assembly language, passing parameters can be a real chore.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to consider when discussing parameters is how we pass them
    to a procedure. If you are familiar with Pascal or C/C++, you’ve probably seen
    two ways to pass parameters: *pass by value* and *pass by reference*. Anything
    that can be done in an HLL can be done in assembly language (obviously, as HLL
    code compiles into machine code), but you have to provide the instruction sequence
    to access those parameters in an appropriate fashion.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'Another concern you will face when dealing with parameters is *where* you pass
    them. There are many places to pass parameters: in registers, on the stack, in
    the code stream, in global variables, or in a combination of these. This chapter
    covers several of the possibilities.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.1 Pass by Value
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A parameter passed by value is just that—the caller passes a value to the procedure.
    Pass-by-value parameters are input-only parameters. You can pass them to a procedure,
    but the procedure cannot return values through them. Consider this C/C++ function
    call:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you pass `I` by value, `CallProc()` does not change the value of`I`, regardless
    of what happens to the parameter inside `CallProc()`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Because you must pass a copy of the data to the procedure, you should use this
    method only for passing small objects like bytes, words, double words, and quad
    words. Passing large arrays and records by value is inefficient (because you must
    create and pass a copy of the object to the procedure).^([6](#c05-footnote-6))
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.2 Pass by Reference
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To pass a parameter by reference, you must pass the address of a variable rather
    than its value. In other words, you must pass a pointer to the data. The procedure
    must dereference this pointer to access the data. Passing parameters by reference
    is useful when you must modify the actual parameter or when you pass large data
    structures between procedures. Because pointers on the x86-64 are 64 bits wide,
    a parameter that you pass by reference will consist of a quad-word value.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: 'You can compute the address of an object in memory in two common ways: the
    `offset` operator or the `lea` instruction. You can use the `offset` operator
    to take the address of any static variable you’ve declared in your `.data`, `.data?`,
    `.const`, or `.code` sections. [Listing 5-8](#listing5-8) demonstrates how to
    obtain the address of a static variable (`staticVar`) and pass that address to
    a procedure (`someFunc`) in the RCX register.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 5-8: Using the `offset` operator to obtain the address of a static
    variable'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `offset` operator raises a couple of issues. First of all, it can
    compute the address of only a static variable; you cannot obtain the address of
    an automatic (local) variable or parameter, nor can you compute the address of
    a memory reference involving a complex memory addressing mode (for example, `[RBX+RDX*1-5]`).
    Another problem is that an instruction like `mov rcx, offset staticVar` assembles
    into a large number of bytes (because the `offset` operator returns a 64-bit constant).
    If you look at the assembly listing MASM produces (with the `/Fl` command line
    option), you can see how big this instruction is:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see here, the `mov` instruction is 10 (0Ah) bytes long.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ve seen numerous examples of the second way to obtain the address of a
    variable: the `lea` instruction (for example, when loading the address of a format
    string into RCX prior to calling `printf()`). [Listing 5-9](#listing5-9) shows
    the example in [Listing 5-8](#listing5-8) recoded to use the `lea` instruction.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 5-9: Obtaining the address of a variable using the `lea` instruction'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the listing MASM produces for this code, we find that the `lea`
    instruction is only 7 bytes long:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So, if nothing else, your programs will be shorter if you use the `lea` instruction
    rather than the `offset` operator.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Another advantage to using `lea` is that it will accept any memory addressing
    mode, not just the name of a static variable. For example, if `staticVar` were
    an array of 32-bit integers, you could load the current element address, indexed
    by the RDX register, in RCX by using an instruction such as this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Pass by reference is usually less efficient than pass by value. You must dereference
    all pass-by-reference parameters on each access; this is slower than simply using
    a value because it typically requires at least two instructions. However, when
    passing a large data structure, pass by reference is faster because you do not
    have to copy the large data structure before calling the procedure. Of course,
    you’d probably need to access elements of that large data structure (for example,
    an array) by using a pointer, so little efficiency is lost when you pass large
    arrays by reference.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.3 Low-Level Parameter Implementation
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A parameter-passing mechanism is a contract between the caller and the callee
    (the procedure). Both parties have to agree on where the parameter data will appear
    and what form it will take (for example, value or address). If your assembly language
    procedures are being called only by other assembly language code that you’ve written,
    you control both sides of the contract negotiation and get to decide where and
    how you’re going to pass parameters.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: However, if external code is calling your procedure, or your procedure is calling
    external code, your procedure will have to adhere to whatever *calling convention*
    that external code uses. On 64-bit Windows systems, that calling convention will,
    undoubtedly, be the Windows ABI.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Before discussing the Windows calling conventions, we’ll consider the situation
    of calling code that you’ve written (and, therefore, have complete control over
    the calling conventions). The following sections provide insight into the various
    ways you can pass parameters in pure assembly language code (without the overhead
    associated with the Microsoft ABI).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.3.1 Passing Parameters in Registers
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Having touched on *how* to pass parameters to a procedure, the next thing to
    discuss is *where* to pass parameters. This depends on the size and number of
    those parameters. If you are passing a small number of parameters to a procedure,
    the registers are an excellent place to pass them. If you are passing a single
    parameter to a procedure, you should use the registers listed in [Table 5-1](#table5-1)
    for the accompanying data types.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5-1: Parameter Location by Size'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data size** | **Pass in this register** |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| Byte | CL |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| Word | CX |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| Double word | ECX |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: '| Quad word | RCX |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
- en: This is not a hard-and-fast rule. However, these registers are convenient because
    they mesh with the first parameter register in the Microsoft ABI (which is where
    most people will pass a single parameter).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are passing several parameters to a procedure in the x86-64’s registers,
    you should probably use up the registers in the following order:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In general, you should pass integer and other non-floating-point values in the
    general-purpose registers, and floating-point values in the XMM*x*/YMM*x* registers.
    This is not a hard requirement, but Microsoft reserves these registers for passing
    parameters and for local variables (*volatile*), so using these registers to pass
    parameters won’t mess with Microsoft ABI nonvolatile registers. Of course, if
    you intend to have Microsoft ABI–compliant code call your procedure, you must
    exactly observe the Microsoft calling conventions (see “Calling Conventions and
    the Microsoft ABI” on page 261).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you’re writing pure assembly language code (no calls to or from
    any code you didn’t write), you can use most of the general-purpose registers
    as you see fit (RSP is an exception, and you should avoid RBP, but the others
    are fair game). Ditto for the XMM/YMM registers.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: As an example, consider the `strfill(s,c)` procedure that copies the character
    `c` (passed by value in AL) to each character position in `s` (passed by reference
    in RDI) up to a zero-terminating byte ([Listing 5-10](#listing5-10)).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 5-10: Passing parameters in registers to the `strfill` procedure'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'To call the `strfill` procedure, you would load the address of the string data
    into RDI and the character value into AL prior to the call. The following code
    fragment demonstrates a typical call to `strfill`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This code passes the string by reference and the character data by value.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.3.2 Passing Parameters in the Code Stream
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another place where you can pass parameters is in the code stream immediately
    after the `call` instruction. Consider the following `print` routine that prints
    a literal string constant to the standard output device:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Normally, a subroutine returns control to the first instruction immediately
    following the `call` instruction. Were that to happen here, the x86-64 would attempt
    to interpret the ASCII codes for `"This..."` as an instruction. This would produce
    undesirable results. Fortunately, you can skip over this string before returning
    from the subroutine.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: So how do you gain access to these parameters? Easy. The return address on the
    stack points at them. Consider the implementation of `print` appearing in [Listing
    5-11](#listing5-11).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 5-11: Print procedure implementation (using code stream parameters)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: One quick note about a machine idiom in [Listing 5-11](#listing5-11). The instruction
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: isn’t actually loading an address into R8, per se. This is really an arithmetic
    instruction that is computing R8 = RDX – 1 (with a single instruction rather than
    two as would normally be required). This is a common usage of the `lea` instruction
    in assembly language programs. Therefore, it’s a little programming trick that
    you should become comfortable with.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides showing how to pass parameters in the code stream, the `print` routine
    also exhibits another concept: *variable-length parameters*. The string following
    the `call` can be any practical length. The zero-terminating byte marks the end
    of the parameter list.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two easy ways to handle variable-length parameters: either use a special
    terminating value (like 0) or pass a special length value that tells the subroutine
    the number of parameters you are passing. Both methods have their advantages and
    disadvantages.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Using a special value to terminate a parameter list requires that you choose
    a value that never appears in the list. For example, `print` uses 0 as the terminating
    value, so it cannot print the NUL character (whose ASCII code is 0). Sometimes
    this isn’t a limitation. Specifying a length parameter is another mechanism you
    can use to pass a variable-length parameter list. While this doesn’t require any
    special codes, or limit the range of possible values that can be passed to a subroutine,
    setting up the length parameter and maintaining the resulting code can be a real
    nightmare.^([8](#c05-footnote-8))
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Despite the convenience afforded by passing parameters in the code stream, passing
    parameters there has disadvantages. First, if you fail to provide the exact number
    of parameters the procedure requires, the subroutine will get confused. Consider
    the `print` example. It prints a string of characters up to a zero-terminating
    byte and then returns control to the first instruction following that byte. If
    you leave off the zero-terminating byte, the `print` routine happily prints the
    following opcode bytes as ASCII characters until it finds a zero byte. Because
    zero bytes often appear in the middle of an instruction, the `print` routine might
    return control into the middle of another instruction, which will probably crash
    the machine.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Inserting an extra 0, which occurs more often than you might think, is another
    problem programmers have with the `print` routine. In such a case, the `print`
    routine would return upon encountering the first zero byte and attempt to execute
    the following ASCII characters as machine code. Problems notwithstanding, however,
    the code stream is an efficient place to pass parameters whose values do not change.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.3.3 Passing Parameters on the Stack
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Most high-level languages use the stack to pass a large number of parameters
    because this method is fairly efficient. Although passing parameters on the stack
    is slightly less efficient than passing parameters in registers, the register
    set is limited (especially if you’re limiting yourself to the four registers the
    Microsoft ABI sets aside for this purpose), and you can pass only a few value
    or reference parameters through registers. The stack, on the other hand, allows
    you to pass a large amount of parameter data without difficulty. This is the reason
    that most programs pass their parameters on the stack (at least, when passing
    more than about three to six parameters).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'To manually pass parameters on the stack, push them immediately before calling
    the subroutine. The subroutine then reads this data from the stack memory and
    operates on it appropriately. Consider the following high-level language function
    call:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Back in the days of 32-bit assembly language, you could have passed these parameters
    to `CallProc` by using an instruction sequence such as the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Unfortunately, with the advent of the x86-64 64-bit CPU, the 32-bit push instruction
    was removed from the instruction set (the 64-bit `push` instruction replaced it).
    If you want to pass parameters to a procedure by using the `push` instruction,
    they must be 64-bit operands.^([9](#c05-footnote-9))
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Because keeping RSP aligned on an appropriate boundary (8 or 16 bytes) is crucial,
    the Microsoft ABI simply requires that every parameter consume 8 bytes on the
    stack, and thus doesn’t allow larger arguments on the stack. If you’re controlling
    both sides of the parameter contract (caller and callee), you can pass larger
    arguments to your procedures. However, it is a good idea to ensure that all parameter
    sizes are a multiple of 8 bytes.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: One simple solution is to make all your variables `qword` objects. Then you
    can directly push them onto the stack by using the `push` instruction prior to
    calling a procedure. However, not all objects fit nicely into 64 bits (characters,
    for example). Even those objects that could be 64 bits (for example, integers)
    often don’t require the use of so much storage.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'One sneaky way to use the `push` instruction on smaller objects is to use type
    coercion. Consider the following calling sequence for `CallProc`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This sequence pushes the 64-bit values starting at the addresses associated
    with variables `i`, `j`, and `k`, regardless of the size of these variables. If
    the `i`, `j`, and `k` variables are smaller objects (perhaps 32-bit integers),
    these `push` instructions will push their values onto the stack along with additional
    data beyond these variables. As long as `CallProc` treats these parameter values
    as their actual size (say, 32 bits) and ignores the HO bits pushed for each argument
    onto the stack, this will usually work out properly.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Pushing extra data beyond the bounds of the variable onto the stack creates
    one possible problem. If the variable is at the very end of a page in memory and
    the following page is not readable, then pushing data beyond the variable may
    attempt to push data from that next memory page, resulting in a memory access
    violation (which will crash your program). Therefore, if you use this technique,
    you must ensure that such variables do not appear at the very end of a memory
    page (with the possibility that the next page in memory is inaccessible). The
    easiest way to do this is to make sure the variables you push on the stack in
    this fashion are never the last variables you declare in your data sections; for
    example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: While pushing extra data beyond a variable will work, it’s still a questionable
    programming practice. A better technique is to abandon the `push` instructions
    altogether and use a different technique to move the parameter data onto the stack.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to “push” data onto the stack is to drop the RSP register down
    an appropriate amount in memory and then simply move data onto the stack by using
    a `mov` (or similar) instruction. Consider the following calling sequence for
    `CallProc`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Although this takes twice as many instructions as the previous examples (eight
    versus four), this sequence is safe (no possibility of accessing inaccessible
    memory pages). Furthermore, it pushes exactly the amount of data needed for the
    parameters onto the stack (32 bits for each object, for a total of 12 bytes).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'The major problem with this approach is that it is a really bad idea to have
    an address in the RSP register that is not aligned on an 8-byte boundary. In the
    worst case, having a nonaligned (to 8 bytes) stack will crash your program; in
    the very best case, it will affect the performance of your program. So even if
    you want to pass the parameters as 32-bit integers, you should always allocate
    a multiple of 8 bytes for parameters on the stack prior to a call. The previous
    example would be encoded as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that `CallProc` will simply ignore the extra 4 bytes allocated on the stack
    in this fashion (don’t forget to remove this extra storage from the stack on return).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'To satisfy the requirement of the Microsoft ABI (and, in fact, of most application
    binary interfaces for the x86-64 CPUs) that each parameter consume exactly 8 bytes
    (even if their native data size is smaller), you can use the following code (same
    number of instructions, just uses a little more stack space):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `mov` instructions spread out the data on 8-byte boundaries. The HO dword
    of each 64-bit entry on the stack will contain garbage (whatever data was in stack
    memory prior to this sequence). That’s okay; the `CallProc` procedure (presumably)
    will ignore that extra data and operate only on the LO 32 bits of each parameter
    value.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Upon entry into `CallProc`, using this sequence, the x86-64’s stack looks like
    [Figure 5-7](#figure5-7).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '![f05007](image_fi/501089c05/f05007.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-7: Stack layout upon entry into `CallProc`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'If your procedure includes the standard entry and exit sequences, you may directly
    access the parameter values in the activation record by indexing off the RBP register.
    Consider the layout of the activation record for `CallProc` that uses the following
    declaration:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Assuming you’ve pushed three quad-word parameters onto the stack, it should
    look something like [Figure 5-8](#figure5-8) immediately after the execution of
    `mov rbp, rsp` in `CallProc`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can access the parameters by indexing off the RBP register:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![f05008](image_fi/501089c05/f05008.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5-8: Activation record for `CallProc` after standard entry sequence
    execution'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.3.4 Accessing Value Parameters on the Stack
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Accessing parameters passed by value is no different from accessing a local
    variable object. One way to accomplish this is by using equates, as was demonstrated
    for local variables earlier. [Listing 5-12](#listing5-12) provides an example
    program whose procedure accesses a parameter that the main program passes to it
    by value.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Listing 5-12: Demonstration of value parameters'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Although you could access the value of `theParm` by using the anonymous address
    `[RBP+16]` within your code, using the equate in this fashion makes your code
    more readable and maintainable.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.4 Declaring Parameters with the proc Directive
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MASM provides another solution for declaring parameters for procedures using
    the `proc` directive. You can supply a list of parameters as operands to the `proc`
    directive, as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: where `parameter_list` is a list of one or more parameter declarations separated
    by commas. Each parameter declaration takes the form
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'where `parm_name` is a valid MASM identifier, and `type` is one of the usual
    MASM types (`proc`, `byte`, `word`, `dword`, and so forth). With one exception,
    the parameter list declarations are identical to the local directive’s operands:
    the exception is that MASM doesn’t allow arrays as parameters. (MASM parameters
    assume that the Microsoft ABI is being used, and the Microsoft ABI allows only
    64-bit parameters.)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameter declarations appearing as `proc` operands assume that a standard
    entry sequence is executed and that the program will access parameters off the
    RBP register, with the saved RBP and return address values at offsets 0 and 8
    from the RBP register (so the first parameter will start at offset 16). MASM assigns
    offsets for each parameter that are 8 bytes apart (per the Microsoft ABI). As
    an example, consider the following parameter declaration:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`k` will have the offset `[RBP+16]`, `j` will have the offset `[RBP+24]`, and
    `i` will have the offset `[RBP+32]`. Again, the offsets are always 8 bytes, regardless
    of the parameter data type.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: As per the Microsoft ABI, MASM will allocate storage on the stack for the first
    four parameters, even though you would normally pass these parameters in RCX,
    RDX, R8, and R9\. These 32 bytes of storage (starting at `RBP+16`) are called
    *shadow storage* in Microsoft ABI nomenclature. Upon entry into the procedure,
    the parameter values do not appear in this shadow storage (instead, the values
    are in the registers). The procedure can save the register values in this preallocated
    storage, or it can use the shadow storage for any purpose it desires (such as
    for additional local variable storage). However, if the procedure refers to the
    parameter names declared in the `proc` operand field, expecting to access the
    parameter data, the procedure should store the values from these registers into
    that shadow storage (assuming the parameters were passed in the RCX, RDX, R8,
    and R9 registers). Of course, if you push these arguments on the stack prior to
    the call (in assembly language, ignoring the Microsoft ABI calling convention),
    then the data is already in place, and you don’t have to worry about shadow storage
    issues.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: 'When calling a procedure whose parameters you declare in the operand field
    of a `proc` directive, don’t forget that MASM assumes you push the parameters
    onto the stack in the reverse order they appear in the parameter list, to ensure
    that the first parameter in the list is at the lowest memory address on the stack.
    For example, if you call the `procWithParms` procedure from the previous code
    snippet, you’d typically use code like the following to push the parameters:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Another possible solution (a few bytes longer, but often faster) is to use
    the following code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Don’t forget that if it is the callee’s responsibility to clean up the stack,
    you’d probably use an `add rsp, 24` instruction after the preceding two sequences
    to remove the parameters from the stack. Of course, you can also have the procedure
    itself clean up the stack by specifying the number to add to RSP as a `ret` instruction
    operand, as explained earlier in this chapter.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 5.5.5 Accessing Reference Parameters on the Stack
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because you pass the addresses of objects as reference parameters, accessing
    the reference parameters within a procedure is slightly more difficult than accessing
    value parameters because you have to dereference the pointers to the reference
    parameters.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 5-13](#listing5-13), the `RefParm` procedure has a single pass-by-reference
    parameter. A pass-by-reference parameter is always a (64-bit) pointer to an object.
    To access the value associated with the parameter, this code has to load that
    quad-word address into a 64-bit register and access the data indirectly. The `mov
    rax, theParm` instruction in [Listing 5-13](#listing5-13) fetches this pointer
    into the RAX register, and then the procedure `RefParm` uses the `[RAX]` addressing
    mode to access the actual value of `theParm`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Listing 5-13: Accessing a reference parameter'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the build commands and program output for [Listing 5-13](#listing5-13):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can see, accessing (small) pass-by-reference parameters is a little less
    efficient than accessing value parameters because you need an extra instruction
    to load the address into a 64-bit pointer register (not to mention you have to
    reserve a 64-bit register for this purpose). If you access reference parameters
    frequently, these extra instructions can really begin to add up, reducing the
    efficiency of your program. Furthermore, it’s easy to forget to dereference a
    reference parameter and use the address of the value in your calculations. Therefore,
    unless you really need to affect the value of the actual parameter, you should
    use pass by value to pass small objects to a procedure.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Passing large objects, like arrays and records, is where using reference parameters
    becomes efficient. When passing these objects by value, the calling code has to
    make a copy of the actual parameter; if it is a large object, the copy process
    can be inefficient. Because computing the address of a large object is just as
    efficient as computing the address of a small scalar object, no efficiency is
    lost when passing large objects by reference. Within the procedure, you must still
    dereference the pointer to access the object, but the efficiency loss due to indirection
    is minimal when you contrast this with the cost of copying that large object.
    The program in [Listing 5-14](#listing5-14) demonstrates how to use pass by reference
    to initialize an array of records.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Listing 5-14: Passing an array of records by referencing'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the build commands and output for [Listing 5-14](#listing5-14):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As you can see from this example, passing large objects by reference is very
    efficient.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 5.6 Calling Conventions and the Microsoft ABI
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in the days of 32-bit programs, different compilers and languages typically
    used completely different parameter-passing conventions. As a result, a program
    written in Pascal could not call a C/C++ function (at least, using the native
    Pascal parameter-passing conventions). Similarly, C/C++ programs couldn’t call
    FORTRAN, or BASIC, or functions written in other languages, without special help
    from the programmer. It was literally a Tower of Babel situation, as the languages
    were incompatible with one another.^([10](#c05-footnote-10))
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: To resolve these problems, CPU manufacturers, such as Intel, devised a set of
    protocols known as the *application binary interface* *(**ABI)* to provide conformity
    to procedure calls. Languages that conformed to the CPU manufacturer’s ABI were
    able to call functions and procedures written in other languages that also conformed
    to the same ABI. This brought a modicum of sanity to the world of programming
    language interoperability.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: For programs running under Windows, Microsoft took a subset of the Intel ABI
    and created the Microsoft calling convention (which most people call the *Microsoft
    ABI*). The next section covers the Microsoft calling conventions in detail. However,
    first it’s worthwhile to discuss many of the other calling conventions that existed
    prior to the Microsoft ABI.^([11](#c05-footnote-11))
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: One of the older *formal* calling conventions is the *Pascal calling convention*.
    In thisconvention, a caller pushes parameters on the stack in the order that they
    appear in the actual parameter list (from left to right). On the 80x86/x86-64
    CPUs, where the stack grows down in memory, the first parameter winds up at the
    highest address on the stack, and the last parameter winds up at the lowest address
    on the stack.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: While it might look like the parameters appear backward on the stack, the computer
    doesn’t really care. After all, the procedure will access the parameters by using
    a numeric offset, and it doesn’t care about the offset’s value.^([12](#c05-footnote-12))
    On the other hand, for simple compilers, it’s much easier to generate code that
    pushes the parameters in the order they appear in the source file, so the Pascal
    calling convention makes life a little easier for compiler writers (though optimizing
    compilers often rearrange the code anyway).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Another feature of the Pascal calling convention is that the callee (the procedure
    itself) is responsible for removing parameter data from the stack upon subroutine
    return. This localizes the cleanup code to the procedure so that parameter cleanup
    isn’t duplicated across every call to the procedure.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: The big drawback to the Pascal calling sequence is that handling variable parameter
    lists is difficult. If one call to a procedure has three parameters, and a second
    call has four parameters, the offset to the first parameter will vary depending
    on the actual number of parameters. Furthermore, it’s more difficult (though certainly
    not impossible) for a procedure to clean up the stack after itself if the number
    of parameters varies. This is not an issue for Pascal programs, as standard Pascal
    does not allow user-written procedures and functions to have varying parameter
    lists. For languages like C/C++, however, this is an issue.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'Because C (and other C-based programming languages) supports varying parameter
    lists (for example, the `printf()` function), C adopted a different calling convention:
    the *C calling convention*, also known as the *cdecl calling convention*. In C,
    the caller pushes parameters on the stack in the reverse order that they appear
    in the actual parameter list. So, it pushes the last parameter first and pushes
    the first parameter last. Because the stack is a LIFO data structure, the first
    parameter winds up at the lowest address on the stack (and at a fixed offset from
    the return address, typically right above it in memory; this is true regardless
    of how many actual parameters appear on the stack). Also, because C supports varying
    parameter lists, it is up to the caller to clean up the parameters on the stack
    after the return from the function.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: The third common calling convention in use on 32-bit Intel machines, *STDCALL*,
    is basically a combination of the Pascal and C/C++ calling conventions. Parameters
    are passed right to left (as in C/C++). However, the callee is responsible for
    cleaning up the parameters on the stack before returning.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: One problem with these three calling conventions is that they all use only memory
    to pass their parameters to a procedure. Of course, the most efficient place to
    pass parameters is in machine registers. This led to a fourth common calling convention
    known as the *FASTCALL calling convention*. In thisconvention, the calling program
    passes parameters in registers to a procedure. However, as registers are a limited
    resource on most CPUs, the FASTCALL calling convention typically passes only the
    first three to six parameters in registers. If more parameters are needed, the
    FASTCALL passes the remaining parameters on the stack (typically in reverse order,
    like the C/C++ and STDCALL calling conventions).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 5.7 The Microsoft ABI and Microsoft Calling Convention
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter has repeatedly referred to the Microsoft ABI. Now it’s time to
    formally describe the Microsoft calling convention.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 5.7.1 Data Types and the Microsoft ABI
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted in “Microsoft ABI Notes” in Chapters 1, 3, and 4, the native data type
    sizes are 1, 2, 4, and 8 bytes (see [Table 1-6](c01.xhtml#table1-6) in Chapter
    1). All such variables should be aligned in memory on their native size.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: For parameters, all procedure/function parameters must consume exactly 64 bits.
    If a data object is smaller than 64 bits, the HO bits of the parameter value (the
    bits beyond the actual parameter’s native size) are undefined (and not guaranteed
    to be zero). Procedures should access only the actual data bits for the parameter’s
    native type and ignore the HO bits.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: If a parameter’s native type is larger than 64 bits, the Microsoft ABI requires
    the caller to pass the parameter by reference rather than by value (that is, the
    caller must pass the address of the data).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 5.7.2 Parameter Locations
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Microsoft ABI uses a variant of the FASTCALL calling convention that requires
    the caller to pass the first four parameters in registers. [Table 5-2](#table5-2)
    lists the register locations for these parameters.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5-2: FASTCALL Parameter Locations'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **If scalar/reference** | **If floating point** |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
- en: '| 1 | RCX | XMM0 |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
- en: '| 2 | RDX | XMM1 |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
- en: '| 3 | R8 | XMM2 |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
- en: '| 4 | R9 | XMM3 |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
- en: '| 5 to *n* | On stack, right to left | On stack, right to left |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
- en: 'If the procedure has floating-point parameters, the calling convention skips
    the use of the general-purpose register for that same parameter location. Say
    you have the following C/C++ function:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then the Microsoft calling convention would expect the caller to pass `a` in
    (the LO 32 bits of) RCX, `b` in XMM1, a pointer to `c` in R8, and `d` in XMM3,
    skipping RDX, R9, XMM0, and XMM2\. This rule has an exception: for vararg (variable
    number of parameters) or unprototyped functions, floating-point values must be
    duplicated in the corresponding general-purpose register (see [https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160#parameter-passing/](https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160#parameter-passing/)).'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Although the Microsoft calling convention passes the first four parameters in
    registers, it still requires the caller to allocate storage on the stack for these
    parameters (*shadow storage*).^([13](#c05-footnote-13)) In fact, the Microsoft
    calling convention requires the caller to allocate storage for four parameters
    on the stack even if the procedure doesn’t have four parameters (or any parameters
    at all). The caller doesn’t need to copy the parameter data into this stack storage
    area—leaving the parameter data only in the registers is sufficient. However,
    that stack space must be present. Microsoft compilers assume the stack space is
    there and will use that stack space to save the register values (for example,
    if the procedure calls another procedure and needs to preserve the registers across
    that other call). Sometimes Microsoft’s compilers use this shadow storage as local
    variables.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: If you’re calling an external function (such as a C/C++ library function) that
    adheres to the Microsoft calling convention and you do not allocate the shadow
    storage, the application will almost certainly crash.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: 5.7.3 Volatile and Nonvolatile Registers
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted way back in Chapter 1, the Microsoft ABI declares certain registers
    to be volatile and others to be nonvolatile. *Volatile* means that a procedure
    can modify the contents of the register without preserving its value. *Nonvolatile*
    means that a procedure must preserve a register’s value if it modifies that value.
    [Table 5-3](#table5-3) lists the registers and their volatility.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 5-3: Register Volatility'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '| **Register** | **Volatile/nonvolatile** |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
- en: '| RAX | Volatile |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
- en: '| RBX | Nonvolatile |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
- en: '| RCX | Volatile |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
- en: '| RDX | Volatile |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
- en: '| RDI | Nonvolatile |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
- en: '| RSI | Nonvolatile |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
- en: '| RBP | Nonvolatile |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
- en: '| RSP | Nonvolatile |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
- en: '| R8 | Volatile |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
- en: '| R9 | Volatile |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
- en: '| R10 | Volatile |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
- en: '| R11 | Volatile |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
- en: '| R12 | Nonvolatile |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
- en: '| R13 | Nonvolatile |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
- en: '| R14 | Nonvolatile |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
- en: '| R15 | Nonvolatile |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
- en: '| XMM0/YMM0 | Volatile |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
- en: '| XMM1/YMM1 | Volatile |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
- en: '| XMM2/YMM2 | Volatile |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
- en: '| XMM3/YMM3 | Volatile |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
- en: '| XMM4/YMM4 | Volatile |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
- en: '| XMM5/YMM5 | Volatile |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
- en: '| XMM6/YMM6 | XMM6 Nonvolatile, upper half of YMM6 volatile |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
- en: '| XMM7/YMM7 | XMM7 Nonvolatile, upper half of YMM7 volatile |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
- en: '| XMM8/YMM8 | XMM8 Nonvolatile, upper half of YMM8 volatile |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
- en: '| XMM9/YMM9 | XMM9 Nonvolatile, upper half of YMM9 volatile |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
- en: '| XMM10/YMM10 | XMM10 Nonvolatile, upper half of YMM10 volatile |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
- en: '| XMM11/YMM11 | XMM11 Nonvolatile, upper half of YMM11 volatile |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
- en: '| XMM12/YMM12 | XMM12 Nonvolatile, upper half of YMM12 volatile |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
- en: '| XMM13/YMM13 | XMM13 Nonvolatile, upper half of YMM13 volatile |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
- en: '| XMM14/YMM14 | XMM14 Nonvolatile, upper half of YMM14 volatile |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
- en: '| XMM15/YMM15 | XMM15 Nonvolatile, upper half of YMM15 volatile |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
- en: '| FPU | Volatile, but FPU stack must be empty upon return |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
- en: '| Direction flag | Must be cleared upon return |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
- en: 'It is perfectly reasonable to use nonvolatile registers within a procedure.
    However, you must preserve those register values so that they are unchanged upon
    return from a function. If you’re not using the shadow storage for anything else,
    this is a good place to save and restore nonvolatile register values during a
    procedure call; for example:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Of course, if you’re using the shadow storage for another purpose, you can
    always save nonvolatile register values in local variables or can even push and
    pop the register values:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 5.7.4 Stack Alignment
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As I’ve mentioned many times now, the Microsoft ABI requires the stack to be
    aligned on a 16-byte boundary whenever you make a call to a procedure. When Windows
    transfers control to your assembly code (or when another Windows ABI–compliant
    code calls your assembly code), you’re guaranteed that the stack will be aligned
    on an 8-byte boundary that is not also a 16-byte boundary (because the return
    address consumed 8 bytes after the stack was 16-byte-aligned). If, within your
    assembly code, you don’t care about 16-byte alignment, you can do anything you
    like with the stack (however, you should keep it aligned on at least an 8-byte
    boundary).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if you ever plan on calling code that uses the Microsoft
    calling conventions, you need to be able to ensure that the stack is properly
    aligned before the call. There are two ways to do this: carefully manage any modifications
    to the RSP register after entry into your code (so you know the stack is 16-byte-aligned
    whenever you make a call), or force the stack to an appropriate alignment prior
    to making a call. Forcing alignment to 16 bytes is easily achieved using this
    instruction:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: However, you must execute this instruction *before* setting up parameters for
    a call. If you execute this instruction immediately before a call instruction
    (but after placing all the parameters on the stack), this could shift RSP down
    in memory, and then the parameters will not be at the expected offset upon entry
    into the procedure.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you don’t know the state of RSP and need to make a call to a procedure
    that expects five parameters (40 bytes, which is not a multiple of 16 bytes).
    Here’s a typical calling sequence you would use:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The only problem with this code is that it is hard to clean up the stack upon
    return (because you don’t know exactly how many bytes you reserved on the stack
    as a result of the `and` instruction). However, as you’ll see in the next section,
    you’ll rarely clean up the stack after an individual procedure call, so you don’t
    have to worry about the stack cleanup here.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 5.7.5 Parameter Setup and Cleanup (or “What’s with These Magic Instructions?”)
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Microsoft ABI requires the caller to set up the parameters and then clean
    them up (remove them from the stack) upon return from the function. In theory,
    this means that a call to a Microsoft ABI–compliant function is going to look
    something like the following:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This allocation and cleanup sequence has two problems. First, you have to repeat
    the sequence (`sub rsp``, parm_size` and `add rsp,` `parm_size`) for every call
    in your program (which can be rather inefficient). Second, as you saw in the preceding
    section, sometimes aligning the stack to a 16-byte boundary forces you to adjust
    the stack downward by an unknown amount, so you don’t know how many bytes to add
    to RSP in order to clean up the stack.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have several calls sprinkled through a given procedure, you can optimize
    the process of allocating and deallocating parameters on the stack by doing this
    operation just once. To understand how this works, consider the following code
    sequence:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If you study this code, you should be able to convince yourself that the first
    `add` and second `sub` are somewhat redundant. If you were to modify the first
    `sub` instruction to reduce the stack size by the greater of `parm_size` and `parm_size2`,
    and replace the final `add` instruction with this same value, you could eliminate
    the `add` and `sub` instructions appearing between the two calls:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If you determine the maximum number of bytes of parameters needed by all calls
    within your procedure, you can eliminate all the individual stack allocations
    and cleanups throughout the procedure (don’t forget, the minimum parameter size
    is 32 bytes, even if the procedure has no parameters at all, because of the shadow
    storage requirements).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: It gets even better, though. If your procedure has local variables, you can
    combine the `sub` instruction that allocates local variables with the one that
    allocates storage for your parameters. Similarly, if you’re using the standard
    entry/exit sequence, the `leave` instruction at the end of your procedure will
    automatically deallocate all the parameters (as well as the local variables) when
    you exit your procedure.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this book, you’ve seen lots of “magic” add and subtract instructions
    that have been offered without much in the way of explanation. Now you know what
    those instructions have been doing: they’ve been allocating storage for local
    variables and all the parameter space for the procedures being called as well
    as keeping the stack 16-byte-aligned.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one last example of a procedure that uses the standard entry/exit procedure
    to set up locals and parameter space:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: However, if you use this trick to allocate storage for your procedures’ parameters,
    you will not be able to use the `push` instructions to move the data onto the
    stack. The storage has already been allocated on the stack for the parameters;
    you must use `mov` instructions to copy the data onto the stack (using the `[RSP+``constant``]`
    addressing mode) when copying the fifth and greater parameters.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 5.8 Functions and Function Results
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Functions* are procedures that return a result to the caller. In assembly
    language, few syntactical differences exist between a procedure and a function,
    which is why MASM doesn’t provide a specific declaration for a function. Nevertheless,
    there are some semantic differences; although you can declare them the same way
    in MASM, you use them differently.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '*Procedures* are a sequence of machine instructions that fulfill a task. The
    result of the execution of a procedure is the accomplishment of that activity.
    Functions, on the other hand, execute a sequence of machine instructions specifically
    to compute a value to return to the caller. Of course, a function can perform
    an activity as well, and procedures can undoubtedly compute values, but the main
    difference is that the purpose of a function is to return a computed result; procedures
    don’t have this requirement.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: In assembly language, you don’t specifically define a function by using special
    syntax. To MASM, everything is a `proc`. A section of code becomes a function
    by virtue of the fact that the programmer explicitly decides to return a function
    result somewhere (typically in a register) via the procedure’s execution.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: The x86-64’s registers are the most common place to return function results.
    The `strlen()` routine in the C Standard Library is a good example of a function
    that returns a value in one of the CPU’s registers. It returns the length of the
    string (whose address you pass as a parameter) in the RAX register.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: By convention, programmers try to return 8-, 16-, 32-, and 64-bit (nonreal)
    results in the AL, AX, EAX, and RAX registers, respectively. This is where most
    high-level languages return these types of results, and it’s where the Microsoft
    ABI states that you should return function results. The exception is floating-point
    values. The Microsoft ABI states that you should return floating-point values
    in the XMM0 register.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there is nothing particularly sacred about the AL, AX, EAX, and RAX
    registers. You could return function results in any register if it is more convenient
    to do so. Of course, if you’re calling a Microsoft ABI–compliant function (such
    as `strlen()`), you have no choice but to expect the function’s return result
    in the RAX register (`strlen()` returns a 64-bit integer in RAX, for example).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: If you need to return a function result that is larger than 64 bits, you obviously
    must return it somewhere other than in RAX (which can hold only 64-bit values).
    For values slightly larger than 64 bits (for example, 128 bits or maybe even as
    many as 256 bits), you can split the result into pieces and return those parts
    in two or more registers. It is common to see functions returning 128-bit values
    in the RDX:RAX register pair. Of course, the XMM/YMM registers are another good
    place to return large values. Just remember that these schemes are not Microsoft
    ABI–compliant, so they’re practical only when calling code you’ve written.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to return a large object as a function result (say, an array of
    1000 elements), you obviously are not going to be able to return the function
    result in the registers. You can deal with large function return results in two
    common ways: either pass the return value as a reference parameter or allocate
    storage on the heap (for example, using the C Standard Library `malloc()` function)
    for the object and return a pointer to it in a 64-bit register. Of course, if
    you return a pointer to storage you’ve allocated on the heap, the calling program
    must free this storage when it has finished with it.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 5.9 Recursion
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Recursion* occurs when a procedure calls itself. The following, for example,
    is a recursive procedure:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Of course, the CPU will never return from this procedure. Upon entry into `Recursive`,
    this procedure will immediately call itself again, and control will never pass
    to the end of the procedure. In this particular case, runaway recursion results
    in an infinite loop.^([14](#c05-footnote-14))
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: 'Like a looping structure, recursion requires a termination condition in order
    to stop infinite recursion. `Recursive` could be rewritten with a termination
    condition as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This modification to the routine causes `Recursive` to call itself the number
    of times appearing in the EAX register. On each call, `Recursive` decrements the
    EAX register by 1 and then calls itself again. Eventually, `Recursive` decrements
    EAX to 0 and returns from each call until it returns to the original caller.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, however, there hasn’t been a real need for recursion. After all, you
    could efficiently code this procedure as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Both examples would repeat the body of the procedure the number of times passed
    in the EAX register.^([15](#c05-footnote-15)) As it turns out, there are only
    a few recursive algorithms that you cannot implement in an iterative fashion.
    However, many recursively implemented algorithms are more efficient than their
    iterative counterparts, and most of the time the recursive form of the algorithm
    is much easier to understand.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: The *quicksort algorithm* is probably the most famous algorithm that usually
    appears in recursive form. A MASM implementation of this algorithm appears in
    [Listing 5-15](#listing5-15).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Listing 5-15: Recursive quicksort program'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the build command and sample output for the quicksort program:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note that this quicksort procedure uses registers for all local variables. The
    quicksort function is a *leaf function*; it doesn’t call any other functions.
    Therefore, it doesn’t need to align the stack on a 16-byte boundary. Also, as
    is a good idea for any pure-assembly procedure (that will be called only by other
    assembly language procedures), this quicksort procedure preserves all the registers
    whose values it modifies (even the volatile registers). That’s just good programming
    practice even if it is a little less efficient.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: 5.10 Procedure Pointers
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The x86-64 call instruction allows three basic forms: PC-relative calls (via
    a procedure name), indirect calls through a 64-bit general-purpose register, and
    indirect calls through a quad-word pointer variable. The `call` instruction supports
    the following (low-level) syntax:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We’ve been using the first form throughout this book, so there is little need
    to discuss it here. The second form, the register indirect call, calls the procedure
    whose address is held in the specified 64-bit register. The address of a procedure
    is the byte address of the first instruction to execute within that procedure.
    On a von Neumann architecture machine (like the x86-64), the system stores machine
    instructions in memory along with other data. The CPU fetches the instruction
    opcode values from memory prior to executing them. When you execute the register
    indirect `call` instruction, the x86-64 first pushes the return address onto the
    stack and then begins fetching the next opcode byte (instruction) from the address
    specified by the register’s value.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: The third form of the preceding `call` instruction fetches the address of a
    procedure’s first instruction from a quad-word variable in memory. Although this
    instruction suggests that the call uses the direct addressing of the procedure,
    you should realize that any legal memory addressing mode is also legal here. For
    example, `call procPtrTable[rbx*8]` is perfectly legitimate; this statement fetches
    the quad word from the array of quad words (`procPtrTable`) and calls the procedure
    whose address is the value contained within that quad word.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: 'MASM treats procedure names like static objects. Therefore, you can compute
    the address of a procedure by using the `offset` operator along with the procedure’s
    name or by using the `lea` instruction. For example, `offset` `proc_name` is the
    address of the very first instruction of the `proc_name` procedure. So, all three
    of the following code sequences wind up calling the `proc_name` procedure:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Because the address of a procedure fits in a 64-bit object, you can store such
    an address into a quad-word variable; in fact, you can initialize a quad-word
    variable with the address of a procedure by using code like the following:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'As with all pointer objects, you should not attempt to indirectly call a procedure
    through a pointer variable unless you’ve initialized that variable with an appropriate
    address. You can initialize a procedure pointer variable in two ways: `.data`
    and `.const` objects allow an initializer, or you can compute the address of a
    routine (as a 64-bit value) and store that 64-bit address directly into the procedure
    pointer at runtime. The following code fragment demonstrates both ways to initialize
    a procedure pointer:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Although all the examples in this section use static variable declarations (`.data`,
    `.const`, `.data?`), don’t think you can declare simple procedure pointers only
    in the static variable declaration sections. You can also declare procedure pointers
    (which are just qword variables) as local variables, pass them as parameters,
    or declare them as fields of a record or a union.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 5.11 Procedural Parameters
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One place where procedure pointers are quite invaluable is in parameter lists.
    Selecting one of several procedures to call by passing the address of a procedure
    is a common operation. Of course, a *procedural parameter* is just a quad-word
    parameter containing the address of a procedure, so this is really no different
    from using a local variable to hold a procedure pointer (except, of course, that
    the caller initializes the parameter with the address of the procedure to call
    indirectly).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'When using parameter lists with the MASM `proc` directive, you can specify
    a procedure pointer type by using the `proc` type specifier; for example:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You can call the procedure pointed at by this parameter by using the following
    call instruction:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 5.12 Saving the State of the Machine, Part II
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: “Saving the State of the Machine” on page 220 described the use of the `push`
    and `pop` instructions to save the state of the registers across a procedure call
    (callee register preservation). While this is certainly one way to preserve registers
    across a procedure call, it certainly isn’t the only way, nor is it always (or
    even usually) the best way to save and restore registers.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: 'The `push` and `pop` instructions have a couple of major benefits: they are
    short (pushing or popping a 64-bit register uses a 1-byte instruction opcode),
    and they work with constant and memory operands. These instructions do have drawbacks,
    however: they modify the stack pointer, they work with only 2- or 8-byte registers,
    they work only with the general-purpose integer registers (and the FLAGS register),
    and they might be slower than an equivalent instruction that moves the register
    data onto the stack. Often, a better solution is to reserve storage in the local
    variable space and simply move the registers to/from those local variables on
    the stack.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following procedure declaration that preserves registers by using
    `push` and `pop` instructions:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'You can achieve the same thing with the following code:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The disadvantage to this code is that two extra instructions are needed to allocate
    (and deallocate) storage on the stack for the local variables that hold the register
    values. The `push` and `pop` instructions automatically allocate this storage,
    sparing you from having to supply these extra instructions. For a simple situation
    such as this, the `push` and `pop` instructions probably are the better solution.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'For more complex procedures, especially those that expect parameters on the
    stack or have local variables, the procedure is already setting up the activation
    record, and subtracting a larger number from RSP doesn’t require any additional
    instructions:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: MASM automatically generates the code to allocate the storage for `saveRAX`,
    `saveRBX`, and `saveRCX` (along with all the other local variables) on the stack,
    as well as clean up the local storage on return.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: 'When allocating local variables on the stack along with storage for any parameters
    a procedure might pass to functions it calls, pushing and popping registers to
    preserve them becomes problematic. For example, consider the following procedure:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Had this function pushed RAX, RBX, and RCX on the stack after subtracting 48
    from RSP, those save registers would have wound up on the stack where the function
    passes `parm1`, `parm2`, and `parm3` to `theFunction`. That’s why the `push` and
    `pop` instructions don’t work well when working with functions that build an activation
    record containing local storage.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 5.13 Microsoft ABI Notes
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This chapter has all but completed the discussion of the Microsoft calling
    conventions. Specifically, a Microsoft ABI–compliant function must follow these
    rules:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: (Scalar) parameters must be passed in RCX, RDX, R8, and R9, then pushed on the
    stack. Floating-point parameters substitute XMM0, XMM1, XMM2, and XMM3 for RCX,
    RDX, R8, and R9, respectively.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Varargs functions (functions with a variable number of parameters, such as `printf()`)
    and unprototyped functions must pass floating-point values in both the general-purpose
    (integer) registers and in the XMM registers. (For what it’s worth, `printf()`
    seems to be happy with just passing the floating-point values in the integer registers,
    though that might be a happy accident with the version of MSVC used in the preparation
    of this book.)
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All parameters must be less than or equal to 64 bits in size; larger parameters
    must be passed by reference.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the stack, parameters always consume 64 bits (8 bytes) regardless of their
    actual size; the HO bits of smaller objects are undefined.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immediately before a `call` instruction, the stack must be aligned on a 16-byte
    boundary.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registers RAX, RCX, RDX, R8, R9, R10, R11, and XMM0/YMM0 to XMM5/YMM5 are volatile.
    The caller must preserve the registers across a call if it needs their values
    to be saved across the call. Also note that the HO 128 bits of YMM0 to YMM15 are
    volatile, and the caller must preserve these registers if it needs these bits
    to be preserved across a call.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registers RBX, RSI, RDI, RBP, RSP, R12 to R15, and XMM6 to XMM15 are nonvolatile.
    The callee must preserve these registers if it changes their values. As noted
    earlier, while YMM0L to YMM15L (the LO 128 bits) are nonvolatile, the upper 128
    bits of these registers can be considered volatile. However, if a procedure is
    saving the LO 128 bits of YMM0 to YMM15, it may as well preserve all the bits
    (this inconsistency in the Microsoft ABI is to support legacy code running on
    CPUs that don’t support the YMM registers).
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalar function returns (64 bits or fewer) come back in the RAX register. If
    the data type is smaller than 64 bits, the HO bits of RAX are undefined.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions that return values larger than 64 bits must allocate storage for the
    return value and pass the address of that storage in the first parameter (RCX)
    to the function. On return, the function must return this pointer in the RAX register.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions return floating-point results (double or single) in the XMM0 register.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.14 For More Information
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The electronic edition of the 32-bit edition this book (found at [https://artofasm.randallhyde.com/](https://artofasm.randallhyde.com/))contains
    a whole “volume” on advanced and intermediate procedures. Though that book covers
    32-bit assembly language programming, the concepts apply directly to 64-bit assembly
    by simply using 64-bit addresses rather than 32-bit addresses.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: While the information appearing in this chapter covers 99 percent of the material
    that assembly programmers typically use, there is additional information on procedures
    and parameters that you may find interesting. In particular, the electronic edition
    covers additional parameter-passing mechanisms (pass by value/result, pass by
    result, pass by name, and pass by lazy evaluation) and goes into greater detail
    about the places you can pass parameters. The electronic version also covers iterators,
    thunks, and other advanced procedure types. Finally, a good compiler construction
    textbook will cover additional details about runtime support for procedures.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the Microsoft ABI, search for *Microsoft calling conventions*
    on the Microsoft website (or on the internet).
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: 5.15 Test Yourself
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Explain, step by step, how the `call` instruction works.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain, step by step, how the `ret` instruction works.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the `ret` instruction, with a numeric constant operand, do?
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What value is pushed on the stack for a return address?
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is namespace pollution?
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you define a single global symbol in a procedure?
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you make all symbols in a procedure non-scoped (that is, all the symbols
    in a procedure would be global)?
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain how to use the `push` and `pop` instructions to preserve registers in
    a function.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main disadvantage of caller preservation?
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the main problem with callee preservation?
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if you fail to pop a value in a function that you pushed on the
    stack at the beginning of the function?
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if you pop extra data off the stack in a function (data that you
    did not push on the stack in the function)?
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an activation record?
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What register usually points at an activation record, providing access to the
    data in that record?
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many bytes are reserved for a typical parameter on the stack when using
    the Microsoft ABI?
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the standard entry sequence for a procedure (the instructions)?
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the standard exit sequence for a procedure (the instructions)?
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What instruction can you use to force 16-byte alignment of the stack pointer
    if the current value in RSP is unknown?
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the scope of a variable?
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the lifetime of a variable?
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an automatic variable?
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When does the system allocate storage for an automatic variable?
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain two ways to declare local/automatic variables in a procedure.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Given the following procedure source code snippet, provide the offsets for
    each of the local variables:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: What statement(s) would you insert in the source file to tell MASM to automatically
    generate the standard entry and standard exit sequences for a procedure?
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When MASM automatically generates a standard entry sequence for a procedure,
    how does it determine where to put the code sequence?
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When MASM automatically generates a standard exit sequence for a procedure,
    how does it determine where to put the code sequence?
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What value does a pass-by-value parameter pass to a function?
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What value does a pass-by-reference parameter pass to a function?
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When passing four integer parameters to a function, where does the Windows ABI
    state those parameters are to be passed?
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When passing a floating-point value as one of the first four parameters, where
    does the Windows ABI insist the values will be passed?
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When passing more than four parameters to a function, where does the Windows
    ABI state the parameters will be passed?
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a volatile and nonvolatile register in the Windows
    ABI?
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which registers are volatile in the Windows ABI?
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which registers are nonvolatile in the Windows ABI?
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When passing parameters in the code stream, how does a function access the parameter
    data?
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a shadow parameter?
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many bytes of shadow storage will a function require if it has a single
    32-bit integer parameter?
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many bytes of shadow storage will a function require if it has two 64-bit
    integer parameters?
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How many bytes of shadow storage will a function require if it has six 64-bit
    integer parameters?
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What offsets will MASM associate with each of the parameters in the following
    `proc` declaration?
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Suppose that `parm4` in the preceding question is a pass-by-reference character
    parameter. How would you load that character into the AL register (provide a code
    sequence)?
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What offsets will MASM associate with each of the local variables in the following
    `proc` snippet?
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: What is the best way to pass a large array to a procedure?
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does *ABI* stand for?
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where is the most common place to return a function result?
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a procedural parameter?
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you call a procedure passed as a parameter to a function/procedure?
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If a procedure has local variables, what is the best way to preserve registers
    within that procedure?
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
