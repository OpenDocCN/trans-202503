- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Procedures
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 过程
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In a procedural programming language, the basic unit of code is the procedure.
    A *procedure* is a set of instructions that compute a value or take an action
    (such as printing or reading a character value). This chapter discusses how MASM
    implements procedures, parameters, and local variables. By the end of this chapter,
    you should be well versed in writing your own procedures and functions, and fully
    understand parameter passing and the Microsoft ABI calling convention.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程式编程语言中，代码的基本单元是过程。*过程* 是一组计算值或执行动作（如打印或读取字符值）的指令。本章讨论了 MASM 如何实现过程、参数和局部变量。通过本章内容的学习，您应该能够熟练编写自己的过程和函数，并完全理解参数传递和
    Microsoft ABI 调用约定。
- en: 5.1 Implementing Procedures
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 实现过程
- en: 'Most procedural programming languages implement procedures by using the call/return
    mechanism. The code calls a procedure, the procedure does its thing, and then
    the procedure returns to the caller. The call and return instructions provide
    the x86-64’s *procedure invocation mechanism*. The calling code calls a procedure
    with the `call` instruction, and the procedure returns to the caller with the
    `ret` instruction. For example, the following x86-64 instruction calls the C Standard
    Library `printf()` function:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数过程式编程语言通过使用调用/返回机制来实现过程。代码调用一个过程，过程执行其任务，然后返回给调用者。调用和返回指令提供了 x86-64 的 *过程调用机制*。调用代码通过
    `call` 指令调用一个过程，过程通过 `ret` 指令返回给调用者。例如，以下 x86-64 指令调用 C 标准库的 `printf()` 函数：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alas, the C Standard Library does not supply all the routines you will ever
    need. Most of the time you’ll have to write your own procedures. To do this, you
    will use MASM’s procedure-declaration facilities. A basic MASM procedure declaration
    takes the following form:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜的是，C 标准库并没有提供你永远需要的所有例程。大多数时候，您需要自己编写过程。为此，您将使用 MASM 的过程声明功能。一个基本的 MASM 过程声明形式如下：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Procedure declarations appear in the `.code` section of your program. In the
    preceding syntax example, `proc_name` represents the name of the procedure you
    wish to define. This can be any valid (and unique) MASM identifier.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 过程声明出现在程序的 `.code` 部分。在前面的语法示例中，`proc_name` 代表您希望定义的过程名称。这可以是任何有效（且唯一）的 MASM
    标识符。
- en: 'Here is a concrete example of a MASM procedure declaration. This procedure
    stores 0s into the 256 double words that RCX points at upon entry into the procedure:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个 MASM 过程声明的具体示例。该过程在进入过程中时，将 0 填充到 RCX 指向的 256 个双字中：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you’ve probably noticed, this simple procedure doesn’t bother with the “magic”
    instructions that add and subtract a value to and from the RSP register. Those
    instructions are a requirement of the Microsoft ABI when the procedure will be
    calling other C/C++ code (or other code written in a Microsoft ABI–compliant language).
    Because this little function doesn’t call any other procedures, it doesn’t bother
    executing such code. Also note that this code uses the loop index to count down
    from 256 to 0, filling in the 256 dword array backward (from end to beginning)
    rather than filling it in from beginning to end. This is a common technique in
    assembly language.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，这个简单的过程没有涉及添加和减去 RSP 寄存器值的“魔术”指令。当过程需要调用其他 C/C++ 代码（或其他使用 Microsoft
    ABI 兼容语言编写的代码）时，这些指令是 Microsoft ABI 的要求。因为这个小函数没有调用其他过程，所以它没有执行这些指令。还要注意，这段代码使用循环索引从
    256 递减到 0，倒序填充这 256 个双字数组（从末尾到开头），而不是从头到尾填充。这是汇编语言中的一种常见技术。
- en: You can use the x86-64 `call` instruction to call this procedure. When, during
    program execution, the code falls into the `ret` instruction, the procedure returns
    to whoever called it and begins executing the first instruction beyond the `call`
    instruction. The program in [Listing 5-1](#listing5-1) provides an example of
    a call to the `zeroBytes` routine.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 x86-64 的 `call` 指令来调用此过程。当程序执行时，代码遇到 `ret` 指令时，过程会返回给调用者，并开始执行 `call`
    指令后的第一条指令。[示例 5-1](#listing5-1) 中的程序提供了调用 `zeroBytes` 例程的示例。
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 5-1: Example of a simple procedure'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-1：一个简单过程的示例
- en: 5.1.1 The call and ret Instructions
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 调用和返回指令
- en: The x86-64 `call` instruction does two things. First, it pushes the (64-bit)
    address of the instruction immediately following the `call` onto the stack; then
    it transfers control to the address of the specified procedure. The value that
    `call` pushes onto the stack is known as the *return address*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64的`call`指令执行两项操作。首先，它将紧接着`call`指令之后的（64位）指令地址压入栈中；然后它将控制转移到指定过程的地址。`call`指令压入栈中的值称为*返回地址*。
- en: When the procedure wants to return to the caller and continue execution with
    the first statement following the `call` instruction, most procedures return to
    their caller by executing a `ret` (*return*) instruction. The `ret` instruction
    pops a (64-bit) return address off the stack and transfers control indirectly
    to that address.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当过程想要返回调用者并继续执行紧跟在`call`指令后的第一条语句时，大多数过程通过执行`ret`（*返回*）指令返回给调用者。`ret`指令会从栈中弹出（64位）返回地址，并间接将控制转移到该地址。
- en: 'The following is an example of the minimal procedure:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最小化过程的示例：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you call this procedure with the `call` instruction, `minimal` will simply
    pop the return address off the stack and return to the caller. If you fail to
    put the `ret` instruction in the procedure, the program will not return to the
    caller upon encountering the `endp` statement. Instead, the program will fall
    through to whatever code happens to follow the procedure in memory.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过`call`指令调用这个过程，`minimal`将简单地从栈中弹出返回地址，并返回到调用者。如果你没有在过程里放入`ret`指令，程序将在遇到`endp`语句时不会返回到调用者。相反，程序会跳到在内存中紧接着过程后面的代码。
- en: The example program in [Listing 5-2](#listing5-2) demonstrates this problem.
    The main program calls `noRet`, which falls straight through to `followingProc`
    (printing the message `followingProc was called`).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例程序在 Listing 5-2](#listing5-2) 中演示了这个问题。主程序调用了`noRet`，该程序直接跳转到`followingProc`（打印消息`followingProc
    was called`）。'
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 5-2: Effect of a missing `ret` instruction in a procedure'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 5-2：缺少`ret`指令在过程中的影响
- en: Although this behavior might be desirable in certain rare circumstances, it
    usually represents a defect in most programs. Therefore, always remember to explicitly
    return from the procedure by using the `ret` instruction.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在某些少见的情况下这种行为可能是期望的，但在大多数程序中通常表现为缺陷。因此，始终记得通过使用`ret`指令显式地从过程返回。
- en: 5.1.2 Labels in a Procedure
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 过程中的标签
- en: Procedures may contain statement labels, just like the main procedure in your
    assembly language program (after all, the main procedure, `asmMain` in most of
    the examples in this book, is just another procedure declaration as far as MASM
    is concerned). Note, however, that statement labels defined within a procedure
    are *local* to that procedure; such symbols are not *visible* outside the procedure.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 过程可以包含语句标签，就像你程序中的主过程一样（毕竟，在MASM看来，书中大部分示例中的主过程`asmMain`只是另一个过程声明）。然而，请注意，在过程内定义的语句标签是*局部*的；这些符号在过程外部是*不可见*的。
- en: In most situations, having *scoped symbols* in a procedure is nice (see “Local
    (Automatic) Variables” on page 234 for a discussion of scope). You don’t have
    to worry about *namespace pollution* (conflicting symbol names) among the different
    procedures in your source file. Sometimes, however, MASM’s name scoping can create
    problems. You might actually want to refer to a statement label outside a procedure.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，过程中的*作用域符号*是很有用的（有关作用域的讨论，请参见第234页的“局部（自动）变量”）。你不必担心不同过程之间的*命名空间污染*（符号名称冲突）。然而，有时，MASM的名称作用域可能会导致问题。你实际上可能想要引用过程外的语句标签。
- en: 'One way to do this on a label-by-label basis is to use a global statement label
    declaration. *Global statement labels* are similar to normal statement labels
    in a procedure except you follow the symbol with two colons instead of a single
    colon, like so:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在标签逐个处理的基础上，一种方法是使用全局语句标签声明。*全局语句标签*与过程中的普通语句标签类似，不同之处在于符号后面跟的是两个冒号而不是一个冒号，像这样：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Global statement labels are visible outside the procedure. You can use an unconditional
    or conditional jump instruction to transfer control to a global symbol from outside
    the procedure; you can even use a `call` instruction to call that global symbol
    (in which case, it becomes a second entry point to the procedure). Generally,
    having multiple entry points to a procedure is considered bad programming style,
    and the use of multiple entry points often leads to programming errors. As such,
    you should rarely use global symbols in assembly language procedures.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 全局语句标签在程序外部是可见的。你可以使用无条件或有条件跳转指令将控制转移到外部程序的全局符号；你甚至可以使用`call`指令调用该全局符号（在这种情况下，它变成了该程序的第二个入口点）。通常，程序拥有多个入口点被认为是糟糕的编程风格，使用多个入口点往往会导致编程错误。因此，你应该很少在汇编语言程序中使用全局符号。
- en: 'If, for some reason, you don’t want MASM to treat all the statement labels
    in a procedure as local to that procedure, you can turn scoping on and off with
    the following statements:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，你不希望MASM将程序中的所有语句标签视为该程序的局部标签，可以通过以下语句打开或关闭作用域：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `option noscoped` directive disables scoping in procedures (for all procedures
    following the directive). The `option scoped` directive turns scoping back on.
    Therefore, you can turn scoping off for a single procedure (or set of procedures)
    and turn it back on immediately afterward.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`option noscoped`指令禁用程序中的作用域（适用于指令之后的所有程序）。`option scoped`指令重新启用作用域。因此，你可以为单个程序（或程序集合）关闭作用域，并立即将其重新启用。'
- en: 5.2 Saving the State of the Machine
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 保存机器的状态
- en: Take a look at [Listing 5-3](#listing5-3). This program attempts to print 20
    lines of 40 spaces and an asterisk. Unfortunately, a subtle bug creates an infinite
    loop. The main program uses the `jnz printLp` instruction to create a loop that
    calls `PrintSpaces` 20 times. This function uses EBX to count off the 40 spaces
    it prints, and then returns with ECX containing 0\. The main program then prints
    an asterisk and a newline, decrements ECX, and then repeats because ECX isn’t
    0 (it will always contain 0FFFF_FFFFh at this point).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下[清单 5-3](#listing5-3)。该程序试图打印20行40个空格和一个星号。不幸的是，一个微妙的错误导致了无限循环。主程序使用`jnz
    printLp`指令创建一个循环，调用`PrintSpaces` 20次。该函数使用EBX来计数它打印的40个空格，然后返回时ECX为0。主程序接着打印一个星号和换行符，递减ECX，然后重复，因为ECX不是0（此时它总是包含0FFFF_FFFFh）。
- en: The problem here is that the `print40Spaces` subroutine doesn’t preserve the
    EBX register. *Preserving a register* means you save it upon entry into the subroutine
    and restore it before leaving. Had the `print40Spaces` subroutine preserved the
    contents of the EBX register, [Listing 5-3](#listing5-3) would have functioned
    properly.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是`print40Spaces`子程序没有保存EBX寄存器。*保存寄存器*意味着在进入子程序时保存寄存器的值，在离开时恢复它。如果`print40Spaces`子程序保存了EBX寄存器的内容，[清单
    5-3](#listing5-3)将能够正常工作。
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 5-3: Program with an unintended infinite loop'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-3：包含意外无限循环的程序
- en: 'You can use the x86-64’s `push` and `pop` instructions to preserve register
    values while you need to use them for something else. Consider the following code
    for `PrintSpaces`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用x86-64的`push`和`pop`指令来保存寄存器的值，暂时用于其他目的。考虑下面的`PrintSpaces`代码：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`print40Spaces` saves and restores RBX by using `push` and `pop` instructions.
    Either the caller (the code containing the call instruction) or the callee (the
    subroutine) can take responsibility for preserving the registers. In the preceding
    example, the callee preserves the registers.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`print40Spaces`通过使用`push`和`pop`指令保存和恢复RBX寄存器。可以由调用者（包含调用指令的代码）或被调用者（子程序）负责保存寄存器。在前面的例子中，被调用者负责保存寄存器。'
- en: '[Listing 5-4](#listing5-4) shows what this code might look like if the caller
    preserves the registers (for reasons that will become clear in “Saving the State
    of the Machine, Part II” on page 280, the main program saves the value of RBX
    in a static memory location rather than using the stack).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 5-4](#listing5-4)展示了如果调用者保存寄存器（出于“保存机器状态，第II部分”第280页的原因，主程序将RBX的值保存在静态内存位置，而不是使用栈）的代码可能是什么样子。'
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 5-4: Demonstration of caller register preservation'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-4：调用者保存寄存器的示例
- en: 'Callee preservation has two advantages: space and maintainability. If the callee
    (the procedure) preserves all affected registers, only one copy of the `push`
    and `pop` instructions exists—those the procedure contains. If the caller saves
    the values in the registers, the program needs a set of preservation instructions
    around every call. This makes your programs not only longer but also harder to
    maintain. Remembering which registers to save and restore on each procedure call
    is not easily done.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 被调用者保留寄存器有两个优点：空间和可维护性。如果被调用者（子程序）保留所有受影响的寄存器，则只有一份`push`和`pop`指令——即子程序中包含的那些。如果调用者保存寄存器中的值，则程序需要在每个调用周围设置一组保留指令。这不仅让程序变得更长，而且也更难维护。记住在每次过程调用时需要保存和恢复哪些寄存器并非易事。
- en: On the other hand, a subroutine may unnecessarily preserve some registers if
    it preserves all the registers it modifies. In the preceding examples, the `print40Spaces`
    procedure didn’t save RBX. Although `print40Spaces` changes RBX, this won’t affect
    the program’s operation. If the caller is preserving the registers, it doesn’t
    have to save registers it doesn’t care about.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果一个子程序保留了它所修改的所有寄存器，它可能不必要地保留某些寄存器。在之前的示例中，`print40Spaces`过程没有保存RBX。尽管`print40Spaces`改变了RBX，但这不会影响程序的运行。如果调用者保留了寄存器，它就不必保存自己不关心的寄存器。
- en: One big problem with having the caller preserve registers is that your program
    may change over time. You may modify the calling code or the procedure to use
    additional registers. Such changes, of course, may change the set of registers
    that you must preserve. Worse still, if the modification is in the subroutine
    itself, you will need to locate *every* call to the routine and verify that the
    subroutine does not change any registers the calling code uses.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 保留寄存器的一个大问题是，随着时间的推移，程序可能会发生变化。你可能会修改调用代码或过程，以使用额外的寄存器。这样的变化，当然，可能会改变你必须保留的寄存器集合。更糟糕的是，如果修改发生在子程序本身，你将需要定位*每一个*调用该例程的地方，并验证该子程序不会更改调用代码所使用的任何寄存器。
- en: 'Assembly language programmers use a common convention with respect to register
    preservation: unless there is a good reason (performance) for doing otherwise,
    most programmers will preserve all registers that a procedure modifies (and that
    doesn’t explicitly return a value in a modified register). This reduces the likelihood
    of defects occurring in a program because a procedure modifies a register the
    caller expects to be preserved. Of course, you could follow the rules concerning
    the Microsoft ABI with respect to volatile and nonvolatile registers; however,
    such calling conventions impose their own inefficiencies on programmers (and other
    programs).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 汇编语言程序员在寄存器保留方面有一个常见约定：除非有充分理由（性能原因）做出不同的选择，否则大多数程序员会保留子程序修改的所有寄存器（且这些寄存器不会显式返回一个修改后的值）。这减少了程序中发生缺陷的可能性，因为子程序修改了调用者期望保留的寄存器。当然，你也可以遵循与微软ABI相关的规则，关于易失性和非易失性寄存器；然而，这样的调用约定给程序员（以及其他程序）带来了效率上的弊端。
- en: Preserving registers isn’t all there is to preserving the environment. You can
    also push and pop variables and other values that a subroutine might change. Because
    the x86-64 allows you to push and pop memory locations, you can easily preserve
    these values as well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 保留寄存器并不是保留环境的全部。你还可以推入和弹出子程序可能更改的变量和其他值。由于x86-64允许你推入和弹出内存位置，你也可以轻松保留这些值。
- en: 5.3 Procedures and the Stack
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 过程与堆栈
- en: 'Because procedures use the stack to hold the return address, you must exercise
    caution when pushing and popping data within a procedure. Consider the following
    simple (and defective) procedure:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于过程使用堆栈来保存返回地址，在过程内推入和弹出数据时必须小心。考虑以下简单（但有缺陷的）过程：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At the point the program encounters the `ret` instruction, the x86-64 stack
    takes the form shown in [Figure 5-1](#figure5-1).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序遇到`ret`指令时，x86-64堆栈呈现出[图5-1](#figure5-1)所示的形式。
- en: '![f05001](image_fi/501089c05/f05001.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![f05001](image_fi/501089c05/f05001.png)'
- en: 'Figure 5-1: Stack contents before `ret` in the `MessedUp` procedure'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-1：`MessedUp`过程中的`ret`指令之前的堆栈内容
- en: The `ret` instruction isn’t aware that the value on the top of the stack is
    not a valid address. It simply pops whatever value is on top and jumps to that
    location. In this example, the top of the stack contains the saved RAX value.
    Because it is very unlikely that RAX’s value pushed on the stack was the proper
    return address, this program will probably crash or exhibit another undefined
    behavior. Therefore, when pushing data onto the stack within a procedure, you
    must take care to properly pop that data prior to returning from the procedure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`ret` 指令并不知道栈顶的值不是有效的地址。它只是弹出栈顶的任何值，并跳转到该位置。在这个例子中，栈顶包含了保存的 RAX 值。因为 RAX 推入栈中的值不太可能是正确的返回地址，所以这个程序可能会崩溃或表现出其他未定义的行为。因此，在过程内将数据推入栈时，必须确保在从过程返回之前正确弹出这些数据。'
- en: 'Popping extra data off the stack prior to executing the `ret` statement can
    also create havoc in your programs. Consider the following defective procedure:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 `ret` 指令之前，从栈中弹出额外数据也可能会对程序造成严重影响。请考虑以下有缺陷的过程：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Upon reaching the `ret` instruction in this procedure, the x86-64 stack looks
    something like [Figure 5-2](#figure5-2).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行到该过程中的`ret`指令时，x86-64栈的状态大致如下图 [Figure 5-2](#figure5-2) 所示。
- en: '![f05002](image_fi/501089c05/f05002.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![f05002](image_fi/501089c05/f05002.png)'
- en: 'Figure 5-2: Stack contents before `ret` in `MessedUp2`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-2：`MessedUp2` 中 `ret` 前的栈内容
- en: Once again, the `ret` instruction blindly pops whatever data happens to be on
    the top of the stack and attempts to return to that address. Unlike the previous
    example, in which the top of the stack was unlikely to contain a valid return
    address (because it contained the value in RAX), there is a small possibility
    that the top of the stack in this example *does* contain a return address. However,
    this will not be the proper return address for the `messedUp2` procedure; instead,
    it will be the return address for the procedure that called `messedUp2`. To understand
    the effect of this code, consider the program in [Listing 5-5](#listing5-5).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`ret` 指令会盲目地弹出栈顶的任何数据，并尝试返回到那个地址。与前面的例子不同，在前者中栈顶的内容不太可能是有效的返回地址（因为它包含了
    RAX 的值），而在这个例子中，栈顶有可能包含有效的返回地址。然而，这个地址不会是 `messedUp2` 过程的正确返回地址；相反，它会是调用 `messedUp2`
    过程的过程的返回地址。为了理解这段代码的效果，可以参考 [Listing 5-5](#listing5-5) 中的程序。
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 5-5: Effect of popping too much data off the stack'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5-5：从栈中弹出过多数据的影响
- en: Because a valid return address is sitting on the top of the stack when `proc1`
    is entered, you might think that this program will actually work (properly). However,
    when returning from the `proc1` procedure, this code returns directly to the `asmMain`
    program rather than to the proper return address in the `proc2` procedure. Therefore,
    all code in the `proc2` procedure that follows the call to `proc1` does not execute.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在进入 `proc1` 时栈顶有一个有效的返回地址，你可能会认为这个程序会正常运行（按预期）。然而，从 `proc1` 过程返回时，这段代码直接返回到
    `asmMain` 程序，而不是返回到 `proc2` 过程中的正确返回地址。因此，所有在调用 `proc1` 之后的 `proc2` 过程中的代码都不会执行。
- en: When reading the source code, you may find it very difficult to figure out why
    those statements are not executing, because they immediately follow the call to
    the `proc1` procedure. It isn’t clear, unless you look very closely, that the
    program is popping an extra return address off the stack and therefore doesn’t
    return to `proc2` but rather returns directly to whoever calls `proc2`. Therefore,
    you should always be careful about pushing and popping data in a procedure, and
    verify that a one-to-one relationship exists between the pushes in your procedures
    and the corresponding pops.^([1](#c05-footnote-1))
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读源代码时，你可能会发现很难理解为什么那些语句没有执行，因为它们紧跟在对 `proc1` 过程的调用之后。除非你仔细观察，否则并不明显，程序正从栈中弹出一个额外的返回地址，因此并没有返回到
    `proc2`，而是直接返回到调用 `proc2` 的地方。因此，在过程中操作栈时，你应该始终小心推入和弹出数据，并确保在你的过程中的每次推入和相应的弹出之间存在一对一的关系。^([1](#c05-footnote-1))
- en: 5.3.1 Activation Records
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 激活记录
- en: Whenever you call a procedure, the program associates certain information with
    that procedure call, including the return address, parameters, and automatic local
    variables, using a data structure called an *activation record.*^([2](#c05-footnote-2))
    The program creates an activation record when calling (activating) a procedure,
    and the data in the structure is organized in a manner identical to records.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你调用一个过程时，程序会为该过程调用关联某些信息，包括返回地址、参数和自动局部变量，这些信息是通过一种叫做*激活记录*的数据结构来管理的。^([2](#c05-footnote-2))
    程序在调用（激活）过程时创建激活记录，结构中的数据按照记录的方式组织。
- en: Construction of an activation record begins in the code that calls a procedure.
    The caller makes room for the parameter data (if any) on the stack and copies
    the data onto the stack. Then the `call` instruction pushes the return address
    onto the stack. At this point, construction of the activation record continues
    within the procedure itself. The procedure pushes registers and other important
    state information and then makes room in the activation record for local variables.
    The procedure might also update the RBP register so that it points at the base
    address of the activation record.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 激活记录的构建始于调用过程的代码。调用者在栈上为参数数据（如果有的话）腾出空间并将数据复制到栈上。然后，`call`指令将返回地址推送到栈上。此时，激活记录的构建在过程内部继续。过程会推送寄存器和其他重要的状态信息，然后为局部变量在激活记录中腾出空间。过程可能还会更新RBP寄存器，使其指向激活记录的基地址。
- en: 'To see what a traditional activation record looks like, consider the following
    C++ procedure declaration:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看传统的激活记录是什么样的，请考虑以下C++过程声明：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Whenever a program calls this `ARDemo` procedure, it begins by pushing the data
    for the parameters onto the stack. In the original C/C++ calling convention (ignoring
    the Microsoft ABI), the calling code pushes the parameters onto the stack in the
    opposite order that they appear in the parameter list, from right to left. Therefore,
    the calling code first pushes the value for the `k` parameter, then it pushes
    the value for the `j` parameter, and it finally pushes the data for the `i` parameter.
    After pushing the parameters, the program calls the `ARDemo` procedure. Immediately
    upon entry into the `ARDemo` procedure, the stack contains these four items arranged
    as shown in [Figure 5-3](#figure5-3). By pushing the parameters in the reverse
    order, they appear on the stack in the correct order (with the first parameter
    at the lowest address in memory).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每当程序调用`ARDemo`过程时，它会首先将参数数据推送到栈上。在原始的C/C++调用约定中（忽略Microsoft ABI），调用代码将参数按与其在参数列表中出现的顺序相反的顺序，从右到左推送到栈上。因此，调用代码首先将`k`参数的值推送到栈上，然后推送`j`参数的值，最后推送`i`参数的数据。在推送完参数后，程序调用`ARDemo`过程。进入`ARDemo`过程时，栈中包含这四个项目，排列方式如[图
    5-3](#figure5-3)所示。通过反向推送参数，它们在栈中的顺序是正确的（第一个参数位于内存中的最低地址）。
- en: '![f05003](image_fi/501089c05/f05003.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![f05003](image_fi/501089c05/f05003.png)'
- en: 'Figure 5-3: Stack organization immediately upon entry into `ARDemo`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-3：进入`ARDemo`时的栈组织
- en: The first few instructions in `ARDemo` will push the current value of RBP onto
    the stack and then copy the value of RSP into RBP.^([3](#c05-footnote-3)) Next,
    the code drops the stack pointer down in memory to make room for the local variables.
    This produces the stack organization shown in [Figure 5-4](#figure5-4).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARDemo`中的前几条指令会将当前的RBP值推送到栈上，然后将RSP的值复制到RBP寄存器中。^([3](#c05-footnote-3)) 接下来，代码将栈指针向下移动，以在内存中为局部变量腾出空间。这会产生如[图
    5-4](#figure5-4)所示的栈组织。'
- en: '![f05004](image_fi/501089c05/f05004.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![f05004](image_fi/501089c05/f05004.png)'
- en: 'Figure 5-4: Activation record for `ARDemo`'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5-4：`ARDemo`的激活记录
- en: 5.3.1.1 Accessing Objects in the Activation Record
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1.1 访问激活记录中的对象
- en: To access objects in the activation record, you must use offsets from the RBP
    register to the desired object. The two items of immediate interest to you are
    the parameters and the local variables. You can access the parameters at positive
    offsets from the RBP register; you can access the local variables at negative
    offsets from the RBP register, as [Figure 5-5](#figure5-5) shows.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问激活记录中的对象，必须使用从RBP寄存器到目标对象的偏移量。你需要特别关注的两个项目是参数和局部变量。你可以通过RBP寄存器的正偏移量访问参数；通过RBP寄存器的负偏移量访问局部变量，如[图
    5-5](#figure5-5)所示。
- en: Intel specifically reserves the RBP (Base Pointer) register for use as a pointer
    to the base of the activation record. This is why you should avoid using the RBP
    register for general calculations. If you arbitrarily change the value in the
    RBP register, you could lose access to the current procedure’s parameters and
    local variables.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔专门保留了RBP（基指针）寄存器，用作指向激活记录基址的指针。这就是为什么你应该避免将RBP寄存器用于常规计算的原因。如果你随意更改RBP寄存器中的值，可能会导致无法访问当前过程的参数和局部变量。
- en: The local variables are aligned on offsets that are equal to their native size
    (chars are aligned on 1-byte addresses, shorts/words are aligned on 2-byte addresses,
    longs/ints/unsigneds/dwords are aligned on 4-byte addresses, and so forth). In
    the `ARDemo` example, all of the locals just happen to be allocated on appropriate
    addresses (assuming a compiler allocates storage in the order of declaration).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量按其本地大小对齐（字符按1字节地址对齐，短整型/字按2字节地址对齐，长整型/整数/无符号整数/双字按4字节地址对齐，依此类推）。在`ARDemo`示例中，所有局部变量恰好都分配在适当的地址上（假设编译器按声明顺序分配存储空间）。
- en: '![f05005](image_fi/501089c05/f05005.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![f05005](image_fi/501089c05/f05005.png)'
- en: 'Figure 5-5: Offsets of objects in the `ARDemo` activation record'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-5：`ARDemo`激活记录中对象的偏移量
- en: 5.3.1.2 Using Microsoft ABI Parameter Conventions
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.3.1.2 使用Microsoft ABI参数约定
- en: 'The Microsoft ABI makes several modifications to the activation record model,
    in particular:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft ABI对激活记录模型进行了若干修改，特别是：
- en: The caller passes the first four parameters in registers rather than on the
    stack (though it must still reserve storage on the stack for those parameters).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用者将前四个参数通过寄存器传递，而不是通过栈传递（尽管它仍然需要在栈上为这些参数保留存储空间）。
- en: Parameters are always 8-byte values.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数始终是8字节的值。
- en: The caller must reserve (at least) 32 bytes of parameter data on the stack,
    even if there are fewer than five parameters (plus 8 bytes for each additional
    parameter if there are five or more parameters).
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用者必须在栈上保留（至少）32字节的参数数据，即使参数少于五个（如果参数有五个或更多，则每个额外的参数还需要保留8字节）。
- en: RSP must be 16-byte-aligned immediately before the `call` instruction pushes
    the return address onto the stack.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`call`指令将返回地址压入栈之前，RSP必须是16字节对齐的。
- en: For more information, see “Microsoft ABI Notes” in Chapter 1. You must follow
    these conventions only when calling Windows or other Microsoft ABI–compliant code.
    For assembly language procedures that you write and call, you can use any convention
    you like.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息请参阅第1章中的“Microsoft ABI说明”。你只需在调用Windows或其他Microsoft ABI兼容代码时遵循这些约定。对于你自己编写并调用的汇编语言过程，你可以使用任何你喜欢的约定。
- en: 5.3.2 The Assembly Language Standard Entry Sequence
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 汇编语言标准入口序列
- en: 'The caller of a procedure is responsible for allocating storage for parameters
    on the stack and moving the parameter data to its appropriate location. In the
    simplest case, this just involves pushing the data onto the stack by using 64-bit
    `push` instructions. The `call` instruction pushes the return address onto the
    stack. It is the procedure’s responsibility to construct the rest of the activation
    record. You can accomplish this by using the following assembly language *standard
    entry sequence* code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 过程的调用者负责在栈上分配参数存储空间，并将参数数据移动到适当的位置。在最简单的情况下，这只是通过使用64位`push`指令将数据压入栈中。`call`指令将返回地址压入栈。构建其余的激活记录是过程的责任。你可以通过以下汇编语言的*标准入口序列*代码来实现这一点：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If the procedure doesn’t have any local variables, the third instruction shown
    here, `sub rsp,` `num_vars`, isn’t necessary.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果过程没有任何局部变量，这里显示的第三条指令`sub rsp, num_vars`就不必要了。
- en: '`num_vars` represents the number of *bytes* of local variables needed by the
    procedure, a constant that should be a multiple of 16 (so the RSP register remains
    aligned on a 16-byte boundary).^([4](#c05-footnote-4)) If the number of bytes
    of local variables in the procedure is not a multiple of 16, you should round
    up the value to the next higher multiple of 16 before subtracting this constant
    from RSP. Doing so will slightly increase the amount of storage the procedure
    uses for local variables but will not otherwise affect the operation of the procedure.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`num_vars` 代表该过程所需的*局部变量*字节数，这是一个常数，应为16的倍数（以确保RSP寄存器在16字节边界上对齐）。^([4](#c05-footnote-4))
    如果过程中的局部变量字节数不是16的倍数，你应该将该值四舍五入到下一个更高的16的倍数，然后再从RSP中减去这个常数。这样做会略微增加该过程为局部变量分配的存储量，但不会影响过程的其他操作。'
- en: If a Microsoft ABI–compliant program calls your procedure, the stack will be
    aligned on a 16-byte boundary immediately prior to the execution of the `call`
    instruction. As the return address adds 8 bytes to the stack, immediately upon
    entry into your procedure, the stack will be aligned on an (*RSP mod 16*) == *8*
    address (aligned on an 8-byte address but not on a 16-byte address). Pushing RBP
    onto the stack (to save the old value before copying RSP into RBP) adds another
    8 bytes to the stack so that RSP is now 16-byte-aligned. Therefore, assuming the
    stack was 16-byte-aligned prior to the call, and the number you subtract from
    RSP is a multiple of 16, the stack will be 16-byte-aligned after allocating storage
    for local variables.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个符合Microsoft ABI的程序调用你的过程，栈将在执行`call`指令之前立即在16字节边界上对齐。由于返回地址向栈中添加了8个字节，进入你的过程时，栈将对齐到一个（*RSP
    mod 16*）== *8* 的地址（对齐到8字节地址，但未对齐到16字节地址）。将RBP推入栈中（以便在将RSP复制到RBP之前保存旧值）会再向栈中添加8个字节，因此RSP现在会是16字节对齐的。因此，假设在调用之前栈已经是16字节对齐的，并且从RSP中减去的数字是16的倍数，分配本地变量存储后，栈将是16字节对齐的。
- en: 'If you cannot ensure that RSP is 16-byte-aligned (*RSP mod 16 == 8*) upon entry
    into your procedure, you can always force 16-byte alignment by using the following
    sequence at the beginning of your procedure:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法确保在进入你的过程时RSP是16字节对齐的（*RSP mod 16 == 8*），你可以通过在过程开始时使用以下序列强制16字节对齐：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The –16 is equivalent to 0FFFF_FFFF_FFFF_FFF0h. The `and` instruction sequence
    forces the stack to be aligned on a 16-byte boundary (it reduces the value in
    the stack pointer so that it is a multiple of 16).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: –16等价于0FFFF_FFFF_FFFF_FFF0h。`and`指令序列强制栈对齐到16字节边界（它将栈指针中的值减少到16的倍数）。
- en: The `ARDemo` activation record has only 12 bytes of local storage. Therefore,
    subtracting 12 from RSP for the local variables will not leave the stack 16-byte-aligned.
    The `and` instruction in the preceding sequence, however, guarantees that RSP
    is 16-byte-aligned regardless of RSP’s value upon entry into the procedure (this
    adds in the padding bytes shown in [Figure 5-5](#figure5-5)). The few bytes and
    CPU cycles needed to execute this instruction would pay off handsomely if RSP
    was not oword aligned. Of course, if you know that the stack was properly aligned
    before the call, you could dispense with the extra `and` instruction and simply
    subtract 16 from RSP rather than 12 (in other words, reserving 4 more bytes than
    the `ARDemo` procedure needs, to keep the stack aligned).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARDemo` 激活记录只有12字节的本地存储。因此，从RSP中减去12来分配本地变量将无法保证栈是16字节对齐的。然而，前面序列中的`and`指令确保无论进入过程时RSP的值如何，RSP始终是16字节对齐的（这会在[图5-5](#figure5-5)中显示的那样，添加填充字节）。如果RSP没有按字节对齐，执行该指令所需的几个字节和CPU周期会得到丰厚的回报。当然，如果你知道栈在调用之前已经正确对齐，你可以省略额外的`and`指令，直接从RSP中减去16，而不是12（换句话说，保留比`ARDemo`过程需要的多4个字节，以保持栈对齐）。'
- en: 5.3.3 The Assembly Language Standard Exit Sequence
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 汇编语言标准退出序列
- en: Before a procedure returns to its caller, it needs to clean up the activation
    record. Standard MASM procedures and procedure calls, therefore, assume that it
    is the procedure’s responsibility to clean up the activation record, although
    it is possible to share the cleanup duties between the procedure and the procedure’s
    caller.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个过程返回到它的调用者之前，需要清理激活记录。因此，标准的MASM过程和过程调用假设清理激活记录是过程的责任，尽管可以在过程和过程的调用者之间共享清理任务。
- en: 'If a procedure does not have any parameters, the exit sequence is simple. It
    requires only three instructions:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个过程没有任何参数，则退出序列非常简单。它只需要三条指令：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the Microsoft ABI (as opposed to pure assembly procedures), it is the caller’s
    responsibility to clean up any parameters pushed on the stack. Therefore, if you
    are writing a function to be called from C/C++ (or other Microsoft ABI–compliant
    code), your procedure doesn’t have to do anything at all about the parameters
    on the stack.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在Microsoft ABI中（与纯汇编过程不同），清理栈上推送的任何参数是调用者的责任。因此，如果你编写的函数是从C/C++（或其他符合Microsoft
    ABI的代码）调用的，你的过程无需做任何关于栈上参数的事情。
- en: 'If you are writing procedures that will be called only from your assembly language
    programs, it is possible to have the callee (the procedure) rather than the caller
    clean up the parameters on the stack upon returning to the caller, using the following
    standard exit sequence:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写只会从汇编语言程序中调用的过程，可以让被调用方（即过程）在返回调用方时清理栈上的参数，使用以下标准退出序列：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `parm_bytes` operand of the `ret` instruction is a constant that specifies
    the number of bytes of parameter data to remove from the stack after the return
    instruction pops the return address. For example, the `ARDemo` example code in
    the previous sections has three quad words reserved for the parameters (because
    we want to keep the stack qword aligned). Therefore, the standard exit sequence
    would take the following form:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`ret`指令的`parm_bytes`操作数是一个常量，指定在返回指令弹出返回地址后，从栈上移除的参数数据的字节数。例如，前面章节中的`ARDemo`示例代码为参数保留了三个四字（因为我们希望保持栈的qword对齐）。因此，标准退出序列将采用以下形式：'
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you do not specify a 16-bit constant operand to the `ret` instruction, the
    x86-64 will not pop the parameters off the stack upon return. Those parameters
    will still be sitting on the stack when you execute the first instruction following
    the `call` to the procedure. Similarly, if you specify a value that is too small,
    some of the parameters will be left on the stack upon return from the procedure.
    If the `ret` operand you specify is too large, the `ret` instruction will actually
    pop some of the caller’s data off the stack, usually with disastrous consequences.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有为`ret`指令指定一个16位常量操作数，x86-64将不会在返回时从栈上弹出参数。执行完`call`到过程后的第一条指令时，这些参数仍然会留在栈上。类似地，如果你指定的值过小，某些参数将会在从过程返回时留在栈上。如果你指定的`ret`操作数过大，`ret`指令实际上会将一些调用者的数据从栈上弹出，通常会导致灾难性后果。
- en: 'By the way, Intel has added a special instruction to the instruction set to
    shorten the standard exit sequence: `leave`. This instruction copies RBP into
    RSP and then pops RBP. The following is equivalent to the standard exit sequence
    presented thus far:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，Intel在指令集中添加了一条特殊指令来缩短标准退出序列：`leave`。这条指令将RBP复制到RSP，然后弹出RBP。以下代码与之前介绍的标准退出序列等效：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The choice is up to you. Most compilers generate the `leave` instruction (because
    it’s shorter), so using it is the standard choice.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 选择权在你。大多数编译器会生成`leave`指令（因为它更简短），因此使用它是标准选择。
- en: 5.4 Local (Automatic) Variables
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 局部（自动）变量
- en: Procedures and functions in most high-level languages let you declare *local
    variables*. These are generally accessible only within the procedure; they are
    not accessible by the code that calls the procedure.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数高级语言中的过程和函数允许你声明*局部变量*。这些变量通常只能在过程内部访问；它们无法被调用该过程的代码访问。
- en: 'Local variables possess two special attributes in HLLs: scope and lifetime.The
    *scope* of an identifier determines where that identifier is visible (accessible)
    in the source file during compilation. In most HLLs, the scope of a procedure’s
    local variable is the body of that procedure; the identifier is inaccessible outside
    that procedure.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量在高级语言中具有两个特殊属性：作用域和生命周期。标识符的*作用域*决定了该标识符在编译期间源文件中的可见性（可访问性）。在大多数高级语言中，过程的局部变量的作用域是该过程的主体；标识符在该过程外部不可访问。
- en: Whereas scope is a compile-time attribute of a symbol, *lifetime* is a runtime
    attribute. The lifetime of a variable is from that point when storage is first
    bound to the variable until the point where the storage is no longer available
    for that variable. Static objects (those you declare in the `.data`, `.const`,
    `.data?`, and `.code` sections) have a lifetime equivalent to the total runtime
    of the application. The program allocates storage for such variables when the
    program first loads into memory, and those variables maintain that storage until
    the program terminates.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 而作用域是符号的编译时属性，*生命周期*是运行时属性。变量的生命周期是从存储首次绑定到该变量时开始，到存储不再可用时结束。静态对象（即你在`.data`、`.const`、`.data?`和`.code`段中声明的对象）具有与应用程序总运行时间相等的生命周期。程序在第一次加载到内存时为这些变量分配存储空间，这些变量在程序终止之前保持该存储空间。
- en: Local variables (or, more properly, *automatic variables*) have their storage
    allocated upon entry into a procedure, and that storage is returned for other
    use when the procedure returns to its caller. The name *automatic* refers to the
    program automatically allocating and deallocating storage for the variable on
    procedure invocation and return.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量（或者更准确地说，*自动变量*）在进入一个过程时会分配存储空间，并在过程返回时将这些存储空间归还以供其他用途。*自动*一词指的是程序在调用和返回过程时自动分配和释放变量的存储空间。
- en: A procedure can access any global `.data`, `.data?`, or `.const` object the
    same way the main program accesses such variables—by referencing the name (using
    the PC-relative addressing mode). Accessing global objects is convenient and easy.
    Of course, accessing global objects makes your programs harder to read, understand,
    and maintain, so you should avoid using global variables within procedures. Although
    accessing global variables within a procedure may sometimes be the best solution
    to a given problem, you likely won’t be writing such code at this point, so you
    should carefully consider your options before doing so.^([5](#c05-footnote-5))
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个过程可以通过引用名称（使用相对PC寻址模式）来访问任何全局`.data`、`.data?`或`.const`对象，就像主程序访问这些变量一样。访问全局对象方便且简单。当然，访问全局对象会使程序更难阅读、理解和维护，因此你应尽量避免在过程内使用全局变量。虽然在某些情况下，在过程内访问全局变量可能是解决特定问题的最佳方案，但在这个阶段，你可能不会编写这样的代码，因此在这么做之前应仔细考虑你的选择。^([5](#c05-footnote-5))
- en: 5.4.1 Low-Level Implementation of Automatic (Local) Variables
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 自动（局部）变量的低级实现
- en: Your program accesses local variables in a procedure by using negative offsets
    from the activation record base address (RBP). Consider the following MASM procedure
    in [Listing 5-6](#listing5-6) (which admittedly doesn’t do much, other than demonstrate
    the use of local variables).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你的程序通过使用来自激活记录基地址（RBP）的负偏移量来访问过程中的局部变量。考虑下面这个MASM过程，见[清单5-6](#listing5-6)（诚然，这个过程并不做什么，除了展示局部变量的使用）。
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 5-6: Sample procedure that accesses local variables'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 清单5-6：访问局部变量的示例过程
- en: The standard entry sequence allocates 16 bytes of storage even though locals
    `a` and `b` require only 8\. This keeps the stack 16-byte-aligned. If this isn’t
    necessary for a particular procedure, subtracting 8 would work just as well.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 标准入口序列即使局部变量`a`和`b`只需要8个字节，也会分配16个字节的存储空间。这是为了保持栈的16字节对齐。如果某个过程不需要这么做，减去8个字节也完全可以。
- en: The activation record for `localVars` appears in [Figure 5-6](#figure5-6).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`localVars`的激活记录见[图5-6](#figure5-6)。'
- en: Of course, having to refer to the local variables by the offset from the RBP
    register is truly horrible. This code is not only difficult to read (is `[RBP-4]`
    the `a` or the `b` variable?) but also hard to maintain. For example, if you decide
    you no longer need the `a` variable, you’d have to go find every occurrence of
    `[RBP-8]` (accessing the `b` variable) and change it to `[RBP-4]`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，必须通过偏移量引用局部变量，从RBP寄存器算起，实在是太糟糕了。这个代码不仅难以阅读（`[RBP-4]`是`a`变量还是`b`变量？），而且也很难维护。例如，如果你决定不再需要`a`变量，那么你必须去找到每个出现`[RBP-8]`（访问`b`变量）的地方，并把它改成`[RBP-4]`。
- en: '![f05006](image_fi/501089c05/f05006.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![f05006](image_fi/501089c05/f05006.png)'
- en: 'Figure 5-6: Activation record for the `LocalVars` procedure'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-6：`LocalVars`过程的激活记录
- en: A slightly better solution is to create equates for your local variable names.
    Consider the modification to [Listing 5-6](#listing5-6) shown here in [Listing
    5-7](#listing5-7).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微更好的解决方案是为你的局部变量名创建等式。考虑[清单5-6](#listing5-6)中所示修改后的[清单5-7](#listing5-7)。
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 5-7: Local variables using equates'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 清单5-7：使用等式的局部变量
- en: 'This is considerably easier to read and maintain than the former program in
    [Listing 5-6](#listing5-6). It’s possible to improve on this equate system. For
    example, the following four equates are perfectly legitimate:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这比[清单5-6](#listing5-6)中的旧程序更易读且更易维护。实际上，可以改进这个等式系统。例如，以下四个等式完全合法：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: MASM will associate `[RBP-4]` with `a`, `[RBP-8]` with `b`, `[RBP-12]` with
    `d`, and `[RBP-16]` with `e`. However, getting too crazy with fancy equates doesn’t
    pay; MASM provides a high-level-like declaration for local variables (and parameters)
    you can use if you really want your declarations to be as maintainable as possible.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: MASM会将`[RBP-4]`与`a`关联，将`[RBP-8]`与`b`关联，将`[RBP-12]`与`d`关联，将`[RBP-16]`与`e`关联。然而，过度使用花哨的等式并没有好处；如果你真的想让声明尽可能易于维护，MASM提供了类似高级语言的局部变量（和参数）声明。
- en: 5.4.2 The MASM Local Directive
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 MASM局部指令
- en: 'Creating equates for local variables is a lot of work and error prone. It’s
    easy to specify the wrong offset when defining equates, and adding and removing
    local variables from a procedure is a headache. Fortunately, MASM provides a directive
    that lets you specify local variables, and MASM automatically fills in the offsets
    for the locals. That directive, `local`, uses the following syntax:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为本地变量创建等式是一项繁琐且容易出错的工作。在定义等式时，很容易指定错误的偏移量，添加或删除过程中的本地变量也非常麻烦。幸运的是，MASM 提供了一条指令，让你能够指定本地变量，并且
    MASM 会自动为本地变量填充偏移量。这个指令是 `local`，其语法如下：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `list_of_declarations` is a list of local variable declarations, separated
    by commas. A local variable declaration has two main forms:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`list_of_declarations` 是一个本地变量声明的列表，声明之间用逗号分隔。一个本地变量声明有两种主要形式：'
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, `type` is one of the usual MASM data types (`byte`, `word`, `dword`, and
    so forth), and `identifier` is the name of the local variable you are declaring.
    The second form declares local arrays, where `elements` is the number of array
    elements. `elements` must be a constant expression that MASM can resolve at assembly
    time.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`type` 是常见的 MASM 数据类型之一（`byte`、`word`、`dword` 等），`identifier` 是你要声明的本地变量的名称。第二种形式声明本地数组，其中
    `elements` 是数组元素的数量。`elements` 必须是 MASM 在汇编时能够解析的常量表达式。
- en: '`local` directives, if they appear in a procedure, must be the first statement(s)
    after a procedure declaration (the `proc` directive). A procedure may have more
    than one local statement; if there is more than one `local` directive, all must
    appear together after the `proc` declaration. Here’s a code snippet with examples
    of local variable declarations:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`local` 指令，如果出现在一个过程（procedure）中，必须是紧跟在过程声明（`proc` 指令）之后的第一条语句。一个过程可以有多个 `local`
    语句；如果有多个 `local` 指令，它们必须紧随 `proc` 声明之后。下面是一个包含本地变量声明的代码片段示例：'
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'MASM automatically associates appropriate offsets with each variable you declare
    via the `local` directive. MASM assigns offsets to the variables by subtracting
    the variable’s size from the current offset (starting at zero) and then rounding
    down to an offset that is a multiple of the object’s size. For example, if `userType`
    is `typedef`’d to `real8`, MASM assigns offsets to the local variables in `procWithLocals`
    as shown in the following MASM listing output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 会自动为你通过 `local` 指令声明的每个变量关联适当的偏移量。MASM 通过将变量的大小从当前偏移量（从零开始）中减去，然后将其舍入到对象大小的倍数来为变量分配偏移量。例如，如果
    `userType` 被 `typedef` 定义为 `real8`，MASM 会像下面的 MASM 输出一样为 `procWithLocals` 中的本地变量分配偏移量：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In addition to assigning an offset to each local variable, MASM associates the
    `[RBP-constant]` addressing mode with each of these symbols. Therefore, if you
    use a statement like `mov ax, local2` in the procedure, MASM will substitute `[RBP-4]`
    for the symbol `local2`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除了为每个本地变量分配偏移量外，MASM 还将 `[RBP-constant]` 寻址模式与每个符号关联。因此，如果你在过程内使用像 `mov ax,
    local2` 这样的语句，MASM 将会用 `[RBP-4]` 替代符号 `local2`。
- en: Of course, upon entry into the procedure, you must still allocate storage for
    the local variables on the stack; that is, you must still provide the code for
    the standard entry (and standard exit) sequence. This means you must add up all
    the storage needed for the local variables so you can subtract this value from
    RSP after moving RSP’s value into RBP. Once again, this is grunt work that could
    turn out to be a source of defects in the procedure (if you miscount the number
    of bytes of local variable storage), so you must take care when manually computing
    the storage requirements.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在进入过程时，你仍然需要在堆栈上分配本地变量的存储空间；也就是说，你仍然需要提供标准的入口（和标准退出）序列的代码。这意味着你必须加总所有本地变量所需的存储空间，以便在将
    RSP 的值移动到 RBP 后从 RSP 中减去这个值。同样，这是重复性工作，如果你误算了本地变量存储的字节数，可能会成为过程中的缺陷源，因此在手动计算存储需求时必须小心。
- en: 'MASM does provide a solution (of sorts) for this problem: the `option` directive.
    You’ve seen the `option casemap:none`, `option noscoped`, and `option scoped`
    directives already; the `option` directive actually supports a wide array of arguments
    that control MASM’s behavior. Two option operands control procedure code generation
    when using the local directive: `prologue` and `epilogue`. These operands typically
    take the following two forms:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 确实为这个问题提供了一种解决方案（某种程度上）：`option` 指令。你已经看到过 `option casemap:none`、`option
    noscoped` 和 `option scoped` 指令；`option` 指令实际上支持许多参数，用于控制 MASM 的行为。使用 `local` 指令时，有两个操作数控制过程代码生成：`prologue`
    和 `epilogue`。这些操作数通常有以下两种形式：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: By default, MASM assumes `prologue:none` and `epilogue:none`. When you specify
    `none` as the `prologue` and `epilogue` values, MASM will not generate any extra
    code to support local variable storage allocation and deallocation in a procedure;
    you will be responsible for supplying the standard entry and exit sequences for
    the procedure.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，MASM 假设 `prologue:none` 和 `epilogue:none`。当你将 `prologue` 和 `epilogue`
    的值设置为 `none` 时，MASM 不会生成任何额外的代码来支持过程中的本地变量存储分配和释放；你将负责为该过程提供标准的入口和退出序列。
- en: If you insert the `option prologue:``PrologueDef` (default prologue generation)
    and `option epilogue:``EpilogueDef` (default epilogue generation) into your source
    file, all following procedures will automatically generate the appropriate standard
    entry and exit sequences for you (assuming local directives are in the procedure).
    MASM will quietly generate the standard entry sequence (the *prologue*) immediately
    after the last local directive (and before the first machine instruction) in a
    procedure, consisting of the usual standard entry sequence instructions
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在源文件中插入 `option prologue:PrologueDef`（默认序言生成）和 `option epilogue:EpilogueDef`（默认尾声生成），所有后续过程将自动为你生成适当的标准入口和退出序列（前提是过程内有本地指令）。MASM
    会在过程的最后一个本地指令之后（在第一个机器指令之前）悄悄生成标准入口序列（*序言*），包括通常的标准入口序列指令。
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: where `local_size` is a constant specifying the number of local variables plus
    a (possible) additional amount to leave the stack aligned on a 16-byte boundary.
    (MASM usually assumes the stack was aligned on a *mod 16 == 8* boundary prior
    to the `push rbp` instruction.)
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `local_size` 是一个常量，指定本地变量的数量，外加一个（可能的）额外量，用于保持栈对齐到16字节边界。（MASM 通常假设栈在 `push
    rbp` 指令之前是对齐到 *mod 16 == 8* 的边界。）
- en: 'For MASM’s automatically generated prologue code to work, the procedure must
    have exactly one entry point. If you define a global statement label as a second
    entry point, MASM won’t know that it is supposed to generate the prologue code
    at that point. Entering the procedure at that second entry point will create problems
    unless you explicitly include the standard entry sequence yourself. Moral of the
    story: procedures should have exactly one entry point.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 MASM 自动生成的序言代码正常工作，过程必须有且只有一个入口点。如果你定义了一个全局语句标签作为第二个入口点，MASM 就不知道在那个位置生成序言代码。除非你明确地自己包含标准入口序列，否则从第二个入口点进入过程会导致问题。这个故事的寓意是：过程应该有且只有一个入口点。
- en: 'Generating the standard exit sequence for the epilogue is a bit more problematic.
    Although it is rare for an assembly language procedure to have more than a single
    *entry* point, it’s common to have multiple *exit* points. After all, the exit
    point is controlled by the programmer’s placement of a `ret` instruction, not
    by a directive (like `endp`). MASM deals with the issue of multiple exit points
    by automatically translating any `ret` instruction it finds into the standard
    exit sequence:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 生成尾声的标准退出序列会更具挑战性。虽然一个汇编语言过程通常只有一个 *入口* 点，但常常有多个 *退出* 点。毕竟，退出点是由程序员通过放置 `ret`
    指令来控制的，而不是通过某个指令（如 `endp`）。MASM 通过自动将找到的任何 `ret` 指令转换为标准退出序列来处理多个退出点的问题。
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Assuming, of course, that `option epilogue:EpilogueDef` is active.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，假设 `option epilogue:EpilogueDef` 处于激活状态。
- en: You can control whether MASM generates prologues (standard entry sequences)
    and epilogues (standard exit sequences) independently of one another. So if you
    would prefer to write the `leave` instruction yourself (while having MASM generate
    the standard entry sequence), you can.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以控制 MASM 是否生成序言（标准入口序列）和尾声（标准退出序列），它们相互独立。因此，如果你希望自己编写 `leave` 指令（同时让 MASM
    生成标准入口序列），是完全可以的。
- en: One final note about the `prologue:` and `epilogue:` options. In addition to
    specifying `prologue:PrologueDef` and `epilogue:EpilogueDef`, you can also supply
    a *macro identifier* after the `prologue:` or `epilogue:` options. If you supply
    a macro identifier, MASM will expand that macro for the standard entry or exit
    sequence. For more information on macros, see “Macros and the MASM Compile-Time
    Language” in Chapter 13.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `prologue:` 和 `epilogue:` 选项的最后一点。在指定 `prologue:PrologueDef` 和 `epilogue:EpilogueDef`
    之外，你还可以在 `prologue:` 或 `epilogue:` 选项后提供一个 *宏标识符*。如果你提供了宏标识符，MASM 会为标准入口或退出序列展开该宏。有关宏的更多信息，请参见第13章中的《宏和MASM编译时语言》。
- en: Most of the example programs throughout the remainder of this book continue
    to use `textequ` declarations for local variables rather than the `local` directive
    to make the use of the `[RBP-constant]` addressing mode and local variable offsets
    more explicit.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本书其余部分中的大多数示例程序继续使用`textequ`声明局部变量，而不是使用`local`指令，以使得`[RBP-constant]`寻址模式和局部变量偏移更加显式。
- en: 5.4.3 Automatic Allocation
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.3 自动分配
- en: 'One big advantage to automatic storage allocation is that it efficiently shares
    a fixed pool of memory among several procedures. For example, say you call three
    procedures in a row, like so:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 自动存储分配的一个大优点是它能高效地在多个过程之间共享固定的内存池。例如，假设你依次调用三个过程，如下所示：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first procedure (`ProcA` in this code) allocates its local variables on
    the stack. Upon return, `ProcA` deallocates that stack storage. Upon entry into
    `ProcB`, the program allocates storage for `ProcB`’s local variables by *using
    the same memory locations just freed by ProcA*. Likewise, when `ProcB` returns
    and the program calls `ProcC`, `ProcC` uses the same stack space for its local
    variables that `ProcB` recently freed up. This memory reuse makes efficient use
    of the system resources and is probably the greatest advantage to using automatic
    variables.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个过程（代码中的`ProcA`）在栈上分配其局部变量。返回时，`ProcA`释放该栈存储。进入`ProcB`时，程序通过*使用刚才由`ProcA`释放的相同内存位置*来分配`ProcB`的局部变量存储。同样，当`ProcB`返回并且程序调用`ProcC`时，`ProcC`使用`ProcB`最近释放的相同栈空间来存储它的局部变量。这种内存重用有效地利用了系统资源，可能是使用自动变量的最大优点。
- en: Now that you’ve seen how assembly language allocates and deallocates storage
    for local variables, it’s easy to understand why automatic variables do not maintain
    their values between two calls to the same procedure. Once the procedure returns
    to its caller, the storage for the automatic variable is lost, and, therefore,
    the value is lost as well. Thus, *you must always assume that a local* `var` *object
    is uninitialized upon entry into a procedure*. If you need to maintain the value
    of a variable between calls to a procedure, you should use one of the static variable
    declaration types.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了汇编语言如何为局部变量分配和释放存储，就容易理解为什么自动变量在两次调用同一过程时不会保持其值。一旦过程返回到其调用者，自动变量的存储就丢失了，因此，值也就丢失了。因此，*你必须始终假设局部`var`对象在进入过程时是未初始化的*。如果你需要在多次调用同一过程时保持变量的值，你应该使用静态变量声明类型。
- en: 5.5 Parameters
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 参数
- en: Although many procedures are totally self-contained, most require input data
    and return data to the caller. *Parameters* are values that you pass to and from
    a procedure. In straight assembly language, passing parameters can be a real chore.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管许多过程是完全自包含的，但大多数过程需要输入数据并将数据返回给调用者。*参数*是你传递给和从过程返回的数据。在纯汇编语言中，传递参数可能是一件真正麻烦的事。
- en: 'The first thing to consider when discussing parameters is how we pass them
    to a procedure. If you are familiar with Pascal or C/C++, you’ve probably seen
    two ways to pass parameters: *pass by value* and *pass by reference*. Anything
    that can be done in an HLL can be done in assembly language (obviously, as HLL
    code compiles into machine code), but you have to provide the instruction sequence
    to access those parameters in an appropriate fashion.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论参数时，首先要考虑的是如何将它们传递给过程。如果你熟悉Pascal或C/C++，你可能见过两种传递参数的方法：*按值传递*和*按引用传递*。在汇编语言中，任何在高级语言（HLL）中能做的事情都能在汇编语言中做（显然，高级语言代码会被编译成机器码），但你必须提供指令序列来以适当的方式访问这些参数。
- en: 'Another concern you will face when dealing with parameters is *where* you pass
    them. There are many places to pass parameters: in registers, on the stack, in
    the code stream, in global variables, or in a combination of these. This chapter
    covers several of the possibilities.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理参数时，另一个你会面临的问题是*在哪里*传递参数。有很多地方可以传递参数：寄存器、栈、代码流、全局变量，或者它们的组合。本章涵盖了几种可能性。
- en: 5.5.1 Pass by Value
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.1 值传递
- en: 'A parameter passed by value is just that—the caller passes a value to the procedure.
    Pass-by-value parameters are input-only parameters. You can pass them to a procedure,
    but the procedure cannot return values through them. Consider this C/C++ function
    call:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 按值传递的参数就是传递一个值——调用者将一个值传递给过程。值传递参数是仅用于输入的参数。你可以将它们传递给过程，但过程不能通过这些参数返回值。考虑以下的C/C++函数调用：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you pass `I` by value, `CallProc()` does not change the value of`I`, regardless
    of what happens to the parameter inside `CallProc()`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按值传递 `I`，无论在 `CallProc()` 内部发生什么，`CallProc()` 都不会改变 `I` 的值。
- en: Because you must pass a copy of the data to the procedure, you should use this
    method only for passing small objects like bytes, words, double words, and quad
    words. Passing large arrays and records by value is inefficient (because you must
    create and pass a copy of the object to the procedure).^([6](#c05-footnote-6))
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你必须将数据的副本传递给过程，所以应该仅将此方法用于传递小对象，如字节、字、双字和四字。按值传递大型数组和记录效率低下（因为你必须创建并传递该对象的副本给过程）。^([6](#c05-footnote-6))
- en: 5.5.2 Pass by Reference
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.2 按引用传递
- en: To pass a parameter by reference, you must pass the address of a variable rather
    than its value. In other words, you must pass a pointer to the data. The procedure
    must dereference this pointer to access the data. Passing parameters by reference
    is useful when you must modify the actual parameter or when you pass large data
    structures between procedures. Because pointers on the x86-64 are 64 bits wide,
    a parameter that you pass by reference will consist of a quad-word value.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要按引用传递参数，你必须传递变量的地址，而不是它的值。换句话说，你必须传递数据的指针。过程必须取消引用该指针以访问数据。按引用传递参数在需要修改实际参数或在过程之间传递大型数据结构时非常有用。由于
    x86-64 中的指针宽度为 64 位，按引用传递的参数将是一个四字（quad-word）值。
- en: 'You can compute the address of an object in memory in two common ways: the
    `offset` operator or the `lea` instruction. You can use the `offset` operator
    to take the address of any static variable you’ve declared in your `.data`, `.data?`,
    `.const`, or `.code` sections. [Listing 5-8](#listing5-8) demonstrates how to
    obtain the address of a static variable (`staticVar`) and pass that address to
    a procedure (`someFunc`) in the RCX register.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种常见方式计算内存中对象的地址：`offset` 操作符或 `lea` 指令。你可以使用 `offset` 操作符获取你在 `.data`、`.data?`、`.const`
    或 `.code` 段中声明的任何静态变量的地址。[清单 5-8](#listing5-8) 演示了如何获取静态变量（`staticVar`）的地址，并将该地址传递给过程（`someFunc`），地址保存在
    RCX 寄存器中。
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 5-8: Using the `offset` operator to obtain the address of a static
    variable'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-8：使用 `offset` 操作符获取静态变量的地址
- en: 'Using the `offset` operator raises a couple of issues. First of all, it can
    compute the address of only a static variable; you cannot obtain the address of
    an automatic (local) variable or parameter, nor can you compute the address of
    a memory reference involving a complex memory addressing mode (for example, `[RBX+RDX*1-5]`).
    Another problem is that an instruction like `mov rcx, offset staticVar` assembles
    into a large number of bytes (because the `offset` operator returns a 64-bit constant).
    If you look at the assembly listing MASM produces (with the `/Fl` command line
    option), you can see how big this instruction is:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `offset` 操作符会引发一些问题。首先，它只能计算静态变量的地址；你无法获取自动（局部）变量或参数的地址，也不能计算涉及复杂内存寻址模式的内存引用的地址（例如，`[RBX+RDX*1-5]`）。另一个问题是，像
    `mov rcx, offset staticVar` 这样的指令会生成大量字节（因为 `offset` 操作符返回的是 64 位常量）。如果你查看 MASM
    生成的汇编列表（使用 `/Fl` 命令行选项），你可以看到这条指令有多大：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see here, the `mov` instruction is 10 (0Ah) bytes long.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里看到的，`mov` 指令的长度是 10（0Ah）字节。
- en: 'You’ve seen numerous examples of the second way to obtain the address of a
    variable: the `lea` instruction (for example, when loading the address of a format
    string into RCX prior to calling `printf()`). [Listing 5-9](#listing5-9) shows
    the example in [Listing 5-8](#listing5-8) recoded to use the `lea` instruction.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看过多次获取变量地址的第二种方法：`lea` 指令（例如，在调用 `printf()` 之前，将格式化字符串的地址加载到 RCX 中）。[清单 5-9](#listing5-9)
    展示了将 [清单 5-8](#listing5-8) 中的例子重写为使用 `lea` 指令的版本。
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 5-9: Obtaining the address of a variable using the `lea` instruction'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-9：使用 `lea` 指令获取变量的地址
- en: 'Looking at the listing MASM produces for this code, we find that the `lea`
    instruction is only 7 bytes long:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 MASM 为这段代码生成的列表，我们发现 `lea` 指令的长度只有 7 字节。
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So, if nothing else, your programs will be shorter if you use the `lea` instruction
    rather than the `offset` operator.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果没有其他原因，使用 `lea` 指令而不是 `offset` 操作符会让你的程序更简短。
- en: 'Another advantage to using `lea` is that it will accept any memory addressing
    mode, not just the name of a static variable. For example, if `staticVar` were
    an array of 32-bit integers, you could load the current element address, indexed
    by the RDX register, in RCX by using an instruction such as this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `lea` 的另一个优点是它接受任何内存寻址模式，而不仅仅是静态变量的名称。例如，如果 `staticVar` 是一个 32 位整数数组，你可以通过使用类似这样的指令，将当前元素地址（由
    RDX 寄存器索引）加载到 RCX 中：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Pass by reference is usually less efficient than pass by value. You must dereference
    all pass-by-reference parameters on each access; this is slower than simply using
    a value because it typically requires at least two instructions. However, when
    passing a large data structure, pass by reference is faster because you do not
    have to copy the large data structure before calling the procedure. Of course,
    you’d probably need to access elements of that large data structure (for example,
    an array) by using a pointer, so little efficiency is lost when you pass large
    arrays by reference.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用传递通常比按值传递效率低。你必须在每次访问时解引用所有按引用传递的参数；这比直接使用值要慢，因为通常需要至少两条指令。然而，在传递大型数据结构时，通过引用传递更快，因为你不需要在调用过程之前复制整个大型数据结构。当然，你可能需要通过指针访问该大型数据结构的元素（例如，数组），所以传递大型数组时，效率损失非常小。
- en: 5.5.3 Low-Level Parameter Implementation
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.3 低级参数实现
- en: A parameter-passing mechanism is a contract between the caller and the callee
    (the procedure). Both parties have to agree on where the parameter data will appear
    and what form it will take (for example, value or address). If your assembly language
    procedures are being called only by other assembly language code that you’ve written,
    you control both sides of the contract negotiation and get to decide where and
    how you’re going to pass parameters.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 参数传递机制是调用者和被调用者（过程）之间的契约。双方必须就参数数据的出现位置和形式（例如，值或地址）达成一致。如果你的汇编语言过程只被你编写的其他汇编语言代码调用，那么你可以控制契约的双方，并决定如何以及在哪里传递参数。
- en: However, if external code is calling your procedure, or your procedure is calling
    external code, your procedure will have to adhere to whatever *calling convention*
    that external code uses. On 64-bit Windows systems, that calling convention will,
    undoubtedly, be the Windows ABI.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果外部代码调用了你的过程，或者你的过程调用了外部代码，那么你的过程必须遵循外部代码使用的*调用约定*。在 64 位 Windows 系统上，该调用约定无疑是
    Windows ABI。
- en: Before discussing the Windows calling conventions, we’ll consider the situation
    of calling code that you’ve written (and, therefore, have complete control over
    the calling conventions). The following sections provide insight into the various
    ways you can pass parameters in pure assembly language code (without the overhead
    associated with the Microsoft ABI).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论 Windows 调用约定之前，我们将考虑你编写的代码的调用情况（因此，你完全控制调用约定）。接下来的章节将深入介绍在纯汇编语言代码中传递参数的各种方式（不涉及与
    Microsoft ABI 相关的开销）。
- en: 5.5.3.1 Passing Parameters in Registers
  id: totrans-196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.3.1 在寄存器中传递参数
- en: Having touched on *how* to pass parameters to a procedure, the next thing to
    discuss is *where* to pass parameters. This depends on the size and number of
    those parameters. If you are passing a small number of parameters to a procedure,
    the registers are an excellent place to pass them. If you are passing a single
    parameter to a procedure, you should use the registers listed in [Table 5-1](#table5-1)
    for the accompanying data types.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了*如何*将参数传递给过程之后，接下来要讨论的是*在哪里*传递参数。这取决于这些参数的大小和数量。如果你传递的是少量参数，寄存器是传递它们的理想位置。如果你只传递一个参数，你应该使用[表
    5-1](#table5-1)中列出的寄存器，匹配相应的数据类型。
- en: 'Table 5-1: Parameter Location by Size'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-1：按大小划分的参数位置
- en: '| **Data size** | **Pass in this register** |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| **数据大小** | **在此寄存器中传递** |'
- en: '| --- | --- |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Byte | CL |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 字节 | CL |'
- en: '| Word | CX |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 字 | CX |'
- en: '| Double word | ECX |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| 双字 | ECX |'
- en: '| Quad word | RCX |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 四字 | RCX |'
- en: This is not a hard-and-fast rule. However, these registers are convenient because
    they mesh with the first parameter register in the Microsoft ABI (which is where
    most people will pass a single parameter).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一条严格的规则。然而，这些寄存器非常方便，因为它们与 Microsoft ABI 中的第一个参数寄存器相匹配（大多数人会在此寄存器中传递一个参数）。
- en: 'If you are passing several parameters to a procedure in the x86-64’s registers,
    you should probably use up the registers in the following order:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 x86-64 寄存器中传递多个参数到一个过程，你应该按以下顺序使用寄存器：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In general, you should pass integer and other non-floating-point values in the
    general-purpose registers, and floating-point values in the XMM*x*/YMM*x* registers.
    This is not a hard requirement, but Microsoft reserves these registers for passing
    parameters and for local variables (*volatile*), so using these registers to pass
    parameters won’t mess with Microsoft ABI nonvolatile registers. Of course, if
    you intend to have Microsoft ABI–compliant code call your procedure, you must
    exactly observe the Microsoft calling conventions (see “Calling Conventions and
    the Microsoft ABI” on page 261).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你应该通过通用寄存器传递整数和其他非浮动值，通过 XMM*x*/YMM*x* 寄存器传递浮动值。这不是一个强制要求，但微软为传递参数和局部变量（*volatile*）保留这些寄存器，因此使用这些寄存器传递参数不会干扰微软
    ABI 的非易失性寄存器。当然，如果你打算让符合微软 ABI 的代码调用你的过程，你必须严格遵守微软调用约定（参见第 261 页“调用约定和微软 ABI”）。
- en: Of course, if you’re writing pure assembly language code (no calls to or from
    any code you didn’t write), you can use most of the general-purpose registers
    as you see fit (RSP is an exception, and you should avoid RBP, but the others
    are fair game). Ditto for the XMM/YMM registers.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你在编写纯汇编语言代码（没有调用任何你没写的代码），你可以根据需要使用大多数通用寄存器（RSP 是例外，应该避免使用 RBP，但其他寄存器都可以使用）。XMM/YMM
    寄存器也是如此。
- en: As an example, consider the `strfill(s,c)` procedure that copies the character
    `c` (passed by value in AL) to each character position in `s` (passed by reference
    in RDI) up to a zero-terminating byte ([Listing 5-10](#listing5-10)).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，考虑 `strfill(s,c)` 过程，它将字符 `c`（通过 AL 传值）复制到 `s`（通过 RDI 传引用）中的每个字符位置，直到遇到零终止字节（[Listing
    5-10](#listing5-10)）。
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Listing 5-10: Passing parameters in registers to the `strfill` procedure'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 5-10：通过寄存器传递参数给 `strfill` 过程
- en: 'To call the `strfill` procedure, you would load the address of the string data
    into RDI and the character value into AL prior to the call. The following code
    fragment demonstrates a typical call to `strfill`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用 `strfill` 过程，你需要在调用之前将字符串数据的地址加载到 RDI 中，将字符值加载到 AL 中。以下代码片段演示了典型的 `strfill`
    调用：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This code passes the string by reference and the character data by value.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码通过引用传递字符串，通过值传递字符数据。
- en: 5.5.3.2 Passing Parameters in the Code Stream
  id: totrans-216
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.3.2 代码流中传递参数
- en: 'Another place where you can pass parameters is in the code stream immediately
    after the `call` instruction. Consider the following `print` routine that prints
    a literal string constant to the standard output device:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以传递参数的地方是在 `call` 指令之后的代码流中。考虑以下 `print` 例程，它将一个字面常量字符串打印到标准输出设备：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Normally, a subroutine returns control to the first instruction immediately
    following the `call` instruction. Were that to happen here, the x86-64 would attempt
    to interpret the ASCII codes for `"This..."` as an instruction. This would produce
    undesirable results. Fortunately, you can skip over this string before returning
    from the subroutine.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，子程序会将控制权返回到紧接着 `call` 指令后的第一条指令。如果在这里发生这种情况，x86-64 会试图将 `"This..."` 的 ASCII
    码解释为一条指令。这将产生不期望的结果。幸运的是，在从子程序返回之前，你可以跳过这个字符串。
- en: So how do you gain access to these parameters? Easy. The return address on the
    stack points at them. Consider the implementation of `print` appearing in [Listing
    5-11](#listing5-11).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你如何访问这些参数呢？很简单。栈上的返回地址指向它们。考虑 [Listing 5-11](#listing5-11) 中的 `print` 实现。
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Listing 5-11: Print procedure implementation (using code stream parameters)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 5-11：打印过程实现（使用代码流参数）
- en: One quick note about a machine idiom in [Listing 5-11](#listing5-11). The instruction
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 [Listing 5-11](#listing5-11) 中的机器习惯用法，有一个快速说明。指令
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: isn’t actually loading an address into R8, per se. This is really an arithmetic
    instruction that is computing R8 = RDX – 1 (with a single instruction rather than
    two as would normally be required). This is a common usage of the `lea` instruction
    in assembly language programs. Therefore, it’s a little programming trick that
    you should become comfortable with.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上并不是将一个地址加载到 R8 中。实际上，这是一个算术指令，它计算 R8 = RDX – 1（通过一个指令，而不是通常需要的两条指令）。这是汇编语言程序中`lea`指令的常见用法。因此，这是一个你应该熟悉的小编程技巧。
- en: 'Besides showing how to pass parameters in the code stream, the `print` routine
    also exhibits another concept: *variable-length parameters*. The string following
    the `call` can be any practical length. The zero-terminating byte marks the end
    of the parameter list.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 除了展示如何在代码流中传递参数外，`print`例程还展示了另一个概念：*可变长度参数*。`call`后面的字符串可以是任何实际长度。以零终止的字节标记参数列表的结束。
- en: 'We have two easy ways to handle variable-length parameters: either use a special
    terminating value (like 0) or pass a special length value that tells the subroutine
    the number of parameters you are passing. Both methods have their advantages and
    disadvantages.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种简单的方法来处理可变长度参数：要么使用特殊的终止值（如0），要么传递一个特殊的长度值，告诉子程序你正在传递多少个参数。两种方法各有优缺点。
- en: Using a special value to terminate a parameter list requires that you choose
    a value that never appears in the list. For example, `print` uses 0 as the terminating
    value, so it cannot print the NUL character (whose ASCII code is 0). Sometimes
    this isn’t a limitation. Specifying a length parameter is another mechanism you
    can use to pass a variable-length parameter list. While this doesn’t require any
    special codes, or limit the range of possible values that can be passed to a subroutine,
    setting up the length parameter and maintaining the resulting code can be a real
    nightmare.^([8](#c05-footnote-8))
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特殊值终止参数列表要求选择一个在列表中永远不会出现的值。例如，`print`使用0作为终止值，因此它无法打印NUL字符（其ASCII码是0）。有时候，这并不是一个限制。指定长度参数是另一种可以用来传递可变长度参数列表的机制。虽然这种方式不需要任何特殊的代码，也不限制可以传递给子程序的值的范围，但设置长度参数并维护结果代码可能会变得非常麻烦。^([8](#c05-footnote-8))
- en: Despite the convenience afforded by passing parameters in the code stream, passing
    parameters there has disadvantages. First, if you fail to provide the exact number
    of parameters the procedure requires, the subroutine will get confused. Consider
    the `print` example. It prints a string of characters up to a zero-terminating
    byte and then returns control to the first instruction following that byte. If
    you leave off the zero-terminating byte, the `print` routine happily prints the
    following opcode bytes as ASCII characters until it finds a zero byte. Because
    zero bytes often appear in the middle of an instruction, the `print` routine might
    return control into the middle of another instruction, which will probably crash
    the machine.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在代码流中传递参数具有便利性，但这种方法也有缺点。首先，如果你没有提供子程序所需的准确数量的参数，子程序会感到困惑。以`print`为例，它会打印一串字符直到遇到零终止字节，然后将控制权交还给该字节后的第一条指令。如果你没有提供零终止字节，`print`例程会愉快地将随后的操作码字节当作ASCII字符打印，直到遇到一个零字节。因为零字节经常出现在指令的中间，`print`例程可能会将控制权交给另一条指令的中间部分，这很可能会导致机器崩溃。
- en: Inserting an extra 0, which occurs more often than you might think, is another
    problem programmers have with the `print` routine. In such a case, the `print`
    routine would return upon encountering the first zero byte and attempt to execute
    the following ASCII characters as machine code. Problems notwithstanding, however,
    the code stream is an efficient place to pass parameters whose values do not change.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 插入额外的0是程序员在使用`print`例程时遇到的另一个问题，这种情况比你想象的更为常见。在这种情况下，`print`例程会在遇到第一个零字节时返回，并尝试将随后的ASCII字符作为机器码执行。尽管存在问题，但代码流仍然是一个高效的传递参数的地方，尤其是当这些参数的值不发生变化时。
- en: 5.5.3.3 Passing Parameters on the Stack
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.3.3 在栈上传递参数
- en: Most high-level languages use the stack to pass a large number of parameters
    because this method is fairly efficient. Although passing parameters on the stack
    is slightly less efficient than passing parameters in registers, the register
    set is limited (especially if you’re limiting yourself to the four registers the
    Microsoft ABI sets aside for this purpose), and you can pass only a few value
    or reference parameters through registers. The stack, on the other hand, allows
    you to pass a large amount of parameter data without difficulty. This is the reason
    that most programs pass their parameters on the stack (at least, when passing
    more than about three to six parameters).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数高级语言使用栈来传递大量参数，因为这种方法相对高效。尽管在栈上传递参数的效率略低于在寄存器中传递参数，但寄存器集是有限的（特别是如果你只使用微软ABI为此目的保留的四个寄存器），你只能通过寄存器传递少量的值或引用参数。另一方面，栈允许你轻松传递大量的参数数据。这就是大多数程序将参数传递在栈上的原因（至少，当传递超过大约三个到六个参数时）。
- en: 'To manually pass parameters on the stack, push them immediately before calling
    the subroutine. The subroutine then reads this data from the stack memory and
    operates on it appropriately. Consider the following high-level language function
    call:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动将参数传递到栈上，在调用子程序之前立即推送它们。子程序随后从栈内存中读取这些数据，并适当地处理它们。考虑以下高级语言函数调用：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Back in the days of 32-bit assembly language, you could have passed these parameters
    to `CallProc` by using an instruction sequence such as the following:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在32位汇编语言的时代，你可以使用以下指令序列将这些参数传递给`CallProc`：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Unfortunately, with the advent of the x86-64 64-bit CPU, the 32-bit push instruction
    was removed from the instruction set (the 64-bit `push` instruction replaced it).
    If you want to pass parameters to a procedure by using the `push` instruction,
    they must be 64-bit operands.^([9](#c05-footnote-9))
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，随着x86-64 64位CPU的出现，32位`push`指令从指令集中移除了（64位`push`指令替代了它）。如果你想通过使用`push`指令将参数传递给过程，它们必须是64位操作数。^([9](#c05-footnote-9))
- en: Because keeping RSP aligned on an appropriate boundary (8 or 16 bytes) is crucial,
    the Microsoft ABI simply requires that every parameter consume 8 bytes on the
    stack, and thus doesn’t allow larger arguments on the stack. If you’re controlling
    both sides of the parameter contract (caller and callee), you can pass larger
    arguments to your procedures. However, it is a good idea to ensure that all parameter
    sizes are a multiple of 8 bytes.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因为保持RSP在适当的边界（8字节或16字节）对齐至关重要，微软的ABI要求每个参数在栈上占用8字节，因此不允许更大的参数出现在栈上。如果你控制着参数契约的双方（调用者和被调用者），你可以将更大的参数传递给你的过程。然而，确保所有参数的大小都是8字节的倍数是一个好主意。
- en: One simple solution is to make all your variables `qword` objects. Then you
    can directly push them onto the stack by using the `push` instruction prior to
    calling a procedure. However, not all objects fit nicely into 64 bits (characters,
    for example). Even those objects that could be 64 bits (for example, integers)
    often don’t require the use of so much storage.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的解决方案是使所有变量成为`qword`对象。然后，你可以在调用过程之前直接使用`push`指令将它们推送到栈上。然而，并不是所有对象都能完美地适应64位（例如字符）。即使是那些本可以是64位的对象（例如整数），通常也不需要使用那么多存储空间。
- en: 'One sneaky way to use the `push` instruction on smaller objects is to use type
    coercion. Consider the following calling sequence for `CallProc`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`push`指令处理较小对象的一种巧妙方法是使用类型强制转换。考虑以下`CallProc`的调用序列：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This sequence pushes the 64-bit values starting at the addresses associated
    with variables `i`, `j`, and `k`, regardless of the size of these variables. If
    the `i`, `j`, and `k` variables are smaller objects (perhaps 32-bit integers),
    these `push` instructions will push their values onto the stack along with additional
    data beyond these variables. As long as `CallProc` treats these parameter values
    as their actual size (say, 32 bits) and ignores the HO bits pushed for each argument
    onto the stack, this will usually work out properly.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 该序列将从与变量`i`、`j`和`k`关联的地址开始，推送64位的值，无论这些变量的大小如何。如果`i`、`j`和`k`是较小的对象（比如32位整数），这些`push`指令将把它们的值连同超出这些变量的数据一起推送到栈上。只要`CallProc`将这些参数值视为其实际大小（例如，32位），并忽略为每个参数推送到栈上的高位数据，这通常是可行的。
- en: 'Pushing extra data beyond the bounds of the variable onto the stack creates
    one possible problem. If the variable is at the very end of a page in memory and
    the following page is not readable, then pushing data beyond the variable may
    attempt to push data from that next memory page, resulting in a memory access
    violation (which will crash your program). Therefore, if you use this technique,
    you must ensure that such variables do not appear at the very end of a memory
    page (with the possibility that the next page in memory is inaccessible). The
    easiest way to do this is to make sure the variables you push on the stack in
    this fashion are never the last variables you declare in your data sections; for
    example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 将超出变量边界的额外数据推送到栈上可能会带来一个问题。如果变量正好位于内存页的末尾，并且下一页不可读，那么推送超出变量的数据可能会尝试从下一内存页推送数据，从而导致内存访问违规（这将崩溃你的程序）。因此，如果你使用这种技术，必须确保这些变量不出现在内存页的末尾（以免下一页不可访问）。最简单的做法是确保你在数据段中声明的最后一个变量不是你在栈上推送的变量。例如：
- en: '[PRE47]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: While pushing extra data beyond a variable will work, it’s still a questionable
    programming practice. A better technique is to abandon the `push` instructions
    altogether and use a different technique to move the parameter data onto the stack.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管将额外数据推入一个变量是可行的，但这仍然是一种值得怀疑的编程实践。更好的技巧是完全放弃`push`指令，改用另一种方法将参数数据推送到栈上。
- en: 'Another way to “push” data onto the stack is to drop the RSP register down
    an appropriate amount in memory and then simply move data onto the stack by using
    a `mov` (or similar) instruction. Consider the following calling sequence for
    `CallProc`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种将数据“推送”到栈上的方法是将RSP寄存器下移到适当的内存位置，然后通过使用`mov`（或类似的）指令将数据直接移入栈中。考虑以下`CallProc`的调用序列：
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Although this takes twice as many instructions as the previous examples (eight
    versus four), this sequence is safe (no possibility of accessing inaccessible
    memory pages). Furthermore, it pushes exactly the amount of data needed for the
    parameters onto the stack (32 bits for each object, for a total of 12 bytes).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这比前面的示例需要两倍的指令（八条对比四条），但此序列是安全的（没有访问不可访问内存页的可能）。此外，它将准确地将参数所需的数据量推送到栈上（每个对象32位，总共12字节）。
- en: 'The major problem with this approach is that it is a really bad idea to have
    an address in the RSP register that is not aligned on an 8-byte boundary. In the
    worst case, having a nonaligned (to 8 bytes) stack will crash your program; in
    the very best case, it will affect the performance of your program. So even if
    you want to pass the parameters as 32-bit integers, you should always allocate
    a multiple of 8 bytes for parameters on the stack prior to a call. The previous
    example would be encoded as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要问题是，将一个不对齐到8字节边界的地址放入RSP寄存器是一个非常糟糕的主意。在最坏的情况下，栈如果没有按8字节对齐会崩溃程序；在最好的情况下，它会影响程序的性能。因此，即使你希望将参数作为32位整数传递，也应该在调用之前始终为栈上的参数分配8字节的倍数。前面的示例可以编码为如下：
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note that `CallProc` will simply ignore the extra 4 bytes allocated on the stack
    in this fashion (don’t forget to remove this extra storage from the stack on return).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`CallProc`将简单地忽略以这种方式分配到栈上的额外4个字节（别忘了在返回时从栈上移除这些额外的存储）。
- en: 'To satisfy the requirement of the Microsoft ABI (and, in fact, of most application
    binary interfaces for the x86-64 CPUs) that each parameter consume exactly 8 bytes
    (even if their native data size is smaller), you can use the following code (same
    number of instructions, just uses a little more stack space):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足Microsoft ABI的要求（事实上，几乎所有x86-64 CPU的应用程序二进制接口都要求）每个参数精确消耗8字节（即使它们的原生数据大小更小），你可以使用以下代码（指令数量相同，只是多了一些栈空间）：
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `mov` instructions spread out the data on 8-byte boundaries. The HO dword
    of each 64-bit entry on the stack will contain garbage (whatever data was in stack
    memory prior to this sequence). That’s okay; the `CallProc` procedure (presumably)
    will ignore that extra data and operate only on the LO 32 bits of each parameter
    value.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '`mov`指令将数据按8字节边界展开。栈上每个64位项的高位双字（HO dword）将包含垃圾数据（即栈内存中在此序列之前的数据）。这没关系；`CallProc`过程（假设）将忽略这些额外数据，仅对每个参数值的低32位（LO
    32 bits）进行操作。'
- en: Upon entry into `CallProc`, using this sequence, the x86-64’s stack looks like
    [Figure 5-7](#figure5-7).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 进入`CallProc`时，使用此序列，x86-64的栈将如[图5-7](#figure5-7)所示。
- en: '![f05007](image_fi/501089c05/f05007.png)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![f05007](image_fi/501089c05/f05007.png)'
- en: 'Figure 5-7: Stack layout upon entry into `CallProc`'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-7：进入`CallProc`时的栈布局
- en: 'If your procedure includes the standard entry and exit sequences, you may directly
    access the parameter values in the activation record by indexing off the RBP register.
    Consider the layout of the activation record for `CallProc` that uses the following
    declaration:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的过程包括标准的入口和退出序列，你可以通过从RBP寄存器索引直接访问激活记录中的参数值。考虑以下使用声明的`CallProc`的激活记录布局：
- en: '[PRE51]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Assuming you’ve pushed three quad-word parameters onto the stack, it should
    look something like [Figure 5-8](#figure5-8) immediately after the execution of
    `mov rbp, rsp` in `CallProc`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经将三个四字参数推送到栈上，它在执行`CallProc`中的`mov rbp, rsp`之后应该看起来像[图5-8](#figure5-8)。
- en: 'Now you can access the parameters by indexing off the RBP register:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以通过从RBP寄存器索引来访问参数：
- en: '[PRE52]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![f05008](image_fi/501089c05/f05008.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![f05008](image_fi/501089c05/f05008.png)'
- en: 'Figure 5-8: Activation record for `CallProc` after standard entry sequence
    execution'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-8：`CallProc`激活记录在标准入口序列执行后的状态
- en: 5.5.3.4 Accessing Value Parameters on the Stack
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.5.3.4 访问堆栈上的值参数
- en: Accessing parameters passed by value is no different from accessing a local
    variable object. One way to accomplish this is by using equates, as was demonstrated
    for local variables earlier. [Listing 5-12](#listing5-12) provides an example
    program whose procedure accesses a parameter that the main program passes to it
    by value.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 访问按值传递的参数与访问局部变量对象没有什么不同。实现这一点的一种方法是使用等式，正如前面为局部变量所演示的那样。[示例 5-12](#listing5-12)提供了一个示例程序，其中的过程访问了由主程序按值传递给它的参数。
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Listing 5-12: Demonstration of value parameters'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-12：值参数的演示
- en: Although you could access the value of `theParm` by using the anonymous address
    `[RBP+16]` within your code, using the equate in this fashion makes your code
    more readable and maintainable.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以通过在代码中使用匿名地址`[RBP+16]`来访问`theParm`的值，但以这种方式使用等式会使你的代码更具可读性和可维护性。
- en: 5.5.4 Declaring Parameters with the proc Directive
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.4 使用`proc`指令声明参数
- en: 'MASM provides another solution for declaring parameters for procedures using
    the `proc` directive. You can supply a list of parameters as operands to the `proc`
    directive, as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: MASM为使用`proc`指令声明过程的参数提供了另一种解决方案。你可以将参数列表作为操作数传递给`proc`指令，如下所示：
- en: '[PRE54]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: where `parameter_list` is a list of one or more parameter declarations separated
    by commas. Each parameter declaration takes the form
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`parameter_list`是由逗号分隔的一个或多个参数声明的列表。每个参数声明的形式为
- en: '[PRE55]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'where `parm_name` is a valid MASM identifier, and `type` is one of the usual
    MASM types (`proc`, `byte`, `word`, `dword`, and so forth). With one exception,
    the parameter list declarations are identical to the local directive’s operands:
    the exception is that MASM doesn’t allow arrays as parameters. (MASM parameters
    assume that the Microsoft ABI is being used, and the Microsoft ABI allows only
    64-bit parameters.)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`parm_name`是一个有效的MASM标识符，`type`是常见的MASM类型之一（`proc`，`byte`，`word`，`dword`等）。有一个例外，参数列表声明与局部指令的操作数相同：唯一的例外是MASM不允许将数组作为参数。（MASM参数假设使用的是Microsoft
    ABI，而Microsoft ABI只允许64位参数。）
- en: 'The parameter declarations appearing as `proc` operands assume that a standard
    entry sequence is executed and that the program will access parameters off the
    RBP register, with the saved RBP and return address values at offsets 0 and 8
    from the RBP register (so the first parameter will start at offset 16). MASM assigns
    offsets for each parameter that are 8 bytes apart (per the Microsoft ABI). As
    an example, consider the following parameter declaration:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`proc`操作数出现的参数声明假设执行了标准的入口序列，并且程序将从RBP寄存器访问参数，保存的RBP和返回地址值位于RBP寄存器的偏移量0和8（因此第一个参数从偏移量16开始）。MASM为每个参数分配8字节的偏移量（根据Microsoft
    ABI）。举个例子，考虑以下参数声明：
- en: '[PRE56]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`k` will have the offset `[RBP+16]`, `j` will have the offset `[RBP+24]`, and
    `i` will have the offset `[RBP+32]`. Again, the offsets are always 8 bytes, regardless
    of the parameter data type.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`k`的偏移量为`[RBP+16]`，`j`的偏移量为`[RBP+24]`，`i`的偏移量为`[RBP+32]`。再说一遍，这些偏移量始终是8字节，不论参数的数据类型是什么。'
- en: As per the Microsoft ABI, MASM will allocate storage on the stack for the first
    four parameters, even though you would normally pass these parameters in RCX,
    RDX, R8, and R9\. These 32 bytes of storage (starting at `RBP+16`) are called
    *shadow storage* in Microsoft ABI nomenclature. Upon entry into the procedure,
    the parameter values do not appear in this shadow storage (instead, the values
    are in the registers). The procedure can save the register values in this preallocated
    storage, or it can use the shadow storage for any purpose it desires (such as
    for additional local variable storage). However, if the procedure refers to the
    parameter names declared in the `proc` operand field, expecting to access the
    parameter data, the procedure should store the values from these registers into
    that shadow storage (assuming the parameters were passed in the RCX, RDX, R8,
    and R9 registers). Of course, if you push these arguments on the stack prior to
    the call (in assembly language, ignoring the Microsoft ABI calling convention),
    then the data is already in place, and you don’t have to worry about shadow storage
    issues.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Microsoft ABI，MASM会在栈上为前四个参数分配存储空间，尽管你通常会将这些参数传递给RCX、RDX、R8和R9寄存器。这32字节的存储空间（从`RBP+16`开始）在Microsoft
    ABI术语中被称为*影子存储*。进入过程时，参数值不会出现在这个影子存储中（而是存储在寄存器中）。该过程可以将寄存器值保存在这个预分配的存储空间中，或者可以将影子存储用于任何它想要的目的（例如额外的局部变量存储）。然而，如果过程引用在`proc`操作数字段中声明的参数名，并期望访问参数数据，过程应该将这些寄存器中的值存储到该影子存储中（假设这些参数是通过RCX、RDX、R8和R9寄存器传递的）。当然，如果你在调用之前将这些参数压入栈中（在汇编语言中，忽略Microsoft
    ABI调用约定），那么数据已经就位，你就不需要担心影子存储的问题。
- en: 'When calling a procedure whose parameters you declare in the operand field
    of a `proc` directive, don’t forget that MASM assumes you push the parameters
    onto the stack in the reverse order they appear in the parameter list, to ensure
    that the first parameter in the list is at the lowest memory address on the stack.
    For example, if you call the `procWithParms` procedure from the previous code
    snippet, you’d typically use code like the following to push the parameters:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用一个在`proc`指令的操作数字段中声明了参数的过程时，别忘了MASM假定你按照参数列表中出现的反向顺序将参数压入栈中，以确保列表中的第一个参数位于栈上的最低内存地址。例如，如果你从前面的代码片段调用`procWithParms`过程，你通常会使用以下代码将参数压栈：
- en: '[PRE57]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Another possible solution (a few bytes longer, but often faster) is to use
    the following code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能的解决方案（虽然稍微多占几个字节，但通常更快）是使用以下代码：
- en: '[PRE58]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Don’t forget that if it is the callee’s responsibility to clean up the stack,
    you’d probably use an `add rsp, 24` instruction after the preceding two sequences
    to remove the parameters from the stack. Of course, you can also have the procedure
    itself clean up the stack by specifying the number to add to RSP as a `ret` instruction
    operand, as explained earlier in this chapter.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 别忘了，如果清理栈是被调用方的责任，那么你可能会在前两条指令后使用`add rsp, 24`指令来从栈中移除参数。当然，你也可以让过程本身通过将要加到RSP的数字指定为`ret`指令的操作数来清理栈，就像本章前面解释的那样。
- en: 5.5.5 Accessing Reference Parameters on the Stack
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5.5 访问栈上的引用参数
- en: Because you pass the addresses of objects as reference parameters, accessing
    the reference parameters within a procedure is slightly more difficult than accessing
    value parameters because you have to dereference the pointers to the reference
    parameters.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你将对象的地址作为引用参数传递，所以在过程内访问引用参数比访问值参数稍微复杂一些，因为你必须解引用指向引用参数的指针。
- en: In [Listing 5-13](#listing5-13), the `RefParm` procedure has a single pass-by-reference
    parameter. A pass-by-reference parameter is always a (64-bit) pointer to an object.
    To access the value associated with the parameter, this code has to load that
    quad-word address into a 64-bit register and access the data indirectly. The `mov
    rax, theParm` instruction in [Listing 5-13](#listing5-13) fetches this pointer
    into the RAX register, and then the procedure `RefParm` uses the `[RAX]` addressing
    mode to access the actual value of `theParm`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 5-13](#listing5-13)中，`RefParm`过程有一个按引用传递的单一参数。按引用传递的参数总是指向对象的（64位）指针。为了访问与该参数相关的值，这段代码必须将该四字地址加载到一个64位寄存器中，并间接地访问数据。[示例
    5-13](#listing5-13)中的`mov rax, theParm`指令将这个指针加载到RAX寄存器中，然后过程`RefParm`使用`[RAX]`寻址模式来访问`theParm`的实际值。
- en: '[PRE59]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Listing 5-13: Accessing a reference parameter'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-13：访问引用参数
- en: 'Here are the build commands and program output for [Listing 5-13](#listing5-13):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是[示例 5-13](#listing5-13)的构建命令和程序输出：
- en: '[PRE60]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can see, accessing (small) pass-by-reference parameters is a little less
    efficient than accessing value parameters because you need an extra instruction
    to load the address into a 64-bit pointer register (not to mention you have to
    reserve a 64-bit register for this purpose). If you access reference parameters
    frequently, these extra instructions can really begin to add up, reducing the
    efficiency of your program. Furthermore, it’s easy to forget to dereference a
    reference parameter and use the address of the value in your calculations. Therefore,
    unless you really need to affect the value of the actual parameter, you should
    use pass by value to pass small objects to a procedure.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，访问（小的）按引用传递的参数比访问值参数稍微低效一些，因为你需要额外的指令将地址加载到 64 位指针寄存器中（更不用说你还需要为此目的保留一个
    64 位寄存器）。如果你频繁访问引用参数，这些额外的指令会开始累积，降低程序的效率。此外，很容易忘记取消引用一个引用参数并在计算中使用该值的地址。因此，除非你真的需要影响实际参数的值，否则应该使用按值传递来传递小的对象到过程。
- en: Passing large objects, like arrays and records, is where using reference parameters
    becomes efficient. When passing these objects by value, the calling code has to
    make a copy of the actual parameter; if it is a large object, the copy process
    can be inefficient. Because computing the address of a large object is just as
    efficient as computing the address of a small scalar object, no efficiency is
    lost when passing large objects by reference. Within the procedure, you must still
    dereference the pointer to access the object, but the efficiency loss due to indirection
    is minimal when you contrast this with the cost of copying that large object.
    The program in [Listing 5-14](#listing5-14) demonstrates how to use pass by reference
    to initialize an array of records.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 传递大对象，如数组和记录，是使用引用参数变得高效的地方。当按值传递这些对象时，调用代码必须复制实际参数；如果它是一个大对象，复制过程可能效率低下。由于计算大对象的地址和计算小标量对象的地址一样高效，按引用传递大对象时不会损失效率。在过程内部，你仍然需要取消引用指针来访问对象，但由于间接访问的效率损失与复制大对象的成本相比是最小的。
    [示例 5-14](#listing5-14)中的程序演示了如何使用按引用传递来初始化一个记录数组。
- en: '[PRE61]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Listing 5-14: Passing an array of records by referencing'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 5-14：通过引用传递记录数组
- en: 'Here are the build commands and output for [Listing 5-14](#listing5-14):'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是[示例 5-14](#listing5-14)的构建命令和输出：
- en: '[PRE62]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As you can see from this example, passing large objects by reference is very
    efficient.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中可以看出，按引用传递大对象是非常高效的。
- en: 5.6 Calling Conventions and the Microsoft ABI
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 调用约定和 Microsoft ABI
- en: Back in the days of 32-bit programs, different compilers and languages typically
    used completely different parameter-passing conventions. As a result, a program
    written in Pascal could not call a C/C++ function (at least, using the native
    Pascal parameter-passing conventions). Similarly, C/C++ programs couldn’t call
    FORTRAN, or BASIC, or functions written in other languages, without special help
    from the programmer. It was literally a Tower of Babel situation, as the languages
    were incompatible with one another.^([10](#c05-footnote-10))
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在 32 位程序时代，不同的编译器和语言通常使用完全不同的参数传递约定。因此，用 Pascal 编写的程序无法调用 C/C++ 函数（至少，不能使用本地的
    Pascal 参数传递约定）。类似地，C/C++ 程序也无法调用 FORTRAN、BASIC 或其他语言编写的函数，除非程序员特别处理。这就像是一个巴别塔的局面，因为各个语言之间不兼容。^([10](#c05-footnote-10))
- en: To resolve these problems, CPU manufacturers, such as Intel, devised a set of
    protocols known as the *application binary interface* *(**ABI)* to provide conformity
    to procedure calls. Languages that conformed to the CPU manufacturer’s ABI were
    able to call functions and procedures written in other languages that also conformed
    to the same ABI. This brought a modicum of sanity to the world of programming
    language interoperability.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，CPU 制造商（如英特尔）设计了一套协议，称为 *应用程序二进制接口* *(**ABI)*，以提供过程调用的一致性。遵循 CPU 制造商
    ABI 的语言可以调用用其他也遵循相同 ABI 的语言编写的函数和过程。这为编程语言的互操作性带来了一定的理性。
- en: For programs running under Windows, Microsoft took a subset of the Intel ABI
    and created the Microsoft calling convention (which most people call the *Microsoft
    ABI*). The next section covers the Microsoft calling conventions in detail. However,
    first it’s worthwhile to discuss many of the other calling conventions that existed
    prior to the Microsoft ABI.^([11](#c05-footnote-11))
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在 Windows 上运行的程序，微软从 Intel ABI 中取出了一部分，创建了微软调用约定（通常人们称之为*微软 ABI*）。下一节将详细介绍微软调用约定。然而，首先值得讨论的是在微软
    ABI 之前存在的许多其他调用约定。^([11](#c05-footnote-11))
- en: One of the older *formal* calling conventions is the *Pascal calling convention*.
    In thisconvention, a caller pushes parameters on the stack in the order that they
    appear in the actual parameter list (from left to right). On the 80x86/x86-64
    CPUs, where the stack grows down in memory, the first parameter winds up at the
    highest address on the stack, and the last parameter winds up at the lowest address
    on the stack.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 较早的*正式*调用约定之一是*Pascal 调用约定*。在这种约定中，调用者按实际参数列表中参数出现的顺序（从左到右）将参数压入堆栈。在 80x86/x86-64
    CPU 上，由于堆栈在内存中向下增长，第一个参数最终会位于堆栈的最高地址，而最后一个参数则位于堆栈的最低地址。
- en: While it might look like the parameters appear backward on the stack, the computer
    doesn’t really care. After all, the procedure will access the parameters by using
    a numeric offset, and it doesn’t care about the offset’s value.^([12](#c05-footnote-12))
    On the other hand, for simple compilers, it’s much easier to generate code that
    pushes the parameters in the order they appear in the source file, so the Pascal
    calling convention makes life a little easier for compiler writers (though optimizing
    compilers often rearrange the code anyway).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管参数在堆栈上的顺序可能看起来是倒置的，但计算机并不关心这一点。毕竟，过程会通过使用数字偏移量来访问参数，而它并不关心偏移量的具体值。^([12](#c05-footnote-12))
    另一方面，对于简单的编译器来说，按源文件中出现的顺序推送参数更容易生成代码，因此 Pascal 调用约定使编译器编写者的工作稍微轻松一些（尽管优化编译器通常还是会重新排列代码）。
- en: Another feature of the Pascal calling convention is that the callee (the procedure
    itself) is responsible for removing parameter data from the stack upon subroutine
    return. This localizes the cleanup code to the procedure so that parameter cleanup
    isn’t duplicated across every call to the procedure.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal 调用约定的另一个特点是被调用者（即过程本身）负责在子程序返回时从堆栈中移除参数数据。这将清理代码局部化到过程内部，从而避免在每次调用该过程时都重复清理参数。
- en: The big drawback to the Pascal calling sequence is that handling variable parameter
    lists is difficult. If one call to a procedure has three parameters, and a second
    call has four parameters, the offset to the first parameter will vary depending
    on the actual number of parameters. Furthermore, it’s more difficult (though certainly
    not impossible) for a procedure to clean up the stack after itself if the number
    of parameters varies. This is not an issue for Pascal programs, as standard Pascal
    does not allow user-written procedures and functions to have varying parameter
    lists. For languages like C/C++, however, this is an issue.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: Pascal 调用约定的一个大缺点是处理可变参数列表较为困难。如果一个过程调用有三个参数，而第二个调用有四个参数，那么第一个参数的偏移量将根据实际参数的数量而变化。此外，如果参数的数量变化，过程清理堆栈也会变得更加困难（尽管这并非不可能）。对于
    Pascal 程序来说，这不是一个问题，因为标准 Pascal 不允许用户编写的过程和函数有可变的参数列表。然而，对于像 C/C++ 这样的语言来说，这是一个问题。
- en: 'Because C (and other C-based programming languages) supports varying parameter
    lists (for example, the `printf()` function), C adopted a different calling convention:
    the *C calling convention*, also known as the *cdecl calling convention*. In C,
    the caller pushes parameters on the stack in the reverse order that they appear
    in the actual parameter list. So, it pushes the last parameter first and pushes
    the first parameter last. Because the stack is a LIFO data structure, the first
    parameter winds up at the lowest address on the stack (and at a fixed offset from
    the return address, typically right above it in memory; this is true regardless
    of how many actual parameters appear on the stack). Also, because C supports varying
    parameter lists, it is up to the caller to clean up the parameters on the stack
    after the return from the function.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C（以及其他基于C的编程语言）支持变化的参数列表（例如`printf()`函数），C采用了不同的调用约定：*C调用约定*，也叫做*cdecl调用约定*。在C中，调用方按实际参数列表中出现的反向顺序将参数推入堆栈。所以，它首先推入最后一个参数，然后推入第一个参数。由于堆栈是一个LIFO数据结构，第一个参数最终位于堆栈的最低地址处（并且与返回地址有固定的偏移，通常就在它上方；无论堆栈中有多少实际参数，情况都是如此）。此外，由于C支持变化的参数列表，清理堆栈上的参数是由调用方在函数返回后进行的。
- en: The third common calling convention in use on 32-bit Intel machines, *STDCALL*,
    is basically a combination of the Pascal and C/C++ calling conventions. Parameters
    are passed right to left (as in C/C++). However, the callee is responsible for
    cleaning up the parameters on the stack before returning.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种在32位Intel机器上常用的调用约定，*STDCALL*，基本上是Pascal和C/C++调用约定的结合。参数是从右到左传递的（如同C/C++）。然而，被调用方负责在返回之前清理堆栈上的参数。
- en: One problem with these three calling conventions is that they all use only memory
    to pass their parameters to a procedure. Of course, the most efficient place to
    pass parameters is in machine registers. This led to a fourth common calling convention
    known as the *FASTCALL calling convention*. In thisconvention, the calling program
    passes parameters in registers to a procedure. However, as registers are a limited
    resource on most CPUs, the FASTCALL calling convention typically passes only the
    first three to six parameters in registers. If more parameters are needed, the
    FASTCALL passes the remaining parameters on the stack (typically in reverse order,
    like the C/C++ and STDCALL calling conventions).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种调用约定的一个问题是，它们都只使用内存来将参数传递给程序。当然，最有效的参数传递方式是在机器寄存器中。这导致了第四种常见的调用约定，即*FASTCALL调用约定*。在这种约定中，调用程序将参数通过寄存器传递给程序。然而，由于寄存器是大多数CPU上的有限资源，FASTCALL调用约定通常只通过寄存器传递前三到六个参数。如果需要更多参数，FASTCALL会将其余的参数通过堆栈传递（通常按照反向顺序，如同C/C++和STDCALL调用约定）。
- en: 5.7 The Microsoft ABI and Microsoft Calling Convention
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7 Microsoft ABI 和 Microsoft 调用约定
- en: This chapter has repeatedly referred to the Microsoft ABI. Now it’s time to
    formally describe the Microsoft calling convention.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已经多次提到Microsoft ABI。现在是时候正式描述Microsoft调用约定了。
- en: 5.7.1 Data Types and the Microsoft ABI
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7.1 数据类型与Microsoft ABI
- en: As noted in “Microsoft ABI Notes” in Chapters 1, 3, and 4, the native data type
    sizes are 1, 2, 4, and 8 bytes (see [Table 1-6](c01.xhtml#table1-6) in Chapter
    1). All such variables should be aligned in memory on their native size.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 正如《Microsoft ABI注释》在第1、3和4章中所指出的，本机数据类型的大小为1、2、4和8字节（请参见第1章中的[表1-6](c01.xhtml#table1-6)）。所有这些变量应按其本机大小对齐存储。
- en: For parameters, all procedure/function parameters must consume exactly 64 bits.
    If a data object is smaller than 64 bits, the HO bits of the parameter value (the
    bits beyond the actual parameter’s native size) are undefined (and not guaranteed
    to be zero). Procedures should access only the actual data bits for the parameter’s
    native type and ignore the HO bits.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于参数，所有过程/函数的参数必须占用精确的64位。如果数据对象小于64位，则参数值的高位部分（超出实际参数本机大小的位）是未定义的（并且不保证为零）。过程应该仅访问参数本机类型的实际数据位，忽略高位部分。
- en: If a parameter’s native type is larger than 64 bits, the Microsoft ABI requires
    the caller to pass the parameter by reference rather than by value (that is, the
    caller must pass the address of the data).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果参数的本机类型大于64位，则Microsoft ABI要求调用方通过引用传递该参数，而不是通过值传递（即，调用方必须传递数据的地址）。
- en: 5.7.2 Parameter Locations
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7.2 参数位置
- en: The Microsoft ABI uses a variant of the FASTCALL calling convention that requires
    the caller to pass the first four parameters in registers. [Table 5-2](#table5-2)
    lists the register locations for these parameters.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的 ABI 使用一种变种的 FASTCALL 调用约定，要求调用者通过寄存器传递前四个参数。[表 5-2](#table5-2) 列出了这些参数的寄存器位置。
- en: 'Table 5-2: FASTCALL Parameter Locations'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-2：FASTCALL 参数位置
- en: '| **Parameter** | **If scalar/reference** | **If floating point** |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **如果是标量/引用** | **如果是浮点数** |'
- en: '| --- | --- | --- |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | RCX | XMM0 |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| 1 | RCX | XMM0 |'
- en: '| 2 | RDX | XMM1 |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| 2 | RDX | XMM1 |'
- en: '| 3 | R8 | XMM2 |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| 3 | R8 | XMM2 |'
- en: '| 4 | R9 | XMM3 |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| 4 | R9 | XMM3 |'
- en: '| 5 to *n* | On stack, right to left | On stack, right to left |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| 5 到 *n* | 在栈上，从右到左 | 在栈上，从右到左 |'
- en: 'If the procedure has floating-point parameters, the calling convention skips
    the use of the general-purpose register for that same parameter location. Say
    you have the following C/C++ function:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如果过程有浮点参数，调用约定会跳过使用通用寄存器来传递相同参数位置的参数。假设你有以下 C/C++ 函数：
- en: '[PRE63]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then the Microsoft calling convention would expect the caller to pass `a` in
    (the LO 32 bits of) RCX, `b` in XMM1, a pointer to `c` in R8, and `d` in XMM3,
    skipping RDX, R9, XMM0, and XMM2\. This rule has an exception: for vararg (variable
    number of parameters) or unprototyped functions, floating-point values must be
    duplicated in the corresponding general-purpose register (see [https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160#parameter-passing/](https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160#parameter-passing/)).'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，微软的调用约定会期望调用者将 `a` 传递到（RCX 的低 32 位），`b` 传递到 XMM1，`c` 的指针传递到 R8，`d` 传递到 XMM3，跳过
    RDX、R9、XMM0 和 XMM2。这个规则有一个例外：对于变参（参数数量不固定）或未声明原型的函数，浮点值必须在相应的通用寄存器中复制（请参阅 [https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160#parameter-passing/](https://docs.microsoft.com/en-us/cpp/build/x64-calling-convention?view=msvc-160#parameter-passing/)）。
- en: Although the Microsoft calling convention passes the first four parameters in
    registers, it still requires the caller to allocate storage on the stack for these
    parameters (*shadow storage*).^([13](#c05-footnote-13)) In fact, the Microsoft
    calling convention requires the caller to allocate storage for four parameters
    on the stack even if the procedure doesn’t have four parameters (or any parameters
    at all). The caller doesn’t need to copy the parameter data into this stack storage
    area—leaving the parameter data only in the registers is sufficient. However,
    that stack space must be present. Microsoft compilers assume the stack space is
    there and will use that stack space to save the register values (for example,
    if the procedure calls another procedure and needs to preserve the registers across
    that other call). Sometimes Microsoft’s compilers use this shadow storage as local
    variables.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管微软的调用约定将前四个参数传递到寄存器中，但它仍然要求调用者为这些参数在栈上分配存储空间（*影子存储*）。^([13](#c05-footnote-13))
    事实上，即使过程没有四个参数（或根本没有参数），微软调用约定也要求调用者在栈上为四个参数分配存储空间。调用者不需要将参数数据复制到栈存储区域——只需将参数数据保留在寄存器中即可。然而，这块栈空间必须存在。微软编译器假定栈空间已经存在，并会使用这块栈空间来保存寄存器值（例如，如果过程调用了另一个过程并需要保留寄存器值）。有时微软的编译器将此影子存储用作局部变量。
- en: If you’re calling an external function (such as a C/C++ library function) that
    adheres to the Microsoft calling convention and you do not allocate the shadow
    storage, the application will almost certainly crash.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调用了一个符合微软调用约定的外部函数（比如一个 C/C++ 库函数），并且没有为影子存储分配空间，应用程序几乎肯定会崩溃。
- en: 5.7.3 Volatile and Nonvolatile Registers
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7.3 易失性与非易失性寄存器
- en: As noted way back in Chapter 1, the Microsoft ABI declares certain registers
    to be volatile and others to be nonvolatile. *Volatile* means that a procedure
    can modify the contents of the register without preserving its value. *Nonvolatile*
    means that a procedure must preserve a register’s value if it modifies that value.
    [Table 5-3](#table5-3) lists the registers and their volatility.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 正如第一章早期所提到的，微软的 ABI（应用二进制接口）将某些寄存器声明为易失性，其他的则为非易失性。*易失性*意味着一个过程可以修改寄存器的内容而不保留其值。*非易失性*则意味着如果一个过程修改了寄存器的值，必须保留该寄存器的原始值。[表
    5-3](#table5-3) 列出了这些寄存器及其易失性。
- en: 'Table 5-3: Register Volatility'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-3：寄存器易失性
- en: '| **Register** | **Volatile/nonvolatile** |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| **寄存器** | **易失性/非易失性** |'
- en: '| --- | --- |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| RAX | Volatile |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| RAX | 易失性 |'
- en: '| RBX | Nonvolatile |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| RBX | 非易失性 |'
- en: '| RCX | Volatile |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| RCX | 易失性 |'
- en: '| RDX | Volatile |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| RDX | 易失性 |'
- en: '| RDI | Nonvolatile |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| RDI | 非易失性 |'
- en: '| RSI | Nonvolatile |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| RSI | 非易失性 |'
- en: '| RBP | Nonvolatile |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| RBP | 非易失性 |'
- en: '| RSP | Nonvolatile |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| RSP | 非易失性 |'
- en: '| R8 | Volatile |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| R8 | 易失性 |'
- en: '| R9 | Volatile |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| R9 | 易失性 |'
- en: '| R10 | Volatile |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| R10 | 易失性 |'
- en: '| R11 | Volatile |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| R11 | 易失性 |'
- en: '| R12 | Nonvolatile |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| R12 | 非易失性 |'
- en: '| R13 | Nonvolatile |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| R13 | 非易失性 |'
- en: '| R14 | Nonvolatile |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| R14 | 非易失性 |'
- en: '| R15 | Nonvolatile |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| R15 | 非易失性 |'
- en: '| XMM0/YMM0 | Volatile |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| XMM0/YMM0 | 易失性 |'
- en: '| XMM1/YMM1 | Volatile |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| XMM1/YMM1 | 易失性 |'
- en: '| XMM2/YMM2 | Volatile |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| XMM2/YMM2 | 易失性 |'
- en: '| XMM3/YMM3 | Volatile |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| XMM3/YMM3 | 易失性 |'
- en: '| XMM4/YMM4 | Volatile |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| XMM4/YMM4 | 易失性 |'
- en: '| XMM5/YMM5 | Volatile |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| XMM5/YMM5 | 易失性 |'
- en: '| XMM6/YMM6 | XMM6 Nonvolatile, upper half of YMM6 volatile |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| XMM6/YMM6 | XMM6 非易失性，YMM6 的上半部分为易失性 |'
- en: '| XMM7/YMM7 | XMM7 Nonvolatile, upper half of YMM7 volatile |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| XMM7/YMM7 | XMM7 非易失性，YMM7 的上半部分为易失性 |'
- en: '| XMM8/YMM8 | XMM8 Nonvolatile, upper half of YMM8 volatile |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| XMM8/YMM8 | XMM8 非易失性，YMM8 的上半部分为易失性 |'
- en: '| XMM9/YMM9 | XMM9 Nonvolatile, upper half of YMM9 volatile |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| XMM9/YMM9 | XMM9 非易失性，YMM9 的上半部分为易失性 |'
- en: '| XMM10/YMM10 | XMM10 Nonvolatile, upper half of YMM10 volatile |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| XMM10/YMM10 | XMM10 非易失性，YMM10 的上半部分为易失性 |'
- en: '| XMM11/YMM11 | XMM11 Nonvolatile, upper half of YMM11 volatile |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| XMM11/YMM11 | XMM11 非易失性，YMM11 的上半部分为易失性 |'
- en: '| XMM12/YMM12 | XMM12 Nonvolatile, upper half of YMM12 volatile |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| XMM12/YMM12 | XMM12 非易失性，YMM12 的上半部分为易失性 |'
- en: '| XMM13/YMM13 | XMM13 Nonvolatile, upper half of YMM13 volatile |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| XMM13/YMM13 | XMM13 非易失性，YMM13 的上半部分为易失性 |'
- en: '| XMM14/YMM14 | XMM14 Nonvolatile, upper half of YMM14 volatile |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| XMM14/YMM14 | XMM14 非易失性，YMM14 的上半部分为易失性 |'
- en: '| XMM15/YMM15 | XMM15 Nonvolatile, upper half of YMM15 volatile |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| XMM15/YMM15 | XMM15 非易失性，YMM15 的上半部分为易失性 |'
- en: '| FPU | Volatile, but FPU stack must be empty upon return |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| FPU | 易失性，但 FPU 栈在返回时必须为空 |'
- en: '| Direction flag | Must be cleared upon return |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| Direction flag | 必须在返回时清除 |'
- en: 'It is perfectly reasonable to use nonvolatile registers within a procedure.
    However, you must preserve those register values so that they are unchanged upon
    return from a function. If you’re not using the shadow storage for anything else,
    this is a good place to save and restore nonvolatile register values during a
    procedure call; for example:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个过程内使用非易失性寄存器是完全合理的。但是，必须保存这些寄存器的值，以确保它们在函数返回时不会改变。如果你没有将影像存储用作其他用途，这是保存和恢复非易失性寄存器值的好地方；例如：
- en: '[PRE64]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Of course, if you’re using the shadow storage for another purpose, you can
    always save nonvolatile register values in local variables or can even push and
    pop the register values:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你将影像存储用于其他目的，你总是可以将非易失性寄存器值保存在局部变量中，或者甚至可以将寄存器值压入和弹出栈：
- en: '[PRE65]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 5.7.4 Stack Alignment
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7.4 栈对齐
- en: As I’ve mentioned many times now, the Microsoft ABI requires the stack to be
    aligned on a 16-byte boundary whenever you make a call to a procedure. When Windows
    transfers control to your assembly code (or when another Windows ABI–compliant
    code calls your assembly code), you’re guaranteed that the stack will be aligned
    on an 8-byte boundary that is not also a 16-byte boundary (because the return
    address consumed 8 bytes after the stack was 16-byte-aligned). If, within your
    assembly code, you don’t care about 16-byte alignment, you can do anything you
    like with the stack (however, you should keep it aligned on at least an 8-byte
    boundary).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我多次提到的，Microsoft ABI 要求每次调用过程时，栈必须对齐到 16 字节边界。当 Windows 将控制权转移到你的汇编代码（或当其他符合
    Windows ABI 的代码调用你的汇编代码时），可以确保栈会对齐到一个 8 字节的边界，而该边界并不是 16 字节边界（因为返回地址在栈对齐到 16 字节后消耗了
    8 字节）。如果在你的汇编代码中，你不关心 16 字节对齐，可以随意操作栈（不过，你应该至少保证栈对齐到 8 字节边界）。
- en: 'On the other hand, if you ever plan on calling code that uses the Microsoft
    calling conventions, you need to be able to ensure that the stack is properly
    aligned before the call. There are two ways to do this: carefully manage any modifications
    to the RSP register after entry into your code (so you know the stack is 16-byte-aligned
    whenever you make a call), or force the stack to an appropriate alignment prior
    to making a call. Forcing alignment to 16 bytes is easily achieved using this
    instruction:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果你计划调用使用 Microsoft 调用约定的代码，你需要确保在调用之前栈被正确对齐。可以通过两种方式来做到这一点：小心管理进入代码后的
    RSP 寄存器修改（这样每次调用时你都知道栈是 16 字节对齐的），或者在调用前强制栈对齐到适当的边界。强制栈对齐到 16 字节可以使用如下指令轻松实现：
- en: '[PRE66]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: However, you must execute this instruction *before* setting up parameters for
    a call. If you execute this instruction immediately before a call instruction
    (but after placing all the parameters on the stack), this could shift RSP down
    in memory, and then the parameters will not be at the expected offset upon entry
    into the procedure.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你必须*在*设置参数之前执行此指令。如果你在调用指令之前立即执行此指令（但在将所有参数放入栈中之后），这可能会将RSP在内存中向下移动，从而使参数在进入过程时不在预期的偏移量处。
- en: 'Suppose you don’t know the state of RSP and need to make a call to a procedure
    that expects five parameters (40 bytes, which is not a multiple of 16 bytes).
    Here’s a typical calling sequence you would use:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你不知道RSP的状态，并且需要调用一个期望五个参数（40字节，不是16字节的倍数）的过程。这里是你通常会使用的调用顺序：
- en: '[PRE67]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The only problem with this code is that it is hard to clean up the stack upon
    return (because you don’t know exactly how many bytes you reserved on the stack
    as a result of the `and` instruction). However, as you’ll see in the next section,
    you’ll rarely clean up the stack after an individual procedure call, so you don’t
    have to worry about the stack cleanup here.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码唯一的问题是很难在返回时清理栈（因为你无法准确知道`and`指令导致在栈上预留了多少字节）。不过，正如你将在下一部分看到的，通常你不会在单独的过程调用后清理栈，所以在这里不需要担心栈的清理。
- en: 5.7.5 Parameter Setup and Cleanup (or “What’s with These Magic Instructions?”)
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.7.5 参数设置和清理（或“这些魔法指令到底是什么？”）
- en: 'The Microsoft ABI requires the caller to set up the parameters and then clean
    them up (remove them from the stack) upon return from the function. In theory,
    this means that a call to a Microsoft ABI–compliant function is going to look
    something like the following:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 微软ABI要求调用者设置参数，然后在函数返回时清理它们（从栈中移除）。理论上，这意味着调用一个符合微软ABI的函数应该看起来像以下内容：
- en: '[PRE68]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This allocation and cleanup sequence has two problems. First, you have to repeat
    the sequence (`sub rsp``, parm_size` and `add rsp,` `parm_size`) for every call
    in your program (which can be rather inefficient). Second, as you saw in the preceding
    section, sometimes aligning the stack to a 16-byte boundary forces you to adjust
    the stack downward by an unknown amount, so you don’t know how many bytes to add
    to RSP in order to clean up the stack.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分配和清理序列有两个问题。首先，你必须为程序中的每个调用重复这个序列（`sub rsp`、`parm_size` 和 `add rsp,` `parm_size`），这可能会非常低效。其次，正如你在前一部分看到的那样，有时将栈对齐到16字节边界会强迫你向下调整栈一个未知的量，因此你不知道需要多少字节才能将RSP加回，以便清理栈。
- en: 'If you have several calls sprinkled through a given procedure, you can optimize
    the process of allocating and deallocating parameters on the stack by doing this
    operation just once. To understand how this works, consider the following code
    sequence:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序中有多个调用分布在不同位置，你可以通过只执行一次该操作来优化参数在栈上的分配和回收过程。要理解这一点，可以考虑以下代码顺序：
- en: '[PRE69]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If you study this code, you should be able to convince yourself that the first
    `add` and second `sub` are somewhat redundant. If you were to modify the first
    `sub` instruction to reduce the stack size by the greater of `parm_size` and `parm_size2`,
    and replace the final `add` instruction with this same value, you could eliminate
    the `add` and `sub` instructions appearing between the two calls:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你研究这段代码，你应该能够说服自己，第一次的`add`和第二次的`sub`有些多余。如果你修改第一次的`sub`指令，将栈大小减少到`parm_size`和`parm_size2`中的较大者，并用这个相同的值替换最后的`add`指令，你就可以消除两个调用之间出现的`add`和`sub`指令：
- en: '[PRE70]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If you determine the maximum number of bytes of parameters needed by all calls
    within your procedure, you can eliminate all the individual stack allocations
    and cleanups throughout the procedure (don’t forget, the minimum parameter size
    is 32 bytes, even if the procedure has no parameters at all, because of the shadow
    storage requirements).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确定在你的过程内所有调用所需的最大字节数，你可以消除整个过程中的所有单独的栈分配和清理（不要忘记，最小参数大小是32字节，即使过程没有任何参数，也因为影像存储需求）。
- en: It gets even better, though. If your procedure has local variables, you can
    combine the `sub` instruction that allocates local variables with the one that
    allocates storage for your parameters. Similarly, if you’re using the standard
    entry/exit sequence, the `leave` instruction at the end of your procedure will
    automatically deallocate all the parameters (as well as the local variables) when
    you exit your procedure.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，更好的是，如果你的过程有局部变量，你可以将分配局部变量的`sub`指令与分配参数存储空间的指令结合起来。类似地，如果你使用标准的入口/退出序列，过程结束时的`leave`指令会自动释放所有参数（以及局部变量），当你退出过程时。
- en: 'Throughout this book, you’ve seen lots of “magic” add and subtract instructions
    that have been offered without much in the way of explanation. Now you know what
    those instructions have been doing: they’ve been allocating storage for local
    variables and all the parameter space for the procedures being called as well
    as keeping the stack 16-byte-aligned.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你已经看到许多“神奇”的加法和减法指令，这些指令并没有太多的解释。现在你知道这些指令在做什么：它们在为局部变量和所有被调用过程的参数空间分配存储空间，同时保持栈的16字节对齐。
- en: 'Here’s one last example of a procedure that uses the standard entry/exit procedure
    to set up locals and parameter space:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用标准入口/退出过程来设置局部变量和参数空间的过程的最后一个示例：
- en: '[PRE71]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: However, if you use this trick to allocate storage for your procedures’ parameters,
    you will not be able to use the `push` instructions to move the data onto the
    stack. The storage has already been allocated on the stack for the parameters;
    you must use `mov` instructions to copy the data onto the stack (using the `[RSP+``constant``]`
    addressing mode) when copying the fifth and greater parameters.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你使用这个技巧为过程的参数分配存储空间，你将无法使用`push`指令将数据移入栈中。参数的存储空间已经在栈上分配；你必须使用`mov`指令（使用`[RSP+``常量``]`寻址模式）将数据复制到栈上（从第五个参数开始复制）。
- en: 5.8 Functions and Function Results
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.8 函数与函数结果
- en: '*Functions* are procedures that return a result to the caller. In assembly
    language, few syntactical differences exist between a procedure and a function,
    which is why MASM doesn’t provide a specific declaration for a function. Nevertheless,
    there are some semantic differences; although you can declare them the same way
    in MASM, you use them differently.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*是返回结果给调用者的过程。在汇编语言中，过程和函数之间几乎没有语法上的差异，这也是为什么MASM没有为函数提供特定声明的原因。然而，还是有一些语义上的差异；虽然你可以用相同的方式在MASM中声明它们，但使用方式不同。'
- en: '*Procedures* are a sequence of machine instructions that fulfill a task. The
    result of the execution of a procedure is the accomplishment of that activity.
    Functions, on the other hand, execute a sequence of machine instructions specifically
    to compute a value to return to the caller. Of course, a function can perform
    an activity as well, and procedures can undoubtedly compute values, but the main
    difference is that the purpose of a function is to return a computed result; procedures
    don’t have this requirement.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '*过程*是一系列完成任务的机器指令。执行过程的结果就是完成该活动。而函数则执行一系列机器指令，专门计算一个值并返回给调用者。当然，函数也可以执行某个活动，过程也可以计算值，但主要的区别在于函数的目的是返回一个计算结果；过程没有这个要求。'
- en: In assembly language, you don’t specifically define a function by using special
    syntax. To MASM, everything is a `proc`. A section of code becomes a function
    by virtue of the fact that the programmer explicitly decides to return a function
    result somewhere (typically in a register) via the procedure’s execution.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在汇编语言中，你不会使用特殊的语法来专门定义一个函数。对MASM而言，一切都是`proc`。一段代码通过程序员明确决定将函数结果（通常在寄存器中）通过过程的执行返回，从而变成一个函数。
- en: The x86-64’s registers are the most common place to return function results.
    The `strlen()` routine in the C Standard Library is a good example of a function
    that returns a value in one of the CPU’s registers. It returns the length of the
    string (whose address you pass as a parameter) in the RAX register.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64的寄存器是返回函数结果的最常见地方。C标准库中的`strlen()`例程就是一个很好的例子，它将字符串的长度（你传递的地址作为参数）返回到RAX寄存器中。
- en: By convention, programmers try to return 8-, 16-, 32-, and 64-bit (nonreal)
    results in the AL, AX, EAX, and RAX registers, respectively. This is where most
    high-level languages return these types of results, and it’s where the Microsoft
    ABI states that you should return function results. The exception is floating-point
    values. The Microsoft ABI states that you should return floating-point values
    in the XMM0 register.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 按惯例，程序员通常在AL、AX、EAX和RAX寄存器中返回8位、16位、32位和64位（非浮点）结果。这是大多数高级语言返回这些类型结果的地方，也是Microsoft
    ABI规定返回函数结果的地方。例外是浮点值。Microsoft ABI规定，应该在XMM0寄存器中返回浮点值。
- en: Of course, there is nothing particularly sacred about the AL, AX, EAX, and RAX
    registers. You could return function results in any register if it is more convenient
    to do so. Of course, if you’re calling a Microsoft ABI–compliant function (such
    as `strlen()`), you have no choice but to expect the function’s return result
    in the RAX register (`strlen()` returns a 64-bit integer in RAX, for example).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，AL、AX、EAX和RAX寄存器并没有什么特别神圣的地方。如果更方便，你可以将函数结果返回到任何寄存器中。当然，如果你调用的是一个符合Microsoft
    ABI的函数（如`strlen()`），你就只能期望函数的返回结果在RAX寄存器中（例如，`strlen()`在RAX中返回一个64位整数）。
- en: If you need to return a function result that is larger than 64 bits, you obviously
    must return it somewhere other than in RAX (which can hold only 64-bit values).
    For values slightly larger than 64 bits (for example, 128 bits or maybe even as
    many as 256 bits), you can split the result into pieces and return those parts
    in two or more registers. It is common to see functions returning 128-bit values
    in the RDX:RAX register pair. Of course, the XMM/YMM registers are another good
    place to return large values. Just remember that these schemes are not Microsoft
    ABI–compliant, so they’re practical only when calling code you’ve written.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要返回一个大于64位的函数结果，显然必须将其返回到RAX以外的地方（因为RAX只能存储64位值）。对于稍大于64位的值（例如128位，甚至可能多达256位），你可以将结果分割成几部分，并将这些部分返回到两个或更多的寄存器中。常见的做法是将128位的值返回到RDX:RAX寄存器对中。当然，XMM/YMM寄存器也是返回大值的好地方。只需记住，这些方案不符合Microsoft
    ABI，因此只有在调用你自己编写的代码时才实用。
- en: 'If you need to return a large object as a function result (say, an array of
    1000 elements), you obviously are not going to be able to return the function
    result in the registers. You can deal with large function return results in two
    common ways: either pass the return value as a reference parameter or allocate
    storage on the heap (for example, using the C Standard Library `malloc()` function)
    for the object and return a pointer to it in a 64-bit register. Of course, if
    you return a pointer to storage you’ve allocated on the heap, the calling program
    must free this storage when it has finished with it.'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要返回一个大型对象作为函数结果（比如一个包含1000个元素的数组），显然无法在寄存器中返回函数结果。你可以通过两种常见的方式来处理大型函数返回结果：要么将返回值作为引用参数传递，要么在堆上分配存储空间（例如，使用C标准库的`malloc()`函数）来存储该对象，并将指向它的指针返回到64位寄存器中。当然，如果你返回指向堆上分配的存储空间的指针，调用程序必须在使用完之后释放这段存储空间。
- en: 5.9 Recursion
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.9 递归
- en: '*Recursion* occurs when a procedure calls itself. The following, for example,
    is a recursive procedure:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '*递归*发生在一个过程调用自身时。例如，下面是一个递归过程：'
- en: '[PRE72]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Of course, the CPU will never return from this procedure. Upon entry into `Recursive`,
    this procedure will immediately call itself again, and control will never pass
    to the end of the procedure. In this particular case, runaway recursion results
    in an infinite loop.^([14](#c05-footnote-14))
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，CPU永远不会从这个过程返回。进入`Recursive`时，这个过程将立即再次调用自己，控制永远不会传递到过程的末尾。在这个特殊情况下，过度递归会导致无限循环。^([14](#c05-footnote-14))
- en: 'Like a looping structure, recursion requires a termination condition in order
    to stop infinite recursion. `Recursive` could be rewritten with a termination
    condition as follows:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 像循环结构一样，递归需要一个终止条件来停止无限递归。`Recursive`可以通过如下方式重写，加入终止条件：
- en: '[PRE73]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This modification to the routine causes `Recursive` to call itself the number
    of times appearing in the EAX register. On each call, `Recursive` decrements the
    EAX register by 1 and then calls itself again. Eventually, `Recursive` decrements
    EAX to 0 and returns from each call until it returns to the original caller.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 对例程的这个修改使得`Recursive`根据EAX寄存器中显示的次数调用自身。在每次调用时，`Recursive`将EAX寄存器减1，然后再次调用自己。最终，`Recursive`会将EAX减至0，并从每个调用返回，直到返回到最初的调用者。
- en: 'So far, however, there hasn’t been a real need for recursion. After all, you
    could efficiently code this procedure as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，到目前为止，并没有真正需要递归的情况。毕竟，你可以高效地按照以下方式编写该过程的代码：
- en: '[PRE74]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Both examples would repeat the body of the procedure the number of times passed
    in the EAX register.^([15](#c05-footnote-15)) As it turns out, there are only
    a few recursive algorithms that you cannot implement in an iterative fashion.
    However, many recursively implemented algorithms are more efficient than their
    iterative counterparts, and most of the time the recursive form of the algorithm
    is much easier to understand.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个例子都会根据EAX寄存器中传递的次数重复过程的主体。^([15](#c05-footnote-15)) 事实证明，只有少数递归算法不能以迭代方式实现。然而，许多递归实现的算法比它们的迭代版本更高效，而且大多数情况下，算法的递归形式更容易理解。
- en: The *quicksort algorithm* is probably the most famous algorithm that usually
    appears in recursive form. A MASM implementation of this algorithm appears in
    [Listing 5-15](#listing5-15).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '*快速排序算法*可能是最著名的通常以递归形式出现的算法。该算法的MASM实现见[清单 5-15](#listing5-15)。'
- en: '[PRE75]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Listing 5-15: Recursive quicksort program'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 5-15：递归快速排序程序
- en: 'Here is the build command and sample output for the quicksort program:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是快速排序程序的构建命令和示例输出：
- en: '[PRE76]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Note that this quicksort procedure uses registers for all local variables. The
    quicksort function is a *leaf function*; it doesn’t call any other functions.
    Therefore, it doesn’t need to align the stack on a 16-byte boundary. Also, as
    is a good idea for any pure-assembly procedure (that will be called only by other
    assembly language procedures), this quicksort procedure preserves all the registers
    whose values it modifies (even the volatile registers). That’s just good programming
    practice even if it is a little less efficient.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个快速排序过程使用寄存器处理所有局部变量。快速排序函数是一个*叶函数*；它不调用任何其他函数。因此，它不需要将堆栈对齐到16字节边界。此外，对于任何纯汇编过程（只会被其他汇编语言过程调用），像这种快速排序过程最好保存所有它修改过的寄存器的值（即使是易失性寄存器）。即使效率稍低，这也是一种良好的编程实践。
- en: 5.10 Procedure Pointers
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.10 过程指针
- en: 'The x86-64 call instruction allows three basic forms: PC-relative calls (via
    a procedure name), indirect calls through a 64-bit general-purpose register, and
    indirect calls through a quad-word pointer variable. The `call` instruction supports
    the following (low-level) syntax:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64调用指令允许三种基本形式：基于程序计数器相对地址的调用（通过过程名）、通过64位通用寄存器的间接调用和通过四字长指针变量的间接调用。`call`指令支持以下（低级）语法：
- en: '[PRE77]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: We’ve been using the first form throughout this book, so there is little need
    to discuss it here. The second form, the register indirect call, calls the procedure
    whose address is held in the specified 64-bit register. The address of a procedure
    is the byte address of the first instruction to execute within that procedure.
    On a von Neumann architecture machine (like the x86-64), the system stores machine
    instructions in memory along with other data. The CPU fetches the instruction
    opcode values from memory prior to executing them. When you execute the register
    indirect `call` instruction, the x86-64 first pushes the return address onto the
    stack and then begins fetching the next opcode byte (instruction) from the address
    specified by the register’s value.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中一直使用第一种形式，因此这里不需要进一步讨论。第二种形式，即寄存器间接调用，通过指定的64位寄存器调用保存地址的过程。过程的地址是该过程内第一个要执行的指令的字节地址。在冯·诺依曼架构的机器（如x86-64）上，系统将机器指令与其他数据一起存储在内存中。CPU在执行指令之前从内存中获取指令操作码值。当你执行寄存器间接`call`指令时，x86-64首先将返回地址压入堆栈，然后开始从寄存器值指定的地址获取下一个操作码字节（指令）。
- en: The third form of the preceding `call` instruction fetches the address of a
    procedure’s first instruction from a quad-word variable in memory. Although this
    instruction suggests that the call uses the direct addressing of the procedure,
    you should realize that any legal memory addressing mode is also legal here. For
    example, `call procPtrTable[rbx*8]` is perfectly legitimate; this statement fetches
    the quad word from the array of quad words (`procPtrTable`) and calls the procedure
    whose address is the value contained within that quad word.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`call`指令的第三种形式从内存中的一个四字长变量中获取过程的第一个指令地址。虽然该指令暗示调用使用了过程的直接寻址，但你应该意识到，任何合法的内存寻址模式在这里也是合法的。例如，`call
    procPtrTable[rbx*8]`是完全合法的；该语句从四字长数组（`procPtrTable`）中获取四字长并调用地址值为该四字长内容的过程。
- en: 'MASM treats procedure names like static objects. Therefore, you can compute
    the address of a procedure by using the `offset` operator along with the procedure’s
    name or by using the `lea` instruction. For example, `offset` `proc_name` is the
    address of the very first instruction of the `proc_name` procedure. So, all three
    of the following code sequences wind up calling the `proc_name` procedure:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: MASM将过程名称视为静态对象。因此，你可以通过使用`offset`操作符配合过程名称，或使用`lea`指令来计算过程的地址。例如，`offset` `proc_name`是`proc_name`过程的第一条指令的地址。所以，以下三种代码序列都会调用`proc_name`过程：
- en: '[PRE78]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Because the address of a procedure fits in a 64-bit object, you can store such
    an address into a quad-word variable; in fact, you can initialize a quad-word
    variable with the address of a procedure by using code like the following:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 由于过程的地址适合存储在64位对象中，你可以将这样的地址存储到四字变量中；实际上，你可以通过如下代码将过程的地址初始化到一个四字变量中：
- en: '[PRE79]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'As with all pointer objects, you should not attempt to indirectly call a procedure
    through a pointer variable unless you’ve initialized that variable with an appropriate
    address. You can initialize a procedure pointer variable in two ways: `.data`
    and `.const` objects allow an initializer, or you can compute the address of a
    routine (as a 64-bit value) and store that 64-bit address directly into the procedure
    pointer at runtime. The following code fragment demonstrates both ways to initialize
    a procedure pointer:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有指针对象一样，除非你已经用适当的地址初始化了该变量，否则不应尝试通过指针变量间接调用过程。你可以通过两种方式初始化过程指针变量：`.data`和`.const`对象允许使用初始化值，或者你可以计算一个例程的地址（作为64位值），并在运行时将该64位地址直接存储到过程指针中。以下代码片段演示了两种初始化过程指针的方式：
- en: '[PRE80]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Although all the examples in this section use static variable declarations (`.data`,
    `.const`, `.data?`), don’t think you can declare simple procedure pointers only
    in the static variable declaration sections. You can also declare procedure pointers
    (which are just qword variables) as local variables, pass them as parameters,
    or declare them as fields of a record or a union.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本节中的所有示例都使用静态变量声明（`.data`、`.const`、`.data?`），但不要以为只能在静态变量声明部分声明简单的过程指针。你也可以将过程指针（实际上就是四字变量）声明为局部变量，作为参数传递，或者将它们声明为记录或联合体的字段。
- en: 5.11 Procedural Parameters
  id: totrans-433
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.11 过程参数
- en: One place where procedure pointers are quite invaluable is in parameter lists.
    Selecting one of several procedures to call by passing the address of a procedure
    is a common operation. Of course, a *procedural parameter* is just a quad-word
    parameter containing the address of a procedure, so this is really no different
    from using a local variable to hold a procedure pointer (except, of course, that
    the caller initializes the parameter with the address of the procedure to call
    indirectly).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**过程指针**非常有用的地方是在参数列表中。通过传递过程的地址来选择多个过程中的一个进行调用是一种常见操作。当然，*过程参数*只是一个包含过程地址的四字变量，因此这与使用局部变量保存过程指针没有什么不同（当然，区别在于调用者通过过程地址间接初始化该参数）。
- en: 'When using parameter lists with the MASM `proc` directive, you can specify
    a procedure pointer type by using the `proc` type specifier; for example:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MASM `proc`指令时，你可以通过使用`proc`类型说明符来指定过程指针类型；例如：
- en: '[PRE81]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You can call the procedure pointed at by this parameter by using the following
    call instruction:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下调用指令调用由此参数指向的过程：
- en: '[PRE82]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 5.12 Saving the State of the Machine, Part II
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.12 保存机器状态，第二部分
- en: “Saving the State of the Machine” on page 220 described the use of the `push`
    and `pop` instructions to save the state of the registers across a procedure call
    (callee register preservation). While this is certainly one way to preserve registers
    across a procedure call, it certainly isn’t the only way, nor is it always (or
    even usually) the best way to save and restore registers.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在第220页的“保存机器状态”中描述了使用`push`和`pop`指令来保存寄存器的状态，跨过程调用（被调用者寄存器的保护）。虽然这当然是保存寄存器跨过程调用的一种方法，但它并不是唯一的方式，也并不总是（甚至通常不是）保存和恢复寄存器的最佳方法。
- en: 'The `push` and `pop` instructions have a couple of major benefits: they are
    short (pushing or popping a 64-bit register uses a 1-byte instruction opcode),
    and they work with constant and memory operands. These instructions do have drawbacks,
    however: they modify the stack pointer, they work with only 2- or 8-byte registers,
    they work only with the general-purpose integer registers (and the FLAGS register),
    and they might be slower than an equivalent instruction that moves the register
    data onto the stack. Often, a better solution is to reserve storage in the local
    variable space and simply move the registers to/from those local variables on
    the stack.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`push` 和 `pop` 指令有几个主要优点：它们很简短（将一个 64 位寄存器推送或弹出只需要一个字节的指令操作码），并且它们可以与常量和内存操作数一起使用。然而，这些指令也有缺点：它们会修改栈指针，只能与
    2 字节或 8 字节寄存器一起使用，它们只适用于通用整数寄存器（以及 FLAGS 寄存器），并且它们的速度可能比将寄存器数据移动到栈上的等效指令更慢。通常，更好的解决方案是保留局部变量空间中的存储，并简单地将寄存器移动到栈上的这些局部变量之间。'
- en: 'Consider the following procedure declaration that preserves registers by using
    `push` and `pop` instructions:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下使用 `push` 和 `pop` 指令来保存寄存器的过程声明：
- en: '[PRE83]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'You can achieve the same thing with the following code:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下代码实现相同的功能：
- en: '[PRE84]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The disadvantage to this code is that two extra instructions are needed to allocate
    (and deallocate) storage on the stack for the local variables that hold the register
    values. The `push` and `pop` instructions automatically allocate this storage,
    sparing you from having to supply these extra instructions. For a simple situation
    such as this, the `push` and `pop` instructions probably are the better solution.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的缺点在于，需要两个额外的指令来为存储局部变量（用于保存寄存器值）分配（和释放）栈空间。`push` 和 `pop` 指令自动分配这个存储空间，免去了你需要提供这些额外指令的麻烦。对于像这样的简单情况，`push`
    和 `pop` 指令可能是更好的解决方案。
- en: 'For more complex procedures, especially those that expect parameters on the
    stack or have local variables, the procedure is already setting up the activation
    record, and subtracting a larger number from RSP doesn’t require any additional
    instructions:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的过程，尤其是那些期望栈上传递参数或有局部变量的过程，过程已经在设置激活记录，从 RSP 中减去一个更大的数值不需要任何额外的指令：
- en: '[PRE85]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: MASM automatically generates the code to allocate the storage for `saveRAX`,
    `saveRBX`, and `saveRCX` (along with all the other local variables) on the stack,
    as well as clean up the local storage on return.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: MASM 自动生成代码为 `saveRAX`、`saveRBX` 和 `saveRCX`（以及所有其他局部变量）分配栈上的存储，并在返回时清理局部存储。
- en: 'When allocating local variables on the stack along with storage for any parameters
    a procedure might pass to functions it calls, pushing and popping registers to
    preserve them becomes problematic. For example, consider the following procedure:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 当在栈上分配局部变量以及程序可能传递给它调用的函数的参数时，推送和弹出寄存器以保存它们会变得有问题。例如，考虑以下过程：
- en: '[PRE86]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Had this function pushed RAX, RBX, and RCX on the stack after subtracting 48
    from RSP, those save registers would have wound up on the stack where the function
    passes `parm1`, `parm2`, and `parm3` to `theFunction`. That’s why the `push` and
    `pop` instructions don’t work well when working with functions that build an activation
    record containing local storage.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个函数在从 RSP 中减去 48 后将 RAX、RBX 和 RCX 推送到栈上，那么这些保存寄存器最终会出现在栈上，和函数传递给 `theFunction`
    的 `parm1`、`parm2` 和 `parm3` 一起。正因如此，`push` 和 `pop` 指令在处理构建包含局部存储的激活记录的函数时表现不佳。
- en: 5.13 Microsoft ABI Notes
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.13 微软 ABI 说明
- en: 'This chapter has all but completed the discussion of the Microsoft calling
    conventions. Specifically, a Microsoft ABI–compliant function must follow these
    rules:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 本章几乎已经完成了对微软调用约定的讨论。具体来说，一个符合微软 ABI 的函数必须遵循以下规则：
- en: (Scalar) parameters must be passed in RCX, RDX, R8, and R9, then pushed on the
    stack. Floating-point parameters substitute XMM0, XMM1, XMM2, and XMM3 for RCX,
    RDX, R8, and R9, respectively.
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （标量）参数必须通过 RCX、RDX、R8 和 R9 传递，然后被推送到栈上。浮动点参数则用 XMM0、XMM1、XMM2 和 XMM3 来替代 RCX、RDX、R8
    和 R9。
- en: Varargs functions (functions with a variable number of parameters, such as `printf()`)
    and unprototyped functions must pass floating-point values in both the general-purpose
    (integer) registers and in the XMM registers. (For what it’s worth, `printf()`
    seems to be happy with just passing the floating-point values in the integer registers,
    though that might be a happy accident with the version of MSVC used in the preparation
    of this book.)
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变参数函数（如`printf()`）和未原型声明的函数，必须同时通过通用寄存器（整数寄存器）和XMM寄存器传递浮点值。（值得一提的是，`printf()`似乎仅通过整数寄存器传递浮点值就能正常工作，虽然这可能是使用本书编写时所用MSVC版本的一个偶然结果。）
- en: All parameters must be less than or equal to 64 bits in size; larger parameters
    must be passed by reference.
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有参数的大小必须小于或等于64位；较大的参数必须通过引用传递。
- en: On the stack, parameters always consume 64 bits (8 bytes) regardless of their
    actual size; the HO bits of smaller objects are undefined.
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在栈上，参数总是占用64位（8字节），无论其实际大小如何；较小对象的高位（HO位）是未定义的。
- en: Immediately before a `call` instruction, the stack must be aligned on a 16-byte
    boundary.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`call`指令之前，栈必须按照16字节对齐。
- en: Registers RAX, RCX, RDX, R8, R9, R10, R11, and XMM0/YMM0 to XMM5/YMM5 are volatile.
    The caller must preserve the registers across a call if it needs their values
    to be saved across the call. Also note that the HO 128 bits of YMM0 to YMM15 are
    volatile, and the caller must preserve these registers if it needs these bits
    to be preserved across a call.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器RAX、RCX、RDX、R8、R9、R10、R11和XMM0/YMM0到XMM5/YMM5是易失的。调用者必须在调用之前保存这些寄存器的值，如果它需要在调用后继续使用这些值。还需注意，YMM0到YMM15的高128位是易失的，调用者必须在调用之前保存这些寄存器的值，如果需要保存这些位。
- en: Registers RBX, RSI, RDI, RBP, RSP, R12 to R15, and XMM6 to XMM15 are nonvolatile.
    The callee must preserve these registers if it changes their values. As noted
    earlier, while YMM0L to YMM15L (the LO 128 bits) are nonvolatile, the upper 128
    bits of these registers can be considered volatile. However, if a procedure is
    saving the LO 128 bits of YMM0 to YMM15, it may as well preserve all the bits
    (this inconsistency in the Microsoft ABI is to support legacy code running on
    CPUs that don’t support the YMM registers).
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寄存器RBX、RSI、RDI、RBP、RSP、R12到R15，以及XMM6到XMM15是非易失的。如果被调用函数更改了这些寄存器的值，它必须保留这些寄存器的值。如前所述，虽然YMM0L到YMM15L（低128位）是非易失的，但这些寄存器的高128位可以认为是易失的。然而，如果一个过程保存了YMM0到YMM15的低128位，它也可以保留所有位（这种在Microsoft
    ABI中的不一致性是为了支持在不支持YMM寄存器的CPU上运行的遗留代码）。
- en: Scalar function returns (64 bits or fewer) come back in the RAX register. If
    the data type is smaller than 64 bits, the HO bits of RAX are undefined.
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标量函数返回值（64位或更小）会返回到RAX寄存器。如果数据类型小于64位，RAX的高位（HO位）是未定义的。
- en: Functions that return values larger than 64 bits must allocate storage for the
    return value and pass the address of that storage in the first parameter (RCX)
    to the function. On return, the function must return this pointer in the RAX register.
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值大于64位的函数必须为返回值分配存储空间，并将该存储空间的地址作为第一个参数（RCX）传递给函数。返回时，函数必须在RAX寄存器中返回该指针。
- en: Functions return floating-point results (double or single) in the XMM0 register.
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数返回浮点结果（双精度或单精度）时，结果会存放在XMM0寄存器中。
- en: 5.14 For More Information
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.14 更多信息
- en: The electronic edition of the 32-bit edition this book (found at [https://artofasm.randallhyde.com/](https://artofasm.randallhyde.com/))contains
    a whole “volume” on advanced and intermediate procedures. Though that book covers
    32-bit assembly language programming, the concepts apply directly to 64-bit assembly
    by simply using 64-bit addresses rather than 32-bit addresses.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的32位电子版（可在[https://artofasm.randallhyde.com/](https://artofasm.randallhyde.com/)找到）包含了一个关于高级和中级过程的完整“卷”。虽然这本书讲解的是32位汇编语言编程，但这些概念通过简单地使用64位地址而不是32位地址，同样适用于64位汇编。
- en: While the information appearing in this chapter covers 99 percent of the material
    that assembly programmers typically use, there is additional information on procedures
    and parameters that you may find interesting. In particular, the electronic edition
    covers additional parameter-passing mechanisms (pass by value/result, pass by
    result, pass by name, and pass by lazy evaluation) and goes into greater detail
    about the places you can pass parameters. The electronic version also covers iterators,
    thunks, and other advanced procedure types. Finally, a good compiler construction
    textbook will cover additional details about runtime support for procedures.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所包含的信息涵盖了汇编程序员通常使用的99%的材料，但还有一些关于过程和参数的附加信息，可能会引起您的兴趣。特别是，电子版介绍了更多的参数传递机制（按值/结果传递、按结果传递、按名称传递和按懒惰求值传递），并详细讨论了您可以传递参数的地方。电子版还涵盖了迭代器、懒惰计算和其他高级过程类型。最后，一本好的编译器构造教材会介绍有关过程运行时支持的更多细节。
- en: For more information on the Microsoft ABI, search for *Microsoft calling conventions*
    on the Microsoft website (or on the internet).
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Microsoft ABI的更多信息，请在Microsoft网站（或互联网）上搜索*Microsoft calling conventions*。
- en: 5.15 Test Yourself
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.15 自测
- en: Explain, step by step, how the `call` instruction works.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐步解释`call`指令是如何工作的。
- en: Explain, step by step, how the `ret` instruction works.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 逐步解释`ret`指令是如何工作的。
- en: What does the `ret` instruction, with a numeric constant operand, do?
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ret`指令带有数字常量操作数时，做了什么？'
- en: What value is pushed on the stack for a return address?
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回地址会将什么值推送到栈上？
- en: What is namespace pollution?
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是命名空间污染？
- en: How do you define a single global symbol in a procedure?
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在过程定义中声明一个单一的全局符号？
- en: How would you make all symbols in a procedure non-scoped (that is, all the symbols
    in a procedure would be global)?
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使过程中的所有符号都无作用域（即，过程中的所有符号都是全局的）？
- en: Explain how to use the `push` and `pop` instructions to preserve registers in
    a function.
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释如何使用`push`和`pop`指令来保存函数中的寄存器。
- en: What is the main disadvantage of caller preservation?
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被调用方保存的主要缺点是什么？
- en: What is the main problem with callee preservation?
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 被调用方保存的主要问题是什么？
- en: What happens if you fail to pop a value in a function that you pushed on the
    stack at the beginning of the function?
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在函数开始时将一个值推送到栈上，但在函数中未弹出它，会发生什么？
- en: What happens if you pop extra data off the stack in a function (data that you
    did not push on the stack in the function)?
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在函数中弹出多余的数据（即没有在函数中推送到栈上的数据），会发生什么？
- en: What is an activation record?
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是激活记录？
- en: What register usually points at an activation record, providing access to the
    data in that record?
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个寄存器通常指向一个激活记录，从而访问该记录中的数据？
- en: How many bytes are reserved for a typical parameter on the stack when using
    the Microsoft ABI?
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Microsoft ABI时，在栈上为典型参数保留了多少字节？
- en: What is the standard entry sequence for a procedure (the instructions)?
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过程的标准入口序列是什么（指令）？
- en: What is the standard exit sequence for a procedure (the instructions)?
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 过程的标准退出序列是什么（指令）？
- en: What instruction can you use to force 16-byte alignment of the stack pointer
    if the current value in RSP is unknown?
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前RSP值未知，您可以使用什么指令强制栈指针对齐为16字节？
- en: What is the scope of a variable?
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量的作用域是什么？
- en: What is the lifetime of a variable?
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量的生命周期是什么？
- en: What is an automatic variable?
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是自动变量？
- en: When does the system allocate storage for an automatic variable?
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统何时为自动变量分配存储空间？
- en: Explain two ways to declare local/automatic variables in a procedure.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释声明局部/自动变量的两种方式。
- en: 'Given the following procedure source code snippet, provide the offsets for
    each of the local variables:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定以下过程源代码片段，提供每个局部变量的偏移量：
- en: '[PRE87]'
  id: totrans-494
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: What statement(s) would you insert in the source file to tell MASM to automatically
    generate the standard entry and standard exit sequences for a procedure?
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源文件中插入哪些语句，才能告诉MASM自动生成过程的标准入口和标准退出序列？
- en: When MASM automatically generates a standard entry sequence for a procedure,
    how does it determine where to put the code sequence?
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当MASM自动为一个过程生成标准入口序列时，它是如何确定将代码序列放在哪里的？
- en: When MASM automatically generates a standard exit sequence for a procedure,
    how does it determine where to put the code sequence?
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当MASM自动为一个过程生成标准退出序列时，它是如何确定将代码序列放在哪里的？
- en: What value does a pass-by-value parameter pass to a function?
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按值传递的参数向函数传递什么值？
- en: What value does a pass-by-reference parameter pass to a function?
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按引用传递的参数会传递什么值给函数？
- en: When passing four integer parameters to a function, where does the Windows ABI
    state those parameters are to be passed?
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当将四个整数参数传递给函数时，Windows ABI规定这些参数将如何传递？
- en: When passing a floating-point value as one of the first four parameters, where
    does the Windows ABI insist the values will be passed?
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当将浮动点值作为前四个参数之一传递时，Windows ABI要求这些值将如何传递？
- en: When passing more than four parameters to a function, where does the Windows
    ABI state the parameters will be passed?
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当将超过四个参数传递给函数时，Windows ABI规定这些参数将如何传递？
- en: What is the difference between a volatile and nonvolatile register in the Windows
    ABI?
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows ABI中，易失性寄存器和非易失性寄存器有什么区别？
- en: Which registers are volatile in the Windows ABI?
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows ABI中，哪些寄存器是易失性的？
- en: Which registers are nonvolatile in the Windows ABI?
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows ABI中，哪些寄存器是非易失性的？
- en: When passing parameters in the code stream, how does a function access the parameter
    data?
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在代码流中传递参数时，函数如何访问参数数据？
- en: What is a shadow parameter?
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是影像参数？
- en: How many bytes of shadow storage will a function require if it has a single
    32-bit integer parameter?
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个函数有一个32位整数参数，它需要多少字节的影像存储？
- en: How many bytes of shadow storage will a function require if it has two 64-bit
    integer parameters?
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个函数有两个64位整数参数，它需要多少字节的影像存储？
- en: How many bytes of shadow storage will a function require if it has six 64-bit
    integer parameters?
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个函数有六个64位整数参数，它需要多少字节的影像存储？
- en: What offsets will MASM associate with each of the parameters in the following
    `proc` declaration?
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下`proc`声明中，MASM会将每个参数与哪些偏移量关联？
- en: '[PRE88]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Suppose that `parm4` in the preceding question is a pass-by-reference character
    parameter. How would you load that character into the AL register (provide a code
    sequence)?
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设在前一个问题中，`parm4`是一个按引用传递的字符参数。你如何将该字符加载到AL寄存器中（请提供代码序列）？
- en: What offsets will MASM associate with each of the local variables in the following
    `proc` snippet?
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下`proc`代码片段中，MASM会将每个局部变量与哪些偏移量关联？
- en: '[PRE89]'
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: What is the best way to pass a large array to a procedure?
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个大型数组传递给过程的最佳方法是什么？
- en: What does *ABI* stand for?
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*ABI*代表什么？'
- en: Where is the most common place to return a function result?
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回函数结果最常见的位置在哪里？
- en: What is a procedural parameter?
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是过程参数？
- en: How would you call a procedure passed as a parameter to a function/procedure?
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何调用作为参数传递给函数/过程的过程？
- en: If a procedure has local variables, what is the best way to preserve registers
    within that procedure?
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个过程有局部变量，如何在该过程中保存寄存器是最好的方法？
