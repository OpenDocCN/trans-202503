## **6**

**TEXT EFFECTS AND TYPOGRAPHIC STYLES**

![Image](graphics/common-01.jpg)

Text content has been the backbone of the Web since its creation, yet for years we’ve had to make do with a limited set of tools. CSS3 hugely expands its typographic toolset by introducing a range of new and updated features in the Text Module.

Chief among these new features is the ability to add shadows to text. Although this addition doesn’t sound particularly revolutionary—print typographers have been using shadows for a long time—the new syntax is flexible enough to allow for some very nice effects. A similar feature is textoutlining (or text-stroking), which, although not widely implemented, does increase the variety of options available when creating decorative headlines. In addition to these are some less flashy effects but ones that can do wonders for your text’s readability.

The CSS Text Level 3 Module (*[http://www.w3.org/TR/css3-text/](http://www.w3.org/TR/css3-text/)*) currently has Last Call Working Draft status; however, some elements are well implemented and ready for you to use straightaway.

Before I introduce the first new property in this module, I’ll briefly introduce the concepts of coordinates and axes. If you’re already familiar with these, feel free to skip this section; otherwise, read on.

### **Understanding Axes and Coordinates**

One syntax concept that’s new to CSS3 is that of the *axis* (or *axes* when you have more than one). You may know all about axes if you remember your math lessons, but if you’re reading this section, I assume you need a refresher.

CSS uses the *Cartesian coordinate system*, which consists of two lines, one horizontal and one vertical, that cross each other at a right angle. Each of these lines is an axis: The horizontal line is known as the *x-axis*, and the vertical line is known as the *y-axis*. The point where the two lines meet is called the *origin*. You can see this illustrated in [Figure 6-1](ch06.html#ch06fig1).

![Image](graphics/f06-01.jpg)

*Figure 6-1: The x-* *and* y*-axes and the point of origin*

For onscreen items, you measure the lengths of these axes in pixels. In [Figure 6-1](ch06.html#ch06fig1), you can see the axes and origin are overlaid on a grid. Imagine that each square corresponds to a single pixel. You’ll also notice positive (+) and negative (−) labels at either end of each axis; these tell you that the distance away from the origin will be measured either positively or negatively in this direction.

Now that you understand this concept, you can find the coordinates of any point relative to the origin. The *coordinates* are a pair of values—one for each axis—that indicate the distance from the origin. The origin has coordinates (0, 0). For example, given the coordinates (3, 4), you would find the point by moving 3 pixels along the *x*-axis, and 4 pixels along the *y*-axis (remember the first line on each axis is 0 and is not counted). Likewise, the coordinates (−3, −1) indicate a point 3 pixels in a negative direction away from the origin along the *x*-axis and 1 pixel away from the origin in a negative direction along the *y*-axis. You can see both of these values plotted on the chart in [Figure 6-2](ch06.html#ch06fig2).

![Image](graphics/f06-02.jpg)

*Figure 6-2: Two sets of coordinates*

If this all sounds terribly complicated, don’t worry—you’ve been using the Cartesian coordinate system already with properties like `background-position`; you just didn’t realize it.

In CSS, all elements have a height and a width, each of which is a stated number of pixels in length (even when using other length units such as em or a percentage). The height and width together create a *pixel grid*; for example, an element that is 10px by 10px in size has a pixel grid of 100px. If you consider that the origin of the element is at the top-left corner, then the two positional values for properties like `background-position` correspond exactly to the *x*- and *y*-coordinates.

**NOTE**
*In CSS, the default origin is the top-left corner of an element, but that isn’t always fixed; some CSS properties allow you to change the origin’s position. For instance, you could set the origin at the dead center of an element or at the bottom-right corner or anywhere you wish. We’ll see this later in this book, for example when dealing with 2D Transformations in [Chapter 12](ch12.html#ch12).*

### **Applying Dimensional Effects: text-shadow**

The ability to apply drop shadows to text using the `text-shadow` property has been around for a long time; Safari first implemented it in version 1.1, which was released in 2005\. So you might be wondering why I am discussing it in a book on CSS3\. As with the font properties in [Chapter 5](ch05.html#ch05), `text-shadow` was dropped from CSS2.1 owing to lack of implementation, but this property has been reinstated in the CSS3 spec and is well implemented in browsers today.

The position of the shadow is set using the *x*- and *y*-coordinates that I just introduced. The simplest form of the syntax accepts two values: *x* to set the horizontal distance from the text (known as the *x-offset*) and *y* to set the vertical distance (the *y-offset*):

```
E { text-shadow: x y; }
```

By default, the shadow will be the color that it inherited from its parent (usually black), so if you want to specify a different color, you need to provide a value for that, such as:

```
E { text-shadow: x y color; }
```

Here’s an example of a gray (hex code #BBB) drop shadow located 3px to the right and 3px down from the original text:

```
h1 { text-shadow: 3px 3px #BBB; }
```

You can see the output of this code in [Figure 6-3](ch06.html#ch06fig3).

![Image](graphics/f06-03.jpg)

*Figure 6-3: Simple* `*text-shadow*`

You aren’t limited to positive integers as offset values; you can use both 0 (zero) and negative numbers to get different effects. Here are a few examples:

```
➊ .one { text-shadow: -3px -3px #BBB; }
➋ .two { text-shadow: -5px 3px #BBB; }
➌ .three { text-shadow: -5px 0 #BBB; }
```

You can see the output of these examples in [Figure 6-4](ch06.html#ch06fig4).

![Image](graphics/f06-04.jpg)

*Figure 6-4: Different axis offset values for* `*text-shadow*`

The first example (➊) uses negative values for both axes, so the shadow is rendered above and to the left of the text. The next (➋) uses a negative value for the *x*-axis and a positive value for the *y*-axis, so the shadow renders below and to the left. The final example (➌) has a negative value for the *x*-axis and a value of 0 for *y*-axis, so the shadow renders to the left and on the same baseline.

The `text-shadow` property also has a fourth option: `*blur-radius*`. This option sets the extent of a blur effect on the shadow and must be used after the offset values:

```
E { text-shadow: x y blur-radius color; }
```

The blur radius value is, like the two offset values, also an integer with a length unit; the higher the value, the wider (and lighter) the blur. If no value is supplied (as in the examples shown in [Figure 6-4](ch06.html#ch06fig4)), the blur radius is assumed to be 0\. Here are a couple of examples:

```
.one { text-shadow: 3px 3px 3px #BBB; }
.two { text-shadow: 0 0 3px #000; }
```

You can see the output of these examples in [Figure 6-5](ch06.html#ch06fig5).

![Image](graphics/f06-05.jpg)

*Figure 6-5: Different blur values for* `*text-shadow*`

In the first example, I set the same offset values as in [Figure 6-4](ch06.html#ch06fig4), but with a blur radius of 3px. The result is a much softer, more “natural” shadow. In the second example, I’ve set 0 values for the offsets and a 3px blur radius, matching the text to the background and creating the illusion that the text is raised.

#### ***Multiple Shadows***

You don’t have to limit yourself to a single shadow—`text-shadow`’s syntax supports adding multiple shadows to a text node. Just supply extra values to the property, using commas to separate them, like this:

```
E { text-shadow: value, value, value; }
```

The shadows are applied in the order you supply the values. [Figure 6-6](ch06.html#ch06fig6) shows two examples of multiple shadows in action.

![Image](graphics/f06-06.jpg)

*Figure 6-6: Using multiple values with* `*text-shadow*`

The CSS for these examples is shown here. The first example has a class of `one`, and the second has a class of `two`. Note that I’ve indented them for clarity.

```
.one {
    text-shadow:
    0 -2px 3px #FFF,
    0 -4px 3px #AAA,
    0 -6px 6px #666,
    0 -8px 9px #000;
}
.two {
    color: #FFF;
    text-shadow:
    0 2px rgba(0,0,0,0.4),
    0 4px rgba(0,0,0,0.4),
    0 6px rgba(0,0,0,0.4),
    0 8px 0 rgba(0,0,0,0.4);
}
```

In the first example, I’ve kept the x-offset at 0 while increasing the y-offset’s negative value from −2px to −8px. The blur radius increases from 3px to 9px, and the color gets gradually darker, creating a ghostly pale outline behind the characters, which becomes a darker shadow as it gets farther from the characters.

In the second example, the x-offset also remains consistent, but this time the y-offset increases its value positively. Because the `*blur-radius*` value isn’t specified, it stays at 0\. Here, I’ve used the `rgba()` color function (which I explain in [Chapter 10](ch10.html#ch10)), so the color stays the same but is partially transparent, creating an overlapping effect. Although the value changes are fairly small, the visual difference between the two elements is quite profound.

As I said earlier, `text-shadow` is well implemented in browsers, with support in IE10+ and all other major browsers, including mobile.

### **Restricting Overflow**

Under certain circumstances—perhaps on mobile devices where screen space is limited—you may want to restrict text to a single line and a fixed width, perhaps when displaying a list of links to other pages, where you don’t want the link text to wrap onto multiple lines. In these circumstances, your text being wider than its container and getting clipped mid-character can be quite frustrating.

A new property called `text-overflow` is available in CSS3 for just those circumstances. Here’s its syntax:

```
E { text-overflow: keyword; }
```

The permitted keyword values are `clip` and `ellipsis`. The default value is `clip`, which acts in the way I just described: Your text is clipped at the point where it flows out of the container element. But the new value that’s really interesting is `ellipsis`, which replaces the last whole or partial character before the overflow with an ellipsis character—the one that looks like three dots (…).

Let’s walk through an example using the following CSS:

```
p {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
```

On this `p` element, I set the value of `overflow` to `hidden` to prevent the content showing outside of the border, the value of the `white-space` property to `nowrap` to prevent the text from wrapping over multiple lines, and a value of `ellipsis` on the `text-overflow` property. You can see the result, compared with the default behavior, in [Figure 6-7](ch06.html#ch06fig7).

![Image](graphics/f06-07.jpg)

*Figure 6-7: The* `*text-overflow*` *property with a value of* `*ellipsis*` *(bottom)*

The last word in the sentence has been truncated and an ellipsis used in place of the removed characters, signifying that the line has been truncated.

The `text-overflow` property was originally specified in the Text Module, but has since been moved to the Basic User Interface Module (*[http://www.w3.org/TR/css3-ui/](http://www.w3.org/TR/css3-ui/)*). This property is implemented in all major browsers.

The specification also extends the basic syntax in two ways. First, you can provide two values to the property—a first for overflow at the end of a line and a second for overflow at the start. For example, if you negatively indented text that also overflowed its container, you could put ellipses on both ends:

```
E { text-overflow: ellipsis ellipsis; }
```

The second extension offers a third possible keyword value, which is a string of characters to be used instead of the ellipsis, like in this example where I use a tilde to show the overflow:

```
E { text-overflow: '~'; }
```

These extensions are currently implemented only in Firefox and are marked in the spec as being at risk of being removed at a later date.

### **Aligning Text**

The `text-align` property has been around for a long time, but CSS3 adds two new values to it: `start` and `end`. For people who read left-to-right, they are equivalent to the values `left` and `right` (respectively). Their real usefulness is on internationalized sites that may also use right-to-left text, however. You can use these new values in most modern browsers, with the exception of Internet Explorer.

New to CSS3 is the `text-align-last` property, which lets you set the alignment of the last (or only) line of text in a justified block. This property accepts the same values as `text-align`:

```
E { text-align-last: keyword; }
```

So if you want to justify a block of text but also align the last line to the right, you would use

```
p {
    text-align: justify;
    text-align-last: right;
}
```

At the time of writing, this extension is implemented in Internet Explorer (although, again, without the `start` and `end` keyword values), Firefox with the `-moz-` prefix, and Chrome.

### **Controlling Line Wrapping**

An issue that’s frequently encountered when working with dynamic text is line wrapping in inappropriate places. For example, if you’re providing details about an event, you want the start time and end time to appear next to each other on the same line, but with a dynamic line break, the end time may be pushed to the subsequent line. CSS3 gives you more control over these kinds of issues with a pair of properties that lets you define more clearly how you want your content to wrap.

#### ***Breaking Words***

The first property is `word-wrap`, which specifies whether the browser can break long words to make them fit into the parent element. The syntax for it is simple:

```
E { word-wrap: keyword; }
```

This property allows the keyword values `normal` or `break-word`. The former allows lines to break only between words (unless otherwise specified in the markup), and the latter allows a word to be broken if required to prevent overflow of the parent element.

So, for example, if I want to allow long words to be wrapped instead of overflowing their containing element, I might use:

```

p.break { word-wrap: break-word; }
```

[Figure 6-8](ch06.html#ch06fig8) shows this effect. The left block doesn’t use word wrapping, and the right block does.

![Image](graphics/f06-08.jpg)

*Figure 6-8: Example of text with (left) and without (right) a* `*break-word*` *value for* `*word-wrap*`

The `word-wrap` property is widely implemented across all major browsers, including Internet Explorer. Recent versions of the Text Module have renamed `word-wrap` to `overflow-wrap`, however, and some browsers—Chrome and Safari, for example—have implemented the new name, although the old name will also be supported for legacy reasons.

#### ***Hyphenating Words***

If you’d prefer an extra option for breaking words over multiple lines, you can use hyphenation. Long a standard of print, hyphens indicate where the break in a word occurs. You can hyphenate your text already in HTML, using the soft-hyphenation symbol entity, `&shy;`—although this requires that you mark up all of your content, which is not always an option.

CSS3 makes this somewhat easier through the `hyphens` property:

```
E { hyphens: keyword; }
```

`hyphens` has three possible keyword values: `manual` hyphenates words only where a hyphenation suggestion exists in the markup—that is, using the soft-hyphenation symbol mentioned in the previous paragraph; `auto` hyphenates words at an appropriate point even if no hyphenation suggestions are present; and `none` never hyphenates words, even if suggestions are present.

**WARNING**
*Automatic hyphenation only occurs when the language of a document has been specified, and the browser has access to a hyphenation dictionary of that language.*

You can see an example of hyphenation in [Figure 6-9](ch06.html#ch06fig9). The paragraph on the left has no hyphenation applied, whereas the paragraph on the right has a value of `auto`; the word “conversations” (highlighted) has been hyphenated and broken over two lines by the browser.

![Image](graphics/f06-09.jpg)

*Figure 6-9: The paragraph on the right has automatic hyphenation enabled*

The `hyphens` property currently has a rather piecemeal implementation: it’s in IE10+, Firefox, and Safari, with the relevant vendor prefix for each, but has recently been pulled from Chrome (where automatic hyphenation was not supported anyway). It’s also in Safari for iOS.

### **Resizing Elements**

Another new property that’s useful for elements whose contents are wider than their container is the `resize` property. This property lets you control an element’s dimensions by providing a handle with which you can drag the element out to a different size.

The property has the following syntax:

```
E { resize: keyword; }
```

The keyword value states in which direction the element can be dragged: `horizontal` or `vertical`, `both`, or `none`. In the following example, I’ll show a `p` element with the value of `both` on the `resize` property, using this code:

```
p {
    overflow: hidden;
    resize: both;
}
```

[Figure 6-10](ch06.html#ch06fig10) shows how a resizable element is displayed in Firefox on the Mac.

![Image](graphics/f06-10.jpg)

*Figure 6-10: A resizable text box has a striped handle in the lower-right corner*

The `resize` property is supported in Chrome, Firefox, and Safari—although the implementation can be somewhat shaky in mobile browsers, which have coarser input controls. Also be aware that resizing elements may not be keyboard-accessible, so don’t make resizing a required activity.

### **Summary**

The last few years have seen a noticeable upturn in the quality of typography on the Web, although the limited range of CSS text properties hasn’t made that easy. But I believe that browser makers have noticed the push for better implementation and, slowly but surely, more typographic control is being placed in our hands.

In [Chapter 5](ch05.html#ch05), I looked at ways to increase the range and variety of fonts, and in this chapter, I’ve discussed methods to make those fonts more decorative, flexible, and—most importantly—readable. [Chapter 7](ch07.html#ch07) will complete the trio of chapters on fonts and typography by introducing a whole new way to lay out text content. Well, new to the Web, that is; printers have been doing it for centuries.

### **Text Effects and Typographic Styles: Browser Support**

|  | **Chrome** | **Firefox** | **Safari** | **IE** |
| `text-shadow` | Yes | Yes | Yes | IE10 |
| `text-overflow` | Yes | Yes | Yes | Yes |
| `text-align` (new values) | Yes | Yes | Yes | No |
| `text-align-last` | Yes | Yes^([*](ch06.html#footnote22a)) | No | Yes^([†](ch06.html#footnote23a)) |
| `overflow-wrap` | Yes | Yes^([‡](ch06.html#footnote24a)) | Yes | Yes^‡ |
| `hyphens` | No | Yes* | Yes* | IE10* |
| `resize` | Yes^([§](ch06.html#footnote25a)) | Yes | Yes^§ | No |

[*](ch06.html#footnote_22a) With vendor prefix

[†](ch06.html#footnote_23a) Without the start and end values

[‡](ch06.html#footnote_24a) As word-wrap

[§](ch06.html#footnote_25a) Not in mobile browsers