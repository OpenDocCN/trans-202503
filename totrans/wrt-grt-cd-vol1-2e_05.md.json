["```\nMemory: array [0..1048575] of byte; // 1MB address space (20 bits)\n```", "```\nLO byte:     0\n\nByte #1:     1\n\nByte #2:     0\n\nHO byte:     0\n```", "```\nByte:        3    2    1    0\n\n256:         0    0    1    0    (each digit represents an 8-bit value)\n```", "```\nByte:        3    2    1    0\n\n256:         0    1    0    0    (each digit represents an 8-bit value)\n```", "```\nstruct\n\n{\n\n    short unsigned i;   // Assume shorts require 16 bits.\n\n    short unsigned u;\n\n    long unsigned r;    // Assume longs require 32 bits.\n\n} RECORDvar;\n\nunion\n\n{\n\n    short unsigned i;\n\n    short unsigned u;\n\n    long unsigned r;\n\n} UNIONvar;\n```", "```\nunion\n\n{\n\n    unsigned long bits32; /* This assumes that C uses 32 bits for \n\n                             unsigned long */\n\n    unsigned char bytes[4];\n\n} theValue;\n```", "```\ntheValue.bytes[0] = byte0;\n\ntheValue.bytes[1] = byte1;\n\ntheValue.bytes[2] = byte2;\n\ntheValue.bytes[3] = byte3;\n```", "```\ntheValue.bytes[0] = byte3;\n\ntheValue.bytes[1] = byte2;\n\ntheValue.bytes[2] = byte1;\n\ntheValue.bytes[3] = byte0;\n```", "```\ntheValue.bytes[0] = 0;\n\ntheValue.bytes[1] = 1;\n\ntheValue.bytes[2] = 0;\n\ntheValue.bytes[3] = 0;\n\nisLittleEndian = theValue.bits32 == 256;\n```", "```\nI := J;\n\nI := I * 5 + 2;\n```", "```\nfor i := 0 to 10 do\n\n         A [i] := 0;\n```", "```\nstatic\n\n    i:dword;\n\n         . . .\n\n    mov( eax, i ); // Store EAX's value into the i variable.\n```", "```\nstatic\n\n    byteArray: byte[16];\n\n         . . .\n\n    lea( ebx, byteArray );  // Loads EBX register with the address \n\n                            // of byteArray.\n\n    mov( [ebx], al );       // Loads byteArray[0] into AL.\n\n    inc( ebx );             // Point EBX at the next byte in memory\n\n                            // (byteArray[1]).\n\n    mov( [ebx], ah );       // Loads byteArray[1] into AH.\n```", "```\nstatic\n\n    byteArray: byte[16];\n\n        . . .\n\n    mov( 0, ebx );                    // Initialize an index into the array.\n\n    while( ebx < 16 ) do\n\n        mov( 0, byteArray[ebx] );     // Zeros out byteArray[ebx].\n\n        inc( ebx );                   // EBX := EBX +1, move on to the\n\n                                      // next array element.\n\n    endwhile;\n```", "```\nlea( ebx, byteArray ); // Loads the address of byteArray into EBX.\n\n    . . .\n\nmov( al, [ebx+2] );    // Stores al into byteArray[2]\n```", "```\nmov( [ebx+ecx*1], al );             // EBX is base address, ecx is index.\n\nmov( wordArray[ecx*2], ax );        // wordArray is base address, ecx is index.\n\nmov( dwordArray[ebx+ecx*4], eax );  // Effective address is combination \n\n                                    // of offset(dwordArray)+ebx+(ecx*4).\n```"]