- en: '**3**'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**RECONNAISSANCE**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, I show you how to search subscriptions for useful data, such
    as what storage accounts it uses, its SQL databases, the virtual machines it contains,
    and any network firewalls in place.
  prefs: []
  type: TYPE_NORMAL
- en: Like other large cloud service providers, Azure offers a growing list of services,
    ranging from web hosting to databases, secret key storage, and machine learning.
    With so many offerings, it can be hard to determine which services and features
    a given customer is taking advantage of, and if any of them are configured in
    a vulnerable way.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will demonstrate how Azure’s PowerShell cmdlets and command
    line tools can be used to quickly examine the contents of a subscription. We start
    by authenticating to Azure in the console. Next, we enumerate a subscription’s
    web services, followed by its virtual machines. We then get a list of the subscription’s
    storage accounts and their access keys, followed by any internet-facing network
    ports and firewalls. Then we look at SQL servers and databases.
  prefs: []
  type: TYPE_NORMAL
- en: By enumerating these services, you’ll be able to include all of your client’s
    resources in your pentest, ensuring that nothing is overlooked. This is crucial
    because when requesting an assessment, customers may focus on production services
    but forget to mention test resources where security controls may be lax. Similarly,
    documenting the contents of storage accounts can help clients determine if they
    are following proper data classification and storage practices.
  prefs: []
  type: TYPE_NORMAL
- en: After reviewing some powerful individual commands for commonly used Azure services,
    I present scripts that are ideal for scanning any new subscription you compromise.
  prefs: []
  type: TYPE_NORMAL
- en: '**Installing PowerShell and the Azure PowerShell Module**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you begin, you need to install a few free tools from Microsoft. On Windows,
    PowerShell and the Azure PowerShell module are the most straightforward tools
    for gathering subscription information. Another option are the Azure Command Line
    Interface (CLI) tools, which are offered for Windows, Linux, and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: '***On Windows***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You have two ways to install these tools on Windows. If you’d like both the
    PowerShell cmdlets and the command line interface, along with the ability to update
    the tools whenever new versions are released, use the Microsoft Web Platform Installer
    (WebPI). This small package manager makes it easy to install a number of Microsoft
    tools, including those used to manage Azure. WebPI also checks for missing dependencies,
    so if you don’t already have PowerShell installed, it will take care of that for
    you.
  prefs: []
  type: TYPE_NORMAL
- en: To use WebPI, simply download the installer from *[https://www.microsoft.com/web/downloads/platform.aspx](https://www.microsoft.com/web/downloads/platform.aspx)*
    and run it. Once it’s installed, search for Web Platform Installer in the Start
    menu and launch the application.
  prefs: []
  type: TYPE_NORMAL
- en: You can use WebPI’s search box to find Microsoft Azure PowerShell and Microsoft
    Azure Cross-platform Command Line Tools (see [Figure 3-1](part0012.html#ch03fig1)).
    Then click **Add** to download and install the tools. If multiple versions of
    a tool are returned, choose the most recent release. (You can launch WebPI again
    to check for updates to the packages.)
  prefs: []
  type: TYPE_NORMAL
- en: After running the installer, close any open PowerShell and command line windows
    to be sure that the tools are recognized.
  prefs: []
  type: TYPE_NORMAL
- en: '***On Linux or macOS***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you are running Linux or macOS, you’ll need to install the Azure Command
    Line Cross-platform Tools package. There are two versions of this package—one
    written in Node.js and one in Python. I use the Node.js versions in my examples,
    but both versions use similar syntax, so feel free to use either one. You’ll find
    installer packages for the Node.js version in DMG format for macOS and TAR format
    for Linux at *[https://github.com/azure/azure-xplat-cli/](https://github.com/azure/azure-xplat-cli/)*.
    The Python version can be downloaded from *[https://github.com/azure/azure-cli/](https://github.com/azure/azure-cli/)*.
    Install these as you would any other package on your platform.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: Using Microsoft’s Web Platform Installer to locate and install
    Azure tools*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Running Your Tools***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once you’ve installed your tools, launch them. For the PowerShell module, open
    a PowerShell window and at the prompt, run Import-Module Azure. For the command
    line tools, open a terminal window and enter azure (or az if using the Python
    version). If the command line tools are properly installed, you should see a help
    message like the one shown in [Figure 3-2](part0012.html#ch03fig2).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: The help message for the Azure command line tools*'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you should have everything you need to begin connecting to Azure.
    Let’s start gathering information about our target subscriptions and their services.
  prefs: []
  type: TYPE_NORMAL
- en: '**Service Models**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall from [Chapter 2](part0011.html#ch02) that Microsoft uses two different
    service models in Azure, each with its own set of commands to view or change services.
    For every service discussed in this chapter, I provide the syntax for querying
    both Azure Resource Manager (ARM) and Azure Service Management (ASM), unless a
    service is exclusive to just one model.
  prefs: []
  type: TYPE_NORMAL
- en: The PowerShell module includes both ARM and ASM cmdlets. To help keep things
    organized, commands for ASM services are typically named *Verb*-Azure*Noun*, such
    as `Get-AzureVM`, whereas ARM commands are *Verb*-Azure**Rm***Noun*, such as `Get-AzureRmVM`.
  prefs: []
  type: TYPE_NORMAL
- en: The command line tools take a different approach. Instead of using different
    commands for each service model, you can place the `azure` executable into either
    ARM or ASM mode, and it will stay in that state until the mode is switched.
  prefs: []
  type: TYPE_NORMAL
- en: To determine the currently selected mode, view the last line of output when
    `azure` is run with no other options. To switch modes, run azure config mode asm
    to target the ASM model or run azure config mode arm to target the ARM model.
    [Listing 3-1](part0012.html#ch03list1) shows the output of Azure CLI when switching
    modes, as well as the last line of the Azure command to confirm the current mode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-1: Switching and verifying modes in Azure CLI*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Best Practices: PowerShell Security**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since its official release in 2006, PowerShell has grown in popularity, capability,
    and maturity. Originally a scripting language to perform basic Windows management,
    PowerShell is now the de facto way to manage a wide variety of Microsoft products
    and services, which of course includes Azure. Because it offers so many features,
    PowerShell has also been attractive for hackers. As a system administrator or
    defender, you need to be aware of a number of settings to ensure that PowerShell
    remains secure on your systems. As we’ve already seen, a compromised workstation
    could lead to Azure subscription access, so securing endpoints is important!
  prefs: []
  type: TYPE_NORMAL
- en: First, enable PowerShell logging, and make sure this data is forwarded to your
    security auditing solution. Not only will this increase the speed of detecting
    an attacker leveraging PowerShell in your environment, it will give the defenders
    a clear picture of what actions were taken by the attacker. Forwarding events
    also makes it harder for an attacker to tamper with event logs.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Microsoft’s Lee Holmes published an excellent article on all the ways in which
    the PowerShell team has engineered blue team capabilities into PowerShell. You
    can find it at* [https://blogs.msdn.microsoft.com/powershell/2015/06/09/powershell-the-blue-team/](https://blogs.msdn.microsoft.com/powershell/2015/06/09/powershell-the-blue-team/)*.*'
  prefs: []
  type: TYPE_NORMAL
- en: Second, be aware that PowerShell supports remote sessions and remote command
    execution, using the WS-Management protocol on TCP ports 5985 and 5986\. Additionally,
    now that PowerShell has been ported to Linux, remote PowerShell commands can also
    be executed over SSH (TCP port 22). PowerShell remoting is typically enabled by
    default on Windows Server installations but disabled on workstations. All forms
    of PowerShell remoting require authentication, and usually an account with membership
    in the administrators group is required to connect. Although remote PowerShell
    makes management of large quantities of remote systems easier, it can also lead
    to illegitimate access if administrator accounts aren’t closely guarded or if
    remoting permissions are made too broad. A discussion of PowerShell remoting security
    can be found at *[https://docs.microsoft.com/en-us/powershell/scripting/setup/winrmsecurity/](https://docs.microsoft.com/en-us/powershell/scripting/setup/winrmsecurity/)*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, consider using PowerShell security features such as constrained language
    mode. When in use, constrained language mode greatly reduces the ability to arbitrarily
    run some of the more powerful operations in PowerShell, without impairing the
    ability to run properly signed scripts. This way, if an attacker does gain access
    to a PowerShell session on a system, they won’t be able to utilize many of the
    tools or scripts they’d like to run. A great introduction to constrained language
    mode is available at *[https://blogs.msdn.microsoft.com/powershell/2017/11/02/powershell-constrained-language-mode/](https://blogs.msdn.microsoft.com/powershell/2017/11/02/powershell-constrained-language-mode/)*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Authenticating with the PowerShell Module and CLI**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To gather details about any services in Azure, you first need to authenticate.
    The authentication process varies depending on the type of credential (username
    and password, service principal, or management certificate), the service model,
    and the tool being used (Azure CLI or PowerShell). [Table 3-1](part0012.html#ch03tab1)
    shows, for each credential type, which service model/tool pairs you can use to
    authenticate. Note that not every combination of these options is possible.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-1:** Supported Authentication Methods by Service Model and Tool'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tool/interface** | **Username and password** | **Management certificate**
    | **Service principal with password** | **Service principal with certificate**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Azure CLI – ASM mode | Supported | Partially supported | Not supported |
    Not supported |'
  prefs: []
  type: TYPE_TB
- en: '| Azure CLI – ARM mode | Supported | Not supported | Supported | Supported
    |'
  prefs: []
  type: TYPE_TB
- en: '| Azure PowerShell ASM cmdlets | Supported | Supported | Not supported | Not
    supported |'
  prefs: []
  type: TYPE_TB
- en: '| Azure PowerShell ARM cmdlets | Supported | Not supported | Supported | Supported
    |'
  prefs: []
  type: TYPE_TB
- en: '| *[http://portal.azure.com/](http://portal.azure.com/)* | Supported | Not
    supported | Not supported | Not supported |'
  prefs: []
  type: TYPE_TB
- en: '| *[http://manage.windowsazure.com/](http://manage.windowsazure.com/)* | Supported
    | Not supported | Not supported | Not supported |'
  prefs: []
  type: TYPE_TB
- en: As you can see, a username and password pair is accepted by each Azure management
    interface. Authenticating with a username and password pair has a few other advantages
    as well. For one, once authenticated, you probably won’t need to know what subscriptions
    a given user has access to, because you can use their password to sign in to either
    of the Azure web interfaces to see a list of their subscriptions. In contrast,
    the command line interfaces expect you to specify the target subscription when
    executing a command.
  prefs: []
  type: TYPE_NORMAL
- en: Usernames and passwords are easier to use than management certificates and service
    principals. Each tool will present a login prompt that accepts a password. If
    the user doesn’t have multi-factor authentication enabled, you’re good to go.
    Authentication with management certificates or service principals might require
    a series of commands. Let’s take a look at how to authenticate with them.
  prefs: []
  type: TYPE_NORMAL
- en: '**Authenticating with Management Certificates**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When authenticating with management certificates, you need to know the subscription
    ID you plan to target. As you know from the scoping discussion in [Chapter 1](part0010.html#ch01),
    this shouldn’t be a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, your certificate needs to be in the management certificate list for
    the target subscription for authentication to succeed. The best way to determine
    where a given certificate can be used is through educated guessing and trial and
    error. In other words, if a certificate came from a developer’s machine who owns
    one subscription, or if the certificate is checked into a code repository for
    a service that you know runs in your target subscription, there’s a very good
    chance it will work. Luckily, trying a certificate and finding it doesn’t work
    doesn’t really have a downside. Although the failed connection attempt may be
    logged somewhere, I’ve yet to encounter such a log, and in practice, no subscription
    owner has ever detected my attempts to penetrate their subscription because I
    tried the wrong certificate.
  prefs: []
  type: TYPE_NORMAL
- en: '***Installing the Certificate***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In order to use the certificate, you first need to install it into your computer’s
    certificate store. To do so, double-click the certificate file and walk through
    the wizard. The certificate location doesn’t matter, but if you choose to place
    it in the Local Machine store, you need to run subsequent commands with administrative
    (User Account Control–elevated) rights.
  prefs: []
  type: TYPE_NORMAL
- en: '***Authenticating***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The PowerShell script shown in [Listing 3-2](part0012.html#ch03list2) authenticates
    to a subscription using a certificate. This allows you to run subsequent commands
    against the subscription, using this certificate as your credential.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-2: Authenticating to Azure using management certificates in PowerShell*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what’s happening in [Listing 3-2](part0012.html#ch03list2), step by
    step:'
  prefs: []
  type: TYPE_NORMAL
- en: To authenticate with a management certificate, we need to retrieve it from the
    certificate store. We first specify that the certificate is installed in the *Personal*
    directory (*My*) ➊, within the `LocalMachine` store ➋ (as opposed to the `CurrentUser`
    store). If you installed it elsewhere, be sure to use the programmatic name for
    that location, which you can find on Microsoft’s website at *[https://msdn.microsoft.com/en-us/library/windows/desktop/aa388136(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/aa388136(v=vs.85).aspx)*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We then request a list of certificates in that location and place it into the
    variable `$certs` ➌.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see the list of certificates available, we execute the variable as a command
    ➍. The output tells us that the only certificate installed is *AzureCert*, and
    it lists the certificate’s *thumbprint* as well (“8D9 . . . 1D3”). The thumbprint
    uniquely identifies a certificate.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we get a reference to the certificate object with the `Get-Item` cmdlet,
    using the thumbprint to select the correct certificate ➎.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see if you have a usable certificate, issue the certificate variable name
    as a command to ensure that a certificate was retrieved, as shown at ➏. If you
    see an empty response, something went wrong with the `Get-Item` command and you
    should double-check that you entered the values at ➎ correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we see if the certificate we’ve found has the associated private key
    with `HasPrivateKey` ➐. Without the private key, you won’t be able to use it to
    connect to the subscription.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Connecting and Validating Access***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With the certificate ready to use, try to connect to the subscription. You
    can do so by using two commands: `Set-AzureSubscription` followed by `Select-AzureSubscription`.
    In the former command, you specify the name of the subscription, subscription
    ID, and the certificate variable ➑. If you don’t know the name of the subscription,
    just make something up. Now, because you may have access to numerous subscriptions,
    use the `Select-AzureSubscription` cmdlet to specify the subscription that PowerShell
    should run subsequent commands against. Note that the name here must match the
    one specified in the set command.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, if the certificate was valid for that subscription, you should
    have access. To confirm, run Get-AzureAccount ➒. If the subscription is listed,
    you should now be able to run any other Azure ASM commands against the subscription
    to view and interact with its ASM resources.
  prefs: []
  type: TYPE_NORMAL
- en: Azure CLI technically supports management certificates in its ASM mode, but
    it fails in practice to properly load certificates. The workaround is to use a
    *.publishsettings* file instead of a certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because *.publishsettings* files are just XML documents embedded with base64-encoded
    management certificates and subscription IDs (as discussed in [Chapter 2](part0011.html#ch02)),
    you can manually create one given the certificate and subscription ID. The steps
    to do so are a bit lengthy; fortunately, software developer and Microsoft MVP
    Gaurav Mantri has posted sample code to automate the process: *[http://gauravmantri.com/2012/09/14/about-windows-azure-publish-settings-file-and-how-to-create-your-own-publish-settings-file/](http://gauravmantri.com/2012/09/14/about-windows-azure-publish-settings-file-and-how-to-create-your-own-publish-settings-file/)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have a *.publishsettings* file, run the following to add the credential
    to Azure CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run a command to verify that the credential works, such as `azure vm
    list`. If you see the error `We don''t have a valid access token`, the credential
    did not work. Upon successful authentication, you should see `info: vm list command
    OK`, even if the subscription contains no virtual machines.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Best Practices: Service Principals**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Service principals replace management certificates as the preferred way for
    apps, scripts, and services to programmatically access and manage Azure resources.
    There are several security advantages to using service principals over management
    certificates.
  prefs: []
  type: TYPE_NORMAL
- en: The most notable improvement with service principals is their ability to have
    a limited scope of permissions. By default, a service principal is created for
    use with a single application and can be granted the specific rights it needs
    to perform its function. Following the principle of least privilege, test which
    rights are actually needed for your application; don’t just give it access to
    everything, as this would allow an attacker to wreak havoc if the service principal
    was compromised.
  prefs: []
  type: TYPE_NORMAL
- en: Also, service principals can be created with either a long, automatically generated
    password (referred to as its *client secret*) or a certificate for authentication.
    When you create a service principal with a password, the client secret value is
    displayed only once, and you cannot view it again after navigating away from that
    page in the portal. (It can be regenerated if needed, though.) As such, the page
    encourages you to record the value. Be sure that this value is stored in a secure
    place, such as Key Vault or a password manager. Avoid storing it in a source control
    repository, as this makes it hard to control or track who has access as well as
    who has viewed it, and it’s difficult to remove from version history. Secrets
    stored in source code are a common source of breaches. Likewise, never store such
    secrets in a plaintext file, even temporarily.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, be sure to document the purpose of all service principals you create
    and periodically review the service principals with permissions to your resources.
    As applications are retired, it’s easy to forget to remove old service principals;
    cleaning up old accounts reduces the attack surface of the subscription and its
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: '**Authenticating with Service Principals**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Recall from [Chapter 2](part0011.html#ch02) that service principals are the
    Azure-based equivalent of service accounts found in most companies’ domains. Just
    as in on-premises environments, these accounts are used when a service needs to
    run regularly—that is, independent of a particular administrator’s account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure provides two authentication options for these accounts: passwords and
    certificates. However, service principals are more restrictive than regular accounts
    or management certificates. Because service principals are tied to a particular
    application, they usually only have rights to what that application needs to access.
    Additionally, service principals check for password expiration or certificate
    validity (depending on the authentication method you use), so a captured credential
    can’t be used indefinitely.'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFENDER’S TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: Because service principals can’t use multi-factor authentication, they may pose
    a greater risk than standard user accounts that use a second factor during authentication.
    Although service principals do have long, auto-generated passwords or strong certificate-based
    keys, which help to mitigate the risk of brute-forcing and password-guessing attacks,
    to be safe, you should make sure your service principals only have the minimum
    amount of privileges needed to perform their duties. Additionally, it’s far better
    to use several service principals, each dedicated to performing a specific task
    with a small set of rights, than to have one service principal with full control
    over everything in a subscription. Sure, the initial setup will be a bit more
    complex, but the security benefits are worth it.
  prefs: []
  type: TYPE_NORMAL
- en: '***Using Service Principals with Passwords***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: To connect as a service principal with a password, you’ll need the service principal’s
    GUID (usually referred to as a client ID or application ID), its password (also
    called a *key* in the Azure portal), and the tenant ID of the Azure Active Directory
    instance where that service principal is defined (another GUID). You’ll most likely
    find the tenant ID where you discovered the client ID and password, since any
    program using the service principal would also need this value. Once you have
    these values, you should be able to authenticate in PowerShell or Azure CLI, as
    discussed next.
  prefs: []
  type: TYPE_NORMAL
- en: '**PowerShell**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In PowerShell, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `Get-Credential` cmdlet should open a dialog with space for you to enter
    a username and password. Enter the application ID value as the username and the
    key as the password ➊. On the next line, save the tenant ID as a variable ➋ and
    then pass both values into `Add-AzureRmAccount` ➌. If you have it, you can also
    specify a subscription using the `-SubscriptionID` parameter of `Add-AzureRmAccount`,
    though this will return an error if the service principal doesn’t have rights
    to any resources in the subscription.
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure CLI**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To authenticate in Azure CLI with a password-based service principal, make
    sure Azure CLI is in ARM mode and then run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This command will not display any output, so use azure resource list to see
    if it worked and to show existing resources. If the credential doesn’t work, it
    should display an error.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Generally, I surround argument values passed in to various commands with double
    quotes, such as the username and password values here. This isn’t required if
    the input provided doesn’t contain spaces; however, because Azure allows spaces
    in many of its fields, such as service names, it’s safer to assume that the input
    has a space and to wrap it in double quotes.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Authenticating with X.509 Certificates***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Service principals can also be authenticated with X.509 certificates. To do
    this in PowerShell, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to specify the thumbprint of the certificate you plan to use ➊, instead
    of a password, and enter the service principal ID (application ID) on the command
    line ➋ because there will be no prompt for a credential. The tenant ID ➌ is the
    same as in password-based authentication. For the `Add-AzureRMAccount` command,
    replace the `-Credential` switch with the `-CertificateThumbprint` switch ➍.
  prefs: []
  type: TYPE_NORMAL
- en: '**Best Practices: Subscription Security**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Subscription owners can take a number of steps to reduce the attack surface
    of their subscription and increase their awareness of changes in it. This includes
    keeping the number of highly privileged users in the subscription to a minimum,
    limiting the rights of nonhuman accounts, enabling auditing, limiting the scope
    of services in each subscription, and using JIT and Azure PIM (as described in
    “[Best Practices: Protecting Privileged Accounts](part0011.html#lev37)” on [page
    26](part0011.html#page_26)) to protect the remaining accounts.'
  prefs: []
  type: TYPE_NORMAL
- en: First, a subscription is only as secure as its weakest administrator. Therefore,
    it is crucial to require users to select strong passwords and enforce multi-factor
    authentication on all subscription user accounts. Limiting the number of users
    with access to the subscription also reduces the odds of compromised user accounts
    or computers being used for successful attacks against a subscription.
  prefs: []
  type: TYPE_NORMAL
- en: Next, look at the number of nonhuman accounts with access to the subscription,
    including management certificates, service accounts, and service principals. Administrators
    often feel less accountability for these accounts, particularly if they are shared
    among multiple people.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, auditing plays a key role in tracking access to subscriptions,
    identifying anomalies, and providing accountability for actions taken against
    the subscription. Without audit logs, defenders will have a very difficult time
    determining how an adversary gained access and what actions they took in the event
    of a breach. Microsoft has thorough documentation describing the types of logging
    available in Azure, and how to enable it, at *[https://docs.microsoft.com/en-us/azure/monitoring-and-diagnostics/monitoring-overview-activity-logs/](https://docs.microsoft.com/en-us/azure/monitoring-and-diagnostics/monitoring-overview-activity-logs/)*.
  prefs: []
  type: TYPE_NORMAL
- en: Another consideration is the scope of services running within a subscription.
    Some companies are tempted to provision just a few subscriptions and put multiple
    workloads in each, but this can exacerbate the too-many-administrators issue.
    It can also lead to the creation of confusing security permissions to keep everyone
    limited to their own resources (or worse, permissions that give everyone free
    rein over everything in the subscription). I suggest using a separate subscription
    for each major project, and potentially different subscriptions for development,
    pre-production, and production deployments. For particularly sensitive resources,
    such as a Key Vault hosting critical secrets, it might make sense to place them
    in their own subscription.
  prefs: []
  type: TYPE_NORMAL
- en: To assist in making these changes and ensuring that a subscription does not
    slip back into insecurity over time, Microsoft has released a subscription and
    resource security automation toolkit known as the Secure DevOps Kit. We’ll cover
    this in depth in [Chapter 8](part0017.html#ch08).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, consider using Azure PIM, so accounts only have administrative rights
    in the subscription when those privileges are needed. PIM also allows for additional
    auditing when those rights are used. For more details, see “[Best Practices: Protecting
    Privileged Accounts](part0011.html#lev37)” on [page 26](part0011.html#page_26).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gathering Subscription Information**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you’re signed in, you can begin gathering information about the subscription
    and its services. The data you gather will help determine where to perform deeper
    investigation. The first thing to gather from any subscription is data about the
    subscription itself, such as the name of the subscription and what accounts have
    access to it. This information often allows you to determine what a subscription
    is used for, and you can get some clues as to how best to pivot into other subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: When gathering this data, begin by listing the currently selected subscription.
    That listing should provide you with the name of the current subscription and
    its subscription ID. The subscription name is often quite informative. For example,
    it may contain a team or project name, such as “Human Resources – Production Site”
    or “E-Commerce Test Environment.” Additionally, confirm that the subscription
    ID is one you were expecting and that it is in scope for your assessment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list the current ASM subscription in PowerShell, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This command should return a `PSAzureSubscription` object and display the subscription
    name, subscription ID, the Azure Active Directory tenant ID, and the account you
    are connected with. It should also display the environment, which is the type
    of Azure cloud where this subscription is hosted. For example, AzureCloud is the
    default commercial version of Azure, whereas AzureUSGovernment is a separate instance
    of Azure just for US government use.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Some countries with unique privacy and data laws, like Germany and China,
    have their own clouds. You can find a list of cloud environments and their management
    URLs by running* Get-AzureEnvironment*.*'
  prefs: []
  type: TYPE_NORMAL
- en: To view current subscription information for ARM subscriptions in PowerShell,
    you can run the `Get-AzureRmContext` cmdlet. This command should return a `PSAzureContext`
    object, which is a container that holds `PSAzureRmAccount`, `PSAzureEnvironment`,
    `PSAzureSubscription`, and `PSAzureTenant` objects. In other words, its output
    should let you drill into specific details of the tenant, subscription, and account
    you are using.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put a variable name and an equals sign before the context command so its output
    will be saved into a variable you can reference later, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, enter the variable name again, followed by a dot, followed by the data
    you want to drill into (`Account`, `Environment`, `Subscription`, or `Tenant`)
    to return all the available information for that object. For example, you could
    run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*It can be tricky to remember what options you can use on a given object represented
    by a variable. Fortunately, PowerShell has autocomplete. Just type the variable
    name, followed by a dot, and then press TAB to show the first possible option.
    Keep pressing TAB to cycle through possible options. When you reach to the one
    you want, press ENTER to run it. Alternatively, you can use the* Get-Member *cmdlet
    to see all possible values.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run this cmdlet to show which users have ARM access and their privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To view all possible ARM roles, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you’re using the Azure command line tools, run
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: to see the current subscription. Although the CLI won’t display the current
    user account, it should show the subscription ID and name, as well as the environment
    and the tenant ID, if available. It should also show whether you’re connected
    using a certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the CLI in ARM mode to display accounts that have access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also show all available roles, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '***Viewing Resource Groups***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Resource groups* were added in ARM as a way to assemble a set of services
    into one package for easier management. For example, a website might consist of
    the web pages themselves, along with a SQL database to store user profiles, and
    an instance of Application Insights (a telemetry service for applications). In
    ASM, each of these items was managed separately, and it was often difficult to
    tell which services were related. Resource groups allow you to monitor all related
    services, see how much a given deployment costs to run, assign permissions to
    all services in a group at once, and even delete everything in a group in one
    place. (Resource groups also help with reconnaissance by giving you a jumpstart
    in understanding these relationships and evaluating the potential importance of
    a given service.)'
  prefs: []
  type: TYPE_NORMAL
- en: Resource groups pose two challenges, however. The first is that some developers
    might not understand how to use resource groups and simply create a new group
    for each service, even for related ones. Because resource groups are a management
    convenience, and not a security boundary, nothing prevents services in different
    groups from interacting with one another.
  prefs: []
  type: TYPE_NORMAL
- en: Second, when you’re investigating a given service, the ARM PowerShell cmdlets
    usually have the resource group as a required parameter, as does Azure CLI when
    in ARM mode. This can be frustrating, because you may know the name of a resource
    but not in which resource group it resides. To determine this, you’ll need to
    use separate commands to enumerate the groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the resource groups for a subscription using PowerShell, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In Azure CLI, run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Each command will show all resource groups in a subscription, but not which
    services are in these groups. It can be tedious running the enumeration commands
    on a subscription with dozens or even hundreds of groups. Fortunately, you can
    list all ARM resources in a subscription, along with their resource group and
    their service type, at a high level. To get the resource list in ARM PowerShell,
    run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In Azure CLI, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The output of these commands can get pretty ugly, so put it in a spreadsheet
    and use it as a guide to make sure your investigation doesn’t miss anything.
  prefs: []
  type: TYPE_NORMAL
- en: '***Viewing a Subscription’s App Services (Web Apps)***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When a company decides to move some of its services to the cloud, its website
    is often an easy first step. After all, most or all of that data is already public,
    so the confidentiality concerns often associated with storing data on remote servers
    are greatly reduced. Additionally, websites can take advantage of the auto-scaling
    features of Platform as a Service (PaaS) cloud providers to increase capacity
    during busy times such as new product launches and holiday shopping.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft initially called these sites *Web Apps* in the old management interface,
    but has moved their management entirely to the new portal and renamed them *App
    Services*. The new portal also offers a gallery of pre-built web service templates—everything
    from blogs to e-commerce platforms. One benefit of this migration is that even
    apps deployed under the ASM model are viewable from the ARM PowerShell cmdlets
    and the ARM mode of the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using PowerShell**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To view the Web Apps in a subscription using PowerShell, run Get-AzureRmWebApp
    with no parameters. The legacy `Get-AzureWebsite` will return the site list. Both
    commands allow you to pass the name of a site as a parameter to get additional
    details. Try the ASM version of the command because it returns details that the
    ARM version leaves out on classic websites. [Listing 3-3](part0012.html#ch03list3)
    shows an example of this output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-3: Output from the* Get-AzureWebsite *PowerShell cmdlet*'
  prefs: []
  type: TYPE_NORMAL
- en: After retrieving the names of any Azure websites and their URLs ➊, pass the
    name of a site you are interested in to `Get-AzureWebsite` using `-Name` ➋. Some
    of the details that `Get-AzureWebsite` provides but that `Get-AzureRmWebApp` omits
    are the version of .NET ➌ and PHP ➍ the site is running, as well as the username
    ➎ and password ➏ of the account used to publish site content. These values are
    clearly useful to an attacker because they can make it possible to look for known
    PHP and .NET exploits based on version. They also provide the ability to modify
    site content.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the CLI in ASM**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can retrieve similar data using the CLI. In ASM mode, use the command azure
    site list to see a listing of all subscription websites, and then run
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: to see a given site’s details. The detailed output isn’t as thorough as the
    PowerShell cmdlet; instead, many of the details get their own command, such as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To see all of these options, run azure help site.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the CLI in ARM**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In ARM mode, the CLI requires you to provide the resource group of the website
    in ARM mode, even if you simply want to enumerate a list of sites. Start with
    a list of resource groups, using azure group list. Then, once you have the list
    of groups, run azure webapp list "group_name" for each resource group. From there,
    run the following to see detailed information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As with the ASM CLI, some details are hidden behind additional subcommands.
    To see these options, enter azure help webapp.
  prefs: []
  type: TYPE_NORMAL
- en: '***Gathering Information on Virtual Machines***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As the quintessential *Infrastructure as a Service (IaaS)* role, virtual machines
    (VMs) are one of the most frequently encountered services in an Azure subscription.
    In terms of management, Azure actually breaks down VMs into several components,
    which are all configured separately with different commands. I’ll discuss how
    to get information about the VM container itself and then show you how to get
    at the VM’s hard disk image and network settings.
  prefs: []
  type: TYPE_NORMAL
- en: '**Viewing a List of VMs**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Unlike App Services, virtual machines are segregated by service model, with
    classic VMs only appearing in the ASM cmdlets and ARM VMs appearing exclusively
    in the ARM cmdlets. Running `Get-AzureVM` in PowerShell returns a list of ASM-based
    VMs, including each VM’s service name, name, and status. For a detailed status
    report for a VM, use the service name parameter of the cmdlet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This report should include information like the VM’s IP address, DNS address,
    power state, and the “size” of the VM.
  prefs: []
  type: TYPE_NORMAL
- en: '**WHAT VM PRICING TIERS REVEAL ABOUT TARGETS**'
  prefs: []
  type: TYPE_NORMAL
- en: VM sizes map to a particular set of hardware allowances for the VM and a monthly
    cost. For example, an A0 VM has 768MB of memory, 20GB of hard drive space, one
    CPU core, and one network interface, whereas a D14 VM has 112GB of memory, 800GB
    of SSD-based storage, 16 CPU cores, and up to eight network interfaces. The specifications
    for each tier can be found at *[https://docs.microsoft.com/en-us/azure/virtual-machines/virtual-machines-windows-sizes/](https://docs.microsoft.com/en-us/azure/virtual-machines/virtual-machines-windows-sizes/)*,
    and current pricing is available from *[https://azure.microsoft.com/en-us/pricing/details/cloud-services/](https://azure.microsoft.com/en-us/pricing/details/cloud-services/)*.
  prefs: []
  type: TYPE_NORMAL
- en: These details can be critical because they provide some indication of the importance,
    workload, or value of the VM. Test VMs are often in the A0–A3 range, whereas production
    VMs are often in the higher-level D tier. Also, specialty tiers such as N provide
    dedicated hardware-based Nvidia graphics processors (GPUs) directly to the VM.
    These are used for computationally intensive work, such as rendering animations
    (or, for us penetration testers, cracking passwords).
  prefs: []
  type: TYPE_NORMAL
- en: '**Viewing a List of ARM VMs in PowerShell**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To get a list of ARM VMs in PowerShell, use the `Get-AzureRmVM` cmdlet with
    no parameters. This should return each VM in the subscription, along with its
    resource group’s name, region, and size.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-4](part0012.html#ch03list4) shows how to get the details of an ARM
    VM in PowerShell.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-4: Obtaining details for an ARM VM in PowerShell*'
  prefs: []
  type: TYPE_NORMAL
- en: The first command gets the details of the VM and saves them into the variable
    `$vm` ➊. Next, we dump the information stored in the variable ➋ and show the VM
    size ➌. This information is available in the initial VM enumeration from `Get-AzureRmVM`,
    but it’s nice to have it inline with the rest of the details of the specific VM
    when reading the output later.
  prefs: []
  type: TYPE_NORMAL
- en: Now we dump the OS profile block ➍, which includes the administrator’s username
    (sadly, the password is usually omitted). Finally, we display the image reference
    information from the storage profile ➎. This tells us the base image of the VM,
    which often includes version details—in this case, Ubuntu Server version 16.04
    Long Term Support (LTS) edition.
  prefs: []
  type: TYPE_NORMAL
- en: '**Collecting Information with the CLI**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To collect this information from the CLI in ASM mode, use azure vm list to enumerate
    the classic VMs in the subscription and then use azure vm show "name" on each
    VM to see its details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the CLI in ARM mode is almost identical for VMs—the enumeration command
    is also `azure vm list`. The only change is that, in order to show the details
    of a VM, ARM mode also requires the resource group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Unlike PowerShell, this will display all the details at once, including the
    username, VM size, and OS version.
  prefs: []
  type: TYPE_NORMAL
- en: '***Finding Storage Accounts and Storage Account Keys***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Azure Storage is the primary place to store data in Microsoft’s cloud. Storage
    accounts offer four types of data storage, and any given storage account can have
    any or all of these types in use at a time. *Blob storage* is used to hold unstructured
    data, including files and large binary steams. *File storage* is just like blob
    storage, except that it offers direct Server Message Block (SMB) access to files.
    (This is convenient because blob storage has traditionally required the use of
    either complicated APIs or third-party tools to access its contents. I’ll cover
    how to use these tools to extract data in [Chapter 4](part0013.html#ch04).) *Table
    storage* is a scalable, NoSQL tabular dataset container. Finally, *queues* hold
    transient messages for ordered, asynchronous processing.
  prefs: []
  type: TYPE_NORMAL
- en: Many other services rely on storage accounts to host their underlying data,
    including virtual machines. The Virtual Hard Disk (VHD) files used in VMs are
    stored here as blobs. Other services, such as Azure Websites, Machine Learning,
    and Activity Log, can use a storage account to hold their log files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your reconnaissance should answer two main questions about storage accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: Which storage accounts are available in the target subscription?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are their keys?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answering the first question is straightforward, as long as you remember that
    classic (ASM-based) storage accounts and ARM-based storage accounts are completely
    separate in Azure, so remember to look for both types. To check for classic storage
    accounts in PowerShell, use the `Get-AzureStorageAccount` cmdlet without any parameters
    to list all ASM storage accounts in the subscription. The equivalent command in
    Azure CLI is `azure storage account list`. Both commands will show the storage
    account name, its type (whether its data is redundant in one datacenter, one region,
    or multiple regions), and its location (the datacenter where the data is being
    stored, such as Central US). The PowerShell command also provides some additional
    details, such as the URLs used for the account, but this information can be obtained
    from the CLI with the `azure storage account show "`account_name`"` command.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for ARM storage accounts is equally easy. In the CLI, the same commands
    you use for ASM work for ARM (once the CLI mode is switched). For PowerShell,
    the command is `Get-AzureRmStorageAccount`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you’ll need the storage account keys to access data within Azure Storage.
    Azure assigns two base64-encoded, 64-byte keys to each storage account. They’re
    labeled “primary” and “secondary,” but you can use either. Having two keys simultaneously
    allows administrators to rotate keys without bringing down their service by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Updating their service’s configuration to go from using the primary to the secondary
    key
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the Azure portal to generate a new primary key
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating their service to switch from the secondary to the new primary key
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You won’t have too much trouble obtaining these keys. Because the same key (or
    same two keys) is used for every service that accesses that storage account, administrators
    need a way to easily retrieve the key again and again, each time they add or update
    a service. Additionally, because the key is used everywhere and doesn’t expire
    unless a new key is generated, most administrators never change it, since following
    the preceding three steps for multiple services can be tedious.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFENDER’S TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing how to properly reset a leaked or otherwise compromised credential is
    critical to a speedy remediation if a security incident arises. Understanding
    authentication dependencies is equally important in order to minimize disruptions
    that could result from credential changes. It is therefore wise to practice resetting
    or “rolling” any type of credential used by your organization regularly, and to
    make optimizations as needed, so that you can reset credentials promptly and accurately
    during a real attack. Storage keys or SSL private keys are no different—practice
    switching between primary and secondary keys in all of your services during development
    and in production to make sure you’ve properly documented every place where the
    keys need to be replaced.
  prefs: []
  type: TYPE_NORMAL
- en: Because the keys need to be retrievable, Azure exposes them via the portal,
    PowerShell, and CLI. To get the both the primary and secondary keys for an ASM
    storage account in PowerShell, run
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To do the same in ARM PowerShell, use this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In the CLI, getting the ASM keys is easy; just execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'For some reason, the ARM CLI command to get the keys behaves differently from
    all other ARM CLI commands. It requires the resource group name of the storage
    account, but it doesn’t accept the group name as a parameter on the command line;
    therefore, as in ASM mode, you’ll need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As soon as you run this command, you’ll be prompted to provide the resource
    group name. Enter it at the prompt and then the keys should be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Gathering Information on Networking**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Networking is one of the more complex parts of Azure because it involves IP
    address assignments, firewall rules, virtual networks, and virtual private networks
    (VPNs). It can even involve a dedicated circuit between a business and Azure,
    known as an ExpressRoute. An ExpressRoute connection is essentially a dedicated
    wide area network (WAN) link that allows a company to treat resources running
    in Azure as a part of its internal corporate network. During this phase of the
    operation, I focus on simply enumerating the commonly used networking features:
    network interfaces (IP addresses), endpoints (ports), and network security groups
    (firewalls). I cover more advanced topics in [Chapter 6](part0015.html#ch06).'
  prefs: []
  type: TYPE_NORMAL
- en: '***Network Interfaces***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Network interfaces* are the virtual network cards associated with ARM-based
    virtual machines. In classic VMs, they are just called *IP addresses*. Each VM
    usually has two IP addresses—an internal, non-internet-facing address for connecting
    to other services in the subscription, and an internet-facing public IP or virtual
    IP address. Obtaining these IPs directly from Azure is very beneficial for a penetration
    tester because having them allows for port scanning and other directed attacks
    against virtual machines, without having to scan an entire address range looking
    for devices. It also ensures that the scans stay in scope, because public IP addresses
    in Azure’s space can be dynamically reassigned to other Azure customers.'
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*If you already have Azure portal or API access, why would you need to perform
    external scans against the IP addresses of VMs? During a penetration test, customers
    usually want a number of attack vectors examined, from insider threats to internet-based
    “script kiddies.” Although an insider or nation state may be able to breach your
    client’s network and gain portal access, lesser-skilled attackers probably cannot,
    so it’s important to perform more traditional security assessments of anything
    exposed to the internet. Additionally, Azure does not offer console-type access
    to VMs from the portal. All access to the VM must be made through its network
    interface using remote management services like Remote Desktop Protocol or SSH.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFENDER’S TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: All services on the internet are subject to near-constant port and vulnerability
    scanning, brute-force password guessing, and other attacks. There are even websites
    like Shodan (*[https://www.shodan.io/](https://www.shodan.io/)*) that index port
    scan data and make it publicly searchable. Whenever possible, try to mitigate
    these attacks by turning off management services not in use, restricting access
    to them through IP restrictions, and keeping VMs on private VLANs, shielded from
    the internet.
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing Internal IPs Used by Classic VMs**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To obtain a list of internal IPs used by classic VMs, simply run Get-AzureVM
    or azure vm show. The internal IP should be included in the ASM output of both
    of these commands. Conversely, ARM’s CLI `vm show` command will show only the
    public IP by default. [Table 3-2](part0012.html#ch03tab2) describes which IPs
    are displayed by the VM commands.
  prefs: []
  type: TYPE_NORMAL
- en: '**Table 3-2:** IP Addresses Displayed by Tool'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Command (mode)** | **Internal IP** | **Public IP** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `azure vm show` (ASM) | Shown | Shown |'
  prefs: []
  type: TYPE_TB
- en: '| `azure vm show` (ARM) | Not shown | Shown |'
  prefs: []
  type: TYPE_TB
- en: '| `Get-AzureVM` (ASM) | Shown | Not shown |'
  prefs: []
  type: TYPE_TB
- en: '| `Get-AzureRmVM` (ARM) | Not shown | Not shown |'
  prefs: []
  type: TYPE_TB
- en: 'For ASM VMs, the CLI’s `azure vm show` command is a one-stop shop for obtaining
    IP addresses. To use the CLI in ARM mode to show a list of all network interfaces,
    enter azure network nic list. This should display the interface’s name, resource
    group, MAC address, and location. Here’s how to use it to display details for
    a specific NIC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The output should also display details such as the IP address, whether it is
    static or dynamic, and its associated VM or service.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get dynamically assigned public IP information for a given VM from
    the ASM PowerShell cmdlets, you will need to list the VM’s endpoints, as discussed
    in the next section. That said, if the subscription has any reserved (static)
    public IP addresses for ASM resources, the command `Get-AzureReservedIP` with
    no switches should list them, as well as the service to which they are tied.
  prefs: []
  type: TYPE_NORMAL
- en: And finally, to view IPs for ARM resources in PowerShell, use `Get-AzureRmNetworkInterface`
    to display all the NICs in use in the subscription for ARM resources, though this
    will display only private IPs. To view the public IPs, use the `Get-AzureRmPublicIpAddress`
    cmdlet, which should show any ARM resources using a public IP, the IP address,
    and whether the address is dynamically or statically assigned.
  prefs: []
  type: TYPE_NORMAL
- en: '**Querying Endpoints with Azure Management Tools**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Once you know the IP addresses within a subscription, you should determine the
    ports available at those IPs. In classic Azure VMs, a network port is referred
    to as an *endpoint*—a service running on a host. For ARM VMs, port management
    has been rolled into firewall management, but ASM maintains them separately. Let’s
    look at how to enumerate ASM endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although you could run a port scanner such as Nmap to gather this information,
    doing so has several drawbacks:'
  prefs: []
  type: TYPE_NORMAL
- en: ASM-based VMs put Remote Desktop Protocol (RDP) on random, high-numbered ports,
    so you’d need to scan all 65,535 ports to be sure you find the right ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because the scan would take place over the internet, it would be considerably
    slower than similar scans on a local network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A subscription could have dozens, or even hundreds, of hosts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’d only find internet-facing ports allowed through the firewall, not any
    services that may be exposed only to other hosts in the subscription or within
    Azure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For these reasons, it’s faster and more thorough to query the ports directly
    using Azure management tools. To query endpoints in PowerShell, use `Get-AzureEndpoint`,
    as shown in [Listing 3-5](part0012.html#ch03list5). You must run it for each classic
    VM and give it a PowerShell `IPersistentVM` object instead of the name of a virtual
    machine. The `Get-AzureVM` cmdlet returns an object of this type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-5: Obtaining endpoints for an ASM VM in PowerShell*'
  prefs: []
  type: TYPE_NORMAL
- en: At ➊, we obtain a VM object using the VM’s service name and store it in a variable.
    Next, we pass that object into the `Get-AzureEndpoint` cmdlet ➋, which should
    return the port the server is listening on ➌, the name of the endpoint ➍ (often
    the name of the service being used, such as SSH, RDP, or HTTP), the port exposed
    to the internet that is forwarded to the local port ➎, and the endpoint’s virtual
    IP address ➏. The VIP is the public IP address of the VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Azure CLI also allows you to list endpoints in ASM mode. To get a listing
    of endpoints with a particular VM name, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You only need to run this command once for each VM to see all its endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: '***Obtaining Firewall Rules or Network Security Groups***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It can be really helpful to collect information on a VM’s network settings from
    Azure’s firewall rules because they dictate which ports for a given VM are accessible,
    and from where. These rules are separate from the VM’s operating system–based
    firewall and act like the port-forwarding settings on a router. Azure calls these
    firewall filters *Network Security Groups (NSG)* in ARM and *Network Security
    Groups (classic)* for ASM.
  prefs: []
  type: TYPE_NORMAL
- en: '**Viewing ASM-based NSGs with PowerShell**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'For various reasons, classic VMs often don’t use NSGs. Nevertheless, it’s worth
    knowing how to list both classic and ARM-based NSGs, because knowing whether a
    firewall is in place can help avoid unnecessary port scanning, and you might even
    report a lack of firewalls in your findings to your client. In PowerShell, you
    can list classic NSG names and locations with `Get-AzureNetworkSecurityGroup`
    and no arguments. To view the rules inside a specific classic NSG, use the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To view the details of every classic NSG, run this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the output of this command won’t map the NSG back to a virtual
    machine. To do so, get the VM object for the target virtual machine and then run
    the following to display the NSG associated with that VM (you’ll see an error
    if the VM doesn’t use an NSG):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '**Viewing ASM-based NSGs with the CLI**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Azure CLI can also show classic NSG settings. To see all classic NSGs in ASM
    mode, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the rules in an NSG, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: I have yet to find a way to map the association between an NSG and a virtual
    machine using the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: '**Viewing ARM-based NSGs with PowerShell**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Run Get-AzureRmNetworkSecurityGroup to view ARM-based NSGs with PowerShell.
    This should return every ARM NSG’s name, resource group, region, and rules. This
    includes rules defined by the subscription administrator as well as rules that
    Azure automatically creates, such as “Allow outbound traffic from all VMs to internet.”
    It can be helpful to see all these rules (after all, the removal of the “allow
    outbound traffic to the internet” rule could block your command-and-control traffic
    on a compromised VM), but if you prefer, you can see only the custom rules for
    a particular NSG with `Get-AzureRmNetworkSecurityRuleConfig`.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use PowerShell to get the mapping of an ARM virtual machine to an
    ARM NSG, you’ll need to find the interface for the desired VM and then look up
    the NSG for that interface. You could nest all of the following commands into
    one single line, but to improve readability and avoid mistakes, I usually break
    it into a series of commands, as shown in [Listing 3-6](part0012.html#ch03list6).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-6: Finding a Network Security Group for a given VM in PowerShell*'
  prefs: []
  type: TYPE_NORMAL
- en: At ➊, we get the VM object and put it in a variable. At ➋, we perform a lookup
    to obtain the Network Interface object for that VM, using the VM’s Network Interface
    ID property. Finally, we display the NSG using the Network Security Group identifier
    stored in the Network Interface object ➌. Aside from replacing the VM resource
    group and name on the first line, you can run everything else exactly as shown
    here.
  prefs: []
  type: TYPE_NORMAL
- en: '**Viewing ARM-based NSGs with the CLI**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The CLI commands for viewing NSGs in ARM mode are almost identical to those
    for ASM. The only difference is that the ARM command to show a specific NSG requires
    the resource group name: `azure network nsg show "`Resource_Group_Name`" "`NSG_Name`"`.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Viewing Azure SQL Databases and Servers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: SQL is frequently found in Azure, not only because many websites based in Azure
    require it, but because installing SQL on an on-premises server can be slow and
    has dozens of potentially confusing configuration options. However, it takes only
    minutes to set up Azure SQL (the name of Microsoft’s cloud-based SQL solution).
  prefs: []
  type: TYPE_NORMAL
- en: Azure SQL is separated into SQL servers and SQL databases. Although a database
    lives within an Azure SQL server instance, the two items are managed individually—a
    separation that might surprise experienced SQL administrators.
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing Azure SQL Servers**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To list the SQL servers in a subscription (including database server name, location,
    username of the administrator account, and version), run Get-AzureSqlDatabaseServer
    with no parameters. Once you have the server information, run
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: to see the names, sizes, and creation dates of every database within that server.
  prefs: []
  type: TYPE_NORMAL
- en: '**Viewing Azure SQL Firewall Rules**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To view any firewall rules applied to Azure SQL, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: By default, Azure prevents access to Azure SQL servers, except from other Azure
    services. Although this is great for security, it frustrates developers who want
    to connect to databases from their workstations. In fact, this was such a hassle
    that SQL Server Management Studio (the tool used to manage SQL databases) added
    a prompt during sign-on to Azure SQL servers that offers to automatically add
    the user’s current IP address to the firewall rules. Not surprisingly, this annoys
    developers whose IP addresses change frequently, so you will often find firewall
    rules in Azure SQL that allow connections from any IP address in the world, or
    at least anywhere within a company’s network. Check the firewall to see what hosts
    you can use to bypass the firewall and target the SQL server directly.
  prefs: []
  type: TYPE_NORMAL
- en: '**SQL ARM PowerShell Cmdlets**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The ARM PowerShell extension has dozens more SQL-related commands than ASM PowerShell
    does, though most deal with less common features or are simply not relevant to
    a penetration tester. Perhaps the biggest hurdle with ARM, though, is that the
    resource group field of the `Get-AzureRmSqlServer` cmdlet is required. Fortunately,
    although this would normally mean that in order to see all the SQL servers you
    would need to run the command for each resource group in the subscription, PowerShell
    provides a shortcut. Simply pipe the output of `Get-AzureRmResourceGroup` to `Get-AzureRmSqlServer`,
    and you should see all the SQL servers, as shown in [Listing 3-7](part0012.html#ch03list7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-7: Finding ARM-based SQL servers in PowerShell*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listing Databases in a Server**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'PowerShell provides an ARM command to show all the databases within a SQL server,
    including the size, creation date, and region. To list the databases in a server,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To view SQL firewall rules for ARM, as well as the starting and ending IP addresses
    for each rule and its name, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, consider running the following to see if Azure’s threat detection
    tool is in operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This tool monitors for attacks such as SQL injection. You will want to know
    if it’s running before launching a test that might trigger alerts.
  prefs: []
  type: TYPE_NORMAL
- en: '**DEFENDER’S TIP**'
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to take advantage of Azure’s security features. Regularly check to make
    sure that no one has added an allow-all rule to your SQL firewall, and enable
    new security features when they are added, such as SQL Threat Detection (*[https://docs.microsoft.com/en-us/azure/sql-database/sql-database-threat-detection/](https://docs.microsoft.com/en-us/azure/sql-database/sql-database-threat-detection/)*
    ). Although no feature can guarantee the complete security of your system, each
    added control provides another layer of protection and makes an attack against
    your services that much harder. Make it hard enough that the attacker decides
    to go target someone else.
  prefs: []
  type: TYPE_NORMAL
- en: '**Using the CLI for Azure SQL**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: You can use the CLI to gather information on Azure SQL, but keep in mind that
    it only offers SQL commands when in ASM mode. Also, the command to list databases
    within a SQL server instance requires the database account credentials, and there
    is no command to view the state of SQL Threat Detection (or any of the advanced
    SQL commands available in ARM PowerShell).
  prefs: []
  type: TYPE_NORMAL
- en: To use CLI to view SQL servers within a subscription, including the database
    name and the datacenter where it is hosted, run azure sql server list. Then run
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'to view additional details such as the database administrator username and
    server version. Finally, to check the firewall rules, enter azure sql firewallrule
    list. You can display a specific firewall rule with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '**Consolidated PowerShell Scripts**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: During a penetration test, I often have limited time to gather data, either
    because I have dozens of subscriptions to review or because I’m using a legitimate
    user’s system or credentials and the longer I use it, the greater the chance of
    my being detected. Therefore, I like having all the commands I need in one place
    in easy-to-run scripts.
  prefs: []
  type: TYPE_NORMAL
- en: In the sections that follow, I present scripts for both ASM PowerShell and ARM
    PowerShell. It’s important to have both handy because credentials that work in
    one subscription model might not work in the other. Also, not all systems will
    have the ARM cmdlets installed. When not constrained by either limitation, I usually
    run both scripts. There’s always some duplication, but it’s better to get more
    information than to miss something.
  prefs: []
  type: TYPE_NORMAL
- en: I haven’t provided a script for the CLI tools because the PowerShell output
    is much easier to work with in scripting form. Also, you’re far less likely to
    be detected when penetration testing if you’re using the same tools your target
    uses. Most developers will have the Azure PowerShell extensions installed; far
    fewer will install the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: You can download both scripts from the book’s website at *[https://nostarch.com/azure/](https://nostarch.com/azure/)*.
    You may, of course, need to customize them for your particular scenario, adding
    authentication and such. (I find it’s easiest to launch a PowerShell window, authenticate
    with the credentials I have obtained, and then kick off the script.) You may also
    need to run the `Set-ExecutionPolicy -Scope Process Unrestricted` command so the
    system can run unsigned scripts, if you haven’t done so already in this PowerShell
    window.
  prefs: []
  type: TYPE_NORMAL
- en: '***ASM Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The script shown in [Listing 3-8](part0012.html#ch03list8) iterates over the
    common ASM resources in a subscription and then displays information about those
    services. It uses all the ASM PowerShell commands discussed in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-8: Consolidated ASM PowerShell reconnaissance script*'
  prefs: []
  type: TYPE_NORMAL
- en: '***ARM Script***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Listing 3-9](part0012.html#ch03list9) shows the ARM version of [Listing 3-8](part0012.html#ch03list8).
    It’s slightly longer than the ASM version because it gathers more details about
    the subscription, VMs, and network interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-9: Consolidated ARM PowerShell reconnaissance script*'
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to check the book’s website (*[https://nostarch.com/azure/](https://nostarch.com/azure/)*)
    for updated versions of these scripts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I’ve covered a wide range of commands that you can use to understand how an
    Azure subscription is being used. I explained where to obtain Azure’s PowerShell
    and command line tools. I discussed various authentication methods to be used
    based on the type of credential you have captured. I showed how to discover websites,
    virtual machines, storage accounts, network settings, and SQL databases in a subscription.
    Finally, I provided you with scripts you can use to quickly query these services.
  prefs: []
  type: TYPE_NORMAL
- en: 'I see these techniques as indispensable for any thorough penetration test,
    as they help to draw a better picture of your client’s overall attack surface:
    non-production systems can often be used as a foothold to access production resources,
    yet they are often ignored in risk assessments. By including the entire subscription
    in your test, and not just those resources that are deemed most critical, you
    can significantly improve the value provided to your client.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I’ll demonstrate some useful techniques for exploiting
    Azure Storage accounts.
  prefs: []
  type: TYPE_NORMAL
