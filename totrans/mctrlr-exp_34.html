<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="app09"><span epub:type="pagebreak" id="page_405"/><strong>I  Other Chips</strong></h2>&#13;
<h3 class="h3" id="app09_1"><strong>I.1 PAL Truth Tables</strong></h3>&#13;
<p class="noindent">Programmable array logic (PAL) and generic array logic (GAL) devices were early technologies for programmable logic that predate CPLD and FPGA devices. Programming methods were often unique to the brand of the chip, while the pinout and functionality were compatible between vendors. These days, they are mostly dumped for retrocomputing emulation and repair projects.</p>&#13;
<p class="indent">DuPAL is an open suite of tools for PAL reverse engineering, available as Battaglia (2020). It consists of a hardware board with an Atmega chip for applying inputs and sampling outputs of a PAL chip, and GUI tools in Java that can export observations or test potential chip configurations.</p>&#13;
<p class="indent">DuPAL does not read the raw memory out of the chip, so it is limited to states that can be externally observed from inputs and outputs. This gets confusing when output values are fed back as inputs, sometimes with a delay for synchronous logic.</p>&#13;
<p class="indent">Surply (2015) describes the use of an Arduino Uno to dump the truth table of a PAL16L8 chip from a pinball machine. The truth tables were too large to reduce with Karnaugh mapping, but Surply was able to use the Quine-McCluskey method in the form of Niels Serup’s Electruth library for Python to minimize the PAL’s truth table in a few hours, revealing the address space of the machine’s many I/O ports.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_406"/><img id="chIfig1" src="../images/f0406-01.jpg" alt="Image" width="777" height="883"/></div>&#13;
<p class="figcap">Figure I.1: MMI PAL16R6B</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_407"/>It’s also possible to dump these chips visually. PALs mark truth table bits with electromigration fuses. These work by running too much current through a very thin metal trace, causing the metal to flow along the path of the current, which breaks the trace.</p>&#13;
<h3 class="h3" id="app09_2"><strong>I.2 Mifare Classic Gate Recovery</strong></h3>&#13;
<p class="noindent">Nohl et al. (2008) describes a successful reverse engineering of a then-secret cryptographic algorithm used by NXP’s Mifare Classic RFID tags. The chip, shown in <a href="app09.xhtml#chIfig2">Figure I.2</a>, is barely a millimeter square, available in 1K and 4K versions.</p>&#13;
<p class="indent">Nohl required both surface and delayered photographs for this recovery, then used edge detection and pattern matching to recognize the standard-cell library of the chip. Though there are many thousands of gates on the chip, there are only seventy or so unique logic cells. The gate tileset has been published as SRL (2012b).</p>&#13;
<p class="indent">Of the six chip layers, the upper ones obscured cell identification. These were removed by mechanical polishing rather than through chemical etching. Images were then stitched with Hugin, and as Degate had not yet been written, custom Matlab scripts were used to perform standard cell identification.</p>&#13;
<p class="indent">After the Mifare Classic was reverse engineered, Plötz and Nohl (2011) followed with details of reverse engineering the Legic Prime RFID tag. The authors dumped their custom Matlab scripts for Degate, and published their tile set as SRL (2012a).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_408"/><img id="chIfig2" src="../images/f0408-01.jpg" alt="Image" width="777" height="769"/></div>&#13;
<p class="figcap">Figure I.2: Mifare Classic</p>&#13;
</div>
</div>
</body></html>