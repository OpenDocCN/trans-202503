<html><head></head><body>
<h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_189"/><span class="big">4</span><br/>BINARY AND DATA REPRESENTATION</h2>&#13;
<div class="imagec"><img alt="image" src="../images/common.jpg"/></div>&#13;
<p class="noindents">From simple stone tablets and cave paintings to written words and phonograph grooves, humans have perpetually sought to record and store information. In this chapter, we’ll characterize how the latest of humanity’s big storage breakthroughs, digital computing, represents information. We also illustrate how to interpret meaning from digital data.</p>&#13;
<p class="indent">Modern computers utilize a variety of media for storing information (e.g., magnetic disks, optical discs, flash memory, tapes, and simple electrical circuits). We characterize storage devices later in Section 11.2; however, for this discussion, the medium is largely irrelevant—whether there’s a laser scanning the surface of a DVD or a disk head gliding over a magnetic platter, the output from the storage device is ultimately a sequence of electrical signals. To simplify the circuitry, each signal is <em>binary</em>, meaning that it can take only one of two states: the absence of a voltage (interpreted as zero) and the presence of a voltage (one). This chapter explores how systems encode information into binary, regardless of the original storage medium.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_190"/>In binary, each signal corresponds to one <em>bit</em> (binary digit) of information: a zero or a one. It may be surprising that all data can be represented using just zeros and ones. Of course, as the complexity of information increases, so does the number of bits needed to represent it. Luckily, the number of unique values doubles for each additional bit in a bit sequence, so a sequence of <em>N</em> bits can represent 2<sup><em>N</em></sup> unique values.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch4fig1">Figure 4-1</a> illustrates the growth in the number of representable values as the length of a bit sequence increases. A single bit can represent <em>two</em> values: 0 and 1. Two bits can represent <em>four</em> values: both of the one-bit values with a leading 0 (00 and 01), and both of the one-bit values with a leading 1 (10 and 11). The same pattern applies for any additional bit that extends an existing bit sequence: the new bit can be a 0 or 1, and in either case, the remaining bits represent the same range of values they did prior to the new bit being added. Thus, adding additional bits exponentially increases the number of values the new sequence can represent.</p>&#13;
<div class="imagec" id="ch4fig1"><img alt="image" src="../images/04fig01.jpg"/></div>&#13;
<p class="figcap"><em>Figure 4-1: The values that can be represented with one to four bits. The underlined bits correspond to the prefix coming from the row above.</em></p>&#13;
<p class="indent">Because a single bit doesn’t represent much information, storage systems commonly group bits into longer sequences for storing more interesting values. The most ubiquitous grouping is a <em>bytes</em>, which is a collection of eight bits. One byte represents 2<sup>8</sup> = 256 unique values (0–255)—enough to enumerate the letters and common punctuation symbols of the English language. Bytes are the smallest unit of addressable memory in a computer system, meaning that a program can’t ask for fewer than eight bits to store a variable.</p>&#13;
<p class="indent">Modern CPUs also typically define a <em>word</em> as either 32 bits or 64 bits, depending on the design of the hardware. The size of a word determines the “default” size a system’s hardware uses to move data from one component to another (e.g., between memory and registers). These larger sequences are necessary for storing numbers, since programs often need to count higher than 256! If you’ve programmed in C, you know that you must declare a <span epub:type="pagebreak" id="page_191"/>variable before using it (see “Variables and C Numeric Types” on <a href="ch01.xhtml#lev3_2">page 21</a>). Such declarations inform the C compiler of two important properties regarding the variable’s binary representation: the number of bits to allocate for it, and the way in which the program intends to interpret those bits. Conceptually, the number of bits is straightforward, as the compiler simply looks up how many bits are associated with the declared type (e.g., a <span class="literal">char</span> is one byte—see “C Numeric Types” on <a href="ch01.xhtml#lev3_2">page 23</a>) and associates that amount of memory with the variable. The interpretation of a sequence of bits is much more conceptually interesting. All data in a computer’s memory is stored as bits, but bits have no <em>inherent</em> meaning. For example, even with just a single bit, you could interpret the bit’s two values in many different ways: up and down, black and white, yes and no, on and off, etc.</p>&#13;
<p class="indent">Extending the length of a bit sequence expands the range of its interpretations. For example, a <span class="literal">char</span> variable uses the American Standard Code for Information Interchange (ASCII) encoding standard, which defines how an eight-bit binary value corresponds to English letters and punctuation symbols. <a href="ch04.xhtml#ch4tab1">Table 4-1</a> shows a small subset of the ASCII standard (for a full reference, run <span class="literal">man ascii</span> on the command line). There’s no special reason why the character <span class="literal">’X’</span> needs to correspond to 01011000, so don’t bother memorizing the table. What matters is that every program storing letters agrees on their bit sequence interpretation, which is why ASCII is defined by a standards committee.</p>&#13;
<p class="tabcap" id="ch4tab1"><strong>Table 4-1:</strong> A Small Snippet of the Eight-Bit ASCII Character Encoding Standard</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:30%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Binary value</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Character interpretation</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Binary value</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Character interpretation</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">01010111</p></td>&#13;
<td style="vertical-align: top"><p class="tab">W</p></td>&#13;
<td style="vertical-align: top"><p class="tab">00100000</p></td>&#13;
<td style="vertical-align: top"><p class="tab">space</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">01011000</p></td>&#13;
<td style="vertical-align: top"><p class="tab">X</p></td>&#13;
<td style="vertical-align: top"><p class="tab">00100001</p></td>&#13;
<td style="vertical-align: top"><p class="tab">!</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">01011001</p></td>&#13;
<td style="vertical-align: top"><p class="tab">Y</p></td>&#13;
<td style="vertical-align: top"><p class="tab">00100010</p></td>&#13;
<td style="vertical-align: top"><p class="tab">"</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">01011010</p></td>&#13;
<td style="vertical-align: top"><p class="tab">Z</p></td>&#13;
<td style="vertical-align: top"><p class="tab">00100011</p></td>&#13;
<td style="vertical-align: top"><p class="tab">#</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Any information can be encoded in binary, including rich data like graphics and audio. For example, suppose that an image encoding scheme defines 00, 01, 10, and 11 to correspond to the colors white, orange, blue, and black. <a href="ch04.xhtml#ch4fig2">Figure 4-2</a> illustrates how we might use this simple two-bit encoding strategy to draw a crude image of a fish using only 12 bytes. In part (a), each cell of the image equates to one two-bit sequence. Parts (b) and (c) show the corresponding binary encoding as two-bit and byte sequences, respectively. Although this example encoding scheme is simplified for learning purposes, the general idea is similar to what real graphics systems use, albeit with many more bits for a wider range of colors.</p>&#13;
<span epub:type="pagebreak" id="page_192"/>&#13;
<div class="imagec" id="ch4fig2"><img alt="image" src="../images/04fig02.jpg"/></div>&#13;
<p class="figcap"><em>Figure 4-2: The (a) image representation, (b) two-bit cell representation, and (c) byte representation of a simple fish image.</em></p>&#13;
<p class="indent">Having just introduced two encoding schemes, the same bit sequence, 01011010, might mean the character <span class="literal">’Z’</span> to a text editor, whereas a graphics program might interpret it as part of a fish’s tail fin. Which interpretation is correct depends on the context. Despite the underlying bits being the same, humans often find some interpretations much easier to comprehend than others (e.g., perceiving the fish as colored cells rather than a table of bytes).</p>&#13;
<p class="indent">The remainder of this chapter largely deals with representing and manipulating binary numbers, but the overall point bears repeating: all information is stored in a computer’s memory as 0s and 1s, and it’s up to programs or the people running them to interpret the meaning of those bits.</p>&#13;
<h3 class="h3" id="lev1_28">4.1 Number Bases and Unsigned Integers</h3>&#13;
<p class="noindent">Having seen that binary sequences can be interpreted in all sorts of nonnumerical ways, let’s turn our attention to numbers. Specifically, we’ll start with <em>unsigned</em> numbers, which can be interpreted as zero or positive, but they can never be negative (they have no <em>sign</em>).</p>&#13;
<h4 class="h4" id="lev2_61">4.1.1 Decimal Numbers</h4>&#13;
<p class="noindent">Rather than starting with binary, let’s first examine a number system we’re already comfortable using, the <em>decimal number system</em>, which uses a <em>base</em> of 10. <em>Base 10</em> implies two important properties for the interpretation and representation of decimal values.</p>&#13;
<p class="indent">First, any individual digit in a base 10 number stores one of 10 unique values (0–9). To store a value larger than 9, the value must <em>carry</em> to an additional digit to the left. For example, if one digit starts at its maximum value (9) and we add 1 to it, the result requires two digits (9 + 1 = 10). The same pattern holds for any digit, regardless of its position within a number (e.g., 50<strong>8</strong>0 + <strong>2</strong>0 = 5<strong>10</strong>0).</p>&#13;
<p class="indent">Second, the position of each digit in the number determines how important that digit is to the overall value of the number. Labeling the digits from <em>right to left</em> as <em>d</em><sub>0</sub>, <em>d</em><sub>1</sub>, <em>d</em><sub>2</sub>, etc., each successive digit contributes a factor of <em>ten</em> more than the next. For example, take the value 8425 (<a href="ch04.xhtml#ch4fig3">Figure 4-3</a>).</p>&#13;
<span epub:type="pagebreak" id="page_193"/>&#13;
<div class="imagec" id="ch4fig3"><img alt="image" src="../images/04fig03.jpg"/></div>&#13;
<p class="figcap"><em>Figure 4-3: The importance of each digit in a base 10 number, using names that you may have given to each digit in grade school.</em></p>&#13;
<p class="indent">For the example value 8425, the 5 in the “ones” place contributes 5 (5 × 10<sup>0</sup>). The 2 in the “tens” place contributes 20 (2 × 10<sup>1</sup>). The 4 in the “hundreds” place contributes 400 (4 × 10<sup>2</sup>), and, finally, the 8 in the “thousands” place contributes 8000 (8 × 10<sup>3</sup>). More formally, one could express 8425 as</p>&#13;
<p class="center">(8 × 10<sup>3</sup>) + (4 × 10<sup>2</sup>) + (2 × 10<sup>1</sup>) + (5 × 10<sup>0</sup>)</p>&#13;
<p class="indent">This pattern of increasing exponents applied to a base of 10 is the reason why it’s called a <em>base 10</em> number system. Assigning position numbers to digits from right to left starting with <em>d</em><sub>0</sub> implies that each digit <em>d</em><sub><em>i</em></sub> contributes 10<sup><em>i</em></sup> to the overall value. Thus, the overall value of any <em>N</em>-digit decimal number can be expressed as</p>&#13;
<p class="center">(<em>d</em><sub><em>N</em>–1</sub> × 10<sup><em>N</em>–1</sup>) + (<em>d</em><sub><em>N</em>–2</sub> × 10<sup><em>N</em>–2</sup>) + … + (<em>d</em><sub>2</sub> × 10<sup>2</sup>) + (<em>d</em><sub>1</sub> × 10<sup>1</sup>) + (<em>d</em><sub>0</sub> × 10<sup>0</sup>)</p>&#13;
<p class="indent">Fortunately, as we’ll soon see, a very similar pattern applies to other number systems.</p>&#13;
<p class="note"><strong><span class="black">Note</span> DISTINGUISHING NUMBER BASES</strong></p>&#13;
<p class="note1">Now that we’re about to introduce a second number system, one potential problem is a lack of clarity regarding how to interpret a number. For example, consider the value 1000. It’s not immediately obvious whether you should interpret that number as a decimal value (i.e., one thousand) or a binary value (i.e., eight, for reasons explained soon). To help clarify, the remainder of this chapter will explicitly attach a prefix to all nondecimal numbers. We’ll soon introduce binary, for which the prefix is 0b, and hexadecimal, which uses a prefix of 0x.</p>&#13;
<p class="note1">Therefore, if you see 1000, you should assume it’s a decimal “one thousand,” and if you see 0b1000, you should interpret it as a binary number, in this case the value “eight.”</p>&#13;
<h4 class="h4" id="lev2_62">4.1.2 Unsigned Binary Numbers</h4>&#13;
<p class="noindent">While you may never have considered the specific formula describing decimal numbers as powers of 10, the concept of {<em>ones</em>, <em>tens</em>, <em>hundreds</em>, etc.} places should hopefully feel comfortable. Luckily, similar terminology applies to other number systems, like binary. Of course, the base is different in <span epub:type="pagebreak" id="page_194"/>other number systems, so each digit position contributes a different amount to its numerical value.</p>&#13;
<p class="indent">A <em>binary number system</em> uses a base of 2 instead of decimal’s 10. Analyzing it the same way that we just did for decimal reveals several parallels (with 2 substituted for 10).</p>&#13;
<p class="indent">First, any individual bit in a base 2 number stores one of two unique values (0 or 1). To store a value larger than 1, the binary encoding must <em>carry</em> to an additional bit to the left. For example, if one bit starts at its maximum value (1) and we add 1 to it, the result requires two bits (1 + 1 = 0b10). The same pattern holds for any bit, regardless of its position within a number (e.g., 0b100<strong>1</strong>00 + 0b<strong>1</strong>00 = 0b10<strong>10</strong>00).</p>&#13;
<p class="indent">Second, the position of each bit in the number determines how important that bit is to the numerical value of the number. Labeling the digits from <em>right to left</em> as <em>d</em><sub>0</sub>, <em>d</em><sub>1</sub>, <em>d</em><sub>2</sub>, etc., each successive bit contributes a factor of <em>two</em> more than the next.</p>&#13;
<p class="indent">The first point implies that counting in binary follows the same pattern as decimal: by simply enumerating the values and adding digits (bits). Since this section focuses on <em>unsigned</em> numbers (zero and positives only), it’s natural to start counting from zero. <a href="ch04.xhtml#ch4tab2">Table 4-2</a> shows how to count the first few natural numbers in binary. As you can see from the table, counting in binary quickly increases the number of digits. Intuitively, this growth makes sense, since each binary digit (two possible values) represents less information than a decimal digit (10 possible values).</p>&#13;
<p class="tabcap" id="ch4tab2"><strong>Table 4-2:</strong> A Comparison of Counting in Binary versus Decimal</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Binary value</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Decimal value</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">10</p></td>&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">11</p></td>&#13;
<td style="vertical-align: top"><p class="tab">3</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">100</p></td>&#13;
<td style="vertical-align: top"><p class="tab">4</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">101</p></td>&#13;
<td style="vertical-align: top"><p class="tab">5</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">...</p></td>&#13;
<td style="vertical-align: top"><p class="tab">...</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">The second point about labeling digits looks really familiar! In fact, it’s so similar to decimal that it leads to a nearly identical formula for interpreting a binary number. Simply replace the 10 at the base of each exponent with a 2:</p>&#13;
<p class="center">(<em>d</em><sub><em>N</em>–1</sub> × 2<sup><em>N</em>–1</sup>) + (<em>d</em><sub><em>N</em>–2</sub> × 2<sup><em>N</em>–2</sup>) + … + (<em>d</em><sub>2</sub> × 2<sup>2</sup>) + (<em>d</em><sub>1</sub> × 2<sup>1</sup>) + (<em>d</em><sub>0</sub> × 2<sup>0</sup>)</p>&#13;
<p class="indent">Applying this formula yields the <em>unsigned</em> interpretation of any binary number. For example, take 0b1000:</p>&#13;
<p class="center">(1 × 2<sup>3</sup>) + (0 × 2<sup>2</sup>) + (0 × 2<sup>1</sup>) + (0 × 2<sup>0</sup>) = 8 + 0 + 0 + 0 = 8</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_195"/>Here’s a longer one-byte example, 0b10110100:</p>&#13;
<p class="center">(1 × 2<sup>7</sup>) + (0 × 2<sup>6</sup>) + (1 × 2<sup>5</sup>) + (1 × 2<sup>4</sup>) + (0 × 2<sup>3</sup>) + (1 × 2<sup>2</sup>) + (0 × 2<sup>1</sup>) + (0 × 2<sup>0</sup>) = 128 + 0 + 32 + 16 + 0 + 4 + 0 + 0 = 180</p>&#13;
<h4 class="h4" id="lev2_63">4.1.3 Hexadecimal</h4>&#13;
<p class="noindent">Thus far, we’ve examined two number systems, decimal and binary. Decimal is notable due to its comfort for humans, whereas binary matches the way data is stored in hardware. It’s important to note that they are equivalent in their expressive power. That is, there’s no number you can represent in one system that you can’t represent in the other. Given their equivalence, it may surprise you that we’re going to discuss one more number system: the base 16 <em>hexadecimal</em> system.</p>&#13;
<p class="indent">With two perfectly good number systems, you may wonder why we need another. The answer is primarily convenience. As shown in <a href="ch04.xhtml#ch4tab2">Table 4-2</a>, binary bit sequences quickly grow to a large number of digits. Humans tend to have a tough time making sense of long sequences containing only 0’s and 1’s. And whereas decimal is more compact, its base of 10 is a mismatch with binary’s base 2.</p>&#13;
<p class="indent">Decimal doesn’t easily capture the range that can be expressed using a fixed number of bits. For example, suppose that an old computer uses 16-bit memory addresses. It’s valid addresses range from 0b0000000000000000 to 0b1111111111111111. Represented in decimal, the addresses range from 0 to 65535. Clearly, the decimal representations are more compact than the long binary sequences, but unless you memorize their conversions, it’s more difficult to reason about the decimal numbers. Both problems only get worse on modern devices, which use 32- or 64-bit addresses!</p>&#13;
<p class="indent">These long bit sequences are where hexadecimal’s base 16 shines. The large base allows each digit to represent enough information for hexadecimal numbers to be compact. Furthermore, because the base is itself a power of two (2<sup>4</sup> = 16), it’s easy to map hexadecimal to binary, and vice versa. For the sake of completeness, let’s analyze hexadecimal in the same way as decimal and binary.</p>&#13;
<p class="indent">First, any individual digit in a base 16 number stores one of 16 unique values. Any more than 10 values presents a new challenge for hexadecimal—traditional base 10 digits stop at a maximum value of 9. By convention, hexadecimal uses letters to represent values larger than 9, with A for 10, B for 11, up to F for 15. Like the other systems, to store a value larger than 15, the number must <em>carry</em> to an additional digit to the left. For example, if one digit starts at its maximum value (F) and we add 1 to it, the result requires two digits (0xF + 0x1 = 0x10; note that we use 0x to indicate hexadecimal numbers).</p>&#13;
<p class="indent">Second, the position of each digit in the number determines how important that digit is to the numerical value of the number. Labeling the digits <span epub:type="pagebreak" id="page_196"/>from <em>right to left</em> as <em>d</em><sub>0</sub>, <em>d</em><sub>1</sub>, <em>d</em><sub>2</sub>, etc., each successive digit contributes a factor of 16 more than the next.</p>&#13;
<p class="indent">Unsurprisingly, the same trusty formula for interpreting a number applies to hexadecimal, with 16 as the base:</p>&#13;
<p class="center">(<em>d</em><sub><em>N</em>–1</sub> × 16<sup><em>N</em>–1</sup>) + (<em>d</em><sub><em>N</em>–2</sub> × 16<sup><em>N</em>–2</sup>) + … + (<em>d</em><sub>2</sub> × 16<sup>2</sup>) + (<em>d</em><sub>1</sub> × 16<sup>1</sup>) + (<em>d</em><sub>0</sub> × 16<sup>0</sup>)</p>&#13;
<p class="indent">For example, to determine the decimal value of 0x23C8:</p>&#13;
<div class="imagec"><img alt="image" src="../images/f0196-01.jpg"/></div>&#13;
<p class="note"><strong><span class="black">Warning</span> HEXADECIMAL MISCONCEPTION</strong></p>&#13;
<p class="note-w">You may not encounter hexadecimal numbers frequently as you’re first learning about systems programming. In fact, the only context where you’re likely to find them is in representing memory addresses. For example, if you print the address of a variable using the <span class="literal">%p</span> (pointer) format code for <span class="literal">printf</span>, you’ll get hexadecimal output.</p>&#13;
<p class="note-w">Many students often begin to equate memory addresses (e.g., C pointer variables) with hexadecimal. While you may get used to seeing addresses represented that way, keep in mind that <em>they are still stored using binary in the hardware</em>, just like all other data!</p>&#13;
<h4 class="h4" id="lev2_64">4.1.4 Storage Limitations</h4>&#13;
<p class="noindent">Conceptually, there are infinitely many unsigned integers. In practice, a programmer must choose how many bits to dedicate to a variable <em>prior to storing it</em>, for a variety of reasons:</p>&#13;
<ul>&#13;
<li class="noindent">Before storing a value, a program must allocate storage space for it. In C, declaring a variable tells the compiler how much memory it needs based on its type (see “C Numeric Types” on <a href="ch01.xhtml#lev3_2">page 24</a>).</li>&#13;
<li class="noindent">Hardware storage devices have finite capacity. Whereas a system’s main memory is typically large and unlikely to be a limiting factor, storage locations inside the CPU that are used as temporary “scratch space” (i.e., registers, see “CPU Register” on <a href="ch05.xhtml#lev3_51">page 260</a>) are more constrained. A CPU uses registers that are limited to its word size (typically 32 or 64 bits, depending on the CPU architecture).</li>&#13;
<li class="noindent">Programs often move data from one storage device to another (e.g., between CPU registers and main memory). As values get larger, storage devices need more wires to communicate signals between them. Hence, expanding storage increases the complexity of the hardware and leaves less physical space for other components.</li>&#13;
</ul>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_197"/>The number of bits used to store an integer dictates the range of its representable values. <a href="ch04.xhtml#ch4fig4">Figure 4-4</a> depicts how we might conceptualize infinite and finite unsigned integer storage spaces.</p>&#13;
<div class="imagec" id="ch4fig4"><img alt="image" src="../images/04fig04.jpg"/></div>&#13;
<p class="figcap"><em>Figure 4-4: Illustrations of (a) an infinite unsigned number line and (b) a finite unsigned number line. The latter “wraps around” at either endpoint (overflow).</em></p>&#13;
<p class="indent">Attempting to store a larger value to a variable than the variable’s size allows is known as <em>integer overflow</em>. This chapter defers the details of overflow to a later section (see “Integer Overflow” on <a href="ch04.xhtml#lev1_32">page 211</a>). For now, think of it like a car’s odometer that “rolls over” back to zero if it attempts to increase beyond its maximum value. Similarly, subtracting one from zero yields the maximum value.</p>&#13;
<p class="indent">At this point, a natural question to ask about unsigned binary is “What’s the largest positive value that <em>N</em> bits can store?” In other words, given a sequence of <em>N</em> bits that are all 1, what value does the sequence represent? Reasoning about this question informally, the analysis in the previous section shows that <em>N</em> bits yield 2<sup><em>N</em></sup> unique bit sequences. Since one of those sequences must represent the number 0, that leaves 2<sup><em>N</em></sup> – 1 positive values ranging from 1 to 2<sup><em>N</em></sup> – 1. Thus, the maximum value for an unsigned binary number of <em>N</em> bits must be 2<sup><em>N</em></sup> – 1.</p>&#13;
<p class="indent">For example, 8 bits provide 2<sup>8</sup> = 256 unique sequences. One of those sequences, 0b00000000, is reserved for 0, leaving 255 sequences for storing positive values. Therefore, an 8-bit variable represents the positive values 1 through 255, the largest of which is 255.</p>&#13;
<h3 class="h3" id="lev1_29">4.2 Converting Between Bases</h3>&#13;
<p class="noindent">You’re likely to encounter each of the three number bases we’ve introduced in this chapter in different contexts. In some cases, you may need to convert from one base to another. This section starts by showing how to convert between binary and hexadecimal, since those two map easily to each other. After that, we’ll explore conversions to and from decimal.</p>&#13;
<h4 class="h4" id="lev2_65"><span epub:type="pagebreak" id="page_198"/>4.2.1 Converting Between Binary and Hexadecimal</h4>&#13;
<p class="noindent">Because the bases for both binary and hexadecimal are powers of 2, converting between the two is relatively straightforward. Specifically, each hexadecimal digit holds one of 16 unique values, and four bits also represents 2<sup>4</sup> = 16 unique values, making their expressive power equivalent. <a href="ch04.xhtml#ch4tab3">Table 4-3</a> enumerates the one-to-one mapping between any sequence of four bits and any single hexadecimal digit.</p>&#13;
<p class="tabcap" id="ch4tab3"><strong>Table 4-3:</strong> The Correspondence Between All Four-Bit Sequences and One-Digit Hexadecimal Numbers</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
<col style="width:25%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Binary</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Hexadecimal</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Binary</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Hexadecimal</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0000</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1000</p></td>&#13;
<td style="vertical-align: top"><p class="tab">8</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0001</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1001</p></td>&#13;
<td style="vertical-align: top"><p class="tab">9</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0010</p></td>&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1010</p></td>&#13;
<td style="vertical-align: top"><p class="tab">A</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0011</p></td>&#13;
<td style="vertical-align: top"><p class="tab">3</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1011</p></td>&#13;
<td style="vertical-align: top"><p class="tab">B</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0100</p></td>&#13;
<td style="vertical-align: top"><p class="tab">4</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1100</p></td>&#13;
<td style="vertical-align: top"><p class="tab">C</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0101</p></td>&#13;
<td style="vertical-align: top"><p class="tab">5</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1101</p></td>&#13;
<td style="vertical-align: top"><p class="tab">D</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0110</p></td>&#13;
<td style="vertical-align: top"><p class="tab">6</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1110</p></td>&#13;
<td style="vertical-align: top"><p class="tab">E</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0111</p></td>&#13;
<td style="vertical-align: top"><p class="tab">7</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1111</p></td>&#13;
<td style="vertical-align: top"><p class="tab">F</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Note that the content of <a href="ch04.xhtml#ch4tab3">Table 4-3</a> is equivalent to simply counting from 0 to 15 in both number systems, so there’s no need to memorize it. Armed with this mapping, you can convert any number of consecutive bits or hex digits in either direction.</p>&#13;
<p class="indent">To convert 0xB491 to binary, simply substitute the corresponding binary value for each hexadecimal digit:</p>&#13;
<p class="programs">  B    4    9    1<br/>&#13;
1011 0100 1001 0001  -&gt;  0b1011010010010001</p>&#13;
<p class="indent">To convert 0b1111011001 to hexadecimal, first divide up the bits into chunks of four, from <em>right to left</em>. If the leftmost chunk doesn’t have four bits, you can pad with leading zeros. Then, substitute the corresponding hexadecimal values:</p>&#13;
<p class="programs">1111011001  -&gt;  11 1101 1001  -&gt;  0011 1101 1001<br/>&#13;
                                  ^ padding<br/>&#13;
<br/>&#13;
0011 1101 1001<br/>&#13;
  3    D    9  -&gt;  0x3D9</p>&#13;
<h4 class="h4" id="lev2_66">4.2.2 Converting to Decimal</h4>&#13;
<p class="noindent">Fortunately, converting values to decimal is what we’ve been doing throughout previous sections of this chapter. Given a number in <em>any</em> base <em>B</em>, labeling the digits from <em>right to left</em> as <em>d</em><sub>0</sub>, <em>d</em><sub>1</sub>, <em>d</em><sub>2</sub>, etc. enables a general formula for converting values to decimal:</p>&#13;
<span epub:type="pagebreak" id="page_199"/>&#13;
<p class="center">(<em>d</em><sub><em>N</em>–1</sub> × B<sup><em>N</em>–1</sup>) + (<em>d</em><sub><em>N</em>–2</sub> × B<sup><em>N</em>–2</sup>) + … + (<em>d</em><sub>2</sub> × <em>B</em><sup>2</sup>) + (<em>d</em><sub>1</sub> × <em>B</em><sup>1</sup>) + (<em>d</em><sub>0</sub> × <em>B</em><sup>0</sup>)</p>&#13;
<h4 class="h4" id="lev2_67">4.2.3 Converting from Decimal</h4>&#13;
<p class="noindent">Converting from decimal to other systems requires a little more work. Informally, the goal is to do the reverse of the previous formula: determine the value of each digit such that, based on the position of the digit, adding each term results in the source decimal number. It may help to think about each digit in the target base system in the same way that we described the places (e.g., the “ones” place, the “tens” place, etc.) for decimal. For example, consider converting from decimal to hexadecimal. Each digit of a hexadecimal number corresponds to an increasingly large power of 16, and <a href="ch04.xhtml#ch4tab4">Table 4-4</a> lists the first few powers.</p>&#13;
<p class="tabcap" id="ch4tab4"><strong>Table 4-4:</strong> Powers of 16</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>16</strong><sup>4</sup></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>16</strong><sup>3</sup></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>16</strong><sup>2</sup></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>16</strong><sup>1</sup></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>16</strong><sup>0</sup></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">65536</p></td>&#13;
<td style="vertical-align: top"><p class="tab">4096</p></td>&#13;
<td style="vertical-align: top"><p class="tab">256</p></td>&#13;
<td style="vertical-align: top"><p class="tab">16</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">For example, to convert 9742 to hexadecimal, consider:</p>&#13;
<ul>&#13;
<li class="noindent">How many multiples of 65536 fit into 9742? (In other words, what is the value of the “65536s” place?)&#13;
<p class="noindentt">The resulting hexadecimal value doesn’t need any multiples of 65536, since the value (9742) is smaller than 65536, so <em>d</em><sub>4</sub> should be set to 0. Note that by the same logic, all higher-numbered digits will also be 0 because each digit would contribute values even larger than 65536. Thus far, the result contains only:</p>&#13;
<table class="line-c">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">4</sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">3</sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">2</sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">1</sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">0</sub></p></td>&#13;
</tr>&#13;
</table></li>&#13;
<li class="noindent">How many multiples of 4096 fit into 9742? (In other words, what is the value of the “4096s” place?)&#13;
<p class="noindentt">4096 fits into 9742 twice (2 × 4096 = 8192), so the value of <em>d</em><sub>3</sub> should be 2. Thus, <em>d</em><sub>3</sub> will contribute 8192 to the overall value, so the result must still account for 9742 − 8192 = 1550.</p>&#13;
<table class="line-c">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">4</sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">3</sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">2</sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">1</sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">0</sub></p></td>&#13;
</tr>&#13;
</table></li>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_200"/>How many multiples of 256 fit into 1550? (In other words, what is the value of the “256s” place?)&#13;
<p class="noindentt">256 fits into 1550 six times (6 × 256 = 1536), so the value of <em>d</em><sub>2</sub> should be 6, leaving 1550 − 1536 = 14.</p>&#13;
<table class="line-c">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;
<td style="vertical-align: top"><p class="tab">6</p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">4</sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">3</sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">2</sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">1</sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">0</sub></p></td>&#13;
</tr>&#13;
</table></li>&#13;
<li class="noindent">How many multiples of 16 fit into 14? (In other words, what is the value of the “sixteens” place?)&#13;
<p class="noindentt">None, so <em>d</em><sub>1</sub> must be 0.</p>&#13;
<table class="line-c">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;
<td style="vertical-align: top"><p class="tab">6</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab"/></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">4</sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">3</sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">2</sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">1</sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">0</sub></p></td>&#13;
</tr>&#13;
</table></li>&#13;
<li class="noindent">Finally, how many multiples of 1 fit into 14? (In other words, what is the value of the “ones” place?)&#13;
<p class="noindentt">The answer is 14, of course, which hexadecimal represents with the digit E.</p>&#13;
<table class="line-c">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;
<td style="vertical-align: top"><p class="tab">6</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab">E</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">4</sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">3</sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">2</sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">1</sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><em>d</em><sub class="textsubscript">0</sub></p></td>&#13;
</tr>&#13;
</table></li>&#13;
</ul>&#13;
<p class="indent">Thus, decimal 9742 corresponds to 0x260E.</p>&#13;
<h5 class="h5" id="lev3_39">Decimal to Binary: Powers of Two</h5>&#13;
<p class="noindent">The same procedure works for binary, as well (or any other number system), provided that you use powers of the appropriate base. <a href="ch04.xhtml#ch4tab5">Table 4-5</a> lists the first few powers of two, which will help to convert the example decimal value 422 to binary.</p>&#13;
<p class="tabcap" id="ch4tab5"><strong>Table 4-5:</strong> Powers of Two</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:12%"/>&#13;
<col style="width:11%"/>&#13;
<col style="width:11%"/>&#13;
<col style="width:11%"/>&#13;
<col style="width:11%"/>&#13;
<col style="width:11%"/>&#13;
<col style="width:11%"/>&#13;
<col style="width:11%"/>&#13;
<col style="width:11%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>2</strong><sup>8</sup></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>2</strong><sup>7</sup></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>2</strong><sup>6</sup></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>2</strong><sup>5</sup></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>2</strong><sup>4</sup></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>2</strong><sup>3</sup></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>2</strong><sup>2</sup></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>2</strong><sup>1</sup></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>2</strong><sup>0</sup></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">256</p></td>&#13;
<td style="vertical-align: top"><p class="tab">128</p></td>&#13;
<td style="vertical-align: top"><p class="tab">64</p></td>&#13;
<td style="vertical-align: top"><p class="tab">32</p></td>&#13;
<td style="vertical-align: top"><p class="tab">16</p></td>&#13;
<td style="vertical-align: top"><p class="tab">8</p></td>&#13;
<td style="vertical-align: top"><p class="tab">4</p></td>&#13;
<td style="vertical-align: top"><p class="tab">2</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Since an individual bit is only allowed to store a 0 or 1, the question is no longer “How many multiples of each power fit within a value?” when converting to binary. Instead, ask a simpler question: “Does the next power of two fit?” For example, in converting 422:</p>&#13;
<ul>&#13;
<li class="noindent"><span epub:type="pagebreak" id="page_201"/>256 fits into 422, so <em>d</em><sub>8</sub> should be a 1. That leaves 422 − 256 = 166.</li>&#13;
<li class="noindent">128 fits into 166, so <em>d</em><sub>7</sub> should be a 1. That leaves 166 − 128 = 38.</li>&#13;
<li class="noindent">64 does not fit into 38, so <em>d</em><sub>6</sub> should be a 0.</li>&#13;
<li class="noindent">32 fits into 38, so <em>d</em><sub>5</sub> should be a 1. That leaves 38 − 32 = 6.</li>&#13;
<li class="noindent">16 does not fit into 6, so <em>d</em><sub>4</sub> should be a 0.</li>&#13;
<li class="noindent">8 does not fit into 6, so <em>d</em><sub>3</sub> should be a 0.</li>&#13;
<li class="noindent">4 fits into 6, so <em>d</em><sub>2</sub> should be a 1. That leaves 6 − 4 = 2.</li>&#13;
<li class="noindent">2 fits into 2, so <em>d</em><sub>1</sub> should be a 1. That leaves 2 − 2 = 0.&#13;
<p class="noindent">(Note: upon reaching 0, all remaining digits will always be 0.)</p></li>&#13;
<li class="noindent">1 does not fit into 0, so <em>d</em><sub>0</sub> should be a 0.</li>&#13;
</ul>&#13;
<p class="indent">Thus, decimal 422 corresponds to 0b110100110.</p>&#13;
<h5 class="h5" id="lev3_40">Decimal to Binary: Repeated Division</h5>&#13;
<p class="noindent">The method we just described generally works well for students who are familiar with the relevant powers of two (e.g., for 422, the converter must recognize that it should start at <em>d</em><sub>8</sub> because 2<sup>9</sup> = 512 is too large).</p>&#13;
<p class="indent">An alternative method doesn’t require knowing powers of two. Instead, this method builds a binary result by checking the parity (even or odd) status of a decimal number and repeatedly dividing it by two (rounding halves down) to determine each successive bit. Note that it builds the resulting bit sequence from <em>right to left</em>. If the decimal value is even, the next bit should be a zero; if it’s odd, the next bit should be a one. When the division reaches zero, the conversion is complete.</p>&#13;
<p class="indent">For example, when converting 422:</p>&#13;
<ul>&#13;
<li class="noindent">422 is even, so <em>d</em><sub>0</sub> should be a 0. (This is the rightmost bit.)</li>&#13;
<li class="noindent">422/2 = 211, which is odd, so <em>d</em><sub>1</sub> should be a 1.</li>&#13;
<li class="noindent">211/2 = 105, which is odd, so <em>d</em><sub>2</sub> should be a 1.</li>&#13;
<li class="noindent">105/2 = 52, which is even, so <em>d</em><sub>3</sub> should be a 0.</li>&#13;
<li class="noindent">52/2 = 26, which is even, so <em>d</em><sub>4</sub> should be a 0.</li>&#13;
<li class="noindent">26/2 = 13, which is odd, so <em>d</em><sub>5</sub> should be a 1.</li>&#13;
<li class="noindent">13/2 = 6, which is even, so <em>d</em><sub>6</sub> should be a 0.</li>&#13;
<li class="noindent">6/2 = 3, which is odd, so <em>d</em><sub>7</sub> should be a 1.</li>&#13;
<li class="noindent">3/2 = 1, which is odd, so <em>d</em><sub>8</sub> should be a 1.</li>&#13;
<li class="noindent">1/2 = 0, so any digit numbered nine or above will be 0, and the algorithm terminates.</li>&#13;
</ul>&#13;
<p class="noindent">As expected, this method produces the same binary sequence: 0b110100110.</p>&#13;
<h3 class="h3" id="lev1_30"><span epub:type="pagebreak" id="page_202"/>4.3 Signed Binary Integers</h3>&#13;
<p class="noindent">So far, we’ve limited the discussion of binary numbers to <em>unsigned</em> (strictly non-negative) integers. This section presents an alternative interpretation of binary that incorporates negative numbers. Given that a variable has finite storage space, a signed binary encoding must distinguish between negative values, zero, and positive values. Manipulating signed numbers additionally requires a procedure for negating a number.</p>&#13;
<p class="indent">A signed binary encoding must divide bit sequences between negative and non-negative values. In practice, systems designers build <em>general-purpose</em> systems, so a 50% / 50% split is a good middle-of-the-road choice. Therefore, the signed number encodings that this chapter presents represent an equal number of negative and non-negative values.</p>&#13;
<p class="note"><strong><span class="black">Note</span> NON-NEGATIVE VERSUS POSITIVE</strong></p>&#13;
<p class="note1">Note that there’s a subtle but important difference between <em>non-negative</em> and <em>positive</em>. The set of strictly positive values excludes zero, whereas the non-negative set includes zero. Even after dividing the available bit sequences 50% / 50% between negative and non-negative values, one of the non-negative values must still be reserved for zero. Thus, with a fixed number of bits, a number system may end up representing more negative values than positive values (e.g., in the two’s complement system).</p>&#13;
<p class="indent">Signed number encodings use one bit to distinguish between the sets of <em>negative</em> numbers and <em>non-negative</em> numbers. By convention, the leftmost bit indicates whether a number is negative (1) or non-negative (0). This leftmost bit is known as the <em>high-order bit</em> or the <em>most significant bit</em>.</p>&#13;
<p class="indent">This chapter presents two potential signed binary encodings—<em>signed magnitude</em> and <em>two’s complement</em>. Even though only one of these encodings (two’s complement) is still used in practice, comparing them will help to illustrate their important characteristics.</p>&#13;
<h4 class="h4" id="lev2_68">4.3.1 Signed Magnitude</h4>&#13;
<p class="noindent">The <em>signed magnitude</em> representation treats the high-order bit exclusively as a sign bit. That is, whether the high-order bit is a 0 or a 1 does not affect the absolute value of the number, it determines <em>only</em> whether the value is positive (high-order bit 0) or negative (high-order bit 1). Compared to two’s complement, signed magnitude makes the decimal conversion and negation procedures relatively straightforward:</p>&#13;
<ul>&#13;
<li class="noindent">To compute a decimal value for an <em>N</em>-bit signed magnitude sequence, compute the value of digits <em>d</em><sub>0</sub> through <em>d</em><sub><em>N–</em>2</sub> using the familiar unsigned method from “Unsigned Binary Numbers” on <a href="ch04.xhtml#lev2_62">page 193</a>. Then, check the most significant bit, <em>d</em><sub><em>N–</em>1</sub>: if it’s 1, the value is negative; otherwise it isn’t.</li>&#13;
<li class="noindent">To negate a value, simply flip the most significant bit to change its sign.</li>&#13;
</ul>&#13;
<span epub:type="pagebreak" id="page_203"/>&#13;
<p class="note"><strong><span class="black">Warning</span> NEGATION MISCONCEPTION</strong></p>&#13;
<p class="note-w">Signed magnitude is presented purely for pedagogical purposes. Although it was used by some machines in the past (e.g., IBM’s 7090 in the 1960s), no modern systems use signed magnitude to represent integers (although a similar mechanism <em>is</em> part of the standard for storing floating-point values).</p>&#13;
<p class="note-w">Unless you’re explicitly asked to consider signed magnitude, you should <em>not</em> assume that flipping the first bit of a binary number will negate that number’s value on a modern system.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch4fig5">Figure 4-5</a> shows how four-bit signed magnitude sequences correspond to decimal values. At first glance, signed magnitude might seem attractive due to its simplicity. Unfortunately, it suffers from two major drawbacks that make it unappealing. The first is that it presents <em>two</em> representations of zero. For example, with four bits, signed magnitude represents both <em>zero</em> (0b0000) and <em>negative zero</em> (0b1000). Consequently, it poses a challenge to hardware designers because the hardware will need to account for two possible binary sequences that are numerically equal despite having different bit values. The hardware designer’s job is much easier with just one way of representing such an important number.</p>&#13;
<div class="imagec" id="ch4fig5"><img alt="image" src="../images/04fig05.jpg"/></div>&#13;
<p class="figcap"><em>Figure 4-5: A logical layout of signed magnitude values for bit sequences of length four</em></p>&#13;
<p class="indent">The other drawback of signed magnitude is that it exhibits an inconvenient discontinuity between negative values and zero. While we’ll cover overflow in more detail in “Integer Overflow” on <a href="ch04.xhtml#lev1_32">page 211</a>, adding 1 to the four-bit sequence 0b1111 “rolls over” back to 0b0000. With signed magnitude, this effect means 0b1111 (–7) + 1 might be mistaken for 0 rather than the expected –6. This problem is solvable, but the solution again complicates the design of the hardware, essentially turning any transition between negative and non-negative integers into a special case that requires extra care.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_204"/>For these reasons, signed magnitude has largely disappeared in practice, and two’s complement reigns supreme.</p>&#13;
<h4 class="h4" id="lev2_69">4.3.2 Two’s Complement</h4>&#13;
<p class="noindent"><em>Two’s complement</em> encoding solves signed magnitude’s problems in an elegant way. Like signed magnitude, the high-order bit of a two’s complement number indicates whether or not the value should be interpreted as negative. In contrast though, the high-order bit also affects the value of the number. So, how can it do both?</p>&#13;
<p class="indent">Computing a decimal value for an <em>N</em>-bit two’s complement number is similar to the familiar unsigned method, except the high-order bit’s contribution to the overall value is negated. That is, for an <em>N</em>-bit two’s complement sequence, instead of the first bit contributing <em>d</em><sub><em>N–</em>1</sub> × 2<sup><em>N–</em>1</sup> to the sum, it contributes  <em>– d</em><sub><em>N–</em>1</sub> × 2<sup><em>N–</em>1</sup> (note the negative sign). Therefore, if the most significant bit is a 1, the overall value will be negative, since that first bit contributes the largest absolute value to the sum. Otherwise, the first bit contributes nothing to the sum, and the result is non-negative. Following is the full formula:</p>&#13;
<p class="center">–(<em>d</em><sub><em>N</em>–1</sub> × 2<sup><em>N</em>–1</sup>) + (<em>d</em><sub><em>N</em>–2</sub> × 2<sup><em>N</em>–2</sup>) + … + (<em>d</em><sub>2</sub> × 2<sup>2</sup>) + (<em>d</em><sub>1</sub> × 2<sup>1</sup>) + (<em>d</em><sub>0</sub> × 2<sup>0</sup>)</p>&#13;
<p class="noindent">(note the leading negative sign for just the first term!).</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch4fig6">Figure 4-6</a> illustrates the layout of four-bit sequences in two’s complement. This definition encodes just one representation of zero—a sequence of bits that are all 0’s. With only a single <em>zero</em> sequence, two’s complement represents one more negative value than positive. Using four-bit sequences as an example, two’s complement represents a minimum value of 0b1000 (–8), but a maximum value of only 0b0111 (7). Fortunately, this quirk doesn’t hinder hardware design and rarely causes problems for applications.</p>&#13;
<div class="imagec" id="ch4fig6"><img alt="image" src="../images/04fig06.jpg"/></div>&#13;
<p class="figcap"><em>Figure 4-6: A logical layout of two’s complement values for bit sequences of length four</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_205"/>Compared to signed magnitude, two’s complement also simplifies the transition between negative numbers and zero. Regardless of the number of bits used to store it, a two’s complement number consisting of all ones will always hold the value –1. Adding 1 to a bit sequence of all 1s “rolls over” to zero, which makes two’s complement convenient, since –1 + 1 <em>should</em> produce zero.</p>&#13;
<h5 class="h5" id="lev3_41">Negation</h5>&#13;
<p class="noindent">Negating a two’s complement number is slightly trickier than negating a signed magnitude value. To negate an <em>N</em>-bit value, determine it’s <em>complement</em> with respect to 2<sup><em>N</em></sup> (this is where the encoding’s name comes from). In other words, to negate an <em>N</em>-bit value <em>X</em>, find a bit sequence <em>Y</em> (<em>X</em>’s complement) such that <em>X</em> + <em>Y</em> = 2<sup><em>N</em></sup>.</p>&#13;
<p class="indent">Fortunately, there’s a quick shortcut for negating a two’s complement number in practice: flip all the bits and add one. For example, to negate the eight-bit value 13, first determine the binary value of 13 (see “Converting from Decimal” on <a href="ch04.xhtml#lev2_67">page 199</a>). Since 13 is the sum of 8, 4, and 1, set the bits in positions 3, 2, and 0:</p>&#13;
<p class="programs">00001101  (decimal 13)</p>&#13;
<p class="indent">Next, “flip the bits” (change all zeros to ones, and vice versa):</p>&#13;
<p class="programs">11110010</p>&#13;
<p class="indent">Finally, adding one yields 0b11110011. Sure enough, applying the formula for interpreting a two’s complement bit sequence shows that the value is –13:</p>&#13;
<p class="center">–(1 × 2<sup>7</sup>) + (1 × 2<sup>6</sup>) + (1 × 2<sup>5</sup>) + (1 × 2<sup>4</sup>) + (0 × 2<sup>3</sup>) + (0 × 2<sup>2</sup>) + (1 × 2<sup>1</sup>) + (1 × 2<sup>0</sup>) = –128 + 64 + 32 + 16 + 0 + 0 + 2 + 1 = –13</p>&#13;
<p class="indent">If you’re curious as to why this seemingly magical shortcut works, consider the eight-bit negation of 13 more formally. To find 13’s complement, solve 0b00001101 (13) + <em>Y</em> = 0b100000000 (2<sup>8</sup>, which requires an extra bit to represent). The equation can be rearranged as <em>Y</em> = 0b100000000 – 0b00001101. This is clearly now a subtraction problem:</p>&#13;
<p class="programs"> 100000000  (256)<br/>&#13;
- 00001101   (13)</p>&#13;
<p class="indent">Even though such a subtraction might seem daunting, we can express it in a way that’s easier to compute as (0b011111111 + 1) – 0b00001101. Note that this change simply expresses 2<sup>8</sup> (256) as (255 + 1). After that change, the arithmetic looks like:</p>&#13;
<p class="programs"> 011111111  (255)  + 00000001  (1)<br/>&#13;
- 00001101   (13)</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_206"/>As it turns out, for <em>any</em> bit value <em>b</em>, 1 <em>– b</em> is equivalent to “flipping” that bit. Thus, the entire subtraction in the preceding example can be reduced to just flipping all the bits of the lower number. All that’s left is to add the remaining +1 from expressing 256 as 255 + 1. Putting it all together, we can simply flip a value’s bits and add one to compute its complement!</p>&#13;
<p class="note"><strong><span class="black">Warning</span> C PROGRAMMING WITH SIGNED VERSUS UNSIGNED INTEGERS</strong></p>&#13;
<p class="note-w">In addition to allocating space, declaring variables in C also tells the compiler how you’d like the variable to be interpreted. When you declare an <span class="literal">int</span>, the compiler interprets the variable as a signed two’s complement integer. To allocate an unsigned value, declare an <span class="literal">unsigned int</span>.</p>&#13;
<p class="note-w">The distinction is also relevant to C in other places, like the <span class="literal">printf</span> function. As this chapter has been stressing throughout, a bit sequence can be interpreted in different ways! With <span class="literal">printf</span>, the interpretation depends on the formatting placeholder you use. For example:</p>&#13;
<p class="programs-l">#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
int main() {<br/>&#13;
    int example = -100;<br/>&#13;
<br/>&#13;
    /* Print example int using both signed and unsigned placeholders. */<br/>&#13;
    printf("%d  %u\n", example, example);<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<p class="note-w">Even though this code passes <span class="literal">printf</span> the same variable (<span class="literal">example</span>) twice, it prints <span class="literal">-100 4294967196</span>. Be careful to interpret your values correctly!</p>&#13;
<h5 class="h5" id="lev3_42">Sign Extension</h5>&#13;
<p class="noindent">Occasionally, you may find yourself wanting to perform an arithmetic operation on two numbers that are stored using different numbers of bits. For example, in C you may want to add a 32-bit <span class="literal">int</span> and a 16-bit <span class="literal">short</span>. In such cases, the smaller number needs to be <em>sign extended</em>, which is a fancy way of saying that its most significant bit gets repeated as many times as necessary to extend the length of the bit sequence to the target length. Though the compiler will take care of wrangling the bits for you in C, it’s still helpful to understand how the process works.</p>&#13;
<p class="indent">For example, to extend the four-bit sequence 0b0110 (6) to an eight-bit sequence, take the high-order bit (0) and prepend it four times to produce the extended value: 0b00000110 (still 6). Extending 0b1011 (–5) to an eight-bit sequence similarly takes the high-order bit (this time, 1) and prepends it four times to the resulting extended value: 0b11111011 (still –5). To verify the correctness, consider how the value changes after adding each new bit:</p>&#13;
<p class="programs">    0b1011 =                      -8 + 0 + 2 + 1 = -5<br/>&#13;
   0b11011 =                 -16 + 8 + 0 + 2 + 1 = -5<br/>&#13;
<span epub:type="pagebreak" id="page_207"/>  0b111011 =            -32 + 16 + 8 + 0 + 2 + 1 = -5<br/>&#13;
 0b1111011 =       -64 + 32 + 16 + 8 + 0 + 2 + 1 = -5<br/>&#13;
0b11111011 = -128 + 64 + 32 + 16 + 8 + 0 + 2 + 1 = -5</p>&#13;
<p class="indent">As evidenced by the examples, numbers that are non-negative (high-order bit of zero) remain non-negative after adding zeros to the front. Likewise, negatives (high-order bit of one) remain negative after prepending ones to extended values.</p>&#13;
<p class="note"><strong><span class="black">Note</span> UNSIGNED ZERO EXTENSION</strong></p>&#13;
<p class="note1">For an unsigned value (e.g., a C variable explicitly declared with an <span class="literal">unsigned</span> qualifier), extending it to a longer bit sequence instead requires <em>zero extension</em>, since the <span class="literal">unsigned</span> qualifier prevents the value from ever being interpreted as negative. Zero extension simply prepends zeros to the high-order bits of the extended bit sequence. For example, 0b1110 (14 when interpreted as unsigned!) extends to 0b00001110 despite the original leading 1.</p>&#13;
<h3 class="h3" id="lev1_31">4.4 Binary Integer Arithmetic</h3>&#13;
<p class="noindent">Earlier, we presented binary representations for unsigned (“Unsigned Binary Numbers” on <a href="ch04.xhtml#lev2_62">page 193</a>) and signed (“Unsigned Binary Numbers” on <a href="ch04.xhtml#lev2_62">page 193</a>) integers; now we’re ready to use them in arithmetic operations. Fortunately, due to their encoding, it <em>does not matter</em> to the arithmetic procedures whether we choose to interpret the operands or result as signed or unsigned. This observation is great news for hardware designers because it allows them to build one set of hardware components that can be shared for both unsigned and signed operations. “Circuits” on <a href="ch05.xhtml#lev1_41">page 246</a> describes the circuitry for performing arithmetic in more detail.</p>&#13;
<p class="indent">Luckily, the same pencil-and-paper algorithms you learned in grade school for performing arithmetic on decimal numbers also work for binary numbers. Though the hardware might not compute them in exactly the same way, you should at least be able to make sense of the calculations.</p>&#13;
<h4 class="h4" id="lev2_70">4.4.1 Addition</h4>&#13;
<p class="noindent">Recall that in a binary number, each digit holds only 0 or 1. Consequently, when adding two bits that are <em>both</em> 1, the result <em>carries out</em> to the next digit (e.g., 1 + 1 = 0b10, which requires two bits to represent). In practice, programs add multibit variables, where the result of one digit’s <em>carry out</em> influences the next digit by <em>carrying in</em>.</p>&#13;
<p class="indent">In general, when summing digits from two binary numbers (<em>A</em> and <em>B</em>), there are <em>eight</em> possible outcomes depending on the values of <em>Digit<sub>A</sub></em>, <em>Digit<sub>B</sub></em>, and a <em>Carry<sub>in</sub></em> from the previous digit. <a href="ch04.xhtml#ch4tab6">Table 4-6</a> enumerates the eight possibilities that may result from adding one pair of bits. The <em>Carry<sub>in</sub></em> column refers to a carry feeding into the sum from the previous digit, and the <em>Carry<sub>out</sub></em> column indicates whether adding the pair of digits will feed a carry out to the next digit.</p>&#13;
<p class="tabcap" id="ch4tab6"><span epub:type="pagebreak" id="page_208"/><strong>Table 4-6:</strong> The Eight Possible Outcomes of Adding Two Binary Digits (<em>A</em> and <em>B</em>) with a Potential Carry In from the Previous Digit</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<tr>&#13;
<td colspan="3" style="vertical-align: top"><p class="tab-c"><strong>Inputs</strong></p></td>&#13;
<td colspan="2" style="vertical-align: top"><p class="tab-c"><strong>Outputs</strong></p></td>&#13;
</tr>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab-c"><strong>Digit</strong><sub class="textsubscript"><strong>A</strong></sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><strong>Digit</strong><sub class="textsubscript"><strong>B</strong></sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><strong>Carry</strong><sub class="textsubscript"><strong>in</strong></sub></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><strong>Result (Sum)</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab-c"><strong>Carry</strong><sub class="textsubscript"><strong>out</strong></sub></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab-c">1</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Consider the addition of two four-bit binary numbers. Start by lining up the numbers so that their corresponding digits match vertically, and then sum each corresponding digit in order, from the low-order digit (<em>d</em><sub>0</sub>) to the high-order digit (<em>d</em><sub>3</sub>). For example, adding 0b0010 + 0b1011:</p>&#13;
<table class="line" id="table04in01">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Problem Setup</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Worked Example</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderr" style="vertical-align: middle"><p class="tab"><img alt="image" src="../images/t0208-01.jpg"/></p></td>&#13;
<td style="vertical-align: middle"><p class="tab"><img alt="image" src="../images/t0208-02.jpg"/></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">The example shows a 1 carrying from <em>d</em><sub>1</sub> into <em>d</em><sub>2</sub>. This situation is analogous to adding two decimal digits that sum to a value larger than 9. For example, when adding 5 + 8 = 13, the resulting ones place contains 3, and a 1 carries into the tens place.</p>&#13;
<p class="indent">The first operand (0b0010) has a leading 0, so it represents 2 for both two’s complement and unsigned interpretations. The second operand (0b1011) represents –5 if interpreted as a signed two’s complement value. Otherwise, it represents 11 if interpreted as an unsigned value. Fortunately, the interpretation of the operands doesn’t affect the steps for computing the result. That is, the computed result (0b1101) represents either 13 (unsigned: 2 + 11) or –3 (signed: 2 + –5), both of which are correct depending on the interpretation of the second operand.</p>&#13;
<p class="indent">More generally, a four-bit sequence represents values in the range [0, 15] when interpreted as <em>unsigned</em>. When interpreted as <em>signed</em>, it represents the range [–8, 7]. In the previous example, the result fits within the representable range either way, but we may not always be so lucky. For example, when adding 0b1100 (unsigned 12) + 0b0111 (7), the answer should be 19, but four bits can’t represent 19:</p>&#13;
<span epub:type="pagebreak" id="page_209"/>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Problem Setup</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Worked Example</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderr" style="vertical-align: middle"><p class="tab"><img alt="image" src="../images/t0209-01.jpg"/></p></td>&#13;
<td style="vertical-align: middle"><p class="tab"><img alt="image" src="../images/t0209-02.jpg"/></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">Note that the addition in this example carries a 1 from the most significant bit, a condition known as a <em>carry out</em> for the overall arithmetic operation. In this example, the carry out suggests that the arithmetic output needs an extra bit to store the intended result. However, when performing four-bit arithmetic, there’s nowhere to put the carry out’s extra bit, so the hardware simply drops or <em>truncates</em> it, leaving 0b0011 as the result. Of course, if the goal was to add 12 + 7, a result of 3 is likely to be surprising. The surprise is a consequence of <em>overflow</em>. We’ll explore how to detect overflow and why it produces the results that it does in “Integer Overflow” on <a href="ch04.xhtml#lev1_32">page 211</a>.</p>&#13;
<p class="note"><strong><span class="black">Note</span></strong></p>&#13;
<p class="note1">Multibit adder circuits also support a <em>carry in</em> that behaves like a carry into the rightmost digit (i.e., it serves as the <em>Carry<sub>in</sub></em> input for <em>d</em><sub>0</sub>). The carry in isn’t useful when performing addition—it’s implicitly set to 0, which is why it doesn’t appear in the preceding example. However, the carry in does become relevant for other operations that use adder circuitry, most notably subtraction.</p>&#13;
<h4 class="h4" id="lev2_71">4.4.2 Subtraction</h4>&#13;
<p class="noindent">Subtraction combines two familiar operations: negation and addition. In other words, subtracting 7 – 3 is equivalent to expressing the operation as 7 + (–3). This portrayal of subtraction aligns well with how the hardware behaves—a CPU already contains circuits for negation and addition, so it makes sense to reuse those circuits rather than build an entirely new subtractor. Recall that a simple procedure to negate a binary number is to flip the bits and add one (see “Negation” on <a href="ch04.xhtml#lev3_41">page 205</a>).</p>&#13;
<p class="indent">Consider the example 0b0111 (7) – 0b0011 (3), which starts by sending the 3 to a bit-flipping circuit. To get the “plus one,” it takes advantage of the <em>carry in</em> to the adder circuit. That is, rather than carrying from one digit to another, subtraction feeds a <em>carry in</em> to <em>d</em><sub>0</sub> of the adder. Setting the carry in to 1 increases the resulting “ones place” value by one, which is exactly what it needs to get the “plus one” part of the negation. Putting it all together, the example would look like the following:</p>&#13;
<span epub:type="pagebreak" id="page_210"/>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Problem Setup</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Converted to Addition</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Worked Example</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderr" style="vertical-align: middle"><p class="tab"><img alt="image" src="../images/t0210-01.jpg"/></p></td>&#13;
<td class="borderr" style="vertical-align: middle"><p class="tab"><img alt="image" src="../images/t0210-02.jpg"/></p></td>&#13;
<td style="vertical-align: middle"><p class="tab"><img alt="image" src="../images/t0210-03.jpg"/></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">While the full result of the addition carries into an extra digit, the truncated result (0b0100) represents the expected result (4). Unlike the previous addition example, a carry out from the high-order bit is not necessarily indicative of an overflow problem for subtraction.</p>&#13;
<p class="indent">Performing subtraction as negation followed by addition also works when subtracting a negative value. For example, 7 – (–3) produces 10:</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Problem Setup</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Converted to Addition</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Worked Example</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderr" style="vertical-align: middle"><p class="tab"><img alt="image" src="../images/t0210-04.jpg"/></p></td>&#13;
<td class="borderr" style="vertical-align: middle"><p class="tab"><img alt="image" src="../images/t0210-05.jpg"/></p></td>&#13;
<td style="vertical-align: middle"><p class="tab"><img alt="image" src="../images/t0210-06.jpg"/></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">We further explore the implications of carrying out (or not) in “Integer Overflow” on <a href="ch04.xhtml#lev1_32">page 211</a>.</p>&#13;
<h4 class="h4" id="lev2_72">4.4.3 Multiplication and Division</h4>&#13;
<p class="noindent">This section briefly describes binary multiplication and division with integers. In particular, it shows methods for computing results by hand and does not reflect the behavior of modern hardware. This description is not meant to be comprehensive, as the remainder of the chapter focuses primarily on addition and subtraction.</p>&#13;
<h5 class="h5" id="lev3_43">Multiplication</h5>&#13;
<p class="noindent">To multiply binary numbers, use the common pencil-and-paper strategy of considering one digit at a time and adding the results. For example, multiplying 0b0101 (5) and 0b0011 (3) is equivalent to summing:</p>&#13;
<ul>&#13;
<li class="noindent">the result of multiplying <em>d</em><sub>0</sub> by 0b101 (5): 0b0101 (5)</li>&#13;
<li class="noindent">the result of multiplying <em>d</em><sub>1</sub> by 0b101 (5) and shifting the result to the left by one digit: 0b1010 (10).</li>&#13;
</ul>&#13;
<p class="programs">  0101       0101       0101<br/>&#13;
x 0011  =  x    1  +  x   10  =  101 + 1010  =  1111 (15)</p>&#13;
<h5 class="h5" id="lev3_44"><span epub:type="pagebreak" id="page_211"/>(Integer) Division</h5>&#13;
<p class="noindent">Unlike the other operations just described, division has the potential to produce a non-integral result. The primary thing to keep in mind when dividing integers is that in most languages (e.g., C, Python 2, and Java) the fractional portion of the result gets truncated. Otherwise, binary division uses the same long form method that most students learn in grade school. For example, here’s how computing 11 / 3 produces an integer result of 3:</p>&#13;
<p class="programs">    ____<br/>&#13;
11 |1011<br/>&#13;
<br/>&#13;
    00__   11 (3) doesn't fit into 1 (1) or 10 (2),<br/>&#13;
11 |1011   so the first two digits of the result are 00.<br/>&#13;
<br/>&#13;
    001_   11 (3) fits into 101 (5) once.<br/>&#13;
11 |1011<br/>&#13;
<br/>&#13;
    101    101 (5) - 11 (3) leaves 10 (2).<br/>&#13;
  -  11<br/>&#13;
     10<br/>&#13;
<br/>&#13;
    0011<br/>&#13;
11 |1011   11 (3) fits into 101 (5) once again.<br/>&#13;
     101</p>&#13;
<p class="indent">At this point, the arithmetic has produced the expected integer result, 0011 (3), and the hardware truncates any fractional parts. If you’re interested in determining the integral remainder, use the modulus operator (%), e.g., 11 % 3 = 2.</p>&#13;
<h3 class="h3" id="lev1_32">4.5 Integer Overflow</h3>&#13;
<p class="noindent">Although the number of integers is mathematically infinite, in practice, numeric types in a computer’s memory occupy a fixed number of bits (see “Storage Limitations” on <a href="ch04.xhtml#lev2_64">page 196</a>). As we’ve hinted throughout this chapter, using a fixed number of bits implies that programs might be unable to represent values that they’d like to store. For example, the discussion of addition showed that adding two legitimate values can produce a result that can’t be represented (see <a href="ch04.xhtml#table04in01">page 208</a>). A computation that lacks the storage to represent its result has <em>overflowed</em>.</p>&#13;
<h4 class="h4" id="lev2_73"><span epub:type="pagebreak" id="page_212"/>4.5.1 Odometer Analogy</h4>&#13;
<p class="noindent">To characterize overflow, consider an example from the non-computing world: a car’s odometer. An odometer counts the number of miles a car has driven, and whether it’s digital or analog, it can display only so many (base 10) digits. If the car drives more miles than the odometer can represent, the odometer “rolls over” back to zero, since the true value can’t be expressed. For example, with a standard six-digit odometer, the maximum value it represents is 999999. Driving just one additional mile <em>should</em> display 1000000, but like the overflowing addition example of <a href="ch04.xhtml#page_208">page 208</a>, the 1 carries out from the six available digits, leaving only 000000.</p>&#13;
<p class="indent">For simplicity, let’s continue analyzing an odometer that’s limited to just one decimal digit. That is, the odometer represents the range [0, 9], so after every 10 miles the odometer resets back to zero. Illustrating the odometer’s range visually, it might look like <a href="ch04.xhtml#ch4fig7">Figure 4-7</a>.</p>&#13;
<div class="imagec" id="ch4fig7"><img alt="image" src="../images/04fig07.jpg"/></div>&#13;
<p class="figcap"><em>Figure 4-7: A visual depiction of a one-digit odometer’s potential values</em></p>&#13;
<p class="indent">Because a one-digit odometer rolls over upon reaching 10, drawing a circular shape emphasizes the discontinuity at the top of the circle (and <em>only</em> at the top). Specifically, by adding one to any value <em>other than nine</em>, the result lands on the expected value. On the other hand, adding one to nine jumps to a value that doesn’t naturally follow it (zero). More generally, when performing <em>any</em> arithmetic that crosses the discontinuity between nine and zero, the computation will overflow. For example, consider adding 8 + 4, as in <a href="ch04.xhtml#ch4fig8">Figure 4-8</a>.</p>&#13;
<span epub:type="pagebreak" id="page_213"/>&#13;
<div class="imagec" id="ch4fig8"><img alt="image" src="../images/04fig08.jpg"/></div>&#13;
<p class="figcap"><em>Figure 4-8: The result of adding 8 + 4 with only one decimal digit. Crossing the discontinuity between 0 and 9 indicates that an overflow has occurred.</em></p>&#13;
<p class="indent">Here, the sum yields 2 instead of the expected 12. Note that many other values added to 8 (e.g., 8 + 14) would also land on two, with the only difference being that the computations would take additional trips around the circle. Consequently, it doesn’t matter whether the car drives 2, 12, or 152 miles—in the end, the odometer will read 2 regardless.</p>&#13;
<p class="indent">Any device that behaves like an odometer performs <em>modular arithmetic</em>. In this case, all arithmetic is modular with respect to a modulus of 10, since one decimal digit represents only 10 values. Therefore, given any number of miles traveled, we can compute what the odometer will read by dividing the distance by 10 and taking the remainder as the result. If the odometer had two decimal digits instead of one, the modulus would change to 100, since it could represent a larger range of values: [0, 99]. Similarly, clocks perform modular arithmetic with an hour modulus of 12.</p>&#13;
<h4 class="h4" id="lev2_74">4.5.2 Binary Integer Overflow</h4>&#13;
<p class="noindent">Having seen a familiar form of overflow, let’s turn to binary number encodings. Recall that <em>N</em> bits of storage represent 2<sup><em>N</em></sup> unique bit sequences and that those sequences can be interpreted in different ways (as <em>unsigned</em> or <em>signed</em>). Some operations that yield correct results under one interpretation may exhibit overflow according to the other, so the hardware needs to recognize overflow differently for each.</p>&#13;
<p class="indent">For example, suppose that a machine is using four-bit sequences to compute 0b0010 (2) – 0b0101 (5). Running this operation through the subtraction procedure (see “Subtraction” on <a href="ch04.xhtml#lev2_71">page 209</a>) produces a binary result of 0b1101. Interpreting this result as a <em>signed</em> value produces –3 (–8 + 4 + 1), the expected result for 2 – 5 without overflow. Alternatively, interpreting it as an <em>unsigned</em> value yields 13 (8 + 4 + 1), which is incorrect and clearly indicative of overflow. Scrutinizing this example further, it instinctively makes some <span epub:type="pagebreak" id="page_214"/>sense—the result should be negative, and a signed interpretation allows for negatives, whereas unsigned does not.</p>&#13;
<h5 class="h5" id="lev3_45">Unsigned Overflow</h5>&#13;
<p class="noindent"><em>Unsigned</em> numbers behave similarly to the decimal odometer examples given that both represent only non-negative values. <em>N</em> bits represent unsigned values in the range [0, 2<sup><em>N</em></sup> – 1], making all arithmetic modular with respect to 2<sup><em>N</em></sup>. <a href="ch04.xhtml#ch4fig9">Figure 4-9</a> illustrates an arrangement of the unsigned interpretations of four-bit sequences into a modular space.</p>&#13;
<div class="imagec" id="ch4fig9"><img alt="image" src="../images/04fig09.jpg"/></div>&#13;
<p class="figcap"><em>Figure 4-9: An arrangement of four-bit unsigned values into a modular space. All arithmetic is modular with respect to 2<sup>4</sup> (16).</em></p>&#13;
<p class="indent">Given that unsigned interpretations can’t hold negative values, the discontinuity again sits between the maximum value and zero. Therefore, unsigned overflow results from any operation that crosses the divide between 2<sup><em>N</em></sup> – 1 and 0. Stated more plainly, if performing addition (which should make the result <em>larger</em>) produces a smaller result, the addition caused unsigned overflow. Symmetrically, if performing subtraction (which should make the result <em>smaller</em>) produces a larger result, the subtraction caused unsigned overflow.</p>&#13;
<p class="indent">As a shortcut for detecting unsigned overflow for addition and subtraction, recall the carry out (<a href="ch04.xhtml#page_208">page 208</a>) and carry in (<a href="ch04.xhtml#page_209">page 209</a>) bits of those operations. A <em>carry out</em> is a carry from the most significant bit in the result of the computation. When set, a <em>carry in</em> increments the value of the result by carrying one into the least significant bit of the arithmetic operation. The <em>carry in</em> is only set to 1 for subtraction as part of the negation procedure.</p>&#13;
<p class="indent">The shortcut for unsigned arithmetic is: the carry out must match the carry in, otherwise the operation causes overflow. Intuitively, this shortcut works because:</p>&#13;
<ul>&#13;
<li class="noindent">For addition (carry in = 0), the result should be larger than (or equal to) the first operand. However, if the sum requires an extra bit of <span epub:type="pagebreak" id="page_215"/>storage (carry out = 1), then truncating that extra bit from the sum yields a smaller result (overflow). For example, in the unsigned four-bit number space, adding 0b1100 (12) + 0b1101 (13) requires <em>five</em> bits to store the result 0b11001 (25). When truncated to only four bits, the result represents 0b1001 (9), which is smaller than the operands (therefore, overflow).</li>&#13;
<li class="noindent">For subtraction (carry in = 1), the result should be smaller than (or equal to) the first operand. Since subtraction executes as a combination of addition and negation, the addition subproblem should produce a smaller result. The only way addition can end up with a smaller value is by truncating its sum (carry out = 1). If it doesn’t require truncation (carry out = 0), the subtraction yields a larger result (overflow).</li>&#13;
</ul>&#13;
<p class="indent">Let’s examine two examples of four-bit subtraction: one that overflows, and one that doesn’t. First, consider 0b0111 (7) – 0b1001 (9). The subtraction procedure treats this computation as:</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Problem Setup</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Converted to Addition</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Worked Example</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderr" style="vertical-align: middle"><p class="tab"><img alt="image" src="../images/t0215-01.jpg"/></p></td>&#13;
<td class="borderr" style="vertical-align: middle"><p class="tab"><img alt="image" src="../images/t0215-02.jpg"/></p></td>&#13;
<td style="vertical-align: middle"><p class="tab"><img alt="image" src="../images/t0215-03.jpg"/></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">The computation <em>did not</em> carry out of <em>d</em><sub>3</sub>, so no truncation occurs and the carry in (1) fails to match the carry out (0). The result, 0b1110 (14), is larger than either operand and thus clearly incorrect for 7 – 9 (overflow).</p>&#13;
<p class="indent">Next, consider 0b0111 (7) – 0b0101 (5). The subtraction procedure treats this computation as:</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>Problem Setup</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Converted to Addition</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>Worked Example</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="borderr" style="vertical-align: middle"><p class="tab"><img alt="image" src="../images/t0215-04.jpg"/></p></td>&#13;
<td class="borderr" style="vertical-align: middle"><p class="tab"><img alt="image" src="../images/t0215-05.jpg"/></p></td>&#13;
<td style="vertical-align: middle"><p class="tab"><img alt="image" src="../images/t0215-06.jpg"/></p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">The computation carries out a bit to <em>d</em><sub>4</sub>, causing the carry in (1) to match the carry out (1). The truncated result, 0b0010 (2), correctly represents the expected outcome of the subtraction operation (no overflow).</p>&#13;
<h5 class="h5" id="lev3_46">Signed Overflow</h5>&#13;
<p class="noindent">The same intuition behind overflow applies to <em>signed</em> binary interpretations: there exists a discontinuity in the modular number space. However, because <span epub:type="pagebreak" id="page_216"/>a signed interpretation allows for negatives, the discontinuity doesn’t occur around 0. Recall that two’s complement (see <a href="ch04.xhtml#lev2_69">page 204</a>) “rolls over” cleanly from –1 (0b1111 . . . 111) to 0 (0b0000 . . . 0em000). Thus, the discontinuity exists at the <em>other</em> end of the number space, where the largest positive value and smallest negative value meet.</p>&#13;
<p class="indent"><a href="ch04.xhtml#ch4fig10">Figure 4-10</a> shows an arrangement of the signed interpretations of four-bit sequences into a modular space. Note that half of the values are negative, the other half are non-negative, and the discontinuity lies at the min/max divide between them.</p>&#13;
<div class="imagec" id="ch4fig10"><img alt="image" src="../images/04fig10.jpg"/></div>&#13;
<p class="figcap"><em>Figure 4-10: An arrangement of four-bit signed values into a modular space. Because a signed interpretation allows for negative values, the discontinuity no longer resides at zero.</em></p>&#13;
<p class="indent">When performing signed arithmetic, it’s always safe to generate a result that moves closer to zero. That is, any operation that reduces the absolute value of the result cannot overflow, because the overflow discontinuity resides where the magnitude of the representable values is the largest.</p>&#13;
<p class="indent">Consequently, systems detect overflow in signed addition and subtraction by comparing the most significant bit of the operands with the most significant bit of the result. For subtraction, first rearrange the arithmetic in terms of addition (e.g., rewrite 5 – 2 as 5 + –2).</p>&#13;
<p class="indent">If the addition’s operands have <em>different</em> high-order bit values (i.e., one operand is negative and the other is positive), there can be no signed overflow, because the absolute value of the result must be smaller than (or equal to) either operand. The result is moving <em>toward</em> zero.</p>&#13;
<p class="indent">If the addition’s operands have the <em>same</em> high-order bit value (i.e., both are positive or both are negative), then a correct result must also have the same high-order bit value. Thus, when adding two operands with the same sign, a signed overflow occurs if the result’s sign differs from that of the operands.</p>&#13;
<p class="indent">Consider the following four-bit signed binary examples:</p>&#13;
<span epub:type="pagebreak" id="page_217"/>&#13;
<ul>&#13;
<li class="noindent">5 – 4 is equivalent to 5 + –4. The first operand (5) is positive, whereas the second (–4) is negative, so the result must be moving toward zero where <em>no overflow</em> is possible.</li>&#13;
<li class="noindent">4 + 2 (both positive) yields 6 (also positive), so <em>no overflow</em> occurs.</li>&#13;
<li class="noindent">–5 – 1 is equivalent to –5 + –1 (both negative) and yields –6 (also negative), so <em>no overflow</em> occurs.</li>&#13;
<li class="noindent">4 + 5 (both positive) yields –7 (negative). Since the operands have the same sign and it doesn’t match the result’s sign, this operation <em>overflows</em>.</li>&#13;
<li class="noindent">–3 – 8 is equivalent to –3 + –8 (both negative) and yields 5 (positive). Since the operands have the same sign and it doesn’t match the result’s sign, this operation <em>overflows</em>.</li>&#13;
</ul>&#13;
<h4 class="h4" id="lev2_75">4.5.3 Overflow Summary</h4>&#13;
<p class="noindent">In general, integer overflow occurs when an arithmetic operation moves between the minimum and maximum values that its result can represent. If you’re ever in doubt about the rules for signed versus unsigned overflow, consider the minimum and maximum values of an <em>N</em>-bit sequence:</p>&#13;
<ul>&#13;
<li class="noindent">The minimum <em>unsigned</em> value is 0 (because unsigned encodings can’t represent negative numbers) and the maximum unsigned value is 2<sup><em>N</em></sup> – 1 (because one bit sequence is reserved for zero). Therefore the discontinuity is between 2<sup><em>N</em></sup> – 1 and 0.</li>&#13;
<li class="noindent">The minimum <em>signed</em> value is –2<sup><em>N–</em>1</sup> (because half of the sequences are reserved for negative values) and the maximum is 2<sup><em>N–</em>1</sup> – 1 (because in the other half, one value is reserved for zero). Therefore, the discontinuity is between 2<sup><em>N–</em>1</sup> – 1 and –2<sup><em>N–</em>1</sup>.</li>&#13;
</ul>&#13;
<h4 class="h4" id="lev2_76">4.5.4 Overflow Consequences</h4>&#13;
<p class="noindent">While you may not run into integer overflow frequently, overflows have the potential to break programs in notable (and potentially devastating) ways.</p>&#13;
<p class="indent">For example, in 2014, PSY’s popular “Gangnam Style”<sup><a href="ch04.xhtml#fn4_1" id="rfn4_1">1</a></sup> music video threatened to overflow the 32-bit counter that YouTube used to track video hits. As a result, YouTube switched to using a 64-bit counter.</p>&#13;
<p class="indent">Another relatively harmless example shows up in the 1980 arcade game <em>Pac-Man</em>. The game’s developers used an unsigned eight-bit value to track the player’s progress through the game’s levels. As a result, if an expert player makes it beyond level 255 (the maximum value of an eight-bit unsigned integer), half of the board ends up glitching significantly, as shown in <a href="ch04.xhtml#ch4fig11">Figure 4-11</a>.</p>&#13;
<span epub:type="pagebreak" id="page_218"/>&#13;
<div class="imagec" id="ch4fig11"><img alt="image" src="../images/04fig11.jpg"/></div>&#13;
<p class="figcap"><em>Figure 4-11: The <em>Pac-Man</em> game board “freaks out” upon reaching level 256.</em></p>&#13;
<p class="indent">A much more tragic example of overflow appears in the history of the Therac-25<sup><a href="ch04.xhtml#fn4_2" id="rfn4_2">2</a></sup> radiation therapy machine of the mid 1980s. The Therac-25 suffered from several design problems, including one that incremented a truth flag variable rather than setting it to a constant. After enough uses, the flag overflowed, causing it to erroneously roll over to zero (false) and bypass safety mechanisms. The Therac-25 ultimately caused serious harm to (and in some cases killed) six patients.</p>&#13;
<h3 class="h3" id="lev1_33">4.6 Bitwise Operators</h3>&#13;
<p class="noindent">In addition to the standard arithmetic operations described earlier, CPUs also support operations that are uncommon outside of binary. These <em>bitwise operators</em> directly apply the behavior of logic gates (see “Basic Logic Gates” on <a href="ch05.xhtml#lev2_94">page 243</a>) to bit sequences, making them straightforward to implement efficiently in hardware. Unlike addition and subtraction, which programmers typically use to manipulate a variable’s numerical interpretation, programmers commonly use bitwise operators to modify specific bits in a variable. For example, a program might encode a certain bit position in a variable to hold a true/false meaning, and bitwise operations allow the program to manipulate the variable’s individual bits to change that specific bit.</p>&#13;
<h4 class="h4" id="lev2_77"><span epub:type="pagebreak" id="page_219"/>4.6.1 Bitwise AND</h4>&#13;
<p class="noindent">The bitwise AND operator (<span class="literal">&amp;</span>) evaluates two input bit sequences. For each digit of the inputs, it outputs a 1 in the corresponding position of the output if <em>both</em> inputs are 1 in that position. Otherwise, it outputs a 0 for the digit. <a href="ch04.xhtml#ch4tab7">Table 4-7</a> shows the truth table for the bitwise AND of two values, <em>A</em> and <em>B</em>.</p>&#13;
<p class="tabcap" id="ch4tab7"><strong>Table 4-7:</strong> The Results of Bitwise ANDing Two Values (A AND B)</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>A</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>B</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>A &amp; B</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">For example, to bitwise AND 0b011010 with 0b110110, start by lining up the two sequences. Checking vertically through each digit, set the result of the column to 1 if <em>both</em> digits are 1. Otherwise, set the result of the column to 0:</p>&#13;
<p class="programs">        011010<br/>&#13;
    AND 110110  Only digits 1 and 4 are 1's in BOTH inputs, so<br/>&#13;
Result: 010010  those are the only digits set to 1 in the output.</p>&#13;
<p class="indent">To perform a bitwise AND in C, place C’s bitwise AND operator (<span class="literal">&amp;</span>) between two operand variables. Here’s the example again, performed in C:</p>&#13;
<p class="programs">int x = 26;<br/>&#13;
int y = 54;<br/>&#13;
<br/>&#13;
printf("Result: %d\n", x &amp; y);  // Prints 18</p>&#13;
<p class="note"><strong><span class="black">Warning</span> BITWISE OPERATIONS VERSUS LOGICAL TRUTH OPERATIONS</strong></p>&#13;
<p class="note-w">Be careful not to conflate bitwise operators with logical truth operators (see “Boolean Values in C” on <a href="ch01.xhtml#lev2_6">page 32</a>). Despite having similar names (AND, OR, NOT, etc.), the two <em>are not</em> the same:</p>&#13;
<ul>&#13;
<li class="note-w">Bitwise operators consider each bit of their inputs independently and produce an output bit sequence as a function of the specific input bits that are set.</li>&#13;
<li class="note-w">Logical operators consider only the <em>truth</em> interpretation of their operands. To C, a value of zero is <em>false</em>, whereas all other values are considered <em>true</em>. Logical operators are often used when evaluating conditionals (e.g., <span class="literal">if</span> statements).</li>&#13;
</ul>&#13;
<p class="note-w"><span epub:type="pagebreak" id="page_220"/>Note that C often uses similar (but slightly different) operators to distinguish between the two. For example, you can indicate bitwise AND and bitwise OR using a single <span class="literal">&amp;</span> and <span class="literal">|</span>, respectively. Logical AND and logical OR correspond to a double <span class="literal">&amp;&amp;</span> and <span class="literal">||</span>. Finally, bitwise NOT uses <span class="literal">~</span>, whereas logical NOT is expressed by <span class="literal">!</span>.</p>&#13;
<h4 class="h4" id="lev2_78">4.6.2 Bitwise OR</h4>&#13;
<p class="noindent">The bitwise OR operator (<span class="literal">|</span>) behaves like the bitwise AND operator except that it outputs a 1 for a digit if <em>either or both</em> of the inputs is 1 in the corresponding position. Otherwise, it outputs a 0 for the digit. <a href="ch04.xhtml#ch4tab8">Table 4-8</a> shows the truth table for the bitwise OR of two values, <em>A</em> and <em>B</em>.</p>&#13;
<p class="tabcap" id="ch4tab8"><strong>Table 4-8:</strong> The Results of Bitwise ORing Two Values (A OR B)</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>A</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>B</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>A|B</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">For example, to bitwise OR 0b011010 with 0b110110, start by lining up the two sequences. Checking vertically through each digit, set the result of the column to 1 if <em>either</em> digit is 1:</p>&#13;
<p class="programs">        011010<br/>&#13;
     OR 110110     Only digit 0 contains a 0 in both inputs, so it's<br/>&#13;
Result: 111110     the only digit not set to 1 in the result.</p>&#13;
<p class="indent">To perform a bitwise OR in C, place C’s bitwise OR operator (<span class="literal">|</span>) between two operands. Here’s the same example again, performed in C:</p>&#13;
<p class="programs">int x = 26;<br/>&#13;
int y = 54;<br/>&#13;
<br/>&#13;
printf("Result: %d\n", x | y);  // Prints 62</p>&#13;
<h4 class="h4" id="lev2_79">4.6.3 Bitwise XOR (Exclusive OR)</h4>&#13;
<p class="noindent">The bitwise XOR operator (<span class="literal">^</span>) behaves like the bitwise OR operator except that it outputs a 1 for a digit only if <em>exactly one</em> (but not both) of the inputs is 1 in the corresponding position. Otherwise, it outputs a 0 for the digit. <a href="ch04.xhtml#ch4tab9">Table 4-9</a> shows the truth table for the bitwise XOR of two values, <em>A</em> and <em>B</em>.</p>&#13;
<p class="tabcap" id="ch4tab9"><span epub:type="pagebreak" id="page_221"/><strong>Table 4-9:</strong> The Results of Bitwise XORing Two Values (A XOR B)</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:30%"/>&#13;
<col style="width:40%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>A</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>B</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>A ^ B</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">For example, to bitwise XOR 0b011010 with 0b110110, start by lining up the two sequences. Checking vertically through each digit, set the result of the column to 1 if <em>only one</em> digit is 1:</p>&#13;
<p class="programs">        011010<br/>&#13;
    XOR 110110     Digits 2, 3, and 6 contain a 1 in exactly one of<br/>&#13;
Result: 101100     the two inputs.</p>&#13;
<p class="indent">To perform a bitwise XOR in C, place C’s bitwise XOR operator (<span class="literal">^</span>) between two operands. Here’s the same example again, performed in C:</p>&#13;
<p class="programs">int x = 26;<br/>&#13;
int y = 54;<br/>&#13;
<br/>&#13;
printf("Result: %d\n", x ^ y);  // Prints 44</p>&#13;
<h4 class="h4" id="lev2_80">4.6.4 Bitwise NOT</h4>&#13;
<p class="noindent">The bitwise NOT operator (<span class="literal">~</span>) operates on just one operand. For each bit in the sequence, it simply flips the bit such that a zero becomes a one, or vice versa. <a href="ch04.xhtml#ch4tab10">Table 4-10</a> shows the truth table for the bitwise NOT operator.</p>&#13;
<p class="tabcap" id="ch4tab10"><strong>Table 4-10:</strong> The Results of Bitwise NOTing a Value (A)</p>&#13;
<table class="line">&#13;
<colgroup>&#13;
<col style="width:50%"/>&#13;
<col style="width:50%"/>&#13;
</colgroup>&#13;
<tr class="borderb">&#13;
<td style="vertical-align: top"><p class="tab"><strong>A</strong></p></td>&#13;
<td style="vertical-align: top"><p class="tab"><strong>~A</strong></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top"><p class="tab">1</p></td>&#13;
<td style="vertical-align: top"><p class="tab">0</p></td>&#13;
</tr>&#13;
</table>&#13;
<p class="indent">For example, to bitwise NOT 0b011010, invert the value of each bit:</p>&#13;
<p class="programs">    NOT 011010<br/>&#13;
Result: 100101</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_222"/>To perform a bitwise NOT in C, place a tilde character (<span class="literal">~</span>) in front of an operand. Here’s the same example again, performed in C:</p>&#13;
<p class="programs">int x = 26;<br/>&#13;
<br/>&#13;
printf("Result: %d\n", ~x); // Prints -27</p>&#13;
<p class="note"><strong><span class="black">Warning</span> BITWISE NOT VERSUS NEGATION</strong></p>&#13;
<p class="note-w">Note that all modern systems represent integers using two’s complement, so bitwise NOT isn’t quite the same as negation. Bitwise NOT <em>only</em> flips the bits and <em>doesn’t</em> add one.</p>&#13;
<h4 class="h4" id="lev2_81">4.6.5 Bit Shifting</h4>&#13;
<p class="noindent">Another important bitwise operation involves shifting the position of an operand’s bits either to the left (<span class="literal">&lt;&lt;</span>) or to the right (<span class="literal">&gt;&gt;</span>). Both the left and right shifting operators take two operands: the bit sequence to shift and the number of places it should be shifted.</p>&#13;
<h5 class="h5" id="lev3_47">Shifting Left</h5>&#13;
<p class="noindent">Shifting a sequence to the left by <em>N</em> places moves each of its bits to the left <em>N</em> times, appending new zeros to the right side of the sequence. For example, shifting the eight-bit sequence 0b00101101 to the left by two produces 0b10110100. The two zeros at the right are appended to end of the sequence, since the result still needs to be an eight-bit sequence.</p>&#13;
<p class="indent">In the absence of overflow, shifting to the left <em>increases</em> the value of the result , since bits move toward digits that contribute larger powers of two to the value of the number. However, with a fixed number of bits, any bits that shift into positions beyond the maximum capacity of the number get truncated. For example, shifting the eight-bit sequence 0b11110101 (unsigned interpretation 245) to the left by one produces 0b11101010 (unsigned interpretation 234). Here, the truncation of the high-order bit that shifted out makes the result smaller.</p>&#13;
<p class="indent">To perform a left bit shift in C, place two less-than characters (<span class="literal">&lt;&lt;</span>) between a value and the number of places to shift that value:</p>&#13;
<p class="programs">int x = 13;  // 13 is 0b00001101<br/>&#13;
<br/>&#13;
printf("Result: %d\n", x &lt;&lt; 3);  // Prints 104 (0b01101000)</p>&#13;
<h5 class="h5" id="lev3_48">Shifting Right</h5>&#13;
<p class="noindent">Shifting to the right is similar to left shifting—any bits that are shifted out of a variable’s capacity (e.g., off the end to the right) disappear due to truncation. However, right shifting introduces an additional consideration: the new bits prepended to the left side of the result may need to be either all <span epub:type="pagebreak" id="page_223"/>zeros or all ones depending on the <em>type</em> of the variable being shifted and its high-order bit value. Conceptually, the choice to prepend zeros or ones resembles that of sign extension (see “Sign Extension” on <a href="ch04.xhtml#lev3_42">page 206</a>). Thus, there exist two distinct variants of right shifting:</p>&#13;
<ul>&#13;
<li class="noindent">A <em>logical right shift</em> always prepends zeros to the high-order bits of the result. Logical shifting is used to shift <em>unsigned</em> variables, since a leading 1 in the most significant bit of an unsigned value isn’t intended to mean that the value is negative. For example, shifting 0b10110011 to the right by two using a logical shift yields 0b00101100.</li>&#13;
<li class="noindent">An <em>arithmetic right shift</em> prepends a copy of the shifted value’s most significant bit into each of the new bit positions. Arithmetic shifting applies to <em>signed</em> variables, for which it’s important to preserve the signedness of the high-order bits. For example, shifting 0b10110011 to the right by two using an arithmetic shift yields 0b11101100.</li>&#13;
</ul>&#13;
<p class="indent">Fortunately, when programming in C, you don’t typically need to worry about the distinction if you’ve declared your variables properly. If your program includes a right shift operator (<span class="literal">&gt;&gt;</span>), virtually every C compiler will automatically perform the appropriate type of shifting according to the type of the shifting variable. That is, if the shifting variable was declared with the <em>unsigned</em> qualifier, the compiler will perform a logical shift. Otherwise, it will perform an arithmetic shift.</p>&#13;
<p class="note"><strong><span class="black">Note</span> C RIGHT SHIFT EXAMPLE PROGRAM</strong></p>&#13;
<p class="note-w">You can test the behavior of right shifting with a small example program like this one:</p>&#13;
<p class="programs-l">#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
int main(int argc, char **argv) {<br/>&#13;
    /* Unsigned integer value: u_val */<br/>&#13;
    unsigned int u_val = 0xFF000000;<br/>&#13;
<br/>&#13;
    /* Signed integer value: s_val */<br/>&#13;
    int s_val = 0xFF000000;<br/>&#13;
<br/>&#13;
    printf("%08X\n", u_val &gt;&gt; 12);  // logical right shift<br/>&#13;
    printf("%08X\n", s_val &gt;&gt; 12);  // arithmetic right shift<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<p class="note-w">This program declares two 32-bit integers: one as an unsigned integer (<span class="literal">u_val</span>), and another as a signed integer (<span class="literal">s_val</span>). It initializes both integers to the same starting value: a sequence of 8 ones followed by 24 zeros (<span class="literal">0b1111111100000000000000000000000000</span>), and then it shifts both values 12 positions to the right. When executed, it prints:</p>&#13;
<span epub:type="pagebreak" id="page_224"/>&#13;
<p class="programs-l">$ <span class="codestrong1">./a.out</span><br/>&#13;
000FF000<br/>&#13;
FFFFF000</p>&#13;
<p class="note-w">Because a leading 1 doesn’t indicate “negative” for the unsigned <span class="literal">u_val</span>, the compiler uses instructions to prepend it with only zeros. The shifted result contains 12 zeros, 8 ones, and 12 more zeros (<span class="literal">0b00000000000011111111000000000000</span>). On the other hand, the leading 1 <em>does</em> indicate “negative” for <span class="literal">s_val</span>, so the compiler prepends 1’s to the front of the shifted value, yielding 20 ones followed by 12 zeros (<span class="literal">0b11111111111111111111000000000000</span>).</p>&#13;
<h3 class="h3" id="lev1_34">4.7 Integer Byte Order</h3>&#13;
<p class="noindent">So far, this chapter has described several schemes for encoding numbers with bits, but it hasn’t mentioned how the values are organized in memory. For modern systems, the smallest addressable unit of memory is a byte, which consists of eight bits. Consequently, to store a one-byte value (e.g., a variable of type <span class="literal">char</span>) starting at address <em>X</em>, you don’t really have any options—just store the byte at location <em>X</em>.</p>&#13;
<p class="indent">However, for multibyte values (e.g., variables of type <span class="literal">short</span> or <span class="literal">int</span>), the hardware has more options for assigning a value’s bytes to memory addresses. For example, consider a two-byte <span class="literal">short</span> variable <span class="literal">s</span> whose bytes are labeled A (containing the high-order bits of <span class="literal">s</span>) and B (containing the low-order bits of <span class="literal">s</span>). When a system is asked to store a <span class="literal">short</span> like <span class="literal">s</span> at address <em>X</em> (i.e., in addresses <em>X</em> and <em>X</em> + 1), it must define which byte of the variable (A or B) should occupy which address (<em>X</em> or <em>X</em> + 1). <a href="ch04.xhtml#ch4fig12">Figure 4-12</a> shows the two options for storing <span class="literal">s</span> in memory.</p>&#13;
<div class="imagec" id="ch4fig12"><img alt="image" src="../images/04fig12.jpg"/></div>&#13;
<p class="figcap"><em>Figure 4-12: Two potential memory layouts for a two-byte short starting at memory address <em>X</em></em></p>&#13;
<p class="indent">The <em>byte order</em> (or <em>endianness</em>) of a system defines how its hardware assigns the bytes of a multibyte variable to consecutive memory addresses. Although byte order is rarely an issue for programs that only run on a single system, it might appear surprising if one of your programs attempts to print bytes one at a time or if you’re examining variables with a debugger.</p>&#13;
<p class="indent">For example, consider the following program:</p>&#13;
<p class="programs">#include &lt;stdio.h&gt;<br/>&#13;
<br/>&#13;
int main(int argc, char **argv) {<br/>&#13;
    // Initialize a four-byte integer with easily distinguishable byte values<br/>&#13;
<span epub:type="pagebreak" id="page_225"/>&#13;
    int value = 0xAABBCCDD;<br/>&#13;
<br/>&#13;
    // Initialize a character pointer to the address of the integer.<br/>&#13;
    char *p = (char *) &amp;value;<br/>&#13;
<br/>&#13;
    // For each byte in the integer, print its memory address and value.<br/>&#13;
    int i;<br/>&#13;
    for (i = 0; i &lt; sizeof(value); i++) {<br/>&#13;
        printf("Address: %p, Value: %02hhX\n", p, *p);<br/>&#13;
        p += 1;<br/>&#13;
    }<br/>&#13;
<br/>&#13;
    return 0;<br/>&#13;
}</p>&#13;
<p class="indent">This program allocates a four-byte integer and initializes the bytes, in order from most to least significant, to the hexadecimal values <span class="literal">0xAA</span>, <span class="literal">0xBB</span>, <span class="literal">0xCC</span>, and <span class="literal">0xDD</span>. It then prints the bytes one at a time starting from the base address of the integer. You’d be forgiven for expecting the bytes to print in alphabetical order. However, commonly used CPU architectures (i.e., x86 and most ARM hardware) print the bytes in reverse order when executing the example program:</p>&#13;
<p class="programs">$ <span class="codestrong1">./a.out</span><br/>&#13;
Address: 0x7ffc0a234928, Value: DD<br/>&#13;
Address: 0x7ffc0a234929, Value: CC<br/>&#13;
Address: 0x7ffc0a23492a, Value: BB<br/>&#13;
Address: 0x7ffc0a23492b, Value: AA</p>&#13;
<p class="indent">x86 CPUs store integers in a <em>little-endian</em> format—from least-significant byte (“little end”) to the most-significant byte in consecutive addresses. Other <em>big-endian</em> CPU architectures store multibyte integers in the opposite order. <a href="ch04.xhtml#ch4fig13">Figure 4-13</a> depicts a four-byte integer in the (a) big-endian and (b) little-endian layouts.</p>&#13;
<div class="imagec" id="ch4fig13"><img alt="image" src="../images/04fig13.jpg"/></div>&#13;
<p class="figcap"><em>Figure 4-13: The memory layout of a four-byte integer in the (a) big-endian and (b) little-endian formats</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_226"/>The seemingly strange “endian” terminology originates from Jonathan Swift’s satirical novel <em>Gulliver’s Travels</em> (1726).<sup><a href="ch04.xhtml#fn4_3" id="rfn4_3">3</a></sup> In the story, Gulliver finds himself among two empires of six-inch-tall people who are fighting a war over the proper method for breaking eggs. The “big-endian” empire of Blefuscu cracks the large end of their eggs, whereas people in the “little-endian” empire of Lilliput crack the small end.</p>&#13;
<p class="indent">In the computing world, whether a system is <em>big-endian</em> or <em>little-endian</em> typically affects only programs that communicate across machines (e.g., over a network). When communicating data between systems, both systems must agree on the byte order for the receiver to properly interpret the value. In 1980, Danny Cohen authored a note to the Internet Engineering Task Force (IETF) titled <em>On Holy Wars and a Plea for Peace</em>.<sup><a href="ch04.xhtml#fn4_4" id="rfn4_4">4</a></sup> In that note, Cohen adopts Swift’s “endian” terminology and suggests that the IETF adopts a standard byte order for network transmissions. The IETF eventually adopted <em>big-endian</em> as the “network byte order” standard.</p>&#13;
<p class="indent">The C language provides two libraries that allow a program to reorder an integer’s bytes<sup><a href="ch04.xhtml#fn4_5" id="rfn4_5">5</a></sup> for communication purposes.</p>&#13;
<h3 class="h3" id="lev1_35">4.8 Real Numbers in Binary</h3>&#13;
<p class="noindent">While this chapter mainly focuses on binary integer representations, programmers often need to store real numbers, too. Storing real numbers is inherently difficult, and no binary encoding represents real values with perfect precision. That is, for any binary encoding of real numbers, there exist values that cannot be represented <em>exactly</em>. Irrational values like <em>π</em> clearly can’t be represented precisely, since their representation never terminates. Given a fixed number of bits, binary encodings still can’t represent some rational values within their range.</p>&#13;
<p class="indent">Unlike integers, which are countably infinite,<sup><a href="ch04.xhtml#fn4_6" id="rfn4_6">6</a></sup> the set of real numbers is uncountable.<sup><a href="ch04.xhtml#fn4_7" id="rfn4_7">7</a></sup> In other words, even for a narrow range of real values (e.g., between zero and one), the set of values within that range is so large that we can’t even begin to enumerate them. Thus, real number encodings typically store only approximations of values that have been truncated to a predetermined number of bits. Given enough bits, the approximations are typically precise enough for most purposes, but be careful when writing applications that cannot tolerate rounding.</p>&#13;
<p class="indent">The remainder of this section briefly describes two methods for representing real numbers in binary: <em>fixed-point</em>, which extends the binary integer format, and <em>floating-point</em>, which represents a large range of values at the cost of some extra complexity.</p>&#13;
<h4 class="h4" id="lev2_82">4.8.1 Fixed-Point Representation</h4>&#13;
<p class="noindent">In a <em>fixed-point representation</em>, the position of a value’s <em>binary point</em> remains fixed and cannot be changed. Like a <em>decimal point</em> in a decimal number, the binary point indicates where the fractional portion of the number begins. The fixed-point encoding rules resemble the unsigned integer representation <span epub:type="pagebreak" id="page_227"/>(see “Unsigned Binary Numbers” on <a href="ch04.xhtml#lev2_62">page 193</a>), with one major exception: the digits after the binary point represent powers of two raised to a <em>negative</em> value. For example, consider the eight-bit sequence 0b000101.10 in which the first six bits represent whole numbers, and the remaining two bits represent the fractional part. <a href="ch04.xhtml#ch4fig14">Figure 4-14</a> labels the digit positions and their individual interpretations.</p>&#13;
<div class="imagec" id="ch4fig14"><img alt="image" src="../images/04fig14.jpg"/></div>&#13;
<p class="figcap"><em>Figure 4-14: The value of each digit in an eight-bit number with two bits after the fixed binary point</em></p>&#13;
<p class="indent">Applying the formula for converting 0b000101.10 to decimal shows:</p>&#13;
<p class="center">(0 × 2<sup>5</sup>) + (0 × 2<sup>4</sup>) + (0 × 2<sup>3</sup>) + (1 × 2<sup>2</sup>) + (0 × 2<sup>1</sup>) + (1 × 2<sup>0</sup>) + (1 × 2<sup>–1</sup>) + (0 × 2<sup>–2</sup>) = 0 + 0 + 0 + 4 + 0 + 1 + 0.5 + 0 = 5.5</p>&#13;
<p class="indent">More generally, with two bits after the binary point, the fractional portion of a number holds one of four sequences: 00 (.00), 01 (.25), 10 (.50), or 11 (.75). Thus, two fractional bits allow a fixed-point number to represent fractional values that are precise to 0.25 (2<sup>–2</sup>). Adding a third bit increases the precision to 0.125 (2<sup>–3</sup>), and the pattern continues similarly, with <em>N</em> bits after the binary point enabling 2<sup><em>–N</em></sup> precision.</p>&#13;
<p class="indent">Because the number of bits after the binary point remains fixed, some computations with fully precise operands may produce a result that requires truncation (rounding). Consider the same eight-bit fixed-point encoding from the previous example. It precisely represents both 0.75 (0b000000.11) and 2 (0b000010.00). However, it cannot precisely represent the result of dividing 0.75 by 2: the computation <em>should</em> produce 0.375, but storing it would require a third bit after the binary point (0b000000.011). Truncating the rightmost 1 enables the result to fit within the specified format, but it yields a rounded result of 0.75 / 2 = 0.25. In this example, the rounding is egregious due to the small number of bits involved, but even longer bit sequences will require truncation at some point.</p>&#13;
<p class="indent">Even worse, rounding errors compound over the course of intermediate calculations, and in some cases the result of a sequence of computations might vary according to the order in which they’re performed. For example, consider two arithmetic sequences under the same eight-bit fixed-point encoding described earlier:</p>&#13;
<div class="number">&#13;
<p class="number">1. <span class="literal">(0.75 / 2) * 3 = 0.75</span></p>&#13;
<p class="number"><span epub:type="pagebreak" id="page_228"/>2. <span class="literal">(0.75 * 3) / 2 = 1.00</span></p>&#13;
</div>&#13;
<p class="indent">Note that the only difference between the two is the order of the multiplication and division operations. If no rounding were necessary, both computations should produce the same result (1.125). However, due to truncation occurring at different locations in the arithmetic, they produce different results:</p>&#13;
<div class="number">&#13;
<p class="number">1. Proceeding from left to right, the intermediate result (<span class="literal">0.75 / 2</span>) gets rounded to 0.25 and ultimately produces 0.75 when multiplied by 3.</p>&#13;
<p class="number">2. Proceeding from left to right, the intermediate computation (<span class="literal">0.75</span> <span class="literal">* 3</span>) precisely yields 2.25 without any rounding. Dividing 2.25 by 2 rounds to a final result of 1.</p>&#13;
</div>&#13;
<p class="indent">In this example, just one additional bit for the 2<sup>–3</sup> place allows the example to succeed with full precision, but the fixed-point position we chose only allowed for two bits after the binary point. All the while, the high-order bits of the operands went entirely unused (digits <em>d</em><sub>2</sub> through <em>d</em><sub>5</sub> were never set to 1). At the cost of extra complexity, an alternative representation (floating-point) allows the full range of bits to contribute to a value regardless of the split between whole and fractional parts.</p>&#13;
<h4 class="h4" id="lev2_83">4.8.2 Floating-Point Representation</h4>&#13;
<p class="noindent">In a <em>floating-point representation</em>, a value’s binary point is <em>not</em> fixed into a predefined position. That is, the interpretation of a binary sequence must encode how it’s representing the split between the whole and fractional parts of a value. While the position of the binary point could be encoded in many possible ways, this section focuses on just one, the Institute of Electrical and Electronics Engineers (IEEE) standard 754.<sup><a href="ch04.xhtml#fn4_8" id="rfn4_8">8</a></sup> Almost all modern hardware follows the IEEE 754 standard to represent floating-point values.</p>&#13;
<div class="imagec" id="ch4fig15"><img alt="image" src="../images/04fig15.jpg"/></div>&#13;
<p class="figcap"><em>Figure 4-15: The 32-bit IEEE 754 floating-point standard</em></p>&#13;
<p class="indent"><a href="ch04.xhtml#ch4fig15">Figure 4-15</a> illustrates the IEEE 754 interpretation of a 32-bit floating-point number (C’s <span class="literal">float</span> type). The standard partitions the bits into three regions:</p>&#13;
<div class="number">&#13;
<p class="number">1. The low-order 23 bits (digits <em>d</em><sub>22</sub> through <em>d</em><sub>0</sub>) represent the <em>significand</em> (sometimes called the <em>mantissa</em>). As the largest region of bits, the significand serves as the foundation for the value, which ultimately gets altered by multiplying it according to the other bit regions. <span epub:type="pagebreak" id="page_229"/>When interpreting the significand, its value implicitly follows a 1 and binary point. The fractional portion behaves like the fixed-point representation described in the previous section.</p>&#13;
<p class="number-p">For example, if the bits of the significand contain 0b110000…0000, the first bit represents 0.5 (1 × 2<sup>–1</sup>), the second bit represents 0.25 (1 × 2<sup>–2</sup>), and all the remaining bits are zeros, so they don’t affect the value. Thus, the significand contributes 1.(0.5 + 0.25), or 1.75.</p>&#13;
<p class="number">2. The next eight bits (digits <em>d</em><sub>30</sub> through <em>d</em><sub>23</sub>) represent the <em>exponent</em>, which scales the significand’s value to provide a wide representable range. The significand gets multiplied by 2<sup>(exponent–127)</sup>, where the 127 is a <em>bias</em> that enables the float to represent both very large and very small values.</p>&#13;
<p class="number">3. The final high-order bit (digit <em>d</em><sub>31</sub>) represents the <em>sign bit</em>, which encodes whether the value is positive (0) or negative (1).</p>&#13;
</div>&#13;
<p class="indent">As an example, consider decoding the bit sequence 0b110000011011 01000000000000000000. The significand portion is 01101000000000000000000, which represents 2<sup>–2</sup> + 2<sup>–3</sup> + 2<sup>–5</sup> = 0<em>.</em>40625, so the signifcand region contributes 1.40625. The exponent is 10000011, which represents the decimal value 131, so the exponent contributes a factor of 2<sup>(131–127)</sup> (16). Finally, the sign bit is 1, so the sequence represents a negative value. Putting it all together, the bit sequence represents 1<em>.</em>40625 × 16 × –1 = –22<em>.</em>5.</p>&#13;
<p class="indent">Although clearly more complex than the fixed-point scheme described earlier, the IEEE floating-point standard provides additional flexibility for representing a wide range of values. Despite the flexibility, a floating-point format with a constant number of bits still can’t precisely represent every possible value. That is, like fixed-point, rounding problems similarly affect floating-point encodings.</p>&#13;
<h4 class="h4" id="lev2_84">4.8.3 Rounding Consequences</h4>&#13;
<p class="noindent">While rounding isn’t likely to ruin most of the programs you write, real number rounding errors have occasionally caused some high-profile system failures. During the Gulf War in 1991, a rounding error caused an American Patriot missile battery to fail to intercept an Iraqi missile.<sup><a href="ch04.xhtml#fn4_9" id="rfn4_9">9</a></sup> The missile killed 28 soldiers and left many others wounded. In 1996, the European Space Agency’s first launch of the Ariane 5 rocket exploded 39 seconds after taking off.<sup><a href="ch04.xhtml#fn4_10" id="rfn4_10">10</a></sup> The rocket, which borrowed much of its code from the Ariane 4, triggered an overflow when attempting to convert a floating-point value into an integer value.</p>&#13;
<h3 class="h3" id="lev1_36">4.9 Summary</h3>&#13;
<p class="noindent">This chapter examined how modern computers represent information using bits and bytes. An important takeaway is that a computer’s memory stores all information as binary 0’s and 1’s—it’s up to programs or the people running <span epub:type="pagebreak" id="page_230"/>them to interpret the meaning of those bits. This chapter primarily focused on integer representations, beginning with unsigned (non-negative) integers before considering signed integers.</p>&#13;
<p class="indent">Computer hardware supports a variety of operations on integers, including the familiar addition, subtraction, multiplication, and division. Systems also provide bitwise operations like bitwise AND, OR, NOT, and shifting. When performing <em>any</em> operation, consider the number of bits used to represent the operands and result. If the storage space allocated to the result isn’t large enough, an overflow may misrepresent the resulting value.</p>&#13;
<p class="indent">Finally, this chapter explored common schemes for representing real numbers in binary, including the standard IEEE 754 standard. Note that when representing floating-point values, we sacrifice precision for increased flexibility (i.e., the ability to move the decimal point).</p>&#13;
<h3 class="h3" id="lev1_37">Notes</h3>&#13;
<p class="fnote"><a href="ch04.xhtml#rfn4_1" id="fn4_1">1.</a> <em><a href="https://en.wikipedia.org/wiki/Gangnam_Style">https://en.wikipedia.org/wiki/Gangnam_Style</a></em></p>&#13;
<p class="fnote"><a href="ch04.xhtml#rfn4_2" id="fn4_2">2.</a> <em><a href="https://en.wikipedia.org/wiki/Therac-25">https://en.wikipedia.org/wiki/Therac-25</a></em></p>&#13;
<p class="fnote"><a href="ch04.xhtml#rfn4_3" id="fn4_3">3.</a> Jonathan Swift, <em>Gulliver’s Travels</em>. <em><a href="http://www.gutenberg.org/ebooks/829">http://www.gutenberg.org/ebooks/829</a></em></p>&#13;
<p class="fnote"><a href="ch04.xhtml#rfn4_4" id="fn4_4">4.</a> Danny Cohen, <em>On Holy Wars and a Plea for Peace</em>. <em><a href="https://www.ietf.org/rfc/ien/ien137.txt">https://www.ietf.org/rfc/ien/ien137.txt</a></em></p>&#13;
<p class="fnote"><a href="ch04.xhtml#rfn4_5" id="fn4_5">5.</a> <em><a href="https://linux.die.net/man/3/byteorder">https://linux.die.net/man/3/byteorder</a>, <a href="https://linux.die.net/man/3/endian">https://linux.die.net/man/3/endian</a></em></p>&#13;
<p class="fnote"><a href="ch04.xhtml#rfn4_6" id="fn4_6">6.</a> <em><a href="https://en.wikipedia.org/wiki/Countable_set">https://en.wikipedia.org/wiki/Countable_set</a></em></p>&#13;
<p class="fnote"><a href="ch04.xhtml#rfn4_7" id="fn4_7">7.</a> <em><a href="https://en.wikipedia.org/wiki/Uncountable_set">https://en.wikipedia.org/wiki/Uncountable_set</a></em></p>&#13;
<p class="fnote"><a href="ch04.xhtml#rfn4_8" id="fn4_8">8.</a> <em><a href="https://en.wikipedia.org/wiki/IEEE_754">https://en.wikipedia.org/wiki/IEEE_754</a></em></p>&#13;
<p class="fnote"><a href="ch04.xhtml#rfn4_9" id="fn4_9">9.</a> <em><a href="http://www-users.math.umn.edu/~arnold/disasters/patriot.html">http://www-users.math.umn.edu/~arnold/disasters/patriot.html</a></em></p>&#13;
<p class="fnote1"><a href="ch04.xhtml#rfn4_10" id="fn4_10">10.</a> <em><a href="https://medium.com/@bishr_tabbaa/crash-and-burn-a-short-story-of-ariane-5-flight-501-3a3c50e0e284">https://medium.com/@bishr_tabbaa/crash-and-burn-a-short-story-of-ariane-5-flight-501-3a3c50e0e284</a></em></p>&#13;
</body></html>