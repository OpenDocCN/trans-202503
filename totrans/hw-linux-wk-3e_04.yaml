- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Disks and Filesystems
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In Chapter 3, we saw an overview of some of the top-level disk devices that
    the kernel makes available. In this chapter, we’ll discuss in detail how to work
    with disks on a Linux system. You’ll learn how to partition disks, create and
    maintain the filesystems that go inside disk partitions, and work with swap space.
  prefs: []
  type: TYPE_NORMAL
- en: Recall that disk devices have names like */dev/sda*, the first SCSI subsystem
    disk. This kind of block device represents the entire disk, but there are many
    different components and layers inside a disk.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-1](#figure4-1) illustrates a schematic of a simple Linux disk (note
    that the figure is not to scale). As you progress through this chapter, you’ll
    learn where each piece fits in.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f04001](image_fi/500402c04/f04001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-1: Typical Linux disk schematic'
  prefs: []
  type: TYPE_NORMAL
- en: '*Partitions* are subdivisions of the whole disk. On Linux, they’re denoted
    with a number after the whole block device, so they have names like */dev/sda1*
    and */dev/sdb3*. The kernel presents each partition as a block device, just as
    it would an entire disk. Partitions are defined on a small area of the disk called
    a *partition table* (also called a *disk label*).'
  prefs: []
  type: TYPE_NORMAL
- en: The kernel makes it possible for you to access both an entire disk and one of
    its partitions at the same time, but you wouldn’t normally do so unless you were
    copying the entire disk.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux *Logical Volume Manager (LVM)* adds more flexibility to traditional
    disk devices and partitions, and is now in use in many systems. We’ll cover LVM
    in Section 4.4.
  prefs: []
  type: TYPE_NORMAL
- en: The next layer up from the partition is the *filesystem*, the database of files
    and directories that you’re accustomed to interacting with in user space. We’ll
    explore filesystems in Section 4.2.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Figure 4-1](#figure4-1), if you want to access the data in
    a file, you need to use the appropriate partition location from the partition
    table and then search the filesystem database on that partition for the desired
    file data.
  prefs: []
  type: TYPE_NORMAL
- en: To access data on a disk, the Linux kernel uses the system of layers shown in
    [Figure 4-2](#figure4-2). The SCSI subsystem and everything else described in
    Section 3.6 are represented by a single box. Notice that you can work with the
    disk through the filesystem as well as directly through the disk devices. You’ll
    see how both methods work in this chapter. To make things simpler, LVM is not
    represented in [Figure 4-2](#figure4-2), but it has components in the block device
    interface and a few management components in user space.
  prefs: []
  type: TYPE_NORMAL
- en: To get a handle on how everything fits together, let’s start at the bottom with
    partitions.
  prefs: []
  type: TYPE_NORMAL
- en: '![f04002](image_fi/500402c04/f04002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-2: Kernel schematic for disk access'
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Partitioning Disk Devices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many kinds of partition tables. There’s nothing special about a partition
    table—it’s just a bunch of data that says how the blocks on the disk are divided.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional table, dating back to the PC days, is the one found inside the
    *Master Boot Record (MBR)*, and it has many limitations. Most newer systems use
    the *Globally Unique Identifier Partition Table (GPT)*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few of the many Linux partitioning tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '`parted` **(“partition editor”)** A text-based tool that supports both MBR
    and GPT.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`gparted` A graphical version of `parted`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`fdisk` The traditional text-based Linux disk partitioning tool. Recent versions
    of `fdisk` support the MBR, GPT, and many other kinds of partition tables, but
    older versions were limited to MBR support.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because it has supported both the MBR and GPT for some time, and it’s easy to
    run single commands to get partition labels, we’ll use `parted` to display partition
    tables. However, when creating and altering partition tables, we’ll use `fdisk`.
    This will illustrate both interfaces, and why many people prefer the `fdisk` interface
    due to its interactive nature and the fact that it doesn’t make any changes to
    the disk until you’ve had a chance to review them (we’ll discuss this shortly).
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.1 Viewing a Partition Table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can view your system’s partition table with `parted -l`. This sample output
    shows two disk devices with two different kinds of partition tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first device (*/dev/sda*) 1 uses the traditional MBR partition table (which
    `parted` calls `msdos`), and the second (*/dev/sdf*) 2 contains a GPT. Notice
    that the two table types store different sets of parameters. In particular, the
    MBR table has no `Name` column because names don’t exist under that scheme. (I
    arbitrarily chose the names `myfirst` and `mysecond` in the GPT.)
  prefs: []
  type: TYPE_NORMAL
- en: MBR Basics
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The MBR table in this example contains primary, extended, and logical partitions.
    A *primary partition* is a normal subdivision of the disk; partition 1 is an example.
    The basic MBR has a limit of four primary partitions, so if you want more than
    four, you must designate one as an *extended partition*. An extended partition
    breaks down into *logical partitions*, which the operating system can then use
    as it would any other partition. In this example, partition 2 is an extended partition
    that contains logical partition 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'LVM Partitions: A Sneak Peek'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When viewing your partition table, if you see partitions labeled as LVM (code
    `8e` as the partition type), devices named `/dev/dm-*`, or references to the “device
    mapper,” then your system uses LVM. Our discussion will start with traditional
    direct disk partitioning, which will look slightly different from what’s on a
    system using LVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just so you know what to expect, let’s take a quick look at some sample `parted
    -l` output on a system with LVM (a fresh installation of Ubuntu using LVM on VirtualBox).
    First, there’s a description of the actual partition table, which looks mostly
    as you’d expect, except for the `lvm` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then there are some devices that look like they should be partitions, but are
    called disks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A simple way to think about this is that the partitions have been somehow separated
    from the partition table. You’ll see what’s actually going on in Section 4.4.
  prefs: []
  type: TYPE_NORMAL
- en: Initial Kernel Read
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When initially reading the MBR table, the Linux kernel produces debugging output
    like this (remember that you can view this with `journalctl -k`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `sda2 < sda5 >` portion of the output indicates that */dev/sda2* is an extended
    partition containing one logical partition, */dev/sda5*. You’ll normally ignore
    the extended partition itself because you typically care only about accessing
    the logical partitions it contains.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.2 Modifying Partition Tables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Viewing partition tables is a relatively simple and harmless operation. Altering
    partition tables is also relatively easy, but making this kind of change to the
    disk involves risks. Keep the following in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the partition table makes it quite difficult to recover any data on
    partitions that you delete or redefine, because doing so can erase the location
    of the filesystems on those partitions. Make sure you have a backup if the disk
    you’re partitioning contains critical data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that no partitions on your target disk are currently in use. This is
    a concern because most Linux distributions automatically mount any detected filesystem.
    (See Section 4.2.3 for more on mounting and unmounting.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you’re ready, choose your partitioning program. If you’d like to use `parted`,
    you can use the command-line `parted` utility or a graphical interface, such as
    `gparted`; `fdisk` is fairly easy to work with on the command line. These utilities
    all have online help and are easy to learn. (Try using them on a flash device
    or something similar if you don’t have any spare disks.)
  prefs: []
  type: TYPE_NORMAL
- en: That said, there is a major difference in the way that `fdisk` and `parted`
    work. With `fdisk`, you design your new partition table before making the actual
    changes to the disk, and it makes the changes only when you exit the program.
    But with `parted`, partitions are created, modified, and removed *as you issue
    the commands*. You don’t get the chance to review the partition table before you
    change it.
  prefs: []
  type: TYPE_NORMAL
- en: These differences are also key to understanding how the two utilities interact
    with the kernel. Both `fdisk` and `parted` modify the partitions entirely in user
    space; there’s no need to provide kernel support for rewriting a partition table,
    because user space can read and modify all of a block device.
  prefs: []
  type: TYPE_NORMAL
- en: 'At some point, though, the kernel must read the partition table in order to
    present the partitions as block devices so you can use them. The `fdisk` utility
    uses a relatively simple method. After modifying the partition table, `fdisk`
    issues a single system call to tell the kernel that it should reread the disk’s
    partition table (you’ll see an example of how to interact with `fdisk` shortly).
    The kernel then generates debugging output, which you can view with `journalctl
    -k`. For example, if you create two partitions on */dev/sdf*, you’ll see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `parted` tools do not use this disk-wide system call; instead, they signal
    the kernel when individual partitions are altered. After processing a single partition
    change, the kernel does not produce the preceding debugging output.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few ways to see the partition changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `udevadm` to watch the kernel event changes. For example, the command `udevadm
    monitor --kernel` will show the old partition devices being removed and the new
    ones being added.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check */proc/partitions* for full partition information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check */sys/block/device/* for altered partition system interfaces or */dev*
    for altered partition devices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.1.3 Creating a Partition Table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s apply everything you just learned by creating a new partition table on
    a new, empty disk. This example shows the following scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: 4GB disk (a small USB flash device, unused; if you want to follow this example,
    use any size device that you have at hand)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MBR-style partition table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Two partitions intended to be populated with an ext4 filesystem: 200MB and
    3.8GB'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disk device at */dev/sdd*; you’ll need to find your own device location with
    `lsblk`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You’ll use `fdisk` to do the work. Recall that this is an interactive command,
    so after ensuring that nothing on the disk is mounted, you’ll start at the command
    prompt with the device name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll get an introductory message and then a command prompt like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'First, print the current table with the `p` command (`fdisk` commands are rather
    terse). Your interaction will probably look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Most devices already contain one FAT-style partition, like this one at */dev/sdd1*.
    Because you want to create new partitions for Linux (and, of course, you’re sure
    you don’t need anything here), you can delete the existing ones like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Remember that `fdisk` doesn’t make changes until you explicitly write the partition
    table, so you haven’t yet modified the disk. If you make a mistake you can’t recover
    from, use the `q` command to quit `fdisk` without writing the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you’ll create the first 200MB partition with the `n` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, `fdisk` prompts you for the MBR partition style, the partition number,
    the start of the partition, and its end (or size). The default values are quite
    often what you want. The only thing changed here is the partition end/size with
    the `+` syntax to specify a size and unit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating the second partition works the same way, except you’ll use all default
    values, so we won’t go over that. When you’re finished laying out the partitions,
    use the `p` (print) command to review:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When you’re ready to write the partition table, use the `w` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note that `fdisk` doesn’t ask you if you’re sure as a safety measure; it simply
    does its work and exits.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in additional diagnostic messages, use `journalctl -k`
    to see the kernel read messages mentioned earlier, but remember that you’ll get
    them only if you’re using `fdisk`.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you have all the basics to start partitioning disks, but if you’d
    like more details about disks, read on. Otherwise, skip ahead to Section 4.2 to
    learn about putting a filesystem on the disk.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.4 Navigating Disk and Partition Geometry
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any device with moving parts introduces complexity into a software system because
    there are physical elements that resist abstraction. A hard disk is no exception;
    even though you can think of a hard disk as a block device with random access
    to any block, there can be serious performance consequences if the system isn’t
    careful about how it lays out data on the disk. Consider the physical properties
    of the simple single-platter disk illustrated in [Figure 4-3](#figure4-3).
  prefs: []
  type: TYPE_NORMAL
- en: '![f04003](image_fi/500402c04/f04003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-3: Top-down view of a hard disk'
  prefs: []
  type: TYPE_NORMAL
- en: The disk consists of a spinning platter on a spindle, with a head attached to
    a moving arm that can sweep across the radius of the disk. As the disk spins underneath
    the head, the head reads data. When the arm is in one position, the head can read
    data only from a fixed circle. This circle is called a *cylinder* because larger
    disks have more than one platter, all stacked and spinning around the same spindle.
    Each platter can have one or two heads, for the top and/or bottom of the platter,
    and all heads are attached to the same arm and move in concert. Because the arm
    moves, there are many cylinders on the disk, from small ones around the center
    to large ones around the periphery of the disk. Finally, you can divide a cylinder
    into slices called *sectors*. This way of thinking about the disk geometry is
    called *CHS*, for *cylinder-head-sector*; in older systems, you could find any
    part of the disk by addressing it with these three parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel and the various partitioning programs can tell you what a disk reports
    as its number of cylinders. However, on any halfway recent hard disk, *the reported
    values are fiction*! The traditional addressing scheme that uses CHS doesn’t scale
    with modern disk hardware, nor does it account for the fact that you can put more
    data into outer cylinders than inner cylinders. Disk hardware supports *Logical
    Block Addressing (LBA)* to address a location on the disk by a block number (this
    is a much more straightforward interface), but remnants of CHS remain. For example,
    the MBR partition table contains CHS information as well as LBA equivalents, and
    some boot loaders are still dumb enough to believe the CHS values (don’t worry—most
    Linux boot loaders use the LBA values).
  prefs: []
  type: TYPE_NORMAL
- en: 4.1.5 Reading from Solid-State Disks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Storage devices with no moving parts, such as *solid-state disks (SSDs)*, are
    radically different from spinning disks in terms of their access characteristics.
    For these, random access isn’t a problem because there’s no head to sweep across
    a platter, but certain characteristics can change how an SSD performs.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most significant factors affecting the performance of SSDs is *partition
    alignment*. When you read data from an SSD, you read it in chunks (called *pages*,
    not to be confused with virtual memory pages)—such as 4,096 or 8,192 bytes at
    a time—and the read must begin at a multiple of that size. This means that if
    your partition and its data do not lie on a boundary, you may have to do two reads
    instead of one for small, common operations, such as reading the contents of a
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: Reasonably new versions of partitioning utilities include logic to put newly
    created partitions at the proper offsets from the beginning of the disks, so you
    probably don’t need to worry about improper partition alignment. Partitioning
    tools currently don’t make any calculations; instead, they just align partitions
    on 1MB boundaries or, more precisely, 2,048 512-byte blocks. This is a rather
    conservative approach because the boundary aligns with page sizes of 4,096, 8,192,
    and so on, all the way up to 1,048,576.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you’re curious or want to make sure that your partitions begin
    on a boundary, you can easily find this information in the */sys/block* directory.
    Here’s an example for the partition */dev/sdf2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The output here is the partition’s offset from the start of the device, in units
    of 512 bytes (again, confusingly called *sectors* by the Linux system). If this
    SSD uses 4,096-byte pages, there are eight of these sectors in a page. All you
    need to do is see if you can evenly divide the partition offset by 8\. In this
    case, you can’t, so the partition would not attain optimal performance.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last link between the kernel and user space for disks is typically the *filesystem*;
    this is what you’re accustomed to interacting with when you run commands like
    `ls` and `cd`. As previously mentioned, the filesystem is a form of database;
    it supplies the structure to transform a simple block device into the sophisticated
    hierarchy of files and subdirectories that users can understand.
  prefs: []
  type: TYPE_NORMAL
- en: At one time, all filesystems resided on disks and other physical media that
    were intended exclusively for data storage. However, the tree-like directory structure
    and I/O interface of filesystems are quite versatile, so filesystems now perform
    a variety of tasks, such as the system interfaces that you see in */sys* and */proc*.
    Filesystems are traditionally implemented in the kernel, but the innovation of
    9P from Plan 9 ([https://en.wikipedia.org/wiki/9P_(protocol)](https://en.wikipedia.org/wiki/9P_(protocol)))
    has inspired the development of user-space filesystems. The *File System in User
    Space (FUSE)* feature allows user-space filesystems in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: The *Virtual File System (VFS)* abstraction layer completes the filesystem implementation.
    Much as the SCSI subsystem standardizes communication between different device
    types and kernel control commands, VFS ensures that all filesystem implementations
    support a standard interface so that user-space applications access files and
    directories in the same manner. VFS support has enabled Linux to support an extraordinarily
    large number of filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.1 Filesystem Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linux filesystem support includes native designs optimized for Linux; foreign
    types, such as the Windows FAT family; universal filesystems, like ISO 9660; and
    many others. The following list includes the most common types of filesystems
    for data storage. The type names as recognized by Linux are in parentheses next
    to the filesystem names.
  prefs: []
  type: TYPE_NORMAL
- en: The *Fourth Extended filesystem* (ext4) is the current iteration of a line of
    filesystems native to Linux. The *Second Extended filesystem* (ext2) was a longtime
    default for Linux systems inspired by traditional Unix filesystems, such as the
    Unix File System (UFS) and the Fast File System (FFS). The *Third Extended filesystem*
    (ext3) added a journal feature (a small cache outside the normal filesystem data
    structure) to enhance data integrity and hasten booting. The ext4 filesystem is
    an incremental improvement and supports larger files than ext2 or ext3 as well
    as a greater number of subdirectories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s a certain amount of backward compatibility in the extended filesystem
    series. For example, you can mount ext2 and ext3 filesystems as each other, and
    you can mount ext2 and ext3 filesystems as ext4, but you *cannot* mount ext4 as
    ext2 or ext3.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Btrfs, or B-tree filesystem* (btrfs), is a newer filesystem native to Linux
    designed to scale beyond the capabilities of ext4.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*FAT filesystems* (msdos, vfat, exfat) pertain to Microsoft systems. The simple
    msdos type supports the very primitive monocase variety in MS-DOS systems. Most
    removable flash media, such as SD cards and USB drives, contain vfat (up to 4GB)
    or exfat (4GB and up) partitions by default. Windows systems can use either a
    FAT-based filesystem or the more advanced *NT File System* (ntfs).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*XFS* is a high-performance filesystem used by default by some distributions,
    such as Red Hat Enterprise Linux 7.0 and beyond.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*HFS+* (hfsplus) is an Apple standard used on most Macintosh systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*ISO 9660* (iso9660) is a CD-ROM standard. Most CD-ROMs use some variety of
    the ISO 9660 standard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.2.2 Creating a Filesystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re preparing a new storage device, once you’re finished with the partitioning
    process described in Section 4.1, you’re ready to create a filesystem. As with
    partitioning, you’ll do this in user space because a user-space process can directly
    access and manipulate a block device.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mkfs` utility can create many kinds of filesystems. For example, you can
    create an ext4 partition on */dev/sdf2* with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `mkfs` program automatically determines the number of blocks in a device
    and sets some reasonable defaults. Unless you really know what you’re doing and
    feel like reading the documentation in detail, don’t change them.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a filesystem, `mkfs` prints diagnostic output as it works, including
    output pertaining to the superblock. The *superblock* is a key component at the
    top level of the filesystem database, and it’s so important that `mkfs` creates
    a number of backups in case the original is destroyed. Consider recording a few
    of the superblock backup numbers when `mkfs` runs, in case you need to recover
    the superblock in the event of a disk failure (see Section 4.2.11).
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.3 Mounting a Filesystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On Unix, the process of attaching a filesystem to a running system is called
    *mounting*. When the system boots, the kernel reads some configuration data and
    mounts root (`/`) based on the configuration data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to mount a filesystem, you must know the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The filesystem’s device, location, or identifier (such as a disk partition—where
    the actual filesystem data resides). Some special-purpose filesystems, such as
    proc and sysfs, don’t have locations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The filesystem type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *mount point*—the place in the current system’s directory hierarchy where
    the filesystem will be attached. The mount point is always a normal directory.
    For instance, you could use */music* as a mount point for a filesystem containing
    music. The mount point need not be directly below */*; it can be anywhere on the
    system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The common terminology for mounting a filesystem is “mount a device *on* a
    mount point.” To learn the current filesystem status of your system, you run `mount`.
    The output (which can be quite lengthy) should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line corresponds to one currently mounted filesystem, with items in this
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: The device, such as */dev/sda3*. Notice that some of these aren’t real devices
    (`proc`, for example) but are stand-ins for real device names because these special-purpose
    filesystems do not need devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The word `on`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The mount point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The word `type`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The filesystem type, usually in the form of a short identifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount options (in parentheses). See Section 4.2.6 for more details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To mount a filesystem manually, use the `mount` command as follows with the
    filesystem type, device, and desired mount point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, to mount the Fourth Extended filesystem found on the device */dev/sdf2*
    on */home/extra*, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You normally don’t need to supply the `-t` `type` option because `mount` usually
    figures it out for you. However, sometimes it’s necessary to distinguish between
    two similar types, such as the various FAT-style filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: 'To unmount (detach) a filesystem, use the `umount` command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can also unmount a filesystem with its device instead of its mount point.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.4 Filesystem UUID
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The method of mounting filesystems discussed in the preceding section depends
    on device names. However, device names can change because they depend on the order
    in which the kernel finds the devices. To solve this problem, you can identify
    and mount filesystems by their *universally unique identifier (UUID)*, an industry
    standard for unique “serial numbers” to identify objects in a computer system.
    Filesystem creation programs like `mke2fs` generate a UUID when initializing the
    filesystem data structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view a list of devices and the corresponding filesystems and UUIDs on your
    system, use the `blkid` (block ID) program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, `blkid` found four partitions with data: two with ext4 filesystems,
    one with a swap space signature (see Section 4.3), and one with a FAT-based filesystem.
    The Linux native partitions all have standard UUIDs, but the FAT partition doesn’t.
    You can reference the FAT partition with its FAT volume serial number (in this
    case, 4859-EFEA).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To mount a filesystem by its UUID, use the `UUID` mount option. For example,
    to mount the first filesystem from the preceding list on */home/extra*, enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Typically you won’t manually mount filesystems by UUID like this, because you
    normally know the device, and it’s much easier to mount a device by its name than
    by its crazy UUID. Still, it’s important to understand UUIDs. For one thing, they’re
    the preferred way to mount non-LVM filesystems in */etc/fstab* automatically at
    boot time (see Section 4.2.8). In addition, many distributions use the UUID as
    a mount point when you insert removable media. In the preceding example, the FAT
    filesystem is on a flash media card. An Ubuntu system with someone logged in will
    mount this partition at */media/user/4859-EFEA* upon insertion. The udevd daemon
    described in Chapter 3 handles the initial event for the device insertion.
  prefs: []
  type: TYPE_NORMAL
- en: You can change the UUID of a filesystem if necessary (for example, if you copied
    the complete filesystem from somewhere else and now need to distinguish it from
    the original). See the tune2fs(8) manual page for how to do this on an ext2/ext3/ext4
    filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.5 Disk Buffering, Caching, and Filesystems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Linux, like other Unix variants, buffers writes to the disk. This means the
    kernel usually doesn’t immediately write changes to filesystems when processes
    request changes. Instead, it stores those changes in RAM until the kernel determines
    a good time to actually write them to the disk. This buffering system is transparent
    to the user and provides a very significant performance gain.
  prefs: []
  type: TYPE_NORMAL
- en: When you unmount a filesystem with `umount`, the kernel automatically *synchronizes*
    with the disk, writing the changes in its buffer to the disk. You can also force
    the kernel to do this at any time by running the `sync` command, which by default
    synchronizes all the disks on the system. If for some reason you can’t unmount
    a filesystem before you turn off the system, be sure to run `sync` first.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the kernel uses RAM to cache blocks as they’re read from a disk.
    Therefore, if one or more processes repeatedly access a file, the kernel doesn’t
    have to go to the disk again and again—it can simply read from the cache and save
    time and resources.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.6 Filesystem Mount Options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many ways to change the `mount` command behavior, which you’ll often
    need to do when working with removable media or performing system maintenance.
    In fact, the total number of `mount` options is staggering. The extensive mount(8)
    manual page is a good reference, but it’s hard to know where to start and what
    you can safely ignore. You’ll see the most useful options in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Options fall into two rough categories: general and filesystem-specific. General
    options typically work for all filesystem types and include `-t` for specifying
    the filesystem type, as shown earlier. In contrast, a filesystem-specific option
    pertains only to certain filesystem types.'
  prefs: []
  type: TYPE_NORMAL
- en: To activate a filesystem option, use the `-o` switch followed by the option.
    For example, `-o remount,rw` remounts a filesystem already mounted as read-only
    in read-write mode.
  prefs: []
  type: TYPE_NORMAL
- en: Short General Options
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'General options have a short syntax. The most important are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-r` The `-r` option mounts the filesystem in read-only mode. This has a number
    of uses, from write protection to bootstrapping. You don’t need to specify this
    option when accessing a read-only device, such as a CD-ROM; the system will do
    it for you (and will also tell you about the read-only status).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-n` The `-n` option ensures that `mount` does not try to update the system
    runtime mount database, */etc/mtab*. By default, the `mount` operation fails when
    it cannot write to this file, so this option is important at boot time because
    the root partition (including the system mount database) is read-only at first.
    You’ll also find this option handy when trying to fix a system problem in single-user
    mode, because the system mount database may not be available at the time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`-t` The `-t` `type` option specifies the filesystem type.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Long Options
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Short options like `-r` are too limited for the ever-increasing number of `mount`
    options; there are too few letters in the alphabet to accommodate all possible
    options. Short options are also troublesome because it’s difficult to determine
    an option’s meaning based on a single letter. Many general options and all filesystem-specific
    options use a longer, more flexible option format.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use long options with `mount` on the command line, start with `-o` followed
    by the appropriate keywords separated by commas. Here’s a complete example, with
    the long options following `-o`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The two long options here are `ro` and `uid=1000`. The `ro` option specifies
    read-only mode and is the same as the `-r` short option. The `uid=1000` option
    tells the kernel to treat all files on the filesystem as if user ID 1000 is the
    owner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most useful long options are these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`exec`, `noexec` Enables or disables execution of programs on the filesystem.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`suid`, `nosuid` Enables or disables `setuid` programs.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ro` Mounts the filesystem in read-only mode (as does the `-r` short option).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`rw` Mounts the filesystem in read-write mode.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4.2.7 Remounting a Filesystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There will be times when you need to change the `mount` options for a currently
    mounted filesystem; the most common situation is when you need to make a read-only
    filesystem writable during crash recovery. In that case, you need to reattach
    the filesystem at the same mount point.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command remounts the root directory in read-write mode (you need
    the `-n` option because the `mount` command can’t write to the system mount database
    when the root is read-only):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This command assumes that the correct device listing for */* is in */etc/fstab*
    (as discussed in the next section). If it isn’t, you must specify the device as
    an additional option.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.8 The /etc/fstab Filesystem Table
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To mount filesystems at boot time and take the drudgery out of the `mount` command,
    Linux systems keep a permanent list of filesystems and options in */etc/fstab*.
    This is a plaintext file in a very simple format, as [Listing 4-1](#listing4-1)
    shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-1: List of filesystems and options in */etc/fstab*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line corresponds to one filesystem and is broken into six fields. From
    left to right, these fields are:'
  prefs: []
  type: TYPE_NORMAL
- en: The device or UUID Most current Linux systems no longer use the device in */etc/fstab*,
    preferring the UUID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The mount point Indicates where to attach the filesystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The filesystem type You may not recognize `swap` in this list; this is a swap
    partition (see Section 4.3).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Options Long options, separated by commas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Backup information for use by the `dump` command The `dump` command is a long-obsolete
    backup utility; this field is no longer relevant. You should always set it to
    `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The filesystem integrity test order To ensure that `fsck` always runs on the
    root first, always set this to `1` for the root filesystem and `2` for any other
    locally attached filesystems on a hard disk or SSD. Use `0` to disable the bootup
    check for every other filesystem, including read-only devices, swap, and the */proc*
    filesystem (see the `fsck` command in Section 4.2.11).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When using `mount`, you can take some shortcuts if the filesystem you want to
    work with is in */etc/fstab*. For example, if you were using [Listing 4-1](#listing4-1)
    and mounting a CD-ROM, you would simply run `mount /cdrom`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also try to simultaneously mount all entries in */etc/fstab* that do
    not contain the `noauto` option with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 4-1](#listing4-1) introduces some new options—namely, `errors`, `noauto`,
    and `user`, because they don’t apply outside the */etc/fstab* file. In addition,
    you’ll often see the `defaults` option here. These options are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`defaults` This sets the `mount` defaults: read-write mode, enable device files,
    executables, the `setuid` bit, and so on. Use this when you don’t want to give
    the filesystem any special options but you do want to fill all fields in */etc/fstab*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`errors` This ext2/3/4-specific parameter sets the kernel behavior when the
    system has trouble mounting a filesystem. The default is normally `errors=continue`,
    meaning that the kernel should return an error code and keep running. To have
    the kernel try the mount again in read-only mode, use `errors=remount-ro`. The
    `errors=panic` setting tells the kernel (and your system) to halt when there’s
    a problem with the mount.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`noauto` This option tells a `mount -a` command to ignore the entry. Use this
    to prevent a boot-time mount of a removable-media device, such as a flash storage
    device.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`user` This option allows unprivileged users to run `mount` on a particular
    entry, which can be handy for allowing certain kinds of access to removable media.
    Because users can put a *setuid-root* file on removable media with another system,
    this option also sets `nosuid`, `noexec`, and `nodev` (to bar special device files).
    Keep in mind that for removable media and other general cases, this option is
    now of limited use, because most systems use `ubus` along with other mechanisms
    to automatically mount inserted media. However, this option can be useful in special
    cases when you want to grant control over mounting specific directories.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4.2.9 Alternatives to /etc/fstab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although the */etc/fstab* file has been the traditional way to represent filesystems
    and their mount points, there are two alternatives. The first is an */etc/fstab.d*
    directory, which contains individual filesystem configuration files (one file
    for each filesystem). The idea is very similar to many other configuration directories
    that you’ll see throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: A second alternative is to configure *systemd units* for the filesystems. You’ll
    learn more about systemd and its units in Chapter 6. However, the systemd unit
    configuration is often generated from (or based on) the */etc/fstab* file, so
    you may find some overlap on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.10 Filesystem Capacity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To view the size and utilization of your currently mounted filesystems, use
    the `df` command. The output can be very extensive (and it gets longer all the
    time, thanks to specialized filesystems), but it should include information on
    your actual storage devices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s a brief description of the fields in the `df` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Filesystem` The filesystem device'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1K-blocks` The total capacity of the filesystem in blocks of 1,024 bytes'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Used` The number of occupied blocks'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Available` The number of free blocks'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Use%` The percentage of blocks in use'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Mounted on` The mount point'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It should be easy to see that the two filesystems here are roughly 215GB and
    3GB in size. However, the capacity numbers may look a little strange because 127,989,560
    plus 75,339,204 does not equal 214,234,312, and 127,989,560 is not 63 percent
    of 214,234,312\. In both cases, 5 percent of the total capacity is unaccounted
    for. In fact, the space is there, but it’s hidden in *reserved* blocks. Only the
    superuser can use the reserved blocks of the filesystem when it starts to fill
    up. This feature keeps system servers from immediately failing when they run out
    of disk space.
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.11 Checking and Repairing Filesystems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The optimizations that Unix filesystems offer are made possible by a sophisticated
    database mechanism. For filesystems to work seamlessly, the kernel has to trust
    that a mounted filesystem has no errors and also that the hardware stores data
    reliably. If errors exist, data loss and system crashes may result.
  prefs: []
  type: TYPE_NORMAL
- en: Aside from hardware problems, filesystem errors are usually due to a user shutting
    down the system in a rude way (for example, by pulling out the power cord). In
    such cases, the previous filesystem cache in memory may not match the data on
    the disk, and the system also may be in the process of altering the filesystem
    when you happen to give the computer a kick. Although many filesystems support
    journals to make filesystem corruption far less common, you should always shut
    down the system properly. Regardless of the filesystem in use, filesystem checks
    are still necessary every now and then to make sure that everything is still in
    order.
  prefs: []
  type: TYPE_NORMAL
- en: The tool to check a filesystem is `fsck`. As with the `mkfs` program, there’s
    a different version of `fsck` for each filesystem type that Linux supports. For
    example, when run on an Extended filesystem series (ext2/ext3/ext4), `fsck` recognizes
    the filesystem type and starts the `e2fsck` utility. Therefore, you generally
    don’t need to type `e2fsck`, unless `fsck` can’t figure out the filesystem type
    or you’re looking for the `e2fsck` manual page.
  prefs: []
  type: TYPE_NORMAL
- en: The information presented in this section is specific to the Extended filesystem
    series and `e2fsck`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run `fsck` in interactive manual mode, give the device or the mount point
    (as listed in */etc/fstab*) as the argument. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In manual mode, `fsck` prints verbose status reports on its passes, which should
    look something like this when there are no problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If `fsck` finds a problem in manual mode, it stops and asks a question relevant
    to fixing the problem. These questions deal with the internal structure of the
    filesystem, such as reconnecting loose inodes and clearing blocks (*inodes* are
    building blocks of the filesystem; you’ll see how they work in Section 4.6). When
    `fsck` asks you about reconnecting an inode, it has found a file that doesn’t
    appear to have a name. When reconnecting such a file, `fsck` places the file in
    the *lost+found* directory in the filesystem, with a number as the filename. If
    this happens, you need to guess the name based on the file’s contents; the original
    filename is probably gone.
  prefs: []
  type: TYPE_NORMAL
- en: In general, it’s pointless to sit through the `fsck` repair process if you’ve
    just uncleanly shut down the system, because `fsck` may have a lot of minor errors
    to fix. Fortunately, `e2fsck` has a `-p` option that automatically fixes ordinary
    problems without asking and aborts when there’s a serious error. In fact, Linux
    distributions run a variant of `fsck -p` at boot time. (You may also see `fsck
    -a`, which does the same thing.)
  prefs: []
  type: TYPE_NORMAL
- en: If you suspect a major disaster on your system, such as a hardware failure or
    device misconfiguration, you need to decide on a course of action, because `fsck`
    can really mess up a filesystem that has larger problems. (One telltale sign that
    your system has a serious problem is if `fsck` asks a *lot* of questions in manual
    mode.)
  prefs: []
  type: TYPE_NORMAL
- en: If you think that something really bad has happened, try running `fsck -n` to
    check the filesystem without modifying anything. If there’s a problem with the
    device configuration that you think you can fix (such as loose cables or an incorrect
    number of blocks in the partition table), fix it before running `fsck` for real,
    or you’re likely to lose a lot of data.
  prefs: []
  type: TYPE_NORMAL
- en: If you suspect that only the superblock is corrupt (for example, because someone
    wrote to the beginning of the disk partition), you might be able to recover the
    filesystem with one of the superblock backups that `mkfs` creates. Use `fsck -b``num`
    to replace the corrupted superblock with an alternate at block `num` and hope
    for the best.
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t know where to find a backup superblock, you might be able to run
    `mkfs -n` on the device to view a list of superblock backup numbers without destroying
    your data. (Again, *make sure* that you’re using `-n`, or you’ll *really* tear
    up the filesystem.)
  prefs: []
  type: TYPE_NORMAL
- en: Checking ext3 and ext4 Filesystems
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You normally do not need to check ext3 and ext4 filesystems manually because
    the journal ensures data integrity (recall that the *journal* is a small data
    cache that has not yet been written to a specific spot in the filesystem). If
    you don’t shut your system down cleanly, you can expect the journal to contain
    some data. To flush the journal in an ext3 or ext4 filesystem to the regular filesystem
    database, run `e2fsck` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: However, you may want to mount a broken ext3 or ext4 filesystem in ext2 mode,
    because the kernel won’t mount an ext3 or ext4 filesystem with a nonempty journal.
  prefs: []
  type: TYPE_NORMAL
- en: The Worst Case
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Disk problems that are more severe leave you with few choices:'
  prefs: []
  type: TYPE_NORMAL
- en: You can try to extract the entire filesystem image from the disk with `dd` and
    transfer it to a partition on another disk of the same size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can try to patch the filesystem as much as possible, mount it in read-only
    mode, and salvage what you can.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can try `debugfs`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first two cases, you still need to repair the filesystem before you mount
    it, unless you feel like picking through the raw data by hand. If you like, you
    can choose to answer `y` to all of the `fsck` questions by entering `fsck -y`,
    but do this as a last resort because issues may come up during the repair process
    that you would rather handle manually.
  prefs: []
  type: TYPE_NORMAL
- en: The `debugfs` tool allows you to look through the files on a filesystem and
    copy them elsewhere. By default, it opens filesystems in read-only mode. If you’re
    recovering data, it’s probably a good idea to keep your files intact to avoid
    messing things up further.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if you’re really desperate—say with a catastrophic disk failure on your
    hands and no backups—there isn’t a lot you can do other than hope a professional
    service can “scrape the platters.”
  prefs: []
  type: TYPE_NORMAL
- en: 4.2.12 Special-Purpose Filesystems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Not all filesystems represent storage on physical media. Most versions of Unix
    have filesystems that serve as system interfaces. That is, rather than serving
    only as a means to store data on a device, a filesystem can represent system information,
    such as process IDs and kernel diagnostics. This idea goes back to the */dev*
    mechanism, which is an early model of using files for I/O interfaces. The */proc*
    idea came from the eighth edition of research Unix, implemented by Tom J. Killian
    and accelerated when Bell Labs (including many of the original Unix designers)
    created Plan 9—a research operating system that took filesystem abstraction to
    a whole new level ([https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs](https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the special filesystem types in common use on Linux include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`proc` Mounted on */proc*. The name `proc` is an abbreviation for *process*.
    Each *numbered* directory inside */proc* refers to the ID of a current process
    on the system; the files in each directory represent various aspects of that process.
    The directory */proc/self* represents the current process. The Linux `proc` filesystem
    includes a great deal of additional kernel and hardware information in files like
    */proc/cpuinfo*. Keep in mind that the kernel design guidelines recommend moving
    information unrelated to processes out of */proc* and into */sys*, so system information
    in */proc* might not be the most current interface.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sysfs` Mounted on */sys*. (You saw this in Chapter 3.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tmpfs` Mounted on */run* and other locations. With `tmpfs`, you can use your
    physical memory and swap space as temporary storage. You can mount `tmpfs` where
    you like, using the `size` and `nr_blocks` long options to control the maximum
    size. However, be careful not to pour things constantly into a `tmpfs` location,
    because your system will eventually run out of memory and programs will start
    to crash.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`squashfs` A type of read-only filesystem where content is stored in a compressed
    format and extracted on demand through a loopback device. One example use is in
    the snap package management system that mounts packages under the */snap* directory.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`overlay` A filesystem that merges directories into a composite. Containers
    often use overlay filesystems; you’ll see how they work in Chapter 17.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 4.3 Swap Space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not every partition on a disk contains a filesystem. It’s also possible to augment
    the RAM on a machine with disk space. If you run out of real memory, the Linux
    virtual memory system can automatically move pieces of memory to and from disk
    storage. This is called *swapping* because pieces of idle programs are swapped
    to the disk in exchange for active pieces residing on the disk. The disk area
    used to store memory pages is called *swap space* (or just *swap*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `free` command’s output includes the current swap usage in kilobytes as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 4.3.1 Using a Disk Partition as Swap Space
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use an entire disk partition as swap, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure the partition is empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `mkswap` `dev`, where `dev` is the partition’s device. This command puts
    a *swap signature* on the partition, marking it as swap space (rather than a filesystem
    or otherwise).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Execute `swapon` `dev` to register the space with the kernel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After creating a swap partition, you can put a new swap entry in your */etc/fstab*
    file to make the system use the swap space as soon as the machine boots. Here’s
    a sample entry that uses */dev/sda5* as a swap partition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Swap signatures have UUIDs, so keep in mind that many systems now use these
    instead of raw device names.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.2 Using a File as Swap Space
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use a regular file as swap space if you’re in a situation where you
    would be forced to repartition a disk in order to create a swap partition. You
    shouldn’t notice any problems when doing this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use these commands to create an empty file, initialize it as swap, and add
    it to the swap pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here, `swap_file` is the name of the new swap file, and `num_mb` is the desired
    size in megabytes.
  prefs: []
  type: TYPE_NORMAL
- en: To remove a swap partition or file from the kernel’s active pool, use the `swapoff`
    command. Your system must have enough free remaining memory (real and swap combined)
    to accommodate any active pages in the part of the swap pool that you’re removing.
  prefs: []
  type: TYPE_NORMAL
- en: 4.3.3 Determining How Much Swap You Need
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At one time, Unix conventional wisdom said you should always reserve at least
    twice as much swap space as you have real memory. Today, not only do the enormous
    disk and memory capacities available cloud the issue, but so do the ways we use
    the system. On one hand, disk space is so plentiful, it’s tempting to allocate
    more than double the memory size. On the other hand, you may never even dip into
    your swap space because you have so much real memory.
  prefs: []
  type: TYPE_NORMAL
- en: The “double the real memory” rule dated from a time when multiple users would
    be logged in to one machine. Not all of them would be active, though, so it was
    convenient to be able to swap out the memory of the inactive users when an active
    user needed more memory.
  prefs: []
  type: TYPE_NORMAL
- en: The same may still hold true for a single-user machine. If you’re running many
    processes, it’s generally fine to swap out parts of inactive processes or even
    inactive pieces of active processes. However, if you frequently access swap space
    because many active processes want to use the memory at once, you’ll suffer serious
    performance problems because disk I/O (even that of SSDs) is just too slow to
    keep up with the rest of the system. The only solutions are to buy more memory,
    terminate some processes, or complain.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, the Linux kernel may choose to swap out a process in favor of a little
    more disk cache. To prevent this behavior, some administrators configure certain
    systems with no swap space at all. For example, high-performance servers should
    never dip into swap space and should avoid disk access if at all possible.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn much more about how the memory system works in Chapter 8.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4 The Logical Volume Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we’ve looked at direct management and use of disks through partitions,
    specifying the exact locations on storage devices where certain data should reside.
    You know that accessing a block device like */dev/sda1* leads you to a place on
    a particular device according to the partition table on */dev/sda*, even if the
    exact location may be left to the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: This usually works fine, but it does have some disadvantages, especially when
    it comes to making changes to your disks *after* installation. For example, if
    you want to upgrade a disk, you must install the new disk, partition, add filesystems,
    possibly do some boot loader changes and other tasks, and finally switch over
    to the new disk. This process can be error-prone and requires several reboots.
    It’s perhaps worse when you want to install an additional disk to get more capacity—here,
    you have to pick a new mount point for the filesystem on that disk and hope that
    you can manually distribute your data between the old and new disks.
  prefs: []
  type: TYPE_NORMAL
- en: The LVM deals with these problems by adding another layer between the physical
    block devices and the filesystem. The idea is that you select a set of *physical
    volumes* (usually just block devices, such as disk partitions) to include into
    a *volume group*, which acts as a sort of generic data pool. Then you carve *logical
    volumes* out of the volume group.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-4](#figure4-4) shows a schematic of how these fit together for one
    volume group. This figure shows several physical and logical volumes, but many
    LVM-based systems have only one PV and just two logical volumes (for root and
    swap).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f04004](image_fi/500402c04/f04004.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-4: How PVs and logical volumes fit together in a volume group'
  prefs: []
  type: TYPE_NORMAL
- en: Logical volumes are just block devices, and they typically contain filesystems
    or swap signatures, so you can think of the relationship between a volume group
    and its logical volumes as similar to that of a disk and its partitions. The critical
    difference is that you don’t normally define how the logical volumes are laid
    out in the volume group—the LVM works all of this out.
  prefs: []
  type: TYPE_NORMAL
- en: 'The LVM allows some powerful and extremely useful operations, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Add more PVs (such as another disk) to a volume group, increasing its size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove PVs as long as there’s enough space remaining to accommodate existing
    logical volumes inside a volume group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resize logical volumes (and as a consequence, resize filesystems with the `fsadm`
    utility).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can do all of this without rebooting the machine, and in most cases without
    unmounting any filesystems. Although adding new physical disk hardware can require
    a shutdown, cloud computing environments often allow you to add new block storage
    devices on the fly, making LVM an excellent choice for systems that need this
    kind of flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to explore LVM in a moderate amount of detail. First, we’ll see
    how to interact with and manipulate logical volumes and their components, and
    then we’ll take a closer look at how LVM works and the kernel driver that it’s
    built on. However, the discussion here is not essential to understanding the rest
    of the book, so if you get too bogged down, feel free to skip ahead to Chapter
    5.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.2 Working with LVM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: LVM has a number of user-space tools for managing volumes and volume groups.
    Most of these are based around the `lvm` command, an interactive general-purpose
    tool. There are individual commands (which are just symbolic links to LVM) to
    perform specific tasks. For example, the `vgs` command has the same effect as
    typing `vgs` at the `lvm>` prompt of the interactive `lvm` tool, and you’ll find
    that *vgs* (usually in */sbin*) is a symbolic link to *lvm*. We’ll use the individual
    commands in this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, we’ll look at the components of a system that uses
    logical volumes. The first examples come from a standard Ubuntu installation using
    the LVM partitioning option, so many of the names will contain the word *Ubuntu*.
    However, none of the technical details are specific to that distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Listing and Understanding Volume Groups
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `vgs` command just mentioned shows the volume groups currently configured
    on the system. The output is fairly concise. Here’s what you might see in our
    example LVM installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line is a header, with each successive line representing a volume
    group. The columns are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`VG` The volume group name. `ubuntu-vg` is the generic name that the Ubuntu
    installer assigns when configuring a system with LVM.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#PV` The number of physical volumes that the volume group’s storage comprises.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#LV` The number of logical volumes inside the volume group.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`#SN` The number of logical volume *snapshots*. We won’t go into detail about
    these.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Attr` A number of status attributes of the volume group. Here, `w` (writeable),
    `z` (resizable), and `n` (normal allocation policy) are active.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`VSize` The volume group size.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`VFree` The amount of unallocated space on the volume group.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This synopsis of a volume group is sufficient for most purposes. If you want
    to go a little deeper into a volume group, use the `vgdisplay` command, which
    is very useful for understanding a volume group’s properties. Here’s the same
    volume group with `vgdisplay`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You saw some of this before, but there are some new items of note:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Open LV` The number of logical volumes currently in use.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Cur PV` The number of physical volumes the volume group comprises.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Act LV` The number of active physical volumes in the volume group.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`VG UUID` The volume group’s universally unique identifier. It’s possible to
    have more than one volume group with the same name on a system; in this case,
    the UUID can help you isolate a particular one. Most LVM tools (such as `vgrename`,
    which can help you resolve a situation like this) accept the UUID as an alternative
    to the volume group name. Be warned that you’re about to see a lot of different
    UUIDs; every component of LVM has one.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A *physical extent* (abbreviated as `PE` in the `vgdisplay` output) is a piece
    of a physical volume, much like a block, but on a much larger scale. In this example,
    the PE size is 4MB. You can see that most of the PEs on this volume group are
    in use, but that’s not a cause for alarm. This is merely the amount of space on
    the volume group allocated for the logical partitions (in this case, a filesystem
    and swap space); it doesn’t reflect the actual usage within the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Listing Logical Volumes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Similar to volume groups, the commands to list logical volumes are `lvs` for
    a short listing and `lvdisplay` for more detail. Here’s a sample of `lvs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'On basic LVM configurations, only the first four columns are important to understand,
    and the remaining columns may be empty, as is the case here (we won’t cover those).
    The relevant columns here are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LV` The logical volume name.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`VG` The volume group where the logical volume resides.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Attr` Attributes of the logical volume. Here, they are `w` (writeable), `i`
    (inherited allocation policy), `a` (active), and `o` (open). In more advanced
    volume group configurations, more of these slots are active—in particular, the
    first, seventh, and ninth.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`LSize` The size of the logical volume.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Running the more detailed `lvdisplay` helps to shed some light on where a logical
    volume fits into your system. Here’s the output for one of our logical volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a lot of interesting stuff here, and most of it is fairly self-explanatory
    (note that the UUID of the logical volume is different from that of its volume
    group). Perhaps the most important thing you haven’t seen yet is first: `LV Path`,the
    device path of the logical volume. Some systems, but not all, use this as the
    mount point of the filesystem or swap space (in a systemd mount unit or */etc/fstab*).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though you can see the major and minor device numbers of the logical volume’s
    block device (here, 253 and 0), as well as something that looks like a device
    path, it’s not actually the path that the kernel uses. A quick look at */dev/ubuntu-vg/root*
    reveals that something else is going on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is just a symbolic link to */dev/dm-0*. Let’s look at that
    briefly.
  prefs: []
  type: TYPE_NORMAL
- en: Using Logical Volume Devices
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Once LVM has done its setup work on your system, logical volume block devices
    are available at */dev/dm-0*, */dev/dm-1*, and so on, and may be arranged in any
    order. Due to the unpredictability of these device names, LVM also creates symbolic
    links to the devices that have stable names based on the volume group and logical
    volume names. You saw this in the preceding section with */dev/ubuntu-vg/root*.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s an additional location for symbolic links in most implementations:
    */dev/mapper*. The name format here is also based on the volume group and logical
    volume, but there’s no directory hierarchy; instead, the links have names like
    *ubuntu--vg-root*. Here, udev has transformed the single dash in the volume group
    into a double dash, and then separated the volume group and logical volume names
    with a single dash.'
  prefs: []
  type: TYPE_NORMAL
- en: Many systems use the links in */dev/mapper* in their */etc/fstab*, systemd,
    and boot loader configurations in order to point the system to the logical volumes
    used for filesystems and swap space.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, these symbolic links point to block devices for the logical volumes,
    and you can interact with them just as you would any other block device: create
    filesystems, create swap partitions, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with Physical Volumes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The final major piece of LVM to examine is the *physical volume (PV)*. A volume
    group is built from one or more PVs. Although a PV may seem like a straightforward
    part of the LVM system, it contains a little more information than meets the eye.
    Much like volume groups and logical volumes, the LVM commands to view PVs are
    `pvs` (for a short list) and `pvdisplay` (for a more in-depth view). Here’s the
    `pvs` display for our example system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And here’s `pvdisplay`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'From the previous discussion of volume groups and logical volumes, you should
    understand most of this output. Here are some notes:'
  prefs: []
  type: TYPE_NORMAL
- en: There’s no special name for the PV other than the block device. There’s no need
    for one—all of the names required to reference a logical volume are at the volume
    group level and above. However, the PV does have a UUID, which is required to
    compose a volume group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this case, the number of PEs matches the usage in the volume group (which
    we saw earlier), because this is the only PV in the group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s a tiny amount of space that LVM labels as not usable because it’s not
    enough to fill a full PE.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `a` in the attributes of the `pvs` output corresponds to `Allocatable` in
    the `pvdisplay` output, and it simply means that if you want to allocate space
    for a logical volume in the volume group, LVM can choose to use this PV. However,
    in this case, there are only nine unallocated PEs (a total of 36MB), so not much
    is available for new logical volumes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As alluded to earlier, PVs contain more than just information about their own
    individual contribution to a volume group. Each PV contains *physical volume metadata*,
    extensive information about its volume group and its logical volumes. We’ll explore
    PV metadata shortly, but first let’s get some hands-on experience to see how what
    we’ve learned fits together.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing a Logical Volume System
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s look at an example of how to create a new volume group and some logical
    volumes out of two disk devices. We’ll combine two disk devices of 5GB and 15GB
    into a volume group and then divide this space into two logical volumes of 10GB
    each—a nearly impossible task without LVM. The example shown here uses VirtualBox
    disks. Although the capacities are quite small on any contemporary system, they
    suffice for illustration.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-5](#figure4-5) shows the volume schematic. The new disks are at */dev/sdb*
    and */dev/sdc*, the new volume group will be called `myvg`, and the two new logical
    volumes are called `mylv1` and `mylv2`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f04005](image_fi/500402c04/f04005.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-5: Constructing a logical volume system'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first task is to create a single partition on each of these disks and label
    it for LVM. Do this with a partitioning program (see Section 4.1.2), using the
    partition type ID `8e`, so that the partition tables look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You don’t necessarily need to partition a disk to make it a PV. PVs can be any
    block device, even entire-disk devices, such as */dev/sdb*. However, partitioning
    enables booting from the disk, and it also provides a means of identifying the
    block devices as LVM physical volumes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Physical Volumes and a Volume Group
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With the new partitions of */dev/sdb1* and */dev/sdc1* in hand, the first step
    with LVM is to designate one of the partitions as a PV and assign it to a new
    volume group. A single command, `vgcreate`, performs this task. Here’s how to
    create a volume group called `myvg` with */dev/sdb1* as the initial PV:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, most systems automatically detect the new volume group; run
    a command such as `vgs` to verify (keeping in mind that there may be existing
    volume groups on your system that show up in addition to the one you just created):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can add your second PV at */dev/sdc1* to the volume group with the
    `vgextend` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Running `vgs` now shows two PVs, and the size is that of the two partitions
    combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Creating Logical Volumes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The final step at the block device level is to create the logical volumes. As
    mentioned before, we’re going to create two logical volumes of 10GB each, but
    feel free to experiment with other possibilities, such as one big logical volume
    or multiple smaller ones.
  prefs: []
  type: TYPE_NORMAL
- en: The `lvcreate` command allocates a new logical volume in a volume group. The
    only real complexities in creating simple logical volumes are determining the
    sizes when there is more than one per volume group, and specifying the type of
    logical volume. Remember that PVs are divided into extents; the number of PEs
    available may not *quite* line up with your desired size. However, it should be
    close enough so that it doesn’t present a concern, so if this your first time
    working with the LVM, you don’t really have to pay attention to PEs.
  prefs: []
  type: TYPE_NORMAL
- en: When using `lvcreate`, you can specify a logical volume’s size by numeric capacity
    in bytes with the `--size` option or by number of PEs with the `--extents` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to see how this works, and to complete the LVM schematic in [Figure 4-5](#figure4-5),
    we’ll create logical volumes named `mylv1` and `mylv2` using `--size`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The type here is the linear mapping, the simplest type when you don’t need redundancy
    or any other special features (we won’t work with any other types in this book).
    In this case, `--type linear` is optional because it’s the default mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'After running these commands, verify that the logical volumes exist with an
    `lvs` command, and then take a closer look at the current state of the volume
    group with `vgdisplay`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Notice how there are 42 free PEs because the sizes that we chose for the logical
    volumes didn’t quite take up all of the available extents in the volume group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Manipulating Logical Volumes: Creating Partitions'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With the new logical volumes available, you can now make use of them by putting
    filesystems on the devices and mounting them just like any normal disk partition.
    As mentioned earlier, there will be symbolic links to the devices in */dev/mapper*
    and (for this case) a */dev/myvg* directory for the volume group. So, for example,
    you might run the following three commands to create a filesystem, mount it temporarily,
    and see how much actual space you have on a logical volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Removing Logical Volumes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We haven’t yet looked at any operations on the other logical volume, *mylv2*,
    so let’s use it to make this example more interesting. Say you find you’re not
    really using that second logical volume. You decide to remove it and resize the
    first logical volume to take over the remaining space on the volume group. [Figure
    4-6](#figure4-6) shows our goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming you’ve already moved or backed up anything important on the logical
    volume you’re going to delete, and that it’s not in current system use (that is,
    you’ve unmounted it), first remove it with `lvremove`. When manipulating logical
    volumes with this command, you’ll refer to them using a different syntax—by separating
    the volume group and logical volume names by a slash (`myvg/mylv2`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '![f04006](image_fi/500402c04/f04006.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-6: Results of reconfiguring logical volumes'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from this interaction, `lvremove` tries to protect you from blunders
    by double-checking that you really want to remove each logical volume targeted
    for removal. It also won’t try to remove a volume that’s in use. But don’t just
    assume that you should reply `y` to any question you’re asked.
  prefs: []
  type: TYPE_NORMAL
- en: Resizing Logical Volumes and Filesystems
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you can resize the first logical volume, `mylv1`. You can do this even when
    the volume is in use and its filesystem is mounted. However, it’s important to
    understand that there are two steps. To use your larger logical volume, you need
    to resize both it *and* the filesystem inside it (which you can also do while
    it’s mounted). But because this is such a common operation, the `lvresize` command
    that resizes a logical volume has an option (`-r`) to perform the filesystem resizing
    for you also.
  prefs: []
  type: TYPE_NORMAL
- en: 'For illustration only, let’s use two separate commands to see how this works.
    There are several ways to specify the change in size to a logical volume, but
    in this case, the most straightforward method is to add all of the free PEs in
    the volume group to the logical volume. Recall that you can find that number with
    `vgdisplay`; in our running example, it’s 2,602\. Here’s the `lvresize` command
    to add all of those to `mylv1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you need to resize the filesystem inside. You can do this with the `fsadm`
    command. It’s fun to watch it work in verbose mode (use the `-v` option):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the output, `fsadm` is just a script that knows how to transform
    its arguments into the ones used by filesystem-specific tools like `resize2fs`.
    By default, if you don’t specify a size, it’ll simply resize to fit the entire
    device.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve seen the details of resizing volumes, you’re probably looking
    for shortcuts. The much simpler approach is to use a different syntax for the
    size and have `lvresize` perform the partition resizing for you, with this single
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: It’s rather nice that you can expand an ext2/ext3/ext4 filesystem while it’s
    mounted. Unfortunately, it doesn’t work in reverse. You *cannot* shrink a filesystem
    when it’s mounted. Not only must you unmount the filesystem, but the process of
    shrinking a logical volume requires you to do the steps in reverse. So, when resizing
    manually, you’d need to resize the partition before the logical volume, making
    sure that the new logical volume is still big enough to contain the filesystem.
    Again, it’s *much* easier to use `lvresize` with the `-r` option so that it can
    coordinate the filesystem and logical volume sizes for you.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.3 The LVM Implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the more practical operational basics of LVM covered, we can now take a
    brief look at its implementation. As with almost every other topic in this book,
    LVM contains a number of layers and components, with a fairly careful separation
    between the parts in kernel and user space.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll see soon, finding PVs to discover the structure of the volume groups
    and logical volumes is somewhat complicated, and the Linux kernel would rather
    not deal with any of it. There’s no reason for any of this to happen in kernel
    space; PVs are just block devices, and user space has random access to block devices.
    In fact, LVM (more specifically, LVM2 in current systems) itself is just the name
    for a suite of user-space utilities that know the LVM structure.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the kernel handles the work of routing a request for a location
    on a logical volume’s block device to the true location on an actual device. The
    driver for this is the *device mapper* (sometimes shortened to *devmapper*), a
    new layer sandwiched between normal block devices and the filesystem. As the name
    suggests, the task the device mapper performs is like following a map; you can
    almost think of it as translating a street address into an absolute location like
    global latitude/longitude coordinates. (It’s a form of virtualization; the virtual
    memory we’ll see elsewhere in the book works on a similar concept.)
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s some glue between LVM user-space tools and the device mapper: a few
    utilities that run in user space to manage the device map in the kernel. Let’s
    look at both the LVM side and the kernel side, starting with LVM.'
  prefs: []
  type: TYPE_NORMAL
- en: LVM Utilities and Scanning for Physical Volumes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before it does anything, an LVM utility must first scan the available block
    devices to look for PVs. The steps that LVM must perform in user space are roughly
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Find all of the PVs on the system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find all of the volume groups that the PVs belong to by UUID (this information
    is contained in the PVs).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that everything is complete (that is, all necessary PVs that belong to
    the volume group are present).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find all of the logical volumes in the volume groups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure out the scheme for mapping data from the PVs to the logical volumes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There’s a header at the beginning of every PV that identifies the volume as
    well as its volume groups and the logical volumes within. The LVM utilities can
    put this information together and determine whether all PVs necessary for a volume
    group (and its logical volumes) are present. If everything checks out, LVM can
    work on getting the information to the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Any LVM utility, such as `pvscan`, `lvs`, or `vgcreate`, is capable of performing
    the work of scanning and processing PVs.
  prefs: []
  type: TYPE_NORMAL
- en: The Device Mapper
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After LVM has determined the structure of the logical volumes from all of the
    headers on the PVs, it communicates with the kernel’s device mapper driver in
    order to initialize the block devices for the logical volumes and load their mapping
    tables. It achieves this with the ioctl(2) system call (a commonly used kernel
    interface) on the */dev/mapper/control* device file. It’s not really practical
    to try to monitor this interaction, but it’s possible to look at the details of
    the results with the `dmsetup` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an inventory of mapped devices currently serviced by the device mapper,
    use `dmsetup info`. Here’s what you might get for one of the logical volumes created
    earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The major and minor number of the device correspond to the */dev/dm-** device
    file for the mapped device; the major number for this device mapper is 253\. Because
    the minor number is 1, the device file is named */dev/dm-1*. Notice that the kernel
    has a name and yet another UUID for the mapped device. LVM supplied these to the
    kernel (the kernel UUID is just a concatenation of the volume group and logical
    volume UUIDs).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also view the table that LVM gave to the device mapper, by issuing
    the command `dmsetup table`. Here’s what that looks like for our earlier example
    when there were two 10GB logical volumes (`mylv1` and `mylv2`) spread across the
    two physical volumes of 5GB (*/dev/sdb1*) and 15GB (*/dev/sdc1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Each line provides a segment of the map for a given mapped device. For the
    device `myvg-mylv2`, there are two pieces, and for `myvg-mylv1`, there’s a single
    one. The fields after the name, in order, are:'
  prefs: []
  type: TYPE_NORMAL
- en: The start offset of the mapped device. The units are in 512-byte “sectors,”
    or the normal block size that you see in many other devices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The length of this segment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The mapping scheme. Here, it’s the simple one-to-one linear scheme.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The major and minor device number pair of a source device—that is, what LVM
    calls physical volumes. Here 8:17 is */dev/sdb1* and 8:33 is */dev/sdc1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A starting offset on the source device.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s interesting here is that in our example, LVM chose to use the space in
    */dev/sdc1* for the first logical volume that we created (`mylv1`). LVM decided
    that it wanted to lay out the first 10GB logical volume in a contiguous manner,
    and the only way to do that was on */dev/sdc1*. However, when creating the second
    logical volume (`mylv2`), LVM had no choice but to spread it into two segments
    across the two PVs. [Figure 4-7](#figure4-7) shows the arrangement.
  prefs: []
  type: TYPE_NORMAL
- en: '![f04007_new](image_fi/500402c04/f04007_new.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-7: How LVM arranges `mylv1` and `mylv2`'
  prefs: []
  type: TYPE_NORMAL
- en: 'As a further consequence, when we removed `mylv2` and expanded `mylv1` to fit
    the remaining space in the volume group, the original start offset in the PV remained
    where it was on */dev/sdc1*, but everything else changed to include the remainder
    of the PVs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 4-8](#figure4-8) shows the arrangement.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f04008](image_fi/500402c04/f04008.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-8: The arrangement after we remove `mylv2` and expand `mylv1`'
  prefs: []
  type: TYPE_NORMAL
- en: You can experiment with logical volumes and the device mapper to your heart’s
    content with virtual machines and see how the mappings turn out. Many features,
    such as software RAID and encrypted disks, are built on the device mapper.
  prefs: []
  type: TYPE_NORMAL
- en: '4.5 Looking Forward: Disks and User Space'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In disk-related components on a Unix system, the boundaries between user space
    and the kernel can be difficult to characterize. As you’ve seen, the kernel handles
    raw block I/O from the devices, and user-space tools can use the block I/O through
    device files. However, user space typically uses the block I/O only for initializing
    operations, such as partitioning, filesystem creation, and swap space creation.
    In normal use, user space uses only the filesystem support that the kernel provides
    on top of the block I/O. Similarly, the kernel also handles most of the tedious
    details when dealing with swap space in the virtual memory system.
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of this chapter briefly looks at the innards of a Linux filesystem.
    This is more advanced material, and you certainly don’t need to know it to proceed
    with the book. If this is your first time through, skip to the next chapter and
    start learning about how Linux boots.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6 Inside a Traditional Filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A traditional Unix filesystem has two primary components: a pool of data blocks
    where you can store data and a database system that manages the data pool. The
    database is centered around the inode data structure. An *inode* is a set of data
    that describes a particular file, including its type, permissions, and—perhaps
    most important—where in the data pool the file data resides. Inodes are identified
    by numbers listed in an inode table.'
  prefs: []
  type: TYPE_NORMAL
- en: Filenames and directories are also implemented as inodes. A directory inode
    contains a list of filenames and links corresponding to other inodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide a real-life example, I created a new filesystem, mounted it, and
    changed the directory to the mount point. Then, I added some files and directories
    with these commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note that I created *dir_2/file_5* as a hard link to *dir_1/file_3*, meaning
    that these two filenames actually represent the same file (more on this shortly).
    Feel free to try this yourself. It doesn’t necessarily need to be on a new filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to explore the directories in this filesystem, its contents would
    appear as shown in [Figure 4-9](#figure4-9).
  prefs: []
  type: TYPE_NORMAL
- en: '![f04009](image_fi/500402c04/f04009.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-9: User-level representation of a filesystem'
  prefs: []
  type: TYPE_NORMAL
- en: The actual layout of the filesystem as a set of inodes, shown in [Figure 4-10](#figure4-10),
    doesn’t look nearly as clean as the user-level representation.
  prefs: []
  type: TYPE_NORMAL
- en: '![f04010](image_fi/500402c04/f04010.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-10: Inode structure of the filesystem shown in [Figure 4-9](#figure4-9)'
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we make sense of this? For any ext2/3/4 filesystem, you start at inode
    number 2, which is the *root inode* (try not to confuse this with the system root
    filesystem). From the inode table in [Figure 4-10](#figure4-10), you can see that
    this is a directory inode (*dir*), so you can follow the arrow over to the data
    pool, where you see the contents of the root directory: two entries named *dir_1*
    and *dir_2* corresponding to inodes 12 and 7633, respectively. To explore those
    entries, go back to the inode table and look at either of those inodes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To examine *dir_1/file_2* in this filesystem, the kernel does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Determines the path’s components: a directory named *dir_1*, followed by a
    component named *file_2*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follows the root inode to its directory data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finds the name *dir_1* in inode 2’s directory data, which points to inode number
    12.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Looks up inode 12 in the inode table and verifies that it is a directory inode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follows inode 12’s data link to its directory information (the second box down
    in the data pool).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locates the second component of the path (*file_2*) in inode 12’s directory
    data. This entry points to inode number 14.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Looks up inode 14 in the directory table. This is a file inode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, the kernel knows the properties of the file and can open it by
    following inode 14’s data link.
  prefs: []
  type: TYPE_NORMAL
- en: This system, of inodes pointing to directory data structures and directory data
    structures pointing to inodes, allows you to create the filesystem hierarchy that
    you’re used to. In addition, notice that the directory inodes contain entries
    for *.* (the current directory) and *..* (the parent directory, except for the
    root directory). This makes it easy to get a point of reference and to navigate
    back down the directory structure.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.1 Inode Details and the Link Count
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To view the inode numbers for any directory, use the `ls -i` command. Here’s
    what you’d get at the root of this example (for more detailed inode information,
    use the `stat` command):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You’re probably wondering about the *link count* in the inode table. You’ve
    already seen the link count in the output of the common `ls -l` command, but you
    likely ignored it. How does the link count relate to the files in [Figure 4-9](#figure4-9),
    in particular the “hard-linked” *file_5*? The link count field is the number of
    total directory entries (across all directories) that point to an inode. Most
    of the files have a link count of 1 because they occur only once in the directory
    entries. This is expected. Most of the time when you create a file, you create
    a new directory entry and a new inode to go with it. However, inode 15 occurs
    twice. First it’s created as *dir_1/file_3*, and then it’s linked to as *dir_2/file_5*.
    A hard link is just a manually created entry in a directory to an inode that already
    exists. The `ln` command (without the `-s` option) allows you to create new hard
    links manually.
  prefs: []
  type: TYPE_NORMAL
- en: This is also why removing a file is sometimes called *unlinking*. If you run
    `rm dir_1/file_2`, the kernel searches for an entry named *file_2* in inode 12’s
    directory entries. Upon finding that *file_2* corresponds to inode 14, the kernel
    removes the directory entry and then subtracts 1 from inode 14’s link count. As
    a result, inode 14’s link count will be 0, and the kernel will know that there
    are no longer any names linking to the inode. Therefore, it can now delete the
    inode and any data associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you run `rm dir_1/file_3`, the end result is that the link count
    of inode 15 goes from 2 to 1 (because *dir_2/file_5* still points there), and
    the kernel knows not to remove the inode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Link counts work much the same for directories. Note that inode 12’s link count
    is 2, because there are two inode links there: one for *dir_1* in the directory
    entries for inode 2 and the second a self-reference (`.`) in its own directory
    entries. If you create a new directory *dir_1/dir_3*, the link count for inode
    12 would go to 3 because the new directory would include a parent (`..`) entry
    that links back to inode 12, much as inode 12’s parent link points to inode 2.'
  prefs: []
  type: TYPE_NORMAL
- en: There is one small exception in link counts. The root inode 2 has a link count
    of 4\. However, [Figure 4-10](#figure4-10) shows only three directory entry links.
    The “fourth” link is in the filesystem’s superblock because the superblock tells
    you where to find the root inode.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t be afraid to experiment on your system. Creating a directory structure
    and then using `ls -i` or `stat` to walk through the pieces is harmless. You don’t
    need to be root (unless you mount and create a new filesystem).
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.2 Block Allocation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s still one piece missing from our discussion. When allocating data pool
    blocks for a new file, how does the filesystem know which blocks are in use and
    which are available? One of the most basic ways is to use an additional management
    data structure called a *block bitmap*. In this scheme, the filesystem reserves
    a series of bytes, with each bit corresponding to one block in the data pool.
    A value of 0 means that the block is free, and a 1 means that it’s in use. Thus,
    allocating and deallocating blocks is a matter of flipping bits.
  prefs: []
  type: TYPE_NORMAL
- en: Problems in a filesystem arise when the inode table data doesn’t match the block
    allocation data or when the link counts are incorrect; for example, this can happen
    when you don’t cleanly shut down a system. Therefore, when you check a filesystem,
    as described in Section 4.2.11, the `fsck` program walks through the inode table
    and directory structure to generate new link counts and a new block allocation
    map (such as the block bitmap), and then it compares the newly generated data
    with the filesystem on the disk. If there are mismatches, `fsck` must fix the
    link counts and determine what to do with any inodes and/or data that didn’t come
    up when it traversed the directory structure. Most `fsck` programs make these
    “orphans” new files in the filesystem’s *lost+found* directory.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.3 Working with Filesystems in User Space
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with files and directories in user space, you shouldn’t have to
    worry much about the implementation going on below them. Processes are expected
    to access the contents of files and directories of a mounted filesystem through
    kernel system calls. Curiously, though, you do have access to certain filesystem
    information that doesn’t seem to fit in user space—in particular, the `stat()`
    system call returns inode numbers and link counts.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re not maintaining a filesystem, do you have to worry about inode numbers,
    link counts, and other implementation details? Generally, no. This stuff is accessible
    to user-mode programs primarily for backward compatibility. Furthermore, not all
    filesystems available in Linux have these filesystem internals. The VFS interface
    layer ensures that system calls always return inode numbers and link counts, but
    those numbers may not necessarily mean anything.
  prefs: []
  type: TYPE_NORMAL
- en: You may not be able to perform traditional Unix filesystem operations on nontraditional
    filesystems. For example, you can’t use `ln` to create a hard link on a mounted
    VFAT filesystem because its directory entry structure, designed for Windows rather
    than Unix/Linux, does not support that concept.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the system calls available to user space on Linux systems provide
    enough abstraction for painless file access—you don’t need to know anything about
    the underlying implementation in order to access files. In addition, filenames
    are flexible in format and mixed-case names are supported, making it easy to support
    other hierarchical-style filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, specific filesystem support does not necessarily need to be in the
    kernel. For example, in user-space filesystems, the kernel only needs to act as
    a conduit for system calls.
  prefs: []
  type: TYPE_NORMAL
