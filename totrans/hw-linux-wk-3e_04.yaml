- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Disks and Filesystems
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘和文件系统
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: In Chapter 3, we saw an overview of some of the top-level disk devices that
    the kernel makes available. In this chapter, we’ll discuss in detail how to work
    with disks on a Linux system. You’ll learn how to partition disks, create and
    maintain the filesystems that go inside disk partitions, and work with swap space.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们概览了一些内核提供的顶级磁盘设备。在本章中，我们将详细讨论如何在Linux系统中操作磁盘。你将学习如何分区、创建并维护磁盘分区内的文件系统，以及如何使用交换空间。
- en: Recall that disk devices have names like */dev/sda*, the first SCSI subsystem
    disk. This kind of block device represents the entire disk, but there are many
    different components and layers inside a disk.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，磁盘设备有类似*/dev/sda*的名称，这是第一个SCSI子系统磁盘。这种类型的块设备代表整个磁盘，但磁盘内部有许多不同的组件和层次。
- en: '[Figure 4-1](#figure4-1) illustrates a schematic of a simple Linux disk (note
    that the figure is not to scale). As you progress through this chapter, you’ll
    learn where each piece fits in.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4-1](#figure4-1)展示了一个简单Linux磁盘的示意图（注意该图并非按比例绘制）。随着你学习本章内容，你将了解每个部分是如何相互配合的。'
- en: '![f04001](image_fi/500402c04/f04001.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![f04001](image_fi/500402c04/f04001.png)'
- en: 'Figure 4-1: Typical Linux disk schematic'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-1：典型的Linux磁盘示意图
- en: '*Partitions* are subdivisions of the whole disk. On Linux, they’re denoted
    with a number after the whole block device, so they have names like */dev/sda1*
    and */dev/sdb3*. The kernel presents each partition as a block device, just as
    it would an entire disk. Partitions are defined on a small area of the disk called
    a *partition table* (also called a *disk label*).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*分区*是整个磁盘的子划分。在Linux中，分区通过在整个块设备后加上数字来表示，因此它们的名称像*/dev/sda1*和*/dev/sdb3*。内核将每个分区呈现为一个块设备，就像它处理整个磁盘一样。分区定义在磁盘的一个小区域，称为*分区表*（也叫*磁盘标签*）。'
- en: The kernel makes it possible for you to access both an entire disk and one of
    its partitions at the same time, but you wouldn’t normally do so unless you were
    copying the entire disk.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 内核使你能够同时访问整个磁盘和其某个分区，但除非你是在复制整个磁盘，否则通常不会这样做。
- en: The Linux *Logical Volume Manager (LVM)* adds more flexibility to traditional
    disk devices and partitions, and is now in use in many systems. We’ll cover LVM
    in Section 4.4.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的*逻辑卷管理器（LVM）*为传统磁盘设备和分区增加了更多的灵活性，现在已被许多系统使用。我们将在第4.4节讨论LVM。
- en: The next layer up from the partition is the *filesystem*, the database of files
    and directories that you’re accustomed to interacting with in user space. We’ll
    explore filesystems in Section 4.2.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 分区之上的下一层是*文件系统*，它是你在用户空间中习惯与之交互的文件和目录的数据库。我们将在第4.2节深入探讨文件系统。
- en: As you can see in [Figure 4-1](#figure4-1), if you want to access the data in
    a file, you need to use the appropriate partition location from the partition
    table and then search the filesystem database on that partition for the desired
    file data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图4-1](#figure4-1)所示，如果你想访问文件中的数据，需要从分区表中使用适当的分区位置，然后在该分区的文件系统数据库中查找所需的文件数据。
- en: To access data on a disk, the Linux kernel uses the system of layers shown in
    [Figure 4-2](#figure4-2). The SCSI subsystem and everything else described in
    Section 3.6 are represented by a single box. Notice that you can work with the
    disk through the filesystem as well as directly through the disk devices. You’ll
    see how both methods work in this chapter. To make things simpler, LVM is not
    represented in [Figure 4-2](#figure4-2), but it has components in the block device
    interface and a few management components in user space.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问磁盘上的数据，Linux内核使用[图4-2](#figure4-2)中所示的层次结构。SCSI子系统及第3.6节中描述的其他内容被表示为一个单独的框。请注意，你可以通过文件系统以及直接通过磁盘设备来操作磁盘。在本章中，你将看到这两种方法如何工作。为了简化，LVM在[图4-2](#figure4-2)中未被表示，但它在块设备接口中有组件，并在用户空间中有一些管理组件。
- en: To get a handle on how everything fits together, let’s start at the bottom with
    partitions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解各部分如何组合在一起，我们从最底层的分区开始。
- en: '![f04002](image_fi/500402c04/f04002.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![f04002](image_fi/500402c04/f04002.png)'
- en: 'Figure 4-2: Kernel schematic for disk access'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图4-2：磁盘访问的内核示意图
- en: 4.1 Partitioning Disk Devices
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 磁盘设备分区
- en: There are many kinds of partition tables. There’s nothing special about a partition
    table—it’s just a bunch of data that says how the blocks on the disk are divided.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 分区表有很多种类型。分区表本身并没有什么特别之处——它只是一堆数据，用来表示磁盘上的块是如何划分的。
- en: The traditional table, dating back to the PC days, is the one found inside the
    *Master Boot Record (MBR)*, and it has many limitations. Most newer systems use
    the *Globally Unique Identifier Partition Table (GPT)*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的分区表可以追溯到PC时代，存在于*主引导记录（MBR）*中，并且有许多限制。大多数较新的系统使用*全局唯一标识符分区表（GPT）*。
- en: 'Here are a few of the many Linux partitioning tools:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些常见的Linux分区工具：
- en: '`parted` **(“partition editor”)** A text-based tool that supports both MBR
    and GPT.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`parted` **（“分区编辑器”）** 一款支持MBR和GPT的基于文本的工具。'
- en: '`gparted` A graphical version of `parted`.'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`gparted` `parted`的图形化版本。'
- en: '`fdisk` The traditional text-based Linux disk partitioning tool. Recent versions
    of `fdisk` support the MBR, GPT, and many other kinds of partition tables, but
    older versions were limited to MBR support.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fdisk` 传统的基于文本的Linux磁盘分区工具。`fdisk`的新版支持MBR、GPT以及许多其他类型的分区表，但旧版本仅支持MBR。'
- en: Because it has supported both the MBR and GPT for some time, and it’s easy to
    run single commands to get partition labels, we’ll use `parted` to display partition
    tables. However, when creating and altering partition tables, we’ll use `fdisk`.
    This will illustrate both interfaces, and why many people prefer the `fdisk` interface
    due to its interactive nature and the fact that it doesn’t make any changes to
    the disk until you’ve had a chance to review them (we’ll discuss this shortly).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`parted`已经支持MBR和GPT很长时间了，并且可以很容易地通过单个命令获取分区标签，我们将使用`parted`来显示分区表。不过，在创建和修改分区表时，我们将使用`fdisk`。这将展示两种界面，以及为什么许多人更喜欢`fdisk`界面，因为它是交互式的，并且在你有机会查看变更之前，它不会对磁盘做任何修改（我们稍后会讨论这一点）。
- en: 4.1.1 Viewing a Partition Table
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 查看分区表
- en: 'You can view your system’s partition table with `parted -l`. This sample output
    shows two disk devices with two different kinds of partition tables:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`parted -l`查看系统的分区表。以下是示例输出，展示了两个不同分区表类型的磁盘设备：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first device (*/dev/sda*) 1 uses the traditional MBR partition table (which
    `parted` calls `msdos`), and the second (*/dev/sdf*) 2 contains a GPT. Notice
    that the two table types store different sets of parameters. In particular, the
    MBR table has no `Name` column because names don’t exist under that scheme. (I
    arbitrarily chose the names `myfirst` and `mysecond` in the GPT.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个设备（*/dev/sda*）1使用传统的MBR分区表（`parted`称之为`msdos`），而第二个设备（*/dev/sdf*）2包含一个GPT。注意，两个分区表类型存储的参数集不同。特别是，MBR表没有`Name`列，因为在这种方案下没有名字。（我在GPT中随意选择了`myfirst`和`mysecond`作为名称。）
- en: MBR Basics
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MBR基础知识
- en: The MBR table in this example contains primary, extended, and logical partitions.
    A *primary partition* is a normal subdivision of the disk; partition 1 is an example.
    The basic MBR has a limit of four primary partitions, so if you want more than
    four, you must designate one as an *extended partition*. An extended partition
    breaks down into *logical partitions*, which the operating system can then use
    as it would any other partition. In this example, partition 2 is an extended partition
    that contains logical partition 5.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中的MBR表包含主分区、扩展分区和逻辑分区。*主分区*是磁盘的正常子分区；分区1就是一个示例。基础的MBR最多支持四个主分区，因此如果你需要超过四个分区，你必须将其中一个标记为*扩展分区*。扩展分区可以划分为*逻辑分区*，操作系统可以像使用任何其他分区一样使用这些逻辑分区。在这个示例中，分区2是一个扩展分区，它包含了逻辑分区5。
- en: 'LVM Partitions: A Sneak Peek'
  id: totrans-31
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: LVM分区：快速预览
- en: When viewing your partition table, if you see partitions labeled as LVM (code
    `8e` as the partition type), devices named `/dev/dm-*`, or references to the “device
    mapper,” then your system uses LVM. Our discussion will start with traditional
    direct disk partitioning, which will look slightly different from what’s on a
    system using LVM.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看你的分区表时，如果你看到标记为LVM（分区类型代码为`8e`）、设备名为`/dev/dm-*`，或者提到“设备映射器”的内容，那么说明你的系统使用了LVM。我们的讨论将从传统的直接磁盘分区开始，这看起来与使用LVM的系统稍有不同。
- en: 'Just so you know what to expect, let’s take a quick look at some sample `parted
    -l` output on a system with LVM (a fresh installation of Ubuntu using LVM on VirtualBox).
    First, there’s a description of the actual partition table, which looks mostly
    as you’d expect, except for the `lvm` flag:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你知道该期待什么，我们先快速看一下在一台使用LVM的系统上（在VirtualBox中安装全新Ubuntu并使用LVM）运行`parted -l`命令时的输出。首先，是实际分区表的描述，整体看起来和你预期的差不多，唯一不同的是`lvm`标志：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then there are some devices that look like they should be partitions, but are
    called disks:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是一些看起来应该是分区，但被称为磁盘的设备：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A simple way to think about this is that the partitions have been somehow separated
    from the partition table. You’ll see what’s actually going on in Section 4.4.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的理解方式是，分区在某种程度上已经与分区表分离。你将在第4.4节看到实际发生了什么。
- en: Initial Kernel Read
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 初始内核读取
- en: 'When initially reading the MBR table, the Linux kernel produces debugging output
    like this (remember that you can view this with `journalctl -k`):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初读取MBR表时，Linux内核会输出类似这样的调试信息（记得你可以通过`journalctl -k`查看）：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `sda2 < sda5 >` portion of the output indicates that */dev/sda2* is an extended
    partition containing one logical partition, */dev/sda5*. You’ll normally ignore
    the extended partition itself because you typically care only about accessing
    the logical partitions it contains.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 输出中的`sda2 < sda5 >`部分表示*/dev/sda2*是一个扩展分区，包含一个逻辑分区*/dev/sda5*。通常，你会忽略扩展分区本身，因为你通常只关心访问它包含的逻辑分区。
- en: 4.1.2 Modifying Partition Tables
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 修改分区表
- en: 'Viewing partition tables is a relatively simple and harmless operation. Altering
    partition tables is also relatively easy, but making this kind of change to the
    disk involves risks. Keep the following in mind:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 查看分区表是一个相对简单且无害的操作。更改分区表也相对容易，但对磁盘进行这种更改涉及一定的风险。请记住以下几点：
- en: Changing the partition table makes it quite difficult to recover any data on
    partitions that you delete or redefine, because doing so can erase the location
    of the filesystems on those partitions. Make sure you have a backup if the disk
    you’re partitioning contains critical data.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改分区表会使恢复你删除或重新定义的分区上的任何数据变得非常困难，因为这样做可能会删除这些分区上文件系统的位置。如果你正在分区的磁盘包含重要数据，请确保你有备份。
- en: Ensure that no partitions on your target disk are currently in use. This is
    a concern because most Linux distributions automatically mount any detected filesystem.
    (See Section 4.2.3 for more on mounting and unmounting.)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保目标磁盘上的分区当前没有被使用。这是一个重要问题，因为大多数Linux发行版会自动挂载任何检测到的文件系统。（关于挂载和卸载的更多内容，请参见第4.2.3节。）
- en: When you’re ready, choose your partitioning program. If you’d like to use `parted`,
    you can use the command-line `parted` utility or a graphical interface, such as
    `gparted`; `fdisk` is fairly easy to work with on the command line. These utilities
    all have online help and are easy to learn. (Try using them on a flash device
    or something similar if you don’t have any spare disks.)
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好时，选择你的分区程序。如果你想使用`parted`，你可以使用命令行工具`parted`或图形界面工具，如`gparted`；`fdisk`在命令行中也非常容易使用。这些工具都有在线帮助，且容易学习。（如果你没有备用磁盘，试着在闪存设备或类似设备上使用它们。）
- en: That said, there is a major difference in the way that `fdisk` and `parted`
    work. With `fdisk`, you design your new partition table before making the actual
    changes to the disk, and it makes the changes only when you exit the program.
    But with `parted`, partitions are created, modified, and removed *as you issue
    the commands*. You don’t get the chance to review the partition table before you
    change it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，`fdisk`和`parted`的工作方式存在一个主要区别。使用`fdisk`时，你在实际更改磁盘之前先设计好新的分区表，并且只有在退出程序时才会进行更改。但使用`parted`时，分区是在你发出命令时*创建、修改和删除*的。在更改之前，你没有机会查看分区表。
- en: These differences are also key to understanding how the two utilities interact
    with the kernel. Both `fdisk` and `parted` modify the partitions entirely in user
    space; there’s no need to provide kernel support for rewriting a partition table,
    because user space can read and modify all of a block device.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些差异对于理解这两种工具如何与内核交互也非常关键。`fdisk`和`parted`都完全在用户空间修改分区；不需要提供内核支持来重写分区表，因为用户空间可以读取和修改整个块设备。
- en: 'At some point, though, the kernel must read the partition table in order to
    present the partitions as block devices so you can use them. The `fdisk` utility
    uses a relatively simple method. After modifying the partition table, `fdisk`
    issues a single system call to tell the kernel that it should reread the disk’s
    partition table (you’ll see an example of how to interact with `fdisk` shortly).
    The kernel then generates debugging output, which you can view with `journalctl
    -k`. For example, if you create two partitions on */dev/sdf*, you’ll see this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某个时刻，内核必须读取分区表，以便将分区作为块设备呈现，这样你就可以使用它们。`fdisk`工具采用一种相对简单的方法。在修改分区表后，`fdisk`会发出一个系统调用，告诉内核应该重新读取磁盘的分区表（你很快会看到如何与`fdisk`交互的示例）。然后，内核会生成调试输出，你可以通过`journalctl
    -k`查看。例如，如果你在*/dev/sdf*上创建了两个分区，你将看到如下信息：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `parted` tools do not use this disk-wide system call; instead, they signal
    the kernel when individual partitions are altered. After processing a single partition
    change, the kernel does not produce the preceding debugging output.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`parted` 工具不会使用这种磁盘范围的系统调用；相反，它们在修改单个分区时会向内核发送信号。处理单个分区更改后，内核不会产生前面提到的调试输出。'
- en: 'There are a few ways to see the partition changes:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以查看分区更改：
- en: Use `udevadm` to watch the kernel event changes. For example, the command `udevadm
    monitor --kernel` will show the old partition devices being removed and the new
    ones being added.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `udevadm` 监视内核事件变化。例如，命令 `udevadm monitor --kernel` 将显示旧的分区设备被移除并添加新的分区设备。
- en: Check */proc/partitions* for full partition information.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 */proc/partitions* 获取完整的分区信息。
- en: Check */sys/block/device/* for altered partition system interfaces or */dev*
    for altered partition devices.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 */sys/block/device/* 以查看修改后的分区系统接口，或 */dev* 以查看修改后的分区设备。
- en: 4.1.3 Creating a Partition Table
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 创建分区表
- en: 'Let’s apply everything you just learned by creating a new partition table on
    a new, empty disk. This example shows the following scenario:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在一个新的空磁盘上创建一个新的分区表来应用你刚刚学到的所有内容。这个例子展示了以下场景：
- en: 4GB disk (a small USB flash device, unused; if you want to follow this example,
    use any size device that you have at hand)
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4GB 磁盘（一个小型 USB 闪存设备，未使用；如果你想跟着这个示例操作，可以使用任何你手头的设备）
- en: MBR-style partition table
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MBR 风格分区表
- en: 'Two partitions intended to be populated with an ext4 filesystem: 200MB and
    3.8GB'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个分区打算使用 ext4 文件系统：200MB 和 3.8GB
- en: Disk device at */dev/sdd*; you’ll need to find your own device location with
    `lsblk`
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘设备位于 */dev/sdd*；你需要使用 `lsblk` 查找自己的设备位置
- en: 'You’ll use `fdisk` to do the work. Recall that this is an interactive command,
    so after ensuring that nothing on the disk is mounted, you’ll start at the command
    prompt with the device name:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 `fdisk` 来完成工作。回想一下，这是一条交互式命令，所以在确保磁盘上没有任何挂载内容后，你会在命令提示符下输入设备名称：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You’ll get an introductory message and then a command prompt like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你将收到一个介绍性消息，然后是类似这样的命令提示符：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'First, print the current table with the `p` command (`fdisk` commands are rather
    terse). Your interaction will probably look something like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用 `p` 命令打印当前的分区表（`fdisk` 命令简洁明了）。你的操作大致如下：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Most devices already contain one FAT-style partition, like this one at */dev/sdd1*.
    Because you want to create new partitions for Linux (and, of course, you’re sure
    you don’t need anything here), you can delete the existing ones like so:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数设备已经包含一个 FAT 风格的分区，比如这个位于 */dev/sdd1* 的分区。因为你要为 Linux 创建新分区（当然，你确定不需要这里的任何内容），所以你可以像这样删除现有的分区：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Remember that `fdisk` doesn’t make changes until you explicitly write the partition
    table, so you haven’t yet modified the disk. If you make a mistake you can’t recover
    from, use the `q` command to quit `fdisk` without writing the changes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`fdisk` 在你明确写入分区表之前不会做任何更改，因此你还没有修改磁盘。如果你犯了无法恢复的错误，可以使用 `q` 命令退出 `fdisk`
    而不保存更改。
- en: 'Now you’ll create the first 200MB partition with the `n` command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将使用 `n` 命令创建第一个 200MB 的分区：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, `fdisk` prompts you for the MBR partition style, the partition number,
    the start of the partition, and its end (or size). The default values are quite
    often what you want. The only thing changed here is the partition end/size with
    the `+` syntax to specify a size and unit.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`fdisk` 会提示你选择 MBR 分区风格、分区号、分区的起始位置及其结束位置（或大小）。默认值通常是你需要的。这里唯一变化的是使用 `+`
    语法来指定分区的结束位置/大小和单位。
- en: 'Creating the second partition works the same way, except you’ll use all default
    values, so we won’t go over that. When you’re finished laying out the partitions,
    use the `p` (print) command to review:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 创建第二个分区的方式与此相同，只是你会使用所有默认值，因此我们不再赘述。当你完成分区布局后，使用 `p`（打印）命令进行查看：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When you’re ready to write the partition table, use the `w` command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好写入分区表时，使用 `w` 命令：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that `fdisk` doesn’t ask you if you’re sure as a safety measure; it simply
    does its work and exits.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`fdisk` 不会像安全措施一样询问你是否确定，它会直接执行操作并退出。
- en: If you’re interested in additional diagnostic messages, use `journalctl -k`
    to see the kernel read messages mentioned earlier, but remember that you’ll get
    them only if you’re using `fdisk`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对其他诊断信息感兴趣，可以使用 `journalctl -k` 查看之前提到的内核读取信息，但请记住，只有在使用 `fdisk` 时你才能看到这些信息。
- en: At this point, you have all the basics to start partitioning disks, but if you’d
    like more details about disks, read on. Otherwise, skip ahead to Section 4.2 to
    learn about putting a filesystem on the disk.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经掌握了开始分区硬盘的基础知识，但如果您想要更多关于硬盘的细节，请继续阅读。否则，跳到第4.2节了解如何在硬盘上放置文件系统。
- en: 4.1.4 Navigating Disk and Partition Geometry
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.4 导航硬盘和分区几何
- en: Any device with moving parts introduces complexity into a software system because
    there are physical elements that resist abstraction. A hard disk is no exception;
    even though you can think of a hard disk as a block device with random access
    to any block, there can be serious performance consequences if the system isn’t
    careful about how it lays out data on the disk. Consider the physical properties
    of the simple single-platter disk illustrated in [Figure 4-3](#figure4-3).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 任何带有移动部件的设备都会向软件系统引入复杂性，因为存在抵制抽象的物理元素。硬盘也不例外；即使您可以将硬盘视为具有对任何块的随机访问的块设备，如果系统在如何在硬盘上布局数据方面不小心，可能会导致严重的性能后果。考虑图示的简单单盘硬盘的物理特性[图4-3](#figure4-3)。
- en: '![f04003](image_fi/500402c04/f04003.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![f04003](image_fi/500402c04/f04003.png)'
- en: 'Figure 4-3: Top-down view of a hard disk'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-3：硬盘的俯视图
- en: The disk consists of a spinning platter on a spindle, with a head attached to
    a moving arm that can sweep across the radius of the disk. As the disk spins underneath
    the head, the head reads data. When the arm is in one position, the head can read
    data only from a fixed circle. This circle is called a *cylinder* because larger
    disks have more than one platter, all stacked and spinning around the same spindle.
    Each platter can have one or two heads, for the top and/or bottom of the platter,
    and all heads are attached to the same arm and move in concert. Because the arm
    moves, there are many cylinders on the disk, from small ones around the center
    to large ones around the periphery of the disk. Finally, you can divide a cylinder
    into slices called *sectors*. This way of thinking about the disk geometry is
    called *CHS*, for *cylinder-head-sector*; in older systems, you could find any
    part of the disk by addressing it with these three parameters.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 硬盘由安装在主轴上的旋转盘片和连接到移动臂的磁头组成，臂可以在盘片半径上扫动。当盘片在磁头下旋转时，磁头读取数据。当臂处于一个位置时，磁头只能从一个固定圆圈读取数据。这个圆圈因为较大的硬盘有多个盘片，所有盘片都围绕同一主轴旋转，被称为*柱面*。每个盘片可以有一个或两个磁头，用于盘片的顶部和/或底部，并且所有磁头都连接到同一个臂上并协调移动。由于臂的移动，硬盘上有许多柱面，从中心周围的小柱面到盘片边缘周围的大柱面。最后，您可以将柱面分为*扇区*。这种关于硬盘几何结构的思维方式称为*CHS*，代表*柱面-磁头-扇区*；在旧系统中，您可以通过这三个参数的地址找到硬盘的任何部分。
- en: The kernel and the various partitioning programs can tell you what a disk reports
    as its number of cylinders. However, on any halfway recent hard disk, *the reported
    values are fiction*! The traditional addressing scheme that uses CHS doesn’t scale
    with modern disk hardware, nor does it account for the fact that you can put more
    data into outer cylinders than inner cylinders. Disk hardware supports *Logical
    Block Addressing (LBA)* to address a location on the disk by a block number (this
    is a much more straightforward interface), but remnants of CHS remain. For example,
    the MBR partition table contains CHS information as well as LBA equivalents, and
    some boot loaders are still dumb enough to believe the CHS values (don’t worry—most
    Linux boot loaders use the LBA values).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 内核和各种分区程序可以告诉您，硬盘报告的柱面数是多少。然而，在任何半新的硬盘上，*报告的值都是虚构的*！使用CHS的传统寻址方案无法与现代硬盘硬件兼容，也不能解释外圈柱面可以存放更多数据的事实。硬盘硬件支持*逻辑块地址寻址（LBA）*通过块编号来寻址硬盘上的位置（这是一个更直接的接口），但CHS的遗留物仍然存在。例如，MBR分区表包含CHS信息以及LBA等效信息，并且一些引导加载程序仍然愚蠢到相信CHS值（不用担心——大多数Linux引导加载程序使用LBA值）。
- en: 4.1.5 Reading from Solid-State Disks
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.5 从固态硬盘读取
- en: Storage devices with no moving parts, such as *solid-state disks (SSDs)*, are
    radically different from spinning disks in terms of their access characteristics.
    For these, random access isn’t a problem because there’s no head to sweep across
    a platter, but certain characteristics can change how an SSD performs.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 没有移动部件的存储设备，如*固态硬盘（SSD）*，在访问特性上与旋转硬盘有根本的不同。对于这些设备，随机访问不是问题，因为没有磁头在盘片上扫过，但某些特性可能会改变SSD的性能表现。
- en: One of the most significant factors affecting the performance of SSDs is *partition
    alignment*. When you read data from an SSD, you read it in chunks (called *pages*,
    not to be confused with virtual memory pages)—such as 4,096 or 8,192 bytes at
    a time—and the read must begin at a multiple of that size. This means that if
    your partition and its data do not lie on a boundary, you may have to do two reads
    instead of one for small, common operations, such as reading the contents of a
    directory.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 影响SSD性能的最重要因素之一是*分区对齐*。当你从SSD读取数据时，你是按块读取数据（称为*页面*，不要与虚拟内存页面混淆）——例如每次读取4,096或8,192字节——而且读取必须从该大小的倍数开始。这意味着如果你的分区及其数据不位于边界上，你可能需要做两次读取而不是一次，这对于小的常见操作（例如读取目录内容）来说会增加开销。
- en: Reasonably new versions of partitioning utilities include logic to put newly
    created partitions at the proper offsets from the beginning of the disks, so you
    probably don’t need to worry about improper partition alignment. Partitioning
    tools currently don’t make any calculations; instead, they just align partitions
    on 1MB boundaries or, more precisely, 2,048 512-byte blocks. This is a rather
    conservative approach because the boundary aligns with page sizes of 4,096, 8,192,
    and so on, all the way up to 1,048,576.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 较新的分区工具版本包含将新创建的分区放置在磁盘起始位置适当偏移处的逻辑，因此你可能不需要担心分区对齐不当的问题。目前，分区工具不进行任何计算；它们只是将分区对齐到1MB边界，或者更精确地说，是2,048个512字节的块。这是一种相当保守的方法，因为该边界与4,096、8,192等页面大小对齐，一直到1,048,576。
- en: 'However, if you’re curious or want to make sure that your partitions begin
    on a boundary, you can easily find this information in the */sys/block* directory.
    Here’s an example for the partition */dev/sdf2*:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你有兴趣或想确保你的分区以边界开始，你可以很容易地在*/sys/block*目录中找到此信息。以下是分区*/dev/sdf2*的一个例子：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The output here is the partition’s offset from the start of the device, in units
    of 512 bytes (again, confusingly called *sectors* by the Linux system). If this
    SSD uses 4,096-byte pages, there are eight of these sectors in a page. All you
    need to do is see if you can evenly divide the partition offset by 8\. In this
    case, you can’t, so the partition would not attain optimal performance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的输出是分区相对于设备起始位置的偏移量，以512字节为单位（Linux系统将其混淆地称为*扇区*）。如果这个SSD使用4,096字节的页面，那么每个页面里有八个这样的扇区。你只需要检查是否能够将分区偏移量除以8整除。此时，你不能整除，因此该分区将无法达到最佳性能。
- en: 4.2 Filesystems
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 文件系统
- en: The last link between the kernel and user space for disks is typically the *filesystem*;
    this is what you’re accustomed to interacting with when you run commands like
    `ls` and `cd`. As previously mentioned, the filesystem is a form of database;
    it supplies the structure to transform a simple block device into the sophisticated
    hierarchy of files and subdirectories that users can understand.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘上内核与用户空间之间的最后一个连接通常是*文件系统*；这就是你在运行像`ls`和`cd`这样的命令时与之交互的内容。正如前面提到的，文件系统是一种数据库形式；它提供了将简单的块设备转化为用户可以理解的复杂文件和子目录层次结构的结构。
- en: At one time, all filesystems resided on disks and other physical media that
    were intended exclusively for data storage. However, the tree-like directory structure
    and I/O interface of filesystems are quite versatile, so filesystems now perform
    a variety of tasks, such as the system interfaces that you see in */sys* and */proc*.
    Filesystems are traditionally implemented in the kernel, but the innovation of
    9P from Plan 9 ([https://en.wikipedia.org/wiki/9P_(protocol)](https://en.wikipedia.org/wiki/9P_(protocol)))
    has inspired the development of user-space filesystems. The *File System in User
    Space (FUSE)* feature allows user-space filesystems in Linux.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 曾几何时，所有文件系统都存在于磁盘和其他仅用于数据存储的物理介质上。然而，文件系统的树状目录结构和I/O接口非常通用，因此文件系统现在执行各种任务，例如在*/sys*和*/proc*中看到的系统接口。文件系统传统上是在内核中实现的，但来自Plan
    9的9P创新（[https://en.wikipedia.org/wiki/9P_(protocol)](https://en.wikipedia.org/wiki/9P_(protocol)))激发了用户空间文件系统的发展。*用户空间文件系统
    (FUSE)* 功能允许Linux中的用户空间文件系统。
- en: The *Virtual File System (VFS)* abstraction layer completes the filesystem implementation.
    Much as the SCSI subsystem standardizes communication between different device
    types and kernel control commands, VFS ensures that all filesystem implementations
    support a standard interface so that user-space applications access files and
    directories in the same manner. VFS support has enabled Linux to support an extraordinarily
    large number of filesystems.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*虚拟文件系统（VFS）*抽象层完成了文件系统的实现。就像 SCSI 子系统通过标准化不同设备类型与内核控制命令之间的通信一样，VFS 确保所有文件系统实现都支持标准接口，使得用户空间应用程序能够以相同的方式访问文件和目录。VFS
    的支持使得 Linux 能够支持数量庞大的文件系统。'
- en: 4.2.1 Filesystem Types
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 文件系统类型
- en: Linux filesystem support includes native designs optimized for Linux; foreign
    types, such as the Windows FAT family; universal filesystems, like ISO 9660; and
    many others. The following list includes the most common types of filesystems
    for data storage. The type names as recognized by Linux are in parentheses next
    to the filesystem names.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 文件系统支持包括为 Linux 优化的本地设计；外来类型，如 Windows FAT 系列；通用文件系统，如 ISO 9660；以及许多其他文件系统。以下列表包括用于数据存储的最常见文件系统类型。Linux
    识别的类型名称位于文件系统名称旁边的括号内。
- en: The *Fourth Extended filesystem* (ext4) is the current iteration of a line of
    filesystems native to Linux. The *Second Extended filesystem* (ext2) was a longtime
    default for Linux systems inspired by traditional Unix filesystems, such as the
    Unix File System (UFS) and the Fast File System (FFS). The *Third Extended filesystem*
    (ext3) added a journal feature (a small cache outside the normal filesystem data
    structure) to enhance data integrity and hasten booting. The ext4 filesystem is
    an incremental improvement and supports larger files than ext2 or ext3 as well
    as a greater number of subdirectories.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第四扩展文件系统*（ext4）是 Linux 本地文件系统系列的最新版本。*第二扩展文件系统*（ext2）曾是 Linux 系统的默认文件系统，灵感来自传统的
    Unix 文件系统，如 Unix 文件系统（UFS）和快速文件系统（FFS）。*第三扩展文件系统*（ext3）增加了日志功能（一个在正常文件系统数据结构之外的小缓存）以增强数据完整性并加速启动。ext4
    文件系统是在 ext2 和 ext3 的基础上的增量改进，支持比 ext2 或 ext3 更大的文件以及更多的子目录。'
- en: There’s a certain amount of backward compatibility in the extended filesystem
    series. For example, you can mount ext2 and ext3 filesystems as each other, and
    you can mount ext2 and ext3 filesystems as ext4, but you *cannot* mount ext4 as
    ext2 or ext3.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 扩展文件系统系列具有一定的向后兼容性。例如，你可以将 ext2 和 ext3 文件系统互相挂载，也可以将 ext2 和 ext3 文件系统挂载为 ext4，但你*不能*将
    ext4 挂载为 ext2 或 ext3。
- en: '*Btrfs, or B-tree filesystem* (btrfs), is a newer filesystem native to Linux
    designed to scale beyond the capabilities of ext4.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Btrfs，或 B 树文件系统*（btrfs）是一个较新的 Linux 本地文件系统，旨在超越 ext4 的能力。'
- en: '*FAT filesystems* (msdos, vfat, exfat) pertain to Microsoft systems. The simple
    msdos type supports the very primitive monocase variety in MS-DOS systems. Most
    removable flash media, such as SD cards and USB drives, contain vfat (up to 4GB)
    or exfat (4GB and up) partitions by default. Windows systems can use either a
    FAT-based filesystem or the more advanced *NT File System* (ntfs).'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*FAT 文件系统*（msdos, vfat, exfat）属于微软系统。简单的 msdos 类型支持 MS-DOS 系统中的非常原始的单一字母大小写。大多数可移动闪存介质，如
    SD 卡和 USB 驱动器，默认包含 vfat（最多 4GB）或 exfat（4GB 及以上）分区。Windows 系统可以使用 FAT 文件系统或更高级的
    *NT 文件系统*（ntfs）。'
- en: '*XFS* is a high-performance filesystem used by default by some distributions,
    such as Red Hat Enterprise Linux 7.0 and beyond.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*XFS* 是一种高性能文件系统，一些发行版（如 Red Hat Enterprise Linux 7.0 及更高版本）默认使用该文件系统。'
- en: '*HFS+* (hfsplus) is an Apple standard used on most Macintosh systems.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*HFS+*（hfsplus）是苹果公司在大多数 Macintosh 系统上使用的标准。'
- en: '*ISO 9660* (iso9660) is a CD-ROM standard. Most CD-ROMs use some variety of
    the ISO 9660 standard.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ISO 9660*（iso9660）是一个 CD-ROM 标准。大多数 CD-ROM 使用某种变种的 ISO 9660 标准。'
- en: 4.2.2 Creating a Filesystem
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 创建文件系统
- en: If you’re preparing a new storage device, once you’re finished with the partitioning
    process described in Section 4.1, you’re ready to create a filesystem. As with
    partitioning, you’ll do this in user space because a user-space process can directly
    access and manipulate a block device.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在准备一个新的存储设备，一旦完成了 4.1 节中描述的分区过程，你就可以开始创建文件系统了。与分区一样，你将在用户空间中进行此操作，因为用户空间进程可以直接访问和操作块设备。
- en: 'The `mkfs` utility can create many kinds of filesystems. For example, you can
    create an ext4 partition on */dev/sdf2* with this command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkfs` 工具可以创建多种类型的文件系统。例如，你可以使用以下命令在 */dev/sdf2* 上创建一个 ext4 分区：'
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `mkfs` program automatically determines the number of blocks in a device
    and sets some reasonable defaults. Unless you really know what you’re doing and
    feel like reading the documentation in detail, don’t change them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`mkfs`程序会自动确定设备中的块数并设置一些合理的默认值。除非你非常清楚自己在做什么并且愿意详细阅读文档，否则不要修改这些设置。'
- en: When you create a filesystem, `mkfs` prints diagnostic output as it works, including
    output pertaining to the superblock. The *superblock* is a key component at the
    top level of the filesystem database, and it’s so important that `mkfs` creates
    a number of backups in case the original is destroyed. Consider recording a few
    of the superblock backup numbers when `mkfs` runs, in case you need to recover
    the superblock in the event of a disk failure (see Section 4.2.11).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个文件系统时，`mkfs`会在工作过程中打印诊断输出，包括关于超级块的输出。*超级块*是文件系统数据库顶层的一个关键组件，它非常重要，以至于`mkfs`会创建多个备份，以防原始的超级块丢失。考虑在`mkfs`运行时记录一些超级块备份编号，以防在磁盘故障时需要恢复超级块（详见第4.2.11节）。
- en: 4.2.3 Mounting a Filesystem
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 挂载文件系统
- en: On Unix, the process of attaching a filesystem to a running system is called
    *mounting*. When the system boots, the kernel reads some configuration data and
    mounts root (`/`) based on the configuration data.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix中，将文件系统附加到运行中的系统的过程称为*挂载*。当系统启动时，内核会读取一些配置数据并根据这些配置数据挂载根目录(`/`)。
- en: 'In order to mount a filesystem, you must know the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要挂载文件系统，你必须知道以下内容：
- en: The filesystem’s device, location, or identifier (such as a disk partition—where
    the actual filesystem data resides). Some special-purpose filesystems, such as
    proc and sysfs, don’t have locations.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统的设备、位置或标识符（例如磁盘分区——实际文件系统数据所在的地方）。一些特殊用途的文件系统，如proc和sysfs，没有具体的位置。
- en: The filesystem type.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统类型。
- en: The *mount point*—the place in the current system’s directory hierarchy where
    the filesystem will be attached. The mount point is always a normal directory.
    For instance, you could use */music* as a mount point for a filesystem containing
    music. The mount point need not be directly below */*; it can be anywhere on the
    system.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*挂载点*——当前系统目录层次结构中将附加文件系统的位置。挂载点始终是一个普通目录。例如，你可以使用*/music*作为包含音乐的文件系统的挂载点。挂载点不必直接位于*/*下，它可以位于系统中的任何位置。'
- en: 'The common terminology for mounting a filesystem is “mount a device *on* a
    mount point.” To learn the current filesystem status of your system, you run `mount`.
    The output (which can be quite lengthy) should look like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 挂载文件系统的常用术语是“将设备*挂载*到挂载点”。要查看当前系统的文件系统状态，可以运行`mount`命令。输出（可能相当长）应如下所示：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Each line corresponds to one currently mounted filesystem, with items in this
    order:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行对应一个当前挂载的文件系统，项目顺序如下：
- en: The device, such as */dev/sda3*. Notice that some of these aren’t real devices
    (`proc`, for example) but are stand-ins for real device names because these special-purpose
    filesystems do not need devices.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设备，例如*/dev/sda3*。注意，其中一些不是实际的设备（例如`proc`），而是实际设备名称的代替符，因为这些特殊用途的文件系统不需要设备。
- en: The word `on`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单词`on`。
- en: The mount point.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挂载点。
- en: The word `type`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单词`type`。
- en: The filesystem type, usually in the form of a short identifier.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件系统类型，通常以简短标识符的形式表示。
- en: Mount options (in parentheses). See Section 4.2.6 for more details.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挂载选项（在括号中）。更多详情见第4.2.6节。
- en: 'To mount a filesystem manually, use the `mount` command as follows with the
    filesystem type, device, and desired mount point:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动挂载文件系统，可以使用`mount`命令，指定文件系统类型、设备和所需的挂载点：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For example, to mount the Fourth Extended filesystem found on the device */dev/sdf2*
    on */home/extra*, use this command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将位于设备*/dev/sdf2*上的第四扩展文件系统挂载到*/home/extra*，可以使用以下命令：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You normally don’t need to supply the `-t` `type` option because `mount` usually
    figures it out for you. However, sometimes it’s necessary to distinguish between
    two similar types, such as the various FAT-style filesystems.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你不需要提供`-t` `type`选项，因为`mount`通常会为你自动识别。不过，有时需要区分两种相似的类型，例如各种FAT样式的文件系统。
- en: 'To unmount (detach) a filesystem, use the `umount` command as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要卸载（分离）文件系统，可以使用以下`umount`命令：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can also unmount a filesystem with its device instead of its mount point.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用设备而非挂载点来卸载文件系统。
- en: 4.2.4 Filesystem UUID
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 文件系统UUID
- en: The method of mounting filesystems discussed in the preceding section depends
    on device names. However, device names can change because they depend on the order
    in which the kernel finds the devices. To solve this problem, you can identify
    and mount filesystems by their *universally unique identifier (UUID)*, an industry
    standard for unique “serial numbers” to identify objects in a computer system.
    Filesystem creation programs like `mke2fs` generate a UUID when initializing the
    filesystem data structure.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 前面部分讨论的挂载文件系统的方法依赖于设备名称。然而，设备名称可能会发生变化，因为它们取决于内核找到设备的顺序。为了解决这个问题，您可以通过它们的*全局唯一标识符（UUID）*来识别和挂载文件系统。UUID是一种行业标准，用于为计算机系统中的对象分配唯一的“序列号”。像`mke2fs`这样的文件系统创建程序在初始化文件系统数据结构时会生成UUID。
- en: 'To view a list of devices and the corresponding filesystems and UUIDs on your
    system, use the `blkid` (block ID) program:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看系统上设备及其对应的文件系统和UUID列表，请使用`blkid`（块ID）程序：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this example, `blkid` found four partitions with data: two with ext4 filesystems,
    one with a swap space signature (see Section 4.3), and one with a FAT-based filesystem.
    The Linux native partitions all have standard UUIDs, but the FAT partition doesn’t.
    You can reference the FAT partition with its FAT volume serial number (in this
    case, 4859-EFEA).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，`blkid`发现了四个包含数据的分区：两个带有ext4文件系统，一个带有交换空间标识符（参见第4.3节），还有一个带有FAT文件系统。Linux本地分区都有标准UUID，但FAT分区没有。您可以通过其FAT卷序列号（在此例中为4859-EFEA）引用FAT分区。
- en: 'To mount a filesystem by its UUID, use the `UUID` mount option. For example,
    to mount the first filesystem from the preceding list on */home/extra*, enter:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过UUID挂载文件系统，请使用`UUID`挂载选项。例如，要将前面列表中的第一个文件系统挂载到*/home/extra*，请输入：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Typically you won’t manually mount filesystems by UUID like this, because you
    normally know the device, and it’s much easier to mount a device by its name than
    by its crazy UUID. Still, it’s important to understand UUIDs. For one thing, they’re
    the preferred way to mount non-LVM filesystems in */etc/fstab* automatically at
    boot time (see Section 4.2.8). In addition, many distributions use the UUID as
    a mount point when you insert removable media. In the preceding example, the FAT
    filesystem is on a flash media card. An Ubuntu system with someone logged in will
    mount this partition at */media/user/4859-EFEA* upon insertion. The udevd daemon
    described in Chapter 3 handles the initial event for the device insertion.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通常您不会像这样手动通过UUID挂载文件系统，因为您通常知道设备，并且通过设备名称挂载比通过UUID更简单。然而，理解UUID很重要。一方面，它们是自动在启动时通过*/etc/fstab*挂载非LVM文件系统的首选方法（参见第4.2.8节）。此外，许多发行版在插入可移动媒体时使用UUID作为挂载点。在前面的例子中，FAT文件系统位于闪存介质卡上。当有人登录的Ubuntu系统插入该卡时，会在*/media/user/4859-EFEA*处挂载此分区。第3章中描述的udevd守护进程处理设备插入的初始事件。
- en: You can change the UUID of a filesystem if necessary (for example, if you copied
    the complete filesystem from somewhere else and now need to distinguish it from
    the original). See the tune2fs(8) manual page for how to do this on an ext2/ext3/ext4
    filesystem.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，您可以更改文件系统的UUID（例如，如果您将整个文件系统从其他地方复制过来，现在需要将其与原始文件系统区分开）。有关如何在ext2/ext3/ext4文件系统上执行此操作，请参阅tune2fs(8)手册页。
- en: 4.2.5 Disk Buffering, Caching, and Filesystems
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.5 磁盘缓冲、缓存与文件系统
- en: Linux, like other Unix variants, buffers writes to the disk. This means the
    kernel usually doesn’t immediately write changes to filesystems when processes
    request changes. Instead, it stores those changes in RAM until the kernel determines
    a good time to actually write them to the disk. This buffering system is transparent
    to the user and provides a very significant performance gain.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Linux与其他Unix变种一样，会缓冲写入磁盘。这意味着内核通常不会立即在进程请求更改时将更改写入文件系统。相反，它将这些更改存储在RAM中，直到内核确定一个合适的时机将它们实际写入磁盘。这个缓冲系统对用户是透明的，并提供了显著的性能提升。
- en: When you unmount a filesystem with `umount`, the kernel automatically *synchronizes*
    with the disk, writing the changes in its buffer to the disk. You can also force
    the kernel to do this at any time by running the `sync` command, which by default
    synchronizes all the disks on the system. If for some reason you can’t unmount
    a filesystem before you turn off the system, be sure to run `sync` first.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`umount`卸载文件系统时，内核会自动与磁盘进行*同步*，将其缓冲区中的更改写入磁盘。您也可以通过运行`sync`命令强制内核随时执行此操作，默认情况下该命令会同步系统上的所有磁盘。如果由于某种原因您在关闭系统前无法卸载文件系统，请务必先运行`sync`命令。
- en: In addition, the kernel uses RAM to cache blocks as they’re read from a disk.
    Therefore, if one or more processes repeatedly access a file, the kernel doesn’t
    have to go to the disk again and again—it can simply read from the cache and save
    time and resources.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，内核使用 RAM 来缓存从磁盘读取的块。因此，如果一个或多个进程反复访问某个文件，内核就不需要一次又一次地访问磁盘，它可以直接从缓存中读取，从而节省时间和资源。
- en: 4.2.6 Filesystem Mount Options
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.6 文件系统挂载选项
- en: There are many ways to change the `mount` command behavior, which you’ll often
    need to do when working with removable media or performing system maintenance.
    In fact, the total number of `mount` options is staggering. The extensive mount(8)
    manual page is a good reference, but it’s hard to know where to start and what
    you can safely ignore. You’ll see the most useful options in this section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以改变`mount`命令的行为，这在处理可移动媒体或进行系统维护时经常需要做。实际上，`mount`选项的总数非常庞大。详尽的`mount(8)`手册页是一个很好的参考，但很难知道从哪里开始以及哪些可以安全忽略。在本节中，你将看到最有用的选项。
- en: 'Options fall into two rough categories: general and filesystem-specific. General
    options typically work for all filesystem types and include `-t` for specifying
    the filesystem type, as shown earlier. In contrast, a filesystem-specific option
    pertains only to certain filesystem types.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 选项大致分为两类：通用选项和特定于文件系统的选项。通用选项通常适用于所有类型的文件系统，包括早前提到的`-t`，用于指定文件系统类型。相反，特定于文件系统的选项仅适用于某些文件系统类型。
- en: To activate a filesystem option, use the `-o` switch followed by the option.
    For example, `-o remount,rw` remounts a filesystem already mounted as read-only
    in read-write mode.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用文件系统选项，请使用 `-o` 交换符，后面跟上选项。例如，`-o remount,rw` 将已挂载为只读的文件系统重新挂载为读写模式。
- en: Short General Options
  id: totrans-153
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 短通用选项
- en: 'General options have a short syntax. The most important are:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通用选项有简短的语法。最重要的选项包括：
- en: '`-r` The `-r` option mounts the filesystem in read-only mode. This has a number
    of uses, from write protection to bootstrapping. You don’t need to specify this
    option when accessing a read-only device, such as a CD-ROM; the system will do
    it for you (and will also tell you about the read-only status).'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-r` `-r`选项以只读模式挂载文件系统。它有多种用途，从写保护到引导。访问只读设备（如 CD-ROM）时，你无需指定此选项；系统会自动为你处理（并告知你只读状态）。'
- en: '`-n` The `-n` option ensures that `mount` does not try to update the system
    runtime mount database, */etc/mtab*. By default, the `mount` operation fails when
    it cannot write to this file, so this option is important at boot time because
    the root partition (including the system mount database) is read-only at first.
    You’ll also find this option handy when trying to fix a system problem in single-user
    mode, because the system mount database may not be available at the time.'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-n` `-n`选项确保 `mount` 不尝试更新系统运行时的挂载数据库 `*/etc/mtab*`。默认情况下，当无法写入此文件时，`mount`
    操作会失败，因此在启动时这个选项非常重要，因为根分区（包括系统挂载数据库）初始时是只读的。当你尝试在单用户模式下修复系统问题时，这个选项也很有用，因为此时系统挂载数据库可能不可用。'
- en: '`-t` The `-t` `type` option specifies the filesystem type.'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`-t` `-t` `type`选项用于指定文件系统类型。'
- en: Long Options
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 长选项
- en: Short options like `-r` are too limited for the ever-increasing number of `mount`
    options; there are too few letters in the alphabet to accommodate all possible
    options. Short options are also troublesome because it’s difficult to determine
    an option’s meaning based on a single letter. Many general options and all filesystem-specific
    options use a longer, more flexible option format.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 像 `-r` 这样的短选项对于不断增加的 `mount` 选项来说过于有限；字母表中的字母太少，无法容纳所有可能的选项。短选项也很麻烦，因为仅凭一个字母很难确定选项的含义。许多通用选项和所有特定于文件系统的选项都使用更长且更灵活的选项格式。
- en: 'To use long options with `mount` on the command line, start with `-o` followed
    by the appropriate keywords separated by commas. Here’s a complete example, with
    the long options following `-o`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要在命令行中使用 `mount` 的长选项，可以从 `-o` 开始，后面跟着用逗号分隔的适当关键词。以下是一个完整的示例，长选项紧跟在 `-o` 后面：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The two long options here are `ro` and `uid=1000`. The `ro` option specifies
    read-only mode and is the same as the `-r` short option. The `uid=1000` option
    tells the kernel to treat all files on the filesystem as if user ID 1000 is the
    owner.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的两个长选项是 `ro` 和 `uid=1000`。`ro` 选项指定只读模式，和 `-r` 短选项相同。`uid=1000` 选项告诉内核将文件系统上的所有文件视为用户
    ID 为 1000 的所有者。
- en: 'The most useful long options are these:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最有用的长选项如下：
- en: '`exec`, `noexec` Enables or disables execution of programs on the filesystem.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`exec`、`noexec` 启用或禁用在文件系统上执行程序。'
- en: '`suid`, `nosuid` Enables or disables `setuid` programs.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`suid`、`nosuid` 启用或禁用`setuid`程序。'
- en: '`ro` Mounts the filesystem in read-only mode (as does the `-r` short option).'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ro` 以只读模式挂载文件系统（与`-r`短选项相同）。'
- en: '`rw` Mounts the filesystem in read-write mode.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`rw` 以读写模式挂载文件系统。'
- en: 4.2.7 Remounting a Filesystem
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.7 重新挂载文件系统
- en: There will be times when you need to change the `mount` options for a currently
    mounted filesystem; the most common situation is when you need to make a read-only
    filesystem writable during crash recovery. In that case, you need to reattach
    the filesystem at the same mount point.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要更改当前已挂载文件系统的`mount`选项；最常见的情况是在崩溃恢复期间，你需要将只读文件系统变为可写。在这种情况下，你需要在相同的挂载点重新附加文件系统。
- en: 'The following command remounts the root directory in read-write mode (you need
    the `-n` option because the `mount` command can’t write to the system mount database
    when the root is read-only):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将根目录以读写模式重新挂载（由于`mount`命令在根目录为只读时无法写入系统挂载数据库，因此你需要使用`-n`选项）：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This command assumes that the correct device listing for */* is in */etc/fstab*
    (as discussed in the next section). If it isn’t, you must specify the device as
    an additional option.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令假定`/*`的正确设备列表已经在*/etc/fstab*中（如下一节所述）。如果没有，你必须将设备作为额外选项指定。
- en: 4.2.8 The /etc/fstab Filesystem Table
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.8 /etc/fstab文件系统表
- en: To mount filesystems at boot time and take the drudgery out of the `mount` command,
    Linux systems keep a permanent list of filesystems and options in */etc/fstab*.
    This is a plaintext file in a very simple format, as [Listing 4-1](#listing4-1)
    shows.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在启动时挂载文件系统并简化`mount`命令，Linux系统将文件系统及其选项的永久列表保存在*/etc/fstab*中。这是一个非常简单格式的纯文本文件，如[清单
    4-1](#listing4-1)所示。
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 4-1: List of filesystems and options in */etc/fstab*'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-1：*/etc/fstab*中的文件系统及其选项列表
- en: 'Each line corresponds to one filesystem and is broken into six fields. From
    left to right, these fields are:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行对应一个文件系统，并分为六个字段。从左到右，这些字段分别是：
- en: The device or UUID Most current Linux systems no longer use the device in */etc/fstab*,
    preferring the UUID.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设备或UUID 当前大多数Linux系统不再使用*/etc/fstab*中的设备，倾向于使用UUID。
- en: The mount point Indicates where to attach the filesystem.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 挂载点 指示将文件系统附加到哪里。
- en: The filesystem type You may not recognize `swap` in this list; this is a swap
    partition (see Section 4.3).
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件系统类型 你可能不会在这个列表中识别`swap`，它是交换分区（见第4.3节）。
- en: Options Long options, separated by commas.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选项 长选项，用逗号分隔。
- en: Backup information for use by the `dump` command The `dump` command is a long-obsolete
    backup utility; this field is no longer relevant. You should always set it to
    `0`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于`dump`命令的备份信息 `dump`命令是一个早已废弃的备份工具；该字段不再相关。你应该始终将其设置为`0`。
- en: The filesystem integrity test order To ensure that `fsck` always runs on the
    root first, always set this to `1` for the root filesystem and `2` for any other
    locally attached filesystems on a hard disk or SSD. Use `0` to disable the bootup
    check for every other filesystem, including read-only devices, swap, and the */proc*
    filesystem (see the `fsck` command in Section 4.2.11).
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件系统完整性测试顺序 为确保`fsck`始终首先在根文件系统上运行，请始终将根文件系统的该值设置为`1`，并将任何其他本地附加的硬盘或SSD文件系统的该值设置为`2`。使用`0`可以禁用对其他所有文件系统的启动检查，包括只读设备、交换分区以及*/proc*文件系统（请参见第4.2.11节中的`fsck`命令）。
- en: When using `mount`, you can take some shortcuts if the filesystem you want to
    work with is in */etc/fstab*. For example, if you were using [Listing 4-1](#listing4-1)
    and mounting a CD-ROM, you would simply run `mount /cdrom`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mount`时，如果你想要操作的文件系统已经在*/etc/fstab*中，你可以使用一些快捷方式。例如，如果你使用的是[清单 4-1](#listing4-1)并且挂载了一个CD-ROM，你只需运行`mount
    /cdrom`。
- en: 'You can also try to simultaneously mount all entries in */etc/fstab* that do
    not contain the `noauto` option with this command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以尝试同时挂载所有在*/etc/fstab*中没有包含`noauto`选项的条目，使用以下命令：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[Listing 4-1](#listing4-1) introduces some new options—namely, `errors`, `noauto`,
    and `user`, because they don’t apply outside the */etc/fstab* file. In addition,
    you’ll often see the `defaults` option here. These options are defined as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 4-1](#listing4-1)介绍了一些新的选项——即`errors`、`noauto`和`user`，因为它们不适用于*/etc/fstab*文件之外。此外，你还会经常看到`defaults`选项。这些选项的定义如下：'
- en: '`defaults` This sets the `mount` defaults: read-write mode, enable device files,
    executables, the `setuid` bit, and so on. Use this when you don’t want to give
    the filesystem any special options but you do want to fill all fields in */etc/fstab*.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`defaults` 这会设置`mount`的默认选项：读写模式，启用设备文件，执行文件，`setuid`位，等等。若不想为文件系统提供任何特别选项，但又想填写*/etc/fstab*中的所有字段，则使用此选项。'
- en: '`errors` This ext2/3/4-specific parameter sets the kernel behavior when the
    system has trouble mounting a filesystem. The default is normally `errors=continue`,
    meaning that the kernel should return an error code and keep running. To have
    the kernel try the mount again in read-only mode, use `errors=remount-ro`. The
    `errors=panic` setting tells the kernel (and your system) to halt when there’s
    a problem with the mount.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`errors` 这是一个特定于ext2/3/4的参数，用来设置系统在挂载文件系统时遇到问题时的内核行为。默认值通常是`errors=continue`，意味着内核应返回错误代码并继续运行。若要让内核在只读模式下重新尝试挂载，使用`errors=remount-ro`。`errors=panic`设置则会告诉内核（以及你的系统）在挂载出现问题时停止。'
- en: '`noauto` This option tells a `mount -a` command to ignore the entry. Use this
    to prevent a boot-time mount of a removable-media device, such as a flash storage
    device.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`noauto` 此选项告诉`mount -a`命令忽略此条目。若想防止可移动媒体设备（如闪存存储设备）在启动时挂载，可以使用此选项。'
- en: '`user` This option allows unprivileged users to run `mount` on a particular
    entry, which can be handy for allowing certain kinds of access to removable media.
    Because users can put a *setuid-root* file on removable media with another system,
    this option also sets `nosuid`, `noexec`, and `nodev` (to bar special device files).
    Keep in mind that for removable media and other general cases, this option is
    now of limited use, because most systems use `ubus` along with other mechanisms
    to automatically mount inserted media. However, this option can be useful in special
    cases when you want to grant control over mounting specific directories.'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`user` 此选项允许非特权用户对特定条目执行`mount`命令，这对于允许某些类型的可移动媒体访问非常方便。因为用户可以在可移动媒体上放置*setuid-root*文件并用另一个系统访问该媒体，所以此选项还会设置`nosuid`、`noexec`和`nodev`（以禁止特殊设备文件）。请记住，对于可移动媒体和其他一般情况，此选项现在的使用有限，因为大多数系统通过`ubus`及其他机制自动挂载插入的媒体。然而，在某些特殊情况下，若你想授予控制挂载特定目录的权限，此选项仍然有用。'
- en: 4.2.9 Alternatives to /etc/fstab
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.9 /etc/fstab的替代方案
- en: Although the */etc/fstab* file has been the traditional way to represent filesystems
    and their mount points, there are two alternatives. The first is an */etc/fstab.d*
    directory, which contains individual filesystem configuration files (one file
    for each filesystem). The idea is very similar to many other configuration directories
    that you’ll see throughout this book.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管*/etc/fstab*文件一直是表示文件系统及其挂载点的传统方式，但仍有两种替代方案。第一种是*/etc/fstab.d*目录，其中包含单独的文件系统配置文件（每个文件系统一个文件）。这个想法与本书中将看到的许多其他配置目录非常相似。
- en: A second alternative is to configure *systemd units* for the filesystems. You’ll
    learn more about systemd and its units in Chapter 6. However, the systemd unit
    configuration is often generated from (or based on) the */etc/fstab* file, so
    you may find some overlap on your system.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种替代方案是为文件系统配置*systemd单元*。你将在第六章了解更多关于systemd及其单元的内容。然而，systemd单元配置通常是从（或基于）*/etc/fstab*文件生成的，因此你可能会在系统中发现一些重叠部分。
- en: 4.2.10 Filesystem Capacity
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.10 文件系统容量
- en: To view the size and utilization of your currently mounted filesystems, use
    the `df` command. The output can be very extensive (and it gets longer all the
    time, thanks to specialized filesystems), but it should include information on
    your actual storage devices.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 若要查看当前挂载的文件系统的大小和利用率，请使用`df`命令。输出可能非常庞大（并且随着专用文件系统的增多而越来越长），但应该包含有关实际存储设备的信息。
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here’s a brief description of the fields in the `df` output:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`df`输出字段的简要说明：
- en: '`Filesystem` The filesystem device'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Filesystem` 文件系统设备'
- en: '`1K-blocks` The total capacity of the filesystem in blocks of 1,024 bytes'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`1K-blocks` 文件系统的总容量，以1,024字节为单位的块数'
- en: '`Used` The number of occupied blocks'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Used` 已占用的块数'
- en: '`Available` The number of free blocks'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Available` 剩余的空闲块数'
- en: '`Use%` The percentage of blocks in use'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Use%` 已使用的块的百分比'
- en: '`Mounted on` The mount point'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Mounted on` 挂载点'
- en: It should be easy to see that the two filesystems here are roughly 215GB and
    3GB in size. However, the capacity numbers may look a little strange because 127,989,560
    plus 75,339,204 does not equal 214,234,312, and 127,989,560 is not 63 percent
    of 214,234,312\. In both cases, 5 percent of the total capacity is unaccounted
    for. In fact, the space is there, but it’s hidden in *reserved* blocks. Only the
    superuser can use the reserved blocks of the filesystem when it starts to fill
    up. This feature keeps system servers from immediately failing when they run out
    of disk space.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 应该很容易看出，这两个文件系统的大小分别大约为 215GB 和 3GB。然而，容量数值可能看起来有点奇怪，因为 127,989,560 加 75,339,204
    并不等于 214,234,312，而且 127,989,560 也不是 214,234,312 的 63%。在这两种情况下，总容量的 5% 没有被计算在内。实际上，空间是存在的，但它隐藏在
    *保留* 块中。只有超级用户才能在文件系统开始填满时使用这些保留块。这一功能能防止系统服务器在磁盘空间用尽时立即崩溃。
- en: 4.2.11 Checking and Repairing Filesystems
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.11 检查和修复文件系统
- en: The optimizations that Unix filesystems offer are made possible by a sophisticated
    database mechanism. For filesystems to work seamlessly, the kernel has to trust
    that a mounted filesystem has no errors and also that the hardware stores data
    reliably. If errors exist, data loss and system crashes may result.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 文件系统所提供的优化功能得益于一个复杂的数据库机制。为了让文件系统无缝工作，内核必须信任已挂载的文件系统没有错误，并且硬件能够可靠地存储数据。如果存在错误，可能会导致数据丢失和系统崩溃。
- en: Aside from hardware problems, filesystem errors are usually due to a user shutting
    down the system in a rude way (for example, by pulling out the power cord). In
    such cases, the previous filesystem cache in memory may not match the data on
    the disk, and the system also may be in the process of altering the filesystem
    when you happen to give the computer a kick. Although many filesystems support
    journals to make filesystem corruption far less common, you should always shut
    down the system properly. Regardless of the filesystem in use, filesystem checks
    are still necessary every now and then to make sure that everything is still in
    order.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 除了硬件问题，文件系统错误通常是由于用户粗暴关闭系统（例如拔掉电源线）导致的。在这种情况下，内存中的先前文件系统缓存可能与磁盘上的数据不匹配，且当你给计算机“踢”一脚时，系统可能正在修改文件系统。尽管许多文件系统支持日志功能，从而使文件系统损坏的情况变得不那么常见，但你仍然应该正确关闭系统。无论使用哪种文件系统，定期检查文件系统仍然是必要的，以确保一切正常。
- en: The tool to check a filesystem is `fsck`. As with the `mkfs` program, there’s
    a different version of `fsck` for each filesystem type that Linux supports. For
    example, when run on an Extended filesystem series (ext2/ext3/ext4), `fsck` recognizes
    the filesystem type and starts the `e2fsck` utility. Therefore, you generally
    don’t need to type `e2fsck`, unless `fsck` can’t figure out the filesystem type
    or you’re looking for the `e2fsck` manual page.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 检查文件系统的工具是 `fsck`。与 `mkfs` 程序一样，Linux 支持的每种文件系统类型都有一个不同版本的 `fsck`。例如，当在扩展文件系统系列（ext2/ext3/ext4）上运行时，`fsck`
    会识别文件系统类型并启动 `e2fsck` 工具。因此，通常情况下你不需要输入 `e2fsck`，除非 `fsck` 无法识别文件系统类型，或者你需要查阅
    `e2fsck` 的手册页。
- en: The information presented in this section is specific to the Extended filesystem
    series and `e2fsck`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中提供的信息特定于扩展文件系统系列和 `e2fsck`。
- en: 'To run `fsck` in interactive manual mode, give the device or the mount point
    (as listed in */etc/fstab*) as the argument. For example:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要在交互式手动模式下运行 `fsck`，请将设备或挂载点（如 */etc/fstab* 中列出的）作为参数。例如：
- en: '[PRE25]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In manual mode, `fsck` prints verbose status reports on its passes, which should
    look something like this when there are no problems:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在手动模式下，`fsck` 会打印详细的状态报告，报告的内容在没有问题时应该类似于以下内容：
- en: '[PRE26]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If `fsck` finds a problem in manual mode, it stops and asks a question relevant
    to fixing the problem. These questions deal with the internal structure of the
    filesystem, such as reconnecting loose inodes and clearing blocks (*inodes* are
    building blocks of the filesystem; you’ll see how they work in Section 4.6). When
    `fsck` asks you about reconnecting an inode, it has found a file that doesn’t
    appear to have a name. When reconnecting such a file, `fsck` places the file in
    the *lost+found* directory in the filesystem, with a number as the filename. If
    this happens, you need to guess the name based on the file’s contents; the original
    filename is probably gone.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`fsck`在手动模式下发现问题，它会停止并提出一个与修复该问题相关的问题。这些问题涉及文件系统的内部结构，例如重新连接松散的 inode 和清理块（*inode*是文件系统的构建模块；你将在第4.6节中了解它们的工作原理）。当`fsck`询问你是否要重新连接一个inode时，它已发现一个看起来没有名称的文件。重新连接这样的文件时，`fsck`会将该文件放入文件系统中的*lost+found*目录，并以数字作为文件名。如果发生这种情况，你需要根据文件的内容来猜测文件名；原始文件名可能已经丢失。
- en: In general, it’s pointless to sit through the `fsck` repair process if you’ve
    just uncleanly shut down the system, because `fsck` may have a lot of minor errors
    to fix. Fortunately, `e2fsck` has a `-p` option that automatically fixes ordinary
    problems without asking and aborts when there’s a serious error. In fact, Linux
    distributions run a variant of `fsck -p` at boot time. (You may also see `fsck
    -a`, which does the same thing.)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果你只是非正常关闭了系统，坐等`fsck`修复过程是没有意义的，因为`fsck`可能需要修复很多小问题。幸运的是，`e2fsck`有一个`-p`选项，它会自动修复普通问题而不询问，并在遇到严重错误时中止。事实上，Linux发行版在启动时会运行一个变种的`fsck
    -p`。（你也可能会看到`fsck -a`，它执行相同的操作。）
- en: If you suspect a major disaster on your system, such as a hardware failure or
    device misconfiguration, you need to decide on a course of action, because `fsck`
    can really mess up a filesystem that has larger problems. (One telltale sign that
    your system has a serious problem is if `fsck` asks a *lot* of questions in manual
    mode.)
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你怀疑系统出现了重大故障，比如硬件故障或设备配置错误，你需要决定一个行动方案，因为`fsck`在文件系统出现较大问题时，可能会真的破坏文件系统。（一个明显的信号是，如果`fsck`在手动模式下问了*很多*问题，说明系统可能有严重问题。）
- en: If you think that something really bad has happened, try running `fsck -n` to
    check the filesystem without modifying anything. If there’s a problem with the
    device configuration that you think you can fix (such as loose cables or an incorrect
    number of blocks in the partition table), fix it before running `fsck` for real,
    or you’re likely to lose a lot of data.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为发生了严重问题，尝试运行`fsck -n`检查文件系统而不修改任何内容。如果你认为设备配置有问题（例如松动的电缆或分区表中的块数量不正确），在真正运行`fsck`之前，先修复它，否则你很可能会丢失大量数据。
- en: If you suspect that only the superblock is corrupt (for example, because someone
    wrote to the beginning of the disk partition), you might be able to recover the
    filesystem with one of the superblock backups that `mkfs` creates. Use `fsck -b``num`
    to replace the corrupted superblock with an alternate at block `num` and hope
    for the best.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你怀疑只有超级块损坏（例如，因为某人写入了磁盘分区的开始位置），你可能可以使用`mkfs`创建的超级块备份之一来恢复文件系统。使用`fsck -b`
    `num`将损坏的超级块替换为块`num`处的备用超级块，并希望一切顺利。
- en: If you don’t know where to find a backup superblock, you might be able to run
    `mkfs -n` on the device to view a list of superblock backup numbers without destroying
    your data. (Again, *make sure* that you’re using `-n`, or you’ll *really* tear
    up the filesystem.)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道在哪儿找到备份超级块，你可以在设备上运行`mkfs -n`，查看超级块备份号列表，而不会破坏你的数据。（再次提醒，*确保*你使用的是`-n`，否则你会*真的*破坏文件系统。）
- en: Checking ext3 and ext4 Filesystems
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查ext3和ext4文件系统
- en: 'You normally do not need to check ext3 and ext4 filesystems manually because
    the journal ensures data integrity (recall that the *journal* is a small data
    cache that has not yet been written to a specific spot in the filesystem). If
    you don’t shut your system down cleanly, you can expect the journal to contain
    some data. To flush the journal in an ext3 or ext4 filesystem to the regular filesystem
    database, run `e2fsck` as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不需要手动检查ext3和ext4文件系统，因为日志确保了数据完整性（回想一下，*日志*是一个小的数据缓存，尚未写入文件系统中的特定位置）。如果你没有正常关闭系统，你可以预期日志中会包含一些数据。要将ext3或ext4文件系统中的日志刷新到常规文件系统数据库，运行`e2fsck`，方法如下：
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: However, you may want to mount a broken ext3 or ext4 filesystem in ext2 mode,
    because the kernel won’t mount an ext3 or ext4 filesystem with a nonempty journal.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能想将损坏的ext3或ext4文件系统以ext2模式挂载，因为内核不会挂载带有非空日志的ext3或ext4文件系统。
- en: The Worst Case
  id: totrans-225
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 最坏的情况
- en: 'Disk problems that are more severe leave you with few choices:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 更严重的磁盘问题会让你面临很少的选择：
- en: You can try to extract the entire filesystem image from the disk with `dd` and
    transfer it to a partition on another disk of the same size.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以尝试使用`dd`从磁盘提取整个文件系统镜像，并将其传输到另一个相同大小的磁盘上的分区。
- en: You can try to patch the filesystem as much as possible, mount it in read-only
    mode, and salvage what you can.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以尽量修补文件系统，将其挂载为只读模式，并尽可能恢复数据。
- en: You can try `debugfs`.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以尝试`debugfs`。
- en: In the first two cases, you still need to repair the filesystem before you mount
    it, unless you feel like picking through the raw data by hand. If you like, you
    can choose to answer `y` to all of the `fsck` questions by entering `fsck -y`,
    but do this as a last resort because issues may come up during the repair process
    that you would rather handle manually.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两种情况下，你仍然需要修复文件系统，然后才能挂载它，除非你愿意手动浏览原始数据。如果你愿意，你可以选择对所有`fsck`问题回答`y`，通过输入`fsck
    -y`，但最好作为最后的手段，因为在修复过程中可能会出现你更愿意手动处理的问题。
- en: The `debugfs` tool allows you to look through the files on a filesystem and
    copy them elsewhere. By default, it opens filesystems in read-only mode. If you’re
    recovering data, it’s probably a good idea to keep your files intact to avoid
    messing things up further.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`debugfs`工具允许你浏览文件系统中的文件并将它们复制到其他地方。默认情况下，它以只读模式打开文件系统。如果你正在恢复数据，最好保持文件的完整性，以避免进一步破坏。'
- en: Now, if you’re really desperate—say with a catastrophic disk failure on your
    hands and no backups—there isn’t a lot you can do other than hope a professional
    service can “scrape the platters.”
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你真的绝望——比如在发生灾难性的磁盘故障且没有备份的情况下——你能做的也不多，除了希望专业服务能够“刮取盘片”。
- en: 4.2.12 Special-Purpose Filesystems
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.12 特殊用途文件系统
- en: Not all filesystems represent storage on physical media. Most versions of Unix
    have filesystems that serve as system interfaces. That is, rather than serving
    only as a means to store data on a device, a filesystem can represent system information,
    such as process IDs and kernel diagnostics. This idea goes back to the */dev*
    mechanism, which is an early model of using files for I/O interfaces. The */proc*
    idea came from the eighth edition of research Unix, implemented by Tom J. Killian
    and accelerated when Bell Labs (including many of the original Unix designers)
    created Plan 9—a research operating system that took filesystem abstraction to
    a whole new level ([https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs](https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs)).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的文件系统都代表物理媒体上的存储。大多数Unix版本都有作为系统接口的文件系统。也就是说，文件系统不仅仅是用来存储数据的工具，它还可以代表系统信息，如进程ID和内核诊断信息。这个概念追溯到*/dev*机制，这是早期通过文件作为I/O接口的模型。*/proc*的概念来自于第八版的研究Unix，由Tom
    J. Killian实现，并在贝尔实验室（包括许多原始Unix设计者）创建Plan 9时得到了加速——这是一个将文件系统抽象提升到全新水平的研究操作系统 ([https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs](https://en.wikipedia.org/wiki/Plan_9_from_Bell_Labs))。
- en: 'Some of the special filesystem types in common use on Linux include:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上常见的一些特殊文件系统类型包括：
- en: '`proc` Mounted on */proc*. The name `proc` is an abbreviation for *process*.
    Each *numbered* directory inside */proc* refers to the ID of a current process
    on the system; the files in each directory represent various aspects of that process.
    The directory */proc/self* represents the current process. The Linux `proc` filesystem
    includes a great deal of additional kernel and hardware information in files like
    */proc/cpuinfo*. Keep in mind that the kernel design guidelines recommend moving
    information unrelated to processes out of */proc* and into */sys*, so system information
    in */proc* might not be the most current interface.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`proc`挂载在*/proc*上。`proc`是*进程*的缩写。*/proc*下的每个*编号*目录表示系统上当前进程的ID；每个目录中的文件表示该进程的各种方面。目录*/proc/self*表示当前进程。Linux的`proc`文件系统在像*/proc/cpuinfo*这样的文件中包含了大量额外的内核和硬件信息。请记住，内核设计指南建议将与进程无关的信息从*/proc*移动到*/sys*，因此*/proc*中的系统信息可能不是最当前的接口。'
- en: '`sysfs` Mounted on */sys*. (You saw this in Chapter 3.)'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sysfs`挂载在*/sys*上。（你在第3章已经看过这一点。）'
- en: '`tmpfs` Mounted on */run* and other locations. With `tmpfs`, you can use your
    physical memory and swap space as temporary storage. You can mount `tmpfs` where
    you like, using the `size` and `nr_blocks` long options to control the maximum
    size. However, be careful not to pour things constantly into a `tmpfs` location,
    because your system will eventually run out of memory and programs will start
    to crash.'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`tmpfs`挂载在*/run*和其他位置。使用`tmpfs`，您可以将物理内存和交换空间用作临时存储。您可以根据需要将`tmpfs`挂载到任何位置，并使用`size`和`nr_blocks`长选项控制最大大小。然而，请小心不要不断向`tmpfs`位置写入数据，因为您的系统最终会耗尽内存，程序将开始崩溃。'
- en: '`squashfs` A type of read-only filesystem where content is stored in a compressed
    format and extracted on demand through a loopback device. One example use is in
    the snap package management system that mounts packages under the */snap* directory.'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`squashfs` 一种只读文件系统，其中内容以压缩格式存储，并通过回环设备按需提取。一个典型的应用是snap软件包管理系统，它将软件包挂载到*/snap*目录下。'
- en: '`overlay` A filesystem that merges directories into a composite. Containers
    often use overlay filesystems; you’ll see how they work in Chapter 17.'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`overlay` 一种将目录合并为复合体的文件系统。容器通常使用overlay文件系统；您将在第17章看到它们的工作原理。'
- en: 4.3 Swap Space
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 交换空间
- en: Not every partition on a disk contains a filesystem. It’s also possible to augment
    the RAM on a machine with disk space. If you run out of real memory, the Linux
    virtual memory system can automatically move pieces of memory to and from disk
    storage. This is called *swapping* because pieces of idle programs are swapped
    to the disk in exchange for active pieces residing on the disk. The disk area
    used to store memory pages is called *swap space* (or just *swap*).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 磁盘上的并非每个分区都包含文件系统。也可以使用磁盘空间扩展机器的RAM。如果您的真实内存用尽，Linux虚拟内存系统可以自动将内存的一部分转移到磁盘存储中。这被称为*交换*，因为空闲的程序部分被交换到磁盘上，以换取磁盘上的活动部分。用于存储内存页面的磁盘区域称为*交换空间*（或简称*交换*）。
- en: 'The `free` command’s output includes the current swap usage in kilobytes as
    follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`free`命令的输出包括当前的交换使用情况，单位为千字节，如下所示：'
- en: '[PRE28]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 4.3.1 Using a Disk Partition as Swap Space
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 使用磁盘分区作为交换空间
- en: 'To use an entire disk partition as swap, follow these steps:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用整个磁盘分区作为交换空间，请按照以下步骤操作：
- en: Make sure the partition is empty.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保分区为空。
- en: Run `mkswap` `dev`, where `dev` is the partition’s device. This command puts
    a *swap signature* on the partition, marking it as swap space (rather than a filesystem
    or otherwise).
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`mkswap` `dev`命令，其中`dev`是分区的设备。此命令会在分区上放置一个*交换签名*，将其标记为交换空间（而非文件系统或其他用途）。
- en: Execute `swapon` `dev` to register the space with the kernel.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`swapon` `dev`命令将该空间注册到内核中。
- en: 'After creating a swap partition, you can put a new swap entry in your */etc/fstab*
    file to make the system use the swap space as soon as the machine boots. Here’s
    a sample entry that uses */dev/sda5* as a swap partition:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 创建交换分区后，您可以在*/etc/fstab*文件中添加一个新的交换条目，以便在机器启动时立即使用交换空间。以下是一个示例条目，使用*/dev/sda5*作为交换分区：
- en: '[PRE29]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Swap signatures have UUIDs, so keep in mind that many systems now use these
    instead of raw device names.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 交换签名具有UUID，因此请记住，现在许多系统使用UUID而非原始设备名称。
- en: 4.3.2 Using a File as Swap Space
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 使用文件作为交换空间
- en: You can use a regular file as swap space if you’re in a situation where you
    would be forced to repartition a disk in order to create a swap partition. You
    shouldn’t notice any problems when doing this.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您处于必须重新分区磁盘以创建交换分区的情况，您可以使用普通文件作为交换空间。这样做时，您不应遇到任何问题。
- en: 'Use these commands to create an empty file, initialize it as swap, and add
    it to the swap pool:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个空文件，将其初始化为交换，并将其添加到交换池中：
- en: '[PRE30]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, `swap_file` is the name of the new swap file, and `num_mb` is the desired
    size in megabytes.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`swap_file`是新交换文件的名称，`num_mb`是所需的大小（单位为兆字节）。
- en: To remove a swap partition or file from the kernel’s active pool, use the `swapoff`
    command. Your system must have enough free remaining memory (real and swap combined)
    to accommodate any active pages in the part of the swap pool that you’re removing.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要从内核的活动池中移除交换分区或文件，使用`swapoff`命令。您的系统必须有足够的剩余内存（物理内存和交换空间总和），以容纳您要移除的交换池部分中的任何活动页面。
- en: 4.3.3 Determining How Much Swap You Need
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.3 确定您需要多少交换空间
- en: At one time, Unix conventional wisdom said you should always reserve at least
    twice as much swap space as you have real memory. Today, not only do the enormous
    disk and memory capacities available cloud the issue, but so do the ways we use
    the system. On one hand, disk space is so plentiful, it’s tempting to allocate
    more than double the memory size. On the other hand, you may never even dip into
    your swap space because you have so much real memory.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 曾几何时，Unix的传统观念认为你应该为真实内存至少保留两倍的交换空间。今天，不仅是巨大的磁盘和内存容量让这个问题变得模糊，而且我们使用系统的方式也影响了这一点。一方面，磁盘空间如此充足，以至于人们有时会分配超过两倍内存大小的交换空间；另一方面，可能你永远都不会使用交换空间，因为你拥有如此多的真实内存。
- en: The “double the real memory” rule dated from a time when multiple users would
    be logged in to one machine. Not all of them would be active, though, so it was
    convenient to be able to swap out the memory of the inactive users when an active
    user needed more memory.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: “双倍真实内存”的规则起源于多用户登录同一台机器的时代。当时并非所有用户都在活跃，因此可以方便地将不活跃用户的内存交换出去，以便活跃用户能够使用更多内存。
- en: The same may still hold true for a single-user machine. If you’re running many
    processes, it’s generally fine to swap out parts of inactive processes or even
    inactive pieces of active processes. However, if you frequently access swap space
    because many active processes want to use the memory at once, you’ll suffer serious
    performance problems because disk I/O (even that of SSDs) is just too slow to
    keep up with the rest of the system. The only solutions are to buy more memory,
    terminate some processes, or complain.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单用户机器来说，这种情况可能仍然成立。如果你正在运行许多进程，通常交换掉不活跃进程的部分内容，甚至是活跃进程的某些不活跃部分也是可以的。然而，如果你频繁访问交换空间，因为许多活跃进程希望同时使用内存，那么你将遭遇严重的性能问题，因为磁盘I/O（即使是SSD的I/O）也无法跟上系统的其他部分。唯一的解决办法是购买更多内存、终止一些进程或抱怨。
- en: Sometimes, the Linux kernel may choose to swap out a process in favor of a little
    more disk cache. To prevent this behavior, some administrators configure certain
    systems with no swap space at all. For example, high-performance servers should
    never dip into swap space and should avoid disk access if at all possible.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，Linux内核可能会选择交换出一个进程，以腾出更多磁盘缓存。为了防止这种行为，一些管理员会将某些系统配置为完全不使用交换空间。例如，高性能服务器绝不应该使用交换空间，并应尽量避免磁盘访问。
- en: You’ll learn much more about how the memory system works in Chapter 8.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在第8章中学习更多关于内存系统如何工作的内容。
- en: 4.4 The Logical Volume Manager
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 逻辑卷管理器
- en: So far we’ve looked at direct management and use of disks through partitions,
    specifying the exact locations on storage devices where certain data should reside.
    You know that accessing a block device like */dev/sda1* leads you to a place on
    a particular device according to the partition table on */dev/sda*, even if the
    exact location may be left to the hardware.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过分区直接管理和使用磁盘，指定在存储设备上某些数据应存放的位置。你知道，访问像*/dev/sda1*这样的块设备会根据*/dev/sda*上的分区表将你引导到特定设备的某个位置，即使确切的位置可能由硬件决定。
- en: This usually works fine, but it does have some disadvantages, especially when
    it comes to making changes to your disks *after* installation. For example, if
    you want to upgrade a disk, you must install the new disk, partition, add filesystems,
    possibly do some boot loader changes and other tasks, and finally switch over
    to the new disk. This process can be error-prone and requires several reboots.
    It’s perhaps worse when you want to install an additional disk to get more capacity—here,
    you have to pick a new mount point for the filesystem on that disk and hope that
    you can manually distribute your data between the old and new disks.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通常效果良好，但它也有一些缺点，特别是在安装*之后*对磁盘进行更改时。例如，如果你想升级磁盘，你必须安装新磁盘、分区、添加文件系统、可能还需要做一些引导加载程序的更改以及其他任务，最后切换到新磁盘。这个过程容易出错，并且需要多次重启。当你想安装额外的磁盘以获得更多容量时，情况可能更糟——在这种情况下，你必须为该磁盘上的文件系统选择一个新的挂载点，并希望你能够手动将数据在旧磁盘和新磁盘之间分配。
- en: The LVM deals with these problems by adding another layer between the physical
    block devices and the filesystem. The idea is that you select a set of *physical
    volumes* (usually just block devices, such as disk partitions) to include into
    a *volume group*, which acts as a sort of generic data pool. Then you carve *logical
    volumes* out of the volume group.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: LVM 通过在物理块设备和文件系统之间增加一层来解决这些问题。其思想是，你选择一组 *物理卷*（通常是块设备，如磁盘分区），将它们包含到 *卷组* 中，卷组充当一个类似于通用数据池的角色。然后，你可以从卷组中分割出
    *逻辑卷*。
- en: '[Figure 4-4](#figure4-4) shows a schematic of how these fit together for one
    volume group. This figure shows several physical and logical volumes, but many
    LVM-based systems have only one PV and just two logical volumes (for root and
    swap).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-4](#figure4-4) 显示了这些如何在一个卷组中组合的示意图。该图展示了多个物理卷和逻辑卷，但许多基于 LVM 的系统通常只有一个物理卷和两个逻辑卷（分别用于根和交换分区）。'
- en: '![f04004](image_fi/500402c04/f04004.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![f04004](image_fi/500402c04/f04004.png)'
- en: 'Figure 4-4: How PVs and logical volumes fit together in a volume group'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-4：物理卷和逻辑卷如何在卷组中组合
- en: Logical volumes are just block devices, and they typically contain filesystems
    or swap signatures, so you can think of the relationship between a volume group
    and its logical volumes as similar to that of a disk and its partitions. The critical
    difference is that you don’t normally define how the logical volumes are laid
    out in the volume group—the LVM works all of this out.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑卷仅仅是块设备，通常包含文件系统或交换分区标记，因此你可以将卷组和其逻辑卷之间的关系比作磁盘和其分区之间的关系。关键的不同之处在于，你通常不会定义逻辑卷在卷组中的布局—LVM
    会自动处理这些问题。
- en: 'The LVM allows some powerful and extremely useful operations, such as:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: LVM 允许一些强大且极为有用的操作，例如：
- en: Add more PVs (such as another disk) to a volume group, increasing its size.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向卷组添加更多的物理卷（如另一个磁盘），以增加其大小。
- en: Remove PVs as long as there’s enough space remaining to accommodate existing
    logical volumes inside a volume group.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在卷组中，移除物理卷，只要剩余的空间足以容纳现有的逻辑卷。
- en: Resize logical volumes (and as a consequence, resize filesystems with the `fsadm`
    utility).
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整逻辑卷的大小（因此，也可以通过 `fsadm` 工具调整文件系统的大小）。
- en: You can do all of this without rebooting the machine, and in most cases without
    unmounting any filesystems. Although adding new physical disk hardware can require
    a shutdown, cloud computing environments often allow you to add new block storage
    devices on the fly, making LVM an excellent choice for systems that need this
    kind of flexibility.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在不重启机器的情况下完成所有这些操作，在大多数情况下，也不需要卸载任何文件系统。虽然添加新的物理磁盘硬件可能需要关闭系统，但云计算环境通常允许你动态添加新的块存储设备，这使得
    LVM 成为需要这种灵活性的系统的绝佳选择。
- en: We’re going to explore LVM in a moderate amount of detail. First, we’ll see
    how to interact with and manipulate logical volumes and their components, and
    then we’ll take a closer look at how LVM works and the kernel driver that it’s
    built on. However, the discussion here is not essential to understanding the rest
    of the book, so if you get too bogged down, feel free to skip ahead to Chapter
    5.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将适度详细地探讨 LVM。首先，我们将学习如何与逻辑卷及其组件交互并进行操作，然后我们将更深入地了解 LVM 的工作原理以及它所依赖的内核驱动程序。然而，这里的讨论并不完全必要，理解本书的其余部分，因此如果你觉得内容过于繁琐，可以随时跳到第
    5 章。
- en: 4.4.2 Working with LVM
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 使用 LVM 进行操作
- en: LVM has a number of user-space tools for managing volumes and volume groups.
    Most of these are based around the `lvm` command, an interactive general-purpose
    tool. There are individual commands (which are just symbolic links to LVM) to
    perform specific tasks. For example, the `vgs` command has the same effect as
    typing `vgs` at the `lvm>` prompt of the interactive `lvm` tool, and you’ll find
    that *vgs* (usually in */sbin*) is a symbolic link to *lvm*. We’ll use the individual
    commands in this book.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: LVM 提供了一些用于管理卷和卷组的用户空间工具。大多数工具都基于 `lvm` 命令，这是一个交互式的通用工具。还有一些独立的命令（这些命令实际上是 LVM
    的符号链接）用于执行特定任务。例如，`vgs` 命令的效果与在 `lvm>` 提示符下输入 `vgs` 相同，你会发现 *vgs*（通常位于 */sbin*
    目录）是 *lvm* 的符号链接。在本书中，我们将使用这些独立的命令。
- en: In the next few sections, we’ll look at the components of a system that uses
    logical volumes. The first examples come from a standard Ubuntu installation using
    the LVM partitioning option, so many of the names will contain the word *Ubuntu*.
    However, none of the technical details are specific to that distribution.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将讨论使用逻辑卷的系统组件。第一个示例来自使用LVM分区选项的标准Ubuntu安装，因此许多名称将包含*Ubuntu*一词。然而，所有技术细节与该发行版无关。
- en: Listing and Understanding Volume Groups
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列出和理解卷组
- en: 'The `vgs` command just mentioned shows the volume groups currently configured
    on the system. The output is fairly concise. Here’s what you might see in our
    example LVM installation:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`vgs`命令显示当前在系统上配置的卷组。输出相当简洁。以下是我们示例LVM安装中的输出：'
- en: '[PRE31]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The first line is a header, with each successive line representing a volume
    group. The columns are as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行是标题，每一行表示一个卷组。列内容如下：
- en: '`VG` The volume group name. `ubuntu-vg` is the generic name that the Ubuntu
    installer assigns when configuring a system with LVM.'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VG` 卷组名称。`ubuntu-vg`是Ubuntu安装程序在配置LVM系统时分配的通用名称。'
- en: '`#PV` The number of physical volumes that the volume group’s storage comprises.'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#PV` 卷组存储所包含的物理卷数量。'
- en: '`#LV` The number of logical volumes inside the volume group.'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#LV` 卷组内的逻辑卷数量。'
- en: '`#SN` The number of logical volume *snapshots*. We won’t go into detail about
    these.'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#SN` 逻辑卷*快照*的数量。我们不会详细讲解这些。'
- en: '`Attr` A number of status attributes of the volume group. Here, `w` (writeable),
    `z` (resizable), and `n` (normal allocation policy) are active.'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Attr` 卷组的多个状态属性。这里，`w`（可写）、`z`（可调整大小）和`n`（正常分配策略）是活动状态。'
- en: '`VSize` The volume group size.'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VSize` 卷组的大小。'
- en: '`VFree` The amount of unallocated space on the volume group.'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VFree` 卷组中未分配空间的大小。'
- en: 'This synopsis of a volume group is sufficient for most purposes. If you want
    to go a little deeper into a volume group, use the `vgdisplay` command, which
    is very useful for understanding a volume group’s properties. Here’s the same
    volume group with `vgdisplay`:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个卷组的概述足以满足大多数需求。如果你想更深入地了解卷组，可以使用`vgdisplay`命令，这对于了解卷组的属性非常有用。以下是使用`vgdisplay`查看同一卷组的输出：
- en: '[PRE32]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You saw some of this before, but there are some new items of note:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前见过其中的一些，但也有一些新的项目需要注意：
- en: '`Open LV` The number of logical volumes currently in use.'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Open LV` 当前正在使用的逻辑卷数量。'
- en: '`Cur PV` The number of physical volumes the volume group comprises.'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Cur PV` 卷组包含的物理卷数量。'
- en: '`Act LV` The number of active physical volumes in the volume group.'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Act LV` 卷组中活动物理卷的数量。'
- en: '`VG UUID` The volume group’s universally unique identifier. It’s possible to
    have more than one volume group with the same name on a system; in this case,
    the UUID can help you isolate a particular one. Most LVM tools (such as `vgrename`,
    which can help you resolve a situation like this) accept the UUID as an alternative
    to the volume group name. Be warned that you’re about to see a lot of different
    UUIDs; every component of LVM has one.'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VG UUID` 卷组的全局唯一标识符。系统上可能会有多个同名的卷组；在这种情况下，UUID可以帮助你定位特定的卷组。大多数LVM工具（如`vgrename`，可以帮助你解决这种情况）接受UUID作为卷组名称的替代。请注意，你将看到许多不同的UUID；LVM的每个组件都有一个。'
- en: A *physical extent* (abbreviated as `PE` in the `vgdisplay` output) is a piece
    of a physical volume, much like a block, but on a much larger scale. In this example,
    the PE size is 4MB. You can see that most of the PEs on this volume group are
    in use, but that’s not a cause for alarm. This is merely the amount of space on
    the volume group allocated for the logical partitions (in this case, a filesystem
    and swap space); it doesn’t reflect the actual usage within the filesystem.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '*物理区*（在`vgdisplay`输出中缩写为`PE`）是物理卷的一部分，类似于一个块，但规模要大得多。在这个示例中，PE的大小为4MB。你可以看到，这个卷组中大多数PE都在使用中，但这并不意味着有问题。这仅仅是卷组中分配给逻辑分区（在此案例中为文件系统和交换空间）的空间量；它并不反映文件系统中的实际使用情况。'
- en: Listing Logical Volumes
  id: totrans-301
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列出逻辑卷
- en: 'Similar to volume groups, the commands to list logical volumes are `lvs` for
    a short listing and `lvdisplay` for more detail. Here’s a sample of `lvs`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于卷组，列出逻辑卷的命令是`lvs`（简短列表）和`lvdisplay`（详细列表）。以下是`lvs`的示例：
- en: '[PRE33]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'On basic LVM configurations, only the first four columns are important to understand,
    and the remaining columns may be empty, as is the case here (we won’t cover those).
    The relevant columns here are:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在基础LVM配置中，只有前四列对理解是重要的，其余列可能为空，如这里所示（我们不讨论那些）。这里相关的列是：
- en: '`LV` The logical volume name.'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LV` 逻辑卷名称。'
- en: '`VG` The volume group where the logical volume resides.'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`VG` 逻辑卷所在的卷组。'
- en: '`Attr` Attributes of the logical volume. Here, they are `w` (writeable), `i`
    (inherited allocation policy), `a` (active), and `o` (open). In more advanced
    volume group configurations, more of these slots are active—in particular, the
    first, seventh, and ninth.'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Attr` 逻辑卷的属性。这里它们是`w`（可写）、`i`（继承的分配策略）、`a`（活动）、`o`（打开）。在更高级的卷组配置中，这些槽位中的更多项是激活的，特别是第一、七和第九项。'
- en: '`LSize` The size of the logical volume.'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LSize` 逻辑卷的大小。'
- en: 'Running the more detailed `lvdisplay` helps to shed some light on where a logical
    volume fits into your system. Here’s the output for one of our logical volumes:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 运行更详细的`lvdisplay`有助于揭示逻辑卷在系统中的位置。以下是我们某个逻辑卷的输出：
- en: '[PRE34]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There is a lot of interesting stuff here, and most of it is fairly self-explanatory
    (note that the UUID of the logical volume is different from that of its volume
    group). Perhaps the most important thing you haven’t seen yet is first: `LV Path`,the
    device path of the logical volume. Some systems, but not all, use this as the
    mount point of the filesystem or swap space (in a systemd mount unit or */etc/fstab*).'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多有趣的内容，其中大多数都比较自解释（请注意，逻辑卷的UUID与其卷组的UUID不同）。也许你还没有看到的最重要的内容是：`LV Path`，即逻辑卷的设备路径。一些系统，但不是所有系统，都将其用作文件系统或交换空间的挂载点（在systemd挂载单元或*/etc/fstab*中）。
- en: 'Even though you can see the major and minor device numbers of the logical volume’s
    block device (here, 253 and 0), as well as something that looks like a device
    path, it’s not actually the path that the kernel uses. A quick look at */dev/ubuntu-vg/root*
    reveals that something else is going on:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你可以看到逻辑卷的块设备的主设备号和次设备号（这里是253和0），以及看起来像设备路径的东西，实际上这并不是内核使用的路径。快速查看*/dev/ubuntu-vg/root*会发现其实有其他事情在发生：
- en: '[PRE35]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see, this is just a symbolic link to */dev/dm-0*. Let’s look at that
    briefly.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这只是一个指向*/dev/dm-0*的符号链接。我们来简要看一下。
- en: Using Logical Volume Devices
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用逻辑卷设备
- en: Once LVM has done its setup work on your system, logical volume block devices
    are available at */dev/dm-0*, */dev/dm-1*, and so on, and may be arranged in any
    order. Due to the unpredictability of these device names, LVM also creates symbolic
    links to the devices that have stable names based on the volume group and logical
    volume names. You saw this in the preceding section with */dev/ubuntu-vg/root*.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦LVM在系统中完成设置，逻辑卷块设备就会出现在*/dev/dm-0*、*/dev/dm-1*等位置，并且可以以任何顺序排列。由于这些设备名称的不确定性，LVM还会创建指向设备的符号链接，这些链接基于卷组和逻辑卷名称，具有稳定的名称。你在前一节中已经看到了这个，*/dev/ubuntu-vg/root*。
- en: 'There’s an additional location for symbolic links in most implementations:
    */dev/mapper*. The name format here is also based on the volume group and logical
    volume, but there’s no directory hierarchy; instead, the links have names like
    *ubuntu--vg-root*. Here, udev has transformed the single dash in the volume group
    into a double dash, and then separated the volume group and logical volume names
    with a single dash.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数实现中，还有一个符号链接的额外位置：*/dev/mapper*。这里的名称格式也基于卷组和逻辑卷，但没有目录层级；相反，链接的名称像是*ubuntu--vg-root*。在这里，udev将卷组中的单个破折号转化为双破折号，并用单个破折号将卷组和逻辑卷的名称分开。
- en: Many systems use the links in */dev/mapper* in their */etc/fstab*, systemd,
    and boot loader configurations in order to point the system to the logical volumes
    used for filesystems and swap space.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 许多系统在它们的*/etc/fstab*、systemd和引导加载器配置中使用*/dev/mapper*中的链接，以便将系统指向用于文件系统和交换空间的逻辑卷。
- en: 'In any case, these symbolic links point to block devices for the logical volumes,
    and you can interact with them just as you would any other block device: create
    filesystems, create swap partitions, and so on.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，这些符号链接指向逻辑卷的块设备，你可以像操作其他块设备一样与它们交互：创建文件系统，创建交换分区等等。
- en: Working with Physical Volumes
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用物理卷
- en: 'The final major piece of LVM to examine is the *physical volume (PV)*. A volume
    group is built from one or more PVs. Although a PV may seem like a straightforward
    part of the LVM system, it contains a little more information than meets the eye.
    Much like volume groups and logical volumes, the LVM commands to view PVs are
    `pvs` (for a short list) and `pvdisplay` (for a more in-depth view). Here’s the
    `pvs` display for our example system:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: LVM 中需要检查的最后一个主要部分是 *物理卷（PV）*。卷组是由一个或多个 PV 构建的。虽然 PV 可能看起来是 LVM 系统中的一个简单组成部分，但它包含的信息比眼睛所见的要多。像卷组和逻辑卷一样，查看
    PV 的 LVM 命令是 `pvs`（用于简短列表）和 `pvdisplay`（用于更深入查看）。这是我们示例系统的 `pvs` 显示：
- en: '[PRE36]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And here’s `pvdisplay`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `pvdisplay`：
- en: '[PRE37]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'From the previous discussion of volume groups and logical volumes, you should
    understand most of this output. Here are some notes:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前对卷组和逻辑卷的讨论中，你应该能理解大部分输出内容。这里有一些注释：
- en: There’s no special name for the PV other than the block device. There’s no need
    for one—all of the names required to reference a logical volume are at the volume
    group level and above. However, the PV does have a UUID, which is required to
    compose a volume group.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PV 除了块设备外没有特别的名称。没有必要使用特殊名称——所有引用逻辑卷所需的名称都在卷组层级及其以上。然而，PV 确实有一个 UUID，这是构建卷组所必需的。
- en: In this case, the number of PEs matches the usage in the volume group (which
    we saw earlier), because this is the only PV in the group.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，PE 的数量与卷组中的使用情况匹配（我们之前看到过），因为这是该组中唯一的 PV。
- en: There’s a tiny amount of space that LVM labels as not usable because it’s not
    enough to fill a full PE.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一小部分空间被 LVM 标记为不可用，因为它不足以填充一个完整的 PE。
- en: The `a` in the attributes of the `pvs` output corresponds to `Allocatable` in
    the `pvdisplay` output, and it simply means that if you want to allocate space
    for a logical volume in the volume group, LVM can choose to use this PV. However,
    in this case, there are only nine unallocated PEs (a total of 36MB), so not much
    is available for new logical volumes.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pvs` 输出中的 `a` 对应于 `pvdisplay` 输出中的 `Allocatable`，它仅仅意味着，如果你想在卷组中为逻辑卷分配空间，LVM
    可以选择使用这个 PV。然而，在这种情况下，只有九个未分配的 PEs（总共 36MB），所以没有多少空间可以用于新逻辑卷。'
- en: As alluded to earlier, PVs contain more than just information about their own
    individual contribution to a volume group. Each PV contains *physical volume metadata*,
    extensive information about its volume group and its logical volumes. We’ll explore
    PV metadata shortly, but first let’s get some hands-on experience to see how what
    we’ve learned fits together.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，PV 不仅包含有关其对卷组贡献的个人信息。每个 PV 都包含 *物理卷元数据*，即有关其卷组及其逻辑卷的详细信息。我们稍后将深入探讨 PV
    元数据，但首先让我们通过实际操作，看看我们学到的内容是如何结合在一起的。
- en: Constructing a Logical Volume System
  id: totrans-331
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构建逻辑卷系统
- en: Let’s look at an example of how to create a new volume group and some logical
    volumes out of two disk devices. We’ll combine two disk devices of 5GB and 15GB
    into a volume group and then divide this space into two logical volumes of 10GB
    each—a nearly impossible task without LVM. The example shown here uses VirtualBox
    disks. Although the capacities are quite small on any contemporary system, they
    suffice for illustration.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个如何通过两个磁盘设备创建新的卷组和一些逻辑卷的示例。我们将两个 5GB 和 15GB 的磁盘设备组合成一个卷组，然后将这个空间划分为两个各
    10GB 的逻辑卷——如果没有 LVM，这几乎是不可能完成的任务。这里展示的示例使用了 VirtualBox 磁盘。虽然在当代系统中这些容量相当小，但足以用于演示。
- en: '[Figure 4-5](#figure4-5) shows the volume schematic. The new disks are at */dev/sdb*
    and */dev/sdc*, the new volume group will be called `myvg`, and the two new logical
    volumes are called `mylv1` and `mylv2`.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-5](#figure4-5) 显示了卷的示意图。新磁盘位于 */dev/sdb* 和 */dev/sdc*，新卷组将命名为 `myvg`，两个新的逻辑卷分别命名为
    `mylv1` 和 `mylv2`。'
- en: '![f04005](image_fi/500402c04/f04005.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![f04005](image_fi/500402c04/f04005.png)'
- en: 'Figure 4-5: Constructing a logical volume system'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4-5：构建逻辑卷系统
- en: 'The first task is to create a single partition on each of these disks and label
    it for LVM. Do this with a partitioning program (see Section 4.1.2), using the
    partition type ID `8e`, so that the partition tables look like this:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务是在这些磁盘上创建一个分区，并将其标记为 LVM。使用分区程序（参见第 4.1.2 节）完成此操作，使用分区类型 ID `8e`，这样分区表看起来如下：
- en: '[PRE38]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You don’t necessarily need to partition a disk to make it a PV. PVs can be any
    block device, even entire-disk devices, such as */dev/sdb*. However, partitioning
    enables booting from the disk, and it also provides a means of identifying the
    block devices as LVM physical volumes.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Creating Physical Volumes and a Volume Group
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With the new partitions of */dev/sdb1* and */dev/sdc1* in hand, the first step
    with LVM is to designate one of the partitions as a PV and assign it to a new
    volume group. A single command, `vgcreate`, performs this task. Here’s how to
    create a volume group called `myvg` with */dev/sdb1* as the initial PV:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'At this point, most systems automatically detect the new volume group; run
    a command such as `vgs` to verify (keeping in mind that there may be existing
    volume groups on your system that show up in addition to the one you just created):'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now you can add your second PV at */dev/sdc1* to the volume group with the
    `vgextend` command:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Running `vgs` now shows two PVs, and the size is that of the two partitions
    combined:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Creating Logical Volumes
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The final step at the block device level is to create the logical volumes. As
    mentioned before, we’re going to create two logical volumes of 10GB each, but
    feel free to experiment with other possibilities, such as one big logical volume
    or multiple smaller ones.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: The `lvcreate` command allocates a new logical volume in a volume group. The
    only real complexities in creating simple logical volumes are determining the
    sizes when there is more than one per volume group, and specifying the type of
    logical volume. Remember that PVs are divided into extents; the number of PEs
    available may not *quite* line up with your desired size. However, it should be
    close enough so that it doesn’t present a concern, so if this your first time
    working with the LVM, you don’t really have to pay attention to PEs.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: When using `lvcreate`, you can specify a logical volume’s size by numeric capacity
    in bytes with the `--size` option or by number of PEs with the `--extents` option.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'So, to see how this works, and to complete the LVM schematic in [Figure 4-5](#figure4-5),
    we’ll create logical volumes named `mylv1` and `mylv2` using `--size`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The type here is the linear mapping, the simplest type when you don’t need redundancy
    or any other special features (we won’t work with any other types in this book).
    In this case, `--type linear` is optional because it’s the default mapping.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'After running these commands, verify that the logical volumes exist with an
    `lvs` command, and then take a closer look at the current state of the volume
    group with `vgdisplay`:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice how there are 42 free PEs because the sizes that we chose for the logical
    volumes didn’t quite take up all of the available extents in the volume group.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'Manipulating Logical Volumes: Creating Partitions'
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'With the new logical volumes available, you can now make use of them by putting
    filesystems on the devices and mounting them just like any normal disk partition.
    As mentioned earlier, there will be symbolic links to the devices in */dev/mapper*
    and (for this case) a */dev/myvg* directory for the volume group. So, for example,
    you might run the following three commands to create a filesystem, mount it temporarily,
    and see how much actual space you have on a logical volume:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Removing Logical Volumes
  id: totrans-361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We haven’t yet looked at any operations on the other logical volume, *mylv2*,
    so let’s use it to make this example more interesting. Say you find you’re not
    really using that second logical volume. You decide to remove it and resize the
    first logical volume to take over the remaining space on the volume group. [Figure
    4-6](#figure4-6) shows our goal.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming you’ve already moved or backed up anything important on the logical
    volume you’re going to delete, and that it’s not in current system use (that is,
    you’ve unmounted it), first remove it with `lvremove`. When manipulating logical
    volumes with this command, you’ll refer to them using a different syntax—by separating
    the volume group and logical volume names by a slash (`myvg/mylv2`):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![f04006](image_fi/500402c04/f04006.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-6: Results of reconfiguring logical volumes'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from this interaction, `lvremove` tries to protect you from blunders
    by double-checking that you really want to remove each logical volume targeted
    for removal. It also won’t try to remove a volume that’s in use. But don’t just
    assume that you should reply `y` to any question you’re asked.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Resizing Logical Volumes and Filesystems
  id: totrans-368
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now you can resize the first logical volume, `mylv1`. You can do this even when
    the volume is in use and its filesystem is mounted. However, it’s important to
    understand that there are two steps. To use your larger logical volume, you need
    to resize both it *and* the filesystem inside it (which you can also do while
    it’s mounted). But because this is such a common operation, the `lvresize` command
    that resizes a logical volume has an option (`-r`) to perform the filesystem resizing
    for you also.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: 'For illustration only, let’s use two separate commands to see how this works.
    There are several ways to specify the change in size to a logical volume, but
    in this case, the most straightforward method is to add all of the free PEs in
    the volume group to the logical volume. Recall that you can find that number with
    `vgdisplay`; in our running example, it’s 2,602\. Here’s the `lvresize` command
    to add all of those to `mylv1`:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now you need to resize the filesystem inside. You can do this with the `fsadm`
    command. It’s fun to watch it work in verbose mode (use the `-v` option):'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As you can see from the output, `fsadm` is just a script that knows how to transform
    its arguments into the ones used by filesystem-specific tools like `resize2fs`.
    By default, if you don’t specify a size, it’ll simply resize to fit the entire
    device.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve seen the details of resizing volumes, you’re probably looking
    for shortcuts. The much simpler approach is to use a different syntax for the
    size and have `lvresize` perform the partition resizing for you, with this single
    command:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It’s rather nice that you can expand an ext2/ext3/ext4 filesystem while it’s
    mounted. Unfortunately, it doesn’t work in reverse. You *cannot* shrink a filesystem
    when it’s mounted. Not only must you unmount the filesystem, but the process of
    shrinking a logical volume requires you to do the steps in reverse. So, when resizing
    manually, you’d need to resize the partition before the logical volume, making
    sure that the new logical volume is still big enough to contain the filesystem.
    Again, it’s *much* easier to use `lvresize` with the `-r` option so that it can
    coordinate the filesystem and logical volume sizes for you.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 4.4.3 The LVM Implementation
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the more practical operational basics of LVM covered, we can now take a
    brief look at its implementation. As with almost every other topic in this book,
    LVM contains a number of layers and components, with a fairly careful separation
    between the parts in kernel and user space.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll see soon, finding PVs to discover the structure of the volume groups
    and logical volumes is somewhat complicated, and the Linux kernel would rather
    not deal with any of it. There’s no reason for any of this to happen in kernel
    space; PVs are just block devices, and user space has random access to block devices.
    In fact, LVM (more specifically, LVM2 in current systems) itself is just the name
    for a suite of user-space utilities that know the LVM structure.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the kernel handles the work of routing a request for a location
    on a logical volume’s block device to the true location on an actual device. The
    driver for this is the *device mapper* (sometimes shortened to *devmapper*), a
    new layer sandwiched between normal block devices and the filesystem. As the name
    suggests, the task the device mapper performs is like following a map; you can
    almost think of it as translating a street address into an absolute location like
    global latitude/longitude coordinates. (It’s a form of virtualization; the virtual
    memory we’ll see elsewhere in the book works on a similar concept.)
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s some glue between LVM user-space tools and the device mapper: a few
    utilities that run in user space to manage the device map in the kernel. Let’s
    look at both the LVM side and the kernel side, starting with LVM.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: LVM Utilities and Scanning for Physical Volumes
  id: totrans-383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Before it does anything, an LVM utility must first scan the available block
    devices to look for PVs. The steps that LVM must perform in user space are roughly
    as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Find all of the PVs on the system.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find all of the volume groups that the PVs belong to by UUID (this information
    is contained in the PVs).
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that everything is complete (that is, all necessary PVs that belong to
    the volume group are present).
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find all of the logical volumes in the volume groups.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure out the scheme for mapping data from the PVs to the logical volumes.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There’s a header at the beginning of every PV that identifies the volume as
    well as its volume groups and the logical volumes within. The LVM utilities can
    put this information together and determine whether all PVs necessary for a volume
    group (and its logical volumes) are present. If everything checks out, LVM can
    work on getting the information to the kernel.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Any LVM utility, such as `pvscan`, `lvs`, or `vgcreate`, is capable of performing
    the work of scanning and processing PVs.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: The Device Mapper
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: After LVM has determined the structure of the logical volumes from all of the
    headers on the PVs, it communicates with the kernel’s device mapper driver in
    order to initialize the block devices for the logical volumes and load their mapping
    tables. It achieves this with the ioctl(2) system call (a commonly used kernel
    interface) on the */dev/mapper/control* device file. It’s not really practical
    to try to monitor this interaction, but it’s possible to look at the details of
    the results with the `dmsetup` command.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: 'To get an inventory of mapped devices currently serviced by the device mapper,
    use `dmsetup info`. Here’s what you might get for one of the logical volumes created
    earlier in this chapter:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The major and minor number of the device correspond to the */dev/dm-** device
    file for the mapped device; the major number for this device mapper is 253\. Because
    the minor number is 1, the device file is named */dev/dm-1*. Notice that the kernel
    has a name and yet another UUID for the mapped device. LVM supplied these to the
    kernel (the kernel UUID is just a concatenation of the volume group and logical
    volume UUIDs).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also view the table that LVM gave to the device mapper, by issuing
    the command `dmsetup table`. Here’s what that looks like for our earlier example
    when there were two 10GB logical volumes (`mylv1` and `mylv2`) spread across the
    two physical volumes of 5GB (*/dev/sdb1*) and 15GB (*/dev/sdc1*):'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Each line provides a segment of the map for a given mapped device. For the
    device `myvg-mylv2`, there are two pieces, and for `myvg-mylv1`, there’s a single
    one. The fields after the name, in order, are:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: The start offset of the mapped device. The units are in 512-byte “sectors,”
    or the normal block size that you see in many other devices.
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The length of this segment.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The mapping scheme. Here, it’s the simple one-to-one linear scheme.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The major and minor device number pair of a source device—that is, what LVM
    calls physical volumes. Here 8:17 is */dev/sdb1* and 8:33 is */dev/sdc1*.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A starting offset on the source device.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What’s interesting here is that in our example, LVM chose to use the space in
    */dev/sdc1* for the first logical volume that we created (`mylv1`). LVM decided
    that it wanted to lay out the first 10GB logical volume in a contiguous manner,
    and the only way to do that was on */dev/sdc1*. However, when creating the second
    logical volume (`mylv2`), LVM had no choice but to spread it into two segments
    across the two PVs. [Figure 4-7](#figure4-7) shows the arrangement.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '![f04007_new](image_fi/500402c04/f04007_new.png)'
  id: totrans-406
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-7: How LVM arranges `mylv1` and `mylv2`'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'As a further consequence, when we removed `mylv2` and expanded `mylv1` to fit
    the remaining space in the volume group, the original start offset in the PV remained
    where it was on */dev/sdc1*, but everything else changed to include the remainder
    of the PVs:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[Figure 4-8](#figure4-8) shows the arrangement.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '![f04008](image_fi/500402c04/f04008.png)'
  id: totrans-411
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-8: The arrangement after we remove `mylv2` and expand `mylv1`'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: You can experiment with logical volumes and the device mapper to your heart’s
    content with virtual machines and see how the mappings turn out. Many features,
    such as software RAID and encrypted disks, are built on the device mapper.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '4.5 Looking Forward: Disks and User Space'
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In disk-related components on a Unix system, the boundaries between user space
    and the kernel can be difficult to characterize. As you’ve seen, the kernel handles
    raw block I/O from the devices, and user-space tools can use the block I/O through
    device files. However, user space typically uses the block I/O only for initializing
    operations, such as partitioning, filesystem creation, and swap space creation.
    In normal use, user space uses only the filesystem support that the kernel provides
    on top of the block I/O. Similarly, the kernel also handles most of the tedious
    details when dealing with swap space in the virtual memory system.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of this chapter briefly looks at the innards of a Linux filesystem.
    This is more advanced material, and you certainly don’t need to know it to proceed
    with the book. If this is your first time through, skip to the next chapter and
    start learning about how Linux boots.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 4.6 Inside a Traditional Filesystem
  id: totrans-417
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A traditional Unix filesystem has two primary components: a pool of data blocks
    where you can store data and a database system that manages the data pool. The
    database is centered around the inode data structure. An *inode* is a set of data
    that describes a particular file, including its type, permissions, and—perhaps
    most important—where in the data pool the file data resides. Inodes are identified
    by numbers listed in an inode table.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: Filenames and directories are also implemented as inodes. A directory inode
    contains a list of filenames and links corresponding to other inodes.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide a real-life example, I created a new filesystem, mounted it, and
    changed the directory to the mount point. Then, I added some files and directories
    with these commands:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that I created *dir_2/file_5* as a hard link to *dir_1/file_3*, meaning
    that these two filenames actually represent the same file (more on this shortly).
    Feel free to try this yourself. It doesn’t necessarily need to be on a new filesystem.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: If you were to explore the directories in this filesystem, its contents would
    appear as shown in [Figure 4-9](#figure4-9).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '![f04009](image_fi/500402c04/f04009.png)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-9: User-level representation of a filesystem'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: The actual layout of the filesystem as a set of inodes, shown in [Figure 4-10](#figure4-10),
    doesn’t look nearly as clean as the user-level representation.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '![f04010](image_fi/500402c04/f04010.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4-10: Inode structure of the filesystem shown in [Figure 4-9](#figure4-9)'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we make sense of this? For any ext2/3/4 filesystem, you start at inode
    number 2, which is the *root inode* (try not to confuse this with the system root
    filesystem). From the inode table in [Figure 4-10](#figure4-10), you can see that
    this is a directory inode (*dir*), so you can follow the arrow over to the data
    pool, where you see the contents of the root directory: two entries named *dir_1*
    and *dir_2* corresponding to inodes 12 and 7633, respectively. To explore those
    entries, go back to the inode table and look at either of those inodes.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'To examine *dir_1/file_2* in this filesystem, the kernel does the following:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: 'Determines the path’s components: a directory named *dir_1*, followed by a
    component named *file_2*.'
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follows the root inode to its directory data.
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finds the name *dir_1* in inode 2’s directory data, which points to inode number
    12.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Looks up inode 12 in the inode table and verifies that it is a directory inode.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follows inode 12’s data link to its directory information (the second box down
    in the data pool).
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locates the second component of the path (*file_2*) in inode 12’s directory
    data. This entry points to inode number 14.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Looks up inode 14 in the directory table. This is a file inode.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, the kernel knows the properties of the file and can open it by
    following inode 14’s data link.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: This system, of inodes pointing to directory data structures and directory data
    structures pointing to inodes, allows you to create the filesystem hierarchy that
    you’re used to. In addition, notice that the directory inodes contain entries
    for *.* (the current directory) and *..* (the parent directory, except for the
    root directory). This makes it easy to get a point of reference and to navigate
    back down the directory structure.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.1 Inode Details and the Link Count
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To view the inode numbers for any directory, use the `ls -i` command. Here’s
    what you’d get at the root of this example (for more detailed inode information,
    use the `stat` command):'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You’re probably wondering about the *link count* in the inode table. You’ve
    already seen the link count in the output of the common `ls -l` command, but you
    likely ignored it. How does the link count relate to the files in [Figure 4-9](#figure4-9),
    in particular the “hard-linked” *file_5*? The link count field is the number of
    total directory entries (across all directories) that point to an inode. Most
    of the files have a link count of 1 because they occur only once in the directory
    entries. This is expected. Most of the time when you create a file, you create
    a new directory entry and a new inode to go with it. However, inode 15 occurs
    twice. First it’s created as *dir_1/file_3*, and then it’s linked to as *dir_2/file_5*.
    A hard link is just a manually created entry in a directory to an inode that already
    exists. The `ln` command (without the `-s` option) allows you to create new hard
    links manually.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: This is also why removing a file is sometimes called *unlinking*. If you run
    `rm dir_1/file_2`, the kernel searches for an entry named *file_2* in inode 12’s
    directory entries. Upon finding that *file_2* corresponds to inode 14, the kernel
    removes the directory entry and then subtracts 1 from inode 14’s link count. As
    a result, inode 14’s link count will be 0, and the kernel will know that there
    are no longer any names linking to the inode. Therefore, it can now delete the
    inode and any data associated with it.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: However, if you run `rm dir_1/file_3`, the end result is that the link count
    of inode 15 goes from 2 to 1 (because *dir_2/file_5* still points there), and
    the kernel knows not to remove the inode.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'Link counts work much the same for directories. Note that inode 12’s link count
    is 2, because there are two inode links there: one for *dir_1* in the directory
    entries for inode 2 and the second a self-reference (`.`) in its own directory
    entries. If you create a new directory *dir_1/dir_3*, the link count for inode
    12 would go to 3 because the new directory would include a parent (`..`) entry
    that links back to inode 12, much as inode 12’s parent link points to inode 2.'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: There is one small exception in link counts. The root inode 2 has a link count
    of 4\. However, [Figure 4-10](#figure4-10) shows only three directory entry links.
    The “fourth” link is in the filesystem’s superblock because the superblock tells
    you where to find the root inode.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Don’t be afraid to experiment on your system. Creating a directory structure
    and then using `ls -i` or `stat` to walk through the pieces is harmless. You don’t
    need to be root (unless you mount and create a new filesystem).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.2 Block Allocation
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s still one piece missing from our discussion. When allocating data pool
    blocks for a new file, how does the filesystem know which blocks are in use and
    which are available? One of the most basic ways is to use an additional management
    data structure called a *block bitmap*. In this scheme, the filesystem reserves
    a series of bytes, with each bit corresponding to one block in the data pool.
    A value of 0 means that the block is free, and a 1 means that it’s in use. Thus,
    allocating and deallocating blocks is a matter of flipping bits.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Problems in a filesystem arise when the inode table data doesn’t match the block
    allocation data or when the link counts are incorrect; for example, this can happen
    when you don’t cleanly shut down a system. Therefore, when you check a filesystem,
    as described in Section 4.2.11, the `fsck` program walks through the inode table
    and directory structure to generate new link counts and a new block allocation
    map (such as the block bitmap), and then it compares the newly generated data
    with the filesystem on the disk. If there are mismatches, `fsck` must fix the
    link counts and determine what to do with any inodes and/or data that didn’t come
    up when it traversed the directory structure. Most `fsck` programs make these
    “orphans” new files in the filesystem’s *lost+found* directory.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: 4.6.3 Working with Filesystems in User Space
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working with files and directories in user space, you shouldn’t have to
    worry much about the implementation going on below them. Processes are expected
    to access the contents of files and directories of a mounted filesystem through
    kernel system calls. Curiously, though, you do have access to certain filesystem
    information that doesn’t seem to fit in user space—in particular, the `stat()`
    system call returns inode numbers and link counts.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: When you’re not maintaining a filesystem, do you have to worry about inode numbers,
    link counts, and other implementation details? Generally, no. This stuff is accessible
    to user-mode programs primarily for backward compatibility. Furthermore, not all
    filesystems available in Linux have these filesystem internals. The VFS interface
    layer ensures that system calls always return inode numbers and link counts, but
    those numbers may not necessarily mean anything.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: You may not be able to perform traditional Unix filesystem operations on nontraditional
    filesystems. For example, you can’t use `ln` to create a hard link on a mounted
    VFAT filesystem because its directory entry structure, designed for Windows rather
    than Unix/Linux, does not support that concept.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the system calls available to user space on Linux systems provide
    enough abstraction for painless file access—you don’t need to know anything about
    the underlying implementation in order to access files. In addition, filenames
    are flexible in format and mixed-case names are supported, making it easy to support
    other hierarchical-style filesystems.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: Remember, specific filesystem support does not necessarily need to be in the
    kernel. For example, in user-space filesystems, the kernel only needs to act as
    a conduit for system calls.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
