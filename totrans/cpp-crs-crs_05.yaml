- en: '**3'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**3'
- en: REFERENCE TYPES**
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型**
- en: '*Everyone knows that debugging is twice as hard as writing a program in the
    first place. So if you’re as clever as you can be when you write it, how will
    you ever debug it?'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*每个人都知道，调试比写程序要难两倍。那么，如果你在编写程序时已经尽可能聪明，那你怎么可能调试它呢？*'
- en: —Brian Kernighan*
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: —布赖恩·肯尼汉*
- en: '![Image](../images/common.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![Image](../images/common.jpg)'
- en: '*Reference types* store the memory addresses of objects. These types enable
    efficient programming, and many elegant design patterns feature them. In this
    chapter, I’ll discuss the two kinds of reference types: pointers and references.
    I’ll also discuss `this`, `const`, and `auto` along the way.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*引用类型*存储对象的内存地址。这些类型使得高效编程成为可能，许多优雅的设计模式也包含它们。在本章中，我将讨论两种引用类型：指针和引用。我还会讨论`this`、`const`和`auto`。'
- en: '**Pointers**'
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**指针**'
- en: '*Pointers* are the fundamental mechanism used to refer to memory addresses.
    Pointers encode both pieces of information required to interact with another object—that
    is, the object’s address and the object’s type.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*指针*是用来引用内存地址的基本机制。指针编码了与另一个对象交互所需的两部分信息——即对象的地址和对象的类型。'
- en: 'You can declare a pointer’s type by appending an asterisk (`*`) to the pointed-to
    type. For example, you declare a pointer to `int` called `my_ptr` as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在指向类型后面加一个星号（`*`）来声明一个指针的类型。例如，你可以如下声明一个指向`int`的指针`my_ptr`：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The format specifier for a pointer is `%p`. For example, to print the value
    in `my_ptr`, you could use the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 指针的格式说明符是`%p`。例如，要打印`my_ptr`中的值，你可以使用如下代码：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Pointers are very low-level objects. Although they play a central role in most
    C programs, C++ offers higher-level, sometimes more efficient, constructs that
    obviate the need to deal with memory addresses directly. Nonetheless, pointers
    are a foundational concept that you’ll no doubt come across in your system-programming
    travels.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 指针是非常低级的对象。尽管它们在大多数C程序中扮演着核心角色，但C++提供了更高级的构造， 有时更高效，可以避免直接处理内存地址的需要。尽管如此，指针仍然是一个基础概念，你无疑会在系统编程中遇到它。
- en: 'In this section, you’ll learn how to find the address of an object and how
    to assign the result to a pointer variable. You’ll also learn how to perform the
    opposite operation, which is called *dereferencing*: given a pointer, you can
    obtain the object residing at the corresponding address.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何找到一个对象的地址，并将结果赋值给一个指针变量。你还将学习如何执行相反的操作，这称为*解引用*：给定一个指针，你可以获取位于相应地址的对象。
- en: You’ll learn more about *arrays*, the simplest construct for managing an object
    collection, as well as how arrays relate to pointers. As low-level constructs,
    arrays and pointers are relatively dangerous. You’ll learn about what can go wrong
    when pointer- and array-based programs go awry.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你将进一步了解*数组*，这是管理对象集合的最简单构造，以及数组如何与指针相关联。作为低级构造，数组和指针相对危险。你将了解指针和数组相关程序出错时可能会发生的情况。
- en: 'This chapter introduces two special kinds of pointers: `void` pointers and
    `std::byte` pointers. These very useful types have some special behaviors that
    you’ll need to keep in mind. Additionally, you’ll learn how to encode empty pointers
    with `nullptr` and how to use pointers in Boolean expressions to determine whether
    they’re empty.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了两种特殊类型的指针：`void`指针和`std::byte`指针。这些非常有用的类型具有一些特殊的行为，您需要记住这些行为。此外，您还将学习如何使用`nullptr`编码空指针，并学习如何在布尔表达式中使用指针来判断它们是否为空。
- en: '***Addressing Variables***'
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***变量地址***'
- en: You can obtain the address of a variable by prepending the *address-of operator*
    (`&`). You might want to use this operator to initialize a pointer so it “points
    to” the corresponding variable. Such programming requirements arise very often
    in operating systems programming. For example, major operating systems, such as
    Windows, Linux, and FreeBSD, have interfaces that use pointers heavily.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在变量前加上*取地址操作符*（`&`）来获取变量的地址。你可能想用这个操作符来初始化一个指针，使其“指向”相应的变量。这样的编程需求在操作系统编程中非常常见。例如，主要的操作系统，如Windows、Linux和FreeBSD，都有大量使用指针的接口。
- en: '[Listing 3-1](ch03.xhtml#ch03ex01) demonstrates how to obtain the address of
    an `int`.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-1](ch03.xhtml#ch03ex01)演示了如何获取一个`int`的地址。'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '*Listing 3-1: A program featuring the address-of operator `&` and a terrible
    pun*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-1：一个包含取地址操作符`&`和一个糟糕双关语的程序*'
- en: First, you declare the integer `gettysburg` ➊ and print its value ➋. Then you
    declare a pointer, called `gettysburg_address`, to that integer’s address ➌; notice
    that the asterisk prepends the pointer and the ampersand prepends `gettysburg`.
    Finally, you print the pointer to the screen ➍ to reveal the `gettysburg` integer’s
    address.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你声明整数`gettysburg` ➊并打印其值 ➋。然后你声明一个指针，名为`gettysburg_address`，指向该整数的地址 ➌；注意，星号（`*`）出现在指针前面，而&符号出现在`gettysburg`前面。最后，你打印指针到屏幕上
    ➍，以显示`gettysburg`整数的地址。
- en: 'If you run [Listing 3-1](ch03.xhtml#ch03ex01) on Windows 10 (x86), you should
    see the following output:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Windows 10（x86）上运行[示例 3-1](ch03.xhtml#ch03ex01)，你应该看到以下输出：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Running the same code on Windows 10 x64 yields the following output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows 10 x64上运行相同的代码会产生以下输出：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Your output should have an identical value for `gettysburg`, but `gettysburg_address`
    should be different each time. This variation is due to *address space layout
    randomization*, which is a security feature that scrambles the base address of
    important memory regions to hamper exploitation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你的输出应当在`gettysburg`上具有相同的值，但`gettysburg_address`每次应有所不同。这种变化是由于*地址空间布局随机化*，这是一种安全特性，旨在通过打乱重要内存区域的基础地址来防止攻击者利用漏洞。
- en: '**Address Space Layout Randomization**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**地址空间布局随机化**'
- en: Why does address space layout randomization hamper exploitation? When a hacker
    finds an exploitable condition in a program, they can sometimes cram a malicious
    payload into user-provided input. One of the first security features designed
    to prevent a hacker from getting this malicious payload to execute is to make
    all data sections non-executable. If the computer attempts to execute data as
    code, then the theory is that it knows something’s amiss and should terminate
    the program with an exception.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么地址空间布局随机化能有效阻止攻击？当黑客在程序中发现可利用的漏洞时，他们有时会将恶意负载塞入用户提供的输入中。为了防止黑客让恶意负载执行，设计的第一个安全特性是将所有数据区域设置为不可执行。如果计算机试图将数据作为代码执行，那么理论上它会发现异常并通过异常终止程序。
- en: Some exceedingly clever hackers figured out how to repurpose executable code
    instructions in totally unforeseen ways by carefully crafting exploits containing
    so-called *return-oriented programs*. These exploits could arrange to invoke the
    relevant system APIs to mark their payload executable, hence defeating the non-executable-memory
    mitigation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一些极为聪明的黑客通过精心设计包含所谓的*返回导向程序*的漏洞，找到了以完全出乎意料的方式重新利用可执行代码指令的方法。这些漏洞可以安排调用相关的系统API，使它们的负载能够被标记为可执行，从而突破非可执行内存的防护措施。
- en: Address space layout randomization combats return-oriented programming by randomizing
    memory addresses, making it difficult to repurpose existing code because the attacker
    doesn’t know where it resides in memory.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 地址空间布局随机化通过随机化内存地址来对抗返回导向编程，使得攻击者难以重新利用现有代码，因为他们不知道代码在内存中的具体位置。
- en: Also note that in the outputs for [Listing 3-1](ch03.xhtml#ch03ex01), `gettysburg_address`
    contains 8 hexadecimal digits (4 bytes) for an x86 architecture and 16 hexadecimal
    digits (8 bytes) for an x64 architecture. This should make some sense because
    on modern desktop systems, the pointer size is the same as the CPU’s general-purpose
    register. An x86 architecture has 32-bit (4-byte) general-purpose registers, whereas
    an x64 architecture has 64-bit (8-byte) general-purpose registers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另外请注意，在[示例 3-1](ch03.xhtml#ch03ex01)的输出中，`gettysburg_address`在x86架构下包含8个十六进制数字（4字节），而在x64架构下包含16个十六进制数字（8字节）。这应该是有道理的，因为在现代桌面系统上，指针的大小与CPU的通用寄存器相同。x86架构具有32位（4字节）的通用寄存器，而x64架构具有64位（8字节）的通用寄存器。
- en: '***Dereferencing Pointers***'
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***解引用指针***'
- en: The *dereference operator* (`*`) is a unary operator that accesses the object
    to which a pointer refers. This is the inverse operation of the address-of operator.
    Given an address, you can obtain the object residing there. Like the address-of
    operator, system programmers use the dereference operator very often. Many operating
    system APIs will return pointers, and if you want to access the referred-to object,
    you’ll use the dereference operator.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*解引用操作符*（`*`）是一个一元操作符，用于访问指针所指向的对象。这是地址操作符的逆操作。给定一个地址，你可以获得驻留在该地址的对象。像地址操作符一样，系统程序员常常使用解引用操作符。许多操作系统API会返回指针，如果你想访问指针所指向的对象，你就需要使用解引用操作符。'
- en: 'Unfortunately, the dereference operator can cause a lot of notation-based confusion
    for beginners because the dereference operator, the pointer declaration, and multiplication
    all use asterisks. Remember that you append an asterisk to the end of the pointed-to
    object’s type to declare a pointer; however, you prepend the dereference operator—an
    asterisk—to the pointer, like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，解引用运算符可能会给初学者带来很多符号上的困惑，因为解引用运算符、指针声明和乘法都使用星号。请记住，你在声明指针时，应该在指向对象的类型后加上星号；但是，你在指针前加上解引用运算符——一个星号——像这样：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After accessing an object by prepending the dereference operator to a pointer,
    you can treat the result like any other object of the pointed-to type. For example,
    because `gettysburg` is an integer, you can write the value 17325 into `gettysburg`
    using `gettysburg_address`. The correct syntax is as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过在指针前加解引用运算符来访问一个对象后，你可以像对待任何其他指向类型的对象一样对待该结果。例如，因为`gettysburg`是一个整数，你可以使用`gettysburg_address`将值17325写入`gettysburg`。正确的语法如下：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Because the dereferenced pointer—that is, `*gettysburg_address`—appears on the
    left side of the equal sign, you’re writing to the address where `gettysburg`
    is stored.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因为解引用指针——也就是`*gettysburg_address`——出现在等号的左侧，所以你正在向存储`gettysburg`的地址写入数据。
- en: 'If a dereferenced pointer appears anywhere except the left side of an equal
    sign, you’re reading from the address. To retrieve the `int` pointed to by `gettysburg_address`,
    you just tack on the dereference operator. For instance, the following statement
    will print the value stored in `gettysburg`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果解引用指针出现在等号的右侧或其他地方，你就是在从该地址读取数据。要获取`gettysburg_address`指向的`int`，只需加上解引用运算符。例如，以下语句将打印`gettysburg`中存储的值：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Listing 3-2](ch03.xhtml#ch03ex02) uses the dereference operator to read and
    write.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-2](ch03.xhtml#ch03ex02) 使用解引用运算符进行读写操作。'
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*Listing 3-2: An example program illustrating reads and writes using a pointer
    (output is from a Windows 10 x64 machine)*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-2：一个使用指针进行读写操作的示例程序（输出来自Windows 10 x64机器）*'
- en: First, you initialize `gettysburg` to zero. Then, you initialize the pointer
    `gettysburg_address` to the address of `gettysburg` ➊. Next, you print the `int`
    pointed to by `gettysburg_address` ➋ and the value of `gettysburg_address` itself
    ➌.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将`gettysburg`初始化为零。然后，你将指针`gettysburg_address`初始化为`gettysburg`的地址 ➊。接着，你打印`gettysburg_address`指向的`int`
    ➋以及`gettysburg_address`本身的值 ➌。
- en: You write the value 17325 into the memory pointed to by `gettysburg_address`
    ➍ and then print the pointed-to value ➎ and address ➏ again.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你将值17325写入`gettysburg_address`指向的内存 ➍，然后再次打印该指针指向的值 ➎ 和地址 ➏。
- en: '[Listing 3-2](ch03.xhtml#ch03ex02) would be functionally identical if you assigned
    the value 17325 directly to `gettysburg` instead of to the `gettysburg_address`
    pointer, like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你直接将值17325赋给`gettysburg`而不是`gettysburg_address`指针，像这样，[清单 3-2](ch03.xhtml#ch03ex02)在功能上是完全相同的：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This example illustrates the close relationship between a pointed-to object
    (`gettysburg`) and a dereferenced pointer to that object (`*gettysburg_address)`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例说明了指向对象（`gettysburg`）与指向该对象的解引用指针（`*gettysburg_address`）之间的密切关系。
- en: '***The Member-of-Pointer Operator***'
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***成员指针运算符***'
- en: 'The *member-of-pointer operator*, or *arrow operator* (`->`), performs two
    simultaneous operations:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*成员指针运算符*，或称为*箭头运算符*（`->`），执行两个同时的操作：'
- en: It dereferences a pointer.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它解引用一个指针。
- en: It accesses a member of the pointed-to object.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它访问指向对象的成员。
- en: You can use this operator to reduce *notational friction*, the resistance a
    programmer feels in expressing their intent in code, when you’re handling pointers
    to classes. You’ll need to handle pointers to classes in a variety of design patterns.
    For example, you might want to pass a pointer to a class as a function parameter.
    If the receiving function needs to interact with a member of that class, the member-of-pointer
    operator is the tool for the job.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个运算符来减少*符号摩擦*，也就是程序员在编写代码时表达意图时遇到的阻力，尤其是在处理指向类的指针时。你将在各种设计模式中处理指向类的指针。例如，你可能需要将指向类的指针作为函数参数传递。如果接收函数需要与该类的成员进行交互，成员指针运算符就是完成该任务的工具。
- en: '[Listing 3-3](ch03.xhtml#ch03ex03) employs the arrow operator to read the `year`
    from a `ClockOfTheLongNow` object (which you implemented in [Listing 2-22](ch02.xhtml#ch02ex22)
    on [page 58](ch02.xhtml#page_58)).'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-3](ch03.xhtml#ch03ex03) 使用箭头运算符从`ClockOfTheLongNow`对象中读取`year`（该对象在[清单
    2-22](ch02.xhtml#ch02ex22)中实现，位于[第58页](ch02.xhtml#page_58)）。'
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 3-3: Using a pointer and the arrow operator to manipulate the `ClockOfTheLongNow`
    object (output is from a Windows 10 x64 machine)*'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-3：使用指针和箭头操作符操作`ClockOfTheLongNow`对象（输出来自一台Windows 10 x64机器）*'
- en: You declare a `clock` and then store its address in `clock_ptr` ➊. Next, you
    use the arrow operator to set the `year` member of `clock` to 2020 ➋. Finally,
    you print the address of `clock` ➌ and the value of `year` ➍.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你声明一个`clock`，然后将其地址存储在`clock_ptr`中➊。接着，你使用箭头操作符将`clock`的`year`成员设置为2020➋。最后，你打印`clock`的地址➌以及`year`的值➍。
- en: 'You could achieve an identical result using the dereference (`*`) and member
    of (`.`) operators. For example, you could have written the last line of [Listing
    3-3](ch03.xhtml#ch03ex03) as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用解引用（`*`）和成员访问（`.`）操作符来实现相同的结果。例如，你可以将[列表 3-3](ch03.xhtml#ch03ex03)的最后一行写成如下：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First, you dereference `clock_ptr`, and then you access the `year`. Although
    this is equivalent to invoking the pointer-to-member operator, it’s a more verbose
    syntax and provides no benefit over its simpler alternative.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你解引用`clock_ptr`，然后访问`year`。虽然这与调用指向成员的操作符等效，但它是一种冗长的语法，并且没有比更简单的替代方式带来额外的好处。
- en: '**NOTE**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*For now, use parentheses to emphasize the order of operations. [Chapter 7](ch07.xhtml#ch07)
    walks through the precedents rules for operators.*'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*现在，使用括号来强调运算顺序。[第七章](ch07.xhtml#ch07)会详细讲解操作符的优先级规则。*'
- en: '***Pointers and Arrays***'
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***指针与数组***'
- en: Pointers share several characteristics with arrays. Pointers encode object location.
    Arrays encode the location and length of contiguous objects.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 指针与数组有几个相似之处。指针表示对象的位置，而数组则表示连续对象的起始位置和长度。
- en: 'At the slightest provocation, an array will *decay* into a pointer. A decayed
    array loses length information and converts to a pointer to the array’s first
    element. For example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 只要有一点触发，数组就会*退化*为指针。退化后的数组会失去长度信息，并转换为指向数组第一个元素的指针。例如：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, you initialize an `int` array `key_to_the_universe` with three elements.
    Next, you initialize the `int` pointer `key_ptr` to `key_to_the_universe`, which
    decays into a pointer. After initialization, `key_ptr` points to the first element
    of `key_to_the_universe`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你初始化一个包含三个元素的`int`数组`key_to_the_universe`。接下来，你将`int`指针`key_ptr`初始化为指向`key_to_the_universe`，此时`key_ptr`会退化为一个指向数组的指针。初始化后，`key_ptr`指向`key_to_the_universe`的第一个元素。
- en: '[Listing 3-4](ch03.xhtml#ch03ex04) initializes an array containing `College`
    objects and passes the array to a function as a pointer.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-4](ch03.xhtml#ch03ex04)初始化一个包含`College`对象的数组，并将该数组作为指针传递给一个函数。'
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*Listing 3-4: A program illustrating array decay into a pointer*'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-4：展示数组退化为指针的程序*'
- en: The `print_name` function takes a pointer-to-`College` argument ➊, so the `best_colleges`
    array decays into a pointer when you call `print_name`. Because arrays decay into
    pointers to their first element, `college_ptr` at ➊ points to the first `College`
    in `best_colleges`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_name`函数接受一个指向`College`的指针作为参数➊，因此在调用`print_name`时，`best_colleges`数组会退化为指向其第一个元素的指针。因为数组退化成指向第一个元素的指针，所以➊处的`college_ptr`指向`best_colleges`中的第一个`College`。'
- en: There’s another array decay in [Listing 3-4](ch03.xhtml#ch03ex04) ➋ as well.
    You use the arrow operator (`->`) to access the `name` member of the `College`
    pointed to by `college_ptr`, which is itself a `char` array. The `printf` format
    specifier `%s` expects a C-style string, which is a `char` pointer, and `name`
    decays into a pointer to satisfy `printf`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-4](ch03.xhtml#ch03ex04)中也有另一个数组退化➋。你使用箭头操作符（`->`）访问`college_ptr`指向的`College`的`name`成员，而`college_ptr`本身是一个`char`数组。`printf`的格式说明符`%s`期望一个C风格的字符串，它是一个`char`指针，`name`退化为一个指针来满足`printf`的要求。'
- en: '**Handling Decay**'
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**处理退化**'
- en: 'Often, you pass arrays as two arguments:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会将数组作为两个参数传递：
- en: A pointer to the first array element
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向第一个数组元素的指针
- en: The array’s length
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的长度
- en: The mechanism that enables this pattern is square brackets (`[]`), which work
    with pointers just as with arrays. [Listing 3-5](ch03.xhtml#ch03ex05) employs
    this technique.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使这种模式得以实现的机制是方括号（`[]`），它们与指针的作用与数组相同。[列表 3-5](ch03.xhtml#ch03ex05)中使用了这种技术。
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Listing 3-5: A program illustrating a common idiom for passing arrays to functions*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-5：展示将数组传递给函数的常见用法的程序*'
- en: 'The `print_names` function accepts an array in two arguments: a pointer to
    the first `College` element ➊ and the number of elements `n_colleges` ➋. Within
    `print_names`, you iterate with a `for` loop and an index `i`. The value of `i`
    iterates from `0` to `n_colleges-1` ➌.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_names`函数接受两个参数的数组：指向第一个`College`元素的指针➊和元素数量`n_colleges`➋。在`print_names`内部，你使用`for`循环和索引`i`进行迭代。`i`的值从`0`迭代到`n_colleges-1`➌。'
- en: You extract the corresponding college name by accessing the `i`th element ➍
    and then get the `name` member ➎.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过访问第`i`个元素➍来提取对应的学院名称，然后获取`name`成员➎。
- en: This pointer-plus-size approach to passing arrays is ubiquitous in C-style APIs,
    for example, in Windows or Linux system programming.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将指针与大小相结合的数组传递方法在C风格的API中无处不在，例如在Windows或Linux系统编程中。
- en: '**Pointer Arithmetic**'
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**指针运算**'
- en: 'To obtain the address of the `n`th element of an array, you have two options.
    First, you can take the direct approach of obtaining the `n`th element with square
    brackets (`[]`) and then use the address-of (`&`) operator:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取数组中第`n`个元素的地址，你有两种选择。首先，你可以采取直接的方式，通过方括号（`[]`）获取第`n`个元素，然后使用取地址（`&`）运算符：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Pointer arithmetic*, the set of rules for addition and subtraction on pointers,
    provides an alternate approach. When you add or subtract integers to pointers,
    the compiler figures out the correct byte offset using the size of the pointed-to
    type. For example, adding 4 to a `uint64_t` pointer adds 32 bytes: a `uint64_t`
    takes up 8 bytes, so 4 of them take up 32 bytes. The following is therefore equivalent
    to the previous option of obtaining the address of the `n`th element of an array:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*指针运算*，即对指针进行加法和减法的规则，提供了一种替代方法。当你对指针进行加法或减法操作时，编译器会根据指向类型的大小计算出正确的字节偏移。例如，将4加到一个`uint64_t`指针上会增加32个字节：`uint64_t`占用8个字节，因此4个`uint64_t`占用32个字节。因此，下面的操作等同于前一种获取数组中第`n`个元素地址的方法：'
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***Pointers Are Dangerous***'
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***指针是危险的***'
- en: It’s not possible to convert a pointer to an array, which is a good thing. You
    shouldn’t need to, and besides it wouldn’t be possible in general for a compiler
    to recover the size of the array from a pointer. But the compiler can’t save you
    from all the dangerous things you might try to do.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 无法将指针转换为数组，这是件好事。你不应该需要这么做，而且一般来说，编译器也不可能从指针恢复数组的大小。但编译器无法阻止你尝试做所有危险的事情。
- en: '**Buffer Overflows**'
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**缓冲区溢出**'
- en: For arrays and pointers, you can access arbitrary array elements with the bracket
    operator (`[]`) or with pointer arithmetic. These are very powerful tools for
    low-level programming because you can interact with memory more or less without
    abstraction. This gives you exquisite control over the system, which you need
    in some environments (for example, in system programming contexts like implementing
    network protocols or with embedded controllers). With great power comes great
    responsibility, however, and you must be very careful. Simple mistakes with pointers
    can have catastrophic and mysterious consequences.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组和指针，你可以通过括号运算符（`[]`）或指针运算来访问任意的数组元素。这些是低级编程中非常强大的工具，因为你可以或多或少不经过抽象直接与内存交互。这让你对系统拥有精细的控制，某些环境（例如在系统编程环境中实现网络协议或嵌入式控制器时）中是必需的。然而，强大的能力伴随着巨大的责任，你必须非常小心。指针的简单错误可能会导致灾难性且神秘的后果。
- en: '[Listing 3-6](ch03.xhtml#ch03ex06) performs low-level manipulation on two strings.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-6](ch03.xhtml#ch03ex06)对两个字符串执行低级别操作。'
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 3-6: A program containing a buffer overflow*'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-6：包含缓冲区溢出的程序*'
- en: After initializing the strings `lower` and `upper`, you initialize `upper_ptr`
    pointing to the first element ➊ in `upper`. You then reassign the fourth elements
    of both `lower` and `upper` (the question marks) to `d` and `D` ➋ ➌. Notice that
    `lower` is an array and `upper_ptr` is a pointer, but the mechanism is the same.
    So far, so good.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化`lower`和`upper`字符串后，你初始化`upper_ptr`指向`upper`中的第一个元素➊。然后，你将`lower`和`upper`的第四个元素（问号）重新赋值为`d`和`D`➋
    ➌。注意，`lower`是一个数组，而`upper_ptr`是一个指针，但机制是相同的。到目前为止，一切顺利。
- en: Finally, you make a major boo-boo by writing out-of-bounds memory ➎. By accessing
    the element at index `7` ➍, you’ve gone past the storage allotted to `lower`.
    No bounds checking occurs; this code compiles without warning.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你犯了一个大错，写出了超出边界的内存➎。通过访问索引为`7`的元素➍，你已经越过了分配给`lower`的存储空间。没有进行边界检查；这段代码可以在没有警告的情况下编译。
- en: At runtime, you get *undefined behavior*. Undefined behavior means the C++ language
    specification doesn’t prescribe what happens, so your program might crash, open
    a security vulnerability, or spawn an artificial general intelligence ➎.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，你会遇到 *未定义行为*。未定义行为意味着 C++ 语言规范没有规定会发生什么，因此你的程序可能会崩溃、暴露安全漏洞或启动一个人工通用智能 ➎。
- en: '**The Connection Between Brackets and Pointer Arithmetic**'
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**括号和指针算术之间的关系**'
- en: To understand the ramifications of out-of-bounds access, you must understand
    the connection between bracket operators and pointer arithmetic. Consider that
    you could have written [Listing 3-6](ch03.xhtml#ch03ex06) with pointer arithmetic
    and dereference operators rather than bracket operators, as demonstrated in [Listing
    3-7](ch03.xhtml#ch03ex07).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解越界访问的影响，你必须理解括号操作符和指针算术之间的关系。考虑到你可以用指针算术和解引用操作符，而不是括号操作符来编写[示例 3-6](ch03.xhtml#ch03ex06)，正如在[示例
    3-7](ch03.xhtml#ch03ex07)中所示。
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 3-7: An equivalent program to [Listing 3-6](ch03.xhtml#ch03ex06) that
    uses pointer arithmetic*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-7：一个使用指针算术的与 [示例 3-6](ch03.xhtml#ch03ex06) 等效的程序*'
- en: The `lower` array has length 6 (the letters *a*–*e* plus a null terminator).
    It should now be clear why assigning `lower[7]` ➊ is perilous. In this case, you’re
    writing to some memory that doesn’t belong to `lower`. This can result in access
    violations, program crashes, security vulnerabilities, and corrupted data. These
    kinds of errors can be very insidious, because the point at which the bad write
    occurs might be far removed from the point at which the bug manifests.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`lower` 数组的长度为 6（包括字母 *a*–*e* 和一个空终止符）。现在应该清楚为什么给 `lower[7]` 赋值 ➊ 是危险的了。在这种情况下，你正在写入一些不属于
    `lower` 的内存。这可能导致访问违规、程序崩溃、安全漏洞和数据损坏。这些错误可能非常隐蔽，因为错误发生的点和 bug 显现出来的点可能相距甚远。'
- en: '***void Pointers and std::byte Pointers***'
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***空指针和 std::byte 指针***'
- en: Sometimes the pointed-to type is irrelevant. In such situations, you use the
    *void pointer* `void*`. The `void` pointers have important restrictions, the principal
    of which is that you cannot dereference a `void*`. Because the pointed-to type
    has been erased, dereferencing makes no sense (recall that the set of values for
    `void` objects is empty). For similar reasons, C++ forbids `void` pointer arithmetic.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，指向的类型并不重要。在这种情况下，你使用 *void 指针* `void*`。`void` 指针有重要的限制，其中最主要的是你不能解引用一个 `void*`。因为指向的类型已被删除，解引用没有意义（回想一下
    `void` 对象的值集是空的）。出于类似的原因，C++ 禁止 `void` 指针算术。
- en: Other times, you want to interact with raw memory at the byte level. Examples
    include low-level operations like copying raw data between files and memory, encryption,
    and compression. You cannot use a `void` pointer for such purposes because bit-wise
    and arithmetic operations are disabled. In such situations, you can use a `std::byte`
    pointer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你希望在字节级别与原始内存进行交互。举例来说，这包括低级操作，如在文件和内存之间复制原始数据、加密和压缩。你不能使用 `void` 指针来执行这些操作，因为位运算和算术操作被禁用了。在这种情况下，你可以使用
    `std::byte` 指针。
- en: '***nullptr and Boolean Expressions***'
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***nullptr 和布尔表达式***'
- en: Pointers can have a special literal value, `nullptr`. Generally, a pointer that
    equals `nullptr` doesn’t point to anything. You could use `nullptr` to indicate,
    for example, that there’s no more memory left to allocate or that some error occurred.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 指针可以有一个特殊的字面值，`nullptr`。通常，等于 `nullptr` 的指针不指向任何东西。例如，你可以使用 `nullptr` 来表示没有更多内存可以分配，或者某个错误发生了。
- en: Pointers have an implicit conversion to `bool`. Any value that is not `nullptr`
    converts implicitly to `true`, whereas `nullptr` converts implicitly to `false`.
    This is useful when a function returning a pointer ran successfully. A common
    idiom is that such a function returns `nullptr` in the case of failure. The canonical
    example is memory allocation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 指针有一个隐式转换为 `bool` 的机制。任何不等于 `nullptr` 的值会隐式转换为 `true`，而 `nullptr` 会隐式转换为 `false`。这在一个返回指针的函数成功执行时非常有用。一个常见的惯用法是，函数在失败时返回
    `nullptr`。一个经典例子是内存分配。
- en: '**References**'
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**引用**'
- en: '*References* are safer, more convenient versions of pointers. You declare references
    with the `&` declarator appended to the type name. References cannot be assigned
    to null (easily), and they cannot be *reseated* (or reassigned). These characteristics
    eliminate some bugs endemic to pointers.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*引用* 是比指针更安全、更方便的版本。你通过在类型名后附加 `&` 声明引用。引用不能轻易赋值为 null，且不能被 *重新定位*（或重新赋值）。这些特性消除了指针中一些常见的错误。'
- en: The syntax for dealing in references is much cleaner than for pointers. Rather
    than using the member-of-pointer and dereference operators, you use references
    exactly as if they’re of the pointed-to type.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 处理引用的语法比指针更简洁。你无需使用指针的成员操作符和解引用操作符，引用就像是指向类型一样直接使用。
- en: '[Listing 3-8](ch03.xhtml#ch03ex08) features a reference argument.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-8](ch03.xhtml#ch03ex08) 特征是一个引用参数。'
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 3-8: A program using references*'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-8：使用引用的程序*'
- en: 'You declare the `clock` argument as a `ClockOfTheLongNow` reference using the
    ampersand rather than the asterisk ➊. Within `add_year`, you use clock as if it
    were of type `ClockOfTheLongNow` ➋: there’s no need to use clumsy dereference
    and pointer-to-reference operators. First, you print the value of `year` ➌. Next,
    at the call site, you pass a `ClockOfTheLongNow` object directly into `add_year`
    ➍: there’s no need to take its address. Finally, you print the value of `year`
    again to illustrate that it has incremented ➎.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过使用与星号不同的`&`符号将`clock`参数声明为`ClockOfTheLongNow`的引用 ➊。在`add_year`中，你像使用`ClockOfTheLongNow`类型一样使用`clock`
    ➋：无需使用笨拙的解引用和指针到引用操作符。首先，你打印`year`的值 ➌。接着，在调用点，你直接将一个`ClockOfTheLongNow`对象传入`add_year`
    ➍：无需获取它的地址。最后，你再次打印`year`的值，说明它已经增加 ➎。
- en: '**Usage of Pointers and References**'
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**指针和引用的使用**'
- en: Pointers and references are largely interchangeable, but both have trade-offs.
    If you must sometimes change your reference type’s value—that is, if you must
    change what your reference type refers to—you must use a pointer. Many data structures
    (including forward-linked lists, which are covered in the next section) require
    that you be able to change a pointer’s value. Because references cannot be reseated
    and they shouldn’t generally be assigned to `nullptr`, they’re sometimes not suitable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 指针和引用在很大程度上是可以互换的，但两者各有优缺点。如果你有时必须改变引用类型的值——也就是说，如果你必须改变引用类型所指向的内容——你必须使用指针。许多数据结构（包括下一节将介绍的前向链表）要求你能够更改指针的值。由于引用不能重新指向并且通常不应赋值为`nullptr`，因此它们有时不适用。
- en: '***Forward-Linked Lists: The Canonical Pointer-Based Data Structure***'
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***前向链表：典型的基于指针的数据结构***'
- en: A *forward-linked list* is a simple data structure made up of a series of elements.
    Each element holds a pointer to the next element. The last element in the linked
    list holds a `nullptr`. Inserting elements into a linked list is very efficient,
    and elements can be discontinuous in memory.[Figure 3-1](ch03.xhtml#ch03fig01)
    illustrates their layout.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*前向链表*是一种由一系列元素组成的简单数据结构。每个元素保存一个指向下一个元素的指针。链表中的最后一个元素保存一个`nullptr`。将元素插入链表非常高效，并且元素在内存中可以是不连续的。[图
    3-1](ch03.xhtml#ch03fig01) 说明了它们的布局。'
- en: '![image](../images/fig3_1.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig3_1.jpg)'
- en: '*Figure 3-1: A linked list*'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-1：链表*'
- en: '[Listing 3-9](ch03.xhtml#ch03ex09) demonstrates a possible implementation of
    a singly linked list element.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-9](ch03.xhtml#ch03ex09) 演示了单向链表元素的一种可能实现。'
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 3-9: An implementation of a linked list `Element` with an operating
    number*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-9：具有操作编号的链表 `Element` 实现*'
- en: Each `element` has a pointer to the `next` element in the linked list ➊, which
    initializes to `nullptr`. You insert a new element using the `insert_after` method
    ➋. It sets the `next` member of `new_element` to the `next` of `this` ➌ and then
    sets `next` of `this` to `new_element` ➍.[Figure 3-2](ch03.xhtml#ch03fig02) illustrates
    this insertion. You haven’t changed the memory location of any `Element` objects
    in this listing; you’re only modifying pointer values.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`element`都有一个指向链表中`next`元素的指针 ➊，并初始化为`nullptr`。你通过`insert_after`方法插入一个新元素
    ➋。它将`new_element`的`next`成员设置为`this`的`next` ➌，然后将`this`的`next`设置为`new_element`
    ➍。[图 3-2](ch03.xhtml#ch03fig02) 演示了这个插入过程。你并没有改变任何`Element`对象的内存位置；你只是修改了指针的值。
- en: '![image](../images/fig3_2.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/fig3_2.jpg)'
- en: '*Figure 3-2: Inserting an element into a linked list*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 3-2：插入元素到链表中*'
- en: Each `Element` also contains a `prefix` array ➎ and an `operating_number` short
    ➏.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Element`还包含一个`prefix`数组 ➎和一个`operating_number`短整数 ➏。
- en: '[Listing 3-10](ch03.xhtml#ch03ex10) traverses a linked list of stormtroopers
    of type `Element`, printing their operating numbers along the way.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-10](ch03.xhtml#ch03ex10) 遍历一个`Element`类型的风暴兵链表，并沿途打印其操作编号。'
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 3-10: A program illustrating a forward-linked list*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-10：演示前向链表的程序*'
- en: '[Listing 3-10](ch03.xhtml#ch03ex10) initializes three stormtroopers ➊. The
    element `trooper1` is assigned the operating number TK-421, and then you insert
    it as the next element in the list ➋. The elements `trooper2` and `trooper3` have
    operating numbers FN-2187 and LS-005 and are also inserted into the list ➌➍.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-10](ch03.xhtml#ch03ex10)初始化了三个暴风兵 ➊。元素`trooper1`被赋予操作编号TK-421，然后你将其作为链表中的下一个元素插入
    ➋。元素`trooper2`和`trooper3`的操作编号分别为FN-2187和LS-005，也被插入到链表中 ➌➍。'
- en: The `for` loop iterates through the linked list. First, you assign the cursor
    pointer to the address of `trooper1` ➎. This is the beginning of the list. Before
    each iteration, you make sure that `cursor` is not `nullptr` ➏. After each iteration,
    you set `cursor` to the `next` element ➐. Within the loop, you print each stormtrooper’s
    operating number ➑.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环遍历链表。首先，你将光标指针分配给`trooper1`的地址 ➎。这是链表的起始位置。在每次迭代之前，你确保`cursor`不是`nullptr`
    ➏。每次迭代后，你将`cursor`设置为`next`元素 ➐。在循环内，你打印每个暴风兵的操作编号 ➑。'
- en: '***Employing References***'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用引用***'
- en: Pointers provide a lot of flexibility, but this flexibility comes at a safety
    cost. If you don’t need the flexibility of reseatability and `nullptr`, references
    are the go-to reference type.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 指针提供了很大的灵活性，但这种灵活性是以安全性为代价的。如果你不需要重定向和`nullptr`的灵活性，引用是首选的引用类型。
- en: Let’s drive home the point that references cannot be reseated. [Listing 3-11](ch03.xhtml#ch03ex11)
    initializes an `int` reference and then attempts to reseat it with a `new_value`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再强调一次，引用不能被重新设置。[清单 3-11](ch03.xhtml#ch03ex11)初始化了一个`int`引用，然后尝试用`new_value`重新设置它。
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*Listing 3-11: A program illustrating that you cannot reseat references*'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-11：演示无法重新设置引用的程序*'
- en: This program initializes an `int` called `original` to 100\. Then it declares
    a reference to `original` called `original_ref`. From this point on, `original_ref`
    will *always* refer to `original`. This is illustrated by printing the value of
    `original` ➊ and the value referred to by `original_ref` ➋. They’re the same.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序初始化一个名为`original`的`int`变量为100。然后声明一个对`original`的引用，称为`original_ref`。从此以后，`original_ref`将*始终*指向`original`。这一点通过打印`original`的值
    ➊ 和`original_ref`所引用的值 ➋ 来说明。它们是相同的。
- en: 'Next, you initialize another `int` called `new_value` to 200 and assign it
    to `original` ➌. Read that carefully: this assignment ➌ doesn’t reseat `original_ref`
    so that it points to `new_value`. Rather, it assigns the value of `new_value`
    to the object it points to (`original`).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你初始化另一个`int`变量`new_value`为200，并将其赋值给`original` ➌。仔细阅读：此赋值 ➌ 并不会重新设置`original_ref`指向`new_value`。而是将`new_value`的值赋给它所指向的对象（即`original`）。
- en: The upshot is that all of these variables—`original`, `original_ref`, and `new_value`—evaluate
    to 200 ➍➎➏.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，这些变量——`original`、`original_ref`和`new_value`——的值都为200 ➍➎➏。
- en: '***this Pointers***'
  id: totrans-142
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***this 指针***'
- en: Remember that methods are associated with classes and that instances of classes
    are objects. When you program a method, sometimes you need to access the *current
    object*, which is the object that is executing the method.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，方法与类相关，类的实例是对象。当你编写方法时，有时你需要访问*当前对象*，即正在执行该方法的对象。
- en: Within method definitions, you can access the current object using the `this`
    pointer. Usually, `this` isn’t needed, because `this` is implicit when accessing
    members. But sometimes you might need to disambiguate—for example, if you declare
    a method parameter whose name collides with a member variable. For example, you
    can rewrite [Listing 3-9](ch03.xhtml#ch03ex09) to make explicit which `Element`
    you’re referring to, as demonstrated in [Listing 3-12](ch03.xhtml#ch03ex12).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法定义中，你可以使用`this`指针访问当前对象。通常不需要`this`，因为在访问成员时`this`是隐式的。但是有时你可能需要消除歧义——例如，如果你声明了一个与成员变量同名的方法参数。例如，你可以重写[清单
    3-9](ch03.xhtml#ch03ex09)，明确指出你指的是哪个`Element`，如[清单 3-12](ch03.xhtml#ch03ex12)所示。
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '*Listing 3-12: A rewriting of [Listing 3-9](ch03.xhtml#ch03ex09) using the
    `this` pointer*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-12：使用`this`指针重写[清单 3-9](ch03.xhtml#ch03ex09)*'
- en: Here, `next` is replaced with `this->next` ➊➋. The listings are functionally
    identical.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`next`被替换为`this->next` ➊➋。这些清单在功能上是相同的。
- en: Sometimes, you need `this` to resolve ambiguity between members and arguments,
    as demonstrated in [Listing 3-13](ch03.xhtml#ch03ex13).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你需要`this`来解决成员与参数之间的歧义，正如[清单 3-13](ch03.xhtml#ch03ex13)所示。
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 3-13: A verbose `ClockOfTheLongNow` definition using `this`*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-13：使用`this`的冗长`ClockOfTheLongNow`定义*'
- en: 'The `year` argument ➊ has the same name as the `year` member ➌. Method arguments
    will always mask members, meaning when you type `year` within this method, it
    refers to the `year` argument ➊, not the `year` member ➌. That’s no problem: you
    disambiguate with `this` ➋.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`year` 参数 ➊ 与 `year` 成员 ➌ 同名。方法参数总是会遮蔽成员，这意味着当你在该方法中输入 `year` 时，它指的是 `year`
    参数 ➊，而不是 `year` 成员 ➌。这没问题：你可以通过 `this` ➋ 来消除歧义。'
- en: '***const Correctness***'
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***const 正确性***'
- en: The keyword `const` (short for “constant”) roughly means “I promise not to modify.”
    It’s a safety mechanism that prevents unintended (and potentially catastrophic)
    modifications of member variables. You’ll use `const` in function and class definitions
    to specify that a variable (usually a reference or a pointer) won’t be modified
    by that function or class. If code attempts to modify a `const` variable, the
    compiler will emit an error. When used correctly, `const` is one of the most powerful
    language features in all modern programming languages because it helps you to
    eliminate many kinds of common programming mistakes at compile time.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 关键字（常用作“常量”的缩写）大致意味着“我承诺不会修改”。它是一种安全机制，防止无意中（以及潜在的灾难性）修改成员变量。你将在函数和类的定义中使用
    `const` 来指定一个变量（通常是引用或指针）在该函数或类中不会被修改。如果代码试图修改一个 `const` 变量，编译器将发出错误。当正确使用时，`const`
    是所有现代编程语言中最强大的语言特性之一，因为它有助于你在编译时消除许多常见的编程错误。'
- en: Let’s look at a few common usages of `const`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `const` 的一些常见用法。
- en: '**const Arguments**'
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**const 参数**'
- en: Marking an argument `const` precludes its modification within a function’s scope.
    A `const` pointer or reference provides you with an efficient mechanism to pass
    an object into a function for read-only use. The function in [Listing 3-14](ch03.xhtml#ch03ex14)
    takes a `const` pointer.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 将参数标记为 `const` 使得它不能在函数的作用域内被修改。`const` 指针或引用为你提供了一种高效的机制，可以将对象传递给函数进行只读使用。[列表
    3-14](ch03.xhtml#ch03ex14) 中的函数接受一个 `const` 指针。
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 3-14: A function taking a `const` pointer (This code doesn’t compile.)*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-14：一个接受 `const` 指针的函数（此代码无法编译。）*'
- en: The `petruchio` function takes a `shrew` string by `const` reference ➊. You
    can read from `shrew` ➋, but attempting to write to it results in a compiler error
    ➌.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`petruchio` 函数通过 `const` 引用 ➊ 接受一个 `shrew` 字符串。你可以从 `shrew` ➋ 中读取，但尝试写入它会导致编译错误
    ➌。'
- en: '**const Methods**'
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**const 方法**'
- en: Marking a method `const` communicates that you promise not to modify the current
    object’s state within the `const` method. Put another way, these are read-only
    methods.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法标记为 `const` 表示你承诺在该 `const` 方法中不会修改当前对象的状态。换句话说，这些方法是只读的。
- en: To mark a method `const`, place the `const` keyword after the argument list
    but before the method body. For example, you could update the `ClockOfTheLongNow`
    object’s `get_year` with `const`, as demonstrated in [Listing 3-15](ch03.xhtml#ch03ex15).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要将方法标记为 `const`，请将 `const` 关键字放在参数列表之后但在方法体之前。例如，你可以像 [列表 3-15](ch03.xhtml#ch03ex15)
    中演示的那样更新 `ClockOfTheLongNow` 对象的 `get_year` 方法，添加 `const`。
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 3-15: Updating `ClockOfTheLongNow` with `const`*'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-15：使用 `const` 更新 `ClockOfTheLongNow`*'
- en: All you need to do is place `const` between the argument list and the method
    body ➊. Had you attempted to modify `year` within `get_year`, the compiler would
    have generated an error.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要将 `const` 放在参数列表和方法体之间 ➊。如果你尝试在 `get_year` 中修改 `year`，编译器将生成一个错误。
- en: Holders of `const` references and pointers cannot invoke methods that are not
    `const`, because methods that are not `const` might modify an object’s state.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 持有 `const` 引用和指针的对象不能调用非 `const` 方法，因为非 `const` 方法可能会修改对象的状态。
- en: The `is_leap_year` function in [Listing 3-16](ch03.xhtml#ch03ex16) takes a `const
    ClockOfTheLongNow` reference and determines whether it’s a leap year.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-16](ch03.xhtml#ch03ex16) 中的 `is_leap_year` 函数接受一个 `const ClockOfTheLongNow`
    引用，并判断其是否为闰年。'
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '*Listing 3-16: A function for determining leap years*'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3-16：一个判断是否为闰年的函数*'
- en: Had `get_year` not been marked a `const` method, [Listing 3-16](ch03.xhtml#ch03ex16)
    would not compile because `clock` is a `const` reference and cannot be modified
    within `is_leap_year`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `get_year` 没有被标记为 `const` 方法，[列表 3-16](ch03.xhtml#ch03ex16) 将无法编译，因为 `clock`
    是一个 `const` 引用，不能在 `is_leap_year` 中被修改。
- en: '***const Member Variables***'
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***const 成员变量***'
- en: You can mark member variables `const` by adding the keyword to the member’s
    type. The `const` member variables cannot be modified after their initialization.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将 `const` 关键字添加到成员的类型中来标记成员变量为 `const`。这些 `const` 成员变量在初始化后不能被修改。
- en: In [Listing 3-17](ch03.xhtml#ch03ex17), the `Avout` class contains two member
    variables, one `const` and one not `const`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在[清单 3-17](ch03.xhtml#ch03ex17)中，`Avout`类包含两个成员变量，一个是`const`类型，一个不是`const`类型。
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Listing 3-17: An `Avout` class with a `const` member*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-17：具有`const`成员的`Avout`类*'
- en: The `name` member is `const`, meaning the pointed-to value cannot be modified
    ➊. On the other hand, `apert` is not `const` ➋.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`成员是`const`，这意味着指向的值无法修改 ➊。另一方面，`apert`不是`const` ➋。'
- en: 'Of course, a `const Avout` reference cannot be modified, so the usual rules
    would still apply to `apert`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`const Avout`引用不能被修改，因此通常的规则仍然适用于`apert`：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Sometimes you want the safety of marking a member variable `const` but would
    also like to initialize the member with arguments passed into a constructor. For
    this, you employ member initializer lists.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你想标记一个成员变量为`const`，但又希望使用传入构造函数的参数来初始化该成员。为此，你可以使用成员初始化列表。
- en: '***Member Initializer Lists***'
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***成员初始化列表***'
- en: '*Member initializer lists* are the primary mechanism for initializing class
    members. To declare a member initializer list, place a colon after the argument
    list in a constructor. Then insert one or more comma-separated *member initializers*.
    A member initializer is the name of the member followed by a braced initialization
    `{ }`. Member initializers allow you to set the value of `const` fields at runtime.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*成员初始化列表*是初始化类成员的主要机制。要声明一个成员初始化列表，在构造函数的参数列表后加上冒号，然后插入一个或多个逗号分隔的*成员初始化器*。成员初始化器是成员的名称，后面跟着一个大括号初始化`{
    }`。成员初始化器允许你在运行时设置`const`字段的值。'
- en: The example in [Listing 3-18](ch03.xhtml#ch03ex18) improves [Listing 3-17](ch03.xhtml#ch03ex17)
    by introducing a member initialization list.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-18](ch03.xhtml#ch03ex18) 中的示例通过引入成员初始化列表改进了[清单 3-17](ch03.xhtml#ch03ex17)。'
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 3-18: A program declaring and announcing two `Avout` objects*'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 3-18：声明并初始化两个`Avout`对象的程序*'
- en: The `Avout` constructor takes two arguments, a `name` and the `year_of_apert`
    ➊. A member initializer list is added by inserting a colon ➋ followed by the names
    of each member you’re initializing ➌➎ and braced initializations ➍➏. A `const`
    method `announce` is also added to print the `Avout` constructor’s status ➐.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Avout`构造函数接受两个参数，一个是`name`，另一个是`year_of_apert` ➊。通过插入一个冒号 ➋ 来添加成员初始化列表，接着列出你要初始化的每个成员的名称
    ➌➎ 和大括号初始化 ➍➏。还添加了一个`const`类型的`announce`方法，用于打印`Avout`构造函数的状态 ➐。'
- en: 'All member initializations execute before the constructor’s body. This has
    two advantages:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 所有成员初始化在构造函数体执行之前都会被执行。这有两个优点：
- en: It ensures validity of all members before the constructor executes, so you can
    focus on initialization logic rather than member error checking.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它确保在构造函数执行之前所有成员都有效，因此你可以专注于初始化逻辑，而不是成员错误检查。
- en: The members initialize once. If you reassign members in the constructor, you
    potentially do extra work.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员只会初始化一次。如果你在构造函数中重新赋值成员，可能会做一些额外的工作。
- en: '**NOTE**'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You should order the member initializers in the same order they appear in
    the class definition, because their constructors will be called in this order.*'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*你应该按它们在类定义中出现的顺序排列成员初始化器，因为它们的构造函数将按此顺序被调用。*'
- en: Speaking of eliminating extra work, it’s time to meet `auto`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 说到消除额外的工作，是时候介绍`auto`了。
- en: '**auto Type Deduction**'
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**auto类型推导**'
- en: As a strongly typed language, C++ affords its compiler a lot of information.
    When you initialize elements or return from functions, the compiler can divine
    type information from context. The `auto` keyword tells the compiler to perform
    such a divination for you, relieving you from inputting redundant type information.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种强类型语言，C++为其编译器提供了大量信息。当你初始化元素或从函数返回时，编译器可以根据上下文推断出类型信息。`auto`关键字告诉编译器为你执行这样的推断，从而免去你输入冗余的类型信息。
- en: '***Initialization with auto***'
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用auto初始化***'
- en: 'In almost all situations, the compiler can determine the correct type of an
    object using the initialization value. This assignment contains redundant information:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有情况下，编译器可以根据初始化值确定对象的正确类型。这种赋值包含冗余信息：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The compiler knows `answer` is an `int` because 42 is an `int`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器知道`answer`是`int`类型，因为42是`int`类型。
- en: 'You can use `auto` instead:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`auto`代替：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This also works when you’re initializing with parentheses `()` and the lone
    `=`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用括号`()`和单独的`=`进行初始化时，这种方式同样适用：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Because you’ve committed to universal initialization with `{}` as much as possible,
    this section will say no more of these alternatives.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你尽可能使用`{}`进行统一初始化，本节将不再讨论这些替代方法。
- en: Alone, all of this simple initialization help doesn’t buy you much; however,
    when types become more complicated—for example, dealing with iterators from stdlib
    containers—it really saves quite a bit of typing. It also makes your code more
    resilient to refactoring.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用这些简单的初始化帮助并不能给你带来太多好处；然而，当类型变得更加复杂时——例如，处理来自标准库容器的迭代器——它确实节省了很多输入工作量。它还使你的代码在重构时更具弹性。
- en: '***auto and Reference Types***'
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***auto 和引用类型***'
- en: 'It’s common to add modifiers like `&`, `*`, and `const` to `auto`. Such modifications
    add the intended meanings (reference, pointer, and `const`, respectively):'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会在 `auto` 上添加修饰符，如 `&`、`*` 和 `const`。这些修饰符分别添加了预期的含义（引用、指针和 `const`）：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Adding modifiers to the `auto` declaration behaves just as you’d expect: if
    you add a modifier, the resulting type is guaranteed to have that modifier.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `auto` 声明中添加修饰符的行为如你所预期：如果你添加了修饰符，结果类型将确保包含该修饰符。
- en: '***auto and Code Refactorings***'
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***auto 和代码重构***'
- en: The `auto` keyword assists in making code simpler and more resilient to refactoring.
    Consider the example in [Listing 3-19](ch03.xhtml#ch03ex19) with a range-based
    `for` loop.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto` 关键字有助于简化代码并提高代码在重构时的弹性。考虑[示例 3-19](ch03.xhtml#ch03ex19)中的基于范围的 `for`
    循环示例。'
- en: '[PRE35]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 3-19: An example using `auto` in a range-based `for` loop*'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 3-19：在基于范围的 `for` 循环中使用 `auto` 的示例*'
- en: If ever the type of `dwarves` changes, the assignment in the range-based `for`
    loop ➊ doesn’t need to change. The `dwarf` type will adapt to its surroundings,
    in much the same way that the dwarves of Middle Earth don’t.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `dwarves` 的类型发生变化，基于范围的 `for` 循环中的赋值 ➊ 不需要修改。`dwarf` 类型将根据其环境自适应，就像中土世界的矮人一样。
- en: As a general rule, use `auto` always.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，始终使用 `auto`。
- en: '**NOTE**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*There are some corner cases to using braced initialization where you might
    get surprising results, but these are few, especially after C++17 fixed some pedantic
    nonsense behavior. Prior to C++17, using `auto` with braces `{}` specified a special
    object called a `std::initializer_list`, which you’ll meet in [Chapter 13](ch13.xhtml#ch13).*'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用大括号初始化时，可能会出现一些边缘情况，导致你得到意想不到的结果，但这种情况很少，特别是在 C++17 修复了一些过于苛刻的行为后。在 C++17
    之前，使用带大括号 `{}` 的 `auto` 会指定一个特殊对象 `std::initializer_list`，你将在[第 13 章](ch13.xhtml#ch13)中遇到它。*'
- en: '**Summary**'
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**总结**'
- en: 'This chapter covered the two reference types: references and pointers. Along
    the way, you learned about the member-of-pointer operator, how pointers and arrays
    interplay, and `void`/`byte` pointers. You also learned about the meaning of `const`
    and its basic usage, the `this` pointer, and member initializer lists. Additionally,
    the chapter introduced `auto` type deduction.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了两种引用类型：引用和指针。在此过程中，你学习了成员指针操作符、指针与数组的相互作用以及 `void`/`byte` 指针。你还了解了 `const`
    的含义及其基本用法、`this` 指针和成员初始化列表。此外，本章还介绍了 `auto` 类型推导。
- en: '**EXERCISES**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '**3-1.** Read about CVE-2001-0500, a buffer overflow in Microsoft’s Internet
    Information Services. (This vulnerability is commonly referred to as the Code
    Red worm vulnerability.)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**3-1.** 阅读有关 CVE-2001-0500 的内容，这是微软 Internet 信息服务中的一个缓冲区溢出漏洞。（此漏洞通常被称为 Code
    Red 蠕虫漏洞。）'
- en: '**3-2.** Add a `read_from` and a `write_to` function to [Listing 3-6](ch03.xhtml#ch03ex06).
    These functions should read or write to `upper` or `lower` as appropriate. Perform
    bounds checking to prevent buffer overflows.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**3-2.** 向[示例 3-6](ch03.xhtml#ch03ex06)中添加一个 `read_from` 和一个 `write_to` 函数。这些函数应根据需要读取或写入
    `upper` 或 `lower`。进行边界检查以防止缓冲区溢出。'
- en: '**3-3.** Add an `Element* previous` to [Listing 3-9](ch03.xhtml#ch03ex09) to
    make a *doubly linked list*. Add an `insert_before` method to `Element`. Traverse
    the list from front to back, then from back to front, using two separate `for`
    loops. Print the `operating_number` inside each loop.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**3-3.** 向[示例 3-9](ch03.xhtml#ch03ex09)中添加一个 `Element* previous`，以创建一个*双向链表*。向
    `Element` 添加一个 `insert_before` 方法。使用两个独立的 `for` 循环从前向后遍历列表，再从后向前遍历。打印每个循环中的 `operating_number`。'
- en: '**3-4.** Reimplement [Listing 3-11](ch03.xhtml#ch03ex11) using no explicit
    types. (Hint: use `auto`.)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**3-4.** 使用没有显式类型的方式重新实现[示例 3-11](ch03.xhtml#ch03ex11)。 （提示：使用 `auto`。）'
- en: '**3-5.** Scan the listings in [Chapter 2](ch02.xhtml#ch02). Which methods could
    be marked `const`? Where could you use `auto` ?'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**3-5.** 浏览[第 2 章](ch02.xhtml#ch02)中的示例。哪些方法可以标记为 `const`？你在哪里可以使用 `auto`？'
- en: '**FURTHER READING**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**进一步阅读**'
- en: '*The C++ Programming Language*, 4th Edition, by Bjarne Stroustrup (Pearson
    Education, 2013)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《C++ 编程语言》*，第 4 版，Bjarne Stroustrup 著（Pearson Education，2013）'
- en: “C++ Core Guidelines” by Bjarne Stroustrup and Herb Sutter (*[https://github.com/isocpp/CppCoreGuidelines/](https://github.com/isocpp/CppCoreGuidelines/)*)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《C++ 核心准则》由Bjarne Stroustrup和Herb Sutter编著（* [https://github.com/isocpp/CppCoreGuidelines/](https://github.com/isocpp/CppCoreGuidelines/)
    *）
- en: “East End Functions” by Phil Nash (2018; *[https://levelofindirection.com/blog/east-end-functions.html](https://levelofindirection.com/blog/east-end-functions.html)*)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《East End Functions》由Phil Nash编著（2018年；* [https://levelofindirection.com/blog/east-end-functions.html](https://levelofindirection.com/blog/east-end-functions.html)
    *）
- en: “References FAQ” by the Standard C++ Foundation (*[https://isocpp.org/wiki/faq/references/](https://isocpp.org/wiki/faq/references/)*)
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《引用常见问题解答》由标准C++基金会编写（* [https://isocpp.org/wiki/faq/references/](https://isocpp.org/wiki/faq/references/)
    *）
