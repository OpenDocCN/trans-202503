- en: '**3'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: REFERENCE TYPES**
  prefs: []
  type: TYPE_NORMAL
- en: '*Everyone knows that debugging is twice as hard as writing a program in the
    first place. So if you’re as clever as you can be when you write it, how will
    you ever debug it?'
  prefs: []
  type: TYPE_NORMAL
- en: —Brian Kernighan*
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](../images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Reference types* store the memory addresses of objects. These types enable
    efficient programming, and many elegant design patterns feature them. In this
    chapter, I’ll discuss the two kinds of reference types: pointers and references.
    I’ll also discuss `this`, `const`, and `auto` along the way.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pointers**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Pointers* are the fundamental mechanism used to refer to memory addresses.
    Pointers encode both pieces of information required to interact with another object—that
    is, the object’s address and the object’s type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can declare a pointer’s type by appending an asterisk (`*`) to the pointed-to
    type. For example, you declare a pointer to `int` called `my_ptr` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The format specifier for a pointer is `%p`. For example, to print the value
    in `my_ptr`, you could use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Pointers are very low-level objects. Although they play a central role in most
    C programs, C++ offers higher-level, sometimes more efficient, constructs that
    obviate the need to deal with memory addresses directly. Nonetheless, pointers
    are a foundational concept that you’ll no doubt come across in your system-programming
    travels.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you’ll learn how to find the address of an object and how
    to assign the result to a pointer variable. You’ll also learn how to perform the
    opposite operation, which is called *dereferencing*: given a pointer, you can
    obtain the object residing at the corresponding address.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll learn more about *arrays*, the simplest construct for managing an object
    collection, as well as how arrays relate to pointers. As low-level constructs,
    arrays and pointers are relatively dangerous. You’ll learn about what can go wrong
    when pointer- and array-based programs go awry.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter introduces two special kinds of pointers: `void` pointers and
    `std::byte` pointers. These very useful types have some special behaviors that
    you’ll need to keep in mind. Additionally, you’ll learn how to encode empty pointers
    with `nullptr` and how to use pointers in Boolean expressions to determine whether
    they’re empty.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Addressing Variables***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can obtain the address of a variable by prepending the *address-of operator*
    (`&`). You might want to use this operator to initialize a pointer so it “points
    to” the corresponding variable. Such programming requirements arise very often
    in operating systems programming. For example, major operating systems, such as
    Windows, Linux, and FreeBSD, have interfaces that use pointers heavily.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-1](ch03.xhtml#ch03ex01) demonstrates how to obtain the address of
    an `int`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-1: A program featuring the address-of operator `&` and a terrible
    pun*'
  prefs: []
  type: TYPE_NORMAL
- en: First, you declare the integer `gettysburg` ➊ and print its value ➋. Then you
    declare a pointer, called `gettysburg_address`, to that integer’s address ➌; notice
    that the asterisk prepends the pointer and the ampersand prepends `gettysburg`.
    Finally, you print the pointer to the screen ➍ to reveal the `gettysburg` integer’s
    address.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run [Listing 3-1](ch03.xhtml#ch03ex01) on Windows 10 (x86), you should
    see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the same code on Windows 10 x64 yields the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Your output should have an identical value for `gettysburg`, but `gettysburg_address`
    should be different each time. This variation is due to *address space layout
    randomization*, which is a security feature that scrambles the base address of
    important memory regions to hamper exploitation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Address Space Layout Randomization**'
  prefs: []
  type: TYPE_NORMAL
- en: Why does address space layout randomization hamper exploitation? When a hacker
    finds an exploitable condition in a program, they can sometimes cram a malicious
    payload into user-provided input. One of the first security features designed
    to prevent a hacker from getting this malicious payload to execute is to make
    all data sections non-executable. If the computer attempts to execute data as
    code, then the theory is that it knows something’s amiss and should terminate
    the program with an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Some exceedingly clever hackers figured out how to repurpose executable code
    instructions in totally unforeseen ways by carefully crafting exploits containing
    so-called *return-oriented programs*. These exploits could arrange to invoke the
    relevant system APIs to mark their payload executable, hence defeating the non-executable-memory
    mitigation.
  prefs: []
  type: TYPE_NORMAL
- en: Address space layout randomization combats return-oriented programming by randomizing
    memory addresses, making it difficult to repurpose existing code because the attacker
    doesn’t know where it resides in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that in the outputs for [Listing 3-1](ch03.xhtml#ch03ex01), `gettysburg_address`
    contains 8 hexadecimal digits (4 bytes) for an x86 architecture and 16 hexadecimal
    digits (8 bytes) for an x64 architecture. This should make some sense because
    on modern desktop systems, the pointer size is the same as the CPU’s general-purpose
    register. An x86 architecture has 32-bit (4-byte) general-purpose registers, whereas
    an x64 architecture has 64-bit (8-byte) general-purpose registers.
  prefs: []
  type: TYPE_NORMAL
- en: '***Dereferencing Pointers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The *dereference operator* (`*`) is a unary operator that accesses the object
    to which a pointer refers. This is the inverse operation of the address-of operator.
    Given an address, you can obtain the object residing there. Like the address-of
    operator, system programmers use the dereference operator very often. Many operating
    system APIs will return pointers, and if you want to access the referred-to object,
    you’ll use the dereference operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the dereference operator can cause a lot of notation-based confusion
    for beginners because the dereference operator, the pointer declaration, and multiplication
    all use asterisks. Remember that you append an asterisk to the end of the pointed-to
    object’s type to declare a pointer; however, you prepend the dereference operator—an
    asterisk—to the pointer, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After accessing an object by prepending the dereference operator to a pointer,
    you can treat the result like any other object of the pointed-to type. For example,
    because `gettysburg` is an integer, you can write the value 17325 into `gettysburg`
    using `gettysburg_address`. The correct syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Because the dereferenced pointer—that is, `*gettysburg_address`—appears on the
    left side of the equal sign, you’re writing to the address where `gettysburg`
    is stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a dereferenced pointer appears anywhere except the left side of an equal
    sign, you’re reading from the address. To retrieve the `int` pointed to by `gettysburg_address`,
    you just tack on the dereference operator. For instance, the following statement
    will print the value stored in `gettysburg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[Listing 3-2](ch03.xhtml#ch03ex02) uses the dereference operator to read and
    write.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-2: An example program illustrating reads and writes using a pointer
    (output is from a Windows 10 x64 machine)*'
  prefs: []
  type: TYPE_NORMAL
- en: First, you initialize `gettysburg` to zero. Then, you initialize the pointer
    `gettysburg_address` to the address of `gettysburg` ➊. Next, you print the `int`
    pointed to by `gettysburg_address` ➋ and the value of `gettysburg_address` itself
    ➌.
  prefs: []
  type: TYPE_NORMAL
- en: You write the value 17325 into the memory pointed to by `gettysburg_address`
    ➍ and then print the pointed-to value ➎ and address ➏ again.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-2](ch03.xhtml#ch03ex02) would be functionally identical if you assigned
    the value 17325 directly to `gettysburg` instead of to the `gettysburg_address`
    pointer, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This example illustrates the close relationship between a pointed-to object
    (`gettysburg`) and a dereferenced pointer to that object (`*gettysburg_address)`.
  prefs: []
  type: TYPE_NORMAL
- en: '***The Member-of-Pointer Operator***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The *member-of-pointer operator*, or *arrow operator* (`->`), performs two
    simultaneous operations:'
  prefs: []
  type: TYPE_NORMAL
- en: It dereferences a pointer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It accesses a member of the pointed-to object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use this operator to reduce *notational friction*, the resistance a
    programmer feels in expressing their intent in code, when you’re handling pointers
    to classes. You’ll need to handle pointers to classes in a variety of design patterns.
    For example, you might want to pass a pointer to a class as a function parameter.
    If the receiving function needs to interact with a member of that class, the member-of-pointer
    operator is the tool for the job.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-3](ch03.xhtml#ch03ex03) employs the arrow operator to read the `year`
    from a `ClockOfTheLongNow` object (which you implemented in [Listing 2-22](ch02.xhtml#ch02ex22)
    on [page 58](ch02.xhtml#page_58)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-3: Using a pointer and the arrow operator to manipulate the `ClockOfTheLongNow`
    object (output is from a Windows 10 x64 machine)*'
  prefs: []
  type: TYPE_NORMAL
- en: You declare a `clock` and then store its address in `clock_ptr` ➊. Next, you
    use the arrow operator to set the `year` member of `clock` to 2020 ➋. Finally,
    you print the address of `clock` ➌ and the value of `year` ➍.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could achieve an identical result using the dereference (`*`) and member
    of (`.`) operators. For example, you could have written the last line of [Listing
    3-3](ch03.xhtml#ch03ex03) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First, you dereference `clock_ptr`, and then you access the `year`. Although
    this is equivalent to invoking the pointer-to-member operator, it’s a more verbose
    syntax and provides no benefit over its simpler alternative.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*For now, use parentheses to emphasize the order of operations. [Chapter 7](ch07.xhtml#ch07)
    walks through the precedents rules for operators.*'
  prefs: []
  type: TYPE_NORMAL
- en: '***Pointers and Arrays***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pointers share several characteristics with arrays. Pointers encode object location.
    Arrays encode the location and length of contiguous objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the slightest provocation, an array will *decay* into a pointer. A decayed
    array loses length information and converts to a pointer to the array’s first
    element. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: First, you initialize an `int` array `key_to_the_universe` with three elements.
    Next, you initialize the `int` pointer `key_ptr` to `key_to_the_universe`, which
    decays into a pointer. After initialization, `key_ptr` points to the first element
    of `key_to_the_universe`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-4](ch03.xhtml#ch03ex04) initializes an array containing `College`
    objects and passes the array to a function as a pointer.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-4: A program illustrating array decay into a pointer*'
  prefs: []
  type: TYPE_NORMAL
- en: The `print_name` function takes a pointer-to-`College` argument ➊, so the `best_colleges`
    array decays into a pointer when you call `print_name`. Because arrays decay into
    pointers to their first element, `college_ptr` at ➊ points to the first `College`
    in `best_colleges`.
  prefs: []
  type: TYPE_NORMAL
- en: There’s another array decay in [Listing 3-4](ch03.xhtml#ch03ex04) ➋ as well.
    You use the arrow operator (`->`) to access the `name` member of the `College`
    pointed to by `college_ptr`, which is itself a `char` array. The `printf` format
    specifier `%s` expects a C-style string, which is a `char` pointer, and `name`
    decays into a pointer to satisfy `printf`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Handling Decay**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Often, you pass arrays as two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: A pointer to the first array element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The array’s length
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mechanism that enables this pattern is square brackets (`[]`), which work
    with pointers just as with arrays. [Listing 3-5](ch03.xhtml#ch03ex05) employs
    this technique.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-5: A program illustrating a common idiom for passing arrays to functions*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `print_names` function accepts an array in two arguments: a pointer to
    the first `College` element ➊ and the number of elements `n_colleges` ➋. Within
    `print_names`, you iterate with a `for` loop and an index `i`. The value of `i`
    iterates from `0` to `n_colleges-1` ➌.'
  prefs: []
  type: TYPE_NORMAL
- en: You extract the corresponding college name by accessing the `i`th element ➍
    and then get the `name` member ➎.
  prefs: []
  type: TYPE_NORMAL
- en: This pointer-plus-size approach to passing arrays is ubiquitous in C-style APIs,
    for example, in Windows or Linux system programming.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pointer Arithmetic**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'To obtain the address of the `n`th element of an array, you have two options.
    First, you can take the direct approach of obtaining the `n`th element with square
    brackets (`[]`) and then use the address-of (`&`) operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*Pointer arithmetic*, the set of rules for addition and subtraction on pointers,
    provides an alternate approach. When you add or subtract integers to pointers,
    the compiler figures out the correct byte offset using the size of the pointed-to
    type. For example, adding 4 to a `uint64_t` pointer adds 32 bytes: a `uint64_t`
    takes up 8 bytes, so 4 of them take up 32 bytes. The following is therefore equivalent
    to the previous option of obtaining the address of the `n`th element of an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '***Pointers Are Dangerous***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It’s not possible to convert a pointer to an array, which is a good thing. You
    shouldn’t need to, and besides it wouldn’t be possible in general for a compiler
    to recover the size of the array from a pointer. But the compiler can’t save you
    from all the dangerous things you might try to do.
  prefs: []
  type: TYPE_NORMAL
- en: '**Buffer Overflows**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: For arrays and pointers, you can access arbitrary array elements with the bracket
    operator (`[]`) or with pointer arithmetic. These are very powerful tools for
    low-level programming because you can interact with memory more or less without
    abstraction. This gives you exquisite control over the system, which you need
    in some environments (for example, in system programming contexts like implementing
    network protocols or with embedded controllers). With great power comes great
    responsibility, however, and you must be very careful. Simple mistakes with pointers
    can have catastrophic and mysterious consequences.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-6](ch03.xhtml#ch03ex06) performs low-level manipulation on two strings.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-6: A program containing a buffer overflow*'
  prefs: []
  type: TYPE_NORMAL
- en: After initializing the strings `lower` and `upper`, you initialize `upper_ptr`
    pointing to the first element ➊ in `upper`. You then reassign the fourth elements
    of both `lower` and `upper` (the question marks) to `d` and `D` ➋ ➌. Notice that
    `lower` is an array and `upper_ptr` is a pointer, but the mechanism is the same.
    So far, so good.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you make a major boo-boo by writing out-of-bounds memory ➎. By accessing
    the element at index `7` ➍, you’ve gone past the storage allotted to `lower`.
    No bounds checking occurs; this code compiles without warning.
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, you get *undefined behavior*. Undefined behavior means the C++ language
    specification doesn’t prescribe what happens, so your program might crash, open
    a security vulnerability, or spawn an artificial general intelligence ➎.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Connection Between Brackets and Pointer Arithmetic**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To understand the ramifications of out-of-bounds access, you must understand
    the connection between bracket operators and pointer arithmetic. Consider that
    you could have written [Listing 3-6](ch03.xhtml#ch03ex06) with pointer arithmetic
    and dereference operators rather than bracket operators, as demonstrated in [Listing
    3-7](ch03.xhtml#ch03ex07).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-7: An equivalent program to [Listing 3-6](ch03.xhtml#ch03ex06) that
    uses pointer arithmetic*'
  prefs: []
  type: TYPE_NORMAL
- en: The `lower` array has length 6 (the letters *a*–*e* plus a null terminator).
    It should now be clear why assigning `lower[7]` ➊ is perilous. In this case, you’re
    writing to some memory that doesn’t belong to `lower`. This can result in access
    violations, program crashes, security vulnerabilities, and corrupted data. These
    kinds of errors can be very insidious, because the point at which the bad write
    occurs might be far removed from the point at which the bug manifests.
  prefs: []
  type: TYPE_NORMAL
- en: '***void Pointers and std::byte Pointers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Sometimes the pointed-to type is irrelevant. In such situations, you use the
    *void pointer* `void*`. The `void` pointers have important restrictions, the principal
    of which is that you cannot dereference a `void*`. Because the pointed-to type
    has been erased, dereferencing makes no sense (recall that the set of values for
    `void` objects is empty). For similar reasons, C++ forbids `void` pointer arithmetic.
  prefs: []
  type: TYPE_NORMAL
- en: Other times, you want to interact with raw memory at the byte level. Examples
    include low-level operations like copying raw data between files and memory, encryption,
    and compression. You cannot use a `void` pointer for such purposes because bit-wise
    and arithmetic operations are disabled. In such situations, you can use a `std::byte`
    pointer.
  prefs: []
  type: TYPE_NORMAL
- en: '***nullptr and Boolean Expressions***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pointers can have a special literal value, `nullptr`. Generally, a pointer that
    equals `nullptr` doesn’t point to anything. You could use `nullptr` to indicate,
    for example, that there’s no more memory left to allocate or that some error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Pointers have an implicit conversion to `bool`. Any value that is not `nullptr`
    converts implicitly to `true`, whereas `nullptr` converts implicitly to `false`.
    This is useful when a function returning a pointer ran successfully. A common
    idiom is that such a function returns `nullptr` in the case of failure. The canonical
    example is memory allocation.
  prefs: []
  type: TYPE_NORMAL
- en: '**References**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*References* are safer, more convenient versions of pointers. You declare references
    with the `&` declarator appended to the type name. References cannot be assigned
    to null (easily), and they cannot be *reseated* (or reassigned). These characteristics
    eliminate some bugs endemic to pointers.'
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for dealing in references is much cleaner than for pointers. Rather
    than using the member-of-pointer and dereference operators, you use references
    exactly as if they’re of the pointed-to type.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-8](ch03.xhtml#ch03ex08) features a reference argument.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-8: A program using references*'
  prefs: []
  type: TYPE_NORMAL
- en: 'You declare the `clock` argument as a `ClockOfTheLongNow` reference using the
    ampersand rather than the asterisk ➊. Within `add_year`, you use clock as if it
    were of type `ClockOfTheLongNow` ➋: there’s no need to use clumsy dereference
    and pointer-to-reference operators. First, you print the value of `year` ➌. Next,
    at the call site, you pass a `ClockOfTheLongNow` object directly into `add_year`
    ➍: there’s no need to take its address. Finally, you print the value of `year`
    again to illustrate that it has incremented ➎.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Usage of Pointers and References**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pointers and references are largely interchangeable, but both have trade-offs.
    If you must sometimes change your reference type’s value—that is, if you must
    change what your reference type refers to—you must use a pointer. Many data structures
    (including forward-linked lists, which are covered in the next section) require
    that you be able to change a pointer’s value. Because references cannot be reseated
    and they shouldn’t generally be assigned to `nullptr`, they’re sometimes not suitable.
  prefs: []
  type: TYPE_NORMAL
- en: '***Forward-Linked Lists: The Canonical Pointer-Based Data Structure***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A *forward-linked list* is a simple data structure made up of a series of elements.
    Each element holds a pointer to the next element. The last element in the linked
    list holds a `nullptr`. Inserting elements into a linked list is very efficient,
    and elements can be discontinuous in memory.[Figure 3-1](ch03.xhtml#ch03fig01)
    illustrates their layout.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig3_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-1: A linked list*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-9](ch03.xhtml#ch03ex09) demonstrates a possible implementation of
    a singly linked list element.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-9: An implementation of a linked list `Element` with an operating
    number*'
  prefs: []
  type: TYPE_NORMAL
- en: Each `element` has a pointer to the `next` element in the linked list ➊, which
    initializes to `nullptr`. You insert a new element using the `insert_after` method
    ➋. It sets the `next` member of `new_element` to the `next` of `this` ➌ and then
    sets `next` of `this` to `new_element` ➍.[Figure 3-2](ch03.xhtml#ch03fig02) illustrates
    this insertion. You haven’t changed the memory location of any `Element` objects
    in this listing; you’re only modifying pointer values.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](../images/fig3_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 3-2: Inserting an element into a linked list*'
  prefs: []
  type: TYPE_NORMAL
- en: Each `Element` also contains a `prefix` array ➎ and an `operating_number` short
    ➏.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-10](ch03.xhtml#ch03ex10) traverses a linked list of stormtroopers
    of type `Element`, printing their operating numbers along the way.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-10: A program illustrating a forward-linked list*'
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-10](ch03.xhtml#ch03ex10) initializes three stormtroopers ➊. The
    element `trooper1` is assigned the operating number TK-421, and then you insert
    it as the next element in the list ➋. The elements `trooper2` and `trooper3` have
    operating numbers FN-2187 and LS-005 and are also inserted into the list ➌➍.'
  prefs: []
  type: TYPE_NORMAL
- en: The `for` loop iterates through the linked list. First, you assign the cursor
    pointer to the address of `trooper1` ➎. This is the beginning of the list. Before
    each iteration, you make sure that `cursor` is not `nullptr` ➏. After each iteration,
    you set `cursor` to the `next` element ➐. Within the loop, you print each stormtrooper’s
    operating number ➑.
  prefs: []
  type: TYPE_NORMAL
- en: '***Employing References***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Pointers provide a lot of flexibility, but this flexibility comes at a safety
    cost. If you don’t need the flexibility of reseatability and `nullptr`, references
    are the go-to reference type.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s drive home the point that references cannot be reseated. [Listing 3-11](ch03.xhtml#ch03ex11)
    initializes an `int` reference and then attempts to reseat it with a `new_value`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-11: A program illustrating that you cannot reseat references*'
  prefs: []
  type: TYPE_NORMAL
- en: This program initializes an `int` called `original` to 100\. Then it declares
    a reference to `original` called `original_ref`. From this point on, `original_ref`
    will *always* refer to `original`. This is illustrated by printing the value of
    `original` ➊ and the value referred to by `original_ref` ➋. They’re the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you initialize another `int` called `new_value` to 200 and assign it
    to `original` ➌. Read that carefully: this assignment ➌ doesn’t reseat `original_ref`
    so that it points to `new_value`. Rather, it assigns the value of `new_value`
    to the object it points to (`original`).'
  prefs: []
  type: TYPE_NORMAL
- en: The upshot is that all of these variables—`original`, `original_ref`, and `new_value`—evaluate
    to 200 ➍➎➏.
  prefs: []
  type: TYPE_NORMAL
- en: '***this Pointers***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Remember that methods are associated with classes and that instances of classes
    are objects. When you program a method, sometimes you need to access the *current
    object*, which is the object that is executing the method.
  prefs: []
  type: TYPE_NORMAL
- en: Within method definitions, you can access the current object using the `this`
    pointer. Usually, `this` isn’t needed, because `this` is implicit when accessing
    members. But sometimes you might need to disambiguate—for example, if you declare
    a method parameter whose name collides with a member variable. For example, you
    can rewrite [Listing 3-9](ch03.xhtml#ch03ex09) to make explicit which `Element`
    you’re referring to, as demonstrated in [Listing 3-12](ch03.xhtml#ch03ex12).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-12: A rewriting of [Listing 3-9](ch03.xhtml#ch03ex09) using the
    `this` pointer*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `next` is replaced with `this->next` ➊➋. The listings are functionally
    identical.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, you need `this` to resolve ambiguity between members and arguments,
    as demonstrated in [Listing 3-13](ch03.xhtml#ch03ex13).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-13: A verbose `ClockOfTheLongNow` definition using `this`*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `year` argument ➊ has the same name as the `year` member ➌. Method arguments
    will always mask members, meaning when you type `year` within this method, it
    refers to the `year` argument ➊, not the `year` member ➌. That’s no problem: you
    disambiguate with `this` ➋.'
  prefs: []
  type: TYPE_NORMAL
- en: '***const Correctness***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The keyword `const` (short for “constant”) roughly means “I promise not to modify.”
    It’s a safety mechanism that prevents unintended (and potentially catastrophic)
    modifications of member variables. You’ll use `const` in function and class definitions
    to specify that a variable (usually a reference or a pointer) won’t be modified
    by that function or class. If code attempts to modify a `const` variable, the
    compiler will emit an error. When used correctly, `const` is one of the most powerful
    language features in all modern programming languages because it helps you to
    eliminate many kinds of common programming mistakes at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a few common usages of `const`.
  prefs: []
  type: TYPE_NORMAL
- en: '**const Arguments**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Marking an argument `const` precludes its modification within a function’s scope.
    A `const` pointer or reference provides you with an efficient mechanism to pass
    an object into a function for read-only use. The function in [Listing 3-14](ch03.xhtml#ch03ex14)
    takes a `const` pointer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-14: A function taking a `const` pointer (This code doesn’t compile.)*'
  prefs: []
  type: TYPE_NORMAL
- en: The `petruchio` function takes a `shrew` string by `const` reference ➊. You
    can read from `shrew` ➋, but attempting to write to it results in a compiler error
    ➌.
  prefs: []
  type: TYPE_NORMAL
- en: '**const Methods**'
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Marking a method `const` communicates that you promise not to modify the current
    object’s state within the `const` method. Put another way, these are read-only
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: To mark a method `const`, place the `const` keyword after the argument list
    but before the method body. For example, you could update the `ClockOfTheLongNow`
    object’s `get_year` with `const`, as demonstrated in [Listing 3-15](ch03.xhtml#ch03ex15).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-15: Updating `ClockOfTheLongNow` with `const`*'
  prefs: []
  type: TYPE_NORMAL
- en: All you need to do is place `const` between the argument list and the method
    body ➊. Had you attempted to modify `year` within `get_year`, the compiler would
    have generated an error.
  prefs: []
  type: TYPE_NORMAL
- en: Holders of `const` references and pointers cannot invoke methods that are not
    `const`, because methods that are not `const` might modify an object’s state.
  prefs: []
  type: TYPE_NORMAL
- en: The `is_leap_year` function in [Listing 3-16](ch03.xhtml#ch03ex16) takes a `const
    ClockOfTheLongNow` reference and determines whether it’s a leap year.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-16: A function for determining leap years*'
  prefs: []
  type: TYPE_NORMAL
- en: Had `get_year` not been marked a `const` method, [Listing 3-16](ch03.xhtml#ch03ex16)
    would not compile because `clock` is a `const` reference and cannot be modified
    within `is_leap_year`.
  prefs: []
  type: TYPE_NORMAL
- en: '***const Member Variables***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can mark member variables `const` by adding the keyword to the member’s
    type. The `const` member variables cannot be modified after their initialization.
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 3-17](ch03.xhtml#ch03ex17), the `Avout` class contains two member
    variables, one `const` and one not `const`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-17: An `Avout` class with a `const` member*'
  prefs: []
  type: TYPE_NORMAL
- en: The `name` member is `const`, meaning the pointed-to value cannot be modified
    ➊. On the other hand, `apert` is not `const` ➋.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, a `const Avout` reference cannot be modified, so the usual rules
    would still apply to `apert`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes you want the safety of marking a member variable `const` but would
    also like to initialize the member with arguments passed into a constructor. For
    this, you employ member initializer lists.
  prefs: []
  type: TYPE_NORMAL
- en: '***Member Initializer Lists***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Member initializer lists* are the primary mechanism for initializing class
    members. To declare a member initializer list, place a colon after the argument
    list in a constructor. Then insert one or more comma-separated *member initializers*.
    A member initializer is the name of the member followed by a braced initialization
    `{ }`. Member initializers allow you to set the value of `const` fields at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: The example in [Listing 3-18](ch03.xhtml#ch03ex18) improves [Listing 3-17](ch03.xhtml#ch03ex17)
    by introducing a member initialization list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-18: A program declaring and announcing two `Avout` objects*'
  prefs: []
  type: TYPE_NORMAL
- en: The `Avout` constructor takes two arguments, a `name` and the `year_of_apert`
    ➊. A member initializer list is added by inserting a colon ➋ followed by the names
    of each member you’re initializing ➌➎ and braced initializations ➍➏. A `const`
    method `announce` is also added to print the `Avout` constructor’s status ➐.
  prefs: []
  type: TYPE_NORMAL
- en: 'All member initializations execute before the constructor’s body. This has
    two advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It ensures validity of all members before the constructor executes, so you can
    focus on initialization logic rather than member error checking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The members initialize once. If you reassign members in the constructor, you
    potentially do extra work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*You should order the member initializers in the same order they appear in
    the class definition, because their constructors will be called in this order.*'
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of eliminating extra work, it’s time to meet `auto`.
  prefs: []
  type: TYPE_NORMAL
- en: '**auto Type Deduction**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a strongly typed language, C++ affords its compiler a lot of information.
    When you initialize elements or return from functions, the compiler can divine
    type information from context. The `auto` keyword tells the compiler to perform
    such a divination for you, relieving you from inputting redundant type information.
  prefs: []
  type: TYPE_NORMAL
- en: '***Initialization with auto***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In almost all situations, the compiler can determine the correct type of an
    object using the initialization value. This assignment contains redundant information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The compiler knows `answer` is an `int` because 42 is an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `auto` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This also works when you’re initializing with parentheses `()` and the lone
    `=`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Because you’ve committed to universal initialization with `{}` as much as possible,
    this section will say no more of these alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: Alone, all of this simple initialization help doesn’t buy you much; however,
    when types become more complicated—for example, dealing with iterators from stdlib
    containers—it really saves quite a bit of typing. It also makes your code more
    resilient to refactoring.
  prefs: []
  type: TYPE_NORMAL
- en: '***auto and Reference Types***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'It’s common to add modifiers like `&`, `*`, and `const` to `auto`. Such modifications
    add the intended meanings (reference, pointer, and `const`, respectively):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding modifiers to the `auto` declaration behaves just as you’d expect: if
    you add a modifier, the resulting type is guaranteed to have that modifier.'
  prefs: []
  type: TYPE_NORMAL
- en: '***auto and Code Refactorings***'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `auto` keyword assists in making code simpler and more resilient to refactoring.
    Consider the example in [Listing 3-19](ch03.xhtml#ch03ex19) with a range-based
    `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 3-19: An example using `auto` in a range-based `for` loop*'
  prefs: []
  type: TYPE_NORMAL
- en: If ever the type of `dwarves` changes, the assignment in the range-based `for`
    loop ➊ doesn’t need to change. The `dwarf` type will adapt to its surroundings,
    in much the same way that the dwarves of Middle Earth don’t.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, use `auto` always.
  prefs: []
  type: TYPE_NORMAL
- en: '**NOTE**'
  prefs: []
  type: TYPE_NORMAL
- en: '*There are some corner cases to using braced initialization where you might
    get surprising results, but these are few, especially after C++17 fixed some pedantic
    nonsense behavior. Prior to C++17, using `auto` with braces `{}` specified a special
    object called a `std::initializer_list`, which you’ll meet in [Chapter 13](ch13.xhtml#ch13).*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This chapter covered the two reference types: references and pointers. Along
    the way, you learned about the member-of-pointer operator, how pointers and arrays
    interplay, and `void`/`byte` pointers. You also learned about the meaning of `const`
    and its basic usage, the `this` pointer, and member initializer lists. Additionally,
    the chapter introduced `auto` type deduction.'
  prefs: []
  type: TYPE_NORMAL
- en: '**EXERCISES**'
  prefs: []
  type: TYPE_NORMAL
- en: '**3-1.** Read about CVE-2001-0500, a buffer overflow in Microsoft’s Internet
    Information Services. (This vulnerability is commonly referred to as the Code
    Red worm vulnerability.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**3-2.** Add a `read_from` and a `write_to` function to [Listing 3-6](ch03.xhtml#ch03ex06).
    These functions should read or write to `upper` or `lower` as appropriate. Perform
    bounds checking to prevent buffer overflows.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3-3.** Add an `Element* previous` to [Listing 3-9](ch03.xhtml#ch03ex09) to
    make a *doubly linked list*. Add an `insert_before` method to `Element`. Traverse
    the list from front to back, then from back to front, using two separate `for`
    loops. Print the `operating_number` inside each loop.'
  prefs: []
  type: TYPE_NORMAL
- en: '**3-4.** Reimplement [Listing 3-11](ch03.xhtml#ch03ex11) using no explicit
    types. (Hint: use `auto`.)'
  prefs: []
  type: TYPE_NORMAL
- en: '**3-5.** Scan the listings in [Chapter 2](ch02.xhtml#ch02). Which methods could
    be marked `const`? Where could you use `auto` ?'
  prefs: []
  type: TYPE_NORMAL
- en: '**FURTHER READING**'
  prefs: []
  type: TYPE_NORMAL
- en: '*The C++ Programming Language*, 4th Edition, by Bjarne Stroustrup (Pearson
    Education, 2013)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “C++ Core Guidelines” by Bjarne Stroustrup and Herb Sutter (*[https://github.com/isocpp/CppCoreGuidelines/](https://github.com/isocpp/CppCoreGuidelines/)*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “East End Functions” by Phil Nash (2018; *[https://levelofindirection.com/blog/east-end-functions.html](https://levelofindirection.com/blog/east-end-functions.html)*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “References FAQ” by the Standard C++ Foundation (*[https://isocpp.org/wiki/faq/references/](https://isocpp.org/wiki/faq/references/)*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
