["```\n#include <sys/wait.h>\n\npid_t `wait`(int **status*);\n```", "```\nwhile ((childPid = wait(NULL)) != -1)\n    continue;\nif (errno != ECHILD)                /* An unexpected error... */\n    errExit(\"wait\");\n```", "```\n$ `./multi_wait 7 1 4`\n[13:41:00] child 1 started with PID 21835, sleeping 7 seconds\n[13:41:00] child 2 started with PID 21836, sleeping 1 seconds\n[13:41:00] child 3 started with PID 21837, sleeping 4 seconds\n[13:41:01] wait() returned child PID 21836 (numDead=1)\n[13:41:04] wait() returned child PID 21837 (numDead=2)\n[13:41:07] wait() returned child PID 21835 (numDead=3)\nNo more children - bye!\n```", "```\n`procexec/multi_wait.c`\n#include <sys/wait.h>\n#include <time.h>\n#include \"curr_time.h\"              /* Declaration of currTime() */\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int numDead;       /* Number of children so far waited for */\n    pid_t childPid;    /* PID of waited for child */\n    int j;\n\n    if (argc < 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s sleep-time...\\n\", argv[0]);\n\n    setbuf(stdout, NULL);           /* Disable buffering of stdout */\n\n    for (j = 1; j < argc; j++) {    /* Create one child for each argument */\n        switch (fork()) {\n        case -1:\n            errExit(\"fork\");\n\n        case 0:                     /* Child sleeps for a while then exits */\n            printf(\"[%s] child %d started with PID %ld, sleeping %s \"\n                    \"seconds\\n\", currTime(\"%T\"), j, (long) getpid(), argv[j]);\n            sleep(getInt(argv[j], GN_NONNEG, \"sleep-time\"));\n            _exit(EXIT_SUCCESS);\n\n        default:                    /* Parent just continues around loop */\n            break;\n        }\n    }\n\n    numDead = 0;\n    for (;;) {                      /* Parent waits for each child to exit */\n        childPid = wait(NULL);\n        if (childPid == -1) {\n            if (errno == ECHILD) {\n                printf(\"No more children - bye!\\n\");\n                exit(EXIT_SUCCESS);\n            } else {                /* Some other (unexpected) error */\n                errExit(\"wait\");\n            }\n        }\n\n        numDead++;\n        printf(\"[%s] wait() returned child PID %ld (numDead=%d)\\n\",\n                currTime(\"%T\"), (long) childPid, numDead);\n    }\n}\n     `procexec/multi_wait.c`\n```", "```\n#include <sys/wait.h>\n\npid_t `waitpid`(pid_t *pid*, int **status*, int *options*);\n```", "```\n`procexec/print_wait_status.c`\n#define _GNU_SOURCE     /* Get strsignal() declaration from <string.h> */\n#include <string.h>\n#include <sys/wait.h>\n#include \"print_wait_status.h\"  /* Declaration of printWaitStatus() */\n#include \"tlpi_hdr.h\"\n\n/* NOTE: The following function employs printf(), which is not\n   async-signal-safe (see Section 21.1.2). As such, this function is\n   also not async-signal-safe (i.e., beware of calling it from a\n   SIGCHLD handler). */\n\nvoid                    /* Examine a wait() status using the W* macros */\nprintWaitStatus(const char *msg, int status)\n{\nif (msg != NULL)\n        printf(\"%s\", msg);\n\n    if (WIFEXITED(status)) {\n        printf(\"child exited, status=%d\\n\", WEXITSTATUS(status));\n\n    } else if (WIFSIGNALED(status)) {\n        printf(\"child killed by signal %d (%s)\",\n                WTERMSIG(status), strsignal(WTERMSIG(status)));\n#ifdef WCOREDUMP        /* Not in SUSv3, may be absent on some systems */\n        if (WCOREDUMP(status))\n            printf(\" (core dumped)\");\n#endif\n        printf(\"\\n\");\n\n    } else if (WIFSTOPPED(status)) {\n        printf(\"child stopped by signal %d (%s)\\n\",\n                WSTOPSIG(status), strsignal(WSTOPSIG(status)));\n\n#ifdef WIFCONTINUED     /* SUSv3 has this, but older Linux versions and\n                           some other UNIX implementations don't */\n    } else if (WIFCONTINUED(status)) {\n        printf(\"child continued\\n\");\n#endif\n\n    } else {            /* Should never happen */\n        printf(\"what happened to this child? (status=%x)\\n\",\n                (unsigned int) status);\n    }\n}\n\n     `procexec/print_wait_status.c`\n```", "```\n$ `./child_status 23`\nChild started with PID = 15807\nwaitpid() returned: PID=15807; status=0x1700 (23,0)\nchild exited, status=23\n```", "```\n$ `./child_status &`\n[1] 15870\n$ Child started with PID = 15871\n`kill -STOP 15871`\n$ waitpid() returned: PID=15871; status=0x137f (19,127)\nchild stopped by signal 19 (Stopped (signal))\n`kill -CONT 15871`\n$ waitpid() returned: PID=15871; status=0xffff (255,255)\nchild continued\n```", "```\n`kill -ABRT 15871`\n$ waitpid() returned: PID=15871; status=0x0006 (0,6)\nchild killed by signal 6 (Aborted)\n*Press Enter, in order to see shell notification that background job has terminated*\n[1]+  Done              ./child_status\n$ `ls -l core`\nls: core: No such file or directory\n$ `ulimit -c`                                    *Display* RLIMIT_CORE *limit*\n0\n```", "```\n$ `ulimit -c unlimited`                           *Allow core dumps*\n$ `./child_status &`\n[1] 15902\n$ Child started with PID = 15903\n`kill -ABRT 15903`                                *Send* SIGABRT *to child*\n$ waitpid() returned: PID=15903; status=0x0086 (0,134)\nchild killed by signal 6 (Aborted) (core dumped)\n*Press Enter, in order to see shell notification that background job has terminated*\n[1]+  Done              ./child_status\n$ `ls -l core`                                   *This time we get a core dump*\n-rw-------   1 mtk      users       65536 May  6 21:01 core\n```", "```\n`procexec/child_status.c`\n#include <sys/wait.h>\n#include \"print_wait_status.h\"          /* Declares printWaitStatus() */\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int status;\n    pid_t childPid;\nif (argc > 1 && strcmp(argv[1], \"—help\") == 0)\n        usageErr(\"%s [exit-status]\\n\", argv[0]);\n\n    switch (fork()) {\n    case -1: errExit(\"fork\");\n\n    case 0:             /* Child: either exits immediately with given\n                           status or loops waiting for signals */\n        printf(\"Child started with PID = %ld\\n\", (long) getpid());\n        if (argc > 1)                   /* Status supplied on command line? */\n            exit(getInt(argv[1], 0, \"exit-status\"));\n        else                            /* Otherwise, wait for signals */\n            for (;;)\n                pause();\n        exit(EXIT_FAILURE);             /* Not reached, but good practice */\n\n    default:            /* Parent: repeatedly wait on child until it\n                           either exits or is terminated by a signal */\n        for (;;) {\n            childPid = waitpid(-1, &status, WUNTRACED\n#ifdef WCONTINUED       /* Not present on older versions of Linux */\n                                                | WCONTINUED\n#endif\n                    );\n            if (childPid == -1)\n                errExit(\"waitpid\");\n\n            /* Print status in hex, and as separate decimal bytes */\n\n            printf(\"waitpid() returned: PID=%ld; status=0x%04x (%d,%d)\\n\",\n                    (long) childPid,\n                    (unsigned int) status, status >> 8, status & 0xff);\n            printWaitStatus(NULL, status);\n\n            if (WIFEXITED(status) || WIFSIGNALED(status))\n                exit(EXIT_SUCCESS);\n        }\n    }\n}\n      `procexec/child_status.c`\n```", "```\nvoid\nhandler(int sig)\n{\n    /* Perform cleanup steps */\n\n    signal(sig, SIG_DFL);            /* Disestablish handler */\n    raise(sig);                      /* Raise signal again */\n}\n```", "```\n#include <sys/wait.h>\n\nint `waitid`(idtype_t *idtype*, id_t *id*, siginfo_t **infop*, int *options*);\n```", "```\nsiginfo_t info;\n...\nmemset(&info, 0, sizeof(siginfo_t));\nif (waitid(idtype, id, &info, options | WNOHANG) == -1)\n    errExit(\"waitid\");\nif (info.si_pid == 0) {\n    /* No children changed state */\n} else {\n    /* A child changed state; details are provided in 'info' */\n}\n```", "```\n#define _BSD_SOURCE       /* Or #define _XOPEN_SOURCE 500 for wait3() */\n#include <sys/resource.h>\n#include <sys/wait.h>\n\npid_t `wait3`(int **status*, int *options*, struct rusage **rusage*);\npid_t `wait4`(pid_t *pid*, int **status*, int *options*, struct rusage **rusage*);\n```", "```\nwaitpid(-1, &status, options);\n```", "```\nwaitpid(pid, &status, options);\n```", "```\n$ `./make_zombie`\nParent PID=1013\nChild (PID=1014) exiting\n 1013 pts/4    00:00:00 make_zombie                       *Output from* `ps(1)`\n 1014 pts/4    00:00:00 make_zombie <defunct>\nAfter sending SIGKILL to make_zombie (PID=1014):\n 1013 pts/4    00:00:00 make_zombie                       *Output from* `ps(1)`\n 1014 pts/4    00:00:00 make_zombie <defunct>\n```", "```\n`procexec/make_zombie.c`\n#include <signal.h>\n#include <libgen.h>             /* For basename() declaration */\n#include \"tlpi_hdr.h\"\n\n#define CMD_SIZE 200\n\nint\nmain(int argc, char *argv[])\n{\n    char cmd[CMD_SIZE];\n    pid_t childPid;\n\n    setbuf(stdout, NULL);       /* Disable buffering of stdout */\n\n    printf(\"Parent PID=%ld\\n\", (long) getpid());\n\n    switch (childPid = fork()) {\n    case -1:\n        errExit(\"fork\");\n\n    case 0:     /* Child: immediately exits to become zombie */\n        printf(\"Child (PID=%ld) exiting\\n\", (long) getpid());\n        _exit(EXIT_SUCCESS);\n\n        default:    /* Parent */\n        sleep(3);               /* Give child a chance to start and exit */\n        snprintf(cmd, CMD_SIZE, \"ps | grep %s\", basename(argv[0]));\n        cmd[CMD_SIZE - 1] = '\\0';       /* Ensure string is null-terminated */\n        system(cmd);            /* View zombie child */\n\n        /* Now send the \"sure kill\" signal to the zombie */\n\n        if (kill(childPid, SIGKILL) == -1)\n            errMsg(\"kill\");\n        sleep(3);               /* Give child a chance to react to signal */\n        printf(\"After sending SIGKILL to zombie (PID=%ld):\\n\", (long) childPid);\n        system(cmd);            /* View zombie child again */\n\n        exit(EXIT_SUCCESS);\n    }\n}\n      `procexec/make_zombie.c`\n```", "```\nwhile (waitpid(-1, NULL, WNOHANG) > 0)\n    continue;\n```", "```\n$ `./multi_SIGCHLD 1 2 4`\n16:45:18 Child 1 (PID=17767) exiting\n16:45:18 handler: Caught SIGCHLD            *First invocation of handler*\n16:45:18 handler: Reaped child 17767 - child exited, status=0\n16:45:19 Child 2 (PID=17768) exiting        *These children terminate during...*\n16:45:21 Child 3 (PID=17769) exiting        *first invocation of handler*\n16:45:23 handler: returning                 *End of first invocation of handler*\n16:45:23 handler: Caught SIGCHLD            *Second invocation of handler*\n16:45:23 handler: Reaped child 17768 - child exited, status=0\n16:45:23 handler: Reaped child 17769 - child exited, status=0\n16:45:28 handler: returning\n16:45:28 All 3 children have terminated; SIGCHLD was caught 2 times\n```", "```\n`procexec/multi_SIGCHLD.c`\n    #include <signal.h>\n    #include <sys/wait.h>\n    #include \"print_wait_status.h\"\n    #include \"curr_time.h\"\n    #include \"tlpi_hdr.h\"\n\n    static volatile int numLiveChildren = 0;\n                    /* Number of children started but not yet waited on */\n\n    static void\n    sigchldHandler(int sig)\n    {\n\n        int status, savedErrno;\n        pid_t childPid;\n\n        /* UNSAFE: This handler uses non-async-signal-safe functions\n           (printf(), printWaitStatus(), currTime(); see Section 21.1.2) */\n\n        savedErrno = errno;     /* In case we modify 'errno' */\n\n        printf(\"%s handler: Caught SIGCHLD\\n\", currTime(\"%T\"));\n\n        while ((childPid = waitpid(-1, &status, WNOHANG)) > 0) {\n\n            printf(\"%s handler: Reaped child %ld - \", currTime(\"%T\"),\n                    (long) childPid);\n            printWaitStatus(NULL, status);\n            numLiveChildren—;\n        }\n\n        if (childPid == -1 && errno != ECHILD)\n            errMsg(\"waitpid\");\n        sleep(5);               /* Artificially lengthen execution of handler */\n        printf(\"%s handler: returning\\n\", currTime(\"%T\"));\n\n        errno = savedErrno;\n    }\n\n    int\n    main(int argc, char *argv[])\n    {\n        int j, sigCnt;\n        sigset_t blockMask, emptyMask;\n        struct sigaction sa;\n\n        if (argc < 2 || strcmp(argv[1], \"—help\") == 0)\n            usageErr(\"%s child-sleep-time...\\n\", argv[0]);\n\n        setbuf(stdout, NULL);       /* Disable buffering of stdout */\n\n        sigCnt = 0;\n        numLiveChildren = argc - 1;\n\n        sigemptyset(&sa.sa_mask);\n        sa.sa_flags = 0;\n        sa.sa_handler = sigchldHandler;\n        if (sigaction(SIGCHLD, &sa, NULL) == -1)\n            errExit(\"sigaction\");\n\n        /* Block SIGCHLD to prevent its delivery if a child terminates\n           before the parent commences the sigsuspend() loop below */\n\n        sigemptyset(&blockMask);\n        sigaddset(&blockMask, SIGCHLD);\n    if (sigprocmask(SIG_SETMASK, &blockMask, NULL) == -1)\n            errExit(\"sigprocmask\");\n\n    for (j = 1; j < argc; j++) {\n            switch (fork()) {\n            case -1:\n                errExit(\"fork\");\n\n            case 0:         /* Child - sleeps and then exits */\n            sleep(getInt(argv[j], GN_NONNEG, \"child-sleep-time\"));\n                printf(\"%s Child %d (PID=%ld) exiting\\n\", currTime(\"%T\"),\n                        j, (long) getpid());\n                _exit(EXIT_SUCCESS);\n\n            default:        /* Parent - loops to create next child */\n                break;\n            }\n        }\n\n            /* Parent comes here: wait for SIGCHLD until all children are dead */\n\n        sigemptyset(&emptyMask);\n        while (numLiveChildren > 0) {\n        if (sigsuspend(&emptyMask) == -1 && errno != EINTR)\n                errExit(\"sigsuspend\");\n            sigCnt++;\n        }\n\n        printf(\"%s All %d children have terminated; SIGCHLD was caught \"\n                \"%d times\\n\", currTime(\"%T\"), argc - 1, sigCnt);\n\n        exit(EXIT_SUCCESS);\n    }\n          `procexec/multi_SIGCHLD.c`\n```"]