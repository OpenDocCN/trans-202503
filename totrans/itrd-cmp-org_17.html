<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="h2" id="ch17"><span epub:type="pagebreak" id="page_361"/><strong><span class="big">17</span><br/>DATA STRUCTURES</strong></h2>&#13;
<div class="image1"><img src="../images/pg297_Image_276.jpg" alt="Image" width="192" height="195"/></div>&#13;
<p class="noindentz">An essential part of programming is determining how best to organize data. In this chapter, we’ll cover two of the most fundamental ways of organizing data: arrays, which can be used for grouping data items of the same data type; and records, which can be used for grouping data items of different data types.</p>&#13;
<p class="indent">These ways of organizing data determine how we access the individual data items. Both require two addressing items to locate a data item. Since the data items in an array are all of the same type, we can access an individual data item if we know the name of the array and the index number of the item. Accessing an individual data item in a record requires the name of the record and the name of the data item in the record.</p>&#13;
<h3 class="h3" id="ch17lev1sec1"><strong>Arrays</strong></h3>&#13;
<p class="noindent">An <em>array</em> is a collection of data elements of the same data type, arranged in a sequence. We can access a single element in an array using the name of the array together with an <em>index value</em>, which specifies the number of the element relative to the beginning of the array. We have used <span class="literal">char</span> arrays in previous chapters to store ASCII characters as text strings. Each element in the <span epub:type="pagebreak" id="page_362"/>array was the same type, a <span class="literal">char</span>, which is 1 byte. In our earlier applications, we were accessing each character in order, so we started with a pointer to the first <span class="literal">char</span> and simply incremented it by 1 to access each subsequent <span class="literal">char</span>. We didn’t need an index to locate each <span class="literal">char</span> within the text string array.</p>&#13;
<p class="indent">In this chapter, we’ll look at <span class="literal">int</span> arrays, which use 4 bytes for each data element in the array. If we started with a pointer to the first element, we’d need to increment it by 4 to access each subsequent element; it’s much easier to use the array index number to access each individual element. You’ll see how the index number is converted to an address offset to access an array element relative to the beginning of the array. You’ll also see that C passes arrays to other functions differently from other data items.</p>&#13;
<h4 class="h4" id="ch17lev2sec1"><em><strong>In C</strong></em></h4>&#13;
<p class="noindent">We define an array in C by stating the element data type, giving the array a name, and specifying the number of elements in the array. Let’s start with the example in <a href="ch17.xhtml#ch17list1">Listing 17-1</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>fill_array.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Allocate an int array, store (2 * element number)&#13;
// in each element, and print the array contents.&#13;
&#13;
#include "twice_index.h"&#13;
#include "display_array.h"&#13;
#define N 10&#13;
&#13;
int main(void)&#13;
{&#13;
    int my_array[N];&#13;
&#13;
    twice_index(my_array, N);&#13;
    display_array(my_array, N);&#13;
&#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch17list1"><em>Listing 17-1: A program to store</em> <span class="codeitalic">int</span> <em>s in an array and display them</em></p>&#13;
<p class="indent">This <span class="literal">main</span> function calls the <span class="literal">twice_index</span> function, which sets each element in the array to twice its index. For example, <span class="literal">twice_index</span> stores the <span class="literal">int</span> 8 in array element number 4. The <span class="literal">main</span> function then calls <span class="literal">display_array</span>, which prints the contents of the entire array in the terminal window.</p>&#13;
<p class="indent">You first encountered arrays in <a href="ch02.xhtml">Chapter 2</a>, when learning about C-style strings. Those strings used a sentinel value, <span class="literal">NUL</span>, to mark the end of the array. The array we’re using here doesn’t have a sentinel value, so we need to pass the number of elements in the array to each function that processes it.</p>&#13;
<p class="indent">One thing you might notice about the arguments we’re passing to the functions is that it appears the array is being passed by value, since we give only its name in the argument list. But <span class="literal">twice_index</span> stores values in the array, so it needs to know where the array is located in memory.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_363"/>Usually, a programmer passes an input value to a function by value. But if the input consists of a large number of data items, copying them all into registers and onto the stack would be very inefficient; it makes more sense to pass by pointer. Arrays almost always have many data items, so the designers of the C language decided to always pass them by pointer. When you give the name of the array as an argument to a function call, C will pass the address of the first element of the array; thus, <span class="literal">twice_index</span> can output data to the array.</p>&#13;
<p class="indent">To see this explicitly, let’s look at the compiler-generated assembly language for this <span class="literal">main</span> function, as shown in <a href="ch17.xhtml#ch17list2">Listing 17-2</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>fill_array.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "fill_array.c"&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
     <span class="ent">➊</span> stp     x29, x30, [sp, -64]!&#13;
        mov     x29, sp&#13;
     <span class="ent">➋</span> add     x0, sp, 24            /// Address of array&#13;
        mov     w1, 10&#13;
        bl      twice_index&#13;
     <span class="ent">➌</span> add     x0, sp, 24&#13;
        mov     w1, 10&#13;
        bl      display_array&#13;
        mov     w0, 0&#13;
        ldp     x29, x30, [sp], 64&#13;
        ret&#13;
        .size   main, .-main&#13;
        .ident  "GCC: (Debian 12.2.0-14) 12.2.0"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<p class="list" id="ch17list2"><em>Listing 17-2: The compiler-generated assembly language for the function in <a href="ch17.xhtml#ch17list1">Listing 17-1</a></em></p>&#13;
<p class="indent">The entire <span class="literal">int</span> array is allocated in <span class="literal">main</span>’s stack frame <span class="ent">❶</span>. In assembly language, the address of the array is passed both to the <span class="literal">twice_index</span> function ❷ and to the <span class="literal">display_array</span> function <span class="ent">❸</span>. The elements of the array are inputs to the <span class="literal">display_array</span> function, so it does not need to know the address of the array, but it’s much more efficient to pass the address of the entire array than a copy of each of the array elements.</p>&#13;
<p class="indent">Next, we’ll look at the function to store the <span class="literal">int</span>s in the array, <span class="literal">twice_index</span>. <a href="ch17.xhtml#ch17list3">Listing 17-3</a> shows its header file.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>twice_index.h</em></p>&#13;
</div>&#13;
<pre class="pre">// Store (2 * element number) in each array element.&#13;
&#13;
#ifndef TWICE_INDEX_H&#13;
#define TWICE_INDEX_H&#13;
void twice_index(int the_array[], int n_elements);&#13;
#endif</pre>&#13;
<span epub:type="pagebreak" id="page_364"/>&#13;
<p class="list" id="ch17list3"><em>Listing 17-3: The header file for the</em> <span class="codeitalic">twice_index</span> <em>function</em></p>&#13;
<p class="indent">This prototype statement shows how we use the <span class="literal">[]</span> syntax to indicate that the argument to a function is an array. As described previously, we need to provide the number of elements in the array as a separate argument.</p>&#13;
<p class="indent">The definition of the <span class="literal">twice_index</span> function is given in <a href="ch17.xhtml#ch17list4">Listing 17-4</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>twice_index.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Store (2 * element number) in each array element.&#13;
&#13;
#include "twice_index.h"&#13;
&#13;
void twice_index(int the_array[], int n_elements)&#13;
{&#13;
    int i;&#13;
&#13;
    for (i = 0; i &lt; n_elements; i++) {&#13;
        the_array[i] = 2 * i;&#13;
    }&#13;
}</pre>&#13;
<p class="list" id="ch17list4"><em>Listing 17-4: A function to store twice the index number in each element of an array</em></p>&#13;
<p class="indent">The number of iterations is known when this loop starts, so we use a <span class="literal">for</span> loop to process the array. The compiler generated the assembly language shown in <a href="ch17.xhtml#ch17list5">Listing 17-5</a> for the <span class="literal">twice_index</span> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>twice_index.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "twice_index.c"&#13;
        .text&#13;
        .align  2&#13;
        .global twice_index&#13;
        .type   twice_index, %function&#13;
twice_index:&#13;
        sub     sp, sp, #32&#13;
        str     x0, [sp, 8]       /// Address of the_array&#13;
        str     w1, [sp, 4]       /// n_elements&#13;
        str     wzr, [sp, 28]     /// i = 0;&#13;
        b       .L2&#13;
.L3:&#13;
        ldrsw   x0, [sp, 28]&#13;
     <span class="ent">➊</span> lsl     x0, x0, 2         /// Each element is 4 bytes&#13;
        ldr     x1, [sp, 8]&#13;
     <span class="ent">➋</span> add     x0, x1, x0        /// Address of ith element&#13;
        ldr     w1, [sp, 28]&#13;
        lsl     w1, w1, 1         /// 2 * i;&#13;
        str     w1, [x0]&#13;
        ldr     w0, [sp, 28]&#13;
        add     w0, w0, 1         /// i++&#13;
        str     w0, [sp, 28]&#13;
.L2:&#13;
        ldr     w1, [sp, 28]&#13;
        ldr     w0, [sp, 4]&#13;
        cmp     w1, w0&#13;
        blt     .L3&#13;
        nop&#13;
        nop&#13;
        add     sp, sp, 32&#13;
        ret&#13;
        .size   twice_index, .-twice_index&#13;
        .ident  "GCC: (Debian 12.2.0-14) 12.2.0"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<span epub:type="pagebreak" id="page_365"/>&#13;
<p class="list" id="ch17list5"><em>Listing 17-5: The compiler-generated assembly language for the function in <a href="ch17.xhtml#ch17list4">Listing 17-4</a></em></p>&#13;
<p class="indent">To access an array element, the compiler computes the offset of the element from the beginning of the array and then adds that offset to the address of the beginning. This is an array of <span class="literal">int</span>s, so each element is 4 bytes. The compiler shifts the array index, <span class="literal">i</span>, 2 bits to the left to multiply it by 4 <span class="ent">❶</span>. Adding <span class="literal">4 * i</span> to the address of the beginning of the array gives the address of the array element <span class="ent">❷</span>.</p>&#13;
<p class="indent">Next, we’ll look at the <span class="literal">display_array</span> function used to display the contents of the array. <a href="ch17.xhtml#ch17list6">Listing 17-6</a> shows the header file for this function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>display_array.h</em></p>&#13;
</div>&#13;
<pre class="pre">// Print the int array contents.&#13;
&#13;
#ifndef DISPLAY_ARRAY_H&#13;
#define DISPLAY_ARRAY_H&#13;
void display_array(int the_array[], int n_elements);&#13;
#endif</pre>&#13;
<p class="list" id="ch17list6"><em>Listing 17-6: The header file for the</em> <span class="codeitalic">display_array</span> <em>function</em></p>&#13;
<p class="indent">As with the <span class="literal">twice_index</span> function, we use the <span class="literal">[]</span> syntax to indicate that the argument to the <span class="literal">display_array</span> function is an array. We also need to provide the number of elements in the array as a separate argument. The function definition is given in <a href="ch17.xhtml#ch17list7">Listing 17-7</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>display_array.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Print the int array contents.&#13;
&#13;
#include "display_array.h"&#13;
#include "write_str.h"&#13;
#include "write_char.h"&#13;
#include "put_int.h"&#13;
void display_array(int the_array[], int n_elements)&#13;
{&#13;
    int i;&#13;
    for (i = 0; i &lt; n_elements; i++) {&#13;
        write_str("my_array[");&#13;
        put_int(i);&#13;
        write_str("] = ");&#13;
        put_int(the_array[i]);&#13;
        write_char('\n');&#13;
    }&#13;
}</pre>&#13;
<span epub:type="pagebreak" id="page_366"/>&#13;
<p class="list" id="ch17list7"><em>Listing 17-7: A function to display</em> <span class="codeitalic">int</span> <em>s in an array</em></p>&#13;
<p class="indent">To display the integers, we’re using the <span class="literal">put_int</span> function that you wrote in “Your Turn” <a href="ch16.xhtml#ch16exe8">exercise 16.8</a> on <a href="ch16.xhtml#ch16you2">page 358</a>. <a href="ch17.xhtml#ch17list8">Listing 17-8</a> shows the compiler-generated assembly language for this function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>display_array.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "display_array.c"&#13;
        .text&#13;
        .section        .rodata&#13;
        .align  3&#13;
        .LC0:&#13;
        .string "my_array["&#13;
        .align  3&#13;
.LC1:&#13;
        .string "] = "&#13;
        .text&#13;
        .align  2&#13;
        .global display_array&#13;
        .type   display_array, %function&#13;
display_array:&#13;
        stp     x29, x30, [sp, -48]!&#13;
        mov     x29, sp&#13;
     <span class="ent">➊</span> str     x0, [sp, 24]      /// Address of the_array&#13;
        str     w1, [sp, 20]      /// n_elements&#13;
        str     wzr, [sp, 44]     /// i = 0;&#13;
        b       .L2&#13;
.L3:&#13;
        adrp    x0, .LC0&#13;
        add     x0, x0, :lo12:.LC0&#13;
        bl      write_str&#13;
        ldr     w0, [sp, 44]&#13;
        bl      put_int&#13;
        adrp    x0, .LC1&#13;
        add     x0, x0, :lo12:.LC1&#13;
        bl      write_str&#13;
        ldrsw   x0, [sp, 44]&#13;
     <span class="ent">➋</span> lsl     x0, x0, 2         /// Each element is 4 bytes&#13;
     <span class="ent">➌</span> ldr     x1, [sp, 24]      /// Address of array&#13;
        add     x0, x1, x0        /// Address of ith element&#13;
        ldr     w0, [x0]&#13;
        bl      put_int&#13;
        mov     w0, 10            /// '\n' character&#13;
        bl      write_char&#13;
        ldr     w0, [sp, 44]&#13;
        add     w0, w0, 1         /// i++&#13;
        str     w0, [sp, 44]&#13;
.L2:&#13;
        ldr     w1, [sp, 44]&#13;
        ldr     w0, [sp, 20]&#13;
        cmp     w1, w0&#13;
        blt     .L3&#13;
        nop&#13;
        nop&#13;
        ldp     x29, x30, [sp], 48&#13;
        ret&#13;
        .size   display_array, .-display_array&#13;
        .ident  "GCC: (Debian 12.2.0-14) 12.2.0"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<span epub:type="pagebreak" id="page_367"/>&#13;
<p class="list" id="ch17list8"><em>Listing 17-8: The compiler-generated assembly language for the function in <a href="ch17.xhtml#ch17list7">Listing 17-7</a></em></p>&#13;
<p class="indent">Although the array is an input to the <span class="literal">display_array</span> function, C passes the address of the array to the called function <span class="ent">❶</span> <span class="ent">❸</span>. As in the <span class="literal">twice_index</span> function, the compiler multiplies the index by 4 to get the offset of each <span class="literal">int</span> in the array <span class="ent">❷</span>. Next, I’ll demonstrate a different way to index the array elements when writing this program directly in assembly language.</p>&#13;
<h4 class="h4" id="ch17lev2sec2"><em><strong>In Assembly Language</strong></em></h4>&#13;
<p class="noindent">Our approach to the <span class="literal">fill_array</span> program will be similar to the compiler’s, but we’ll use instructions that are a little more intuitive. <a href="ch17.xhtml#ch17list9">Listing 17-9</a> shows our <span class="literal">main</span> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>fill_array.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Allocate an int array, store (2 * element number)&#13;
// in each element, and print array contents.&#13;
        .arch armv8-a&#13;
// Useful constant&#13;
        .equ    N, 10                   // Array length&#13;
// Stack frame&#13;
        .equ    my_array, 16&#13;
        .equ    FRAME, 64&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
        stp     fp, lr, [sp, -FRAME]!   // Create stack frame&#13;
        mov     fp, sp                  // Set our frame pointer&#13;
&#13;
        mov     w1, N                   // Length of array&#13;
        add     x0, sp, my_array        // Address of array&#13;
        bl      twice_index             // Fill the array&#13;
&#13;
        mov     w1, N                   // Number of elements&#13;
        add     x0, sp, my_array        // Address of array&#13;
        bl      display_array           // Print array contents&#13;
&#13;
        mov     w0, wzr                 // Return 0&#13;
        ldp     fp, lr, [sp], FRAME     // Delete stack frame&#13;
        ret</pre>&#13;
<span epub:type="pagebreak" id="page_368"/>&#13;
<p class="list" id="ch17list9"><em>Listing 17-9: The assembly language program to store</em> <span class="codeitalic">int</span> <em>s in an array and display them</em></p>&#13;
<p class="indent">This is similar to what the compiler generated in <a href="ch17.xhtml#ch17list2">Listing 17-2</a>, except that we use more meaningful names. However, we’ll use a different way to compute the address of each array element in our <span class="literal">twice_index</span> function, as shown in <a href="ch17.xhtml#ch17list10">Listing 17-10</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>twice_index.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Store (2 * element number) in each array element.&#13;
// Calling sequence:&#13;
//    x0 &lt;- address of array&#13;
//    w1 &lt;- number of array elements&#13;
//    Return 0.&#13;
        .arch armv8-a&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
        .global twice_index&#13;
        .type   twice_index, %function&#13;
twice_index:&#13;
        mov     w2, wzr                // i = 0&#13;
loop:&#13;
        add     w3, w2, w2             // 2 * i&#13;
     <span class="ent">➊</span> str     w3, [x0, w2, uxtw 2]   // Current element address&#13;
        add     w2, w2, 1              // i++&#13;
        cmp     w2, w1                 // At end?&#13;
        b.lt    loop                   // No, continue filling&#13;
&#13;
        mov     w0, wzr                // Yes, return 0&#13;
        ret</pre>&#13;
<p class="list" id="ch17list10"><em>Listing 17-10: The assembly language function to store twice the index number in each element of an array</em></p>&#13;
<p class="indent">We’re using a variant of the <span class="literal">str</span> instruction that uses a register to hold the offset from the base register instead of a constant <span class="ent">❶</span>. In our case, the <span epub:type="pagebreak" id="page_369"/>index is in a 32-bit register, <span class="literal">w2</span>, so the value needs to be extended to 64 bits before adding it to the address in the base register, <span class="literal">x0</span>. Since each element in the array is 4 bytes, the index value needs to be multiplied by 4 to give an address offset.</p>&#13;
<p class="indent">Let’s look at the load and store instructions that use a register to hold the offset from a base register:</p>&#13;
<h5 class="h5" id="ch17lev3sec1"><span class="codestrong">ldr</span><strong>—Load register, base register–relative, register offset</strong></h5>&#13;
<p class="noindentin"><span class="literal">ldr w</span><span class="codeitalic">d</span> <span class="literal">, [x</span><span class="codeitalic">b</span> <span class="literal">, w</span><span class="codeitalic">o</span> <span class="literal">,</span> <span class="codeitalic">xtnd</span> <span class="literal">{</span> <span class="codeitalic">amnt</span> <span class="literal">}]</span> loads <span class="literal">w</span><span class="codeitalic">d</span> with the 32-bit value at the memory location obtained by adding the address in <span class="literal">x</span><span class="codeitalic">b</span> and the value in <span class="literal">w</span><span class="codeitalic">o</span>, optionally shifted left 2 bits, extended to 64 bits.</p>&#13;
<p class="noindentin"><span class="literal">ldr w</span><span class="codeitalic">d</span> <span class="literal">, [x</span><span class="codeitalic">b</span> <span class="literal">, x</span><span class="codeitalic">o</span> <span class="literal">{,</span> <span class="codeitalic">xtnd</span> <span class="literal">{</span> <span class="codeitalic">amnt</span> <span class="literal">}}]</span> loads <span class="literal">w</span><span class="codeitalic">d</span> with the 32-bit value at the memory location obtained by adding the address in <span class="literal">x</span><span class="codeitalic">b</span> and the value in <span class="literal">x</span><span class="codeitalic">o</span>, optionally shifted left 2 bits.</p>&#13;
<p class="noindentin"><span class="literal">ldr x</span><span class="codeitalic">d</span> <span class="literal">, [x</span><span class="codeitalic">b</span> <span class="literal">, w</span><span class="codeitalic">o</span> <span class="literal">,</span> <span class="codeitalic">xtnd</span> <span class="literal">{</span> <span class="codeitalic">amnt</span> <span class="literal">}]</span> loads <span class="literal">x</span><span class="codeitalic">d</span> with the 64-bit value at the memory location obtained by adding the address in <span class="literal">x</span><span class="codeitalic">b</span> and the value in <span class="literal">w</span><span class="codeitalic">o</span>, optionally shifted left 3 bits, extended to 64 bits.</p>&#13;
<p class="noindentin"><span class="literal">ldr x</span><span class="codeitalic">d</span> <span class="literal">, [x</span><span class="codeitalic">b</span> <span class="literal">, x</span><span class="codeitalic">o</span> <span class="literal">{,</span> <span class="codeitalic">xtnd</span> <span class="literal">{</span> <span class="codeitalic">amnt</span> <span class="literal">}}]</span> loads <span class="literal">x</span><span class="codeitalic">d</span> with the 64-bit value at the memory location obtained by adding the address in <span class="literal">x</span><span class="codeitalic">b</span> and the value in <span class="literal">x</span><span class="codeitalic">o</span>, optionally shifted left 3 bits.</p>&#13;
<h5 class="h5" id="ch17lev3sec2"><span class="codestrong">str</span><strong>—Store register, base register–relative, register offset</strong></h5>&#13;
<p class="noindentin"><span class="literal">str w</span><span class="codeitalic">s</span> <span class="literal">, [x</span><span class="codeitalic">b</span> <span class="literal">, w</span><span class="codeitalic">o</span> <span class="literal">,</span> <span class="codeitalic">xtnd</span> <span class="literal">{</span> <span class="codeitalic">amnt</span> <span class="literal">}]</span> stores the 32-bit value in <span class="literal">w</span><span class="codeitalic">s</span> in the memory location obtained by adding the address in <span class="literal">x</span><span class="codeitalic">b</span> and the value in <span class="literal">w</span><span class="codeitalic">o</span>, optionally shifted left 2 bits, extended to 64 bits.</p>&#13;
<p class="noindentin"><span class="literal">str w</span><span class="codeitalic">s</span> <span class="literal">, [x</span><span class="codeitalic">b</span> <span class="literal">, x</span><span class="codeitalic">o</span> <span class="literal">{,</span> <span class="codeitalic">xtnd</span> <span class="literal">{</span> <span class="codeitalic">amnt</span> <span class="literal">}}]</span> stores the 32-bit value in <span class="literal">w</span><span class="codeitalic">s</span> in the memory location obtained by adding the address in <span class="literal">x</span><span class="codeitalic">b</span> and the value in <span class="literal">x</span><span class="codeitalic">o</span>, optionally shifted left 2 bits.</p>&#13;
<p class="noindentin"><span class="literal">str x</span><span class="codeitalic">s</span> <span class="literal">, [x</span><span class="codeitalic">b</span> <span class="literal">, w</span><span class="codeitalic">o</span> <span class="literal">,</span> <span class="codeitalic">xtnd</span> <span class="literal">{</span> <span class="codeitalic">amnt</span> <span class="literal">}]</span> stores the 64-bit value in <span class="literal">x</span><span class="codeitalic">s</span> in the memory location obtained by adding the address in <span class="literal">x</span><span class="codeitalic">b</span> and the value in <span class="literal">w</span><span class="codeitalic">o</span>, optionally shifted left 3 bits, extended to 64 bits.</p>&#13;
<p class="noindentin"><span class="literal">str x</span><span class="codeitalic">s</span> <span class="literal">, [x</span><span class="codeitalic">b</span> <span class="literal">, x</span><span class="codeitalic">o</span> <span class="literal">{,</span> <span class="codeitalic">xtnd</span> <span class="literal">{</span> <span class="codeitalic">amnt</span> <span class="literal">}}]</span> stores the 64-bit value in <span class="literal">x</span><span class="codeitalic">s</span> in the memory location obtained by adding the address in <span class="literal">x</span><span class="codeitalic">b</span> and the value in <span class="literal">x</span><span class="codeitalic">o</span>, optionally shifted left 3 bits.</p>&#13;
<p class="indentgt"><a href="ch17.xhtml#ch17tab1">Table 17-1</a> lists the allowable values for the <span class="codeitalic">xtnd</span> option for the <span class="literal">ldr</span> and <span class="literal">str</span> instructions.</p>&#13;
<p class="tabcap" id="ch17tab1"><strong>Table 17-1:</strong> Allowable Values for <span class="codeitalic">xtnd</span> in <span class="literal">ldr</span> and <span class="literal">str</span> Instructions</p>&#13;
<table class="table-h">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:70%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th class="tab_th"><span class="codestrongitalic">xtnd</span></th>&#13;
<th class="tab_th"><strong>Effect</strong></th></tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">uxtw</span></td>&#13;
<td class="bg1">Unsigned extension of word, optional left shift</td></tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">lsl</span></td>&#13;
<td class="bg">Left shift</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg1"><span class="literal">sxtw</span></td>&#13;
<td class="bg1">Signed extension of word, optional left shift</td>&#13;
</tr>&#13;
<tr>&#13;
<td class="bg"><span class="literal">sxtx</span></td>&#13;
<td class="bg">Left shift</td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_370"/>A 32-bit offset, <span class="literal">w</span><span class="codeitalic">o</span>, must be extended to 64 bits to be added to the address in the base register, <span class="literal">x</span><span class="codeitalic">b</span>. The <span class="literal">sxtx</span> option exists for syntactic symmetry; it has the same effect as <span class="literal">lsl</span>.</p>&#13;
<p class="indent">Allowable values for <span class="codeitalic">amnt</span> are <span class="literal">0</span> or <span class="literal">2</span> for <span class="literal">w</span><span class="codeitalic">d</span> and <span class="literal">w</span><span class="codeitalic">s</span> registers, and <span class="literal">0</span> or <span class="literal">3</span> for <span class="literal">x</span><span class="codeitalic">d</span> and <span class="literal">x</span><span class="codeitalic">s</span> registers. This allows us to multiply the value in the offset register, <span class="literal">w</span><span class="codeitalic">o</span> or <span class="literal">x</span><span class="codeitalic">o</span>, by the number of bytes in the data element we are loading or storing. This makes it easy for us to convert an array index number into an array element address offset, as we saw in <a href="ch17.xhtml#ch17list10">Listing 17-10</a><span class="ent">❶</span>.</p>&#13;
<p class="indent"><a href="ch17.xhtml#ch17list11">Listing 17-11</a> shows the function for displaying the contents of the array.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>display_array.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Display ints in an array.&#13;
// Calling sequence:&#13;
//    x0 &lt;- address of array&#13;
//    w1 &lt;- number of array elements&#13;
        .arch armv8-a&#13;
// Stack frame&#13;
        .equ    save1920, 16&#13;
        .equ    save21, 32&#13;
        .equ    FRAME, 48&#13;
// Code&#13;
        .section  .rodata&#13;
        .align  3&#13;
msg1:&#13;
        .string "my_array["&#13;
msg2:&#13;
        .string "] = "&#13;
        .text&#13;
        .align  2&#13;
        .global display_array&#13;
        .type   display_array, %function&#13;
display_array:&#13;
     <span class="ent">➊</span> stp     fp, lr, [sp, -FRAME]!     // Create stack frame&#13;
        mov     fp, sp                    // Set our frame pointer&#13;
        stp     x19, x20,  [sp, save1920] // Save regs&#13;
        str     x21, [sp, save21]&#13;
&#13;
        mov     x19, x0                   // Array address&#13;
        mov     w20, w1                   // Array size&#13;
        mov     w21, wzr                  // Array index&#13;
loop:&#13;
        adr     x0, msg1                  // Start line&#13;
        bl      write_str&#13;
        mov     w0, w21                   // Index&#13;
        bl      put_int&#13;
        adr     x0, msg2                  // More text on line&#13;
        bl      write_str&#13;
        ldr     w0, [x19, w21, uxtw 2]    // Current element&#13;
        bl      put_int&#13;
        mov     w0, '\n'                  // Finish line&#13;
        bl      write_char&#13;
        add     w21, w21, 1               // Increment index&#13;
        cmp     w21, w20                  // At end?&#13;
        b.lt    loop                      // No, continue&#13;
&#13;
        mov     w0, wzr                   // Return 0&#13;
        ldp     x19, x20,  [sp, save1920] // Restore regs&#13;
        ldr     x21, [sp, save21]&#13;
        ldp     fp, lr, [sp], FRAME       // Delete stack frame&#13;
        ret</pre>&#13;
<span epub:type="pagebreak" id="page_371"/>&#13;
<p class="list" id="ch17list11"><em>Listing 17-11: The assembly language function to display</em> <span class="codeitalic">int</span> <em>s in an array</em></p>&#13;
<p class="indent">This function uses the same basic algorithm as the <span class="literal">twice_index</span> function, but it calls other functions, so we need to create a stack record <span class="ent">❶</span>. We also need to save the <span class="literal">x19</span>, <span class="literal">x20</span>, and <span class="literal">x21</span> registers for the calling function.</p>&#13;
<p class="indent">Arrays are used to group data items of the same type. In the next section, we’ll look at how to group items of different data types.</p>&#13;
<div class="box">&#13;
<p class="box-title"><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch17exe1">17.1     Change the <span class="literal">twice_index</span> and <span class="literal">display_array</span> functions to use pass by pointer (<span class="literal">int *the_array</span>) instead of pass by array (<span class="literal">int the_array[]</span>). Compare the compiler-generated assembly language with that shown in <a href="ch17.xhtml#ch17list2">Listings 17-2</a>, <a href="ch17.xhtml#ch17list5">17-5</a>, and <a href="ch17.xhtml#ch17list8">17-8</a>.</p>&#13;
<p class="box-list1" id="ch17exe2">17.2     Modify the program in <a href="ch17.xhtml#ch17list9">Listings 17-9</a> to <a href="ch17.xhtml#ch17list11">17-11</a> to store 16 times the index number in each element of the array.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch17lev1sec2"><strong>Records</strong></h3>&#13;
<p class="noindent">A <em>record</em> (or <em>structure</em>) allows a programmer to group several data items of possibly different data types together into a new programmer-defined data type. The location of each individual data item in a record is called a <em>field</em> or <em>element</em>. You may also see a field called a <em>member</em>, especially in object-oriented programming. I’ll cover C++ objects in the next chapter.</p>&#13;
<p class="indent">Since the fields in a record can have different sizes, accessing them is a bit more complex than accessing the data items in an array. I’ll first describe how this is done in C, and then we’ll look at how records are passed to other functions.</p>&#13;
<h4 class="h4" id="ch17lev2sec3"><span epub:type="pagebreak" id="page_372"/><em><strong>In C</strong></em></h4>&#13;
<p class="noindent">Let’s start by looking at a program that defines a record, stores data in each of its fields, and then displays the values, as shown in <a href="ch17.xhtml#ch17list12">Listing 17-12</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>fill_record.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Allocate a record and assign a value to each field.&#13;
&#13;
#include &lt;stdio.h&gt;&#13;
&#13;
int main(void)&#13;
{&#13;
    struct {&#13;
     <span class="ent">➊</span> char a;&#13;
        int i;&#13;
        char b;&#13;
        int j;&#13;
        char c;&#13;
<span class="ent">➋</span> } x;&#13;
&#13;
<span class="ent">➌</span> x.a = 'a';&#13;
    x.i = 12;&#13;
    x.b = 'b';&#13;
    x.j = 34;&#13;
    x.c = 'c';&#13;
&#13;
    printf("x: %c, %i, %c, %i, %c\n", x.a, x.i,&#13;
          x.b, x.j, x.c);&#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch17list12"><em>Listing 17-12: A program to store data in a record</em></p>&#13;
<p class="indent">We use the <span class="literal">struct</span> keyword to declare a record in C. The fields of the record are declared using the usual C syntax: a data type followed by the field name <span class="ent">❶</span>. The entire sequence, starting with the <span class="literal">struct</span> keyword through the ending <span class="literal">}</span> bracket, defines a new data type <span class="ent">❷</span>. We define a record variable by following this data type with a name for the variable. The individual fields of a record are accessed with the dot operator followed by the field name <span class="ent">❸</span>.</p>&#13;
<p class="indent">We can learn how the record is stored in memory by looking at the assembly language the compiler generates for this function, which is shown in <a href="ch17.xhtml#ch17list13">Listing 17-13</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>fill_record.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "fill_record.c"&#13;
        .text&#13;
        .section        .rodata&#13;
        .align  3&#13;
.LC0:&#13;
        .string "x: %c, %i, %c, %i, %c\n"&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
        stp     x29, x30, [sp, -48]!&#13;
        mov     x29, sp&#13;
        mov     w0, 97&#13;
     <span class="ent">➊</span> strb    w0, [sp, 24]    /// x.a = 'a';&#13;
        mov     w0, 12&#13;
     <span class="ent">➋</span> str     w0, [sp, 28]    /// x.i = 12;&#13;
        mov     w0, 98&#13;
        strb    w0, [sp, 32]    /// x.b = 'b';&#13;
        mov     w0, 34&#13;
        str     w0, [sp, 36]    /// x.j = 34;&#13;
        mov     w0, 99&#13;
        strb    w0, [sp, 40]    /// x.c = 'c';&#13;
        ldrb    w0, [sp, 24]&#13;
        mov     w6, w0&#13;
        ldr     w0, [sp, 28]&#13;
        ldrb    w1, [sp, 32]&#13;
        mov     w3, w1&#13;
        ldr     w1, [sp, 36]&#13;
        ldrb    w2, [sp, 40]&#13;
        mov     w5, w2&#13;
        mov     w4, w1&#13;
        mov     w2, w0&#13;
        mov     w1, w6&#13;
        adrp    x0, .LC0&#13;
        add     x0, x0, :lo12:.LC0&#13;
        bl      printf&#13;
        mov     w0, 0&#13;
        ldp     x29, x30, [sp], 48&#13;
        ret&#13;
        .size   main, .-main&#13;
        .ident  "GCC: (Debian 12.2.0-14) 12.2.0"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<span epub:type="pagebreak" id="page_373"/>&#13;
<p class="list" id="ch17list13"><em>Listing 17-13: The compiler-generated assembly language for the</em> <span class="codeitalic">main</span> <em>function in <a href="ch17.xhtml#ch17list12">Listing 17-12</a></em></p>&#13;
<p class="indent">Like other local variables, the record is allocated in the function’s stack frame. The individual fields in the record are accessed by offsets from the stack pointer <span class="ent">❶</span>. <a href="ch17.xhtml#ch17fig1">Figure 17-1</a> shows the stack frame used by the compiler for this <span class="literal">main</span> function.</p>&#13;
<span epub:type="pagebreak" id="page_374"/>&#13;
<div class="image"><img id="ch17fig1" src="../images/pg402_Image_287.jpg" alt="Image" width="438" height="259"/></div>&#13;
<p class="figcap"><em>Figure 17-1: The stack frame for fields in a record</em></p>&#13;
<p class="indent">You learned in <a href="ch12.xhtml">Chapter 12</a> that the <span class="literal">ldr</span> and <span class="literal">str</span> instructions encode the word offset (see the discussion following <a href="ch12.xhtml#ch12fig1">Figures 12-1</a> and <a href="ch12.xhtml#ch12fig2">12-2</a>), so the <span class="literal">i</span> and <span class="literal">j</span> fields must each be aligned to a 4-byte word boundary <span class="ent">❷</span>. Each of the <span class="literal">a</span>, <span class="literal">b</span>, and <span class="literal">c</span> fields is placed in the low-order bytes of the words at the offsets 24, 32, and 40, respectively.</p>&#13;
<p class="indent">The <span class="literal">struct</span> occupies 20 bytes in the stack frame. The blank areas you see in <a href="ch17.xhtml#ch17fig1">Figure 17-1</a> are unused bytes in the <span class="literal">struct</span>. The gray areas are unused bytes in the stack frame.</p>&#13;
<p class="indent">Passing a record to another function raises additional issues. As you have seen, we need to specify the type of data we’re passing, but a record can have many fields, each of which can have a different data type. Next, you’ll see how C solves this problem.</p>&#13;
<p class="indent">Defining the fields every time we define another instance of a record is cumbersome. C allows us to define our own <span class="literal">struct</span> types using a <em>structure tag</em> (or simply <em>tag</em>), which serves as a synonym for the field definitions. This is not only useful for defining multiple records of the same field composition but also necessary for passing records to other functions.</p>&#13;
<p class="indent">For example, we defined the <span class="literal">struct</span> variable <span class="literal">x</span> in <a href="ch17.xhtml#ch17list12">Listing 17-12</a> as follows:</p>&#13;
<pre class="pre">struct {&#13;
    char a;&#13;
    int i;&#13;
    char b;&#13;
    int j;&#13;
    char c;&#13;
} x;</pre>&#13;
<p class="indent">Instead, we can create a tag for the fields in the <span class="literal">struct</span>, like this:</p>&#13;
<pre class="pre">struct chars_and_ints {&#13;
    char a;&#13;
    int i;&#13;
    char b;&#13;
    int j;&#13;
    char c;&#13;
};</pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_375"/>Now that we have created a name for our programmer-defined data type, <span class="literal">struct chars_and_ints</span>, we can define its variables in the usual way:</p>&#13;
<pre class="pre">struct chars_and_ints x;</pre>&#13;
<p class="indent">We’ll start by declaring our new <span class="literal">struct</span> data type in a separate header file, as shown in <a href="ch17.xhtml#ch17list14">Listing 17-14</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>my_record.h</em></p>&#13;
</div>&#13;
<pre class="pre">// Declare a record.&#13;
&#13;
#ifndef MY_RECORD_H&#13;
#define MY_RECORD_H&#13;
struct chars_and_ints {&#13;
    char a;&#13;
    int i;&#13;
    char b;&#13;
    int j;&#13;
    char c;&#13;
};&#13;
#endif</pre>&#13;
<p class="list" id="ch17list14"><em>Listing 17-14: A record tag</em></p>&#13;
<p class="indent">We include this header file in any file where we want to define a <span class="literal">struct chars_and_ints</span> variable or function parameter.</p>&#13;
<p class="indent"><a href="ch17.xhtml#ch17list15">Listing 17-15</a> shows how we can use <span class="literal">chars_and_ints</span> to define two records in a function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>fill_records.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Allocate two records, assign a value to each field&#13;
// in each record, and display the contents.&#13;
&#13;
#include "my_record.h"&#13;
#include "load_record.h"&#13;
#include "display_record.h"&#13;
&#13;
int main(void)&#13;
{&#13;
 <span class="ent">➊</span> struct chars_and_ints x;&#13;
    struct chars_and_ints y;&#13;
&#13;
 <span class="ent">➋</span> load_record(&amp;x, 'a', 12, 'b', 34, 'c');&#13;
    load_record(&amp;y, 'd', 56, 'e', 78, 'f');&#13;
&#13;
 <span class="ent">➌</span> display_record(x);&#13;
    display_record(y);&#13;
&#13;
    return 0;&#13;
}</pre>&#13;
<p class="list" id="ch17list15"><em>Listing 17-15: A program to load data into two records and display their contents</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_376"/>The <span class="literal">struct</span> C keyword and our tag specify the data type of the record variables we’re defining <span class="ent">❶</span>. Since the <span class="literal">load_record</span> function outputs data values to the record, we need to pass the address of the record <span class="ent">❷</span>. The record is an input to the <span class="literal">display_record</span> function, so we use pass by value to pass a copy of the record <span class="ent">❸</span>.</p>&#13;
<p class="indent">The compiler-generated assembly language for the <span class="literal">main</span> function in <a href="ch17.xhtml#ch17list16">Listing 17-16</a> shows the differences between passing a record by pointer to <span class="literal">load_record</span> and passing by value to <span class="literal">display_record</span>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>fill_records.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "fill_records.c"&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
     <span class="ent">➊</span> stp     x29, x30, [sp, -96]!&#13;
        mov     x29, sp&#13;
     <span class="ent">➋</span> add     x0, sp, 72        /// Pass by pointer&#13;
        mov     w5, 99&#13;
        mov     w4, 34&#13;
        mov     w3, 98&#13;
        mov     w2, 12&#13;
        mov     w1, 97&#13;
        bl      load_record&#13;
        add     x0, sp, 48&#13;
        mov     w5, 102&#13;
        mov     w4, 78&#13;
        mov     w3, 101&#13;
        mov     w2, 56&#13;
        mov     w1, 100&#13;
        bl      load_record&#13;
     <span class="ent">➌</span> add     x2, sp, 16        /// Point to temporary place&#13;
        add     x3, sp, 72        ///   and copy record there&#13;
        ldp     x0, x1, [x3]&#13;
        stp     x0, x1, [x2]&#13;
        ldr     w0, [x3, 16]&#13;
        str     w0, [x2, 16]&#13;
     <span class="ent">➍</span> add     x0, sp, 16&#13;
        bl      display_record   /// Pass temp place by pointer&#13;
        add     x2, sp, 16&#13;
        add     x3, sp, 48&#13;
        ldp     x0, x1, [x3]&#13;
        stp     x0, x1, [x2]&#13;
        ldr     w0, [x3, 16]&#13;
        str     w0, [x2, 16]&#13;
        add     x0, sp, 16&#13;
        bl      display_record&#13;
        mov     w0, 0&#13;
        ldp     x29, x30, [sp], 96&#13;
        ret&#13;
        .size   main, .-main&#13;
        .ident  "GCC: (Debian 12.2.0-14) 12.2.0"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<span epub:type="pagebreak" id="page_377"/>&#13;
<p class="list" id="ch17list16"><em>Listing 17-16: The compiler-generated assembly language for the</em> <span class="codeitalic">main</span> <em>function in <a href="ch17.xhtml#ch17list15">Listing 17-15</a></em></p>&#13;
<p class="indent">The <span class="literal">load_record</span> function will output data to the <span class="literal">struct</span>, so it’s passed by pointer <span class="ent">❷</span>. As we saw in <a href="ch17.xhtml#ch17list2">Listing 17-2</a>, C uses pass by pointer when we pass the name of an array to a function even when it’s an input, because arrays are typically large. Records can also be large, but this is less common than with arrays, so C uses pass by value when we pass the name of a <span class="literal">struct</span> to a function. However, the procedure call standard states that if a <span class="literal">struct</span> is over 16 bytes, it must be copied to memory and the copy passed by pointer.</p>&#13;
<p class="indent"><a href="ch17.xhtml#ch17fig1">Figure 17-1</a> shows that the size of our <span class="literal">struct</span> is 20 bytes. The compiler has allocated extra memory in the stack frame for this copy <span class="ent">❶</span>. Our <span class="literal">main</span> function makes a copy of the <span class="literal">struct</span> <span class="ent">❸</span> and passes a pointer to the copy as an input to the <span class="literal">load_record</span> function <span class="ent">❹</span>.</p>&#13;
<p class="indent">Let’s look at the <span class="literal">load_record</span> function, whose header file is shown in <a href="ch17.xhtml#ch17list17">Listing 17-17</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>load_record.h</em></p>&#13;
</div>&#13;
<pre class="pre">// Load a record with data.&#13;
&#13;
#ifndef LOAD_RECORD_H&#13;
#define LOAD_RECORD_H&#13;
#include "my_record.h"&#13;
int load_record(struct chars_and_ints *a_record, char x, int y, char z);&#13;
#endif</pre>&#13;
<p class="list" id="ch17list17"><em>Listing 17-17: The header file for the function to load data into a record</em></p>&#13;
<p class="indent"><a href="ch17.xhtml#ch17list18">Listing 17-18</a> shows the definition of the <span class="literal">load_record</span> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>load_record.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Load a record with data.&#13;
&#13;
#include "load_record.h"&#13;
&#13;
void load_record(struct chars_and_ints *a_record, char v, int w,&#13;
                 char x, int y, char z)&#13;
{&#13;
 <span class="ent">➊</span> (*a_record).a = v;&#13;
 <span class="ent">➋</span> a_record-&gt;b = x;     // Equivalent syntax&#13;
    a_record-&gt;c = z;&#13;
    a_record-&gt;i = w;&#13;
    a_record-&gt;j = y;&#13;
}</pre>&#13;
<p class="list" id="ch17list18"><em>Listing 17-18: A function to load data into a record</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_378"/>The parentheses are required to dereference the <span class="literal">a_record</span> pointer variable before the field selection because the field selection operator (<span class="literal">.</span>) has a higher precedence than the dereference operator (<span class="literal">*</span>) in C <span class="ent">❶</span>. Without them, <span class="literal">*a_record.a</span> means <span class="literal">*(a_record.a)</span>. Pointers to records are so common that C provides the equivalent <span class="literal">-&gt;</span> syntax to dereference the record pointer first and then select a field <span class="ent">❷</span>.</p>&#13;
<p class="indent"><a href="ch17.xhtml#ch17list19">Listing 17-19</a> shows the assembly language the compiler generated for our <span class="literal">load_record</span> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>load_record.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "load_record.c"&#13;
        .text&#13;
        .align  2&#13;
        .global load_record&#13;
        .type   load_record, %function&#13;
load_record:&#13;
     <span class="ent">➊</span> sub     sp, sp, #32&#13;
        str     x0, [sp, 24]    /// a_record address&#13;
        strb    w1, [sp, 23]    /// v&#13;
        str     w2, [sp, 16]    /// w&#13;
        strb    w3, [sp, 22]    /// x&#13;
        str     w4, [sp, 12]    /// y&#13;
        strb    w5, [sp, 21]    /// z&#13;
        ldr     x0, [sp, 24]    /// Load a_record address&#13;
        ldrb    w1, [sp, 23]    /// Load v&#13;
        strb    w1, [x0]        /// Store in record field&#13;
     <span class="ent">➋</span> ldr     x0, [sp, 24]    /// Load a_record address&#13;
        ldrb    w1, [sp, 22]    /// Load X&#13;
        strb    w1, [x0, 8]     /// Store in record field&#13;
        ldr     x0, [sp, 24]&#13;
        ldrb    w1, [sp, 21]&#13;
        strb    w1, [x0, 16]&#13;
        ldr     x0, [sp, 24]    /// Load a_record address&#13;
        ldr     w1, [sp, 16]    /// Load w&#13;
        str     w1, [x0, 4]     /// Store in record field&#13;
        ldr     x0, [sp, 24]&#13;
        ldr     w1, [sp, 12]&#13;
        str     w1, [x0, 12]&#13;
        nop&#13;
        add     sp, sp, 32&#13;
        ret&#13;
        .size   load_record, .-load_record&#13;
        .ident  "GCC: (Debian 12.2.0-14) 12.2.0"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<p class="list" id="ch17list19"><em>Listing 17-19: The compiler-generated assembly language for the function in <a href="ch17.xhtml#ch17list18">Listing 17-18</a></em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_379"/>This is a leaf function, so we don’t need a frame record, but the compiler created a stack frame for saving the arguments to the function <span class="ent">❶</span>. The address of the <span class="literal">struct</span> is retrieved before accessing each field <span class="ent">❷</span>.</p>&#13;
<p class="indent">Now, let’s look at the <span class="literal">display_record</span> function, whose header file is shown in <a href="ch17.xhtml#ch17list20">Listing 17-20</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>display_record.h</em></p>&#13;
</div>&#13;
<pre class="pre">// Display the contents of a record.&#13;
&#13;
#ifndef DISPLAY_RECORD_H&#13;
#define DISPLAY_RECORD_H&#13;
#include "a_record.h"&#13;
void display_record(struct chars_and_ints a_record);&#13;
#endif</pre>&#13;
<p class="list" id="ch17list20"><em>Listing 17-20: The header file for the function to display data in a record</em></p>&#13;
<p class="indent"><a href="ch17.xhtml#ch17list21">Listing 17-21</a> shows the definition of the <span class="literal">display_record</span> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>display_record.c</em></p>&#13;
</div>&#13;
<pre class="pre">// Display the contents of a record.&#13;
&#13;
#include &lt;stdio.h&gt;&#13;
#include "display_record.h"&#13;
&#13;
void display_record(struct chars_and_ints a_record)&#13;
{&#13;
    printf("%c, %i, %c, %i, %c\n", a_record.a, a_record.i, a_record.b,&#13;
          a_record.j, a_record.c);&#13;
}</pre>&#13;
<p class="list" id="ch17list21"><em>Listing 17-21: A function to display data in a record</em></p>&#13;
<p class="indent"><a href="ch17.xhtml#ch17list22">Listing 17-22</a> shows the compiler-generated assembly language for the <span class="literal">display_record</span> function.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>display_record.s</em></p>&#13;
</div>&#13;
<pre class="pre">        .arch armv8-a&#13;
        .file   "display_record.c"&#13;
        .text&#13;
        .section        .rodata&#13;
        .align  3&#13;
        .LC0:&#13;
        .string "%c, %i, %c, %i, %c\n"&#13;
        .text&#13;
        .align  2&#13;
        .global display_record&#13;
        .type   display_record, %function&#13;
display_record:&#13;
        stp     x29, x30, [sp, -32]!&#13;
        mov     x29, sp&#13;
        str     x19, [sp, 16]&#13;
     <span class="ent">➊</span> mov     x19, x0         /// Pointer to caller's copy&#13;
        ldrb    w0, [x19]&#13;
        mov     w6, w0&#13;
        ldr     w0, [x19, 4]&#13;
        ldrb    w1, [x19, 8]&#13;
        mov     w3, w1&#13;
        ldr     w1, [x19, 12]&#13;
        ldrb    w2, [x19, 16]&#13;
     <span class="ent">➋</span> mov     w5, w2          /// Arguments to printf&#13;
        mov     w4, w1&#13;
        mov     w2, w0&#13;
        mov     w1, w6&#13;
        adrp    x0, .LC0&#13;
        add     x0, x0, :lo12:.LC0&#13;
        bl      printf&#13;
        nop&#13;
        ldr     x19, [sp, 16]&#13;
        ldp     x29, x30, [sp], 32&#13;
        ret&#13;
        .size   display_record, .-display_record&#13;
        .ident  "GCC: (Debian 12.2.0-14) 12.2.0"&#13;
        .section        .note.GNU-stack,"",@progbits</pre>&#13;
<span epub:type="pagebreak" id="page_380"/>&#13;
<p class="list" id="ch17list22"><em>Listing 17-22: The compiler-generated assembly language for the function in <a href="ch17.xhtml#ch17list21">Listing 17-21</a></em></p>&#13;
<p class="indent">The compiler uses <span class="literal">x19</span> as a pointer to the caller’s copy of the <span class="literal">struct</span> <span class="ent">❶</span>. After retrieving the values in each field of the record, it loads them in the proper registers for passing to the <span class="literal">printf</span> function <span class="ent">❷</span>.</p>&#13;
<p class="indent">You’ve seen how to pass by value <span class="literal">struct</span>s that are larger than 16 bytes. Next, let’s look at passing records of less than 16 bytes. We’ll do this by rearranging the fields of the record and using assembly language.</p>&#13;
<h4 class="h4" id="ch17lev2sec4"><em><strong>In Assembly Language</strong></em></h4>&#13;
<p class="noindent">Although it’s seldom an issue, we can rearrange the fields in our record to make it a bit smaller. <a href="ch17.xhtml#ch17fig2">Figure 17-2</a> shows how we’ll place both records in the <span class="literal">main</span> function’s stack frame and where their fields are.</p>&#13;
<div class="image"><img id="ch17fig2" src="../images/pg408_Image_288.jpg" alt="Image" width="478" height="258"/></div>&#13;
<p class="figcap"><em>Figure 17-2: Two records in the stack frame</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_381"/>Using this diagram of the stack frame, we can design the <span class="literal">main</span> function as shown in <a href="ch17.xhtml#ch17list23">Listing 17-23</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>fill_records.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Allocate two records, assign a value to each field&#13;
// in each record, and display the contents.&#13;
        .arch armv8-a&#13;
// Stack frame&#13;
        .equ    x, 16&#13;
     <span class="ent">➊</span> .equ    y, 32&#13;
        .equ    FRAME, 48&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
        .global main&#13;
        .type   main, %function&#13;
main:&#13;
        stp     fp, lr, [sp, -FRAME]!   // Create stack frame&#13;
        mov     fp, sp                  // Set our frame pointer&#13;
&#13;
        mov     w5, 'c'                 // Data to load&#13;
        mov     w4, 34&#13;
        mov     w3, 'b'&#13;
        mov     w2, 12&#13;
        mov     w1, 'a'&#13;
        add     x0, sp, x               // Address of first record&#13;
        bl      load_record             // Load values&#13;
&#13;
        mov     w5, 'f'                 // Data to load&#13;
        mov     w4, 78&#13;
        mov     w3, 'e'&#13;
        mov     w2, 56&#13;
        mov     w1, 'd'&#13;
        add     x0, sp, y               // Address of second record&#13;
        bl      load_record             // Load values&#13;
&#13;
     <span class="ent">➋</span> ldr     x0, [sp, x]             // First 8 bytes of x&#13;
        ldr     w1, [sp, x+8]           // Last 4 bytes of x&#13;
        bl      display_record          // Display x&#13;
&#13;
     <span class="ent">➌</span> ldr     x0, [sp, y]             // First 8 bytes of y&#13;
        ldr     w1, [sp, y+8]           // Last 4 bytes of y&#13;
        bl      display_record          // Display y&#13;
&#13;
        mov     w0, wzr                 // Return 0&#13;
        ldp     fp, lr, [sp], FRAME     // Delete stack frame&#13;
        ret</pre>&#13;
<p class="list" id="ch17list23"><em>Listing 17-23: The assembly language program to load and display two records</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_382"/>In <a href="ch17.xhtml#ch17fig2">Figure 17-2</a>, the record is 12 bytes long. The procedure call standard states that records less than 16 bytes long should be passed in registers. We load the entire 12 bytes of a record, including the unused memory gaps between the fields, into registers <span class="literal">x0</span> and <span class="literal">w1</span> to pass to <span class="literal">display_record</span> <span class="ent">❷</span>.</p>&#13;
<p class="indent">The <span class="literal">ldr</span> instruction requires that the offset be a multiple of the number of bytes in the destination register. When we designed the stack frame in <a href="ch17.xhtml#ch17fig2">Figure 17-2</a>, we placed the start of the <span class="literal">y</span> record on a doubleword boundary <span class="ent">❶</span> so we can pass the first 8 bytes of the record in the <span class="literal">x0</span> register <span class="ent">❸</span>.</p>&#13;
<p class="indent">Using the diagram of our stack frame in <a href="ch17.xhtml#ch17fig2">Figure 17-2</a>, we’ll place the <span class="literal">.equ</span> directives for the record field offsets in a file called <em>my_record.s</em>, as shown in <a href="ch17.xhtml#ch17list24">Listing 17-24</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>my_record.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Assembly language declaration of a record.&#13;
// This record takes 12 bytes.&#13;
        .equ    a, 0&#13;
        .equ    b, 1&#13;
        .equ    c, 2&#13;
        .equ    i, 4&#13;
        .equ    j, 8</pre>&#13;
<p class="list" id="ch17list24"><em>Listing 17-24: The field offsets for a record</em></p>&#13;
<p class="indent">We can include the <em>my_record.s</em> file in any assembly language file that uses the field names to ensure consistency. Let’s look at how this works in the <span class="literal">load_record</span> function in <a href="ch17.xhtml#ch17list25">Listing 17-25</a>.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>load_record.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Load the fields of my_record.s.&#13;
// Calling sequence:&#13;
//    x0 &lt;- address of record&#13;
//    w1 &lt;- char a&#13;
//    w2 &lt;- int x&#13;
//    w3 &lt;- char b&#13;
//    w4 &lt;- int y&#13;
//    w5 &lt;- char c&#13;
//    Returns 0&#13;
        .arch armv8-a&#13;
     <span class="ent">➊</span> .include  "my_record.s"   // Field offsets&#13;
// Code&#13;
        .text&#13;
        .align  2&#13;
        .global load_record&#13;
        .type   load_record, %function&#13;
load_record:&#13;
        strb    w1, [x0, a]       // First char&#13;
        str     w2, [x0, i]       // First int&#13;
        strb    w3, [x0, b]       // Second char&#13;
&#13;
        str     w4, [x0, j]       // Second int&#13;
        strb    w5, [x0, c]       // Third char&#13;
&#13;
        mov     w0, wzr           // Return 0&#13;
        ret</pre>&#13;
<span epub:type="pagebreak" id="page_383"/>&#13;
<p class="list" id="ch17list25"><em>Listing 17-25: The assembly language function to load data into a record</em></p>&#13;
<p class="indent">The algorithm of this function is very simple. You can see a new assembly directive here, <span class="literal">.include</span> <span class="ent">❶</span>. The argument to this directive is a filename in quotes. The text in that file is inserted at this location. The <span class="literal">.equ</span> values in <em>my_record.s</em> give the offsets to the fields in the record.</p>&#13;
<p class="indent">The procedure call standard says that when records of less than 16 bytes are passed in registers, we need to make a copy of the record in the called function. This differs from passing larger records by value, where the copy of the record is made in the calling function, with a pointer to the copy passed to the called function. We’ll place <span class="literal">display_record</span>’s copy in its stack frame, as shown in <a href="ch17.xhtml#ch17fig3">Figure 17-3</a>.</p>&#13;
<div class="image"><img id="ch17fig3" src="../images/pg411_Image_289.jpg" alt="Image" width="491" height="227"/></div>&#13;
<p class="figcap"><em>Figure 17-3: The saved</em> <span class="codeitalic">x19</span> <em>register and</em> <span class="codeitalic">record</span> <em>in a stack frame</em></p>&#13;
<p class="indent"><a href="ch17.xhtml#ch17list26">Listing 17-26</a> shows the resulting <span class="literal">display_record</span> function design.</p>&#13;
<div class="note6">&#13;
<p class="notep"><em>display_record.s</em></p>&#13;
</div>&#13;
<pre class="pre">// Display the fields of my_record.s.&#13;
//    x0 &lt;- first 8 bytes of record contents&#13;
//    w1 &lt;- remaining 4 bytes of record contents&#13;
        .arch armv8-a&#13;
        .include  "my_record.s"      // Field offsets&#13;
// Stack frame&#13;
        .equ    save19, 16&#13;
        .equ    record, 24&#13;
        .equ    FRAME, 48&#13;
// Code&#13;
        .section  .rodata&#13;
        .align  3&#13;
separator:&#13;
        .string ", "&#13;
        .text&#13;
        .align  2&#13;
        .global display_record&#13;
        .type   display_record, %function&#13;
display_record:&#13;
        stp     fp, lr, [sp, -FRAME]! // Create stack frame&#13;
        mov     fp, sp                // Set our frame pointer&#13;
     <span class="ent">➊</span> str     x19, [sp, save19]     // Save reg&#13;
&#13;
        add     x19, sp, record       // Point to our copy&#13;
     <span class="ent">➋</span> str     x0, [x19]             // Make a copy of record&#13;
        str     w1, [x19, 8]&#13;
&#13;
        ldrb    w0, [x19, a]          // First char&#13;
        bl      write_char            // Display&#13;
        adr     x0, separator         // Field separation&#13;
        bl      write_str&#13;
        ldr     w0, [x19, i]          // First int&#13;
        bl      put_int               // Display&#13;
        adr     x0, separator         // Field separation&#13;
        bl      write_str&#13;
        ldrb    w0, [x19, b]          // Second char&#13;
        bl      write_char            // Display&#13;
        adr     x0, separator         // Field separation&#13;
        bl      write_str&#13;
        ldr     w0, [x19, j]          // Second int&#13;
        bl      put_int               // Display&#13;
        adr     x0, separator         // Field separation&#13;
        bl      write_str&#13;
        ldrb    w0, [x19, c]          // Third char&#13;
        bl      write_char            // Display&#13;
        mov     w0, '\n'              // Newline&#13;
        bl      write_char&#13;
&#13;
        mov     w0, wzr               // Return 0&#13;
        ldr     x19, [sp, save19]     // Restore reg&#13;
        ldp     fp, lr, [sp], FRAME   // Delete stack frame&#13;
        ret</pre>&#13;
<span epub:type="pagebreak" id="page_384"/>&#13;
<p class="list" id="ch17list26"><em>Listing 17-26: The assembly language function to display data in a record</em></p>&#13;
<p class="indent">The procedure call standard states that a called function needs to preserve the value in <span class="literal">x19</span>. We save its contents in our stack frame so we can use the register to point to our local copy of the record <span class="ent">❶</span>. We then store the 12 bytes in the record, 8 in <span class="literal">x0</span> and 4 in <span class="literal">w1</span>, in the memory in our stack frame to create our local copy of the record <span class="ent">❷</span>.</p>&#13;
<div class="box">&#13;
<p class="box-title"><span epub:type="pagebreak" id="page_385"/><strong>YOUR TURN</strong></p>&#13;
<p class="box-list1" id="ch17exe3">17.3     Change the order of the fields in <a href="ch17.xhtml#ch17list12">Listing 17-12</a> to group the <span class="literal">char</span> fields together, followed by the <span class="literal">int</span> fields. Recompile the program in <a href="ch17.xhtml#ch17list15">Listings 17-15</a>, <a href="ch17.xhtml#ch17list17">17-17</a>, <a href="ch17.xhtml#ch17list18">17-18</a>, <a href="ch17.xhtml#ch17list20">17-20</a>, and <a href="ch17.xhtml#ch17list21">17-21</a>. Compare the assembly language generated by the compiler with what you see in <a href="ch17.xhtml#ch17list16">Listings 17-16</a>, <a href="ch17.xhtml#ch17list19">17-19</a>, and <a href="ch17.xhtml#ch17list22">17-22</a>.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch17lev1sec3"><strong>What You’ve Learned</strong></h3>&#13;
<p class="noindentin"><strong>Arrays</strong> Collections of data items of the same data type, stored contiguously in memory.</p>&#13;
<p class="noindentin"><strong>Processing arrays</strong> The CPU has an addressing mode for accessing an array element using an index value.</p>&#13;
<p class="noindentin"><strong>Passing arrays</strong> In C, arrays are passed by pointer rather than by value.</p>&#13;
<p class="noindentin"><strong>Records</strong> Collections of data items, possibly of different data types, stored together in memory, possibly with padding for address alignment purposes.</p>&#13;
<p class="noindentin"><strong>Accessing record fields</strong> The address with offset addressing mode can be used to access a record field.</p>&#13;
<p class="noindentin"><strong>Passing records</strong> It’s often more efficient to pass a record by pointer, even when it’s an input.</p>&#13;
<p class="indentgt">In the next chapter, I’ll show you how C++ uses records to implement the object-oriented programming paradigm.<span epub:type="pagebreak" id="page_386"/></p>&#13;
</div>
</div>
</body></html>