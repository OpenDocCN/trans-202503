- en: Chapter 5. CSS Transitions and Transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we’ve created a bare-bones game with HTML, CSS, and JavaScript: we
    can fire and pop bubbles, and our user interface feels responsive. We achieved
    this through Document Object Model (DOM) manipulation with a lot of jQuery help.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore CSS transitions and transformations, which can
    improve game performance and let you create a wider range of effects, such as
    rotating and scaling elements.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of CSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CSS provides a set of transformation and transition attributes that you can
    use to animate changes to CSS properties, such as the `left` or `top` coordinates
    of an element. Rather than using JavaScript to handle animations frame by frame,
    as we’ve done so far, CSS transitions are specified in the style sheet or as styles
    attached to DOM elements. An animation is then initiated by making a single change
    to a CSS property rather than making many incremental changes to a property, as
    JavaScript animations require.
  prefs: []
  type: TYPE_NORMAL
- en: CSS animations are handled by the browser’s rendering engine rather than by
    the JavaScript interpreter, freeing up CPU time for running other JavaScript code
    and ensuring the smoothest animation possible on the device at the time. On systems
    with graphics processors, the effects are often handled entirely by the graphics
    processor, which means less work for the JavaScript code you are running and can
    reduce the load on the CPU even further, resulting in higher frame rates. As a
    result, the animation will run at the highest frame rate possible for the device
    it’s displayed on.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use CSS to add some simple transitions to user-interface elements and
    then replace our jQuery animations with transformations, and we’ll do this while
    maintaining the cross-browser compatibility that we’ve achieved thus far.
  prefs: []
  type: TYPE_NORMAL
- en: Basic CSS Transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first CSS animation we’ll focus on is the transition. A *transition* defines
    how a style property of an object should change from one state to a new one. For
    example, if we change the `left` property of a DOM element from 50 pixels to 500
    pixels, it will instantly change position on the screen. But if we specify a transition,
    we can instead make it move gradually across the screen. A CSS transition specifies
    a property or properties to animate, how the animation should take place, and
    how long the animation should take.
  prefs: []
  type: TYPE_NORMAL
- en: 'Transitions generally apply to any CSS property that has a numerical value.
    For example, animating the `left` property, as mentioned earlier, is possible
    because intermediate values between the beginning and end can be calculated. Other
    property changes, such as between `visibility : hidden` and `visibility : visible`,
    are not valid properties for a transition because intermediate values cannot be
    calculated. However, we could make an element fade in by animating the `opacity`
    property from 0 to 1.'
  prefs: []
  type: TYPE_NORMAL
- en: Colors are also valid properties to animate, because hex values are also numbers
    (each contains three pairs, and each pair represents red, green, or blue) that
    can be gradually changed from one value to another. You can find a list of all
    the properties that can be animated with transitions at *[https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties/](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties/)*.
  prefs: []
  type: TYPE_NORMAL
- en: How to Write a Transition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To animate a `div` using a transition, add a CSS `transition` property to it.
    A `transition` property includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '****CSS properties to apply the transition to****. These can be any valid CSS
    properties that you want to animate, such as `top`, `left`, `font-size`, or just
    `all`, which applies transitions to all valid property changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****Duration****. How long (in seconds) the transition will take.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****Easing****. Tells a property how fast to change over the transition duration.
    For example, an element might move from one point to another at a smooth pace,
    or it could accelerate at the beginning and then decelerate toward the end, as
    in [Figure 5-1](ch05.html#graph_showing_movement_with_no_easing_an "Figure 5-1. Graph
    showing movement with no easing and movement with easing in (at the start of the
    animation) and out (at the end)."). You can apply easing to other properties you
    want to change, too, including color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Graph showing movement with no easing and movement with easing in (at the
    start of the animation) and out (at the end).](httpatomoreillycomsourcenostarchimages2184527.png.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 5-1. Graph showing movement with no easing and movement with easing in
    (at the start of the animation) and out (at the end).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '****Start delay****. Specifies the number of seconds to wait to start the transition.
    The most common value is 0 (or empty), which means start immediately.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ll write a transition definition just like any other CSS rule, and when
    we want the transition to occur, we’ll make a change to the CSS property that
    we want to animate. To move a `div` or other HTML element smoothly across the
    screen, we set the `top` and `left` coordinates to new values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As an example, we’ll make the New Game button move down the screen. Add the
    following to *main.css*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*main.css*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `transition` definition’s first value ➊ states which property (or properties)
    the transition applies to. Using `all` applies the transition to every property;
    think of it as a wildcard. The second value ➋ is the duration of the transition
    in seconds. The third value ➌ is the easing: `ease-in-out` produces a smooth transition
    with an initial acceleration and ending deceleration. Finally, we add a delay
    ➍ of 1 second before the animation runs. The next three lines beginning at ➎ provide
    the same specification but with vendor-specific prefixes for cross-browser support.
    These are needed for older browsers; newer browsers use the unprefixed version
    once the tag definition is considered to be stable.'
  prefs: []
  type: TYPE_NORMAL
- en: To guarantee your game will run on a certain browser, always include the correct
    vendor-specific prefix. Just be sure that whenever you change a transition’s property,
    you also change it in the transition definition for each browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, the rule is simple: the browser-specific versions of `transition`
    are just copies of the regular version with one of the following prefixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-moz-` for Mozilla browsers, such as Firefox'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-webkit-` for Webkit browsers, such as Chrome and Safari'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-ms-` for Microsoft Internet Explorer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reload the page and then type the following into the JavaScript console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You should see a pause, and then the button will smoothly slide up the screen.
    The effect is more or less identical to an `animate` call, but we changed only
    the CSS value.
  prefs: []
  type: TYPE_NORMAL
- en: Delete the CSS definition for `.button` now because we’re going to apply a more
    useful effect.
  prefs: []
  type: TYPE_NORMAL
- en: Color-Changing Buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s apply transitions to spice up our user interface! We’ll animate a button
    without a single line of JavaScript; instead, we’ll use a `transition` definition
    and the `hover` pseudo-class that you’re probably familiar with for creating rollover
    button effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll add a rollover state to the New Game button with a CSS amendment.
    Add the following to *main.css* now:'
  prefs: []
  type: TYPE_NORMAL
- en: '*main.css*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `transition` definition’s first value ➊ states which property (or properties)
    the transition applies to. We’re applying it to the `background-color` property,
    which is written exactly as it would appear as a standard CSS rule. The second
    value ➋ is the length of the transition in seconds. The third value ➌ is once
    again the easing, set to `ease-in-out`.
  prefs: []
  type: TYPE_NORMAL
- en: Other types of easing include `ease`, `linear`, or just `ease-in` or `ease-out`.
    But all of these shorthand descriptions are actually aliases for specific definitions
    of `cubic-bezier`, which you can use to indicate any transition curve you like.
    The `cubic-bezier` easing function accepts four decimal numbers to define a graph;
    for example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: is identical to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Bézier curves are described by specifying the coordinates of two points that
    form the tangent line of the beginning and the end parts of the curve, respectively.
    These are shown as P1 and P2 in [Figure 5-2](ch05.html#two_points_that_specify_a_beacutezier_cu
    "Figure 5-2. The two points that specify a Bézier curve are P1 and P2.").
  prefs: []
  type: TYPE_NORMAL
- en: '![The two points that specify a Bézier curve are P1 and P2.](httpatomoreillycomsourcenostarchimages2184529.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2. The two points that specify a Bézier curve are P1 and P2.
  prefs: []
  type: TYPE_NORMAL
- en: The values specified in the CSS are the coordinates of P1 and P2, which are
    always between 0 and 1\. You won’t specify P0 and P3 because they’re always the
    origin (0,0) and (1,1), respectively. The angle of P1 and P2 from the vertical
    axis determines the slope of the curve, and the length of the lines from P0 to
    P1 and P2 to P3 determines how pronounced the curvature will be.
  prefs: []
  type: TYPE_NORMAL
- en: Unless you want a specific easing, `ease-in-out` or `linear` will often do just
    fine. But for more complex transitions, some online tools will help you create
    `cubic-bezier` curves based on visual graphs and input values. One such website
    is *[http://cubic-bezier.com/](http://cubic-bezier.com/)*, which allows you to
    tweak values and watch the animation to see how the numbers translate to a movement
    transition.
  prefs: []
  type: TYPE_NORMAL
- en: The three lines, starting after the initial transition definition at ➍, are
    vendor-specific transition definitions, which I made sure to include so the transition
    works properly in different browsers. The CSS standard is still considered a work
    in progress, and browser manufacturers have adopted their own prefixes to avoid
    potential conflicts with how the standard is implemented when it’s finalized.
  prefs: []
  type: TYPE_NORMAL
- en: 'The single-line format I’ve used so far is the most compact way to specify
    a transition, but you could also specify the properties individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I recommend sticking with the compact approach most of the time. Otherwise,
    you’d need all the CSS standard lines plus the three vendor-specific copies of
    each, which would quickly clutter your style sheet.
  prefs: []
  type: TYPE_NORMAL
- en: Reload the page and hover over the New Game button. You should see a gentle
    change in color from light to darker red. That’s a nice effect, and you didn’t
    write any JavaScript! But there’s still more you can do to add effects using CSS
    only.
  prefs: []
  type: TYPE_NORMAL
- en: Basic CSS Transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The second powerful feature of CSS we’ll look at is transformations. *Transformations*
    allow you to manipulate an object’s shape. In most browsers, it’s possible to
    transform an object in either two dimensions or three and to skew, distort, and
    rotate it in any way that can be described by a three-dimensional matrix. You
    can animate transformations with transitions or let them stand alone; for example,
    to display a button at an angle, you might let the viewer watch it rotate, or
    you might just render the button askew.
  prefs: []
  type: TYPE_NORMAL
- en: How to Write a Transformation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some simple CSS transformations include:'
  prefs: []
  type: TYPE_NORMAL
- en: Translations by (*x*,*y*) or even (*x*,*y*,*z*) coordinates in 3D
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scaling by dimensions along the *x-*, *y-*, and *z*-axes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rotating in place by an angle along any of the *x*-, *y*-, or *z*-axes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skewing along the *x*- or *y*-axis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding 3D perspective
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can transform by a 2D or even a 3D matrix. Transforming by a matrix involves
    some calculation of the math involved. If you want to explore it in more depth,
    some references are available online, such as *[https://developer.mozilla.org/en-US/docs/Web/CSS/transform/](https://developer.mozilla.org/en-US/docs/Web/CSS/transform/)*.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling a Button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we’ll make the New Game button a bit more dynamic by adding
    an enlarging effect on top of the current color change. Make the following addition
    to the `.button:hover` definition in *main.css*:'
  prefs: []
  type: TYPE_NORMAL
- en: '*main.css*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The entire transformation is primarily contained in one `transform` line ➊.
    The transformation is specified as scaling by a factor of 1.1—a size increase
    of 10 percent. The three lines that follow do the same thing but use the identical
    vendor-specific prefixes you used in the `transition` definition.
  prefs: []
  type: TYPE_NORMAL
- en: We just want to scale the New Game button, so reload the page and then mouse
    over the button again. The scaling should work but not as a smooth animation.
    Although the color still changes gradually in response to the mouse hover, the
    button’s size jumps in a single step. We’ll amend the transition definition to
    apply to the transform as well as the background color.
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this task, we could simply change the `.button` definition so the
    `transition` property affects every CSS property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This definition applies the `ease-in-out` effect to all of the button’s CSS
    properties that it’s possible to apply transitions to. Now if any of those properties
    change after the DOM is rendered, the button will be animated with a 300-millisecond
    transition effect on that property. But what if you don’t want all button animations
    to happen at the same rate?
  prefs: []
  type: TYPE_NORMAL
- en: 'In that case, you could specify multiple properties by adding a comma-separated
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This solution also minimizes side effects if we want to change any other CSS
    properties on the fly without having them animate automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you apply transitions to individual `transform` properties in CSS, you
    still need to specify vendor-specific versions within each `transition` definition.
    Therefore, the full button definition needs to be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Make this change in *main.css*, reload the page, and mouse over the button again.
    Now, both the background color and scale should change in a smooth transition.
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS transitions and transformations are useful for simple animations and especially
    for mouseover effects on user-interface elements, such as buttons. However, they’re
    useful for more than just adding a bit of sparkle to the user interface: we can
    also use them to animate sprites, including the fired bubbles in the game.'
  prefs: []
  type: TYPE_NORMAL
- en: CSS Transitions in Place of jQuery animate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, when a player fires a bubble, it leaves the firing point and moves in a
    straight line toward its destination. Any fired bubble follows a path simple enough
    that a CSS transition can handle that animation easily, and making the switch
    will remove some of the load from JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: The hard-coded CSS transition we used for the button hover effect, where the
    transition is defined in the style sheet, won’t work for bubble movement because
    the duration of the transition needs to change depending on how far the bubble
    has to move. Currently, a bubble moves at 1,000 pixels per second. So for example,
    if we want a bubble to move 200 pixels, the duration needs to be set at 200 milliseconds.
    To handle this variable duration, instead of specifying the CSS transitions in
    the style sheet, we’ll apply them at runtime with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Setting a CSS transition with jQuery uses the same syntax as setting any other
    CSS property, but we’ll need to add browser prefixes for property names. Fortunately,
    we don’t have to write four versions of the same transition for this task. Modernizr
    can take care of those prefixes for us, which actually makes it easier to create
    CSS transitions in JavaScript than in a style sheet!
  prefs: []
  type: TYPE_NORMAL
- en: However, not all older browsers support transitions, so inside *ui.js* we’ll
    first check whether CSS animations are supported and fall back to the jQuery animation
    if they’re not. Unless you’re sure that CSS transitions are supported in all of
    the browsers you’re targeting, it’s a good idea to build in a fallback option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this CSS animation involves three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the transition CSS property to the element to tell it how quickly to move
    and which property to apply the transition to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `top` and `left` properties to the coordinates we want the bubble
    to stop at.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the bubble has reached its destination, remove the CSS transition definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Amend `fireBubble` in *ui.js* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*ui.js*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We’ve moved the post-animation function—the one we want jQuery to call once
    the `animate` call has been completed—into its own named definition ➊ by assigning
    it to a variable. This function ensures that if the bubble hasn’t disappeared
    off the screen, it’s finally positioned within the board grid. This function is
    identical to the previous version in that first we check to see whether the bubble
    has a row definition ➋. If the row definition is null, the bubble missed the board
    or caused a popping event. Otherwise, the bubble needs to become part of the main
    board. In that case, we also remove ➌ the transition definition and move the bubble
    to its final position. Consequently, if we apply any CSS changes to the bubble
    in the future, an unwanted transition won’t be applied to them.
  prefs: []
  type: TYPE_NORMAL
- en: When `fireBubble` is called, we check that CSS transitions are supported using
    Modernizr ➍. If they are supported, we can add the transition CSS to the bubble
    element ➎. The transition definition will take the form
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`Modernizr.prefixed("transition")` adds any necessary vendor-specific prefixes.
    We set the transition duration to be the same as the duration passed in but divide
    it by a thousand to convert from milliseconds to seconds ➎.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if we did add a transition, we set a timeout ➏ to call `complete` when
    that transition ends. We don’t need the `setTimeout` call if a browser doesn’t
    support CSS because, in that case, we’ll use the jQuery `animate` function, which
    accepts a callback function to run once an animation completes. We need to add
    the `complete` function as a parameter to that `animate` call ➐, but essentially,
    the jQuery version of the animation is the same as before.
  prefs: []
  type: TYPE_NORMAL
- en: Refresh the page, fire a bubble, and most likely you’ll see no change in the
    game from the last time you tested it. But that just means your device could display
    the jQuery animation we asked it to before at a high enough frame rate that it’s
    indistinguishable from the CSS version. Behind the scenes, that animation is now
    being passed off to the graphics processor, if your device has one, so JavaScript
    doesn’t have to handle the processing load. In games with numerous moving elements,
    the change you just made could result in a noticeable performance increase.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantages of CSS Transitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If JavaScript has to do so much work to animate an element frame by frame, why
    not use CSS transitions wherever possible? Although CSS transitions offer a number
    of benefits, particularly when it comes to smooth animations, their usefulness
    in games is often limited by a lack of control.
  prefs: []
  type: TYPE_NORMAL
- en: CSS transitions become more cumbersome to compose as you add more animations
    to a single element. For example, if you want an element to move by 100 pixels
    over a duration of 1 second and you also resize it by 10 pixels over 2 seconds,
    you need to specify a different transition for each CSS property. More important,
    at the end of the movement transition, you’ll need to retain the CSS definition
    so the resize animation continues, which is especially difficult if you need to
    move the element again.
  prefs: []
  type: TYPE_NORMAL
- en: A second disadvantage of transitions is that although easing can alter the way
    an animation appears, movement must be in a straight line. Movement along a curve,
    as in an animation of a character jumping over something, could be generated by
    animating over many small straight line segments. But in that case, you may as
    well use JavaScript for the entire animation.
  prefs: []
  type: TYPE_NORMAL
- en: Once set in motion, CSS transitions are impossible to interrogate and change.
    The browser handles the transition and updates the element’s position as soon
    as you set the value in CSS. The element may be rendered halfway to its destination
    due to the transition, but the DOM will report that it’s already done moving.
    As a result, it is impossible to interrogate an element for its current position
    until the animation ends. If you wanted to apply a change in direction, you’d
    need to perform new calculations and rewrite your CSS transition.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you tell an element to change its left position from 50 pixels
    to 250 pixels over 2 seconds, but after 1 second you need to move it to a different
    screen position, you would first need to calculate where it sits on the screen
    after 1 second. The DOM would report its left position at 250 pixels, but we know
    that it’s at the midpoint of an animation, which would put it at 150 pixels in
    *most* cases. But if you had specified easing along a cubic Bézier curve, the
    element is unlikely to be at the midpoint and indeed may be quite far from it.
    You would need to write an equation to calculate the current left coordinate.
    This example is simpler than most because we stop the element midway, but with
    any kind of easing applied and at almost any other point along the animation path,
    calculating where an element might be drawn on the screen is no simple task.
  prefs: []
  type: TYPE_NORMAL
- en: Compare this example to animating with jQuery, in which you can just call the
    `.stop` method after 1,000 milliseconds to stop an element dead in its tracks.
    With jQuery, you can even apply a new `animate` method to set a sprite on an entirely
    new path without waiting for a previous animation to finish. CSS transformations
    and transitions work well for user-interface manipulation or for relatively simple
    straight-line movement, but they don’t provide the flexibility we need for a lot
    of in-game action.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve seen how simple and powerful CSS transitions can be, but also how their
    usefulness can be limited for in-game action. You’ve also taken a brief look at
    CSS transformations that can be used in combination with transitions to add special
    effects to buttons or other HTML elements.
  prefs: []
  type: TYPE_NORMAL
- en: One of the main advantages of CSS transitions over JavaScript animation is their
    rendering speed, but unfortunately they are not easy to work with for anything
    other than the simplest of animations. In the next chapter, we’ll look at the
    `canvas` element and see how we can animate games with greater speed and control
    than DOM-based development has given us.
  prefs: []
  type: TYPE_NORMAL
- en: Further Practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the CSS transition example in which we animated the New Game button, experiment
    with some Bézier curve easing. Think about how different values might be useful
    in game animations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a transformation matrix to flip an element from left to right to make
    it appear mirrored.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Common 2D CSS transformations include translate, rotate, scale, and skew. Which
    of these can you reproduce using a matrix transformation, and which can’t you
    reproduce?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
