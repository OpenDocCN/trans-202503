<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch10">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_195" aria-label="195"/>&#13;
<hgroup>&#13;
<h2 class="CHAPTER" id="ch10">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">10</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">RSA</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" alt="" width="401" height="386"/></figure>&#13;
<p class="TNI1">The Rivest–Shamir–Adleman (RSA) cryptosystem revolutionized cryptography when it emerged in 1977 as the first public-key encryption scheme. Whereas classical, symmetric-key encryption schemes use the same secret key to encrypt and decrypt messages, <i>public-key encryption</i> (or <i>asymmetric</i> encryption) uses two keys: a public key, which anyone who wants to encrypt messages for you can use, and a private key, which is required to decrypt messages encrypted using the public key. This magic is the reason why RSA was a real breakthrough, and 40 years later, it’s still the paragon of public-key encryption and a workhorse of internet security. (One year prior to RSA, Whitfield Diffie and Martin Hellman introduced the concept of public-key cryptography, but their scheme was able to perform key distribution only in a public-key setting.)</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_196" aria-label="196"/>RSA works by creating a <i>trapdoor permutation</i>, a function that transforms a number <i>x</i> to a number <i>y</i> in the same range, such that computing <i>y</i> from <i>x</i> is easy using the public key, but computing <i>x</i> from <i>y</i> is practically impossible unless you know the private key—the trapdoor. (Think of <i>x</i> as a plaintext and <i>y</i> as a ciphertext.)</p>&#13;
<p class="TX">In addition to encryption, you can also use RSA to build digital signatures, wherein only the owner of the private key is able to sign a message, and the public key enables anyone to verify the signature’s validity.</p>&#13;
<p class="TX">In this chapter, you’ll learn how the RSA trapdoor permutation works and why this permutation alone isn’t enough to build <i>secure</i> encryption and signatures. I also discuss RSA’s security relative to the factoring problem (see <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>), ways to implement RSA securely, and how to attack it.</p>&#13;
<p class="TX">We begin with an explanation of the basic mathematical notions behind RSA.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
<h3 class="H1" id="sec1"><span id="h1-68"/><samp class="SANS_Futura_Std_Bold_B_11">The Math Behind RSA</samp></h3>&#13;
<p class="TNI">When processing a message, whether encrypting or signing it, RSA first creates a big number from that message and processes it by performing multiplications between big numbers. Therefore, to understand how RSA works, you need to know what kind of big numbers it manipulates and how multiplication works on those numbers.</p>&#13;
<p class="TX">To encrypt or sign, RSA transforms a positive integer between 1 and <i>n</i> – 1, where <i>n</i> is a large number called the <i>modulus</i>. Such numbers, when multiplied together, yield another number that satisfies these criteria. These numbers form a group, which you denote <b>Z</b><span class="ePub-I-SUB">n</span><sup>*</sup> and call the multiplicative group of integers modulo <i>n</i>. (See the mathematical definition of a group in “<span class="Xref"><a href="chapter9.xhtml#sec12">Groups</a></span>” <span class="Xref">on page 189</span>.)</p>&#13;
<p class="TX">For example, consider the group <b>Z</b><sub>4</sub><sup>*</sup> of integers modulo 4. Recall from <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span> that a group must include an identity element (that is, 1) and that each number <i>x</i> in the group must have an inverse, a number <i>y</i> such that <i>x</i> × <i>y</i> = 1. How do you determine the set that makes up <b>Z</b><sub>4</sub><sup>*</sup>? Based on the definitions, you know that 0 is not in the group <b>Z</b><sub>4</sub><sup>*</sup> because multiplying any number by 0 can never give 1, so 0 has no inverse. The number 1 belongs to <b>Z</b><sub>4</sub><sup>*</sup> because 1 × 1 = 1, so 1 is its own inverse. However, the number 2 doesn’t belong in this group because you can’t obtain 1 by multiplying 2 with another element of <b>Z</b><sub>4</sub><sup>*</sup> (note that 2 isn’t coprime with 4, because 4 and 2 share the factor of 2). The number 3 belongs in the group <b>Z</b><sub>4</sub><sup>*</sup> because it is its own inverse within <b>Z</b><sub>4</sub><sup>*</sup>. Thus, you have <b>Z</b><sub>4</sub><sup>*</sup> = {1, 3}.</p>&#13;
<p class="TX">Now consider <b>Z</b><sub>5</sub><sup>*</sup>, the multiplicative group of integers modulo 5. As in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>, <b>Z</b><sub>5</sub><sup>*</sup> = {1, 2, 3, 4}. Indeed, 5 being prime, 1, 2, 3, and 4 are all coprime with 5, so the set of <b>Z</b><sub>5</sub><sup>*</sup> includes all of them. Let’s verify this: 2 × 3 mod 5 = 1; therefore, 2 is 3’s inverse, and 3 is 2’s inverse; note that 4 is its own inverse because 4 × 4 mod 5 = 1; and finally, 1 is again its own inverse in the group.</p>&#13;
<p class="TX">To find the number of elements in a group <b>Z</b><span class="ePub-I-SUB">n</span><sup>*</sup> when <i>n</i> isn’t prime, you can use <i>Euler’s totient function</i>, which we write as <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>), with <span class="greek"><span xml:lang="el" lang="el">φ</span></span> representing <span role="doc-pagebreak" epub:type="pagebreak" id="pg_197" aria-label="197"/>the Greek letter phi. This function gives the number of elements coprime with <i>n</i>, which is the number of elements in <b>Z</b><span class="ePub-I-SUB">n</span><sup>*</sup>. As a rule, if <i>n</i> is a product of prime numbers <i>n</i> = <i>p</i><sub>1</sub> × <i>p</i><sub>2</sub> × . . . × <i>p</i><span class="ePub-I-SUB">m</span>, the number of elements in the group <b>Z</b><span class="ePub-I-SUB">n</span><sup>*</sup> is the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg197-1.jpg" alt="" width="1388" height="53"/></figure>&#13;
<p class="TX">RSA deals only with numbers <i>n</i> that are the product of two large primes, usually noted as <i>n</i> = <i>pq</i>. The associated group <b>Z</b><span class="ePub-I-SUB">n</span><sup>*</sup> then contains <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) = (<i>p</i> – 1)(<i>q</i> – 1) elements. By expanding this expression, you get the equivalent definition <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) = <i>n</i> – <i>p</i> – <i>q</i> + 1, or <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) = (<i>n</i> + 1) – (<i>p</i> + <i>q</i>), which expresses more intuitively the value of <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) relative to <i>n</i>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
<h3 class="H1" id="sec2"><span id="h1-69"/><samp class="SANS_Futura_Std_Bold_B_11">The RSA Trapdoor Permutation</samp></h3>&#13;
<p class="TNI">The RSA trapdoor permutation is the core algorithm behind RSA-based encryption and signatures. Given a modulus <i>n</i> and a number <i>e</i>, which you call the <i>public exponent</i>, the RSA trapdoor permutation transforms a number <i>x</i> from the set <b>Z</b><span class="ePub-I-SUB">n</span><sup>*</sup> into a number <i>y</i> = <i>x</i><i><sup>e</sup></i> mod <i>n</i>. In other words, it calculates the value that’s equal to <i>x</i> multiplied by itself <i>e –</i> 1 times modulo <i>n</i> and then returns the result. When you use the RSA trapdoor permutation to encrypt, the modulus <i>n</i> and the exponent <i>e</i> make up the RSA public key.</p>&#13;
<p class="TX">To get <i>x</i> back from <i>y</i>, you can use another number, <i>d</i>, to compute the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg197-2.jpg" alt="" width="1388" height="65"/></figure>&#13;
<p class="TX">Because <i>d</i> is the trapdoor that allows you to decrypt, it’s part of the private key in an RSA key pair, meaning it should always be kept secret. The number <i>d</i> is also called the <i>secret exponent</i>.</p>&#13;
<p class="TX">Of course, <i>d</i> isn’t just any number; it’s the number such that <i>e</i> multiplied by <i>d</i> is equivalent to 1 and therefore such that <i>x</i><i><sup>ed</sup></i> mod <i>n</i> = <i>x</i> for any <i>x</i>. More precisely, you must have <i>ed</i> mod <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) = 1 to get <i>x</i><i><sup>ed</sup></i> = <i>x</i><sup>1</sup> = <i>x</i> and to decrypt the message correctly. Note that you compute modulo <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) and not modulo <i>n</i> here because exponents behave like <i>indexes</i> of elements of <b>Z</b><span class="ePub-I-SUB">n</span><sup>*</sup> rather than as the elements themselves. Because <b>Z</b><span class="ePub-I-SUB">n</span><sup>*</sup> has <span class="greek"><span xml:lang="el" lang="el">φ</span></span><i>(n</i>) elements, the index must be less than <span class="greek"><span xml:lang="el" lang="el">φ</span></span><i>(n</i>).</p>&#13;
<p class="TX">The number <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) is crucial to RSA’s security. In fact, finding <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) for an RSA modulus <i>n</i> is equivalent to breaking RSA because you can easily derive the secret exponent <i>d</i> from <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) and <i>e</i> by computing <i>e</i>’s inverse. Hence <i>p</i> and <i>q</i> should also be secret, since knowing <i>p</i> or <i>q</i> gives <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) by computing (<i>p</i> – 1)(<i>q</i> – 1) = <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>).</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i><span xml:lang="el" lang="el">φ</span>(</i><span class="note_Italic">n</span><i>) is called the</i> <span class="note_Italic">order</span> <i>of the group</i> <b>Z</b><sub>n</sub><i><sup>*</sup></i><i>; the order is an important characteristic of a group, which is essential to other public-key systems such as Diffie–Hellman and elliptic curve cryptography.</i></p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_198" aria-label="198"/>&#13;
<h3 class="H1" id="sec3"><span id="h1-70"/><samp class="SANS_Futura_Std_Bold_B_11">RSA Key Generation and Security</samp></h3>&#13;
<p class="TNI"><i>Key generation</i> is the process by which an RSA key pair is created, namely, a public key (modulus <i>n</i> and public exponent <i>e</i>) and its private key (secret exponent <i>d</i>). As the numbers <i>p</i> and <i>q</i> (such that <i>n</i> = <i>pq</i>) and the order <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) should also be secret, you will often include them as part of the private key.</p>&#13;
<p class="TX">To generate an RSA key pair, first pick two random prime numbers, <i>p</i> and <i>q</i>, and compute <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) from them. Then compute <i>d</i> as the inverse of <i>e</i>. <a href="chapter10.xhtml#Lis10-1">Listing 10-1</a> shows how this works using SageMath (<i><a href="https://www.sagemath.org">https://<wbr/>www<wbr/>.sagemath<wbr/>.org</a></i>), an open source Python-esque environment that includes many mathematical packages.</p>&#13;
<span id="Lis10-1"/><pre><code>sage: <b>p = random_prime(2^32); p</b>&#13;
1103222539&#13;
sage: <b>q = random_prime(2^32); q</b>&#13;
17870599&#13;
sage: <b>n = p*q; n</b>&#13;
19715247602230861&#13;
sage: <b>phi = (p-1)*(q-1); phi</b>&#13;
19715246481137724&#13;
sage: <b>e = random_prime(phi); e</b>&#13;
13771927877214701&#13;
sage: <b>d = xgcd(e, phi)[1]; d = mod(d, phi)</b>&#13;
11417851791646385&#13;
sage: <b>mod(d*e, phi)</b>&#13;
1</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-1: Generating RSA parameters using SageMath</samp></p>&#13;
<p class="TX">Here you use the <samp class="SANS_TheSansMonoCd_W5Regular_11">random_prime()</samp> function to pick random primes <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp>, which are lower than a given argument. Next, you multiply <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">q</samp> to get the modulus <samp class="SANS_TheSansMonoCd_W5Regular_11">n</samp> and <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>), which is the <samp class="SANS_TheSansMonoCd_W5Regular_11">phi</samp> variable. You then generate a random public exponent, <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp>, by picking a random prime less than <samp class="SANS_TheSansMonoCd_W5Regular_11">phi</samp> to ensure that <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp> has an inverse modulo <samp class="SANS_TheSansMonoCd_W5Regular_11">phi</samp>.</p>&#13;
<p class="TX">You use the <samp class="SANS_TheSansMonoCd_W5Regular_11">xgcd()</samp> function from Sage to generate the associated private exponent <i>d</i>. This function computes the numbers <i>s</i> and <i>t</i> given two numbers, <i>a</i> and <i>b</i>, with the extended Euclidean algorithm such that <i>as</i> + <i>bt</i> = <b>GCD</b>(<i>a</i>, <i>b</i>). Finally, you check that <i>ed</i> mod <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) = 1 to ensure that <i>d</i> correctly inverts the RSA permutation.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>I’ve used a 64-bit modulus</i> <span class="note_Italic">n</span> <i>in <a href="chapter10.xhtml#Lis10-1">Listing 10-1</a> to avoid multiple pages of output, but in practice an RSA modulus should be at least 2,048 bits to be secure.</i></p>&#13;
<p class="TX">Now you can apply the trapdoor permutation, as <a href="chapter10.xhtml#Lis10-2">Listing 10-2</a> shows.</p>&#13;
<span id="Lis10-2"/><pre><code><span role="doc-pagebreak" epub:type="pagebreak" id="pg_199" aria-label="199"/>sage: <b>x = 1234567</b>&#13;
sage: <b>y = power_mod(x, e, n); y</b>&#13;
17129109575774132&#13;
sage: <b>power_mod(y, d, n)</b>&#13;
1234567</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-2: Computing the RSA trapdoor permutation back and forth</samp></p>&#13;
<p class="TX">You assign the integer 1,234,567 to <i>x</i> and then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">power_mod(x, e, n)</samp> function, the exponentiation modulo <i>n</i>, or <i>x</i><i><sup>e</sup></i> mod <i>n</i> in equation form, to calculate <i>y</i>. After computing <i>y</i> = <i>x</i><i><sup>e</sup></i> mod <i>n</i>, you calculate <i>y</i><i><sup>d</sup></i> mod <i>n</i> with the trapdoor <i>d</i> to return the original <i>x</i>.</p>&#13;
<p class="TX">How hard is it to find <i>x</i> without the trapdoor <i>d</i>? An attacker able to factor big numbers could break RSA by recovering <i>p</i> and <i>q</i> and then <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) to compute <i>d</i> from <i>e</i>. Another risk to RSA lies in an attacker’s ability to compute <i>x</i> from <i>x</i><i><sup>e</sup></i> mod <i>n</i>, or <i>e</i>th roots modulo <i>n</i>, without necessarily factoring <i>n</i>. While both risks seem closely connected, we don’t know for sure that they’re equivalent.</p>&#13;
<p class="TX">Assuming that factoring and finding <i>e</i>th roots are about equally hard, RSA’s security level depends on three factors: the size of <i>n</i>, the choice of <i>p</i> and <i>q</i>, and how the trapdoor permutation is used. If <i>n</i> is too small, one could factor it in a realistic amount of time, revealing the private key. To be safe, <i>n</i> should be at least 2,048 bits long (a security level of about 90 bits, requiring a computational effort of about 2<sup>90</sup> operations) but preferably 4,096 bits long (a security level of approximately 128 bits). The values <i>p</i> and <i>q</i> should be unrelated random prime numbers of similar size. If they’re too small or too close together, it’s easier to determine their value from <i>n</i>. Finally, you shouldn’t use the RSA trapdoor permutation directly for encryption or signing, as I’ll discuss shortly.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<h3 class="H1" id="sec4"><span id="h1-71"/><samp class="SANS_Futura_Std_Bold_B_11">Encrypting with RSA</samp></h3>&#13;
<p class="TNI">Typically, RSA is used in combination with a symmetric encryption scheme, where RSA encrypts a symmetric key that serves to encrypt a message with a symmetric cipher, such as AES-GCM. But encrypting a message or symmetric key with RSA is more complicated than simply converting the target to a number <i>x</i> and computing <i>x</i><i><sup>e</sup></i> mod <i>n</i>.</p>&#13;
<p class="TX">In the following subsections, I explain why a naive application of the RSA trapdoor permutation is insecure and how strong RSA-based encryption works.</p>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
<h4 class="H2" id="sec5"><span id="h2-124"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Textbook RSA Encryption’s Malleability</samp></h4>&#13;
<p class="TNI">The phrase <i>textbook RSA encryption</i> describes the simplistic RSA encryption scheme wherein the number exponentiated contains only the message you want to encrypt. For example, to encrypt the string <i>RSA</i>, you first convert it to a number—for example, by concatenating the ASCII encodings of each of <span role="doc-pagebreak" epub:type="pagebreak" id="pg_200" aria-label="200"/>the three letters as a byte: <i>R</i> (byte <samp class="SANS_TheSansMonoCd_W5Regular_11">52</samp>), <i>S</i> (byte <samp class="SANS_TheSansMonoCd_W5Regular_11">53</samp>), and <i>A</i> (byte <samp class="SANS_TheSansMonoCd_W5Regular_11">41</samp>). The resulting byte string <samp class="SANS_TheSansMonoCd_W5Regular_11">525341</samp> is equal to 5,395,265 when converted to decimal, which you might then encrypt by computing 5,395,265<i><sup>e</sup></i> mod <i>n</i>. Without knowing the secret key, there’s no way to decrypt the message—at least in theory.</p>&#13;
<p class="TX">However, textbook RSA encryption is deterministic: if you encrypt the same plaintext twice, you’ll get the same ciphertext twice. And there’s an even bigger problem: given two textbook RSA ciphertexts <i>y</i><sub>1</sub> = <i>x</i><sub>1</sub><i><sup>e</sup></i> mod <i>n</i> and <i>y</i><sub>2</sub> = <i>x</i><sub>2</sub><i><sup>e</sup></i> mod <i>n</i>, you can derive the ciphertext of <i>x</i><sub>1</sub> × <i>x</i><sub>2</sub> by multiplying these ciphertexts together:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg200-1.jpg" alt="" width="1386" height="53"/></figure>&#13;
<p class="TX">The result is (<i>x</i><sub>1</sub> × <i>x</i><sub>2</sub>)<i><sup>e</sup></i> mod <i>n</i>, the ciphertext of the message <i>x</i><sub>1</sub> × <i>x</i><sub>2</sub> mod <i>n</i>. An attacker could create a new valid ciphertext from two RSA ciphertexts, compromising the security of your encryption by allowing them to deduce information about the original message. This weakness makes textbook RSA encryption <i>malleable</i>. (If you know <i>x</i><sub>1</sub> and <i>x</i><sub>2</sub>, you can compute (<i>x</i><sub>1</sub> × <i>x</i><sub>2</sub>)<i><sup>e</sup></i> mod <i>n</i>, too, but if you know only <i>y</i><sub>1</sub> and <i>y</i><sub>2</sub>, you shouldn’t be able to multiply ciphertexts and get the ciphertext of the multiplied plaintexts.)</p>&#13;
<p class="TX">Another problem with the naive textbook RSA encryption is the existence of “special” messages. Whatever <i>n</i> and <i>e</i> are, 1<i><sup>e</sup></i> = 1. Thus, the message 1 is left unchanged through encryption. Textbook RSA has many other problems, but you’ll learn to avoid them by using a strong RSA encryption.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
<h4 class="H2" id="sec6"><span id="h2-125"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Strong RSA Encryption with OAEP</samp></h4>&#13;
<p class="TNI">To make RSA ciphertexts nonmalleable, the number exponentiated during encryption should combine message data with additional data called <i>padding</i>, as <a href="chapter10.xhtml#fig10-1">Figure 10-1</a> shows.</p>&#13;
<figure class="IMG"><img id="fig10-1" class="img7" src="../images/fig10-1.jpg" alt="" width="939" height="339"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-1: Encrypting a symmetric key,</samp> <samp class="SANS_Futura_Std_Book_11">K</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">, with RSA using (</samp><samp class="SANS_Futura_Std_Book_11">n</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,</samp> <samp class="SANS_Futura_Std_Book_11">e</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">) as a public key</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The standard way to encrypt with RSA in this fashion is to use Optimal Asymmetric Encryption Padding (OAEP), a combination commonly called RSA-OAEP. This scheme involves creating a bit string as large as the modulus by padding the message with extra data and randomness before applying the RSA function.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>Official documents such as the PKCS#1 standard and NIST’s Special Publication 800-56B refer to OAEP as RSAES-OAEP. OAEP improves on the earlier method</i> <span role="doc-pagebreak" epub:type="pagebreak" id="pg_201" aria-label="201"/><i>PKCS#1 v1.5, which is one of the first in a series of Public-Key Cryptography Standards (PKCS) by RSA. It is markedly less secure than OAEP yet has remained in use in many systems after OAEP’s introduction.</i></p>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
<h5 class="H3" id="sec7"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Security</samp></h5>&#13;
<p class="TNI">OAEP uses a PRNG to ensure the indistinguishability and nonmalleability of ciphertexts by making the encryption probabilistic. It’s been proven secure as long as the RSA function and the PRNG are secure and, to a lesser extent, the hash functions aren’t too weak. You should use OAEP when encrypting with RSA, rather than its predecessor, the standard PKCS#1 v1.5.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
<h5 class="H3" id="sec8"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Encryption</samp></h5>&#13;
<p class="TNI">Encrypting with RSA in OAEP mode requires a message (such as a symmetric key, <i>K</i>), a PRNG, and two hash functions. To create the ciphertext, use a given modulus <i>n</i> long of <i>m</i> bytes (that is, 8<i>m</i> bits and therefore an <i>n</i> lower than 2<sup>8</sup><i><sup>m</sup></i>). To encrypt <i>K</i>, form the <i>encoded message</i> as</p>&#13;
<p class="Equation"><i>M</i> = <i>H</i> || <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> . . . <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> || <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> || <i>K</i></p>&#13;
<p class="Continued">where <i>H</i> is an <i>h</i>-byte constant defined by the OAEP scheme, followed by as many <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> bytes as necessary and a <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> byte. <a href="chapter10.xhtml#fig10-2">Figure 10-2</a> shows how to process this encoded message, <i>M</i>.</p>&#13;
<figure class="IMG"><img id="fig10-2" class="img7" src="../images/fig10-2.jpg" alt="" width="789" height="665"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-2: Encrypting a symmetric key,</samp> <samp class="SANS_Futura_Std_Book_11">K</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">, with RSA-OAEP, where</samp> <samp class="SANS_Futura_Std_Book_11">H</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">is a fixed parameter and</samp> <samp class="SANS_Futura_Std_Book_11">R</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">is random bits</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">You generate an <i>h</i>-byte random string <i>R</i> and set <i>M</i> = <i>M</i> <span class="symbol">⊕</span> <b>Hash1</b>(<i>R</i>), where <b>Hash1</b>(<i>R</i>) is as long as <i>M</i>. Next, set <i>R</i> = <i>R</i> <span class="symbol">⊕</span> <b>Hash2</b>(<i>M</i>), where <b>Hash2</b>(<i>M</i>) is as long as <i>R</i>. Now use these new values of <i>M</i> and <i>R</i> to form an <i>m</i>-byte string <i>P</i> = <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> || <i>M</i> || <i>R</i>, which is as long as the modulus <i>n</i> and which <span role="doc-pagebreak" epub:type="pagebreak" id="pg_202" aria-label="202"/>you can convert to an integer number less than <i>n</i>. This conversion results in the number <i>x</i>, which you then use to compute the RSA function <i>x</i><i><sup>e</sup></i> mod <i>n</i> to get the ciphertext.</p>&#13;
<p class="TX">To decrypt a ciphertext <i>y</i>, first compute <i>x</i> = <i>y</i><i><sup>d</sup></i> mod <i>n</i> and, from this, recover the final values of <i>M</i> and <i>R</i>. Next, retrieve <i>M</i>’s initial value by calculating <i>M</i> <span class="symbol">⊕</span> <b>Hash1</b>(<i>R</i> <span class="symbol">⊕</span> <b>Hash2</b>(<i>M</i>)). Finally, verify that <i>M</i> is of the form <i>H</i> || <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> . . . <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> || <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> || <i>K</i>, with an <i>h</i>-byte <i>H</i> and <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> bytes followed by a <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> byte.</p>&#13;
<p class="TX">In practice, the parameters <i>m</i> and <i>h</i> (the length of the modulus and the length of <b>Hash2</b>’s output, respectively) are typically <i>m</i> = 256 bytes (for 2,048-bit RSA) and <i>h</i> = 32 (using SHA-256 as <b>Hash2</b>). This leaves <i>m</i> – <i>h</i> – 1 = 223 bytes for <i>M</i>, of which up to <i>m</i> – 2<i>h</i> – 2 = 190 bytes are available for <i>K</i> (the “– 2” is due to the <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> byte separator in <i>M</i>). The <b>Hash1</b> hash value is then composed of <i>m</i> – <i>h</i> – 1 = 223 bytes, which is longer than the hash value of any common hash function. To build a hash with such an unusual output length, the RSA standard specification defines a <i>mask generating function</i> technique to create hash functions that return arbitrarily large hash values from any hash function. As another approach, use an extendable output function (XOF) such as SHAKE or BLAKE3, although this differs from the standard specifications.</p>&#13;
</section>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
<h3 class="H1" id="sec9"><span id="h1-72"/><samp class="SANS_Futura_Std_Bold_B_11">Signing with RSA</samp></h3>&#13;
<p class="TNI">Digital signatures can prove that the holder of the private key tied to a particular digital signature signed some message, typically to endorse its content. Because only the private key holder knows the private exponent <i>d</i>, no one else can compute a signature <i>y</i> = <i>x</i><i><sup>d</sup></i> mod <i>n</i> from some value <i>x</i>, but everyone can verify <i>y</i><i><sup>e</sup></i> mod <i>n</i> = <i>x</i> given the public exponent <i>e</i>. In principle, one can use that verified signature as evidence to demonstrate that the private-key holder signed some particular message; this is a property called <i>nonrepudiation</i>.</p>&#13;
<p class="TX">It’s tempting to see RSA signatures as the converse of encryption, but they aren’t. Signing with RSA isn’t the same as encrypting with the private key. Encryption provides confidentiality, whereas digital signatures help prevent forgeries. The most salient example of this difference is that it’s OK for a signature scheme to leak information on the message signed, because the message isn’t secret. For example, a scheme that reveals parts of the messages could be a secure signature scheme but not a secure encryption scheme.</p>&#13;
<p class="TX">Because of the necessary processing overhead, public-key encryption can process only short messages, which are usually secret keys rather than actual messages. A signature scheme, however, can process messages of arbitrary sizes by using their hash values <b>Hash</b>(<i>M</i>) as a proxy, and it can be deterministic yet secure. Like RSA-OAEP, RSA-based signature schemes can use a padding scheme, but they can also use the maximal message space allowed by the RSA modulus.</p>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_203" aria-label="203"/>&#13;
<h4 class="H2" id="sec10"><span id="h2-126"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Textbook RSA Signatures</samp></h4>&#13;
<p class="TNI">A <i>textbook RSA signature</i> is the method that signs a message, <i>x</i>, by directly computing <i>y</i> = <i>x</i><i><sup>d</sup></i> mod <i>n</i>, where <i>x</i> can be any number between 1 and <i>n</i> – 1. Like textbook encryption, textbook RSA signing is simple to specify and implement but insecure in the face of several attacks. One such attack involves a trivial forgery: upon noticing that 1<i><sup>d</sup></i> mod <i>n</i> = 1 and (<i>n</i> – 1)<i><sup>d</sup></i> mod <i>n</i> = <i>n</i> – 1, regardless of the value of the private key <i>d</i>, an attacker can forge signatures of 1 or <i>n</i> – 1 without knowing <i>d</i>.</p>&#13;
<p class="TX">More worrying is the <i>blinding attack</i>. For example, say you want to get a third party’s signature on some message, <i>M</i>, that you know they’d never knowingly sign. To launch this attack, first find some value, <i>R</i>, such that <i>R</i><i><sup>e</sup></i><i>M</i> mod <i>n</i> is a message that your victim would knowingly sign. Next, you’d convince them to sign that message and to show you their signature, which is equal to <i>S</i> = (<i>R</i><i><sup>e</sup></i><i>M</i>)<i><sup>d</sup></i> mod <i>n</i>, or the message raised to the power <i>d</i>. Given that signature, you can derive the signature of <i>M</i>, namely, <i>M</i><i><sup>d</sup></i>, with the aid of some straightforward computations.</p>&#13;
<p class="TX">Because you can write <i>S</i> as (<i>R</i> <i><sup>e</sup></i><i>M</i>)<i><sup>d</sup></i> = <i>R</i><i><sup>ed</sup></i><i>M</i><i><sup>d</sup></i>, and because <i>R</i><i><sup>ed</sup></i> = <i>R</i> (by definition), you have <i>S</i> = (<i>R</i><i><sup>e</sup></i><i>M</i>)<i><sup>d</sup></i> = <i>RM</i><i><sup>d</sup></i>. To obtain the signature <i>M</i><i><sup>d</sup></i>, divide <i>S</i> by <i>R</i> as follows:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg203-1.jpg" alt="" width="1386" height="49"/></figure>&#13;
<p class="Continued">This is often a practical and powerful attack.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
<h4 class="H2" id="sec11"><span id="h2-127"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The PSS Signature Standard</samp></h4>&#13;
<p class="TNI">The RSA <i>Probabilistic Signature Scheme (PSS)</i> is to RSA signatures what OAEP is to RSA encryption. It was designed to make message signing more secure, thanks to the addition of padding data.</p>&#13;
<p class="TX"><a href="chapter10.xhtml#fig10-3">Figure 10-3</a> demonstrates that PSS combines a message narrower than the modulus with some random and fixed bits before RSAing the results of this padding process.</p>&#13;
<figure class="IMG"><img id="fig10-3" class="img1" src="../images/fig10-3.jpg" alt="" width="1060" height="338"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-3: Signing a message,</samp> <samp class="SANS_Futura_Std_Book_11">M</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">, with RSA and with the PSS standard, where (</samp><samp class="SANS_Futura_Std_Book_11">n</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">,</samp> <samp class="SANS_Futura_Std_Book_11">d</samp><samp class="SANS_Futura_Std_Book_Oblique_I_11">) is the private key</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Like all public-key signature schemes, PSS works on a message’s hash rather than on the message itself. Signing <b>Hash</b>(<i>M</i>) is secure only if the hash function is collision resistant. You can thus sign messages of any <span role="doc-pagebreak" epub:type="pagebreak" id="pg_204" aria-label="204"/>length because after hashing a message, you’ll obtain a hash value of the same fixed length regardless of the message’s original length.</p>&#13;
<p class="TX">Why not sign by just applying the OAEP encryption to <b>Hash</b>(<i>M</i>)? Unfortunately, you can’t. Although similar to PSS, OAEP has been proven secure only for encryption, not for signatures.</p>&#13;
<p class="TX">Like OAEP, PSS also requires a PRNG and two hash functions. One, <b>Hash1</b>, is a typical hash with a standard output length, such as SHA-256. The other, <b>Hash2</b>, is a wide-output hash like OAEP’s <b>Hash2</b>. Like OAEP, PSS can use the mask-generating function (MGF) construction to build such a hash.</p>&#13;
<p class="TX">The PSS signing procedure works as follows (where <i>h</i> is <b>Hash1</b>’s output length):</p>&#13;
<p class="NLF">  1.  Pick an <i>r</i>-byte random string <i>R</i> using the PRNG.</p>&#13;
<p class="NL">  2.  Form an encoded message <i>M</i> <span class="symbol">′</span> = <samp class="SANS_TheSansMonoCd_W5Regular_11">0000000000000000</samp> || <b>Hash1</b>(<i>M</i>) || <i>R</i>, long of <i>h</i> + <i>r</i> + 8 bytes (with 8 zero bytes at the beginning).</p>&#13;
<p class="NL">  3.  Compute the <i>h</i>-byte string <i>H</i> = <b>Hash1</b>(<i>M</i><span class="symbol">′</span>).</p>&#13;
<p class="NL">  4.  Set <i>L</i> = <samp class="SANS_TheSansMonoCd_W5Regular_11">00. . .00</samp> || <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> || <i>R</i>, or a sequence of <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> bytes followed by a <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> byte and then <i>R</i>, with a number of <samp class="SANS_TheSansMonoCd_W5Regular_11">00</samp> bytes such that <i>L</i> is long of <i>m</i> – <i>h</i> – 1 bytes (the byte width <i>m</i> of the modulus minus the hash length <i>h</i> minus 1).</p>&#13;
<p class="NL">  5.  Set <i>L</i> = <i>L</i> <span class="symbol">⊕</span> <b>Hash2</b>(<i>H</i>) to replace the previous value of <i>L</i> with a new value.</p>&#13;
<p class="NL">  6.  Convert the <i>m</i>-byte string <i>P</i> = <i>L</i> || <i>H</i> || <samp class="SANS_TheSansMonoCd_W5Regular_11">BC</samp> to a number, <i>x</i>, lower than <i>n</i>. Here, the byte <samp class="SANS_TheSansMonoCd_W5Regular_11">BC</samp> is a fixed value appended after <i>H</i>.</p>&#13;
<p class="NL">  7.  Given the value of <i>x</i> just obtained, compute the RSA function <i>x</i><i><sup>d</sup></i> mod <i>n</i> to obtain the signature.</p>&#13;
<p class="NLL">  8.  To verify a signature given a message, <i>M</i>, compute <b>Hash1</b>(<i>M</i>) and use the public exponent <i>e</i> to inverse the RSA function and retrieve <i>L</i>, <i>H</i>, and then <i>M</i><span class="symbol">′</span> from the signature, checking the padding’s correctness at each step.</p>&#13;
<p class="TX">In practice, the random string <i>R</i> (called a <i>salt t</i> in the RSA-PSS standard) is usually as long as the hash value. For example, if you use <i>n</i> = 2,048 bits and SHA-256 as the hash, the value <i>L</i> is <i>m</i> – <i>h</i> – 1 = 256 – 32 – 1 = 223 bytes, and the random string <i>R</i> would typically be 32 bytes.</p>&#13;
<p class="TX">Like OAEP, PSS is provably secure, standardized, and available in many cryptographic software utilities and libraries, including OpenSSL and the Go language’s cryptography module. Also like OAEP, it looks needlessly complex and is prone to implementation errors and mishandled corner cases. Unlike RSA encryption, there’s a simpler alternative to PSS for signing: without a PRNG, with a single hash function, and without padding.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec12">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_205" aria-label="205"/>&#13;
<h4 class="H2" id="sec12"><span id="h2-128"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Full Domain Hash Signatures</samp></h4>&#13;
<p class="TNI"><i>Full Domain Hash (FDH)</i> is the simplest signature scheme you can imagine. To implement it, convert the byte string <b>Hash</b>(<i>M</i>) to a number, <i>x</i>, and create the signature <i>y</i> = <i>x</i><i><sup>d</sup></i> mod <i>n</i>, as in <a href="chapter10.xhtml#fig10-4">Figure 10-4</a>.</p>&#13;
<figure class="IMG"><img id="fig10-4" class="img7" src="../images/fig10-4.jpg" alt="" width="629" height="338"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 10-4: Signing a message with RSA using the Full Domain Hash technique</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Signature verification is straightforward, too. Given a signature that’s a number <i>y</i>, compute <i>x</i> = <i>y</i><i><sup>e</sup></i> mod <i>n</i> and compare the result with <b>Hash</b>(<i>M</i>). It’s boringly simple, deterministic, yet secure. So why bother with the complexity of PSS?</p>&#13;
<p class="TX">PSS was released <i>after</i> FDH, in 1996, and it has a security proof that inspires more confidence than FDH. Specifically, its proof offers slightly higher security guarantees than the proof of FDH, and its use of randomness helped strengthen that proof.</p>&#13;
<p class="TX">These stronger theoretical guarantees are the main reason why many cryptographers prefer PSS over FDH, but most applications using PSS today could switch to FDH with no meaningful security loss. In some contexts, however, it’s viable to use PSS instead of FDH because PSS’s randomness protects it from some attacks on its implementation, such as the fault attacks we’ll discuss in “<span class="Xref">How Things Can Go Wrong</span>” on <span class="Xref"><a href="#sec17">page 211</a></span>.</p>&#13;
<p class="TX">In any case, RSA signatures (PSS or FDH) are less and less used. Signatures based on elliptic curves, such as ECDSA and EdDSA, have gained in popularity, not least because their calculation of a signature is much faster (although signature verification is often faster with RSA).</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec13">&#13;
<h3 class="H1" id="sec13"><span id="h1-73"/><samp class="SANS_Futura_Std_Bold_B_11">RSA Implementations</samp></h3>&#13;
<p class="TNI">I hope you’ll never have to implement RSA from scratch. If you’re asked to, run as fast as you can and question the sanity of the person who asked you to do so. It took decades for cryptographers and engineers to develop RSA implementations that are fast, sufficiently secure, and ideally free of debilitating bugs, so it isn’t wise to reinvent RSA. Even with all the documentation available, it would take months to complete this daunting task.</p>&#13;
<p class="TX">Typically, when using RSA in software, you’ll use a library or API that provides the necessary functions to carry out RSA operations. For example, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_206" aria-label="206"/>the Go language has the following function in its <samp class="SANS_TheSansMonoCd_W5Regular_11">crypto</samp> package (from <i><a href="https://go.dev/src/crypto/rsa/rsa.go">https://<wbr/>go<wbr/>.dev<wbr/>/src<wbr/>/crypto<wbr/>/rsa<wbr/>/rsa<wbr/>.go</a></i>):</p>&#13;
<pre><code>func EncryptOAEP(hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte) (out []byte, err error)</code></pre>&#13;
<p class="TX">The function <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptOAEP()</samp> takes a hash function, a PRNG, a public key, a message, and a label (an optional parameter of OAEP) and returns a ciphertext and an error code. When you call <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptOAEP()</samp>, it calls <samp class="SANS_TheSansMonoCd_W5Regular_11">encrypt()</samp> to compute the RSA function given the padded data, as <a href="chapter10.xhtml#Lis10-3">Listing 10-3</a> shows.</p>&#13;
<span id="Lis10-3"/><pre><code>func encrypt(c *big.Int, pub *PublicKey, m *big.Int) *big.Int {&#13;
    e := big.NewInt(int64(pub.E))&#13;
    c.Exp(m, e, pub.N)&#13;
    return c&#13;
}</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-3: The implementation of the core RSA encryption function from the Go language cryptography library</samp></p>&#13;
<p class="TX">The main operation here is <samp class="SANS_TheSansMonoCd_W5Regular_11">c.Exp(m, e, pub.N)</samp>, which raises a message, <samp class="SANS_TheSansMonoCd_W5Regular_11">m</samp>, to the power <samp class="SANS_TheSansMonoCd_W5Regular_11">e</samp> modulo <samp class="SANS_TheSansMonoCd_W5Regular_11">pub.N</samp>, and assigns the result to the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">c</samp>.</p>&#13;
<p class="TX">If you choose to implement RSA instead of using a readily available library function, be sure to rely on an existing <i>big-number</i> library, which is a set of functions and types that allow you to define and compute arithmetic operations on large numbers thousands of bits long. For example, you might use the GNU Multiple Precision (GMP) arithmetic library in C or in Go’s <samp class="SANS_TheSansMonoCd_W5Regular_11">big</samp> package. (Believe me, you don’t want to implement big-number arithmetic yourself.)</p>&#13;
<p class="TX">Even if you just use a library function when implementing RSA, ensure you understand how the internals work so you can assess the risk and whether it matches the application’s security requirements.</p>&#13;
<section epub:type="division" aria-labelledby="sec14">&#13;
<h4 class="H2" id="sec14"><span id="h2-129"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Fast Exponentiation Algorithm</samp></h4>&#13;
<p class="TNI"><i>Exponentiation</i> is the operation of raising <i>x</i> to the power <i>e</i>, when computing <i>x</i><i><sup>e</sup></i> mod <i>n</i>. When working with big numbers, as with RSA, this operation can be extremely slow if naively implemented. How to efficiently compute exponentiations?</p>&#13;
<p class="TX">The naive way to compute <i>x</i><i><sup>e</sup></i> mod <i>n</i> takes <i>e</i> – 1 multiplications, as the pseudocode algorithm in <a href="chapter10.xhtml#Lis10-4">Listing 10-4</a> demonstrates.</p>&#13;
<span id="Lis10-4"/><pre><code>expModNaive(x, e, n) {&#13;
    y = x&#13;
    for i = 1 to e – 1 {&#13;
        y = y * x mod n&#13;
    }&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_207" aria-label="207"/>    return y&#13;
}</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-4: A naive exponentiation algorithm in pseudocode, raising</samp> <samp class="SANS_Futura_Std_Book_11">x</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to the power</samp> <samp class="SANS_Futura_Std_Book_11">e</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">modulo</samp> <samp class="SANS_Futura_Std_Book_11">n</samp></p>&#13;
<p class="TX">This algorithm is simple but highly inefficient. You can get the same result exponentially faster by squaring rather than multiplying intermediate values <i>y</i> until you reach the correct value. This family of methods is called <i>square-and-multiply</i>, <i>exponentiation by squaring</i>, or <i>binary exponentiation</i>.</p>&#13;
<p class="TX">Say you want to compute 3<sup>65,537</sup> mod 36,567,232,109,354,321, for example. (The number 65,537 is the public exponent in most RSA implementations.) You could multiply the number 3 by itself 65,536 times, or you could approach this problem knowing that you can write 65,537 as 2<sup>16</sup> + 1 and use a series of squaring operations instead. Essentially, you initialize a variable, <i>y</i> = 3, and then compute the following squaring (<i>y</i><sup>2</sup>) operations:</p>&#13;
<p class="NLF">  1.  Set <i>y</i> = <i>y</i><sup>2</sup> mod <i>n</i> (now <i>y</i> = 3<sup>2</sup> mod <i>n</i>).</p>&#13;
<p class="NL">  2.  Set <i>y</i> = <i>y</i><sup>2</sup> mod <i>n</i> (now <i>y</i> = (3<sup>2</sup>)<sup>2</sup> mod <i>n</i> = 3<sup>4</sup> mod <i>n</i>).</p>&#13;
<p class="NL">  3.  Set <i>y</i> = <i>y</i><sup>2</sup> mod <i>n</i> (now <i>y</i> = (3<sup>4</sup>)<sup>2</sup> = 3<sup>8</sup> mod <i>n</i>).</p>&#13;
<p class="NL">  4.  Set <i>y</i> = <i>y</i><sup>2</sup> mod <i>n</i> (now <i>y</i> = (3<sup>8</sup>)<sup>2</sup> = 3<sup>16</sup> mod <i>n</i>).</p>&#13;
<p class="NLL">  5.  Set <i>y</i> = <i>y</i><sup>2</sup> mod <i>n</i> (now <i>y</i> = (3<sup>16</sup>)<sup>2</sup> = 3<sup>32</sup> mod <i>n</i>).</p>&#13;
<p class="TX">And so on until <i>y</i> = 3<sup>65,536</sup>, by performing 16 squarings.</p>&#13;
<p class="TX">To get the final result, you would return 3 × <i>y</i> mod <i>n</i> = 3<sup>65,537</sup> mod <i>n</i> = 26,652,909,283,612,267. In other words, you compute the result with only 17 multiplications rather than 65,536 with the naive method.</p>&#13;
<p class="TX">More generally, a square-and-multiply method works by scanning the exponent’s bits one by one, computing the square for each exponent’s bit to double the exponent’s value, and multiplying by the original number for each bit with a value of 1 encountered. In the preceding example, the exponent 65,537 is 10000000000000001 in binary, and you squared <i>y</i> for each new bit and multiplied by the original number 3 only for the very first and last bits.</p>&#13;
<p class="TX"><a href="chapter10.xhtml#Lis10-5">Listing 10-5</a> shows how this works as a general algorithm in pseudocode to compute <i>x</i><i><sup>e</sup></i> mod <i>n</i> when the exponent <i>e</i> consists of bits <i>e</i><span class="ePub-I-SUB">m –</span> <sub>1</sub><i>e</i><span class="ePub-I-SUB">m –</span> <sub>2</sub> . . . <i>e</i><sub>1</sub><i>e</i><sub>0</sub>, where <i>e</i><sub>0</sub> is the least significant bit.</p>&#13;
<span id="Lis10-5"/><pre><code>expMod(x, e, n) {&#13;
    y = x&#13;
    for i = m – 1 to 0 {&#13;
        y = y * y  mod n&#13;
        if e<span class="TheSansMonoCd_W5Regular_SUB">i</span> == 1 then&#13;
            y = y * x  mod n&#13;
    }&#13;
    return y&#13;
}</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-5: A fast exponentiation algorithm in pseudocode, raising</samp> <samp class="SANS_Futura_Std_Book_11">x</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">to the power</samp> <samp class="SANS_Futura_Std_Book_11">e</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">modulo</samp> <samp class="SANS_Futura_Std_Book_11">n</samp></p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_208" aria-label="208"/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">expMod()</samp> algorithm runs in time <i>O</i>(<i>m</i>), whereas the naive algorithm runs in time <i>O</i>(2<i><sup>m</sup></i>), where <i>m</i> is the bit length of the exponent. Here, <i>O</i>() is the asymptotic complexity notation introduced in <span class="Xref"><a href="chapter9.xhtml">Chapter 9</a></span>.</p>&#13;
<p class="TX">All serious systems implement some variant of this simplest square-and-multiply method. One such variant is the <i>sliding window</i> method, which considers blocks of bits rather than individual bits to perform a given multiplication operation. For example, see the function <samp class="SANS_TheSansMonoCd_W5Regular_11">expNN()</samp> of the Go language, whose source code is available at <i><a href="https://go.dev/src/math/big/nat.go">https://<wbr/>go<wbr/>.dev<wbr/>/src<wbr/>/math<wbr/>/big<wbr/>/nat<wbr/>.go</a></i>.</p>&#13;
<p class="TX">How secure are these square-and-multiply exponentiation algorithms? Unfortunately, the tricks to speed the process up often result in increased vulnerability against some attacks.</p>&#13;
<p class="TX">The weakness of these algorithms stems from the fact that the exponentiation operations are heavily dependent on the exponent’s value. The <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> operation in <a href="chapter10.xhtml#Lis10-5">Listing 10-5</a> takes a different branch based on whether an exponent’s bit is 0 or 1. If a bit is 1, an iteration of the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is slower than it is for 0, and attackers who monitor the execution time of the RSA operation can exploit this time difference to recover a private exponent. This is called a <i>timing attack</i>. Attacks on hardware can distinguish 1 bit from 0 bits by monitoring the device’s power consumption and observing which iterations perform an extra multiplication to reveal which bits of the private exponent are 1.</p>&#13;
<p class="TX">Depending on the type of platform, the information channel may not be execution time. For example, you might distinguish 1-bits in the exponent from 0-bits by measuring the device’s power consumption and observing which iterations perform additional multiplication, revealing the private exponent bits at 1. This is a <i>power-analysis attack</i>. Few open source cryptographic libraries contain effective defenses against these types of attacks.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec15">&#13;
<h4 class="H2" id="sec15"><span id="h2-130"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Small Exponents for Faster Public-Key Operations</samp></h4>&#13;
<p class="TNI">Because an RSA computation is essentially the computation of an exponentiation, its performance depends on the value of the numbers involved, in particular the exponent. Smaller exponents require fewer multiplications and can therefore make the exponentiation computation much faster.</p>&#13;
<p class="TX">In principle, the public exponent <i>e</i> can be any value between 3 and <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) – 1, as long as <i>e</i> and <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) are coprime. But in practice you’ll find only small values of <i>e</i>, and most of the time <i>e</i> = 65,537 due to concerns with encryption and signature verification speed. For example, the Microsoft Windows CryptoAPI supports only public exponents that fit in a 32-bit integer. The larger the <i>e</i>, the slower it is to compute <i>x</i><i><sup>e</sup></i> mod <i>n.</i></p>&#13;
<p class="TX">Unlike the size of the public exponent, the private exponent <i>d</i> is inevitably about as large as <i>n</i>, making decryption much slower than encryption, and signing much slower than verification. Because <i>d</i> is secret, it must be unpredictable and therefore can’t be restricted to a small value. For example, if <i>e</i> is <span role="doc-pagebreak" epub:type="pagebreak" id="pg_209" aria-label="209"/>fixed to 65,537, the corresponding <i>d</i> is usually of the same order of magnitude as the modulus <i>n</i>, which would be close to 2<sup>2,048</sup> if <i>n</i> is 2,048 bits long.</p>&#13;
<p class="TX">As discussed in “<span class="Xref">A Fast Exponentiation Algorithm</span>” on <span class="Xref"><a href="#sec14">page 206</a></span>, raising a number to the power 65,537 takes 17 multiplications, whereas raising a number to the power of some 2,048-bit number takes on the order of 3,000 multiplications.</p>&#13;
<p class="TX">You can estimate the speed of RSA by using the OpenSSL toolkit. For example, <a href="chapter10.xhtml#Lis10-6">Listing 10-6</a> shows the results of 512-, 1,024-, 2,048-, and 4,096-bit RSA operations on a MacBook equipped with an M2 chipset:</p>&#13;
<span id="Lis10-6"/><pre><code><samp class="SANS_TheSansMonoCd_W5Regular_11">Doing 1024 bits private rsa sign ops for 10s: 119019 1024 bits private RSA sign ops in 9.93s</samp>&#13;
Doing 1024 bits public rsa verify ops for 10s: 2573979 1024 bits public RSA verify ops in 9.93s&#13;
Doing 2048 bits private rsa sign ops for 10s: 19184 2048 bits private RSA sign ops in 9.93s&#13;
Doing 2048 bits public rsa verify ops for 10s: 769696 2048 bits public RSA verify ops in 9.93s&#13;
Doing 4096 bits private rsa sign ops for 10s: 3005 4096 bits private RSA sign ops in 9.92s&#13;
Doing 4096 bits public rsa verify ops for 10s: 206367 4096 bits public RSA verify ops in 9.91s&#13;
&#13;
<samp class="SANS_TheSansMonoCd_W5Regular_11">                  sign    verify   sign/s verify/s</samp>&#13;
rsa 1024 bits 0.000083s 0.000004s 11985.8 259212.4&#13;
rsa 2048 bits 0.000518s 0.000013s  1931.9  77512.2&#13;
rsa 4096 bits 0.003301s 0.000048s   302.9  20824.1&#13;
<var>--snip--</var></code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-6: Example benchmarks of RSA operations using the OpenSSL toolkit (version 3.2.0)</samp></p>&#13;
<p class="TX">To get an idea of how much slower verification is compared to signature generation, compute the ratio of the verification time over signature time. The benchmarks in <a href="chapter10.xhtml#Lis10-6">Listing 10-6</a> show that I’ve got verification-over-signature speed ratios of approximately 21.6, 40.1, and 68.7 for 1,024-, 2,048-, and 4,096-bit moduli, respectively. The gap grows with the modulus size because the number of multiplications for <i>e</i> operations remains constant with respect to the modulus size (for example, 17 operations when <i>e</i> = 65,537), while private-key operations always need more multiplications for a greater modulus because <i>d</i> grows accordingly.</p>&#13;
<p class="TX">If small exponents are so nice, why use 65,537 and not something like 3? It would actually be fine (and faster) to use 3 as an exponent when implementing RSA with a secure scheme such as OAEP, PSS, or FDH. Cryptographers avoid doing so, however, because when <i>e</i> = 3, less secure schemes make certain types of mathematical attacks possible. The number 65,537 is large enough to avoid such <i>low-exponent attacks</i>, and it has only two nonzero bits, which decreases the computation time when computing <i>x</i><sup>65,537</sup>. The number 65,537 is also special for mathematicians: it’s the fourth Fermat number, or a number of the form</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg209-1.jpg" alt="" width="1373" height="40"/></figure>&#13;
<p class="Continued">because it’s equal to 2<sup>16</sup> + 1, where 16 = 2<sup>4</sup>, but that’s a curiosity irrelevant to most cryptographic engineers.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec16">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_210" aria-label="210"/>&#13;
<h4 class="H2" id="sec16"><span id="h2-131"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Chinese Remainder Theorem</samp></h4>&#13;
<p class="TNI">The most common trick to speed up decryption and signature generation (that is, the computation of <i>y</i><i><sup>d</sup></i> mod <i>n</i>) is the <i>Chinese remainder theorem (CRT)</i>, which makes RSA about four times faster.</p>&#13;
<p class="TX">The CRT allows for faster decryption by computing two exponentiations, modulo <i>p</i> and modulo <i>q</i>, rather than a single one modulo <i>n</i>. Because <i>p</i> and <i>q</i> are much smaller than <i>n</i>, it’s faster to perform two “small” exponentiations than a single “big” one.</p>&#13;
<p class="TX">The Chinese remainder theorem isn’t specific to RSA. It’s a general arithmetic result that, in its simplest form, states that if <i>n</i> = <i>n</i><sub>1</sub><i>n</i><sub>2</sub><i>n</i><sub>3</sub> . . . , where the <i>n</i><span class="ePub-I-SUB">i</span>s are pairwise coprime (that is, <b>GCD</b>(<i>n</i><span class="ePub-I-SUB">i</span>, <i>n</i><span class="ePub-I-SUB">j</span>) = 1 for any distinct <i>i</i> and <i>j</i>), then one can compute the value <i>x</i> mod <i>n</i> from the values <i>x</i> mod <i>n</i><sub>1</sub>, <i>x</i> mod <i>n</i><sub>2</sub>, <i>x</i> mod <i>n</i><sub>3</sub>, . . . For example, say you have <i>n</i> = 1,155, which is the product of prime factors 3 × 5 × 7 × 11, and say you want to determine <i>x</i> that satisfies <i>x</i> mod 3 = 2, <i>x</i> mod 5 = 1, <i>x</i> mod 7 = 6, and <i>x</i> mod 11 = 8. (I’ve chosen 2, 1, 6, and 8 arbitrarily.) To find <i>x</i> using the Chinese remainder theorem, compute the sum <i>P</i>(<i>n</i><sub>1</sub>) + <i>P</i>(<i>n</i><sub>2</sub>) + . . . , where <i>P</i>(<i>n</i><span class="ePub-I-SUB">i</span>) is defined as follows:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg210-1.jpg" alt="" width="1388" height="56"/></figure>&#13;
<p class="Continued">Note that the second term, <i>n</i>/<i>n</i><span class="ePub-I-SUB">i</span>, is equal to the product of all factors other than this <i>n</i><span class="ePub-I-SUB">i</span>.</p>&#13;
<p class="TX">To apply this formula to this example and recover <i>x</i> mod 1155, compute <i>P</i>(3), <i>P</i>(5), <i>P</i>(7), and <i>P</i>(11); then add them together to get the following expression:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg210-2.jpg" alt="" width="1388" height="123"/></figure>&#13;
<p class="TX">Here, I’ve just applied the preceding definition of <i>P</i>(<i>n</i><span class="ePub-I-SUB">i</span>). (The math behind finding each number is straightforward, but I won’t detail it here.) You can then reduce this expression to [770 + 231 + 1980 + 1680] mod <i>n</i> = 41. As 41 is the number I’d picked for this example, you’ve got the correct result.</p>&#13;
<p class="TX">Applying the CRT to RSA is simpler than the previous example because there are only two factors for each <i>n</i> (namely, <i>p</i> and <i>q</i>). Given a ciphertext <i>y</i> to decrypt, instead of computing <i>y</i><i><sup>d</sup></i> mod <i>n</i>, use the CRT to compute <i>x</i><span class="ePub-I-SUB">p</span> = <i>y</i><i><sup>s</sup></i> mod <i>p</i>, where <i>s</i> = <i>d</i> mod (<i>p</i> – 1) and <i>x</i><span class="ePub-I-SUB">q</span> = <i>y</i><i><sup>t</sup></i> mod <i>q</i>, where <i>t</i> = <i>d</i> mod (<i>q</i> – 1). Combine these two expressions and compute <i>x</i> to be the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg210-3.jpg" alt="" width="1388" height="56"/></figure>&#13;
<p class="TX">That’s it. This is faster than a single exponentiation even with the square-and-multiply trick because the multiplication-heavy operations are carried out on modulo <i>p</i> and <i>q</i>, numbers that are twice as small as <i>n</i>, whereas the complexity of exponentiation increases faster than linearly. When you double the size of the number, you don’t just double the cost of exponentiation—it grows faster.</p>&#13;
<blockquote>&#13;
<p class="Note"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_211" aria-label="211"/><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="NOTE-TXT"><i>In the final operation, you can compute the two numbers</i> <span class="note_Italic">q</span> <i>× (1/</i><span class="note_Italic">q</span> <i>mod</i> <span class="note_Italic">p</span><i>) and</i> <span class="note_Italic">p</span> <i>× (1/</i><span class="note_Italic">p</span> <i>mod</i> <span class="note_Italic">q</span><i>) in advance, which means you need to compute only two multiplications and an addition of modulo</i> <span class="note_Italic">n</span> <i>to find</i> <span class="note_Italic">x</span>.</p>&#13;
<p class="TX">Unfortunately, there’s a security caveat attached to these techniques.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec17">&#13;
<h3 class="H1" id="sec17"><span id="h1-74"/><samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp></h3>&#13;
<p class="TNI">Even more elegant than the RSA scheme itself is the range of attacks that work either because the implementation leaks (or can be made to leak) information on its internals or because RSA is used insecurely. I discuss two classic examples of these types of attacks in the sections that follow.</p>&#13;
<section epub:type="division" aria-labelledby="sec18">&#13;
<h4 class="H2" id="sec18"><span id="h2-132"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Bellcore Attack on RSA-CRT</samp></h4>&#13;
<p class="TNI">The Bellcore attack on RSA is one of the most important attacks in the history of RSA. First discovered in 1996, it stood out because it exploited RSA’s vulnerability to <i>fault injections</i>—attacks that force part of the algorithm to misbehave and potentially yield incorrect results. For example, one may temporarily perturb hardware circuits or embedded systems by suddenly altering their voltage supply or beaming a laser pulse to a carefully chosen part of a chip. Attackers can then exploit the resulting faults in an algorithm’s internals by observing the impact on the result. Comparing the correct result with a faulty one can provide information on the algorithm’s internal values, including secret values. Likewise, attempts to learn whether the result is valid might leak exploitable information.</p>&#13;
<p class="TX">The Bellcore attack is such a fault attack. It works on RSA signature schemes that use the Chinese remainder theorem and that are deterministic—meaning it works on FDH but not on PSS, which is probabilistic.</p>&#13;
<p class="TX">To understand the Bellcore attack, recall from the previous section that with CRT, you obtain the result that’s equal to <i>x</i><i><sup>d</sup></i> mod <i>n</i> by computing the following, where <i>x</i><span class="ePub-I-SUB">p</span> = <i>y</i><i><sup>s</sup></i> mod <i>p</i> and <i>x</i><span class="ePub-I-SUB">q</span> = <i>y</i><i><sup>t</sup></i> mod <i>q</i>:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg211-1.jpg" alt="" width="1386" height="54"/></figure>&#13;
<p class="TX">Now assume that an attacker induces a fault in the computation of <i>x</i><span class="ePub-I-SUB">q</span> so that you end up with some incorrect value, which differs from the actual <i>x</i><span class="ePub-I-SUB">q</span>. Let’s call this incorrect value <i>x</i><span class="ePub-I-SUB">q</span><span class="symbol">′</span> and the final result obtained <i>x</i><span class="symbol">′</span>. The attacker can then subtract the incorrect signature <i>x</i><span class="symbol">′</span> from the correct signature <i>x</i> to factor <i>n</i>, which results in the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg211-2.jpg" alt="" width="1386" height="62"/></figure>&#13;
<p class="TX">The value <i>x</i> – <i>x</i><span class="symbol">′</span> is therefore a multiple of <i>p</i>, so <i>p</i> is a divisor of <i>x</i> – <i>x</i><span class="symbol">′</span>. Because <i>p</i> is also a divisor of <i>n</i>, the greatest common divisor of <i>n</i> and <i>x</i> – <i>x</i><span class="symbol">′</span> yields <i>p</i>, <b>GCD</b>(<i>x</i> – <i>x</i><span class="symbol">′</span>, <i>n</i>) = <i>p</i>. You can then compute <i>q</i> = <i>n</i>/<i>p</i> and <i>d</i>, resulting in a total break of RSA signatures.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_212" aria-label="212"/>A variant of this attack works when you know only that the message is signed, and not the correct signature. There’s also a similar fault attack on the modulus value, rather than on the CRT values computation, but I won’t go into detail on that here.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec19">&#13;
<h4 class="H2" id="sec19"><span id="h2-133"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Shared Private Exponents or Moduli</samp></h4>&#13;
<p class="TNI">Now I’ll show you why your public key shouldn’t have the same modulus <i>n</i> as that of someone else.</p>&#13;
<p class="TX">Private keys belonging to different systems or people should have different private exponents, <i>d</i>, even if the keys use different moduli. Or you could try your own value of <i>d</i> to decrypt messages encrypted for other entities, until you hit one that shares the same <i>d</i>. By the same token, different key pairs should have different <i>n</i> modulus values, even if they have different <i>d</i>s, because <i>p</i> and <i>q</i> are usually part of the private key. Hence, if I share the same <i>n</i> and thus the same <i>p</i> and <i>q</i>, I can compute your private key from your public key <i>e</i> using <i>p</i> and <i>q</i>.</p>&#13;
<p class="TX">Imagine that you know your private exponent <i>d</i><sub>1</sub> and the public exponent <i>e</i><sub>2</sub> of another person with whom you share the same modulus <i>n</i>, but without knowing its factors <i>p</i> and <i>q</i>. How can you calculate <i>p</i> and <i>q</i> from your private exponent <i>d</i><sub>1</sub> to find the private exponent <i>d</i><sub>2</sub> of the other person? The solution is a bit technical but elegant.</p>&#13;
<p class="TX">Remember that <i>d</i> and <i>e</i> satisfy <i>ed</i> = <i>k</i><span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) + 1, where <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) is secret and could reveal <i>p</i> and <i>q</i>. You don’t know <i>k</i> or <span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>), but you can compute <i>k</i><span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) = <i>ed</i> – 1.</p>&#13;
<p class="TX">What can you do with <i>k</i><span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>)? According to <i>Euler’s theorem</i>, for any number <i>a</i> coprime with <i>n</i>, you have <i>a</i><sup><span xml:lang="el" lang="el">φ</span>(</sup><i><sup>n</sup></i><sup>)</sup> = 1 mod <i>n</i>. Therefore, modulo <i>n</i> you have the following:</p>&#13;
<figure class="DIS-IMG"><img class="img1" src="../images/pg212-1.jpg" alt="" width="1389" height="65"/></figure>&#13;
<p class="TX">Because <i>k</i><span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) is an even number, you can write it as 2<i><sup>s</sup></i><i>t</i> for some numbers <i>s</i> and <i>t</i>. That is, you’ll be able to write <i>a</i><i><sup>k</sup></i><sup><span xml:lang="el" lang="el">φ</span>(</sup><i><sup>n</sup></i><sup>)</sup> = 1 mod <i>n</i> under the form <i>x</i><sup>2</sup> = 1 mod <i>n</i> for some <i>x</i> easily computed from <i>k</i><span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>). You can call such an <i>x</i> a <i>root of unity</i>.</p>&#13;
<p class="TX">The key observation is that <i>x</i><sup>2</sup> = 1 mod <i>n</i> is equivalent to saying that the value <i>x</i><sup>2</sup> – 1 = (<i>x</i> – 1)(<i>x</i> + 1) divides <i>n</i>. In other words, <i>x</i> – 1 or <i>x</i> + 1 must have a common factor with <i>n</i>, which can give you the factorization of <i>n</i>.</p>&#13;
<p class="TX"><a href="chapter10.xhtml#Lis10-7">Listing 10-7</a> shows a Python implementation of this method where, to find the factors <i>p</i> and <i>q</i> from <i>n</i> and <i>d</i>, I use small, 64-bit numbers for the sake of simplicity.</p>&#13;
<span id="Lis10-7"/><pre><code>from math import gcd&#13;
&#13;
n = 36567232109354321&#13;
e = 13771927877214701&#13;
d = 15417970063428857&#13;
&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_213" aria-label="213"/><span class="CodeAnnotationHang" aria-label="annotation1">❶</span> kphi = d*e - 1&#13;
t = kphi&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation2">❷</span> while t % 2 == 0:&#13;
    t = divmod(t, 2)[0]&#13;
&#13;
<span class="CodeAnnotationHang" aria-label="annotation3">❸</span> a = 2&#13;
while a &lt; 100:&#13;
  <span class="Code_CodeAnnotation" aria-label="annotation4">❹</span> k = t&#13;
    while k &lt; kphi:&#13;
        x = pow(a, k, n)&#13;
      <span class="Code_CodeAnnotation" aria-label="annotation5">❺</span> if x != 1 and x != (n - 1) and pow(x, 2, n) == 1:&#13;
          <span class="Code_CodeAnnotation" aria-label="annotation6">❻</span> p = gcd(x - 1, n)&#13;
            break&#13;
        k = k*2&#13;
    a = a + 2&#13;
&#13;
q = n//p&#13;
<span class="CodeAnnotationHang" aria-label="annotation7">❼</span> assert (p*q) == n&#13;
print('p = ', p)&#13;
print('q = ', q)</code></pre>&#13;
<p class="ListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 10-7: A Python program that computes the prime factors</samp> <samp class="SANS_Futura_Std_Book_11">p</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">and</samp> <samp class="SANS_Futura_Std_Book_11">q</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">from the private exponent</samp> <samp class="SANS_Futura_Std_Book_11">d</samp></p>&#13;
<p class="TX">This program determines <i>k</i><span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) from <i>e</i> and <i>d</i> <span class="CodeAnnotation" aria-label="annotation1">❶</span> by finding the number <i>t</i> such that <i>k</i><span class="greek"><span xml:lang="el" lang="el">φ</span></span>(<i>n</i>) = 2<i><sup>s</sup></i><i>t</i>, for some <i>s</i> <span class="CodeAnnotation" aria-label="annotation2">❷</span>. Then it looks for <i>a</i> and <i>k</i> such that (<i>a</i><i><sup>k</sup></i>)<sup>2</sup> = 1 mod <i>n</i> <span class="CodeAnnotation" aria-label="annotation3">❸</span>, using <i>t</i> as a starting point for <i>k</i> <span class="CodeAnnotation" aria-label="annotation4">❹</span>. When this condition is satisfied <span class="CodeAnnotation" aria-label="annotation5">❺</span>, you’ve found a solution. It then determines the factor <i>p</i> <span class="CodeAnnotation" aria-label="annotation6">❻</span> and verifies <span class="CodeAnnotation" aria-label="annotation7">❼</span> that the value of <i>pq</i> equals the value of <i>n.</i> It then prints the resulting values of <i>p</i> and <i>q</i>:</p>&#13;
<pre><code>p = 2046223079&#13;
q = 17870599</code></pre>&#13;
<p class="TX">The program correctly returns the two factors.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec20">&#13;
<h3 class="H1" id="sec20"><span id="h1-75"/><samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp></h3>&#13;
<p class="TNI">RSA deserves a book by itself. I had to omit many important and interesting topics, such as Daniel Bleichenbacher’s padding oracle attack on OAEP’s predecessor (the standard PKCS#1 v1.5) or Manger’s padding oracle attack on OAEP, both attacks being similar in spirit to the padding oracle attack on block ciphers in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>. There’s also Michael Wiener’s attack on RSA with low private exponents, and attacks using Coppersmith’s method on RSA with small exponents that potentially also have insecure padding.</p>&#13;
<p class="TX">To see research results related to side-channel attacks and defenses, view the CHES workshop proceedings that have run since 1999 at <i><a href="https://ches.iacr.org">https://<wbr/>ches<wbr/>.iacr<wbr/>.org</a></i>. One of the most useful references while writing this chapter was <span role="doc-pagebreak" epub:type="pagebreak" id="pg_214" aria-label="214"/>Dan Boneh’s “Twenty Years of Attacks on the RSA Cryptosystem,” a survey that reviews and explains the most important attacks on RSA. For reference on timing attacks, the paper “Remote Timing Attacks Are Practical” by Billy Bob Brumley and Dan Boneh is a must-read, both for its analytical and experimental contributions. To learn more about fault attacks, read the full version of the Bellcore attack paper “On the Importance of Eliminating Errors in Cryptographic Computations” by Dan Boneh, Richard DeMillo, and Richard Lipton.</p>&#13;
<p class="TX">The best way to learn how RSA implementations work, though sometimes painful and frustrating, is to review the source code of widely used implementations. For example, see RSA and its underlying big-number arithmetic implementations in OpenSSL, NSS (the library used by the Mozilla Firefox browser), Crypto++, or other popular software, and examine their implementations of arithmetic operations as well as their defenses against timing and fault attacks.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>