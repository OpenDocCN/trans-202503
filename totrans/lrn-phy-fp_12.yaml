- en: '11'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CREATING GRAPHS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you make a graph for a formal report, you want to have titles, axis labels,
    and perhaps other features that will help the reader understand what you are trying
    to say. In this chapter, we’ll show you how to create such a graph using Haskell.
    We’ll look at titles, axis labels, and other labels. We’ll see how to plot data
    given in the form of a list of pairs. Then we’ll show how to plot multiple functions
    or multiple datasets on the same set of axes, how to control the axis ranges,
    and how to produce your graph as a file that can be imported into some other document.
  prefs: []
  type: TYPE_NORMAL
- en: Title and Axis Labels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code produces a graph with a title and axis labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As in the last chapter, we turn on warnings to catch any poor programming we
    might not have intended. Then we import the `Graphics.Gnuplot.Simple` module,
    which we use to make plots. Next, we set up `R` as a *type synonym* for `Double`.
    This lets us think of `Double`s as real numbers and call them by the short name
    `R`. We then define a list tRange of time values that we will use in our plot,
    and we define a function yPos for the height of a projectile.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we define plot1 to make a plot. Recall that plotFunc has type
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: where `a` is a type in some specialized type classes. The `Attribute` type is
    defined in the `Graphics.Gnuplot.Simple` module. If you type `:i Attribute` at
    the GHCi prompt (:i is short for :info), you’ll see some options for what you
    can do with these `Attribute`s. In `plot1`, we pass a list of five `Attribute`s
    to `plotFunc`. The first creates the title, the second and third produce axis
    labels, the fourth specifies the filename to use for the output, and the last
    requests that a legend not appear.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the type `IO ()` (pronounced “eye oh unit”) of plot1\. `IO` is a type
    constructor, like `Maybe`, but it’s a special type constructor that’s designed
    to signal an effect, which is a computation that is not purely functional. An
    effect changes the world in some way (for example, changing a file on the hard
    drive or showing a picture on the screen).
  prefs: []
  type: TYPE_NORMAL
- en: The type `()`, called *unit*, is a type that contains only one value, which
    is also written `()` and also called unit. A type with only one value can’t convey
    any information because there is no choice about what the value might be. Since
    it cannot convey any information, the unit type by itself is not too useful. However,
    coupled with the `IO` type constructor, the type `IO ()` comes to represent an
    effect without a value, which is a very useful type.
  prefs: []
  type: TYPE_NORMAL
- en: The `Attribute` of `Key Nothing` omits the key that is included with the graph
    by default. Since the key makes reference to a temporary file that we don’t care
    about, it is generally uninformative to include the default key. The reader should
    be warned that the `Graphics.Gnuplot.Simple` module is not merely simple, but
    a bit simple-minded. In particular, if an invalid `gnuplot` keyword is passed
    through a Haskell `String`, the result is no output at all, not even an error.
    (For example, if you want to move the legend key to the bottom of the plot instead
    of the top, the attribute `Key (Just ["bottom"])` works, but `Key (Just ["Bottom"])`
    fails with no output because `gnuplot` keywords are case sensitive.) The reader
    is encouraged to consult the online documentation for the `Graphics.Gnuplot.Simple`
    module as well as the documentation for the `gnuplot` program itself.
  prefs: []
  type: TYPE_NORMAL
- en: If you load the code just shown into GHCi and enter plot1 at the prompt, it
    will produce a file called *projectile.png* on your hard drive that you can include
    in a document. [Figure 11-1](ch11.xhtml#ch11fig1) shows what it looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/167fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-1: Graph produced by the function plot1*'
  prefs: []
  type: TYPE_NORMAL
- en: Other Labels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may want to put other labels on a plot. Here is how you can do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note the `Custom` attribute we added. The backslash in front of the quotes is
    because we need to pass quotes inside of quotes. The coordinates `1.5,22` are
    the horizontal and vertical coordinates on the graph where we want the label to
    appear. [Figure 11-2](ch11.xhtml#ch11fig2) shows what this looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/168fig01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*Figure 11-2: Graph produced by the function plot1Custom*'
  prefs: []
  type: TYPE_NORMAL
- en: The syntax for including a custom label is sufficiently awkward and difficult
    to remember that it makes sense to write a new function that takes its arguments
    in a simpler way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We are passing two pieces of information to the custom label function: the
    coordinates of the location of the label and the name of the label. The first
    piece of information has type `(R,R)`, and the second has type `String`. Our function
    `customLabel` will produce an `Attribute` that can be included in the attribute
    list of the function `plotFunc`. We use the `show` function to convert an `R`
    to a `String`, and we use the `++` operator to concatenate strings.'
  prefs: []
  type: TYPE_NORMAL
- en: We refer to the double-quote character in Haskell by prefixing it with a backslash.
    The backslash tells the compiler that we mean to write the double-quote character
    itself rather than to signal the beginning of a string. Having done this, we can
    treat the double quote character as any other character.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Having defined the function `customLabel`, we can use the following nicer syntax
    to make our graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Plotting Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There will be times when we want to plot points of (x, y) pairs rather than
    functions. We can use the plotPath function for this (also defined in the package
    `Graphics.Gnuplot.Simple`). Let’s take a look at the type of the plotPath function
    to better understand its use.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After a list of attributes, `plotPath` takes a list of pairs containing the
    data we want to plot. Here is code to produce the same graph as in [Figure 11-2](ch11.xhtml#ch11fig2)
    but using `plotPath` instead of `plotFunc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We used a list comprehension to produce the list of pairs that `plotPath` requires.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Curves on One Set of Axes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can plot multiple curves on a single set of axes. This is particularly useful
    if you want to compare two functions that have the same independent and dependent
    variables. The function `plotFuncs` from `Graphics.Gnuplot.Simple` enables us
    to plot a list of functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the plotFuncs function takes a list of functions as one of its
    arguments. We promised back in [Chapter 5](ch05.xhtml) that we would find a use
    for a list of functions, and now we have! Here is an example of how to use `plotFuncs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The range of x-values does not have to be the same for the two plots. Consider
    the following example, which introduces the new function plotPaths.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `plotPaths` function takes a list of lists of pairs where the `plotPath`
    function takes a list of pairs.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the Plot Ranges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, `gnuplot` (the program that is making the graphs behind the scenes)
    will make plots based on the x-ranges you provide and the corresponding calculated
    y-ranges. Sometimes, you may want more control over the x-range or the y-range.
  prefs: []
  type: TYPE_NORMAL
- en: 'Revisiting the previous example of three plots, try the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By specifying `XRange (-2,8)`, we produce a graph that runs from *x* = –2 to
    *x* = 8\. Since `xRange` runs from 0 to 10, no data is calculated in the region
    from *x* = –2 to *x* = 0, so this region is blank on the graph. Although we ask
    for data to be calculated up to *x* = 10, it is only shown up to *x* = 8\. Because
    we specify `YRange (-0.2,1)`, values of the cosine and sine functions that fall
    in the region from *y* = –1 to *y* = –0.2 are not shown.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the funny stylistic way in which I made the list [XRange (-2,8), YRange
    (-0.2,1)]. People who code in Haskell sometimes put the comma first on the second
    line of the list, but you don’t have to. You could put this all on one line, or
    put the comma at the end of the first line. It’s a matter of style.
  prefs: []
  type: TYPE_NORMAL
- en: Making a Key
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The default key that `gnuplot` provides with a graph is not very useful. It
    gives the name of a temporary file we are not interested in. It is not a trivial
    thing to produce a handsome key, but it can be done. The following code gives
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here we use the function `plotPathsStyle`, which is an extended version of `plotPaths`
    that allows stylistic alterations. Instead of the list of lists of pairs that
    `plotPaths` requires, `plotPathsStyle` requires a list of pairs, with each pair
    consisting of a `PlotStyle` and a list of pairs with the data to be plotted. In
    this way, we can give a title to each curve that shows up in the key.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we added plotting tools to our toolkit. We learned how to provide
    a title, axis labels, and other labels to a graph. We learned how to plot data
    given in the form of a list of pairs. We saw how to plot multiple functions or
    multiple lists of pairs on a single set of axes. We learned how to manually control
    the axis ranges and how to produce the graph as a file that can be imported into
    another document. In the next chapter, we’ll learn how to make stand-alone programs
    in Haskell.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 11.1.** Make a plot of *y* = *x*² from *x* = –3 to *x* = 3 with
    a title and axis labels.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 11.2.** Make a plot of the cosine and sine functions, together on
    a single set of axes, from *x* = 0 to *x* = 10.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 11.3.** Take a look at the type signature for `plotPath`, and figure
    out how to plot the list of points `txPairs` below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Make a plot with a title and axis labels (with units).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 11.4.** Write a function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: that approximates the sine function by the first four terms in its Taylor expansion.
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/172equ01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: (Depending on how you do this, you may or may not run into the issue that you
    cannot divide an `R` by an `Int` or an `Integer` in Haskell. You can only divide
    a numeric type by the same numeric type. If you run into this problem, you can
    use the function `fromIntegral` to convert an `Int` or an `Integer` to some other
    type, like `R`.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Test your function by trying the following command in GHCi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Make a nice version of this plot (with a title, axis labels, labels to indicate
    which curve is which, and so on).
  prefs: []
  type: TYPE_NORMAL
