- en: '11'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CREATING GRAPHS
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: When you make a graph for a formal report, you want to have titles, axis labels,
    and perhaps other features that will help the reader understand what you are trying
    to say. In this chapter, we’ll show you how to create such a graph using Haskell.
    We’ll look at titles, axis labels, and other labels. We’ll see how to plot data
    given in the form of a list of pairs. Then we’ll show how to plot multiple functions
    or multiple datasets on the same set of axes, how to control the axis ranges,
    and how to produce your graph as a file that can be imported into some other document.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Title and Axis Labels
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code produces a graph with a title and axis labels:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As in the last chapter, we turn on warnings to catch any poor programming we
    might not have intended. Then we import the `Graphics.Gnuplot.Simple` module,
    which we use to make plots. Next, we set up `R` as a *type synonym* for `Double`.
    This lets us think of `Double`s as real numbers and call them by the short name
    `R`. We then define a list tRange of time values that we will use in our plot,
    and we define a function yPos for the height of a projectile.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we define plot1 to make a plot. Recall that plotFunc has type
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: where `a` is a type in some specialized type classes. The `Attribute` type is
    defined in the `Graphics.Gnuplot.Simple` module. If you type `:i Attribute` at
    the GHCi prompt (:i is short for :info), you’ll see some options for what you
    can do with these `Attribute`s. In `plot1`, we pass a list of five `Attribute`s
    to `plotFunc`. The first creates the title, the second and third produce axis
    labels, the fourth specifies the filename to use for the output, and the last
    requests that a legend not appear.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Notice the type `IO ()` (pronounced “eye oh unit”) of plot1\. `IO` is a type
    constructor, like `Maybe`, but it’s a special type constructor that’s designed
    to signal an effect, which is a computation that is not purely functional. An
    effect changes the world in some way (for example, changing a file on the hard
    drive or showing a picture on the screen).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: The type `()`, called *unit*, is a type that contains only one value, which
    is also written `()` and also called unit. A type with only one value can’t convey
    any information because there is no choice about what the value might be. Since
    it cannot convey any information, the unit type by itself is not too useful. However,
    coupled with the `IO` type constructor, the type `IO ()` comes to represent an
    effect without a value, which is a very useful type.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: The `Attribute` of `Key Nothing` omits the key that is included with the graph
    by default. Since the key makes reference to a temporary file that we don’t care
    about, it is generally uninformative to include the default key. The reader should
    be warned that the `Graphics.Gnuplot.Simple` module is not merely simple, but
    a bit simple-minded. In particular, if an invalid `gnuplot` keyword is passed
    through a Haskell `String`, the result is no output at all, not even an error.
    (For example, if you want to move the legend key to the bottom of the plot instead
    of the top, the attribute `Key (Just ["bottom"])` works, but `Key (Just ["Bottom"])`
    fails with no output because `gnuplot` keywords are case sensitive.) The reader
    is encouraged to consult the online documentation for the `Graphics.Gnuplot.Simple`
    module as well as the documentation for the `gnuplot` program itself.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Key Nothing`的`Attribute`省略了默认包含在图表中的键。由于该键引用的是一个我们不关心的临时文件，通常不包括默认键是没有信息意义的。读者应当被告知，`Graphics.Gnuplot.Simple`模块不仅仅是简单的，它有点“简单粗暴”。特别是，如果通过
    Haskell 的`String`传递一个无效的`gnuplot`关键字，结果是完全没有输出，甚至没有错误信息。（例如，如果你想将图例的键从图表顶部移动到底部，`Key
    (Just ["bottom"])`是有效的，但`Key (Just ["Bottom"])`将没有任何输出，因为`gnuplot`的关键字是区分大小写的。）建议读者查阅`Graphics.Gnuplot.Simple`模块的在线文档以及`gnuplot`程序本身的文档。'
- en: If you load the code just shown into GHCi and enter plot1 at the prompt, it
    will produce a file called *projectile.png* on your hard drive that you can include
    in a document. [Figure 11-1](ch11.xhtml#ch11fig1) shows what it looks like.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将刚才显示的代码加载到 GHCi 并在提示符下输入 plot1，它将生成一个名为*projectile.png*的文件，并保存在硬盘上，你可以将它插入到文档中。[图
    11-1](ch11.xhtml#ch11fig1)展示了它的样子。
- en: '![Image](Images/167fig01.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/167fig01.jpg)'
- en: '*Figure 11-1: Graph produced by the function plot1*'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-1：由函数 plot1 生成的图表*'
- en: Other Labels
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他标签
- en: 'You may want to put other labels on a plot. Here is how you can do so:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望在图表上放置其他标签。以下是你可以做到的方法：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note the `Custom` attribute we added. The backslash in front of the quotes is
    because we need to pass quotes inside of quotes. The coordinates `1.5,22` are
    the horizontal and vertical coordinates on the graph where we want the label to
    appear. [Figure 11-2](ch11.xhtml#ch11fig2) shows what this looks like.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们添加的`Custom`属性。引号前的反斜杠是因为我们需要在引号内传递引号。坐标`1.5,22`是我们希望标签出现的图表上的水平和垂直坐标。[图
    11-2](ch11.xhtml#ch11fig2)显示了它的样子。
- en: '![Image](Images/168fig01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![Image](Images/168fig01.jpg)'
- en: '*Figure 11-2: Graph produced by the function plot1Custom*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 11-2：由函数 plot1Custom 生成的图表*'
- en: The syntax for including a custom label is sufficiently awkward and difficult
    to remember that it makes sense to write a new function that takes its arguments
    in a simpler way.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 包含自定义标签的语法相当繁琐且难以记忆，因此写一个接受更简单参数的新函数是明智的选择。
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We are passing two pieces of information to the custom label function: the
    coordinates of the location of the label and the name of the label. The first
    piece of information has type `(R,R)`, and the second has type `String`. Our function
    `customLabel` will produce an `Attribute` that can be included in the attribute
    list of the function `plotFunc`. We use the `show` function to convert an `R`
    to a `String`, and we use the `++` operator to concatenate strings.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向自定义标签函数传递了两项信息：标签位置的坐标和标签的名称。第一项信息的类型是`(R,R)`，第二项的类型是`String`。我们的函数`customLabel`将生成一个`Attribute`，可以包含在`plotFunc`函数的属性列表中。我们使用`show`函数将`R`类型转换为`String`，并使用`++`运算符连接字符串。
- en: We refer to the double-quote character in Haskell by prefixing it with a backslash.
    The backslash tells the compiler that we mean to write the double-quote character
    itself rather than to signal the beginning of a string. Having done this, we can
    treat the double quote character as any other character.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Haskell 中，我们通过在双引号字符前添加反斜杠来引用它。反斜杠告诉编译器我们是想写双引号字符本身，而不是表示字符串的开始。完成这一操作后，我们可以将双引号字符视为任何其他字符。
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Having defined the function `customLabel`, we can use the following nicer syntax
    to make our graph:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了`customLabel`函数后，我们可以使用以下更简洁的语法来绘制我们的图表：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Plotting Data
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制数据
- en: There will be times when we want to plot points of (x, y) pairs rather than
    functions. We can use the plotPath function for this (also defined in the package
    `Graphics.Gnuplot.Simple`). Let’s take a look at the type of the plotPath function
    to better understand its use.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After a list of attributes, `plotPath` takes a list of pairs containing the
    data we want to plot. Here is code to produce the same graph as in [Figure 11-2](ch11.xhtml#ch11fig2)
    but using `plotPath` instead of `plotFunc`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We used a list comprehension to produce the list of pairs that `plotPath` requires.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Curves on One Set of Axes
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can plot multiple curves on a single set of axes. This is particularly useful
    if you want to compare two functions that have the same independent and dependent
    variables. The function `plotFuncs` from `Graphics.Gnuplot.Simple` enables us
    to plot a list of functions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notice that the plotFuncs function takes a list of functions as one of its
    arguments. We promised back in [Chapter 5](ch05.xhtml) that we would find a use
    for a list of functions, and now we have! Here is an example of how to use `plotFuncs`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The range of x-values does not have to be the same for the two plots. Consider
    the following example, which introduces the new function plotPaths.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `plotPaths` function takes a list of lists of pairs where the `plotPath`
    function takes a list of pairs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the Plot Ranges
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, `gnuplot` (the program that is making the graphs behind the scenes)
    will make plots based on the x-ranges you provide and the corresponding calculated
    y-ranges. Sometimes, you may want more control over the x-range or the y-range.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Revisiting the previous example of three plots, try the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By specifying `XRange (-2,8)`, we produce a graph that runs from *x* = –2 to
    *x* = 8\. Since `xRange` runs from 0 to 10, no data is calculated in the region
    from *x* = –2 to *x* = 0, so this region is blank on the graph. Although we ask
    for data to be calculated up to *x* = 10, it is only shown up to *x* = 8\. Because
    we specify `YRange (-0.2,1)`, values of the cosine and sine functions that fall
    in the region from *y* = –1 to *y* = –0.2 are not shown.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Notice the funny stylistic way in which I made the list [XRange (-2,8), YRange
    (-0.2,1)]. People who code in Haskell sometimes put the comma first on the second
    line of the list, but you don’t have to. You could put this all on one line, or
    put the comma at the end of the first line. It’s a matter of style.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Making a Key
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The default key that `gnuplot` provides with a graph is not very useful. It
    gives the name of a temporary file we are not interested in. It is not a trivial
    thing to produce a handsome key, but it can be done. The following code gives
    an example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we use the function `plotPathsStyle`, which is an extended version of `plotPaths`
    that allows stylistic alterations. Instead of the list of lists of pairs that
    `plotPaths` requires, `plotPathsStyle` requires a list of pairs, with each pair
    consisting of a `PlotStyle` and a list of pairs with the data to be plotted. In
    this way, we can give a title to each curve that shows up in the key.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, we added plotting tools to our toolkit. We learned how to provide
    a title, axis labels, and other labels to a graph. We learned how to plot data
    given in the form of a list of pairs. We saw how to plot multiple functions or
    multiple lists of pairs on a single set of axes. We learned how to manually control
    the axis ranges and how to produce the graph as a file that can be imported into
    another document. In the next chapter, we’ll learn how to make stand-alone programs
    in Haskell.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 11.1.** Make a plot of *y* = *x*² from *x* = –3 to *x* = 3 with
    a title and axis labels.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 11.2.** Make a plot of the cosine and sine functions, together on
    a single set of axes, from *x* = 0 to *x* = 10.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 11.3.** Take a look at the type signature for `plotPath`, and figure
    out how to plot the list of points `txPairs` below:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Make a plot with a title and axis labels (with units).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercise 11.4.** Write a function'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: that approximates the sine function by the first four terms in its Taylor expansion.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/172equ01.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: (Depending on how you do this, you may or may not run into the issue that you
    cannot divide an `R` by an `Int` or an `Integer` in Haskell. You can only divide
    a numeric type by the same numeric type. If you run into this problem, you can
    use the function `fromIntegral` to convert an `Int` or an `Integer` to some other
    type, like `R`.)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'Test your function by trying the following command in GHCi:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Make a nice version of this plot (with a title, axis labels, labels to indicate
    which curve is which, and so on).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
