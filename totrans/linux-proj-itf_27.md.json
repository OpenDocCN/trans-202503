["```\n#include <unistd.h>\n\nint `execve`(const char **pathname*, char *const *argv*[], char *const *envp*[]);\n```", "```\n$ `./t_execve ./envargs`\nargv[0] = envargs                   *All of the output is printed by* `envargs`\nargv[1] = hello world\nargv[2] = goodbye\nenviron: GREET=salut\nenviron: BYE=adieu\n```", "```\n`procexec/t_execve.c`\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    char *argVec[10];           /* Larger than required */\n    char *envVec[] = { \"GREET=salut\", \"BYE=adieu\", NULL };\n\n    if (argc != 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s pathname\\n\", argv[0]);\n\n    argVec[0] = strrchr(argv[1], '/');      /* Get basename from argv[1] */\n    if (argVec[0] != NULL)\n        argVec[0]++;\n    else\n        argVec[0] = argv[1];\n    argVec[1] = \"hello world\";\n    argVec[2] = \"goodbye\";\n    argVec[3] = NULL;           /* List must be NULL-terminated */\n\n    execve(argv[1], argVec, envVec);\n    errExit(\"execve\");          /* If we get here, something went wrong */\n}\n\n      `procexec/t_execve.c`\n```", "```\n`procexec/envargs.c`\n#include \"tlpi_hdr.h\"\n\nextern char **environ;\n\nint\nmain(int argc, char *argv[])\n{\n    int j;\n    char **ep;\n\n    for (j = 0; j < argc; j++)\n        printf(\"argv[%d] = %s\\n\", j, argv[j]);\n\n    for (ep = environ; *ep != NULL; ep++)\n        printf(\"environ: %s\\n\", *ep);\n\n    exit(EXIT_SUCCESS);\n}\n     `procexec/envargs.c`\n```", "```\n#include <unistd.h>\n\nint `execle`(const char **pathname*, const char **arg*, ...\n                /* , (char *) NULL, char *const *envp*[] */ );\nint `execlp`(const char **filename*, const char **arg*, ...\n                /* , (char *) NULL */);\nint `execvp`(const char **filename*, char *const *argv*[]);\nint `execv`(const char **pathname*, char *const *argv*[]);\nint `execl`(const char **pathname*, const char **arg*, ...\n                /* , (char *) NULL */);\n```", "```\n$ `echo $PATH`\n/home/mtk/bin:/usr/local/bin:/usr/bin:/bin:.\n```", "```\n$ `which echo`\n/bin/echo\n$ `ls -l /bin/echo`\n-rwxr-xr-x    1 root      15428 Mar 19 21:28 /bin/echo\n$ `echo $PATH`                      *Show contents of* `PATH`\n*environment variable*\n/home/mtk/bin:/usr/local/bin:/usr/bin:/bin/      bin *is in* PATH\n$ `./t_execlp echo`                 execlp() *uses* PATH *to successfully find* echo\nhello world\n```", "```\n$ `PATH=/home/mtk/bin:/usr/local/bin:/usr/bin`\n$ `./t_execlp echo`\nERROR [ENOENT No such file or directory] execlp\n$ `./t_execlp /bin/echo`\nhello world\n```", "```\n`procexec/t_execlp.c`\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    if (argc != 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s pathname\\n\", argv[0]);\n\n    execlp(argv[1], argv[1], \"hello world\", (char *) NULL);\n    errExit(\"execlp\");          /* If we get here, something went wrong */\n}\n     `procexec/t_execlp.c`\n```", "```\n`procexec/t_execle.c`\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    char *envVec[] = { \"GREET=salut\", \"BYE=adieu\", NULL };\n    char *filename;\n\n    if (argc != 2 || strcmp(argv[1], \"--help\") == 0)\n        usageErr(\"%s pathname\\n\", argv[0]);\n\n    filename = strrchr(argv[1], '/');       /* Get basename from argv[1] */\n    if (filename != NULL)\n        filename++;\n    else\n        filename = argv[1];\n\n    execle(argv[1], filename, \"hello world\", (char *) NULL, envVec);\n    errExit(\"execle\");          /* If we get here, something went wrong */\n}\n      `procexec/t_execle.c`\n```", "```\n$ `echo $USER $SHELL`           *Display some of the shell’s environment variables*\nblv /bin/bash\n$ `./t_execl`\nInitial value of USER: blv    *Copy of environment was inherited from the shell*\nbritta                        *These two lines are displayed by execed* printenv\n/bin/bash\n```", "```\n`procexec/t_execl.c`\n#include <stdlib.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    printf(\"Initial value of USER: %s\\n\", getenv(\"USER\"));\n    if (putenv(\"USER=britta\") != 0)\n        errExit(\"putenv\");\n\n    execl(\"/usr/bin/printenv\", \"printenv\", \"USER\", \"SHELL\", (char *) NULL);\n    errExit(\"execl\");           /* If we get here, something went wrong */\n}\n     `procexec/t_execl.c`\n```", "```\n#define _GNU_SOURCE\n#include <unistd.h>\n\nint `fexecve`(int *fd*, char *const *argv*[], char *const *envp*[]);\n```", "```\n#! *interpreter-path* [*optional-arg*]\n```", "```\n#!/bin/sh\n```", "```\n*`interpreter-path`* [*`optional-arg`* ] *`script-path arg`*...\n```", "```\n$ `cat > necho.script`                *Create script*\n#!/home/mtk/bin/necho some argument\nSome junk\n*Type Control-D*\n$ `chmod +x necho.script`             *Make script executable*\n$ `./t_execve necho.script`           *And exec the script*\nargv[0] = /home/mtk/bin/necho       *First 3 arguments are generated by kernel*\nargv[1] = some argument             *Script argument is treated as a single word*\nargv[2] = necho.script              *This is the script path*\nargv[3] = hello world               *This was argVec[1] given to execve()*\nargv[4] = goodbye                   *And this was argVec[2]*\n```", "```\n$ `awk` `'```", "```'` ``*`input-file`*``...\n```", "```\n$ `cat longest_line.awk`\n#!/usr/bin/awk\nlength > max { max = length; }\nEND          { print max; }\n```", "```\nexecl(\"longest_line.awk\", \"longest_line.awk\", \"input.txt\", (char *) NULL);\n```", "```\n/usr/bin/awk longest_line.awk input.txt\n```", "```\n#!/usr/bin/awk -f\nlength > max { max = length; }\nEND          { print max; }\n```", "```\n/usr/bin/awk -f longest_line.awk input.txt\n```", "```\n$ `ls /tmp > dir.txt`\n```", "```\n        fd = open(\"dir.txt\", O_WRONLY | O_CREAT,\n                    S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP |\n         S_IROTH | S_IWOTH);                     /* rw-rw-rw- */\n        if (fd != STDOUT_FILENO) {\n            dup2(fd, STDOUT_FILENO);\n            close(fd);\n        }\n        ```", "```\nint flags;\n\nflags = fcntl(fd, F_GETFD);\nif (flags == -1)\n    errExit(\"fcntl\");\n```", "```\nflags |= FD_CLOEXEC;\nif (fcntl(fd, F_SETFD, flags) == -1)\n    errExit(\"fcntl\");\n```", "```\n$ `./closeonexec`                     *Exec ls without closing standard output*\n-rwxr-xr-x   1 mtk    users    28098 Jun 15 13:59 closeonexec\n$ `./closeonexec n`                   *Sets close-on-exec flag for standard output*\nls: write error: Bad file descriptor\n```", "```\n`procexec/closeonexec.c`\n#include <fcntl.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    int flags;\n\n    if (argc > 1) {\n        flags = fcntl(STDOUT_FILENO, F_GETFD);              /* Fetch flags */\n        if (flags == -1)\n            errExit(\"fcntl - F_GETFD\");\n\n        flags |= FD_CLOEXEC;                    /* Turn on FD_CLOEXEC */\n\n        if (fcntl(STDOUT_FILENO, F_SETFD, flags) == -1)     /* Update flags */\n            errExit(\"fcntl - F_SETFD\");\n    }\n\n    execlp(\"ls\", \"ls\", \"-l\", argv[0], (char *) NULL);\n    errExit(\"execlp\");\n}\n     `procexec/closeonexec.c`\n```", "```\n#include <stdlib.h>\n\nint `system`(const char **command*);\n```", "```\nsystem(\"ls | wc\");\n```", "```\n$ `./t_system`\nCommand: `whoami`\nmtk\nsystem() returned: status=0x0000 (0,0)\nchild exited, status=0\nCommand: `ls | grep XYZ`                   *Shell terminates with the status of...*\nsystem() returned: status=0x0100 (1,0)   *its last command (grep), which...*\nchild exited, status=1                   *found no match, and so did an exit(1)*\nCommand: `exit 127`\nsystem() returned: status=0x7f00 (127,0)\n(Probably) could not invoke shell        *Actually, not true in this case*\nCommand: `sleep 100`\n*Type Control-Z to suspend foreground process group*\n[1]+  Stopped           ./t_system\n$ `ps | grep sleep`                        *Find PID of sleep*\n29361 pts/6    00:00:00 sleep\n$ `kill 29361`                             *And send a signal to terminate it*\n$ `fg`                                     *Bring t_system back into foreground*\n./t_system\nsystem() returned: status=0x000f (0,15)\nchild killed by signal 15 (Terminated)\nCommand: `^D`$                             *Type Control-D to terminate program*\n```", "```\n`procexec/t_system.c`\n#include <sys/wait.h>\n#include \"print_wait_status.h\"\n#include \"tlpi_hdr.h\"\n\n#define MAX_CMD_LEN 200\n\nint\nmain(int argc, char *argv[])\n{\n    char str[MAX_CMD_LEN];      /* Command to be executed by system() */\n    int status;                 /* Status return from system() */\n\n    for (;;) {                  /* Read and execute a shell command */\n        printf(\"Command: \");\n        fflush(stdout);\n        if (fgets(str, MAX_CMD_LEN, stdin) == NULL)\n            break;              /* end-of-file */\n\n        status = system(str);\n        printf(\"system() returned: status=0x%04x (%d,%d)\\n\",\n                (unsigned int) status, status >> 8, status & 0xff);\n\n        if (status == -1) {\n            errExit(\"system\");\n        } else {\n            if (WIFEXITED(status) && WEXITSTATUS(status) == 127)\n                printf(\"(Probably) could not invoke shell\\n\");\n            else                /* Shell successfully executed command */\n                printWaitStatus(NULL, status);\n        }\n    }\n\n    exit(EXIT_SUCCESS);\n}\n     `procexec/t_system.c`\n```", "```\n$ `sh -c \"ls | wc\"`\n     38      38     444\n```", "```\nexecl(\"/bin/sh\", \"sh\", \"-c\", command, (char *) NULL);\n```", "```\n`procexec/simple_system.c`\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n\nint\nsystem(char *command)\n{\n    int status;\n    pid_t childPid;\n\n    switch (childPid = fork()) {\n    case -1: /* Error */\n        return -1;\n\n    case 0: /* Child */\n        execl(\"/bin/sh\", \"sh\", \"-c\", command, (char *) NULL);\n        _exit(127);                     /* Failed exec */\n\n    default: /* Parent */\n        if (waitpid(childPid, &status, 0) == -1)\n            return -1;\n        else\n            return status;\n    }\n}\n      `procexec/simple_system.c`\n```", "```\nsystem(\"sleep 20\");\n```", "```\n`procexec/system.c`\n    #include <unistd.h>\n    #include <signal.h>\n    #include <sys/wait.h>\n    #include <sys/types.h>\n    #include <errno.h>\n\n    int\n    system(const char *command)\n    {\n        sigset_t blockMask, origMask;\n        struct sigaction saIgnore, saOrigQuit, saOrigInt, saDefault;\n        pid_t childPid;\n        int status, savedErrno;\n\n    if (command == NULL)                /* Is a shell available? */\n            return system(\":\") == 0;\n\n            sigemptyset(&blockMask);            /* Block SIGCHLD */\n        sigaddset(&blockMask, SIGCHLD);\n  sigprocmask(SIG_BLOCK, &blockMask, &origMask);\n\n        saIgnore.sa_handler = SIG_IGN;      /* Ignore SIGINT and SIGQUIT */\n        saIgnore.sa_flags = 0;\n        sigemptyset(&saIgnore.sa_mask);\n  sigaction(SIGINT, &saIgnore, &saOrigInt);\n        sigaction(SIGQUIT, &saIgnore, &saOrigQuit);\n\n        switch (childPid = fork()) {\n        case -1: /* fork() failed */\n            status = -1;\n            break;                  /* Carry on to reset signal attributes */\n\n        case 0: /* Child: exec command */\n            saDefault.sa_handler = SIG_DFL;\n            saDefault.sa_flags = 0;\n            sigemptyset(&saDefault.sa_mask);\n      if (saOrigInt.sa_handler != SIG_IGN)\n                sigaction(SIGINT, &saDefault, NULL);\n            if (saOrigQuit.sa_handler != SIG_IGN)\n                sigaction(SIGQUIT, &saDefault, NULL);\n\n      sigprocmask(SIG_SETMASK, &origMask, NULL);\n\n            execl(\"/bin/sh\", \"sh\", \"-c\", command, (char *) NULL);\n      _exit(127);                     /* We could not exec the shell */\n\n        default: /* Parent: wait for our child to terminate */\n        while (waitpid(childPid, &status, 0) == -1) {\n                if (errno != EINTR) {       /* Error other than EINTR */\n                    status = -1;\n\n                    break;                  /* So exit loop */\n                }\n            }\n            break;\n        }\n\n        /* Unblock SIGCHLD, restore dispositions of SIGINT and SIGQUIT */\n\n    savedErrno = errno;                 /* The following may change 'errno' */\n\n    sigprocmask(SIG_SETMASK, &origMask, NULL);\n        sigaction(SIGINT, &saOrigInt, NULL);\n        sigaction(SIGQUIT, &saOrigQuit, NULL);\n\n    errno = savedErrno;\n\n        return status;\n    }\n\n          `procexec/system.c`\n```", "```\nchar path[PATH_MAX];\n\nif (confstr(_CS_PATH, path, PATH_MAX) == 0)\n    _exit(127);\nif (setenv(\"PATH\", path, 1) == -1)\n    _exit(127);\nexeclp(\"sh\", \"sh\", \"-c\", command, (char *) NULL);\n_exit(127);\n```", "```\n    $ `echo $PATH`\n    /usr/local/bin:/usr/bin:/bin:./dir1:./dir2\n    $ `ls -l dir1`\n    total 8\n    -rw-r—r—   1 mtk      users        7860 Jun 13 11:55 xyz\n    $ `ls -l dir2`\n    total 28\n    -rwxr-xr-x   1 mtk      users       27452 Jun 13 11:55 xyz\n    $ `./t_execlp xyz`\n    ```", "```\n    #!/bin/cat -n\n    Hello world\n    ```", "```\n    childPid = fork();\n    if (childPid == -1)\n        errExit(\"fork1\");\n    if (childPid == 0) {    /* Child */\n        switch (fork()) {\n        case -1: errExit(\"fork2\");\n\n        case 0:             /* Grandchild */\n            /* ——- Do real work here ——- */\n            exit(EXIT_SUCCESS);             /* After doing real work */\n\n        default:\n            exit(EXIT_SUCCESS);             /* Make grandchild an orphan */\n        }\n    }\n\n    /* Parent falls through to here */\n\n    if (waitpid(childPid, &status, 0) == -1)\n        errExit(\"waitpid\");\n\n    /* Parent carries on to do other things */\n    ```", "```\n    #include \"tlpi_hdr.h\"\n\n    int\n    main(int argc, char *argv[])\n    {\n        printf(\"Hello world\");\n        execlp(\"sleep\", \"sleep\", \"0\", (char *) NULL);\n    }\n    ```"]