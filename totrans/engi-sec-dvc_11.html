<html><head></head><body>
<div id="sbo-rt-content"><h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_141"/><strong><span class="big">8</span><br/>SECURE BOOT AND SYSTEM INTEGRITY</strong></h2>
<div class="image1"><img alt="Image" height="252" src="../images/common.jpg" width="252"/></div>
<p class="noindent">During the boot process of embedded systems, the initialization of basic hardware as well as the startup of an OS take place. Many of these steps involve firmware stored in flash memory since that provides device engineers with the possibility to update. However, this replaceability comes at a price: attackers are able to tamper with that data for their own advantage.</p>
<p class="indent">In this chapter, I’ll explain the complexity of boot processes and various protection concepts. After introducing the classic secure boot chain concept, I’ll discuss practical considerations like the impact of secure boot process on development and production processes. As usual, theory and practice are not one and the same, so I’ll include a case study on implementing secure boot on the STM32MP157F platform.</p>
<p class="indent">Based on boot process integrity, you might wonder whether device integrity can be taken further, so this chapter also describes how to achieve integrity protections for filesystems and more. Finally, I’ll look at a low-cost firmware integrity solution for microcontroller-based systems that don’t rely on external flash memory and a complex boot process.</p>
<h3 class="h3" id="ch00lev1_63"><span epub:type="pagebreak" id="page_142"/><strong>System Boot Complexity</strong></h3>
<p class="noindent">Many modern microchips for embedded systems contain a variety of submodules and are therefore called <em>system-on-chips (SoCs)</em>. In addition to the availability of multiple CPU cores, GPUs, real-time cores, and similar supporting coprocessors contribute to a system’s complexity. Also, SoCs that include an FPGA continue to gain popularity and add bitstream handling to the equation.</p>
<p class="indent">Further, some SoCs provide a <em>trusted execution environment (TEE)</em>, which is used to separate the execution of critical software logically or physically—on a dedicated processing unit—from the ordinary firmware. In ARM-based SoCs, you’ll come across the terms <em>ARM TrustZone</em> and <em>ARM Trusted Firmware</em> that represent ARM’s TEE. The initialization of such an environment often takes place during the boot process. And, although those features aim for higher security, it can’t be denied that these technologies also lead to even more complexity—the natural enemy of intelligibility and security.</p>
<p class="indent">SoC devices also usually require further components on the PCB—for example, volatile double data rate (DDR) memory and nonvolatile storage, such as an embedded MultiMediaCard (eMMC) or similar flash memories. Initialization of necessary on-chip controllers and their parameters are further crucial parts of modern boot processes. <a href="ch08.xhtml#ch08fig01">Figure 8-1</a> gives an overview of typical software and hardware components of an SoC involved in its boot process.</p>
<div class="image"><img alt="Image" height="437" id="ch08fig01" src="../images/08fig01.jpg" width="916"/></div>
<p class="figcap"><em>Figure 8-1: The components of a typical SoC boot process</em></p>
<p class="indent">After power up, the boot procedure is initiated in hardware based on a boot read-only memory (ROM) <span class="ent">➊</span> that initializes internal structures and loads a minimalist first-stage bootloader (FSBL) like U-Boot SPL that’s copied to internal SRAM memory <span class="ent">➋</span>. This piece of software initializes the external DDR memory and places a fully-fledged second-stage bootloader (SSBL) there <span class="ent">➌</span>. The SSBL is able to provide several convenience features like boot medium selection, debugging, console access, and more. Afterward, the OS kernel, which in the embedded system context is often Linux, is started <span class="ent">➍</span>. <span epub:type="pagebreak" id="page_143"/>At this point, the boot process is “officially” over, and the device is in its runtime state.</p>
<p class="indent"><a href="ch08.xhtml#ch08fig02">Figure 8-2</a> shows the necessary steps for booting in temporal order.</p>
<div class="image"><img alt="Image" height="239" id="ch08fig02" src="../images/08fig02.jpg" width="887"/></div>
<p class="figcap"><em>Figure 8-2: The steps of a typical boot process</em></p>
<p class="indent">There is one basic property to highlight at this point: subsequent stages in a boot process always “trust” their predecessors. That means, for example, without external monitoring measures, an OS can’t tell a malicious boot-loader from the original one; it just relies on every configuration set and the parameters passed to it. Therefore, optimal boot-process protection has to start at its very beginning: in hardware.</p>
<h3 class="h3" id="ch00lev1_64"><strong>Boot Protection Concepts</strong></h3>
<p class="noindent">From the perspective of a customer or a device user, integrity is usually a desired protection goal for a device’s firmware and software. One relevant risk scenario is that cybercriminals try to persist malicious software in firmware to survive a reboot of the system—for example, to enable long-lasting backdoor access. Also, the manipulation of low-level configuration parameters and OS settings wouldn’t be possible with verification routines running at boot time. Even attacks that modify a device’s software during delivery, as reported to be performed by intelligence services, would render a product nonfunctional if solid integrity protection is implemented.</p>
<p class="indent">The authors of IEC 62443 (Part 4-2) also seem to have these scenarios in mind. The embedded device requirement (EDR) 3.14 for security level (SL) 1 or higher aims for integrity of the boot process. It requests that a device must be able to perform integrity verification of the firmware, software, and configuration data used in the device’s boot and runtime processes prior to their execution. Starting at SL 2, the standard even requires authenticity of all replaceable parts of the boot process.</p>
<p class="indent">Device manufacturers usually agree on the importance of integrity and authenticity of firmware and software because that also prevents attackers from installing custom software for reverse-engineering purposes. However, they have another risk to consider: loss of intellectual property. Even at early boot stages, such know-how might be cast in software, like optimized algorithms, proprietary protocols, and secrets. Therefore, in some cases, vendors would like to encrypt all firmware, software, and configuration data used during the boot process in order to protect their confidentiality.</p>
<p class="indentb"><span epub:type="pagebreak" id="page_144"/>The third stakeholder in this game is the chip-manufacturing industry that provides several protection measures advertised by associated marketing terms. The following list provides an overview of typical keywords, but of course, it might not capture all future marketing creativity:</p>
<p class="hanga"><strong>Secure boot</strong>    This generic term is the “classic” and most popular one. It usually stands for the step-by-step verification of integrity and authenticity of software components used throughout the boot process. From a cryptographic point of view, the verification is based on digital signatures and asymmetric algorithms like RSA or ECDSA. Whenever a signature verification fails, the boot process stops. Its details are explained in “Classic Secure Boot Chain” on <a href="ch08.xhtml#ch00lev1_65">page 145</a>.</p>
<p class="hanga"><strong>Verified boot</strong>    Similar to secure boot, this term stresses the cryptographic verification of the software parts executed in the boot chain. Intel uses this term, among others, as part of its Boot Guard technology, and Google utilizes it for Android and Chrome OSs.</p>
<p class="hanga"><strong>High-assurance boot</strong>    NXP works with this label to highlight boot-process protection for i.MX devices. Among other protections, this approach also uses digital signatures to verify integrity and authenticity as described by secure boot.</p>
<p class="hanga"><strong>Authenticated boot</strong>    This term might seem to express the authentication of firmware and other software components. However, the Trusted Computing Group (TCG) uses this term to describe a boot process that allows for reporting “an accurate record of the way that the platform booted.” That means pieces of software are hashed during the boot process and written to a TPM. The startup procedure is not interrupted if manipulated software is to be executed, but the later state, be it original or altered, can be reported to an external party or used by the TPM to grant or deny access to stored secrets.</p>
<p class="hanga"><strong>Measured boot</strong>    Microsoft uses this term in the context of TPM-based boot protection in which software is <em>measured</em>, or hashed, during the boot process. It’s similar to TCG’s authenticated boot.</p>
<p class="hanga"><strong>Trusted boot</strong>    This is sometimes found in close relation to TPM-protected boot processes. However, Microsoft also uses it to describe the verification of the Windows kernel and OS components.</p>
<p class="hanga"><strong>Encrypted boot</strong>    In contrast to all other listed forms of boot protection, this concept aims for confidentiality. In this case, firmware and related software are stored in an encrypted way, usually based on symmetric encryption algorithms. The decryption happens on the fly during boot and is usually supported by hardware.</p>
<div class="note">
<p class="notet"><span epub:type="pagebreak" id="page_145"/><strong><span class="notes">WARNING</span></strong></p>
<p class="notep"><em>Be careful whenever it comes to marketing terms for boot process protection. They can be misleading and sometimes implement only part of what you expect!</em></p>
</div>
<h3 class="h3" id="ch00lev1_65"><strong>Classic Secure Boot Chain</strong></h3>
<p class="noindent">For embedded devices, the most important variant of boot-process protection is the classic secure boot chain in which every component involved in the boot process verifies the next before handing over execution. Therefore, integrity and authenticity of all the software parts in a boot process can be achieved, which are often desirable requirements for several stakeholders.</p>
<p class="indent"><a href="ch08.xhtml#ch08fig03">Figure 8-3</a> shows a linear secure boot process from power up in hardware up to the point when the OS is running.</p>
<div class="image"><img alt="Image" height="342" id="ch08fig03" src="../images/08fig03.jpg" width="896"/></div>
<p class="figcap"><em>Figure 8-3: The steps in a classic secure boot process</em></p>
<p class="indent">In comparison to <a href="ch08.xhtml#ch08fig02">Figure 8-2</a>, notice the set of additional keys at every stage. These are public keys based on asymmetric crypto like RSA or ECDSA, which means they don’t carry any secret but are necessary to verify the signature of the subsequent boot stage. For example, the DDR bootloader has to carry the public key related to the signature of the OS kernel executed in the following boot step.</p>
<p class="indent">Although these keys aren’t required to stay confidential, they have a very important protection goal to fulfill: integrity. The reason for that is simple. If an attacker is able to replace a public key, a self-generated one can be stored instead. By changing a verification key, it becomes possible to correctly verify a forged, self-generated signature of a manipulated piece of software, which would break the secure boot chain.</p>
<p class="indent"><a href="ch08.xhtml#ch08fig04">Figure 8-4</a> shows how the involved public keys are stored in various places within an SoC. Most obviously, some of them are usually stored in flash memory, which is easy for attackers to manipulate.</p>
<div class="image"><span epub:type="pagebreak" id="page_146"/><img alt="Image" height="618" id="ch08fig04" src="../images/08fig04.jpg" width="916"/></div>
<p class="figcap"><em>Figure 8-4: The SoC components involved in a secure boot process</em></p>
<p class="indent">The “trick” for handling this issue is that the integrity of the secure boot chain can be reduced to the integrity of the first verification key. If this initial key is stored in flash memory, the guarantees of the secure boot process hold only as long as an attacker is not able to alter this memory content.</p>
<p class="indent">Microchips supporting secure boot usually provide OTP memory to physically burn the first public key or its hash into the device. This key is then used during boot ROM execution <span class="ent">➊</span> to verify the FSBL. The key for SSBL verification is included in the FSBL <span class="ent">➋</span>, and the SSBL carries the public key to verify the OS kernel <span class="ent">➌</span>, reaching the integrity goal for the whole boot chain. This verification chain might even be extended to kernel modules or application software by integrating further public keys into the OS kernel <span class="ent">➍</span>.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Keep in mind that only a secure boot chain starting in ROM within an SoC is a robust protection against boot software manipulation, because all protection guarantees can be traced back to the beginning of the boot chain.</em></p>
</div>
<h3 class="h3" id="ch00lev1_66"><strong>Considerations for Implementing Secure Boot</strong></h3>
<p class="noindent">Unfortunately, the implementation of secure boot is not like activating a single option in a configuration menu, which is probably why secure boot on embedded systems is still uncommon in the market. However, the following details aren’t meant to scare developers away, but rather to serve as a list of tasks to keep in mind if you decide to take on secure boot.</p>
<h4 class="h4" id="ch00lev2_84"><span epub:type="pagebreak" id="page_147"/><strong><em>Hardware and Software Requirements</em></strong></h4>
<p class="noindent">First, it’s important to understand that a consistent secure boot chain requires every part of that chain to support signature verification based on asymmetric crypto. Of course, that includes the chosen microcontroller running all software. If secure boot was not a requirement during chip purchase, integrating it afterward might not be possible.</p>
<p class="indent">Be sure to make secure boot a requirement during device architecture discussions. If the central microchip doesn’t support it, you’re forced to postpone the secure boot feature to the next device generation.</p>
<p class="indent">In addition, if software components don’t support signature verification, as might be the case for certain bootloaders, and you can’t integrate the functionality yourself, you’ll need to start the possibly tedious process of finding and implementing suitable replacements.</p>
<p class="indent">At the far end of the boot process, verifying the operating system kernel as a final step might be enough. However, on Linux, for example, you might also want to verify integrity and authenticity of kernel modules, or even extend the verification process to filesystems and applications as discussed in “Integrity Protection Beyond the Boot Process” on <a href="ch08.xhtml#ch00lev1_69">page 154</a>.</p>
<p class="indent">But even if all your software already supports digital signature verification, several changes are necessary to incorporate secure boot, from hardware initialization to bootloader settings and maybe even OS kernel configuration.</p>
<h4 class="h4" id="ch00lev2_85"><strong><em>Development Process</em></strong></h4>
<p class="noindent">On the development side, the signature generation process (for example, within a CI pipeline), has to be established. Depending on the hardware and software used within the device, integrating vendor-specific tools, such as for signing and final image generation, might be necessary. If you’re lucky, the use of the <code>openssl</code> command line tool will be sufficient.</p>
<div class="note">
<p class="notet"><strong><span class="notes">WARNING</span></strong></p>
<p class="notep"><em>The image-signing process is crucial for secure boot implementation. However, it involves private keys that have a strong need for confidentiality protection. If they become compromised, authenticity and integrity for device software can no longer be guaranteed.</em></p>
</div>
<p class="indent">A common obstacle to overcome during development of devices protected by secure boot is the handling of test images and devices. Various approaches exist, all valid on their own for specific situations. On the one hand, you might want to perform early testing without any secure boot restrictions on completely open devices. However, you wouldn’t be able to discover issues related to secure boot. On the other hand, you might want to use one or more test signing keys on test devices to authenticate images meant for testing only. However, this bears the risk of unintentionally locking test devices with incorrect configurations or keys, which might turn them into electronic bricks.</p>
<p class="indent"><span epub:type="pagebreak" id="page_148"/>In any case, be careful when using different key pairs for testing and production use cases. If they get mixed up, test images (with additional tools or fewer restrictions) might verify correctly and run on devices in the field.</p>
<h4 class="h4" id="ch00lev2_86"><strong><em>Production and Lifetime</em></strong></h4>
<p class="noindent">Another area relevant for secure boot implementations is the production of devices. Since configuration data and keys have to be burned into OTP memory, the production process has to be adapted to enable secure boot. In-production testing of secure boot can also be a reasonable extension. Just imagine if all the previous steps were taken with great care and effort, but then the devices leave production with an incorrectly activated secure boot process that can be circumvented easily in the field. At best, that would be a motivational disaster for all security engineers, probably worse.</p>
<p class="indent">As if the task isn’t already complicated enough, secure boot implementations are also an attractive target for attackers and researchers. Therefore, the signing keys could get compromised in your development infrastructure, or vulnerabilities in hardware or firmware affecting boot process security could be found by external parties. Both cases lead to the necessity of replacing parts of the firmware with updated versions, maybe including a newly generated public verification key. A secure update functionality, as described in <a href="ch09.xhtml#ch09">Chapter 9</a>, as well as a solid key- and firmware-management process, are essential to handle these circumstances professionally.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>Implementation of secure boot requires developers, IT environment administrators, and production engineers to work together. Make sure that device security is considered a common goal for all people involved.</em></p>
</div>
<h3 class="h3" id="ch00lev1_67"><strong>Open Source Licenses vs. Secure Boot</strong></h3>
<p class="noindent">The possibility to nail down a specific software version to hardware is valuable for device manufacturers, but this game has another player: the free and open source software community.</p>
<p class="indent">Around the year 2000, a company named TiVo developed a digital video recorder (DVR) that prevented the execution of modified software by users. TiVo not only was a secure boot pioneer but also attracted the attention of Richard Stallman and the Free Software Foundation (FSF). The DVR device was running software licensed under the GNU General Public License version 2 (GPLv2), like Linux, which was meant to enable users to run their own customized software. Since then, the term <em>tivoization</em> has been used to describe mechanisms that restrict or prohibit the execution of custom open source software on a device.</p>
<p class="indent">Following this conflict, the FSF developed GPLv3, a license that makes the implicit claims of GPLv2 explicit:</p>
<div class="blockquote">
<p class="noindent">The Corresponding Source conveyed under this section must be accompanied by the Installation Information. [. . .] Installation Information [. . .] means any methods, [. . .] authorization keys, [. . .] required to install and execute modified versions.</p>
</div>
<p class="indent"><span epub:type="pagebreak" id="page_149"/>While the Linux kernel and the popular embedded system bootloader U-Boot are available under GPLv2, other software like the GNU Grand Unified Bootloader (GRUB) is subject to GPLv3 and might lead to legal conflicts when implemented in a secure boot scenario.</p>
<p class="indent">Clarifying the opposing goals of open source software licenses and secure boot protection for your individual case is absolutely necessary before going to market in order to save you quite some trouble.</p>
<p class="indent">It might seem not worth thinking about, but in some cases, developers seek a solution that satisfies both requirements: boot-process protection and the possibility to install modified software. One way to achieve such a compromise is to implement an unlock feature within the boot process. This feature allows the deactivation of secure boot verification in order to enable execution of custom (boot) software, but at the same time, the device has to ensure that all sensitive data, such as decryption keys, authenticators, and proprietary knowledge, are wiped from memory. This approach is already used by a variety of Android mobile phone vendors.</p>
<h3 class="h3" id="ch00lev1_68"><strong>Case Study: Secure Boot Process on an STM32MP157F Device</strong></h3>
<p class="noindent">In this section, I take a look at the specific boot-process protection measures of the STM32MP157F device and its corresponding software packages. However, keep in mind that this is a broad overview and not a step-by-step tutorial. A comprehensive secure boot implementation requires substantial efforts and a lot of fine-tuning.</p>
<h4 class="h4" id="ch00lev2_87"><strong><em>The Boot Process</em></strong></h4>
<p class="noindent">The microcontroller at hand exhibits a common boot-process complexity, as shown in <a href="ch08.xhtml#ch08fig05">Figure 8-5</a>.</p>
<div class="image"><img alt="Image" height="489" id="ch08fig05" src="../images/08fig05.jpg" width="876"/></div>
<p class="figcap"><em>Figure 8-5: The boot chain of STM32MP157F devices</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_150"/>After power-up, the ROM code performs basic initialization of the platform, loads the FSBL to internal RAM, and hands over execution to the FSBL. In this case, the FSBL is the Boot Loader stage 2 (BL2) part of the Trusted Firmware-A (TF-A) provided by ARM. In a simple setup, this BL2 initializes the DDR memory of the device, loads the SSBL into it, and executes the SSBL. However, if use of ARM TrustZone is desired, the FSBL loads not only the SSBL but also the runtime software for the secure world, and then jumps to the SSBL afterward.</p>
<p class="indent">By default, the STM32MP157F platform uses the popular embedded system bootloader U-Boot as the SSBL. U-Boot comes with a variety of features and is commonly used to boot embedded Linux kernels. Next, Linux takes over control, launches its kernel modules, services, and user-space applications, and concludes the boot process.</p>
<p class="indent">Another feature of STM32MP157F devices, also increasingly seen for other microcontroller products and manufacturers, is the availability of a coprocessor. Here, an additional ARM Cortex-M4 microcontroller with dedicated RAM is integrated to allow for the robust execution of real-time tasks, as discussed in <a href="ch10.xhtml#ch10">Chapter 10</a>. Loading firmware to this additional controller might also be part of the boot process. This can be initiated either directly by an SSBL like U-Boot or later, out of the running Linux OS.</p>
<p class="indent">Many developers would stop here, use the platform as described, and be happy if the boot process “just works.” However, until now, no protection against modification of any firmware parts has been considered.</p>
<h4 class="h4" id="ch00lev2_88"><strong><em>Secure Boot Starts in Hardware</em></strong></h4>
<p class="noindent">Robust secure boot concepts have to start in hardware. For this purpose, the ROM code needs to provide a verification routine that can be used to authenticate the FSBL image. Luckily, STM32MP157F devices have an integrated feature for that purpose. <a href="ch08.xhtml#ch08fig06">Figure 8-6</a> shows an overview of the related key generation, signing, and authentication process.</p>
<div class="image"><img alt="Image" height="479" id="ch08fig06" src="../images/08fig06.jpg" width="851"/></div>
<p class="figcap"><em>Figure 8-6: The firmware signing and provisioning process for STM32MP157F devices</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_151"/>The chip at hand utilizes the ECDSA algorithm to achieve integrity and authenticity of firmware images. In comparison to RSA, this enables faster signing and shorter keys, but the verification at boot time might take a bit longer. On the developers’ side, the ECC key pair has to be generated by the STM32MP Key Generator tool, which results in a private key, a corresponding public key, and the SHA-256 hash of the public key. The latter is useful because it requires less OTP memory in the chip compared to storing the whole public key.</p>
<p class="indent">To prepare the device for secure boot, the public-key hash has to be burned into its fuse memory. This can be achieved in various ways. You can use the ST-provided STM32 Cube Programmer or the U-Boot <code>stm32key</code> command. Also, the secure secret provisioning (SSP) feature might be of interest to you because it establishes a protected channel between a programmer and the STM32MP157F device, making it especially useful for secure production purposes.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The STM32MP157F device can be locked after writing the public-key hash to its OTP memory. This is mandatory for production but should be considered with caution during development.</em></p>
</div>
<p class="indent">After key provisioning in the device, the image has to be prepared for authenticated execution. Again, specific software, the STM32MP Signing Tool, is provided that processes the pre-generated ECDSA private key and the SHA-256 hash of the FSBL image in order to obtain the corresponding digital signature for this firmware part. The resulting image also contains the ECDSA public key and can be placed in the nonvolatile memory of the device.</p>
<p class="indent">At boot time, the ROM code verifies the integrity and authenticity of the presented FSBL image. First, the provided public key is verified by comparing its hash to the one stored in OTP memory. If correct, the key is used to verify the validity of the stored signature and the hash of the provided image. If successful, the FSBL payload is executed, and <code>NOTICE: Bootrom authentication succeeded</code> is output to the console. In any other case, the boot process halts.</p>
<h4 class="h4" id="ch00lev2_89"><strong><em>Secure Boot Based on BL2 TF-A</em></strong></h4>
<p class="noindent">For the FSBL, STM32MP157F devices rely on ARM’s BL2 TF-A that also provides secure boot support. However, it’s disabled by default and has to be activated by setting the <code>TRUSTED_BOARD_BOOT=1</code> build flag. Afterward, the digital signatures of binaries loaded by BL2 are verified for integrity and authenticity based on asymmetric cryptography.</p>
<p class="indent">The BL2 TF-A requires a firmware image package (FIP) that can be generated with the <code>fiptool</code> application. It contains all binaries to be loaded and executed and the cryptographic data necessary to verify these binaries. The binaries include, for example, an SSBL and a TEE implementation like OP-TEE that runs in the ARM TrustZone. The TEE is denoted as BL32, and the SSBL is known as BL33 in the TF-A taxonomy.</p>
<p class="indent"><span epub:type="pagebreak" id="page_152"/>Again, the first step is the generation of key pairs (X.509 certificates in this case) that can be used for signing and verification of firmware parts. For this task, ST provides the <code>cert_create</code> tool.</p>
<p class="indent">The TF-A requires all certificates to be part of a chain of trust (CoT). By default, the public key stored in the STM32MP157F’s OTP memory is taken as the root key, so the corresponding private key is a mandatory input for the <code>cert_create</code> tool.</p>
<p class="indent">After all the binaries and corresponding certificates are finalized, the FIP can be generated, and the result can be deployed to the device. During the boot process, the BL2 TF-A will use Mbed TLS for certificate parsing and the STM32MP Crypto Lib for signature verification in order to use the hardware hashing module.</p>
<p class="indent">The order of binary loading and execution is as follows. First, BL2 loads BL32 (OP-TEE) to memory and verifies its signature. Afterward, the same happens for BL33 (U-Boot). Only after successful verification, the execution of BL32 is started, which, in turn, calls BL33 after its own completion.</p>
<h4 class="h4" id="ch00lev2_90"><strong><em>U-Boot’s Secure Boot Feature</em></strong></h4>
<p class="noindent">After the ROM code and the BL2 TF-A, the third implementation involved in the device’s secure boot is U-Boot’s image-authentication procedure. In 2013, the groundwork for U-Boot’s secure boot support was laid by introducing RSA-based signature verification for Flattened Image Tree (FIT) images.</p>
<p class="indent">To activate these features, several configuration options also have to be enabled—for example, RSA crypto functionality (<code>CONFIG_RSA</code>), FIT support (<code>CONFIG_FIT</code>), and signature handling in FIT images (<code>CONFIG_FIT_SIGNATURE</code>).</p>
<p class="indent">Again, key generation is a fundamental step. However, since U-Boot is an open source project, key generation is also possible with open source tools such as the <code>openssl</code> command line tool. At the time of writing, U-Boot supports digital signatures based on RSA-2048, RSA-3072, RSA-4096, and ECDSA with a 256-bit curve.</p>
<p class="indent"><a href="ch08.xhtml#ch08list01">Listing 8-1</a> shows the two commands that generate a typical 2,048-bit RSA key and a corresponding X.509 certificate. Both are required for the later signing and image-generation process.</p>
<pre class="pre">$ <span class="codestrong1">openssl genrsa -out keys/dev.key 2048</span>&#13;
$ <span class="codestrong1">openssl req -batch -new -x509 -key keys/dev.key -out keys/dev.crt</span></pre>
<p class="list-title" id="ch08list01"><em>Listing 8-1: The key generation for U-Boot’s image verification</em></p>
<p class="indent">To generate a correctly signed FIT image, an Image Tree Source (ITS) file has to be created. <a href="ch08.xhtml#ch08list02">Listing 8-2</a> shows an example.</p>
<pre class="pre">/dts-v1/;&#13;
/ {&#13;
    description = "U-Boot fitImage for stm32mp157f";&#13;
    #address-cells = &lt;1&gt;;&#13;
<span epub:type="pagebreak" id="page_153"/>    images {&#13;
        kernel {&#13;
            description = "Linux kernel";&#13;
         <span class="ent">➊</span>  data = /incbin/("zImage");&#13;
            type = "kernel";&#13;
            arch = "arm";&#13;
            os = "linux";&#13;
            compression = "none";&#13;
            load = &lt;0xC0008000&gt;;&#13;
            entry = &lt;0xC0008000&gt;;&#13;
            hash-1 {&#13;
                algo = "sha256";&#13;
            };&#13;
        };&#13;
        fdt-dk2 {&#13;
            description = "FDT dk2";&#13;
         <span class="ent">➋</span>  data = /incbin/("stm32mp157f-dk2.dtb");&#13;
            type = "flat_dt";&#13;
            arch = "arm";&#13;
            compression = "none";&#13;
            hash-1 {&#13;
             <span class="ent">➌</span> algo = "sha256";&#13;
            };&#13;
        };&#13;
    };&#13;
&#13;
  <span class="ent">➍</span> configurations {&#13;
        default = "dk2";&#13;
        dk2 {&#13;
            description = "dk2";&#13;
            kernel = "kernel";&#13;
            fdt = "fdt-dk2";&#13;
            signature-1 {&#13;
              <span class="ent">➎</span> algo = "sha256,rsa2048";&#13;
              <span class="ent">➏</span> key-name-hint = "dev";&#13;
                 sign-images = "fdt", "kernel";&#13;
            };&#13;
        };&#13;
    };&#13;
};</pre>
<p class="list-title" id="ch08list02"><em>Listing 8-2: An example of a FIT image source</em></p>
<p class="indent">This FIT image source example assumes the Linux kernel is available as <code>zImage</code> <span class="ent">➊</span> and its device tree blob (DTB) for the STM32MP157F-DK2 board is stored as <em>stm32mp157f-dk2.dtb</em> <span class="ent">➋</span>. Both are hashed by SHA-256 <span class="ent">➌</span>, but U-Boot would also support SHA-384 and SHA-512.</p>
<p class="indent"><span epub:type="pagebreak" id="page_154"/>Note that the kernel and DTB are combined only in the <code>configurations</code> section <span class="ent">➍</span> of the ITS file. This thwarts mix-and-match attacks that would try to boot and misuse unwanted pairs of kernels and DTBs. Using an RSA-2048 signature <span class="ent">➎</span> generated by the key <em>dev.key</em> <span class="ent">➏</span> on the configuration consisting of a specific kernel and a specific DTB grants only the execution of this explicit combination.</p>
<p class="indent">After processing the ITS file with the <code>mkimage</code> tool, the last firmware part is signed and ready to be stored on the STM32MP157F device’s memory card. On successful verification during U-Boot’s boot procedure, you’ll see a message in the serial console output similar to the one shown in <a href="ch08.xhtml#ch08list03">Listing 8-3</a>.</p>
<pre class="pre">## Loading kernel from FIT Image at c2000000 ...&#13;
   Using 'dk2' configuration&#13;
   Verifying Hash Integrity ... sha256,rsa2048:dev+ OK</pre>
<p class="list-title" id="ch08list03"><em>Listing 8-3: A successful kernel and DTB verification by U-Boot</em></p>
<p class="indent">Subsequently, the execution of the verified Linux kernel is the worthy reward for your hard work.</p>
<p class="indentb">Even if the whole verification chain “works” up to this point, you still have two important tasks to do:</p>
<p class="hanga"><strong>Perform comprehensive testing</strong>    Confirm that every modification of a firmware part is actually detected and that the boot process is stopped accordingly. It might well be that, by mistake, a small part of the created image is not protected by a corresponding signature, which could open the door for manipulations.</p>
<p class="hanga"><strong>Check hardware for known weaknesses</strong>    Vulnerabilities in hardware components relevant for your boot process might break the security of the whole verification chain. Just as an example, CVE-2017-7932 and CVE-2017-7936 describe such hardware issues that can’t be fixed after production.</p>
<h3 class="h3" id="ch00lev1_69"><strong>Integrity Protection Beyond the Boot Process</strong></h3>
<p class="noindent">The classic secure boot chain usually terminates at the point where the OS takes over control. However, device architects might quite rightly want to extend integrity and authenticity protection beyond that stage.</p>
<h4 class="h4" id="ch00lev2_91"><strong><em>Kernel Module Verification</em></strong></h4>
<p class="noindent">Loadable Linux kernel modules enable a modular and dynamic way of extending kernel functionality. However, modification of such a loadable module paves the way for malicious code execution with kernel rights by attackers. Therefore, verifying integrity and authenticity of these modules during the loading process is desirable.</p>
<p class="indent">The Linux kernel already provides support for this security feature. There, RSA-based signatures of kernel modules can be verified upon loading a certain kernel module, but this functionality is disabled by default. It <span epub:type="pagebreak" id="page_155"/>has to be activated in the <code>Enable Loadable Module Support</code> section of the kernel’s configuration (<code>CONFIG_MODULE_SIG</code>).</p>
<p class="indent">By default, kernel-module signature verification runs in <em>permissive</em> mode: modules without signatures or corresponding public keys are marked as tainted but are still loaded. To enforce valid module signatures, the <code>CONFIG _MODULE_SIG_FORCE</code> option has to be enabled.</p>
<p class="indent">With standard settings for module signing, the kernel build process automatically generates signing keys and associated X.509 certificates at compile time by using OpenSSL. The created private keys are used to sign compiled kernel modules and might be discarded afterward. Of course, the certificates containing the public verification keys have to be integrated into the Linux kernel to enable successful verification at runtime.</p>
<h4 class="h4" id="ch00lev2_92"><strong><em>Filesystem Integrity</em></strong></h4>
<p class="noindent">As part of the Linux startup process, the kernel usually will mount one or more filesystems. These may contain application binaries, configuration data, trusted certificates, and public keys, all prone to tampering by adversaries. Standard filesystems like ext3 and ext4 incorporate mechanisms to deal with accidental data corruption but don’t provide integrity protection from a security point of view.</p>
<p class="indent">When looking at integrity protection for filesystem data, it’s important to distinguish between protecting data at rest (for example, in the power-off state) and protecting against data manipulation at runtime.</p>
<h5 class="h5" id="ch00lev3_19"><strong>MAC-Based Filesystem Protection</strong></h5>
<p class="noindent">Stacked filesystems like EncFS and gocryptfs, mentioned for confidentiality protection in <a href="ch05.xhtml#ch05">Chapter 5</a>, can additionally provide integrity protection in the form of HMACs or authenticated encryption. These mechanisms target data-at-rest protection because changing data at runtime is desired and, of course, possible. They generate cryptographic checksums whenever files are written and verify them upon reading.</p>
<p class="indent">Further, integrity protection can also be achieved at the block device level. The popular <code>dm-crypt</code> crypto target for the Linux device mapper infrastructure can use <code>dm-integrity</code> (<code>CONFIG_DM_INTEGRITY</code>) that generates authentication tags when writing and verifies them when data is read. Also, <code>dm-crypt</code> supports authenticated encryption ciphers like AES-GCM and ChaCha20-Poly1305. However, if only integrity protection is desired, <code>dm-integrity</code> can also be used standalone. Again, these measures aim for integrity protection against attackers modifying data in nonvolatile memory.</p>
<h5 class="h5" id="ch00lev3_20"><strong>Read-Only Filesystems</strong></h5>
<p class="noindent">If you’re concerned about filesystem modifications at runtime, an even simpler solution exists. Read-only filesystems like CramFS and SquashFS don’t implement write access for files, which means there’s simply no way to alter disk data at runtime, even if a system is compromised. A further nonsecurity advantage is the compressed storage of these filesystems, decreasing the <span epub:type="pagebreak" id="page_156"/>demand for nonvolatile memory. However, attackers with offline access to the mass storage media can replace the filesystem at will.</p>
<h5 class="h5" id="ch00lev3_21"><strong>Comprehensive Integrity Protection</strong></h5>
<p class="noindent">Finally, one solution provides integrity protection against both offline and runtime attacks: the <code>dm-verity</code> module (<code>CONFIG_DM_VERITY</code>). Originating from the Chrome OS community, it’s meant as a direct extension of secure boot to filesystem integrity. Also, Android 4.4 introduced support for it in 2013, and it was strictly enforced in 2016, beginning with Android 7.0.</p>
<p class="indent">From a technical point of view, <code>dm-verity</code> uses a hash tree in which each data block in a given block device is hashed. Then, sets of hash values are hashed to obtain next-level hashes, and so on, until a single root hash remains. If this root-hash value is incorporated into the secure boot verification process, the integrity of all data within the block device can be guaranteed. At runtime, for each file access, the hash tree is verified up to the root hash. This, of course, leads to a read-only filesystem. The initialization process of such a volume is supported by the <code>veritysetup</code> user-space tool after filesystem image creation.</p>
<h3 class="h3" id="ch00lev1_70"><strong>Write Protection as a Low-Cost Solution</strong></h3>
<p class="noindent">For some microcontrollers, especially low-cost and low-performance variants, secure boot is not available. However, that’s not a valid excuse for missing firmware protection.</p>
<p class="indent">The boot process of these platforms is usually much simpler because they use an RTOS or even just run bare-metal software. Further, their software and data are considerably smaller and often reside at least partially in <em>internal</em> flash memory. But still, the goals of integrity and authenticity can be important to protect devices from malicious modifications.</p>
<p class="indent">A simple yet powerful feature in this context is the activation of write protection for internal flash memory. The firmware is written to the device and the memory is “locked” afterward. Also, debugging interfaces like Joint Test Action Group (JTAG) should be deactivated. Following the principle of defense in depth, it makes sense to implement verification functions within such firmware that check whether lock-bits and other anti-debugging measures are set properly. Then, even if write-protection mechanisms are circumvented—for example, by physical attacks—an adversary still has to invest a substantial amount of reverse engineering to completely break the firmware integrity protection.</p>
<p class="indent">Of course, this internal, integrity-protected software might implement cryptographic signature verification and become the starting point of a verification chain that transfers the internal protection goals to data stored in external memories.</p>
<h3 class="h3" id="ch00lev1_71"><span epub:type="pagebreak" id="page_157"/><strong>Summary</strong></h3>
<p class="noindent">Processor hardware and its manufacturers play an important role in the implementation of secure boot processes for embedded systems. Proprietary architectures, heterogeneous multicore complexity, and a conglomeration of marketing terms contribute to the high barrier that device architects and developers have to climb when aiming for a protected boot process.</p>
<p class="indent">The basic principle is simple: an immutable hardware component verifies the first software component to be loaded for integrity and authenticity. If successful, execution is handed over to that software, which again might verify the next piece of software, and so on. However, in practice, as shown in this chapter’s case study, every stage of the boot process is different and requires product-specific knowledge and often vendor-specific tools. In addition, a series of cryptographic keys has to be managed, and device production processes even have to be prepared for secure boot support. The promising gain of this protection measure for the overall device security exacts its toll.</p>
<p class="indent">A robust secure boot implementation is a strong foundation for further security measures like kernel-module verification, filesystem integrity protection, and a variety of runtime integrity measures. It even has a positive impact on reverse-engineering protection and the secure data storage approaches described in <a href="ch05.xhtml#ch05">Chapter 5</a>, because it prevents attackers from executing custom code on your product and thereby exploring its internals.<span epub:type="pagebreak" id="page_158"/></p>
</div></body></html>