<html><head></head><body>
<div id="sbo-rt-content">
<section epub:type="chapter" role="doc-chapter" aria-labelledby="ch11">
<hgroup>
<h2 class="CHAPTER" id="ch11">
<span class="CN"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_301" aria-label=" Page 301. "/><samp class="SANS_Futura_Std_Bold_Condensed_B_11">11</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">PARLER, THE JANUARY 6 INSURRECTION, AND THE JSON FILE FORMAT</samp></span>
</h2>
</hgroup>
<p class="COS">On the morning of January 6, 2021, two months after Donald Trump lost the 2020 election to Joe Biden by about 6 million votes, thousands of Trump’s supporters prepared to storm the US Capitol in Washington, DC, hoping to subvert democracy. “We will never give up. We will never concede,” Trump told the crowd from the National Mall, just south of the White House. “We fight like hell, and if you don’t fight like hell, you’re not going to have a country anymore.”</p>

<p class="TX">Smartphones in hand, the pro-Trump, anti-democracy activists recorded the entire event. They posted their photos and videos online, many to the far-right social media site Parler. In this chapter, you’ll learn to work with the massive trove of video evidence collected from that day’s insurrection in a popular file format called JavaScript Object Notation (JSON). You’ll learn how JSON data is structured and write Python code to scour a million JSON files full of Parler video metadata to find specific <span role="doc-pagebreak" epub:type="pagebreak" id="pg_302" aria-label=" Page 302. "/>videos. You’ll also learn about working with Global Positioning System (GPS) coordinates, including how to plot points on a map, since many of the videos include GPS coordinates in their metadata. All of these skills could serve you well in your future investigations.</p>

<p class="TX">Let’s start with a brief history of how the Parler dataset became available to the public.</p>

<section epub:type="division" aria-labelledby="sec1">
<h3 class="H1" id="sec1"><span id="h-262"/><samp class="SANS_Futura_Std_Bold_B_11">The Origins of the Parler Dataset</samp></h3>

<p class="TNI">The protesters at the US Capitol insurrection filmed themselves marching with Don’t Tread on Me, Fuck Biden, and Trump flags; tearing down fences; fighting with riot cops; smoking weed; smashing windows and then storming the Capitol building through them; throwing chairs at police; and threatening the lives of members of Congress and Vice President Mike Pence. They uploaded these videos to Parler in real time as they filmed them.</p>

<p class="TX">During the attack on the Capitol, pro-Trump rioters attacked police officers with baseball bats, flag poles, and pipes, injuring at least 138 of them. One officer, Brian Sicknick, was hospitalized and died the next day. In the weeks and months following the attack, four more officers who responded that day died by suicide. A Capitol Police officer shot and killed Ashli Babbitt, a rioter who attempted to breach the doors to the US Senate chamber where senators were sheltering. Three more Trump supporters died during the riot: one from being crushed to death in the crowd, one from a stroke, and one from a heart attack.</p>

<p class="TX">Days after the attack, citing Parler’s unwillingness to moderate content that encourages and incites violence, Apple and Google banned the Parler app from their app stores. Amazon Web Services (AWS), the major cloud hosting service that Parler had relied on, kicked the company off its service. It took Parler a month and a half to bring its site back up. Before it went down, though, a quick-thinking archivist downloaded over a million videos from the site. In this section, I’ll describe how she downloaded the videos and how they were used in Trump’s second impeachment trial.</p>

<section epub:type="division" aria-labelledby="sec2">
<h4 class="H2" id="sec2"><span id="h-263"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">How the Parler Videos Were Archived</samp></h4>
<p class="TNI">On the Saturday after the January 6 attack, John Paczkowski and Ryan Mac published an email in BuzzFeed News from the Amazon AWS Trust &amp; Safety Team to Parler. Amazon informed Parler that it “cannot provide services to a customer that is unable to effectively identify and remove content that encourages or incites violence against others,” and that “we plan to suspend Parler’s account effective Sunday, January 10th.” Less than 48 hours before Parler went dark, a hacker named <span class="LinkTwitter">@donk_enby</span>, with the help of other archivists, raced to download a copy of all of the videos and images uploaded to the social network.</p>

<p class="TX">Parler, it turns out, lacked security measures that prevent automatic scraping of the site’s data. <i>Web scraping</i> is a method of automated data collection where you use code to load web pages, rather than manually loading <span role="doc-pagebreak" epub:type="pagebreak" id="pg_303" aria-label=" Page 303. "/>them in a browser, and extract their data. This chapter won’t cover how to scrape the web like <span class="LinkTwitter">@donk_enby</span> did, but if you’re curious, you can learn how in <span class="Xref">Appendix B</span>.</p>

<p class="TX">Parler’s website didn’t have any <i>rate limiting</i>, a security feature that prevents users from accessing the site too frequently, so nothing stopped a single computer from making millions of web requests. The URLs of Parler posts appeared to have random IDs, but <span class="LinkTwitter">@donk_enby</span> discovered that they also had hidden incremental IDs (1, 2, 3, and so on), so a script could easily loop through every ID, make a web request to download every post, and then find the URLs for every video and image to download. While Parler did strip metadata from videos uploaded by its users, they also left original copies of videos that contained this metadata at predictable URLs. @donk_enby downloaded versions of the videos that contained a wealth of hidden information, including, in many cases, the GPS coordinates of where the video was filmed.</p>

<p class="TX">When <span class="LinkTwitter">@donk_enby</span> archived this data, she saved it to an AWS S3 bucket, an AWS service for hosting files that never runs out of disk space. (It’s ironic that, in response to AWS kicking Parler off its service, she saved copies of the videos to a different part of AWS.)</p>

<p class="TX">Because there’s no widely agreed-upon definition of hacking, whether or not Parler was “hacked” is a matter of perspective. Technically, <span class="LinkTwitter">@donk_enby</span> scraped public content from a public website, which isn’t illegal and doesn’t require bypassing security—had Parler even had any that would have prevented this. The same thing is often true of illegal hacking, though; people break into systems that are barely protected or accidentally left open to the public.</p>

<p class="TX">By Sunday night, <span class="LinkTwitter">@donk_enby</span> had managed to archive at least 32TB of videos. “I hope that it can be used to hold people accountable and to prevent more death,” she told <i>Vice</i>. She worked with DDoSecrets to make a copy of the data available to the public—the copy you’ll work with in this chapter.</p>
</section>

<section epub:type="division" aria-labelledby="sec3">
<h4 class="H2" id="sec3"><span id="h-264"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Dataset’s Impact on Trump’s Second Impeachment</samp></h4>
<p class="TNI">On January 13, a week after the deadly riot at the Capitol and a week before Joe Biden’s inauguration as the new president, the US House of Representatives impeached Trump for “incitement of insurrection,” making Trump the first president in US history to be impeached twice.</p>

<p class="TX">During the impeachment trial in the US Senate, which took place in February at the beginning of Biden’s administration, the impeachment managers showed many videos of violent Trump supporters that <span class="LinkTwitter">@donk_enby</span> had archived from Parler as evidence to support their case. “I had an efficient way to download it all. I knew what was there, but it seemed that nobody else could see the value,” she told CNN at the time. “I hope it inspires more people with similar skills to mine to use those skills for good.”</p>

<p class="TX">Ultimately, 57 percent of the Senate, including seven members of the Republican Party, found Trump guilty, while 43 percent—all of whom were Republicans—found him not guilty. The US Constitution requires a two-thirds majority of the Senate to convict, so Trump was acquitted. However, over 1,000 people were charged in connection to the January 6 <span role="doc-pagebreak" epub:type="pagebreak" id="pg_304" aria-label=" Page 304. "/>insurrection. Two members of the far-right Oath Keepers militia, including its leader, Stewart Rhodes, and four members of the Proud Boys hate group, including its former leader, Enrique Tarrio, were convicted of seditious conspiracy. Several other members of these groups were also convicted of lesser crimes. Rhodes was sentenced to 18 years in prison in May 2023, and Tarrio was sentenced to 22 years in prison in September 2023.</p>

<p class="TX">Further investigating this dataset is obviously in the public interest. Let’s get started in Exercise 11-1.</p>
</section>

</section>

<section epub:type="division" aria-labelledby="sec4">
<h3 class="H1F" id="sec4"><span id="h-265"/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 11-1: Download and Extract Parler Video Metadata</samp></h3>

<p class="TNI">The Parler data is so large that it’s not practical, for the purposes of this chapter, to download it all. Instead, you’ll start with just the video metadata DDoSecrets has made available separately. The metadata contains useful information about each video, like its file format, when it was filmed, what type of phone or camera was used to film it, and in some cases the GPS coordinates describing where it was filmed. In this exercise, you’ll learn how to use the metadata to select and download individual videos to view.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>If you’re using Windows, I recommend that you follow along with this chapter using your Ubuntu terminal instead of PowerShell and that you save this data in your WSL Linux filesystem (for example, in</i> <span class="note_Italic">~/datasets</span><i>), instead of in your Windows-formatted USB disk (</i><span class="note_Italic">/mnt/c</span> <i>or</i> <span class="note_Italic">/mnt/d</span><i>). Because of disk performance issues with WSL, I found that working with this data in Linux rather than directly in Windows was significantly faster. If you’ve only used Python in Windows so far, install Python in Ubuntu with the command</i> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">sudo apt install python3 python3-pip</samp><i>, then install the click Python module by running</i> <samp class="SANS_TheSansMonoCd_W7Bold_Italic_BI_11">python3 -m pip install click</samp><i>. You’ll need the click module for the exercises in this chapter. Refer to <a href="appendixA.xhtml">Appendix A</a> to learn more about solving performance issues in WSL if you run into any problems.</i></p>

<section epub:type="division" aria-labelledby="sec5">
<h4 class="H2" id="sec5"><span id="h-266"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Download the Metadata</samp></h4>
<p class="TNI">Since the Parler dataset takes up so much disk space, DDoSecrets couldn’t publish it using BitTorrent like it does with most of its other public releases. To seed that torrent, you would need a single server with 32TB of data, and no one would be able to connect to the swarm to download it because no one has 32TB of disk space lying around. Instead, DDoSecrets hosts the Parler data on its public data web server<i>.</i> If you know the filename of a Parler video, you can download it from <i>https://<wbr/>data<wbr/>.ddosecrets<wbr/>.com<wbr/>/Parler<wbr/>/Videos<wbr/>/&lt;filename&gt;</i>.</p>

<p class="TX">You can also download a full list of filenames, <i>ddosecrets-parler-listing.txt.gz</i>, and metadata for all of the video files, <i>metadata.tar.gz</i>. Files ending in <i>.gz</i> are compressed using a format called GZIP, so you can tell from the filename that <i>ddosecrets-parler-listing.txt.gz</i> is a compressed text file. Files ending in <i>.tar</i>, called <i>tarballs</i>, also combine multiple files and folders together into a single file. Tar files aren’t compressed, though—they take up as much disk space as all of the files they contain—so it’s common to compress them with GZIP, resulting in <i>.tar.gz</i> files. The <i>metadata.tar.gz</i> file is a GZIP-compressed tarball.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_305" aria-label=" Page 305. "/>Start by downloading <i>ddosecrets-parler-listing.txt.gz</i> and <i>metadata.tar.gz</i> using the <samp class="SANS_TheSansMonoCd_W5Regular_11">wget</samp> command. This command is similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">curl</samp>, but it downloads a file and saves it to disk by default instead of displaying it in your terminal. Check if you already have <samp class="SANS_TheSansMonoCd_W5Regular_11">wget</samp> installed by running <samp class="SANS_TheSansMonoCd_W7Bold_B_11">which wget</samp>. If you don’t, install it on macOS with <samp class="SANS_TheSansMonoCd_W7Bold_B_11">brew install wget</samp>, or on Linux or Windows with WSL with <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sudo apt install wget</samp>.</p>

<p class="TX">Open a terminal. Create a new folder for the Parler data you’ll download, and change to that folder. (If you’re using Windows with WSL, make sure you create it in your WSL Linux filesystem, such as at <i>~/datasets/Parler</i>.) For example, here’s how I did it on my Mac, creating the folder on my <i>datasets</i> USB disk:</p>

<pre id="pre-426"><code>micah@trapdoor ~ % <b>cd </b><b><var>/Volumes/datasets</var></b>
micah@trapdoor datasets % <b>mkdir Parler</b>
micah@trapdoor datasets % <b>cd Parler</b>
micah@trapdoor Parler %</code></pre>
<p class="TX">Now use <samp class="SANS_TheSansMonoCd_W5Regular_11">wget</samp> to download the list of filenames by running the following command:</p>

<pre id="pre-427"><code>micah@trapdoor Parler % <b>wget </b><b>https://data.ddosecrets.com/Parler/Videos/ddosecrets-parler</b>
<b>-listing.txt.gz</b>
<var>--snip--</var>
Resolving data.ddosecrets.com (data.ddosecrets.com)... 172.67.75.15, 104.26.3.199, 104.26.2.199
Connecting to data.ddosecrets.com (data.ddosecrets.com)|172.67.75.15|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 17790173 (17M) [application/octet-stream]
Saving to: 'ddosecrets-parler-listing.txt.gz'

ddosecrets-parler-listin 100%[==================================&gt;]  16.97M  29.1MB/s    in 0.6s 
<var>...</var> (29.1 MB/s) - 'ddosecrets-parler-listing.txt.gz' saved [17790173/17790173]</code></pre>
<p class="TX">The output should show that you’ve downloaded the 17MB <i>ddosecrets -parler-listing.txt.gz</i> file. The <samp class="SANS_TheSansMonoCd_W5Regular_11">wget</samp> program shows you a progress bar of your download in your terminal.</p>

<p class="TX">Next, download the video metadata by running the following command:</p>

<pre id="pre-428"><code><b>wget </b><b>https://data.ddosecrets.com/Parler/Videos/metadata.tar.gz</b></code></pre>
<p class="TX">Check to make sure you’ve successfully downloaded the files by running <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls -lh</samp>. You should get the following output:</p>

<pre id="pre-429"><code>-rw-r--r--  1 micah  staff    17M Mar 28  2021 ddosecrets-parler-listing.txt.gz
-rw-r--r--  1 micah  staff    203M Mar 15  2021 metadata.tar.gz</code></pre>
<p class="TX">The file containing the list of filenames should be 17MB, and the metadata file should be 203MB.</p>
</section>

<section epub:type="division" aria-labelledby="sec6">
<h4 class="H2" id="sec6"><span id="h-267"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_306" aria-label=" Page 306. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Uncompress and Download Individual Parler Videos</samp></h4>
<p class="TNI">To uncompress GZIP files, you’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">gunzip</samp> command with the following syntax: <samp class="SANS_TheSansMonoCd_W5Regular_11">gunzip</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">filename.gz</samp>. Running <samp class="SANS_TheSansMonoCd_W5Regular_11">gunzip</samp> on a gzipped file deletes the original file and leaves you with the uncompressed version without the <i>.gz</i> file extension.</p>

<p class="TX">Uncompress the <i>ddosecrets-parler-listing.txt.gz</i> file by running the following command:</p>

<pre id="pre-430"><code><b>gunzip ddosecrets-parler-listing.txt.gz</b></code></pre>
<p class="TX">Your original 17MB file, <i>ddosecrets-parler-listing.txt.gz</i>, should be replaced with a 43MB text file called <i>ddosecrets-parler-listing.txt</i>, which contains over one million lines, one for each video that <span class="LinkTwitter">@donk_enby</span> archived.</p>

<p class="TX">To make sure it worked, run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">ls -lh</samp> again. Your output should look something like this:</p>

<pre id="pre-431"><code>-rw-r--r--  1 user  staff    43M Mar 28  2021 ddosecrets-parler-listing.txt
-rw-r--r--  1 user  staff    203M Mar 15  2021 metadata.tar.gz</code></pre>
<p class="TX">Count the number of files in <i>ddosecrets-parler-listing.txt</i> with the following command:</p>

<pre id="pre-432"><code><b>cat ddosecrets-parler-listing.txt | wc -l</b></code></pre>
<p class="TX">As you learned in <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp> command displays the content of a file, and piping that command’s output into <samp class="SANS_TheSansMonoCd_W5Regular_11">wc -l</samp> counts the number of lines in that file. The output should be <samp class="SANS_TheSansMonoCd_W5Regular_11">1031509</samp>, meaning there are 1,031,509 lines in <i>ddosecrets-parler-listing.txt</i>.</p>

<p class="TX">If you load the file in a text editor, it should look like this:</p>

<pre id="pre-433"><code>2021-01-12  18:31:54  77632730  0002bz1GNsUP
2021-01-12  18:37:33  14586730  0003lx5cSwSB
2021-01-12  18:37:33  822706    0004D2lOBGpr
2021-01-12  18:37:33  17354739  000EyiYpWZqg
2021-01-12  18:37:33  2318606   000SbGUM7vD4
2021-01-12  18:37:33  5894269   000oDvV6Bcfd
2021-01-12  18:37:36  20806361  0012uTuxv9qQ
2021-01-12  18:37:34  45821231  0015NlY0yUB5
<var>--snip--</var></code></pre>
<p class="TX">The first and second columns of text show the date and time that <span class="LinkTwitter">@donk_enby</span> first uploaded each file to the S3 bucket, just after scraping it. The third column is the size of the file, in bytes, and the final column is the filename. All of the video files in the Parler dataset have similar random-looking names. These are the original IDs that Parler used for each video, and they don’t have file extensions.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_307" aria-label=" Page 307. "/>Now that you know the filenames of each Parler video, you can download individual files from <i>https://<wbr/>data<wbr/>.ddosecrets<wbr/>.com<wbr/>/Parler<wbr/>/Videos<wbr/>/&lt;filename&gt;</i>. Let’s try downloading one of the first videos listed in <i>ddosecrets-parler-listing .txt</i>. First, use the following commands to create a <i>videos</i> folder and switch to that folder:</p>

<pre id="pre-434"><code>micah@trapdoor Parler % <b>mkdir videos</b>
micah@trapdoor Parler % <b>cd videos</b></code></pre>
<p class="TX">Next, run the following command to download the Parler file <i>0003lx5cSwSB</i>:</p>

<pre id="pre-435"><code><b>wget </b><b>https://data.ddosecrets.com/Parler/Videos/0003lx5cSwSB</b></code></pre>
<p class="TX">You can normally tell the format of a file based on its file extension, but since these Parler video filenames don’t have extensions, use the following <samp class="SANS_TheSansMonoCd_W5Regular_11">file</samp> command to determine the format of <i>0003lx5cSwSB</i>:</p>

<pre id="pre-436"><code><b>file 0003lx5cSwSB</b></code></pre>
<p class="TX">The output, <samp class="SANS_TheSansMonoCd_W5Regular_11">0003lx5cSwSB: ISO Media, MP4 v2 [ISO 14496-14]</samp>, shows that the file is an MP4 video. To make it easier to open in video-playing software, you’ll need to add the <i>.mp4</i> extension to the filename. You can rename files using the command <samp class="SANS_TheSansMonoCd_W5Regular_11">mv</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">source_path dest_path</samp>, which moves a file from a source path to a destination path. To rename <i>0003lx5cSwSB</i> to <i>0003lx5cSwSB.mp4</i>, run the following command:</p>

<pre id="pre-437"><code><b>mv 0003lx5cSwSB 0003lx5cSwSB.mp4</b></code></pre>
<p class="TX">You can now watch <i>0003lx5cSwSB.mp4</i> in software like VLC Media Player. <a href="#fig11-1">Figure 11-1</a> shows a screenshot from this video, which features Trump battling the “fake news” media and calls him the “Savior of the Universe.”</p>
<figure class="IMG"><img class="img80" id="fig11-1" src="Images/Figure11-1.jpg" alt="A screenshot from a pro-Trump video in which an image-edited Trump rides a motorcycle. The caption says “Trump A-Ah.”" width="527" height="324"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-1: A screenshot from a pro-Trump Parler video showing an altered image of Trump riding a motorcycle</samp></p></figcaption>
</figure>
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_308" aria-label=" Page 308. "/>In your terminal, run <samp class="SANS_TheSansMonoCd_W7Bold_B_11">cd ..</samp> to change out of the <i>videos</i> folder you just created and back to the Parler dataset folder.</p>

<p class="TX">There are over a million videos in this dataset, and most likely, only a small fraction contain anything newsworthy. If you randomly pick individual videos to download and watch, chances are you’ll be wasting a lot of time. To more efficiently find interesting videos, let’s take a closer look at the metadata.</p>
</section>

<section epub:type="division" aria-labelledby="sec7">
<h4 class="H2" id="sec7"><span id="h-268"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Extract Parler Metadata</samp></h4>
<p class="TNI">To view the Parler metadata, you’ll need to extract the <i>metadata.tar.gz</i> tarball. In your terminal, uncompress and extract <i>metadata.tar.gz</i> using the <samp class="SANS_TheSansMonoCd_W5Regular_11">tar</samp> command:</p>

<pre id="pre-438"><code><b>tar -xvf metadata.tar.gz</b></code></pre>
<p class="TX">Because it’s so common to gzip tar archives, the <samp class="SANS_TheSansMonoCd_W5Regular_11">tar</samp> command will automatically detect if it’s gzipped and uncompress it for you, so you don’t need to manually do the <samp class="SANS_TheSansMonoCd_W5Regular_11">gunzip</samp> step yourself. In the <samp class="SANS_TheSansMonoCd_W5Regular_11">-xvf</samp> argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> tells <samp class="SANS_TheSansMonoCd_W5Regular_11">tar</samp> to extract the files from <i>metadata.tar</i>, <samp class="SANS_TheSansMonoCd_W5Regular_11">v</samp> (meaning verbose) tells <samp class="SANS_TheSansMonoCd_W5Regular_11">tar</samp> to display each filename it extracts in the terminal, and <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> means that the next argument is a filename for the tarball on which this command will run.</p>

<p class="TX">Your output should look like this:</p>

<pre id="pre-439"><code>x metadata/
x metadata/.aws/
x metadata/meta-00CnBY5xCdca.json
x metadata/meta-0003lx5cSwSB.json
x metadata/meta-0070HNolzi3z.json
x metadata/meta-00BIFOMnOyi1.json
x metadata/meta-0002bz1GNsUP.json
<var>--snip--</var></code></pre>
<p class="TX">The command might take 10 minutes or so to extract the over one million JSON files in <i>metadata.tar.gz</i> into a new folder called <i>metadata</i>, depending on the speed of your hard disk. (If you’re using Windows with WSL and this step is going very slowly, consult <span class="Xref">Appendix A</span> for performance tips.)</p>

<p class="TX">Feel free to run <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp> on the <i>metadata</i> folder or view it in a file browser, but beware that there are so many files that those simple tasks will take a long time (it took over five minutes for the <samp class="SANS_TheSansMonoCd_W5Regular_11">ls</samp> command to finish running on my computer). <a href="#fig11-2">Figure 11-2</a> shows the files in the <i>metadata</i> folder in Finder on macOS.</p>

<p class="TX">The files in this folder are all named <i>meta-</i><span class="symbol_Italic">&lt;</span><i>ID</i><span class="symbol_Italic">&gt;</span><i>.json</i>, where <i>ID</i> is the original video ID from Parler. For example, you can find the metadata for the file <i>0003lx5cSwSB</i>, the video you downloaded in the previous section, at <i>metadata/meta-0003lx5cSwSB.json</i>. All of these metadata files are in the JSON file format, so let’s take a closer look at that now.</p>
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_309" aria-label=" Page 309. "/>
<figure class="IMG"><img class="img100" id="fig11-2" src="Images/Figure11-2.png" alt="A Finder window, showing some of the JSON files in the metadata folder." width="696" height="434"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-2: Some of the extracted Parler metadata files</samp></p></figcaption>
</figure>
</section>

</section>

<section epub:type="division" aria-labelledby="sec8">
<h3 class="H1" id="sec8"><span id="h-269"/><samp class="SANS_Futura_Std_Bold_B_11">The JSON File Format</samp></h3>

<p class="TNI">JSON is a format used to store information in text strings. One of its main benefits is that it’s human-readable. Some file formats are designed for computers rather than humans to understand. If you run <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp> on a PDF file, for example, you’ll see random-looking output in your terminal. You need to open the PDF in a program like Adobe Reader to understand the information it contains. However, humans can easily read the JSON text format just by viewing it in a text editor or by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">cat</samp> command.</p>

<p class="TX">JSON is one of the most widely used data formats, and the one most APIs communicate with. Whenever you visit a website that does anything interactive, chances are your web browser and the website’s server are passing JSON data back and forth. This is one reason why hacked data, as well as data scraped from APIs, is often full of JSON files. Most of the data from the America’s Frontline Doctors dataset, covered in detail in <span class="Xref"><a href="chapter13.xhtml">Chapter 13</a></span>, is in JSON format, as is much of the data hacked from Gab, the right-wing social network discussed in <span class="Xref">Appendix B</span>.</p>

<p class="TX">In this section, you’ll learn more about JSON syntax and how to load JSON data into Python scripts.</p>

<section epub:type="division" aria-labelledby="sec9">
<h4 class="H2" id="sec9"><span id="h-270"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Understanding JSON Syntax</samp></h4>
<p class="TNI">JSON has JavaScript in its name because it was first derived from that programming language, but it’s a <i>language-independent</i> data format: you can work with JSON data in JavaScript, Python, or any other programming language. Using their own JSON libraries, programming languages can <span role="doc-pagebreak" epub:type="pagebreak" id="pg_310" aria-label=" Page 310. "/>convert JSON text strings into structured data (such as Python’s dictionaries and lists) and also convert that structured data back into JSON text strings that can be loaded by code in any other programming language.</p>

<p class="TX">To get an idea of the structure of a JSON file, run the following command in your terminal to display the metadata for the Parler video with the filename <i>0003lx5cSwSB</i>:</p>

<pre id="pre-440"><code><b>cat metadata/meta-0003lx5cSwSB.json</b></code></pre>
<p class="TX">The output should look like <a href="#list11-1">Listing 11-1</a>.</p>

<pre id="pre-441"><code>[{
  "SourceFile": "-",
  "ExifToolVersion": 12.00,
  "FileType": "MP4",
  "FileTypeExtension": "mp4",
  "MIMEType": "video/mp4",
  "MajorBrand": "MP4 v2 [ISO 14496-14]",
  "MinorVersion": "0.0.0",
  "CompatibleBrands": ["mp42","mp41","iso4"],
  "MovieHeaderVersion": 0,
  "CreateDate": "2020:10:15 09:35:29",
  "ModifyDate": "2020:10:15 09:35:29",
  "TimeScale": 48000,
  "Duration": "0:01:59",
<var>--snip--</var></code></pre>
<p class="CodeListingCaption" id="list11-1"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-1: Video metadata for the file</samp> <samp class="SANS_Futura_Std_Book_11">0003lx5cSwSB</samp></p>

<p class="TX">As you can see, <samp class="SANS_TheSansMonoCd_W5Regular_11">FileType</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">MP4</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">2020:10:15 09:35:29</samp>, meaning that this video was filmed on October 15, 2020, at 9:35 <small>AM</small>, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">Duration</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">0:01:59</samp>, or 1 minute and 59 seconds.</p>

<p class="TX">JSON syntax is extremely similar to Python syntax but uses different terminology to describe types of information:</p>

<p class="ListHead"><b>Object</b></p>

<p class="ListPlain">A set of key-value pairs. An object is essentially equivalent to a dictionary in Python and even uses the same syntax. In JSON, however, keys <i>must</i> be strings. Objects are defined between braces (<samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>and}), and keys and values are separated with colons—for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">{"first_name": "Frederick", "last_name": "Douglass"}</samp>. The JSON output for <a href="#list11-1">Listing 11-1</a> also includes a JSON object.</p>

<p class="ListHead"><b>Array</b></p>

<p class="ListPlain">An ordered list of items. An array is essentially equivalent to a list in Python and uses the same syntax. Arrays are defined between brackets (<samp class="SANS_TheSansMonoCd_W5Regular_11">[</samp>and]), and items are separated by commas. The JSON output in <a href="#list11-1">Listing 11-1</a> has a few arrays, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">["mp42","mp41","iso4"]</samp>.</p>

<p class="ListHead"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_311" aria-label=" Page 311. "/><b>Boolean</b></p>

<p class="ListPlain">A value of either <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">false</samp>. These work the same as <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> in Python, but they’re lowercase in JSON.</p>

<p class="ListHead"><b>Number</b></p>

<p class="ListPlain">Any whole number or number with decimals in it, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">2600</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">3.14</samp>. These are similar to numbers in Python, though while Python makes a distinction between integers (whole numbers) and floating points (numbers with decimals), JSON does not.</p>

<p class="ListHead"><b>String</b></p>

<p class="ListPlain">A sequence of text characters—for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">"videos have metadata?"</samp>. This is exactly the same as a string in Python, except that JSON strings <i>must</i> be enclosed double quotes (<samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp>), whereas Python also allows you to use single quotes (<samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>).</p>

<p class="ListHead"><samp class="SANS_TheSansMonoCd_W7Bold_B_11">null</samp></p>

<p class="ListPlain">A keyword representing an empty value. This is very similar to Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> keyword.</p>

<p class="TX">All JSON data is made up of combinations of these types, so it’s important to understand their exact syntax. If you use any invalid syntax, such as surrounding a string with single quotes instead of double quotes or using the Boolean <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">true</samp>, the JSON data won’t load properly.</p>

<p class="TX">Unlike in Python code, whitespace isn’t important in JSON data. For example, consider this JSON string:</p>

<pre id="pre-442"><code>{"abolitionists":[{"first_name":"Frederick","last_name":"Douglass"},{"first_name":"John","last
_name":"Brown"},{"first_name":"Harriet","last_name":"Tubman"}]}</code></pre>
<p class="TX">To write the same JSON string in a more human-readable format, you can split it into multiple lines and add indentation:</p>

<pre id="pre-443"><code>{
    "abolitionists": [
        {
            "first_name": "Frederick",
            "last_name": "Douglass"
        },
        {
            "first_name": "John",
            "last_name": "Brown"
        },
        {
            "first_name": "Harriet",
            "last_name": "Tubman"
        }
    ]
}</code></pre>
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_312" aria-label=" Page 312. "/>You might encounter JSON files in datasets that are formatted either way. I often open JSON files in VS Code and use the text editor’s built-in format feature to reformat the JSON for legibility. To format a document in VS Code, click <b>View</b><span class="MenuArrow">▸</span><b>Command Palette</b><span class="MenuArrow">▸</span><b>Format Document</b> and press <small>ENTER</small>.</p>
</section>

<section epub:type="division" aria-labelledby="sec10">
<h4 class="H2" id="sec10"><span id="h-271"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Parsing JSON with Python</samp></h4>
<p class="TNI">You can turn JSON data into Python dictionaries and lists using Python’s built-in <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp> module. First, open a Python interpreter and import the module:</p>

<pre id="pre-444"><code>&gt;&gt;&gt; <b>import json</b></code></pre>
<p class="TX">The function in this module that I use the most is <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp>. This takes a string with JSON data as an argument, parses the string into a Python object like a dictionary or a list, and returns that object. For example, define a string called <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp> and set its value to a JSON string with the following command:</p>

<pre id="pre-445"><code>&gt;&gt;&gt; <b>json_data = '{"first_name": "Frederick", "last_name": "Douglass"}</b><b>'</b></code></pre>
<p class="TX">The value you set <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp> to looks similar to a dictionary, but since it’s surrounded by single quotes, it’s actually a string. In Python, the <samp class="SANS_TheSansMonoCd_W5Regular_11">type()</samp> function tells you the type of a variable. You can confirm that <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp> is a string with the following command:</p>

<pre id="pre-446"><code>&gt;&gt;&gt; <b>type(json_data)</b>
&lt;class 'str'&gt;</code></pre>
<p class="TX">This output shows that <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp> is a class of type <samp class="SANS_TheSansMonoCd_W5Regular_11">str</samp> (<span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span> will touch on classes), meaning it’s a string. Now define a variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> and set its value to the return value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp> function:</p>

<pre id="pre-447"><code>&gt;&gt;&gt; <b>obj = json.loads(json_data)</b></code></pre>
<p class="TX">Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp> takes a string as input and, if the string contains valid JSON, converts it into structured data—in this case, storing the resulting object in <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>. Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">type()</samp> function on <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> now to see what type of variable it is:</p>

<pre id="pre-448"><code>&gt;&gt;&gt; <b>type(obj)</b>
&lt;class 'dict'&gt;</code></pre>
<p class="TX">The output shows that you’ve parsed this JSON data into a Python dictionary (a <samp class="SANS_TheSansMonoCd_W5Regular_11">dict</samp>), which you can now use like any other dictionary. For <span role="doc-pagebreak" epub:type="pagebreak" id="pg_313" aria-label=" Page 313. "/>example, to put the value at the <samp class="SANS_TheSansMonoCd_W5Regular_11">last_name</samp> key of this dictionary in an f-string and then display it, use the following command:</p>

<pre id="pre-449"><code>&gt;&gt;&gt; <b>print(f"Hello, Mr. {obj['last_name']}.")</b>
Hello, Mr. Douglass.</code></pre>
<p class="TX">To practice accessing structured data, in your terminal, change to your Parler dataset folder, and then open a Python interpreter. Run the following commands to load the metadata from a Parler video as structured data. I’ve chosen the file <i>metadata/meta-HS34fpbzqg2b.json</i>, but feel free to load whichever file you’d like:</p>

<pre id="pre-450"><code>&gt;&gt;&gt; <b>import json</b>
&gt;&gt;&gt; <b>with open("</b><b><var>metadata/meta-HS34fpbzqg2b.json</var></b><b>") as f:</b>
...      <b>json_data = f.read()</b>
...
&gt;&gt;&gt; <b>obj = json.loads(json_data)</b></code></pre>
<p class="TX">You now have the video metadata in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>. The simplest way to start inspecting it is to display it to the screen with the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function:</p>

<pre id="pre-451"><code>&gt;&gt;&gt; <b>print(obj)</b>
[{'SourceFile': '-', 'ExifToolVersion': 12.0, 'FileType': 'MOV', 'FileTypeExtension': 'mov',
'MIMEType': 'video/quicktime', 'MajorBrand': 'Apple QuickTime (.MOV/QT)', 'MinorVersion':
'0.0.0', 'CompatibleBrands': ['qt '], 'MediaDataSize': 139501464, 'MediaDataOffset': 36,
<var>--snip--</var></code></pre>
<p class="TX">This output looks a little like JSON, but it’s a Python object—in this case, a list with a nested dictionary. Use the <samp class="SANS_TheSansMonoCd_W5Regular_11">len()</samp> function you learned about in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span> to count how many items are in this list:</p>

<pre id="pre-452"><code>&gt;&gt;&gt; <b>len(obj)</b>
1</code></pre>
<p class="TX">Since any given Parler video metadata file contains the metadata only for one video, there’s only one item in this list. In order to access that metadata, you need to select the first item in the list. To do that, use <samp class="SANS_TheSansMonoCd_W5Regular_11">obj[0]</samp> (remember, 0 is the first index for any list) as follows:</p>

<pre id="pre-453"><code>&gt;&gt;&gt; <b>print(obj[0])</b>
{'SourceFile': '-', 'ExifToolVersion': 12.0, 'FileType': 'MOV', 'FileTypeExtension': 'mov',
'MIMEType': 'video/quicktime', 'MajorBrand': 'Apple QuickTime (.MOV/QT)', 'MinorVersion':
'0.0.0', 'CompatibleBrands': ['qt '], 'MediaDataSize': 139501464, 'MediaDataOffset': 36,
<var>--snip--</var></code></pre>
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_314" aria-label=" Page 314. "/>This time, the output starts with a brace, meaning the item is a dictionary. Now use a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to view all of the keys in this dictionary:</p>

<pre id="pre-454"><code>&gt;&gt;&gt; <b>for key in obj[0]:</b>
...     <b>print(key)</b>
...
SourceFile
ExifToolVersion
FileType
<var>--snip--</var>
GPSLatitude
GPSLongitude
Rotation
GPSPosition</code></pre>
<p class="TX">Each key listed in this output represents a different piece of video metadata from the JSON file. You can also select values from this dictionary using their keys. For example, try printing the values for the <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLatitude</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLongitude</samp> keys:</p>

<pre id="pre-455"><code>&gt;&gt;&gt; <b>print(obj[0]["GPSLatitude"])</b>
38 deg 53' 26.52" N
&gt;&gt;&gt; <b>print(obj[0]["GPSLongitude"])</b>
77 deg 0' 28.44" W</code></pre>
<p class="TX">These values represent the GPS coordinates for the location where this video was filmed.</p>

<p class="TX">Since JSON makes it easy to convert structured data into strings and back, when creating BlueLeaks Explorer I used JSON files to store the structure of BlueLeaks sites, as described in the section <span class="Xref">“The Technology Behind BlueLeaks Explorer”</span> in <span class="Xref"><a href="chapter10.xhtml">Chapter 10</a></span>. When you create a structure for a BlueLeaks site, BlueLeaks Explorer stores all of the configuration for that site in a dictionary, then saves that information to a JSON file. If you quit BlueLeaks Explorer and then run it again later, it loads that JSON file back into a dictionary. Since the Parler metadata comes in JSON format, you can also write Python code that loads these JSON files to easily access that metadata, as you’ll do later in this chapter.</p>

<p class="TX">To learn more about the <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp> module, you can find the documentation and plenty of example code at <a href="https://docs.python.org/3/library/json.html"><i>https://<wbr/>docs<wbr/>.python<wbr/>.org<wbr/>/3<wbr/>/library<wbr/>/json<wbr/>.html</i></a>.</p>
</section>

<section epub:type="division" aria-labelledby="sec11">
<h4 class="H2" id="sec11"><span id="h-272"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Handling Exceptions with JSON</samp></h4>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp> function will throw an exception if you pass an invalid JSON string into it, like this:</p>

<pre id="pre-456"><code>&gt;&gt;&gt; <b>json.loads("this isn't valid json")</b>
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/json/__init__.py",
line 346, in loads
    return _default_decoder.decode(s)<span role="doc-pagebreak" epub:type="pagebreak" id="pg_315" aria-label=" Page 315. "/>
  File "/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/json/decoder.py",
line 337, in decode
    obj, end = self.raw_decode(s, idx=_w(s, 0).end())
  File "/Library/Frameworks/Python.framework/Versions/3.10/lib/python3.10/json/decoder.py",
line 355, in raw_decode
    raise JSONDecodeError("Expecting value", s, err.value) from None
json.decoder.JSONDecodeError: Expecting value: line 1 column 1 (char 0)</code></pre>
<p class="TX">A <samp class="SANS_TheSansMonoCd_W5Regular_11">json.decoder.JSONDecodeError</samp> exception means that the string you passed in doesn’t contain valid JSON data. In this case, it’s telling you the error in the JSON string is at line 1, column 1, and character 0, meaning the error is located at the first character of the string. If you have a longer JSON string that’s mostly valid but just has a little syntax issue, this error message can help you determine which piece of your syntax is wrong.</p>

<p class="TX">Validating JSON data is a common use for Python exception handling, which you learned about in <span class="Xref">“Exception Handling”</span> in <span class="Xref"><a href="chapter7.xhtml">Chapter 7</a></span>. For example, let’s say you have a string called <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>. The following code will catch exceptions in case this string contains invalid JSON data:</p>

<pre id="pre-457"><code>try:
    obj = json.loads(json_data)
    print("The JSON is valid")
    print(obj)
except json.decoder.JSONDecodeError:
    print("Invalid JSON")</code></pre>
<p class="TX">This code uses <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp> statements to catch the <samp class="SANS_TheSansMonoCd_W5Regular_11">json.decoder.JSONDecodeError</samp> exception if it gets thrown. If <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp> is a valid JSON string, it will display <samp class="SANS_TheSansMonoCd_W5Regular_11">The JSON is valid</samp>, followed by the information in <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>. If the JSON string is invalid, the script will display <samp class="SANS_TheSansMonoCd_W5Regular_11">Invalid JSON</samp> and then continue running without crashing.</p>

<p class="TX">To load a JSON file in Python functions such as <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp>, you must first load the content of the file into a string like so</p>

<pre id="pre-458"><code>with open("<var>filename.json</var>") as f:
    json_data = f.read()</code></pre>
<p class="BodyContinued">replacing <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">filename.json</samp> with whatever file you’re loading, such as <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata/meta-HS34fpbzqg2b.json</samp> to load the metadata for the <i>HS34fpbzqg2b</i> video file. As you learned in <span class="bodycontinued_Xref">“Reading and Writing Files”</span> in <span class="bodycontinued_Xref"><a href="chapter8.xhtml">Chapter 8</a></span>, this code opens the file as a file object <samp class="SANS_TheSansMonoCd_W5Regular_11">f</samp> and then stores its content into a string called <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp>.</p>

<p class="TX">Next, you’d run that string through <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp> to convert it from a string into structured data, like this:</p>

<pre id="pre-459"><code>try:
    obj = json.loads(json_data)
except json.decoder.JSONDecodeError:
    print("Invalid JSON")
    return</code></pre>
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_316" aria-label=" Page 316. "/>When this code finishes running, if the JSON string was valid, <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp> will contain the JSON data. Otherwise, it will display <samp class="SANS_TheSansMonoCd_W5Regular_11">Invalid JSON</samp> and then return early from the function. The remaining code in the function can access the data in <samp class="SANS_TheSansMonoCd_W5Regular_11">obj</samp>.</p>

<p class="TX">To prepare for using this module to write Python scripts that parse the Parler metadata files, next we’ll look at how to access values like GPS coordinates from JSON files with several command line programs.</p>
</section>

</section>

<section epub:type="division" aria-labelledby="sec12">
<h3 class="H1" id="sec12"><span id="h-273"/><samp class="SANS_Futura_Std_Bold_B_11">Tools for Exploring JSON Data</samp></h3>

<p class="TNI">While we’ve been focusing primarily on working with JSON files using Python, sometimes writing a Python script is overkill if you just want to quickly search a large block of JSON text. In this section, you’ll learn to use our old friend <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp>, as well as a more powerful tool called <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>, to search JSON files.</p>

<section epub:type="division" aria-labelledby="sec13">
<h4 class="H2" id="sec13"><span id="h-274"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Counting Videos with GPS Coordinates Using grep</samp></h4>
<p class="TNI">As you know from <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span>, the command line programs <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">wc</samp> are incredibly powerful tools to quickly assess datasets. In a single command, and without needing to write a Python script, you can use <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> to efficiently search inside JSON files.</p>

<p class="TX">For example, let’s say you want to figure out how many Parler video metadata files include GPS coordinates. Open a terminal, switch to your Parler dataset folder, and run the following command to grep for the string <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp>:</p>

<pre id="pre-460"><code>micah@trapdoor Parler % <b>grep -r GPSCoordinates metadata</b></code></pre>
<p class="TX">The first argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">-r</samp> (short for <samp class="SANS_TheSansMonoCd_W5Regular_11">--recursive</samp>), tells <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> to look inside every file in the given folder. The next argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp>, is the string to search for. The final argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>, is the name of the folder to search.</p>

<p class="TX">When you run this command, your terminal should quickly fill with GPS coordinates:</p>

<pre id="pre-461"><code>metadata/meta-31VC1ufihFpa.json:  "GPSCoordinates": "22 deg 8' 0.60\" S, 51 deg 22' 4.80\" W",
metadata/meta-ImUNiSXcoGKh.json:  "GPSCoordinates": "0 deg 0" 0.00\" N, 0 deg 0' 0.00\" E",
metadata/meta-70Tv9tAQUKyL.json:  "GPSCoordinates": "36 deg 10' 49.08\" N, 115 deg 26' 45.60\"
W, 1922.566 m Above Sea Level",
metadata/meta-P2w4QOgv5n9U.json:  "GPSCoordinates": "26 deg 14' 46.32\" N, 80 deg 5' 38.76\" W,
3.424 m Above Sea Level",
<var>--snip--</var></code></pre>
<p class="TX">However, you’re trying to find how many of these videos have GPS coordinates, not necessarily what those coordinates are. If coordinates are still loading in your terminal, press <small>CTRL</small>-C to cancel the command, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_317" aria-label=" Page 317. "/>then pipe the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">wc -l</samp> to count how many lines get displayed:</p>

<pre id="pre-462"><code>micah@trapdoor Parler % <b>grep -r GPSCoordinates metadata | wc -l</b>
64088</code></pre>
<p class="TX">Of the slightly more than one million videos, about 64,000 have GPS coordinates.</p>

<p class="TX">Programs like <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">wc</samp> can only take you so far in your attempts to efficiently search large quantities of data. For example, if the JSON files you’re searching are formatted on a single line, rather than split into multiple lines like the Parler files, <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> will search the entire block of JSON data for your string rather than a line at a time. You can’t use <samp class="SANS_TheSansMonoCd_W5Regular_11">grep</samp> to extract specific fields of data from JSON, either. For that, the best tool for the job is a program called <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>.</p>
</section>

<section epub:type="division" aria-labelledby="sec14">
<h4 class="H2" id="sec14"><span id="h-275"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Formatting and Searching Data with the jq Command</samp></h4>
<p class="TNI">The <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> program allows you to take JSON data as input and select key information from it. In this section, you’ll learn how to use it to extract specific information from the Parler files.</p>

<p class="TX">First, you’ll need to install <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>. Mac users can do so by running the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">brew install jq</samp> command. Linux or Windows with WSL users, run the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sudo apt install jq</samp> command.</p>

<p class="TX">You can use the <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> command to indent JSON data and show syntax highlighting in your terminal, making the data easier to read. For example, try running this command in your terminal:</p>

<pre id="pre-463"><code><b>cat metadata/meta-HS34fpbzqg2b.json | jq</b></code></pre>
<p class="TX">The first part of the command, <samp class="SANS_TheSansMonoCd_W5Regular_11">cat metadata/meta-HS34fpbzqg2b.json</samp>, outputs the content of that JSON file, which contains the metadata for a single Parler video. The second part, <samp class="SANS_TheSansMonoCd_W5Regular_11">| jq</samp>, pipes that output as input into <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>.</p>

<p class="TX">The output should look like this:</p>

<pre id="pre-464"><code>[
  {
    "SourceFile": "-",
    "ExifToolVersion": 12,
    "FileType": "MOV",
    "FileTypeExtension": "mov",
    "MIMEType": "video/quicktime",
    "MajorBrand": "Apple QuickTime (.MOV/QT)",
    "MinorVersion": "0.0.0",
    "CompatibleBrands": [
      "qt  "
    ],
<var>--snip--</var>
    "GPSLatitude": "38 deg 53' 26.52\" N",
    "GPSLongitude": "77 deg 0' 28.44\" W",<span role="doc-pagebreak" epub:type="pagebreak" id="pg_318" aria-label=" Page 318. "/>
     "Rotation": 180,
    "GPSPosition": "38 deg 53' 26.52\" N, 77 deg 0' 28.44\" W"
  }
]</code></pre>
<p class="TX">This version includes syntax highlighting (as in VS Code) and formats the JSON data so that the items in every array and object are listed on separate lines and indented.</p>

<p class="TX">You can also use <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> to filter for details from inside the JSON data. For example, suppose you just want to know the GPS coordinates from this JSON file. In the preceding code, you can tell from the bracket character at the beginning that this JSON data is an array. The first value of the array is an object, since it starts with a brace character, and one of the keys of the object is <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSPosition</samp>. To filter for <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSPosition</samp>, pass <samp class="SANS_TheSansMonoCd_W5Regular_11">".[0].GPSPosition"</samp> as an argument into the <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp> command, as follows:</p>

<pre id="pre-465"><code>micah@trapdoor Parler % <b>cat metadata/meta-HS34fpbzqg2b.json | jq ".[0].GPSPosition"</b>
"38 deg 53' 26.52\" N, 77 deg 0' 28.44\" W"</code></pre>
<p class="TX">In this command, <samp class="SANS_TheSansMonoCd_W5Regular_11">.[0]</samp> selects the first item of the list in the file named <i>metaHS34fpbzqg2b.json</i>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">.GPSPosition</samp> selects the value with the key <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSPosition</samp> from the object. The output shows the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSPosition</samp> field, <samp class="SANS_TheSansMonoCd_W5Regular_11">"38 deg 53' 26.52\" N, 77 deg 0' 28.44\" W"</samp>.</p>

<p class="TX">If you’re interested in learning more about how to use <samp class="SANS_TheSansMonoCd_W5Regular_11">jq</samp>, check out its website at <a href="https://stedolan.github.io/jq"><i>https://<wbr/>stedolan<wbr/>.github<wbr/>.io<wbr/>/jq</i></a>. You’ll also revisit it in <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span>, where I explain how I used it to understand the structure of leaked neo-Nazi chat logs.</p>

<p class="TX">Now that you have a foundational understanding of JSON, you’ll try your hand at writing Python code that works with it in Exercise 11-2.</p>
</section>

</section>

<section epub:type="division" aria-labelledby="sec15">
<h3 class="H1F" id="sec15"><span id="h-276"/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 11-2: Write a Script to Filter for Videos with GPS from January 6, 2021</samp></h3>

<p class="TNI">In this exercise, you’ll write a Python script that filters the Parler videos down to just those filmed on January 6, 2021, whose metadata includes GPS coordinates. You’ll do this by looping through all the JSON files in the dataset, converting them into Python objects, and inspecting their metadata to show you just the ones you’re looking for.</p>

<p class="TX">For a challenge, you can try programming your own script to meet the following requirements:</p>
<ul class="BL">
<li class="BL">Make this script accept an argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>, using Click. This will be the path to the <i>metadata</i> folder full of JSON files.</li>
<li class="BL">Define a new variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> that keeps track of the number of Parler videos that include GPS coordinates in their metadata, and set it to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>.</li>
<li class="BL">Loop through all of the JSON files in the <i>metadata</i> folder. For each loop, your program should run the content of each JSON file through <span role="doc-pagebreak" epub:type="pagebreak" id="pg_319" aria-label=" Page 319. "/>the <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp> function to turn it into a Python object. As described in the “<span class="listbullet_Xref">Parsing JSON with Python”</span> section, each object is technically a list containing one element, a dictionary full of all of the video’s metadata.</li>
<li class="BL">Check to see if that video’s metadata dictionary includes the key <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp> and if the date stored in the key <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp> is January 6, 2021. If both of these are true, the script should display a message that this file includes GPS coordinates and is from January 6, 2021, and increment the <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> variable by 1.</li>
<li class="BL">Have the program display a message after looping through all the metadata files that tells the user the total number of videos with GPS coordinates from January 6, 2021 (which should be stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> variable, now that you’re done counting).</li>
</ul>
<p class="TX">Alternatively, follow along with the rest of this exercise and I’ll walk you through the programming process.</p>

<section epub:type="division" aria-labelledby="sec16">
<h4 class="H2" id="sec16"><span id="h-277"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Accept the Parler Metadata Path as an Argument</samp></h4>
<p class="TNI">Start with the usual Python script template:</p>

<pre id="pre-466"><code>def main():
    pass

if __name__ == "__main__":
    main()</code></pre>
<p class="TX">Next, make the following modifications to your script so that it accepts the <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp> CLI argument. This way, when you run the script, you can pass in the path to the <i>metadata</i> folder as an argument, which the code will use to open all of the JSON files inside that folder. The modifications are shown in bold:</p>

<pre id="pre-467"><code><b>import click</b>

<b>@click.command()</b>
<b>@click.argument("parler_metadata_path")</b>
def main(<b>parler_metadata_path</b>):
    <b>"""Filter Parler videos with GPS that were filmed Jan 6, 2021"""</b>
    <b>print(f"Parler metadata path: {parler_metadata_path}")</b>

if __name__ == "__main__":
    main()</code></pre>
<p class="TX">This code first imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">click</samp> module, then uses it to make the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function accept the argument <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>. It also adds a docstring to show what the script does when you run it with the <samp class="SANS_TheSansMonoCd_W5Regular_11">--help</samp> argument. Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function will print the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp> to the screen.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_320" aria-label=" Page 320. "/>Test your code to make sure it works so far, replacing the argument with the path to your own <i>metadata</i> folder:</p>

<pre id="pre-468"><code>micah@trapdoor chapter-11 % <b>python3 exercise-11-2.py </b><b><var>/Volumes/datasets/Parler/metadata</var></b>
Parler metadata path: /Volumes/datasets/Parler/metadata</code></pre>
<p class="TX">Sure enough, the code should display the same string, stored in <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>, that you passed in as an argument.</p>
</section>

<section epub:type="division" aria-labelledby="sec17">
<h4 class="H2" id="sec17"><span id="h-278"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Loop Through Parler Metadata Files</samp></h4>
<p class="TNI">Next, add some code that will loop through all of the JSON files in the <i>metadata</i> folder and run <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp> on their contents to convert them into structured data in Python. Modify your code as follows:</p>

<pre id="pre-469"><code>import click
<b>import os</b>
<b>import json</b>

@click.command()
@click.argument("parler_metadata_path")
def main(parler_metadata_path):
    """Filter Parler videos with GPS that were filmed Jan 6, 2021"""
    <b>for filename in os.listdir(parler_metadata_path):</b>
        <b>abs_filename =</b><b> os.path.join(parler_metadata_path, filename)</b>
        <b>if os.path.isfile(abs_filename) and abs_filename.endswith(".json"):</b>
            <b>with open(abs_filename) as f:</b>
                <b>json_data = f.read()</b>

            <b>try:</b>
                <b>metadata = json.loads(json_data)</b>
                <b>print(f"Successfully loaded JSON: {filename}")</b>
            <b>except json.decoder.JSONDecodeError:</b>
                <b>print(f"Invalid JSON: {filename}")</b>
                <b>continue</b>

if __name__ == "__main__":
    main()</code></pre>
<p class="TX">The code imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">os</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">json</samp> modules at the top of the file so it can use the functions they contain later on. The program then loops through the return value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.listdir()</samp> function, which returns the list of files in the <i>metadata</i> folder, storing each filename in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp>.</p>

<p class="TX">Inside the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, the code defines a new variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">abs_filename</samp> to be the absolute path of the JSON file the code is working with each time it loops. It creates the absolute path by concatenating <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp> with <samp class="SANS_TheSansMonoCd_W5Regular_11">filename</samp> using the <samp class="SANS_TheSansMonoCd_W5Regular_11">os.path.join()</samp> function. Now that the code knows the full filename, it checks to make sure that this is actually a file, not a folder, and that it ends with <i>.json</i>.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_321" aria-label=" Page 321. "/>If the code confirms the file is JSON, it loads all of the data from this file into the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">json_data</samp> and then converts that string into structured data, saved in the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>, using <samp class="SANS_TheSansMonoCd_W5Regular_11">try</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">except</samp> statements, as described in the <span class="Xref">“Handling Exceptions with JSON”</span> section. If there are no syntax errors in an individual JSON file, the code displays a message to the screen saying that the file loaded successfully. Otherwise, it displays an error and moves on to the next file using the <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statement. In a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop, <samp class="SANS_TheSansMonoCd_W5Regular_11">continue</samp> statements immediately end the current loop and move on to the next loop.</p>

<p class="TX">To summarize, at this point the code is looping through every file in the <i>metadata</i> folder, and for each JSON file it comes across, opening it and loading its content as a text string. It then converts this string into a Python object using the <samp class="SANS_TheSansMonoCd_W5Regular_11">json.loads()</samp> function, storing the object in the <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp> variable, and displays a message that it successfully loaded. If the file didn’t successfully load, the message says that the JSON was invalid, and the code continues on to the next JSON file.</p>

<p class="TX">Run the program again, replacing the argument with the path to your own <i>metadata</i> folder:</p>

<pre id="pre-470"><code>micah@trapdoor chapter-11 % <b>python3 exercise-11-2.py </b><b><var>/Volumes/datasets/Parler/metadata</var></b>
Successfully loaded JSON: meta-gzK2iNatgLLr.json
Successfully loaded JSON: meta-31VC1ufihFpa.json
Successfully loaded JSON: meta-ZsZRse5JGx8j.json
<var>--snip--</var></code></pre>
<p class="TX">If your output shows many messages saying different JSON files loaded successfully, your code is working. Once you’ve determined that your output looks correct, you can press <small>CTRL</small>-C to cancel the script before it finishes running.</p>
</section>

<section epub:type="division" aria-labelledby="sec18">
<h4 class="H2" id="sec18"><span id="h-279"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Filter for Videos with GPS Coordinates</samp></h4>
<p class="TNI">Your code currently loops through all of the Parler metadata files, loads each file, and converts it into a Python object so you can work with it. Next, you need to filter out the videos that include GPS coordinates and to count those videos. To do so, make the following modifications:</p>

<pre id="pre-471"><code>import click
import os
import json

@click.command()
@click.argument("parler_metadata_path")
def main(parler_metadata_path):
    """Filter Parler videos with GPS that were filmed Jan 6, 2021"""
    <b>count = 0</b>

    for filename in os.listdir(parler_metadata_path):
        abs_filename = os.path.join(parler_metadata_path, filename)<span role="doc-pagebreak" epub:type="pagebreak" id="pg_322" aria-label=" Page 322. "/>
        if os.path.isfile(abs_filename) and abs_filename.endswith(".json"):
            with open(abs_filename) as f:
                json_data = f.read()

            try:
                metadata = json.loads(json_data)
            except json.decoder.JSONDecodeError:
                print(f"Invalid JSON: {filename}")
                continue

            <b>if "GPSCoordinates" in metadata[0]:</b>
                <b>print(f"Found GPS coordinates: {filename}")</b>
                <b>count += 1</b>

    <b>print(f"Total videos with GPS coordinates: {count:,}")</b>

if __name__ == "__main__":
    main()</code></pre>
<p class="TX">This code defines a new variable called <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> and starts its value out as <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp>. This will keep track of the number of videos with GPS coordinates. After each JSON file is loaded into the <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp> variable, an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement checks if the key <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp> exists inside this metadata dictionary. Remember from the previous section that <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp> is a list with one item, making <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata[0]</samp> the actual dictionary your code is checking. If this video metadata does have the <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp> field, the control flow moves to the code block after the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement. Otherwise, it moves on to the next loop.</p>

<p class="TX">When the Python script comes across metadata that includes GPS coordinates, it displays the name of the file with <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> and increments <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> by 1. This way, by the time this <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is finished, <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp> will contain the total number of videos that have GPS coordinates in their metadata. Finally, after the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop completes, the code displays that total count with a second call to the <samp class="SANS_TheSansMonoCd_W5Regular_11">print()</samp> function. As you learned in <span class="Xref"><a href="chapter8.xhtml">Chapter 8</a></span>, the <samp class="SANS_TheSansMonoCd_W5Regular_11">:,</samp> in the f-string will display larger numbers with comma separators.</p>

<p class="TX">Run your program again:</p>

<pre id="pre-472"><code>micah@trapdoor chapter-11 % <b>python3 exercise-11-2.py </b><b><var>/Volumes/datasets/Parler/metadata</var></b>
Found GPS coordinates: meta-31VC1ufihFpa.json
Found GPS coordinates: meta-ImUNiSXcoGKh.json
Found GPS coordinates: meta-70Tv9tAQUKyL.json
<var>--snip--</var>
Found GPS coordinates: meta-1FMyKoVq53TV.json
Found GPS coordinates: meta-Y0jO2wy1Z7RO.json
Found GPS coordinates: meta-aZlkDfPojhxW.json
Total videos with GPS coordinates: 63,983</code></pre>
<p class="TX">Because this script loads the JSON data from over a million files, it might take a few minutes to finish running. In the end, your script should find 63,983 videos with GPS coordinates. There should also be 63,984 lines of output: one with the name of each metadata file that has GPS coordinates, and one at the end that lists the total.</p>
</section>

<section epub:type="division" aria-labelledby="sec19">
<h4 class="H2" id="sec19"><span id="h-280"/><span role="doc-pagebreak" epub:type="pagebreak" id="pg_323" aria-label=" Page 323. "/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Filter for Videos from January 6, 2021</samp></h4>
<p class="TNI">Now you’ll whittle down that list of roughly 64,000 videos even further to find out which were filmed on January 6, 2021.</p>

<p class="TX">You can tell the date on which a video was filmed from the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp> field in its metadata, as shown earlier in <a href="#list11-1">Listing 11-1</a>. The value of this field looks something like this:</p>

<pre id="pre-473"><code>"CreateDate": "2020:12:28 17:25:47",</code></pre>
<p class="TX">To use the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp> field to filter the results further, make the following modifications to your code:</p>

<pre id="pre-474"><code>import click
import os
import json

@click.command()
@click.argument("parler_metadata_path")
def main(parler_metadata_path):
    """Filter Parler videos with GPS that were filmed Jan 6, 2021"""
    count = 0

    for filename in os.listdir(parler_metadata_path):
        abs_filename = os.path.join(parler_metadata_path, filename)
        if os.path.isfile(abs_filename) and abs_filename.endswith(".json"):
            with open(abs_filename, "rb") as f:
                json_data = f.read()

            try:
                metadata = json.loads(json_data)
            except json.decoder.JSONDecodeError:
                print(f"Invalid JSON: {filename}")
                continue

              <b>if (</b>
                <b>"GPSCoordinates" in metadata[0]</b>
                <b>and "CreateDate" in metadata[0]</b>
                <b>and metadata[0]["CreateDate"].startswith("2021:01:06")</b>
            <b>):</b>
                <b>print(f"GPS + Jan 6: {filename}")</b>
                count += 1

    <b>print(f"Total videos with GPS coordinates, filmed Jan 6: {count:,}")</b>

if __name__ == "__main__":
    main()</code></pre>
<p class="TX">Rather than just checking for videos with GPS coordinates, now the code also checks for those that have a <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp> that starts with <samp class="SANS_TheSansMonoCd_W5Regular_11">2021:01:06</samp>. Once the code determines that the metadata in the current loop has GPS coordinates and was created on January 6, 2021, it displays the filename <span role="doc-pagebreak" epub:type="pagebreak" id="pg_324" aria-label=" Page 324. "/>with <samp class="SANS_TheSansMonoCd_W5Regular_11">print(f"GPS</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Jan 6: {filename}")</samp>. When the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is finished, it displays the total count.</p>

<p class="TX">The expression in this code’s <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement is surrounded by parentheses, and the three conditions inside those parentheses are indented. This is purely cosmetic; the code would work exactly the same if it were all on one line, but this formatting makes it slightly easier to read.</p>

<p class="TX">You can find the final script in the book’s GitHub repo at <a href="https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-11/exercise-11-2.py"><i>https://<wbr/>github<wbr/>.com<wbr/>/micahflee<wbr/>/hacks<wbr/>-leaks<wbr/>-and<wbr/>-revelations<wbr/>/blob<wbr/>/main<wbr/>/chapter<wbr/>-11<wbr/>/exercise<wbr/>-11<wbr/>-2<wbr/>.py</i></a>. Run the completed script like so:</p>

<pre id="pre-475"><code>micah@trapdoor chapter-11 % <b>python3 exercise-11-2.py </b><b><var>/Volumes/datasets/Parler/metadata</var></b>
GPS + Jan 6: meta-xHkUeMHMFx3F.json
GPS + Jan 6: meta-eGqmDWzz0oSh.json
GPS + Jan 6: meta-WhQeLMyPWIrG.json
<var>--snip--</var>
GPS + Jan 6: meta-fhqU4rQ4ZFzO.json
GPS + Jan 6: meta-pTbZXLmXGyyn.json
GPS + Jan 6: meta-hL60MjItBhOW.json
Total videos with GPS coordinates, filmed Jan 6: 1,958</code></pre>
<p class="TX">The script might still take a few minutes to run, but this time, there should be fewer results. Only 1,958 Parler videos have GPS coordinates and were filmed on January 6, 2021; this is about 3 percent of the videos with GPS coordinates, and less than 0.2 percent of all of the videos.</p>

<p class="TX">Watching almost 2,000 videos, while perhaps unpleasant, is at least feasible. We can still do better, though. In all likelihood, some of those January 6 videos weren’t actually filmed at the insurrection itself, but just happened to be uploaded the same day from other locations. To prepare for filtering this list further in order to find videos filmed at the insurrection, you’ll need some background on working with GPS coordinates.</p>
</section>

</section>

<section epub:type="division" aria-labelledby="sec20">
<h3 class="H1" id="sec20"><span id="h-281"/><samp class="SANS_Futura_Std_Bold_B_11">Working with GPS Coordinates</samp></h3>

<p class="TNI">In this section, you’ll learn how latitude and longitude coordinates work and how to look them up on online map services like Google Maps. You’ll also learn how to convert between different GPS formats and measure the rough distance between two locations. I’ll introduce a few new Python features, including the <samp class="SANS_TheSansMonoCd_W5Regular_11">split()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">replace()</samp> methods for modifying strings and the <samp class="SANS_TheSansMonoCd_W5Regular_11">float()</samp> function for converting a string into a decimal number.</p>

<section epub:type="division" aria-labelledby="sec21">
<h4 class="H2" id="sec21"><span id="h-282"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Searching by Latitude and Longitude</samp></h4>
<p class="TNI">You can define any location on Earth using two coordinates: latitude and longitude. These coordinates are measured in degrees, with each degree split into 60 minutes and each minute split into 60 seconds. Latitude goes from 90 degrees North, which is the North Pole, to 0 degrees at the equator, to 90 degrees South, which is the South Pole. Longitude goes from 180 degrees West, which is in the middle of the Pacific Ocean, to 0 degrees, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_325" aria-label=" Page 325. "/>which cuts through England, to 180 degrees East, back to that same location in the middle of the Pacific.</p>

<p class="TX">For example, if you look up the metadata for the Parler video with filename <i>HS34fpbzqg2b</i> (which shows Trump supporters removing barricades around the Capitol building while police officers stand by and watch), you’d find the following GPS coordinates:</p>

<p class="ListPlain">Latitude: 38 deg 53<span class="listplain_symbol">′</span> 26.52<span class="listplain_symbol">″</span> N</p>

<p class="ListPlain">Longitude: 77 deg 0<span class="listplain_symbol">′</span> 28.44<span class="listplain_symbol">″</span> W</p>

<p class="BodyContinued">That means this video was filmed at the latitude of 38 degrees, 53 minutes, 26.52 seconds North and the longitude of 77 degrees, 0 minutes, 28.44 seconds West.</p>

<p class="TX">You can use various online map services, like Google Maps, to search by GPS coordinates and see exactly where on Earth they point to. To search the coordinates contained in the Parler metadata, you’ll need to slightly modify them so that Google Maps will recognize them, loading <a href="https://www.google.com/maps"><i>https://<wbr/>www<wbr/>.google<wbr/>.com<wbr/>/maps</i></a> and entering these coordinates as the string 38°53<span class="body_symbol">′</span>26.52<span class="body_symbol">″</span>, <span class="body_symbol">−</span>77°0<span class="body_symbol">′</span>28.44. Try searching for those coordinates in Google Maps now. <a href="#fig11-3">Figure 11-3</a> shows the exact location this video was filmed: just outside the US Capitol building, where police had set up barricades.</p>
<figure class="IMG"><img class="img100" id="fig11-3" src="Images/Figure11-3.png" alt="A Google Maps screenshot with a pin on a location just outside the US Capitol building." width="696" height="491"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-3: Pinpointing a location near the US Capitol building in Google Maps</samp></p></figcaption>
</figure>
<p class="TX">You can also use Google Maps to discover the GPS coordinates of any given point. If you right-click anywhere on the map, a context menu should pop up showing you the GPS coordinates of that point. However, when you do this, the coordinates it shows you will look slightly different because they’ll be in decimal format.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_326" aria-label=" Page 326. "/>In the next section, you’ll learn to convert from decimals to degrees, minutes, and seconds.</p>
</section>

<section epub:type="division" aria-labelledby="sec22">
<h4 class="H2" id="sec22"><span id="h-283"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Converting Between GPS Coordinate Formats</samp></h4>
<p class="TNI">GPS coordinates in decimal format show the number of degrees on the left side of the decimal point, and converted minutes and seconds values on the right side. For example, consider the GPS coordinates from the <i>HS34fpbzqg2b</i> video:</p>
<ul class="BL">
<li class="BL">The latitude is 38 degrees, 53 minutes, 26.52 seconds North, which is 38.8907 in decimal.</li>
<li class="BL">The longitude is 77 degrees, 0 minutes, 28.44 seconds West, which is <span class="listbullet_symbol">−</span>77.0079 in decimal.</li>
</ul>
<p class="TX">One degree is 60 minutes and one minute is 60 seconds, meaning there are 3,600 seconds in a degree. The formula to convert from degrees, minutes, and seconds to decimal format is <i>degrees</i> + (<i>minutes</i> / 60) + (<i>seconds</i> / 3,600). Latitudes are negative in the Southern Hemisphere but positive in the Northern Hemisphere, while longitudes are negative in the Western Hemisphere but positive in the Eastern Hemisphere. The latitude for the <i>HS34fpbzqg2b</i> video is positive, while the longitude is negative.</p>

<p class="TX">Decimal numbers are simpler to work with in code. Since the GPS coordinates in the Parler metadata are formatted as degrees, minutes, and seconds, let’s use some Python code to convert them to decimal format. The <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp> function in <a href="#list11-2">Listing 11-2</a> takes a GPS coordinate from the Parler metadata as an argument and returns the decimal version.</p>

<pre id="pre-476"><code>def gps_degrees_to_decimal(gps_coordinate):
    parts = gps_coordinate.split()
    degrees = float(parts[0])
    minutes = float(parts[2].replace(" ' ", " "))
    seconds = float(parts[3].replace(' " ', " "))
    hemisphere = parts[4]
    gps_decimal = degrees + (minutes / 60) + (seconds / 3600)
    if hemisphere == "W" or hemisphere == "S":
        gps_decimal *= -1
    return gps_decimal</code></pre>
<p class="CodeListingCaption" id="list11-2"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-2: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">gps_degrees_to_decimal()</samp> function</samp></p>

<p class="TX">This function introduces some new Python features. First, the <samp class="SANS_TheSansMonoCd_W5Regular_11">split()</samp> string method splits a string into a list of parts based on whitespace. For example, this method would convert the string <samp class="SANS_TheSansMonoCd_W5Regular_11">'77 deg 0\' 28.44" W'</samp> into the list of strings <samp class="SANS_TheSansMonoCd_W5Regular_11">['77', 'deg', "0' ", '28.44" ', 'W']</samp>. The line <samp class="SANS_TheSansMonoCd_W5Regular_11">parts</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">gps _coordinate.split()</samp> stores the return value of <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinate.split()</samp> into the <samp class="SANS_TheSansMonoCd_W5Regular_11">parts</samp> variable. If you passed that string into this function as <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinate</samp>, this would mean the following:</p>
<ul class="BL">
<li class="BL"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_327" aria-label=" Page 327. "/><samp class="SANS_TheSansMonoCd_W5Regular_11">parts[0]</samp> is the string <samp class="SANS_TheSansMonoCd_W5Regular_11">77</samp>.</li>
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">parts[1]</samp> is the string <samp class="SANS_TheSansMonoCd_W5Regular_11">deg</samp>.</li>
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">parts[2]</samp> is the string <samp class="SANS_TheSansMonoCd_W5Regular_11">0'</samp> (0 followed by a single quote).</li>
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">parts[3]</samp> is the string <samp class="SANS_TheSansMonoCd_W5Regular_11">28.44"</samp> (28.44 followed by a double quote).</li>
<li class="BL"><samp class="SANS_TheSansMonoCd_W5Regular_11">parts[4]</samp> is the string <samp class="SANS_TheSansMonoCd_W5Regular_11">W</samp>.</li>
</ul>
<p class="TX">Before you can do math with strings in Python, you must convert them into <i>floating-point numbers</i>—which are just numbers that can contain decimals—using the <samp class="SANS_TheSansMonoCd_W5Regular_11">float()</samp> function. <a href="#list11-2">Listing 11-2</a> uses <samp class="SANS_TheSansMonoCd_W5Regular_11">float()</samp> to set the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">degrees</samp> to the floating-point version of <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[0]</samp>. In this case, it converts the value of the string <samp class="SANS_TheSansMonoCd_W5Regular_11">77</samp> in <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinate</samp> to the floating-point number <samp class="SANS_TheSansMonoCd_W5Regular_11">77.0</samp>.</p>

<p class="TX">The next line of code similarly uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">replace()</samp> string method to convert the <samp class="SANS_TheSansMonoCd_W5Regular_11">minutes</samp> value to a floating-point number. This method searches the string for the first argument and replaces it with the second argument. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">"GPS is fun".replace("fun", "hard")</samp> returns the string <samp class="SANS_TheSansMonoCd_W5Regular_11">GPS is hard</samp>. When you run <samp class="SANS_TheSansMonoCd_W5Regular_11">parts[2].replace(" ' ", " ")</samp>, you’re replacing the single quote character (<samp class="SANS_TheSansMonoCd_W5Regular_11">'</samp>) with an empty string, in order to delete that character. This would convert the string <samp class="SANS_TheSansMonoCd_W5Regular_11">0'</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinate</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> and then convert <samp class="SANS_TheSansMonoCd_W5Regular_11">0</samp> to the floating-point number <samp class="SANS_TheSansMonoCd_W5Regular_11">0.0</samp>.</p>

<p class="TX">The next line uses <samp class="SANS_TheSansMonoCd_W5Regular_11">replace()</samp> to delete the double quote character (<samp class="SANS_TheSansMonoCd_W5Regular_11">"</samp>), converting the string <samp class="SANS_TheSansMonoCd_W5Regular_11">28.44"</samp> from <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_coordinates</samp> to <samp class="SANS_TheSansMonoCd_W5Regular_11">28.44</samp>, then converting that into the floating-point number <samp class="SANS_TheSansMonoCd_W5Regular_11">28.44</samp> and saving it as <samp class="SANS_TheSansMonoCd_W5Regular_11">seconds</samp>.</p>

<p class="TX">The rest of the function is more straightforward. It defines the variable <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_decimal</samp> as the decimal version of the GPS coordinates that are passed in an argument, using the formula to convert the coordinates to decimal format using the numbers in <samp class="SANS_TheSansMonoCd_W5Regular_11">degrees</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">minutes</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">seconds</samp>. If the coordinates are in the Western or Southern Hemisphere, the code <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_decimal *=</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">-1</samp> makes <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_decimal</samp> a negative number. Finally, the function returns <samp class="SANS_TheSansMonoCd_W5Regular_11">gps _decimal</samp>, the decimal version of the GPS coordinates.</p>

<p class="TX">Since the GPS coordinates in the Parler data come in strings of degrees, minutes, and seconds, you’ll use the <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp> function in the next exercise to convert them to decimal format. First, though, you’ll need to know how to calculate distances between two GPS coordinates.</p>
</section>

<section epub:type="division" aria-labelledby="sec23">
<h4 class="H2" id="sec23"><span id="h-284"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Calculating GPS Distance in Python</samp></h4>
<p class="TNI">To determine which Parler videos were filmed in Washington, DC, based on their GPS coordinates, you can begin by finding the coordinates for the center point of the city and then imagine a circle around that point. You can consider a video to have been filmed in the city if its metadata has both a longitude and latitude within that circle. This won’t tell you if the video was exactly filmed within the Washington, DC, city limits, but it’s close enough. In this section, I’ll review the simple math required to do this calculation.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_328" aria-label=" Page 328. "/>The Earth isn’t flat, but for the purposes of this chapter, pretend that Washington, DC, is a flat plane. You can think of GPS coordinates as a 2D point on a Cartesian coordinate system, where longitude represents the <i>x</i> axis (East and West) and latitude represents the <i>y</i> axis (North and South). Since you can look up the coordinates of the center of Washington, DC, and you know the coordinates for where each video was filmed, you can use the distance formula to determine if it’s inside the circle.</p>

<p class="TX">The distance formula, as you might recall from geometry class, is used to calculate the distance between two points. It states that the distance between two points equals the square root of ((<i>x</i><sub>2</sub> <span class="body_symbol">−</span> <i>x</i><sub>1</sub>)<sup>2</sup> + (<i>y</i><sub>2</sub> <span class="body_symbol">−</span> <i>y</i><sub>1</sub>)<sup>2</sup>), where (<i>x</i><sub>1</sub>, <i>y</i><sub>1</sub>) is one point and (<i>x</i><sub>2</sub>, <i>y</i><sub>2</sub>) is another point. As an example, <a href="#fig11-4">Figure 11-4</a> shows the distance between the White House and the US Capitol, with the White House at point (<i>x</i><sub>1</sub>, <i>y</i><sub>1</sub>) and the US Capitol at point (<i>x</i><sub>2</sub>, <i>y</i><sub>2</sub>).</p>
<figure class="IMG"><img class="img100" id="fig11-4" src="Images/Figure11-4.png" alt="A map of Washington, DC, overlaid by a right triangle. The White House is at the top of the triangle’s y axis, the US Capitol is at the right of the triangle’s x axis, and the distance formula is shown on the hypotenuse between them." width="695" height="316"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-4: Using the distance formula to calculate the distance between the White House and the US Capitol</samp></p></figcaption>
</figure>
<p class="TX">To determine if a given Parler video was filmed in Washington, DC, you’ll compare the city center with the GPS coordinates of a Parler video. The center point of DC is constant, and when you loop through the JSON files of Parler metadata, you can find all the relevant GPS coordinates. If you plug these points into the distance formula, you can determine whether the distance is close enough to the center to be considered inside the city.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_21">NOTE</samp></span></p>
</blockquote>
<p class="NOTE-TXT"><i>Since the Earth isn’t actually flat, using the distance formula will only be relatively accurate for short distances, like 20 kilometers. It’s possible to calculate much more accurate distances between GPS coordinates using spherical geometry, but that requires using trigonometry functions like sine, cosine, and arctangent. Using the distance formula is much simpler and accurate enough for our purposes.</i></p>

<p class="TX"><a href="#list11-3">Listing 11-3</a> shows a Python <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> function that implements the distance formula.</p>
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_329" aria-label=" Page 329. "/>
<pre id="pre-477"><code>import math

def distance(x1, y1, x2, y2):
    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)</code></pre>
<p class="CodeListingCaption" id="list11-3"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-3: The <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">distance()</samp> function</samp></p>

<p class="TX">The distance formula requires you to calculate a square root, which you can do using Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">math.sqrt()</samp> function. To access this function, first you import the <samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp> module at the top of the file. The <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> function takes the <samp class="SANS_TheSansMonoCd_W5Regular_11">x1</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">x2</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">y1</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">y2</samp> arguments, then calculates the distance formula, returning the distance between the two points. (In Python, <samp class="SANS_TheSansMonoCd_W5Regular_11">**</samp> is the power operator, so we write <i>x</i><sup>2</sup> as <samp class="SANS_TheSansMonoCd_W5Regular_11">x**2</samp>.) If you call <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> and pass any two points into it as arguments, it will return the distance between them.</p>
</section>

<section epub:type="division" aria-labelledby="sec24">
<h4 class="H2" id="sec24"><span id="h-285"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding the Center of Washington, DC</samp></h4>
<p class="TNI">Now you’ll find the coordinates of the center of Washington, DC, so that you can use the distance formula to compare them against those from a Parler video. Load <a href="https://www.google.com/maps"><i>https://<wbr/>www<wbr/>.google<wbr/>.com<wbr/>/maps</i></a> in your browser and search for <b>Washington DC</b>. Right-click the US Capitol building, which is approximately at the center of the city. Google Maps should show you the GPS coordinates of that point (see <a href="#fig11-5">Figure 11-5</a>); click them to copy them. Your GPS coordinates might be slightly different, depending on where exactly you clicked.</p>
<figure class="IMG"><img class="img100" id="fig11-5" src="Images/Figure11-5.png" alt="A screenshot from Google Maps, showing the menu that pops up after right-clicking a point near the center of Washington, DC. The first item on the menu is 33.89410, −77.00667, which are the GPS coordinates of that point." width="696" height="429"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-5: Using Google Maps to find the GPS coordinates of the center of Washington, DC</samp></p></figcaption>
</figure>
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_330" aria-label=" Page 330. "/>If the radius of the imaginary circle around Washington, DC, is about 20 kilometers, you can consider any videos filmed within 0.25 degrees to be inside the city. I decided on 0.25 degrees by checking the GPS coordinates on the outskirts of DC and comparing them to the coordinates in the city center.</p>

<p class="TX">Armed with the <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> Python functions and the GPS coordinates for the center of Washington, DC, you’re ready to finish filtering the Parler videos to find the insurrection videos in Exercise 11-3.</p>
</section>

</section>

<section epub:type="division" aria-labelledby="sec25">
<h3 class="H1F" id="sec25"><span id="h-286"/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 11-3: Update the Script to Filter for Insurrection Videos</samp></h3>

<p class="TNI">In this exercise, you’ll filter the results of the Exercise 11-2 script even further, searching just for videos filmed in Washington, DC. First, make a copy of <i>exercise-11-2.py</i> and rename it <i>exercise-11-3.py</i>. Now modify <i>exercise-11-3.py</i> to match the following code:</p>

<pre id="pre-478"><code>import click
import os
import json
<b>import math</b>

<b>def gps_degrees_to_decimal(gps_coordinate):</b>
    <b>parts = gps_coordinate.split()</b>
    <b>degrees =</b><b> float(parts[0])</b>
    <b>minutes = float(parts[2].replace(" ' ", " "))</b>
    <b>seconds = float(parts[3].replace(' " ', " "))</b>
    <b>hemisphere = parts[4]</b>
    <b>gps_decimal = degrees + (minutes / 60) +</b><b> (seconds / 3600)</b>
    <b>if hemisphere == "W" or hemisphere == "S":</b>
        <b>gps_decimal *= -1</b>
    <b>return gps_decimal</b>

<b>def distance(x1, y1, x2, y2):</b>
    <b>return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)</b>

<b>def was_video_filmed_in_dc(metadata):</b>
    <b>dc_x = -77.0066</b>
    <b>dc_y = 38.8941</b>
    <b>x = gps_degrees_to_decimal(metadata[0]["GPSLongitude"])</b>
    <b>y = gps_degrees_to_decimal(metadata[0]["GPSLatitude"])</b>
    <b>return distance(dc_x, dc_y, x, y) &lt;=</b><b> 0.25</b>

@click.command()
@click.argument("parler_metadata_path")
def main(parler_metadata_path):
  <b>"""Filter Parler videos that were filmed in Washington DC and on Jan 6, 2021"""</b>
    count = 0

    for filename in os.listdir(parler_metadata_path):
      abs_filename = os.path.join(parler_metadata_path, filename)<span role="doc-pagebreak" epub:type="pagebreak" id="pg_331" aria-label=" Page 331. "/>
        if os.path.isfile(abs_filename) and abs_filename.endswith(".json"):
            with open(abs_filename, "rb") as f:
                json_data = f.read()

            try:
                metadata = json.loads(json_data)
            except json.decoder.JSONDecodeError:
                print(f"Invalid JSON: {filename}")
                continue

            if (
                <b>"GPSLongitude" in metadata[0]</b>
                <b>and "GPSLatitude" in metadata[0]</b>
                and "CreateDate" in metadata[0]
                and metadata[0]["CreateDate"].startswith("2021:01:06")
                <b>and was_video_filmed_in_dc(metadata)</b>
          ):
                print(f"<b>Found an insurrection video</b>: {filename}")
                count += 1

    print(f"Total videos <b>filmed in Washington DC on January 6</b>: {count:,}")

if __name__ == "__main__":
    main()</code></pre>
<p class="TX">This code first defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp> function from <a href="#list11-2">Listing 11-2</a> and the <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> function from <a href="#list11-3">Listing 11-3</a>, importing the required <samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp> module at the top of the file. It will later use <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to _decimal()</samp> to convert GPS coordinates from the Parler video metadata into decimal format and <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> to calculate the distance between that GPS coordinate and the center of Washington, DC.</p>

<p class="TX">Next, the code defines the <samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc()</samp> function. This function takes a single argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp>, which contains the Parler video metadata loaded from its JSON file. It returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> if the GPS coordinates in that metadata are located inside Washington, DC, but otherwise returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>.</p>

<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc()</samp> function first defines the <i>x</i> and <i>y</i> coordinates you found for the city center in the variables <samp class="SANS_TheSansMonoCd_W5Regular_11">dc_x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">dc_y</samp>. Next, it defines the <i>x</i> and <i>y</i> coordinates of the Parler video, storing those values in the variables <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>. Since the GPS coordinates in the <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLongitude</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLatitude</samp> metadata fields aren’t in decimal format, it first passes those strings into the <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp> function to convert them from degrees, minutes, and seconds into decimals and then saves the return values into <samp class="SANS_TheSansMonoCd_W5Regular_11">x</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">y</samp>.</p>

<p class="TX">Finally, <samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc()</samp> calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> function to determine the distance between these two points. The return value is this expression:</p>

<pre id="pre-479"><code>distance(dc_x, dc_y, x, y) &lt;= 0.25</code></pre>
<p class="BodyContinued"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_332" aria-label=" Page 332. "/>The <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> function returns a number representing the distance between the center of Washington, DC, and the location where the video was filmed. If that number is less than or equal to 0.25 (roughly 20 kilometers), the expression evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>; otherwise, it evaluates to <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. Thus, the <samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc()</samp> function returns a Boolean.</p>

<p class="TX">With these functions defined at the top of the file, the remaining changes to the script are minimal. The code updates the docstring, since our script’s purpose has changed. It also updates the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement that checks whether or not an insurrection video was found. The version of this script from Exercise 11-2 just checked if the metadata included a <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp> field, but now it checks for the fields <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLongitude</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLatitude</samp> as well. The videos with GPS coordinates contain all three of these fields. <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSCoordinates</samp> is just a single field that contains both longitude and latitude. However, since you need separate values for longitude and latitude, it’s simpler to use the metadata fields that are already separated. Finally, the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement confirms that the video was filmed in Washington, DC, by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc(metadata)</samp>.</p>

<p class="TX">If all of these conditions are true—the metadata contains <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLongitude</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLatitude</samp>; the metadata contains <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp> with a value matching January 6, 2021; and the GPS coordinates in the metadata show that the video was filmed in Washington, DC—then the code displays a message saying it found an insurrection video and increments <samp class="SANS_TheSansMonoCd_W5Regular_11">count</samp>. Finally, after the script has finished looping through all of the Parler metadata files, it displays the total number of insurrection videos found.</p>

<p class="TX">You can find the final script in the book’s GitHub repo at <a href="https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-11/exercise-11-3.py"><i>https://<wbr/>github<wbr/>.com<wbr/>/micahflee<wbr/>/hacks<wbr/>-leaks<wbr/>-and<wbr/>-revelations<wbr/>/blob<wbr/>/main<wbr/>/chapter<wbr/>-11<wbr/>/exercise<wbr/>-11<wbr/>-3<wbr/>.py</i></a>. Run your complete script now, making sure to pass in the correct path to your Parler <i>metadata</i> folder:</p>

<pre id="pre-480"><code>micah@trapdoor chapter-11 % <b>python3 exercise-11-3.py</b><b><var> /Volumes/datasets/Parler/metadata</var></b>
Found an insurrection video: meta-QPsyYtwu4zJb.json
Found an insurrection video: meta-Hcv3lzEsnWaa.json
Found an insurrection video: meta-6dDTCsYzK3k3.json
<var>--snip--</var>
Found an insurrection video: meta-eLSgf3w5r4PI.json
Found an insurrection video: meta-goL0HLdYn3Pb.json
Found an insurrection video: meta-a7DW37R386K3.json
Total videos filmed in Washington DC on January 6: 1,202</code></pre>
<p class="TX">The script should find 1,202 insurrection videos. This means that out of the 1,958 videos uploaded to Parler on January 6 that included GPS coordinates, at least 61 percent were videos of the insurrection itself. (It’s possible that more videos uploaded to Parler were also from the insurrection that day but just didn’t include GPS coordinates in their metadata.) Manually watching 1,202 Parler videos is still unpleasant, but at least it’s not as bad as watching 1,958.</p>
<aside class="box" aria-labelledby="box-4">
<h4 class="BH" id="box-4"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_333" aria-label=" Page 333. "/><samp class="SANS_Dogma_OT_Bold_B_11">PROPUBLICA’S PARLER DATABASE</samp></h4>
<p class="BoxBodyCustom1"><samp class="SANS_Futura_Std_Book_11">Using the metadata as a starting point, as you’ve done so far in this chapter, 36 journalists at ProPublica did in fact watch thousands of insurrection videos from this dataset in late January 2021. The nonprofit newsroom published an interactive database of newsworthy Parler videos related to the January 6 attack. “ProPublica reviewed thousands of videos uploaded publicly to the service that were archived by a programmer before Parler was taken offline by</samp> <samp class="SANS_Futura_Std_Book_11">its web host,” states the project’s website at</samp> <a href="https://projects.propublica.org/parler-capitol-videos/"><samp class="SANS_Futura_Std_Book_Oblique_I_11">https://projects.propublica.org/parler-capitol-videos/</samp></a><samp class="SANS_Futura_Std_Book_11">.</samp> <samp class="SANS_Futura_Std_Book_11">The project included over 500 videos that “ProPublica determined were taken during the events of Jan. 6 and were relevant and newsworthy.” Readers could see what was happening during the insurrection at any point in time that day, and ProPublica organized the videos into the categories Around DC, Near Capitol, and Inside Capitol.</samp></p>
</aside>
<p class="TX">You now know which of the Parler videos were from the January 6 insurrection, but you can draw even more interesting conclusions from this dataset (and others that contain similar location data) when you visualize the data on a map.</p>
</section>

<section epub:type="division" aria-labelledby="sec26">
<h3 class="H1" id="sec26"><span id="h-287"/><samp class="SANS_Futura_Std_Bold_B_11">Plotting GPS Coordinates on a Map with simplekml</samp></h3>

<p class="TNI">Rather than just displaying a list of insurrection video filenames, you could plot the locations of those videos on a map, allowing you to easily choose which videos you’d like to watch first. You could also map all Parler videos that contain GPS coordinates around the world, in case there are other newsworthy videos in this dataset that don’t relate to the January 6 insurrection. In this section, you’ll learn to write Python code to create a file of Parler location data that you can then upload to an online map service to visualize it.</p>

<p class="TX">Google Earth (<a href="https://earth.google.com"><i>https://<wbr/>earth<wbr/>.google<wbr/>.com</i></a>) allows you to upload a file in Keyhole Markup Language (KML), a file format designed to describe geographical features such as points on a map. KML was created in 2004 specifically for use with Google Earth, and it became a standard file format for describing geographic data in 2008.</p>

<p class="TX"><a href="#list11-4">Listing 11-4</a> shows an example KML file.</p>

<pre id="pre-481"><code>&lt;?xml version="1.0" ?&gt;
&lt;kml  &gt;
    &lt;Document id="1"&gt;
      &lt;Placemark id="3"&gt;
            &lt;name&gt;New York City&lt;/name&gt;
            &lt;description&gt;The Big Apple&lt;/description&gt;
            &lt;Point id="2"&gt;<span role="doc-pagebreak" epub:type="pagebreak" id="pg_334" aria-label=" Page 334. "/>
                &lt;coordinates&gt;-74.006393,40.714172,0.0&lt;/coordinates&gt;
          &lt;/Point&gt;
      &lt;/Placemark&gt;
    &lt;/Document&gt;
&lt;/kml&gt;</code></pre>
<p class="CodeListingCaption" id="list11-4"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 11-4: A file written in KML,</samp> <samp class="SANS_Futura_Std_Book_11">example.kml</samp></p>

<p class="TX">As you can see, the KML format is similar to HTML. Both formats are extensions of XML, or Extensible Markup Language, so they share the same rules. The first line, starting with <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;?xml</samp>, is called the XML prolog, and it defines some metadata about this file. The entire contents of the KML file are wrapped in a <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;kml&gt;</samp> tag. Inside this is a <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;Document&gt;</samp> tag, and inside this are one or more <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;Placemark&gt;</samp> tags. Each <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;Placemark&gt;</samp> represents a point on a map: its name, description, and GPS coordinates in decimal format. This example file describes a single point for New York City.</p>

<p class="TX">To plot GPS coordinates on Google Earth, you must generate a KML file that contains these coordinates and then upload it to the service. The simplest way to create KML files is by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp> Python module. You can use this module to create a new KML object, create a new point on it for each Parler video with GPS coordinates, and then save that KML object to a <i>.kml</i> file.</p>

<p class="TX">Install the <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp> module by running the following command:</p>

<pre id="pre-482"><code><b>python3 -m pip install simplekml</b></code></pre>
<p class="TX">Now use the module in the Python interpreter to generate the <i>example .kml</i> file from <a href="#list11-4">Listing 11-4</a>:</p>

<pre id="pre-483"><code>&gt;&gt;&gt; <b>import simplekml</b>
&gt;&gt;&gt; <b>kml = simplekml.Kml()</b>
&gt;&gt;&gt; <b>kml.newpoint(name="New York City", description="The Big Apple", coords=</b><b>[(-74.006393,</b>
<b>40.714172)])</b>
&lt;simplekml.featgeom.Point object at 0x101241cc0&gt;
&gt;&gt;&gt; <b>kml.save("example.kml")</b></code></pre>
<p class="TX">After importing the <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp> module, this code defines the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">kml</samp> variable as the output of <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml.Kml()</samp>, which returns a KML object. It then uses the <samp class="SANS_TheSansMonoCd_W5Regular_11">kml.newpoint()</samp> method to add GPS points to the KML file it’s creating. While this example just adds one point for New York City, with the description “The Big Apple,” you can add as many points as you want. Note that the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">coords</samp> argument must be a list of tuples, with each tuple containing longitude and latitude coordinates in decimal format. Finally, after adding points, the code saves the KML file by running <samp class="SANS_TheSansMonoCd_W5Regular_11">kml.save()</samp> and passes an output filename.</p>

<p class="TX">You can find further documentation for the <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp> Python module at <a href="https://simplekml.readthedocs.io"><i>https://<wbr/>simplekml<wbr/>.readthedocs<wbr/>.io</i></a>.</p>
<aside class="box" aria-labelledby="box-5">
<h4 class="BH" id="box-5"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_335" aria-label=" Page 335. "/><samp class="SANS_Dogma_OT_Bold_B_11">ALTERNATIVES TO GOOGLE EARTH</samp></h4>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">There are many different ways to plot GPS points, including alternative online services like MapBox (</samp><a href="https://www.mapbox.com"><samp class="SANS_Futura_Std_Book_Oblique_I_11">https://www.mapbox.com</samp></a><samp class="SANS_Futura_Std_Book_11">),</samp> <samp class="SANS_Futura_Std_Book_11">which allows you to upload a CSV of GPS coordinates to generate points on a map and even embed that map into articles on your website.</samp></p>

<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">In future projects, you may need to visualize sensitive geographic data without sharing it with a third-party service like Google Earth or MapBox. The free and open source desktop software QGIS (</samp><a href="https://qgis.org"><samp class="SANS_Futura_Std_Book_Oblique_I_11">https://qgis.org</samp></a><samp class="SANS_Futura_Std_Book_11">)</samp> <samp class="SANS_Futura_Std_Book_11">allows you to create maps locally on your computer, though it’s pretty complicated to use. You can also write Python code that pulls data from OpenStreetMap (</samp><a href="https://www.openstreetmap.org"><samp class="SANS_Futura_Std_Book_Oblique_I_11">https://www.openstreetmap.org</samp></a><samp class="SANS_Futura_Std_Book_11">),</samp> <samp class="SANS_Futura_Std_Book_11">a vast and completely free and open source mapping resource that allows you to create geographic images with GPS points on them. These options aren’t as simple as using online tools, and explaining how they work is beyond the scope of this book.</samp></p>

<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">You don’t necessarily need GPS coordinates in your dataset to visualize location data on a map. If you have addresses, or even just city names or postal codes, you could convert that information to GPS coordinates and then plot those on a map. You could do the same with IP addresses, converting them to their rough GPS locations.</samp></p>
</aside>
<p class="TX">You now know how to create KML files full of location data that can be mapped in Google Earth. As your final exercise in this chapter, you’ll generate KML files based on GPS coordinates in the Parler dataset.</p>
</section>

<section epub:type="division" aria-labelledby="sec27">
<h3 class="H1F" id="sec27"><span id="h-288"/><samp class="SANS_Futura_Std_Heavy_B_21">Exercise 11-4: Create KML Files to Visualize Location Data</samp></h3>

<p class="TNI">So far, we’ve focused on finding Parler videos filmed in Washington, DC, during the January 6 insurrection. While this is undoubtedly the most newsworthy part of this dataset, there could be other things we’re missing. Parler is a global far-right social network. What other far-right videos did people post to it? Does it contain any interesting data from other countries, such as Russia? In this exercise, you’ll write a script that creates two KML files full of GPS coordinates from the Parler dataset to visualize in Google Earth:</p>
<ul class="BL">
<li class="BL">A <i>parler-videos-all.kml</i> file containing all videos with GPS coordinates</li>
<li class="BL">A <i>parler-videos-january6.kml</i> file containing videos with GPS coordinates filmed on January 6, 2021</li>
</ul>
<p class="BodyContinued">This exercise will give you experience creating KML files and using Google Earth to visualize location data, a skill that will likely come in handy for any future dataset you come across that includes location data.</p>

<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_336" aria-label=" Page 336. "/>You’ll base your script for this exercise off the script you wrote in Exercise 11-3. For a challenge, you can try programming your own script to meet the following requirements:</p>
<ul class="BL">
<li class="BL">Make this script accept an argument, <samp class="SANS_TheSansMonoCd_W5Regular_11">parler_metadata_path</samp>, using Click. This will be the path to the <i>metadata</i> folder full of JSON files.</li>
<li class="BL">Import the <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp> module and create two KML objects (one for each KML file you’ll be creating). Loop through the Parler video metadata JSON files, and add different points to the appropriate KML objects depending on the metadata. Points for all videos should be added to <i>parler-videos-all.kml</i>, and points only for videos with the <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp> of January 6, 2021, should be added to <i>parler-videos-january6.kml</i>.</li>
<li class="BL">Give every point you add to a KML object a name, a description, and GPS coordinates in decimal format. The name should be the Parler video ID (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">HS34fpbzqg2b</samp>), and the description should be a string containing the video’s download link (for example, <samp class="SANS_TheSansMonoCd_W5Regular_11">https://data.ddosecrets.com/Parler/Videos/HS34fpbzqg2b</samp>) as well as important metadata fields such as <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">FileTypeExtension</samp>, or others you’re interested in.</li>
<li class="BL">Make your script loop through all of the metadata JSON files and filter them for videos that contain GPS coordinates.</li>
</ul>
<p class="TX">Alternatively, follow along with the instructions in the rest of this exercise.</p>

<section epub:type="division" aria-labelledby="sec28">
<h4 class="H2" id="sec28"><span id="h-289"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Create a KML File for All Videos with GPS Coordinates</samp></h4>
<p class="TNI">You’ll begin by writing a script to loop through all of the Parler metadata JSON files and add any GPS coordinates it finds to a single KML file, <i>parler -videos-all.kml</i>, including only the video URL in the description, not any metadata. Make a copy of the <i>exercise-11-3.py</i> script and name it <i>exercise-11-4.py</i>, then make the following modifications:</p>

<pre id="pre-484"><code>import click
import os
import json
<b>import simplekml</b>

<b>def json_filename_to_parler_id(json_filename):</b>
    <b>return json_filename.split("-")[1].split(".")[0]</b>

def gps_degrees_to_decimal(gps_coordinate):
    parts = gps_coordinate.split()
    degrees = float(parts[0])
    minutes = float(parts[2].replace(" ' ", " "))
    seconds = float(parts[3].replace(' " ', " "))
    hemisphere = parts[4]
    gps_decimal = degrees + (minutes / 60) + (seconds / 3600)
    if hemisphere == "W" or hemisphere == "S":
        gps_decimal *= -1
    return gps_decimal
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_337" aria-label=" Page 337. "/>
@click.command()
@click.argument("parler_metadata_path")
def main(parler_metadata_path):
    <b>"""Create KML files of GPS coordinates from Parler metadata"""</b>
    <b>kml_all = simplekml.Kml()</b>

    for filename in os.listdir(parler_metadata_path):
      abs_filename = os.path.join(parler_metadata_path, filename)
        if os.path.isfile(abs_filename) and abs_filename.endswith(".json"):
            with open(abs_filename) as f:
                json_data = f.read()

            try:
                metadata = json.loads(json_data)
            except json.decoder.JSONDecodeError:
                print(f"Invalid JSON: {filename}")
                continue

              <b>if (</b>
                <b>"GPSLongitude" in metadata[0]</b>
                <b>and "GPSLatitude" in metadata[0]</b>
                <b>and metadata[0]["GPSLongitude"] != " "</b>
                <b>and metadata[0]["GPSLatitude"] != " "</b>
            <b>):</b>
                <b>name </b><b>= json_filename_to_parler_id(filename)</b>
                <b>description = f"URL: </b><b>https://data.ddosecrets.com/Parler/Videos/{name}"</b>
                <b>lon = gps_degrees_to_decimal(metadata[0]["GPSLongitude"])</b>
                <b>lat = gps_degrees_to_decimal(metadata[0]["GPSLatitude"])</b>

                <b>print(f"Found a video with GPS coordinates: {filename}")</b>
                <b>kml_all.newpoint(name=name, description</b><b>=description, coords=[(lon, lat)])</b>

    <b>kml_all.save("parler-videos-all.kml")</b>

if __name__ == "__main__":
    main()</code></pre>
<p class="TX">Since you’re going to be mapping this data, you don’t need the code that detects if a video is in Washington, DC—you’ll be able to tell by zooming into Washington, DC. Therefore, this code deletes the <samp class="SANS_TheSansMonoCd_W5Regular_11">distance()</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">was_video_filmed_in_dc()</samp> functions from the previous script, as well as the <samp class="SANS_TheSansMonoCd_W5Regular_11">math</samp> import. The new code imports the <samp class="SANS_TheSansMonoCd_W5Regular_11">simplekml</samp> module at the top of the file so that you can use it later in the script.</p>

<p class="TX">Next, the code defines the function <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename_to_parler_id()</samp>. This function is only a single, complex line of code that takes the filename of a Parler metadata JSON file as an argument, then returns the Parler ID associated with that file. For example, say the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename</samp> is <samp class="SANS_TheSansMonoCd_W5Regular_11">meta-31VC1ufihFpa.json</samp>. In this case, the expression <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename.split("-")</samp> will evaluate to the list <samp class="SANS_TheSansMonoCd_W5Regular_11">['meta', '31VC1ufihFpa.json']</samp>. Since Python starts counting at zero, the code selects the second item in that list (the string <samp class="SANS_TheSansMonoCd_W5Regular_11">31VC1ufihFpa.json</samp>) by adding <samp class="SANS_TheSansMonoCd_W5Regular_11">[1]</samp> to that expression, making it <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename .split("-")[1]</samp>. Next, it splits <i>that</i> string on the period character with the <span role="doc-pagebreak" epub:type="pagebreak" id="pg_338" aria-label=" Page 338. "/>expression <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename.split("-")[1].split(".")</samp>, which returns the list <samp class="SANS_TheSansMonoCd_W5Regular_11">['31VC1ufihFpa', 'json']</samp>. It then selects the first item in that list (the string <samp class="SANS_TheSansMonoCd_W5Regular_11">31VC1ufihFpa</samp>) by adding <samp class="SANS_TheSansMonoCd_W5Regular_11">[0]</samp> to that expression, making it <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename .split("-")[1].split(".")[0]</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename_to_parler_id()</samp> function just returns the result of that expression, which is the Parler ID.</p>

<p class="TX">In the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function, the code defines a new KML object called <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_all</samp> to contain all the GPS points found in the Parler metadata. The rest of this code should be familiar to you from Exercises 11-2 and 11-3. It loops through the Parler <i>metadata</i> folder looking for JSON files, loading the JSON data for each file it finds into the <samp class="SANS_TheSansMonoCd_W5Regular_11">metadata</samp> variable. This time, the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement ensures that the metadata dictionary contains the keys <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLongitude</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GPSLatitude</samp> and that those values aren’t blank.</p>

<p class="TX">When the code finds a Parler video that contains non-empty GPS fields, it sets up variables with the data it needs to add the point to the KML files: <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">lon</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">lat</samp>. It defines <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> as the return value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">json_filename _to_parler_id()</samp> function, meaning the name of the point will be the video’s Parler ID. It defines <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp> as the video’s download URL. Using the <samp class="SANS_TheSansMonoCd_W5Regular_11">gps_degrees_to_decimal()</samp> function, it defines <samp class="SANS_TheSansMonoCd_W5Regular_11">lon</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">lat</samp> as the longitude and latitude, in decimal format, of the GPS coordinates found in the metadata.</p>

<p class="TX">After defining these variables, the code runs <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_all.newpoint()</samp> to add the GPS point to the KML object. It sets the point’s name to <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp>, its description to <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>, and its coordinates to a list of points; in this case, the list has only one point, a tuple containing <samp class="SANS_TheSansMonoCd_W5Regular_11">lon</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">lat</samp>. Finally, when the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop is complete, the code calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_all.save()</samp> function to save all of these GPS points into the file <i>parler-videos-all.kml</i>.</p>

<p class="TX">Run the final script, changing the path in the argument to the path to your Parler <i>metadata</i> folder:</p>

<pre id="pre-485"><code>micah@trapdoor chapter-11 % <b>python3 exercise-11-4.py </b><b><var>/Volumes/datasets/Parler/metadata</var></b>
Adding point 2XpiJFsho2do to kml_all: -117.6683, 33.490500000000004
Adding point bcHZhpDOFnXd to kml_all: -1.3391, 52.04648888888889
<var>--snip--</var></code></pre>
<p class="TX">Since the Parler dataset contains about 64,000 videos with GPS coordinates, the script should return about 64,000 lines of output, each including a video’s Parler ID, longitude, and latitude. When the script finishes running, it should also create a 20MB KML file called <i>parler-videos-all.kml</i> in the same folder as the script.</p>

<p class="TX">Open <i>parler-videos-all.kml</i> in a text editor. The file’s contents should look like this:</p>

<pre id="pre-486"><code>&lt;?xml version="1.0" ?&gt;
&lt;kml  &gt;
    &lt;Document id="1"&gt;
        &lt;Placemark id="3"&gt;
            &lt;name&gt;2XpiJFsho2do&lt;/name&gt;
            &lt;description&gt;URL:https://data.ddosecrets.com/Parler/Videos/2XpiJFsho2do&lt;/description&gt;
            &lt;Point id="2"&gt;
                &lt;coordinates&gt;-117.6683,33.490500000000004,0.0&lt;/coordinates&gt;<span role="doc-pagebreak" epub:type="pagebreak" id="pg_339" aria-label=" Page 339. "/>
            &lt;/Point&gt;
        &lt;/Placemark&gt;
        &lt;Placemark id="5"&gt;
            &lt;name&gt;bcHZhpDOFnXd&lt;/name&gt;
            &lt;description&gt;URL:https://data.ddosecrets.com/Parler/Videos/bcHZhpDOFnXd&lt;/description&gt;
            &lt;Point id="4"&gt;
                &lt;coordinates&gt;-1.3391,52.04648888888889,0.0&lt;/coordinates&gt;
            &lt;/Point&gt;
        &lt;/Placemark&gt;
<var>--snip--</var></code></pre>
<p class="TX">This file should contains 64,000 <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;Placemark&gt;</samp> tags, each representing a different Parler video with GPS coordinates.</p>

<p class="TX">Now that you’ve created a KML file that contains <i>all</i> of the Parler location data, you’ll modify your script further to create a KML file with just the videos from January 6, 2021.</p>
</section>

<section epub:type="division" aria-labelledby="sec29">
<h4 class="H2" id="sec29"><span id="h-290"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Create KML Files for Videos from January 6, 2021</samp></h4>
<p class="TNI">Your script so far has a KML object called <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_all</samp>, and the code adds all of the GPS points in the Parler metadata to it. Make the following changes to your code to create another KML object, <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_january6</samp>, and just add GPS points from videos filmed on January 6, 2021, to it. Since this script is getting long, I’ll quote just the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function, the only part that is modified:</p>

<pre id="pre-487"><code>@click.command()
@click.argument("parler_metadata_path")
def main(parler_metadata_path):
    """Create KML files of GPS coordinates from Parler metadata"""
    kml_all = simplekml.Kml()
    <b>kml_january6 = simplekml.Kml()</b>

    for filename in os.listdir(parler_metadata_path):
        abs_filename = os.path.join(parler_metadata_path, filename)
        if os.path.isfile(abs_filename) and abs_filename.endswith(".json"):
            with open(abs_filename, "rb") as f:
                json_data = f.read()

            try:
                metadata = json.loads(json_data)
            except json.decoder.JSONDecodeError:
                print(f"Invalid JSON: {filename}")
                continue

            if (
                "GPSLongitude" in metadata[0]
                and "GPSLatitude" in metadata[0]
                and metadata[0]["GPSLongitude"] != " "
                and metadata[0]["GPSLatitude"] != " "
            ):
                name = json_filename_to_parler_id(filename)
                <b>description = f"URL: </b><b>https://data.ddosecrets.com/Parler/Videos/{name}&lt;br&gt;"</b>
                <b>for key in [</b><span role="doc-pagebreak" epub:type="pagebreak" id="pg_340" aria-label=" Page 340. "/>
                    <b>"CreateDate",</b>
                    <b>"FileTypeExtension",</b>
                    <b>"Duration",</b>
                    <b>"Make",</b>
                    <b>"Model",</b>
                    <b>"Software",</b>
                <b>]:</b>
                    <b>if key in metadata[0]:</b>
                        <b>description += f"{key}: {metadata[0][key]}&lt;br&gt;"</b>
                lon = gps_degrees_to_decimal(metadata[0]["GPSLongitude"])
                lat = gps_degrees_to_decimal(metadata[0]["GPSLatitude"])

                print(f"Adding point {name} to kml_all: {lon}, {lat}")
                kml_all.newpoint(name=name, description=url, coords=[(lon, lat)])

                <b>if "CreateDate" in metadata[0] and metadata[0]["CreateDate"].startswith(</b>
                    <b>"2021:01:06"</b>
                <b>):</b>
                    <b>print(f"Adding point {name} to kml_january6: {lon}, {lat}")</b>
                    <b>kml_january6.newpoint(</b>
                        <b>name=</b><b>name, description=url, coords=[(lon, lat)]</b>
                    <b>)</b>

    kml_all.save("parler-videos-all.kml")
    <b>kml_january6.save("parler-videos-january6.kml")</b></code></pre>
<p class="TX">At the top of the <samp class="SANS_TheSansMonoCd_W5Regular_11">main()</samp> function, this script adds another KML object called <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_january6</samp>. The code will add points to this file only from January 6, 2021. Next, the <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop will loop through each Parler metadata file, parse the JSON, and determine whether or not it has GPS coordinates. If so, the code will prepare variables so it can add the point to the KML objects. But this time, instead of the <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp> variable containing just the video’s download URL, it will also include metadata.</p>

<p class="TX">When defining <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>, the code adds <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;br&gt;</samp> at the end, which is the HTML tag for a line break. This way, when you visualize this KML file, the description will show the URL on the first line, and the metadata will start on the next line. The code then loops through a list of metadata keys to add to the description, including <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">FileTypeExtension</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Duration</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Make</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Model</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Software</samp>. If there are any other pieces of metadata you’d like to include, feel free to add them to your script.</p>

<p class="TX">In each loop, the code checks to see if the metadata for the current video includes that key, and if so, adds its value to <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp>, inserting a line break after each piece of metadata. For example, if the code is looking at the JSON file <i>meta-g09yZZCplavI.json</i>, <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp> will appear as follows:</p>

<pre id="pre-488"><code>URL: https://data.ddosecrets.com/Parler/Videos/g09yZZCplavI
CreateDate: 2021:01:06 20:08:25
FileTypeExtension: mov
Duration: 25.24 s
Make: Apple
Model: iPhone XS Max
Software: 14.3</code></pre>
<p class="BodyContinued"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_341" aria-label=" Page 341. "/>(The actual value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">description</samp> string will contain <samp class="SANS_TheSansMonoCd_W5Regular_11">&lt;br&gt;</samp> for the line breaks, but this is how the description will look in Google Earth.)</p>

<p class="TX">Next, the code uses another <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement to see if that video was created on January 6, 2021, and if so, adds that point to <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_january6</samp>. It does this by checking that the file has a <samp class="SANS_TheSansMonoCd_W5Regular_11">CreateDate</samp> metadata field and that the date in that field is from January 6, 2021, just as you did in Exercise 11-2. Finally, when the script finishes looping through all of the Parler videos, after saving the points in <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_all</samp> to <i>parler-videos-all.kml</i>, it also saves the points in <samp class="SANS_TheSansMonoCd_W5Regular_11">kml_january6</samp> to <i>parler-videos-january6.kml</i>.</p>

<p class="TX">You can find the final script in the book’s GitHub repo at <a href="https://github.com/micahflee/hacks-leaks-and-revelations/blob/main/chapter-11/exercise-11-4.py"><i>https://<wbr/>github<wbr/>.com<wbr/>/micahflee<wbr/>/hacks<wbr/>-leaks<wbr/>-and<wbr/>-revelations<wbr/>/blob<wbr/>/main<wbr/>/chapter<wbr/>-11<wbr/>/exercise<wbr/>-11<wbr/>-4<wbr/>.py</i></a>. Run your complete script like so:</p>

<pre id="pre-489"><code>micah@trapdoor chapter-11 % <b>python3 exercise-11-4.py </b><b><var>/Volumes/datasets/Parler/metadata</var></b>
Adding point 2XpiJFsho2do to kml_all: -117.6683, 33.490500000000004
Adding point bcHZhpDOFnXd to kml_all: -1.3391, 52.04648888888889
<var>--snip--</var>
Adding point VNYtKrEURiZs to kml_all: -97.0244, 33.1528
Adding point VNYtKrEURiZs to kml_january6: -97.0244, 33.1528
Adding point KptnQksS5Xr8 to kml_all: -77.0142, 38.8901
<var>--snip--</var></code></pre>
<p class="TX">When the script is finished running, it should have created two KML files: a 31MB file called <i>parler-videos-all.kml</i> (the file is bigger this time because the descriptions are longer) and a 929KB file called <i>parler-videos -january6.kml</i>.</p>

<p class="TX">Now that you’ve put in the hard work of generating KML files full of GPS coordinates, you can move on to the fun part: visualizing this data using Google Earth. This will allow you to scroll around the globe picking which videos you’d like to watch.</p>
</section>

</section>

<section epub:type="division" aria-labelledby="sec30">
<h3 class="H1" id="sec30"><span id="h-291"/><samp class="SANS_Futura_Std_Bold_B_11">Visualizing Location Data with Google Earth</samp></h3>

<p class="TNI">In this section, you’ll learn how to visualize location data in the KML files that you just created using Google Earth, marking each Parler video with a pin on a map. Not only will this let you visualize exactly where all of the videos with GPS coordinates were filmed, but this will also make it considerably simpler to download these videos to watch.</p>

<p class="TX">When you created those KML files, you set the description for each Parler video to include its download URL. Once you load a KML file into Google Earth and turn it into pins on a map, you can click on a video’s pin to see its description and then click the link in the description to download the video. In a web browser, load Google Earth at <a href="https://earth.google.com"><i>https://<wbr/>earth<wbr/>.google<wbr/>.com</i></a>. (You don’t have to log in to a Google account, though doing so enables you to save your work and revisit it later.) In the menu bar on the left, choose <b>Projects</b><span class="MenuArrow">▸</span><b>Open</b><span class="MenuArrow">▸</span><b>Import KML File from Computer</b>. Browse for the <i>parler -videos-all.kml</i> file you created in the previous exercise and open it. When it’s done loading, click the pencil icon to edit the title of this project, name it <span role="doc-pagebreak" epub:type="pagebreak" id="pg_342" aria-label=" Page 342. "/><i>All Parler Videos</i>, and press <small>ENTER</small>. This should create a pin on the map for each Parler video in the entire dataset, labeled by its ID.</p>

<p class="TX">Repeat this process for <i>parler-videos-january6.kml</i>, and name this one <b>Parler Videos from January 6, 2021</b>. In the Projects panel on the left of the screen, you should see your two projects.</p>

<p class="TX">By clicking the eye icon, you can show and hide Google Earth projects to choose which KML files you want displayed. With the pins you want displayed, you can rotate the Earth and zoom in on whatever you’d like. You can double-click on the map, click the plus (<span class="symbol_Bold">+</span>) button to zoom in, and click the minus (<span class="symbol_Bold">−</span>) button to zoom out.</p>

<p class="TX">For example, to investigate just the insurrection videos, show that project and hide the others. <a href="#fig11-6">Figure 11-6</a> shows Google Earth zoomed in on the US Capitol building in Washington, DC, with just the videos from the January 6 insurrection showing. The pins in the figure are all videos of the January 6 insurrection, and the pins located over the Capitol building itself are videos filmed by Trump supporters who were actively trespassing inside the US Capitol that day.</p>
<figure class="IMG"><img class="img100" id="fig11-6" src="Images/Figure11-6.png" alt="A screenshot of Google Earth focused on the US Capitol building, with only the insurrection videos showing." width="845" height="390"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-6: Google Earth, focused on the US Capitol building, with pins at the GPS points in</samp> <samp class="SANS_Futura_Std_Book_11">parler-videos-january6.kml</samp></p></figcaption>
</figure>
<p class="TX">When you find a video you’re interested in, click its pin to view its description. You should see the URL to download the video, and you can watch it using software like VLC Media Player.</p>

<p class="TX">You can also use Google Earth to search for a location so you can see the individual pins there. For example, you could hide the Parler Videos from January 6, 2021, project and instead show pins for the All Parler Videos project, then search for <i>Moscow</i>. <a href="#fig11-7">Figure 11-7</a> shows Google Earth zoomed in on the city of Moscow, Russia. As the figure indicates, only a handful of videos whose metadata included GPS coordinates were filmed there and uploaded to Parler.</p>
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_343" aria-label=" Page 343. "/>
<figure class="IMG"><img class="img100" id="fig11-7" src="Images/Figure11-7.jpg" alt="A screenshot of Google Earth, zoomed into Moscow, with five pins." width="846" height="502"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-7: Parler videos filmed in Moscow</samp></p></figcaption>
</figure>
<p class="TX">Click the pin for the video labeled <i>ykAXApWbiZuM</i>. You should see the following description:</p>

<pre id="pre-490"><code>URL: https://data.ddosecrets.com/Parler/Videos/ykAXApWbiZuM
CreateDate: 2020:06:28 21:56:41
FileTypeExtension: mov
Duration: 0:06:51
Make: Apple
Model: iPhone 7 Plus
Software: 13.5.1</code></pre>
<p class="TX">As you can see, this video was filmed on June 28, 2020 (during the Black Lives Matter uprising), with an iPhone 7 Plus running iOS 13.5.1. Right-click the link to see the option to download the video. This way, your web browser won’t try opening it directly in a new tab, where it might not display properly.</p>

<p class="TX">If you’re interested, you can open the video file using VLC Media Player to watch it. In the recording, a tattooed American white supremacist who runs a Confederate-themed barber shop in Moscow goes on a racist and homophobic rant, in part explaining why he moved to Russia. “I voted Trump in office in 2016,” he said. “But the fact is, nothing’s gonna change. The fact is, all these Trump supporters in America all the time can’t see the real problem. Your real problem is fucking Jews in America.” <a href="#fig11-8">Figure 11-8</a> shows a screenshot from the video where he’s telling Parler users that he’s a real white supremacist and not a liberal troll, as people were accusing him of being.</p>
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_344" aria-label=" Page 344. "/>
<figure class="IMG"><img class="img80" id="fig11-8" src="Images/Figure11-8.png" alt="A still from the Parler video of the American white supremacist in Moscow, in VLC Media Player." width="526" height="303"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 11-8: A screenshot from a Parler video filmed by an American white supremacist in Moscow</samp></p></figcaption>
</figure>
<p class="TX">He goes on to fantasize about mass shooting Black Lives Matter protesters. “I watch the news in America. I see all these fucking [N-word]s, antifa fucking scum. Ripping down the monuments. It angers me more than anything. What I don’t understand is where’s the fucking police to stop any of this?” he asks. “How come nobody’s shooting these motherfuckers? If I was in Los Angeles still, seeing all this rioting and looting going on, I’d be up on a motherfucking building with my AK-47 just spraying the fucking crowd.”</p>

<p class="TX">If you’re curious about the complete metadata from this video, you can check the original file at <i>meta-ykAXApWbiZuM.json</i>. If you wanted to see more videos posted by this Parler user, you could modify your script to filter videos that were filmed on the exact device by checking for the same <samp class="SANS_TheSansMonoCd_W5Regular_11">Make</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Model</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Software</samp> fields. You might find some other users’ videos, but chances are you’ll also find more videos from this poster as well.</p>

<p class="TX">The media spent the bulk of its time focusing on Parler videos they knew were taken in Washington, DC, on the day of the insurrection. If you’re interested in further exploring this dataset, you might try to find videos from other far-right protests, or events with far-right counterprotesters. For example, you could create a KML file that includes the date ranges of the specific 2020 Black Lives Matters protests and explore those videos. You might find video evidence of other crimes.</p>
</section>

<section epub:type="division" aria-labelledby="sec31">
<h3 class="H1" id="sec31"><span id="h-292"/><samp class="SANS_Futura_Std_Bold_B_11">Viewing Metadata with ExifTool</samp></h3>

<p class="TNI">When <span class="LinkTwitter">@donk_enby</span> downloaded the Parler videos and extracted metadata from them in JSON format, she used a command line program called <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp>. This program is one of the investigation tools I use most frequently, and this section explains how to use it.</p>

<p class="TX">If you run <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp> followed by a filepath, it will attempt to find metadata stored in that file and show it to you. It works on a variety of file formats, including Microsoft Office documents, PDFs, images, and videos. You can use it to find hidden information in the metadata of those documents, <span role="doc-pagebreak" epub:type="pagebreak" id="pg_345" aria-label=" Page 345. "/>such as the author of a Word document, which type of phone or camera was used to take a photo, and much more.</p>

<p class="TX">You don’t need to run <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp> on the Parler videos since <span class="LinkTwitter">@donk_enby</span> did it for you, but most of the time, you won’t be so lucky. If you want to search for hidden information in BlueLeaks documents, for example, you’d need to run <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp> on them yourself. In this subsection, to learn how <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp> works, you’ll use it to view the metadata on one of the Parler videos in JSON format.</p>

<p class="TX">Mac users, install <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp> by running the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">brew install exiftool</samp> command; users of Linux or Windows with WSL, install it with the <samp class="SANS_TheSansMonoCd_W7Bold_B_11">sudo apt install libimage-exiftool-perl</samp> command. In your terminal, change to the <i>videos</i> folder in your Parler dataset folder and use <samp class="SANS_TheSansMonoCd_W5Regular_11">wget</samp> to download the Parler video with the ID <i>HS34fpbzqg2b</i>:</p>

<pre id="pre-491"><code><b>wget </b><b>https://data.ddosecrets.com/Parler/Videos/HS34fpbzqg2b</b></code></pre>
<p class="TX">You can use <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp> to look at the metadata of a file by running <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">filename</samp>. Run it on the <i>HS34fpbzqg2b</i> file that you just downloaded with the following command:</p>

<pre id="pre-492"><code><b>exiftool HS34fpbzqg2b</b></code></pre>
<p class="TX">The output should show all the metadata for this video file:</p>

<pre id="pre-493"><code><var>--snip--</var>
File Type Extension             : mov
<var>--snip--</var>
Model                           : iPhone XR
Software                        : 14.2
Creation Date                   : 2021:01:06 13:57:49-05:00
<var>--snip--</var>
GPS Position                    : 38 deg 53' 26.52" N, 77 deg 0' 28.44" W</code></pre>
<p class="TX">Along with other information, the metadata shows that this video’s file extension is <i>.mov</i>, it was recorded using an iPhone XR running iOS 14.2 on January 6, 2021, at 1:57 <small>PM</small>, and it was filmed at the GPS coordinates 38 deg 53<span class="body_symbol">′</span> 26.52<span class="body_symbol">″</span> N, 77 deg 0<span class="body_symbol">′</span> 28.44<span class="body_symbol">″</span> W.</p>

<p class="TX">Since the file extension for this video is <i>.mov</i>, rename it by running <samp class="SANS_TheSansMonoCd_W7Bold_B_11">mv HS34fpbzqg2b HS34fpbzqg2b.mov</samp>. You can open <i>HS34fpbzqg2b.mov</i> in a program like VLC Media Player just to see what it contains: police officers stepping out of the way while Trump supporters remove barricades surrounding the Capitol building.</p>

<p class="TX">When <span class="LinkTwitter">@donk_enby</span> used <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp> to extract the metadata from the Parler videos, she used the <samp class="SANS_TheSansMonoCd_W5Regular_11">-json</samp> argument to extract it in JSON format. Here’s how you do that for <i>HS34fpbzqg2b</i>:</p>

<pre id="pre-494"><code>micah@trapdoor videos % <b>exiftool HS34fpbzqg2b -json</b>
[{
  "SourceFile": "HS34fpbzqg2b",
  "ExifToolVersion": 12.42,<span role="doc-pagebreak" epub:type="pagebreak" id="pg_346" aria-label=" Page 346. "/>
  "FileName": "HS34fpbzqg2b",
<var>--snip--</var>
  "GPSLatitude": "38 deg 53' 26.52\" N",
  "GPSLongitude": "77 deg 0' 28.44\" W",
  "Rotation": 180,
  "GPSPosition": "38 deg 53' 26.52\" N, 77 deg 0' 28.44\" W"
}]</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">-json</samp> argument makes the output much easier to work with than <samp class="SANS_TheSansMonoCd_W5Regular_11">exiftool</samp>’s default output.</p>
</section>

<section epub:type="division" aria-labelledby="sec32">
<h3 class="H1" id="sec32"><span id="h-293"/><samp class="SANS_Futura_Std_Bold_B_11">Summary</samp></h3>

<p class="TNI">In this chapter, you’ve learned about the secrets hidden in the metadata of over a million videos uploaded to Parler, many of them by insurrectionists filming themselves during the January 6 riot in Washington, DC. You’ve learned the syntax of the JSON file format and how to work with JSON data in your own Python scripts. You’ve written a series of scripts that filtered the list of a million videos down to just the ones that were, according to their metadata, filmed on January 6, 2021, in Washington, DC, during the attack on the US Capitol by supporters of Donald Trump. You now have the skills necessary to write code that analyzes JSON in your own investigations. Finally, you’ve seen how you can convert GPS coordinates from degrees to decimal and plot them on a map, an invaluable skill for future investigations that involve location data.</p>

<p class="TX">In the next chapter, you’ll explore one more technology that’s common in hacked and leaked datasets: SQL databases. You’ll use the SQL skills you learn to dig into the hacked databases of Epik, a hosting and domain name company that provides service to much of the American fascist movement.</p>
</section>

</section>

</div></body></html>