<html><head></head><body>
<h2 class="h2c" id="ch02"><span epub:type="pagebreak" id="page_23"/><span class="big1"><strong>2</strong></span><br/><strong>DEBUGGING GAMES WITH OLLYDBG</strong></h2>&#13;
<div class="image"><img src="../images/common.jpg" alt="image"/></div>&#13;
<p class="noindent">You can scratch the surface of what happens as a game runs with Cheat Engine, but with a good debugger, you can dig deeper until you understand the game’s structure and execution flow. That makes OllyDbg essential to your game-hacking arsenal. It’s packed with a myriad of powerful tools like conditional breakpoints, referenced string search, assembly pattern search, and execution tracing, making it a robust assembler-level debugger for 32-bit Windows applications.</p>&#13;
<p class="indent">I’ll cover low-level code structure in detail in <a href="ch04.xhtml#ch04">Chapter 4</a>, but for this chapter, I assume you’re at least familiar with modern code-level debuggers, such as the one packaged with Microsoft Visual Studio. OllyDbg is functionally similar to those, with one major difference: it interfaces with <span epub:type="pagebreak" id="page_24"/>the assembly code of an application, working even in the absence of source code and/or debug symbols, making it ideal when you need to dig into the internals of a game. After all, game companies are rarely nice (or dumb) enough to ship their games with debug symbols!</p>&#13;
<p class="indent">In this chapter, I’ll go over OllyDbg’s user interface, show you how to use its most common debugging features, break down its expression engine, and provide some real-world examples of how you can tie it in to your game hacking endeavors. As a wrap-up, I’ll teach you about some useful plug-ins and send you off with a test game designed to get you started in OllyDbg.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>This chapter focuses on OllyDbg 1.10 and may not be entirely accurate for later versions. I use this version because, at the time of writing, the plug-in interface for OllyDbg 2 is still far less robust than the one for OllyDbg 1.</em></p>&#13;
</div>&#13;
<p class="indent">When you feel like you have a handle on OllyDbg’s interface and features, you can try it on a game yourself with “<a href="ch02.xhtml#ch02sb01">Patching an <span class="literal">if()</span> Statement</a>” on <a href="ch02.xhtml#page_46">page 46</a>.</p>&#13;
<h3 class="h3" id="ch00lev1sec31"><strong>A Brief Look at OllyDbg’s User Interface</strong></h3>&#13;
<p class="noindent">Go to the OllyDbg website (<em><a href="http://www.ollydbg.de/">http://www.ollydbg.de/</a></em>), download and install OllyDbg, and open the program. You should see the toolbar shown in <a href="ch02.xhtml#ch2fig1">Figure 2-1</a> above a multiple window interface area.</p>&#13;
<div class="image"><img src="../images/f02-01.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch2fig1"/><em>Figure 2-1: OllyDbg main window</em></p>&#13;
<p class="indent">This toolbar contains the program controls <span class="ent">➊</span>, the debug buttons <span class="ent">➋</span>, the Go to button <span class="ent">➌</span>, the control window buttons <span class="ent">➍</span>, and the Settings button <span class="ent">➎</span>.</p>&#13;
<p class="indent">The three program controls allow you to open an executable and attach to the process it creates, restart the current process, or terminate execution of the current process, respectively. You can also complete these functions with the hotkeys F3, <small>CTRL</small>-F2, and <small>ALT</small>-F2, respectively. To attach to a process that is already running, click <strong>File</strong> <span class="ent">▸</span> <strong>Attach</strong>.</p>&#13;
<p class="indent">The debug buttons control the debugger actions. <a href="ch02.xhtml#ch2tab1">Table 2-1</a> describes what these buttons do, along with their hotkeys and functions. This table also lists three useful debugger actions that don’t have buttons on the debug toolbar.</p>&#13;
<p class="tablecap"><span epub:type="pagebreak" id="page_25"/><a id="ch2tab1"/><strong>Table 2-1:</strong> Debug Buttons and Other Debugger Functions</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Button</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Hotkey</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Function</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Play</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">F9</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Resumes normal execution of the process.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Pause</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">F12</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Pauses execution of all threads within the process and brings up the CPU window at the instruction currently being executed.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Step into</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">F7</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Single-steps to the next operation to be executed (will dive down into function calls).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Step over</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">F8</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Steps to the next operation to be executed within current scope (will skip over function calls).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Trace into</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">CTRL-F11</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Runs a deep trace, tracing every operation that is executed.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Trace over</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">CTRL-F12</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Runs a passive trace that traces only operations within the current scope.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Execute until return</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">CTRL-F9</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Executes until a return operation is hit within the current scope.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"> </p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">CTRL-F7</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Automatically single-steps on every operation, following execution in the disassembly window. This makes execution appear to be animated.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"> </p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">CTRL-F8</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Also animates execution, but steps over functions instead of stepping into them.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"> </p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">ESC</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Stops animation, pausing execution on the current operation.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The Go to button opens a dialog asking for a hexadecimal address. Once you enter the address, OllyDbg opens the CPU window and shows the disassembly at the specified address. When the CPU window is in focus, you can also show that information with the hotkey <small>CTRL</small>-G.</p>&#13;
<p class="indent">The control window buttons open different <em>control windows</em>, which display useful information about the process you’re debugging and expose more debugging functions, like the ability to set breakpoints. OllyDbg has a total of 13 control windows, which can all be open simultaneously within the multiple window interface. <a href="ch02.xhtml#ch2tab2">Table 2-2</a> describes these windows, listed in the order in which they appear on the window buttons toolbar.</p>&#13;
<p class="tablecap"><a id="ch2tab2"/><strong>Table 2-2:</strong> OllyDbg’s Control Windows</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Window</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Hotkey</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Function</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Log</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">ALT-L</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Displays a list of log messages, including debug prints, thread events, debugger events, module loads, and much more.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Modules</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">ALT-E</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Displays a list of all executable modules loaded into the process. Double-click a module to open it in the CPU window.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><span epub:type="pagebreak" id="page_26"/><p class="table">Memory map</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">ALT-M</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Displays a list of all blocks of memory allocated by the process. Double-click a block in the list to bring up a dump window of that memory block.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Threads</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"> </p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Displays a list of threads running in the process. For each thread in this list, the process has a structure called a <em>Thread Information Block (TIB)</em>. OllyDbg allows you to view each thread’s TIB; simply right-click a thread and select Dump thread data block.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Windows</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"> </p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Displays a list of window handles held by the process.<br/>Right-click a window in this list to jump to or set a breakpoint on its class procedure (the function that gets called when a message is sent to the window).</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Handles</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"> </p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Displays a list of handles held by the process. (Note that Process Explorer has a much better handle list than OllyDbg, as I will discuss in <a href="ch03.xhtml#ch03">Chapter 3</a>.)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">CPU</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">ALT-C</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Displays the main disassembler interface and controls a majority of the debugger functionality.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Patches</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">CTRL-P</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Displays a list of any assembly code modifications you have made to modules within the process.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Call stack</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">ALT-K</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Displays the call stack for the active thread. The window updates when the process halts.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Breakpoints</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">ALT-B</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Displays a list of active debugger breakpoints and allows you to toggle them on and off.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">References</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"> </p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Displays the reference list, which typically holds the search results for many different types of searches. It pops up on its own when you run a search.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Run trace</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table"> </p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Displays a list of operations logged by a debugger trace.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Source</p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"> </p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Displays the source code of the disassembled module if a program debug database is present.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Finally, the Settings button opens the OllyDbg settings window. Keep the default settings for now.</p>&#13;
<p class="indent">Now that you’ve had a tour of the main OllyDbg window, let’s explore the CPU, Patches, and Run trace windows more closely. You’ll use those windows extensively as a game hacker, and knowing your way around them is key.</p>&#13;
<h3 class="h3" id="ch00lev1sec32"><strong>OllyDbg’s CPU Window</strong></h3>&#13;
<p class="noindent">The CPU window in <a href="ch02.xhtml#ch2fig2">Figure 2-2</a> is where game hackers spend most of their time in OllyDbg because it is the main control window for the debugging features.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_27"/><img src="../images/f02-02.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch2fig2"/><em>Figure 2-2: OllyDbg CPU window</em></p>&#13;
<p class="indent">This window houses four distinct control panes: the disassembler pane <span class="ent">➊</span>, the registers pane <span class="ent">➋</span>, the dump pane <span class="ent">➌</span>, and the stack pane <span class="ent">➍</span>. These four panes encapsulate OllyDbg’s main debugger functions, so it’s important to know them inside and out.</p>&#13;
<h4 class="h4" id="ch00lev1sec33"><strong><em>Viewing and Navigating a Game’s Assembly Code</em></strong></h4>&#13;
<p class="noindent">You’ll navigate game code and control most aspects of debugging from OllyDbg’s disassembler pane. This pane displays the assembly code for the current module, and its data is neatly displayed in a table composed of four distinct columns: Address, Hex dump, Disassembly, and Comment.</p>&#13;
<p class="indent">The Address column displays the memory addresses of each operation in the game process you’re attached to. You can double-click an address in this column to toggle whether it’s the <em>display base</em>. When an address is set as the display base, the Address column displays all other addresses as offsets relative to it.</p>&#13;
<p class="indent">The Hex dump column displays the byte code for each operation, grouping operation codes and parameters accordingly. Black braces spanning multiple lines on the left side of this column mark known function boundaries. Operations that have jumps going to them are shown with a <span epub:type="pagebreak" id="page_28"/>right-facing arrow on the inside of these braces. Operations that perform jumps are shown with either up-facing or down-facing arrows, depending on the direction in which they jump, on the inside of these braces. For example, in <a href="ch02.xhtml#ch2fig2">Figure 2-2</a>, the instruction at address 0x779916B1 (highlighted in gray) has an up-facing arrow, indicating it’s an upward jump. You can think of a jump as a <span class="literal">goto</span> operator.</p>&#13;
<p class="indent">The Disassembly column displays the assembly code of each operation the game performs. So, for example, you can confirm that the instruction at 0x779916B1 in <a href="ch02.xhtml#ch2fig2">Figure 2-2</a> is a jump by looking at the assembly, which shows a JNZ (jump if nonzero) instruction. Black braces in this column mark the boundaries of loops. Right-facing arrows attached to these braces point to the conditional statements that control whether the loops continue or exit. The three right-facing arrows in this column in <a href="ch02.xhtml#ch2fig2">Figure 2-2</a> point to CMP (compare) and TEST instructions, which are used by assembly code to compare values.</p>&#13;
<p class="indent">The Comment column displays human-readable comments about each operation the game performs. If OllyDbg encounters known API function names, it will automatically insert a comment with the name of the function. Similarly, if it successfully detects arguments being passed to a function, it will label them (for example, <span class="literal">Arg1</span>, <span class="literal">Arg2</span>, . . . , <span class="literal">Arg<span class="codeitalic">N</span></span>). You can double-click in this column to add a customized comment. Black braces in this column mark the assumed boundaries of function call parameters.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>OllyDbg infers function boundaries, jump directions, loop structures, and function parameters during code analysis, so if these columns lack boundary lines or jump arrows, just press <small>CTRL</small>-A to run a code analysis on the binary.</em></p>&#13;
</div>&#13;
<p class="indent">When the disassembler pane is in focus, there are a few hotkeys you can use to quickly navigate code and control the debugger. Use F2 for Toggle breakpoint, <small>SHIFT</small>-F12 for Place conditional breakpoint, - (hyphen) for Go back and + (plus) for Go forward (these two work as you’d expect in a web browser), * (asterisk) for Go to EIP (which is the execution pointer in the x86 architecture), <small>CTRL</small>-- (hyphen) for Go to previous function, and <small>CTRL-+</small> for Go to next function.</p>&#13;
<p class="indentb">The disassembler can also populate the References window with different types of search results. When you want to change the References window’s contents, right-click in the disassembler pane, mouse over the Search for menu to expand it, and select one of the following options:</p>&#13;
<p class="noindenth"><strong>All intermodular calls</strong> Searches for all calls to functions in remote modules. This can, for example, allow you to see everywhere that a game calls <span class="literal">Sleep()</span>, <span class="literal">PeekMessage()</span>, or any other Windows API function, enabling you to inspect or set breakpoints on the calls.</p>&#13;
<p class="noindenth"><strong>All commands</strong> Searches for all occurrences of a given operation written in assembly, where the added operators <span class="literal">CONST</span> and <span class="literal">R32</span> will match a constant value or a register value, respectively. One use for this option might be searching for commands like <span class="literal">MOV [0xDEADBEEF], CONST</span>; <span epub:type="pagebreak" id="page_29"/><span class="literal">MOV [0xDEADBEEF], R32</span>; and <span class="literal">MOV [0xDEADBEEF], [R32+CONST]</span> to list all operations that modify memory at the address <span class="literal">0xDEADBEEF</span>, which could be anything, including the address of your player’s health.</p>&#13;
<p class="noindenth"><strong>All sequences</strong> Searches for all occurrences of a given sequence of operations. This is similar to the previous options, but it allows you to specify multiple commands.</p>&#13;
<p class="noindenth"><strong>All constants</strong> Searches for all instances of a given hexadecimal constant. For instance, if you enter the address of your character’s health, this will list all of the commands that directly access it.</p>&#13;
<p class="noindenth"><strong>All switches</strong> Searches for all switch-case blocks.</p>&#13;
<p class="noindenth"><strong>All referenced text strings</strong> Searches for all strings referenced in code. You can use this option to search through all referenced strings and see what code accesses them, which can be useful for correlating in-game text displays with the code that displays them. This option is also very useful for locating any debug assertion or logging strings, which can be a tremendous help in determining the purpose of code parts.</p>&#13;
<p class="indentt">The disassembler can also populate the Names window with all labels in the current module (<small>CTRL</small>-N) or all known labels in all modules (Search for <span class="ent">▸</span> Name in all modules). Known API functions will be automatically labeled with their names, and you can add a label to a command by highlighting it, pressing <small>SHIFT</small>-; and entering the label when prompted. When a labeled command is referenced in code, the label will be shown in place of the address. One way to use this feature is to name functions that you’ve analyzed (just set a label on the first command in a function) so you can see their names when other functions call them.</p>&#13;
<h4 class="h4" id="ch00lev1sec34"><strong><em>Viewing and Editing Register Contents</em></strong></h4>&#13;
<p class="noindent">The registers pane displays the contents of the eight processor registers, all eight flag bits, the six segment registers, the last Windows error code, and EIP. Underneath these values, this pane can display either <em>Floating-Point Unit (FPU)</em> registers or debug registers; click on the pane’s header to change which registers are displayed. The values in this pane are populated only if you freeze your process. Values that are displayed in red have been changed since the previous pause. Double-click on values in this pane to edit them.</p>&#13;
<h4 class="h4" id="ch00lev1sec35"><strong><em>Viewing and Searching a Game’s Memory</em></strong></h4>&#13;
<p class="noindent">The dump pane displays a dump of the memory at a specific address. To jump to an address and display the memory contents, press <small>CTRL</small>-G and enter the address in the box that appears. You can also jump to the address of an entry in the other CPU window panes by right-clicking on the Address column and selecting Follow in dump.</p>&#13;
<p class="indent">While there are always three columns in the dump pane, the only one you should always see is the Address column, which behaves much like its cousin within the disassembler pane. The data display type you choose <span epub:type="pagebreak" id="page_30"/>determines the other two columns shown. Right-click the dump pane to change the display type; for the one shown in <a href="ch02.xhtml#ch2fig2">Figure 2-2</a>, you’d right-click and select Hex <span class="ent">▸</span> Hex/ASCII (8 bytes).</p>&#13;
<p class="indent">You can set a memory breakpoint on an address shown in the dump pane by right-clicking that address and expanding the Breakpoint submenu. Select <strong>Memory</strong> <span class="ent">▸</span> <strong>On access</strong> from this menu to break on any code that uses the address at all, or select <strong>Memory</strong> <span class="ent">▸</span> <strong>On write</strong> to break only on code that writes to that space in memory. To remove a memory breakpoint, select <strong>Remove memory breakpoint</strong> in the same menu; this option appears only when the address you right-click has a breakpoint.</p>&#13;
<p class="indent">With one or more values selected in the dump, you can press <small>CTRL</small>-R to search the current module’s code for references to addresses of the selected values; results of this search appear in the References window. You can also search for values in this pane using <small>CTRL</small>-B for binary strings and <small>CTRL</small>-N for labels. After you initiate a search, press <small>CTRL</small>-L to jump to the next match. <small>CTRL</small>-E allows you to edit any values you have selected.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The dump windows that you can open from the Memory window work in the same way as the dump pane.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec36"><strong><em>Viewing a Game’s Call Stack</em></strong></h4>&#13;
<p class="noindent">The final CPU pane is the stack pane, and as the name suggests, it shows the call stack. Like the dump and disassembler panes, the stack pane has an Address column. The stack pane also has a Value column, which shows the stack as an array of 32-bit integers, and a Comment column, which shows return addresses, known function names, and other informative labels. The stack pane supports all the same hotkeys as the dump pane, with the exception of <small>CTRL</small>-N.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>MULTICLIENT PATCHING</strong></p>&#13;
<p class="noindent">One type of hack, called a <em>multiclient patch</em>, overwrites the single-instance limitation code within a game’s binary with no-operation code, allowing the user to run multiple game clients, even when doing so is normally forbidden. Because the code that performs instance limitation must be executed very early after a game client is launched, it can be nearly impossible for a bot to inject its patch on time. The easiest workaround for this is to make multiclient patches persist by applying them within OllyDbg and saving them directly to the game binary.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec37"><span epub:type="pagebreak" id="page_31"/><strong>Creating Code Patches</strong></h3>&#13;
<p class="noindent">OllyDbg’s <em>code patches</em> let you make assembly code modifications for a game you want to hack, removing the need to engineer a tool tailored to that specific game. This makes prototyping <em>control flow hacks</em>—which manipulate game behavior through a mix of game design flaws, x86 assembly protocols, and common binary constructs—much easier.</p>&#13;
<p class="indent">Game hackers typically include perfected patches as optional features in a bot’s tool suite, but in some cases, making those features persistent is actually more convenient for your end user. Luckily, OllyDbg patches provide the complete functionality you need to design, test, and permanently save code modifications to an executable binary using only OllyDbg.</p>&#13;
<p class="indent">To place a patch, navigate to the line of assembly code you want to patch in the CPU window, double-click the instruction you wish to modify, place a new assembly instruction in the pop-up prompt, and click <strong>Assemble</strong>, as shown in <a href="ch02.xhtml#ch2fig3">Figure 2-3</a>.</p>&#13;
<div class="image"><img src="../images/f02-03.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch2fig3"/><em>Figure 2-3: Placing a patch with OllyDbg</em></p>&#13;
<p class="indent">Always pay attention to the size of your patch—you can’t just resize and move around assembled code however you’d like. Patches <em>larger</em> than the code you intend to replace will overflow into subsequent operations, potentially removing critical functionality. Patches <em>smaller</em> than the operations you intend to replace are safe, as long as Fill with NOPs is checked. This option fills any abandoned bytes with <em>no-operation (NOP)</em> commands, which are single-byte operations that do nothing when executed.</p>&#13;
<p class="indent">All patches you place are listed, along with the address, size, state, old code, new code, and comment, in the Patches window. Select a patch in this list to access a small but powerful set of hotkeys, shown in <a href="ch02.xhtml#ch2tab3">Table 2-3</a>.</p>&#13;
<p class="tablecap"><span epub:type="pagebreak" id="page_32"/><a id="ch2tab3"/><strong>Table 2-3:</strong> Patches Window Hotkeys</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Operator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Function</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><small>ENTER</small></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Jumps to the patch in the disassembler.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">spacebar</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Toggles the patch on or off.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table">F2</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Places a breakpoint on the patch.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><small>SHIFT</small>-F2</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Places a conditional breakpoint on the patch.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><small>SHIFT</small>-F4</p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Places a conditional log breakpoint on the patch.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><small>DEL</small></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Removes the patch entry from the list only.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">In OllyDbg, you can also save your patches directly to the binary. First, right-click in the disassembler and click <strong>Copy to executable</strong> <span class="ent">▸</span> <strong>All modifications</strong>. If you want to copy only certain patches, highlight them in the disassembly pane and press <strong>Copy to executable</strong> <span class="ent">▸</span> <strong>Selection</strong> instead.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><strong>DETERMINING PATCH SIZE</strong></p>&#13;
<p class="noindent">There are a few ways to determine whether your patch will be a different size than the original code. For example, in <a href="ch02.xhtml#ch2fig3">Figure 2-3</a>, you can see the command at <span class="literal">0x7790ED2E</span> being changed from <span class="literal">SHR AL, 6</span> to <span class="literal">SHR AL, 7</span>. If you look at the bytes to the left of the command, you see 3 bytes that represent the memory of the command. This means our new command must either be 3 bytes or padded with NOPs if it’s less than 3 bytes. Furthermore, these bytes are arranged in two columns. The first column contains <span class="literal">0xC0</span> and <span class="literal">0x08</span>, which represent the command <span class="literal">SHR</span> and the first operand, <span class="literal">AL</span>. The second column contains <span class="literal">0x06</span>, which represents the original operand. Because the second column shows a single byte, any replacement operand must also be 1 byte (between <span class="literal">0x00</span> and <span class="literal">0xFF</span>). If this column had shown <span class="literal">0x00000006</span> instead, a replacement operand could be up to 4 bytes in length.</p>&#13;
<p class="indent">Typical code patches will either use all NOPs to completely remove a command (by leaving the box empty and letting it fill the entire command with NOPs) or just replace a single operand, so this method of checking patch size is almost always effective.</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec38"><strong>Tracing Through Assembly Code</strong></h3>&#13;
<p class="noindent">When you run a trace on any program, OllyDbg single-steps over every executed operation and stores data about each one. When the trace is complete, the logged data is displayed in the Run trace window, shown in <a href="ch02.xhtml#ch2fig4">Figure 2-4</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_33"/><img src="../images/f02-04.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch2fig4"/><em>Figure 2-4: The Run trace window</em></p>&#13;
<p class="indentb">The Run trace window is organized into the following six columns:</p>&#13;
<p class="noindenth"><strong>Back</strong> The number of operations logged between an operation and the current execution state</p>&#13;
<p class="noindenth"><strong>Thread</strong> The thread that executed the operation</p>&#13;
<p class="noindenth"><strong>Module</strong> The module where the operation resides</p>&#13;
<p class="noindenth"><strong>Address</strong> The address of the operation</p>&#13;
<p class="noindenth"><strong>Command</strong> The operation that was executed</p>&#13;
<p class="noindenth"><strong>Modified registers</strong> The registers changed by the operation and their new values</p>&#13;
<p class="indentt">When hacking games, I find OllyDbg’s trace feature very effective at helping me find pointer paths to dynamic memory when Cheat Engine scans prove inconclusive. This works because you can follow the log in the Run trace window backward from the point when the memory is used to the point where it is resolved from a static address.</p>&#13;
<p class="indent">This potent feature’s usefulness is limited only by the creativity of the hacker using it. Though I typically use it only to find pointer paths, I’ve come across a few other situations where it has proven invaluable. The anecdotes in “<a href="ch02.xhtml#ch00lev1sec44">OllyDbg Expressions in Action</a>” on <a href="ch02.xhtml#page_36">page 36</a> will help to illuminate the functionality and power of tracing.</p>&#13;
<h3 class="h3" id="ch00lev1sec39"><strong>OllyDbg’s Expression Engine</strong></h3>&#13;
<p class="noindent">OllyDbg is home to a custom expression engine that can compile and evaluate advanced expressions with a simple syntax. The expression engine is surprisingly powerful and, when utilized properly, can be the difference between an average OllyDbg user and an OllyDbg wizard. You can use this engine to specify expressions for many features, such as conditional breakpoints, conditional traces, and the command line plug-in. This section introduces the expression engine and the options it provides.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_34"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Parts of this section are based on the official expressions documentation</em> (<a href="http://www.ollydbg.de/Help/i_Expressions.htm">http://www.ollydbg.de/Help/i_Expressions.htm</a><em>). I have found, however, that a few of the components defined in the documentation don’t seem to work, at least not in OllyDbg v1.10. Two examples are the</em> <span class="literal"><span class="codeitalic">INT</span></span> <em>and</em> <span class="literal"><span class="codeitalic">ASCII</span></span> <em>data types, which must be substituted with the aliases</em> <span class="literal"><span class="codeitalic">LONG</span></span> <em>and</em> <span class="literal"><span class="codeitalic">STRING</span></span><em>. For this reason, here I include only components that I’ve personally tested and fully understand.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec40"><strong><em>Using Expressions in Breakpoints</em></strong></h4>&#13;
<p class="noindent">When a <em>conditional breakpoint</em> is toggled on, OllyDbg prompts you to enter an expression for the condition; this is where most expressions are used. When that breakpoint is executed, OllyDbg silently pauses execution and evaluates the expression. If the result of the evaluation is nonzero, execution remains paused and you will see the breakpoint get triggered. But if the result of the evaluation is <span class="literal">0</span>, OllyDbg silently resumes execution as if nothing happened.</p>&#13;
<p class="indent">With the huge number of executions that happen within a game every second, you’ll often find that a piece of code is executed in far too many contexts for a breakpoint to be an effective way of getting the data you are looking for. A conditional breakpoint paired with a good understanding of the code surrounding it is a foolproof way to avoid these situations.</p>&#13;
<h4 class="h4" id="ch00lev1sec41"><strong><em>Using Operators in the Expression Engine</em></strong></h4>&#13;
<p class="noindent">For numeric data types, OllyDbg expressions support general C-style operators, as seen in <a href="ch02.xhtml#ch2tab4">Table 2-4</a>. While there is no clear documentation on the operator precedence, OllyDbg seems to follow C-style precedence and can use parenthesized scoping.</p>&#13;
<p class="tablecap"><a id="ch2tab4"/><strong>Table 2-4:</strong> OllyDbg Numeric Operators</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Operator</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Function</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">a == b</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Returns <span class="literal">1</span> if <span class="literal">a</span> is equal to <span class="literal">b</span>, else returns <span class="literal">0</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">a != b</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Returns <span class="literal">1</span> if <span class="literal">a</span> is not equal to <span class="literal">b</span>, else returns <span class="literal">0</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">a &gt; b</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Returns <span class="literal">1</span> if <span class="literal">a</span> is greater than <span class="literal">b</span>, else returns <span class="literal">0</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">a &lt; b</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Returns <span class="literal">1</span> if <span class="literal">a</span> is less than <span class="literal">b</span>, else returns <span class="literal">0</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">a &gt;= b</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Returns <span class="literal">1</span> if <span class="literal">a</span> is greater than or equal to <span class="literal">b</span>, else returns <span class="literal">0</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">a &lt;= b</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Returns <span class="literal">1</span> if <span class="literal">a</span> is less than or equal to <span class="literal">b</span>, else returns <span class="literal">0</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">a &amp;&amp; b</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Returns <span class="literal">1</span> if <span class="literal">a</span> and <span class="literal">b</span> are both nonzero, else returns <span class="literal">0</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">a || b</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Returns <span class="literal">1</span> if either <span class="literal">a</span> or <span class="literal">b</span> are nonzero, else returns <span class="literal">0</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">a ^ b</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Returns the result of <span class="literal">XOR(a, b)</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">a % b</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Returns the result of <span class="literal">MODULUS(a, b)</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">a &amp; b</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Return the result of <span class="literal">AND(a, b)</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">a | b</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Return the result of <span class="literal">OR(a, b)</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">a &lt;&lt; b</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Returns the result of <span class="literal">a</span> shifted <span class="literal">b</span> bits to the left.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">a &gt;&gt; b</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Returns the result of <span class="literal">a</span> shifted <span class="literal">b</span> bits to the right.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><span epub:type="pagebreak" id="page_35"/><p class="table"><span class="literal">a + b</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Returns the sum of <span class="literal">a</span> plus <span class="literal">b</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">a - b</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Returns the difference of <span class="literal">a</span> minus <span class="literal">b</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">a / b</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Returns the quotient of <span class="literal">a</span> divided by <span class="literal">b</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">a * b</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Returns the product of <span class="literal">a</span> times <span class="literal">b</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">+a</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Returns the signed representation of <span class="literal">a</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">-a</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Returns <span class="literal">a*-1</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">!a</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Returns <span class="literal">1</span> if <span class="literal">a</span> is <span class="literal">0</span>, else returns <span class="literal">0</span>.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indentb">For strings, on the other hand, the only available operators are <span class="literal">==</span> and <span class="literal">!=</span>, which both adhere to the following set of rules:</p>&#13;
<p class="bull">• String comparisons are case insensitive.</p>&#13;
<p class="bull">• If only one of the operands is a string literal, the comparison will terminate after it reaches the length of the literal. As a result, the expression <span class="literal">[STRING EAX]=="ABC123"</span>, where <span class="literal">EAX</span> is a pointer to the string <span class="literal">ABC123XYZ</span>, will evaluate to <span class="literal">1</span> instead of <span class="literal">0</span>.</p>&#13;
<p class="bull">• If no type is specified for an operand in a string comparison and the other operand is a string literal (for example, <span class="literal">"MyString"!=EAX</span>), the comparison will first assume the nonliteral operand is an ASCII string, and, if that compare would return <span class="literal">0</span>, it will try a second compare assuming the operand is a Unicode string.</p>&#13;
<p class="indentt">Of course, operators aren’t much use without operands. Let’s look at some of the data you can evaluate in expressions.</p>&#13;
<h4 class="h4" id="ch00lev1sec42"><strong><em>Working with Basic Expression Elements</em></strong></h4>&#13;
<p class="noindentb">Expressions are able to evaluate many different elements, including:</p>&#13;
<p class="noindenth"><strong>CPU registers</strong> <span class="literal">EAX</span>, <span class="literal">EBX</span>, <span class="literal">ECX</span>, <span class="literal">EDX</span>, <span class="literal">ESP</span>, <span class="literal">EBP</span>, <span class="literal">ESI</span>, and <span class="literal">EDI</span>. You can also use the 1-byte and 2-byte registers (for example, <span class="literal">AL</span> for the low byte and <span class="literal">AX</span> for the low word of <span class="literal">EAX</span>). <span class="literal">EIP</span> can also be used.</p>&#13;
<p class="noindenth"><strong>Segment registers</strong> <span class="literal">CS</span>, <span class="literal">DS</span>, <span class="literal">ES</span>, <span class="literal">SS</span>, <span class="literal">FS</span>, and <span class="literal">GS</span>.</p>&#13;
<p class="noindenth"><strong>FPU registers</strong> <span class="literal">ST0</span>, <span class="literal">ST1</span>, <span class="literal">ST2</span>, <span class="literal">ST3</span>, <span class="literal">ST4</span>, <span class="literal">ST5</span>, <span class="literal">ST6</span>, and <span class="literal">ST7</span>.</p>&#13;
<p class="noindenth"><strong>Simple labels</strong> Can be API function names, such as <span class="literal">GetModuleHandle</span>, or user-defined labels.</p>&#13;
<p class="noindenth"><strong>Windows constants</strong> Such as <span class="literal">ERROR_SUCCESS</span>.</p>&#13;
<p class="noindenth"><strong>Integers</strong> Are written in hexadecimal format or decimal format if followed by a trailing decimal point (for example, <span class="literal">FFFF</span> or <span class="literal">65535</span>.).</p>&#13;
<p class="noindenth"><strong>Floating-point numbers</strong> Allow exponents in decimal format (for example, <span class="literal">654.123e-5</span>).</p>&#13;
<p class="noindenth"><strong>String literals</strong> Are wrapped in quotation marks (for example, <span class="literal">"my string"</span>).</p>&#13;
<p class="indentt"><span epub:type="pagebreak" id="page_36"/>The expressions engine looks for these elements in the order they’re listed here. For example, if you have a label that matches the name of a Windows constant, the engine uses the address of the label instead of the constant’s value. But if you have a label named after a register, such as EAX, the engine uses the register value, not the label value.</p>&#13;
<h4 class="h4" id="ch00lev1sec43"><strong><em>Accessing Memory Contents with Expressions</em></strong></h4>&#13;
<p class="noindent">OllyDbg expressions are also powerful enough to incorporate memory reading, which you can do by wrapping a memory address, or an expression that evaluates to one, in square brackets. For example, <span class="literal">[EAX+C]</span> and <span class="literal">[401000]</span> represent the contents at the addresses EAX+C and 401000. To read the memory as a type other than <span class="literal">DWORD</span>, you can specify the desired type either before the brackets, as in <span class="literal">BYTE [EAX]</span>, or as the first token within them, as in <span class="literal">[STRING ESP+C]</span>. Supported types are listed in <a href="ch02.xhtml#ch2tab5">Table 2-5</a>.</p>&#13;
<p class="tablecap"><a id="ch2tab5"/><strong>Table 2-5:</strong> OllyDbg Data Types</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Data type</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Interpretation</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">BYTE</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">8-bit integer (unsigned)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">CHAR</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">8-bit integer (signed)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">WORD</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">16-bit integer (unsigned)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">SHORT</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">16-bit integer (signed)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">DWORD</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">32-bit integer (unsigned)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">LONG</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">32-bit integer (signed)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">FLOAT</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">32-bit floating-point number</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">DOUBLE</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">64-bit floating-point number</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">STRING</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Pointer to an ASCII string (null-terminated)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">UNICODE</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Pointer to a Unicode string (null-terminated)</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Plugging memory contents directly into your OllyDbg expressions is incredibly useful in game hacking, in part because you can tell the debugger to check a character’s health, name, gold, and so on in memory before breaking. You’ll see an example of this in “<a href="ch02.xhtml#ch00lev1sec45">Pausing Execution When a Specific Player’s Name Is Printed</a>” on <a href="ch02.xhtml#page_37">page 37</a>.</p>&#13;
<h3 class="h3" id="ch00lev1sec44"><strong>OllyDbg Expressions in Action</strong></h3>&#13;
<p class="noindent">Expressions in OllyDbg use a syntax similar to that of most programming languages; you can even combine multiple expressions and nest one expression within another. Game hackers (really, all hackers) commonly use them to create conditional breakpoints, as I described in “<a href="ch02.xhtml#ch00lev1sec40">Using Expressions in Breakpoints</a>” on <a href="ch02.xhtml#page_34">page 34</a>, but you can use them in many different places in OllyDbg. For instance, OllyDbg’s command line plug-in can evaluate <span epub:type="pagebreak" id="page_37"/>expressions in place and display their results, allowing you to easily read arbitrary memory, inspect values that are being calculated by assembly code, or quickly get the results of mathematical equations. Furthermore, hackers can even create intelligent, position-agnostic breakpoints by coupling expressions with the trace feature.</p>&#13;
<p class="indent">In this section, I’ll share some anecdotes where the expression engine has come in handy during my work. I will explain my thought process, walk through my entire debugging session, and break each expression down into its component parts so you can see some ways to use OllyDbg expressions in game hacking.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>These examples contain some assembly code, but if you don’t have much experience with assembly, don’t worry. Just ignore the fine details and know that values like</em> <span class="literal"><span class="codeitalic">ECX</span></span>, <span class="literal"><span class="codeitalic">EAX</span></span><em>, and</em> <span class="literal"><span class="codeitalic">ESP</span></span> <em>are process registers like the ones discussed in “<a href="ch02.xhtml#ch00lev1sec34">Viewing and Editing Register Contents</a>” on <a href="ch02.xhtml#page_29">page 29</a>. From there, I’ll explain everything else.</em></p>&#13;
</div>&#13;
<p class="indent">If you get confused about an operator, element, or data type in an expression as I walk through these anecdotes, just refer to “<a href="ch02.xhtml#ch00lev1sec39">OllyDbg’s Expression Engine</a>” on <a href="ch02.xhtml#page_33">page 33</a>.</p>&#13;
<h4 class="h4" id="ch00lev1sec45"><strong><em>Pausing Execution When a Specific Player’s Name Is Printed</em></strong></h4>&#13;
<p class="noindent">During one particular debugging session, I needed to figure out exactly what was happening when a game was drawing the names of players on screen. Specifically, I needed to invoke a breakpoint before the game drew the name “Player 1,” ignoring all other names that were drawn.</p>&#13;
<h5 class="h5" id="ch00lev1sec46"><strong>Figuring Out Where to Pause</strong></h5>&#13;
<p class="noindent">As a starting point, I used Cheat Engine to find the address of Player 1’s name in memory. Once I had the address, I used OllyDbg to set a memory breakpoint on the first byte of the string. Every time this breakpoint got hit, I quickly inspected the assembly code to determine how it was using Player 1’s name. Eventually, I found the name being accessed directly above a call to a function that I had previously given the name <span class="literal">printText()</span>. I had found the code that was drawing the name.</p>&#13;
<p class="indent">I removed my memory breakpoint and replaced it with a code breakpoint on the call to <span class="literal">printText()</span>. There was a problem, however: because the call to <span class="literal">printText()</span> was inside a loop that iterated over every player in the game, my new breakpoint was getting hit every time a name was drawn—and that was much too often. I needed to fix it to hit only on a specific player.</p>&#13;
<p class="indent">Inspecting the assembly code at my previous memory breakpoint told me that each player’s name was accessed using the following assembly code:</p>&#13;
<p class="programs">PUSH DWORD PTR DS:[EAX+ECX*90+50]</p>&#13;
<p class="indent">The <span class="literal">EAX</span> register contained the address of an array of player data; I’ll call it <span class="literal">playerStruct</span>. The size of <span class="literal">playerStruct</span> was 0x90 bytes, the <span class="literal">ECX</span> register contained the iteration index (the famous variable <span class="literal">i</span>), and each player’s <span epub:type="pagebreak" id="page_38"/>name was stored 0x50 bytes after the start of its respective <span class="literal">playerStruct</span>. This meant that this <span class="literal">PUSH</span> instruction essentially put <span class="literal">EAX[ECX].name</span> (the name of the player at index <span class="literal">i</span>) on the stack to be passed as an argument to the <span class="literal">printText()</span> function call. The loop, then, broke down to something like the following psuedocode:</p>&#13;
<p class="programs">playerStruct EAX[MAX_PLAYERS]; // this is filled elsewhere<br/>for (int <span class="ent">➊</span>ECX = 0; ECX &lt; MAX_PLAYERS; ECX++) {<br/>    char* name = <span class="ent">➋</span>EAX[ECX].name;<br/>    breakpoint(); // my code breakpoint was basically right here<br/>    printText(name);<br/>}</p>&#13;
<p class="indent">Purely through analysis, I determined that the <span class="literal">playerStruct()</span> function contained data for all players, and the loop iterated over the total number of players (counting up with <span class="literal">ECX</span> <span class="ent">➊</span>), fetched the character name <span class="ent">➋</span> for each index, and printed the name.</p>&#13;
<h5 class="h5" id="ch00lev1sec47"><strong>Crafting the Conditional Breakpoint</strong></h5>&#13;
<p class="noindent">Knowing that, to pause execution only when printing “Player 1” all I had to do was check the current player name before executing my breakpoint. In pseudocode, the new breakpoint would look like this:</p>&#13;
<p class="programs">if (EAX[ECX].name == "Player 1") breakpoint();</p>&#13;
<p class="indent">Once I figured out the form of my new breakpoint, I needed to access <span class="literal">EAX[ECX].name</span> from within the loop. That’s where OllyDbg’s expression engine came in: I could achieve my goal by making slight modifications to the expression that the assembly code used, leaving me with this expression:</p>&#13;
<p class="programs">[STRING EAX + ECX*0x90 + 0x50] == "Player 1"</p>&#13;
<p class="indent">I removed the code breakpoint on <span class="literal">printText()</span> and replaced it with a conditional breakpoint that used this expression, which told OllyDbg to break only if the string value stored at <span class="literal">EAX + ECX*0x90 + 0x50</span> matched Player 1’s name. This breakpoint hit only when <span class="literal">"Player 1"</span> was being drawn, allowing me to continue my analysis.</p>&#13;
<p class="indent">The amount of work it took to engineer this breakpoint might seem extensive, but with practice, the entire process becomes as intuitive as writing code. Experienced hackers can do this in a matter of seconds.</p>&#13;
<p class="indent">In practice, this breakpoint enabled me to inspect certain values in the <span class="literal">playerStruct()</span> function for <span class="literal">"Player 1"</span> as soon as he appeared on screen. Doing it this way was important, as the states of these values were relevant to my analysis only in the first few frames after the player entered the screen. Creatively using breakpoints like this can enable you to analyze all sorts of complex game behavior.</p>&#13;
<h4 class="h4" id="ch00lev1sec48"><span epub:type="pagebreak" id="page_39"/><strong><em>Pausing Execution When Your Character’s Health Drops</em></strong></h4>&#13;
<p class="noindentb">During another debugging session, I needed to find the first function called after my character’s health dropped below the maximum. I knew two ways to approach this problem:</p>&#13;
<p class="bull">• Find every piece of code that accesses the health value and place a conditional breakpoint that checks the health on each one. Then, once one of these breakpoints is hit, single-step through the code until the next function call.</p>&#13;
<p class="bull">• Use OllyDbg’s trace function to create a dynamic breakpoint that can stop exactly where I need.</p>&#13;
<p class="indentt">The first method required more setup and was not easily repeatable, mostly due to the sheer number of breakpoints needed and the fact that I’d have to single-step by hand. In contrast, the latter method had a quick setup, and since it did everything automatically, it was easily repeatable. Though using the trace function would slow the game down considerably (every single operation was captured by the trace), I chose the latter method.</p>&#13;
<h5 class="h5" id="ch00lev1sec49"><strong>Writing an Expression to Check Health</strong></h5>&#13;
<p class="noindent">Once again, I started by using Cheat Engine to find the address that stored my health. Using the method described in “<a href="ch01.xhtml#ch00lev1sec9">Cheat Engine’s Memory Scanner</a>” on <a href="ch01.xhtml#page_5">page 5</a>, I determined the address to be 0x40A000.</p>&#13;
<p class="indent">Next, I needed an expression that told OllyDbg to return <span class="literal">1</span> when my health was below maximum and return <span class="literal">0</span> otherwise. Knowing that my health was stored at 0x40A000 and that the maximum value was <span class="literal">500</span>, I initially devised this expression:</p>&#13;
<p class="programs">[0x40A000] &lt; 500.</p>&#13;
<p class="indent">This expression would invoke a break when my health was below 500 (remember, decimal numbers must be suffixed with a period in the expression engine), but instead of waiting for a function to be called, the break would happen immediately. To ensure that it waited until a function was called, I appended another expression with the <span class="literal">&amp;&amp;</span> operator:</p>&#13;
<p class="programs">[0x40A000] &lt; 500. &amp;&amp; [<span class="ent">➊</span>BYTE EIP] == 0xE8</p>&#13;
<p class="indent">On x86 processors, the EIP register stores the address of the operation being executed, so I decided to check the first byte at <span class="literal">EIP</span> <span class="ent">➊</span> to see if it was equal to <span class="literal">0xE8</span>. This value tells the processor to execute a <em>near function call</em>, which is the type of call I was looking for.</p>&#13;
<p class="indent">Before starting my trace, I had to do one last thing. Because the trace feature repeatedly single-steps (Trace into uses step into and Trace over <span epub:type="pagebreak" id="page_40"/>uses step over, as described in “<a href="ch02.xhtml#ch00lev1sec31">A Brief Look at OllyDbg’s User Interface</a>” on <a href="ch02.xhtml#page_24">page 24</a>), I needed to start the trace at a location scoped at or above the level of any code that could possibly update the health value.</p>&#13;
<h5 class="h5" id="ch00lev1sec50"><strong>Figuring Out Where to Start the Trace</strong></h5>&#13;
<p class="noindent">To find a good location, I opened the game’s main module in OllyDbg’s CPU window, right-clicked in the disassembler pane, and selected Search for <span class="ent">▸</span> All intermodular calls. The References window popped up and displayed a list of external API functions that were called by the game. Nearly all gaming software polls for new messages using the Windows <span class="literal">USER32.PeekMessage()</span> function, so I sorted the list using the Destination column and typed <span class="literal">PEEK</span> (you can search the list by simply typing a name with the window in focus) to locate the first call to <span class="literal">USER32.PeekMessage()</span>.</p>&#13;
<p class="indent">Thanks to the Destination sorting, every call to this function was listed in a contiguous chunk following the first, as shown in <a href="ch02.xhtml#ch2fig5">Figure 2-5</a>. I set a breakpoint on each by selecting it and pressing F2.</p>&#13;
<div class="image"><img src="../images/f02-05.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch2fig5"/><em>Figure 2-5: OllyDbg’s Found intermodular calls window</em></p>&#13;
<p class="indent">Though there were around a dozen calls to <span class="literal">USER32.PeekMessage()</span>, only two of them were setting off my breakpoints. Even better, the active calls were beside one another in an unconditional loop. At the bottom of this loop were a number of internal function calls. This looked exactly like a main game loop.</p>&#13;
<h5 class="h5" id="ch00lev1sec51"><strong>Activating the Trace</strong></h5>&#13;
<p class="noindent">To finally set my trace, I removed all of my previous breakpoints and placed one at the top of the suspected main loop. I removed the breakpoint as soon as it was hit. I then pressed <small>CTRL</small>-T from the CPU window, which brought up a <span epub:type="pagebreak" id="page_41"/>dialog called Condition to pause run trace, shown in <a href="ch02.xhtml#ch2fig6">Figure 2-6</a>. Within this new dialog, I enabled the Condition is TRUE option, placed my expression in the box beside it, and pressed OK. Then, I went back to the CPU window and pressed <small>CTRL</small>-F11 to begin a Trace Into session.</p>&#13;
<div class="image"><img src="../images/f02-06.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch2fig6"/><em>Figure 2-6: Condition to pause run trace dialog</em></p>&#13;
<p class="indent">Once the trace began, the game ran so slowly it was nearly unplayable. To decrease my test character’s health, I opened a second instance of the game, logged into a different character, and attacked my test character. When the execution of the trace caught up to real time, OllyDbg saw my health change and triggered the breakpoint on the following function call—just as expected.</p>&#13;
<p class="indent">In this game, the main pieces of code that would modify the health value were directly invoked from the network code. Using this trace, I was able to find the function that the network module called directly after a network packet told the game to change the player’s health. Here’s the psuedocode of what the game was doing:</p>&#13;
<p class="programs">   void network::check() {<br/>       while (this-&gt;hasPacket()) {<br/>           packet = this-&gt;getPacket();<br/>           if (packet.type == UPDATE_HEALTH) {<br/>               oldHealth = player-&gt;health;<br/>               player-&gt;health = packet.getInteger();<br/><span class="ent">➊</span>             observe(HEALTH_CHANGE, oldHealth, player-&gt;health);<br/>           }<br/>       }<br/>   }</p>&#13;
<p class="indent">I knew the game had code that needed to execute only when the player’s health was changed, and I needed to add code that could also respond to such changes. Without knowing the overall code structure, I guessed that <span epub:type="pagebreak" id="page_42"/>the health-dependent code would be executed from some function call directly after <span class="literal">health</span> was updated. My trace conditional breakpoint confirmed this hunch, as it broke directly on the <span class="literal">observe()</span> function <span class="ent">➊</span>. From there, I was able to place a <em>hook</em> on the function (<em>hooking</em>, a way to intercept function calls, is described in “<a href="ch08.xhtml#ch00lev1sec151">Hooking to Redirect Game Execution</a>” on <a href="ch08.xhtml#page_153">page 153</a>) and execute my own code when the player’s health changed.</p>&#13;
<h3 class="h3" id="ch00lev1sec52"><strong>OllyDbg Plug-ins for Game Hackers</strong></h3>&#13;
<p class="noindent">OllyDbg’s highly versatile plug-in system is perhaps one of its most powerful features. Experienced game hackers often configure their OllyDbg environments with dozens of useful plug-ins, both publicly available and custom-made.</p>&#13;
<p class="indent">You can download popular plug-ins from the OpenRCE (<em><a href="http://www.openrce.org/downloads/browse/OllyDbg_Plugins">http://www.openrce.org/downloads/browse/OllyDbg_Plugins</a></em>) and tuts4you (<em><a href="http://www.tuts4you.com/download.php?list.9/">http://www.tuts4you.com/download.php?list.9/</a></em>) plug-in repositories. Installing them is easy: just unzip the plug-in files and place them inside OllyDbg’s installation folder.</p>&#13;
<p class="indent">Once installed, some plug-ins can be accessed from the OllyDbg’s Plugin menu item. Other plug-ins, however, might be found only in specific places throughout the OllyDbg interface.</p>&#13;
<p class="indent">You can find hundreds of potent plug-ins using these online repositories, but you should be careful when constructing your arsenal. Working in an environment bloated by unused plug-ins can actually impede productivity. In this section, I’ve carefully selected four plug-ins that I believe are not only integral to a game hacker’s toolkit but also noninvasive to the environment.</p>&#13;
<h4 class="h4" id="ch00lev1sec53"><strong><em>Copying Assembly Code with Asm2Clipboard</em></strong></h4>&#13;
<p class="noindent">Asm2Clipboard is a minimalistic plug-in from the OpenRCE repository that allows you to copy chunks of assembly code from the disassembler pane to the clipboard. This can be useful for updating address offsets and devising code caves, two game-hacking essentials I cover deeply in <a href="ch05.xhtml#ch05">Chapters 5</a> and <a href="ch07.xhtml#ch07">7</a>.</p>&#13;
<p class="indent">With Asm2Clipboard installed, you can highlight a block of assembly code in the disassembler, right-click the highlighted code, expand the Asm2Clipboard submenu, and select either Copy fixed Asm code to clipboard or Copy Asm code to clipboard. The latter prepends the code address of each instruction as a comment, while the former copies only the pure code.</p>&#13;
<h4 class="h4" id="ch00lev1sec54"><strong><em>Adding Cheat Engine to OllyDbg with Cheat Utility</em></strong></h4>&#13;
<p class="noindent">The Cheat Utility plug-in from tuts4you provides a highly slimmed-down version of Cheat Engine within OllyDbg. While Cheat Utility only allows you to do exact-value scans with a very limited number of data types, it can <span epub:type="pagebreak" id="page_43"/>make simple scans much easier when you don’t need the full functionality of Cheat Engine to find what you’re looking for. After installing Cheat Utility, to open its interface (shown in <a href="ch02.xhtml#ch2fig7">Figure 2-7</a>), select <strong>Plugins</strong> <span class="ent">▸</span> <strong>Cheat utility</strong> <span class="ent">▸</span> <strong>Start</strong>.</p>&#13;
<div class="image"><img src="../images/f02-07.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch2fig7"/><em>Figure 2-7: Cheat Utility interface</em></p>&#13;
<p class="indent">Cheat Utility’s user interface and operation mimic Cheat Engine closely, so review <a href="ch01.xhtml#ch01">Chapter 1</a> if you need a refresher.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Games Invader, an updated version of Cheat Utility also from tuts4you, was created to provide more functionality. I’ve found it buggy, however, and I prefer Cheat Utility since I can always use Cheat Engine for advanced scans.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec55"><strong><em>Controlling OllyDbg Through the Command Line</em></strong></h4>&#13;
<p class="noindent">The command line plug-in enables you to control OllyDbg through a small command line interface. To access the plug-in, either press <small>ALT</small>-F1 or select Plugins <span class="ent">▸</span> Command line <span class="ent">▸</span> Command line. You should then see a window, shown in <a href="ch02.xhtml#ch2fig8">Figure 2-8</a>, which acts as the command line interface.</p>&#13;
<div class="image"><img src="../images/f02-08.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch2fig8"/><em>Figure 2-8: Command line interface</em></p>&#13;
<p class="indent">To execute a command, type it into the input box <span class="ent">➊</span> and press <small>ENTER</small>. You will see a session-level command history in the center list <span class="ent">➋</span>, and the bottom label displays the command’s return value <span class="ent">➌</span> (if any).</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_44"/>Though there are many commands available, I find a majority of them useless. I primarily use this tool as a way to test that expressions are parsing as expected and as a handy calculator, but there are a few additional use cases that are also worth mentioning. I’ve described these in <a href="ch02.xhtml#ch2tab6">Table 2-6</a>.</p>&#13;
<p class="tablecap"><a id="ch2tab6"/><strong>Table 2-6:</strong> Command Line Plug-in Commands</p>&#13;
<table class="topbot">&#13;
<thead>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Command</strong></p></td>&#13;
<td style="vertical-align: top;" class="table_th"><p class="table"><strong>Function</strong></p></td>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">BC identifier</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Removes any breakpoints present on <span class="literal">identifier</span>, which can be a code address or API function name.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">BP identifier [,condition]</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Places a debugger breakpoint on <span class="literal">identifier</span>, which can be a code address or API function name. When <span class="literal">identifier</span> is an API function name, the breakpoint will be placed on the function entry point. The <span class="literal">condition</span> parameter is an optional expression that, if present, will be set as the breakpoint condition.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">BPX label</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Places a debugger breakpoint on every instance of <span class="literal">label</span> within the module currently being disassembled. This <span class="literal">label</span> will typically be an API function name.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">CALC expression ? expression</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Evaluates <span class="literal">expression</span> and displays the result.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">HD address</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Removes any hardware breakpoints present on <span class="literal">address</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">HE address</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Places a hardware on-execute breakpoint on <span class="literal">address</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">HR address</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Places a hardware on-access breakpoint on <span class="literal">address</span>. Only four hardware breakpoints can exist at a time.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">HW address</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Places a hardware on-write breakpoint on <span class="literal">address</span>.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MD</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Removes any existing memory breakpoint, if present.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">MR address1, address2</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Places a memory on-access breakpoint starting at <span class="literal">address1</span> and spanning until <span class="literal">address2</span>. Will replace any existing memory breakpoint.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">MW address1, address2</span></p></td>&#13;
<td style="vertical-align: top;" class="table_1"><p class="table">Places a memory on-write breakpoint starting at <span class="literal">address1</span> and spanning until <span class="literal">address2</span>. Will replace any existing memory breakpoint.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table"><p class="table"><span class="literal">WATCH expression W expression</span></p></td>&#13;
<td style="vertical-align: top;" class="table"><p class="table">Opens the Watches window and adds <span class="literal">expression</span> to the watch list. Expressions in this list will be reevaluated every time the process receives a message and the evaluation results will be displayed beside them.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The command line plug-in was made by the OllyDbg developer and should come preinstalled with OllyDbg.</p>&#13;
<h4 class="h4" id="ch00lev1sec56"><span epub:type="pagebreak" id="page_45"/><strong><em>Visualizing Control Flow with OllyFlow</em></strong></h4>&#13;
<p class="noindent">OllyFlow, which can be found in the OpenRCE plug-in directory, is a purely visual plug-in that can generate code graphs like the one in <a href="ch02.xhtml#ch2fig9">Figure 2-9</a> and display them using Wingraph32.</p>&#13;
<div class="image"><img src="../images/f02-09.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch2fig9"/><em>Figure 2-9: An OllyFlow function flowchart</em></p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Wingraph32 is not provided with OllyFlow, but it is available with the free version of IDA here:</em> <a href="https://www.hex-rays.com/products/ida/">https://www.hex-rays.com/products/ida/</a><em>. Download it and drop the</em> .exe <em>in your OllyDbg installation folder.</em></p>&#13;
</div>&#13;
<p class="indentb">Though not interactive, these graphs allow you to easily identify constructs such as loops and nested <span class="literal">if()</span> statements in game code, which can be paramount in control flow analysis. With OllyFlow installed, you can generate a graph by going to Plugins <span class="ent">▸</span> OllyFlow (alternatively, right-click in the disassembler pane and expand the OllyFlow graph submenu) and selecting one of the following options:</p>&#13;
<p class="noindenth"><strong>Generate function flowchart</strong> Generates a graph of the function currently in scope, breaking apart different code blocks and showing jump paths. <a href="ch02.xhtml#ch2fig9">Figure 2-9</a> shows a function flowchart. Without a doubt, this is OllyFlow’s most useful feature.</p>&#13;
<p class="noindenth"><strong>Generate xrefs from graph</strong> Generates a graph of all functions called by the function that is currently in scope.</p>&#13;
<p class="noindenth"><strong>Generate xrefs to graph</strong> Generates a graph of all functions that call the function currently in scope.</p>&#13;
<p class="noindenth"><span epub:type="pagebreak" id="page_46"/><strong>Generate call stack graph</strong> Generates a graph of the assumed call path from the process entry point to the function currently in scope.</p>&#13;
<p class="noindenth"><strong>Generate module graph</strong> Theoretically generates a complete graph of all function calls in the entire module, but rarely actually works.</p>&#13;
<p class="indentt">To get an idea of the usefulness of OllyFlow, take a look at the graph in <a href="ch02.xhtml#ch2fig9">Figure 2-9</a> and compare it to the relatively simple assembly function that generated it:</p>&#13;
<p class="programs">   76f86878:<br/><span class="ent">➊</span>     MOV EAX,DWORD PTR DS:[76FE7E54]<br/>       TEST AL,1<br/>       JE ntdll.76F8689B<br/>   76f86881:<br/><span class="ent">➋</span>     MOV EAX,DWORD PTR FS:[18]<br/>       MOV EAX,DWORD PTR DS:[EAX+30]<br/>       OR DWORD PTR DS:[EAX+68],2000000<br/>       MOV EAX,DWORD PTR DS:[76FE66E0]<br/>       OR DWORD PTR DS:[EAX],1<br/>       JMP ntdll.76F868B2<br/>   76f8689b:<br/><span class="ent">➌</span>     TEST EAX,8000<br/>       JE ntdll.76F868B2<br/>   76f868a2:<br/><span class="ent">➍</span>     MOV EAX,DWORD PTR FS:[18]<br/>       MOV EAX,DWORD PTR DS:[EAX+30]<br/>       OR DWORD PTR DS:[EAX+68],2000000<br/>   76f868b2:<br/><span class="ent">➎</span>     MOV AL,1<br/>       RETN</p>&#13;
<p class="indent">There are five boxes in <a href="ch02.xhtml#ch2fig9">Figure 2-9</a>, and they map to the five pieces of this function. The function starts with <span class="ent">➊</span>, and it falls through to <span class="ent">➋</span> if the branch fails or jumps to <span class="ent">➌</span> if it succeeds. After <span class="ent">➋</span> executes, it jumps directly to piece <span class="ent">➎</span>, which then returns out of the function. After <span class="ent">➌</span> executes, it either falls through to <span class="ent">➍</span> or branches to <span class="ent">➎</span> to return directly. After <span class="ent">➍</span> executes, it unconditionally falls through to <span class="ent">➎</span>. What this function does is irrelevant to understanding OllyFlow; for now, just focus on seeing how the code maps to the graph.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart" id="ch02sb01"><strong>PATCHING AN IF( ) STATEMENT</strong></p>&#13;
<p class="noindent">If you think you’re ready to get your hands dirty with OllyDbg, keep reading. Go to <em><a href="https://www.nostarch.com/gamehacking/">https://www.nostarch.com/gamehacking/</a></em>, download the book’s resource files, grab <em>BasicDebugging.exe</em>, and execute it. At first glance, you’ll see that it looks like the classic game Pong. In this version of Pong, the ball is invisible to you when it is on your opponent’s screen. Your task is to disable this feature so that you can always see the ball. To make it easier for you, I’ve made the game autonomous. You don’t have to play, only hack.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_47"/>To start, attach OllyDbg to the game. Then focus the CPU window on the main module (find the <em>.exe</em> in the module list and double-click it) and use the Referenced text strings feature to locate the string that is displayed when the ball is hidden. Next, double-click the string to bring it up in the code and analyze the surrounding code until you find the <span class="literal">if()</span> statement that determines whether to hide the ball. Lastly, using the code-patching feature, patch the <span class="literal">if()</span> statement so the ball is always drawn. As an added bonus, you might try using OllyFlow to graph this function so you can get a better understanding of what exactly it is doing. (Hint: The <span class="literal">if()</span> statement checks whether the ball’s x-coordinate is less than 0x140. If so, it jumps to code that draws the ball. If not, it draws the scene without the ball. If you can change 0x140 to, say, 0xFFFF, the ball will never get hidden.)</p>&#13;
</div>&#13;
<h3 class="h3" id="ch00lev1sec57"><strong>Closing Thoughts</strong></h3>&#13;
<p class="noindent">OllyDbg is a much more complex beast than Cheat Engine, but you’ll learn best by using it, so dive in and get your hands dirty! You can start by pairing the controls taught in this chapter with your debugging skills and going to work on some real games. If you are not yet ready to tamper with your virtual fate, however, try tackling the example in “<a href="ch02.xhtml#ch02sb01">Patching an <span class="literal">if()</span> Statement</a>” for a practice environment. When you’re done, read on to <a href="ch03.xhtml#ch03">Chapter 3</a>, where I’ll introduce you to Process Monitor and Process Explorer, two tools you’ll find invaluable in game-hacking reconnaissance.<span epub:type="pagebreak" id="page_48"/></p>&#13;
</body></html>