<html><head></head><body>
<div class="imagec"><span epub:type="pagebreak" id="page_131"/><img alt="Image" src="../images/common1.jpg"/></div>
<h2 class="h2" id="ch06"><strong>6</strong><br/><strong>MAD MOVEMENT</strong></h2>
<p class="noindent">In this chapter, you’ll use a few different types of motors to make two of the most impressive projects in this book: an animatronic head that swivels its eyes and talks and a robotic, remote-controlled rover. These toys can amuse the Mad Scientist for hours.</p>
<h3 class="h3" id="ch00lev1sec155"><span epub:type="pagebreak" id="page_132"/><strong>EXPERIMENT 8: MAKING A SERVOMOTOR MOVE</strong></h3>
<div class="image"><img alt="Image" src="../images/common2.jpg"/></div>
<p class="noindent">One way to get things moving is to use a servomotor, like the one shown in <a href="ch06.xhtml#ch6fig1">Figure 6-1</a>.</p>
<div class="image" id="ch6fig1"><img alt="Image" src="../images/06fig01.jpg"/></div>
<p class="figcap"><em>Figure 6-1: A servomotor connected to a micro:bit</em></p>
<p class="indent">A <em>servomotor</em> is a small, low-powered motor with an arm you can control with your program. Unlike most other motors, servomotors don’t rotate all the way around. Instead, they have a 180-degree range of motion. Your program can set the position of the motor arm to a particular angle.</p>
<p class="indent">In this experiment, you’ll learn how to connect a servomotor to a micro:bit and investigate how the servomotor moves.</p>
<div class="imagec"><img alt="Image" src="../images/f0132-01.jpg"/></div>
<h4 class="h4" id="ch00lev1sec156"><span epub:type="pagebreak" id="page_133"/><strong>What You’ll Need</strong></h4>
<p class="noindentint"><strong><span class="blue">Micro:bit</span></strong></p>
<p class="noindentin"><strong><span class="blue">Servomotor</span></strong> A 9-g servomotor is ideal. A micro:bit has just enough power to drive a small servomotor but would struggle with a full-size one. Choose a servomotor that is 3V compatible. See the <a href="app01.xhtml">appendix</a> for more details.</p>
<p class="noindentin"><strong><span class="blue">Alligator clip-to-male jumper cables</span></strong> These connect the micro:bit to the servomotor. (You can also use male-to-male jumper cables; see below.)</p>
<p class="noindentinb"><strong><span class="blue">USB connection to a computer, Monk Makes Power for micro:bit or USB battery pack</span></strong> An AAA battery box may (depending on the servo) work, but AAA batteries may not provide enough voltage for the servomotor. See the <a href="app01.xhtml">appendix</a> for options for powering your micro:bit.</p>
<p class="indent">Instead of using the alligator clip-to-male jumper cables, you could use the more common male-to-male jumper cables by pushing one end of the cable into the servomotor connector and clipping an alligator cable to the other end. However, you would need to make sure the connections don’t accidentally short out. In general, alligator clip-to-male jumper cables will be a useful thing to have in your micro:bit toolbox, so it’s worth getting some.</p>
<h4 class="h4" id="ch00lev1sec157"><strong>Construction</strong></h4>
<p class="noindent">Connect the servomotor to your micro:bit.</p>
<ol>
<li class="noindent">Go to <em><a href="https://github.com/simonmonk/mbms/">https://github.com/simonmonk/mbms/</a></em> to access the book’s code repository and click the link for <strong>Experiment 8: Servomotors</strong>. Once the program has opened, click <strong>Download</strong> and then copy the hex file onto your micro:bit. If you get stuck on this, head back to <a href="ch01.xhtml#ch01">Chapter 1</a>.
<p class="indent">If you prefer to use Python, you’ll find the code for this at the same website. For instructions for downloading and using the book’s examples, see “Downloading the Code” on <a href="ch01.xhtml#page_34">page 34</a>. The Python file for this experiment is <em>Experiment_08.py</em>.</p></li>
<li class="noindent">Servomotors come with different kinds of arms that can be attached to the cog-like shaft of the motor. For <span epub:type="pagebreak" id="page_134"/>this project, select a simple arm like the one shown in <a href="ch06.xhtml#ch6fig1">Figure 6-1</a>.
<div class="note">
<p class="notep"><span class="yellow"><strong>NOTE</strong></span> <em>Your servomotor should come with a little screw. This is intended to fix the arm more permanently to the shaft. If you’re planning to do the animatronic head project, keep the screw nearby; otherwise, put it in a safe place for later use.</em></p>
</div></li>
<li class="noindent">Connect your micro:bit to the servomotor using the alligator clip, as shown in <a href="ch06.xhtml#ch6fig2">Figure 6-2</a>.
<div class="image" id="ch6fig2"><img alt="Image" src="../images/06fig02.jpg"/></div>
<p class="figcap"><em>Figure 6-2: A servomotor connected to a micro:bit</em></p></li>
<li class="noindent">The servomotor has three connections, which are color-coded:
<p class="noindentint"><strong><span class="blue">Control</span></strong> Orange or yellow (This pin controls the position of the servomotor’s arm.)</p>
<p class="noindentin"><strong><span class="blue">+V</span></strong> The red wire is the positive power wire. Servomotors ideally use 5V, but most small servomotors will also work with the 3V of a micro:bit.</p>
<p class="noindentinb"><strong><span class="blue">GND</span></strong> Usually brown, sometimes black (This is the negative power wire.)</p></li>
<li class="noindent">Once powered up, the servomotor arm should jump to a 90-degree position, perpendicular to the servomotor. The micro:bit will use this position as a reference point. If the arm isn’t at 90 degrees, take it off and put it back on so that it is, as shown in <a href="ch06.xhtml#ch6fig1">Figure 6-1</a>. If you plan to make the animatronic head, use the small screw to fix the arm in place.</li>
<li class="noindent"><span epub:type="pagebreak" id="page_135"/>You now have a functioning servomotor! Pressing button A should move the servo arm 10 degrees in one direction. Pressing button B should move the servo arm 10 degrees in the other direction. If you press both buttons together, the current angle of the arm should scroll across the micro:bit’s display.</li>
</ol>
<h4 class="h4" id="ch00lev1sec158"><strong>Code</strong></h4>
<p class="noindent">Both programs follow the same approach of first setting the servomotor’s angle to 90 degrees and then waiting for button presses to increase the angle, decrease it, or display it.</p>
<h5 class="h5" id="ch00lev1sec159"><strong>Blocks Code</strong></h5>
<p class="noindent">Here is the Blocks code for this experiment.</p>
<div class="image"><img alt="Image" src="../images/f0135-01.jpg"/></div>
<p class="indent"><span epub:type="pagebreak" id="page_136"/>We use a variable called <span class="literal">angle</span> to remember the current angle of the servomotor. We define the <span class="literal">angle</span> variable in the <span class="literal">on start</span> block and give it an initial value of 90. When the next servo <span class="literal">write pin</span> block runs, it moves the servo arm to the position set in <span class="literal">angle</span> so that the arm jumps to a 90-degree angle on power-up.</p>
<p class="indent">If you press button A, the <span class="literal">on button A pressed</span> block is called. If you press button B, <span class="literal">on button B pressed</span> is called. The buttons work in a similar way. The block for button A first checks whether the angle is still greater than or equal to 10 and, if so, subtracts 10 from the angle to move the arm in one direction. The block for Button B checks whether the angle is less than or equal to 170 and, if it is, adds 10 to the angle and moves the arm in the opposite direction. Both use the <span class="literal">servo write pin</span> to set the servo to the new angle as a result of the buttons being pressed.</p>
<h5 class="h5" id="ch00lev1sec160"><strong>MicroPython Code</strong></h5>
<p class="noindent">Here is the MicroPython version of the code.</p>
<div class="programs1"><span class="green">from</span> microbit <span class="green">import</span> <span class="purple">*</span><br/><br/><span class="green">def</span> <span class="blue1">set_servo_angle</span><span class="purple">(</span>pin<span class="purple">,</span> angle<span class="purple">):</span><br/>    duty <span class="purple">=</span> <span class="blue1">26</span> <span class="purple">+</span> <span class="purple">(</span>angle <span class="purple">*</span> <span class="blue1">51</span><span class="purple">)</span> <span class="purple">/</span> <span class="blue1">90</span><br/>    pin<span class="purple">.</span>write_analog<span class="purple">(</span>duty<span class="purple">)</span><br/><br/>angle <span class="purple">=</span> <span class="blue1">90</span><br/>set_servo_angle<span class="purple">(</span>pin2<span class="purple">,</span> angle<span class="purple">)</span><br/><br/><span class="green">while True</span><span class="purple">:</span><br/>    <span class="green">if</span> button_a<span class="purple">.</span>was_pressed<span class="purple">()</span> <span class="green">and</span> angle <span class="purple">&gt;=</span> <span class="blue1">10</span><span class="purple">:</span><br/>        angle <span class="purple">-=</span> <span class="blue1">10</span><br/>        set_servo_angle<span class="purple">(</span>pin2<span class="purple">,</span> angle<span class="purple">)</span><br/>    <span class="green">if</span> button_b<span class="purple">.</span>was_pressed<span class="purple">()</span> <span class="green">and</span> angle <span class="purple">&lt;=</span> <span class="blue1">170</span><span class="purple">:</span><br/>        angle <span class="purple">+=</span> <span class="blue1">10</span><br/>        set_servo_angle<span class="purple">(</span>pin2<span class="purple">,</span> angle<span class="purple">)</span><br/><br/><span class="green">if</span> button_a<span class="purple">.</span>is_pressed<span class="purple">()</span> <span class="green">and</span> button_b<span class="purple">.</span>is_pressed<span class="purple">():</span><br/>    display<span class="purple">.</span>scroll<span class="purple">(</span><span class="blue1">str</span><span class="purple">(</span>angle<span class="purple">))</span></div>
<p class="indent">The MicroPython code works in much the same way as the Blocks code. But unlike in the Blocks code, there is no predefined function to set the servomotor to a particular angle. Fortunately, we can write our own method using a little math and PWM analog outputs (see “Making an Analog Signal: Pulse Width Modulation” <span epub:type="pagebreak" id="page_137"/>on <a href="ch01.xhtml#page_8">page 8</a>), which generate the pulses that our servomotor expects (more on this next).</p>
<h4 class="h4" id="ch00lev1sec161"><strong>How It Works: Servomotors and Pulses</strong></h4>
<p class="noindent">You control servomotors by sending them a series of repeating electrical pulses—in this case, from the micro:bit. The pulses are generated by turning a pin on and off very quickly. The servomotor knows how to act based on how long the pulse has been high (3V) over a certain time period. The proportion of time that the signal is high, and thus the pin is on, is known as the <em>duty cycle</em>. This is different from the actual amount of time that the signal is high, which is known as the <em>pulse width</em>. We refer to this amount of time, measured in milliseconds (ms), as a <em>width</em> because we can visualize pulses as a square wave (see <a href="ch06.xhtml#ch6fig3">Figure 6-3</a>). The total length of the wave (between each <em>on</em> pulse) is the <em>period</em>.</p>
<div class="image" id="ch6fig3"><img alt="Image" src="../images/06fig03.jpg"/></div>
<p class="figcap"><em>Figure 6-3: Pulses controlling a servomotor</em></p>
<p class="indent">A servomotor expects to receive a pulse every 20 milliseconds, or at a rate of 50 pulses a second. Each pulse has a width between 0.5 milliseconds and 2.5 milliseconds.</p>
<p class="indent">As you can see in <a href="ch06.xhtml#ch6fig3">Figure 6-3</a>, the length of the pulse determines the position of the arm. If the pulse width is 0.5 ms, the <span epub:type="pagebreak" id="page_138"/>servomotor’s arm will be at one end of its range (0 degrees). If the pulse width is 1.5 ms, the arm will be at its center position (90 degrees). And if the width is 2.5 ms, the arm will be at 180 degrees.</p>
<p class="indent">Conveniently, the micro:bit’s default frequency for analog output (see <a href="ch01.xhtml#ch01">Chapter 1</a>) is 50Hz—exactly the right frequency for a servomotor. However, even the longest pulse is only 2.5 ms out of a total period of 20 ms, meaning that the longest pulse will only be high about one-tenth of the time.</p>
<p class="indent"><a href="ch06.xhtml#ch6fig4">Figure 6-4</a> helps to explain how the numbers used in the MicroPython <span class="literal">set_servo_angle</span> function were calculated. The <em>duty value</em> is the number supplied to the <span class="literal">set_servo_angle</span> function. This value must be between 0 and 1023, where 0 is no pulse at all and 1023 is a pulse so long that it lasts until the next cycle.</p>
<div class="image" id="ch6fig4"><img alt="Image" src="../images/06fig04.jpg"/></div>
<p class="figcap"><em>Figure 6-4: Correspondence of duty values to pulse widths to servo arm angles</em></p>
<p class="indent">The top line of <a href="ch06.xhtml#ch6fig4">Figure 6-4</a> shows the servo arm’s range of positions in terms of angles from 0 to 180 degrees. The code must convert this into a different range of numbers, from 0.5 to 2.5, that are the pulse widths corresponding to those angles.</p>
<p class="indent">To convert an angle in degrees to a pulse width in milliseconds, we’ll start with the information that a pulse of length 0.5 ms is equal to an angle of 0 degrees and a pulse of length 2.5 ms is equal to an angle of 180 degrees. We can then find the degrees per millisecond by dividing the range of degrees (180) by the range of pulse lengths (2), giving 90 degrees per millisecond. Then, to calculate the pulse length of a new angle, we begin with our baseline, 0.5 ms and add the angle we are using divided by 90, the degrees per millisecond.</p>
<p class="indent"><span epub:type="pagebreak" id="page_139"/>Let’s consider an example. If the angle is 0 degrees, the pulse length in milliseconds will be 0.5 (0.5 + 0/90 = 0.5). If the angle is 90 degrees, the pulse length will be 0.5 + (90/90) = 1.5 ms. And if the angle is 180 degrees, the pulse length will be 0.5 + (180/90) = 2.5 ms.</p>
<p class="indent">Now we have a formula for the pulse length for an angle:</p>
<p class="center"><span class="literal">pulse_length</span> = 0.5 + <span class="literal">angle</span>/90</p>
<p class="indent">But, referring to <a href="ch06.xhtml#ch6fig5">Figure 6-5</a> again, we need to convert the pulse length in milliseconds to a duty value between 0 and 1023 because the <span class="literal">set_servo_angle</span> function expects a value in that range.</p>
<p class="indent">The duty value (0 to 1023) is calculated by multiplying the pulse length in milliseconds by the number of steps per millisecond (1023/20 ≈ 51). For example, a pulse length of 1.5 milliseconds would require a duty value of 1.5 × 51 ≈ 77.</p>
<p class="indent">In other words:</p>
<p class="center"><span class="literal">duty_value</span> = <span class="literal">pulse_length</span> × 51</p>
<p class="indent">Combining these two formulas, we have:</p>
<p class="center"><span class="literal">duty_value</span> = (0.5 + <span class="literal">angle</span>/90) × 51</p>
<p class="indent">This can also be written as (with rounding):</p>
<p class="center"><span class="literal">duty_value</span> = 26 + <span class="literal">angle</span> × 51/90</p>
<p class="indent">So the values used in the <span class="literal">write_analog</span> function are between 26 and 128. This range reflects the fact that the pulses are quite short in comparison to the maximum duty cycle value of 1023.</p>
<h3 class="h3" id="ch00lev1sec162"><strong>PROJECT: ANIMATRONIC HEAD (MIKE THE MICRO:BIT ROBOT)</strong></h3>
<div class="image"><img alt="Image" src="../images/common3.jpg"/></div>
<p class="difficulty"><em>Difficulty: Hard</em></p>
<p class="noindent">This animatronic head, shown in <a href="ch06.xhtml#ch6fig5">Figure 6-5</a>, makes a great project for a Halloween display. A servomotor moves a pair of ping-pong ball eyes from left to right, and it uses the micro:bit’s display as a mouth. When the head talks, the lights simulate a simple animation of lips moving.</p>
<div class="image" id="ch6fig5"><span epub:type="pagebreak" id="page_140"/><img alt="Image" src="../images/06fig05.jpg"/></div>
<p class="figcap"><em>Figure 6-5: The animatronic head</em></p>
<h4 class="h4" id="ch00lev1sec163"><strong>What You’ll Need</strong></h4>
<p class="noindent">For this project, you’ll need the following items:</p>
<p class="noindentint"><strong><span class="blue">Micro:bit</span></strong></p>
<p class="noindentin"><strong><span class="blue">Servomotor</span></strong> A small 9g servomotor is ideal.</p>
<p class="noindentin"><strong><span class="blue">Amplified speaker</span></strong> For the head’s voice (Monk Makes Speaker for micro:bit is a good choice.)</p>
<p class="noindentin"><strong><span class="blue">3 × Alligator clip-to-male jumper cables</span></strong> To attach the servomotor</p>
<p class="noindentin"><strong><span class="blue">3 × Alligator clip cables</span></strong> To attach the speaker</p>
<p class="noindentin"><strong><span class="blue">2 × Ping-pong balls</span></strong> For the eyeballs (Balls without any writing or logos on them make decoration easier. Grab a couple of spares, just in case.)</p>
<p class="noindentin"><strong><span class="blue">Thick card</span></strong> Roughly letter or A4 card that is 3 mm or more thick</p>
<p class="noindentin"><strong><span class="blue">Paper and access to a printer</span></strong> To print a template for cutting out the framework</p>
<p class="noindentin"><strong><span class="blue">2 × 3-inch (75 mm) paper clips</span></strong> These are used to make the axles that allow the eyes to swivel and the <span epub:type="pagebreak" id="page_141"/>frame that connects the eyes to the servomotor. Ideally, these are 1.5 mm in diameter.</p>
<p class="noindentin"><strong><span class="blue">Adhesive tape</span></strong> For sticking the cardboard together and sticking various things to the cardboard</p>
<p class="noindentin"><strong><span class="blue">Blu-Tack adhesive putty</span></strong> To attach the speaker to the cardboard</p>
<p class="noindentin"><strong><span class="blue">Paper glue</span></strong> To stick the template onto the cardboard</p>
<p class="noindentin"><strong><span class="blue">Scissors and/or craft knife</span></strong></p>
<p class="noindentin"><strong><span class="blue">Paint or pens</span></strong> To draw the eyeballs</p>
<p class="noindentin"><strong><span class="blue">A drill with 5/64-inch (#47) or 2-mm bit</span></strong> To make holes in the ping-pong balls</p>
<p class="noindentin"><strong><span class="blue">Pliers</span></strong> To bend the wire</p>
<h4 class="h4" id="ch00lev1sec164"><strong>Construction</strong></h4>
<p class="noindent">We’ll begin by creating the eyeballs.</p>
<ol>
<li class="noindent">Grab two ping-pong balls (<a href="ch06.xhtml#ch6fig6">Figure 6-6</a>) and prepare to decorate. The best way to draw an eyeball is to first find two small circular items, one a bit bigger than the other (perhaps the lid of a toothpaste tube and a ring) and then, using the circular items and a pencil, trace two concentric circles on the surface of the ping-pong ball. Once this is done, color the outer ring (the iris) and the inner circle (the pupil) two different colors.
<div class="image" id="ch6fig6"><img alt="Image" src="../images/06fig06.jpg"/></div>
<p class="figcap"><em>Figure 6-6: Decorating an eyeball</em></p></li>
<li class="noindent"><span epub:type="pagebreak" id="page_142"/>Once you’ve drawn on the two balls to make them look like eyes, drill three holes in each, through which you’ll feed wires. Using a pencil, make three marks: with the pupil of the eye facing you, make one mark at the bottom of the ball, one at the top, and a final mark on the back opposite the pupil. The holes on the top and bottom will be used to thread the eyeball onto a vertical wire to hold it in position. The hole in the back will be used to attach the second wire, which will move the eye left and right.
<div class="note">
<p class="notep"><span class="red"><strong>WARNING</strong></span> <em>Using a drill can be dangerous! For this part of the project, a responsible adult should use the drill or at least supervise. The main precaution is to keep the ping-pong ball on a flat surface and hold it from the sides. Then drill from above, as shown in <a href="ch06.xhtml#ch6fig7">Figure 6-7</a>. If you have a vise to clamp the ball in place, that’s even better.</em></p>
</div>
<div class="image" id="ch6fig7"><img alt="Image" src="../images/06fig07.jpg"/></div>
<p class="figcap"><em>Figure 6-7 Drilling the eyeball</em></p></li>
<li class="noindent"><span epub:type="pagebreak" id="page_143"/>Once you’re happy with the position of the marks, grab a drill bit with a diameter slightly larger than that of the paper clip wire and drill into the ping-pong ball. For the 1.5 mm paper clips, a 5/64-inch (#47) or 2-mm drill bit is perfect.</li>
<li class="noindent">Make a frame for the eyeballs. Start by completely straightening out a paper clip. Then make the three bends labeled A, B, and C in <a href="ch06.xhtml#ch6fig8">Figure 6-8</a>.
<div class="image" id="ch6fig8"><img alt="Image" src="../images/06fig08.jpg"/></div>
<p class="figcap"><em>Figure 6-8: Where to bend the paper clip to make the eye frame</em></p></li>
<li class="noindent">Make bends A and C first. Both should be 90 degrees. These will hold the eyeballs upright. Next, make a slight bend at the center of the wire—this is bend B. Bend B will provide something to tape onto the cardboard chassis you will make next. Place the eyeballs on the frame as shown in <a href="ch06.xhtml#ch6fig9">Figure 6-9</a>.
<div class="image" id="ch6fig9"><img alt="Image" src="../images/06fig09.jpg"/></div>
<p class="figcap"><em>Figure 6-9: Placing the eyes on the frame</em></p></li>
<li class="noindent"><span epub:type="pagebreak" id="page_144"/>Once you’ve mounted the eyeballs, you can bend the 10 mm tips of the wires over the eyeballs to prevent them from falling off, as shown in <a href="ch06.xhtml#ch6fig9">Figure 6-9</a>. Use pliers to avoid hurting your fingers.
<div class="note">
<p class="notep"><span class="yellow"><strong>NOTE</strong></span> <em>These bends don’t have to be perfect the first time. Plan to make some adjustments as you build the project.</em></p>
</div></li>
<li class="noindent">Now let’s start assembling the cardboard chassis that will hold everything together. To make this easier, I’ve provided a template that can be downloaded with the code for the book. The template is in the folder <em>other downloads</em> and is called <em>Animatronic_Head_Template</em>. It is available in PDF, PNG, and SVG formats. Download it, print it out, and fix it onto a slightly larger piece of cardboard, as shown in <a href="ch06.xhtml#ch6fig10">Figure 6-10</a>.
<div class="image" id="ch6fig10"><img alt="Image" src="../images/06fig10.jpg"/></div>
<p class="figcap"><em>Figure 6-10: The paper template glued to a piece of cardboard</em></p></li>
<li class="noindent">Except for the places noted in <a href="ch06.xhtml#ch6fig10">Figure 6-10</a>, cut along the lines. This will give you the pieces of cardboard shown in <a href="ch06.xhtml#ch6fig11">Figure 6-11</a>. For many of the cuts, scissors will be fine, but <span epub:type="pagebreak" id="page_145"/>you’ll really need a craft knife to make the cutouts for the slots and servomotor.
<div class="image" id="ch6fig11"><img alt="Image" src="../images/06fig11.jpg"/></div>
<p class="figcap"><em>Figure 6-11: The cardboard pieces for the chassis</em></p>
<div class="note">
<p class="notep"><span class="red"><strong>WARNING</strong></span> <em>Only use a craft knife with adult supervision. Craft knives are very sharp, and it’s easy to accidentally cut yourself with them.</em></p>
</div></li>
<li class="noindent">Attach the micro:bit to the front card by poking holes through the pairs of small circles marked on the front of the board. Then, for each pair of holes, clip an alligator clip through the back. These clips will both allow you to make electrical connections and keep the micro:bit securely attached to the card.
<p class="indent">Attach the alligator clips in the order suggested in <a href="ch06.xhtml#ch6fig12">Figure 6-12</a>: red to 3V, black to GND, and yellow to pin 0. Make sure to attach two alligator clips each to the GND and 3V connections of the micro:bit.</p>
<div class="image" id="ch6fig12"><span epub:type="pagebreak" id="page_146"/><img alt="Image" src="../images/06fig12.jpg"/></div>
<p class="figcap"><em>Figure 6-12: Connecting cables to the micro:bit</em></p></li>
<li class="noindent">To connect the micro:bit to the servomotor, you’ll need to attach three alligator clips with male jumper cables on one end. Clip a yellow alligator clip with a male jumper cables to pin 2. Then, pull back the insulating sheath on the red alligator clip already attached to the 3V, expose some of the metal, and clip the red alligator clip with male jumper cable to the red clip. Do the same with the black GND cable, pulling back the insulating sheath of GND’s black alligator clip and attaching the black alligator to male jumper cable (<a href="ch06.xhtml#ch6fig13">Figure 6-13</a>).
<div class="image" id="ch6fig13"><img alt="Image" src="../images/06fig13.jpg"/></div>
<p class="figcap"><em>Figure 6-13: Attaching the micro:bit to the front of the cardboard</em></p></li>
<li class="noindent"><span epub:type="pagebreak" id="page_147"/>Now slot the bottom piece of cardboard into the front piece and fix it in place using adhesive tape (<a href="ch06.xhtml#ch6fig14">Figure 6-14</a>).
<div class="image" id="ch6fig14"><img alt="Image" src="../images/06fig14.jpg"/></div>
<p class="figcap"><em>Figure 6-14: Attaching the bottom card to the front card</em></p></li>
<li class="noindent">Now attach the speaker to the back card; use adhesive tape or putty to secure it. Clip the other end of the three alligator clips you’ve connected to the micro:bit (black, red, and yellow) to their corresponding ports on the speaker (GND, 3V, and 0, respectively). Affix the back card to the bottom card using adhesive tape. As you can see in <a href="ch06.xhtml#ch6fig15">Figure 6-15</a>, your chassis should now be in a U shape. The red, blue, and yellow alligator clips here are waiting to be attached to the servomotor.
<div class="image" id="ch6fig15"><img alt="Image" src="../images/06fig15.jpg"/></div>
<p class="figcap"><em>Figure 6-15: The back card and speaker</em></p></li>
<li class="noindent"><span epub:type="pagebreak" id="page_148"/>With the servomotor arm fixed in place at 90 degrees (review the end of Experiment 8 if needed), push the servomotor through the top card (the round face), threading the servomotor’s wire through first. Notice that the servomotor’s shaft is not in the center of the servomotor but rather toward one end; that end should be at the end of the servomotor cutout that is closest to the center of the top card (see <a href="ch06.xhtml#ch6fig16">Figure 6-16</a>).
<div class="image" id="ch6fig16"><img alt="Image" src="../images/06fig16.jpg"/></div>
<p class="figcap"><em>Figure 6-16: Connecting the servomotor</em></p></li>
<li class="noindent">Attach the male jumper pins to the servomotor’s socket, as described in Experiment 8.</li>
<li class="noindent">With everything connected together, attach the top piece of cardboard to the rest of the chassis. The two circles marking the position of the eyes on the top piece should face the micro:bit end of the chassis (refer to <a href="ch06.xhtml#ch6fig5">Figure 6-5</a>).</li>
<li class="noindent">Now attach the eyeballs and wire frame to the top card, as shown in <a href="ch06.xhtml#ch6fig17">Figure 6-17</a>. Adjust the bend in the middle of the wire frame so that the eyeballs are centered over the two circles drawn on the top card. Then use adhesive tape to hold the wire in place. Give the eyeballs a little spin to make sure they can turn freely.
<div class="image" id="ch6fig17"><span epub:type="pagebreak" id="page_149"/><img alt="Image" src="../images/06fig17.jpg"/></div>
<p class="figcap"><em>Figure 6-17: Connecting the eyeballs</em></p></li>
<li class="noindent">To connect the servomotor to the eyeballs, you’ll need to straighten out the other paper clip, as shown in <a href="ch06.xhtml#ch6fig18">Figure 6-18</a>.
<div class="image" id="ch6fig18"><img alt="Image" src="../images/06fig18.jpg"/></div>
<p class="figcap"><em>Figure 6-18: Making the connector between the servomotor and the eyeballs</em></p></li>
<li class="noindent"><span epub:type="pagebreak" id="page_150"/>To make the loop in the center of the wire, wrap the wire tightly around a small screwdriver shaft (shown in <a href="ch06.xhtml#ch6fig19">Figure 6-19</a>). The diameter of the screwdriver I used was about 3 mm, making the outside diameter of the little loop around 5 mm. Use a screwdriver with a sharp end that’s narrower than the shaft, or it will be hard to slide the wire off once it’s been bent. Make sure to straighten the legs of the wire as shown.
<div class="image" id="ch6fig19"><img alt="Image" src="../images/06fig19.jpg"/></div>
<p class="figcap"><em>Figure 6-19: Using a screwdriver to bend a loop in the servomotor-to-eyeball connector</em></p>
<div class="note">
<p class="notep"><span class="yellow"><strong>NOTE</strong></span> Screwdrivers are sharp and it takes strong hands to bend the thick wire around the screwdriver, so you might need adult help for this bit.</p>
</div></li>
<li class="noindent">Adjust the connector by bending the paper clip until the arms are the same distance apart as the holes in the backs of the eyeballs. Then, hook the wire into the backs of the eyeballs. Use one of the screws provided with the servomotor to fasten the loop to the tip of the servomotor’s arm, as shown in <a href="ch06.xhtml#ch6fig20">Figure 6-20</a>. Depending on how snugly the servomotor fits its cutout in the top card, you may need to tape down the motor to prevent it from moving.
<div class="image" id="ch6fig20"><span epub:type="pagebreak" id="page_151"/><img alt="Image" src="../images/06fig20.jpg"/></div>
<p class="figcap"><em>Figure 6-20: Fitting the servomotor–eyeball connector to the card</em></p></li>
</ol>
<p class="indent">Now connect the USB cable from your micro:bit and try the project out!</p>
<h4 class="h4" id="ch00lev1sec165"><strong>Code</strong></h4>
<p class="noindent">First, we’ll use the code from Experiment 8 to test that our mechanisms are all working. Once you’re sure everything is working well, switch to the code for this project.</p>
<h5 class="h5" id="ch00lev1sec166"><strong>Using the Code from Experiment 8 as a Test</strong></h5>
<p class="noindent">Go to <em><a href="https://github.com/simonmonk/mbms/">https://github.com/simonmonk/mbms/</a></em> and click the link for <strong>Experiment 8: Servomotors</strong>. Once the program has opened, click <strong>Download</strong> and then copy the hex file onto your micro:bit. If you prefer to use Python while testing, download the Python file, <em>Experiment_08.py</em>, from the same website.</p>
<p class="indent">Once the code is loaded, try pressing the A and B buttons to move the servomotor’s arm left and right. You will probably need to adjust the connector wire slightly so that the eyes are lined up and move freely left to right. Only take the servomotor arm a few steps to either side of the 90-degree position or the linkage might get jammed.</p>
<h5 class="h5" id="ch00lev1sec167"><span epub:type="pagebreak" id="page_152"/><strong>Using the Real Project Code</strong></h5>
<p class="noindent">Once you’re satisfied that the eyeballs are moving the way they should, you can switch to the real project code.</p>
<p class="indent">Because this project uses a speech library, it is only available in MicroPython form. Go to <em><a href="https://github.com/simonmonk/mbms/">https://github.com/simonmonk/mbms/</a></em> to download the Python file is <em>ch_06_Animatronic_Head.py</em>.</p>
<p class="indent">Flash it onto your micro:bit and then gently poke the robot. The accelerometer should pick up the movement and tell your animatronic head to swivel its eyes, say something witty, and then look straight ahead again. For a video of this project, go to my YouTube channel (<em><a href="https://www.youtube.com/watch?v=FAJTS2Z8ZDA">https://www.youtube.com/watch?v=FAJTS2Z8ZDA</a></em>).</p>
<p class="indent">The software for this project does two things: it detects when the head is poked, and it triggers talking events after random periods of time have elapsed. The code is rather long, so instead of showing all of it, I’ll just highlight the key parts. If you want to follow along, load the code into Mu.</p>
<p class="indent">To make it seem as though your animatronic head has a mind of its own, we use the Python random library to give us random numbers, which will trigger random events:</p>
<div class="programs1"><span class="green">import</span> random</div>
<p class="indent">Rather than give the head a free range of eye movements, we keep a list of possible eye angles in the array <span class="literal">eye_angles</span>. When we want to set the eyes in a random direction, we simply use the <span class="literal">random</span> function from the random library to take an angle from this array.</p>
<p class="indent">If you’ve played around with the head, you’ve probably noticed that it doesn’t know that many sentences. The phrases it speaks are contained in the array <span class="literal">sentences</span>, shown here:</p>
<div class="programs1">sentences <span class="purple">=</span> <span class="purple">[</span><br/><span class="red1">"Hello my name is Mike"</span><span class="purple">,</span><br/><span class="red1">"What is your name"</span><span class="purple">,</span><br/><span class="red1">"I am looking at you"</span><span class="purple">,</span><br/><span class="red1">"Exterminate exterminate exterminate"</span><span class="purple">,</span><br/><span class="red1">"Number Five is alive"</span><span class="purple">,</span><br/><span class="red1">"I cant do that Dave"</span><span class="purple">,</span><br/><span class="red1">"daisee daisee give me your answer do"</span><br/><span class="purple">]</span></div>
<p class="indent"><span epub:type="pagebreak" id="page_153"/>As with the eye angles, when we want a sentence, we’ll take it from this array. As you can see in the code, with robotic speakers, sometimes it’s better to spell a word phonetically than spell it correctly.</p>
<p class="indent">The three lip images for the speech animation are created as custom <span class="literal">Image</span> objects. Here is the one for the resting lip animation, a horizontal line:</p>
<div class="programs1">lips0 <span class="purple">=</span> Image<span class="purple">(</span><span class="red1">"00000:"</span><br/><span class="red1">              "00000:"</span><br/><span class="red1">              "99999:"</span><br/><span class="red1">              "00000:"</span><br/><span class="red1">              "00000"</span><span class="purple">)</span></div>
<p class="indent">Each of the five rows in <span class="literal">Image</span> is a string representing one row of the display; each digit in the string represents the brightness from 0 to 9 of a particular LED.</p>
<p class="indent">The images for the lips are held as an array in the variable <span class="literal">lips</span>:</p>
<div class="programs1">lips = [lips0, lips1, lips2]</div>
<p class="indent">Both the speaking and the lip animation are controlled by the function <span class="literal">speak</span>, which takes in the <span class="literal">sentence</span> to speak as a parameter:</p>
<div class="programs1"><span class="green">def</span> <span class="blue1">speak</span><br/><span class="purple">(</span>sentence<span class="purple">):</span><br/>    words <span class="purple">=</span> sentence<span class="purple">.</span>split<span class="purple">()</span><br/>    <span class="green">for</span> i <span class="green">in</span> <span class="blue1">range</span><span class="purple">(</span><span class="blue1">0</span><span class="purple">,</span> <span class="blue1">len</span><span class="purple">(</span>words<span class="purple">)):</span><br/>        display<span class="purple">.</span>show<span class="purple">(</span>random<span class="purple">.</span>choice<span class="purple">(</span>lips<span class="purple">))</span><br/>        speech<span class="purple">.</span>say<span class="purple">(</span>words<span class="purple">[</span>i<span class="purple">])</span><br/>    display<span class="purple">.</span>show<span class="purple">(</span>lips0<span class="purple">)</span></div>
<p class="indent">To make sure that the lips animate as the words are spoken, we use the <span class="literal">split</span> method to break the sentence into the list of individual words saved as <span class="literal">words</span>. Then, for every word in the list, we display one of the lip images (chosen at random using the <span class="literal">choice</span> method from the random library) and have <span class="literal">speech</span> speak the word. When all the words have been spoken, the lip display shows the default <span class="literal">lips0</span> image.</p>
<p class="indent"><span epub:type="pagebreak" id="page_154"/>Next, we define an <span class="literal">act()</span> function:</p>
<div class="programs1"><span class="green">def</span> <span class="blue1">act</span><span class="purple">():</span><br/>    set_servo_angle<span class="purple">(</span>pin2<span class="purple">,</span> random<span class="purple">.</span>choice<span class="purple">(</span>eye_angles<span class="purple">))</span><br/>    sleep<span class="purple">(</span><span class="blue1">300</span><span class="purple">)</span><br/>    speak<span class="purple">(</span>random<span class="purple">.</span>choice<span class="purple">(</span>sentences<span class="purple">))</span><br/>    set_servo_angle<span class="purple">(</span>pin2<span class="purple">,</span> <span class="blue1">90</span><span class="purple">)</span><br/>    sleep<span class="purple">(</span><span class="blue1">2000</span><span class="purple">)</span></div>
<p class="indent">The <span class="literal">act</span> function does three things: it moves the eyes at random by setting the servomotor to a random angle, it selects a sentence to speak by calling <span class="literal">speak</span>, and it resets the eyes by setting the servomotor angle back to 90 degrees. To allow for some time between each step, the code makes a call to <span class="literal">sleep</span>.</p>
<p class="indent">Here is the main body of our code that uses all of our variables and functions:</p>
<div class="programs1"><span class="green">while True</span><span class="purple">:</span><br/>    new_z <span class="purple">=</span> <span class="blue1">abs</span><span class="purple">(</span>accelerometer<span class="purple">.</span>get_z<span class="purple">())</span><br/>    <span class="green">if</span> <span class="blue1">abs</span><span class="purple">(</span>new_z <span class="purple">-</span> base_z<span class="purple">)</span> <span class="purple">&gt;</span> <span class="blue1">20</span><span class="purple">:</span><br/>        base_z <span class="purple">=</span> new_z<br/>        act<span class="purple">()</span><br/>    <span class="green">if</span> random<span class="purple">.</span>randint<span class="purple">(</span><span class="blue1">0</span><span class="purple">,</span> <span class="blue1">1000</span><span class="purple">)</span> <span class="purple">==</span> <span class="blue1">0</span><span class="purple">:</span><br/>        act<span class="purple">()</span><br/>    sleep<span class="purple">(</span><span class="blue1">50</span><span class="purple">)</span></div>
<p class="indent">In the main body of the code, we have a <span class="literal">while True</span> loop, which means the commands execute until the code is signaled to stop. This is useful for when you need code to respond continuously to input. Here, we want to be ready for the sudden change in acceleration caused by a tap on the robot’s head. First, the loop registers the acceleration from the accelerometer. Then, it uses the <span class="literal">abs</span> function to get the magnitude of the acceleration—in this case, we don’t care about the direction, just how large the acceleration is.</p>
<p class="indent">In the first <span class="literal">if</span> statement, we check whether the acceleration value has changed by more than 20 mg (milligravities). If so, the base acceleration is updated to the new acceleration (ensuring that the next time through the loop, the acceleration has to change by <em>another</em> 20 mg), and <span class="literal">act</span> is called.</p>
<p class="indent"><span epub:type="pagebreak" id="page_155"/>In the second <span class="literal">if</span> statement, we give the animatronic head a bit of randomness. The code picks a random number between 0 and 1,000. If it is equal to 0 (a 1 in 1,001 chance), the <span class="literal">act</span> function is called. Even though this probability is very low, since the value gets checked hundreds of times a second, the head springs into action several times a minute.</p>
<h4 class="h4" id="ch00lev1sec168"><strong>Things to Try</strong></h4>
<p class="noindent">Try using a USB battery or AAA battery box to power the head instead of keeping it tethered to your computer with a USB cable.</p>
<p class="indent">If you want to change up your head’s speech, go into the code and add more sentences to the <span class="literal">sentences</span> array.</p>
<p class="indent">The speech library produces rather quiet speech that is also quite indistinct. You can improve this a little by connecting a bigger amplified speaker.</p>
<p class="indent">If you want to add a bit more to the project, take a look at the code examples here: <em><a href="https://microbit-micropython.readthedocs.io/en/latest/tutorials/speech.html">https://microbit-micropython.readthedocs.io/en/latest/tutorials/speech.html</a></em>. In this code, the speech library is used to produce singing.</p>
<h3 class="h3" id="ch00lev1sec169"><strong>PROJECT: ROBOT ROVER</strong></h3>
<div class="image"><img alt="Image" src="../images/common3.jpg"/></div>
<p class="difficulty"><em>Difficulty: Hard</em></p>
<p class="noindent">In this project, we’ll create a robotic rover. Using a clever app called Bitty Controller, you’ll be able to control the little buggy with your Android phone (<a href="ch06.xhtml#ch6fig21">Figure 6-21</a>). The Mad Scientist likes to use the rover to deliver notes to the lab assistants.</p>
<div class="note">
<p class="notep"><span class="red"><strong>WARNING</strong></span> <em>We’re going to use some low-cost chassis kits for this project, but the wires that come with these kits are usually loose—meaning you’ll need to solder the wires onto the motors. This is the only project in the book that requires soldering. The soldering isn’t difficult, but it is dangerous and you can easily get burned. So please find an adult to do this part.</em></p>
</div>
<div class="image" id="ch6fig21"><span epub:type="pagebreak" id="page_156"/><img alt="Image" src="../images/06fig21.jpg"/></div>
<p class="figcap"><em>Figure 6-21: A micro:bit-controlled roving robot</em></p>
<h4 class="h4" id="ch00lev1sec170"><strong>What You’ll Need</strong></h4>
<p class="noindent">For this project, you’ll need the following items:</p>
<p class="noindentint"><strong><span class="blue">Micro:bit</span></strong></p>
<p class="noindentin"><strong><span class="blue">Android phone</span></strong></p>
<p class="noindentin"><strong><span class="blue">Kitronik Motor Driver Board for micro:bit (V2)</span></strong> To control the motors</p>
<p class="noindentin"><strong><span class="blue">Low-cost robot chassis kit</span></strong> Includes two gear motors and a 4 × AA battery box</p>
<p class="noindentin"><strong><span class="blue">4 × AA batteries</span></strong></p>
<p class="noindentin"><strong><span class="blue">Bitty Controller App for Android</span></strong> From Google Play Store (about $5)</p>
<p class="noindentin"><strong><span class="blue">Assorted screwdrivers</span></strong> Suitable for both the nuts and bolts on the chassis and the screw terminals on the motor controller board</p>
<p class="noindentin"><strong><span class="blue">Soldering equipment</span></strong> To attach the wires to the gearmotors</p>
<p class="noindentinb"><strong><span class="blue">Blu-Tack adhesive putty</span></strong> To attach the motor control board and micro:bit to the chassis</p>
<p class="indent"><span epub:type="pagebreak" id="page_157"/>If you search eBay or Amazon for robot chassis, you’ll find low-cost robot chassis kits like the one shown in <a href="ch06.xhtml#ch6fig22">Figure 6-22</a>. Look for one that includes a 4 × AA battery box and two gearmotors (motors with a built-in gearbox).</p>
<div class="image" id="ch6fig22"><img alt="Image" src="../images/06fig22.jpg"/></div>
<p class="figcap"><em>Figure 6-22: The low-cost robot chassis used by this Mad Scientist</em></p>
<h4 class="h4" id="ch00lev1sec171"><strong>Construction</strong></h4>
<p class="noindent">Maybe the trickiest part of this project is the chassis kit assembly. Getting the screws and bolts in the right place will require precision and finesse.</p>
<p class="indent">Not all chassis will be the same, so instead of taking you through the assembly step-by-step, I’ll just give you some high-level advice. Your chassis should come with instructions, although they may be somewhat cryptic. In general, you’ll need to attach the gear motors, the castor wheel (the wheel that can turn freely in any direction), the motor controller, and the micro:bit.</p>
<ol>
<li class="noindent">Solder the supplied wires onto the motor terminals, as shown in <a href="ch06.xhtml#ch6fig23">Figure 6-23a–c</a>. If you work quickly, a good soldering joint can be made by melting a generous <span epub:type="pagebreak" id="page_158"/>amount of solder onto the motor terminal and then pressing the wire onto the dome of solder with the iron (<a href="ch06.xhtml#ch6fig23">Figure 6-23a</a>).
<div class="image" id="ch6fig23"><img alt="Image" src="../images/06fig23.jpg"/></div>
<p class="figcap"><em>Figure 6-23: Soldering wires onto the motor</em></p></li>
<li class="noindent">It doesn’t matter much which terminal you attach the red wire to. Just be sure to be consistent between the two motors. That is, if you decide to attach the red wire to the right-hand terminal on one motor, solder the red wire to the right-hand terminal of the other motor as well.</li>
<li class="noindent">Remove the layer of paper covering the chassis. <a href="ch06.xhtml#ch6fig24">Figure 6-24a–e</a> shows the assembly process at a high level. You may find that your chassis is different.
<div class="image" id="ch6fig24"><span epub:type="pagebreak" id="page_159"/><img alt="Image" src="../images/06fig24.jpg"/></div>
<p class="figcap"><em>Figure 6-24: Building the chassis</em></p>
<p class="indent">Here are a few things to remember when building the chassis:</p>
<p class="bull1"><img alt="Image" src="../images/play.jpg"/>  Don’t overtighten the nuts and bolts, as doing so can cause the plastic chassis to crack.</p>
<p class="bull1"><img alt="Image" src="../images/play.jpg"/>  When attaching the gearmotors, put the nuts toward the inside of the chassis so that the motor-fixing bolts that stick out beyond the nut won’t get in the way of the wheels.</p>
<p class="bull1"><img alt="Image" src="../images/play.jpg"/>  <span epub:type="pagebreak" id="page_160"/>If the bolt doesn’t turn smoothly into the nut, try turning the bolt counterclockwise a little to find the start of the nut’s thread. You may want to use a pair of small pliers to grip the nut while you turn the screw with a screwdriver.</p></li>
<li class="noindent">Once you have the chassis securely assembled, attach the micro:bit to the Kitronik Motor Driver board with the micro:bit’s screen facing outward, as shown in <a href="ch06.xhtml#ch6fig25">Figure 6-25</a>. Line up the micro:bit’s edge connector carefully with the socket on the Motor Controller and press it firmly into place. When your controller looks like <a href="ch06.xhtml#ch6fig25">Figure 6-25</a>, stick it to the chassis using adhesive putty, also shown in <a href="ch06.xhtml#ch6fig25">Figure 6-25</a>.
<div class="image" id="ch6fig25"><img alt="Image" src="../images/06fig25.jpg"/></div>
<p class="figcap"><em>Figure 6-25: Attaching the micro:bit</em></p></li>
<li class="noindent">It’s time to wire up the motors and battery box. First, look at <a href="ch06.xhtml#ch6fig26">Figure 6-26</a> to see what you are aiming for. Unscrew the screw on the relevant terminal, place the wire firmly inside the terminal, and then screw the screw back in fairly tightly.
<div class="image" id="ch6fig26"><span epub:type="pagebreak" id="page_161"/><img alt="Image" src="../images/06fig26.jpg"/></div>
<p class="figcap"><em>Figure 6-26: Wiring up</em></p></li>
<li class="noindent">Make the following connections:
<p class="bull1"><img alt="Image" src="../images/play.jpg"/>  Red (positive) wire from the battery box to the screw terminal marked <span class="literal">RED +</span> on the Motor Controller</p>
<p class="bull1"><img alt="Image" src="../images/play.jpg"/>  Black (negative) wire from the battery box to the screw terminal marked <span class="literal">BLACK -</span> on the Motor Controller</p>
<p class="bull1"><img alt="Image" src="../images/play.jpg"/>  Red wire from the left (as viewed from the back of the rover) motor to the screw terminal on the Motor Controller labeled <span class="literal">MOTOR1 P12</span></p>
<p class="bull1"><img alt="Image" src="../images/play.jpg"/>  Black wire from the left motor to the screw terminal on the Motor Controller labeled <span class="literal">MOTOR1 P8</span></p>
<p class="bull1"><img alt="Image" src="../images/play.jpg"/>  Red wire from the right motor to the screw terminal on the Motor Controller labeled <span class="literal">MOTOR2 P0</span></p>
<p class="bull1"><img alt="Image" src="../images/play.jpg"/>  Black wire from the right motor to the screw terminal on the Motor Controller labeled <span class="literal">MOTOR1 P16</span></p></li>
<li class="noindent">In this project, you’ll use an Android app to control the rover via Bluetooth. You can find the code that runs on the micro:bit at <em><a href="http://www.bittysoftware.com/downloads.html#controller">http://www.bittysoftware.com/downloads.html#controller</a></em>. Click the link <strong>micro:bit hex file for</strong> <span epub:type="pagebreak" id="page_162"/><strong>Kitronik Buggy - no pairing required</strong> and download the hex file. This file is also available with the book downloads in the <em>Other Downloads</em> folder. Next, connect the micro:bit to your computer with a USB and copy the downloaded hex file onto your micro:bit. You won’t need batteries just yet.</li>
<li class="noindent">To install the app on your Android phone, open Google Play and search for <em>Bitty Controller</em>. You’ll have to pay a few dollars for the app. Download and install the app.</li>
<li class="noindent">We’re one step away from trying out the project! Put four AA batteries into the battery box. These will power both the motors and your micro:bit, meaning you can disconnect the USB cable—it’s time to set your rover free.</li>
</ol>
<p class="indent">Open the Bitty Controller app (<a href="ch06.xhtml#ch6fig27">Figure 6-27</a>) and click <strong>Scan</strong>. This should find your micro:bit. In <a href="ch06.xhtml#ch6fig27">Figure 6-27</a>, it’s called <em>BBC micro:bit [gaviv]</em>. Click this and the RC-style controller of <a href="ch06.xhtml#ch6fig28">Figure 6-28</a> should appear. The micro:bit’s display should also show a <span class="literal">C</span>, indicating that it’s connected to your phone.</p>
<div class="image" id="ch6fig27"><img alt="Image" src="../images/06fig27.jpg"/></div>
<p class="figcap"><em>Figure 6-27: Starting Bitty Controller</em></p>
<div class="image" id="ch6fig28"><span epub:type="pagebreak" id="page_163"/><img alt="Image" src="../images/06fig28.jpg"/></div>
<p class="figcap"><em>Figure 6-28: The Dual D-Pad Controller</em></p>
<p class="indent">Use the top and bottom square buttons to control the forward and backward motion of the rover. To turn the rover left and right, use the left and right round buttons.</p>
<p class="indent">For a first test, do something simple: flip the rover onto its back and use the app to control the wheels. Do they spin? Once the rover passes that test, put it on the floor and try driving it around. If you don’t like the controller layout, head to Options on the Bitty Controller app to find other layouts.</p>
<p class="indent">The rover may move forward when you tell it to go backward and vice versa. If this happens, your wires are swapped: switch the red and black wires for motor 1 and motor 2. If your rover drives around in a circle, swap one of the pairs of wires on one of the motors.</p>
<p class="indent">When you want to turn off your rover (a good way to make your batteries last longer), just lift one end of one of the batteries out of the battery holder. Ta-da! Now you have a crude switch.</p>
<h4 class="h4" id="ch00lev1sec172"><strong>How It Works: Motors and the Flow of Electricity</strong></h4>
<p class="noindent">The direction of the gear motors is controlled by the direction of the current flowing through them—if you reverse the direction, you reverse the motors. As you can see in <a href="ch06.xhtml#ch6fig29">Figure 6-29</a>, a motor <span epub:type="pagebreak" id="page_164"/>turns clockwise if connection A is positive and connection B is negative. If A and B are reversed, so that A is negative and B is positive, the motor moves the other way.</p>
<div class="image" id="ch6fig29"><img alt="Image" src="../images/06fig29.jpg"/></div>
<p class="figcap"><em>Figure 6-29: Controlling the direction of a motor</em></p>
<p class="indent">The Kitronik Motor Controller contains a chip that controls the direction of current in two motors. It also supplies the relatively high current that the motors need.</p>
<h3 class="h3" id="ch00lev1sec173"><strong>SUMMARY</strong></h3>
<p class="noindent">We covered a lot of ground in this chapter. First, we learned about servomotors and how to set one up using the micro:bit. Then, we built two complex projects: the animatronic head and the remote-controlled rover. Along the way, we learned about PWM and current flow and picked up a few basic programming tricks to boot.</p>
<p class="indent">Now that you know how to make things move, you can start thinking about other projects you’d like to make. What things would you like to have move all on their own? In the next chapter, we’ll look at how to deal with time.</p>
</body></html>