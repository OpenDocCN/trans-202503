- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Computer Data Representation and Operations
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机数据表示与操作
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: A major stumbling block many beginners encounter when attempting to learn assembly
    language is the common use of the binary and hexadecimal numbering systems. Although
    hexadecimal numbers are a little strange, their advantages outweigh their disadvantages
    by a large margin. Understanding the binary and hexadecimal numbering systems
    is important because their use simplifies the discussion of other topics, including
    bit operations, signed numeric representation, character codes, and packed data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多初学者在学习汇编语言时遇到的一个主要难点是二进制和十六进制数字系统的常见使用。尽管十六进制数字有些陌生，但它们的优点远远超过缺点。理解二进制和十六进制数字系统非常重要，因为它们的使用简化了其他主题的讨论，包括位操作、符号数表示、字符编码和打包数据。
- en: 'This chapter discusses several important concepts, including the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了几个重要的概念，包括以下内容：
- en: The binary and hexadecimal numbering systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制和十六进制数字系统
- en: Binary data organization (bits, nibbles, bytes, words, and double words)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制数据组织（位、半字节、字节、字和双字）
- en: Signed and unsigned numbering systems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有符号和无符号数字系统
- en: Arithmetic, logical, shift, and rotate operations on binary values
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制值上的算术、逻辑、移位和旋转操作
- en: Bit fields and packed data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位域和打包数据
- en: Floating-point and binary-code decimal formats
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数和二进制十进制格式
- en: Character data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符数据
- en: This is basic material, and the remainder of this text depends on your understanding
    of these concepts. If you are already familiar with these terms from other courses
    or study, you should at least skim this material before proceeding to the next
    chapter. If you are unfamiliar with this material, or only vaguely familiar with
    it, you should study it carefully before proceeding. *All of the material in this
    chapter is important!* Do not skip over any material.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基础内容，本文的其余部分依赖于你对这些概念的理解。如果你已经在其他课程或学习中接触过这些术语，你至少应该浏览一下这些材料，然后再继续下一章。如果你对这些内容不熟悉，或者只模糊了解，你应该在继续之前认真学习这些内容。*本章的所有内容都很重要！*不要跳过任何内容。
- en: 2.1 Numbering Systems
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 数字系统
- en: Most modern computer systems do not represent numeric values using the decimal
    (base-10) system. Instead, they typically use a binary, or two’s complement, numbering
    system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现代大多数计算机系统不使用十进制（基数10）系统来表示数字值。相反，它们通常使用二进制或二的补码数字系统。
- en: 2.1.1 A Review of the Decimal System
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 十进制系统回顾
- en: 'You’ve been using the decimal numbering system for so long that you probably
    take it for granted. When you see a number like 123, you don’t think about the
    value 123; rather, you generate a mental image of how many items this value represents.
    In reality, however, the number 123 represents the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用十进制数字系统很久了，可能已经习以为常。当你看到一个数字如123时，你并不会思考数字123的值；相反，你会脑海中生成这个值代表多少个项目的图像。然而，实际上，数字123代表的是：
- en: (1 × 10²) + (2 × 10¹) + (3 × 10⁰)
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (1 × 10²) + (2 × 10¹) + (3 × 10⁰)
- en: or
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或
- en: 100 + 20 + 3
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 100 + 20 + 3
- en: 'In a decimal *positional numbering system*, each digit appearing to the left
    of the decimal point represents a value between 0 and 9 times an increasing power
    of 10\. Digits appearing to the right of the decimal point represent a value between
    0 and 9 times an increasing negative power of 10\. For example, the value 123.456
    means this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在十进制*位置数字系统*中，小数点左侧的每个数字表示一个值，这个值是0到9之间的某个数字，乘以10的逐渐增大的幂。小数点右侧的每个数字表示一个值，这个值是0到9之间的某个数字，乘以10的逐渐减小的负幂。例如，数字123.456表示的是：
- en: (1 × 10²) + (2 × 10¹) + (3 × 10⁰) + (4 × 10^(-1)) + (5 × 10^(-2)) + (6 × 10^(-3))
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (1 × 10²) + (2 × 10¹) + (3 × 10⁰) + (4 × 10^(-1)) + (5 × 10^(-2)) + (6 × 10^(-3))
- en: or
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或
- en: 100 + 20 + 3 + 0.4 + 0.05 + 0.006
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 100 + 20 + 3 + 0.4 + 0.05 + 0.006
- en: 2.1.2 The Binary Numbering System
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.2 二进制数字系统
- en: Most modern computer systems operate using *binary* logic. The computer represents
    values using two voltage levels (usually 0 V and +2.4 to 5 V). These two levels
    can represent exactly two unique values. These could be any two different values,
    but they typically represent the values 0 and 1, the two digits in the binary
    numbering system.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现代大多数计算机系统使用*二进制*逻辑操作。计算机通过两种电压水平（通常是0V和+2.4至5V）来表示值。这两种电压水平可以精确表示两个独特的值。它们可以是任何两个不同的值，但通常表示的是0和1，二进制数字系统中的两个数字。
- en: 'The binary numbering system works just like the decimal numbering system, except
    binary allows only the digits 0 and 1 (rather than 0 to 9) and uses powers of
    2 rather than powers of 10\. Therefore, converting a binary number to decimal
    is easy. For each 1 in a binary string, add 2^(*n*), where *n* is the zero-based
    position of the binary digit. For example, the binary value 11001010[2] represents
    the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制计数系统的工作方式与十进制计数系统相似，区别在于二进制只允许使用数字0和1（而不是0到9），并且使用2的幂而非10的幂。因此，将二进制数转换为十进制非常简单。对于二进制字符串中的每个1，添加2^(*n*)，其中*n*是二进制数字的零基位置。例如，二进制值11001010[2]表示如下：
- en: (1 × 2⁷) + (1 × 2⁶) + (0 × 2⁵) + (0 × 2⁴) + (1 × 2³) + (0 × 2²) + (1 × 2¹) +
    (0 × 2⁰)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (1 × 2⁷) + (1 × 2⁶) + (0 × 2⁵) + (0 × 2⁴) + (1 × 2³) + (0 × 2²) + (1 × 2¹) +
    (0 × 2⁰)
- en: '='
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '='
- en: 128[10] + 64[10] + 8[10] + 2[10]
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 128[10] + 64[10] + 8[10] + 2[10]
- en: '='
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '='
- en: 202[10]
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 202[10]
- en: Converting decimal to binary is slightly more difficult. You must find those
    powers of 2 that, when added together, produce the decimal result.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将十进制转换为二进制稍微复杂一些。你必须找到那些2的幂，当它们相加时，得到十进制结果。
- en: 'A simple way to convert decimal to binary is the *even/odd—divide-by-two* algorithm.
    This algorithm uses the following steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将十进制转换为二进制的一种简单方法是*偶数/奇数—除以二*算法。该算法使用以下步骤：
- en: If the number is even, emit a 0\. If the number is odd, emit a 1.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数字是偶数，则输出0。如果数字是奇数，则输出1。
- en: Divide the number by 2 and throw away any fractional component or remainder.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数字除以2，舍去任何小数部分或余数。
- en: If the quotient is 0, the algorithm is complete.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果商为0，则算法完成。
- en: If the quotient is not 0 and is odd, insert a 1 before the current string; if
    the number is even, prefix your binary string with 0.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果商不为0且为奇数，则在当前字符串前插入1；如果数字为偶数，则在二进制字符串前加0。
- en: Go back to step 2 and repeat.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到步骤2并重复。
- en: Binary numbers, although they have little importance in high-level languages,
    appear everywhere in assembly language programs. So you should be comfortable
    with them.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数字在高级语言中虽然不太重要，但在汇编语言程序中随处可见。因此，你应该熟悉它们。
- en: 2.1.3 Binary Conventions
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.3 二进制约定
- en: 'In the purest sense, every binary number contains an infinite number of digits
    (or *bits*, which is short for *binary digits*). For example, we can represent
    the number 5 by any of the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从最纯粹的角度来看，每个二进制数都包含无限个数字（或*位*，即*二进制数字*的缩写）。例如，我们可以用以下任意一种方式表示数字5：
- en: 101 00000101 0000000000101 . . . 000000000000101
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 101 00000101 0000000000101 . . . 000000000000101
- en: Any number of leading-zero digits may precede the binary number without changing
    its value. Because the x86-64 typically works with groups of 8 bits, we’ll zero-extend
    all binary numbers to a multiple of 4 or 8 bits. Following this convention, we’d
    represent the number 5 as 0101[2] or 00000101[2].
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数量的前导零数字都可以出现在二进制数字前面而不会改变其值。因为x86-64通常以8位为一组，所以我们将所有二进制数字扩展为4位或8位的倍数。按照这个约定，我们将数字5表示为0101[2]或00000101[2]。
- en: To make larger numbers easier to read, we will separate each group of 4 binary
    bits with an underscore. For example, we will write the binary value 1010111110110010
    as 1010_1111_1011_0010.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使较大的数字更易于阅读，我们将每组4个二进制位用下划线分隔。例如，我们将二进制值1010111110110010写成1010_1111_1011_0010。
- en: 'We’ll number each bit as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按如下方式为每个比特编号：
- en: The rightmost bit in a binary number is bit position 0.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二进制数字中的最右侧比特是比特位置0。
- en: Each bit to the left is given the next successive bit number.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个向左的比特都被赋予下一个连续的比特编号。
- en: 'An 8-bit binary value uses bits 0 to 7:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个8位二进制值使用第0到第7位：
- en: '*X*[7] *X*[6] *X*[5] *X*[4] *X*[3] *X*[2] *X*[1] *X*[0]'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*X*[7] *X*[6] *X*[5] *X*[4] *X*[3] *X*[2] *X*[1] *X*[0]'
- en: 'A 16-bit binary value uses bit positions 0 to 15:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个16位二进制值使用第0到第15位：
- en: '*X*[15] *X*[14] *X*[13] *X*[12] *X*[11] *X*[10] *X*[9] *X*[8] *X*[7] *X*[6]
    *X*[5] *X*[4] *X*[3] *X*[2] *X*[1] *X*[0]'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*X*[15] *X*[14] *X*[13] *X*[12] *X*[11] *X*[10] *X*[9] *X*[8] *X*[7] *X*[6]
    *X*[5] *X*[4] *X*[3] *X*[2] *X*[1] *X*[0]'
- en: A 32-bit binary value uses bit positions 0 to 31, and so on.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个32位二进制值使用第0到第31位，依此类推。
- en: Bit 0 is the *low-order (**LO)* bit; some refer to this as the *least significant
    bit*. The leftmost bit is called the *high-order* *(**HO)* bit, or the *most significant
    bit*. We’ll refer to the intermediate bits by their respective bit numbers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 位0是*低位（**LO**）*位；有些人称其为*最低有效位*。最左边的位称为*高位*（**HO**）*位*，或*最高有效位*。我们将根据各自的比特编号来称呼中间的比特。
- en: In MASM, you can specify binary values as a string of 0 or 1 digits ending with
    the character `b`. Remember, MASM doesn’t allow underscores in binary numbers.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在MASM中，可以将二进制值指定为以`b`字符结尾的0或1数字字符串。记住，MASM不允许在二进制数字中使用下划线。
- en: 2.2 The Hexadecimal Numbering System
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.2 十六进制计数系统
- en: Unfortunately, binary numbers are verbose. To represent the value 202[10] requires
    eight binary digits, but only three decimal digits. When dealing with large values,
    binary numbers quickly become unwieldy. Unfortunately, the computer “thinks” in
    binary, so most of the time using the binary numbering system is convenient. Although
    we can convert between decimal and binary, the conversion is not a trivial task.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，二进制数字冗长。表示值202[10]需要八位二进制数字，但只需要三位十进制数字。当处理大数值时，二进制数字很快变得难以处理。不幸的是，计算机是以二进制为“思维方式”的，因此在大多数情况下，使用二进制计数系统非常方便。虽然我们可以在十进制和二进制之间进行转换，但这种转换并非小事。
- en: 'The hexadecimal (base-16) numbering system solves many of the problems inherent
    in the binary system: hexadecimal numbers are compact, and it’s simple to convert
    them to binary, and vice versa. For this reason, most engineers use the hexadecimal
    numbering system.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制（基数16）计数系统解决了二进制系统中许多固有的问题：十六进制数字简洁，且将其转换为二进制以及反向转换都很简单。因此，大多数工程师使用十六进制计数系统。
- en: 'Because the *radix* (base) of a hexadecimal number is 16, each hexadecimal
    digit to the left of the hexadecimal point represents a certain value multiplied
    by a successive power of 16\. For example, the number 1234[16] is equal to this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因为十六进制数字的*基数*（进制）是16，每个十六进制数字在十六进制小数点左边代表一个乘以16的逐次幂的值。例如，数字1234[16]等于：
- en: (1 × 16³) + (2 × 16²) + (3 × 16¹) + (4 × 16⁰)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: (1 × 16³) + (2 × 16²) + (3 × 16¹) + (4 × 16⁰)
- en: or
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者
- en: 4096 + 512 + 48 + 4 = 4660[10]
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 4096 + 512 + 48 + 4 = 4660[10]
- en: 'Each hexadecimal digit can represent one of 16 values between 0 and 15[10].
    Because there are only 10 decimal digits, we need 6 additional digits to represent
    the values in the range 10[10] to 15[10]. Rather than create new symbols for these
    digits, we use the letters A to F. The following are all examples of valid hexadecimal
    numbers:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 每个十六进制数字可以表示0到15[10]之间的16个值。由于只有10个十进制数字，我们需要6个附加数字来表示10[10]到15[10]之间的值。我们没有为这些数字创建新的符号，而是使用字母A到F。以下是所有有效的十六进制数字的示例：
- en: 1234[16] DEAD[16] BEEF[16] 0AFB[16] F001[16] D8B4[16]
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1234[16] DEAD[16] BEEF[16] 0AFB[16] F001[16] D8B4[16]
- en: 'Because we’ll often need to enter hexadecimal numbers into the computer system,
    and on most computer systems you cannot enter a subscript to denote the radix
    of the associated value, we need a different mechanism for representing hexadecimal
    numbers. We’ll adopt the following MASM conventions:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们通常需要将十六进制数字输入到计算机系统中，而在大多数计算机系统中你无法输入下标来表示相关值的基数，所以我们需要一种不同的机制来表示十六进制数字。我们将采用以下MASM约定：
- en: All hexadecimal values begin with a numeric character and have an *h* suffix;
    for example, 123A4h and 0DEADh.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有十六进制值以数字字符开头，并且以*h*后缀结尾；例如，123A4h和0DEADh。
- en: All binary values end with a *b* character; for example, 10010b.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有二进制值以*b*字符结尾；例如，10010b。
- en: Decimal numbers do not have a suffix character.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 十进制数字没有后缀字符。
- en: If the radix is clear from the context, this book may drop the trailing *h*
    or *b* character.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果基数可以从上下文中推断出来，本书可能会省略后缀的*h*或*b*字符。
- en: 'Here are some examples of valid hexadecimal numbers using MASM notation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用MASM符号表示的有效十六进制数字的几个示例：
- en: 1234h 0DEADh 0BEEFh 0AFBh 0F001h 0D8B4h
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1234h 0DEADh 0BEEFh 0AFBh 0F001h 0D8B4h
- en: As you can see, hexadecimal numbers are compact and easy to read. In addition,
    you can easily convert between hexadecimal and binary. [Table 2-1](#table2-1)
    provides all the information you’ll ever need to convert any hexadecimal number
    into a binary number, or vice versa.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，十六进制数字简洁且易于阅读。此外，你可以轻松地在十六进制和二进制之间进行转换。[表2-1](#table2-1)提供了所有你需要的转换信息，可以将任何十六进制数字转换为二进制数字，反之亦然。
- en: 'Table 2-1: Binary/Hexadecimal Conversion'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1：二进制/十六进制转换
- en: '| **Binary** | **Hexadecimal** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **二进制** | **十六进制** |'
- en: '| --- | --- |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 0000 | 0 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 0000 | 0 |'
- en: '| 0001 | 1 |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 0001 | 1 |'
- en: '| 0010 | 2 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 0010 | 2 |'
- en: '| 0011 | 3 |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 0011 | 3 |'
- en: '| 0100 | 4 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 0100 | 4 |'
- en: '| 0101 | 5 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 0101 | 5 |'
- en: '| 0110 | 6 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 0110 | 6 |'
- en: '| 0111 | 7 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 0111 | 7 |'
- en: '| 1000 | 8 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 1000 | 8 |'
- en: '| 1001 | 9 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 1001 | 9 |'
- en: '| 1010 | A |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 1010 | A |'
- en: '| 1011 | B |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 1011 | B |'
- en: '| 1100 | C |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 1100 | C |'
- en: '| 1101 | D |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 1101 | D |'
- en: '| 1110 | E |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 1110 | E |'
- en: '| 1111 | F |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 1111 | F |'
- en: 'To convert a hexadecimal number into a binary number, substitute the corresponding
    4 bits for each hexadecimal digit in the number. For example, to convert 0ABCDh
    into a binary value, convert each hexadecimal digit according to [Table 2-1](#table2-1),
    as shown here:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要将十六进制数字转换为二进制数字，可以将每个十六进制数字对应的4位二进制替换。例如，要将0ABCDh转换为二进制值，根据[表2-1](#table2-1)将每个十六进制数字转换，如下所示：
- en: '| A | B | C | D | Hexadecimal |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| A | B | C | D | 十六进制 |'
- en: '| 1010 | 1011 | 1100 | 1101 | Binary |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 1010 | 1011 | 1100 | 1101 | 二进制 |'
- en: 'To convert a binary number into hexadecimal format is almost as easy:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 将二进制数字转换为十六进制格式几乎同样简单：
- en: 'Pad the binary number with 0s to make sure that the number contains a multiple
    of 4 bits. For example, given the binary number 1011001010, add 2 bits to the
    left of the number so that it contains 12 bits: 001011001010.'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用0填充二进制数，确保该数字包含4位的倍数。例如，给定二进制数1011001010，在数字的左侧加上2位，使其包含12位：001011001010。
- en: Separate the binary value into groups of 4 bits; for example, 0010_1100_1010.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将二进制值分成4位一组；例如，0010_1100_1010。
- en: 'Look up these binary values in [Table 2-1](#table2-1) and substitute the appropriate
    hexadecimal digits: 2CAh.'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找[表2-1](#table2-1)中的这些二进制值，并替换为相应的十六进制数字：2CAh。
- en: Contrast this with the difficulty of conversion between decimal and binary,
    or decimal and hexadecimal!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与十进制和二进制之间，或十进制和十六进制之间的转换困难相比，这是多么简单！
- en: Because converting between hexadecimal and binary is an operation you will need
    to perform over and over again, you should take a few minutes to memorize the
    conversion table. Even if you have a calculator that will do the conversion for
    you, you’ll find manual conversion to be a lot faster and more convenient.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在十六进制和二进制之间的转换是你将反复进行的操作，因此你应该花几分钟时间记住转换表。即使你有一个可以为你完成转换的计算器，你会发现手动转换要快得多，也更方便。
- en: 2.3 A Note About Numbers vs. Representation
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.3 关于数字与表示的说明
- en: Many people confuse numbers and their representation. A common question beginning
    assembly language students ask is, “I have a binary number in the EAX register.
    How do I convert that to a hexadecimal number in the EAX register?” The answer
    is, “You don’t.”
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人混淆了数字和它们的表示。一些学习汇编语言的学生常常问这样一个问题：“我在EAX寄存器中有一个二进制数。如何将它转换为EAX寄存器中的十六进制数？”答案是：“你不需要转换。”
- en: Although a strong argument could be made that numbers in memory or in registers
    are represented in binary, it is best to view values in memory or in a register
    as *abstract numeric quantities*. Strings of symbols like 128, 80h, or 10000000b
    are not different numbers; they are simply different representations for the same
    abstract quantity that we refer to as *one hundred twenty-eight*. Inside the computer,
    a number is a number regardless of representation; the only time representation
    matters is when you input or output the value in a human-readable form.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以强烈论证内存或寄存器中的数字是以二进制表示的，但最好将内存或寄存器中的值视为*抽象的数值量*。像128、80h或10000000b这样的符号串并不是不同的数字；它们只是同一个抽象量的不同表示方式，我们称之为*一百二十八*。在计算机内部，数字就是数字，不管其表示方式如何；只有在输入或输出值时，表示方式才变得重要。
- en: Human-readable forms of numeric quantities are always strings of characters.
    To print the value 128 in human-readable form, you must convert the numeric value
    128 to the three-character sequence 1 followed by 2 followed by 8\. This would
    provide the decimal representation of the numeric quantity. If you prefer, you
    could convert the numeric value 128 to the three-character sequence 80h. It’s
    the same number, but we’ve converted it to a different sequence of characters
    because (presumably) we wanted to view the number using hexadecimal representation
    rather than decimal. Likewise, if we want to see the number in binary, we must
    convert this numeric value to a string containing a 1 followed by seven 0 characters.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 可读的人类格式的数值总是字符的串。要以人类可读的格式打印值128，必须将数值128转换为字符序列“1”后跟“2”再跟“8”。这将提供数值量的十进制表示。如果你愿意，也可以将数值128转换为字符序列80h。这是相同的数字，但我们已将其转换为不同的字符序列，因为（假设）我们想用十六进制表示而不是十进制。同样，如果我们想看到这个数字的二进制表示，我们必须将这个数值转换为一个包含1和七个0字符的字符串。
- en: Pure assembly language has no generic print or write functions you can call
    to display numeric quantities as strings on your console. You could write your
    own procedures to handle this process (and this book considers some of those procedures
    later). For the time being, the MASM code in this book relies on the C Standard
    Library `printf()` function to display numeric values. Consider the program in
    [Listing 2-1](#listing2-1), which converts various values to their hexadecimal
    equivalents.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 纯汇编语言没有通用的打印或写入函数，无法调用它们将数字量以字符串形式显示在控制台上。你可以编写自己的过程来处理这个过程（本书稍后会讨论一些这样的过程）。目前，本书中的
    MASM 代码依赖于 C 标准库的 `printf()` 函数来显示数值。考虑一下 [清单 2-1](#listing2-1) 中的程序，它将各种值转换为其十六进制等价物。
- en: '[PRE0]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 2-1: Decimal-to-hexadecimal conversion program'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 2-1：十进制到十六进制转换程序
- en: '[Listing 2-1](#listing2-1) uses the generic *c.cpp* program from Chapter 1
    (and the generic *build.bat* batch file as well). You can compile and run this
    program by using the following commands at the command line:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 2-1](#listing2-1) 使用了第一章中的通用 *c.cpp* 程序（以及通用的 *build.bat* 批处理文件）。你可以通过以下命令在命令行中编译并运行该程序：'
- en: '[PRE1]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 2.4 Data Organization
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.4 数据组织
- en: In pure mathematics, a value’s representation may require an arbitrary number
    of bits. Computers, on the other hand, generally work with a specific number of
    bits. Common collections are single bits, groups of 4 bits (called *nibbles*),
    8 bits (*bytes*), 16 bits (*words*), 32 bits (*double words*, or *dwords*), 64
    bits (*quad words,* or *qwords*), 128 bits (*octal words,* or *owords*), and more.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯数学中，一个值的表示可能需要任意数量的位。然而，计算机通常使用特定数量的位。常见的集合包括单个位、4 位的组合（称为 *半字*）、8 位（*字节*）、16
    位（*字*）、32 位（*双字*，或 *双字节*）、64 位（*四字*，或 *四字节*）、128 位（*八字*，或 *八字节*）等等。
- en: 2.4.1 Bits
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.1 位
- en: The smallest unit of data on a binary computer is a single *bit*. With a single
    bit, you can represent any two distinct items. Examples include 0 or 1, true or
    false, and right or wrong. However, you are *not* limited to representing binary
    data types; you could use a single bit to represent the numbers 723 and 1245 or,
    perhaps, the colors red and blue, or even the color red and the number 3256\.
    You can represent *any* *two* different values with a single bit, but *only two*
    values with a single bit.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在二进制计算机中，数据的最小单位是单个位（*bit*）。通过一个位，你可以表示任何两个不同的项。例如，0 或 1，真或假，对或错。然而，你并*不*局限于表示二进制数据类型；你可以使用一个位来表示数字
    723 和 1245，或者可能是红色和蓝色，甚至是红色和数字 3256。你可以用一个位表示*任何* *两个* 不同的值，但*仅*能表示两个值。
- en: 'Different bits can represent different things. For example, you could use 1
    bit to represent the values 0 and 1, while a different bit could represent the
    values true and false. How can you tell by looking at the bits? The answer is
    that you can’t. This illustrates the whole idea behind computer data structures:
    *data is what you define it to be*. If you use a bit to represent a Boolean (true/false)
    value, then that bit (by your definition) represents true or false. However, you
    must be consistent. If you’re using a bit to represent true or false at one point
    in your program, you shouldn’t use that value to represent red or blue later.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的位可以表示不同的内容。例如，您可以使用 1 位来表示 0 和 1 的值，而另一位则可以表示 true 和 false 的值。你如何通过查看这些位来区分它们呢？答案是，你无法做到。这说明了计算机数据结构的整体概念：*数据是你定义的样子*。如果你使用一位来表示布尔（真/假）值，那么这位（按照你的定义）表示
    true 或 false。然而，你必须保持一致。如果你在程序的某一部分使用位来表示真或假，那么在之后的代码中不应再使用这个值来表示红色或蓝色。
- en: 2.4.2 Nibbles
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.2 半字
- en: 'A nibble is a collection of 4 bits. With a nibble, we can represent up to 16
    distinct values because a string of 4 bits has 16 unique combinations:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一个半字（nibble）是由 4 位组成的集合。通过一个半字，我们可以表示最多 16 个不同的值，因为 4 位的字符串有 16 种独特的组合：
- en: '[PRE2]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Nibbles are an interesting data structure because it takes 4 bits to represent
    a single digit in *binary-coded decimal (BCD)* numbers^([1](#c02-footnote-1))
    and hexadecimal numbers. In the case of hexadecimal numbers, the values 0, 1,
    2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, and F are represented with 4 bits. BCD
    uses 10 different digits (0, 1, 2, 3, 4, 5, 6, 7, 8 and 9) and also requires 4
    bits (because we can represent only eight different values with 3 bits, and the
    additional six values we can represent with 4 bits are never used in BCD representation).
    In fact, any 16 distinct values can be represented with a nibble, though hexadecimal
    and BCD digits are the primary items we can represent with a single nibble.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 半字节是一种有趣的数据结构，因为它需要4位来表示*二进制编码十进制（BCD）*数值^[1](#c02-footnote-1)和十六进制数。在十六进制数的情况下，0、1、2、3、4、5、6、7、8、9、A、B、C、D、E和F的值是用4位表示的。BCD使用10个不同的数字（0、1、2、3、4、5、6、7、8和9），同样需要4位（因为我们只能用3位表示8个不同的值，而用4位表示的6个额外的值在BCD表示中从不使用）。实际上，任何16个不同的值都可以用半字节表示，虽然十六进制和BCD数字是我们通常用单个半字节表示的主要项。
- en: 2.4.3 Bytes
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.3 字节
- en: Without question, the most important data structure used by the x86-64 microprocessor
    is the byte, which consists of 8 bits. Main memory and I/O addresses on the x86-64
    are all byte addresses. This means that the smallest item that can be individually
    accessed by an x86-64 program is an 8-bit value. To access anything smaller requires
    that we read the byte containing the data and eliminate the unwanted bits. The
    bits in a byte are normally numbered from 0 to 7, as shown in [Figure 2-1](#figure2-1).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，x86-64微处理器使用的最重要的数据结构就是字节，它由8位组成。在x86-64系统中，主存和I/O地址都是字节地址。这意味着x86-64程序可以单独访问的最小项是一个8位的值。要访问更小的数据项，必须读取包含该数据的字节并去除不需要的位。字节中的位通常按0到7的顺序编号，如[图2-1](#figure2-1)所示。
- en: '![f02001](image_fi/501089c02/f02001.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![f02001](image_fi/501089c02/f02001.png)'
- en: 'Figure 2-1: Bit numbering'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-1：位编号
- en: Bit 0 is the LO bit, or least significant bit, and bit 7 is the HO bit, or most
    significant bit of the byte. We’ll refer to all other bits by their number.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 位0是LO位，即最低有效位，位7是HO位，即字节的最高有效位。我们将按位号引用其他所有位。
- en: A byte contains exactly two nibbles (see [Figure 2-2](#figure2-2)).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字节正好包含两个半字节（见[图2-2](#figure2-2)）。
- en: '![f02002](image_fi/501089c02/f02002.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![f02002](image_fi/501089c02/f02002.png)'
- en: 'Figure 2-2: The two nibbles in a byte'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图2-2：字节中的两个半字节
- en: Bits 0 to 3 compose the *low-order nibble*, and bits 4 to 7 form the *high-order
    nibble*. Because a byte contains exactly two nibbles, byte values require two
    hexadecimal digits.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 位0到3组成*低位半字节*，而位4到7构成*高位半字节*。由于一个字节恰好包含两个半字节，因此字节值需要两个十六进制数字表示。
- en: Because a byte contains 8 bits, it can represent 2⁸ (256) different values.
    Generally, we’ll use a byte to represent numeric values in the range 0 through
    255, signed numbers in the range –128 through +127 (see “Signed and Unsigned Numbers”
    on page 62), ASCII IBM character codes, and other special data types requiring
    no more than 256 different values. Many data types have fewer than 256 items,
    so 8 bits are usually sufficient.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因为一个字节包含8位，它可以表示2⁸（256）个不同的值。通常，我们会用一个字节表示数值范围从0到255、带符号数值范围从-128到+127（见第62页的“带符号与无符号数”）、ASCII
    IBM字符编码以及其他需要不超过256个不同值的特殊数据类型。许多数据类型的项数少于256，所以8位通常足够。
- en: Because the x86-64 is a byte-addressable machine, it’s more efficient to manipulate
    a whole byte than an individual bit or nibble. So it’s more efficient to use a
    whole byte to represent data types that require no more than 256 items, even if
    fewer than 8 bits would suffice.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于x86-64是字节寻址的机器，操作整个字节比操作单独的位或半字节更高效。因此，使用一个完整的字节来表示不超过256项的数据类型是更高效的，即使使用少于8位的位数就足够。
- en: Probably the most important use for a byte is holding a character value. Characters
    typed at the keyboard, displayed on the screen, and printed on the printer all
    have numeric values. To communicate with the rest of the world, PCs typically
    use a variant of the *ASCII character set* or the *Unicode character set*. The
    ASCII character set has 128 defined codes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 字节的最重要用途之一可能就是存储字符值。在键盘上输入、在屏幕上显示以及在打印机上打印的字符都有对应的数字值。为了与外界进行通信，PC通常使用变种的*ASCII字符集*或*Unicode字符集*。ASCII字符集有128个已定义的编码。
- en: 'Bytes are also the smallest variable you can create in a MASM program. To create
    an arbitrary byte variable, you should use the `byte` data type, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 字节也是你在 MASM 程序中可以创建的最小变量。要创建一个任意字节变量，你应该使用 `byte` 数据类型，如下所示：
- en: '[PRE3]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `byte` data type is a partially untyped data type. The only type information
    associated with a `byte` object is its size (1 byte).^([2](#c02-footnote-2)) You
    may store any 8-bit value (small signed integers, small unsigned integers, characters,
    and the like) into a byte variable. It is up to you to keep track of the type
    of object you’ve put into a byte variable.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`byte` 数据类型是一种部分未定义的数据类型。与 `byte` 对象相关联的唯一类型信息是其大小（1 字节）。^([2](#c02-footnote-2))
    你可以将任何 8 位值（小的有符号整数、小的无符号整数、字符等）存储到一个字节变量中。跟踪你存入字节变量中的对象类型完全由你决定。'
- en: 2.4.4 Words
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.4 字
- en: A word is a group of 16 bits. We’ll number the bits in a word from 0 to 15,
    as [Figure 2-3](#figure2-3) shows. Like the byte, bit 0 is the low-order bit.
    For words, bit 15 is the high-order bit. When referencing the other bits in a
    word, we’ll use their bit position number.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字是 16 位的一组数据。我们将字中的比特位从 0 到 15 编号，如[图 2-3](#figure2-3)所示。像字节一样，比特 0 是最低有效位。对于字，位
    15 是最高有效位。引用字中的其他比特位时，我们将使用它们的比特位位置编号。
- en: '![f02003](image_fi/501089c02/f02003.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![f02003](image_fi/501089c02/f02003.png)'
- en: 'Figure 2-3: Bit numbers in a word'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-3：一个字中的比特位
- en: A word contains exactly 2 bytes (and, therefore, four nibbles). Bits 0 to 7
    form the low-order byte, and bits 8 to 15 form the high-order byte (see Figures
    2-4 and 2-5).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个字正好包含 2 个字节（因此包含四个半字）。比特 0 到 7 形成低位字节，比特 8 到 15 形成高位字节（参见图 2-4 和 2-5）。
- en: '![f02004](image_fi/501089c02/f02004.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![f02004](image_fi/501089c02/f02004.png)'
- en: 'Figure 2-4: The 2 bytes in a word'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-4：一个字中的 2 个字节
- en: '![f02005](image_fi/501089c02/f02005.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![f02005](image_fi/501089c02/f02005.png)'
- en: 'Figure 2-5: Nibbles in a word'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-5：字中的半字
- en: With 16 bits, you can represent 2^(16) (65,536) values. These could be the values
    in the range 0 to 65,535 or, as is usually the case, the signed values –32,768
    to +32,767, or any other data type with no more than 65,536 values.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 16 位，你可以表示 2^(16)（65,536）个值。这些值可以是 0 到 65,535 的范围，或者通常情况下，是 -32,768 到 +32,767
    的有符号值，或者其他值数不超过 65,536 的数据类型。
- en: The three major uses for words are short signed integer values, short unsigned
    integer values, and Unicode characters. Unsigned numeric values are represented
    by the binary value corresponding to the bits in the word. Signed numeric values
    use the two’s complement form for numeric values (see “Sign Extension and Zero
    Extension” on page 67). As Unicode characters, words can represent up to 65,536
    characters, allowing the use of non-Roman character sets in a computer program.
    Unicode is an international standard, like ASCII, that allows computers to process
    non-Roman characters such as Kanji, Greek, and Russian characters.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 字的三大主要用途是短的有符号整数值、短的无符号整数值和 Unicode 字符。无符号数值由对应字中比特位的二进制值表示。有符号数值使用二进制补码形式表示（参见第
    67 页的“符号扩展和零扩展”）。作为 Unicode 字符，字可以表示最多 65,536 个字符，从而允许在计算机程序中使用非罗马字符集。Unicode
    是一种国际标准，类似于 ASCII，它允许计算机处理非罗马字符，如汉字、希腊字母和俄语字符。
- en: 'As with bytes, you can also create word variables in a MASM program. To create
    an arbitrary word variable, use the `word` data type as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 与字节一样，你也可以在 MASM 程序中创建字变量。要创建一个任意字变量，使用 `word` 数据类型，如下所示：
- en: '[PRE4]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 2.4.5 Double Words
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.5 双字
- en: 'A double word is exactly what its name indicates: a pair of words. Therefore,
    a double-word quantity is 32 bits long, as shown in [Figure 2-6](#figure2-6).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 双字正如其名所示：一对字。因此，双字长度为 32 位，如[图 2-6](#figure2-6)所示。
- en: '![f02006](image_fi/501089c02/f02006.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![f02006](image_fi/501089c02/f02006.png)'
- en: 'Figure 2-6: Bit numbers in a double word'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-6：双字中的比特位编号
- en: Naturally, this double word can be divided into a high-order word and a low-order
    word, 4 bytes, or eight different nibbles (see [Figure 2-7](#figure2-7)).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这个双字可以分为一个高位字和一个低位字，4 字节，或八个不同的半字（见[图 2-7](#figure2-7)）。
- en: Double words (dwords) can represent all kinds of things. A common item you will
    represent with a double word is a 32-bit integer value (which allows unsigned
    numbers in the range 0 to 4,294,967,295 or signed numbers in the range –2,147,483,648
    to 2,147,483,647). 32-bit floating-point values also fit into a double word.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 双字（dword）可以表示各种内容。一个常见的双字用途是表示 32 位整数值（允许无符号数字范围为 0 到 4,294,967,295 或有符号数字范围为
    -2,147,483,648 到 2,147,483,647）。32 位浮点值也可以存储在一个双字中。
- en: '![f02007a](image_fi/501089c02/f02007a.png)![f02007b](image_fi/501089c02/f02007b.png)![f02007c](image_fi/501089c02/f02007c.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![f02007a](image_fi/501089c02/f02007a.png)![f02007b](image_fi/501089c02/f02007b.png)![f02007c](image_fi/501089c02/f02007c.png)'
- en: 'Figure 2-7: Nibbles, bytes, and words in a double word'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2-7：双字中的字节、字和字节组
- en: 'You can create an arbitrary double-word variable by using the `dword` data
    type, as the following example demonstrates:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `dword` 数据类型来创建一个任意的双字变量，如以下示例所示：
- en: '[PRE5]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 2.4.6 Quad Words and Octal Words
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4.6 四字和八字
- en: 'Quad-word (64-bit) values are also important because 64-bit integers, pointers,
    and certain floating-point data types require 64 bits. Likewise, the SSE/MMX instruction
    set of modern x86-64 processors can manipulate 64-bit values. In a similar vein,
    octal-word (128-bit) values are important because the AVX/SSE instruction set
    can manipulate 128-bit values. MASM allows the declaration of 64- and 128-bit
    values by using the `qword` and `oword` types, as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 四字（64 位）值也很重要，因为 64 位整数、指针和某些浮点数据类型需要 64 位。同样，现代 x86-64 处理器的 SSE/MMX 指令集可以操作
    64 位值。类似地，八字（128 位）值也很重要，因为 AVX/SSE 指令集可以操作 128 位值。MASM 允许通过使用 `qword` 和 `oword`
    类型来声明 64 位和 128 位值，如下所示：
- en: '[PRE6]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You may not directly manipulate 128-bit integer objects using standard instructions
    like `mov`, `add`, and `sub` because the standard x86-64 integer registers process
    only 64 bits at a time. In Chapter 8, you will see how to manipulate these extended-precision
    values; Chapter 11 describes how to directly manipulate `oword` values by using
    SIMD instructions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能直接使用标准指令（如 `mov`、`add` 和 `sub`）来操作 128 位整数对象，因为标准的 x86-64 整数寄存器每次只能处理 64
    位。在第 8 章中，你将看到如何操作这些扩展精度值；第 11 章描述了如何通过使用 SIMD 指令直接操作 `oword` 值。
- en: 2.5 Logical Operations on Bits
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.5 位上的逻辑操作
- en: 'We’ll do four primary logical operations (Boolean functions) with hexadecimal
    and binary numbers: AND, OR, XOR (exclusive-or), and NOT.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进行四种主要的逻辑操作（布尔函数），使用十六进制和二进制数字：与、或、异或（XOR）和非（NOT）。
- en: 2.5.1 The AND Operation
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.1 与操作
- en: 'The *logical AND operation* is a *dyadic* operation (meaning it accepts exactly
    two operands).^([3](#c02-footnote-3)) These operands are individual binary bits.
    The AND operation is shown here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '*逻辑与操作*是一个*二元*操作（意味着它接受两个操作数）。^[3](#c02-footnote-3) 这些操作数是单独的二进制位。与操作如下所示：'
- en: '[PRE7]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: A compact way to represent the logical AND operation is with a truth table.
    A *truth table* takes the form shown in [Table 2-2](#table2-2).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 表示逻辑与操作的一种简洁方式是使用真值表。*真值表*的形式如[表 2-2](#table2-2)所示。
- en: 'Table 2-2: AND Truth Table'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-2：与真值表
- en: '| **AND** | **0** | **1** |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| **与** | **0** | **1** |'
- en: '| --- | --- | --- |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | 0 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 0 |'
- en: '| 1 | 0 | 1 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 1 |'
- en: This is just like the multiplication tables you’ve encountered in school. The
    values in the left column correspond to the left operand of the AND operation.
    The values in the top row correspond to the right operand of the AND operation.
    The value located at the intersection of the row and column (for a particular
    pair of input values) is the result of logically ANDing those two values together.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像你在学校遇到的乘法表一样。左列的值对应于与操作的左操作数，顶行的值对应于与操作的右操作数。位于行和列交点处的值（对于特定的输入值对）就是这两个值进行逻辑与操作后的结果。
- en: In English, the logical AND operation is, “If the first operand is 1 and the
    second operand is 1, the result is 1; otherwise, the result is 0.” We could also
    state this as, “If either or both operands are 0, the result is 0.”
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，逻辑与操作是：“如果第一个操作数为 1，第二个操作数为 1，则结果为 1；否则，结果为 0。”我们也可以这样表述：“如果任一或两个操作数为 0，结果为
    0。”
- en: 'You can use the logical AND operation to force a 0 result: if one of the operands
    is 0, the result is always 0 regardless of the other operand. In [Table 2-2](#table2-2),
    for example, the row labeled with a 0 input contains only 0s, and the column labeled
    with a 0 contains only 0s. Conversely, if one operand contains a 1, the result
    is exactly the value of the second operand. These results of the AND operation
    are important, particularly when we want to force bits to 0\. We will investigate
    these uses of the logical AND operation in the next section.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用逻辑与操作强制结果为 0：如果其中一个操作数为 0，则无论另一个操作数是什么，结果始终为 0。例如，在[表 2-2](#table2-2)中，标记为
    0 输入的行仅包含 0，标记为 0 的列也仅包含 0。相反，如果其中一个操作数为 1，结果则完全等于第二个操作数的值。这些与操作的结果非常重要，特别是当我们想要强制位为
    0 时。我们将在下一节中探讨这些逻辑与操作的使用。
- en: 2.5.2 The OR Operation
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.2 或操作
- en: 'The *logical OR operation* is also a dyadic operation. Its definition is as
    follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*逻辑 OR 运算* 也是一个二目运算。它的定义如下：'
- en: '[PRE8]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[Table 2-3](#table2-3) shows the truth table for the OR operation.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-3](#table2-3) 显示了 OR 运算的真值表。'
- en: 'Table 2-3: OR Truth Table'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-3：OR 真值表
- en: '| **OR** | **0** | **1** |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| **OR** | **0** | **1** |'
- en: '| --- | --- | --- |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | 1 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 |'
- en: '| 1 | 1 | 1 |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 1 |'
- en: Colloquially, the logical OR operation is, “If the first operand or the second
    operand (or both) is 1, the result is 1; otherwise, the result is 0.” This is
    also known as the *inclusive-or* operation.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通俗地说，逻辑 OR 运算可以表示为：“如果第一个操作数或第二个操作数（或两者）为 1，结果为 1；否则结果为 0。”这也被称为 *包含或* 运算。
- en: If one of the operands to the logical OR operation is a 1, the result is always
    1 regardless of the second operand’s value. If one operand is 0, the result is
    always the value of the second operand. Like the logical AND operation, this is
    an important side effect of the logical OR operation that will prove quite useful.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果逻辑 OR 运算的一个操作数是 1，结果始终为 1，无论第二个操作数的值如何。如果一个操作数为 0，结果始终是第二个操作数的值。与逻辑 AND 运算一样，这是逻辑
    OR 运算的一个重要副作用，将会非常有用。
- en: Note that there is a difference between this form of the inclusive logical OR
    operation and the standard English meaning. Consider the sentence “I am going
    to the store *or* I am going to the park.” Such a statement implies that the speaker
    is going to the store or to the park, but not to both places. Therefore, the English
    version of logical OR is slightly different from the inclusive-or operation; indeed,
    this is the definition of the *exclusive-or* operation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种形式的包含逻辑 OR 运算与标准的英文含义有所不同。考虑以下句子：“我去商店 *或者* 去公园。”这样的句子意味着说话者要么去商店，要么去公园，但不会同时去两个地方。因此，逻辑
    OR 的英文版本与包含或运算略有不同；实际上，这就是 *异或* 运算的定义。
- en: 2.5.3 The XOR Operation
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.3 XOR 运算
- en: 'The *logical* *XOR (**exclusive-or) operation* is also a dyadic operation.
    Its definition follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*逻辑* *XOR（**异或**运算）* 也是一个二目运算。它的定义如下：'
- en: '[PRE9]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[Table 2-4](#table2-4) shows the truth table for the XOR operation.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-4](#table2-4) 显示了 XOR 运算的真值表。'
- en: 'Table 2-4: XOR Truth Table'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-4：XOR 真值表
- en: '| **XOR** | **0** | **1** |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| **XOR** | **0** | **1** |'
- en: '| --- | --- | --- |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 0 | 1 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 1 |'
- en: '| 1 | 1 | 0 |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 0 |'
- en: In English, the logical XOR operation is, “If the first operand or the second
    operand, but not both, is 1, the result is 1; otherwise, the result is 0.” The
    exclusive-or operation is closer to the English meaning of the word *or* than
    is the logical OR operation.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在英语中，逻辑 XOR 运算是：“如果第一个操作数或第二个操作数，但不是两者，等于 1，结果为 1；否则结果为 0。”异或运算比逻辑 OR 运算更接近英语中
    *or* 这个词的含义。
- en: If one of the operands to the logical exclusive-or operation is a 1, the result
    is always the *inverse* of the other operand; that is, if one operand is 1, the
    result is 0 if the other operand is 1, and the result is 1 if the other operand
    is 0\. If the first operand contains a 0, the result is exactly the value of the
    second operand. This feature lets you selectively invert bits in a bit string.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果逻辑异或运算的一个操作数是 1，结果总是另一个操作数的 *反转*；也就是说，如果一个操作数是 1，另一个操作数是 1 时结果是 0，另一个操作数是
    0 时结果是 1。如果第一个操作数是 0，结果则完全是第二个操作数的值。这个特性让你可以选择性地反转位字符串中的位。
- en: 2.5.4 The NOT Operation
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5.4 NOT 运算
- en: 'The logical NOT operation is a *monadic operation* (meaning it accepts only
    one operand):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑 NOT 运算是一个 *单目运算*（意味着它只接受一个操作数）：
- en: '[PRE10]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The truth table for the NOT operation appears in [Table 2-5](#table2-5).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: NOT 运算的真值表见 [表 2-5](#table2-5)。
- en: 'Table 2-5: NOT Truth Table'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-5：NOT 真值表
- en: '| **NOT** | **0** | **1** |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **非** | **0** | **1** |'
- en: '| --- | --- | --- |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|  | 1 | 0 |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '|  | 1 | 0 |'
- en: 2.6 Logical Operations on Binary Numbers and Bit Strings
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.6 二进制数字和位字符串的逻辑运算
- en: The previous section defines the logical functions for single-bit operands.
    Because the x86-64 uses groups of 8, 16, 32, 64, or more bits,^([4](#c02-footnote-4))
    we need to extend the definition of these functions to deal with more than 2 bits.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节定义了单比特操作数的逻辑函数。由于 x86-64 使用的是 8、16、32、64 或更多比特的分组，^([4](#c02-footnote-4))
    我们需要扩展这些函数的定义，以处理超过 2 比特的情况。
- en: 'Logical functions on the x86-64 operate on a *bit-by-bit* (or *bitwise*) basis.
    Given two values, these functions operate on bit 0 of each value, producing bit
    0 of the result; then they operate on bit 1 of the input values, producing bit
    1 of the result, and so on. For example, if you want to compute the logical AND
    of the following two 8-bit numbers, you would perform the logical AND operation
    on each column independently of the others:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64上的逻辑函数是以*逐位*（或*按位*）的方式操作的。给定两个值，这些函数首先对每个值的第0位进行操作，生成结果的第0位；然后对输入值的第1位进行操作，生成结果的第1位，依此类推。例如，如果你想计算以下两个8位数的逻辑与，你需要在每一列上独立执行逻辑与操作：
- en: '[PRE11]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You may apply this bit-by-bit calculation to the other logical functions as
    well.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将这种逐位计算应用于其他逻辑函数。
- en: To perform a logical operation on two hexadecimal numbers, you should convert
    them to binary first.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 要对两个十六进制数执行逻辑操作，应该先将它们转换为二进制。
- en: The ability to force bits to 0 or 1 by using the logical AND/OR operations and
    the ability to invert bits using the logical XOR operation are very important
    when working with strings of bits (for example, binary numbers). These operations
    let you selectively manipulate certain bits within a bit string while leaving
    other bits unaffected.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用逻辑与/或操作强制位为0或1，以及通过使用逻辑异或操作反转位的能力，在处理位字符串时非常重要（例如二进制数）。这些操作使你能够选择性地操作位字符串中的某些位，而不影响其他位。
- en: For example, if you have an 8-bit binary value *X* and you want to guarantee
    that bits 4 to 7 contain 0s, you could logically AND the value *X* with the binary
    value 0000_1111b. This bitwise logical AND operation would force the HO 4 bits
    to 0 and pass the LO 4 bits of *X* unchanged. Likewise, you could force the LO
    bit of *X* to 1 and invert bit 2 of *X* by logically ORing *X* with 0000_0001b
    and logically XORing *X* with 0000_0100b, respectively.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个8位二进制值*X*，并且你想保证第4到第7位是0，你可以将值*X*与二进制值0000_1111b进行逻辑与操作。这个按位逻辑与操作会将高4位强制为0，并保持低4位的*X*不变。同样，你可以通过分别将*X*与0000_0001b进行逻辑或操作和将*X*与0000_0100b进行逻辑异或操作，强制*X*的低位为1，并反转*X*的第2位。
- en: Using the logical AND, OR, and XOR operations to manipulate bit strings in this
    fashion is known as *masking* bit strings. We use the term *masking* because we
    can use certain values (1 for AND, 0 for OR/XOR) to mask out or mask in certain
    bits from the operation when forcing bits to 0, 1, or their inverse.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逻辑与、或和异或操作按这种方式操作位字符串，称为*掩码*位字符串。我们使用*掩码*这个术语，因为我们可以使用某些值（逻辑与的1，逻辑或/异或的0）来掩盖或暴露操作中的某些位，强制某些位为0、1或其反值。
- en: 'The x86-64 CPUs support four instructions that apply these bitwise logical
    operations to their operands. The instructions are `and`, `or`, `xor`, and `not`.
    The `and`, `or`, and `xor` instructions use the same syntax as the `add` and `sub`
    instructions:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64 CPUs支持四条指令，将这些按位逻辑操作应用于其操作数。这些指令是`and`、`or`、`xor`和`not`。`and`、`or`和`xor`指令使用与`add`和`sub`指令相同的语法：
- en: '[PRE12]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These operands have the same limitations as the `add` operands. Specifically,
    the `source` operand has to be a constant, memory, or register operand, and the
    `dest` operand must be a memory or register operand. Also, the operands must be
    the same size and cannot both be memory operands. If the destination operand is
    64 bits and the source operand is a constant, that constant is limited to 32 bits
    (or fewer), and the CPU will sign-extend the value to 64 bits (see “Sign Extension
    and Zero Extension” on page 67).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作数与 `add` 操作数具有相同的限制。具体来说，`source` 操作数必须是常量、内存或寄存器操作数，而 `dest` 操作数必须是内存或寄存器操作数。此外，操作数必须具有相同的大小，且不能同时为内存操作数。如果目标操作数是64位且源操作数是常量，则该常量限制为32位（或更少），CPU将对该值进行符号扩展至64位（参见第67页的“符号扩展与零扩展”）。
- en: 'These instructions compute the obvious bitwise logical operation via the following
    equation:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令通过以下公式计算明显的按位逻辑操作：
- en: '[PRE13]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The x86-64 logical `not` instruction, because it has only a single operand,
    uses a slightly different syntax. This instruction takes the following form:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64逻辑`not`指令，由于只有一个操作数，因此使用略有不同的语法。此指令的形式如下：
- en: '[PRE14]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This instruction computes the following result:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此指令计算出以下结果：
- en: '[PRE15]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `dest` operand must be a register or memory operand. This instruction inverts
    all the bits in the specified destination operand.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`dest` 操作数必须是寄存器或内存操作数。此指令将指定目标操作数中的所有位进行反转。'
- en: The program in [Listing 2-2](#listing2-2) inputs two hexadecimal values from
    the user and calculates their logical `and`, `or`, `xor`, and `not`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2-2](#listing2-2)中的程序从用户输入两个十六进制值，并计算它们的逻辑 `and`、`or`、`xor` 和 `not`。'
- en: '[PRE16]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 2-2: `and`, `or`, `xor`, and `not` example'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 2-2：`and`、`or`、`xor` 和 `not` 示例
- en: 'Here’s the result of building and running this code:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建并运行此代码后的结果：
- en: '[PRE17]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'By the way, you will often see the following “magic” instruction:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，你会经常看到以下“神奇”的指令：
- en: '[PRE18]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'XORing a register with itself sets that register to 0\. Except for 8-bit registers,
    the `xor` instruction is usually more efficient than moving the immediate constant
    into the register. Consider the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个寄存器与其自身做异或操作会将该寄存器设置为 0。除了 8 位寄存器外，`xor` 指令通常比将立即数移入寄存器更高效。请考虑以下情况：
- en: '[PRE19]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The savings are even greater when dealing with 64-bit registers (as the immediate
    constant `0` is 8 bytes long by itself).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 处理 64 位寄存器时，节省的空间更大（因为立即数 `0` 本身就是 8 字节长）。
- en: 2.7 Signed and Unsigned Numbers
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.7 有符号和无符号数
- en: Thus far, we’ve treated binary numbers as unsigned values. The binary number
    . . . 00000 represents 0, . . . 00001 represents 1, . . . 00010 represents 2,
    and so on toward infinity. With *n* bits, we can represent 2^(*n*) unsigned numbers.
    What about negative numbers? If we assign half of the possible combinations to
    the negative values, and half to the positive values and 0, with *n* bits we can
    represent the signed values in the range –2^(*n*)^(-1) to +2^(*n*)^(-1) –1\. So
    we can represent the negative values –128 to –1 and the non-negative values 0
    to 127 with a single 8-bit byte. With a 16-bit word, we can represent values in
    the range –32,768 to +32,767\. With a 32-bit double word, we can represent values
    in the range –2,147,483,648 to +2,147,483,647.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们将二进制数视为无符号值。二进制数 . . . 00000 代表 0，. . . 00001 代表 1，. . . 00010 代表 2，依此类推，直到无穷大。对于
    *n* 位，我们可以表示 2^(*n*) 个无符号数。那么负数呢？如果我们将可能的组合的一半分配给负值，另一半分配给正值和 0，那么使用 *n* 位，我们可以表示的有符号值范围是
    –2^(*n*)^(-1) 到 +2^(*n*)^(-1) –1。因此，我们可以使用单个 8 位字节表示负值 –128 到 –1 和非负值 0 到 127。使用
    16 位字，可以表示范围从 –32,768 到 +32,767 的值。使用 32 位双字，可以表示范围从 –2,147,483,648 到 +2,147,483,647
    的值。
- en: In mathematics (and computer science), the *complement method* encodes negative
    and non-negative (positive plus zero) numbers into two equal sets in such a way
    that they can use the same algorithm (or hardware) to perform addition and produce
    the correct result regardless of the sign.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学（和计算机科学）中，*补码方法*将负数和非负数（包括正数和零）编码为两个相等的集合，使得它们可以使用相同的算法（或硬件）进行加法运算，并无论符号如何都能得到正确的结果。
- en: The x86-64 microprocessor uses the *two’s complement* notation to represent
    signed numbers. In thissystem, the HO bit of a number is a *sign bit* (dividing
    the integers into two equal sets). If the sign bit is 0, the number is positive
    (or zero); if the sign bit is 1, the number is negative (taking a complement form,
    which I’ll describe in a moment). Following are some examples.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64 微处理器使用 *二进制补码* 表示有符号数。在这种系统中，数字的高位（HO 位）是 *符号位*（将整数分为两个相等的集合）。如果符号位为
    0，则该数为正数（或零）；如果符号位为 1，则该数为负数（采用补码形式，我稍后会描述）。以下是一些示例。
- en: 'For 16-bit numbers:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 16 位数：
- en: 8000h is negative because the HO bit is 1.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 8000h 是负数，因为高位（HO 位）为 1。
- en: 100h is positive because the HO bit is 0.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 100h 是正数，因为高位（HO 位）为 0。
- en: 7FFFh is positive.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7FFFh 是正数。
- en: 0FFFFh is negative.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0FFFFh 是负数。
- en: 0FFFh is positive.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0FFFh 是正数。
- en: If the HO bit is 0, the number is positive (or 0) and uses the standard binary
    format. If the HO bit is 1, the number is negative and uses the two’s complement
    form (which is the magic form that supports addition of negative and non-negative
    numbers with no special hardware).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果高位（HO 位）为 0，则该数为正数（或 0），并使用标准二进制格式。如果高位（HO 位）为 1，则该数为负数，并使用二进制补码形式（这就是支持负数和非负数加法的“神奇形式”，无需特殊硬件）。
- en: 'To convert a positive number to its negative, two’s complement form, you use
    the following algorithm:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要将正数转换为其负数的补码形式，使用以下算法：
- en: Invert all the bits in the number; that is, apply the logical NOT function.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反转数字中的所有位；也就是说，应用逻辑非（NOT）功能。
- en: Add 1 to the inverted result and ignore any carry out of the HO bit.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将反转结果加 1，并忽略高位（HO 位）中的进位。
- en: This produces a bit pattern that satisfies the mathematical definition of the
    complement form. In particular, adding negative and non-negative numbers using
    this form produces the expected result.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了满足补码形式数学定义的位模式。特别地，使用这种形式加法负数和非负数时会得到预期的结果。
- en: 'For example, to compute the 8-bit equivalent of –5:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，计算 -5 的 8 位等效值：
- en: 0000_0101b 5 (in binary).
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0000_0101b 5（以二进制表示）。
- en: 1111_1010b Invert all the bits.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1111_1010b 反转所有位。
- en: 1111_1011b Add 1 to obtain result.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1111_1011b 加 1 得到结果。
- en: 'If we take –5 and perform the two’s complement operation on it, we get our
    original value, 0000_0101b, back again:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们取 -5 并对其执行二的补码操作，我们会得到原始值 0000_0101b，再次返回：
- en: 1111_1011b Two’s complement for –5.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1111_1011b 对 -5 进行二的补码操作。
- en: 0000_0100b Invert all the bits.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0000_0100b 反转所有位。
- en: 0000_0101b Add 1 to obtain result (+5).
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0000_0101b 加 1 得到结果 (+5)。
- en: 'Note that if we add +5 and –5 together (ignoring any carry out of the HO bit),
    we get the expected result of 0:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果我们将 +5 和 –5 相加（忽略 HO 位的进位），我们得到预期的结果 0：
- en: '[PRE20]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following examples provide some positive and negative 16-bit signed values:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例提供了一些正负 16 位有符号值：
- en: '7FFFh: +32767, the largest 16-bit positive number'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '7FFFh: +32767，最大的 16 位正数'
- en: '8000h: –32768, the smallest 16-bit negative number'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '8000h: –32768，最小的 16 位负数'
- en: '4000h: +16384'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '4000h: +16384'
- en: 'To convert the preceding numbers to their negative counterpart (that is, to
    negate them), do the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要将上述数字转换为其负数对（即取反），请执行以下操作：
- en: '[PRE21]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 8000h inverted becomes 7FFFh. After adding 1, we obtain 8000h! Wait, what’s
    going on here? – (–32,768) is –32,768? Of course not. But the value +32,768 cannot
    be represented with a 16-bit signed number, so we cannot negate the smallest negative
    value.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 8000h 反转变为 7FFFh。加 1 后，我们得到 8000h！等一下，发生了什么？–（–32,768）等于 –32,768？当然不是。但值 +32,768
    不能用 16 位有符号数表示，所以我们不能取反最小的负值。
- en: 'Usually, you will not need to perform the two’s complement operation by hand.
    The x86-64 microprocessor provides an instruction, `neg` (*negate*), that performs
    this operation for you:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您不需要手动执行二的补码操作。x86-64 微处理器提供了一条指令，`neg`（*取反*），它为您执行此操作：
- en: '[PRE22]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This instruction computes `dest` `=` `-``dest``;` and the operand must be a
    memory location or a register. `neg` operates on byte-, word-, dword-, and qword-sized
    objects. Because this is a signed integer operation, it only makes sense to operate
    on signed integer values. The program in [Listing 2-3](#listing2-3) demonstrates
    the two’s complement operation and the `neg` instruction on signed 8-bit integer
    values.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 该指令计算 `dest` `=` `-``dest``; 操作数必须是一个内存位置或寄存器。`neg` 操作适用于字节、字、双字和四字大小的对象。因为这是一个有符号整数操作，所以只有对有符号整数值进行操作才有意义。位于[列表
    2-3](#listing2-3)中的程序演示了对有符号 8 位整数值执行二的补码操作和 `neg` 指令。
- en: '[PRE23]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 2-3: Two’s complement example'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 2-3: 二的补码示例'
- en: 'The following commands build and run the program in [Listing 2-3](#listing2-3):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令构建并运行[列表 2-3](#listing2-3)中的程序：
- en: '[PRE24]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Beyond the two’s complement operation (both by inversion/add 1 and using the
    `neg` instruction), this program demonstrates one new feature: user numeric input.
    *Numeric input* is accomplished by reading an input string from the user (using
    the `readLine()` function that is part of the *c.cpp* source file) and then calling
    the C Standard Library `atoi()` function. This function requires a single parameter
    (passed in RCX) that points to a string containing an integer value. It translates
    that string to the corresponding integer and returns the integer value in RAX.^([5](#c02-footnote-5))'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 除了二的补码操作（通过反转/加 1 和使用 `neg` 指令），此程序演示了一个新特性：用户数字输入。*数字输入* 是通过从用户读取输入字符串（使用 *c.cpp*
    源文件中的 `readLine()` 函数）然后调用 C 标准库中的 `atoi()` 函数实现的。此函数需要一个单一的参数（通过 RCX 传递），该参数指向一个包含整数值的字符串。它将该字符串转换为相应的整数，并返回整数值给
    RAX。^([5](#c02-footnote-5))
- en: 2.8 Sign Extension and Zero Extension
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.8 符号扩展与零扩展
- en: Converting an 8-bit two’s complement value to 16 bits, and conversely converting
    a 16-bit value to 8 bits, can be accomplished via *sign extension* and *contraction*
    operations.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 将 8 位二的补码值转换为 16 位，反之将 16 位值转换为 8 位，可以通过 *符号扩展* 和 *收缩* 操作来实现。
- en: To extend a signed value from a certain number of bits to a greater number of
    bits, copy the sign bit into all the additional bits in the new format. For example,
    to sign-extend an 8-bit number to a 16-bit number, copy bit 7 of the 8-bit number
    into bits 8 to 15 of the 16-bit number. To sign-extend a 16-bit number to a double
    word, copy bit 15 into bits 16 to 31 of the double word.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要将有符号值从一定数量的位扩展到更多的位，将符号位复制到新格式中所有额外的位。例如，要将一个 8 位数扩展为 16 位数，复制 8 位数的第 7 位到
    16 位数的第 8 到第 15 位。要将 16 位数扩展为双字，将第 15 位复制到双字的第 16 到第 31 位。
- en: You must use sign extension when manipulating signed values of varying lengths.
    For example, to add a byte quantity to a word quantity, you must sign-extend the
    byte quantity to a word before adding the two values. Other operations (multiplication
    and division, in particular) may require a sign extension to 32 bits; see [Table
    2-6](#table2-6).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作不同长度的有符号值时，必须使用符号扩展。例如，要将一个字节数值添加到一个字（word）数值中，必须将字节数值符号扩展为字，然后再将两个数值相加。其他操作（特别是乘法和除法）可能需要扩展到32位；见[表2-6](#table2-6)。
- en: 'Table 2-6: Sign Extension'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-6：符号扩展
- en: '| **8 Bits** | **16 Bits** | **32 Bits** |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| **8位** | **16位** | **32位** |'
- en: '| --- | --- | --- |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 80h | 0FF80h | 0FFFFFF80h |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 80h | 0FF80h | 0FFFFFF80h |'
- en: '| 28h | 0028h | 00000028h |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 28h | 0028h | 00000028h |'
- en: '| 9Ah | 0FF9Ah | 0FFFFFF9Ah |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 9Ah | 0FF9Ah | 0FFFFFF9Ah |'
- en: '| 7Fh | 007Fh | 0000007Fh |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 7Fh | 007Fh | 0000007Fh |'
- en: '|  | 1020h | 00001020h |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '|  | 1020h | 00001020h |'
- en: '|  | 8086h | 0FFFF8086h |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '|  | 8086h | 0FFFF8086h |'
- en: To extend an unsigned value to a larger one, you must zero-extend the value,
    as shown in [Table 2-7](#table2-7). *Zero extension* is easy—just store a 0 into
    the HO byte(s) of the larger operand. For example, to zero-extend the 8-bit value
    82h to 16 bits, you prepend a 0 to the HO byte, yielding 0082h.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 要将无符号值扩展为更大的数值，必须对该值进行零扩展，如[表2-7](#table2-7)所示。*零扩展*很简单——只需将0存入较大操作数的高字节（HO字节）即可。例如，要将8位值82h零扩展到16位，你只需在高字节前添加一个0，得到0082h。
- en: 'Table 2-7: Zero Extension'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-7：零扩展
- en: '| **8 Bits** | **16 Bits** | **32 Bits** |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| **8位** | **16位** | **32位** |'
- en: '| --- | --- | --- |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 80h | 0080h | 00000080h |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 80h | 0080h | 00000080h |'
- en: '| 28h | 0028h | 00000028h |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 28h | 0028h | 00000028h |'
- en: '| 9Ah | 009Ah | 0000009Ah |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| 9Ah | 009Ah | 0000009Ah |'
- en: '| 7Fh | 007Fh | 0000007Fh |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 7Fh | 007Fh | 0000007Fh |'
- en: '|  | 1020h | 00001020h |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '|  | 1020h | 00001020h |'
- en: '|  | 8086h | 00008086h |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '|  | 8086h | 00008086h |'
- en: 2.9 Sign Contraction and Saturation
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.9 标志收缩与饱和
- en: '*Sign* *contraction*, converting a value with a certain number of bits to the
    identical value with a fewer number of bits, is a little more troublesome. Given
    an *n*-bit number, you cannot always convert it to an *m*-bit number if *m* <
    *n*. For example, consider the value –448\. As a 16-bit signed number, its hexadecimal
    representation is 0FE40h. The magnitude of this number is too large for an 8-bit
    value, so you cannot sign-contract it to 8 bits (doing so would create an overflow
    condition).'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '*符号* *收缩*，即将某个具有特定位数的值转换为具有较少位数的相同值，稍微复杂一些。给定一个*n*位数值，如果*m* < *n*，并不是总能将其转换为*m*位数值。例如，考虑值–448。作为16位有符号数，它的十六进制表示为0FE40h。该数的绝对值太大，无法适应8位数值，因此不能进行8位符号收缩（这样做会导致溢出）。'
- en: 'To properly sign-contract a value, the HO bytes to discard must all contain
    either 0 or 0FFh, and the HO bit of your resulting value must match *every* bit
    you’ve removed from the number. Here are some examples (16 bits to 8 bits):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确地进行标志收缩，必须丢弃的高字节（HO字节）必须全部为0或0FFh，并且结果值的HO位必须与从数字中移除的*每个*位匹配。以下是一些示例（16位到8位）：
- en: 0FF80h can be sign-contracted to 80h.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0FF80h 可以进行符号收缩为80h。
- en: 0040h can be sign-contracted to 40h.
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0040h 可以进行符号收缩为40h。
- en: 0FE40h cannot be sign-contracted to 8 bits.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0FE40h 不能进行8位标志收缩。
- en: 0100h cannot be sign-contracted to 8 bits.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0100h 不能进行8位标志收缩。
- en: If you must convert a larger object to a smaller object, and you’re willing
    to live with loss of precision, you can use *saturation*. To convert a value via
    saturation, you copy the larger value to the smaller value if it is not outside
    the range of the smaller object. If the larger value is outside the range of the
    smaller value, you *clip* the value by setting it to the largest (or smallest)
    value within the range of the smaller object.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你必须将较大的对象转换为较小的对象，并且愿意接受精度损失，可以使用*饱和*。通过饱和转换值时，如果较大值在较小对象的范围内，则将较大值复制到较小值中。如果较大值超出了较小对象的范围，则通过将值裁剪到较小对象范围内的最大（或最小）值来*裁剪*该值。
- en: For example, when converting a 16-bit signed integer to an 8-bit signed integer,
    if the 16-bit value is in the range –128 to +127, you copy the LO byte of the
    16-bit object to the 8-bit object. If the 16-bit signed value is greater than
    +127, then you clip the value to +127 and store +127 into the 8-bit object. Likewise,
    if the value is less than –128, you clip the final 8-bit object to –128.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当将一个16位有符号整数转换为8位有符号整数时，如果16位值的范围在–128到+127之间，你只需将16位对象的低字节（LO字节）复制到8位对象。如果16位有符号值大于+127，则将值裁剪为+127，并将+127存储到8位对象中。同样，如果值小于–128，则将最终的8位对象裁剪为–128。
- en: Although clipping the value to the limits of the smaller object results in loss
    of precision, sometimes this is acceptable because the alternative is to raise
    an exception or otherwise reject the calculation. For many applications, such
    as audio or video processing, the clipped result is still recognizable, so this
    is a reasonable conversion.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管将值限制在较小对象的边界会导致精度损失，但有时这是可以接受的，因为替代方法是引发异常或以其他方式拒绝计算。对于许多应用程序，如音频或视频处理，裁剪后的结果仍然是可识别的，因此这是一个合理的转换。
- en: '2.10 Brief Detour: An Introduction to Control Transfer Instructions'
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.10 简短插曲：控制转移指令简介
- en: The assembly language examples thus far have limped along without making use
    of *conditional execution* (that is, the ability to make decisions while executing
    code). Indeed, except for the `call` and `ret` instructions, you haven’t seen
    any way to affect the straight-line execution of assembly code.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，汇编语言示例一直在没有使用*条件执行*（即，在执行代码时做出决策的能力）的情况下勉强进行。事实上，除了`call`和`ret`指令外，你还没有看到任何影响汇编代码顺序执行的方法。
- en: However, this book is rapidly approaching the point where meaningful examples
    require the ability to conditionally execute different sections of code. This
    section provides a brief introduction to the subject of conditional execution
    and transferring control to other sections of your program.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本书正迅速接近一个阶段，在这个阶段，意义深远的示例需要能够有条件地执行不同的代码部分。本节简要介绍了条件执行的主题以及将控制转移到程序其他部分的方法。
- en: 2.10.1 The jmp Instruction
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.10.1 `jmp`指令
- en: Perhaps the best place to start is with a discussion of the x86-64 unconditional
    transfer-of-control instruction—the `jmp` instruction. The `jmp` instruction takes
    several forms, but the most common form is
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 或许最好的开始方式是讨论x86-64无条件控制转移指令——`jmp`指令。`jmp`指令有几种形式，但最常见的形式是
- en: '[PRE25]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: where `statement_label` is an identifier attached to a machine instruction in
    your `.code` section. The `jmp` instruction immediately transfers control to the
    statement prefaced by the label. This is semantically equivalent to a `goto` statement
    in an HLL.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 其中，`statement_label`是附加在`.code`部分机器指令上的标识符。`jmp`指令会立即将控制转移到由标签前缀的语句。这在语义上等同于高级语言中的`goto`语句。
- en: 'Here is an example of a statement label in front of a `mov` instruction:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在`mov`指令前面加上语句标签的示例：
- en: '[PRE26]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Like all MASM symbols, statement labels have two major attributes associated
    with them: an address (which is the memory address of the machine instruction
    following the label) and a type. The type is `label`, which is the same type as
    a `proc` directive’s identifier.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有MASM符号一样，语句标签有两个主要属性：一个地址（即紧跟标签后的机器指令的内存地址）和一个类型。类型是`label`，与`proc`指令的标识符类型相同。
- en: 'Statement labels don’t have to be on the same physical source line as a machine
    instruction. Consider the following example:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 语句标签不必与机器指令位于同一物理源行。考虑以下示例：
- en: '[PRE27]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This example is semantically equivalent to the previous one. The value (address)
    bound to `anotherLabel` is the address of the machine instruction following the
    label. In this case, it’s still the `mov` instruction even though that `mov` instruction
    appears on the next line (it still follows the label without any other MASM statements
    that would generate code occurring between the label and the `mov` statement).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例在语义上等同于前一个示例。绑定到`anotherLabel`的值（地址）是紧跟标签后的机器指令的地址。在这种情况下，即使该`mov`指令出现在下一行，它仍然是`mov`指令（因为它仍然跟在标签后面，中间没有其他MASM语句生成代码）。
- en: Technically, you could also jump to a `proc` label instead of a statement label.
    However, the `jmp` instruction does not set up a return address, so if the procedure
    executes a `ret` instruction, the return location may be undefined. (Chapter 5
    explores return addresses in greater detail.)
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，你也可以跳转到`proc`标签，而不是语句标签。然而，`jmp`指令不会设置返回地址，因此如果过程执行`ret`指令，返回位置可能未定义。（第5章将更详细地探讨返回地址。）
- en: 2.10.2 The Conditional Jump Instructions
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.10.2 条件跳转指令
- en: Although the common form of the `jmp` instruction is indispensable in assembly
    language programs, it doesn’t provide any ability to conditionally execute different
    sections of code—hence the name *unconditional jump*.^([6](#c02-footnote-6)) Fortunately,
    the x86-64 CPUs provide a wide array of *conditional jump instructions* that,
    as their name suggests, allow conditional execution of code.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `jmp` 指令的常见形式在汇编语言程序中不可或缺，但它并不提供有条件地执行不同代码段的能力——因此称其为 *无条件跳转*。^([6](#c02-footnote-6))
    幸运的是，x86-64 CPU 提供了多种 *条件跳转指令*，顾名思义，这些指令允许条件性地执行代码。
- en: 'These instructions test the condition code bits (see “An Introduction to the
    Intel x86-64 CPU Family” in Chapter 1) in the FLAGS register to determine whether
    a branch should be taken. There are four condition code bits in the FLAGs register
    that these conditional jump instructions test: the carry, sign, overflow, and
    zero flags.^([7](#c02-footnote-7))'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这些指令测试 FLAGS 寄存器中的条件代码位（请参阅第 1 章中的《Intel x86-64 CPU 系列介绍》），以确定是否应进行分支。FLAGS
    寄存器中有四个条件代码位，这些条件跳转指令会测试它们：进位、符号、溢出和零标志。^([7](#c02-footnote-7))
- en: The x86-64 CPUs provide eight instructions that test each of these four flags
    (see [Table 2-8](#table2-8)). The basic operation of the conditional jump instructions
    is that they test a flag to see if it is set (`1`) or clear (`0`) and branch to
    a target label if the test succeeds. If the test fails, the program continues
    execution with the next instruction following the conditional jump instruction.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64 CPU 提供了八条指令，用于测试这四个标志中的每一个（请参阅 [表 2-8](#table2-8)）。条件跳转指令的基本操作是，它们测试一个标志，查看它是已设置（`1`）还是清除（`0`），如果测试成功，则跳转到目标标签。如果测试失败，程序将继续执行条件跳转指令后的下一条指令。
- en: 'Table 2-8: Conditional Jump Instructions That Test the Condition Code Flags'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-8：测试条件代码标志的条件跳转指令
- en: '| **Instruction** | **Explanation** |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **说明** |'
- en: '| --- | --- |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `jc` `label` | Jump if carry set. Jump to label if the carry flag is set
    (`1`); fall through if carry is clear (`0`). |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| `jc` `label` | 如果进位已设置，则跳转。如果进位标志已设置（`1`），则跳转到标签；如果进位标志清除（`0`），则继续执行。 |'
- en: '| `jnc` `label` | Jump if no carry. Jump to label if the carry flag is clear
    (`0`); fall through if carry is set (`1`). |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `jnc` `label` | 如果没有进位，则跳转。如果进位标志清除（`0`），则跳转到标签；如果进位标志已设置（`1`），则继续执行。 |'
- en: '| `jo` `label` | Jump if overflow. Jump to label if the overflow flag is set
    (`1`); fall through if overflow is clear (`0`). |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| `jo` `label` | 如果溢出，则跳转。如果溢出标志已设置（`1`），则跳转到标签；如果溢出标志清除（`0`），则继续执行。 |'
- en: '| `jno` `label` | Jump if no overflow. Jump to label if the overflow flag is
    clear (`0`); fall through if overflow is set (`1`). |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| `jno` `label` | 如果没有溢出，则跳转。如果溢出标志清除（`0`），则跳转到标签；如果溢出标志已设置（`1`），则继续执行。 |'
- en: '| `js` `label` | Jump if sign (negative). Jump to label if the sign flag is
    set (`1`); fall through if sign is clear (`0`). |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| `js` `label` | 如果符号（负数），则跳转。如果符号标志已设置（`1`），则跳转到标签；如果符号标志清除（`0`），则继续执行。 |'
- en: '| `jns` `label` | Jump if not sign. Jump to label if the sign flag is clear
    (`0`); fall through if sign is set (`1`). |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| `jns` `label` | 如果没有符号，则跳转。如果符号标志为清除（`0`），则跳转到标签；如果符号标志已设置（`1`），则继续执行。 |'
- en: '| `jz` `label` | Jump if zero. Jump to label if the zero flag is set (`1`);
    fall through if zero is clear (`0`). |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `jz` `label` | 如果为零，则跳转。如果零标志已设置（`1`），则跳转到标签；如果零标志清除（`0`），则继续执行。 |'
- en: '| `jnz` `label` | Jump if not zero. Jump to label if the zero flag is clear
    (`0`); fall through if zero is set (`1`). |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| `jnz` `label` | 如果不为零，则跳转。如果零标志清除（`0`），则跳转到标签；如果零标志已设置（`1`），则继续执行。 |'
- en: 'To use a conditional jump instruction, you must first execute an instruction
    that affects one (or more) of the condition code flags. For example, an unsigned
    arithmetic overflow will set the carry flag (and likewise, if overflow does not
    occur, the carry flag will be clear). Therefore, you could use the `jc` and `jnc`
    instructions after an `add` instruction to see if an (unsigned) overflow occurred
    during the calculation. For example:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用条件跳转指令，必须首先执行一个会影响一个（或多个）条件代码标志的指令。例如，无符号算术溢出将设置进位标志（同样，如果没有发生溢出，进位标志将被清除）。因此，可以在
    `add` 指令之后使用 `jc` 和 `jnc` 指令，以查看计算过程中是否发生了（无符号）溢出。例如：
- en: '[PRE28]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Not all instructions affect the flags. Of all the instructions we’ve looked
    at thus far (`mov`, `add`, `sub`, `and`, `or`, `not`, `xor`, and `lea`), only
    the `add`, `sub`, `and`, `or`, `xor`, and `not` instructions affect the flags.
    The `add` and `sub` instructions affect the flags as shown in [Table 2-9](#table2-9).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有的指令都会影响标志。在我们到目前为止看到的所有指令（`mov`、`add`、`sub`、`and`、`or`、`not`、`xor` 和 `lea`）中，只有
    `add`、`sub`、`and`、`or`、`xor` 和 `not` 指令会影响标志。`add` 和 `sub` 指令会按照 [表 2-9](#table2-9)
    所示的方式影响标志。
- en: 'Table 2-9: Flag Settings After Executing `add` or `sub`'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-9：执行 `add` 或 `sub` 后的标志设置
- en: '| **Flag** | **Explanation** |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| **标志** | **说明** |'
- en: '| --- | --- |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Carry | Set if an unsigned overflow occurs (for example, adding the byte
    values 0FFh and 01h). Clear if no overflow occurs. Note that subtracting 1 from
    0 will also clear the carry flag (that is, 0 – 1 is equivalent to 0 + (–1), and
    –1 is 0FFh in two’s complement form). |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 进位 | 如果发生无符号溢出，则设置该标志（例如，将字节值 0FFh 和 01h 相加）。如果没有溢出，则清除该标志。请注意，从 0 中减去 1
    也会清除进位标志（即，0 – 1 等同于 0 + （–1），而 –1 在二进制补码形式中表示为 0FFh）。 |'
- en: '| Overflow | Set if a signed overflow occurs (for example, adding the byte
    values 07Fh and 01h). Signed overflow occurs when the next-to-HO-bit overflows
    into the HO bit (for example, 7Fh becomes 80h, or 0FFh becomes 0, when dealing
    with byte-sized calculations). |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 溢出 | 如果发生带符号溢出，则设置该标志（例如，将字节值 07Fh 和 01h 相加）。带符号溢出发生在次高位（HO 位）溢出到最高位（HO 位）（例如，当处理字节大小的计算时，7Fh
    变为 80h，或 0FFh 变为 0）。 |'
- en: '| Sign | The sign flag is set if the HO bit of the result is set. The sign
    flag is clear otherwise (that is, the sign flag reflects the state of the HO bit
    of the result). |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 符号 | 如果结果的最高位（HO 位）被设置，则符号标志被设置。否则，符号标志清除（即，符号标志反映结果的 HO 位状态）。 |'
- en: '| Zero | The zero flag is set if the result of a computation produces 0; it
    is clear otherwise. |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 零 | 如果计算结果为 0，则设置零标志；否则，清除该标志。 |'
- en: The logical instructions (`and`, `or`, `xor`, and `not`) always clear the carry
    and overflow flags. They copy the HO bit of their result into the sign flag and
    set/clear the zero flag if they produce a zero/nonzero result.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑指令（`and`、`or`、`xor` 和 `not`）总是清除进位标志和溢出标志。它们将结果的最高位（HO 位）复制到符号标志，并在结果为零或非零时设置或清除零标志。
- en: In addition to the conditional jump instructions, the x86-64 CPUs also provide
    a set of conditional move instructions. Chapter 7 covers those instructions.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 除了条件跳转指令，x86-64 CPU 还提供了一组条件移动指令。第 7 章介绍了这些指令。
- en: 2.10.3 The cmp Instruction and Corresponding Conditional Jumps
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.10.3 `cmp` 指令与相应的条件跳转
- en: The `cmp` (*compare*) instruction is probably the most useful instruction to
    execute prior to a conditional jump. The compare instruction has the same syntax
    as the `sub` instruction and, in fact, it also subtracts the second operand from
    the first operand and sets the condition code flags based on the result of the
    subtraction.^([8](#c02-footnote-8)) But the `cmp` instruction doesn’t store the
    difference back into the first (destination) operand. The whole purpose of the
    `cmp` instruction is to set the condition code flags based on the result of the
    subtraction.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`cmp`（*比较*）指令可能是执行条件跳转前最有用的指令。比较指令与 `sub` 指令的语法相同，实际上，它也会从第一个操作数中减去第二个操作数，并根据减法结果设置条件码标志。^([8](#c02-footnote-8))
    但 `cmp` 指令不会将差值存回第一个（目标）操作数。`cmp` 指令的全部目的就是基于减法结果设置条件码标志。'
- en: Though you could use the `jc`/`jnc`, `jo`/`jno`, `js`/`jns`, and `jz`/`jnz`
    instructions immediately after a `cmp` instruction (to test how `cmp` has set
    the individual flags), the flag names don’t really mean much in the context of
    the `cmp` instruction. Logically, when you see the following instruction (note
    that the `cmp` instruction’s operand syntax is identical to the `add`, `sub`,
    and `mov` instructions),
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以在 `cmp` 指令之后立即使用 `jc`/`jnc`、`jo`/`jno`、`js`/`jns` 和 `jz`/`jnz` 指令（测试 `cmp`
    如何设置各个标志），但在 `cmp` 指令的上下文中，标志名称的含义并不重要。从逻辑上讲，当你看到以下指令时（注意，`cmp` 指令的操作数语法与 `add`、`sub`
    和 `mov` 指令相同），
- en: '[PRE29]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'you read this instruction as “compare the `left_operand` to the `right_operand`.”
    Questions you would normally ask after such a comparison are as follows:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将此指令理解为“将 `left_operand` 与 `right_operand` 进行比较。”你通常在比较后会问以下问题：
- en: Is the `left_operand` equal to the `right_operand`?
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left_operand` 是否等于 `right_operand`？'
- en: Is the `left_operand` not equal to the `right_operand`?
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left_operand` 是否不等于 `right_operand`？'
- en: Is the `left_operand` less than the `right_operand`?
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left_operand` 是否小于 `right_operand`？'
- en: Is the `left_operand` less than or equal to the `right_operand`?
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left_operand`是否小于或等于`right_operand`？'
- en: Is the `left_operand` greater than the `right_operand`?
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left_operand`是否大于`right_operand`？'
- en: Is the `left_operand` greater than or equal to the `right_operand`?
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`left_operand`是否大于或等于`right_operand`？'
- en: The conditional jump instructions presented thus far don’t (intuitively) answer
    any of these questions.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止介绍的条件跳转指令没有（直观地）回答这些问题。
- en: The x86-64 CPUs provide an additional set of conditional jump instructions,
    shown in [Table 2-10](#table2-10), that allow you to test for comparison conditions.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: x86-64 CPU提供了一组附加的条件跳转指令，如[表2-10](#table2-10)所示，允许你测试比较条件。
- en: 'Table 2-10: Conditional Jump Instructions for Use After a `cmp` Instruction'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-10：`cmp`指令后的条件跳转指令
- en: '| **Instruction** | **Flags tested** | **Explanation** |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| **指令** | **测试的标志** | **解释** |'
- en: '| --- | --- | --- |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `je` `label` | `ZF == 1` | Jump if equal. Transfers control to target label
    if the `left_operand` is equal to the `right_operand`. This is a synonym for `jz`,
    as the zero flag will be set if the two operands are equal (their subtraction
    produces a 0 result in that case). |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| `je` `标签` | `ZF == 1` | 如果相等则跳转。如果`left_operand`等于`right_operand`，则将控制转移到目标标签。这个指令与`jz`同义，因为如果两个操作数相等（它们的减法结果为0），则会设置零标志。
    |'
- en: '| `jne` `label` | `ZF == 0` | Jump if not equal. Transfers control to target
    label if the `left_operand` is not equal to the `right_operand`. This is a synonym
    for `jnz`, as the zero flag will be clear if the two operands are not equal (their
    subtraction produces a nonzero result in that case). |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| `jne` `标签` | `ZF == 0` | 如果不相等则跳转。如果`left_operand`不等于`right_operand`，则将控制转移到目标标签。这个指令与`jnz`同义，因为如果两个操作数不相等（它们的减法结果非零），则零标志会清除。
    |'
- en: '| `ja` `label` | `CF == 0` and `ZF == 0` | Jump if above. Transfers control
    to target label if the *unsigned* `left_operand` is greater than the *unsigned*
    `right_operand`. |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| `ja` `标签` | `CF == 0` 且 `ZF == 0` | 如果条件成立则跳转。如果*无符号*的`left_operand`大于*无符号*的`right_operand`，则将控制转移到目标标签。
    |'
- en: '| `jae` `label` | `CF == 0` | Jump if above or equal. Transfers control to
    target label if the *unsigned* `left_operand` is greater than or equal to the
    *unsigned* `right_operand`. This is a synonym for `jnc`, as it turns out that
    an unsigned overflow (well, underflow, actually) will not occur if the `left_operand`
    is greater than or equal to the `right_operand`. |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| `jae` `标签` | `CF == 0` | 如果大于或等于则跳转。如果*无符号*的`left_operand`大于或等于*无符号*的`right_operand`，则将控制转移到目标标签。这个指令与`jnc`同义，因为如果`left_operand`大于或等于`right_operand`，则不会发生无符号溢出（实际上是下溢）。
    |'
- en: '| `jb` `label` | `CF == 1` | Jump if below. Transfers control to target label
    if the *unsigned* `left_operand` is less than the *unsigned* `right_operand`.
    This is a synonym for `jc`, as it turns out that an unsigned overflow (well, underflow,
    actually) occurs if the `left_operand` is less than the `right_operand`. |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| `jb` `标签` | `CF == 1` | 如果小于则跳转。如果*无符号*的`left_operand`小于*无符号*的`right_operand`，则将控制转移到目标标签。这个指令与`jc`同义，因为如果`left_operand`小于`right_operand`，则会发生无符号溢出（实际上是下溢）。
    |'
- en: '| `jbe` `label` | `CF == 1` or `ZF == 1` | Jump if below or equal. Transfers
    control to target label if the *unsigned* `left_operand` is less than or equal
    to the *unsigned* `right_operand`. |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| `jbe` `标签` | `CF == 1` 或 `ZF == 1` | 如果小于或等于则跳转。如果*无符号*的`left_operand`小于或等于*无符号*的`right_operand`，则将控制转移到目标标签。
    |'
- en: '| `jg` `label` | `SF == OF` and `ZF == 0` | Jump if greater. Transfers control
    to target label if the *signed* `left_operand` is greater than the *signed* `right_operand`.
    |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| `jg` `标签` | `SF == OF` 且 `ZF == 0` | 如果大于则跳转。如果*有符号*的`left_operand`大于*有符号*的`right_operand`，则将控制转移到目标标签。
    |'
- en: '| `jge` `label` | `SF == OF` | Jump if greater or equal. Transfers control
    to target label if the *signed* `left_operand` is greater than or equal to the
    *signed* `right_operand`. |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| `jge` `标签` | `SF == OF` | 如果大于或等于则跳转。如果*有符号*的`left_operand`大于或等于*有符号*的`right_operand`，则将控制转移到目标标签。
    |'
- en: '| `jl` `label` | `SF ≠ OF` | Jump if less. Transfers control to target label
    if the *signed* `left_operand` is less than the *signed* `right_operand`. |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| `jl` `标签` | `SF ≠ OF` | 如果小于则跳转。如果*有符号*的`left_operand`小于*有符号*的`right_operand`，则将控制转移到目标标签。
    |'
- en: '| `jle` `label` | `ZF == 1` or'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '| `jle` `标签` | `ZF == 1` 或'
- en: '`SF ≠ OF` | Jump if less or equal. Transfers control to target label if the
    *signed* `left_operand` is less than or equal to the *signed* `right_operand`.
    |'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`SF ≠ OF` | 如果小于或等于则跳转。如果*有符号*的`left_operand`小于或等于*有符号*的`right_operand`，则将控制转移到目标标签。
    |'
- en: Perhaps the most important thing to note in [Table 2-10](#table2-10) is that
    separate conditional jump instructions test for signed and unsigned comparisons.
    Consider the two byte values 0FFh and 01h. From an unsigned perspective, 0FFh
    is greater than 01h. However, when we treat these as signed numbers (using the
    two’s complement numbering system), 0FFh is actually –1, which is clearly less
    than 1\. They have the same bit representations but two completely different comparison
    results when treating these values as signed or unsigned numbers.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 2.10.4 Conditional Jump Synonyms
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some of the instructions are synonyms for other instructions. For example, `jb`
    and `jc` are the same instruction (that is, they have the same numeric *machine
    code* encoding). This is done for convenience and readability’s sake. After a
    `cmp` instruction, `jb` is much more meaningful than `jc`, for example. MASM defines
    several synonyms for various conditional branch instructions that make coding
    a little easier. [Table 2-11](#table2-11) lists many of these synonyms.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 2-11: Conditional Jump Synonyms'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '| **Instruction** | **Equivalents** | **Description** |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
- en: '| `ja` | `jnbe` | Jump if above, jump if not below or equal. |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
- en: '| `jae` | `jnb`, `jnc` | Jump if above or equal, jump if not below, jump if
    no carry. |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
- en: '| `jb` | `jc`, `jnae` | Jump if below, jump if carry, jump if not above or
    equal. |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
- en: '| `jbe` | `jna` | Jump if below or equal, jump if not above. |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
- en: '| `jc` | `jb`, `jnae` | Jump if carry, jump if below, jump if not above or
    equal. |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
- en: '| `je` | `jz` | Jump if equal, jump if zero. |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
- en: '| `jg` | `jnle` | Jump if greater, jump if not less or equal. |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
- en: '| `jge` | `jnl` | Jump if greater or equal, jump if not less. |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
- en: '| `jl` | `jnge` | Jump if less, jump if not greater or equal. |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
- en: '| `jle` | `jng` | Jump if less or equal, jump if not greater. |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
- en: '| `jna` | `jbe` | Jump if not above, jump if below or equal. |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
- en: '| `jnae` | `jb`, `jc` | Jump if not above or equal, jump if below, jump if
    carry. |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
- en: '| `jnb` | `jae`, `jnc` | Jump if not below, jump if above or equal, jump if
    no carry. |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
- en: '| `jnbe` | `ja` | Jump if not below or equal, jump if above. |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
- en: '| `jnc` | `jnb`, `jae` | Jump if no carry, jump if no below, jump if above
    or equal. |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
- en: '| `jne` | `jnz` | Jump if not equal, jump if not zero. |'
  id: totrans-396
  prefs: []
  type: TYPE_TB
- en: '| `jng` | `jle` | Jump if not greater, jump if less or equal. |'
  id: totrans-397
  prefs: []
  type: TYPE_TB
- en: '| `jnge` | `jl` | Jump if not greater or equal, jump if less. |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
- en: '| `jnl` | `jge` | Jump if not less, jump if greater or equal. |'
  id: totrans-399
  prefs: []
  type: TYPE_TB
- en: '| `jnle` | `jg` | Jump if not less or equal, jump if greater. |'
  id: totrans-400
  prefs: []
  type: TYPE_TB
- en: '| `jnz` | `jne` | Jump if not zero, jump if not equal. |'
  id: totrans-401
  prefs: []
  type: TYPE_TB
- en: '| `jz` | `je` | Jump if zero, jump if equal. |'
  id: totrans-402
  prefs: []
  type: TYPE_TB
- en: 'There is a very important thing to note about the `cmp` instruction: it sets
    the flags only for integer comparisons (which will also cover characters and other
    types you can encode with an integer number). Specifically, it does not compare
    floating-point values and set the flags as appropriate for a floating-point comparison.
    To learn more about floating-point arithmetic (and comparisons), see “Floating-Point
    Arithmetic” in Chapter 6.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: 2.11 Shifts and Rotates
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another set of logical operations that applyto bit strings is the *shift* and
    *rotate* operations. These two categories can be further broken down into left
    shifts, left rotates, right shifts, and right rotates.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: The *shift-left operation* moves each bit in a bit string one position to the
    left, as shown in [Figure 2-8](#figure2-8).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '![f02008](image_fi/501089c02/f02008.png)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-8: Shift-left operation'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Bit 0 moves into bit position 1, the previous value in bit position 1 moves
    into bit position 2, and so on. We’ll shift a 0 into bit 0, and the previous value
    of the high-order bit will become the *carry* out of this operation.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'The x86-64 provides a shift-left instruction, `shl`, that performs this useful
    operation. The syntax for the `shl` instruction is shown here:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `count` operand is either the CL register or a constant in the range 0 to
    *n*, where *n* is one less than the number of bits in the destination operand
    (for example, *n* = 7 for 8-bit operands, *n* = 15 for 16-bit operands, *n* =
    31 for 32-bit operands, and *n* = 63 for 64-bit operands). The `dest` operand
    is a typical destination operand. It can be either a memory location or a register.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: When the `count` operand is the constant 1, the `shl` instruction does the operation
    shown in [Figure 2-9](#figure2-9).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '![f02009](image_fi/501089c02/f02009.png)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-9: `shl` by 1 operation'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 2-9](#figure2-9), the *C* represents the carry flag—that is, the
    HO bit shifted out of the operand moves into the carry flag. Therefore, you can
    test for overflow after a `shl` `dest``, 1` instruction by testing the carry flag
    immediately after executing the instruction (for example, by using `jc` and `jnc`).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: The `shl` instruction sets the zero flag based on the result (`z=1` if the result
    is zero, `z=0` otherwise). The `shl` instruction sets the sign flag if the HO
    bit of the result is 1\. If the shift count is 1, then `shl` sets the overflow
    flag if the HO bit changes (that is, you shift a 0 into the HO bit when it was
    previously 1, or shift a 1 in when it was previously 0); the overflow flag is
    undefined for all other shift counts.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: 'Shifting a value to the left one digit is the same thing as multiplying it
    by its radix (base). For example, shifting a decimal number one position to the
    left (adding a 0 to the right of the number) effectively multiplies it by 10 (the
    radix):'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: (`shl 1` means shift one digit position to the left.)
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Because the radix of a binary number is 2, shifting it left multiplies it by
    2\. If you shift a value to the left *n* times, you multiply that value by 2^(*n*).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: A *shift-right* operation works the same way, except we’re moving the data in
    the opposite direction. For a byte value, bit 7 moves into bit 6, bit 6 moves
    into bit 5, bit 5 moves into bit 4, and so on. During a right shift, we’ll move
    a 0 into bit 7, and bit 0 will be the carry out of the operation (see [Figure
    2-10](#figure2-10)).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '![f02010](image_fi/501089c02/f02010.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-10: Shift-right operation'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: 'As you would probably expect, the x86-64 provides a `shr` instruction that
    will shift the bits to the right in a destination operand. The syntax is similar
    to that of the `shl` instruction:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This instruction shifts a 0 into the HO bit of the destination operand; it shifts
    the other bits one place to the right (from a higher bit number to a lower bit
    number). Finally, bit 0 is shifted into the carry flag. If you specify a count
    of 1, the `shr` instruction does the operation shown in [Figure 2-11](#figure2-11).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '![f02011](image_fi/501089c02/f02011.png)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-11: `shr` by 1 operation'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: The `shr` instruction sets the zero flag based on the result (`ZF=1` if the
    result is zero, `ZF=0` otherwise). The `shr` instruction clears the sign flag
    (because the HO bit of the result is always 0). If the shift count is 1, `shl`
    sets the overflow flag if the HO bit changes (that is, you shift a 0 into the
    HO bit when it was previously 1, or shift a 1 in when it was previously 0); the
    overflow flag is undefined for all other shift counts.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: Because a left shift is equivalent to a multiplication by 2, it should come
    as no surprise that a right shift is roughly comparable to a division by 2 (or,
    in general, a division by the radix of the number). If you perform *n* right shifts,
    you will divide that number by 2^(*n*).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: However, a shift right is equivalent to only an *unsigned* division by 2\. For
    example, if you shift the unsigned representation of 254 (0FEh) one place to the
    right, you get 127 (7Fh), exactly what you would expect. However, if you shift
    the two’s complement representation of –2 (0FEh) to the right one position, you
    get 127 (7Fh), which is *not* correct. This problem occurs because we’re shifting
    a 0 into bit 7\. If bit 7 previously contained a 1, we’re changing it from a negative
    to a positive number. Not a good thing to do when dividing by 2.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the shift right as a division operator, we must define a third shift
    operation: *arithmetic shift right*.^([9](#c02-footnote-9)) This works just like
    the normal shift-right operation (a logical shift right) except, instead of shifting
    a 0 into the high-order bit, an arithmetic shift-right operation copies the HO
    bit back into itself; that is, during the shift operation, it does not modify
    the HO bit, as [Figure 2-12](#figure2-12) shows.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '![f02012](image_fi/501089c02/f02012.png)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-12: Arithmetic shift-right operation'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: An arithmetic shift right generally produces the result you expect. For example,
    if you perform the arithmetic shift-right operation on –2 (0FEh), you get –1 (0FFh).
    However, this operation always rounds the numbers to the closest integer that
    is *less than or equal to the actual result*. For example, if you apply the arithmetic
    shift-right operation on –1 (0FFh), the result is –1, not 0\. Because –1 is less
    than 0, the arithmetic shift-right operation rounds toward –1\. This is not a
    bug in the arithmetic shift-right operation; it just uses a different (though
    valid) definition of integer division.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'The x86-64 provides an arithmetic shift-right instruction, `sar` (*shift arithmetic
    right*). This instruction’s syntax is nearly identical to that of `shl` and `shr`:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The usual limitations on the count and destination operands apply. This instruction
    operates as shown in [Figure 2-13](#figure2-13) if the count is 1.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '![f02013](image_fi/501089c02/f02013.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-13: `sar` `dest``, 1` operation'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: The `sar` instruction sets the zero flag based on the result (`z=1` if the result
    is zero, and `z=0` otherwise). The `sar` instruction sets the sign flag to the
    HO bit of the result. The overflow flag should always be clear after a `sar` instruction,
    as signed overflow is impossible with this operation.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: The *rotate-left* and *rotate-right* operations behave like the shift-left and
    shift-right operations, except the bit shifted out from one end is shifted back
    in at the other end. [Figure 2-14](#figure2-14) diagrams these operations.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: '![f02014a](image_fi/501089c02/f02014a.png)![f02014b](image_fi/501089c02/f02014b.png)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-14: Rotate-left and rotate-right operations'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: 'The x86-64 provides `rol` (rotate left) and `ror` (rotate right) instructions
    that do these basic operations on their operands. The syntax for these two instructions
    is similar to the shift instructions:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If the shift count is 1, these two instructions copy the bit shifted out of
    the destination operand into the carry flag, as Figures 2-15 and 2-16 show.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '![f02015](image_fi/501089c02/f02015.png)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-15: `rol` `dest``, 1` operation'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: '![f02016](image_fi/501089c02/f02016.png)'
  id: totrans-451
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-16: `ror` `dest``, 1` operation'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the shift instructions, the rotate instructions do not affect the settings
    of the sign or zero flags. The OF flag is defined only for the 1-bit rotates;
    it is undefined in all other cases (except RCL and RCR instructions only: a zero-bit
    rotate does nothing—that is, it affects no flags). For left rotates, the OF flag
    is set to the exclusive-or of the original HO 2 bits. For right rotates, the OF
    flag is set to the exclusive-or of the HO 2 bits after the rotate.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: It is often more convenient for the rotate operation to shift the output bit
    through the carry and to shift the previous carry value back into the input bit
    of the shift operation. The x86-64 `rcl` (*rotate through carry left*) and `rcr
    (*rotate through carry right*) instructions achieve this for you. These instructions
    use the following syntax:`
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在旋转操作中，通过进位移动输出位并将前一个进位值移回到移位操作的输入位通常更加方便。x86-64的`rcl`（*通过进位左旋*）和`rcr`（*通过进位右旋*）指令为你实现了这一操作。这些指令使用以下语法：
- en: '[PRE35]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
