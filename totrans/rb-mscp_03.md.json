["```\nputs 2+2\n```", "```\n$ **ruby -e 'puts self'**\n => main\n```", "```\n10.times do\n  puts \"The quick brown fox jumps over the lazy dog.\"\nend\n```", "```\n    /**\n      @c put\n      @e put self.\n      @j スタックに self をプッシュする。\n     */\n    DEFINE_INSN\n    putself\n    ()\n    ()\n    (VALUE val)\n    {\n   val = GET_SELF();\n    }\n```", "```\n    INSN_ENTRY(putself){\n    {\n      VALUE val;\n      DEBUG_ENTER_INSN(\"putself\");\n   ADD_PC(1+0);\n      PREFETCH(GET_PC());\n      #define CURRENT_INSN_putself 1\n      #define INSN_IS_SC()     0\n      #define INSN_LABEL(lab)  LABEL_putself_##lab\n      #define LABEL_IS_SC(lab) LABEL_##lab##_##t\n      COLLECT_USAGE_INSN(BIN(putself));\n    {\n    #line 282 \"insns.def\"\n     val = GET_SELF();\n    #line 408 \"vm.inc\"\n      CHECK_VM_STACK_OVERFLOW(REG_CFP, 1);\n   PUSH(val);\n    #undef CURRENT_INSN_putself\n    #undef INSN_IS_SC\n    #undef INSN_LABEL\n    #undef LABEL_IS_SC\n      END_INSN(putself);}}}\n```", "```\ni = 0\nwhile i < ARGV[0].to_i\n  i += 1\nend\n```", "```\n$ **time ruby benchmark1.rb** 1\nruby benchmark1.rb 1  0.02s user 0.00s system 92% cpu 0.023 total\n```", "```\n$ **time ruby benchmark1.rb 10**\nruby benchmark1.rb 10  0.02s user 0.00s system 94% cpu 0.027 total\n```", "```\ndef display_string\n  str = \"Dynamic access.\"\n  10.times do\n    puts str\n  end\nend\n```", "```\ndef display_string\n  str = \"Dynamic access.\"\n  10.times do\n    10.times do\n      puts str\n    end\n  end\nend\n```", "```\n    /**\n      @c variable\n      @e Get local variable (pointed by `idx' and `level').\n         'level' indicates the nesting depth from the current block.\n      @j level, idx で指定されたローカル変数の値をスタックに置く。\n         level はブロックのネストレベルで、何段上かを示す。\n     */\n    DEFINE_INSN\n    getlocal\n    (lindex_t idx, rb_num_t level)\n    ()\n    (VALUE val)\n    {\n        int i, lev = (int)level;\n     VALUE *ep = GET_EP();\n\n        for (i = 0; i < lev; i++) {\n         ep = GET_PREV_EP(ep);\n        }\n     val = *(ep - idx);\n    }\n```", "```\nval = *(ep – idx);\n```", "```\ngetlocal 2, 1\n```", "```\n/fox/.match(\"The quick brown fox jumped over the lazy dog.\\n\")\nputs \"Value of $& in the top level scope: #{$&}\"\n```", "```\n$ **ruby regex.rb**\nValue of $& in the top level scope: fox\n```", "```\n    str = \"The quick brown fox jumped over the lazy dog.\\n\"\n /fox/.match(str)\n\n    def search(str)\n   /dog/.match(str)\n   puts \"Value of $& inside method: #{$&}\"\n    end\n    search(str)\n\n puts \"Value of $& in the top level scope: #{$&}\"\n```", "```\n$ **ruby regex_method.rb**\nValue of $& inside method: dog\nValue of $& in the top level scope: fox\n```", "```\nstr = \"The quick brown fox jumped over the lazy dog.\\n\"\n/fox/.match(str)\n\n2.times do\n  /dog/.match(str)\n  puts \"Value of $& inside block: #{$&}\"\nend\n\nputs \"Value of $& in the top-level scope: #{$&}\"\n```", "```\n$ **ruby regex_block.rb**\nValue of $& inside block: dog\nValue of $& inside block: dog\nValue of $& in the top-level scope: dog\n```", "```\n case '$':\n    lex_state = EXPR_END;\n    newtok();\n    c = nextc();\n switch (c) {\n   case '_':            /* $_: last read line string */\n        c = nextc();\n        if (parser_is_identchar()) {\n            tokadd('$');\n            tokadd('_');\n            break;\n        }\n        pushback(c);\n        c = '_';\n        /* fall through */\n   case '~':            /* $~: match-data */\n      case '*':            /* $*: argv */\n      case '$':            /* $$: pid */\n      case '?':            /* $?: last status */\n      case '!':            /* $!: error string */\n      case '@':            /* $@: error position */\n      case '/':            /* $/: input record separator */\n      case '\\\\':           /* $\\: output record separator */\n      case ';':            /* $;: field separator */\n      case ',':            /* $,: output field separator */\n      case '.':            /* $.: last read line number */\n      case '=':            /* $=: ignorecase */\n      case ':':            /* $:: load path */\n      case '<':            /* $<: reading filename */\n      case '>':            /* $>: default output handle */\n      case '\\\"':           /* $\": already loaded files */\n        tokadd('$');\n        tokadd(c);\n        tokfix();\n        set_yylval_name(rb_intern(tok()));\n        return tGVAR;\n```", "```\n case '&':                /* $&: last match */\n    case '`':                /* $`: string before last match */\n    case '\\'':               /* $': string after last match */\n    case '+':                /* $+: string matches last paren. */\n      if (last_state == EXPR_FNAME) {\n          tokadd('$');\n          tokadd(c);\n          goto gvar;\n      }\n      set_yylval_node(NEW_BACK_REF(c));\n      return tBACK_REF;\n```", "```\n case '1': case '2': case '3':\n    case '4': case '5': case '6':\n    case '7': case '8': case '9':\n      tokadd('$');\n   do {\n          tokadd(c);\n          c = nextc();\n      } while (c != -1 && ISDIGIT(c));\n      pushback(c);\n      if (last_state == EXPR_FNAME) goto gvar;\n      tokfix();\n      set_yylval_node(NEW_NTH_REF(atoi(tok()+1)));\n      return tNTH_REF;\n```"]