<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><section epub:type="chapter" role="doc-chapter" aria-labelledby="ch18">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_325" aria-label="325"/>&#13;
<hgroup>&#13;
&#13;
<h2 class="CHAPTER" id="ch18">&#13;
<span class="CN"><samp class="SANS_Futura_Std_Bold_Condensed_B_11">18</samp></span>&#13;
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">TOURS THROUGH GRAPHS</samp></span>&#13;
</h2>&#13;
</hgroup>&#13;
<figure class="opener"><img class="opener" src="../images/opener.jpg" role="presentation" alt="" width="386" height="386"/>&#13;
</figure>&#13;
<p class="ChapterIntro">The problem of designing an optimal sightseeing tour lends itself perfectly to a graph formulation. Depending on our travel preferences, we might want to visit each of a set of major landmarks exactly once, minimize the total distance we travel, or visit every shop-lined street in our destination city. Each of these formulations corresponds to a classic graph problem: planning paths through a graph.</p>&#13;
<p class="TX">In this chapter, we consider several variations of this core problem. <i>Hamiltonian paths</i> visit each node exactly once and can help us plan trips where we want to visit a discrete set of sites. Solving the <i>traveling salesperson problem</i> allows us to visit every site while minimizing the total distance we need to walk. Finally, <i>Eulerian paths</i> traverse each edge only once and can help us plan trips where we want to wander down each street without repetition.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_326" aria-label="326"/>These types of path-planning problems have a host of real-world applications beyond vacation planning, such as solving logistical problems within the shipping industry. Unfortunately, many also come with significant computational challenges. While the problem of computing Eulerian paths has an efficient computational solution, both Hamiltonian paths and the traveling salesperson problem are NP-hard. We build upon the techniques from the previous chapters to create exhaustive algorithms for solving these problems.</p>&#13;
<section epub:type="division" aria-labelledby="sec1">&#13;
&#13;
<h3 class="H1" id="sec1"><span id="h-253"/><samp class="SANS_Futura_Std_Bold_B_11">Hamiltonian Paths and Cycles</samp></h3>&#13;
<p class="TNI1">A <i>Hamiltonian path</i>, named after the mathematician William Hamilton, is a path through a graph that visits each node exactly once. We can view the problem in terms of itinerary planning for a thorough yet easily bored tourist. The tourist balances two competing goals. First, they need to ensure they visit every attraction in the city. They do not want to miss a single one. Second, they want to avoid the annoyance of seeing the same spot twice. After all, if you’ve seen a giant clock tower once, do you really need to see it again?</p>&#13;
<p class="TX"><a href="#fig18-1">Figure 18-1</a> shows a Hamiltonian path [0, 1, 2, 5, 4, 3] on a graph with six nodes. The path starts at node 0, progresses through nodes 1, 2, 5, and 4, and terminates at node 3. Each node is visited only once.</p>&#13;
<figure class="IMG"><img id="fig18-1" class="img40" src="../images/f18001.jpg" alt="A graph with six nodes. Arrows mark a path from node 0 through nodes 1, 2, 5, 4, and 3. The path ends at node 3." width="461" height="273"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-1: A Hamiltonian path</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">More useful for the tourist’s case is the <i>Hamiltonian cycle</i> (or circuit), which starts and ends at the same node while traveling to each node exactly once. While the tourist wants to avoid repeat destinations as much as possible, they want to both start and end the journey at their hotel—an acceptable trade-off for not having to carry their luggage through the city.</p>&#13;
<p class="TX">While the tourist example uses a predefined node (the hotel) as the starting and ending location, Hamiltonian cycles can start or end at any node in the graph. The example Hamiltonian cycle in <a href="#fig18-2">Figure 18-2</a> might start at node 0 or any of the other five nodes.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_327" aria-label="327"/>&#13;
<figure class="IMG"><img id="fig18-2" class="img40" src="../images/f18002.jpg" alt="A graph with six nodes. Arrows mark a path from node 0 through nodes 1, 2, 5, 4, and 3 to node 0." width="461" height="273"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-2: A Hamiltonian cycle</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Because the path in <a href="#fig18-2">Figure 18-2</a> forms a loop, all nodes along it must be reachable from themselves. As we will see, this same flexibility does not apply to Hamiltonian paths in general.</p>&#13;
<section epub:type="division" aria-labelledby="sec2">&#13;
&#13;
<h4 class="H2" id="sec2"><span id="h-254"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Validating Hamiltonian Paths</samp></h4>&#13;
<p class="TNI1">Determining whether a path is Hamiltonian requires us to check that each node is visited once. We define a checker function <samp class="SANS_TheSansMonoCd_W5Regular_11">is_hamiltonian_path()</samp> that takes a path as a list of visited nodes:</p>&#13;
<pre><code>def is_hamiltonian_path(g: Graph, path: list) -&gt; bool: &#13;
    num_nodes: int = len(path)&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if num_nodes != g.num_nodes:&#13;
        return False&#13;
&#13;
    visited: list = [False] * g.num_nodes&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> prev_node: int = path[0]&#13;
    visited[prev_node] = True&#13;
&#13;
    for step in range(1, num_nodes):&#13;
        next_node: int = path[step]&#13;
&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if not g.is_edge(prev_node, next_node):&#13;
            return False&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> if visited[next_node]:&#13;
            return False&#13;
&#13;
        visited[next_node] = True&#13;
        prev_node = next_node&#13;
&#13;
    return True&#13;
</code></pre>&#13;
<p class="TX">The code starts by checking for potential validity by confirming the path length is equal to the number of nodes in the graph <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. If there are fewer steps in the path, then not every node could have been visited. If there are more, then some node must have been visited more than once. This also handles the edge cases of an empty path and an empty graph.</p>&#13;
<p class="TX">If the path is non-empty, the code sets up the data structures to use a Boolean array tracking whether each node has been visited (<samp class="SANS_TheSansMonoCd_W5Regular_11">visited</samp>) and the previous node seen along the path (<samp class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp>). The algorithm starts the check by setting <samp class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp> to the first node in the path and marking it visited <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_328" aria-label="328"/>Most of the algorithm consists of a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop through the path. At each step, it checks for an edge between the previous node and current node <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>, then checks that the current node has not yet been visited <span class="CodeAnnotationCode" aria-label="annotation4">❹</span>. If either check fails, the path is not a valid Hamiltonian path, and the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. If both checks succeed, the algorithm marks the current node as seen and sets <samp class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp> to the current node. If the code makes it through the entire path, it knows that it has visited the same number of nodes as in the graph and has not visited any twice. It returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp> to indicate success.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec3">&#13;
&#13;
<h4 class="H2" id="sec3"><span id="h-255"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Hamiltonian Paths with Depth-First Search</samp></h4>&#13;
<p class="TNI1">While the problem of finding Hamiltonian paths is NP-hard, we can define an exhaustive search that, though costly, will find such paths. We use a variation of depth-first search that, instead of visiting each graph node once, explores all paths through a node.</p>&#13;
<p class="TX">Consider the graph in <a href="#fig18-3">Figure 18-3(a)</a>. This graph has the valid Hamiltonian path [0, 1, 3, 2, 4] shown in <a href="#fig18-3">Figure 18-3(b)</a>. However, the depth-first search from <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span> will not visit the nodes in this order but will explore node 2 before node 3.</p>&#13;
<figure class="IMG"><img id="fig18-3" class="img100" src="../images/f18003.jpg" alt="(A) shows a graph with five nodes and directed edges (0, 1), (1, 0), (1, 2), (1, 3), (2, 0), (2, 3), (2, 4), and (3, 2). (B) shows the same graph with the edges (0, 1), (1, 3), (3, 2), and (2, 4) bolded." width="1381" height="398"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-3: A Hamiltonian path that does not match the visit order of the depth-first search</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To find valid Hamiltonian paths, we must extend this depth-first search to backtrack and try different paths. The search must reset the nodes visited <i>after</i> the current node to unseen so that it can try different paths to get to those nodes.</p>&#13;
<p class="TX">The code for Hamiltonian depth-first search in <a href="#list18-1">Listing 18-1</a> uses the standard depth-first search with a few modifications.</p>&#13;
<span id="list18-1"/>&#13;
<pre><code>def hamiltonian_dfs_rec(g: Graph, current: int, path: list,&#13;
                        seen: list) -&gt; Union[list, None]: &#13;
    path.append(current)&#13;
    seen[current] = True&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if len(path) == g.num_nodes:&#13;
        return path&#13;
&#13;
    for edge in g.nodes[current].get_edge_list():&#13;
        n: int = edge.to_node&#13;
        if not seen[n]:&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> result: Union[list, None] = hamiltonian_dfs_rec(g, n, path, seen)<span role="doc-pagebreak" epub:type="pagebreak" id="pg_329" aria-label="329"/>&#13;
            if result is not None:&#13;
                return result&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> _ = path.pop()&#13;
    seen[current] = False&#13;
    return None&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-1: A recursive function for searching for Hamiltonian paths</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">hamiltonian_dfs_rec()</samp> function takes the graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>), the current node index (<samp class="SANS_TheSansMonoCd_W5Regular_11">current</samp>), the path so far as a list of nodes (<samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp>), and the Boolean list of nodes visited (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>). It returns a list of nodes representing the path if one is found and <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> otherwise. We must import <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp> from Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library to support the type hint of the return value.</p>&#13;
<p class="TX">The code starts by adding the current node to the path and marking it seen. It then checks whether it has visited <samp class="SANS_TheSansMonoCd_W5Regular_11">g.num_nodes</samp> unique nodes <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. If so, <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp> is a valid Hamiltonian path, and the function returns it.</p>&#13;
<p class="TX">The core search logic occurs when the path has yet to be completed. The code iterates over the outgoing edges with a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop and recursively tests unvisited neighbors <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>. If it finds a valid Hamiltonian path along any of these explorations (<samp class="SANS_TheSansMonoCd_W5Regular_11">result is not None</samp>), it returns the path immediately. In this case, the function exits without resetting either the nodes’ <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> value or the <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp> list because it will not continue testing alternate paths.</p>&#13;
<p class="TX">If the code makes it through each outgoing edge without finding a valid path, it backtracks to the previous node. The code removes the current node from the path and marks it unseen <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. This allows the search to visit the node via a different path. The code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> to indicate that it was unable to find a path along this branch.</p>&#13;
<p class="TX">We define a wrapper that initiates a search from each possible starting node:</p>&#13;
<pre><code>def hamiltonian_dfs(g: Graph) -&gt; Union[list, None]: &#13;
    seen: list = [False] * g.num_nodes&#13;
    for start in range(g.num_nodes):&#13;
        path: Union[list, None] = hamiltonian_dfs_rec(g, start, [], seen)&#13;
        if path is not None:&#13;
            return path&#13;
    return None&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">hamiltonian_dfs()</samp> function initializes the <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> list to all <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> and uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to start a recursive search from each starting node. As soon as it finds a path (a non-<samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> result), it returns that path. If it cannot find a valid Hamiltonian path using any starting node, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp>.</p>&#13;
<p class="TX"><a href="#fig18-4">Figure 18-4</a> shows an example of this updated search. When visiting node 1 in <a href="#fig18-4">Figure 18-4(a)</a>, the search has two options of where to go next, nodes 2 or 3. It starts by exploring node 2, as shown in <a href="#fig18-4">Figure 18-4(b)</a>, which leads to a dead end at node 3, which leaves node 4 unvisited. Unable to visit node 4, it has not found a valid Hamiltonian path. It must backtrack and try alternate paths.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_330" aria-label="330"/>&#13;
<figure class="IMG"><img id="fig18-4" class="img100" src="../images/f18004.jpg" alt="All four subfigures show the same directed graph with five nodes and directed edges (0, 1), (1, 0), (1, 2), (1, 3), (2, 0), (2, 3), (2, 4), and (3, 2). (A) shows edges (0, 1) bolded and nodes 0 and 1 shaded. (B) shows edges (0, 1), (1, 2), and (2, 3) bolded and nodes 0, 1, 2, and 3 shaded. (C) shows edges (0, 1), (1, 2), and (2, 4) bolded and nodes 0, 1, 2, and 4 shaded. (D) shows edges (0, 1), (1, 3), (3, 2), and (2, 4) bolded and nodes 0, 1, 2, 3, and 4 shaded." width="1372" height="922"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-4: The steps along the depth-first-based Hamiltonian path search</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The search backtracks to node 2. It marks node 3 unvisited because it is no longer including that node in its current path. The search considers the other paths out of node 2. It has already rejected the edge (2, 0) since it visited node 0 earlier. This leaves the edge (2, 4), as shown in <a href="#fig18-4">Figure 18-4(c)</a>. Unfortunately, taking this edge leads to a dead end, which does not visit node 3. It is blocked again.</p>&#13;
<p class="TX">The search must backtrack all the way to node 1 and try the path to node 3, as shown in <a href="#fig18-4">Figure 18-4(d)</a>. It resets both nodes 2 and 4 to unvisited and returns to the state shown in <a href="#fig18-4">Figure 18-4(a)</a>. This allows it to travel from node 3 to node 2 and on to node 4.</p>&#13;
<p class="TX">Unfortunately, it may be insufficient to perform a single depth-first search. Unlike Hamiltonian cycles, the starting node of the search can affect whether the search finds a Hamiltonian path. <a href="#fig18-5">Figure 18-5</a> shows a graph for which we can find Hamiltonian paths of [1, 0, 2] when starting from node 1 or [2, 0, 1] when starting from node 2, but no Hamiltonian path starting from node 0.</p>&#13;
<figure class="IMG"><img id="fig18-5" class="img40" src="../images/f18005.jpg" alt="The figure shows a graph with three nodes and edges (1, 0) and (0, 2)." width="461" height="85"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-5: A graph with no Hamiltonian path starting at node 0</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">To combat this problem, we can run a separate depth-first search using each possible starting node. We keep searching until we have exhausted all the starting nodes or found a valid path.</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec4">&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_331" aria-label="331"/>&#13;
<h3 class="H1" id="sec4"><span id="h-256"/><samp class="SANS_Futura_Std_Bold_B_11">The Traveling Salesperson Problem</samp></h3>&#13;
<p class="TNI1">The <i>traveling salesperson problem</i> is an extension to finding a Hamiltonian cycle that accounts for edge weights. Modeled after the problem of a traveling salesperson planning their itinerary through multiple cities, the goal of this problem is to find a path that (1) starts and ends at the same node, (2) travels to each node exactly once, and (3) minimizes the sum of the edge weights.</p>&#13;
<p class="TX"><a href="#fig18-6">Figure 18-6</a> shows an example graph (a) and the lowest-cost traveling salesperson route through it (b). Spending a few minutes manually trying different paths quickly reveals the difficulty of the problem: the number of possible paths explodes even for simple graphs like this one.</p>&#13;
<figure class="IMG"><img id="fig18-6" class="img100" src="../images/f18006.jpg" alt="(A) shows a weighted graph with 6 nodes and 11 undirected edges with weights: (0, 1) = 5, (0, 2) = 6, (0, 3) = 2, (1, 2) = 3, (1, 3) = 1, (1, 4) = 1, (1, 5) = 2, (2, 5) = 6, (3, 4) = 7, (3, 5) = 5, and (4, 5) = 1. (B) shows the same graph with the edges (0, 3), (3, 1), (1, 4), (4, 5), (5, 2), and (2, 0) bolded." width="1548" height="697"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-6: An example graph with 6 nodes and 11 edges (a) and an optimal traveling salesperson path (b)</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">The many concrete applications of this task to real-world routing problems make it critical in a range of domains such as shipping and logistics. Because of this importance, computer scientists and mathematicians have devoted significant time and effort to studying the traveling salesperson problem and have developed numerous approaches, including heuristic searches and approximation algorithms. In this section, we build off the approaches from previous sections and examine a single exhaustive approach based on depth-first search.</p>&#13;
<section epub:type="division" aria-labelledby="sec5">&#13;
&#13;
<h4 class="H2" id="sec5"><span id="h-257"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Depth-First Search</samp></h4>&#13;
<p class="TNI1">We can directly adapt the depth-first search algorithm from Hamiltonian paths to account for path cost. In doing so, we need to make three changes. First, since we are looking for cycles rather than paths, we update the algorithm to return to the starting node. Second, we no longer stop as soon as we have found the first valid result. Instead, we continue searching until we have evaluated all valid Hamiltonian cycles so that we can find the lowest-cost one. Third, we track the best path seen so far and its cost.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_332" aria-label="332"/>We define the algorithm to perform a depth-first search over paths, resetting each node’s <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> label as the search backtracks from that node. As with the search for Hamiltonian paths, this allows us to try alternate paths out of each node. Each time we reach the end of the recursion by completing a Hamiltonian cycle, we return a copy of the path and its cost. The calling function compares the paths and costs from each of the recursive calls and returns the best one.</p>&#13;
<p class="TX">Unlike the algorithm for Hamiltonian paths, we can begin this search from a single arbitrary node rather than from each starting node, since the result of the traveling salesperson problem is a cycle. The full cycle will have the same cost regardless of which node it uses as a starting and ending point.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec6">&#13;
&#13;
<h4 class="H2" id="sec6"><span id="h-258"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code</samp></h4>&#13;
<p class="TNI1">We base the code for the traveling salesperson problem on the code for Hamiltonian path search in <a href="#list18-1">Listing 18-1</a>. Again, we start with the recursive function, as shown in <a href="#list18-2">Listing 18-2</a>.</p>&#13;
<span id="list18-2"/>&#13;
<pre><code>def tsp_dfs_rec(g: Graph, path: list, seen: list, cost: float) -&gt; tuple: &#13;
    current: int = path[-1]&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if len(path) == g.num_nodes:&#13;
        last_edge: Union[Edge, None] = g.get_edge(current, path[0])&#13;
        if last_edge is not None:&#13;
            return (cost + last_edge.weight, path + [path[0]])&#13;
        else:&#13;
            return (math.inf, [])&#13;
&#13;
    best_path: list = []&#13;
    best_score: float = math.inf&#13;
    for edge in g.nodes[current].get_edge_list():&#13;
        n: int = edge.to_node&#13;
        if not seen[n]:&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> seen[n] = True&#13;
            path.append(n)&#13;
&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> result: tuple = tsp_dfs_rec(g, path, seen, cost + edge.weight)&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> seen[n] = False&#13;
            _ = path.pop()&#13;
&#13;
            if result[0] &lt; best_score:&#13;
                best_score = result[0]&#13;
                best_path = result[1]&#13;
&#13;
    return (best_score, best_path)&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-2: A recursive function for the traveling salesperson problem</samp></p>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">tsp_dfs_rec()</samp> function takes the graph (<samp class="SANS_TheSansMonoCd_W5Regular_11">g</samp>), the path so far (<samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp>), the Boolean list of nodes visited (<samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp>), and the cost so far (<samp class="SANS_TheSansMonoCd_W5Regular_11">cost</samp>). It extracts the index of the current node as the current final node in <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_333" aria-label="333"/>The function starts by considering the base case for the recursion where all the nodes have been visited <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. It checks whether the path can be made into a cycle by returning to the starting node (<samp class="SANS_TheSansMonoCd_W5Regular_11">path[0]</samp>). If so, the code returns a tuple with the cycle’s cost and a new copy of the full cycle (<samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">[path[0]]</samp>). If there is no edge back to the starting node, the code returns an infinite cost to indicate that it is not a valid cycle.</p>&#13;
<p class="TX">If the algorithm has more nodes to explore, the code iterates over the current node’s outgoing edges with a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop and recursively tests unvisited neighbors <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. Unlike in the code for Hamiltonian paths in <a href="#list18-1">Listing 18-1</a>, the code augments <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> and resets <span class="CodeAnnotationCode" aria-label="annotation4">❹</span> both the <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> list and <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp> in the calling function. This simplifies the earlier logic for the base case. After recursively exploring the neighbor, the code checks whether it has found a better result and, if so, saves it. It finishes by returning the best cost and cycle found through this branch.</p>&#13;
<p class="TX">We define a wrapper that sets up the data structures and initiates the search:</p>&#13;
<pre><code>def tsp_dfs(g: Graph) -&gt; tuple: &#13;
    if (g.num_nodes == 1):&#13;
        return (0.0, [0])&#13;
&#13;
    seen: list = [False] * g.num_nodes&#13;
    path: list = [0]&#13;
    seen[0] = True&#13;
&#13;
    return tsp_dfs_rec(g, path, seen, 0.0)&#13;
</code></pre>&#13;
<p class="TX">The code starts by checking the edge case where the graph has a single node and returns the appropriate answer. It then sets up the initial <samp class="SANS_TheSansMonoCd_W5Regular_11">seen</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">path</samp> lists for the search, starting the path at node 0 and marking it seen. Finally, it runs the search and returns the result.</p>&#13;
<p class="TX">The recursive function shown in <a href="#list18-2">Listing 18-2</a> is a basic implementation of the traveling salesperson algorithm. We could improve its efficiency with additional pruning. For example, we could prune the current path if its cost exceeds the best cost so far. Similarly, we could incorporate heuristics like exploring the neighbors in order of increasing edge weight to focus on potentially lower-cost paths. As noted earlier, the vast variety of optimizations and heuristics for the traveling salesperson problem far exceeds the scope of this chapter.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec7">&#13;
&#13;
<h4 class="H2" id="sec7"><span id="h-259"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example</samp></h4>&#13;
<p class="TNI1"><a href="#fig18-7">Figure 18-7</a> shows the results of running this search on the graph from <a href="#fig18-6">Figure 18-6(a)</a>. Each subfigure shows the base case where the algorithm has found a Hamiltonian cycle, with the path highlighted in bold and the cost listed below it.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_334" aria-label="334"/>&#13;
<figure class="IMG"><img id="fig18-7" class="img100" src="../images/f18007.jpg" alt="Fourteen subfigures show paths through the graph along with their costs. The first subfigure has bolded edges (0, 1), (1, 2), (2, 5), (5, 4), (4, 3), and (3, 0) and a cost of 24." width="1666" height="1670"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-7: The 14 Hamiltonian cycles explored during the depth-first search</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Each path appears in <a href="#fig18-7">Figure 18-7</a> multiple times because the algorithm will find the cycle in both directions. For example, the first subfigure corresponds to the path [0, 1, 2, 5, 4, 3, 0], while the second to last corresponds to the path [0, 3, 4, 5, 2, 1, 0].</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec8">&#13;
&#13;
<h3 class="H1" id="sec8"><span id="h-260"/><samp class="SANS_Futura_Std_Bold_B_11">Eulerian Paths and Cycles</samp></h3>&#13;
<p class="TNI1">An <i>Eulerian path</i>, which is named after the mathematician Leonhard Euler, is a path through a graph that traverses each edge exactly once. We can view the problem in terms of an efficient window-shopping tourist. Determined to survey all the stores in a city, our tourist searches for a <span role="doc-pagebreak" epub:type="pagebreak" id="pg_335" aria-label="335"/>path that will take them down every road exactly one time. They refuse to miss out on potential finds by skipping a road or to waste their time passing stores they have already seen. An <i>Eulerian cycle</i> is an Eulerian path that starts and ends at the same node, providing the ideal planning tool if the tourist wants to start and end at their hotel but is concerned about traveling each road exactly once.</p>&#13;
<blockquote>&#13;
<p class="Note"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>&#13;
</blockquote>&#13;
<p class="Note-TXT"><i>Remember that, as described in <a href="chapter3.xhtml">Chapter 3</a>, we are using the definition of path that is common in computer science texts and allows repeated nodes. This differs from the formal graph theory definition of a path, which does not allow for repeated nodes. In graph theory, this problem may be referred to as finding an</i> <span class="ROMAN">Eulerian trail.</span></p>&#13;
<p class="TX"><a href="#fig18-8">Figure 18-8</a> shows an Eulerian cycle on a graph with six nodes. The path starts at node 0 and consists of [0, 1, 2, 5, 1, 3, 4, 5, 3, 0]. While it revisits nodes, it traverses each of the nine edges only once. The tourist may pass through the same intersection multiple times but will venture past each street’s shop windows only a single time.</p>&#13;
<figure class="IMG"><img id="fig18-8" class="img30" src="../images/f18008.jpg" alt="A graph with six nodes. Arrows mark a path from node 0 through nodes 1, 2, 5, 1, 3, 4, 5, 3, and 0." width="461" height="378"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-8: An Eulerian cycle</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Not all graphs contain Eulerian paths. <a href="#fig18-9">Figure 18-9</a> shows an undirected graph where no Eulerian path is possible. After moving from node 1 to any other node, the search would need to use the same edge to return to node 1. Since nodes 0, 2, and 3 are connected only to node 1, any path through all edges would need to return to node 1.</p>&#13;
<figure class="IMG"><img id="fig18-9" class="img30" src="../images/f18009.jpg" alt="A graph with four nodes and edges (0, 1), (1, 2), and (1, 3)." width="461" height="273"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-9: A graph without an Eulerian path</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Leonhard Euler devised a simple and effective way to test whether a connected, undirected graph has an Eulerian cycle:</p>&#13;
<p class="EQ">A connected, undirected graph has an Eulerian cycle if and only if all nodes have an even degree.</p>&#13;
<p class="BodyContinued"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_336" aria-label="336"/>Using this test, we can define a helper function for testing if a graph both is fully connected and has an Eulerian cycle, as shown in <a href="#list18-3">Listing 18-3</a>.</p>&#13;
<span id="list18-3"/>&#13;
<pre><code>def has_eulerian_cycle(g: Graph) -&gt; bool: &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> components: list = dfs_connected_components(g)&#13;
    for i in range(g.num_nodes):&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> if components[i] != 0:&#13;
            return False&#13;
&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> degree: int = g.nodes[i].num_edges()&#13;
        if i in g.nodes[i].edges:&#13;
            degree += 1&#13;
        if degree % 2 == 1:&#13;
            return False&#13;
    return True&#13;
</code></pre>&#13;
<p class="CodeListingCaption"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 18-3: Checking if a graph is fully connected and has an Eulerian cycle</samp></p>&#13;
<p class="TX">The code starts by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">dfs_connected_components()</samp> function from <span class="Xref"><a href="chapter4.xhtml">Chapter 4</a></span> to label each node’s component <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. It then uses a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop to examine each node and check that it is part of the same component <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> and has an even degree.</p>&#13;
<p class="TX">For completeness, the degree computation in <samp class="SANS_TheSansMonoCd_W5Regular_11">has_eulerian_cycle()</samp> handles the case of undirected self-loops <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. As noted in <span class="Xref"><a href="chapter2.xhtml">Chapter 2</a></span>, edges forming self-loops in undirected graphs are counted twice for the degree, since they contact the node on each end.</p>&#13;
<p class="TX">If the code finds a disconnected component or a node with an odd degree, it immediately returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>. If it checks all nodes without a problem, it returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>.</p>&#13;
<section epub:type="division" aria-labelledby="sec9">&#13;
&#13;
<h4 class="H2" id="sec9"><span id="h-261"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Validating Eulerian Paths</samp></h4>&#13;
<p class="TNI1">To determine whether a path is a valid Eulerian cycle, we need to check that each edge is used a single time. We define a checker function that takes a path as a list of nodes:</p>&#13;
<pre><code>def is_eulerian_cycle(g: Graph, path: list) -&gt; bool: &#13;
    num_nodes: int = len(path)&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if num_nodes == 0:&#13;
        return g.num_nodes == 0&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> used: dict = {}&#13;
    for node in g.nodes:&#13;
        for edge in node.get_edge_list():&#13;
            used[(edge.from_node, edge.to_node)] = False&#13;
&#13;
    prev_node: int = path[0]&#13;
    for step in range(1, num_nodes):&#13;
        next_node: int = path[step]&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> if not g.is_edge(prev_node, next_node):&#13;
            return False&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> if used[(prev_node, next_node)]:&#13;
            return False<span role="doc-pagebreak" epub:type="pagebreak" id="pg_337" aria-label="337"/>&#13;
&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation5">❺</span> used[(prev_node, next_node)] = True&#13;
        if g.undirected:&#13;
            used[(next_node, prev_node)] = True&#13;
&#13;
        prev_node = next_node&#13;
&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation6">❻</span> for value in used.values():&#13;
        if not value:&#13;
            return False&#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation7">❼</span> return path[0] == path[-1]&#13;
</code></pre>&#13;
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">is_eulerian_cycle()</samp> code starts by checking the edge case of an empty path, which is assumed to be valid only if the graph has no nodes <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. If the path does have edges, the code builds a dictionary <samp class="SANS_TheSansMonoCd_W5Regular_11">used</samp> that maps each edge in the graph to a Boolean indicating whether that edge has been visited <span class="CodeAnnotationCode" aria-label="annotation2">❷</span>.</p>&#13;
<p class="TX">The main body of the code consists of a <samp class="SANS_TheSansMonoCd_W5Regular_11">for</samp> loop that walks the path, using a combination of the previous node (<samp class="SANS_TheSansMonoCd_W5Regular_11">prev_node</samp>) and the current node (<samp class="SANS_TheSansMonoCd_W5Regular_11">next_node</samp>) to identify the current edge. The function immediately returns <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> if the path uses an edge that does not exist <span class="CodeAnnotationCode" aria-label="annotation3">❸</span> or has already been traversed <span class="CodeAnnotationCode" aria-label="annotation4">❹</span>. Otherwise, the code marks the edges as visited <span class="CodeAnnotationCode" aria-label="annotation5">❺</span>, taking care to mark entries for both directions if the edges are undirected.</p>&#13;
<p class="TX">The code completes by checking that it has visited each of the edges and returning <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp> if it finds an unvisited edge <span class="CodeAnnotationCode" aria-label="annotation6">❻</span>. (Alternatively, we could structure the code to count the total number of edges and the number of edges seen, handling the undirected case correctly, and just compare the counts.) The function uses a final check that the start and end nodes are the same, meaning the path is a cycle <span class="CodeAnnotationCode" aria-label="annotation7">❼</span>.</p>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec10">&#13;
&#13;
<h4 class="H2" id="sec10"><span id="h-262"/><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Finding Eulerian Cycles with Hierholzer’s Algorithm</samp></h4>&#13;
<p class="TNI1">Unlike the previous two problems in this chapter, the problem of finding Eulerian cycles is not NP-hard, and there exists an efficient method for finding an Eulerian cycle in a graph. The mathematician Carl Hierholzer developed an algorithm for extracting the Eulerian cycle in graphs that have one. <i>Hierholzer’s algorithm</i> operates by repeatedly finding cycles over unused edges and removing those cycles from the graph. Since the algorithm requires that the graph does have an Eulerian cycle, we use the Euler’s degree-based test (and the code in <a href="#list18-3">Listing 18-3</a>) to precheck the graph.</p>&#13;
<p class="TX">The primary insight behind this approach is that if a graph has an Eulerian cycle, we can build this full cycle from a series of potentially smaller cycles. We call these smaller cycles <i>subloops</i> to distinguish them from the full Eulerian cycle. The algorithm starts by finding any cycle in the graph and removing its edges, which may leave some edges in the graph. Since the graph has a full Eulerian cycle that uses all the edges, the algorithm can insert these remaining edges into the full path by splicing in additional subloops that each start and end at the same node in the current path.</p>&#13;
<p class="TX"><a href="#fig18-10">Figure 18-10</a> shows an example of this algorithm. In <a href="#fig18-10">Figure 18-10(b)</a>, the search finds an initial cycle [0, 1, 2, 5, 3, 0] that uses five edges and visits the five shaded nodes. It then removes these edges, as shown in <a href="#fig18-10">Figure 18-10(c)</a>.</p>&#13;
<span role="doc-pagebreak" epub:type="pagebreak" id="pg_338" aria-label="338"/>&#13;
<figure class="IMG"><img id="fig18-10" class="img80" src="../images/f18010.jpg" alt="Four subfigures show the steps of Hierholzer’s algorithm. In (a), an initial graph is shown with six nodes and nine undirected edges (0, 1), (0, 3), (1, 2), (1, 3), (1, 5), (2, 5), (3, 4), (3, 5), and (4, 5). (B) shows the cycle [0, 1, 2, 5, 3, 0] with arrows indicating the traversed edges. (C) shows the graph with the traversed edges removed. (D) shows the graph with the cycle [1, 5, 4, 3, 1] highlighted." width="1127" height="885"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-10: The graph before (a), during the first step (b), after the first step (c), and during the second step (d) of Hierholzer’s algorithm</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX">Next, the algorithm looks for a cycle that starts and ends at one of the previously visited nodes but travels unused edges. <a href="#fig18-10">Figure 18-10(d)</a> shows the cycle [1, 5, 4, 3, 1]. We can splice this new loop into the full path by inserting it in place of the occurrence of node 1 for an overall path of [0, 1, 5, 4, 3, 1, 2, 5, 3, 0].</p>&#13;
<p class="TX">Depending on how the algorithm selects which node to visit next, different implementations can ultimately explore different subloops and produce different Eulerian cycles for the same graph. For example, the code in this section will explore the nodes in <a href="#fig18-10">Figure 18-10(a)</a> so as to produce the final Eulerian cycle from <a href="#fig18-8">Figure 18-8</a>: [0, 1, 2, 5, 1, 3, 4, 5, 3, 0].</p>&#13;
<p class="TX">To extract an Eulerian cycle from a graph, we must follow the subloops through the graph:</p>&#13;
<pre><code>def hierholzers(g: Graph) -&gt; Union[list, None]: &#13;
  <span class="CodeAnnotationCode-1" aria-label="annotation1">❶</span> if not has_eulerian_cycle(g):&#13;
        return None&#13;
&#13;
    g_r: Graph = g.make_copy()&#13;
    options: set = set([0])&#13;
    full_cycle: list = [0]&#13;
&#13;
    while len(options) &gt; 0:&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation2">❷</span> start: int = options.pop()&#13;
        current: int = start&#13;
        subcycle: list = [start]&#13;
&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation3">❸</span> while current != start or len(subcycle) == 1:&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation4">❹</span> neighbor: int = list(g_r.nodes[current].edges.keys())[0]<span role="doc-pagebreak" epub:type="pagebreak" id="pg_339" aria-label="339"/>&#13;
            subcycle.append(neighbor)&#13;
            g_r.remove_edge(current, neighbor)&#13;
&#13;
          <span class="CodeAnnotationCode-1" aria-label="annotation5">❺</span> new_num_edges: int = g_r.nodes[current].num_edges()&#13;
            if new_num_edges &gt; 0:&#13;
                options.add(current)&#13;
            elif new_num_edges == 0 and current in options:&#13;
                options.remove(current)&#13;
&#13;
            current = neighbor&#13;
&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation6">❻</span> if g_r.nodes[start].num_edges() == 0 and start in options:&#13;
            options.remove(start)&#13;
&#13;
        loc: int = full_cycle.index(start)&#13;
      <span class="CodeAnnotationCode-1" aria-label="annotation7">❼</span> full_cycle = full_cycle[0:loc] + subcycle + full_cycle[loc+1:]&#13;
&#13;
    return full_cycle&#13;
</code></pre>&#13;
<p class="TX">The code starts by confirming the graph has an Eulerian cycle using the <samp class="SANS_TheSansMonoCd_W5Regular_11">has_eulerian_cycle()</samp> function from <a href="#list18-3">Listing 18-3</a> <span class="CodeAnnotationCode" aria-label="annotation1">❶</span>. If this check fails, the code returns <samp class="SANS_TheSansMonoCd_W5Regular_11">None</samp> to indicate the lack of an Eulerian cycle. The code relies on importing <samp class="SANS_TheSansMonoCd_W5Regular_11">Union</samp> from the <samp class="SANS_TheSansMonoCd_W5Regular_11">typing</samp> library to support the type hints for multiple return types. If the check passes, the code sets up the initial data structures, including a full copy of the graph that can be modified (<samp class="SANS_TheSansMonoCd_W5Regular_11">g_r</samp>), a set of seen nodes that it can use as starting points for subloops (<samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp>), and a list that tracks the Eulerian cycle constructed so far (<samp class="SANS_TheSansMonoCd_W5Regular_11">full_cycle</samp>). The code will iteratively build up <samp class="SANS_TheSansMonoCd_W5Regular_11">full_cycle</samp> by following subloops and inserting them into <samp class="SANS_TheSansMonoCd_W5Regular_11">full_cycle</samp>.</p>&#13;
<p class="TX">The main body of the algorithm is a <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop that continues finding new cycles while there exists a visited node with unused edges (<samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp> is not empty). The <samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp> set provides a list of nodes from which the code can start a new subloop. The code pops an arbitrary node from <samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp> <span class="CodeAnnotationCode" aria-label="annotation2">❷</span> and starts traversing a cycle.</p>&#13;
<p class="TX">The code traverses the new cycle by using an inner <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop that explores until it has completed a circuit and returned to the cycle’s starting node <span class="CodeAnnotationCode" aria-label="annotation3">❸</span>. The loop condition also tests that the new cycle has taken at least one step before terminating. If <samp class="SANS_TheSansMonoCd_W5Regular_11">len(subcycle)</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">==</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">1</samp>, the loop continues because the path hasn’t gone anywhere yet. During each step of the cycle traversal, the code selects the first key in the current node’s <samp class="SANS_TheSansMonoCd_W5Regular_11">edges</samp> dictionary as its next destination to visit (<samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp>) <span class="CodeAnnotationCode" aria-label="annotation4">❹</span>. It adds <samp class="SANS_TheSansMonoCd_W5Regular_11">neighbor</samp> to the current loop being tracked and removes the edge from the copy of the graph.</p>&#13;
<p class="TX">The code updates <samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp> by considering the number of remaining edges from the current node <span class="CodeAnnotationCode" aria-label="annotation5">❺</span>. If there is at least one remaining edge, it adds the node to <samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp> to indicate there are other paths to take. In contrast, if the code has just deleted the last edge adjacent to the current node, the code removes that node from the <samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp>. After the inner <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop completes, the code similarly discards the starting node if it has no remaining edges <span class="CodeAnnotationCode" aria-label="annotation6">❻</span>.</p>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_340" aria-label="340"/>After completing the inner loop, the code also inserts <samp class="SANS_TheSansMonoCd_W5Regular_11">subcycle</samp> into <samp class="SANS_TheSansMonoCd_W5Regular_11">full_cycle</samp> <span class="CodeAnnotationCode" aria-label="annotation7">❼</span>. For simplicity’s sake, we use a linear time find (<samp class="SANS_TheSansMonoCd_W5Regular_11">index()</samp> function) and build a new copy of <samp class="SANS_TheSansMonoCd_W5Regular_11">full_cycle</samp>. With additional bookkeeping, we could use more efficient approaches to minimize the cost of this step.</p>&#13;
<p class="TX"><a href="#fig18-11">Figure 18-11</a> shows the operation of Hierholzer’s algorithm on a graph with eight nodes. <a href="#fig18-11">Figure 18-11(a)</a> shows the state of the graph, the <samp class="SANS_TheSansMonoCd_W5Regular_11">options</samp> set, and the <samp class="SANS_TheSansMonoCd_W5Regular_11">full_cycle</samp> list before the start of the algorithm. The remaining subfigures show the state of the algorithm after each iteration of the outer <samp class="SANS_TheSansMonoCd_W5Regular_11">while</samp> loop. Edges traversed and removed during that iteration are highlighted in bold.</p>&#13;
<p class="TX">We can visualize this algorithm in terms of an officer of a city’s tourism board planning a comprehensive tour. Their goal is to devise a path through the city that travels each street exactly once, giving visitors a full experience of the city without unnecessary repetition. They choose the city’s premier hotel as the starting location (node 0) and set out walking. Throughout their trip, they record each street they travel and visit intersections with untraveled roads.</p>&#13;
<p class="TX"><a href="#fig18-11">Figure 18-11(b)</a> illustrates the results of the tour planner’s first day. Taking untraveled roads, they complete a small cycle [0, 1, 2, 0] to arrive back at the hotel. At this point, they have no untraveled roads out of the current node. Undaunted by the number of streets left unexplored, they cross roads (0, 1), (1, 2), and (2, 0) off of their map. They also note that they could have taken different roads at intersections (that is, nodes) 1 and 2.</p>&#13;
<figure class="IMG"><img id="fig18-11" class="img100" src="../images/f18011.jpg" alt="Five subfigures show the state of Hierholzer’s algorithm at different points. In (A), the options set has element 0. In (B), the edges (0, 1), (1, 2), and (2, 0) are bolded. The options set has elements 1 and 2." width="1680" height="965"/>&#13;
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 18-11: The steps of Hierholzer’s algorithm on an example graph</samp></p></figcaption>&#13;
</figure>&#13;
<p class="TX"><span role="doc-pagebreak" epub:type="pagebreak" id="pg_341" aria-label="341"/>The next day, the planner ventures to one of the nodes with untraveled edges to explore from there. As shown in <a href="#fig18-11">Figure 18-11(c)</a>, they choose to start at node 1 because it was reachable on a previous cycle and had unexplored options. They complete another small cycle [1, 3, 4, 1] before returning to node 1 and discovering they have traversed all the adjacent streets. They update their map to remove roads (1, 3), (3, 4), and (4, 1) and note that there are unexplored streets branching out from intersections 2, 3, and 4. They splice today’s path into yesterday’s path at node 1, providing a combined path of [0, 1, 3, 4, 1, 2, 0].</p>&#13;
<p class="TX">The third day is similar, with the planner starting from node 2, as shown in <a href="#fig18-11">Figure 18-11(d)</a>. They complete the cycle [2, 4, 7, 2], delete the traveled streets, and extend the combined path to [0, 1, 3, 4, 1, 2, 4, 7, 2, 0]. As they follow that day’s tour, they notice that they have traveled all roads adjacent to nodes 2 and 4. They remove both nodes from their starting options, leaving only node 3.</p>&#13;
<p class="TX">The final day starts at node 3, as shown in Figure 18-12(e). The planner travels [3, 5, 6, 3] and splices it into the combined path for an Eulerian cycle of [0, 1, 3, 5, 6, 3, 4, 1, 2, 4, 7, 2, 0].</p>&#13;
</section>&#13;
</section>&#13;
<section epub:type="division" aria-labelledby="sec11">&#13;
&#13;
<h3 class="H1" id="sec11"><span id="h-263"/><samp class="SANS_Futura_Std_Bold_B_11">Why This Matters</samp></h3>&#13;
<p class="TNI1">The three problems discussed in this chapter—finding Hamiltonian and Eulerian paths and solving the traveling salesperson problem—have clear applications to a variety of real-world planning and optimization use cases. Rather than searching for a path from a given origin to a given destination like the problems in the previous two chapters, the problems covered here aim to find paths that visit each node or edge in the graph.</p>&#13;
<p class="TX">These problems provide a foundation on which to build more complex tasks. We could extend the Eulerian path problem by adding pairwise ordering constraints. For example, the tourist might need to visit the city’s welcome center and buy tickets before they can ride the gondolas. A company might partition their cities among five salespeople, requiring them to assign cities as well as paths to each employee. The three formulations from this chapter barely scratch the surface of the interesting and complex questions we can ask.</p>&#13;
<p class="TX">The problems in this chapter also demonstrate that the difficulty of solving seemingly similar problems can actually vary greatly. While the tasks of finding Eulerian and Hamiltonian paths have similar real-world analogies, their worst-case computational costs vary significantly. Recognizing and understanding these types of differences is important when considering which approaches to use when tackling a novel problem.</p>&#13;
</section>&#13;
</section>&#13;
</div>
</div>
</body></html>