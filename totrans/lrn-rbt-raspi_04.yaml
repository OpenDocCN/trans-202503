- en: '4'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '4'
- en: MAKING YOUR ROBOT MOVE
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 让你的机器人动起来
- en: AT THIS STAGE, YOU HAVE A SWEET-LOOKING RASPBERRY PI ROBOT THAT DOESN’T DO ANYTHING.
    . . YET! TO UNLOCK THE CAPABILITIES OF ALL THE HARDWARE YOU JUST WIRED UP, YOU’LL
    HAVE TO SINK YOUR TEETH INTO SOME MORE PROGRAMMING.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一阶段，你有一个外观很酷的树莓派机器人，但它现在什么都做不了…… 还！为了充分发挥你刚接好线的所有硬件功能，你将不得不深入一些编程工作。
- en: In this chapter, I’ll show you how to use the Python programming language to
    make your robot move. We’ll cover basic movement, making your robot remote-controlled,
    and varying its motor speed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我将向你展示如何使用Python编程语言让你的机器人动起来。我们将涵盖基本运动、让机器人实现遥控以及调整电机的速度。
- en: THE PARTS LIST
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部件清单
- en: 'Most of this chapter will be about coding the robot, but to enable remote control
    you’ll need a couple of parts later:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容将涉及如何编写代码来控制机器人，但为了实现遥控，你稍后需要一些配件：
- en: Nintendo Wii remote
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任天堂Wii遥控器
- en: Bluetooth dongle if you’re using a Pi older than a Model 3 or Zero W
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是比Pi 3或Zero W更早的版本，可能需要使用蓝牙加密狗
- en: UNDERSTANDING THE H-BRIDGE
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解H-桥
- en: Most single-motor controllers are based around an electronics concept called
    an *H-bridge*. The L293D motor driver chip we’re using contains two H-bridges,
    permitting you to control the two motors of your robot through a single chip.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数单电机控制器都基于一种叫做 *H-桥* 的电子概念。我们使用的L293D电机驱动芯片包含两个H-桥，允许通过一个芯片控制机器人上的两个电机。
- en: An H-bridge is an electronic circuit that allows a voltage to be applied across
    a load, usually a motor, in either direction. For the purposes of robotics, this
    means that an H-bridge circuit can drive a motor both *forward* and *backward*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: H-桥是一个电子电路，允许在负载（通常是电机）上施加电压，且电压方向可以是任意的。对于机器人应用而言，这意味着H-桥电路可以驱动电机 *正转* 和 *反转*。
- en: A single H-bridge is made of four electronic switches, built from transistors,
    arranged like S1, S2, S3, and S4 in [Figure 4-1](ch04.xhtml#ch04fig1). By manipulating
    these electronic switches, an H-bridge controls the forward and backward voltage
    flow of a single motor.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 单个H-桥由四个电子开关组成，采用晶体管构建，像[图4-1](ch04.xhtml#ch04fig1)中的S1、S2、S3和S4那样排列。通过操作这些电子开关，H-桥控制单个电机的正反电压流动。
- en: '![image](../images/f080-01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f080-01.jpg)'
- en: '**FIGURE 4-1** A single H-bridge circuit'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4-1** 单个H-桥电路'
- en: When all the switches are open, no voltage is applied to the motor and it doesn’t
    move. When only S1 and S4 are closed, there is a flow of current in one direction
    through the motor, making it spin. When only S3 and S2 are closed, a current flows
    in the opposite direction, making the motor spin the other way.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有开关都处于打开状态时，电机上不会施加电压，电机不会转动。当只有S1和S4闭合时，电流会在电机中一个方向流动，令电机旋转。当只有S3和S2闭合时，电流会在相反方向流动，使电机反向旋转。
- en: The design of the L293D means that we can’t close S1 and S2 at the same time.
    This is fortunate, as doing so would short-circuit the power, causing damage!
    The same is true of S3 and S4.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: L293D的设计意味着我们不能同时关闭S1和S2。幸运的是，若这样做会导致短路，从而损坏电路！S3和S4也有相同的问题。
- en: The L293D abstracts this one step further and requires only two inputs for one
    motor (four inputs for a pair of motors, like you wired up in [Chapter 3](ch03.xhtml)).
    The behavior of the motor depends on which inputs are high and which are low (1
    or 0, respectively). [Table 4-1](ch04.xhtml#ch04tab1) summarizes the different
    input options for the control of one motor.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: L293D将这一概念进一步抽象化，只需两个输入控制一个电机（对于一对电机，则需要四个输入，像你在[第3章](ch03.xhtml)中接线的那样）。电机的行为取决于哪些输入为高电平，哪些为低电平（分别为1和0）。[表4-1](ch04.xhtml#ch04tab1)总结了控制一个电机的不同输入选项。
- en: '**TABLE 4-1** Motor Behavior Based on Inputs'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4-1** 基于输入的电机行为'
- en: '| **INPUT 1** | **INPUT 2** | **MOTOR BEHAVIOR** |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| **输入 1** | **输入 2** | **电机行为** |'
- en: '| 0 | 0 | Motor off |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 0 | 电机关闭 |'
- en: '| 0 | 1 | Motor rotates in one direction |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 | 电机朝一个方向旋转 |'
- en: '| 1 | 0 | Motor rotates in other direction |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 0 | 电机朝另一个方向旋转 |'
- en: '| 1 | 1 | Motor off |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 | 电机关闭 |'
- en: We’ll use the GPIO Zero Python library to interface with the Pi’s GPIO pins
    and motor controller. There are several functions in the library for controlling
    basic movement, so you won’t have to worry about turning specific GPIO pins on
    and off yourself.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用GPIO Zero Python库与Pi的GPIO引脚和电机控制器进行接口。该库中有几个函数用于控制基本运动，因此你不必担心自己手动开启或关闭特定的GPIO引脚。
- en: FIRST MOVEMENT
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一次运动
- en: 'Now for the most exciting step of your robotics journey yet: moving your robot!
    You’ll eventually make your robot entirely remote-­controlled and even able to
    follow your instructions, but before that let’s master some basic motor functionality.
    You’ll start by programming your robot to move along a predefined route.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，进入你的机器人旅程中最激动人心的一步：让机器人动起来！你最终会让机器人完全遥控，甚至能够根据你的指令行动，但在那之前，先掌握一些基本的电机功能。你将从编程让机器人沿预定路线移动开始。
- en: Programming Your Robot with a Predefined Route
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 用预定路线编程你的机器人
- en: Boot up your Raspberry Pi on your robot and log in over SSH. While your robot
    is stationary and being programmed, it is best to disconnect your batteries and
    power your Pi from a micro USB cable connected to a wall outlet. This will save
    your batteries for when they are really needed.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 启动你的 Raspberry Pi 并通过 SSH 登录到你的机器人。 当机器人保持静止并进行编程时，最好断开电池连接，通过连接到墙壁插座的 micro
    USB 电缆为 Pi 供电。这样可以节省电池，等到真正需要时再使用。
- en: 'From the terminal, navigate from your home directory into the folder you are
    using to store your code. For me, I’ll navigate into my *robot* projects folder
    like so:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从终端中，导航到你的主目录下存储代码的文件夹。对我来说，我将导航到我的*robot*项目文件夹，命令如下：
- en: pi@raspberrypi:~ $ cd robot
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~ $ cd robot
- en: 'Next, create a new Python program and edit it in the Nano text editor with
    the following command; I have called my program *first_move.py*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的 Python 程序，并使用以下命令在 Nano 文本编辑器中编辑它；我将我的程序命名为 *first_move.py*：
- en: pi@raspberrypi:~/robot $ nano first_move.py
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ nano first_move.py
- en: Now you need to come up with a predefined route to program! With the DC motors
    we’re using, you *can’t* rotate them a specific distance or number of steps, but
    you *can* power them on and off for a certain amount of time. This means that
    any path will be a rough approximation of where you want your robot to go rather
    than a precise plan.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要为编程制定一个预定的路线！对于我们使用的直流电机，你*无法*让它们转动特定的距离或步数，但你*可以*通过开关电源来控制它们运行一定时间。这意味着任何路径都将是你希望机器人走向的粗略近似，而不是精确的计划。
- en: To start, let’s keep things simple and make your robot drive around in a square,
    with a route like the one shown in [Figure 4-2](ch04.xhtml#ch04fig2).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们简化一点，让你的机器人在方形路线内行驶，路线如下所示 [图 4-2](ch04.xhtml#ch04fig2)。
- en: '![image](../images/f082-01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f082-01.jpg)'
- en: '**FIGURE 4-2** The robot’s planned route'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-2** 机器人计划的路线'
- en: In your *first_move.py* file, enter the code in [Listing 4-1](ch04.xhtml#ch04list1)
    to program a square route.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 *first_move.py* 文件中，输入 [列表 4-1](ch04.xhtml#ch04list1) 中的代码来编程一个方形路线。
- en: '[PRE0]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**LISTING 4-1** Programming your robot to move in a square'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 4-1** 编程让你的机器人沿方形路径移动'
- en: 'The program starts by importing familiar Python libraries: `gpiozero` and `time`.
    Then you create a variable called `robot` ➊, to which you assign a `Robot` object
    from the GPIO Zero library.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 程序首先导入常用的 Python 库：`gpiozero` 和 `time`。然后你创建一个名为 `robot` 的变量 ➊，并为其分配来自 GPIO
    Zero 库的 `Robot` 对象。
- en: '*Objects* in Python are a way of holding variables (pieces of information)
    and functions (predefined sets of instructions that perform tasks) in a single
    entity. This means that when we assign an object to a variable, that variable
    then has a range of predefined things that it knows and can do. An object gets
    these capabilities from its *class*. Each class has its own functions (called
    *methods*) and variables (called *attributes*). These are advanced features of
    Python and you don’t have to worry about them too much at this stage. Just know
    that we’re using some predefined classes from Python libraries, like GPIO Zero,
    to make it easier for us.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，*对象* 是一种将变量（信息片段）和函数（执行任务的预定义指令集）保存在一个实体中的方式。这意味着，当我们将一个对象分配给一个变量时，该变量将拥有一系列预定义的功能和操作。对象通过它的*类*来获得这些功能。每个类都有自己的函数（称为*方法*）和变量（称为*属性*）。这些是
    Python 的高级功能，你在这个阶段不需要太多担心它们。只需要知道，我们正在使用来自 Python 库的预定义类，比如 GPIO Zero，这样可以让我们的编程变得更容易。
- en: 'The GPIO Zero library has an inbuilt `Robot` class that features a variety
    of functions for moving a two-wheeled robot in different directions. Notice the
    two sets of values in the parentheses assigned to `left` and `right` ➊. These
    represent the input pins of the L293D you have wired up. If you followed my exact
    wiring from [Chapter 3](ch03.xhtml), then the four GPIO pins should be: 17, 18
    and 27, 22.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO Zero库内置了一个`Robot`类，提供了多种用于让双轮机器人朝不同方向移动的功能。请注意括号中的两组值，它们分别分配给`left`和`right`
    ➊。这些值代表你连接到L293D的输入引脚。如果你按照[第3章](ch03.xhtml)中的接线方式进行操作，那么这四个GPIO引脚应该是：17、18、27、22。
- en: This program also uses a new type of loop called a `for` loop ➋. In [Chapter
    2](ch02.xhtml), while making LEDs flash on and off and getting inputs from buttons,
    you used a `while` loop. A `while` loop keeps repeating its contents indefinitely
    while a certain condition is met, but a `for` loop repeats a block of code a *fixed*
    number of times. The syntax of this loop, `for i in range(4):`, means “do the
    following four times.”
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序还使用了一种新的循环类型，称为`for`循环➋。在[第2章](ch02.xhtml)中，当你让LED灯闪烁并从按钮获取输入时，你使用了`while`循环。`while`循环会在满足某个条件时无限期地重复其内容，而`for`循环则是将一段代码块重复执行*固定*的次数。该循环的语法`for
    i in range(4):`意味着“做以下事情四次”。
- en: The `for` loop commands your robot to start going forward ➌ and then wait for
    half a second ➍ to allow some time for the robot to move. The result is that both
    motors move in a single direction (forward) for half a second.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环指示你的机器人开始向前行进➌，然后等待半秒钟 ➍，以便给机器人一些时间进行移动。结果是两个电机在一个方向（前进）上移动了半秒钟。'
- en: You then instruct your robot to turn right ➎ and wait for a quarter of a second
    as this happens ➏. By telling the robot to turn right, you replace the forward
    command issued half a second ago with a new command for the motors.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，你指示机器人向右转➎，并在此过程中等待四分之一秒 ➏。通过让机器人向右转，你将半秒前发出的前进命令替换为新的电机指令。
- en: Once this has been executed once, the “go forward, then turn right” process
    starts again and continues for a total of *four* times. You are trying to make
    your robot go in a square, and squares have four sides, hence the specific repetition.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行完成，“向前走然后右转”的过程会重新开始，并持续*四*次。你尝试让机器人走一个方形路线，而方形有四条边，因此需要特定次数的重复。
- en: Once you’ve finished writing your program, exit Nano by pressing CTRL-X and
    save your work like usual. Next, we’ll run the program to make the robot move!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成编写程序，按CTRL-X退出Nano并保存你的工作。接下来，我们将运行程序让机器人开始移动！
- en: The GPIO Zero Robot class has commands for all directions and basic functionality,
    summarized in [Table 4-2](ch04.xhtml#ch04tab2).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO Zero的Robot类包含所有方向和基本功能的命令，详见[表4-2](ch04.xhtml#ch04tab2)。
- en: '**TABLE 4-2** The `Robot` Class Commands'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**表4-2** `Robot`类命令'
- en: '| **COMMAND** | **FUNCTIONALITY** |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **功能** |'
- en: '| `robot.forward()` | Run both motors forward. |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `robot.forward()` | 让两个电机向前转动。 |'
- en: '| `robot.backward()` | Run both motors backward. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `robot.backward()` | 让两个电机后退。 |'
- en: '| `robot.left()` | Run the right motor forward and the left motor backward.
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `robot.left()` | 让右电机向前转动，左电机向后转动。 |'
- en: '| `robot.right()` | Run the left motor forward and the right motor backward.
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `robot.right()` | 让左电机前进，右电机后退。 |'
- en: '| `robot.reverse()` | Reverse the robot’s current motor directions. For example:
    if going forward, go backward. If going left, go right. This is *not* the same
    as going backward! |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `robot.reverse()` | 反转机器人的当前电机方向。例如：如果前进，则后退；如果向左，则向右。这*不是*后退！ |'
- en: '| `robot.stop()` | Stop both motors. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `robot.stop()` | 停止两个电机。 |'
- en: 'Running Your Program: Make Your Robot Move'
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行程序：让你的机器人移动
- en: Before you execute your program, ensure your robot is disconnected from the
    wall power outlet and the batteries are connected and turned on. You should also
    place your robot on a relatively large, flat surface clear of obstacles and hazards.
    Rough surfaces, like carpets, may cause your robot to become stuck or struggle
    to move. Try to avoid this, as struggling motors draw more current, and when their
    movement is completely blocked (or *stalled*) you might even damage your electronics!
    The flatter the surface, the better your robot will run.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行程序之前，确保你的机器人已经从墙壁电源插座断开，电池已连接并开启。你还应该将机器人放置在一个相对较大、平坦的表面上，确保没有障碍物和危险。粗糙的表面，如地毯，可能导致你的机器人卡住或难以移动。尽量避免这种情况，因为电机困难时会消耗更多电流，而且当电机完全被阻止（或*停滞*）时，可能会损坏电子元件！表面越平坦，机器人运行得越顺畅。
- en: It is also a good idea to be in a position to “catch” your robot in case either
    it or something/someone is in peril. It may try to go down the stairs, for example,
    or the cat may be in the way.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让你的机器人处于一个能够“接住”它的位置也是个好主意，以防它或某个物体/某个人处于危险之中。例如，它可能会试图下楼梯，或者猫可能会挡住路。
- en: 'To run your program, wirelessly access the terminal of your Pi using SSH and
    enter:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行你的程序，通过 SSH 无线访问你的 Pi 的终端并输入：
- en: pi@raspberrypi:~/robot $ python3 first_move.py
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ python3 first_move.py
- en: Your robot should burst into life and start to move. If all has gone well, it
    will move on a square-based path and then come to a stop, and your program will
    end by itself. If you need to stop your robot at any point, press CTRL-C on your
    keyboard to kill the motors immediately.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你的机器人应该开始动起来。如果一切顺利，它将沿着一个方形路径移动，然后停下来，程序也会自动结束。如果你需要在任何时候停止机器人，可以按键盘上的 CTRL-C
    立即停止电机。
- en: 'TROUBLESHOOTING GUIDE: ROBOT NOT WORKING PROPERLY?'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 故障排除指南：机器人工作不正常？
- en: If your robot isn’t functioning as it should be, don’t worry. Usually malfunctions
    fall into some common categories and should be easy to fix! The following quick
    guide will help you resolve most issues you might have.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的机器人没有正常工作，不用担心。通常故障可以归类为一些常见问题，应该很容易解决！以下的快速指南将帮助你解决大部分可能遇到的问题。
- en: Robot Moving Erratically
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人移动不稳定
- en: The most common problem after you execute the *first_move.py* program is that
    your robot moves, but not in the right pattern. Instead of going forward, it goes
    backward; or instead of turning right, it turns left. You may even find that it
    just spins on the spot!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 *first_move.py* 程序后最常见的问题是，机器人移动了，但不是按照正确的模式。例如，它本应前进，但却后退；或者它本应右转，但却左转。你甚至可能发现它只是原地旋转！
- en: This behavior can be easily fixed. As we discussed, DC motors have two terminals
    with no particular polarity. This means that if you change the direction of current
    flowing through the motor, the motor spins the other way. Consequently, if one
    or both of your motors is going in the opposite direction of your commands, you
    can swap the wires connected to the output pins of your motor controller to reverse
    this. For example, swap the wires connected to Output 1 with Output 2 of your
    L293D. Refer to [Chapter 3](ch03.xhtml) for guidance and relevant diagrams.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况可以很容易修复。正如我们讨论过的，直流电机有两个端子，没有特定的极性。这意味着，如果你改变电流流动的方向，电机就会反向旋转。因此，如果一个或两个电机的转动方向与命令相反，你可以交换连接到电机控制器输出引脚的电线来反转方向。例如，交换连接到
    L293D 输出 1 和输出 2 的电线。有关指导和相关图示，请参阅[第 3 章](ch03.xhtml)。
- en: Motors Not Moving
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 电机不转动
- en: If your program successfully executes, but your robot’s wheels don’t move or
    only one motor starts to move, then you could have an issue related to your wiring.
    Go back to the previous chapter and check that you’ve connected everything as
    per the instructions. Ensure the connections to the motors are solid and that
    none of the wires have become loose. If you’re convinced that you’ve wired everything
    correctly, check whether your batteries are charged and that they can provide
    enough power for your specific motors.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的程序成功执行，但机器人的轮子没有转动，或者只有一个电机开始转动，那么可能是你的接线出了问题。请回到上一章，检查你是否按照说明连接了所有设备。确保电机的连接牢固，没有任何电线松动。如果你确信接线正确，检查一下电池是否充满电，并且它们能为你的电机提供足够的电力。
- en: If your Raspberry Pi crashes when the motors start to turn, you most likely
    have a power issue. Check how you have set up your buck converter. If you are
    using a different converter than mine, you may run into problems. Go back a chapter
    for guidance and recommendations.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 Raspberry Pi 在电机开始转动时崩溃，可能是电源出现了问题。检查你是如何设置降压转换器的。如果你使用的是与我不同的转换器，可能会遇到问题。请回到上一章获取指导和建议。
- en: Robot Moving Very Slowly
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人移动非常缓慢
- en: A slow robot is usually a sign that not enough power is being provided to the
    motors. Check the voltage requirements of your motors and make sure you’re supplying
    them with what they need. Often motors will accept a range of voltages—for example,
    from 3 V to 9 V. If your motors do, try a higher voltage that stays within the
    recommended range. Bear in mind that if you change your batteries and any of the
    voltages, you’ll need to check and reset your buck converter to ensure that you
    don’t feed more than 5.1 V into your Raspberry Pi.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人运动缓慢通常意味着电机没有得到足够的电力。检查你的电机的电压要求，确保你提供了它们所需的电压。通常电机可以接受一范围的电压，例如从3V到9V。如果你的电机支持这一范围，试着使用一个更高的电压，但要确保它仍然在推荐范围内。请记住，如果你更换了电池并且更改了电压，记得检查并重置降压转换器，确保你不会给树莓派提供超过5.1V的电压。
- en: Alternatively, the motors themselves may just have a slow, geared RPM. If that’s
    the case, while your robot may be slow, it will probably have a lot of torque,
    which is a fair trade-off.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，电机本身也可能只有较慢的齿轮转速。如果是这种情况，虽然你的机器人可能会慢，但它可能有很大的扭矩，这是一个不错的权衡。
- en: Robot Not Following the Programmed Path
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人没有按照编程路径行驶
- en: If your robot successfully executes the program and starts to move at a suitable
    speed, but doesn’t follow the exact path you had planned, don’t fret! Every motor
    is different and will need adjustments for the program to work the way you want.
    For example, 0.25 seconds may not be enough time for the motors to make your robot
    turn approximately 90 degrees. Edit the program and play around with the `sleep()`
    and `robot()` statements inside the `for` loop to adjust.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的机器人成功执行程序并开始以适当的速度移动，但没有精确按照你预定的路径行驶，不用担心！每个电机都是不同的，你需要进行一些调整才能让程序按你的需求运行。例如，0.25秒可能不足以让电机让你的机器人大约转动90度。修改程序，调整`for`循环中的`sleep()`和`robot()`语句。
- en: MAKING YOUR ROBOT REMOTE-CONTROLLED
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使你的机器人实现远程控制
- en: Making a robot come to life and move is an exciting first step in robotics,
    and the natural next step is to make your robot remote-­controlled. This means
    it will no longer be limited to a predefined path, so you’ll be able to control
    it in real time!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让机器人“复活”并开始移动是机器人技术的一个令人兴奋的第一步，接下来的自然步骤就是让你的机器人实现远程控制。这意味着它不再局限于预定的路径，你将能够实时控制它！
- en: The aim of this project is to program your robot so you can use a wireless controller
    to guide it. You’ll be able to instantaneously change your robot’s movements without
    going back into your code.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的目的是编程你的机器人，使你能够用无线控制器来引导它。你将能够在不重新进入代码的情况下，瞬间改变机器人运动的方式。
- en: The Wiimote Wireless Controller
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Wiimote无线控制器
- en: In order to control your robot with a wireless controller, first you’ll need
    one! The perfect remote for our robot is a Nintendo Wii remote, also known as
    a *Wiimote*, like the one in [Figure 4-3](ch04.xhtml#ch04fig3).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了用无线控制器控制你的机器人，首先你需要一个！我们机器人的完美遥控器是任天堂的Wii遥控器，也就是*Wiimote*，如[图 4-3](ch04.xhtml#ch04fig3)所示。
- en: '![image](../images/f087-01.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f087-01.jpg)'
- en: '**FIGURE 4-3** My much-loved Nintendo Wiimote'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-3** 我心爱的任天堂Wiimote'
- en: WARNING
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '*To guarantee compatibility with your Raspberry Pi, make sure that your Wiimote
    is a Nintendo-branded official model. Over the years a considerable number of
    third-party Wiimotes have become available to buy. Though usually cheaper than
    an official Wiimote, these aren’t guaranteed to work with the `cwiid` library.*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了确保与你的树莓派兼容，请确保你的Wiimote是任天堂官方品牌的正品型号。近年来，许多第三方Wiimote已经上市。尽管通常比官方Wiimote便宜，但这些产品不能保证与`cwiid`库兼容。*'
- en: A Wiimote is a pretty nifty little Bluetooth controller with a set of buttons
    and some sensors that are able to detect movement. The Wiimote was originally
    created for the Nintendo Wii games console, but fortunately there’s an open source
    Python library, called `cwiid`, that allows Linux computers, like your Raspberry
    Pi, to connect and communicate with Wiimotes. We’ll use `cwiid` to manipulate
    the data from a Wiimote to control your robot’s motors.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Wiimote是一个非常巧妙的小型蓝牙控制器，带有一组按钮和一些能够检测运动的传感器。Wiimote最初是为任天堂Wii游戏机设计的，但幸运的是，有一个开源Python库，叫做`cwiid`，它允许像树莓派这样的Linux电脑与Wiimote连接并进行通信。我们将使用`cwiid`来操控Wiimote的数据，从而控制你的机器人的电机。
- en: If you don’t have a Wiimote already, you’ll need to get your hands on one. These
    are widely available online, both new and used. I recommend picking up a cheap
    used one on a site like eBay or from a secondhand shop—mine cost me less than
    $15.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有Wiimote，你需要去购买一个。这些在线上广泛销售，既有新的，也有二手的。我建议在像eBay这样的网站或二手商店购买一个便宜的二手Wiimote——我买的只花了不到15美元。
- en: You’ll use Bluetooth to pair your Wiimote with the Raspberry Pi on your robot.
    *Bluetooth* is a wireless radio technology that many modern devices, like smartphones,
    use to communicate and transfer data over short distances. The latest Raspberry
    Pi models, like the Pi Zero W and Raspberry Pi 3 Model B+, come with Bluetooth
    capabilities built in. All models prior to the Raspberry Pi 3 Model B, like the
    original Raspberry Pi and Pi 2, do *not*, and consequently you’ll need to get
    a Bluetooth USB adapter (or *dongle*), like the one pictured in [Figure 4-4](ch04.xhtml#ch04fig4),
    to connect to a Wiimote.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用蓝牙将Wiimote与Raspberry Pi连接到你的机器人上。*蓝牙*是一种无线射频技术，许多现代设备，如智能手机，使用它来进行短距离的通信和数据传输。最新的Raspberry
    Pi型号，如Pi Zero W和Raspberry Pi 3 Model B+，内置蓝牙功能。所有在Raspberry Pi 3 Model B之前的型号，如原始的Raspberry
    Pi和Pi 2，都没有蓝牙功能，因此你需要获取一个蓝牙USB适配器（或*适配器*），如[图4-4](ch04.xhtml#ch04fig4)所示，用于连接Wiimote。
- en: '![image](../images/f088-01.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f088-01.jpg)'
- en: '**FIGURE 4-4** A $3 Raspberry Pi–compatible Bluetooth dongle'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4-4** 一款3美元的Raspberry Pi兼容蓝牙适配器'
- en: These are available for less than $5 online; just search for “Raspberry Pi compatible
    Bluetooth dongle.” Before you proceed, make sure you have plugged the dongle into
    one of the USB ports of your Pi.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在网上售价不到5美元；只需搜索“Raspberry Pi兼容的蓝牙适配器”。在继续之前，确保已将适配器插入Pi的一个USB端口。
- en: Installing and Enabling Bluetooth
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 安装并启用蓝牙
- en: 'Before you start to write the next Python script, you’ll need to make sure
    that Bluetooth is installed on your Pi and that the `cwiid` library is set up.
    Power your Raspberry Pi from a wall outlet and then, from the terminal, run this
    command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编写下一个Python脚本之前，你需要确保蓝牙已安装在Pi上，并且`cwiid`库已设置好。从插座为你的Raspberry Pi供电，然后从终端运行以下命令：
- en: pi@raspberrypi:~ $ sudo apt-get update
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~ $ sudo apt-get update
- en: 'And then run this one:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然后运行以下命令：
- en: pi@raspberrypi:~ $ sudo apt-get install bluetooth
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~ $ sudo apt-get install bluetooth
- en: If you have Bluetooth installed already, you should see a dialogue that states
    `bluetooth is already the newest version`. If you don’t get this message, go through
    the Bluetooth installation process.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经安装了蓝牙，你应该会看到一个对话框，显示`bluetooth is already the newest version`。如果没有看到此消息，请按照蓝牙安装流程进行操作。
- en: Next, you’ll need to download and install the `cwiid` library for Python 3\.
    We’ll grab this code from *GitHub*, a website where programmers and developers
    share their software.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要为Python 3下载并安装`cwiid`库。我们将从*GitHub*获取这段代码，GitHub是一个程序员和开发者分享软件的站点。
- en: 'Run the following command in the home folder of your Pi:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pi的主文件夹中运行以下命令：
- en: pi@raspberrypi:~ $ git clone https://github.com/azzra/python3-wiimote
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~ $ git clone https://github.com/azzra/python3-wiimote
- en: You should now have the source code of the `cwiid` library downloaded to your
    Raspberry Pi, stored in a new folder called *python3-wiimote*. Before we can get
    to our next Python program, the source code must first be *compiled*, a process
    that makes and readies software for use on a device.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该已经将`cwiid`库的源代码下载到你的Raspberry Pi中，并存储在一个名为*python3-wiimote*的新文件夹中。在我们开始下一个Python程序之前，源代码需要先进行*编译*，这是将软件制作并准备好在设备上使用的过程。
- en: 'You also need to install four other software packages before you can proceed.
    Enter the following command to install all four at once:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续操作之前，你还需要安装其他四个软件包。输入以下命令一次性安装所有四个软件包：
- en: pi@raspberrypi:~ $ sudo apt-get install bison flex automake libbluetooth-dev
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~ $ sudo apt-get install bison flex automake libbluetooth-dev
- en: 'If you’re prompted to agree to continue, press Y (which is the default). Once
    this command has finished executing, change into the newly downloaded directory
    containing your Wiimote source code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提示你同意继续，请按Y（默认选项）。该命令执行完成后，切换到新下载的目录，其中包含你的Wiimote源代码：
- en: pi@raspberrypi:~ $ cd python3-wiimote
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~ $ cd python3-wiimote
- en: 'Next, you must prepare to compile the library by entering each of the following
    commands, one after the other. This is all part of the compilation process—you
    don’t have to worry about the specifics of each command! The first two commands
    won’t output anything, but the rest of them will. I’ll show the start of each
    output here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你必须通过依次输入以下每个命令来准备编译库。这些都属于编译过程的一部分——你不必担心每个命令的具体内容！前两个命令不会输出任何内容，但其余的命令会输出。我将在这里展示每个输出的开始部分：
- en: pi@raspberrypi:~/python3-wiimote $ aclocal
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/python3-wiimote $ aclocal
- en: pi@raspberrypi:~/python3-wiimote $ autoconf
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/python3-wiimote $ autoconf
- en: pi@raspberrypi:~/python3-wiimote $ ./configure
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/python3-wiimote $ ./configure
- en: checking for gcc... gcc
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正在检查 gcc... gcc
- en: checking whether the C compiler works... yes
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正在检查 C 编译器是否工作... 是
- en: checking for C compiler default output file name... a.out
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 正在检查 C 编译器默认输出文件名... a.out
- en: checking for suffix of executables...
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正在检查可执行文件的后缀...
- en: --snip--
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: --snip--
- en: 'And then finally, to install the `cwiid` library, enter:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最终安装 `cwiid` 库，输入：
- en: pi@raspberrypi:~/python3-wiimote $ make
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/python3-wiimote $ make
- en: make  -C libcwiid
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: make -C libcwiid
- en: 'make[1]: Entering directory ''/home/pi/python3-wiimote/libcwiid'''
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'make[1]: 进入目录 ''/home/pi/python3-wiimote/libcwiid'''
- en: --snip-
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: --snip-
- en: '**NOTE**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you have trouble with the Python 3 `cwiid` installation, check out the
    book’s website to see whether the process has been updated:* [https://nostarch.com/raspirobots/](https://nostarch.com/raspirobots/).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你在安装 Python 3 `cwiid` 时遇到问题，请查看本书网站，看看是否有更新的过程：* [https://nostarch.com/raspirobots/](https://nostarch.com/raspirobots/)。'
- en: After that, `cwiid` should work in Python 3! Now you can navigate out of the
    *python3-wiimote* directory and back to where you have all of your other code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`cwiid` 应该能在 Python 3 中正常工作了！现在，你可以退出 *python3-wiimote* 目录，回到存放其他代码的地方。
- en: Programming Remote Control Functionality
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写远程控制功能
- en: 'Now create and open a new Python program to store the Wiimote code. I have
    called mine *remote_control.py*:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建并打开一个新的 Python 程序来存储 Wiimote 代码。我将其命名为 *remote_control.py*：
- en: pi@raspberrypi:~/robot $ nano remote_control.py
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ nano remote_control.py
- en: In general, before you start to code, it is important to first plan what exactly
    you want to do. In our case, we want to think about how we want the Wiimote to
    control the robot exactly. Let’s make a plan.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在开始编写代码之前，首先规划你到底想做什么是很重要的。在我们的例子中，我们需要考虑如何让 Wiimote 精确地控制机器人。让我们做个计划。
- en: The Wiimote has 11 digital buttons, which is more than we’ll need for this simple
    project. Interestingly for us, 4 of those buttons belong to the D-pad—the four-way
    directional control buttons at the top of your Wiimote, shown in [Figure 4-5](ch04.xhtml#ch04fig5).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Wiimote 有 11 个数字按钮，这对于这个简单的项目来说已经足够了。有趣的是，其中 4 个按钮属于 D-pad——Wiimote 顶部的四向控制按钮，见
    [图 4-5](ch04.xhtml#ch04fig5)。
- en: '![image](../images/f090-02.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f090-02.jpg)'
- en: '**FIGURE 4-5** The four-way D-pad of a Wiimote'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-5** Wiimote 的四向 D-pad'
- en: 'That’s perfect for our purposes: we can use up to make the robot go forward,
    right to make the robot go right, down to make the robot go backward, and left
    to make the robot go left. This is very similar to the program we wrote earlier,
    except that now we read our inputs from the Wiimote rather than them being programmed
    in.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这正好符合我们的需求：我们可以用上方向键让机器人向前进，用右方向键让机器人向右走，用下方向键让机器人向后退，用左方向键让机器人向左走。这和我们之前写的程序非常相似，只不过现在我们从
    Wiimote 获取输入，而不是预先编写好。
- en: We also need something to make the robot stop. The “B” trigger button on the
    underside of the Wiimote would be well suited to this. Let’s write some code in
    Nano that executes the plan we’ve made; see [Listing 4-2](ch04.xhtml#ch04list2).
    I have saved this program as *remote_control.py*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些东西来让机器人停止。Wiimote 底部的“B”触发按钮非常适合这个功能。让我们在 Nano 中写一些代码来执行我们所做的计划；见 [Listing
    4-2](ch04.xhtml#ch04list2)。我将这个程序保存为 *remote_control.py*。
- en: '[PRE1]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**LISTING 4-2** Programming your robot to respond to the D-pad of your Wiimote'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 4-2** 编程让你的机器人响应 Wiimote 的 D-pad'
- en: As before, you start by importing `gpiozero` as well as the new `cwiid` library.
    A `Robot` object is then set up ➊.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你首先需要导入 `gpiozero` 和新的 `cwiid` 库。接着，创建一个 `Robot` 对象 ➊。
- en: In the next section of code ➋, you set up the Wiimote. As with the `Robot` object,
    we assign the `Wiimote` object to a variable called `wii`. When this code runs
    and execution reaches this line, there will be a pairing handshake between the
    Raspberry Pi and Wiimote. The user will need to *press and hold* buttons 1 and
    2 on the Wiimote at the same time to put the Wiimote in a Bluetooth-discoverable
    mode. We add a `print()` statement here to tell the user when to press the buttons.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码部分 ➋，你会设置Wiimote。与`Robot`对象类似，我们将`Wiimote`对象赋值给一个名为`wii`的变量。当这行代码执行时，Raspberry
    Pi和Wiimote之间会进行配对握手。用户需要*同时按住*Wiimote上的1和2按钮，将Wiimote设置为蓝牙可发现模式。我们在这里添加了一个`print()`语句，提醒用户何时按下按钮。
- en: If the pairing is successful, the code prints a positive message for the user.
    We then turn on the Wiimote’s reporting mode ➌, which permits Python to read the
    values of the different buttons and functions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果配对成功，代码会打印出一条正面的消息给用户。接着，我们开启Wiimote的报告模式 ➌，这样Python就可以读取不同按钮和功能的值。
- en: After this, we use an infinite `while` loop to tell the robot what to do when
    each button is pressed. First, the loop reads the current status of the Wiimote
    ➍, meaning it checks what buttons have been pressed. This information is then
    stored in a variable called `buttons`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用一个无限`while`循环来告诉机器人当每个按钮被按下时该做什么。首先，循环会读取Wiimote的当前状态 ➍，即检查哪些按钮被按下。这些信息会被存储在一个名为`buttons`的变量中。
- en: 'Finally, we start the last chunk of the program ➎: a variety of `if` statements
    and conditions that allocate an action to each button. To look at one example,
    the first `if` statement ensures that if the left button of the D-pad has been
    pressed, the robot is instructed to turn left. Over the next lines, the same sort
    of logic is applied: if the right button of the D-pad has been pressed, the robot
    is instructed to turn right, and so on.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们开始程序的最后一部分 ➎：一系列`if`语句和条件，用来为每个按钮分配一个动作。举个例子，第一个`if`语句确保当按下D-pad的左按钮时，机器人会向左转。接下来的代码行应用了类似的逻辑：如果按下D-pad的右按钮，机器人会向右转，依此类推。
- en: As usual, once you have finished writing your program, exit Nano and save your
    work.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，一旦你完成编写程序，退出Nano并保存你的工作。
- en: 'Running Your Program: Remote-Control Your Robot'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行你的程序：远程控制你的机器人
- en: 'Place your robot on a large surface and have your Wiimote handy. If your Pi
    requires a Bluetooth dongle, don’t forget to plug it into one of the USB ports.
    To run your program, use an SSH terminal to enter:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 把你的机器人放在一个大的平面上，并准备好Wiimote。如果你的Pi需要蓝牙适配器，不要忘记将其插入USB端口。要运行程序，可以使用SSH终端输入以下命令：
- en: pi@raspberrypi:~/robot $ python3 remote_control.py
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ python3 remote_control.py
- en: Soon after program execution, a prompt will appear in the terminal asking you
    to press and hold the 1 and 2 buttons on your Wiimote simultaneously. You should
    hold these buttons until you get a success message, which can take up to 10 seconds.
    The Bluetooth handshake process can be fussy, so try to press them as soon as
    the program instructs you to do so.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 程序执行后不久，终端会弹出一个提示，要求你同时按住Wiimote上的1和2按钮。你需要一直按住这两个按钮，直到收到成功消息，最多可能需要10秒钟。蓝牙配对过程可能会有点儿挑剔，所以尽量在程序提示时尽早按下这两个按钮。
- en: If the pairing was successful, another message stating `Connection established`
    will appear. Alternatively, if the pairing was unsuccessful, an error message
    saying that `No Wiimotes were found` will be displayed, and your program will
    crash. If this is the case, and you are using an official Nintendo-branded Wiimote,
    then you most likely were not fast enough pressing the 1 and 2 buttons! Rerun
    the program with the same command and try again.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果配对成功，另一个消息`Connection established`会出现。否则，如果配对失败，则会显示错误消息`No Wiimotes were
    found`，并且程序会崩溃。如果发生这种情况，且你使用的是官方任天堂品牌的Wiimote，那么很可能是你按下1和2按钮的速度不够快！重新运行程序并尝试再次进行配对。
- en: With your Wiimote now successfully connected, you should be able to make your
    robot dash around in any direction you want at the touch of a button! Remember
    that you can stop both motors at any point by pressing B on the underside of your
    Wiimote. As usual, you can kill the program by pressing CTRL-C.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Wiimote已经成功连接，你应该能够通过按下按钮让你的机器人朝任何你想要的方向快速移动！记得你可以随时通过按下Wiimote底部的B按钮来停止两个电机。像往常一样，你可以通过按CTRL-C来终止程序。
- en: VARYING THE MOTOR SPEED
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变电机速度
- en: 'Up until now your robot has been able to go at two speeds: 0 mph, or top speed!
    You might have noticed that this isn’t the most convenient. Traveling at full
    speed makes precise maneuvers almost impossible, and you probably crashed into
    things a few times. Fortunately, it doesn’t always have to be this way. Let’s
    give your robot some control over its speed.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的机器人只能以两种速度行驶：0英里每小时或最快速度！你可能已经注意到，这并不是最方便的。以全速行驶使得精确操控几乎不可能，你可能已经撞到了一些东西。幸运的是，情况不必总是如此。让我们给你的机器人增加一些速度控制。
- en: In this project, we’ll build upon the previous example and create a remote control
    robot with variable motor speed. To do this I’ll introduce a technique called
    *pulse-width modulation (PWM)*, and I’ll explain how to use it inside the Python
    GPIO Zero library. We’ll also put a special sensor called an *accelerometer* in
    your Wiimote to good use to create a much improved version of the remote control
    program!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将在之前的示例基础上，创建一个具有可变电机速度的遥控机器人。为此，我将介绍一种叫做*脉宽调制（PWM）*的技术，并解释如何在Python的GPIO
    Zero库中使用它。我们还将利用一种特殊的传感器，叫做*加速度计*，在Wiimote中进行充分利用，创造出一个大大改进的遥控程序版本！
- en: Understanding How PWM Works
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解PWM是如何工作的
- en: The Raspberry Pi is capable of providing *digital* outputs but not *analog*
    outputs. A digital signal can be either on or off, and nothing in between. An
    analog output, in contrast, is one that can be set at no voltage, full voltage,
    or anything in between. On the Raspberry Pi, at any given time a GPIO pin is either
    on or off, which is no voltage or full voltage. By this logic, motors connected
    to a Pi’s GPIO can only either stop moving or go full speed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 树莓派能够提供*数字*输出，而不能提供*模拟*输出。数字信号只能是开或关，介于两者之间没有状态。相比之下，模拟输出可以设置为零电压、满电压或任何介于两者之间的电压。在树莓派上，任何时刻GPIO引脚的状态要么是开，要么是关，即无电压或满电压。按照这个逻辑，连接到Pi的电机只能停止或全速运转。
- en: That means that it is impossible to set a Pi’s GPIO pin to “half voltage” for
    half the motor speed, for example. Fortunately, the PWM technique allows us to
    approximate this behavior.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，例如，无法将Pi的GPIO引脚设置为“半电压”来实现电机速度的一半。幸运的是，PWM技术使我们能够近似地实现这一行为。
- en: 'To understand PWM, first take a look at the graph in [Figure 4-6](ch04.xhtml#ch04fig6).
    It depicts the state of a digital output changing from low to high. This is what
    happens when you turn on one of your Pi’s GPIO pins: it goes from 0 V to 3.3 V.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解PWM，首先请查看[图 4-6](ch04.xhtml#ch04fig6)中的图表。它描绘了数字输出从低电平到高电平的变化。这就是当你打开树莓派的GPIO引脚时发生的情况：它从0
    V变为3.3 V。
- en: '![image](../images/f093-01.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f093-01.jpg)'
- en: '**FIGURE 4-6** A state change from low (0 V) to high (3.3 V)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-6** 从低电平（0 V）到高电平（3.3 V）的状态变化'
- en: 'PWM works by turning a GPIO pin on and off so quickly that the device (in our
    case, a motor) “notices” only the *average* voltage at any given time. This means
    that the state is somewhere in between 0 V and 3.3 V. This average voltage depends
    on the *duty cycle*, which is simply the amount of time the signal is on, versus
    the amount of time a signal is off in a given period. It is given as a percentage:
    25 percent means the signal was high for 25 percent of the time and low for 75
    percent of the time; 50 percent means the signal was high for 50 percent of the
    time and low for the other 50 percent, and so on.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: PWM通过快速地打开和关闭一个GPIO引脚，使得设备（在我们这个例子中是电机）仅“注意到”任何给定时刻的*平均*电压。这意味着电压的状态介于0 V和3.3
    V之间。这个平均电压取决于*占空比*，即信号在给定周期内“开”与“关”的时间比例。它以百分比表示：25%意味着信号在25%的时间内为高电平，75%的时间内为低电平；50%意味着信号在50%的时间内为高电平，另50%为低电平，依此类推。
- en: 'The duty cycle affects the output voltage proportionally, as shown in [Figure
    4-7](ch04.xhtml#ch04fig7). For example, for the Raspberry Pi, pulse-width modulating
    a GPIO pin at a 50 percent duty cycle would give a voltage of 50 percent: 3.3
    V / 2 = 1.65 V.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 占空比按比例影响输出电压，如[图 4-7](ch04.xhtml#ch04fig7)所示。例如，对于树莓派，在50%占空比下进行脉宽调制会给出50%的电压：3.3
    V / 2 = 1.65 V。
- en: '![image](../images/f094-01.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f094-01.jpg)'
- en: '**FIGURE 4-7** Two different PWM voltage traces: a duty cycle of 25 percent
    (top) and a duty cycle of 50 percent (bottom)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-7** 两种不同的PWM电压波形：25%占空比（上）和50%占空比（下）'
- en: While PWM is not a perfect approximation of an analog signal, for most cases
    it works well, especially at this level. Digitally encoding analog signal levels
    will allow you to control the exact speed of your robot’s movement.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 PWM 不是模拟信号的完美近似，但在大多数情况下，它表现良好，尤其是在这一层次上。通过数字编码模拟信号的电平，你将能够精确控制机器人运动的速度。
- en: 'The GPIO Zero Python library authors have made it easy to vary motor speed
    using PWM, so you don’t need to know the exact mechanics behind it. All you need
    to do is provide a value between 0 and 1 in the parentheses of each motor command
    to represent a value between 0 percent and 100 percent, as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: GPIO Zero Python 库的作者使得使用 PWM 调节电机速度变得非常简单，因此你无需了解其背后的具体机制。你需要做的就是在每个电机指令的括号中提供一个介于
    0 和 1 之间的值，表示从 0% 到 100% 的值，如下所示：
- en: '[PRE2]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**NOTE**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If your robot has been zipping around too fast in the previous examples, feel
    free to go back and adjust the speed in the last two projects using this method!*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你的机器人在前面的例子中运行得太快，随时可以返回并使用这种方法调整前两个项目中的速度！*'
- en: This program would command your robot to move forward for 1 second at 25 percent
    of its full speed, turn left at 50 percent of its full speed for another second,
    and then go backward at full speed for a final second. If you don’t provide a
    value, Python assumes that the robot should move at full speed, just the same
    as if you were to enter a 1.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序将命令你的机器人以其最大速度的 25% 向前移动 1 秒，然后以最大速度的 50% 向左转动 1 秒，再以全速倒退 1 秒。如果你没有提供数值，Python
    将假定机器人应该以全速移动，就像你输入 1 一样。
- en: Understanding the Accelerometer
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解加速度计
- en: Before we improve upon the remote control program in the previous project, let’s
    learn about the accelerometer in your Wiimote and how we can use it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们改进前一个项目中的遥控程序之前，让我们先了解一下 Wiimote 中的加速度计以及我们如何使用它。
- en: Previously, you used the D-pad of the Wiimote to provide control. These four
    buttons are digital and can only detect being pressed on or off. This isn’t ideal
    for controlling both speed and direction at once.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你使用了 Wiimote 的方向键来进行控制。这四个按钮是数字按钮，只能检测是否被按下或松开。这对于同时控制速度和方向并不理想。
- en: 'Inside each Wiimote, however, there is a sensor called an *accelerometer* that
    can detect and measure the acceleration the Wiimote is undergoing at any point.
    This means that moving a Wiimote in the air provides sensory data in all three
    axes: in all three axes: *x*, *y*, and *z*. In this way, the accelerometer can
    track the direction of movement, and the speed of that direction. See [Figure
    4-8](ch04.xhtml#ch04fig8) for a diagram.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在每个 Wiimote 内部，都有一个叫做*加速度计*的传感器，它能够检测并测量 Wiimote 在任何时刻所经历的加速度。这意味着，移动 Wiimote
    在空中时，提供了三个轴上的感应数据：*x*、*y* 和 *z*。通过这种方式，加速度计可以跟踪运动的方向和该方向的速度。参见 [图 4-8](ch04.xhtml#ch04fig8)
    以查看示意图。
- en: '![image](../images/f095-01.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f095-01.jpg)'
- en: '**FIGURE 4-8** The axes of motion the Wiimote’s accelerometer can detect'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-8** Wiimote 加速度计可以检测的运动轴'
- en: This kind of analog data is ideal for a variable-motor-speed remote control
    program. For example, the more you pitch the Wiimote in the *x* direction, the
    faster your robot could move forward.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模拟数据非常适合用于变速电机遥控程序。例如，你越是将 Wiimote 向 *x* 方向倾斜，机器人就越快地向前移动。
- en: Looking at the Data
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查看数据
- en: Before we rework the robot’s program, it would be incredibly helpful to see
    the raw data that the accelerometer from the Wiimote outputs. Once we have an
    idea of what that output looks like, we can think about how to manipulate that
    data to correspond to the robot’s movement.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们重新编写机器人的程序之前，查看 Wiimote 的加速度计输出的原始数据将非常有帮助。一旦我们了解了这些输出数据的样子，就可以考虑如何操控这些数据，使其与机器人的运动相对应。
- en: Power the Pi on your robot from a wall outlet, open a new file in Nano and call
    it *accel_test.py*, and then enter the code in [Listing 4-3](ch04.xhtml#ch04list3)—this
    script uses the `cwiid` library too, so if you haven’t installed that, see the
    instructions in “Installing and Enabling Bluetooth” on [page 88](ch04.xhtml#page_88).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从墙壁插座为机器人上的 Pi 供电，在 Nano 中打开一个新文件并命名为 *accel_test.py*，然后输入 [清单 4-3](ch04.xhtml#ch04list3)
    中的代码——此脚本也使用了 `cwiid` 库，因此如果你还没有安装它，请参阅“安装并启用蓝牙”中的说明，见 [第 88 页](ch04.xhtml#page_88)。
- en: '[PRE3]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**LISTING 4-3** The code to print raw accelerometer data'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**清单 4-3** 打印原始加速度计数据的代码'
- en: This simple program prints the Wiimote’s accelerometer data to the terminal
    every 0.01 seconds.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的程序每 0.01 秒将 Wiimote 的加速度计数据打印到终端。
- en: The `print()` statement denotes the start of the Wiimote setup ➊. The three
    following lines are the same as in the prior project, with the exception of the
    final line in that code block ➋, with which we’re not just turning on a Wiimote’s
    reporting mode like before, but also permitting Python to read values from both
    the buttons *and* the accelerometer. If you haven’t come across it before, the
    keyboard character in the middle of this line is called a *vertical bar* or a
    *pipe*. It is likely to be located on the same key as the backslash on your keyboard.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()`语句表示Wiimote设置的开始 ➊。接下来的三行与之前的项目相同，唯一的区别是代码块的最后一行 ➋，这行代码不仅开启了Wiimote的报告模式，还允许Python读取按钮*和*加速度计的值。如果你以前没见过，这行中的键盘字符被称为*竖线*或*管道符*。它通常与反斜杠在同一个键上。'
- en: An infinite `while` loop prints the status of the accelerometer ➌. The next
    line waits for 0.01 seconds between each *iteration* of the `while` loop so that
    the outputted data is more manageable. In programming, each time a loop goes round
    and executes again is called an iteration.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无限`while`循环打印加速度计的状态 ➌。下一行代码会在每次`while`循环迭代之间等待0.01秒，使得输出数据更易管理。在编程中，每次循环执行一次就称为一次迭代。
- en: 'You can run this program with the command:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下命令运行此程序：
- en: pi@raspberrypi:~/robot $ python3 accel_test.py
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ python3 accel_test.py
- en: 'After you pair your Wiimote, accelerometer data should start printing to the
    terminal. The following output is some of the data that I saw in my terminal:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 配对Wiimote后，加速度计数据应该开始打印到终端。以下是我在终端中看到的一些输出数据：
- en: '[PRE4]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each line of data is delivered as three values in parentheses, representing
    the x-, y-, and z-axes, respectively, which change as you move the Wiimote in
    the different axes. Experiment with different movements and watch as the figures
    go up and down. Exit the program by pressing CTRL-C.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行数据作为三个值以括号形式传递，分别代表x、y和z轴，这些值会随着你在不同轴上移动Wiimote而变化。试着进行不同的运动，观察这些数值的变化。按CTRL-C退出程序。
- en: 'With this raw data, we can put some thought into the next part of the programming
    process, namely answering the question: How can you translate those three figures
    into instructions for your robot? The best way to approach this problem is logically
    and in small steps.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些原始数据，我们可以开始思考下一部分编程过程，即回答这个问题：你如何将这三个数据转换为机器人指令？最好的方法是通过逻辑思考并分步骤解决问题。
- en: Figuring Out the Remote Movement Control
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 弄清楚远程运动控制
- en: 'First, consider the movement of your two-wheeled robot. Because it moves around
    only on the floor, and doesn’t fly up and down, its movement can be expressed
    in two dimensions: *x* and *y*, as shown in [Figure 4-9](ch04.xhtml#ch04fig9).
    We can disregard the z-axis data, which simplifies the problem substantially.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑你双轮机器人的运动。因为它只在地面上移动，不会上下飞行，所以它的运动可以用两个维度来表示：*x* 和 *y*，如[图 4-9](ch04.xhtml#ch04fig9)所示。我们可以忽略z轴数据，这样就大大简化了问题。
- en: '![image](../images/f097-01.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f097-01.jpg)'
- en: '**FIGURE 4-9** Only two axes of control are required for your two-wheeled robot.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-9** 你的双轮机器人只需要两个控制轴。'
- en: Second, consider how you wish to hold the Wiimote when controlling your robot.
    I have decided to hold it horizontally, with the 1 and 2 buttons close to my right
    hand, as shown in [Figure 4-10](ch04.xhtml#ch04fig10). This is the most common
    orientation for traditional Wii-based racing games and is ideal for controlling
    your robot.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，考虑你希望在控制机器人时如何握住Wiimote。我决定将其水平握持，1和2号按钮靠近我的右手，如[图 4-10](ch04.xhtml#ch04fig10)所示。这是传统基于Wii的赛车游戏最常见的握持方式，也是控制机器人时的理想选择。
- en: '![image](../images/f098-01.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f098-01.jpg)'
- en: '**FIGURE 4-10** How to hold the Wiimote in this project'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4-10** 本项目中如何握持Wiimote'
- en: When you’re holding the Wiimote in this way, pitching it backward and forward
    controls the *x* values. Tilting it side-to-side controls the *y* values.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以这种方式握住Wiimote时，向前和向后倾斜控制*x*值。左右倾斜控制*y*值。
- en: When you printed your accelerometer data, you may have noticed that the outputted
    numbers tended to be between 95 and 145\. You can run the test program again to
    observe this. This is because the lowest *x* value is 95, when the Wiimote is
    pitched all the way back. This highest value is 145, when it’s pitched entirely
    forward.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打印加速度计数据时，你可能会注意到输出的数字通常在 95 到 145 之间。你可以再次运行测试程序来观察这一点。之所以如此，是因为最低的 *x* 值为
    95，当 Wiimote 完全向后倾斜时；最高的值为 145，当它完全向前倾斜时。
- en: For the y-axes, left to right, the lowest value is 95 and the highest is 145\.
    The difference between 145 and 95 is 50, and this gives us the usable range of
    data in each axis. See [Figure 4-11](ch04.xhtml#ch04fig11) for an illustration
    of how the Wiimote’s values change.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 y 轴，从左到右，最低值是 95，最高值是 145。145 和 95 之间的差值是 50，这为我们提供了每个轴的可用数据范围。参见 [Figure
    4-11](ch04.xhtml#ch04fig11)，该图说明了 Wiimote 的值是如何变化的。
- en: So far in this chapter, you’ve controlled your robot’s movement by instructing
    it to go forward, backward, left, or right at full speed. We want to change this
    to vary the speed according to the accelerometer. Luckily, the `Robot` class from
    the GPIO Zero Python library has another way of turning the motors on and setting
    their speed that suits our needs.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，你通过指示机器人以全速向前、向后、向左或向右移动来控制其运动。我们希望改变这一点，根据加速度计的值来调整速度。幸运的是，GPIO
    Zero Python 库中的 `Robot` 类有另一种打开电机并设置其速度的方法，正好符合我们的需求。
- en: '![image](../images/f099-01.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![image](../images/f099-01.jpg)'
- en: '**FIGURE 4-11** The Wiimote’s extreme accelerometer values'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '**FIGURE 4-11** Wiimote 的极端加速度计值'
- en: The `Robot` class has an *attribute*—a variable that is part of a class—called
    `value`. At any given time, `value` represents the motion of the robot’s motors
    as a pair of numeric values between –1 and 1\. The first value in the pair is
    for the left motor’s speed, while the second value is for the right motor’s speed.
    For example, (–1, –1) represents full speed backward, whereas (0.5, 0.5) represents
    half speed forward. A value of (1, –1) would represent turning full speed right.
    By setting the `value` attribute, you can manipulate your robot in any direction
    you wish. This is going to come in super-handy in the upcoming program!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Robot` 类有一个 *属性*——一个类中的变量——叫做 `value`。在任何给定时刻，`value` 表示机器人电机的运动，是一对介于 -1
    和 1 之间的数值。这对数值中的第一个值表示左电机的速度，第二个值表示右电机的速度。例如，(–1, –1) 表示全速向后，(0.5, 0.5) 表示半速向前。值为
    (1, –1) 表示全速向右转。通过设置 `value` 属性，你可以将机器人操控至任何你希望的方向。这将在即将到来的程序中大有用处！'
- en: Programming Your Robot for Variable Speed
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编程使你的机器人实现变速
- en: Now that we’ve broken down this problem and found a neat and efficient final
    approach to the program, we can start coding! Use Nano to create a new program
    called *remote_control_accel.py* and input the code shown in [Listing 4-4](ch04.xhtml#ch04list4).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拆解了这个问题，并找到了一个简洁高效的最终方法来编写程序，我们可以开始编码了！使用 Nano 创建一个名为 *remote_control_accel.py*
    的新程序，并输入 [Listing 4-4](ch04.xhtml#ch04list4) 中显示的代码。
- en: '[PRE5]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**LISTING 4-4** Programming your robot to respond to the motion of your Wiimote'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**LISTING 4-4** 编程让你的机器人响应 Wiimote 的运动'
- en: '**NOTE**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Python (and many other programming languages) can deal with numbers in different
    ways. The main two number types in Python are called* integers *and* floats. *Integers
    are whole numbers that have no decimal point. Floats (floating-point real values)
    have decimal points and can represent both the integer and fractional part of
    a number. For example, 8 is an integer, whereas 8.12383 or 8.0 is a float. In
    the* remote_control_accel.py *program, we need to use floats, as the movement
    of your robot will be governed by two numbers in between –1 and 1*.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python（以及许多其他编程语言）可以以不同的方式处理数字。Python 中的主要两种数字类型是* 整数 *和* 浮点数。* 整数是没有小数点的整数。浮点数（浮动点实数）有小数点，能够表示数字的整数部分和小数部分。例如，8
    是一个整数，而 8.12383 或 8.0 是浮点数。在* remote_control_accel.py *程序中，我们需要使用浮点数，因为机器人运动将由两个介于
    -1 和 1 之间的数字控制。*'
- en: The program shares the same Wiimote setup process as the accelerometer test
    program. Then we set up a `while` loop to keep running our code. The first statement
    ➊ reads the *x* value from the accelerometer and then stores it in a variable
    called `x`. Within the variable, the value undergoes two arithmetic operations.
    First, 95 is subtracted; this limits the data to a value between 0 and 50, rather
    than between 95 and 145, so that it fits within the usable range we discovered
    earlier. Second, we subtract a further 25\. This ensures the range of data will
    be between –25 and +25\. Exactly the same process then happens for the *y* value,
    and the result is then stored in a variable called `y`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序与加速度计测试程序共享相同的Wiimote设置过程。然后，我们设置了一个`while`循环以保持代码的运行。第一个语句 ➊ 从加速度计读取*x*值，并将其存储在一个名为`x`的变量中。在该变量中，值经过两次算术操作。首先，减去95；这将数据限制在0到50之间，而不是在95到145之间，从而使其适应我们之前发现的可用范围。其次，再减去25。这确保了数据的范围将在-25到+25之间。然后对*y*值进行完全相同的处理，结果存储在一个名为`y`的变量中。
- en: We need to do this because the `value` attribute of the `Robot` class accepts
    negative values for backward movement and positive values for forward movement.
    This manipulation balances the accelerometer data on either side of 0, making
    it clear which values are for reverse and which are for forward movement.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这样做，因为`Robot`类的`value`属性接受负值表示后退运动，正值表示前进运动。这个操作平衡了加速度计数据的正负值，使得哪一边是后退，哪一边是前进变得清晰。
- en: The four `if` statements ➋ eliminate the chance for errors later in the program.
    In the unlikely event that the Wiimote’s accelerometer outputs data that is not
    within the –25 to +25 range, the `if` statements catch this occurrence and then
    round up or down to the relevant extremity.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 四个`if`语句 ➋ 消除了程序后续错误的可能性。在不太可能的情况下，如果Wiimote的加速度计输出的数据不在-25到+25的范围内，`if`语句会捕捉到这个情况，并将其四舍五入到相关的极限值。
- en: Next, the final x-axis value for the robot is determined and stored in a variable
    called `forward_value` ➌. This calculation divides the `x` variable value by 50,
    providing a new proportional number between –0.5 and 0.5\. This result is then
    multiplied by 2 to get a value between –1 and 1\. The same process is repeated
    to get the final y-axis value, which is then stored in a similar variable called
    `turn_value`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，确定机器人的最终x轴值并将其存储在一个名为`forward_value`的变量中 ➌。这个计算将`x`变量的值除以50，得到一个介于-0.5和0.5之间的新比例值。然后将这个结果乘以2，以获得一个介于-1和1之间的值。相同的过程会重复进行，以得到最终的y轴值，并将其存储在一个类似的变量`turn_value`中。
- en: The line at ➍ starts an `if`/`else` clause. If the `turn_value` is less than
    0.3 or greater than –0.3, `robot.value` is set to be the `forward_value`. So,
    if the Wiimote is tilted by *less than 30 percent* to either side, the program
    will assume that you want the robot to move forward/­backward. This means that
    your robot won’t turn in the wrong direction at the slightest tilt of your Wiimote.
    The forward/­backward speed of your robot is then set according to the pitch of
    your Wiimote. For example, if your Wiimote is pitched all the way forward, it
    will set `robot.value` to (1, 1) and your robot will accelerate forward.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第➍行开始了一个`if`/`else`条件语句。如果`turn_value`小于0.3或大于-0.3，则`robot.value`被设置为`forward_value`。因此，如果Wiimote倾斜不到30度，程序会假设你希望机器人前进或后退。这意味着Wiimote稍微倾斜时，机器人不会误转向。然后，机器人的前进/后退速度将根据Wiimote的俯仰角度来设置。例如，如果Wiimote完全向前倾斜，它将把`robot.value`设置为(1,
    1)，你的机器人将加速向前移动。
- en: Alternatively, if the Wiimote is tilted by more than 30 percent to either side,
    the program will assume that you want the robot to turn left or right on the spot.
    The program then turns the robot based on the angle of your Wiimote tilt. For
    example, if you have the Wiimote tilted all the way to the right, your robot will
    spin very quickly to the right; but if you have it tilted only slightly to the
    right, the robot will turn more slowly and in a more controlled manner.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果Wiimote倾斜超过30度，程序会假设你希望机器人在原地向左或向右转动。程序随后根据Wiimote的倾斜角度来旋转机器人。例如，如果Wiimote完全倾斜到右边，机器人会非常快速地向右旋转；但如果Wiimote只是稍微倾斜到右边，机器人则会较慢且更加平稳地转动。
- en: As usual, after you have finished your program, exit Nano and save your work.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，完成程序后，退出Nano并保存工作。
- en: 'Running Your Program: Remote-Control Your Robot with PWM'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行你的程序：通过PWM远程控制你的机器人
- en: 'Disconnect your robot from your wall outlet, and ensure that it is powered
    by its batteries. Then place it on a large surface and have your Wiimote in hand
    and in a horizontal orientation. To run your program, enter:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 断开你的机器人与墙壁插座的连接，确保它由电池供电。然后将它放置在一个大表面上，手持你的Wiimote并保持水平方向。要运行你的程序，请输入：
- en: pi@raspberrypi:~/robot $ python3 remote_control_accel.py
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: pi@raspberrypi:~/robot $ python3 remote_control_accel.py
- en: After you have gone through the familiar Bluetooth handshake process, your robot
    should come to life and start to move as you change the orientation of your Wiimote.
    Experiment with driving it around at different speeds and practice maneuvering!
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成熟悉的蓝牙握手过程后，你的机器人应该开始运行，并随着你改变Wiimote的方向而移动。试着用不同的速度驾驶它，并练习操作！
- en: 'Challenge Yourself: Refine your Remote-Controlled Robot'
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 挑战自己：完善你的遥控机器人
- en: When you have a feel for the behavior of your remote-controlled robot, take
    another look at the code and refine it as you see fit. For example, you could
    try to make the steering more sensitive, limit the speed of your robot, or even
    make your robot move in a predefined pattern when you press a button. The possibilities
    are endless!
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对遥控机器人的行为有了一定的了解后，重新查看代码并根据需要进行改进。例如，你可以尝试使转向更灵敏、限制机器人的速度，甚至让机器人在按下按钮时按照预定义的模式移动。可能性是无穷无尽的！
- en: SUMMARY
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter has taken you from having a robot-shaped paperweight to a fully
    functional Wiimote-controlled little machine! We have covered a wide range of
    concepts from H-bridges to PWM to accelerometers. Over the process you have written
    three programs, each more advanced than the last.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本章带领你将一个机器人形状的纸重物变成一个完全功能的Wiimote遥控小机器！我们涵盖了从H桥到PWM再到加速度计的广泛概念。在这个过程中，你写了三个程序，每个比上一个更高级。
- en: In the next chapter, I’ll guide you through making your robot a little bit more
    intelligent so that it can automatically avoid obstacles!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我将指导你如何使你的机器人变得更智能，使它能够自动避开障碍物！
