<html><head></head><body>
<h2 class="h" id="ch09"><span epub:type="pagebreak" id="page_269" class="calibre1"/><strong class="calibre2"><span class="big">9</span><br class="calibre3"/>PHYSICS</strong></h2>
<div class="bq">
<p class="center"><em class="calibre11">Physics is not a religion. If it were, we’d have a much easier time raising money.</em></p>
<p class="center1">—Leon M. Lederman</p>
</div>
<div class="image"><img alt="Image" src="../images/common.jpg" class="calibre6"/></div>
<p class="noindent">Julia is a superb platform for physics calculations of all kinds. Various features of its syntax, such as the ability to use mathematical symbols and its concise array operations, make it a natural fit for programming algorithms that we use in physics. Julia’s speed of execution makes it one of only a few languages used for the most demanding large-scale simulations (and the others in this club are all lower-level, statically compiled languages). Julia’s physics ecosystem includes some state-of-the-art packages. Finally, Julia’s unique ability to mix and match functions and data types from disparate packages to create new capabilities is especially powerful in physics calculations, as we’ll see in detail in this chapter.</p>
<p class="indent">We begin with an introduction to two packages of general utility for dealing with units and errors. Both of these are potentially helpful in any <span epub:type="pagebreak" id="page_270"/>physics project. We’ll spend some time in the first section looking into various options for producing publication-quality plots including typeset units in axis labels. Then we’ll turn to specific calculations, first using a package for fluid dynamics and then using a general-purpose differential equation solver. See “Further Reading” on <a href="ch09.xhtml#fur9" class="calibre10">page 304</a> for each major package’s URL.</p>
<h3 class="h2" id="ch09lev1"><strong class="calibre2">Bringing Physical Units into the Computer with Unitful</strong></h3>
<p class="noindent">The traditional way to perform physics calculations on a computer is to represent physical quantities as floating-point numbers, subject those numbers to a long series of arithmetic operations, and then interpret the results again as physical quantities. Since physical quantities are usually not simply numbers, but have <em class="calibre11">dimensions</em>, we need to manually keep track of the <em class="calibre11">units</em> that are associated with these quantities, often with code comments to remind us what the various units are.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">A</em> dimension <em class="calibre11">is a fundamental physical idea encompassing something that can be measured, such as mass or time. A</em> unit <em class="calibre11">is a specific way of measuring a dimension. The dimensions are universal, but there are various systems of units. For example, for the dimension of length, some common units are centimeter (cm), meter (m), or, if we live in the United States, inches or football fields.</em></p>
</div>
<p class="indent">In other words, the physical meanings of the numbers appearing in a program are not part of the quantities themselves, but are implicit. It may not be surprising that this can lead to confusion and errors. In 1999, NASA lost a spacecraft because two different contractors were contributing to the design, and their engineering programs used different systems of units.</p>
<p class="indent">In traditional languages for physics, such as Fortran, not much can be done about this issue directly. In Julia, because of its sophisticated type system, we are not limited to collections of dimensionless numbers; we can calculate with richer objects including units.</p>
<p class="indent">After importing the <span class="literal">Unitful</span> package, we can refer to many common physics units using a nonstandard string literal (see “Nonstandard String Literals” on <a href="ch05.xhtml#ch05lev4" class="calibre10">page 128</a>) with the prefix <span class="literal">u</span>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Unitful</span>

julia&gt; <span class="codestrong">u"1m" + u"1cm"</span>
101//100 m

julia&gt; <span class="codestrong">u"1.0m" + u"1cm"</span>
1.01 m

julia&gt; <span class="codestrong">u"1.0m/1s"</span>
1.0 m s^-1</pre>
<p class="noindent">Here we add a meter and a centimeter, and receive the result as a rational number of meters. The package returns results as rational numbers, when <span epub:type="pagebreak" id="page_271"/>possible, to preserve the ability to carry out exact conversions. But, as the second example shows, we can coerce a floating-point result by supplying a floating-point coefficient. The third example shows how we can construct expressions within the string literal.</p>
<p class="indent">You can find the complete list of units only in the source code, in its GitHub repository at <em class="calibre11">src/pkgdefaults.jl</em>, but most of them follow the usual physics conventions. Using the string literal syntax each time we want to refer to a unit can be cumbersome, so we can assign units to our own variables to ease our typing and make the code easier to read:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">m = u"m";</span>

julia&gt; <span class="codestrong">1m + u"1km"</span>
1001 m</pre>
<p class="indent">We add a meter to a kilometer, showing how we can use custom variables in combination with the string literals. The result is 1,001 meters.</p>
<p class="indent">We can parse a string as a <span class="literal">Unitful</span> expression with another function provided by the package (undocumented at the time of writing):</p>
<pre class="calibre13">julia&gt; <span class="codestrong">earth_accel = "9.8m/s^2";</span>

julia&gt; <span class="codestrong">kg_weight_earth = uparse("kg * " * earth_accel)</span>
9.8 kg m s^-2</pre>
<p class="indent">Here we use <span class="literal">uparse()</span> to convert a string, created by concatenating a string representing a mass with another representing the gravitational acceleration near the surface of Earth, into a unit expression representing the mass’s weight. The forms in which unit expressions appear in the REPL are not themselves legal strings for converting with <span class="literal">uconvert()</span>. For example, we need to include the multiplication operator in the string in the second line.</p>
<h4 class="h3" id="ch09lev1sec1"><strong class="calibre2"><em class="calibre4">Using Unitful Types</em></strong></h4>
<p class="noindent">We can gain access to a large supply of standard SI units by importing the <span class="literal">DefaultSymbols</span> submodule rather than defining them one by one. This practice adds a profusion of names to our namespace, however, so it may not be a good idea if we’re using only a few units:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Unitful.DefaultSymbols</span>

julia&gt; <span class="codestrong">minute = u"minute"</span>

julia&gt; <span class="codestrong">2s + 1minute</span>
62 s</pre>
<p class="noindent">Here we add 2 seconds to 1 minute, resulting in 62 seconds. The <span class="literal">DefaultSymbols</span> submodule supplies the <span class="literal">s</span> unit, but we need to define <span class="literal">minute</span>, as that’s not an SI unit. We’re using Julia’s syntax for multiplication through juxtaposition; this <span epub:type="pagebreak" id="page_272"/>expression is the same as <span class="literal">2 * s + 1minute</span>. However, these variables must be attached to numerical coefficients in arithmetic expressions; <span class="literal">2 * s + minute</span> is a <span class="literal">MethodError</span>.</p>
<p class="indent">We can find the reason for this error in the types of the two expressions:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">typeof(1minute)</span>
Quantity{Int64, <span class="codestrong">T</span>, Unitful.FreeUnits{(minute,), <span class="codestrong">T</span>, nothing}}

julia&gt; <span class="codestrong">typeof(minute)</span>
Unitful.FreeUnits{(minute,), <span class="codestrong">T</span>, nothing}</pre>
<p class="indent">The type of <span class="literal">1minute</span>, which is the same as the type of <span class="literal">1 * minute</span>, is a <span class="literal">Quantity</span>, while the type of <span class="literal">minute</span> is a <span class="literal">FreeUnits</span>. Both of these types are defined in the package. The <span class="literal">Unitful</span> package defines methods for addition and other arithmetic operations that accept arguments of type <span class="literal">Quantity</span>, but not of type <span class="literal">FreeUnits</span>.</p>
<p class="indent">These types contain parameters appearing as boldface Unicode characters. The <span class="literal">Unitful</span> package uses these characters to represent dimensions, so these type specifications tell us that the <span class="literal">minute</span> unit has dimensions of time, represented by <span class="literal"><strong class="calibre7">T</strong></span>.</p>
<p class="indent">The type of <span class="literal">minute</span> and other units is an abstract type (see “The Type Hierarchy” on <a href="ch08.xhtml#ch08lev1sec4" class="calibre10">page 222</a>), while the types of quantified units such as <span class="literal">1minute</span> are concrete. For good performance, we should calculate with concrete types and define our own types with fields that have concrete types only.</p>
<h4 class="h3" id="ch09lev1sec2"><strong class="calibre2"><em class="calibre4">Stripping and Converting Units</em></strong></h4>
<p class="noindent">Sometimes we need to remove the units from the result of a calculation—for example, when passing a result to a function that doesn’t understand units. We can do this with the <span class="literal">convert()</span> function:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">convert(Float64, u"1m/100cm")</span>
1.0</pre>
<p class="indent">The type of the result is <span class="literal">Float64</span>. The results returned by <span class="literal">Unitful</span> calculations may not always be what we expect, so we should use <span class="literal">convert()</span> when we require a simple number:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">u"1m / 100cm"</span>
0.01 m cm^-1

julia&gt; <span class="codestrong">typeof(u"1m/100cm")</span>
Quantity{Float64, NoDims, Unitful.FreeUnits{(cm^-1, m), NoDims, nothing}}</pre>
<p class="noindent">Here we divide a length by another length, so the result should be the simple number 1.0 (because the lengths are equal) with no dimensions. The actual result is equivalent to that, but it’s expressed in an obscure form. Checking the type of the result, we find that it’s the concrete <span class="literal">Unitful</span> type <span class="literal">Quantity</span>, with type parameters indicating that it has no dimensions.</p>
<p class="indent"><span epub:type="pagebreak" id="page_273"/>If we use the same literal unit in the numerator and denominator, we get a result that may be closer to what we expect:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">u"1m / 2m"</span>
0.5

julia&gt; <span class="codestrong">typeof(u"1m / 2m")</span>
Float64</pre>
<p class="indent">A further example shows that <span class="literal">Unitful</span> is consistent in retaining the units we use in expressions instead of making conversions that might seem obvious to a physicist:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">u"1m * 1m"</span>
1 m^2

julia&gt; <span class="codestrong">u"1m * 100cm"</span>
100 cm m</pre>
<p class="noindent">The two input expressions mean the same thing, but lead to equivalent results that are expressed differently.</p>
<p class="indent">The function <span class="literal">upreferred()</span> from <span class="literal">Unitful</span> converts expressions so they use a standard set of units. The user can establish preferred systems of units, but the default behavior uses conventional SI units:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">u"1m * 100cm" |&gt; upreferred</span>
1//1 m^2</pre>
<p class="indent">In addition to converting to a number with <span class="literal">convert()</span>, we can use <span class="literal">uconvert()</span>, which is part of <span class="literal">Unitful</span>, to convert between units:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">uconvert(u"J", u"1erg")</span>
1//10000000 J

julia&gt; <span class="codestrong">uconvert(u"kg", u"2slug")</span>
29.187805874412728 kg</pre>
<p class="noindent">The function takes the unit to convert to in its first argument and the expression to convert in its second argument. In the first example we convert from ergs to joules. As both are metric units related by an exact ratio, <span class="literal">uconvert()</span> supplies the answer using a rational coefficient. The second example is a conversion from the US unit of mass, slugs, to kilograms, the standard SI unit used in physics. The conversion factor is a floating-point number.</p>
<p class="indent"><a href="ch09.xhtml#ch9lis1" class="calibre10">Listing 9-1</a> shows another way to extract the purely numerical part of a <span class="literal">Unitful</span> expression with <span class="literal">ustrip()</span>.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">vi = 17u"m/s"</span>
17 m s^-1

<span epub:type="pagebreak" id="page_274"/>julia&gt; <span class="codestrong">vf = 17.0u"m/s"</span>
17.0 m s^-1

julia&gt; <span class="codestrong">ustrip(v), ustrip(vf)</span>
(17, 17.0)</pre>
<p class="list" id="ch9lis1"><em class="calibre11">Listing 9-1: Stripping units with</em> <span class="codeitalic">ustrip()</span></p>
<p class="noindent">The <span class="literal">ustrip()</span> function preserves the numerical type in the expression.</p>
<p class="indent">To extract just the unit from a <span class="literal">Unitful</span> expression, the package provides the <span class="literal">unit()</span> function, as shown in <a href="ch09.xhtml#ch9lis2" class="calibre10">Listing 9-2</a>.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">unit(vi)</span>
m s^-1</pre>
<p class="list" id="ch9lis2"><em class="calibre11">Listing 9-2: Extracting units with</em> <span class="codeitalic">unit()</span></p>
<p class="indent">We’ll find applications for <span class="literal">ustrip()</span> and <span class="literal">unit()</span> in “Plotting with Units” on <a href="ch09.xhtml#ch09lev1sec4" class="calibre10">page 276</a>.</p>
<h4 class="h3" id="ch09lev1sec3"><strong class="calibre2"><em class="calibre4">Typesetting Units</em></strong></h4>
<p class="noindent">Using the <span class="literal">UnitfulLatexify</span> package, we can turn our <span class="literal">Unitful</span> expressions into LaTeX-typeset mathematics: either as LaTeX source ready to be dropped into a research paper or as a rendered image. Here is a simple example:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Unitful, Latexify, UnitfulLatexify</span>

julia&gt; <span class="codestrong">9.8u"m/s^2" |&gt; latexify</span>
L"$9.8\;\mathrm{m}\,\mathrm{s}^{-2}$"</pre>
<p class="indent">The <span class="literal">latexify()</span> function transforms the <span class="literal">Unitful</span> expression for Earth’s gravitational acceleration into a LaTeX string. We encountered La TeXstrings in <a href="ch04.xhtml#ch4lis1" class="calibre10">Listing 4-1</a>, when we used one to generate a title for a graph. The <span class="literal">UnitfulLatexify</span> package combines the LaTeX abilities in <span class="literal">Latexify</span> with <span class="literal">Unitful</span>, which is why we need to import all three packages, as we did at the start of this example.</p>
<p class="indent">When used in the REPL or another nongraphical context, <span class="literal">latexify()</span> produces LaTeX markup ready to be copied and pasted into a document. We can, instead, create a PDF image of the result by passing it to the <span class="literal">render()</span> function. To do that, you need to have the external program <span class="literal">LuaLaTeX</span>, which is part of standard LaTeX installations, installed. If that program is available, <span class="literal">render()</span> will use it to typeset the LaTeX string and immediately display it with the default PDF viewer. The <span class="literal">render()</span> process litters your temporary directory with files for every rendered expression, which is something to keep an eye on.</p>
<p class="indent">When using <span class="literal">UnitfulLatexify</span> in a graphical environment, such as a Pluto notebook, the output is rendered as LaTeX rather than LaTeX source. In most environments, typesetting uses a built-in engine rather than an external program, so no additional installations are required. For example, Pluto uses MathJax, a JavaScript library for LaTeX mathematical typesetting.</p>
<p class="noindent"><span epub:type="pagebreak" id="page_275"/><a href="ch09.xhtml#ch9fig1" class="calibre10">Figure 9-1</a> shows a Pluto session with Newton’s Second Law of Motion.</p>
<div class="image1"><img alt="Image" id="ch9fig1" src="../images/ch09fig01.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-1: Using</em> <span class="codeitalic">UnitfulLatexify</span> <em class="calibre11">in Pluto</em></p>
<p class="indent">In the final cell in <a href="ch09.xhtml#ch9fig1" class="calibre10">Figure 9-1</a>, we convert the acceleration to a more conventional combination of units and pass the result to <span class="literal">latexify()</span>. The typeset version appears as the result. MathJax provides a contextual menu when right-clicking on the result that gives us access to the LaTeX source.</p>
<p class="indent">If the use of negative exponents in unit expressions is not to our taste, we can pass the <span class="literal">permode</span> keyword to tell <span class="literal">latexify()</span> to use other styles. Here’s an example that demonstrates the default and the two options for <span class="literal">permode</span>:</p>
<pre class="calibre13">julia&gt; a = 0.0571u"m/s^2"

julia&gt; """
       <span class="codestrong">a = $(latexify(a))</span>

       <span class="codestrong">or</span>

       <span class="codestrong">$(latexify(a; permode=:frac))</span>

       <span class="codestrong">or</span>

       <span class="codestrong">$(latexify(a; permode=:slash))</span>

       <span class="codestrong">""" |&gt; println</span>
a = $0.0571\;\mathrm{m}\,\mathrm{s}^{-2}$

or

<span epub:type="pagebreak" id="page_276"/>$0.0571\;\frac{\mathrm{m}}{\mathrm{s}^{2}}$

or

$0.0571\;\mathrm{m}\,/\,\mathrm{s}^{2}$</pre>
<p class="indent">The example uses the existing definition for <span class="literal">a</span>. The <span class="literal">:frac</span> option uses LaTeX fractions instead of negative exponents, and the <span class="literal">:slash</span> option uses a slash, which is usually better for inline math.</p>
<p class="indent">Pasting the output in the previous listing into the LaTeX source of this book shows the rendered result:</p>
<div class="bqparan">
<p class="noindentin">a = 0.0571 m s<sup class="calibre23">−2</sup></p>
<p class="noindentin">or</p>
<p class="noindentin">0.0571 <img alt="Image" src="../images/276math.jpg" class="calibre6"/></p>
<p class="noindentin">or</p>
<p class="noindentin">0.0571 m/s<sup class="calibre23">2</sup></p>
</div>
<p class="noindent">We can change the default mode for rendering units with the <span class="literal">set_default(permode=:slash)</span> command.</p>
<h4 class="h3" id="ch09lev1sec4"><strong class="calibre2"><em class="calibre4">Plotting with Units</em></strong></h4>
<p class="noindent"><a href="ch09.xhtml#ch9lis3" class="calibre10">Listing 9-3</a> shows how <span class="literal">Plots</span> knows how to handle <span class="literal">Unitful</span> quantities.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Plots, Unitful</span>
julia&gt; <span class="codestrong">mass = 6.3u"kg";</span>
julia&gt; <span class="codestrong">velocity = (0:0.05:1)u"m/s";</span>
julia&gt; <span class="codestrong">KE = mass .* velocity.^2 ./ 2;</span>
julia&gt; <span class="codestrong">plot(velocity, KE; xlabel="Velocity", ylabel="KE",</span>
       <span class="codestrong">lw=3, legend=:topleft, label="Kinetic Energy")</span></pre>
<p class="list" id="ch9lis3"><em class="calibre11">Listing 9-3: Plotting</em> <span class="codeitalic">Unitful</span> <em class="calibre11">arrays</em></p>
<p class="indent">Here we import <span class="literal">Plots</span>, which we need for plotting, and <span class="literal">Unitful</span>, to handle units. After defining a mass in kilograms and a range of velocities in meters per second, we create an array of kinetic energies, <span class="literal">KE</span>, from the fact that kinetic energy = 1/2 mass × velocity<sup class="calibre23">2</sup>. The new package gives the plotting functions in <span class="literal">Plots</span> the ability to handle quantities with units and automatically appends the units to the axis labels. <a href="ch09.xhtml#ch9fig2" class="calibre10">Figure 9-2</a> shows the result of the <span class="literal">plot()</span> statement.</p>
<div class="image1"><img alt="Image" id="ch9fig2" src="../images/ch09fig02.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-2: The plot that <a href="ch09.xhtml#ch9lis3" class="calibre10">Listing 9-3</a> generates</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_277"/>I’ve left the energy units alone for this example, but more conventional physics usage would involve a conversion to joules using <span class="literal">uconvert()</span>, which we could have done before the plotting call or inline within <span class="literal">plot()</span>.</p>
<p class="indent">We were able to create this graph with the same <span class="literal">plot()</span> call that we might have used to plot the same quantities stored in numerical arrays without units. All the plotting functions in <span class="literal">Plots</span>, such as <span class="literal">scatter()</span> and <span class="literal">surface()</span>, work with <span class="literal">Unitful</span> arrays to produce similar axis labels.</p>
<h4 class="h3" id="ch09lev1sec5"><strong class="calibre2"><em class="calibre4">Making Plots for Publication</em></strong></h4>
<p class="noindent">When attempting to make high-quality plots for publication, however, we encounter some shortcomings. While <span class="literal">Plots</span> aspires to create a unified interface to a variety of backends, each plotting engine works somewhat differently, with each having unique capabilities and limitations.</p>
<p class="indent">These differences among backends become more salient when we are making the final adjustments that accompany the preparation of graphs for publication. It is at this stage that, for example, the typographic details in labels and annotations become important. <a href="ch09.xhtml#ch9fig2" class="calibre10">Figure 9-2</a> was created using the <span class="literal">GR</span> backend, which, as mentioned in “Useful Backends” on <a href="ch04.xhtml#ch04lev11" class="calibre10">page 115</a>, is the default at the time of writing, and is fast and capable.</p>
<p class="indent"><span epub:type="pagebreak" id="page_278"/><a href="ch09.xhtml#ch9fig2" class="calibre10">Figure 9-2</a> may be acceptable as is, but for publication we may want to improve the appearance of its graph labels, especially to make the unit notations look like conventional mathematical notation. As we saw in “LaTeX Titles and Label Positioning by Data” on <a href="ch04.xhtml#ch04lev1sec12" class="calibre10">page 103</a>, we can use LaTeX notation in graph annotations with mathematical content. This also works for the automatic labeling using units with the packages we’ve already imported:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Plots, Unitful, Latexify, UnitfulLatexify</span>

julia&gt; <span class="codestrong">plot(velocity, KE; xlabel="\\textrm{Velocity}",</span>
       <span class="codestrong">ylabel="\\textrm{KE}", unitformat=latexroundunitlabel)</span></pre>
<p class="indent">The example repeats the plot command from <a href="ch09.xhtml#ch9lis3" class="calibre10">Listing 9-3</a>, but with some alterations to create LaTeX strings for the plot labels. The <span class="literal">unitformat</span> keyword processes the unit annotations through <span class="literal">latexify()</span>, with the value <span class="literal">latexroundunitlabel</span> retaining the parentheses around the units. Since this triggers placing the entire label into a LaTeX string, we also need to wrap the non-math parts of the labels in LaTeX commands to set them as normal text instead of math.</p>
<h5 class="h4" id="ch09sec1sec1"><strong class="calibre2">The GR Backend</strong></h5>
<p class="noindent">The results of this approach depend critically on what backend we’re using. Obviously, it makes sense to use LaTeX strings only with backends that can do something with them. Although the default <span class="literal">GR</span> backend can interpret LaTeX, the results are not always adequate. This engine includes its own version of LaTeX processing, which often creates poor-quality typesetting with faulty kerning. The LaTeX engine in <span class="literal">GR</span> is the focus of some development activity, however, so its performance may improve.</p>
<p class="indent">Good-quality typesetting of labels in most cases requires processing by an external TeX engine, which involves a TeX installation such as TeXLive. As many physicists and other scientists have already made such an installation, we’ll move on to considering options that take advantage of it.</p>
<h5 class="h4" id="ch09sec1sec2"><strong class="calibre2">The Gaston Backend</strong></h5>
<p class="noindent">Gnuplot can optionally be compiled with support for the <span class="literal">tikz</span> terminal, which saves plots as text files containing TikZ commands. (TikZ is a graphics language that comes with most full-featured TeX installations.) Such files are processed with LaTeX and can contain TeX or LaTeX markup for the annotations on the plot. The result is of the highest quality, with fonts and styles that match the document in which the plot is included. Unfortunately, at the time of writing, the <span class="literal">Gaston</span> backend, which uses gnuplot, does not properly support the <span class="literal">tikz</span> terminal, so this option is off the table. It’s being worked on, however, and once we can use <span class="literal">Gaston</span> with <span class="literal">tikz</span>, it will be the best option for complex plots for publication or when the best typographic quality is desired.</p>
<h5 class="h4" id="ch09sec1sec3"><span epub:type="pagebreak" id="page_279" class="calibre1"/><strong class="calibre2">The PGFPlotsX Backend</strong></h5>
<p class="noindent">Another backend that can make use of LaTeX strings is <span class="literal">PGFPlotsX</span>, which is invoked with the <span class="literal">pgfplotsx()</span> function. This backend creates plots by calling out to the LuaLaTeX TeX engine, which comes with most TeX installations, including TeXLive. Since LuaLaTeX does all the typesetting, the labels come out with TeX-level quality. This backend is, therefore, an excellent choice for publication-quality graphs. <span class="literal">Gaston</span> may still be the best future choice for complex plots because processing through LuaLaTeX can be far slower than through gnuplot if the plot contains a large number of elements, such as in a large scatterplot.</p>
<h5 class="h4" id="ch09sec1sec4"><strong class="calibre2">Handling Units Manually</strong></h5>
<p class="noindent">Unfortunately, <span class="literal">PGFPlotsX</span> does not work properly with <span class="literal">Unitful</span>, not taking TeX processing into account. This limitation provides the opportunity to demonstrate a different way of plotting <span class="literal">Unitful</span> quantities and labeling axes with units—one that affords us complete control over the details.</p>
<p class="indent">The following listing contains the definition of a function that accepts two <span class="literal">Unitful</span> arrays for plotting, along with keyword arguments for labels:</p>
<pre class="calibre13">using Plots, LaTeXStrings, Latexify, UnitfulLatexify

function plot_with_units(ux, uy; xl="", yl="", label="",
                         legend=:topleft, plotfile="plotfile")

    set_default(permode=:slash)
    x = ustrip(ux); y = ustrip(uy)
 <span class="ent">➊</span> xlabel = L"$\textrm{%$xl}$ (%$(latexify(unit(eltype(ux)))))"
    ylabel = L"$\textrm{%$yl}$ (%$(latexify(unit(eltype(uy)))))"

    plot(x, y; xlabel, ylabel, lw=2, label, legend)
 <span class="ent">➋</span> savefig(plotfile * ".tex")
    savefig(plotfile * ".pdf")

end</pre>
<p class="indent">Using the <span class="literal">ustrip()</span> and <span class="literal">unit()</span> functions (see <a href="ch09.xhtml#ch9lis1" class="calibre10">Listings 9-1</a> and <a href="ch09.xhtml#ch9lis2" class="calibre10">9-2</a>), this code separates the arrays from their associated units, plotting the numerical parts and using the unit parts to construct labels with the <span class="literal">LaTeXStrings</span> package.</p>
<p class="indent">In order to interpolate values into a <span class="literal">LaTeXStrings</span> string, we need to use the two characters <span class="literal">%$</span> rather than a simple <span class="literal">$</span> <span class="ent">➊</span>. When extracting the units from the arrays, we require the units of the elements of the array, which is why <span class="literal">eltype()</span> appears in the label assignment. The function saves both the stand-alone PDF version of the graph and its TeX version <span class="ent">➋</span> for including in a LaTeX document.</p>
<p class="indent"><span epub:type="pagebreak" id="page_280"/>After selecting the desired backend, we call the function to create the <em class="calibre11">.pdf</em> and <em class="calibre11">.tex</em> files with the default names:</p>
<pre class="calibre13">pgfplotsx()
plot_with_units(velocity, KE; xl="Velocity", yl="K. E.")</pre>
<p class="indent"><a href="ch09.xhtml#ch9fig3" class="calibre10">Figure 9-3</a> shows the result.</p>
<div class="image1"><img alt="Image" id="ch9fig3" src="../images/ch09fig03.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-3: A</em> <span class="codeitalic">PGFPlotsX</span> <em class="calibre11">plot with typeset unit labels</em></p>
<p class="indent">Typesetting by LuaTeX provides the excellent quality of the labels in <a href="ch09.xhtml#ch9fig3" class="calibre10">Figure 9-3</a>.</p>
<h3 class="h2" id="ch09lev2"><strong class="calibre2">Error Propagation with Measurements</strong></h3>
<p class="noindent">In the previous section we explored a package that extended the concept of numbers to include physical units. Here we’ll meet <span class="literal">Measurements</span>, another package that defines a number-like object useful for calculations in physics or nearly any empirical science.</p>
<p class="indent">The <span class="literal">Measurements</span> package allows us to attach uncertainties to numbers. The number in question must be convertible to a float, so we can attach uncertainties directly to <span class="literal">Float64</span> numbers, integers, and <span class="literal">Irrational</span> quantities. (We can also create complex numbers with uncertainties, if we really want to, by attaching errors to their real and imaginary parts.) The <span class="literal">Measurements</span> package defines a new data type, called <span class="literal">Measurement{T}</span>, where <span class="literal">T</span> can be any size float. We can perform any arithmetic operations on <span class="literal">Measurement</span> types that are allowed on floats, and the errors, or uncertainties, will be propagated to the result using standard linear error propagation theory.</p>
<p class="indent">Here are some examples of creating instances of <span class="literal">Measurement</span> types:</p>
<span epub:type="pagebreak" id="page_281"/>
<pre class="calibre13">   julia&gt; <span class="codestrong">using Measurements</span>

   julia&gt; <span class="codestrong">92 ± 3</span>
   92.0 ± 3.0

   julia&gt; <span class="codestrong">typeof(ans)</span>
   Measurement{Float64}

<span class="ent">➊</span> julia&gt; <span class="codestrong">92.0f0 ± 3</span>
   92.0 ± 3.0

   julia&gt; <span class="codestrong">typeof(ans)</span>
   Measurement{Float64}

   julia&gt; <span class="codestrong">92.0f0 ± 3f0</span>
   92.0 ± 3.0

   julia&gt; <span class="codestrong">typeof(ans)</span>
   Measurement{Float32}

   julia&gt; <span class="codestrong">big(1227.0) ± 2</span>
   1227.0 ± 2.0

   julia&gt; <span class="codestrong">typeof(ans)</span>
   Measurement{BigFloat}</pre>
<p class="indent">We create <span class="literal">Measurement</span> objects using a notation that will be familiar to scientists. We can type the <span class="literal">±</span> operator by entering <span class="codestrong1">\pm</span> in the REPL and pressing <small class="calibre5">TAB</small> or by using the operating system’s entry method for special characters.</p>
<p class="indent">In the REPL, the <span class="literal">ans</span> variable holds the most recently returned result. Since <span class="literal">Measurement</span> objects have only one type parameter, the base number and the error must be of the same type. As the <span class="literal">typeof()</span> calls show, <span class="literal">Measurements</span> promotes the smaller type as needed; the <span class="literal">f0</span> suffix is a way to enter 32-bit float literals <span class="ent">➊</span>.</p>
<p class="indent">The package treats significant digits intelligently:</p>
<pre class="calibre13">julia&gt; π <span class="codestrong">± 0.001</span>
3.1416 ± 0.001

julia&gt; π <span class="codestrong">± 0.01</span>
3.142 ± 0.01</pre>
<p class="noindent">The digits made insignificant by the error are not printed.</p>
<p class="indent">When printing results in the REPL, the package displays only two significant digits in the error, to keep things neat:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">m1 = 2.20394232 ± 0.00343</span>
2.2039 ± 0.0034

<span epub:type="pagebreak" id="page_282"/>julia&gt; <span class="codestrong">Measurements.value(m1)</span>
2.20394232

julia&gt; <span class="codestrong">Measurements.uncertainty(m1)</span>
0.00343</pre>
<p class="indent">However, it retains the full values internally for computations. We can access these components with the <span class="literal">value()</span> and <span class="literal">uncertainty()</span> functions shown here, which, as they are not exported, we need to qualify with the package namespace.</p>
<p class="indent">Scientists often use an alternative, convenient notation to express uncertainty by appending the error in the final significant digits within parentheses. The <span class="literal">Measurements</span> package understands this notation as well:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">emass = measurement("9.1093837015(28)e-31")</span>
9.1093837015e-31 ± 2.8e-40</pre>
<p class="indent">In order to use the notation, we need to employ the <span class="literal">measurement()</span> function and supply the argument as a string. We can also use <span class="literal">measurement()</span> as an alternative to the <span class="literal">±</span> operator:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">m1 = measurement(20394232, 0.00343)</span>
2.0394232e7 ± 0.0034</pre>
<p class="indent">Arithmetic operations propagate errors correctly:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">emass</span>
9.1093837015e-31 ± 2.8e-40

julia&gt; <span class="codestrong">2emass</span>
1.8218767403e-30 ± 5.6e-40

julia&gt; <span class="codestrong">emass + emass</span>
1.8218767403e-30 ± 5.6e-40

julia&gt; <span class="codestrong">emass/2</span>
4.5546918508e-31 ± 1.4e-40

julia&gt; <span class="codestrong">emass/2emass</span>
0.5 ± 0.0</pre>
<p class="indent">All these examples perform arithmetic as might be expected on the quantities and their errors. More interesting is the last example, where <span class="literal">Measurements</span> has recognized a ratio that has no error. The package maintains the notion of correlated and independent measurements, which is explained in its documentation. See “Further Reading” on <a href="ch09.xhtml#fur9" class="calibre10">page 304</a> for the URL.</p>
<p class="indent">Referring back to the example in <a href="ch09.xhtml#ch9lis3" class="calibre10">Listing 9-3</a>, we can add an uncertainty to the <span class="literal">Unitful</span> value for mass in two ways:</p>
<span epub:type="pagebreak" id="page_283"/>
<pre class="calibre13">julia&gt; <span class="codestrong">using Measurements, Unitful</span>

julia&gt; <span class="codestrong">mass = 6.3u"kg" ± 0.5u"kg"</span>
6.3 ± 0.5 kg

julia&gt; <span class="codestrong">mass = 6.3u"kg"; mass = (1 ± 0.5/6.3) * mass</span>
6.3 ± 0.5 kg</pre>
<p class="noindent">This example shows that the packages <span class="literal">Measurements</span> and <span class="literal">Unitful</span> can work together to create quantities with both units and uncertainties.</p>
<p class="indent">Let’s continue with the example from <a href="ch09.xhtml#ch9lis3" class="calibre10">Listing 9-3</a> using this new value for <span class="literal">mass</span>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Plots</span>

julia&gt; <span class="codestrong">velocity = (0:0.05:1)u"m/s";</span>

julia&gt; <span class="codestrong">KE = mass .* velocity.^2 ./ 2;</span>

julia&gt; <span class="codestrong">plot(velocity, uconvert.(u"J", KE); xlabel="Velocity", ylabel="K.E.",</span>
       <span class="codestrong">lw=2, legend=:topleft, label="Kinetic energy")</span></pre>
<p class="indent">Although, as before, <span class="literal">velocity</span> has no uncertainty attached to it, <span class="literal">mass</span> does; therefore, <span class="literal">KE</span> should also contain uncertainties.</p>
<p class="indent"><a href="ch09.xhtml#ch9fig4" class="calibre10">Figure 9-4</a> shows the result.</p>
<div class="image1"><img alt="Image" id="ch9fig4" src="../images/ch09fig04.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-4: Plotting with units and errors</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_284"/><a href="ch09.xhtml#ch9fig4" class="calibre10">Figure 9-4</a> shows the <span class="literal">Unitful</span> arrays plotted as before with the axes labeled with their units. It also has error bars, showing how the error increases as the kinetic energy increases. We didn’t have to change anything in the call to <span class="literal">plot()</span>. Somehow the type of the quantities to be plotted triggered the plotting function to use both unit labels and error bars. We would observe the same behavior with the other plotting functions in <span class="literal">Plots</span>, such as <span class="literal">scatter()</span> or <span class="literal">surface()</span>.</p>
<h3 class="h2" id="ch09lev3"><strong class="calibre2">Fluid Dynamics with Oceananigans</strong></h3>
<p class="noindent">The <span class="literal">Oceananigans</span> package for fluid dynamics simulations is especially well suited, as the name suggests, to the physics of the ocean. It provides a simulation construction kit that can include the effects of temperature and salinity variations, Earth’s rotation, wind, and more. Its defaults usually perform well, but it’s flexible enough that the user can specify one of several available solution methods. It has various physics models built in, including a linear equation of state, but makes it easy to substitute others of the user’s devising.</p>
<h4 class="h3" id="ch09lev1sec6"><strong class="calibre2"><em class="calibre4">The Physical System</em></strong></h4>
<p class="noindent">We are setting out to simulate a two-dimensional layer of fluid in Earth’s gravitational field. The bottom of the layer is maintained at a higher temperature than the top. This heating from below creates a convective motion, as can be seen in clouds or in a pan on the stove.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><span class="codeitalic1">Oceananigans</span> <em class="calibre11">depends on some compiled binaries in the standard library. If the precompilation of</em> <span class="codeitalic1">Oceananigans</span> <em class="calibre11">fails and you’re using a recent or beta version of Julia, try it with an earlier Julia release (the previous major version number).</em></p>
</div>
<p class="indent">The bottom and top simulation boundaries are impenetrable and freeslip, which means the fluid can slide across them. Horizontally, we impose a periodic boundary condition, requiring the solution to wrap around and be the same on the left and right boundaries. The horizontal direction is <em class="calibre11">x</em> and the vertical direction is <em class="calibre11">z</em>. We start the fluid at rest and are interested in the pattern of motion that the temperature difference creates.</p>
<p class="indent"><a href="ch09.xhtml#ch9fig5" class="calibre10">Figure 9-5</a> shows the setup of the simulated system. The gray area represents the fluid, and the thick black horizontal lines indicate the constant-temperature boundaries.</p>
<div class="image1"><img alt="Image" id="ch9fig5" src="../images/ch09fig05.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-5: The simulation box</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_285"/>The <span class="literal">Luxor</span> program (see “Diagramming with Luxor” on <a href="ch07.xhtml#ch07lev1" class="calibre10">page 190</a>) that created this diagram is available in the Physics section of the online supplement at <a href="https://julia.lee-phillips.org" class="calibre10"><em class="calibre11">https://julia.lee-phillips.org</em></a>.</p>
<p class="indent">A fluid dynamics simulation contains many pieces that we’ll need to construct separately before we can begin the calculation. In the following subsections, we’ll define the computational grid, the boundary conditions, the diffusivity models, and the equation of state, and establish the boundary conditions and the hydrodynamic model, in that order. After all the pieces are in place, we’ll run the <span class="literal">Oceananigans</span> simulation and visualize the results.</p>
<h4 class="h3" id="ch09lev1sec7"><strong class="calibre2"><em class="calibre4">The Grid</em></strong></h4>
<p class="noindent">To put together an <span class="literal">Oceananigans</span> simulation, we’ll define its various components using functions exported by the package, and then define a model using the <span class="literal">model()</span> function, passing in the components as arguments. For this example we’ll use a <span class="literal">grid</span>, a <span class="literal">buoyancy</span> model that specifies the fluid’s equation of state, a set of boundary conditions, the coefficients of viscosity and thermal diffusivity (material properties of the fluid), and initial conditions on the temperature within the fluid. We won’t include the effects of Earth’s rotation, salinity, or wind, but these ingredients are available for use in other <span class="literal">Oceananigans</span> models.</p>
<p class="indent">The grid is defined by its computational <span class="literal">size</span> (how many grid points exist in each direction), its <span class="literal">extent</span> (the physical lengths represented by these directions), and its <span class="literal">topology</span>, which is the term <span class="literal">Oceananigans</span> uses for what boundary conditions hold in each direction. For our problem we define the grid this way:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Oceananigans</span>

julia&gt; <span class="codestrong">grid = RectilinearGrid(size=(256, 32);</span>
              <span class="codestrong">topology=(Periodic, Flat, Bounded),</span>
              <span class="codestrong">extent=(256, 32))</span>
 256×1×32 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo
|-- Periodic x ∈ [0.0, 256.0)     regularly spaced with Δx=1.0
|-- Flat y
-- Bounded  z ∈ [-32.0, 0.0]      regularly spaced with Δz=1.0</pre>
<p class="indent">The <span class="literal">RectilinearGrid()</span> function that <span class="literal">Oceananigans</span> provides constructs grids as one of many data types defined in the package. We assign the grid to our own variable, <span class="literal">grid</span>, for use later when creating the model. We could have chosen any name for this variable, but <span class="literal">grid</span> is the name of the relevant keyword argument accepted by the model construction function; using the same names for our own variables will keep everything neat.</p>
<p class="indent">In the <span class="literal">topology</span> keyword argument, we list the boundary conditions in the <em class="calibre11">x</em>, <em class="calibre11">y</em>, and <em class="calibre11">z</em> directions, with <em class="calibre11">z</em> pointing upward. The boundary condition <span class="literal">Flat</span> means that we’re not using (in this case) the <em class="calibre11">y</em> direction. This call defines a two-dimensional, <em class="calibre11">x</em>–<em class="calibre11">z</em> grid, with periodic boundaries in <em class="calibre11">x</em> and impenetrable boundaries in <em class="calibre11">z</em>. <span class="literal">Oceananigans</span> uses a kilogram-meter-second unit system. <span epub:type="pagebreak" id="page_286"/>Because we set the <span class="literal">extent</span> to be equal to the <span class="literal">size</span>, the grid spacing is one unit in length along each dimension, giving us a fluid layer 256 meters wide and 32 meters tall.</p>
<p class="indent">As the example shows, <span class="literal">Oceananigans</span> has useful forms for representing its data types in the REPL, summarizing the salient information for our inspection. Here the output provides us with a summary of the grid parameters and boundary conditions.</p>
<h4 class="h3" id="ch09lev1sec8"><strong class="calibre2"><em class="calibre4">The Boundary Conditions</em></strong></h4>
<p class="noindent">We define any boundary conditions on physical variables as a separate component, which is also eventually passed into <span class="literal">model()</span>. We want to impose constant values of temperature on the top and bottom boundaries; <span class="literal">Oceananigans</span> sets this type of boundary condition with the <span class="literal">FieldBoundaryConditions()</span> function, as it sets boundary conditions on, in this case, the temperature field. We can use <span class="literal">Oceananigans</span>’s convenient definitions of <span class="literal">top</span> and <span class="literal">bottom</span>, which have their intuitive meaning (there are also <span class="literal">north</span>, <span class="literal">south</span>, <span class="literal">east</span>, and <span class="literal">west</span>, which we don’t need in this problem):</p>
<pre class="calibre13">julia&gt; <span class="codestrong">bc = FieldBoundaryConditions(</span>
               <span class="codestrong">top=ValueBoundaryCondition(1.0),</span>
               <span class="codestrong">bottom=ValueBoundaryCondition(20.0))</span>
Oceananigans.FieldBoundaryConditions, with boundary conditions
|-- west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
|-- east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
|-- south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
|-- north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
|-- bottom: ValueBoundaryCondition: 20.0
|-- top: ValueBoundaryCondition: 1.0
-- immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)</pre>
<p class="indent">The <span class="literal">immersed</span> boundary refers to one that exists inside the fluid volume, but we’re not using that one, nor any of the other myriad options, such as defined gradients or fluxes. The <span class="literal">ValueBoundaryCondition</span> that we use sets a constant value for a variable on the specified boundary.</p>
<h4 class="h3" id="ch09lev1sec9"><strong class="calibre2"><em class="calibre4">The Diffusivities</em></strong></h4>
<p class="noindent">We need to assign values to two constants that describe some of the fluid’s material properties; this is part of the problem definition. The viscosity coefficient (<em class="calibre11">ν</em>) determines how “thick” the fluid is, and the thermal diffusivity (<em class="calibre11">κ</em>) determines how readily it conducts heat. These values are passed to the model in the <span class="literal">closure</span> keyword and can be set through the <span class="literal">ScalarDiffusivity()</span> function:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">closure = ScalarDiffusivity(ν=0.05, κ=0.01)</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_287"/>The symbol for viscosity is the Greek letter <em class="calibre11">nu</em> and that for thermal diffusivity is <em class="calibre11">kappa</em>. Like all Greek letters, we can precede their names with a backslash and then press TAB to enter them in the REPL.</p>
<h4 class="h3" id="ch09lev1sec10"><strong class="calibre2"><em class="calibre4">The Equation of State</em></strong></h4>
<p class="noindent">The equation of state is a function that describes how the density of the fluid at any point depends on the temperature and salinity there (the assumption of <em class="calibre11">incompressibility</em> usually used in <span class="literal">Oceananigans</span> models means that density has no dependence on pressure). Our model is salt free, but our fluid will be lighter when it’s hotter. This is what will cause the fluid to move, as the lighter parts will rise and the heavier parts will sink, driven by gravity.</p>
<p class="indent">The <span class="literal">model()</span> function expects the keyword <span class="literal">buoyancy</span>, so we’ll use that too:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">buoyancy = SeawaterBuoyancy(equation_of_state=</span>
                  <span class="codestrong">LinearEquationOfState(thermal_expansion=0.01,</span>
                  <span class="codestrong">haline_contraction=0))</span>
SeawaterBuoyancy{Float64}:
|-- gravitational_acceleration: 9.80665
-- equation of state: LinearEquationOfState(thermal_expansion=0.01, haline_contraction=0.0)</pre>
<p class="indent"><span class="codeitalic1">Oceananigans</span> offers many other options, including the ability to define our own equation of state, but we’ll keep the model simple. The <span class="literal">SeawaterBuoyancy</span> component deals with buoyancy by combining gravity (with the default Earth value given here) with density variations. As we’re not interested in salinity effects for this calculation, we set <span class="literal">haline_contraction</span> to 0 (“haline” is essentially a synonym for saline used by oceanographers).</p>
<h4 class="h3" id="ch09lev1sec11"><strong class="calibre2"><em class="calibre4">The Model and Initial Conditions</em></strong></h4>
<p class="noindent">Now that we have all the pieces set up, we can put them together into a <em class="calibre11">model</em>, the <span class="literal">Oceananigans</span> term for the definition of the computational problem, including all the physics along with the grid and the boundary conditions:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">model = NonhydrostaticModel(;</span>
                  <span class="codestrong">grid, buoyancy, closure,</span>
                  <span class="codestrong">boundary_conditions=(T=bc,), tracers=(:T, :S))</span>
NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)
|-- grid: 256×1×32 RectilinearGrid{Float64, Periodic, Flat, Bounded}
 <span class="ent">➊</span> on CPU with 3×0×3 halo
|-- timestepper: QuasiAdamsBashforth2TimeStepper
|-- tracers: (T, S)
|-- closure: ScalarDiffusivity{ExplicitTimeDiscretization}
    (ν=0.05, κ=(T=0.01, S=0.01))
|-- buoyancy: SeawaterBuoyancy with g=9.80665 and
    LinearEquationOfState(thermal_expansion=0.01, haline_contraction=0.0)
    with -ĝ = ZDirection
-- coriolis: Nothing</pre>
<p class="indent"><span epub:type="pagebreak" id="page_288"/>The package prints a nice summary of the result, including a reminder of some (but not all) of the features we’re not using, such as the coriolis force from Earth’s rotation.</p>
<p class="indent">The <span class="literal">NonhydrostaticModel()</span> function creates a model using the approximation appropriate to our problem. <span class="literal">Oceananigans</span> offers several other choices, including a hydrostatic model to simulate surface waves.</p>
<p class="indent">We use the abbreviated form of passing keyword arguments explained in “Concise Syntax for Keyword Arguments” on <a href="ch06.xhtml#ch06lev1sec1" class="calibre10">page 154</a>.</p>
<p class="indent">Our boundary condition <span class="literal">bc</span> doesn’t refer to any particular physical variable; it simply defines a constant field value on the boundaries. The named tuple assigned to <span class="literal">boundary_conditions</span> enforces them on <span class="literal">T</span>, the variable used in <span class="literal">Oceananigans</span> for the temperature.</p>
<p class="indent">The printed result refers to the CPU <span class="ent">➊</span>, which means that this model is intended for “normal” machine architectures. The other option is to calculate on GPUs (graphics processing units). The <span class="literal">halo</span> refers to the several points outside the physical grid that the numerical algorithm uses to enforce the boundary conditions or other constraints.</p>
<p class="indent">The final keyword argument, <span class="literal">tracers</span>, tells the model to keep track of the temperature and salinity as those scalar fields are advected around the fluid. We’re required to include <span class="literal">:S</span> even though our equation of state means it will have no effect.</p>
<p class="indent">The fluid layer heated from below defined by our model is physically <em class="calibre11">unstable</em>, which means that a small perturbation to its initial, motionless state will be magnified and develop into a state with some form of persistent motion, driven by the temperature difference and the gravitational field. It is the development of the instability that we want to study. We need to add the small perturbation, or else, even though the system is unstable, it will never move.</p>
<p class="indent">The <span class="literal">set!()</span> function lets us create any desired initial condition on any of the fields. We’ll use it to add a small, random perturbation to the temperature field throughout the fluid volume:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">tper(x, y, z) = 0.1 * rand()</span>
tper (generic function with 1 method)

julia&gt; <span class="codestrong">set!(model; T = tper)</span></pre>
<p class="noindent">The function is spelled with an exclamation point to remind us that it mutates its arguments: it alters the <span class="literal">T</span> field in place, and the model as well.</p>
<h4 class="h3" id="ch09lev1sec12"><strong class="calibre2"><em class="calibre4">The Simulation</em></strong></h4>
<p class="noindent">Next we need to create a <em class="calibre11">simulation</em>, using the <span class="literal">Simulation()</span> function. This object will receive the model as its positional argument, along with keyword arguments for the timestep and when to stop the calculation. It will keep track of how much simulation time and wall-clock time has elapsed and the state of all the physical fields. This allows us to continue the simulation after <span epub:type="pagebreak" id="page_289"/>the requested start time if we want, save the progress of the simulation in files, and retrieve the fields for examination and plotting.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">simulation = Simulation(model; Δt=0.01, stop_time=1800)</span>
Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)
|-- Next time step: 10 ms
|-- Elapsed wall time: 0 seconds
|-- Wall time per iteration: NaN years
|-- Stop time: 30 minutes
|-- Stop iteration : Inf
|-- Wall time limit: Inf
|-- Callbacks: OrderedDict with 4 entries:
|   |-- stop_time_exceeded =&gt; Callback of stop_time_exceeded on IterationInterval(1)
|   |-- stop_iteration_exceeded =&gt; Callback of stop_iteration_exceeded on IterationInterval(1)
|   |-- wall_time_limit_exceeded =&gt; Callback of wall_time_limit_exceeded on IterationInterval(1)
|    -- nan_checker =&gt; Callback of NaNChecker for u on IterationInterval(100)
|-- Output writers: OrderedDict with no entries
-- Diagnostics: OrderedDict with no entries</pre>
<p class="indent">This is a simple call, as <span class="literal">model</span> already contains all the details of the problem. We get a summary of various options for the simulation, most of which we didn’t use. If you want to use the <em class="calibre11">delta</em> for the time interval in the REPL, enter <span class="codestrong1">\Delta</span> and press <small class="calibre5">TAB</small>.</p>
<p class="indent">Before running the simulation, let’s arrange for the velocity and temperature fields to be stored on disk at regular intervals so we can see its development over time (if we don’t do this, we’ll see only the final state of the simulation), as shown in <a href="ch09.xhtml#ch9lis4" class="calibre10">Listing 9-4</a>.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">simulation.output_writers[:velocities] =</span>
              <span class="codestrong">JLD2OutputWriter(model, model.velocities,</span>
              <span class="codestrong">filename="conv4.jld2", schedule=TimeInterval(1))</span>
 JLD2OutputWriter scheduled on TimeInterval(1 second):
|-- filepath: ./conv4.jld2
|-- 3 outputs: (u, v, w)
|-- array type: Array{Float32}
|-- including: [:grid, :coriolis, :buoyancy, :closure]
-- max filesize: Inf YiB

julia&gt; <span class="codestrong">simulation.output_writers[:tracers] =</span>
              <span class="codestrong">JLD2OutputWriter(model, model.tracers,</span>
              <span class="codestrong">filename="conv4T.jld2", schedule=TimeInterval(1))</span>
 JLD2OutputWriter scheduled on TimeInterval(1 second):
|-- filepath: ./conv4T.jld2
|-- 2 outputs: (T, S)
|-- array type: Array{Float32}
|-- including: [:grid, :coriolis, :buoyancy, :closure]
-- max filesize: Inf YiB</pre>
<p class="list" id="ch9lis4"><em class="calibre11">Listing 9-4: Setting up output writers</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_290"/>Adding elements to the <span class="literal">output_writers</span> property of the <span class="literal">simulation</span> causes it to store the results periodically. The <span class="literal">JLD2OutputWriter</span> uses the <span class="literal">JLD2</span> file format, which is a compact way to store multiple Julia data structures in a single file. It’s a version of the <span class="literal">HDF5</span> format widely used in computational science. The <span class="literal">schedule</span> causes a data dump every 1 second, which, using our timestep, will be every 100 steps. The information in the result shows which quantities will be saved: <span class="literal">T</span> and <span class="literal">S</span> are the temperature and salinity.</p>
<p class="indent">With this, we’re ready to run the calculation:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">run!(simulation)</span>
[ Info: Initializing simulation...
[ Info:     ... simulation initialization complete (6.850 ms)
[ Info: Executing initial time step...
[ Info:     ... initial time step complete (80.507 ms).</pre>
<p class="indent">The REPL will not have anything more to say until it reaches the final timestep, which in this case will take several hours on a typical personal computer. Then it will indicate that the calculation is complete and return to the interactive prompt. <a href="ch15.xhtml" class="calibre10">Chapter 15</a> explores ways to speed up such calculations by using parallel processing.</p>
<h4 class="h3" id="ch09lev1sec13"><strong class="calibre2"><em class="calibre4">The Results</em></strong></h4>
<p class="noindent">When an <span class="literal">Oceananigans</span> simulation ends, the final state of the fields (the velocity components and the temperature, in this case) is available as properties of the <span class="literal">model</span>. <a href="ch09.xhtml#ch9lis5" class="calibre10">Listing 9-5</a> shows how to retrieve them.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Plots</span>

julia&gt; <span class="codestrong">uF = model.velocities.u;</span>

julia&gt; <span class="codestrong">TF = model.tracers.T;</span>

julia&gt; <span class="codestrong">heatmap(interior(TF, 1:grid.Nx, 1, 1:grid.Nz)';</span>
               <span class="codestrong">aspect_ratio=1, yrange=(0, 1.5grid.Nz))</span></pre>
<p class="list" id="ch9lis5"><em class="calibre11">Listing 9-5: Examining the results of a simulation</em></p>
<p class="indent">The velocity and temperature fields are properties of the model. The <span class="literal">heatmap()</span> call will plot the two-dimensional temperature field, but first we need to turn it into an array with the <span class="literal">interior()</span> function. This function converts the <span class="literal">Oceananigans</span> field into a numerical array and trims away the <span class="literal">halo</span> points. Its arguments, following the field to convert, are the extents of the grid in each of the three directions; we enter a <span class="literal">1</span> to indicate an unused coordinate. In setting the <span class="literal">yrange</span>, we’ve accessed another property of the field, its grid shape. The prime after the array to plot transposes it so that it appears in its natural orientation, with a vertical gravity.</p>
<p class="indent">We would normally run a simulation for just a few timesteps and examine the fields in this way before running a long calculation, to make sure <span epub:type="pagebreak" id="page_291"/>we’ve set it up correctly. If we want to take another look after a few more timesteps, we can do this:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">simulation.stop_time+=10;</span>

julia&gt; <span class="codestrong">run!(simulation);</span></pre>
<p class="noindent">These commands advance the simulation an additional 10 timesteps, after which we can repeat the steps in <a href="ch09.xhtml#ch9lis5" class="calibre10">Listing 9-5</a> to see how things are going.</p>
<p class="indent">Returning now to the quantities stored in files, as set up in <a href="ch09.xhtml#ch9lis4" class="calibre10">Listing 9-4</a>, <a href="ch09.xhtml#ch9lis6" class="calibre10">Listing 9-6</a> shows how to retrieve the entire history of a field.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">uF = FieldTimeSeries("conv4.jld2", "u")</span>
256×1×32×1030 FieldTimeSeries{InMemory} located at
    (Face, Center, Center) on CPU
|-- grid: 256×1×32 RectilinearGrid{Float64, Periodic, Flat, Bounded}
    on CPU with 3×0×3 halo
|-- indices: (1:256, 1:1, 1:32)
-- data: 256×1×32×1030 OffsetArray(::Array{Float64, 4},
    1:256, 1:1, 1:32, 1:1030) with eltype Float64 with
 indices 1:256×1:1×1:32×1:1030
    -- max=7.66057, min=-7.88889, mean=2.79295e-11</pre>
<p class="list" id="ch9lis6"><em class="calibre11">Listing 9-6: Retrieving a field from the JLD2 file</em></p>
<p class="indent">The summary of the result shows that the <span class="literal">FieldTimeSeries</span> has dimensions of 256×1×32×1,030, which means that it’s defined on a 2D, 256×32 grid and evolves over 1,030 timesteps.</p>
<p class="indent">After this call the entire history of the <em class="calibre11">x</em>-velocity field and its various properties are conveniently available. The data structure <span class="literal">uF</span> itself takes up almost no space:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">sizeof(uF)</span>
544</pre>
<p class="noindent">The <span class="literal">sizeof()</span> function returns the amount of storage, in bytes, occupied by its argument. The actual data occupies 256 × 32 × 1,030 × 8 = 67,502,080 bytes.</p>
<p class="indent">We can plot the horizontal velocity field at any timestep:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Printf</span>

julia&gt; <span class="codestrong">i = 50;</span>

julia&gt; <span class="codestrong">h50 = heatmap(interior(uF[i], 1:grid.Nx, 1, 1:grid.Nz)';</span>
               <span class="codestrong">aspect_ratio=1, yrange=(0, 1.5grid.Nz),</span>
               <span class="codestrong">colorbar=:false, ylabel="z",</span>
               <span class="codestrong">annotations=[</span>
                  <span class="codestrong">(0, uF.grid.Nz+15,</span>
                    <span class="codestrong">text("Horizontal velocity at timestep $i", 12, :left)),</span>
                  <span epub:type="pagebreak" id="page_292"/><span class="codestrong">(0, uF.grid.Nz+5,</span>
                    <span class="codestrong">text((@sprintf "Max = %.3g" maximum(uF[i])), 8, :left)),</span>
                  <span class="codestrong">(100, uF.grid.Nz+5,</span>
                    <span class="codestrong">text((@sprintf "Min = %.3g" minimum(uF[i])), 8, :left))],</span>
                  <span class="codestrong">grid=false, axis=false)</span></pre>
<p class="indent">We’ve added some labeling to the version in <a href="ch09.xhtml#ch9lis5" class="calibre10">Listing 9-5</a>, annotating the plot using properties read out from the field. Creating similar plots for timesteps 100 and 500, adding an <span class="literal">xlabel</span> to the last one, and putting them together with <span class="literal">plot(h50, h100, h500; layout=(3, 1))</span> creates the plot in <a href="ch09.xhtml#ch9fig6" class="calibre10">Figure 9-6</a>.</p>
<div class="image1"><img alt="Image" id="ch9fig6" src="../images/ch09fig06.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-6: Results of an</em> <span class="codeitalic">Oceananigans</span> <em class="calibre11">simulation</em></p>
<p class="indent">The system evinces the regime called <em class="calibre11">turbulent convection</em>; it’s interesting to observe the emergence of large-scale order from randomness and its persistent coexistence with the turbulent flow.</p>
<p class="indent">In order to make an animation of the simulation, we need to generate plots at equally spaced time intervals and stitch them together into a video file. Our simulation used a constant timestep, so in this case, equal time intervals translates into equal numbers of timesteps. However, that won’t always be the case. <span class="literal">Oceananigans</span> has options for automatically adjusted timesteps, and we may perform a simulation in stages with differently sized Δ<em class="calibre11">t</em>. It’s convenient, therefore, to have a function that creates a plot given a <em class="calibre11">time</em>. Since a given time may not correspond to any particular stored field, but may fall between two consecutive data dumps, we’ll need a function that determines which stored field is closest to the time requested. The Julia program shown in <a href="ch09.xhtml#ch9lis7" class="calibre10">Listing 9-7</a> retrieves the simulation output and produces a movie of a specified duration.</p>
<span epub:type="pagebreak" id="page_293"/>
<pre class="calibre13">using Oceananigans, Reel, Plots

function heatmap_at_time(F, time, fmin, fmax, duration)
    ts = F.times
    time = time * ts[end]/duration
    i = indexin(minimum(abs.(ts .- time)), abs.(ts .- time))[1] <span class="ent">➊</span>
    xr = yr = zr = 1
    if F.grid.Nx &gt; 1
        xr = 1:F.grid.Nx
    end
    if F.grid.Ny &gt; 1
        yr = 1:F.grid.Ny
    end
    if F.grid.Nz &gt; 1
        zr = 1:F.grid.Nz
    end
    heatmap(interior(F[i], xr, yr, zr)'; aspect_ratio=1, yrange=(0, 1.5F.grid.Nz),
            clim=(fmin, fmax)) <span class="ent">➋</span>
end

uF = FieldTimeSeries("conv4.jld2", "u")
const fmin = 0.5minimum(uF) <span class="ent">➌</span>
const fmax = 0.5maximum(uF)
const duration = 30

function plotframe(t, dt)
    heatmap_at_time(uF, t, fmin, fmax, duration)
end

uMovie = roll(plotframe; fps=30, duration)

write("uMovie.mp4", uMovie)</pre>
<p class="list" id="ch9lis7"><em class="calibre11">Listing 9-7: Creating an animation of an Oceananigans simulation</em></p>
<p class="indent">The <span class="literal">heatmap_at_time()</span> function does what’s needed, creating a heatmap at the time closest to the time in its argument. In this function, <span class="literal">F</span> is a field retrieved with a call to <span class="literal">FieldTimeSeries()</span>, as in <a href="ch09.xhtml#ch9lis6" class="calibre10">Listing 9-6</a>. It makes use of the <span class="literal">times</span> property of these objects, which is an array holding all the times at which the field has been saved. The index <span class="literal">i</span> holds the dump corresponding to the time closest to the supplied <span class="literal">time</span> <span class="ent">➊</span>. When making an animation of a heatmap, we want to use the same mapping from values to colors in each frame, so our call to <span class="literal">heatmap()</span> uses the <span class="literal">clim</span> keyword <span class="ent">➋</span>.</p>
<p class="indent">With this function in place we can create an animation using the <span class="literal">Reel</span> package introduced in “Animations with Reel” on <a href="ch07.xhtml#ch07lev4" class="calibre10">page 206</a>. To work with that package, we need to define a function of time <span class="literal">t</span> and (an unused) <span class="literal">dt</span> that returns a plot corresponding to <span class="literal">t</span>: the <span class="literal">plotframe()</span> function. The three constants <span class="ent">➌</span> in the script set the palette limits based on the data and the desired <span epub:type="pagebreak" id="page_294"/>total duration of the animation. The palette limits are scaled so that more details are visible near the beginning of the run, but we can adjust it based on the features of interest.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">See the online supplement at</em> <a href="https://julia.lee-phillips.org" class="calibre10">https://julia.lee-phillips.org</a> <em class="calibre11">for the resulting animation, along with full-color versions of the figures.</em></p>
</div>
<p class="indent">The final call saves the animation as an MP4 file. Other options that will work with <span class="literal">Reel</span> are <span class="literal">gif</span> and <span class="literal">webm</span>. To create these file types, we merely need to use the appropriate file ending.</p>
<h3 class="h2" id="ch09lev4"><strong class="calibre2">Solving Differential Equations with DifferentialEquations</strong></h3>
<p class="noindent">Since the 18th century, differential equations have been the language of physical science and engineering, and of the quantitative aspects of other sciences as well. Julia’s <span class="literal">DifferentialEquations</span> package is a massive, state-of-the-art facility for solving many types of differential equations using a multitude of methods. It incorporates recent research on the use of machine learning to apply the best line of attack for solving a given equation.</p>
<p class="indent">This section introduces the use of <span class="literal">DifferentialEquations</span> by solving an example problem. Interested readers can delve into its detailed documentation for more information (see “Further Reading” on <a href="ch09.xhtml#fur9" class="calibre10">page 304</a>).</p>
<h4 class="h3" id="ch09lev1sec14"><strong class="calibre2"><em class="calibre4">Defining the Physics Problem and Its Differential Equation</em></strong></h4>
<p class="noindent">As an example, let’s investigate the pendulum. <a href="ch09.xhtml#ch9fig7" class="calibre10">Figure 9-7</a> diagrams the problem and defines the string length (<em class="calibre11">L</em>) and the angle (<em class="calibre11">θ</em>).</p>
<div class="image1"><img alt="Image" id="ch9fig7" src="../images/ch09fig07.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-7: The pendulum system</em></p>
<p class="indent">We measure <em class="calibre11">θ</em> counterclockwise from the vertical reference line, which is dotted in the diagram, and the gravitational acceleration points down.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">The</em> <span class="codeitalic1">Luxor</span> <em class="calibre11">program that produced the diagram is available in the code section of the Physics chapter on the online supplement at</em> <a href="https://julia.lee-phillips.org" class="calibre10">https://julia.lee-phillips.org</a><em class="calibre11">.</em></p>
</div>
<p class="indent"><span epub:type="pagebreak" id="page_295"/>A straightforward analysis of the forces on the pendulum bob (the black circle in the diagram) and Newton’s Second Law leads to the differential equation</p>
<div class="image"><img alt="Image" src="../images/295math.jpg" class="calibre6"/></div>
<p class="noindent">which is derived in any introductory general physics text. Here <em class="calibre11">t</em> is time and <em class="calibre11">g</em> is the gravitational acceleration. The usual next step is to confine the problem to small angles (≲ 5<sup class="calibre23">°</sup>), where sin(<em class="calibre11">θ</em>) ≈ <em class="calibre11">θ</em>, and solve the resulting differential equation for simple harmonic motion. We’re going to solve the “exact” pendulum equation numerically, using the <span class="literal">DifferentialEquations</span> package. We’ll be able to examine the solution for any initial <em class="calibre11">θ</em>, up to π radians.</p>
<p class="indent">The package works with systems of first-order equations, which means differential equations limited to first derivatives of the unknown function. To handle the pendulum equation, therefore, we first need to cast it into the form of two coupled first-order equations. This first step is also part of many analytic solution methods. We can proceed easily by defining a new variable:</p>
<div class="image"><img alt="Image" src="../images/295math1.jpg" class="calibre6"/></div>
<p class="noindent">Now we’re solving for two functions of time, the angle <em class="calibre11">θ</em>(<em class="calibre11">t</em>) and the angular velocity <em class="calibre11">ω</em>(<em class="calibre11">t</em>).</p>
<h4 class="h3" id="ch09lev1sec15"><strong class="calibre2"><em class="calibre4">Setting Up the Problem</em></strong></h4>
<p class="noindent">The first step in translating the mathematical problem into a form that <span class="literal">DifferentialEquations</span> can digest is to define a Julia function of four positional arguments:</p>
<div class="bqparan">
<p class="noindentin"><span class="codestrong1">du</span>  An array for the derivatives of the solutions</p>
<p class="noindentin"><span class="codestrong1">u</span>   An array for the solution functions</p>
<p class="noindentin"><span class="codestrong1">p</span>   An array of parameters</p>
<p class="noindentin"><span class="codestrong1">t</span>   The time</p>
</div>
<p class="indent"><a href="ch09.xhtml#ch9lis8" class="calibre10">Listing 9-8</a> is the version for the pendulum problem.</p>
<pre class="calibre13">function pendulum!(du, u, p, t)
    L, g = p
    θ, ω = u
    du[1] = ω
    du[2] = -g/L * sin(θ)
end</pre>
<p class="list" id="ch9lis8"><em class="calibre11">Listing 9-8: The Julia version of the pendulum equation</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_296"/>This is a mutating function, as indicated by the exclamation point, because as the calculation progresses, the solution engine mutates the <span class="literal">u</span> and <span class="literal">du</span> arrays to hold the results. Here <span class="literal">L</span> and <span class="literal">g</span> are set through destructuring the array <span class="literal">p</span>, and θ and ω are read from the array <span class="literal">u</span>. The solver from <span class="literal">DifferentialEquations</span> will repeatedly call <span class="literal">pendulum!()</span> as it builds up the solution, passing in <span class="literal">p</span>, <span class="literal">t</span>, and the developing solution arrays themselves.</p>
<h4 class="h3" id="ch09lev1sec16"><strong class="calibre2"><em class="calibre4">Solving the Equation System</em></strong></h4>
<p class="noindent">To calculate the solution, we first define the computational problem and then pass that problem to the <span class="literal">solve()</span> function. The components of the computational problem are the parameter array, the initial conditions, the time span over which we want the solution, and the function that defines the differential equations to be solved, in this example <span class="literal">pendulum!()</span>. Other options include such things as the numerical method to be employed, but in this simple example we’ll leave those options unspecified. The package generally does an excellent job of choosing the solution method best suited to the nature of the equations we present to it. <a href="ch09.xhtml#ch9lis9" class="calibre10">Listing 9-9</a> shows the problem set up and initiated.</p>
<pre class="calibre13">using DifferentialEquations

p = [1.0, 9.8]
 #    L    g   &lt;- Parameters

u0 = [deg2rad(5), 0]
 #    θ    ω   &lt;- Initial conditions

tspan = (0, 20)

prob = ODEProblem(pendulum!, u0, tspan, p)
sol5d = solve(prob)</pre>
<p class="list" id="ch9lis9"><em class="calibre11">Listing 9-9: Solving differential equations using</em> <span class="codeitalic">DifferentialEquations</span></p>
<p class="indent">The only two functions in this section from the <span class="literal">DifferentialEquations</span> package are <span class="literal">ODEProblem()</span> and <span class="literal">solve()</span>. <span class="literal">ODEProblem()</span> takes four positional arguments: the function defining the equation system, an array of initial conditions, the time span, and the parameter array. We defined the function in <a href="ch09.xhtml#ch9lis8" class="calibre10">Listing 9-8</a> and we define the other three arguments here. Allowing the solver to pass the parameters as arguments makes it convenient to generate families of solutions with a range of parameters.</p>
<p class="indent">The result returned by <span class="literal">ODEProblem()</span> contains the complete solutions of all functions (in this example, two) bundled into a data type defined in the package. This data type is designed to make it easy to examine and plot the solutions, and it contains, in addition to the computed functions, information about the problem and the calculation.</p>
<h4 class="h3" id="ch09lev1sec17"><span epub:type="pagebreak" id="page_297" class="calibre1"/><strong class="calibre2"><em class="calibre4">Examining the Solutions</em></strong></h4>
<p class="noindent">For small angles, the analytic solution to our pendulum problem is</p>
<div class="image"><img alt="Image" src="../images/297math.jpg" class="calibre6"/></div>
<p class="noindent">where <em class="calibre11">θ</em><sub class="calibre24">0</sub> is the initial angle. The initial conditions in <a href="ch09.xhtml#ch9lis9" class="calibre10">Listing 9-9</a> have the pendulum at rest with a starting angle of 5°, so the small angle approximation should be valid.</p>
<p class="indent">Since we know the analytic solution, we can check the numerical result against it. <a href="ch09.xhtml#ch9lis10" class="calibre10">Listing 9-10</a> shows how we can plot one against the other.</p>
<pre class="calibre13">using Plots

plot(sol5d; idxs=1, lw=4, lc=:lightgrey, label="Numeric",
     legend=:outerright, title="Pendulum at θ<sub class="calibre25">0</sub> = 5°")

L, g = p

plot!(t -&gt; u0[1]*cos(sqrt(g/L)*t); xrange=(0, 20),
      ls=:dash, lc=:black, label="Analytic")</pre>
<p class="list" id="ch9lis10"><em class="calibre11">Listing 9-10: Solving for the small angle case</em></p>
<p class="indent">The first <span class="literal">plot()</span> call uses only one data argument, the solution itself, assigned to <span class="literal">sol5d</span> in <a href="ch09.xhtml#ch9lis9" class="calibre10">Listing 9-9</a>. This is neither an array nor a function, yet <span class="literal">plot()</span> seems to know how to display it. The first keyword argument, <span class="literal">idxs</span>, requests that (in this case) the first function, <em class="calibre11">θ</em>, is plotted. <span class="literal">idxs</span> does not appear in the documentation for the <span class="literal">Plots</span> package, and in fact is not defined in that package. Thus, it has no effect unless we first import <span class="literal">DifferentialEquations</span>.</p>
<p class="indent">The plot, shown in <a href="ch09.xhtml#ch9fig8" class="calibre10">Figure 9-8</a>, gives us confidence that we’ve set up the problem correctly and that the numerical solution methods are working.</p>
<div class="image"><img alt="Image" id="ch9fig8" src="../images/ch09fig08.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-8: Checking the small angle solution of the pendulum equation</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_298"/>Plotting the solution as we did here does not simply plot the solution arrays. It also interpolates between calculated values in order to generate a smooth plot. In this case, the solution contains only 83 points, which, if plotted directly, would make a coarse graph.</p>
<p class="indent">Although the solution objects are not arrays, the package defines methods for indexing that make it convenient to extract the data. If we do want access to the uninterpolated solution data, we can get it by indexing. Here, <span class="literal">sol5d[1, :]</span> returns a <span class="literal">Vector</span> of the 83 points for the first variable, <em class="calibre11">θ</em>, and <span class="literal">sol5d[2, :]</span> for the second, <em class="calibre11">ω</em>. To get the times at which these values are defined, we use a property: <span class="literal">sol5d.t</span>.</p>
<p class="indent">Using the solution objects as functions returns the result interpolated to the time passed as an argument. (We’re using time in this section, but in other problems the independent variable may be something else.) The <span class="literal">sol5d(1.3)</span> function call returns a <span class="literal">Vector</span> of two elements, one for each variable, interpolated to the time 1.3. These functions accept ranges and arrays as well, so <span class="literal">sol5d(0:0.1:1)</span> returns the interpolated solution data at 11 times from 0 to 1. To extract just the angle variable at these times, we can call <span class="literal">sol5d(0:0.1:1)[1, :]</span>. Controlling the density of the interpolation by using the functional form of the solution objects can be helpful when making, for example, scatterplots, where we need to control the density of plotted points.</p>
<p class="indent">How does the solution depend on the initial angle? Redefining <span class="literal">u0</span> to try two larger initial angles, and proceeding as in <a href="ch09.xhtml#ch9lis10" class="calibre10">Listing 9-10</a> to generate two new solutions, we get the results shown in <a href="ch09.xhtml#ch9fig9" class="calibre10">Figure 9-9</a>.</p>
<div class="image"><img alt="Image" id="ch9fig9" src="../images/ch09fig09.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-9: The pendulum with larger initial angles</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_299"/>The 90° solution, with the pendulum string initially horizontal, appears approximately sinusoidal, but with the frequency around 25 percent lower than the small angle case. When the initial angle is 175°, the period is nearly three times the small angle period, and the solution is clearly far from sinusoidal. In generating <a href="ch09.xhtml#ch9fig9" class="calibre10">Figure 9-9</a>, we limit the range of the independent variable by passing another <span class="literal">DifferentialEquations</span>-defined keyword to <span class="literal">plot()</span>: <span class="literal">tspan=(0, 10)</span>.</p>
<h4 class="h3" id="ch09lev1sec18"><strong class="calibre2"><em class="calibre4">Defining Time-Dependent Parameters</em></strong></h4>
<p class="noindent">By replacing one or more of the constant parameters in the <span class="literal">p</span> array with functions of time, we can study the system’s response to time-dependent parameters. In this way we can include inhomogeneous terms in the differential equations, forcing functions, and time-varying parameters in general.</p>
<p class="indent">Let’s find out what happens if we pull up on the string steadily as the pendulum oscillates. We’ll start at 45° and calculate the solution over 10 seconds, replacing the constant <span class="literal">L</span> by a linearly decreasing function of time:</p>
<pre class="calibre13">tspan = (0, 10)
u0 = [π/4, 0]
Lt(t) = 1 - 0.999t/10</pre>
<p class="indent">We need to create a slightly different version of our <span class="literal">pendulum()</span> function, shown in <a href="ch09.xhtml#ch9lis11" class="calibre10">Listing 9-11</a>, that can use the time-dependent string length.</p>
<pre class="calibre13">function pendulum2!(du, u, p, t)
    L, g = p
    θ, ω = u
    du[1] = ω
 <span class="ent">➊</span> du[2] = -g/L(t) * sin(θ)
end</pre>
<p class="list" id="ch9lis11"><em class="calibre11">Listing 9-11: The pendulum function with a time-dependent</em> <span class="codeitalic">L</span></p>
<p class="indent">The only change we made to the previous function is replacing <span class="literal">L</span> with <span class="literal">L(t)</span> <span class="ent">➊</span>. We proceed just as before. The <span class="literal">ODEProblem()</span> function needs a new parameter array, shown in <a href="ch09.xhtml#ch9lis12" class="calibre10">Listing 9-12</a>, to pass in to <span class="literal">pendulum2()</span>.</p>
<pre class="calibre13">p = [Lt, 9.8]
prob = ODEProblem(pendulum2!, u0, tspan, p)
solLt = solve(prob)</pre>
<p class="list" id="ch9lis12"><em class="calibre11">Listing 9-12: Getting the numerical solution with a time-varying</em> <span class="codeitalic">L</span></p>
<p class="indent">The ease of generalizing the problem to include a time-varying parameter clarifies the advantages of the parameter-passing approach in <span class="literal">Differential</span> <span class="literal">Equations</span>. The result, in <a href="ch09.xhtml#ch9fig10" class="calibre10">Figure 9-10</a>, shows a steadily decreasing period and amplitude with an increasing angular velocity (<em class="calibre11">ω</em>).</p>
<div class="image"><img alt="Image" id="ch9fig10" src="../images/ch09fig10.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-10: Pulling up the string on the pendulum</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_300"/>We create <a href="ch09.xhtml#ch9fig10" class="calibre10">Figure 9-10</a> with the following calls:</p>
<pre class="calibre13">plot(solLt; idxs=1, label="θ", legend=:topleft, ylabel="θ",
  <span class="ent">➊</span> right_margin=13mm)
plot!(twinx(), solLt; idxs=2, label="ω", legend=:topright,
      ylabel="ω", ls=:dot)</pre>
<p class="indent">In the call to <span class="literal">plot!()</span>, the first argument, <span class="literal">twinx()</span>, creates a subplot overlay that shares the horizontal axis with the first plot and draws a new vertical axis; we use it so the two curves don’t have to share the same scale. We need some extra room on the right <span class="ent">➊</span> for the labels on the second vertical axis. This margin setting requires the import of <span class="literal">Plots.PlotMeasures</span>, as explained in “Working with Plot Settings” on <a href="ch04.xhtml#ch04lev7" class="calibre10">page 101</a>.</p>
<h4 class="h3" id="ch09lev1sec19"><strong class="calibre2"><em class="calibre4">Parametric Instability</em></strong></h4>
<p class="noindent">A child “pumping” a swing in the playground to get it moving is exploiting a <em class="calibre11">parametric instability</em>. The driver of this instability is the periodic change in the effective length of the pendulum string. The results of linear theory (the small angle version of the differential equation that we’re attacking in this section) tell us that a resonance occurs when the forcing frequency is twice the natural frequency of the pendulum, which, using our <em class="calibre11">L</em> = 1, is <img alt="Image" src="../images/300math.jpg" class="calibre6"/>. If the string length is perturbed sinusoidally at this frequency, the amplitude of small oscillations will increase exponentially.</p>
<p class="indent">Since we know how to insert any time-dependent function <em class="calibre11">L</em>(<em class="calibre11">t</em>) into the numerical solution, we can investigate the response of the pendulum to parametric excitation beyond the small angle approximation. We’ll start <span epub:type="pagebreak" id="page_301"/>with a small initial angle, follow the evolution for a longer span, and define a new function of time for the string length:</p>
<pre class="calibre13">const g = 9.8
tspan = (0, 400)
u0 = [π/32, 0]
Lt(t) =  1.0 + 0.1*cos(2*sqrt(g)*t)</pre>
<p class="indent"><span class="literal">Lt(t)</span> will perturb the nominal length of 1 meter by 10 percent at the frequency of parametric resonance.</p>
<p class="indent">Our work proceeds exactly as before, with one adjustment. We use <span class="literal">pendulum2()</span>, defined in <a href="ch09.xhtml#ch9lis11" class="calibre10">Listing 9-11</a>, and set up the problem as in <a href="ch09.xhtml#ch9lis12" class="calibre10">Listing 9-12</a>. The adjustment is that we need to supply a keyword argument to the solving function:</p>
<pre class="calibre13">solLt = solve(prob; reltol=1e-5)</pre>
<p class="indent">The <span class="literal">reltol</span> parameter adjusts the adaptive timestepping as needed to limit the local error to the value that we supply. Its default of 0.001 led to a solution that seemed suspicious, as it was not quite periodic. I generated solutions with <span class="literal">reltol</span> = 1e–4, 1e–5, and 1e–6. The 1e–4 solution looked reasonable, but the 1e–5 solution was slightly different. As the solution with <span class="literal">reltol</span> = 1e–6 looked identical to the one at 1e–5, they’re probably accurate. <a href="ch09.xhtml#ch9fig11" class="calibre10">Figure 9-11</a> shows the resulting graph of <em class="calibre11">θ</em> versus time.</p>
<div class="image"><img alt="Image" id="ch9fig11" src="../images/ch09fig11.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-11: Parametric instability of the finite-angle pendulum</em></p>
<p class="indent">Initially, the amplitude increases exponentially, as predicted by the linear theory. But we know from our previous solutions that the frequency of the pendulum decreases with amplitude; therefore, it moves continuously out of <span epub:type="pagebreak" id="page_302"/>resonance with the forcing function, and the amplitude decreases back to close to its initial value. At that point it’s closer to resonance, and the amplitude again grows exponentially. As the solution shows, the process repeats.</p>
<h4 class="h3" id="ch09lev1sec20"><strong class="calibre2"><em class="calibre4">Combining DifferentialEquations with Measurements</em></strong></h4>
<p class="noindent">Suppose we want to verify the predictions of our pendulum solutions with an experiment. There will be some error inherent in the setting of the initial angle. If we estimate that uncertainty to be one degree, we might think to state the initial conditions this way (see “Error Propagation with Measurements” on <a href="ch09.xhtml#ch09lev2" class="calibre10">page 280</a>):</p>
<pre class="calibre13">using Measurements

u0 = [π/2 ± deg2rad(1), 0]</pre>
<p class="noindent">The function <span class="literal">deg2rad()</span> converts from degrees to radians.</p>
<p class="indent">We can proceed exactly as before, repeating the procedure shown in <a href="ch09.xhtml#ch9lis8" class="calibre10">Listings 9-8</a> and <a href="ch09.xhtml#ch9lis9" class="calibre10">9-9</a>. A plot of the solution for <em class="calibre11">θ</em>(<em class="calibre11">t</em>) now looks like <a href="ch09.xhtml#ch9fig12" class="calibre10">Figure 9-12</a>.</p>
<div class="image"><img alt="Image" id="ch9fig12" src="../images/ch09fig12.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-12: Combining</em> <span class="codeitalic">DifferentialEquations</span> <em class="calibre11">with</em> <span class="codeitalic">Measurements</span></p>
<p class="indent">Although we don’t tell the <span class="literal">plot()</span> function anything about drawing error bars, they appear in the plot. The plot shows how the error in the angular position grows, on average, over time. The error doesn’t grow monotonically, however. It decreases when the exact solution and those at the limits of the error bound happen to be in phase.</p>
<p class="indent"><span epub:type="pagebreak" id="page_303"/>We generate the solution and plot it in <a href="ch09.xhtml#ch9fig12" class="calibre10">Figure 9-12</a> as follows:</p>
<pre class="calibre13">prob = ODEProblem(pendulum!, u0, tspan, p)

solM = solve(prob)

plot(solM(0:0.1:5)[1, :]; legend=false, lw=2, ylabel="θ", xlabel="t")</pre>
<p class="indent">Since <span class="literal">DifferentialEquations</span> places an error on every point of the solution, including the points interpolated when creating a plot, we have to use the technique described in “Examining the Solutions” on <a href="ch09.xhtml#ch09lev1sec17" class="calibre10">page 297</a> to limit the number of points plotted; otherwise, the plot becomes too crowded with error bars and is impossible to interpret.</p>
<h3 class="h2" id="ch09lev5"><strong class="calibre2">Conclusion</strong></h3>
<p class="noindent">Although we delved into several physics packages at some length in this chapter, we really only scratched their surfaces. I hope, however, that the introductions here are sufficient to help you assess whether any of the packages explored in this chapter might be a good choice for your projects and to show you how to get started.</p>
<p class="indent">Another purpose of this chapter is to serve as an introduction to a superpower of Julia and the Julia ecosystem. In several examples we were able to combine the abilities of two or three packages without making any particular arrangements to do so. We made plots and typeset expressions that contained units, and saw that they were handled sensibly. We handed the output of a differential equation solver to a plotting function from a different package, and it extracted the relevant data and plotted it. We solved differential equations with error estimates in their initial conditions, and the error was propagated through the solution correctly. We plotted <em class="calibre11">this</em> result, and, as if by magic, the solution displayed error bars.</p>
<p class="indent">We wrote scripts and programs that combined the abilities of five packages in various combinations, giving them capabilities neither envisioned nor planned by their authors. Most of these packages were written without any knowledge of the others that we combined them with. The authors of these packages wrote their code in a generic way that allows Julia’s type system and its method of multiple dispatch to enable its functions to work with data types defined in other packages.</p>
<p class="indent">Julia initially attracted attention as a language that was as easy to pick up and be productive in as a high-level interpreted language, but one that was fast enough for the most demanding scientific work: “as easy as Python and as fast as Fortran.” The second reason for Julia’s increasing adoption in the sciences is its ability to combine the abilities of disparate packages with no additional work on the part of the application programmer. Julia creators and package authors refer to this property as the <em class="calibre11">composability</em> of packages, in analogy with the composition of functions.</p>
<div class="box">
<p class="boxtitle-d" id="fur9"><span epub:type="pagebreak" id="page_304" class="calibre1"/><strong class="calibre2">FURTHER READING</strong></p>
<ul class="calibre12">
<li class="noindent1">The GitHub community  “Julia’s Physics Ecosystem”  (<a href="https://juliaphysics.github.io/latest/ecosystem/" class="calibre10"><em class="calibre11">https://juliaphysics.github.io/latest/ecosystem/</em></a>) maintains a convenient list of packages related to all areas of physics,  and includes related packages for mathematics and plotting.</li>
<li class="noindent1">The <span class="literal">Unitful</span> package is available at <a href="https://github.com/PainterQubits/Unitful.jl" class="calibre10"><em class="calibre11">https://github.com/PainterQubits/Unitful.jl</em></a>.</li>
<li class="noindent1">See  <a href="https://www.simscale.com/blog/2017/12/nasa-mars-climate-orbiter-metric/" class="calibre10"><em class="calibre11">https://www.simscale.com/blog/2017/12/nasa-mars-climate-orbiter-metric/</em></a> for details on how a mixup in units destroyed the Mars Climate Orbiter.</li>
<li class="noindent1">The documentation for  <span class="literal">UnitfulLatexify</span> is at  <a href="https://gustaphe.github.io/UnitfulLatexify.jl/dev/" class="calibre10"><em class="calibre11">https://gustaphe.github.io/UnitfulLatexify.jl/dev/</em></a>.</li>
<li class="noindent1">The  <span class="literal">Measurements</span> package resides at  <a href="https://github.com/JuliaPhysics/Measurements.jl" class="calibre10"><em class="calibre11">https://github.com/JuliaPhysics/Measurements.jl</em></a>.</li>
<li class="noindent1">To get started with  <span class="literal">Oceananigans</span>,  see  <a href="https://clima.github.io/OceananigansDocumentation/stable/quick_start/" class="calibre10"><em class="calibre11">https://clima.github.io/OceananigansDocumentation/stable/quick_start/</em></a>.</li>
<li class="noindent1">The  <span class="literal">DifferentialEquations.jl</span> documentation is available at  <a href="https://diffeq.sciml.ai/stable/" class="calibre10"><em class="calibre11">https://diffeq.sciml.ai/stable/</em></a>.</li>
<li class="noindent1">Animations,  color images,  and supplementary code for this chapter are available at  <a href="https://julia.lee-phillips.org" class="calibre10"><em class="calibre11">https://julia.lee-phillips.org</em></a>.</li>
<li class="noindent1">You can find simple examples of the use of <span class="literal">DifferentialEquations.jl</span> at  <a href="https://lwn.net/Articles/835930/" class="calibre10"><em class="calibre11">https://lwn.net/Articles/835930/</em></a> and  <a href="https://lwn.net/Articles/834571/" class="calibre10"><em class="calibre11">https://lwn.net/Articles/834571/</em></a>.</li>
<li class="noindent1">The parametric instability of a pendulum is demonstrated in the video at  <a href="https://www.youtube.com/watch?v=dGE_LQXy6c0" class="calibre10"><em class="calibre11">https://www.youtube.com/watch?v=dGE_LQXy6c0</em></a>.</li>
<li class="noindent1">The theory of parametric resonance for the general harmonic oscillator is treated at  <a href="https://www.lehman.edu/faculty/dgaranin/Mechanics/Parametric_resonance.pdf" class="calibre10"><em class="calibre11">https://www.lehman.edu/faculty/dgaranin/Mechanics/Parametric_resonance.pdf</em></a>.</li>
</ul>
</div>
</body></html>