<html><head></head><body>
<h2 class="h" id="ch09"><span epub:type="pagebreak" id="page_269" class="calibre1"/><strong class="calibre2"><span class="big">9</span><br class="calibre3"/>PHYSICS</strong></h2>
<div class="bq">
<p class="center"><em class="calibre11">Physics is not a religion. If it were, we’d have a much easier time raising money.</em></p>
<p class="center1">—Leon M. Lederman</p>
</div>
<div class="image"><img alt="Image" src="../images/common.jpg" class="calibre6"/></div>
<p class="noindent">Julia is a superb platform for physics calculations of all kinds. Various features of its syntax, such as the ability to use mathematical symbols and its concise array operations, make it a natural fit for programming algorithms that we use in physics. Julia’s speed of execution makes it one of only a few languages used for the most demanding large-scale simulations (and the others in this club are all lower-level, statically compiled languages). Julia’s physics ecosystem includes some state-of-the-art packages. Finally, Julia’s unique ability to mix and match functions and data types from disparate packages to create new capabilities is especially powerful in physics calculations, as we’ll see in detail in this chapter.</p>
<p class="indent">We begin with an introduction to two packages of general utility for dealing with units and errors. Both of these are potentially helpful in any <span epub:type="pagebreak" id="page_270"/>physics project. We’ll spend some time in the first section looking into various options for producing publication-quality plots including typeset units in axis labels. Then we’ll turn to specific calculations, first using a package for fluid dynamics and then using a general-purpose differential equation solver. See “Further Reading” on <a href="ch09.xhtml#fur9" class="calibre10">page 304</a> for each major package’s URL.</p>
<h3 class="h2" id="ch09lev1"><strong class="calibre2">Bringing Physical Units into the Computer with Unitful</strong></h3>
<p class="noindent">The traditional way to perform physics calculations on a computer is to represent physical quantities as floating-point numbers, subject those numbers to a long series of arithmetic operations, and then interpret the results again as physical quantities. Since physical quantities are usually not simply numbers, but have <em class="calibre11">dimensions</em>, we need to manually keep track of the <em class="calibre11">units</em> that are associated with these quantities, often with code comments to remind us what the various units are.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">A</em> dimension <em class="calibre11">is a fundamental physical idea encompassing something that can be measured, such as mass or time. A</em> unit <em class="calibre11">is a specific way of measuring a dimension. The dimensions are universal, but there are various systems of units. For example, for the dimension of length, some common units are centimeter (cm), meter (m), or, if we live in the United States, inches or football fields.</em></p>
</div>
<p class="indent">In other words, the physical meanings of the numbers appearing in a program are not part of the quantities themselves, but are implicit. It may not be surprising that this can lead to confusion and errors. In 1999, NASA lost a spacecraft because two different contractors were contributing to the design, and their engineering programs used different systems of units.</p>
<p class="indent">In traditional languages for physics, such as Fortran, not much can be done about this issue directly. In Julia, because of its sophisticated type system, we are not limited to collections of dimensionless numbers; we can calculate with richer objects including units.</p>
<p class="indent">After importing the <code>Unitful</code> package, we can refer to many common physics units using a nonstandard string literal (see “Nonstandard String Literals” on <a href="ch05.xhtml#ch05lev4" class="calibre10">page 128</a>) with the prefix <code>u</code>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Unitful</span>

julia&gt; <span class="codestrong">u"1m" + u"1cm"</span>
101//100 m

julia&gt; <span class="codestrong">u"1.0m" + u"1cm"</span>
1.01 m

julia&gt; <span class="codestrong">u"1.0m/1s"</span>
1.0 m s^-1</pre>
<p class="noindent">Here we add a meter and a centimeter, and receive the result as a rational number of meters. The package returns results as rational numbers, when <span epub:type="pagebreak" id="page_271"/>possible, to preserve the ability to carry out exact conversions. But, as the second example shows, we can coerce a floating-point result by supplying a floating-point coefficient. The third example shows how we can construct expressions within the string literal.</p>
<p class="indent">You can find the complete list of units only in the source code, in its GitHub repository at <em class="calibre11">src/pkgdefaults.jl</em>, but most of them follow the usual physics conventions. Using the string literal syntax each time we want to refer to a unit can be cumbersome, so we can assign units to our own variables to ease our typing and make the code easier to read:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">m = u"m";</span>

julia&gt; <span class="codestrong">1m + u"1km"</span>
1001 m</pre>
<p class="indent">We add a meter to a kilometer, showing how we can use custom variables in combination with the string literals. The result is 1,001 meters.</p>
<p class="indent">We can parse a string as a <code>Unitful</code> expression with another function provided by the package (undocumented at the time of writing):</p>
<pre class="calibre13">julia&gt; <span class="codestrong">earth_accel = "9.8m/s^2";</span>

julia&gt; <span class="codestrong">kg_weight_earth = uparse("kg * " * earth_accel)</span>
9.8 kg m s^-2</pre>
<p class="indent">Here we use <code>uparse()</code> to convert a string, created by concatenating a string representing a mass with another representing the gravitational acceleration near the surface of Earth, into a unit expression representing the mass’s weight. The forms in which unit expressions appear in the REPL are not themselves legal strings for converting with <code>uconvert()</code>. For example, we need to include the multiplication operator in the string in the second line.</p>
<h4 class="h3" id="ch09lev1sec1"><strong class="calibre2"><em class="calibre4">Using Unitful Types</em></strong></h4>
<p class="noindent">We can gain access to a large supply of standard SI units by importing the <code>DefaultSymbols</code> submodule rather than defining them one by one. This practice adds a profusion of names to our namespace, however, so it may not be a good idea if we’re using only a few units:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Unitful.DefaultSymbols</span>

julia&gt; <span class="codestrong">minute = u"minute"</span>

julia&gt; <span class="codestrong">2s + 1minute</span>
62 s</pre>
<p class="noindent">Here we add 2 seconds to 1 minute, resulting in 62 seconds. The <code>DefaultSymbols</code> submodule supplies the <code>s</code> unit, but we need to define <code>minute</code>, as that’s not an SI unit. We’re using Julia’s syntax for multiplication through juxtaposition; this <span epub:type="pagebreak" id="page_272"/>expression is the same as <code>2 * s + 1minute</code>. However, these variables must be attached to numerical coefficients in arithmetic expressions; <code>2 * s + minute</code> is a <code>MethodError</code>.</p>
<p class="indent">We can find the reason for this error in the types of the two expressions:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">typeof(1minute)</span>
Quantity{Int64, <span class="codestrong">T</span>, Unitful.FreeUnits{(minute,), <span class="codestrong">T</span>, nothing}}

julia&gt; <span class="codestrong">typeof(minute)</span>
Unitful.FreeUnits{(minute,), <span class="codestrong">T</span>, nothing}</pre>
<p class="indent">The type of <code>1minute</code>, which is the same as the type of <code>1 * minute</code>, is a <code>Quantity</code>, while the type of <code>minute</code> is a <code>FreeUnits</code>. Both of these types are defined in the package. The <code>Unitful</code> package defines methods for addition and other arithmetic operations that accept arguments of type <code>Quantity</code>, but not of type <code>FreeUnits</code>.</p>
<p class="indent">These types contain parameters appearing as boldface Unicode characters. The <code>Unitful</code> package uses these characters to represent dimensions, so these type specifications tell us that the <code>minute</code> unit has dimensions of time, represented by <code><strong class="calibre7">T</strong></code>.</p>
<p class="indent">The type of <code>minute</code> and other units is an abstract type (see “The Type Hierarchy” on <a href="ch08.xhtml#ch08lev1sec4" class="calibre10">page 222</a>), while the types of quantified units such as <code>1minute</code> are concrete. For good performance, we should calculate with concrete types and define our own types with fields that have concrete types only.</p>
<h4 class="h3" id="ch09lev1sec2"><strong class="calibre2"><em class="calibre4">Stripping and Converting Units</em></strong></h4>
<p class="noindent">Sometimes we need to remove the units from the result of a calculation—for example, when passing a result to a function that doesn’t understand units. We can do this with the <code>convert()</code> function:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">convert(Float64, u"1m/100cm")</span>
1.0</pre>
<p class="indent">The type of the result is <code>Float64</code>. The results returned by <code>Unitful</code> calculations may not always be what we expect, so we should use <code>convert()</code> when we require a simple number:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">u"1m / 100cm"</span>
0.01 m cm^-1

julia&gt; <span class="codestrong">typeof(u"1m/100cm")</span>
Quantity{Float64, NoDims, Unitful.FreeUnits{(cm^-1, m), NoDims, nothing}}</pre>
<p class="noindent">Here we divide a length by another length, so the result should be the simple number 1.0 (because the lengths are equal) with no dimensions. The actual result is equivalent to that, but it’s expressed in an obscure form. Checking the type of the result, we find that it’s the concrete <code>Unitful</code> type <code>Quantity</code>, with type parameters indicating that it has no dimensions.</p>
<p class="indent"><span epub:type="pagebreak" id="page_273"/>If we use the same literal unit in the numerator and denominator, we get a result that may be closer to what we expect:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">u"1m / 2m"</span>
0.5

julia&gt; <span class="codestrong">typeof(u"1m / 2m")</span>
Float64</pre>
<p class="indent">A further example shows that <code>Unitful</code> is consistent in retaining the units we use in expressions instead of making conversions that might seem obvious to a physicist:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">u"1m * 1m"</span>
1 m^2

julia&gt; <span class="codestrong">u"1m * 100cm"</span>
100 cm m</pre>
<p class="noindent">The two input expressions mean the same thing, but lead to equivalent results that are expressed differently.</p>
<p class="indent">The function <code>upreferred()</code> from <code>Unitful</code> converts expressions so they use a standard set of units. The user can establish preferred systems of units, but the default behavior uses conventional SI units:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">u"1m * 100cm" |&gt; upreferred</span>
1//1 m^2</pre>
<p class="indent">In addition to converting to a number with <code>convert()</code>, we can use <code>uconvert()</code>, which is part of <code>Unitful</code>, to convert between units:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">uconvert(u"J", u"1erg")</span>
1//10000000 J

julia&gt; <span class="codestrong">uconvert(u"kg", u"2slug")</span>
29.187805874412728 kg</pre>
<p class="noindent">The function takes the unit to convert to in its first argument and the expression to convert in its second argument. In the first example we convert from ergs to joules. As both are metric units related by an exact ratio, <code>uconvert()</code> supplies the answer using a rational coefficient. The second example is a conversion from the US unit of mass, slugs, to kilograms, the standard SI unit used in physics. The conversion factor is a floating-point number.</p>
<p class="indent"><a href="ch09.xhtml#ch9lis1" class="calibre10">Listing 9-1</a> shows another way to extract the purely numerical part of a <code>Unitful</code> expression with <code>ustrip()</code>.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">vi = 17u"m/s"</span>
17 m s^-1

<span epub:type="pagebreak" id="page_274"/>julia&gt; <span class="codestrong">vf = 17.0u"m/s"</span>
17.0 m s^-1

julia&gt; <span class="codestrong">ustrip(v), ustrip(vf)</span>
(17, 17.0)</pre>
<p class="list" id="ch9lis1"><em class="calibre11">Listing 9-1: Stripping units with</em> <span class="codeitalic">ustrip()</span></p>
<p class="noindent">The <code>ustrip()</code> function preserves the numerical type in the expression.</p>
<p class="indent">To extract just the unit from a <code>Unitful</code> expression, the package provides the <code>unit()</code> function, as shown in <a href="ch09.xhtml#ch9lis2" class="calibre10">Listing 9-2</a>.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">unit(vi)</span>
m s^-1</pre>
<p class="list" id="ch9lis2"><em class="calibre11">Listing 9-2: Extracting units with</em> <span class="codeitalic">unit()</span></p>
<p class="indent">We’ll find applications for <code>ustrip()</code> and <code>unit()</code> in “Plotting with Units” on <a href="ch09.xhtml#ch09lev1sec4" class="calibre10">page 276</a>.</p>
<h4 class="h3" id="ch09lev1sec3"><strong class="calibre2"><em class="calibre4">Typesetting Units</em></strong></h4>
<p class="noindent">Using the <code>UnitfulLatexify</code> package, we can turn our <code>Unitful</code> expressions into LaTeX-typeset mathematics: either as LaTeX source ready to be dropped into a research paper or as a rendered image. Here is a simple example:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Unitful, Latexify, UnitfulLatexify</span>

julia&gt; <span class="codestrong">9.8u"m/s^2" |&gt; latexify</span>
L"$9.8\;\mathrm{m}\,\mathrm{s}^{-2}$"</pre>
<p class="indent">The <code>latexify()</code> function transforms the <code>Unitful</code> expression for Earth’s gravitational acceleration into a LaTeX string. We encountered La TeXstrings in <a href="ch04.xhtml#ch4lis1" class="calibre10">Listing 4-1</a>, when we used one to generate a title for a graph. The <code>UnitfulLatexify</code> package combines the LaTeX abilities in <code>Latexify</code> with <code>Unitful</code>, which is why we need to import all three packages, as we did at the start of this example.</p>
<p class="indent">When used in the REPL or another nongraphical context, <code>latexify()</code> produces LaTeX markup ready to be copied and pasted into a document. We can, instead, create a PDF image of the result by passing it to the <code>render()</code> function. To do that, you need to have the external program <code>LuaLaTeX</code>, which is part of standard LaTeX installations, installed. If that program is available, <code>render()</code> will use it to typeset the LaTeX string and immediately display it with the default PDF viewer. The <code>render()</code> process litters your temporary directory with files for every rendered expression, which is something to keep an eye on.</p>
<p class="indent">When using <code>UnitfulLatexify</code> in a graphical environment, such as a Pluto notebook, the output is rendered as LaTeX rather than LaTeX source. In most environments, typesetting uses a built-in engine rather than an external program, so no additional installations are required. For example, Pluto uses MathJax, a JavaScript library for LaTeX mathematical typesetting.</p>
<p class="noindent"><span epub:type="pagebreak" id="page_275"/><a href="ch09.xhtml#ch9fig1" class="calibre10">Figure 9-1</a> shows a Pluto session with Newton’s Second Law of Motion.</p>
<div class="image1"><img alt="Image" id="ch9fig1" src="../images/ch09fig01.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-1: Using</em> <span class="codeitalic">UnitfulLatexify</span> <em class="calibre11">in Pluto</em></p>
<p class="indent">In the final cell in <a href="ch09.xhtml#ch9fig1" class="calibre10">Figure 9-1</a>, we convert the acceleration to a more conventional combination of units and pass the result to <code>latexify()</code>. The typeset version appears as the result. MathJax provides a contextual menu when right-clicking on the result that gives us access to the LaTeX source.</p>
<p class="indent">If the use of negative exponents in unit expressions is not to our taste, we can pass the <code>permode</code> keyword to tell <code>latexify()</code> to use other styles. Here’s an example that demonstrates the default and the two options for <code>permode</code>:</p>
<pre class="calibre13">julia&gt; a = 0.0571u"m/s^2"

julia&gt; """
       <span class="codestrong">a = $(latexify(a))</span>

       <span class="codestrong">or</span>

       <span class="codestrong">$(latexify(a; permode=:frac))</span>

       <span class="codestrong">or</span>

       <span class="codestrong">$(latexify(a; permode=:slash))</span>

       <span class="codestrong">""" |&gt; println</span>
a = $0.0571\;\mathrm{m}\,\mathrm{s}^{-2}$

or

<span epub:type="pagebreak" id="page_276"/>$0.0571\;\frac{\mathrm{m}}{\mathrm{s}^{2}}$

or

$0.0571\;\mathrm{m}\,/\,\mathrm{s}^{2}$</pre>
<p class="indent">The example uses the existing definition for <code>a</code>. The <code>:frac</code> option uses LaTeX fractions instead of negative exponents, and the <code>:slash</code> option uses a slash, which is usually better for inline math.</p>
<p class="indent">Pasting the output in the previous listing into the LaTeX source of this book shows the rendered result:</p>
<div class="bqparan">
<p class="noindentin">a = 0.0571 m s<sup class="calibre23">−2</sup></p>
<p class="noindentin">or</p>
<p class="noindentin">0.0571 <img alt="Image" src="../images/276math.jpg" class="calibre6"/></p>
<p class="noindentin">or</p>
<p class="noindentin">0.0571 m/s<sup class="calibre23">2</sup></p>
</div>
<p class="noindent">We can change the default mode for rendering units with the <code>set_default(permode=:slash)</code> command.</p>
<h4 class="h3" id="ch09lev1sec4"><strong class="calibre2"><em class="calibre4">Plotting with Units</em></strong></h4>
<p class="noindent"><a href="ch09.xhtml#ch9lis3" class="calibre10">Listing 9-3</a> shows how <code>Plots</code> knows how to handle <code>Unitful</code> quantities.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Plots, Unitful</span>
julia&gt; <span class="codestrong">mass = 6.3u"kg";</span>
julia&gt; <span class="codestrong">velocity = (0:0.05:1)u"m/s";</span>
julia&gt; <span class="codestrong">KE = mass .* velocity.^2 ./ 2;</span>
julia&gt; <span class="codestrong">plot(velocity, KE; xlabel="Velocity", ylabel="KE",</span>
       <span class="codestrong">lw=3, legend=:topleft, label="Kinetic Energy")</span></pre>
<p class="list" id="ch9lis3"><em class="calibre11">Listing 9-3: Plotting</em> <span class="codeitalic">Unitful</span> <em class="calibre11">arrays</em></p>
<p class="indent">Here we import <code>Plots</code>, which we need for plotting, and <code>Unitful</code>, to handle units. After defining a mass in kilograms and a range of velocities in meters per second, we create an array of kinetic energies, <code>KE</code>, from the fact that kinetic energy = 1/2 mass × velocity<sup class="calibre23">2</sup>. The new package gives the plotting functions in <code>Plots</code> the ability to handle quantities with units and automatically appends the units to the axis labels. <a href="ch09.xhtml#ch9fig2" class="calibre10">Figure 9-2</a> shows the result of the <code>plot()</code> statement.</p>
<div class="image1"><img alt="Image" id="ch9fig2" src="../images/ch09fig02.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-2: The plot that <a href="ch09.xhtml#ch9lis3" class="calibre10">Listing 9-3</a> generates</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_277"/>I’ve left the energy units alone for this example, but more conventional physics usage would involve a conversion to joules using <code>uconvert()</code>, which we could have done before the plotting call or inline within <code>plot()</code>.</p>
<p class="indent">We were able to create this graph with the same <code>plot()</code> call that we might have used to plot the same quantities stored in numerical arrays without units. All the plotting functions in <code>Plots</code>, such as <code>scatter()</code> and <code>surface()</code>, work with <code>Unitful</code> arrays to produce similar axis labels.</p>
<h4 class="h3" id="ch09lev1sec5"><strong class="calibre2"><em class="calibre4">Making Plots for Publication</em></strong></h4>
<p class="noindent">When attempting to make high-quality plots for publication, however, we encounter some shortcomings. While <code>Plots</code> aspires to create a unified interface to a variety of backends, each plotting engine works somewhat differently, with each having unique capabilities and limitations.</p>
<p class="indent">These differences among backends become more salient when we are making the final adjustments that accompany the preparation of graphs for publication. It is at this stage that, for example, the typographic details in labels and annotations become important. <a href="ch09.xhtml#ch9fig2" class="calibre10">Figure 9-2</a> was created using the <code>GR</code> backend, which, as mentioned in “Useful Backends” on <a href="ch04.xhtml#ch04lev11" class="calibre10">page 115</a>, is the default at the time of writing, and is fast and capable.</p>
<p class="indent"><span epub:type="pagebreak" id="page_278"/><a href="ch09.xhtml#ch9fig2" class="calibre10">Figure 9-2</a> may be acceptable as is, but for publication we may want to improve the appearance of its graph labels, especially to make the unit notations look like conventional mathematical notation. As we saw in “LaTeX Titles and Label Positioning by Data” on <a href="ch04.xhtml#ch04lev1sec12" class="calibre10">page 103</a>, we can use LaTeX notation in graph annotations with mathematical content. This also works for the automatic labeling using units with the packages we’ve already imported:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Plots, Unitful, Latexify, UnitfulLatexify</span>

julia&gt; <span class="codestrong">plot(velocity, KE; xlabel="\\textrm{Velocity}",</span>
       <span class="codestrong">ylabel="\\textrm{KE}", unitformat=latexroundunitlabel)</span></pre>
<p class="indent">The example repeats the plot command from <a href="ch09.xhtml#ch9lis3" class="calibre10">Listing 9-3</a>, but with some alterations to create LaTeX strings for the plot labels. The <code>unitformat</code> keyword processes the unit annotations through <code>latexify()</code>, with the value <code>latexroundunitlabel</code> retaining the parentheses around the units. Since this triggers placing the entire label into a LaTeX string, we also need to wrap the non-math parts of the labels in LaTeX commands to set them as normal text instead of math.</p>
<h5 class="h4" id="ch09sec1sec1"><strong class="calibre2">The GR Backend</strong></h5>
<p class="noindent">The results of this approach depend critically on what backend we’re using. Obviously, it makes sense to use LaTeX strings only with backends that can do something with them. Although the default <code>GR</code> backend can interpret LaTeX, the results are not always adequate. This engine includes its own version of LaTeX processing, which often creates poor-quality typesetting with faulty kerning. The LaTeX engine in <code>GR</code> is the focus of some development activity, however, so its performance may improve.</p>
<p class="indent">Good-quality typesetting of labels in most cases requires processing by an external TeX engine, which involves a TeX installation such as TeXLive. As many physicists and other scientists have already made such an installation, we’ll move on to considering options that take advantage of it.</p>
<h5 class="h4" id="ch09sec1sec2"><strong class="calibre2">The Gaston Backend</strong></h5>
<p class="noindent">Gnuplot can optionally be compiled with support for the <code>tikz</code> terminal, which saves plots as text files containing TikZ commands. (TikZ is a graphics language that comes with most full-featured TeX installations.) Such files are processed with LaTeX and can contain TeX or LaTeX markup for the annotations on the plot. The result is of the highest quality, with fonts and styles that match the document in which the plot is included. Unfortunately, at the time of writing, the <code>Gaston</code> backend, which uses gnuplot, does not properly support the <code>tikz</code> terminal, so this option is off the table. It’s being worked on, however, and once we can use <code>Gaston</code> with <code>tikz</code>, it will be the best option for complex plots for publication or when the best typographic quality is desired.</p>
<h5 class="h4" id="ch09sec1sec3"><span epub:type="pagebreak" id="page_279" class="calibre1"/><strong class="calibre2">The PGFPlotsX Backend</strong></h5>
<p class="noindent">Another backend that can make use of LaTeX strings is <code>PGFPlotsX</code>, which is invoked with the <code>pgfplotsx()</code> function. This backend creates plots by calling out to the LuaLaTeX TeX engine, which comes with most TeX installations, including TeXLive. Since LuaLaTeX does all the typesetting, the labels come out with TeX-level quality. This backend is, therefore, an excellent choice for publication-quality graphs. <code>Gaston</code> may still be the best future choice for complex plots because processing through LuaLaTeX can be far slower than through gnuplot if the plot contains a large number of elements, such as in a large scatterplot.</p>
<h5 class="h4" id="ch09sec1sec4"><strong class="calibre2">Handling Units Manually</strong></h5>
<p class="noindent">Unfortunately, <code>PGFPlotsX</code> does not work properly with <code>Unitful</code>, not taking TeX processing into account. This limitation provides the opportunity to demonstrate a different way of plotting <code>Unitful</code> quantities and labeling axes with units—one that affords us complete control over the details.</p>
<p class="indent">The following listing contains the definition of a function that accepts two <code>Unitful</code> arrays for plotting, along with keyword arguments for labels:</p>
<pre class="calibre13">using Plots, LaTeXStrings, Latexify, UnitfulLatexify

function plot_with_units(ux, uy; xl="", yl="", label="",
                         legend=:topleft, plotfile="plotfile")

    set_default(permode=:slash)
    x = ustrip(ux); y = ustrip(uy)
 <span class="ent">➊</span> xlabel = L"$\textrm{%$xl}$ (%$(latexify(unit(eltype(ux)))))"
    ylabel = L"$\textrm{%$yl}$ (%$(latexify(unit(eltype(uy)))))"

    plot(x, y; xlabel, ylabel, lw=2, label, legend)
 <span class="ent">➋</span> savefig(plotfile * ".tex")
    savefig(plotfile * ".pdf")

end</pre>
<p class="indent">Using the <code>ustrip()</code> and <code>unit()</code> functions (see <a href="ch09.xhtml#ch9lis1" class="calibre10">Listings 9-1</a> and <a href="ch09.xhtml#ch9lis2" class="calibre10">9-2</a>), this code separates the arrays from their associated units, plotting the numerical parts and using the unit parts to construct labels with the <code>LaTeXStrings</code> package.</p>
<p class="indent">In order to interpolate values into a <code>LaTeXStrings</code> string, we need to use the two characters <code>%$</code> rather than a simple <code>$</code> <span class="ent">➊</span>. When extracting the units from the arrays, we require the units of the elements of the array, which is why <code>eltype()</code> appears in the label assignment. The function saves both the stand-alone PDF version of the graph and its TeX version <span class="ent">➋</span> for including in a LaTeX document.</p>
<p class="indent"><span epub:type="pagebreak" id="page_280"/>After selecting the desired backend, we call the function to create the <em class="calibre11">.pdf</em> and <em class="calibre11">.tex</em> files with the default names:</p>
<pre class="calibre13">pgfplotsx()
plot_with_units(velocity, KE; xl="Velocity", yl="K. E.")</pre>
<p class="indent"><a href="ch09.xhtml#ch9fig3" class="calibre10">Figure 9-3</a> shows the result.</p>
<div class="image1"><img alt="Image" id="ch9fig3" src="../images/ch09fig03.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-3: A</em> <span class="codeitalic">PGFPlotsX</span> <em class="calibre11">plot with typeset unit labels</em></p>
<p class="indent">Typesetting by LuaTeX provides the excellent quality of the labels in <a href="ch09.xhtml#ch9fig3" class="calibre10">Figure 9-3</a>.</p>
<h3 class="h2" id="ch09lev2"><strong class="calibre2">Error Propagation with Measurements</strong></h3>
<p class="noindent">In the previous section we explored a package that extended the concept of numbers to include physical units. Here we’ll meet <code>Measurements</code>, another package that defines a number-like object useful for calculations in physics or nearly any empirical science.</p>
<p class="indent">The <code>Measurements</code> package allows us to attach uncertainties to numbers. The number in question must be convertible to a float, so we can attach uncertainties directly to <code>Float64</code> numbers, integers, and <code>Irrational</code> quantities. (We can also create complex numbers with uncertainties, if we really want to, by attaching errors to their real and imaginary parts.) The <code>Measurements</code> package defines a new data type, called <code>Measurement{T}</code>, where <code>T</code> can be any size float. We can perform any arithmetic operations on <code>Measurement</code> types that are allowed on floats, and the errors, or uncertainties, will be propagated to the result using standard linear error propagation theory.</p>
<p class="indent">Here are some examples of creating instances of <code>Measurement</code> types:</p>
<span epub:type="pagebreak" id="page_281"/>
<pre class="calibre13">   julia&gt; <span class="codestrong">using Measurements</span>

   julia&gt; <span class="codestrong">92 ± 3</span>
   92.0 ± 3.0

   julia&gt; <span class="codestrong">typeof(ans)</span>
   Measurement{Float64}

<span class="ent">➊</span> julia&gt; <span class="codestrong">92.0f0 ± 3</span>
   92.0 ± 3.0

   julia&gt; <span class="codestrong">typeof(ans)</span>
   Measurement{Float64}

   julia&gt; <span class="codestrong">92.0f0 ± 3f0</span>
   92.0 ± 3.0

   julia&gt; <span class="codestrong">typeof(ans)</span>
   Measurement{Float32}

   julia&gt; <span class="codestrong">big(1227.0) ± 2</span>
   1227.0 ± 2.0

   julia&gt; <span class="codestrong">typeof(ans)</span>
   Measurement{BigFloat}</pre>
<p class="indent">We create <code>Measurement</code> objects using a notation that will be familiar to scientists. We can type the <code>±</code> operator by entering <span class="codestrong1">\pm</span> in the REPL and pressing <small class="calibre5">TAB</small> or by using the operating system’s entry method for special characters.</p>
<p class="indent">In the REPL, the <code>ans</code> variable holds the most recently returned result. Since <code>Measurement</code> objects have only one type parameter, the base number and the error must be of the same type. As the <code>typeof()</code> calls show, <code>Measurements</code> promotes the smaller type as needed; the <code>f0</code> suffix is a way to enter 32-bit float literals <span class="ent">➊</span>.</p>
<p class="indent">The package treats significant digits intelligently:</p>
<pre class="calibre13">julia&gt; π <span class="codestrong">± 0.001</span>
3.1416 ± 0.001

julia&gt; π <span class="codestrong">± 0.01</span>
3.142 ± 0.01</pre>
<p class="noindent">The digits made insignificant by the error are not printed.</p>
<p class="indent">When printing results in the REPL, the package displays only two significant digits in the error, to keep things neat:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">m1 = 2.20394232 ± 0.00343</span>
2.2039 ± 0.0034

<span epub:type="pagebreak" id="page_282"/>julia&gt; <span class="codestrong">Measurements.value(m1)</span>
2.20394232

julia&gt; <span class="codestrong">Measurements.uncertainty(m1)</span>
0.00343</pre>
<p class="indent">However, it retains the full values internally for computations. We can access these components with the <code>value()</code> and <code>uncertainty()</code> functions shown here, which, as they are not exported, we need to qualify with the package namespace.</p>
<p class="indent">Scientists often use an alternative, convenient notation to express uncertainty by appending the error in the final significant digits within parentheses. The <code>Measurements</code> package understands this notation as well:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">emass = measurement("9.1093837015(28)e-31")</span>
9.1093837015e-31 ± 2.8e-40</pre>
<p class="indent">In order to use the notation, we need to employ the <code>measurement()</code> function and supply the argument as a string. We can also use <code>measurement()</code> as an alternative to the <code>±</code> operator:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">m1 = measurement(20394232, 0.00343)</span>
2.0394232e7 ± 0.0034</pre>
<p class="indent">Arithmetic operations propagate errors correctly:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">emass</span>
9.1093837015e-31 ± 2.8e-40

julia&gt; <span class="codestrong">2emass</span>
1.8218767403e-30 ± 5.6e-40

julia&gt; <span class="codestrong">emass + emass</span>
1.8218767403e-30 ± 5.6e-40

julia&gt; <span class="codestrong">emass/2</span>
4.5546918508e-31 ± 1.4e-40

julia&gt; <span class="codestrong">emass/2emass</span>
0.5 ± 0.0</pre>
<p class="indent">All these examples perform arithmetic as might be expected on the quantities and their errors. More interesting is the last example, where <code>Measurements</code> has recognized a ratio that has no error. The package maintains the notion of correlated and independent measurements, which is explained in its documentation. See “Further Reading” on <a href="ch09.xhtml#fur9" class="calibre10">page 304</a> for the URL.</p>
<p class="indent">Referring back to the example in <a href="ch09.xhtml#ch9lis3" class="calibre10">Listing 9-3</a>, we can add an uncertainty to the <code>Unitful</code> value for mass in two ways:</p>
<span epub:type="pagebreak" id="page_283"/>
<pre class="calibre13">julia&gt; <span class="codestrong">using Measurements, Unitful</span>

julia&gt; <span class="codestrong">mass = 6.3u"kg" ± 0.5u"kg"</span>
6.3 ± 0.5 kg

julia&gt; <span class="codestrong">mass = 6.3u"kg"; mass = (1 ± 0.5/6.3) * mass</span>
6.3 ± 0.5 kg</pre>
<p class="noindent">This example shows that the packages <code>Measurements</code> and <code>Unitful</code> can work together to create quantities with both units and uncertainties.</p>
<p class="indent">Let’s continue with the example from <a href="ch09.xhtml#ch9lis3" class="calibre10">Listing 9-3</a> using this new value for <code>mass</code>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Plots</span>

julia&gt; <span class="codestrong">velocity = (0:0.05:1)u"m/s";</span>

julia&gt; <span class="codestrong">KE = mass .* velocity.^2 ./ 2;</span>

julia&gt; <span class="codestrong">plot(velocity, uconvert.(u"J", KE); xlabel="Velocity", ylabel="K.E.",</span>
       <span class="codestrong">lw=2, legend=:topleft, label="Kinetic energy")</span></pre>
<p class="indent">Although, as before, <code>velocity</code> has no uncertainty attached to it, <code>mass</code> does; therefore, <code>KE</code> should also contain uncertainties.</p>
<p class="indent"><a href="ch09.xhtml#ch9fig4" class="calibre10">Figure 9-4</a> shows the result.</p>
<div class="image1"><img alt="Image" id="ch9fig4" src="../images/ch09fig04.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-4: Plotting with units and errors</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_284"/><a href="ch09.xhtml#ch9fig4" class="calibre10">Figure 9-4</a> shows the <code>Unitful</code> arrays plotted as before with the axes labeled with their units. It also has error bars, showing how the error increases as the kinetic energy increases. We didn’t have to change anything in the call to <code>plot()</code>. Somehow the type of the quantities to be plotted triggered the plotting function to use both unit labels and error bars. We would observe the same behavior with the other plotting functions in <code>Plots</code>, such as <code>scatter()</code> or <code>surface()</code>.</p>
<h3 class="h2" id="ch09lev3"><strong class="calibre2">Fluid Dynamics with Oceananigans</strong></h3>
<p class="noindent">The <code>Oceananigans</code> package for fluid dynamics simulations is especially well suited, as the name suggests, to the physics of the ocean. It provides a simulation construction kit that can include the effects of temperature and salinity variations, Earth’s rotation, wind, and more. Its defaults usually perform well, but it’s flexible enough that the user can specify one of several available solution methods. It has various physics models built in, including a linear equation of state, but makes it easy to substitute others of the user’s devising.</p>
<h4 class="h3" id="ch09lev1sec6"><strong class="calibre2"><em class="calibre4">The Physical System</em></strong></h4>
<p class="noindent">We are setting out to simulate a two-dimensional layer of fluid in Earth’s gravitational field. The bottom of the layer is maintained at a higher temperature than the top. This heating from below creates a convective motion, as can be seen in clouds or in a pan on the stove.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><span class="codeitalic1">Oceananigans</span> <em class="calibre11">depends on some compiled binaries in the standard library. If the precompilation of</em> <span class="codeitalic1">Oceananigans</span> <em class="calibre11">fails and you’re using a recent or beta version of Julia, try it with an earlier Julia release (the previous major version number).</em></p>
</div>
<p class="indent">The bottom and top simulation boundaries are impenetrable and freeslip, which means the fluid can slide across them. Horizontally, we impose a periodic boundary condition, requiring the solution to wrap around and be the same on the left and right boundaries. The horizontal direction is <em class="calibre11">x</em> and the vertical direction is <em class="calibre11">z</em>. We start the fluid at rest and are interested in the pattern of motion that the temperature difference creates.</p>
<p class="indent"><a href="ch09.xhtml#ch9fig5" class="calibre10">Figure 9-5</a> shows the setup of the simulated system. The gray area represents the fluid, and the thick black horizontal lines indicate the constant-temperature boundaries.</p>
<div class="image1"><img alt="Image" id="ch9fig5" src="../images/ch09fig05.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-5: The simulation box</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_285"/>The <code>Luxor</code> program (see “Diagramming with Luxor” on <a href="ch07.xhtml#ch07lev1" class="calibre10">page 190</a>) that created this diagram is available in the Physics section of the online supplement at <a href="https://julia.lee-phillips.org" class="calibre10"><em class="calibre11">https://julia.lee-phillips.org</em></a>.</p>
<p class="indent">A fluid dynamics simulation contains many pieces that we’ll need to construct separately before we can begin the calculation. In the following subsections, we’ll define the computational grid, the boundary conditions, the diffusivity models, and the equation of state, and establish the boundary conditions and the hydrodynamic model, in that order. After all the pieces are in place, we’ll run the <code>Oceananigans</code> simulation and visualize the results.</p>
<h4 class="h3" id="ch09lev1sec7"><strong class="calibre2"><em class="calibre4">The Grid</em></strong></h4>
<p class="noindent">To put together an <code>Oceananigans</code> simulation, we’ll define its various components using functions exported by the package, and then define a model using the <code>model()</code> function, passing in the components as arguments. For this example we’ll use a <code>grid</code>, a <code>buoyancy</code> model that specifies the fluid’s equation of state, a set of boundary conditions, the coefficients of viscosity and thermal diffusivity (material properties of the fluid), and initial conditions on the temperature within the fluid. We won’t include the effects of Earth’s rotation, salinity, or wind, but these ingredients are available for use in other <code>Oceananigans</code> models.</p>
<p class="indent">The grid is defined by its computational <code>size</code> (how many grid points exist in each direction), its <code>extent</code> (the physical lengths represented by these directions), and its <code>topology</code>, which is the term <code>Oceananigans</code> uses for what boundary conditions hold in each direction. For our problem we define the grid this way:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Oceananigans</span>

julia&gt; <span class="codestrong">grid = RectilinearGrid(size=(256, 32);</span>
              <span class="codestrong">topology=(Periodic, Flat, Bounded),</span>
              <span class="codestrong">extent=(256, 32))</span>
 256×1×32 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo
|-- Periodic x ∈ [0.0, 256.0)     regularly spaced with Δx=1.0
|-- Flat y
-- Bounded  z ∈ [-32.0, 0.0]      regularly spaced with Δz=1.0</pre>
<p class="indent">The <code>RectilinearGrid()</code> function that <code>Oceananigans</code> provides constructs grids as one of many data types defined in the package. We assign the grid to our own variable, <code>grid</code>, for use later when creating the model. We could have chosen any name for this variable, but <code>grid</code> is the name of the relevant keyword argument accepted by the model construction function; using the same names for our own variables will keep everything neat.</p>
<p class="indent">In the <code>topology</code> keyword argument, we list the boundary conditions in the <em class="calibre11">x</em>, <em class="calibre11">y</em>, and <em class="calibre11">z</em> directions, with <em class="calibre11">z</em> pointing upward. The boundary condition <code>Flat</code> means that we’re not using (in this case) the <em class="calibre11">y</em> direction. This call defines a two-dimensional, <em class="calibre11">x</em>–<em class="calibre11">z</em> grid, with periodic boundaries in <em class="calibre11">x</em> and impenetrable boundaries in <em class="calibre11">z</em>. <code>Oceananigans</code> uses a kilogram-meter-second unit system. <span epub:type="pagebreak" id="page_286"/>Because we set the <code>extent</code> to be equal to the <code>size</code>, the grid spacing is one unit in length along each dimension, giving us a fluid layer 256 meters wide and 32 meters tall.</p>
<p class="indent">As the example shows, <code>Oceananigans</code> has useful forms for representing its data types in the REPL, summarizing the salient information for our inspection. Here the output provides us with a summary of the grid parameters and boundary conditions.</p>
<h4 class="h3" id="ch09lev1sec8"><strong class="calibre2"><em class="calibre4">The Boundary Conditions</em></strong></h4>
<p class="noindent">We define any boundary conditions on physical variables as a separate component, which is also eventually passed into <code>model()</code>. We want to impose constant values of temperature on the top and bottom boundaries; <code>Oceananigans</code> sets this type of boundary condition with the <code>FieldBoundaryConditions()</code> function, as it sets boundary conditions on, in this case, the temperature field. We can use <code>Oceananigans</code>’s convenient definitions of <code>top</code> and <code>bottom</code>, which have their intuitive meaning (there are also <code>north</code>, <code>south</code>, <code>east</code>, and <code>west</code>, which we don’t need in this problem):</p>
<pre class="calibre13">julia&gt; <span class="codestrong">bc = FieldBoundaryConditions(</span>
               <span class="codestrong">top=ValueBoundaryCondition(1.0),</span>
               <span class="codestrong">bottom=ValueBoundaryCondition(20.0))</span>
Oceananigans.FieldBoundaryConditions, with boundary conditions
|-- west: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
|-- east: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
|-- south: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
|-- north: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)
|-- bottom: ValueBoundaryCondition: 20.0
|-- top: ValueBoundaryCondition: 1.0
-- immersed: DefaultBoundaryCondition (FluxBoundaryCondition: Nothing)</pre>
<p class="indent">The <code>immersed</code> boundary refers to one that exists inside the fluid volume, but we’re not using that one, nor any of the other myriad options, such as defined gradients or fluxes. The <code>ValueBoundaryCondition</code> that we use sets a constant value for a variable on the specified boundary.</p>
<h4 class="h3" id="ch09lev1sec9"><strong class="calibre2"><em class="calibre4">The Diffusivities</em></strong></h4>
<p class="noindent">We need to assign values to two constants that describe some of the fluid’s material properties; this is part of the problem definition. The viscosity coefficient (<em class="calibre11">ν</em>) determines how “thick” the fluid is, and the thermal diffusivity (<em class="calibre11">κ</em>) determines how readily it conducts heat. These values are passed to the model in the <code>closure</code> keyword and can be set through the <code>ScalarDiffusivity()</code> function:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">closure = ScalarDiffusivity(ν=0.05, κ=0.01)</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_287"/>The symbol for viscosity is the Greek letter <em class="calibre11">nu</em> and that for thermal diffusivity is <em class="calibre11">kappa</em>. Like all Greek letters, we can precede their names with a backslash and then press TAB to enter them in the REPL.</p>
<h4 class="h3" id="ch09lev1sec10"><strong class="calibre2"><em class="calibre4">The Equation of State</em></strong></h4>
<p class="noindent">The equation of state is a function that describes how the density of the fluid at any point depends on the temperature and salinity there (the assumption of <em class="calibre11">incompressibility</em> usually used in <code>Oceananigans</code> models means that density has no dependence on pressure). Our model is salt free, but our fluid will be lighter when it’s hotter. This is what will cause the fluid to move, as the lighter parts will rise and the heavier parts will sink, driven by gravity.</p>
<p class="indent">The <code>model()</code> function expects the keyword <code>buoyancy</code>, so we’ll use that too:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">buoyancy = SeawaterBuoyancy(equation_of_state=</span>
                  <span class="codestrong">LinearEquationOfState(thermal_expansion=0.01,</span>
                  <span class="codestrong">haline_contraction=0))</span>
SeawaterBuoyancy{Float64}:
|-- gravitational_acceleration: 9.80665
-- equation of state: LinearEquationOfState(thermal_expansion=0.01, haline_contraction=0.0)</pre>
<p class="indent"><span class="codeitalic1">Oceananigans</span> offers many other options, including the ability to define our own equation of state, but we’ll keep the model simple. The <code>SeawaterBuoyancy</code> component deals with buoyancy by combining gravity (with the default Earth value given here) with density variations. As we’re not interested in salinity effects for this calculation, we set <code>haline_contraction</code> to 0 (“haline” is essentially a synonym for saline used by oceanographers).</p>
<h4 class="h3" id="ch09lev1sec11"><strong class="calibre2"><em class="calibre4">The Model and Initial Conditions</em></strong></h4>
<p class="noindent">Now that we have all the pieces set up, we can put them together into a <em class="calibre11">model</em>, the <code>Oceananigans</code> term for the definition of the computational problem, including all the physics along with the grid and the boundary conditions:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">model = NonhydrostaticModel(;</span>
                  <span class="codestrong">grid, buoyancy, closure,</span>
                  <span class="codestrong">boundary_conditions=(T=bc,), tracers=(:T, :S))</span>
NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)
|-- grid: 256×1×32 RectilinearGrid{Float64, Periodic, Flat, Bounded}
 <span class="ent">➊</span> on CPU with 3×0×3 halo
|-- timestepper: QuasiAdamsBashforth2TimeStepper
|-- tracers: (T, S)
|-- closure: ScalarDiffusivity{ExplicitTimeDiscretization}
    (ν=0.05, κ=(T=0.01, S=0.01))
|-- buoyancy: SeawaterBuoyancy with g=9.80665 and
    LinearEquationOfState(thermal_expansion=0.01, haline_contraction=0.0)
    with -ĝ = ZDirection
-- coriolis: Nothing</pre>
<p class="indent"><span epub:type="pagebreak" id="page_288"/>The package prints a nice summary of the result, including a reminder of some (but not all) of the features we’re not using, such as the coriolis force from Earth’s rotation.</p>
<p class="indent">The <code>NonhydrostaticModel()</code> function creates a model using the approximation appropriate to our problem. <code>Oceananigans</code> offers several other choices, including a hydrostatic model to simulate surface waves.</p>
<p class="indent">We use the abbreviated form of passing keyword arguments explained in “Concise Syntax for Keyword Arguments” on <a href="ch06.xhtml#ch06lev1sec1" class="calibre10">page 154</a>.</p>
<p class="indent">Our boundary condition <code>bc</code> doesn’t refer to any particular physical variable; it simply defines a constant field value on the boundaries. The named tuple assigned to <code>boundary_conditions</code> enforces them on <code>T</code>, the variable used in <code>Oceananigans</code> for the temperature.</p>
<p class="indent">The printed result refers to the CPU <span class="ent">➊</span>, which means that this model is intended for “normal” machine architectures. The other option is to calculate on GPUs (graphics processing units). The <code>halo</code> refers to the several points outside the physical grid that the numerical algorithm uses to enforce the boundary conditions or other constraints.</p>
<p class="indent">The final keyword argument, <code>tracers</code>, tells the model to keep track of the temperature and salinity as those scalar fields are advected around the fluid. We’re required to include <code>:S</code> even though our equation of state means it will have no effect.</p>
<p class="indent">The fluid layer heated from below defined by our model is physically <em class="calibre11">unstable</em>, which means that a small perturbation to its initial, motionless state will be magnified and develop into a state with some form of persistent motion, driven by the temperature difference and the gravitational field. It is the development of the instability that we want to study. We need to add the small perturbation, or else, even though the system is unstable, it will never move.</p>
<p class="indent">The <code>set!()</code> function lets us create any desired initial condition on any of the fields. We’ll use it to add a small, random perturbation to the temperature field throughout the fluid volume:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">tper(x, y, z) = 0.1 * rand()</span>
tper (generic function with 1 method)

julia&gt; <span class="codestrong">set!(model; T = tper)</span></pre>
<p class="noindent">The function is spelled with an exclamation point to remind us that it mutates its arguments: it alters the <code>T</code> field in place, and the model as well.</p>
<h4 class="h3" id="ch09lev1sec12"><strong class="calibre2"><em class="calibre4">The Simulation</em></strong></h4>
<p class="noindent">Next we need to create a <em class="calibre11">simulation</em>, using the <code>Simulation()</code> function. This object will receive the model as its positional argument, along with keyword arguments for the timestep and when to stop the calculation. It will keep track of how much simulation time and wall-clock time has elapsed and the state of all the physical fields. This allows us to continue the simulation after <span epub:type="pagebreak" id="page_289"/>the requested start time if we want, save the progress of the simulation in files, and retrieve the fields for examination and plotting.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">simulation = Simulation(model; Δt=0.01, stop_time=1800)</span>
Simulation of NonhydrostaticModel{CPU, RectilinearGrid}(time = 0 seconds, iteration = 0)
|-- Next time step: 10 ms
|-- Elapsed wall time: 0 seconds
|-- Wall time per iteration: NaN years
|-- Stop time: 30 minutes
|-- Stop iteration : Inf
|-- Wall time limit: Inf
|-- Callbacks: OrderedDict with 4 entries:
|   |-- stop_time_exceeded =&gt; Callback of stop_time_exceeded on IterationInterval(1)
|   |-- stop_iteration_exceeded =&gt; Callback of stop_iteration_exceeded on IterationInterval(1)
|   |-- wall_time_limit_exceeded =&gt; Callback of wall_time_limit_exceeded on IterationInterval(1)
|    -- nan_checker =&gt; Callback of NaNChecker for u on IterationInterval(100)
|-- Output writers: OrderedDict with no entries
-- Diagnostics: OrderedDict with no entries</pre>
<p class="indent">This is a simple call, as <code>model</code> already contains all the details of the problem. We get a summary of various options for the simulation, most of which we didn’t use. If you want to use the <em class="calibre11">delta</em> for the time interval in the REPL, enter <span class="codestrong1">\Delta</span> and press <small class="calibre5">TAB</small>.</p>
<p class="indent">Before running the simulation, let’s arrange for the velocity and temperature fields to be stored on disk at regular intervals so we can see its development over time (if we don’t do this, we’ll see only the final state of the simulation), as shown in <a href="ch09.xhtml#ch9lis4" class="calibre10">Listing 9-4</a>.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">simulation.output_writers[:velocities] =</span>
              <span class="codestrong">JLD2OutputWriter(model, model.velocities,</span>
              <span class="codestrong">filename="conv4.jld2", schedule=TimeInterval(1))</span>
 JLD2OutputWriter scheduled on TimeInterval(1 second):
|-- filepath: ./conv4.jld2
|-- 3 outputs: (u, v, w)
|-- array type: Array{Float32}
|-- including: [:grid, :coriolis, :buoyancy, :closure]
-- max filesize: Inf YiB

julia&gt; <span class="codestrong">simulation.output_writers[:tracers] =</span>
              <span class="codestrong">JLD2OutputWriter(model, model.tracers,</span>
              <span class="codestrong">filename="conv4T.jld2", schedule=TimeInterval(1))</span>
 JLD2OutputWriter scheduled on TimeInterval(1 second):
|-- filepath: ./conv4T.jld2
|-- 2 outputs: (T, S)
|-- array type: Array{Float32}
|-- including: [:grid, :coriolis, :buoyancy, :closure]
-- max filesize: Inf YiB</pre>
<p class="list" id="ch9lis4"><em class="calibre11">Listing 9-4: Setting up output writers</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_290"/>Adding elements to the <code>output_writers</code> property of the <code>simulation</code> causes it to store the results periodically. The <code>JLD2OutputWriter</code> uses the <code>JLD2</code> file format, which is a compact way to store multiple Julia data structures in a single file. It’s a version of the <code>HDF5</code> format widely used in computational science. The <code>schedule</code> causes a data dump every 1 second, which, using our timestep, will be every 100 steps. The information in the result shows which quantities will be saved: <code>T</code> and <code>S</code> are the temperature and salinity.</p>
<p class="indent">With this, we’re ready to run the calculation:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">run!(simulation)</span>
[ Info: Initializing simulation...
[ Info:     ... simulation initialization complete (6.850 ms)
[ Info: Executing initial time step...
[ Info:     ... initial time step complete (80.507 ms).</pre>
<p class="indent">The REPL will not have anything more to say until it reaches the final timestep, which in this case will take several hours on a typical personal computer. Then it will indicate that the calculation is complete and return to the interactive prompt. <a href="ch15.xhtml" class="calibre10">Chapter 15</a> explores ways to speed up such calculations by using parallel processing.</p>
<h4 class="h3" id="ch09lev1sec13"><strong class="calibre2"><em class="calibre4">The Results</em></strong></h4>
<p class="noindent">When an <code>Oceananigans</code> simulation ends, the final state of the fields (the velocity components and the temperature, in this case) is available as properties of the <code>model</code>. <a href="ch09.xhtml#ch9lis5" class="calibre10">Listing 9-5</a> shows how to retrieve them.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Plots</span>

julia&gt; <span class="codestrong">uF = model.velocities.u;</span>

julia&gt; <span class="codestrong">TF = model.tracers.T;</span>

julia&gt; <span class="codestrong">heatmap(interior(TF, 1:grid.Nx, 1, 1:grid.Nz)';</span>
               <span class="codestrong">aspect_ratio=1, yrange=(0, 1.5grid.Nz))</span></pre>
<p class="list" id="ch9lis5"><em class="calibre11">Listing 9-5: Examining the results of a simulation</em></p>
<p class="indent">The velocity and temperature fields are properties of the model. The <code>heatmap()</code> call will plot the two-dimensional temperature field, but first we need to turn it into an array with the <code>interior()</code> function. This function converts the <code>Oceananigans</code> field into a numerical array and trims away the <code>halo</code> points. Its arguments, following the field to convert, are the extents of the grid in each of the three directions; we enter a <code>1</code> to indicate an unused coordinate. In setting the <code>yrange</code>, we’ve accessed another property of the field, its grid shape. The prime after the array to plot transposes it so that it appears in its natural orientation, with a vertical gravity.</p>
<p class="indent">We would normally run a simulation for just a few timesteps and examine the fields in this way before running a long calculation, to make sure <span epub:type="pagebreak" id="page_291"/>we’ve set it up correctly. If we want to take another look after a few more timesteps, we can do this:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">simulation.stop_time+=10;</span>

julia&gt; <span class="codestrong">run!(simulation);</span></pre>
<p class="noindent">These commands advance the simulation an additional 10 timesteps, after which we can repeat the steps in <a href="ch09.xhtml#ch9lis5" class="calibre10">Listing 9-5</a> to see how things are going.</p>
<p class="indent">Returning now to the quantities stored in files, as set up in <a href="ch09.xhtml#ch9lis4" class="calibre10">Listing 9-4</a>, <a href="ch09.xhtml#ch9lis6" class="calibre10">Listing 9-6</a> shows how to retrieve the entire history of a field.</p>
<pre class="calibre13">julia&gt; <span class="codestrong">uF = FieldTimeSeries("conv4.jld2", "u")</span>
256×1×32×1030 FieldTimeSeries{InMemory} located at
    (Face, Center, Center) on CPU
|-- grid: 256×1×32 RectilinearGrid{Float64, Periodic, Flat, Bounded}
    on CPU with 3×0×3 halo
|-- indices: (1:256, 1:1, 1:32)
-- data: 256×1×32×1030 OffsetArray(::Array{Float64, 4},
    1:256, 1:1, 1:32, 1:1030) with eltype Float64 with
 indices 1:256×1:1×1:32×1:1030
    -- max=7.66057, min=-7.88889, mean=2.79295e-11</pre>
<p class="list" id="ch9lis6"><em class="calibre11">Listing 9-6: Retrieving a field from the JLD2 file</em></p>
<p class="indent">The summary of the result shows that the <code>FieldTimeSeries</code> has dimensions of 256×1×32×1,030, which means that it’s defined on a 2D, 256×32 grid and evolves over 1,030 timesteps.</p>
<p class="indent">After this call the entire history of the <em class="calibre11">x</em>-velocity field and its various properties are conveniently available. The data structure <code>uF</code> itself takes up almost no space:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">sizeof(uF)</span>
544</pre>
<p class="noindent">The <code>sizeof()</code> function returns the amount of storage, in bytes, occupied by its argument. The actual data occupies 256 × 32 × 1,030 × 8 = 67,502,080 bytes.</p>
<p class="indent">We can plot the horizontal velocity field at any timestep:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using Printf</span>

julia&gt; <span class="codestrong">i = 50;</span>

julia&gt; <span class="codestrong">h50 = heatmap(interior(uF[i], 1:grid.Nx, 1, 1:grid.Nz)';</span>
               <span class="codestrong">aspect_ratio=1, yrange=(0, 1.5grid.Nz),</span>
               <span class="codestrong">colorbar=:false, ylabel="z",</span>
               <span class="codestrong">annotations=[</span>
                  <span class="codestrong">(0, uF.grid.Nz+15,</span>
                    <span class="codestrong">text("Horizontal velocity at timestep $i", 12, :left)),</span>
                  <span epub:type="pagebreak" id="page_292"/><span class="codestrong">(0, uF.grid.Nz+5,</span>
                    <span class="codestrong">text((@sprintf "Max = %.3g" maximum(uF[i])), 8, :left)),</span>
                  <span class="codestrong">(100, uF.grid.Nz+5,</span>
                    <span class="codestrong">text((@sprintf "Min = %.3g" minimum(uF[i])), 8, :left))],</span>
                  <span class="codestrong">grid=false, axis=false)</span></pre>
<p class="indent">We’ve added some labeling to the version in <a href="ch09.xhtml#ch9lis5" class="calibre10">Listing 9-5</a>, annotating the plot using properties read out from the field. Creating similar plots for timesteps 100 and 500, adding an <code>xlabel</code> to the last one, and putting them together with <code>plot(h50, h100, h500; layout=(3, 1))</code> creates the plot in <a href="ch09.xhtml#ch9fig6" class="calibre10">Figure 9-6</a>.</p>
<div class="image1"><img alt="Image" id="ch9fig6" src="../images/ch09fig06.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-6: Results of an</em> <span class="codeitalic">Oceananigans</span> <em class="calibre11">simulation</em></p>
<p class="indent">The system evinces the regime called <em class="calibre11">turbulent convection</em>; it’s interesting to observe the emergence of large-scale order from randomness and its persistent coexistence with the turbulent flow.</p>
<p class="indent">In order to make an animation of the simulation, we need to generate plots at equally spaced time intervals and stitch them together into a video file. Our simulation used a constant timestep, so in this case, equal time intervals translates into equal numbers of timesteps. However, that won’t always be the case. <code>Oceananigans</code> has options for automatically adjusted timesteps, and we may perform a simulation in stages with differently sized Δ<em class="calibre11">t</em>. It’s convenient, therefore, to have a function that creates a plot given a <em class="calibre11">time</em>. Since a given time may not correspond to any particular stored field, but may fall between two consecutive data dumps, we’ll need a function that determines which stored field is closest to the time requested. The Julia program shown in <a href="ch09.xhtml#ch9lis7" class="calibre10">Listing 9-7</a> retrieves the simulation output and produces a movie of a specified duration.</p>
<span epub:type="pagebreak" id="page_293"/>
<pre class="calibre13">using Oceananigans, Reel, Plots

function heatmap_at_time(F, time, fmin, fmax, duration)
    ts = F.times
    time = time * ts[end]/duration
    i = indexin(minimum(abs.(ts .- time)), abs.(ts .- time))[1] <span class="ent">➊</span>
    xr = yr = zr = 1
    if F.grid.Nx &gt; 1
        xr = 1:F.grid.Nx
    end
    if F.grid.Ny &gt; 1
        yr = 1:F.grid.Ny
    end
    if F.grid.Nz &gt; 1
        zr = 1:F.grid.Nz
    end
    heatmap(interior(F[i], xr, yr, zr)'; aspect_ratio=1, yrange=(0, 1.5F.grid.Nz),
            clim=(fmin, fmax)) <span class="ent">➋</span>
end

uF = FieldTimeSeries("conv4.jld2", "u")
const fmin = 0.5minimum(uF) <span class="ent">➌</span>
const fmax = 0.5maximum(uF)
const duration = 30

function plotframe(t, dt)
    heatmap_at_time(uF, t, fmin, fmax, duration)
end

uMovie = roll(plotframe; fps=30, duration)

write("uMovie.mp4", uMovie)</pre>
<p class="list" id="ch9lis7"><em class="calibre11">Listing 9-7: Creating an animation of an Oceananigans simulation</em></p>
<p class="indent">The <code>heatmap_at_time()</code> function does what’s needed, creating a heatmap at the time closest to the time in its argument. In this function, <code>F</code> is a field retrieved with a call to <code>FieldTimeSeries()</code>, as in <a href="ch09.xhtml#ch9lis6" class="calibre10">Listing 9-6</a>. It makes use of the <code>times</code> property of these objects, which is an array holding all the times at which the field has been saved. The index <code>i</code> holds the dump corresponding to the time closest to the supplied <code>time</code> <span class="ent">➊</span>. When making an animation of a heatmap, we want to use the same mapping from values to colors in each frame, so our call to <code>heatmap()</code> uses the <code>clim</code> keyword <span class="ent">➋</span>.</p>
<p class="indent">With this function in place we can create an animation using the <code>Reel</code> package introduced in “Animations with Reel” on <a href="ch07.xhtml#ch07lev4" class="calibre10">page 206</a>. To work with that package, we need to define a function of time <code>t</code> and (an unused) <code>dt</code> that returns a plot corresponding to <code>t</code>: the <code>plotframe()</code> function. The three constants <span class="ent">➌</span> in the script set the palette limits based on the data and the desired <span epub:type="pagebreak" id="page_294"/>total duration of the animation. The palette limits are scaled so that more details are visible near the beginning of the run, but we can adjust it based on the features of interest.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">See the online supplement at</em> <a href="https://julia.lee-phillips.org" class="calibre10">https://julia.lee-phillips.org</a> <em class="calibre11">for the resulting animation, along with full-color versions of the figures.</em></p>
</div>
<p class="indent">The final call saves the animation as an MP4 file. Other options that will work with <code>Reel</code> are <code>gif</code> and <code>webm</code>. To create these file types, we merely need to use the appropriate file ending.</p>
<h3 class="h2" id="ch09lev4"><strong class="calibre2">Solving Differential Equations with DifferentialEquations</strong></h3>
<p class="noindent">Since the 18th century, differential equations have been the language of physical science and engineering, and of the quantitative aspects of other sciences as well. Julia’s <code>DifferentialEquations</code> package is a massive, state-of-the-art facility for solving many types of differential equations using a multitude of methods. It incorporates recent research on the use of machine learning to apply the best line of attack for solving a given equation.</p>
<p class="indent">This section introduces the use of <code>DifferentialEquations</code> by solving an example problem. Interested readers can delve into its detailed documentation for more information (see “Further Reading” on <a href="ch09.xhtml#fur9" class="calibre10">page 304</a>).</p>
<h4 class="h3" id="ch09lev1sec14"><strong class="calibre2"><em class="calibre4">Defining the Physics Problem and Its Differential Equation</em></strong></h4>
<p class="noindent">As an example, let’s investigate the pendulum. <a href="ch09.xhtml#ch9fig7" class="calibre10">Figure 9-7</a> diagrams the problem and defines the string length (<em class="calibre11">L</em>) and the angle (<em class="calibre11">θ</em>).</p>
<div class="image1"><img alt="Image" id="ch9fig7" src="../images/ch09fig07.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-7: The pendulum system</em></p>
<p class="indent">We measure <em class="calibre11">θ</em> counterclockwise from the vertical reference line, which is dotted in the diagram, and the gravitational acceleration points down.</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="notep"><em class="calibre11">The</em> <span class="codeitalic1">Luxor</span> <em class="calibre11">program that produced the diagram is available in the code section of the Physics chapter on the online supplement at</em> <a href="https://julia.lee-phillips.org" class="calibre10">https://julia.lee-phillips.org</a><em class="calibre11">.</em></p>
</div>
<p class="indent"><span epub:type="pagebreak" id="page_295"/>A straightforward analysis of the forces on the pendulum bob (the black circle in the diagram) and Newton’s Second Law leads to the differential equation</p>
<div class="image"><img alt="Image" src="../images/295math.jpg" class="calibre6"/></div>
<p class="noindent">which is derived in any introductory general physics text. Here <em class="calibre11">t</em> is time and <em class="calibre11">g</em> is the gravitational acceleration. The usual next step is to confine the problem to small angles (≲ 5<sup class="calibre23">°</sup>), where sin(<em class="calibre11">θ</em>) ≈ <em class="calibre11">θ</em>, and solve the resulting differential equation for simple harmonic motion. We’re going to solve the “exact” pendulum equation numerically, using the <code>DifferentialEquations</code> package. We’ll be able to examine the solution for any initial <em class="calibre11">θ</em>, up to π radians.</p>
<p class="indent">The package works with systems of first-order equations, which means differential equations limited to first derivatives of the unknown function. To handle the pendulum equation, therefore, we first need to cast it into the form of two coupled first-order equations. This first step is also part of many analytic solution methods. We can proceed easily by defining a new variable:</p>
<div class="image"><img alt="Image" src="../images/295math1.jpg" class="calibre6"/></div>
<p class="noindent">Now we’re solving for two functions of time, the angle <em class="calibre11">θ</em>(<em class="calibre11">t</em>) and the angular velocity <em class="calibre11">ω</em>(<em class="calibre11">t</em>).</p>
<h4 class="h3" id="ch09lev1sec15"><strong class="calibre2"><em class="calibre4">Setting Up the Problem</em></strong></h4>
<p class="noindent">The first step in translating the mathematical problem into a form that <code>DifferentialEquations</code> can digest is to define a Julia function of four positional arguments:</p>
<div class="bqparan">
<p class="noindentin"><span class="codestrong1">du</span>  An array for the derivatives of the solutions</p>
<p class="noindentin"><span class="codestrong1">u</span>   An array for the solution functions</p>
<p class="noindentin"><span class="codestrong1">p</span>   An array of parameters</p>
<p class="noindentin"><span class="codestrong1">t</span>   The time</p>
</div>
<p class="indent"><a href="ch09.xhtml#ch9lis8" class="calibre10">Listing 9-8</a> is the version for the pendulum problem.</p>
<pre class="calibre13">function pendulum!(du, u, p, t)
    L, g = p
    θ, ω = u
    du[1] = ω
    du[2] = -g/L * sin(θ)
end</pre>
<p class="list" id="ch9lis8"><em class="calibre11">Listing 9-8: The Julia version of the pendulum equation</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_296"/>This is a mutating function, as indicated by the exclamation point, because as the calculation progresses, the solution engine mutates the <code>u</code> and <code>du</code> arrays to hold the results. Here <code>L</code> and <code>g</code> are set through destructuring the array <code>p</code>, and θ and ω are read from the array <code>u</code>. The solver from <code>DifferentialEquations</code> will repeatedly call <code>pendulum!()</code> as it builds up the solution, passing in <code>p</code>, <code>t</code>, and the developing solution arrays themselves.</p>
<h4 class="h3" id="ch09lev1sec16"><strong class="calibre2"><em class="calibre4">Solving the Equation System</em></strong></h4>
<p class="noindent">To calculate the solution, we first define the computational problem and then pass that problem to the <code>solve()</code> function. The components of the computational problem are the parameter array, the initial conditions, the time span over which we want the solution, and the function that defines the differential equations to be solved, in this example <code>pendulum!()</code>. Other options include such things as the numerical method to be employed, but in this simple example we’ll leave those options unspecified. The package generally does an excellent job of choosing the solution method best suited to the nature of the equations we present to it. <a href="ch09.xhtml#ch9lis9" class="calibre10">Listing 9-9</a> shows the problem set up and initiated.</p>
<pre class="calibre13">using DifferentialEquations

p = [1.0, 9.8]
 #    L    g   &lt;- Parameters

u0 = [deg2rad(5), 0]
 #    θ    ω   &lt;- Initial conditions

tspan = (0, 20)

prob = ODEProblem(pendulum!, u0, tspan, p)
sol5d = solve(prob)</pre>
<p class="list" id="ch9lis9"><em class="calibre11">Listing 9-9: Solving differential equations using</em> <span class="codeitalic">DifferentialEquations</span></p>
<p class="indent">The only two functions in this section from the <code>DifferentialEquations</code> package are <code>ODEProblem()</code> and <code>solve()</code>. <code>ODEProblem()</code> takes four positional arguments: the function defining the equation system, an array of initial conditions, the time span, and the parameter array. We defined the function in <a href="ch09.xhtml#ch9lis8" class="calibre10">Listing 9-8</a> and we define the other three arguments here. Allowing the solver to pass the parameters as arguments makes it convenient to generate families of solutions with a range of parameters.</p>
<p class="indent">The result returned by <code>ODEProblem()</code> contains the complete solutions of all functions (in this example, two) bundled into a data type defined in the package. This data type is designed to make it easy to examine and plot the solutions, and it contains, in addition to the computed functions, information about the problem and the calculation.</p>
<h4 class="h3" id="ch09lev1sec17"><span epub:type="pagebreak" id="page_297" class="calibre1"/><strong class="calibre2"><em class="calibre4">Examining the Solutions</em></strong></h4>
<p class="noindent">For small angles, the analytic solution to our pendulum problem is</p>
<div class="image"><img alt="Image" src="../images/297math.jpg" class="calibre6"/></div>
<p class="noindent">where <em class="calibre11">θ</em><sub class="calibre24">0</sub> is the initial angle. The initial conditions in <a href="ch09.xhtml#ch9lis9" class="calibre10">Listing 9-9</a> have the pendulum at rest with a starting angle of 5°, so the small angle approximation should be valid.</p>
<p class="indent">Since we know the analytic solution, we can check the numerical result against it. <a href="ch09.xhtml#ch9lis10" class="calibre10">Listing 9-10</a> shows how we can plot one against the other.</p>
<pre class="calibre13">using Plots

plot(sol5d; idxs=1, lw=4, lc=:lightgrey, label="Numeric",
     legend=:outerright, title="Pendulum at θ<sub class="calibre25">0</sub> = 5°")

L, g = p

plot!(t -&gt; u0[1]*cos(sqrt(g/L)*t); xrange=(0, 20),
      ls=:dash, lc=:black, label="Analytic")</pre>
<p class="list" id="ch9lis10"><em class="calibre11">Listing 9-10: Solving for the small angle case</em></p>
<p class="indent">The first <code>plot()</code> call uses only one data argument, the solution itself, assigned to <code>sol5d</code> in <a href="ch09.xhtml#ch9lis9" class="calibre10">Listing 9-9</a>. This is neither an array nor a function, yet <code>plot()</code> seems to know how to display it. The first keyword argument, <code>idxs</code>, requests that (in this case) the first function, <em class="calibre11">θ</em>, is plotted. <code>idxs</code> does not appear in the documentation for the <code>Plots</code> package, and in fact is not defined in that package. Thus, it has no effect unless we first import <code>DifferentialEquations</code>.</p>
<p class="indent">The plot, shown in <a href="ch09.xhtml#ch9fig8" class="calibre10">Figure 9-8</a>, gives us confidence that we’ve set up the problem correctly and that the numerical solution methods are working.</p>
<div class="image"><img alt="Image" id="ch9fig8" src="../images/ch09fig08.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-8: Checking the small angle solution of the pendulum equation</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_298"/>Plotting the solution as we did here does not simply plot the solution arrays. It also interpolates between calculated values in order to generate a smooth plot. In this case, the solution contains only 83 points, which, if plotted directly, would make a coarse graph.</p>
<p class="indent">Although the solution objects are not arrays, the package defines methods for indexing that make it convenient to extract the data. If we do want access to the uninterpolated solution data, we can get it by indexing. Here, <code>sol5d[1, :]</code> returns a <code>Vector</code> of the 83 points for the first variable, <em class="calibre11">θ</em>, and <code>sol5d[2, :]</code> for the second, <em class="calibre11">ω</em>. To get the times at which these values are defined, we use a property: <code>sol5d.t</code>.</p>
<p class="indent">Using the solution objects as functions returns the result interpolated to the time passed as an argument. (We’re using time in this section, but in other problems the independent variable may be something else.) The <code>sol5d(1.3)</code> function call returns a <code>Vector</code> of two elements, one for each variable, interpolated to the time 1.3. These functions accept ranges and arrays as well, so <code>sol5d(0:0.1:1)</code> returns the interpolated solution data at 11 times from 0 to 1. To extract just the angle variable at these times, we can call <code>sol5d(0:0.1:1)[1, :]</code>. Controlling the density of the interpolation by using the functional form of the solution objects can be helpful when making, for example, scatterplots, where we need to control the density of plotted points.</p>
<p class="indent">How does the solution depend on the initial angle? Redefining <code>u0</code> to try two larger initial angles, and proceeding as in <a href="ch09.xhtml#ch9lis10" class="calibre10">Listing 9-10</a> to generate two new solutions, we get the results shown in <a href="ch09.xhtml#ch9fig9" class="calibre10">Figure 9-9</a>.</p>
<div class="image"><img alt="Image" id="ch9fig9" src="../images/ch09fig09.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-9: The pendulum with larger initial angles</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_299"/>The 90° solution, with the pendulum string initially horizontal, appears approximately sinusoidal, but with the frequency around 25 percent lower than the small angle case. When the initial angle is 175°, the period is nearly three times the small angle period, and the solution is clearly far from sinusoidal. In generating <a href="ch09.xhtml#ch9fig9" class="calibre10">Figure 9-9</a>, we limit the range of the independent variable by passing another <code>DifferentialEquations</code>-defined keyword to <code>plot()</code>: <code>tspan=(0, 10)</code>.</p>
<h4 class="h3" id="ch09lev1sec18"><strong class="calibre2"><em class="calibre4">Defining Time-Dependent Parameters</em></strong></h4>
<p class="noindent">By replacing one or more of the constant parameters in the <code>p</code> array with functions of time, we can study the system’s response to time-dependent parameters. In this way we can include inhomogeneous terms in the differential equations, forcing functions, and time-varying parameters in general.</p>
<p class="indent">Let’s find out what happens if we pull up on the string steadily as the pendulum oscillates. We’ll start at 45° and calculate the solution over 10 seconds, replacing the constant <code>L</code> by a linearly decreasing function of time:</p>
<pre class="calibre13">tspan = (0, 10)
u0 = [π/4, 0]
Lt(t) = 1 - 0.999t/10</pre>
<p class="indent">We need to create a slightly different version of our <code>pendulum()</code> function, shown in <a href="ch09.xhtml#ch9lis11" class="calibre10">Listing 9-11</a>, that can use the time-dependent string length.</p>
<pre class="calibre13">function pendulum2!(du, u, p, t)
    L, g = p
    θ, ω = u
    du[1] = ω
 <span class="ent">➊</span> du[2] = -g/L(t) * sin(θ)
end</pre>
<p class="list" id="ch9lis11"><em class="calibre11">Listing 9-11: The pendulum function with a time-dependent</em> <span class="codeitalic">L</span></p>
<p class="indent">The only change we made to the previous function is replacing <code>L</code> with <code>L(t)</code> <span class="ent">➊</span>. We proceed just as before. The <code>ODEProblem()</code> function needs a new parameter array, shown in <a href="ch09.xhtml#ch9lis12" class="calibre10">Listing 9-12</a>, to pass in to <code>pendulum2()</code>.</p>
<pre class="calibre13">p = [Lt, 9.8]
prob = ODEProblem(pendulum2!, u0, tspan, p)
solLt = solve(prob)</pre>
<p class="list" id="ch9lis12"><em class="calibre11">Listing 9-12: Getting the numerical solution with a time-varying</em> <span class="codeitalic">L</span></p>
<p class="indent">The ease of generalizing the problem to include a time-varying parameter clarifies the advantages of the parameter-passing approach in <code>Differential</code> <code>Equations</code>. The result, in <a href="ch09.xhtml#ch9fig10" class="calibre10">Figure 9-10</a>, shows a steadily decreasing period and amplitude with an increasing angular velocity (<em class="calibre11">ω</em>).</p>
<div class="image"><img alt="Image" id="ch9fig10" src="../images/ch09fig10.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-10: Pulling up the string on the pendulum</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_300"/>We create <a href="ch09.xhtml#ch9fig10" class="calibre10">Figure 9-10</a> with the following calls:</p>
<pre class="calibre13">plot(solLt; idxs=1, label="θ", legend=:topleft, ylabel="θ",
  <span class="ent">➊</span> right_margin=13mm)
plot!(twinx(), solLt; idxs=2, label="ω", legend=:topright,
      ylabel="ω", ls=:dot)</pre>
<p class="indent">In the call to <code>plot!()</code>, the first argument, <code>twinx()</code>, creates a subplot overlay that shares the horizontal axis with the first plot and draws a new vertical axis; we use it so the two curves don’t have to share the same scale. We need some extra room on the right <span class="ent">➊</span> for the labels on the second vertical axis. This margin setting requires the import of <code>Plots.PlotMeasures</code>, as explained in “Working with Plot Settings” on <a href="ch04.xhtml#ch04lev7" class="calibre10">page 101</a>.</p>
<h4 class="h3" id="ch09lev1sec19"><strong class="calibre2"><em class="calibre4">Parametric Instability</em></strong></h4>
<p class="noindent">A child “pumping” a swing in the playground to get it moving is exploiting a <em class="calibre11">parametric instability</em>. The driver of this instability is the periodic change in the effective length of the pendulum string. The results of linear theory (the small angle version of the differential equation that we’re attacking in this section) tell us that a resonance occurs when the forcing frequency is twice the natural frequency of the pendulum, which, using our <em class="calibre11">L</em> = 1, is <img alt="Image" src="../images/300math.jpg" class="calibre6"/>. If the string length is perturbed sinusoidally at this frequency, the amplitude of small oscillations will increase exponentially.</p>
<p class="indent">Since we know how to insert any time-dependent function <em class="calibre11">L</em>(<em class="calibre11">t</em>) into the numerical solution, we can investigate the response of the pendulum to parametric excitation beyond the small angle approximation. We’ll start <span epub:type="pagebreak" id="page_301"/>with a small initial angle, follow the evolution for a longer span, and define a new function of time for the string length:</p>
<pre class="calibre13">const g = 9.8
tspan = (0, 400)
u0 = [π/32, 0]
Lt(t) =  1.0 + 0.1*cos(2*sqrt(g)*t)</pre>
<p class="indent"><code>Lt(t)</code> will perturb the nominal length of 1 meter by 10 percent at the frequency of parametric resonance.</p>
<p class="indent">Our work proceeds exactly as before, with one adjustment. We use <code>pendulum2()</code>, defined in <a href="ch09.xhtml#ch9lis11" class="calibre10">Listing 9-11</a>, and set up the problem as in <a href="ch09.xhtml#ch9lis12" class="calibre10">Listing 9-12</a>. The adjustment is that we need to supply a keyword argument to the solving function:</p>
<pre class="calibre13">solLt = solve(prob; reltol=1e-5)</pre>
<p class="indent">The <code>reltol</code> parameter adjusts the adaptive timestepping as needed to limit the local error to the value that we supply. Its default of 0.001 led to a solution that seemed suspicious, as it was not quite periodic. I generated solutions with <code>reltol</code> = 1e–4, 1e–5, and 1e–6. The 1e–4 solution looked reasonable, but the 1e–5 solution was slightly different. As the solution with <code>reltol</code> = 1e–6 looked identical to the one at 1e–5, they’re probably accurate. <a href="ch09.xhtml#ch9fig11" class="calibre10">Figure 9-11</a> shows the resulting graph of <em class="calibre11">θ</em> versus time.</p>
<div class="image"><img alt="Image" id="ch9fig11" src="../images/ch09fig11.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-11: Parametric instability of the finite-angle pendulum</em></p>
<p class="indent">Initially, the amplitude increases exponentially, as predicted by the linear theory. But we know from our previous solutions that the frequency of the pendulum decreases with amplitude; therefore, it moves continuously out of <span epub:type="pagebreak" id="page_302"/>resonance with the forcing function, and the amplitude decreases back to close to its initial value. At that point it’s closer to resonance, and the amplitude again grows exponentially. As the solution shows, the process repeats.</p>
<h4 class="h3" id="ch09lev1sec20"><strong class="calibre2"><em class="calibre4">Combining DifferentialEquations with Measurements</em></strong></h4>
<p class="noindent">Suppose we want to verify the predictions of our pendulum solutions with an experiment. There will be some error inherent in the setting of the initial angle. If we estimate that uncertainty to be one degree, we might think to state the initial conditions this way (see “Error Propagation with Measurements” on <a href="ch09.xhtml#ch09lev2" class="calibre10">page 280</a>):</p>
<pre class="calibre13">using Measurements

u0 = [π/2 ± deg2rad(1), 0]</pre>
<p class="noindent">The function <code>deg2rad()</code> converts from degrees to radians.</p>
<p class="indent">We can proceed exactly as before, repeating the procedure shown in <a href="ch09.xhtml#ch9lis8" class="calibre10">Listings 9-8</a> and <a href="ch09.xhtml#ch9lis9" class="calibre10">9-9</a>. A plot of the solution for <em class="calibre11">θ</em>(<em class="calibre11">t</em>) now looks like <a href="ch09.xhtml#ch9fig12" class="calibre10">Figure 9-12</a>.</p>
<div class="image"><img alt="Image" id="ch9fig12" src="../images/ch09fig12.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 9-12: Combining</em> <span class="codeitalic">DifferentialEquations</span> <em class="calibre11">with</em> <span class="codeitalic">Measurements</span></p>
<p class="indent">Although we don’t tell the <code>plot()</code> function anything about drawing error bars, they appear in the plot. The plot shows how the error in the angular position grows, on average, over time. The error doesn’t grow monotonically, however. It decreases when the exact solution and those at the limits of the error bound happen to be in phase.</p>
<p class="indent"><span epub:type="pagebreak" id="page_303"/>We generate the solution and plot it in <a href="ch09.xhtml#ch9fig12" class="calibre10">Figure 9-12</a> as follows:</p>
<pre class="calibre13">prob = ODEProblem(pendulum!, u0, tspan, p)

solM = solve(prob)

plot(solM(0:0.1:5)[1, :]; legend=false, lw=2, ylabel="θ", xlabel="t")</pre>
<p class="indent">Since <code>DifferentialEquations</code> places an error on every point of the solution, including the points interpolated when creating a plot, we have to use the technique described in “Examining the Solutions” on <a href="ch09.xhtml#ch09lev1sec17" class="calibre10">page 297</a> to limit the number of points plotted; otherwise, the plot becomes too crowded with error bars and is impossible to interpret.</p>
<h3 class="h2" id="ch09lev5"><strong class="calibre2">Conclusion</strong></h3>
<p class="noindent">Although we delved into several physics packages at some length in this chapter, we really only scratched their surfaces. I hope, however, that the introductions here are sufficient to help you assess whether any of the packages explored in this chapter might be a good choice for your projects and to show you how to get started.</p>
<p class="indent">Another purpose of this chapter is to serve as an introduction to a superpower of Julia and the Julia ecosystem. In several examples we were able to combine the abilities of two or three packages without making any particular arrangements to do so. We made plots and typeset expressions that contained units, and saw that they were handled sensibly. We handed the output of a differential equation solver to a plotting function from a different package, and it extracted the relevant data and plotted it. We solved differential equations with error estimates in their initial conditions, and the error was propagated through the solution correctly. We plotted <em class="calibre11">this</em> result, and, as if by magic, the solution displayed error bars.</p>
<p class="indent">We wrote scripts and programs that combined the abilities of five packages in various combinations, giving them capabilities neither envisioned nor planned by their authors. Most of these packages were written without any knowledge of the others that we combined them with. The authors of these packages wrote their code in a generic way that allows Julia’s type system and its method of multiple dispatch to enable its functions to work with data types defined in other packages.</p>
<p class="indent">Julia initially attracted attention as a language that was as easy to pick up and be productive in as a high-level interpreted language, but one that was fast enough for the most demanding scientific work: “as easy as Python and as fast as Fortran.” The second reason for Julia’s increasing adoption in the sciences is its ability to combine the abilities of disparate packages with no additional work on the part of the application programmer. Julia creators and package authors refer to this property as the <em class="calibre11">composability</em> of packages, in analogy with the composition of functions.</p>
<div class="box">
<p class="boxtitle-d" id="fur9"><span epub:type="pagebreak" id="page_304" class="calibre1"/><strong class="calibre2">FURTHER READING</strong></p>
<ul class="calibre12">
<li class="noindent1">The GitHub community  “Julia’s Physics Ecosystem”  (<a href="https://juliaphysics.github.io/latest/ecosystem/" class="calibre10"><em class="calibre11">https://juliaphysics.github.io/latest/ecosystem/</em></a>) maintains a convenient list of packages related to all areas of physics,  and includes related packages for mathematics and plotting.</li>
<li class="noindent1">The <code>Unitful</code> package is available at <a href="https://github.com/PainterQubits/Unitful.jl" class="calibre10"><em class="calibre11">https://github.com/PainterQubits/Unitful.jl</em></a>.</li>
<li class="noindent1">See  <a href="https://www.simscale.com/blog/2017/12/nasa-mars-climate-orbiter-metric/" class="calibre10"><em class="calibre11">https://www.simscale.com/blog/2017/12/nasa-mars-climate-orbiter-metric/</em></a> for details on how a mixup in units destroyed the Mars Climate Orbiter.</li>
<li class="noindent1">The documentation for  <code>UnitfulLatexify</code> is at  <a href="https://gustaphe.github.io/UnitfulLatexify.jl/dev/" class="calibre10"><em class="calibre11">https://gustaphe.github.io/UnitfulLatexify.jl/dev/</em></a>.</li>
<li class="noindent1">The  <code>Measurements</code> package resides at  <a href="https://github.com/JuliaPhysics/Measurements.jl" class="calibre10"><em class="calibre11">https://github.com/JuliaPhysics/Measurements.jl</em></a>.</li>
<li class="noindent1">To get started with  <code>Oceananigans</code>,  see  <a href="https://clima.github.io/OceananigansDocumentation/stable/quick_start/" class="calibre10"><em class="calibre11">https://clima.github.io/OceananigansDocumentation/stable/quick_start/</em></a>.</li>
<li class="noindent1">The  <code>DifferentialEquations.jl</code> documentation is available at  <a href="https://diffeq.sciml.ai/stable/" class="calibre10"><em class="calibre11">https://diffeq.sciml.ai/stable/</em></a>.</li>
<li class="noindent1">Animations,  color images,  and supplementary code for this chapter are available at  <a href="https://julia.lee-phillips.org" class="calibre10"><em class="calibre11">https://julia.lee-phillips.org</em></a>.</li>
<li class="noindent1">You can find simple examples of the use of <code>DifferentialEquations.jl</code> at  <a href="https://lwn.net/Articles/835930/" class="calibre10"><em class="calibre11">https://lwn.net/Articles/835930/</em></a> and  <a href="https://lwn.net/Articles/834571/" class="calibre10"><em class="calibre11">https://lwn.net/Articles/834571/</em></a>.</li>
<li class="noindent1">The parametric instability of a pendulum is demonstrated in the video at  <a href="https://www.youtube.com/watch?v=dGE_LQXy6c0" class="calibre10"><em class="calibre11">https://www.youtube.com/watch?v=dGE_LQXy6c0</em></a>.</li>
<li class="noindent1">The theory of parametric resonance for the general harmonic oscillator is treated at  <a href="https://www.lehman.edu/faculty/dgaranin/Mechanics/Parametric_resonance.pdf" class="calibre10"><em class="calibre11">https://www.lehman.edu/faculty/dgaranin/Mechanics/Parametric_resonance.pdf</em></a>.</li>
</ul>
</div>
</body></html>