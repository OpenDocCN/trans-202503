- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 9 LABELS AND NONSEQUENTIAL EXECUTION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In politics, labels have gotten a bad reputation, but at the most basic level,
    a *label* is an identifier that concisely defines a product or an object in as
    few words as possible. Commerce would grind to a halt if we didn’t have labels;
    grocery stores would contain shelves and shelves of mysterious canned products.
    What’s for dinner? It might be beans or pumpkin pie mix; we won’t know until we
    open it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without labels Batch wouldn’t be thrown into quite this level of disarray,
    but an important tool for creating more complex bat files would be missing from
    your coder’s toolbox. Up until now every bat file, snippet, and listing in this
    book has executed sequentially. The interpreter interprets each line, one by one,
    executing the first command first, followed by the second. This continues until
    one of two things happens: either the final command of the bat file is interpreted,
    or a syntax error crashes the bat file. Labels allow you to execute Batch commands
    in a nonsequential manner. In this chapter, I’ll introduce the concept of branching
    forward and backward in the code, repeating some section of code based on a data
    condition and even creating a couple commands not intrinsic to Batch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Labels will also afford me a great opportunity to discuss a topic that’s exceedingly
    important: coding conventions, in particular, indentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Labels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *label* in Batch is what you might expect it to be, a tag defining a block
    of code. More specifically, a certain spot or location in the bat file is *labeled*.
    A label isn’t a command, and although it’s never executed, you’ll soon see that
    it’s critical to the execution flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Labels can contain letters, numbers, and some special characters, and, most
    important, they must start with a colon. Oddly, the name of the label can contain
    additional colons, but never in the second position. For example, here’s some
    code being defined or labeled for exactly what it does, checking the state of
    a specific variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, this bit of code handles a very rudimentary abort process and is
    labeled as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: I’ll discuss the exit command in [Chapter 10](chapter10.xhtml). For now, it’s
    simply being used to get out of the bat file.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a label is straightforward, but before getting into the impactfulness
    of labels and how to use them, allow me a digression, maybe even a rant, on coding
    conventions.
  prefs: []
  type: TYPE_NORMAL
- en: Indentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many Batch coders refuse to indent their code. I’m not sure why, as every other
    language I'm familiar with has some sort of a convention, if not a hard requirement,
    on indentation. My best guess is that at its core is a fundamental disrespect
    of the language, considering Batch a utilitarian nuisance that must be dispatched
    with as quickly as possible with no regard for readability, much less aesthetics.
    For your Batch code to garner the respect it merits, I recommend starting all
    commands with an indentation of two spaces. Indent all logic inside the code blocks
    of if commands (and similar structures yet to be discussed) another three spaces,
    with nested structures indented even more.
  prefs: []
  type: TYPE_NORMAL
- en: This topic might seem like a non sequitur in a chapter about labels, but in
    reality, it’s the ideal location. Labels should stand out a bit, or even more
    than a bit. A well-formatted document of any kind has parts, chapters, sections,
    and/or subsections, where each often has some sort of a header or cue—or dare
    I say *label*—that visually stands out from the rest of the text with a different
    font, font size, emboldening, underlining, colorization, or a combination of some
    or all of the above. These options are unavailable when writing a bat file. Our
    arsenal for the task has been reduced to one significant item, indentation, with
    a nod to capitalization and whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the first character of a label is always a colon, I always place that
    colon in the second byte of the line, reducing my typical indentation to one character.
    Therefore, when anyone, including myself, views a bat file that I’ve written,
    all the labels stand out. I reserve the first character of a line for the start
    of a rem command. For instance, here’s a rudimentary remark, label, and two simple
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The uppercase character after the colon in the label also adds to its prominence.
  prefs: []
  type: TYPE_NORMAL
- en: I hope I’m not coming across as the Stalin of Batch coding conventions. This
    is just one coder’s opinion, and other well-thought-out conventions exist that
    are different from mine. What’s important is that the code should be easy to read.
    There are many ways to accomplish this, but a complete lack of indenting most
    certainly fails the test, even if this topic brings out my autocratic side.
  prefs: []
  type: TYPE_NORMAL
- en: The goto Command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have a label defining a snippet of code, what good is it? Some
    coders actually use labels as makeshift remarks (which is fine, I guess), but
    the true function of a label is to direct the process flow to the code under the
    label. This is where the goto command comes into play, and it does what it sounds
    like it would do. It instructs the interpreter to skip to (or go to) a location
    in the code defined by a label. Consider these two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The goto commands are sending control to the :Abort and :DoSomething labels
    defined previously in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Well, that’s not entirely true; the first command sends the execution to the
    abort routine, and the second goto command never executes. In a bat file, a label
    itself can come before or after the goto command that branches to it, but what’s
    important to understand is that the execution never returns to the command immediately
    after the goto command. Once the goto is executed, we are totally at the mercy
    of the code under the label.
  prefs: []
  type: TYPE_NORMAL
- en: 'To go to a label defined as :Abort, you can also do so with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Two things are going on here. First, the colon has been dropped from the label
    name in the goto command. I suspect that this is an early bug that Microsoft won’t
    fix to maintain backward compatibility. Second, the actual label has only the
    A capitalized, but the goto command shows the entire label name capitalized.
  prefs: []
  type: TYPE_NORMAL
- en: This example demonstrates that the label name is case-insensitive, as Batch
    is in general, and that the colon is optional in the goto command. While the interpreter
    makes this permissible, I see no reason for the two label names to differ in any
    way as it can only breed confusion. Consistency is key.
  prefs: []
  type: TYPE_NORMAL
- en: The call command introduced in [Chapter 8](chapter8.xhtml) is also used in conjunction
    with labels, but its behavior is quite distinct from the goto command. I’ll come
    back to the call command and those differences in [Chapter 10](chapter10.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Branching Forward
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The goto command sends control or the process flow in one of two directions;
    one is to branch forward over code. Three echo commands write text to the console
    in this example, but only the first and third are executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It’s not hard to imagine more complex code using this technique. A goto command
    might be done conditionally based on the results of an if command, and instead
    of branching over a single echo command, it might be skipping a far larger section
    of code. For instance, you can skip the execution of one or more programs if a
    certain file is present or not present, or if a failure is detected, you can jump
    to the code that will abort the bat file’s execution, skipping everything else.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goto can also be a tool to break out of a loop. Unfortunately, I haven’t
    discussed loops yet; in [Part II](part2.xhtml), I’ll discuss the for command and
    loops extensively. But for now, to understand this logic you need to know only
    that this loop will execute once for each name listed in the listOfNames variable,
    regardless of how many names it contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The if command is searching for a particular name. If and when it’s found, the
    goto command breaks out of the loop, jumping down to the label on the last line.
  prefs: []
  type: TYPE_NORMAL
- en: This is important for two reasons. One, it’s efficient—if the name is found
    near the beginning of the list, CPU cycles aren’t wasted pointlessly searching
    the rest of the list. More important, the echo command is never executed if the
    name is found. Notice that the logic not only breaks out of the loop prematurely
    but also branches over the writing of the message that indicates that the name
    wasn’t found.
  prefs: []
  type: TYPE_NORMAL
- en: Branching Backward
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The examples in the previous section use a goto command to skip forward in the
    code. Next, I’ll look at examples of a goto command going in the reverse direction.
    But first, I’ve already discussed how we can build certain components of more
    modern languages that aren’t explicitly part of Batch (think booleans and floats),
    but many others are yet to come. Batch doesn’t have a while command, nor does
    it support a do...while command. In other languages, a while command executes
    a block of code zero to multiple times until a condition is met. A do...while
    command is very similar; the only difference is that the code block will execute
    once before the condition is evaluated. Let’s create both of these in Batch.
  prefs: []
  type: TYPE_NORMAL
- en: The while “Command”
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: To demonstrate the usefulness of a Batch while command, we’ll write some code
    that’ll strip all leading zeros off a value, a necessity for any coder not wanting
    to perform octal arithmetic accidentally (long story on that in [Chapter 6](chapter6.xhtml)
    if you missed it). The while command might execute a bit of code as long as—or
    *while*—the first byte is 0, and that code will do nothing more than strip off
    one leading byte.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code performs the task perfectly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The interpreter essentially ignores the label when it’s first encountered and
    interrogates the first character of nbr. If it’s zero, the code next verifies
    that there’s a second byte—that is, that the 0 is in fact leading something. If
    both are true, the code block is entered, where it strips off the leading 0 before
    the goto command sends control back to the label just prior to the if command.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s step through the code with three different numbers to really get a feel
    for the logic. If the variable has no leading 0, the code block is never executed.
    If it has one leading 0, the code block is executed once. Then the leading byte
    is checked again, and since it’s no longer 0, the execution flow proceeds to whatever
    comes next. If nbr has 17 leading 0s, the code block removing a 0 executes 17
    times, and after the leading byte is checked an 18th time, the execution moves
    on.
  prefs: []
  type: TYPE_NORMAL
- en: The word *while* doesn’t appear in that listing, but it does everything a proper
    while command would. As far as I’m concerned, it’s a Batch while command.
  prefs: []
  type: TYPE_NORMAL
- en: NOTE
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The previous snippet is the first example I’ve shown of one if command nested
    inside another, but you’ll see many more nested commands in the chapters ahead.
    As another note on coding conventions, I’ve stacked the two trailing close parentheses
    on a single line in that listing. This makes the code more compact, especially
    when nesting multiple levels deep, and it keeps the focus on the interesting logic,
    but I concede that I’m in the minority. Most Batch coders line up each close parenthesis
    with its respective if command. This requires more lines of code, but the following
    is functionally equivalent to my previous code:*'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*Do what feels right to you and do it consistently. Also, notice that the label
    name contains a numeric value. As mentioned previously, we aren’t restricted to
    letters of the alphabet. And by the way, doesn’t that indentation look nice?*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The do...while “Command”
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: A Batch do...while command looks quite similar; the only difference is that
    the main logic must be executed at least once. In languages with a built-in do...while
    command, the conditional clause usually comes at the tail end of the structure
    (understandably after the main logic is executed once), and Batch is no different.
    Compared to the while command, the main logic is moved from inside the if command
    code block to just after the label and prior to the if command.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate, let’s take an example where the textStr variable is to be right-padded
    with at least one space to build it out to a minimum of 25 bytes in length. If
    the original string is less than 25 bytes long, the result will be 25 bytes; if
    it’s originally at least 25 bytes long, a single space will be appended to the
    result. (The string might be part of some concatenated text to be displayed on
    the console, where the space-padding will line up the columns. But of course,
    we’ll want a space between it and whatever comes next, even if it requires an
    extra byte.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that the right padding must be done at least once lends itself to
    the do...while command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As with the while command, the label precedes the bulk of the code, but the
    core logic immediately follows it, which in this case is a single set command
    padding the string with one space. Then the 25th byte is examined. (Remember,
    it’s zero-offset.) If it doesn’t exist, the goto command sends the execution back
    to the label so that another space can be appended to the string. This repeats
    until that 25th byte is populated, ensuring that the string is at least 25 bytes
    long and also that at least one space has been added regardless of the length.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 26](chapter26.xhtml), I’ll detail how to perform automatic restarts
    of a failed process that might work if tried again with little more than a label
    and a goto command—also known as the do...while command.
  prefs: []
  type: TYPE_NORMAL
- en: The :eof Label
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One special label not created by the coder but intrinsic to all bat files is
    :eof, which stands for *end of file*. When the following goto :eof command executes
    in the main logic of a called bat file, control is returned to the calling bat
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Executing the same command in the high-level bat file will cease the process
    entirely even though no label defined as :eof exists in the bat file.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re of the contrarian nature and decide to define your own :eof label,
    the interpreter will simply ignore it as if it were a nonsensical remark. In [Chapter
    10](chapter10.xhtml), I’ll explore this unique label further, in particular, how
    the interpreter handles the goto :eof command when inside a callable routine.
  prefs: []
  type: TYPE_NORMAL
- en: Variable Labels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Working in a language that doesn’t have a compiler has some definite downsides,
    but I’ve already shown you some silver linings (delayed expansion, for example).
    One more is the ability to define the label name in a goto command at the time
    of execution, although the label itself must be hardcoded. To set that up, envision
    a different label for each month of the year. The first three are shown here without
    their respective month-centric code beneath them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, the following command will send the execution to one particular
    label in the previous snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'But that’s old news by now. More interesting, if the variable month is set
    to the value February, the following command will call the same label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The argument to this goto command is the concatenation of the hardcoded :Month
    and the value of the month variable. After the variable is resolved, the command
    directs the execution to the label :MonthFebruary. The same goes for the other
    valid months, meaning that the same line of code also goes to :MonthMarch if month
    is set to the value of March.
  prefs: []
  type: TYPE_NORMAL
- en: 'But that does raise the question of what happens when the resulting label name
    doesn’t exist in the bat file, for instance, if month is set to Erele (February
    in the Yoruba language). The interpreter writes the following message to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Unfortunately, you’ll never see this message because the process will immediately
    crash.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 10](chapter10.xhtml), you’ll see that Batch handles a bad label
    name better when used with a call command, but if you use this technique with
    a goto command, ensure that the argument resolves to a valid label.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I introduced the concept of labels and how to navigate to them
    via the goto command. You learned how to create labels, explored tips on their
    use, and saw how instrumental they are in the building of the while and do...while
    commands. I also introduced the indispensable :eof label.
  prefs: []
  type: TYPE_NORMAL
- en: But you can navigate to labels in two distinct ways. Much of the next chapter
    will also focus on labels and how you can use them to create callable routines
    inside a bat file. I’ll also detail how to call one bat file from another, a crucial
    topic as you begin creating projects too complex for a single bat file.
  prefs: []
  type: TYPE_NORMAL
