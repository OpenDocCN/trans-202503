<html><head></head><body>
<h2 class="h2" id="app02"><span epub:type="pagebreak" id="page_345"/><span class="big"><strong>B</strong></span><br/><strong>BONUS SCRIPTS</strong></h2>&#13;
<div class="imagec"><img src="../images/common4.jpg" alt="image"/></div>&#13;
<p class="noindent">Because we couldn’t say no to these gems! As we developed this second edition, we ended up writing a few more scripts for backup purposes. It turns out we didn’t need the spare scripts, but we didn’t want to keep our secret sauce from our readers.</p>&#13;
<p class="indent">The first two bonus scripts are for the systems administrators out there who have to manage moving or processing a lot of files. The last script is for web users always looking for the next web service that’s just begging to be turned into a shell script; we’ll scrape a website that helps us track the phases of the moon!</p>&#13;
<h3 class="h3" id="app02lev1sec01"><span epub:type="pagebreak" id="page_346"/><strong>#102 Bulk-Renaming Files</strong></h3>&#13;
<p class="noindenta">Systems administrators are often tasked with moving many files from one system to another, and it’s fairly common for the files in the new system to require a totally different naming scheme. For a few files, renaming is simple to do manually, but when renaming hundreds or thousands of files, it immediately becomes a job better suited for a shell script.</p>&#13;
<h4 class="h4" id="app02lev2sec01"><em><strong>The Code</strong></em></h4>&#13;
<p class="noindenta">The simple script in <a href="app02.xhtml#app02ex1">Listing B-1</a> takes two arguments for the text to match and replace, and a list of arguments specifying the files you want to rename (which can be globbed for easy use).</p>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # bulkrename--Renames specified files by replacing text in the filename&#13;
&#13;
<span class="ent">➊</span> printHelp()&#13;
   {&#13;
     echo "Usage: $0 -f find -r replace FILES_TO_RENAME*"&#13;
     echo -e "\t-f The text to find in the filename"&#13;
     echo -e "\t-r The replacement text for the new filename"&#13;
     exit 1&#13;
   }&#13;
&#13;
<span class="ent">➋</span> while getopts "f:r:" opt&#13;
   do&#13;
     case "$opt" in&#13;
       r ) replace="$OPTARG"    ;;&#13;
       f ) match="$OPTARG"      ;;&#13;
       ? ) printHelp            ;;&#13;
     esac&#13;
   done&#13;
&#13;
   shift $(( $OPTIND - 1 ))&#13;
&#13;
   if [ -z $replace<span class="ent">➌</span> ] || [ -z $match<span class="ent">➍</span> ]&#13;
   then&#13;
     echo "You need to supply a string to find and a string to replace";&#13;
     printHelp&#13;
   fi&#13;
&#13;
<span class="ent">➎</span> for i in $@&#13;
   do&#13;
     newname=$(echo $i | <span class="ent">➏</span>sed "s/$match/$replace/")&#13;
     mv $i $newname&#13;
     &amp;&amp; echo "Renamed file $i to $newname"&#13;
   done</pre>&#13;
<p class="listcap"><a id="app02ex1"/><em>Listing B-1: The</em> <code><em>bulkrename</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="app02lev2sec02"><span epub:type="pagebreak" id="page_347"/><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">We first define a <code>printHelp()</code> function <span class="ent">➊</span> that will print the arguments required and the purpose of the script, and then exit. After defining the new function, the code iterates over the arguments passed to the script with <code>getopts</code> <span class="ent">➋</span>, as done in previous scripts, assigning values to the <code>replace</code> and <code>match</code> variables when their arguments are specified.</p>&#13;
<p class="indent">The script then checks that we have values for the variables we will use later. If the <code>replace</code> <span class="ent">➌</span> and <code>match</code> <span class="ent">➍</span> variables have a length of zero, the script prints an error telling the user that they need to supply a string to find and a string to replace. The script then prints the <code>printHelp</code> text and exits.</p>&#13;
<p class="indent">After verifying there are values for <code>match</code> and <code>replace</code>, the script begins iterating over the rest of the arguments specified <span class="ent">➎</span>, which should be the files to rename. We use <code>sed</code> <span class="ent">➏</span> to replace the <code>match</code> string with the <code>replace</code> string in the filename and store the new filename in a bash variable. With the new filename stored, we use the <code>mv</code> command to move the file to the new filename, and then print a message telling the user that the file has been renamed.</p>&#13;
<h4 class="h4" id="app02lev2sec03"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">The <code>bulkrename</code> shell script takes the two string arguments and the files to rename (which can be globbed for easier use; otherwise, they’re listed individually). If invalid arguments are specified, a friendly help message is printed, as shown in <a href="app02.xhtml#app02ex2">Listing B-2</a>.</p>&#13;
<h4 class="h4" id="app02lev2sec04"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">   $ <span class="codestrong">ls ~/tmp/bulk</span>&#13;
   1_dave  2_dave  3_dave  4_dave&#13;
   $ <span class="codestrong">bulkrename</span>&#13;
   You need to supply a string to find and a string to replace&#13;
   Usage: bulkrename -f find -r replace FILES_TO_RENAME*&#13;
     -f The text to find in the filename&#13;
     -r The replacement text for the new filename&#13;
<span class="ent">➊</span> $ <span class="codestrong">bulkrename -f dave -r brandon ~/tmp/bulk/*</span>&#13;
   Renamed file /Users/bperry/tmp/bulk/1_dave to /Users/bperry/tmp/bulk/1_brandon&#13;
   Renamed file /Users/bperry/tmp/bulk/2_dave to /Users/bperry/tmp/bulk/2_brandon&#13;
   Renamed file /Users/bperry/tmp/bulk/3_dave to /Users/bperry/tmp/bulk/3_brandon&#13;
   Renamed file /Users/bperry/tmp/bulk/4_dave to /Users/bperry/tmp/bulk/4_brandon&#13;
   $ <span class="codestrong">ls ~/tmp/bulk</span>&#13;
   1_brandon  2_brandon  3_brandon  4_brandon</pre>&#13;
<p class="listcap"><a id="app02ex2"/><em>Listing B-2: Running the</em> <code><em>bulkrename</em></code> <em>script</em></p>&#13;
<p class="indent">You can list the files to rename individually or glob them using an asterisk (<code>*</code>) in the file path like we do at <span class="ent">➊</span>. After being moved, each renamed file is printed to the screen with its new name to reassure the user that the files were renamed as expected.</p>&#13;
<h4 class="h4" id="app02lev2sec05"><span epub:type="pagebreak" id="page_348"/><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">Sometimes it may be useful to replace text in a filename with a special string, like today’s date or a timestamp. Then you’d know when the file was renamed without needing to specify today’s date in the <code>-r</code> argument. You can accomplish this by adding special tokens to the script that can then be replaced when the file is renamed. For instance, you could have a <code>replace</code> string containing <code>%d</code> or <code>%t</code>, which are then replaced with today’s date or a timestamp, respectively, when the file is renamed.</p>&#13;
<p class="indent">Special tokens like this can make moving files for backup purposes easier. You can add a <code>cron</code> job that moves certain files so the dynamic token in the filenames will be updated by the script automatically, instead of updating the <code>cron</code> job when you want to change the date in the filename.</p>&#13;
<h3 class="h3" id="app02lev1sec02"><strong>#103 Bulk-Running Commands on Multiprocessor Machines</strong></h3>&#13;
<p class="noindenta">When this book was first published, it was uncommon to have a multicore or multiprocessor machine unless you worked on servers or mainframes for a living. Today, most laptops and desktops have multiple cores, allowing the computer to perform more work at once. But sometimes programs you want to run are unable to take advantage of this increase in processing power and will only use one core at a time; to use more cores you have to run multiple instances of the program in parallel.</p>&#13;
<p class="indent">Say you have a program that converts image files from one format to another, and you have a whole lot of files to convert! Having a single process convert each file serially (one after another instead of in parallel) could take a long time. It would be much faster to split up the files across multiple processes running alongside each other.</p>&#13;
<p class="indent">The script in <a href="app02.xhtml#app02ex3">Listing B-3</a> details how to parallelize a given command for a certain number of processes you may want to run all at once.</p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>If you</em> don’t <em>have multiple cores in your computer, or if your program is slow for other reasons, such as a hard drive access bottleneck, running parallel instances of a program may be detrimental to performance. Be careful with starting too many processes as it could easily overwhelm an underpowered system. Luckily, even a Raspberry Pi has multiple cores nowadays!</em></p>&#13;
</div>&#13;
<h4 class="h4" id="app02lev2sec06"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
   # bulkrun--Iterates over a directory of files, running a number of&#13;
   #   concurrent processes that will process the files in parallel&#13;
&#13;
   printHelp()&#13;
   {&#13;
     echo "Usage: $0 -p 3 -i inputDirectory/ -x \"command -to run/\""&#13;
<span class="ent">➊</span>   echo -e "\t-p The maximum number of processes to start concurrently"&#13;
<span class="ent">➋</span>   echo -e "\t-i The directory containing the files to run the command on"&#13;
<span class="ent">➌</span>   echo -e "\t-x The command to run on the chosen files"&#13;
     exit 1&#13;
   }&#13;
&#13;
<span class="ent">➍</span> while getopts "p:x:i:" opt&#13;
   do&#13;
     case "$opt" in&#13;
       p ) procs="$OPTARG"    ;;&#13;
       x ) command="$OPTARG"  ;;&#13;
       i ) inputdir="$OPTARG" ;;&#13;
       ? ) printHelp          ;;&#13;
     esac&#13;
   done&#13;
&#13;
   if [[ -z $procs || -z $command || -z $inputdir ]]&#13;
   then&#13;
<span class="ent">➎</span>   echo "Invalid arguments"&#13;
     printHelp&#13;
   fi&#13;
&#13;
   total=<span class="ent">➏</span>$(ls $inputdir | wc -l)&#13;
   files="$(ls -Sr $inputdir)"&#13;
&#13;
<span class="ent">➐</span> for k in $(seq 1 $procs $total)&#13;
   do&#13;
<span class="ent">➑</span>   for i in $(seq 0 $procs)&#13;
     do&#13;
       if [[ $((i+k)) -gt $total ]]&#13;
       then&#13;
         wait&#13;
         exit 0&#13;
       fi&#13;
&#13;
       file=<span class="ent">➒</span>$(echo "$files" | sed $(expr $i + $k)"q;d")&#13;
       echo "Running $command $inputdir/$file"&#13;
       $command "$inputdir/$file"&amp;&#13;
     done&#13;
&#13;
<span class="ent">➓</span> wait&#13;
   done</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_349"/><a id="app02ex3"/><em>Listing B-3: The</em> <code><em>bulkrun</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="app02lev2sec07"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">The <code>bulkrun</code> script takes three arguments: the maximum number of processes to run at any one time <span class="ent">➊</span>, the directory containing the files to process <span class="ent">➋</span>, and the command to run (suffixed with the filename to run on) <span class="ent">➌</span>. After going through the arguments supplied by the user with <code>getopts</code> <span class="ent">➍</span>, the script checks that the user supplied these three arguments. If any of the <code>procs</code>, <code>command</code>, or <code>inputdir</code> variables are undefined after processing the user arguments, the script prints an error message <span class="ent">➎</span> and the help text and then exits.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_350"/>Once we know we have the variables needed to manage running the parallel processes, the real work of the script can start. First, the script determines the number of files to process <span class="ent">➏</span> and saves a list of the files for use later. Then the script begins a <code>for</code> loop that will be used to keep track of how many files it has processed so far. This <code>for</code> loop uses the <code>seq</code> command <span class="ent">➐</span> to iterate from 1 to the total number of files specified, using the number of processes that will run in parallel as the increment step.</p>&#13;
<p class="indent">Inside this is another <code>for</code> loop <span class="ent">➑</span> that tracks the number of processes starting at a given time. This inner <code>for</code> loop also uses the <code>seq</code> command to iterate from 0 to the number of processes specified, with 1 as the default increment step. In each iteration of the inner <code>for</code> loop, a new file is pulled out of the file list <span class="ent">➒</span>, using <code>sed</code> to print only the file we want from the list of files saved at the beginning of the script, and the supplied command is run on the file in the background using the <code>&amp;</code> sign.</p>&#13;
<p class="indent">When the maximum number of processes has been started in the background, the <code>wait</code> command <span class="ent">➓</span> tells the script to sleep until all the commands in the background have finished processing. After <code>wait</code> is finished, the whole workflow starts over again, picking up more processes to work on more files. This is similar to how we quickly achieve the best compression in the script <code>bestcompress</code> (<a href="ch04.xhtml#ch04lev1sec08">Script #34</a> on <a href="ch04.xhtml#page_113">page 113</a>).</p>&#13;
<h4 class="h4" id="app02lev2sec08"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">Using the <code>bulkrun</code> script is pretty straightforward. The three arguments it takes are the maximum number of processes to run at any one time, the directory of files to work on, and the command to run on them. If you wanted to run the ImageMagick utility <code>mogrify</code> to resize a directory of images in parallel, for instance, you could run something like <a href="app02.xhtml#app02ex4">Listing B-4</a>.</p>&#13;
<h4 class="h4" id="app02lev2sec09"><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">bulkrun -p 3 -i tmp/ -x "mogrify -resize 50%"</span>&#13;
Running mogrify -resize 50% tmp//1024-2006_1011_093752.jpg&#13;
Running mogrify -resize 50% tmp//069750a6-660e-11e6-80d1-001c42daa3a7.jpg&#13;
Running mogrify -resize 50% tmp//06970ce0-660e-11e6-8a4a-001c42daa3a7.jpg&#13;
Running mogrify -resize 50% tmp//0696cf00-660e-11e6-8d38-001c42daa3a7.jpg&#13;
Running mogrify -resize 50% tmp//0696cf00-660e-11e6-8d38-001c42daa3a7.jpg&#13;
--<span class="codeitalic">snip</span>--</pre>&#13;
<p class="listcap"><a id="app02ex4"/><em>Listing B-4: Running the</em> <code><em>bulkrun</em></code> <em>command to parallelize the</em> <code><em>mogrify</em></code> <em>ImageMagick command</em></p>&#13;
<h4 class="h4" id="app02lev2sec10"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta">It’s often useful to be able to specify a filename inside of a command, or use tokens similar to those mentioned in the <code>bulkrename</code> script (<a href="app02.xhtml#app02lev1sec01">Script #102</a> on <a href="app02.xhtml#page_346">page 346</a>): special strings that are replaced at runtime with dynamic values (such as <code>%d</code>, which is replaced with the current date, or <code>%t</code>, which is <span epub:type="pagebreak" id="page_351"/>replaced with a timestamp). Updating the script so that it can replace special tokens in the command or in the filename with something like a date or timestamp as the files are processed would prove useful.</p>&#13;
<p class="indent">Another useful hack might be to track how long it takes to perform all the processing using the <code>time</code> utility. Having the script print statistics on how many files will be processed, or how many have been processed and how many are left, would be valuable if you’re taking care of a truly massive job.</p>&#13;
<h3 class="h3" id="app02lev1sec03"><strong>#104 Finding the Phase of the Moon</strong></h3>&#13;
<p class="noindenta">Whether you’re a werewolf, a witch, or just interested in the lunar calendar, it can be helpful and educational to track the phases of the moon and learn about waxing, waning, and even gibbous moons (which have nothing to do with gibbons).</p>&#13;
<p class="indent">To make things complicated, the moon has an orbit of 27.32 days and its phase is actually dependent on where you are on Earth. Still, given a specific date, it is possible to calculate the phase of the moon.</p>&#13;
<p class="indent">But why go through all the work when there are plenty of sites online that already calculate the phase for any given date in the past, present, or future? For the script in <a href="app02.xhtml#app02ex5">Listing B-5</a>, we’re going to utilize the same site Google uses if you do a search for the current phase of the moon: <em><a href="http://www.moongiant.com/">http://www.moongiant.com/</a></em>.</p>&#13;
<h4 class="h4" id="app02lev2sec11"><em><strong>The Code</strong></em></h4>&#13;
<pre class="programs">   #!/bin/bash&#13;
&#13;
   # moonphase--Reports the phase of the moon (really the percentage of&#13;
   #   illumination) for today or a specified date&#13;
&#13;
   # Format of Moongiant.com query:&#13;
   #   http://www.moongiant.com/phase/MM/DD/YYYY&#13;
&#13;
   # If no date is specified, use "today" as a special value.&#13;
&#13;
   if [ $# -eq 0 ] ; then&#13;
     thedate="today"&#13;
   else&#13;
     # Date specified. Let's check whether it's in the right format.&#13;
      mon="$(echo $1 | cut -d/ -f1)"&#13;
      day="$(echo $1 | cut -d/ -f2)"&#13;
     year="$(echo $1 | cut -d/ -f3)"&#13;
&#13;
<span class="ent">➊</span>   if [ -z "$year" -o -z "$day" ] ; then     # Zero length?&#13;
       echo "Error: valid date format is MM/DD/YYYY"&#13;
       exit 1&#13;
     fi&#13;
     thedate="$1" # No error checking = dangerous&#13;
   fi&#13;
&#13;
   url="http://www.moongiant.com/phase/$thedate"&#13;
<span class="ent">➋</span> pattern="Illumination:"&#13;
&#13;
<span class="ent">➌</span> phase="$( curl -s "$url" | grep "$pattern" | tr ',' '\&#13;
   ' | grep "$pattern" | sed 's/[^0-9]//g')"&#13;
&#13;
   # Site output format is "Illumination: &lt;span&gt;NN%\n&lt;\/span&gt;"&#13;
&#13;
   if [ "$thedate" = "today" ] ; then&#13;
     echo "Today the moon is ${phase}% illuminated."&#13;
   else&#13;
     echo "On $thedate the moon = ${phase}% illuminated."&#13;
   fi&#13;
&#13;
   exit 0</pre>&#13;
<p class="listcap"><span epub:type="pagebreak" id="page_352"/><a id="app02ex5"/><em>Listing B-5: The</em> <code><em>moonphase</em></code> <em>script</em></p>&#13;
<h4 class="h4" id="app02lev2sec12"><em><strong>How It Works</strong></em></h4>&#13;
<p class="noindenta">As with other scripts that scrape values from a web query, the <code>moonphase</code> script revolves around identifying the format of different query URLs and pulling the specific value from the resultant HTML data stream.</p>&#13;
<p class="indent">Analysis of the site shows that there are two types of URLs: one that specifies the current date, simply structured as “phase/today”, and one that specifies a date in the past or future in the format MM/DD/Y Y Y Y, like “phase/08/03/2017”.</p>&#13;
<p class="indent">Specify a date in the right format and you can get the phase of the moon on that date. But we can’t just append the date to the site’s domain name without some error-checking, so the script splits the user input into three fields—month, day, and year—and then makes sure that the day and year values are nonzero at <span class="ent">➊</span>. There’s more error-checking that can be done, which we’ll explore in “Hacking the Script.”</p>&#13;
<p class="indent">The trickiest part of any scraper script is properly identifying the pattern that lets you extract the desired data. In the <code>moonphase</code> script, that’s specified at <span class="ent">➋</span>. The longest and most complicated line is at <span class="ent">➌</span>, where the script gets the page from the <em>moongiant.com</em> site, and then uses a sequence of <code>grep</code> and <code>sed</code> commands to pull just the line that matches the pattern specified.</p>&#13;
<p class="indent">After that, it’s just a matter of displaying the illumination level, either for today or the specified date, using the final <code>if</code>/<code>then</code>/<code>else</code> statement.</p>&#13;
<h4 class="h4" id="app02lev2sec13"><em><strong>Running the Script</strong></em></h4>&#13;
<p class="noindenta">Without an argument, the <code>moonphase</code> script shows the percentage of lunar illumination for the current date. Specify any date in the past or future by entering MM/DD/YYYY, as shown in <a href="app02.xhtml#app02ex6">Listing B-6</a>.</p>&#13;
<h4 class="h4" id="app02lev2sec14"><span epub:type="pagebreak" id="page_353"/><em><strong>The Results</strong></em></h4>&#13;
<pre class="programs">$ <span class="codestrong">moonphase 08/03/2121</span>&#13;
On 08/03/2121 the moon = 74% illuminated.&#13;
&#13;
$ <span class="codestrong">moonphase</span>&#13;
Today the moon is 100% illuminated.&#13;
&#13;
$ <span class="codestrong">moonphase 12/12/1941</span>&#13;
On 12/12/1941 the moon = 43% illuminated.</pre>&#13;
<p class="listcap"><a id="app02ex6"/><em>Listing B-6: Running the</em> <code><em>moonphase</em></code> <em>script</em></p>&#13;
<div class="note">&#13;
<p class="notet"><span class="noteg"><strong>NOTE</strong></span></p>&#13;
<p class="notep"><em>December 12, 1941 is when the classic Universal horror film</em> The Wolf Man <em>was first released to movie theaters. And it wasn’t a full moon. Go figure!</em></p>&#13;
</div>&#13;
<h4 class="h4" id="app02lev2sec15"><em><strong>Hacking the Script</strong></em></h4>&#13;
<p class="noindenta1">From an internal perspective, the script could be greatly improved by having a better error-checking sequence, or even by just utilizing <a href="ch01.xhtml#ch01lev1sec04">Script #3</a> on <a href="ch01.xhtml#page_17">page 17</a>. That would let users specify dates in more formats. An improvement would be to replace the <code>if</code>/<code>then</code>/<code>else</code> statement at the end with a function that translates illumination level into more common moon phase phrases like “waning,” “waxing,” and “gibbous.” NASA has a web page you could use that defines the different phases: <em><a href="http://starchild.gsfc.nasa.gov/docs/StarChild/solar_system_level2/moonlight.html">http://starchild.gsfc.nasa.gov/docs/StarChild/ solar_system_level2/moonlight.html</a></em>.<span epub:type="pagebreak" id="page_354"/></p>&#13;
</body></html>