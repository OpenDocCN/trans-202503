<html><head></head><body><div id="sbo-rt-content"><section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="1" id="Page_1"/>1</span><br/>
<span class="ChapterTitle">An Introduction to WebAssembly</span></h1>
</header>
<figure class="opener">
<img src="Images/chapterart.png" alt="" width="190" height="190"/>
</figure>
<p class="ChapterIntro">In this chapter, you’ll acquire background knowledge of WebAssembly and explore the tools you’ll need to start working with WebAssembly and its textual representation, WebAssembly Text (WAT). We’ll discuss the benefits of WebAssembly, including improved performance, legacy library integration, portability, security, and its use as an alternative to JavaScript. We’ll consider JavaScript’s relationship with WebAssembly and what WebAssembly is and isn’t. You’ll learn the WAT inline and S-expression syntax. We’ll introduce the concepts of the embedding environment and discuss embedding WebAssembly in web browsers, Node.js, and the WebAssembly System Interface (WASI).</p>
<p>Then we’ll discuss the benefits of using Visual Studio Code as a development environment for WAT. You’ll learn the basics of Node.js and how to use it as an embedding environment for WebAssembly. We’ll show you how to use npm to install the wat-wasm tool, which provides you with everything <span epub:type="pagebreak" title="2" id="Page_2"/>you need to build WebAssembly applications from WAT. In addition, we’ll write our first WebAssembly app and execute it with Node.js as the embedding environment.</p>
<h2 id="h1-501737c01-0001">What Is WebAssembly?</h2>
<p class="BodyFirst">WebAssembly is a technology that will massively improve the performance of web applications over the next several years. Because WebAssembly is new and requires some explanation, many people misunderstand it and how to use it. This book teaches you what WebAssembly is and how to use it to make high-performing web applications.</p>
<p><em>WebAssembly</em> is a virtual <em>Instruction Set Architecture (ISA)</em> for a stack machine. Generally, an ISA is a binary format designed to execute on a specific machine. However, WebAssembly is designed to run on a <em>virtual</em> machine, meaning it’s not designed for physical hardware. The virtual machine allows WebAssembly to run on a variety of computer hardware and digital devices. The WebAssembly ISA was designed to be compact, portable, and secure, with small binary files to reduce download times when deployed as part of a web application. It’s easy to port the bytecode to a variety of computer hardware, and it has a secure platform for deploying code over the web.</p>
<p>All major browser vendors have adopted WebAssembly. According to the Mozilla Foundation, WebAssembly code runs between 10 percent and 800 percent faster than the equivalent JavaScript code. One eBay WebAssembly project executed 50 times faster than the original JavaScript version. Later in the book we’ll build a collision detection program that we can use to measure performance. When we ran it, our performance benchmarking found that our WebAssembly collision detection code ran more than four times faster than JavaScript in Chrome and more than two times faster than JavaScript in Firefox.</p>
<p>WebAssembly offers the most significant performance improvement the web has seen since the introduction of the just-in-time (JIT) JavaScript compilers. Modern browser JavaScript engines can parse and download the WebAssembly binary format an order of magnitude faster than JavaScript. The fact that WebAssembly is a binary target, not a programming language like JavaScript, allows the developer to choose the programming language that best suits their application’s needs. The saying “JavaScript is the assembly language of the web” might have become fashionable recently, but the JavaScript format is a terrible compilation target. Not only is JavaScript less efficient than a binary format like WebAssembly, but any JavaScript target code also has to handle the specifics of the JavaScript language.</p>
<p> WebAssembly offers tremendous web application performance improvements in two areas. One is startup speed. Currently, the most compact JavaScript format is minified JavaScript, which improves application download sizes but must parse, interpret, JIT compile, and optimize the JavaScript code. These steps are unnecessary with a WebAssembly binary, which is also more compact. WebAssembly still needs to be parsed, but it’s faster because it’s a bytecode format rather than text. Web engines still do optimization <span epub:type="pagebreak" title="3" id="Page_3"/>passes on WebAssembly, but it’s much faster because the language is more cleanly designed.</p>
<p>The other significant performance improvement WebAssembly offers is in throughput. WebAssembly makes it easier for the browser engine to optimize. JavaScript is a highly dynamic and flexible programming language, which is helpful to a JavaScript developer, but creates a code optimization nightmare. WebAssembly doesn’t make any web-specific assumptions (despite its name) and can be used beyond the browser.</p>
<p>Eventually, WebAssembly might be able to do everything JavaScript can. Unfortunately, the current version, its MVP (Minimum Viable Product) release version 1.0, cannot. In the MVP release, WebAssembly can do certain tasks very well. It’s not intended to be a drop-in replacement for JavaScript or a framework, such as Angular, React, or Vue. If you want to work with WebAssembly right now, you should have a specific computationally intensive project that requires very high performance. Online games, WebVR, 3D math, and crypto are effective ways people currently use WebAssembly.</p>
<h2 id="h1-501737c01-0002">Reasons to Use WebAssembly</h2>
<p class="BodyFirst">Before we take a closer look at WebAssembly, let’s consider a few reasons you might be interested in using it. These explanations should also give you an idea of what WebAssembly is and why and how to use it.</p>
<h3 id="h2-501737c01-0001">Better Performance</h3>
<p class="BodyFirst">JavaScript requires software engineers to make choices that will affect how they design the JavaScript engine. For example, you can optimize a JavaScript engine for peak performance using a JIT optimizing compiler, which can execute code faster but requires more startup time. Alternatively, you can use an interpreter, which starts running code right away but won’t reach the peak performance of a JIT optimizing compiler. The solution most JavaScript engine designers use in their web browsers is to implement both, but that requires a much larger memory footprint. Every decision you make is a trade-off.</p>
<p>WebAssembly allows for a faster startup time and higher peak performance without all of the memory bloat. Unfortunately, you can’t just rewrite your JavaScript in AssemblyScript, Rust, or C++ and expect this to happen without a little extra work. WebAssembly isn’t magic, and merely porting JavaScript to another language and compiling it without understanding what WebAssembly is doing at a lower level can lead to some disappointing results. Writing C++ code and compiling it to WebAssembly using optimization flags will usually be a bit faster than JavaScript. Occasionally, programmers will complain that they’ve spent all day rewriting their app in C++ and it only runs 10 percent faster. If that’s the case, it’s likely that these apps wouldn’t benefit from converting to WebAssembly, and their C++ gets compiled into mostly JavaScript. Take the time to learn WebAssembly, not C++, and make your web applications run lightning fast.</p>
<h3 id="h2-501737c01-0002"><span epub:type="pagebreak" title="4" id="Page_4"/>Integrating Legacy Libraries</h3>
<p class="BodyFirst">Two popular libraries for porting existing libraries to WebAssembly are <em>wasm-pack</em> for Rust and <em>Emscripten</em> for C/C++. Using WebAssembly is ideal for when you have existing code written in C/C++ or Rust that you want to make available to web applications, or want to port entire existing desktop applications to make them available on the web. The Emscripten toolchain is particularly efficient at porting existing C++ desktop applications to the web using WebAssembly. If this is your path, you’ll likely want your app to perform as closely as possible to the native speed of your existing application, which should be feasible as long as the application isn’t a resource hog. However, you might also have an app that needs performance tuning to make it run as it does on the desktop. By the end of this book, you’ll be able to evaluate the WebAssembly module your toolchain generates from your existing code.</p>
<h3 id="h2-501737c01-0003">Portability and Security</h3>
<p class="BodyFirst">We combined the portability and security features into one section because they frequently go together. WebAssembly started as a technology to run in the browser but is quickly expanding to become a sandboxed environment to run anywhere. From server-side WASI code to WebAssembly for embedded systems and the internet of things (IoT), the WebAssembly working group is creating a highly secure runtime that prevents bad actors from compromising your code. I recommend listening to Lin Clark’s excellent talk about WebAssembly security and package reuse at the first WebAssembly Summit (<a href="https://www.youtube.com/watch?v=IBZFJzGnBoU/" class="LinkURL">https://www.youtube.com/watch?v=IBZFJzGnBoU/</a>).</p>
<p>Even though the WebAssembly working group focuses on security, no system is entirely secure. Learning to understand WebAssembly at a low level will prepare you for any future security risks.</p>
<h3 id="h2-501737c01-0004">JavaScript Skeptics</h3>
<p class="BodyFirst">Some people simply dislike JavaScript and would rather that JavaScript not be the dominant web programming language. Unfortunately, WebAssembly isn’t in a position to dethrone JavaScript. Today, JavaScript and WebAssembly must coexist and play well together, as shown in <a href="#figure1-1" id="figureanchor1-1">Figure 1-1</a>.</p>
<p>But there is good news for the JavaScript skeptics in the world: WebAssembly toolchains offer many options for writing web applications without having to write JavaScript. For example, Emscripten allows you to write web applications in C/C++ with very little, if any, JavaScript. You can also write entire web applications using Rust and wasm-pack. Not only do these toolchains generate WebAssembly, but they also create copious JavaScript glue code for your application. The reason is that currently, there are limits to WebAssembly’s capabilities, and the toolchains fill these gaps with JavaScript code. The beauty of mature toolchains like Emscripten is that they do this for you. If you’re developing with one of these toolchains, it’s helpful to understand when your code will turn into WebAssembly and when it will be JavaScript. This book helps you know when this will happen.</p>
<span epub:type="pagebreak" title="5" id="Page_5"/><figure>
<img src="Images/f01001.png" alt="f01001" width="675" height="592"/>
<figcaption><p><a id="figure1-1">Figure 1-1</a>: JavaScript and WebAssembly can coexist in harmony.</p></figcaption>
</figure>
<h2 id="h1-501737c01-0003">WebAssembly’s Relationship with JavaScript</h2>
<p class="BodyFirst">It’s important to clarify how WebAssembly is used with and compares to JavaScript. WebAssembly isn’t a direct replacement for JavaScript; rather, WebAssembly:</p>
<ul>
<li>Is faster to download, compile, and execute</li>
<li>Allows you to write applications for the web in languages other than JavaScript  </li>
<li>Can provide near-native speed for your application when used properly</li>
<li>Works <em>with</em> JavaScript to improve the performance of your web applications when appropriately used</li>
<li>Isn’t an assembly language, although there is a pseudo assembly language associated with it (WAT)    </li>
<li>Isn’t only for the web but can execute from non-browser JavasScript engines, such as Node.js, or can execute using runtimes that implement the WASI  </li>
<li>Isn’t yet a one-size-fits-all solution for creating web applications </li>
</ul>
<p><span epub:type="pagebreak" title="6" id="Page_6"/>WebAssembly is the result of all major browser vendors collaborating to create a new platform for distributing applications over the internet. The JavaScript language evolved from the needs of web browsers in the late 1990s to the mature scripting language it is today. Although JavaScript has become a reasonably fast language, web developers have noticed that it sometimes performs inconsistently. WebAssembly is a solution to many of the performance problems associated with JavaScript.</p>
<p>Even though WebAssembly can’t do everything JavaScript can, it can execute certain operations much faster than JavaScript while consuming less memory. Throughout this book, we compare JavaScript code with the corresponding WebAssembly. We’ll repeatedly benchmark and profile the code for comparison. By the end of this book, you’ll be able to judge when you should use WebAssembly and when it makes sense to continue using JavaScript.</p>
<h2 id="h1-501737c01-0004">Why Learn WAT?</h2>
<p class="BodyFirst">Many WebAssembly books and tutorials focus on specific toolchains, such as the aforementioned wasm-pack for Rust or Emscripten for C/C++. Toolchains for other languages like AssemblyScript (a subset of TypeScript) and Go are currently in development. These toolchains are a major reason programmers turn to WebAssembly, and more WebAssembly language toolchains are continually becoming available. In the future, web developers will be able to choose the language they use to develop based on project needs rather than language availability.</p>
<p>One factor that is useful across any of these languages is understanding what WebAssembly does at its lowest level. A deep understanding of WAT tells you why the code might not run as fast as you thought it would. It can help you comprehend how WebAssembly interacts with its embedding environment. Writing a module in WAT is the best way to work as close to the metal (low-level) as possible in a web browser. Knowledge of WAT can help you make the highest-performing web applications possible and allows you to disassemble and evaluate any web application written for the WebAssembly platform. It helps you assess any potential future security risks. In addition, it enables you to write code that is as close to native speed as possible without writing native code.</p>
<p>So what is WAT? WAT is like an assembly language for the WebAssembly virtual machine. Let’s look at what this means in a practical sense. Writing WebAssembly programs in a language like Rust or C++ uses a toolchain, which, as mentioned earlier, compiles a WebAssembly binary file as well as JavaScript glue code and HTML that embeds the WebAssembly module. A WebAssembly file is very similar to machine code because it includes sections, opcodes, and data all stored as a series of binary numbers. When you have an executable file in machine code, you can disassemble that file into that machine’s <em>assembly language, </em>the lowest level of programming languages. Assembly replaces the numeric opcodes in the binary with mnemonic codes that are intended to be readable by a human being. WAT acts as the assembly language for WebAssembly.</p>
<h3 id="h2-501737c01-0005"><span epub:type="pagebreak" title="7" id="Page_7"/>WAT Coding Styles</h3>
<p class="BodyFirst">There are two primary styles of WAT coding to choose from. One style is the <em>linear instruction list</em> style. This coding style requires the developer to mentally keep track of items on the stack. Most WAT instructions push items onto a stack, pop them off a stack, or both. If you choose to write in the linear instruction style, there is an implicit stack where the parameters of your instructions must be placed before the instruction is called. The other coding style is called <em>S-Expressions</em>. S-Expressions are a tree-like coding structure where parameters are passed into the tree in a way that looks a bit more like function calls in JavaScript. If you have trouble visualizing the stack and the items being pushed onto and off of it, the S-Expression syntax might be more your style. You can also mix the two styles depending on the implicit stack for less complicated instructions and use an S-Expression when the number of parameters become challenging to keep track of.</p>
<h4 id="h3-501737c01-0001">Example Using Linear Instruction List Style</h4>
<p class="BodyFirst">Consider the simple addition function in <a href="#listing1-1" id="listinganchor1-1">Listing 1-1</a>, which is in JavaScript.</p>
<pre><code>function main() {
    let a_val = 1;
    let b_val = 2;
    let c_val = a_val + b_val;
}</code></pre>
<p class="CodeListingCaption"><a id="listing1-1">Listing 1-1</a>: JavaScript code adding <code>a_val</code> and <code>b_val</code> variables</p>
<p>After executing these lines, the value in the <code>c_val</code> variable is now <code>3</code>, which is the result of adding <code>a_val</code> and <code>b_val</code>. To do the same task in WAT, you would need quite a few lines of code. <a href="#listing1-2" id="listinganchor1-2">Listing 1-2</a> shows the same program using WAT.</p>
<pre><code>(module
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> (global $a_val (mut i32) (i32.const 1))
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> (global $b_val (mut i32) (i32.const 2))
    (global $c_val (mut i32) (i32.const 0))
    (func $main (export "main")
        global.get $a_val
        global.get $b_val
    
        i32.add
        global.set $c_val
    )
)</code></pre>
<p class="CodeListingCaption"><a id="listing1-2">Listing 1-2</a>: WebAssembly adding <code>$a_val</code> to <code>$b_val</code></p>
<p><a href="#listing1-2">Listing 1-2</a> contains more lines of code because WAT must be more explicit than JavaScript. JavaScript has no idea whether the types in the previous two examples are floating-point data, integers, strings, or a mix <span epub:type="pagebreak" title="8" id="Page_8"/>until the code runs. The WebAssembly is compiled into a bytecode ahead of time and must be made aware of the types it’s using when it’s compiled. The JavaScript must be parsed and tokenized before the JIT compiler can turn it into bytecode. Once the optimizing compiler begins working on that bytecode, the compiler must watch to see whether the variables are consistently integers. If they are, the JIT can create a bytecode that makes that assumption.</p>
<p>However, JavaScript is never quite sure whether it will end up with string data or floating-point data when it expected integers; so at any time, it must be ready to throw out its optimized code and start over again. The WAT code might be harder to write and to understand, but it’s much easier for the web browser to run. WebAssembly moves a lot of work from the browser to the toolchain compiler or the developer. Not having to do as much work makes for happy browsers and faster applications.</p>
<h4 id="h3-501737c01-0002">Stack Machines</h4>
<p class="BodyFirst">As mentioned earlier, WebAssembly is a virtual stack machine. Let’s explore what this means. Think of a stack as a stack of dishes. Each dish in this metaphor is a piece of data. When you add a dish to the stack, you place it on top of the dishes already there. When you take a dish off the stack, you don’t take it from the bottom, you take it off the top. For this reason, the last dish you put on the stack is the first dish you remove. In computer science, this is called <em>last-in, first-out</em> (<em>LIFO</em>). Adding data to a stack is called a <em>push</em>, and taking data off a stack is called a <em>pop</em>. When you use a stack machine, almost all commands perform some interaction with the stack, either adding more data to the top of the stack with a push or removing data from the top with a pop. <a href="#figure1-2" id="figureanchor1-2">Figure 1-2</a> shows a depiction of stack interaction.</p>
<figure>
<img src="Images/f01002.png" alt="f01002" width="675" height="281"/>
<figcaption><p><a id="figure1-2">Figure 1-2</a>: A stack machine pops values off and pushes values onto the stack.</p></figcaption>
</figure>
<p>As you saw earlier, the first two lines of the <code>$main </code>function in <a href="#listing1-2">Listing 1-2</a> push <code>$a_val</code> on the top of the stack <span class="CodeAnnotation" aria-label="annotation1">1</span> and then push <code>$b_val</code> on top of that <span class="CodeAnnotation" aria-label="annotation2">2</span>. The result is a stack with two values on it. The bottom of the stack has the value in <code>$a_val</code> because we added it first, and the top has the value in <code>$b_val</code> because it was added last.</p>
<p><span epub:type="pagebreak" title="9" id="Page_9"/>It’s important to make the distinction between an ISA for a stack machine, like WebAssembly, and an ISA for a register machine, such as x86, ARM, MIPS, PowerPC, or any other popular hardware architecture of the past 30 years. Register machines must move data from memory into CPU registers to perform mathematical operations on them. WebAssembly is a virtual stack machine that must run on register machines. As we write WAT formatted code, you’ll see this interaction up close.</p>
<p>Stack machines push data onto and off of a stack to perform calculations. Hardware stack machines are a rare breed of computer. Virtual stack machines like WebAssembly are more common; examples include Java’s JVM, Adobe Flash player’s AVM2, Ethereum’s EVM, and the CPython bytecode interpreter. The advantage of virtual stack machines is that they create smaller bytecode sizes, which is handy for any bytecode intended to be downloaded or streamed over the internet.</p>
<p>Stack machines make no assumptions about the number of general-purpose registers available to the embedding environment. That allows the hardware to choose which registers to use and when. The WAT code can be a little confusing if you’re not aware of how a stack machine works, so let’s take another look at the first two lines of the function <code>$main</code> with the stack in mind (<a href="#listing1-3" id="listinganchor1-3">Listing 1-3</a>).</p>
<pre><code>global.get $a_val <span class="LiteralGray">;; push $a_val onto the stack</span>
global.get $b_val <span class="LiteralGray">;; push $b_val onto the stack</span></code></pre>
<p class="CodeListingCaption"><a id="listing1-3">Listing 1-3</a>: Retrieving <code>$a_val</code> and <code>$b_val</code>, and then pushing them on the stack</p>
<p>The first line gets the value of <code>$a_val</code>, which we define as a global value, and the second line gets the global variable <code>$b_val</code>. Both items end up on the stack waiting to be processed.</p>
<p>The function <code>i32.add</code> takes two 32-bit integer variables off the stack, adds them together, and then pushes the result back onto the top of the stack. Once the two values are on the stack, we can call <code>i32.add</code>. If you run a function that pops more values off the stack than were available, the tools you use to convert your WAT into a WebAssembly binary won’t allow this and will throw a compiler error. We use the final line in the <code>$main</code> function to set the <code>$c_val</code> variable to the value on the stack. That value is the result of the <code>i32.add</code> function call.</p>
<h4 id="h3-501737c01-0003">Example Using S-Expressions</h4>
<p class="BodyFirst">S-Expressions are a nested tree structure coding style used in programming languages, such as Lisp. In <a href="#listing1-3">Listing 1-3</a>, we used the linear instruction list style for writing WAT. The linear instruction style implicitly uses the stack for each call statement and expression called. For those with some assembly language experience, this method might feel comfortable for you. But if you come to WebAssembly from a high-level language, like JavaScript, the S-Expression syntax for WAT is likely to feel more familiar. S-Expressions organize your calls to WAT statements and expressions in a nested structure. The linear style requires you to mentally push items onto the stack <span epub:type="pagebreak" title="10" id="Page_10"/>and pop them off as you write your code. The S-Expressions look more like JavaScript function calls than the linear style.</p>
<p>In <a href="#listing1-2">Listing 1-2</a>, we set <code>c_val</code> to <code>a_val</code> + <code>b_val</code> using the stack. The code in <a href="#listing1-4" id="listinganchor1-4">Listing 1-4</a> is the fragment of code in <a href="#listing1-2">Listing 1-2</a> where we added those values together:</p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> global.get $a_val <span class="LiteralGray">;; push $a_val onto the stack</span>
global.get $b_val <span class="LiteralGray">;; push $b_val onto the stack</span>

<span class="CodeAnnotationHang" aria-label="annotation2">2</span> i32.add           <span class="LiteralGray">;; pop two values, add and place result on stack</span>
global.set $c_val <span class="LiteralGray">;; pop a value off the stack and set $c_val</span></code></pre>
<p class="CodeListingCaption"><a id="listing1-4">Listing 1-4</a>: Adding and setting <code>$c_val</code> in WebAssembly</p>
<p>We push two 32-bit integer variables onto the stack that we retrieved from global variables using <code>global.get</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. We then popped those two values off the stack with a call to <code>i32.add</code>. After adding those two values together, the <code>i32.add</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> function pushed the resulting value back onto the stack. That’s how the stack machine works. Each instruction either pushes a value onto the stack, pops a value off, or both. </p>
<p><a href="#listing1-5" id="listinganchor1-5">Listing 1-5</a> shows the same function using the alternative S-Expression syntax.</p>
<pre><code>(module
  (global $a_val (mut i32) (i32.const 1))
  (global $b_val (mut i32) (i32.const 2))
  (global $c_val (mut i32) (i32.const 0))
  (func $main (export "main")
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> (global.set $c_val
      (i32.add (global.get $a_val) (global.get $b_val))
    )
  )
)</code></pre>
<p class="CodeListingCaption"><a id="listing1-5">Listing 1-5</a>: WebAssembly module to add two values</p>
<p>Don’t let the parentheses confuse you: they work the same way as the <code>{}</code> characters do in many languages to create code blocks. When writing a WAT function, we enclose the function in parentheses. When you bring a matching parenthesis below the opening parenthesis with the same indentation, it looks similar to the way you would indent the <code>{</code> and <code>}</code> characters in a language like JavaScript. For instance, look at the indentation of the <code>(</code> before the <code>global.set</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> call and match it up by eye with the closing <code>)</code> below it.</p>
<p>This code looks more like a conventional programming language than <a href="#listing1-2">Listing 1-2</a>, because it appears to pass parameters into a function instead of pushing and popping values with a stack. To be clear, this code compiles into the same binary. If you write your code in an S-Expressions style, you’re still pushing items on and off the stack. This style of writing WAT is just <em>syntactic sugar </em>(syntax to make code easier to read). When you’re comfortable disassembling WebAssembly files into WAT, you’ll find that the S-Expression syntax isn’t provided by disassemblers, such as <em>wasm2wat</em>.</p>
<h2 id="h1-501737c01-0005"><span epub:type="pagebreak" title="11" id="Page_11"/>The Embedding Environment</h2>
<p class="BodyFirst">As mentioned earlier, WebAssembly doesn’t run directly on hardware. You must embed the WebAssembly binary in a host environment that controls the loading and initializing of a WebAssembly module. In this book, we work with JavaScript engines, such as Node.js, and web browsers as embedding environments. Other environments include WASI, such as wasmtime (defined shortly). But even though we discuss WASI, we won’t use it in this book because it’s still very new and under development. It’s up to the embedding environment to implement the stack machine. Because modern hardware is typically a register machine, the embedding environment manages the stack using the hardware registers.</p>
<h3 id="h2-501737c01-0006">The Browser</h3>
<p class="BodyFirst">There’s a good chance that you’re interested in WebAssembly because you want it to improve the performance of your web applications. All modern browser JavaScript engines implement WebAssembly. Currently, Chrome and Firefox have the best tools for debugging WebAssembly, so we suggest choosing one of those browsers for development. Your WAT applications should also run just fine in Microsoft Edge, but Internet Explorer is no longer adding features. Unfortunately, Internet Explorer doesn’t support WebAssembly and never will.</p>
<p>When you’re writing WAT for a web browser, it’s crucial to understand which parts of an application you can write in WAT and which you must write in JavaScript. There might also be cases where the performance improvement you gain with WebAssembly might not be worth the additional development time. If you understand WAT and WebAssembly, you’ll be able to make these decisions. When you’re working with WebAssembly, you must frequently trade performance for development time, or sacrifice CPU cycles for memory, or vice versa. Performance optimization is about choices.</p>
<h3 id="h2-501737c01-0007">WASI</h3>
<p class="BodyFirst"><em>WASI</em> is a runtime specification for WebAssembly applications and is a standard for WebAssembly interaction with the operating system. It allows WebAssembly to use the filesystem, make system calls, and handle input and output. The Mozilla Foundation has created a WebAssembly runtime called <em>wasmtime</em> that implements the WASI standard. With WASI, WebAssembly can do everything that a native application can do but in a secure and platform-independent way. It does it all with performance similar to native apps.</p>
<p>Node.js can also run a WASI experimental preview using the <code>--experimental-wasi-unstable-preview1</code> flag. You can use it to run WebAssembly applications that interact with the operating system outside of a web browser. Windows, macOS, Linux, or any other operating system can implement a WASI runtime, because it’s designed to make WebAssembly portable, secure, and eventually universal.</p>
<h3 id="h2-501737c01-0008"><span epub:type="pagebreak" title="12" id="Page_12"/>Visual Studio Code</h3>
<p class="BodyFirst"><em>Visual Studio Code (VS Code)</em> is an open source integrated development environment (IDE), and the one I used to write the examples in this book. VS Code is available for Windows, macOS, and Linux at<em> </em><a href="https://code.visualstudio.com/download" class="LinkURL">https://code.visualstudio.com/download</a>. We use VS Code with the WebAssembly extension written by Dmitriy Tsvettsikh, which is available at <a href="https://marketplace.visualstudio.com/items?itemName=dtsvet.vscode-wasm" class="LinkURL">https://marketplace.visualstudio.com/items?itemName=dtsvet.vscode-wasm</a>. The extension provides code coloring for the WAT format, as well as several other useful menu items. For example, if you have a WebAssembly file, you can disassemble it into WAT by right-clicking the file and choosing the <b>Show WebAssembly</b> menu option. This is very useful if you want to look at WebAssembly code you didn’t write or code that was compiled using a toolchain. The extension can also compile your WAT files into a WebAssembly binary. You can right-click the <em>.wat</em> file and choose <b>Save as WebAssembly binary file</b>. A save file prompt appears, allowing you to specify the filename where you want to save the WebAssembly file.</p>
<p><a href="#figure1-3" id="figureanchor1-3">Figure 1-3</a> shows a screenshot of the extension.</p>
<figure>
<img src="Images/f01003.png" alt="f01003" width="662" height="352"/>
<figcaption><p><a id="figure1-3">Figure 1-3</a>: Installing the WebAssembly extension for VS Code</p></figcaption>
</figure>
<h3 id="h2-501737c01-0009">Node.js</h3>
<p class="BodyFirst"><em>Node.js</em> is an excellent tool for testing the performance of WebAssembly modules against existing JavaScript modules and is the JavaScript runtime environment we use in much of this book. Node.js comes with <em>npm (Node Package Manager),</em> which you can use to easily install packages of code. WebAssembly is a great alternative to writing a native module in Node.js, which locks you into using specific hardware. If you want to create an npm module for general use, writing for WebAssembly can give you the performance of a native module with the portability and security of a JavaScript module. We’ll execute many of the applications we write in this book using Node.js.</p>
<p><span epub:type="pagebreak" title="13" id="Page_13"/>Node.js is our preferred development tool for executing WebAssembly, whether it be from JavaScript or through a web server. We’ll begin by using Node.js to execute WebAssembly modules from JavaScript, and in <span class="xref" itemid="xref_target_Chapter 7">Chapter 7</span>, we’ll write a simple web server to serve WebAssembly web applications.</p>
<p>Node.js comes with the npm, which makes it easy to install some tools you can use to develop WebAssembly. In this section, we’ll show you how to use npm to install the <em>wat-wasm</em> module, a tool for compiling, optimizing, and disassembling WebAssembly. We’ll also show you how to use Node.js to write a simple WebAssembly application. Many readers might already be familiar with Node.js, but if not, there is a mountain of Node.js documentation available if you want to learn more than the short introduction and setup we discuss here.</p>
<h4 id="h3-501737c01-0004">Installing Node.js</h4>
<p class="BodyFirst">You must have Node.js installed to complete the code examples in this book. Fortunately, the installation isn’t complicated. If you’re using Windows or macOS, installers are available for both operating systems at <a href="https://nodejs.org/en/download/" class="LinkURL">https://nodejs.org/en/download/</a>.</p>
<p>For Ubuntu Linux, you can install Node using the following <code>apt</code> command:</p>
<pre><code>sudo apt install nodejs</code></pre>
<p>Once you have Node installed, run the following command from a command prompt (on any platform) to make sure everything installed as intended:</p>
<pre><code>node -v</code></pre>
<p>If everything is installed, you should see the version of Node.js installed as output. When we run the command <code>node -v</code> on our Windows machine, it produces the following output:</p>
<pre><code>v12.14.0</code></pre>
<p>This means that we’re running version 12.14.0.</p>
<aside epub:type="sidebar">
<div class="top hr"><hr/></div>
<section class="note">
<h2><span class="NoteHead">NOTE</span></h2>
<p>	If you’re having problems executing the code in this book, you might want to install this specific version of Node.js from the “Previous Releases” page at <a href="https://nodejs.org/en/download/releases/" class="LinkURL">https://nodejs.org/en/download/releases/</a><em>.</em></p>
<div class="bottom hr"><hr/></div>
</section>
</aside>
<h4 id="h3-501737c01-0005">Installing wat-wasm</h4>
<p class="BodyFirst">Many tools are available for converting WAT code to a WebAssembly binary. In fact, while writing this book, I used many of these tools. In the end, I wrote <em>wat-wasm</em> on top of <em>WABT.js</em> and <em>Binaryen.js</em><em> </em>to reduce the number of <span epub:type="pagebreak" title="14" id="Page_14"/>packages needed for the features I wanted to demonstrate. To install <code>wat-wasm</code>, execute the following <code>npm</code> command:</p>
<pre><code>npm install -g wat-wasm</code></pre>
<p>The <code>-g</code> flag installs <code>wat-wasm</code> globally. Throughout this book we’ll use command line tools like <code>wat2wasm</code> in the terminal window. To use the tools for more than just the current project, you need to install it globally. Once you have <code>wat-wasm</code> installed, make sure you can run it by running the <code>wat2wasm</code> command from the command line:</p>
<pre><code>wat2wasm</code></pre>
<p>You should then see the <code>wat-wasm</code> usage logged to your console. This will show you a variety of flags that you’ll learn about later in this book.</p>
<p>You can test <code>wat2wasm</code> by creating the simplest possible WAT module, as shown in <a href="#listing1-6" id="listinganchor1-6">Listing 1-6</a>. Create a new file called <em>file.wat</em> and enter the following code into that file:</p>
<pre><code>(module)</code></pre>
<p class="CodeListingCaption"><a id="listing1-6">Listing 1-6</a>: The simplest possible WebAssembly module</p>
<p>With <code>wat-wasm</code><code> </code>installed, you can use the command in <a href="#listing1-7" id="listinganchor1-7">Listing 1-7</a> to compile <em>file.wat</em> file to <em>file.wasm</em>, which is the WebAssembly binary file:</p>
<pre><code>wat2wasm file.wat</code></pre>
<p class="CodeListingCaption"><a id="listing1-7">Listing 1-7</a>: Assembling the <em>file.</em><em>wat</em> file with <code>wat2wasm</code></p>
<p>We’ll use Node.js throughout this book to run WebAssembly command line apps and serve WebAssembly web apps to open in a browser. In the next section, we’ll write the first WebAssembly app that we’ll execute using Node.js.</p>
<h3 id="h2-501737c01-0010">Our First Node.js WebAssembly App</h3>
<p class="BodyFirst">We’ll begin the book by using Node.js as the embedding environment instead of the web browser so as to remove the need for HTML and CSS in the code examples and keep them simple. Later, once you have the basics, we’ll explore using the browser as the embedding environment.</p>
<p>The WAT code in our Node.js apps will work the same as they do in the browser. The WebAssembly engine inside Node.js is the same as the one inside Chrome, and the WebAssembly part of the app is completely unaware of the environment it’s running in.</p>
<p>Let’s begin by creating a simple WAT file and compiling it using <code>wat2wasm</code>. Create a file called <em>AddInt.wat</em> and add the WAT code in <a href="#listing1-8" id="listinganchor1-8">Listing 1-8</a> to it.</p>
<p class="CodeLabel"><b>AddInt.wat</b></p>
<pre><code>(module
    (func (export "AddInt")
    (param $value_1 i32) (param $value_2 i32)
    (result i32)
<span epub:type="pagebreak" title="15" id="Page_15"/>        local.get $value_1
        local.get $value_2
        i32.add
    )
)</code></pre>
<p class="CodeListingCaption"><a id="listing1-8">Listing 1-8</a>: WebAssembly module with a function that adds two integers</p>
<p>By now, you should be able to understand this code. Take some time to look it over until you’re comfortable with the logic. This is a straightforward WebAssembly module with a single function <code>AddInt</code> that we export to the embedding environment. Now compile <em>AddInt.wat</em> into <em>AddInt.wasm</em> using <code>wat2wasm</code>, as shown in <a href="#listing1-9" id="listinganchor1-9">Listing 1-9</a>.</p>
<pre><code>wat2wasm AddInt.wat</code></pre>
<p class="CodeListingCaption"><a id="listing1-9">Listing 1-9</a>: Compiling <em>AddInt.wat</em> into <em>AddInt.wasm</em></p>
<p>Now we’re ready to write the JavaScript portion of our first Node.js app.</p>
<h3 id="h2-501737c01-0011">Calling the WebAssembly Module from Node.js</h3>
<p class="BodyFirst">We can call the WebAssembly module from Node.js using JavaScript. Create a file called <em>AddInt.js</em> and add the JavaScript code in <a href="#listing1-10" id="listinganchor1-10">Listing 1-10</a>.</p>
<p class="CodeLabel"><b>AddInt.js</b></p>
<pre><code><span class="CodeAnnotationHang" aria-label="annotation1">1</span> const fs = require ('fs');
const bytes = fs.readFileSync (__dirname + '/AddInt.wasm');
<span class="CodeAnnotationHang" aria-label="annotation2">2</span> const value_1 = parseInt (process.argv[2]);
const value_2 = parseInt (process.argv[3]);

<span class="CodeAnnotationHang" aria-label="annotation3">3</span> (async () =&gt; {
<span class="CodeAnnotationCode" aria-label="annotation4">4</span> const obj = await WebAssembly.instantiate (
                                new Uint8Array (bytes));
<span class="CodeAnnotationCode" aria-label="annotation5">5</span> let add_value = obj.instance.exports.AddInt( value_1, value_2 );
<span class="CodeAnnotationCode" aria-label="annotation6">6</span> console.log(`${value_1} + ${value_2} = ${add_value}`);
})();</code></pre>
<p class="CodeListingCaption"><a id="listing1-10">Listing 1-10</a>:  Calling the <code>AddInt</code> WebAssembly function from an asynchronous IIFE</p>
<p>Node.js can read the WebAssembly file directly from the hard drive where the application is running using the built-in module called <code>fs</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> that reads files from local storage. We load this module using Node.js’s <code>require</code> function. We use the <code>fs</code> module to read in the <em>AddInt.wasm</em> file using the <code>readFileSync</code> function. We also take in two arguments from the command line using the <code>process.argv</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> array. The <code>argv</code> array has all the arguments passed in from the command line to Node.js. We’ll run the function from the command line; <code>process.argv[0]</code> will contain the command <code>node</code> and <code>process.argv[1]</code> will contain the name of the JavaScript file <em>AddInt.js</em>. When we run the program, we pass in two numbers on the command line, which will set <code>process.argv[2]</code> and <code>process.argv[3]</code>. </p>
<p>We use an asynchronous <em>immediately invoked function expression (IIFE)</em> to instantiate the WebAssembly module, call the WebAssembly function, and output the results to the console. For those unfamiliar with the <span epub:type="pagebreak" title="16" id="Page_16"/>IIFE syntax, it’s a means by which JavaScript is able to wait for a promise before executing the rest of the code. When you do tasks like instantiate a WebAssembly module, it takes time, and you don’t want to tie up the browser or node while waiting for that process to finish. The <code>(async () =&gt; {})();</code> <span class="CodeAnnotation" aria-label="annotation3">3</span> syntax tells the JavaScript engine that there is a promise object coming, so go do something else while waiting for the result. Inside the IIFE, we call <code>WebAssembly.instantiate</code> <span class="CodeAnnotation" aria-label="annotation4">4</span> passing the <code>bytes</code> we retrieved from the WebAssembly file earlier with the call to <code>readFileSync</code>. After instantiating the module, we call the <code>AddInt</code> <span class="CodeAnnotation" aria-label="annotation5">5</span> function exported from the WAT code. We then call a <code>console.log</code> <span class="CodeAnnotation" aria-label="annotation6">6</span> statement to output the values we’re adding and the result.</p>
<p>Now that we have the WebAssembly module and the JavaScript file, we can run the app from the command line using the call to Node.js, as shown in <a href="#listing1-11" id="listinganchor1-11">Listing 1-11</a>.</p>
<pre><code>node AddInt.js 7 9</code></pre>
<p class="CodeListingCaption"><a id="listing1-11">Listing 1-11</a>: Running <em>AddInt.js</em> using Node.js</p>
<p>Running that command results in the following output:</p>
<pre><code>7 + 9 = 16</code></pre>
<p>The addition of the two integers happens in WebAssembly. Before we move on, we’ll quickly show you how to use the <code>.then</code> syntax as an alternative to the asynchronous IIFE.</p>
<h3 id="h2-501737c01-0012">The .then Syntax</h3>
<p class="BodyFirst">The other widely used syntax to wait for the return of promises is the <code>.then</code> syntax. We prefer to use the IIFE syntax in <a href="#listing1-10">Listing 1-10</a>, but either syntax is perfectly acceptable. </p>
<p>Create a file called <em>AddIntThen.js</em> and add the code in <a href="#listing1-12" id="listinganchor1-12">Listing 1-12</a> to replace the asynchronous IIFE syntax in <a href="#listing1-10">Listing 1-10</a> with the <code>.then</code><code> </code>code.</p>
<p class="CodeLabel"><b>AddIntThen.js</b></p>
<pre><code>const fs = require ('fs');
const bytes = fs.readFileSync (__dirname + '/AddInt.wasm');
const value_1 = parseInt (process.argv[2]);
const value_2 = parseInt (process.argv[3]);

<span class="CodeAnnotationCode" aria-label="annotation1">1</span> WebAssembly.instantiate (new Uint8Array (bytes))
<span class="CodeAnnotationCode" aria-label="annotation2">2</span> .then (obj =&gt; {
    let add_value = obj.instance.exports.AddInt(value_1, value_2);
    console.log(`${value_1} + ${value_2} = ${add_value}`);
  });</code></pre>
<p class="CodeListingCaption"><a id="listing1-12">Listing 1-12</a>: Using the <code>.then</code> syntax to call a WebAssembly function</p>
<p>The primary difference here lies in the <code>WebAssembly.instantiate</code> <span class="CodeAnnotation" aria-label="annotation1">1</span> function, followed by <code>.then</code> <span class="CodeAnnotation" aria-label="annotation2">2</span>, and containing an arrow function callback that passes in an object <code>obj</code>. </p>
<h2 id="h1-501737c01-0006"><span epub:type="pagebreak" title="17" id="Page_17"/>The Time Is Now</h2>
<p class="BodyFirst">Now is a great time to learn WAT. At the time of writing this, the current release of WebAssembly 1.0 has a relatively small instruction set with a total of 172 different opcodes in the WebAssembly binary, although you don’t need to remember all of them. WebAssembly supports four different data types: <code>i32</code>, <code>i64</code>, <code>f32</code>, and <code>f64</code>, and many of the opcodes are duplicate commands for each type (for example, <code>i32.add</code><code> </code>and <code>i64.add</code>). If you eliminate the duplicate opcodes, you only need to know about 50 different mnemonics to know the entire language. The number of opcodes supported by WebAssembly will increase over time. Starting WebAssembly now in its early days gives you a leg up. In the future, remembering every opcode will become difficult or impossible.</p>
<p>As mentioned earlier, writing your modules in WAT is the best way to work as close to the metal as possible within a web browser. The way JavaScript is implemented in the browser today can create performance inconsistencies depending on a wide variety of factors. WebAssembly can eliminate these inconsistencies, and WAT can help you streamline your code to make it as fast as possible.</p>
<p>You can use a toolchain like Emscripten with only a minimal understanding of the WebAssembly platform. However, using the toolchains this way might result in minimal performance improvements in your application and mislead you to conclude that WebAssembly isn’t worth the effort. You would be wrong. If you want to get the highest possible performance from your web application, you must learn as much as you can about WebAssembly. You need to know what it can and cannot do. You must understand what it’s good at and what you should do in JavaScript. The best way to gain this knowledge is to write WAT code. In the end, you might not write your application in WAT, but knowing the language helps you comprehend WebAssembly and the web browser.</p>
</section>
</div></body></html>