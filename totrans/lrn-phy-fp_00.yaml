- en: INTRODUCTION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: One of the best ways to learn something is to teach it. It is invaluable to
    have a person who is willing to listen to what we say, to read what we write,
    and to respond. Knowing that someone is listening or reading encourages us to
    spend time and effort creating something of quality. And if our writing incites
    a response, so much the better, for we have started a conversation that might
    challenge us to sharpen our understanding.
  prefs: []
  type: TYPE_NORMAL
- en: A pleasant and productive way to learn physics is to teach a computer how to
    do it. We admit up front that the computer is not as rich a listener as a person
    and cannot provide the depth or breadth of response to our writing that a person
    can. On the other hand, the computer is very attentive, willing to listen incessantly,
    and unwilling to accept statements unless they are expressed in clear language
    and make sense. The computer can provide us with a useful response because it
    will happily calculate what we ask it to calculate, and it will quickly tell us
    if what we just said makes no sense (and hopefully give us a clue about why it
    makes no sense).
  prefs: []
  type: TYPE_NORMAL
- en: This book is about learning basic theoretical physics by teaching a computer
    how to do it. We will spend a substantial amount of time with Newton’s second
    law. We will focus on the concept of the *state* of a physical system and see
    that Newton’s second law is the core rule for describing how the state changes
    in time. We will study basic electromagnetic theory, asking the computer to calculate
    electric and magnetic fields produced by charge and current distributions. The
    point is to deepen our understanding of physics by approaching it from a new angle,
    with a new language. The language we will use is precise and will help to clarify
    our thinking.
  prefs: []
  type: TYPE_NORMAL
- en: Who This Book Is For
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This book arises from a course in computational physics I teach to second-year
    students of physics at Lebanon Valley College. I expect that you have had one
    year of introductory physics and at least one semester of calculus. No previous
    programming experience is required. The purpose of the book is to deepen your
    understanding of basic physics by exploring it in a new language. By using a formal
    language to express the ideas of physics, we will stretch our ability to formulate
    and communicate the ideas of physics as we also calculate quantities we are interested
    in and make graphs and animations.
  prefs: []
  type: TYPE_NORMAL
- en: Because the book begins with a self-contained introduction to the Haskell programming
    language for people who have not programmed before, it can be used as a supplement
    for introductory and intermediate courses in physics in which the instructor or
    student
  prefs: []
  type: TYPE_NORMAL
- en: wishes to include a computational component, or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: desires a deeper understanding of the structure of basic physical theories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The book is also appropriate for self-study by any student who wishes to deepen
    their understanding of physics by programming.
  prefs: []
  type: TYPE_NORMAL
- en: Why Functional Programming, and Why Haskell?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many scientists, after learning their second programming language, develop the
    idea that all programming languages are more or less the same and that the difference
    between languages is mainly one of syntax. Scientists are busy people, and they
    have their work to do, so perhaps they can be excused for choosing not to dive
    into the sea of available programming languages to learn the more complex truth
    that languages can differ on a semantic level and can have profound effects on
    the way a person thinks about the problem they are writing code to solve. The
    style of programming called *functional programming* grows from a different branch
    of the programming language tree than object-oriented programming, and the two
    do not mix well together. Neither is clearly better for all applications.
  prefs: []
  type: TYPE_NORMAL
- en: Physics can be encoded in any programming language. Why use a functional language
    instead of a more mainstream object-oriented language? Beauty and power are to
    be found more in verbs than in nouns. Newton found beauty and power not in the
    world per se, but in the description of how the world changes. Functional programming
    found beauty and power not in objects but in the functions that take objects as
    input and produce objects as output, and in the notion that such objects might
    themselves be functions. Haskell is a good programming language for learning physics
    for two reasons. First, Haskell is a functional programming language. This means
    that functions play a central role in the language, including functions that take
    other functions as arguments and return functions as results. Many physical ideas
    are naturally expressed in the language of higher-order functions. Second, Haskell’s
    type system provides a clean way to organize our thinking about the physical quantities
    and procedures of interest in physics. I know of no better way to clarify my thinking
    than expressing my ideas in functional language.
  prefs: []
  type: TYPE_NORMAL
- en: About This Book
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This book is composed of three parts. The first part is an introduction to functional
    programming in general and Haskell in particular, aimed at people who have never
    programmed before. The second part shows how to use a functional language to express
    Newton’s second law, and consequently to solve mechanics problems. The third part
    aims at electromagnetic theory, showing how Faraday and Maxwell’s ideas can be
    expressed in functional language, and how problems that involve electric and magnetic
    fields can be solved. Throughout, we’ll see how functional language is close to
    mathematics; how it’s really a form of mathematics that computers can understand.
    Many of the deep ideas of physics that are so eloquently and succinctly expressed
    in mathematical language find beautiful expression in functional language as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The book includes the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Part I: The Haskell Language](part01.xhtml)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 1: Calculating with Haskell](ch01.xhtml)** This chapter is all about
    how to use Haskell as a calculator. Basic mathematical operations are built into
    Haskell, and these are immediately available to do calculations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 2: Writing Basic Functions](ch02.xhtml)** Here we begin writing
    functions. Haskell functions are very much like mathematical functions. The simplest
    Haskell functions take a number as input and produce a number as output. As you
    might guess, functions play a central role in functional programming languages.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 3: Types and Entities](ch03.xhtml)** This chapter introduces the
    idea of types. The entities, such as numbers and functions, with which Haskell
    deals are classified into types; every entity has a type. Types guide our thinking
    about what can be done with an entity. Real numbers can be squared, for example,
    but it doesn’t always make sense to square a function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 4: Describing Motion](ch04.xhtml)** Here we look at how the motion
    of a particle in one dimension is described in Haskell. We introduce position,
    velocity, and acceleration, and we notice how these quantities are related by
    the notion of a derivative from calculus.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 5: Working with Lists](ch05.xhtml)** This chapter discusses lists
    in Haskell. Lists can be lists of numbers, lists of functions, or lists of more
    complicated things. After functions, lists are probably the most important structures
    in functional programming because they are used in the process of iteration (doing
    something over and over again).'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 6: Higher-Order Functions](ch06.xhtml)** This chapter introduces
    higher-order functions, which are functions that take other functions as input
    or produce functions as output. Higher-order functions are central to the power
    and concision of functional languages. We give examples of how higher-order functions
    naturally appear in physics.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 7: Graphing Functions](ch07.xhtml)** This chapter shows how to graph
    a function such as the cosine function or a function that you define that takes
    numbers as input and produces numbers as output.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 8: Type Classes](ch08.xhtml)** Here we introduce type classes in
    Haskell. Type classes own functions that need to be able to work with some, but
    not all, types. Equality checking is such a function. We want to be able to check
    equality of numbers, equality of lists, and equality of other things. The equality
    checking function is owned by a type class.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 9: Tuples and Type Constructors](ch09.xhtml)** This chapter introduces
    tuples, a structure that holds two or more objects. This chapter also discusses
    type constructors, which are functions at the type level (in other words, functions
    that take a type as input and produce a type as output).'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 10: Describing Motion in Three Dimensions](ch10.xhtml)** This chapter
    is similar in outlook to [Chapter 4](ch04.xhtml) in that it focuses on a particular
    need that physics has (in this case, a need for vectors) and shows how that need
    is satisfied in the Haskell language.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 11: Creating Graphs](ch11.xhtml)** Here we return to the topic of
    making graphs, first broached in [Chapter 7](ch07.xhtml), and include more detail
    about how to make pleasing and informative graphs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 12: Creating Stand-Alone Programs](ch12.xhtml)** In the beginning
    of the book, we interact with Haskell primarily through the GHCi interactive compiler.
    Later in the book, when we start doing animation, we make stand-alone programs.
    This chapter shows several ways to produce stand-alone programs.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 13: Creating 2D and 3D Animations](ch13.xhtml)** This chapter introduces
    animation, showing how to make simple 2D and 3D animations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Part II: Newtonian Mechanics](part02.xhtml)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 14: Newton’s Second Law and Differential Equations](ch14.xhtml)**
    Here we introduce Newton’s first and second laws. We learn how to solve a limited
    class of mechanics problems in one spatial dimension. We also learn why some mechanics
    problems are easy to solve and others are difficult. It comes down to what the
    forces depend on. This chapter covers situations of increasing complexity, starting
    with constant forces and ending with forces that depend on time and the particle’s
    velocity. This chapter introduces the concept of differential equations, and we
    write code capable of solving a first-order differential equation.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 15: Mechanics in One Dimension](ch15.xhtml)** This chapter continues
    the path of increasing complexity, looking at forces that depend on time, position,
    and velocity. Such situations lead to a second-order differential equation, which
    we solve by introducing state variables.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 16: Mechanics in Three Dimensions](ch16.xhtml)** Here we return
    to the vector setting first seen in [Chapter 10](ch10.xhtml), completing the theory
    of the mechanics of a single object. We show how to express and solve Newton’s
    second law for a single particle in three dimensions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 17: Satellite, Projectile, and Proton Motion](ch17.xhtml)** This
    chapter gives three extended examples, applying the ideas and tools developed
    in the previous chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 18: A Very Short Primer on Relativity](ch18.xhtml)** This chapter
    shows what mechanics looks like if we embrace the ideas of special relativity
    in favor of those of Newton. We see that many of our tools survive the transition,
    enabling us to solve problems in relativity.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 19: Interacting Particles](ch19.xhtml)** This chapter introduces
    Newton’s third law, which is needed when we care about more than one object. We
    develop a theory of interacting particles and express the key ideas in Haskell.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 20: Springs, Billiard Balls, and a Guitar String](ch20.xhtml)**
    This chapter gives three extended examples of interacting particles in which we
    use the ideas and tools of [Chapter 19](ch19.xhtml). Having dealt with the mechanics
    of arbitrarily many interacting particles in three dimensions, our treatment of
    Newtonian mechanics is complete.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Part III: Electromagnetic Theory](part03.xhtml)**'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 21: Electricity](ch21.xhtml)** This chapter looks at the old electric
    theory of Coulomb, in which electricity is simply a force on charged particles
    produced by other charged particles, similar in spirit to Newtonian gravity. Coulomb’s
    electricity does not use the electric field.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 22: Coordinate Systems and Fields](ch22.xhtml)** Here we introduce
    the key idea of a field, which is a function of space—a quantity that can have
    a different value at each position in space. This chapter also introduces Cartesian,
    cylindrical, and spherical coordinates for three-dimensional space.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 23: Curves, Surfaces, and Volumes](ch23.xhtml)** This chapter discusses
    how we can describe curves, surfaces, and volumes in the Haskell language.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 24: Electric Charge](ch24.xhtml)** This chapter covers electric
    charge, the quantity responsible for electrical phenomena, and the different kinds
    of charge distributions.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 25: Electric Field](ch25.xhtml)** This chapter describes how electric
    charge produces an electric field, beginning our study of modern Faraday-Maxwell
    electromagnetic theory in which electric and magnetic fields play such a crucial
    role.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 26: Electric Current](ch26.xhtml)** This chapter discusses electric
    current and current distributions, paralleling the discussion of charge in [Chapter
    24](ch24.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 27: Magnetic Field](ch27.xhtml)** This chapter describes how current
    produces a magnetic field, paralleling [Chapter 25](ch25.xhtml) in that charge
    is to electric field as current is to magnetic field, at least in static situations.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 28: The Lorentz Force Law](ch28.xhtml)** While [Chapters 24](ch24.xhtml)
    through [27](ch27.xhtml) deal with the aspect of electromagnetic theory in which
    charge creates fields, this chapter discusses the second aspect of electromagnetic
    theory, in which fields exert forces on charge. The Lorentz force law describes
    this second aspect.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Chapter 29: The Maxwell Equations](ch29.xhtml)** This chapter presents the
    Maxwell equations, in which the first aspect of electromagnetic theory reaches
    its full sophistication, and we see how electric and magnetic fields are dynamic
    quantities, interacting and changing in time. Although there are many situations
    and applications we won’t discuss, the Maxwell equations and the Lorentz force
    law give a complete description of modern electromagnetic theory—a theory important
    not just for explaining electricity, magnetism, and light, but also for serving
    as the prototype for present-day theories of elementary particle physics.'
  prefs: []
  type: TYPE_NORMAL
- en: '**[Appendix: Installing Haskell](app.xhtml)** This appendix shows how to install
    the Haskell compiler and software libraries we will use.'
  prefs: []
  type: TYPE_NORMAL
- en: This book has been a labor of love, meaning that my motivation for writing it
    comes from a love of the ideas presented and a desire to share them. I hope that
    I have created a beautiful book, but even more than that, I hope that this book
    helps you to express beautiful ideas with beautiful code. Enjoy!
  prefs: []
  type: TYPE_NORMAL
