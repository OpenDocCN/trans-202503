["```\n1\\. chop vegetables\n2\\. boil water\n3\\. chop chicken\n4\\. brown chicken\n5\\. add vegetables to pot\n6\\. add chicken to pot\n7\\. simmer pot\n8\\. chop herbs...\n```", "```\na:     dd 4, 3\nb:     dd 1, 5\nmain:\n       movd   mm0, [a]\n       movd   mm1, [b]\n       paddd  mm0, mm1\n```", "```\n;from en.wikibooks.org/wiki/X86_Assembly/SSE, CC BY 3\nsection .data\n    v1: dd 1.1, 2.2, 3.3, 4.4    ; first set of four numbers\n    v2: dd 5.5, 6.6, 7.7, 8.8    ; second set\n\nsection .bss\n    v3: resd 4    ; result\n\nsection .text\n    _start:\n\n    movups xmm0, [v1]   ; load v1 into xmm0\n    movups xmm1, [v2]   ; load v2 into xmm1\n\n    addps xmm0, xmm1    ; add\n    mulps xmm0, xmm1    ; multiply\n    subps xmm0, xmm1    ; subtract\n    movups [v3], xmm0   ; store result in v3\n\n    ret\n```", "```\n    v1: dd 0.50, 0.25, 0.125, 0.0625, 0.03125, 0.015625, 0.0078125, 0.00390625\n    v2: dd 2.0, 4.0, 8.0, 16.0, 32.0, 64.0, 128.0, 256.0\n    v3: dd 0, 0, 0, 0, 0, 0, 0, 0\nmain:\n    vmovups ymm0, [v1]\n    vmovups ymm1, [v2]\n    vaddpd ymm3, ymm1, ymm2\n    vmovups [v3], ymm3\n```", "```\n       mov.u32          %r1, %tid.x;       // r1 := my threadID\n       cvt.rn.f64.s32   %fd1, %r1;         // convert threadID to float\n       mul.wide.s32     %rd4, %r1, 8;      // id times 8 = address offset\n       add.s64          %rd5, %rd3, %rd4;  // global address to store result\n       st.global.f64    [%rd5], %fd1;      // store threadID in result address\n       ret;\n```", "```\n      mov.u32        %r1, %tid.x;    // r1 := my thread ID (an int)\n      cvt.rn.f64.s32 %fd4, %r1;      // fd4 := convert threadID to doublefloat\n\n      setp.lt.s32    %p1, %r1, 4;    // set predicate1 to \"threadID is less than 4\"\n\n      // lines starting @%p1 only execute if predicate1 is true\n@%p1 mov.f64         %fd2, 0d4008CCCCCCCCCCCD; // load doublefloat 3.1 to fd2\n@%p1 add.f64         %fd1, %fd2, %fd4;         // and add it to the id\n      // lines starting @!%p1 only execute if predicate1 is false\n@!%p1 mov.f64        %fd3, 0d4024000000000000; // load float 10.0 to fd3\n@!%p1 mul.f64        %fd1, %fd3, %fd4;         // and multiply it by thread ID\n\n      mul.wide.s32   %rd4, %r1, 8;     // id times 8 = address offset\n      add.s64        %rd5, %rd3, %rd4; // global address to store result\n      st.global.f64  [%rd5], %fd1;     // result address := fd1\n      ret;\n```", "```\n3.1, 4.1, 5.1, 6.1, 40.0, 50.0, 60.0\\. 70.0, 80.0, 90.0 --snip--\n```", "```\nmov.u32          %r4, %ctaid.x;      //r4:=which subgroup is this?\nmov.u32          %r2, %ntid.x;       //r2:=subgroup size\nmov.u32          %r3, %tid.x;        //as well as the usual local thread ID\nmad.lo.s32       %r1, %r2, %r4, %r3; //compute the global job ID as\n                                     // jobID = r1 := r2 x r4 + r3\ncvt.rn.f64.s32   %fd1, %r1;          //fd1 := convert global jobID to float\n\nmul.wide.s32     %rd4, %r1, 8;       //id times 8 = address offset\nadd.s64          %rd5, %rd3, %rd4;   //global address to store result\nst.global.f64    [%rd5], %fd1;       //store threadID in result address\nret;\n```", "```\n      mov.u32        %r1, %tid.x;       //r1 := thread ID\n      mov.u32        %r2, 0;            //r2 = i = input counter := 0\n      mov.f64        %fd1, 0d0000000000000000; //cumsum:=doublefloat(0)\n      mul.wide.s32   %rd4, %r1, 8;\n  //id x 8 = addr offset from threadID\nMYLOOP:\n      mul.wide.s32   %rd5, %r2, 8;      //i times 8\n                                        //=adr offset from conv iteration\n      add.s64        %rd8, %rd1, %rd4;  //rd8:=adr of id-th element of\n                                        // x=&x+jobIDoffset\n      add.s64        %rd8, %rd8, %rd5;  // + convoffset\n      ld.global.f64 %fd3, [%rd8];       //fd3:=x_(job+i)\n\n      add.s64        %rd9, %rd2, %rd4;  //rd9:=adr of id-th element of\n                                        // w=&w+convoffset\n      ld.global.f64 %fd2, [%rd9];       //fd2:=w_i\n      mul.f64       %fd4, %fd3, %fd2;   //fd4:=x_(job+i) * w_i\n      add.f64       %fd1, %fd1, %fd4;   //cumsum += fd4\n\n      add.u32       %r2, %r2, 1;        //i++\n      setp.ne.s32   %p1, %r2, 10;       //test if i==10\n@%p1 bra   MYLOOP;                  //stop if so, else loop, using pred guard\n      //reLU\n      setp.lt.f64   %p0, %fd1, 0d3DA5FD7FE1796495; //pred0:=(cumsum<double 0)\n@%p0 mov.f64        %fd1, 0d3DA5FD7FE1796495;      //predicate guard:\n                                                   // if p0, cumsum:=0\n      add.s64       %rd5, %rd3, %rd4;    //global address to store result\n      st.global.f64 [%rd5], %fd1;        //store cumsum in result address\n      ret;\n```", "```\n0000 MOV R1, c[0][28] ;                00000a0000017a02  003fde0000000f00\n0010 MOV R2, 160 ;                     0000016000027802  003fde0000000f00\n0020 LDC.64 R2, c[0][R2] ;             0000000002027b82  00321e0000000a00\n0030 MOV R12, R2 ;                     00000002000c7202  003fde0000000f00\n0040 MOV R13, R3 ;                     00000003000d7202  003fde0000000f00\n0050 MOV R12, R12 ;                    0000000c000c7202  003fde0000000f00\n0060 MOV R13, R13 ;                    0000000d000d7202  003fde0000000f00\n0070 MOV R2, 168 ;                     0000016800027802  003fde0000000f00\n0080 LDC.64 R2, c[0][R2] ;             0000000002027b82  00321e0000000a00\n0090 MOV R10, R2 ;                     00000002000a7202  003fde0000000f00\n00a0 MOV R11, R3 ;                     00000003000b7202  003fde0000000f00\n00b0 MOV R10, R10 ;                    0000000a000a7202  003fde0000000f00\n00c0 MOV R11, R11 ;                    0000000b000b7202  003fde0000000f00\n00d0 MOV R2, 170 ;                     0000017000027802  003fde0000000f00\n00e0 LDC.64 R2, c[0][R2] ;             0000000002027b82  00321e0000000a00\n00f0 MOV R8, R2 ;                      0000000200087202  003fde0000000f00\n0100 MOV R9, R3 ;                      0000000300097202  003fde0000000f00\n0110 MOV R8, R8 ;                      0000000800087202  003fde0000000f00\n0120 MOV R9, R9 ;                      0000000900097202  003fde0000000f00\n0130 MOV R12, R12 ;                    0000000c000c7202  003fde0000000f00\n0140 MOV R13, R13 ;                    0000000d000d7202  003fde0000000f00\n0150 MOV R10, R10 ;                    0000000a000a7202  003fde0000000f00\n0160 MOV R11, R11 ;                    0000000b000b7202  003fde0000000f00\n0170 MOV R8, R8 ;                      0000000800087202  003fde0000000f00\n0180 MOV R9, R9 ;                      0000000900097202  003fde0000000f00\n0190 S2R R4, SR_TID.X ;                0000000000047919  00321e0000002100\n01a0 MOV R4, R4 ;                      0000000400047202  003fde0000000f00\n01b0 MOV R0, RZ ;                      000000ff00007202  003fde0000000f00\n01c0 CS2R R2, SRZ ;                    0000000000027805  003fde000001ff00\n01d0 IMAD.WIDE R4, R4, 8, RZ ;         0000000804047825  003fde00078e02ff\n01e0 MOV R14, R4 ;                     00000004000e7202  003fde0000000f00\n01f0 MOV R15, R5 ;                     00000005000f7202  003fde0000000f00\n0200 MOV R14, R14 ;                    0000000e000e7202  003fde0000000f00\n0210 MOV R15, R15 ;                    0000000f000f7202  003fde0000000f00\n0220 MOV R12, R12 ;                    0000000c000c7202  003fde0000000f00\n0230 MOV R13, R13 ;                    0000000d000d7202  003fde0000000f00\n0240 MOV R10, R10 ;                    0000000a000a7202  003fde0000000f00\n0250 MOV R11, R11 ;                    0000000b000b7202  003fde0000000f00\n0260 MOV R8, R8 ;                      0000000800087202  003fde0000000f00\n0270 MOV R9, R9 ;                      0000000900097202  003fde0000000f00\n0280 MOV R0, R0 ;                      0000000000007202  003fde0000000f00\n0290 MOV R2, R2 ;                      0000000200027202  003fde0000000f00\n02a0 MOV R3, R3 ;                      0000000300037202  003fde0000000f00\n02b0 IMAD.WIDE R4, R0, 8, RZ ;         0000000800047825  003fde00078e02ff\n02c0 MOV R6, R4 ;                      0000000400067202  003fde0000000f00\n02d0 MOV R7, R5 ;                      0000000500077202  003fde0000000f00\n02e0 IADD3 R4, P0,R12, R14, RZ;        0000000e0c047210  003fde0007f1e0ff\n02f0 IADD3.X R5,R13,R15,RZ,P0,!PT;     0000000f0d057210  003fde00007fe4ff\n0300 IADD3 R4, P0, R4, R6, RZ ;        0000000604047210  003fde0007f1e0ff\n0310 IADD3.X R5,R5,R7,RZ,P0,!PT;       0000000705057210  003fde00007fe4ff\n0320 MOV R4, R4 ;                      0000000400047202  003fde0000000f00\n0330 MOV R5, R5 ;                      0000000500057202  003fde0000000f00\n0340 MOV R4, R4 ;                      0000000400047202  003fde0000000f00\n0350 MOV R5, R5 ;                      0000000500057202  003fde0000000f00\n0360 LDG.E.64.SYS R4, [R4] ;           0000000004047381  00321e00001eeb00\n0370 IADD3 R6, P0, R10, R14, RZ;       0000000e0a067210  003fde0007f1e0ff\n0380 IADD3.X R7,R11,R15,RZ,P0,!PT;     0000000f0b077210  003fde00007fe4ff\n0390 MOV R6, R6 ;                      0000000600067202  003fde0000000f00\n03a0 MOV R7, R7 ;                      0000000700077202  003fde0000000f00\n03b0 MOV R6, R6 ;                      0000000600067202  003fde0000000f00\n03c0 MOV R7, R7 ;                      0000000700077202  003fde0000000f00\n03d0 LDG.E.64.SYS R6, [R6] ;           0000000006067381  00321e00001eeb00\n03e0 DMUL R4, R4, R6 ;                 0000000604047228  00321e0000000000\n03f0 DADD R2, R2, R4 ;                 0000000002027229  00321e0000000004\n0400 IADD3 R0, R0, 1, RZ ;             0000000100007810  003fde0007ffe0ff\n0410 ISETP.NE.AND P0,PT,R0,a,PT;       0000000a0000780c  003fde0003f05270\n0420 MOV R2, R2 ;                      0000000200027202  003fde0000000f00\n0430 MOV R3, R3 ;                      0000000300037202  003fde0000000f00\n0440 MOV R0, R0 ;                      0000000000007202  003fde0000000f00\n0450 @P0 BRA 2b0 ;                     fffffe5000000947  003fde000383ffff\n0460 DSETP.LT.AND P0,PT,R2,c[2][0],PT; 008000000200762a  00321e0003f01000\n0470 MOV R4, e1796495 ;                e179649500047802  003fde0000000f00\n0480 MOV R5, 3da5fd7f ;                3da5fd7f00057802  003fde0000000f00\n0490 MOV R0, R4 ;                      0000000400007202  003fde0000000f00\n04a0 MOV R4, R5 ;                      0000000500047202  003fde0000000f00\n04b0 MOV R5, R2 ;                      0000000200057202  003fde0000000f00\n04c0 MOV R2, R3 ;                      0000000300027202  003fde0000000f00\n04d0 FSEL R0, R0, R5, P0 ;             0000000500007208  003fde0000000000\n04e0 FSEL R2, R4, R2, P0 ;             0000000204027208  003fde0000000000\n04f0 MOV R3, R2 ;                      0000000200037202  003fde0000000f00\n0500 MOV R2, R0 ;                      0000000000027202  003fde0000000f00\n0510 IADD3 R4, P0, R8, R14, RZ ;       0000000e08047210  003fde0007f1e0ff\n0520 IADD3.X R5,R9,R15,RZ,P0,!PT;      0000000f09057210  003fde00007fe4ff\n0530 MOV R4, R4 ;                      0000000400047202  003fde0000000f00\n0540 MOV R5, R5 ;                      0000000500057202  003fde0000000f00\n0550 MOV R4, R4 ;                      0000000400047202  003fde0000000f00\n0560 MOV R5, R5 ;                      0000000500057202  003fde0000000f00\n0570 STG.E.64.SYS [R4], R2 ;           0000000204007386  0033de000010eb00\n0580 MOV R2, R2 ;                      0000000200027202  003fde0000000f00\n0590 MOV R3, R3 ;                      0000000300037202  003fde0000000f00\n05a0 EXIT ;                            000000000000794d  003fde0003800000\n05b0 BRA 5b0;                          fffffff000007947  000fc0000383ffff\n```", "```\n__global__ void myKernel(double *x, double *w, double *out) {\n    int id = threadIdx.x;   //get my ID\n    out[id] = x[id] + w[id];\n}\n```", "```\n> nvcc -arch=sm_75 -ptx kernel.cu\n```", "```\nEntryPoint Kernel 9\nMemoryModel Physical64 OpenCL1.2\nName 4 \"LocalInvocationId\"\nName 9 \"add\"\nName 10 \"in1\"\nName 11 \"in2\"\nName 12 \"out\"\nName 13 \"entry\"\nName 15 \"call\"\nName 16 \"arrayidx\"\nName 18 \"arrayidx1\"\nName 20 \"add\"\nName 21 \"arrayidx2\"\nDecorate 4(LocalInvocationId) Constant\nDecorate 4(LocalInvocationId) Built-In LocalInvocationId\nDecorate 10(in1) FuncParamAttr 5\nDecorate 11(in2) FuncParamAttr 5\nDecorate 12(out) FuncParamAttr 5\nDecorate 17 Alignment 4\nDecorate 19 Alignment 4\nDecorate 22 Alignment 4\n1: TypeInt 64 0\n2: TypeVector 1(int) 3\n3: TypePointer UniformConstant 2(ivec3)\n5: TypeVoid\n6: TypeInt 32 0\n7: TypePointer WorkgroupGlobal 6(int)\n8: TypeFunction 5 7(ptr) 7(ptr) 7(ptr)\n4(LocalInvocationId): 3(ptr) Variable UniformConstant\n9(add): 5 Function NoControl 8\n10(in1): 7(ptr) FunctionParameter\n11(in2): 7(ptr) FunctionParameter\n12(out): 7(ptr) FunctionParameter\n13(entry): Label\n14: 2(ivec3) Load 4(LocalInvocationId)\n15(call): 1(int) CompositeExtract 14 0\n16(arrayidx): 7(ptr) InBoundsAccessChain 10(in1) 15(call)\n17: 6(int) Load 16(arrayidx)\n18(arrayidx1): 7(ptr) InBoundsAccessChain 11(in2) 15(call)\n19: 6(int) Load 18(arrayidx1)\n20(add): 6(int) IAdd 19 17\n21(arrayidx2): 7(ptr) InBoundsAccessChain 12(out) 15(call)\nStore 22 21(arrayidx2) 20\nReturn\nFunctionEnd\n```", "```\n#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n__kernel void vecAdd( __global double *a,\n__global double *b,\n__global double *c,\nconst unsigned int n) {\n  int id = get_global_id(0);\n  if (id < n)\n    c[id] = a[id] + b[id];\n}\n```", "```\nprecision mediump float;       // default precision to medium\nuniform vec3 u_LightPos;       // the position of the light in eye space\nvarying vec3 v_Position;       // interpolated position for this fragment\nvarying vec4 v_Color;          // color interpolated across the triangle\nvarying vec3 v_Normal;         // interpolated normal for this fragment\nvoid main() {\n    float distance = length(u_LightPos - v_Position);\n    vec3 lightVector = normalize(u_LightPos - v_Position);\n    float diffuse = max(dot(v_Normal, lightVector), 0.1);\n    diffuse = diffuse*(1.0/(1.0+(0.25*distance*distance))); //attenuation\n    gl_FragColor = v_Color * diffuse;\n}\n```", "```\ndata = [1,2,3,4]\nfor i in data:\n    doSomething(i)\n```", "```\nfrom multiprocessing import Pool\ndata = [1,2,3,4]\npool(4).map(doSomething , data)\n```", "```\n    // directives to tell the assembler what versions to use\n    .version 7.1\n    .target sm_75\n    .address_size 64\n    // this describes how the code will interface with C code on the host\n    .visible .entry _Z8myKernelPdS_S_(\n        .param .u64 _Z8myKernelPdS_S__param_0,\n        .param .u64 _Z8myKernelPdS_S__param_1,\n        .param .u64 _Z8myKernelPdS_S__param_2\n    )\n    {\n        // directives to say how many registers we will be using\n        .reg .pred %p<2>;     // predicate reg\n        .reg .b32   %r<5>;    // regs of 32-bit ints\n        .reg .f64   %fd<5>;   // regs of 64-bit (double) floats\n        .reg .b64   %rd<10>;  // regs of 64-bit (double) ints\n        // generic part to load argument pointers to rd1-3 and jobID to r1\n        ld.param.u64 %rd4, [_Z8myKernelPdS_S__param_0]; //rd1:=pointer arg0\n        ld.param.u64  %rd5, [_Z8myKernelPdS_S__param_1];\n        ld.param.u64  %rd6, [_Z8myKernelPdS_S__param_2];\n        // convert address of pointers, generic to global memory\n        cvta.to.global.u64  %rd1, %rd4;   // rd1 stores global address of x\n        cvta.to.global.u64  %rd2, %rd5;   // re2 stores global address of w\n        cvta.to.global.u64  %rd3, %rd6;   // rd3 stores global address of out\n        //------put your chosen example code below------\n    }\n    ```", "```\n    > ptxas -arch=sm_75 --opt-level 0 \"mykernel.ptx\" -o \"mykernel.cubin\"\n    ```", "```\n    > cuobjdump -sass -ptx mykernel.cubin\n    ```", "```\n    #include <stdio.h>\n    #include <stdlib.h>\n    #include <math.h>\n    #include \"cuda.h\"\n    int main(int argc, char* argv[]) {\n        cuInit(0); CUcontext pctx; CUdevice dev;\n        cuDeviceGet(&dev, 0);   cuCtxCreate(&pctx, 0, dev);\n        CUmodule module; CUfunction vector_add;\n        const char* module_file = \"mykernel.cubin\"; int err;\n        err = cuModuleLoad(&module, module_file); // load cubin executable\n        const char* kernel_name = \"_Z8myKernelPdS_S_\";\n        err = cuModuleGetFunction(&vector_add, module, kernel_name);\n        int n = 100000;                  // size of vectors\n        double *h_x, *h_w, *h_out;       // host in and out vectors\n        double *d_x, *d_w, *d_out;       // device in and out vectors\n        size_t bytes = n*sizeof(double); // size, in bytes, of each vector\n        h_x=(double*)malloc(bytes);      // allocate memory for vectors on host\n        h_w=(double*)malloc(bytes);h_out=(double*)malloc(bytes);\n        // allocate memory for each vector on GPU\n        cudaMalloc(&d_x,bytes);\n        cudaMalloc(&d_w, bytes);\n        cudaMalloc(&d_out, bytes);\n        int i; for(i = 0; i < n; i++) // init host vecs to arbitrary values\n            {h_x[i] = sin(i)*sin(i); h_w[i] = cos(i)*cos(i);}\n        cudaMemcpy(d_x, h_x, bytes, cudaMemcpyHostToDevice); // device<-host\n        cudaMemcpy(d_w, h_w, bytes, cudaMemcpyHostToDevice);\n        // set arguments and launch the kernels on the GPU\n        int blockSize, gridSize;      // threads in block, blocks in grid\n        blockSize = 1024;   gridSize = (int)ceil((float)n/blockSize);\n        void *args[3] = { &d_x , &d_w, &d_out };\n        cuLaunchKernel(vector_add, gridSize,1,1, blockSize,1,1, 0,0,args,0);\n        cudaMemcpy(h_out,d_out,bytes,cudaMemcpyDeviceToHost); // host<-result\n        for(i=0; i<10; i++) printf(\"out: %f\\n\", h_out[i]);    // print result\n        cudaFree(d_x); cudaFree(d_w); cudaFree(d_out);        // free device mem\n        free(h_x); free(h_w); free(h_out); return 0;          // free host mem\n    }\n    ```", "```\n    > nvcc myptxhost.cu -lcuda\n    > ./a.out\n    ```"]