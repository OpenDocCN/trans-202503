- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication and Authorization Bypasses
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: Out of the box, GraphQL has no authentication or authorization controls. As
    a result, the ecosystem has created its own or adopted those seen in traditional
    systems. In this chapter, we’ll cover the common GraphQL authentication and authorization
    implementations. Then we’ll discuss attacks that target some of their weaknesses.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '*Authentication* is the mechanism by which a client proves their identity to
    a server. It answers the question: Is the user really who they say they are? Authentication
    attacks target a client’s identity, attempting to either steal credentials or
    spoof them to authenticate with a server, take certain actions on their behalf,
    or steal data to which they have access.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '*Authorization* controls are responsible for granting access to data and ensuring
    that the actions an entity takes, whether they’re a human or a machine, match
    their assigned roles, groups, and permissions. Authorization attacks attempt to
    either bypass a security control entirely or poke holes in it, allowing an attacker
    to take actions that wouldn’t otherwise be possible. For example, they might gain
    unauthorized access to system data or perform privileged actions, such as setting
    another user’s password.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization controls can be challenging to implement. This
    is especially true when an application creates its own mechanisms from scratch
    instead of using the many battle-tested frameworks available for specific programming
    languages. Performing security testing of such controls is also a nontrivial task;
    security tools (such as API application scanners) struggle to identify authorization
    and authentication issues. One of the primary reasons is that scanners have no
    contextual understanding of the application’s business logic.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: For years, hackers have defeated both authentication and authorization defenses
    by taking advantage of weak passwords, default credentials, forged tokens, flawed
    account recovery processes, replay attacks, and poor rate-limit controls. Not
    only is exploiting these weaknesses possible in GraphQL implementations, but,
    in many cases, GraphQL’s client-empowering features actually enable hackers to
    optimize their attacks, as you’ll soon learn.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The State of Authentication and Authorization in GraphQL
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GraphQL spec has left implementers to fend for themselves when it comes
    to authentication and authorization. This lack of a detailed standard has led
    developers to select and deploy their own GraphQL authentication and authorization
    controls from a variety of libraries, tools, and configurations, often leading
    to vulnerabilities and implementation gaps.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll sink our teeth into the ecosystem-driven authentication
    and authorization services, libraries, and plug-ins available for GraphQL. Broadly,
    these approaches follow two distinct architectural deployment models: in-band
    and out-of-band.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: In-Band vs. Out-of-Band
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In an *in-band* authentication and authorization architecture, developers implement
    client login, signup, role-based access controls, and other permission controls
    directly in the GraphQL API. The same GraphQL instance that provides clients with
    their application data also controls the logic that authenticates clients and
    grants them permissions to view data. In-band GraphQL architectures typically
    host query or mutation operations that enable clients to send credentials to the
    API. The API is responsible for verifying these credentials and then issuing tokens
    to the clients.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '*Out-of-band* authentication and authorization architectures implement the
    access control and permissions logic on either a separate internal web application
    service or an external system. In such an architecture, the GraphQL API isn’t
    responsible for managing client login, signup, or even access control. Instead,
    it offloads authorization decisions to another component, such as an API gateway,
    a container sidecar, or another server on the network. This allows developers
    to decouple the authorization logic from the GraphQL application.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Of the two architectural styles, in-band architectures tend to be more vulnerable
    to authentication and authorization attacks. Their added complexity increases
    an API’s attack surface drastically. These APIs often duplicate permission logic
    for each entry point into the service, and as you’ll see later in this chapter,
    we, as hackers, can take advantage of even the slightest misaligned control.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Thus, some contributors to the GraphQL ecosystem advocate for keeping authentication
    and authorization logic outside of GraphQL. The current industry best practice
    is to delegate authorization logic to the *business logic layer* of an application,
    which serves as the single source of truth for all business domain rules. It should
    sit between the GraphQL layer and the *persistence layer* (also known as the *database*
    or *datastore* layer), as shown in [Figure 7-1](#figure7-1).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c07/f07001.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1: The gateway, API, business, and persistence layers'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, authentication for the entire GraphQL API should occur in an external
    or third-party *gateway layer*, which passes authenticated user contexts along
    to the API.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Common Approaches
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no way to know what kinds of controls you’ll come across during your
    GraphQL hacking adventures. However, this section lists some of the common approaches
    we’ve seen in our research and testing. By understanding these techniques, you’ll
    be better equipped to detect them, as well as evaluate the vulnerabilities to
    which they may be susceptible.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Basic Authentication
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One of the most rudimentary GraphQL authentication methods is *HTTP basic authentication*.
    Defined in RFC 7617, this scheme involves the inclusion of a Base64-encoded username
    and password in the header of a client request. The header looks as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Base64-encoded username and password are joined by a colon into a single
    credential.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication is a simple technique that does not require cookies, session
    identifiers, or login pages. To detect basic authentication, we can use our browser.
    [Figure 7-2](#figure7-2) is an example of an automatic browser pop-up used to
    collect and encode credentials for basic authentication.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c07/f07002.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-2: A browser pop-up example of basic authentication'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the weaknesses of this method is the lack of confidentiality protections
    in place when transmitting the credentials to a GraphQL server over HTTP. Imagine
    a basic authentication header such as the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Because the credentials are encoded using Base64 and sent on every request
    (by contrast, other systems might generate a temporary session token upon login),
    the attack window from which to steal such credentials is larger. The risk of
    transmitting credentials over an unencrypted channel can be mitigated through
    the use of TLS. However, if the credentials are stolen, an attacker can Base64-decode
    them fairly easily. To test this, open your terminal and run the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Another weakness in basic authentication is the lack of any supported logout
    feature that would invalidate the credential. An attacker who steals basic authentication
    credentials has permanent access to the API until an admin changes the credentials.
    It’s rare to see basic authentication used in production-grade applications. You
    have a higher chance of stumbling upon the mechanism in testing or staging environments,
    as a quick-and-dirty method of protecting the application, but anything is possible!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2.0 and JSON Web Token
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Open Authorization (OAuth)* is an authorization framework that enables a third
    party to obtain temporary access to an HTTP service such as a GraphQL API. This
    access is obtained by orchestrating a grant process between the user and the API,
    or by allowing a third-party application to obtain access on behalf of the user.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: You may have encountered OAuth in the past if you’ve ever logged in to a website
    by clicking a button that says something like *Log in with Google*. We’ll only
    scratch the surface of OAuth 2.0 in this section, but if you’re interested in
    learning more about it, you can find information at [https://datatracker.ietf.org/doc/html/rfc6749](https://datatracker.ietf.org/doc/html/rfc6749).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you’re performing a penetration test against an application, such
    as an e-commerce app, that has a login mechanism in place to prevent unauthorized
    access. The OAuth protocol allows the e-commerce app (or the *client*, in OAuth
    terminology) to request authorization from a *resource owner* (you, the penetration
    tester, who needs to log in). When the authorization request is granted (also
    called an *authorization grant*), the e-commerce app will obtain an access token
    that it can use to access certain resources on a resource server. This resource
    server can be a GraphQL server. It will check the access token and, if it is found
    valid, service the request by allowing the client to perform queries to a resource
    (also called a *protected resource*).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Applications that leverage the OAuth 2.0 framework can use *JSON Web Token (JWT)*
    as their token format. JWT is an open standard (defined in RFC 7519) that allows
    for the secure transmission of information between systems via a JSON object.
    Servers can verify JWT tokens through digital signatures and encryption. A JWT
    token comprises three distinct sections that are Base64-encoded and separated
    by periods (`.`), as shown in [Listing 7-1](#listing7-1). These three parts are
    the header, payload, and signature.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 7-1: A sample JWT token'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'The *header*, or the JWT token’s first section, defines two important details:
    the type of token and the signing algorithm. When we Base64-decode this header,
    we should be able see its contents:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `typ` key is a header parameter that declares structural media type information
    about the JWT token. In this case, the media type is `JWT`. The full list of possible
    media types can be found at [https://www.iana.org/assignments/media-types/media-types.xhtml](https://www.iana.org/assignments/media-types/media-types.xhtml).
    This header parameter is considered optional but can be set so the application
    reading the header is aware of the object type structure.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'The `alg` key defines the JWT token’s signing algorithm used to ensure the
    token’s integrity. This key can represent different signing algorithms, such as
    these:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: No digital signature (`none`)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HMAC with SHA-256 (`HS256`)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HMAC with SHA-384 (`HS384`)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RSA with SHA-256 (`RS256`)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RSA with SHA-384 (`RS384`)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hash-based message authentication code (HMAC)* is a symmetric cryptographic
    authentication technique (meaning it uses a shared secret), whereas *Rivest-Shamir-Adleman
    (RSA)* is asymmetric (using public- and private-key pairs). The full list of signing
    algorithms can be found in RFC 7518.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: A common attack against applications using JWT involves setting the `alg` header
    parameter to `none`. If an application accepts unsigned JWT tokens, hackers can
    tamper with their JWT token to identify as another user or perform sensitive actions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'The *payload* section, or the second part of the JWT, contains relevant information
    about the user, as well as any additional data the developers might find useful
    to include. In our example, the decoded payload should match this output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Most JWT payloads will include a few standard elements, called *claims*, including
    an `iat` field, which represents the timestamp at which the JWT was initiated,
    and the `exp` field, which represents the expiry timestamp in Unix timestamp format.
    You can learn more about JWT fields by reading the RFC 7519 documentation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the JWT is the *signature*, which ensures that the entire JWT
    wasn’t tampered with. Any manual change to the JWT should invalidate this signature,
    causing the GraphQL server to reject the token. As you’ll soon learn, vulnerabilities
    in a GraphQL server’s signature verification may allow an attacker to forge JWT
    tokens. In “Forging and Leaking JWT Credentials” on page 178, we’ll touch on a
    few common JWT implementation weaknesses and how to exploit them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL Modules
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When testing JavaScript-based GraphQL implementations, you may come across a
    utility library known as *GraphQL Modules*, built by The Guild ([https://www.the-guild.dev](https://www.the-guild.dev)).
    This library separates GraphQL schemas into smaller, reusable modules that act
    as middleware. Developers can then use these to wrap their resolvers. [Listing
    7-2](#listing7-2) is the Authentication module, which provides GraphQL clients
    with a standard set of login, signup, and user-lookup mutations and queries.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 7-2: The Authentication module from the GraphQL Modules library'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the module defines a query named `me` that returns a `User`
    object, as well as two mutations, named `login` and `signup`, that accept `username`
    and `password` arguments and return a `User` object.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Developers could also implement custom `login` query and `signup` mutation operations
    in their GraphQL APIs without using an external library. In “Authentication Testing”
    on page 171, we’ll teach you how to defeat in-band authentication operations like
    the examples mentioned here by using batched queries, introduced in Chapter 5,
    and CrackQL, installed in Chapter 2.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL Shield
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*GraphQL Shield* is another middleware library, built by The Guild, for generating
    an authorization layer in GraphQL APIs. It allows developers to define rules that
    either permit or deny client access. [Listing 7-3](#listing7-3) shows queries
    and mutations protected by GraphQL Shield, which defines the permissions and roles
    required to access each query.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 7-3: A GraphQL Shield code example'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Clients wishing to use the `frontPage` query don’t have to be authenticated,
    as defined by the rule `not(isAuthenticated)`, whereas to use the `customers`
    query, they have to both be authenticated and have an admin user, as indicated
    by `and(isAuthenticated, isAdmin)`. The `and` operator mandates that both conditions
    must be true for permission to be granted.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: A developer community actively maintains GraphQL Shield and continuously improves
    it. As of this writing, the last documented vulnerability in GraphQL Shield was
    an authorization bypass that dates back to 2020 in versions earlier than 6.0.6.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个开发者社区积极维护着 GraphQL Shield，并不断改进它。截止本文写作时，GraphQL Shield 中最后一个文档化的漏洞是一个授权绕过漏洞，发生在
    2020 年，并出现在早于 6.0.6 的版本中。
- en: When performing a code review, look for the GraphQL Shield component called
    the `fallbackRule`. This rule can determine whether a request should be allowed
    or denied by default whenever a rule is not defined. By default, `fallbackRule`
    is set to `allow`. To read more about GraphQL Shield rules, refer to the official
    documentation at [https://www.graphql-shield.com/docs/rules#logic-rules](https://www.graphql-shield.com/docs/rules#logic-rules).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行代码审查时，查找名为`fallbackRule`的 GraphQL Shield 组件。此规则可以在未定义规则时决定请求是否默认允许或拒绝。默认情况下，`fallbackRule`
    设置为`allow`。要了解更多关于 GraphQL Shield 规则的信息，请参阅官方文档 [https://www.graphql-shield.com/docs/rules#logic-rules](https://www.graphql-shield.com/docs/rules#logic-rules)。
- en: Schema Directives
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 架构指令
- en: GraphQL deployments might use custom schema-level directives to apply both authentication
    and authorization controls on certain operations and fields. By decorating schema
    components, these custom directives can control what clients can and can’t do
    in the API. We can use them to enforce security at the query level, type level,
    field level, and so on.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 部署可能会使用自定义的架构级指令来对某些操作和字段应用身份验证和授权控制。通过修饰架构组件，这些自定义指令可以控制客户端在 API 中可以做什么以及不能做什么。我们可以通过它们在查询级、类型级、字段级等地方执行安全控制。
- en: The graphql-directive-auth library ([https://github.com/graphql-community/graphql-directive-auth](https://github.com/graphql-community/graphql-directive-auth))
    provides one example of how developers could apply directives to solve authentication
    and authorization gaps in their APIs. In some implementations, the `@auth` directive
    accepts a `requires` argument, which takes a string value representing the role
    or group a user needs in order to query the field. Clients usually send these
    user groups or roles through a JWT payload. The directive logic analyzes these
    to either allow or deny access to protected elements of the schema.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: graphql-directive-auth 库 ([https://github.com/graphql-community/graphql-directive-auth](https://github.com/graphql-community/graphql-directive-auth))
    提供了一个示例，展示了开发者如何使用指令来解决其 API 中的身份验证和授权问题。在某些实现中，`@auth` 指令接受一个 `requires` 参数，该参数采用一个字符串值，表示用户查询字段所需的角色或组。客户端通常通过
    JWT 负载发送这些用户组或角色。指令逻辑会分析这些信息，从而决定是否允许或拒绝访问架构中的受保护元素。
- en: Authorization directives can have various other names or arguments. [Table 7-1](#table7-1)
    is a list of common ones you might encounter in your introspection hunts.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 授权指令可能具有各种其他名称或参数。[表 7-1](#table7-1) 是一个常见的指令列表，你可能会在内省时遇到这些指令。
- en: 'Table 7-1: Common GraphQL Authorization Directives'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-1：常见的 GraphQL 授权指令
- en: '| **Directive name** | **Argument name** | **Argument type** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **指令名称** | **参数名称** | **参数类型** |'
- en: '| --- | --- | --- |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `@auth` | `requires` | `String` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `@auth` | `requires` | `String` |'
- en: '| `@protect` | `role` | `String` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `@protect` | `role` | `String` |'
- en: '| `@hasRole` | `role` | `String` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `@hasRole` | `role` | `String` |'
- en: Some `@auth` directives might also use an argument called `permissions`, which
    accepts a list of scope grants.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 `@auth` 指令可能还使用一个名为 `permissions` 的参数，该参数接受一个范围授权列表。
- en: IP-Based Allow Listing
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于 IP 的允许列表
- en: Some GraphQL APIs, particularly those deployed in internal systems that aren’t
    public facing, may choose not to authenticate individual client requests. Instead,
    they might opt to use an allow list of source IP addresses to authorize clients.
    In this technique, the server checks the client IP address included in a network
    request against a list of addresses or network range (such as *10.0.0.0/24*).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 GraphQL API，特别是那些部署在内部系统中并非公开的系统，可能选择不对单个客户端请求进行身份验证。相反，它们可能选择使用一个来源 IP 地址的允许列表来授权客户端。在这种技术中，服务器通过将网络请求中包含的客户端
    IP 地址与地址或网络范围列表（如 *10.0.0.0/24*）进行比对来检查客户端 IP 地址。
- en: This IP address often gets passed to the API by a public-facing network device,
    such as a reverse proxy or a load balancer. Applications will then attempt to
    discover the IP address by looking for HTTP headers set on incoming requests.
    A few common HTTP headers for this purpose are `X-Forwarded-For`, `X-Real-IP`,
    `X-Originating-IP`, and `X-Host`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 IP 地址通常通过公共网络设备传递给 API，比如反向代理或负载均衡器。然后，应用程序将尝试通过查找传入请求中的 HTTP 头来发现 IP 地址。一些常见的用于此目的的
    HTTP 头包括 `X-Forwarded-For`、`X-Real-IP`、`X-Originating-IP` 和 `X-Host`。
- en: 'Because clients can spoof these headers, reverse proxies may blindly forward
    misinformation to the application. For example, here is how you might pass a custom
    `X-Forwarded-For` header to DVGA with cURL:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If the application allows only requests to the GraphQL API that originate from
    the network *10.0.0.0/24*, injecting such a header at a later stage could allow
    an attacker to bypass the IP-based allow list and communicate with the application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Authentication Testing
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you’re testing GraphQL authentication, you’ll encounter certain operations
    that aren’t protected by any authentication layer. For example, unauthenticated
    users might have access to queries, while only authenticated users might be able
    to perform more sensitive, state-changing actions using mutations. You might find
    this model in use on a blog: any client can read posts, whereas only authenticated
    users can write comments.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to do a thorough scan of the target GraphQL server and schema
    for any unprotected queries. This section will outline how you can detect and
    defeat certain GraphQL authentication controls.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the Authentication Layer
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the best ways to determine whether a target GraphQL application is protected
    by an authentication layer is by sending it a canary query. Use either of the
    introspection queries from Chapter 6 or craft your own to probe the schema for
    a range of operations, objects, and types. Depending on the response you receive,
    you may be able to detect the type of authentication used, as well as the layer
    at which authentication controls are implemented. In particular, keep an eye out
    for status codes, error messages, and differences in the responses to query variations.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Status Codes
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A sure way to verify that some sort of authentication layer exists on a GraphQL
    target is by analyzing the HTTP response you receive after sending a canary query.
    Most GraphQL implementations will always return a *200 OK* status code, even when
    the query contains typos or errors. However, if you receive a *403 Forbidden Error*,
    it’s possible that out-of-band authentication and authorization control, like
    a gateway or a WAF, has blocked your request from reaching the API in the first
    place.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Error Messages
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Error messages can obviously reveal the presence of authentication controls,
    but they might also tell us exactly what type of authentication the API requires
    and where in the architecture these checks occur. [Table 7-2](#table7-2) shows
    a list of common in-band GraphQL authentication error messages and the authentication
    implementation known to raise the error message by default.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 7-2: Common GraphQL Authentication Errors'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '| **Error message** | **Possible authentication implementation** |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
- en: '| `Authentication credentials are missing. Authorization header is required
    and must contain a value.` | OAuth 2.0 Bearer with JSON Web Token |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
- en: '| `Not Authorised!` | GraphQL Shield |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
- en: '| `Not logged in` `Auth required`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '`API key is required` | GraphQL Modules |'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '| `Invalid token!` `Invalid role!` | graphql-directive-auth |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: Error messages can be customized and might differ from those shown here. Reference
    Chapter 6 for additional information on how to abuse errors to extract valuable
    information from GraphQL. For example, a combination of a *200 OK* status code
    and an error message could indicate that authentication is required. Because these
    details may vary from one GraphQL API to another, we recommend checking all avenues.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Authentication-Related Fields
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another great way to detect an authentication layer is to use introspection
    queries to identify any authentication-related query or mutation operations. By
    design, in-band GraphQL authentication requires authentication, session management,
    and identity-based operations. For example, a client will most likely need to
    send unauthenticated mutation requests that perform login and sign-up operations
    to create and access their authenticated accounts. We can use the introspection
    query in [Listing 7-4](#listing7-4) to analyze the schema for any mutation operations
    related to authentication.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 7-4: An introspection query used to identify all mutations'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Check whether the query returns any mutation names similar to these:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '`me`'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`login`'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`logout`'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`signup`'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`register`'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`createUser`'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`createAccount`'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If so, you can infer that the API has an authentication layer, which means you
    can begin testing its resiliency against password brute-force attacks.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Brute-Forcing Passwords by Using Query Batching
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A classic authentication attack, password brute-forcing works against systems
    that fail to implement rate limits or other automated account-takeover prevention
    controls. To perform one, an attacker sends many login requests to a system in
    an attempt to correctly guess a password. This programmatic attack usually accepts
    a dictionary of possible user credentials or iterates through a sequence of characters
    to generate possible credential combinations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Security controls such as WAFs are great at preventing excessive numbers of
    HTTP requests from a single client, and often throttle or ban the client when
    they detect such activity. However, in Chapter 5, we introduced *query batching*,
    which essentially allows a client to pack multiple query operations in a single
    HTTP request. We can take advantage of this batching feature to brute-force credentials
    by using several operations in only a single HTTP request, effectively evading
    security controls such as WAFs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of batch operations: array-based and alias-based. Tools
    like BatchQL leverage array-based query batching to send multiple operations in
    a single request. However, if you return to the GraphQL Threat Matrix screenshot
    shown in Figure 3-4 of Chapter 3, you’ll notice that few GraphQL implementations
    support this type of batching. By contrast, all major GraphQL implementations
    support alias-based query batching, as it’s defined in the GraphQL spec.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use aliases to execute a password brute-force attack against DVGA’s GraphQL’s
    authentication layer. First, we’ll need to include multiple login operations with
    different credentials in a single GraphQL document. [Listing 7-5](#listing7-5)
    shows a GraphQL document with 10 login mutation aliases targeting the *admin*
    and *operator* user accounts in DVGA. You can also find the query in the book’s
    GitHub repository at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch07/password-brute-force.graphql](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch07/password-brute-force.graphql).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Each alias operation has a unique identifier, as well as a target username
    and a potential password. If one of the operations succeeds, the server should
    return the attacked user’s JWT access token (`accessToken`) in the response:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 7-5: A password brute-forcing example using batched queries'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Executing this password brute-force query against DVGA will result in the large
    response shown next. As you can see, most of this data consists of `Authentication
    Failure` errors. However, for `alias10`, we receive a valid `accessToken`, meaning
    we correctly brute-forced the *operator* password, which was set to *password123*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Even if a security control protected the API by banning clients from making
    more than, say, five HTTP login requests per minute, this attack would evade such
    logic, because we sent only a single HTTP request while performing 10 login attempts.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: Brute-Forcing Passwords with CrackQL
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Manually building the large GraphQL document needed to successfully brute-force
    login credentials would be extremely time-consuming. In Chapter 2, you installed
    a GraphQL password brute-forcing and fuzzing tool called *CrackQL*. This tool
    accepts a single GraphQL query or mutation operation and automatically generates
    the alias payloads by using a CSV wordlist. Let’s run the same password brute-force
    attack but, this time, use CrackQL to automate it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Enter the CrackQL directory and then execute the brute-force attack against
    DVGA. The `-t` (target) argument specifies the destination GraphQL endpoint URL,
    the `-q` (query) argument takes a sample query (`login.graphql`), and the `-i`
    (input) argument defines the list of usernames and passwords to use in the attack.
    The `--verbose` argument allows us to view additional information such as the
    final payload before it is sent to DVGA.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: CrackQL comes preinstalled with a sample username and password CSV dictionary,
    as well as the *login.graphql* query, shown in [Listing 7-6](#listing7-6). As
    you can see, it contains a single login mutation with two embedded variables,
    `username` and `password`. CrackQL uses Jinja-templating syntax, so variables
    are passed using double curly brackets (`{{}}`).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 7-6: The sample CrackQL login brute-force query'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'When you execute the CrackQL command, the tool will automatically take each
    username and password variable from the CSV file and inject them into a duplicated
    login operation in the same query document. CrackQL’s verbose output provides
    payload details, as well as the output results:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In cases where GraphQL query cost controls prevent the execution of large query
    batches, CrackQL has an optional `-b` (batch) argument, which you can use to define
    a more limited set of aliased operations, allowing your attack to fly under the
    radar.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: You could also use CrackQL for a variety of other attacks. Using a list of possible
    one-time password tokens, CrackQL could brute-force two-factor authentication.
    It can also perform account enumeration attacks, by automating the scanning for
    valid emails or usernames, or fuzz for unique object identifiers to exploit *insecure
    direct object reference (IDOR)* vulnerabilities, where, by directly referencing
    an object identifier, we are able to access the object without being authorized
    to do so.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'When performing attacks against authenticated queries, you’ll likely need to
    pass it authentication headers and possibly cookies. CrackQL allows you to do
    so using the *config.py* file, which accepts `COOKIES` and `HEADERS` variables.
    Here is an example of how to supply the tool with custom headers and cookies:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When performing a penetration test, you can obtain these headers by inspecting
    the network traffic with tools such as the Firefox Developer Tools’ Network tab.
    Look at any GraphQL requests that are sent after you perform an initial login
    to a website. At that point, you should see unique authentication headers or session
    cookies.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Using Allow-Listed Operation Names
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Certain in-band GraphQL implementations may make some queries and mutations
    publicly available for unauthenticated clients, such as those for login or account
    registration. Some of these deployments use *operation name-based allow lists*,
    a weak enforcement control, to reject all unauthenticated requests unless their
    operation names are in an allow list. However, operation names can be defined
    by the client, so an attacker can bypass these authentication mechanisms by simply
    spoofing an operation’s name.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of an unauthenticated mutation. As you can see,
    it would allow a user to register a new user account:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: An implementation may choose to allow-list this `register` operation by using
    its operation name `RegisterAccount`. As attackers, we can take advantage of this
    by sending a request like the one in [Listing 7-7](#listing7-7).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 7-7: An example operation that could bypass authentication by using
    an allow-listed operation name'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: We used the allowed operation name to withdraw money with a withdrawal mutation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Forging and Leaking JWT Credentials
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While JWT tokens can be encrypted using JSON Web Encryption (RFC 7516), they
    often aren’t. And when they aren’t, they may leak sensitive data. For example,
    take a look at the payload section of the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When we Base64-decode the payload, we discover a hardcoded credential, `api_token`,
    in the payload section:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can gain a lot of insight into an application by decoding and testing the
    contents of JWT tokens.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Another way to bypass weak JWT authentication controls is by forging our own
    JWT tokens. If a GraphQL API fails to correctly verify the signature of a JWT
    token, it becomes vulnerable to forgery-based attacks, in which an attacker can
    encode their own user details.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s perform a JWT forgery attack against DVGA by forging the JWT token of
    an administrator. First, copy the `accessToken` JWT we received in “Brute-Forcing
    Passwords by Using Query Batching” on page 173, when we successfully brute-forced
    the *operator* password. We can verify that the `accessToken` is valid by sending
    it as a `token` argument in the `me` query operation in DVGA:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'DVGA will authenticate the user based on the identity claim in the JWT and
    use the `me` query operation to return the authenticated user object fields:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, let’s paste the JWT string into [https://jwt.io](https://jwt.io), as shown
    in [Figure 7-3](#figure7-3). This website will automatically decode and present
    the three JWT segments in a more human-readable form.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'In the right panel, we can directly modify the decoded payload’s JSON data,
    changing the `"identity": "operator"` line to `"identity": "admin"`. You’ll notice
    that [https://jwt.io](https://jwt.io) will automatically encode the payload changes
    in the left panel.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c07/f07003.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-3: The DVGA operator’s `accessToken`, decoded using [https://jwt.io](https://jwt.io)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try using this forged JWT token against the `me` operation. Simply copy
    the JWT and paste it into the query’s `token` argument. Because DVGA doesn’t verify
    the JWT signature, it will authenticate our request with the forged JWT token
    and return the admin user’s password:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When a client changes a JWT token, its signature should become invalid. GraphQL
    APIs that don’t validate this signature by using their secret key will be prone
    to forgery-based attacks.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Authorization Testing
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with authentication, developers can take several approaches to implementing
    authorization. When given a limited GraphQL user account, we, as hackers, should
    see how far we can escalate our privileges. In particular, we should determine
    whether we’re able to bypass controls intended to prevent us from reading user
    data or performing certain elevated functions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Like REST, GraphQL can be vulnerable to a variety of authorization attacks,
    depending on how the API handles permission controls. Failure to protect unauthorized
    access at the function level may result in the leakage of sensitive data or the
    execution of damaging operations.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL-specific authorization flaws typically arise when permission checks
    occur at the resolver level or after the execution of any business logic or state
    changes. Let’s learn to detect some of these authorization approaches and explore
    the attacks to which they might be vulnerable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the Authorization Layer
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can go about detecting whether an API uses authorization controls, and of
    what type, in several ways.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Finding Schema Directives
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We mentioned earlier that developers sometimes implement authorization by using
    schema directives. You can identify these schema directives if you have access
    to the API’s SDL files. Alternatively, you can send a specialized introspection
    query, like the one in [Listing 7-8](#listing7-8).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 7-8: An introspection query to fetch directive names and arguments'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Running this query will return a list of all the query- and schema-level directives
    in the target server. If you notice the `@auth` directive in the list, you can
    assume that the schema supports it. Of course, developers can call directives
    different things, so also look for names like `@authorize`, `@authorization`,
    `@authz`, and others.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Finding Authentication Directives in the Schema
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we perform an introspection query to identify directives, we’ll know whether
    an `@auth` directive exists. However, we won’t know where this directive is applied
    in the schema, as this information isn’t exposed in an introspection query. That’s
    because clients don’t call schema-level directives; instead, developers use them
    to protect against unauthorized access, among other use cases.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the `User` object type in [Listing 7-9](#listing7-9) as an example.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 7-9: An `@auth` directive usage example in a schema'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find scanning the schema for `@auth` directives useful in white-box penetration
    tests, which provide you with the SDL files. But in black-box tests that provide
    no access to the schema, you might know that the `password` field exists, for
    example, but not that the `@auth` directive applies to it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The GraphQL developer community has discussed exposing information about the
    use of schema-level directives in the introspection system. However, many GraphQL
    implementations currently don’t expose this information.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating Paths with graphql-path-enum
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To test authorization controls, you should try accessing sensitive fields in
    as many ways as you can imagine. For example, consider the following excerpt from
    the DVGA’s schema, in which three queries access the `PasteObject`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As a client, you could return information about pastes by using either `pastes`,
    `paste`, or `readAndBurn`. When implementing in-band authorization, a developer
    might accidentally protect only some of these queries. As such, determine all
    possible paths to a given object type.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'Schemas can be very large, so you’ll find it helpful to automate the process
    of identifying all paths to a given object type. For this task, we’ll use graphql-path-enum.
    This tool expects two important arguments: the introspection JSON response and
    the name of an object type we want to test for authorization issues. Let’s use
    it to find all paths to the `PasteObject` object type.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: First, run a full introspection query by pasting the query from [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/queries/introspection_query.txt](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/queries/introspection_query.txt)
    into Altair. Send the request and copy the response to a file named *introspection.json*.
    Next, provide graphql-path-enum with this file and tell it to search for all paths
    leading to the `PasteObject` object, as shown in [Listing 7-10](#listing7-10).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 7-10: Performing type path enumeration with graphql-path-enum'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, graphql-path-enum traversed the introspection response and identified
    all possible query paths to the object. Now we can manually send these three queries
    to see whether any of them grant access to objects that other queries don’t.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to practice schema traversal in a large, complex GraphQL API,
    try running graphql-path-enum against the `Vehicle` object type in the popular
    Star Wars API (SWAPI). This API’s schema is larger than that of the DVGA and should
    illustrate the importance of path enumeration when testing for authorization issues.
    You can access the SWAPI schema at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch07/starwars-schema.json](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch07/starwars-schema.json).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Brute-Forcing Arguments and Fields with CrackQL
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because graphql-path-enum works for only object types, you might try the field-stuffing
    technique discussed in Chapter 6 to test for weak or nonexistent authorization
    controls intended to limit the amount of data an unprivileged user can view. We
    can also use CrackQL to programmatically brute-force arguments and fields to which
    we shouldn’t have access. Imagine a query that looks like the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, say that accessing information about certain users requires special authorization
    permissions. We know that the user IDs are numerical and incremental, but not
    which are protected. Let’s attempt to brute-force them all with CrackQL.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'In the CrackQL folder, under *sample-queries*, create a new file named *users.graphql*
    with the following content:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This query uses the `users` field with an `id` parameter of the `Int` type.
    Because the query takes an `id` argument, we can attempt to enumerate accounts
    by incrementally supplying a list of numerical user identifiers. CrackQL will
    render the `{{id|int}}` string and replace it with words from a wordlist we will
    create next.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create this dictionary of possible user IDs as a one-column CSV wordlist.
    Such a list is easy to generate with some Bash-fu:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, check that the file was generated properly by printing the first five
    lines:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now run CrackQL to find valid user IDs and retrieve their username and password
    fields:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also, in the same fashion, brute-force fields that you suspect you
    won’t be able to access because of authorization controls by simply modifying
    the original query to include these potential fields:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: CrackQL will save the output of all attempts under the *~/CrackQL/results* folder.
    If these fields are accessible, you’ll see the responses to them there.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about in-band and out-of-band GraphQL authentication
    and authorization architectural models. We reviewed a few traditional controls
    developers may have adopted in their GraphQL deployments and called out the weaknesses
    to which they might be susceptible. For example, GraphQL implementations that
    use JWT tokens might be vulnerable to token forging. We also directed your attention
    to newer, GraphQL-specific authentication and authorization libraries and plug-ins,
    such as GraphQL Modules, GraphQL Shield, and custom schema directives.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: By taking advantage of GraphQL features like alias-based query batching, we
    can brute-force in-band authentication operations manually or use CrackQL to do
    this automatically. Using graphql-path-enum, we can enumerate paths to types,
    and using CrackQL once again, we can potentially access fields without proper
    authorization controls.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we’ll turn to another age-old vulnerability class: injections,
    which continue to wreak havoc even against modern API services like GraphQL.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
