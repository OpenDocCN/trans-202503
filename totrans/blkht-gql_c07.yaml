- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Authentication and Authorization Bypasses
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证和授权绕过
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: Out of the box, GraphQL has no authentication or authorization controls. As
    a result, the ecosystem has created its own or adopted those seen in traditional
    systems. In this chapter, we’ll cover the common GraphQL authentication and authorization
    implementations. Then we’ll discuss attacks that target some of their weaknesses.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，GraphQL 没有身份验证或授权控制。因此，生态系统创建了自己的机制，或采纳了传统系统中的机制。在本章中，我们将介绍常见的 GraphQL
    身份验证和授权实现。然后，我们将讨论针对它们的一些弱点的攻击。
- en: '*Authentication* is the mechanism by which a client proves their identity to
    a server. It answers the question: Is the user really who they say they are? Authentication
    attacks target a client’s identity, attempting to either steal credentials or
    spoof them to authenticate with a server, take certain actions on their behalf,
    or steal data to which they have access.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*身份验证*是客户端向服务器证明其身份的机制。它回答了这样一个问题：用户是否真的是他们所说的人？身份验证攻击瞄准客户端的身份，试图窃取凭证或伪造凭证来与服务器进行身份验证，代表用户执行某些操作，或窃取他们可以访问的数据。'
- en: '*Authorization* controls are responsible for granting access to data and ensuring
    that the actions an entity takes, whether they’re a human or a machine, match
    their assigned roles, groups, and permissions. Authorization attacks attempt to
    either bypass a security control entirely or poke holes in it, allowing an attacker
    to take actions that wouldn’t otherwise be possible. For example, they might gain
    unauthorized access to system data or perform privileged actions, such as setting
    another user’s password.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*授权*控制负责授予数据访问权限，并确保实体（无论是人类还是机器）所执行的操作与其分配的角色、组和权限匹配。授权攻击试图绕过安全控制，或者在其漏洞中开辟缺口，使攻击者能够执行本不可能的操作。例如，他们可能会获得未经授权的系统数据访问权限，或执行特权操作，如设置其他用户的密码。'
- en: Authentication and authorization controls can be challenging to implement. This
    is especially true when an application creates its own mechanisms from scratch
    instead of using the many battle-tested frameworks available for specific programming
    languages. Performing security testing of such controls is also a nontrivial task;
    security tools (such as API application scanners) struggle to identify authorization
    and authentication issues. One of the primary reasons is that scanners have no
    contextual understanding of the application’s business logic.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证和授权控制的实现可能会很具挑战性。特别是在应用程序从零开始创建自己的机制，而不是使用许多经过严格测试的框架时，这一点尤为明显。对这些控制进行安全测试也是一项复杂的任务；安全工具（如
    API 应用程序扫描器）在识别授权和身份验证问题时常常力不从心。其主要原因之一是扫描器对应用程序的业务逻辑缺乏上下文理解。
- en: For years, hackers have defeated both authentication and authorization defenses
    by taking advantage of weak passwords, default credentials, forged tokens, flawed
    account recovery processes, replay attacks, and poor rate-limit controls. Not
    only is exploiting these weaknesses possible in GraphQL implementations, but,
    in many cases, GraphQL’s client-empowering features actually enable hackers to
    optimize their attacks, as you’ll soon learn.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，黑客通过利用弱密码、默认凭证、伪造的令牌、缺陷的帐户恢复过程、重放攻击和不完善的速率限制控制来突破身份验证和授权防御。这些弱点不仅在 GraphQL
    实现中可以被利用，而且在许多情况下，GraphQL 强大的客户端功能实际上帮助黑客优化了他们的攻击，正如你很快将了解的那样。
- en: The State of Authentication and Authorization in GraphQL
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL 中的身份验证和授权现状
- en: The GraphQL spec has left implementers to fend for themselves when it comes
    to authentication and authorization. This lack of a detailed standard has led
    developers to select and deploy their own GraphQL authentication and authorization
    controls from a variety of libraries, tools, and configurations, often leading
    to vulnerabilities and implementation gaps.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 规范在身份验证和授权方面没有为实现者提供明确的指引。缺乏详细的标准导致开发者从各种库、工具和配置中选择并部署自己的 GraphQL 身份验证和授权控制，这常常导致漏洞和实现差距。
- en: 'In this section, we’ll sink our teeth into the ecosystem-driven authentication
    and authorization services, libraries, and plug-ins available for GraphQL. Broadly,
    these approaches follow two distinct architectural deployment models: in-band
    and out-of-band.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入探讨面向生态系统的身份验证和授权服务、库以及可用于 GraphQL 的插件。总体来说，这些方法遵循两种不同的架构部署模型：带内（in-band）和带外（out-of-band）。
- en: In-Band vs. Out-of-Band
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带内 vs. 带外
- en: In an *in-band* authentication and authorization architecture, developers implement
    client login, signup, role-based access controls, and other permission controls
    directly in the GraphQL API. The same GraphQL instance that provides clients with
    their application data also controls the logic that authenticates clients and
    grants them permissions to view data. In-band GraphQL architectures typically
    host query or mutation operations that enable clients to send credentials to the
    API. The API is responsible for verifying these credentials and then issuing tokens
    to the clients.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在*内联*认证和授权架构中，开发者直接在 GraphQL API 中实现客户端登录、注册、基于角色的访问控制和其他权限控制。提供客户端应用数据的同一 GraphQL
    实例还控制着认证客户端的逻辑，并授予其查看数据的权限。内联 GraphQL 架构通常托管查询或变更操作，允许客户端将凭证发送到 API。API 负责验证这些凭证，然后向客户端发放令牌。
- en: '*Out-of-band* authentication and authorization architectures implement the
    access control and permissions logic on either a separate internal web application
    service or an external system. In such an architecture, the GraphQL API isn’t
    responsible for managing client login, signup, or even access control. Instead,
    it offloads authorization decisions to another component, such as an API gateway,
    a container sidecar, or another server on the network. This allows developers
    to decouple the authorization logic from the GraphQL application.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*外联*认证和授权架构将访问控制和权限逻辑实现于单独的内部 Web 应用服务或外部系统中。在这种架构中，GraphQL API 不负责管理客户端登录、注册，甚至是访问控制。相反，它将授权决策交给另一个组件，如
    API 网关、容器旁车或网络上的其他服务器。这使得开发者可以将授权逻辑与 GraphQL 应用程序解耦。'
- en: Of the two architectural styles, in-band architectures tend to be more vulnerable
    to authentication and authorization attacks. Their added complexity increases
    an API’s attack surface drastically. These APIs often duplicate permission logic
    for each entry point into the service, and as you’ll see later in this chapter,
    we, as hackers, can take advantage of even the slightest misaligned control.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种架构风格中，内联架构通常更容易受到认证和授权攻击。它们增加的复杂性大幅提高了 API 的攻击面。这些 API 经常为服务的每个入口点复制权限逻辑，正如你将在本章后面看到的那样，作为黑客，我们可以利用即便是最细微的不对齐控制。
- en: Thus, some contributors to the GraphQL ecosystem advocate for keeping authentication
    and authorization logic outside of GraphQL. The current industry best practice
    is to delegate authorization logic to the *business logic layer* of an application,
    which serves as the single source of truth for all business domain rules. It should
    sit between the GraphQL layer and the *persistence layer* (also known as the *database*
    or *datastore* layer), as shown in [Figure 7-1](#figure7-1).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一些 GraphQL 生态系统的贡献者主张将认证和授权逻辑保持在 GraphQL 之外。目前的行业最佳实践是将授权逻辑委托给应用程序的*业务逻辑层*，该层作为所有业务领域规则的单一真实来源。它应该位于
    GraphQL 层与*持久层*（也称为*数据库*或*数据存储层*）之间，如[图 7-1](#figure7-1)所示。
- en: '![](image_fi/502840c07/f07001.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c07/f07001.png)'
- en: 'Figure 7-1: The gateway, API, business, and persistence layers'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-1：网关、API、业务和持久层
- en: By contrast, authentication for the entire GraphQL API should occur in an external
    or third-party *gateway layer*, which passes authenticated user contexts along
    to the API.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，整个 GraphQL API 的认证应发生在外部或第三方*网关层*，该层将已认证的用户上下文传递给 API。
- en: Common Approaches
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见方法
- en: There is no way to know what kinds of controls you’ll come across during your
    GraphQL hacking adventures. However, this section lists some of the common approaches
    we’ve seen in our research and testing. By understanding these techniques, you’ll
    be better equipped to detect them, as well as evaluate the vulnerabilities to
    which they may be susceptible.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在你进行 GraphQL 黑客实验时，无法预知会遇到哪些类型的控制。然而，本节列出了一些我们在研究和测试中见过的常见方法。通过了解这些技术，你将更有能力发现它们，并评估它们可能受到的漏洞。
- en: HTTP Basic Authentication
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: HTTP 基本认证
- en: 'One of the most rudimentary GraphQL authentication methods is *HTTP basic authentication*.
    Defined in RFC 7617, this scheme involves the inclusion of a Base64-encoded username
    and password in the header of a client request. The header looks as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的 GraphQL 认证方法之一是*HTTP 基本认证*。在 RFC 7617 中定义的此方案涉及将一个 Base64 编码的用户名和密码包含在客户端请求的头部。头部如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Base64-encoded username and password are joined by a colon into a single
    credential.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Base64 编码的用户名和密码通过冒号连接成一个单一凭证。
- en: Basic authentication is a simple technique that does not require cookies, session
    identifiers, or login pages. To detect basic authentication, we can use our browser.
    [Figure 7-2](#figure7-2) is an example of an automatic browser pop-up used to
    collect and encode credentials for basic authentication.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 基本认证是一种简单的技术，不需要使用 cookies、会话标识符或登录页面。为了检测基本认证，我们可以使用浏览器。[图 7-2](#figure7-2)
    是一个示例，展示了浏览器自动弹出窗口，用于收集和编码基本认证的凭证。
- en: '![](image_fi/502840c07/f07002.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c07/f07002.png)'
- en: 'Figure 7-2: A browser pop-up example of basic authentication'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7-2：基本认证的浏览器弹出示例
- en: 'One of the weaknesses of this method is the lack of confidentiality protections
    in place when transmitting the credentials to a GraphQL server over HTTP. Imagine
    a basic authentication header such as the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个缺点是在通过 HTTP 向 GraphQL 服务器传输凭证时缺乏保密性保护。想象一下如下的基本认证头：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Because the credentials are encoded using Base64 and sent on every request
    (by contrast, other systems might generate a temporary session token upon login),
    the attack window from which to steal such credentials is larger. The risk of
    transmitting credentials over an unencrypted channel can be mitigated through
    the use of TLS. However, if the credentials are stolen, an attacker can Base64-decode
    them fairly easily. To test this, open your terminal and run the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于凭证使用 Base64 编码，并且每次请求都会发送（相比之下，其他系统可能在登录时生成临时会话令牌），因此盗取这些凭证的攻击窗口较大。通过使用 TLS
    可以缓解在未加密通道上传输凭证的风险。然而，如果凭证被窃取，攻击者可以相对容易地将其 Base64 解码。要测试这一点，请打开终端并运行以下命令：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Another weakness in basic authentication is the lack of any supported logout
    feature that would invalidate the credential. An attacker who steals basic authentication
    credentials has permanent access to the API until an admin changes the credentials.
    It’s rare to see basic authentication used in production-grade applications. You
    have a higher chance of stumbling upon the mechanism in testing or staging environments,
    as a quick-and-dirty method of protecting the application, but anything is possible!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 基本认证的另一个缺点是缺乏任何支持的登出功能，无法使凭证失效。窃取基本认证凭证的攻击者可以永久访问 API，直到管理员更改凭证。基本认证很少在生产级应用中使用。你更有可能在测试或暂存环境中遇到这种机制，作为一种快速且简便的保护应用方法，但一切皆有可能！
- en: OAuth 2.0 and JSON Web Token
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: OAuth 2.0 和 JSON Web Token
- en: '*Open Authorization (OAuth)* is an authorization framework that enables a third
    party to obtain temporary access to an HTTP service such as a GraphQL API. This
    access is obtained by orchestrating a grant process between the user and the API,
    or by allowing a third-party application to obtain access on behalf of the user.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*开放授权（OAuth）* 是一种授权框架，允许第三方临时访问 HTTP 服务，例如 GraphQL API。这种访问是通过用户与 API 之间的授权过程，或者通过允许第三方应用代表用户获取访问权限来实现的。'
- en: You may have encountered OAuth in the past if you’ve ever logged in to a website
    by clicking a button that says something like *Log in with Google*. We’ll only
    scratch the surface of OAuth 2.0 in this section, but if you’re interested in
    learning more about it, you can find information at [https://datatracker.ietf.org/doc/html/rfc6749](https://datatracker.ietf.org/doc/html/rfc6749).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经点击类似 *使用 Google 登录* 的按钮登录到网站，你可能已经遇到过 OAuth。在本节中，我们仅触及 OAuth 2.0 的表面，但如果你有兴趣了解更多信息，可以参考
    [https://datatracker.ietf.org/doc/html/rfc6749](https://datatracker.ietf.org/doc/html/rfc6749)。
- en: Imagine that you’re performing a penetration test against an application, such
    as an e-commerce app, that has a login mechanism in place to prevent unauthorized
    access. The OAuth protocol allows the e-commerce app (or the *client*, in OAuth
    terminology) to request authorization from a *resource owner* (you, the penetration
    tester, who needs to log in). When the authorization request is granted (also
    called an *authorization grant*), the e-commerce app will obtain an access token
    that it can use to access certain resources on a resource server. This resource
    server can be a GraphQL server. It will check the access token and, if it is found
    valid, service the request by allowing the client to perform queries to a resource
    (also called a *protected resource*).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在对一个具有登录机制的应用程序进行渗透测试，例如一个电子商务应用程序，以防止未经授权的访问。OAuth协议允许电子商务应用程序（在OAuth术语中为*客户端*）向*资源拥有者*（你，渗透测试人员，必须登录的人）请求授权。当授权请求被授予（也称为*授权许可*）时，电子商务应用程序将获得一个访问令牌，可以用来访问资源服务器上的某些资源。这个资源服务器可以是一个GraphQL服务器。它将检查访问令牌，如果它有效，则通过允许客户端执行查询到某个资源（也称为*受保护资源*）来提供服务。
- en: Applications that leverage the OAuth 2.0 framework can use *JSON Web Token (JWT)*
    as their token format. JWT is an open standard (defined in RFC 7519) that allows
    for the secure transmission of information between systems via a JSON object.
    Servers can verify JWT tokens through digital signatures and encryption. A JWT
    token comprises three distinct sections that are Base64-encoded and separated
    by periods (`.`), as shown in [Listing 7-1](#listing7-1). These three parts are
    the header, payload, and signature.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 利用OAuth 2.0框架的应用程序可以使用*JSON Web令牌（JWT）*作为其令牌格式。JWT是一种开放标准（在RFC 7519中定义），允许通过JSON对象在系统之间安全传输信息。服务器可以通过数字签名和加密验证JWT令牌。JWT令牌包含三个不同的部分，这些部分经过Base64编码，并由句点（`.`）分隔，如[示例7-1](#listing7-1)所示。这三部分分别是头部、负载和签名。
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 7-1: A sample JWT token'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 7-1：一个示例JWT令牌
- en: 'The *header*, or the JWT token’s first section, defines two important details:
    the type of token and the signing algorithm. When we Base64-decode this header,
    we should be able see its contents:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*头部*，即JWT令牌的第一部分，定义了两个重要细节：令牌类型和签名算法。当我们对这个头部进行Base64解码时，我们应该能够看到它的内容：'
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `typ` key is a header parameter that declares structural media type information
    about the JWT token. In this case, the media type is `JWT`. The full list of possible
    media types can be found at [https://www.iana.org/assignments/media-types/media-types.xhtml](https://www.iana.org/assignments/media-types/media-types.xhtml).
    This header parameter is considered optional but can be set so the application
    reading the header is aware of the object type structure.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`typ`键是一个头部参数，声明JWT令牌的结构媒体类型信息。在这种情况下，媒体类型是`JWT`。可能的媒体类型完整列表可以在[https://www.iana.org/assignments/media-types/media-types.xhtml](https://www.iana.org/assignments/media-types/media-types.xhtml)找到。这个头部参数被认为是可选的，但可以设置，以便读取头部的应用程序知道对象类型的结构。'
- en: 'The `alg` key defines the JWT token’s signing algorithm used to ensure the
    token’s integrity. This key can represent different signing algorithms, such as
    these:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`alg`键定义JWT令牌的签名算法，用于确保令牌的完整性。这个键可以表示不同的签名算法，如下所示：'
- en: No digital signature (`none`)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无数字签名（`none`）
- en: HMAC with SHA-256 (`HS256`)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HMAC与SHA-256（`HS256`）
- en: HMAC with SHA-384 (`HS384`)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HMAC与SHA-384（`HS384`）
- en: RSA with SHA-256 (`RS256`)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RSA与SHA-256（`RS256`）
- en: RSA with SHA-384 (`RS384`)
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RSA与SHA-384（`RS384`）
- en: '*Hash-based message authentication code (HMAC)* is a symmetric cryptographic
    authentication technique (meaning it uses a shared secret), whereas *Rivest-Shamir-Adleman
    (RSA)* is asymmetric (using public- and private-key pairs). The full list of signing
    algorithms can be found in RFC 7518.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*基于哈希的消息认证码（HMAC）*是一种对称加密认证技术（意味着它使用共享的秘密），而*Rivest-Shamir-Adleman（RSA）*则是非对称加密（使用公钥和私钥对）。签名算法的完整列表可以在RFC
    7518中找到。'
- en: A common attack against applications using JWT involves setting the `alg` header
    parameter to `none`. If an application accepts unsigned JWT tokens, hackers can
    tamper with their JWT token to identify as another user or perform sensitive actions.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 针对使用JWT的应用程序的常见攻击之一是将`alg`头参数设置为`none`。如果应用程序接受未签名的JWT令牌，黑客可以篡改JWT令牌，以冒充另一个用户或执行敏感操作。
- en: 'The *payload* section, or the second part of the JWT, contains relevant information
    about the user, as well as any additional data the developers might find useful
    to include. In our example, the decoded payload should match this output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*载荷* 部分，或者说是 JWT 的第二部分，包含了关于用户的相关信息，以及开发者可能觉得有用的任何额外数据。在我们的示例中，解码后的载荷应匹配以下输出：'
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Most JWT payloads will include a few standard elements, called *claims*, including
    an `iat` field, which represents the timestamp at which the JWT was initiated,
    and the `exp` field, which represents the expiry timestamp in Unix timestamp format.
    You can learn more about JWT fields by reading the RFC 7519 documentation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 JWT 载荷都会包含一些标准元素，称为 *声明*，包括一个 `iat` 字段，它表示 JWT 被创建的时间戳，以及 `exp` 字段，它表示过期时间戳，格式为
    Unix 时间戳。你可以通过阅读 RFC 7519 文档了解更多关于 JWT 字段的信息。
- en: The last part of the JWT is the *signature*, which ensures that the entire JWT
    wasn’t tampered with. Any manual change to the JWT should invalidate this signature,
    causing the GraphQL server to reject the token. As you’ll soon learn, vulnerabilities
    in a GraphQL server’s signature verification may allow an attacker to forge JWT
    tokens. In “Forging and Leaking JWT Credentials” on page 178, we’ll touch on a
    few common JWT implementation weaknesses and how to exploit them.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 的最后一部分是 *签名*，它确保整个 JWT 没有被篡改。对 JWT 进行任何手动更改都会使签名失效，从而导致 GraphQL 服务器拒绝该令牌。正如你将很快学到的，GraphQL
    服务器签名验证中的漏洞可能允许攻击者伪造 JWT 令牌。在第178页的“伪造和泄露 JWT 凭证”一节中，我们将探讨一些常见的 JWT 实现漏洞及如何利用它们。
- en: GraphQL Modules
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GraphQL Modules
- en: When testing JavaScript-based GraphQL implementations, you may come across a
    utility library known as *GraphQL Modules*, built by The Guild ([https://www.the-guild.dev](https://www.the-guild.dev)).
    This library separates GraphQL schemas into smaller, reusable modules that act
    as middleware. Developers can then use these to wrap their resolvers. [Listing
    7-2](#listing7-2) is the Authentication module, which provides GraphQL clients
    with a standard set of login, signup, and user-lookup mutations and queries.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试基于 JavaScript 的 GraphQL 实现时，你可能会遇到一个名为 *GraphQL Modules* 的实用库，它由 The Guild（[https://www.the-guild.dev](https://www.the-guild.dev)）构建。这个库将
    GraphQL 架构分解为更小的、可重用的模块，作为中间件使用。开发者可以使用这些模块来包装他们的解析器。[列表 7-2](#listing7-2) 是身份验证模块，它为
    GraphQL 客户端提供了标准的登录、注册和用户查询变更操作。
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 7-2: The Authentication module from the GraphQL Modules library'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-2：来自 GraphQL Modules 库的身份验证模块
- en: As you can see, the module defines a query named `me` that returns a `User`
    object, as well as two mutations, named `login` and `signup`, that accept `username`
    and `password` arguments and return a `User` object.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，模块定义了一个名为 `me` 的查询，该查询返回一个 `User` 对象，以及两个变更操作，分别为 `login` 和 `signup`，它们接受
    `username` 和 `password` 参数并返回一个 `User` 对象。
- en: Developers could also implement custom `login` query and `signup` mutation operations
    in their GraphQL APIs without using an external library. In “Authentication Testing”
    on page 171, we’ll teach you how to defeat in-band authentication operations like
    the examples mentioned here by using batched queries, introduced in Chapter 5,
    and CrackQL, installed in Chapter 2.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者也可以在他们的 GraphQL API 中实现自定义的 `login` 查询和 `signup` 变更操作，而无需使用外部库。在第171页的“身份验证测试”一节中，我们将教你如何通过使用第五章介绍的批量查询和第二章安装的
    CrackQL 来破解这里提到的内联身份验证操作。
- en: GraphQL Shield
  id: totrans-61
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: GraphQL Shield
- en: '*GraphQL Shield* is another middleware library, built by The Guild, for generating
    an authorization layer in GraphQL APIs. It allows developers to define rules that
    either permit or deny client access. [Listing 7-3](#listing7-3) shows queries
    and mutations protected by GraphQL Shield, which defines the permissions and roles
    required to access each query.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '*GraphQL Shield* 是由 The Guild 构建的另一个中间件库，用于在 GraphQL API 中生成授权层。它允许开发者定义规则，允许或拒绝客户端访问。[列表
    7-3](#listing7-3) 显示了由 GraphQL Shield 保护的查询和变更操作，定义了访问每个查询所需的权限和角色。'
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 7-3: A GraphQL Shield code example'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-3：一个 GraphQL Shield 代码示例
- en: Clients wishing to use the `frontPage` query don’t have to be authenticated,
    as defined by the rule `not(isAuthenticated)`, whereas to use the `customers`
    query, they have to both be authenticated and have an admin user, as indicated
    by `and(isAuthenticated, isAdmin)`. The `and` operator mandates that both conditions
    must be true for permission to be granted.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 希望使用 `frontPage` 查询的客户端不需要进行身份验证，正如规则 `not(isAuthenticated)` 所定义的那样；而要使用 `customers`
    查询，他们必须同时满足已认证和具有管理员用户的条件，正如 `and(isAuthenticated, isAdmin)` 所示。`and` 运算符要求两个条件都为真，才能授予访问权限。
- en: A developer community actively maintains GraphQL Shield and continuously improves
    it. As of this writing, the last documented vulnerability in GraphQL Shield was
    an authorization bypass that dates back to 2020 in versions earlier than 6.0.6.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一个开发者社区积极维护着 GraphQL Shield，并不断改进它。截止本文写作时，GraphQL Shield 中最后一个文档化的漏洞是一个授权绕过漏洞，发生在
    2020 年，并出现在早于 6.0.6 的版本中。
- en: When performing a code review, look for the GraphQL Shield component called
    the `fallbackRule`. This rule can determine whether a request should be allowed
    or denied by default whenever a rule is not defined. By default, `fallbackRule`
    is set to `allow`. To read more about GraphQL Shield rules, refer to the official
    documentation at [https://www.graphql-shield.com/docs/rules#logic-rules](https://www.graphql-shield.com/docs/rules#logic-rules).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行代码审查时，查找名为`fallbackRule`的 GraphQL Shield 组件。此规则可以在未定义规则时决定请求是否默认允许或拒绝。默认情况下，`fallbackRule`
    设置为`allow`。要了解更多关于 GraphQL Shield 规则的信息，请参阅官方文档 [https://www.graphql-shield.com/docs/rules#logic-rules](https://www.graphql-shield.com/docs/rules#logic-rules)。
- en: Schema Directives
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 架构指令
- en: GraphQL deployments might use custom schema-level directives to apply both authentication
    and authorization controls on certain operations and fields. By decorating schema
    components, these custom directives can control what clients can and can’t do
    in the API. We can use them to enforce security at the query level, type level,
    field level, and so on.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 部署可能会使用自定义的架构级指令来对某些操作和字段应用身份验证和授权控制。通过修饰架构组件，这些自定义指令可以控制客户端在 API 中可以做什么以及不能做什么。我们可以通过它们在查询级、类型级、字段级等地方执行安全控制。
- en: The graphql-directive-auth library ([https://github.com/graphql-community/graphql-directive-auth](https://github.com/graphql-community/graphql-directive-auth))
    provides one example of how developers could apply directives to solve authentication
    and authorization gaps in their APIs. In some implementations, the `@auth` directive
    accepts a `requires` argument, which takes a string value representing the role
    or group a user needs in order to query the field. Clients usually send these
    user groups or roles through a JWT payload. The directive logic analyzes these
    to either allow or deny access to protected elements of the schema.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: graphql-directive-auth 库 ([https://github.com/graphql-community/graphql-directive-auth](https://github.com/graphql-community/graphql-directive-auth))
    提供了一个示例，展示了开发者如何使用指令来解决其 API 中的身份验证和授权问题。在某些实现中，`@auth` 指令接受一个 `requires` 参数，该参数采用一个字符串值，表示用户查询字段所需的角色或组。客户端通常通过
    JWT 负载发送这些用户组或角色。指令逻辑会分析这些信息，从而决定是否允许或拒绝访问架构中的受保护元素。
- en: Authorization directives can have various other names or arguments. [Table 7-1](#table7-1)
    is a list of common ones you might encounter in your introspection hunts.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 授权指令可能具有各种其他名称或参数。[表 7-1](#table7-1) 是一个常见的指令列表，你可能会在内省时遇到这些指令。
- en: 'Table 7-1: Common GraphQL Authorization Directives'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-1：常见的 GraphQL 授权指令
- en: '| **Directive name** | **Argument name** | **Argument type** |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **指令名称** | **参数名称** | **参数类型** |'
- en: '| --- | --- | --- |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `@auth` | `requires` | `String` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `@auth` | `requires` | `String` |'
- en: '| `@protect` | `role` | `String` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `@protect` | `role` | `String` |'
- en: '| `@hasRole` | `role` | `String` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `@hasRole` | `role` | `String` |'
- en: Some `@auth` directives might also use an argument called `permissions`, which
    accepts a list of scope grants.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 `@auth` 指令可能还使用一个名为 `permissions` 的参数，该参数接受一个范围授权列表。
- en: IP-Based Allow Listing
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于 IP 的允许列表
- en: Some GraphQL APIs, particularly those deployed in internal systems that aren’t
    public facing, may choose not to authenticate individual client requests. Instead,
    they might opt to use an allow list of source IP addresses to authorize clients.
    In this technique, the server checks the client IP address included in a network
    request against a list of addresses or network range (such as *10.0.0.0/24*).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 GraphQL API，特别是那些部署在内部系统中并非公开的系统，可能选择不对单个客户端请求进行身份验证。相反，它们可能选择使用一个来源 IP 地址的允许列表来授权客户端。在这种技术中，服务器通过将网络请求中包含的客户端
    IP 地址与地址或网络范围列表（如 *10.0.0.0/24*）进行比对来检查客户端 IP 地址。
- en: This IP address often gets passed to the API by a public-facing network device,
    such as a reverse proxy or a load balancer. Applications will then attempt to
    discover the IP address by looking for HTTP headers set on incoming requests.
    A few common HTTP headers for this purpose are `X-Forwarded-For`, `X-Real-IP`,
    `X-Originating-IP`, and `X-Host`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 IP 地址通常通过公共网络设备传递给 API，比如反向代理或负载均衡器。然后，应用程序将尝试通过查找传入请求中的 HTTP 头来发现 IP 地址。一些常见的用于此目的的
    HTTP 头包括 `X-Forwarded-For`、`X-Real-IP`、`X-Originating-IP` 和 `X-Host`。
- en: 'Because clients can spoof these headers, reverse proxies may blindly forward
    misinformation to the application. For example, here is how you might pass a custom
    `X-Forwarded-For` header to DVGA with cURL:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于客户端可以伪造这些头信息，反向代理可能会将错误信息盲目转发给应用程序。例如，以下是如何使用 cURL 向 DVGA 传递自定义 `X-Forwarded-For`
    头信息的示例：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If the application allows only requests to the GraphQL API that originate from
    the network *10.0.0.0/24*, injecting such a header at a later stage could allow
    an attacker to bypass the IP-based allow list and communicate with the application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序只允许来自网络 *10.0.0.0/24* 的请求访问 GraphQL API，那么在后续阶段注入此类头信息可能会让攻击者绕过基于 IP 的允许列表，并与应用程序进行通信。
- en: Authentication Testing
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证测试
- en: 'When you’re testing GraphQL authentication, you’ll encounter certain operations
    that aren’t protected by any authentication layer. For example, unauthenticated
    users might have access to queries, while only authenticated users might be able
    to perform more sensitive, state-changing actions using mutations. You might find
    this model in use on a blog: any client can read posts, whereas only authenticated
    users can write comments.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试 GraphQL 认证时，你会遇到一些没有经过任何认证层保护的操作。例如，未认证的用户可能可以访问查询，而只有认证用户才能执行更敏感的、更改状态的操作（例如
    mutations）。你可能会在博客中看到这种模型：任何客户端都可以读取文章，而只有认证用户可以发表评论。
- en: It’s important to do a thorough scan of the target GraphQL server and schema
    for any unprotected queries. This section will outline how you can detect and
    defeat certain GraphQL authentication controls.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对目标 GraphQL 服务器和模式进行彻底扫描以查找任何未保护的查询非常重要。本节将概述如何检测和击败某些 GraphQL 认证控制。
- en: Detecting the Authentication Layer
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测认证层
- en: One of the best ways to determine whether a target GraphQL application is protected
    by an authentication layer is by sending it a canary query. Use either of the
    introspection queries from Chapter 6 or craft your own to probe the schema for
    a range of operations, objects, and types. Depending on the response you receive,
    you may be able to detect the type of authentication used, as well as the layer
    at which authentication controls are implemented. In particular, keep an eye out
    for status codes, error messages, and differences in the responses to query variations.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 确定目标 GraphQL 应用程序是否受到认证层保护的最佳方法之一是通过发送金丝雀查询。可以使用第六章中的任意 introspection 查询，或者自己编写查询来探测模式中的一系列操作、对象和类型。根据你收到的响应，你可能能够检测到使用的认证类型，以及认证控制实施的层级。特别要注意状态码、错误信息以及对查询变体的响应差异。
- en: HTTP Status Codes
  id: totrans-90
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: HTTP 状态码
- en: A sure way to verify that some sort of authentication layer exists on a GraphQL
    target is by analyzing the HTTP response you receive after sending a canary query.
    Most GraphQL implementations will always return a *200 OK* status code, even when
    the query contains typos or errors. However, if you receive a *403 Forbidden Error*,
    it’s possible that out-of-band authentication and authorization control, like
    a gateway or a WAF, has blocked your request from reaching the API in the first
    place.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 验证 GraphQL 目标是否存在某种认证层的可靠方法是分析你在发送金丝雀查询后收到的 HTTP 响应。大多数 GraphQL 实现即使查询包含拼写错误或其他错误，也会始终返回
    *200 OK* 状态码。然而，如果你收到 *403 Forbidden Error*，这可能意味着类似网关或 WAF 的带外认证和授权控制已阻止你的请求进入
    API。
- en: Error Messages
  id: totrans-92
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 错误信息
- en: Error messages can obviously reveal the presence of authentication controls,
    but they might also tell us exactly what type of authentication the API requires
    and where in the architecture these checks occur. [Table 7-2](#table7-2) shows
    a list of common in-band GraphQL authentication error messages and the authentication
    implementation known to raise the error message by default.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 错误信息显然可以揭示认证控制的存在，但它们也可能告诉我们 API 需要哪种类型的认证，以及这些检查在架构中的位置。[表 7-2](#table7-2)
    显示了常见的带内 GraphQL 认证错误信息列表以及默认情况下可能引发这些错误信息的认证实现。
- en: 'Table 7-2: Common GraphQL Authentication Errors'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-2：常见的 GraphQL 认证错误
- en: '| **Error message** | **Possible authentication implementation** |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| **错误信息** | **可能的认证实现** |'
- en: '| --- | --- |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Authentication credentials are missing. Authorization header is required
    and must contain a value.` | OAuth 2.0 Bearer with JSON Web Token |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `认证凭据缺失。需要授权头并且必须包含一个值。` | 使用 JSON Web Token 的 OAuth 2.0 Bearer |'
- en: '| `Not Authorised!` | GraphQL Shield |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `未授权！` | GraphQL Shield |'
- en: '| `Not logged in` `Auth required`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '| `未登录` `需要认证` |'
- en: '`API key is required` | GraphQL Modules |'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`需要API密钥` | GraphQL模块 |'
- en: '| `Invalid token!` `Invalid role!` | graphql-directive-auth |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `无效令牌！` `无效角色！` | graphql-directive-auth |'
- en: Error messages can be customized and might differ from those shown here. Reference
    Chapter 6 for additional information on how to abuse errors to extract valuable
    information from GraphQL. For example, a combination of a *200 OK* status code
    and an error message could indicate that authentication is required. Because these
    details may vary from one GraphQL API to another, we recommend checking all avenues.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息可以自定义，可能与此处显示的消息不同。请参考第6章，了解如何滥用错误以从GraphQL中提取有价值信息的附加信息。例如，*200 OK*状态码与错误消息的组合可能表示需要进行身份验证。由于这些详细信息可能因GraphQL
    API而异，我们建议检查所有途径。
- en: Authentication-Related Fields
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与身份验证相关的字段
- en: Another great way to detect an authentication layer is to use introspection
    queries to identify any authentication-related query or mutation operations. By
    design, in-band GraphQL authentication requires authentication, session management,
    and identity-based operations. For example, a client will most likely need to
    send unauthenticated mutation requests that perform login and sign-up operations
    to create and access their authenticated accounts. We can use the introspection
    query in [Listing 7-4](#listing7-4) to analyze the schema for any mutation operations
    related to authentication.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个检测身份验证层的好方法是使用内省查询来识别任何与身份验证相关的查询或变异操作。根据设计，在带内GraphQL身份验证中需要身份验证、会话管理和基于身份的操作。例如，客户端很可能需要发送未经身份验证的变异请求，执行登录和注册操作来创建和访问他们的经过身份验证的帐户。我们可以使用[Listing
    7-4](#listing7-4)中的内省查询来分析模式，以查找与身份验证相关的任何变异操作。
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 7-4: An introspection query used to identify all mutations'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-4：用于识别所有变异的内省查询
- en: 'Check whether the query returns any mutation names similar to these:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 检查查询是否返回类似于以下名称的变异名称：
- en: '`me`'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`me`'
- en: '`login`'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`login`'
- en: '`logout`'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`logout`'
- en: '`signup`'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`signup`'
- en: '`register`'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`register`'
- en: '`createUser`'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`createUser`'
- en: '`createAccount`'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`createAccount`'
- en: If so, you can infer that the API has an authentication layer, which means you
    can begin testing its resiliency against password brute-force attacks.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，您可以推断API具有身份验证层，这意味着您可以开始测试其抵御密码暴力攻击的韧性。
- en: Brute-Forcing Passwords by Using Query Batching
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用查询批处理进行密码暴力破解
- en: A classic authentication attack, password brute-forcing works against systems
    that fail to implement rate limits or other automated account-takeover prevention
    controls. To perform one, an attacker sends many login requests to a system in
    an attempt to correctly guess a password. This programmatic attack usually accepts
    a dictionary of possible user credentials or iterates through a sequence of characters
    to generate possible credential combinations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一种经典的身份验证攻击，密码暴力破解针对未能实施速率限制或其他自动化账户接管预防控制系统。攻击者发送许多登录请求到系统，试图正确猜测密码来执行此操作。这种程序化攻击通常接受可能的用户凭据字典或迭代字符序列以生成可能的凭据组合。
- en: Security controls such as WAFs are great at preventing excessive numbers of
    HTTP requests from a single client, and often throttle or ban the client when
    they detect such activity. However, in Chapter 5, we introduced *query batching*,
    which essentially allows a client to pack multiple query operations in a single
    HTTP request. We can take advantage of this batching feature to brute-force credentials
    by using several operations in only a single HTTP request, effectively evading
    security controls such as WAFs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 安全控制，例如WAF（Web 应用程序防火墙），非常适合防止单个客户端发出过多的HTTP请求，通常在检测到此类活动时会进行节流或禁止客户端。然而，在第5章中，我们介绍了*查询批处理*，这实质上允许客户端在单个HTTP请求中打包多个查询操作。我们可以利用这种批处理功能来通过一次HTTP请求中的多个操作来暴力破解凭据，有效地规避诸如WAF之类的安全控制。
- en: 'There are two types of batch operations: array-based and alias-based. Tools
    like BatchQL leverage array-based query batching to send multiple operations in
    a single request. However, if you return to the GraphQL Threat Matrix screenshot
    shown in Figure 3-4 of Chapter 3, you’ll notice that few GraphQL implementations
    support this type of batching. By contrast, all major GraphQL implementations
    support alias-based query batching, as it’s defined in the GraphQL spec.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种批处理操作类型：基于数组和基于别名。像BatchQL这样的工具利用基于数组的查询批处理将多个操作发送到单个请求中。然而，如果您回到第3章中图3-4展示的GraphQL威胁矩阵截图，您会注意到很少有GraphQL实现支持这种类型的批处理。相比之下，所有主要的GraphQL实现支持基于别名的查询批处理，因为它在GraphQL规范中有定义。
- en: Let’s use aliases to execute a password brute-force attack against DVGA’s GraphQL’s
    authentication layer. First, we’ll need to include multiple login operations with
    different credentials in a single GraphQL document. [Listing 7-5](#listing7-5)
    shows a GraphQL document with 10 login mutation aliases targeting the *admin*
    and *operator* user accounts in DVGA. You can also find the query in the book’s
    GitHub repository at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch07/password-brute-force.graphql](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch07/password-brute-force.graphql).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用别名对 DVGA 的 GraphQL 认证层执行密码暴力破解攻击。首先，我们需要在一个 GraphQL 文档中包含多个不同凭证的登录操作。[列表
    7-5](#listing7-5) 显示了一个 GraphQL 文档，包含了 10 个登录突变别名，针对 DVGA 中的*admin*和*operator*用户账户。你还可以在本书的
    GitHub 仓库中找到该查询，网址为 [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch07/password-brute-force.graphql](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch07/password-brute-force.graphql)。
- en: 'Each alias operation has a unique identifier, as well as a target username
    and a potential password. If one of the operations succeeds, the server should
    return the attacked user’s JWT access token (`accessToken`) in the response:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 每个别名操作都有一个唯一的标识符，以及一个目标用户名和一个潜在密码。如果其中一个操作成功，服务器应该在响应中返回被攻击用户的 JWT 访问令牌（`accessToken`）。
- en: '[PRE10]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 7-5: A password brute-forcing example using batched queries'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-5：使用批量查询进行密码暴力破解的示例
- en: Executing this password brute-force query against DVGA will result in the large
    response shown next. As you can see, most of this data consists of `Authentication
    Failure` errors. However, for `alias10`, we receive a valid `accessToken`, meaning
    we correctly brute-forced the *operator* password, which was set to *password123*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对 DVGA 执行这个密码暴力破解查询将产生如下的大量响应。如你所见，大部分数据由`身份验证失败`错误组成。然而，对于`alias10`，我们收到了有效的`accessToken`，这意味着我们成功破解了*operator*的密码，该密码为*password123*。
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Even if a security control protected the API by banning clients from making
    more than, say, five HTTP login requests per minute, this attack would evade such
    logic, because we sent only a single HTTP request while performing 10 login attempts.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有安全控制通过禁止客户端每分钟发出超过五次 HTTP 登录请求来保护 API，这种攻击也能绕过这种逻辑，因为我们在执行 10 次登录尝试时只发送了一个
    HTTP 请求。
- en: Brute-Forcing Passwords with CrackQL
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 CrackQL 进行密码暴力破解
- en: Manually building the large GraphQL document needed to successfully brute-force
    login credentials would be extremely time-consuming. In Chapter 2, you installed
    a GraphQL password brute-forcing and fuzzing tool called *CrackQL*. This tool
    accepts a single GraphQL query or mutation operation and automatically generates
    the alias payloads by using a CSV wordlist. Let’s run the same password brute-force
    attack but, this time, use CrackQL to automate it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 手动构建成功进行密码暴力破解所需的大型 GraphQL 文档将非常耗时。在第 2 章中，你安装了一个名为*CrackQL*的 GraphQL 密码暴力破解和模糊测试工具。该工具接受一个单一的
    GraphQL 查询或突变操作，并使用 CSV 字典自动生成别名有效载荷。让我们运行相同的密码暴力破解攻击，不过这次使用 CrackQL 来自动化它。
- en: Enter the CrackQL directory and then execute the brute-force attack against
    DVGA. The `-t` (target) argument specifies the destination GraphQL endpoint URL,
    the `-q` (query) argument takes a sample query (`login.graphql`), and the `-i`
    (input) argument defines the list of usernames and passwords to use in the attack.
    The `--verbose` argument allows us to view additional information such as the
    final payload before it is sent to DVGA.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 进入 CrackQL 目录，然后执行对 DVGA 的暴力破解攻击。`-t`（目标）参数指定目标 GraphQL 端点 URL，`-q`（查询）参数接受一个示例查询（`login.graphql`），`-i`（输入）参数定义了攻击中使用的用户名和密码列表。`--verbose`
    参数允许我们查看额外的信息，如发送给 DVGA 的最终有效载荷。
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: CrackQL comes preinstalled with a sample username and password CSV dictionary,
    as well as the *login.graphql* query, shown in [Listing 7-6](#listing7-6). As
    you can see, it contains a single login mutation with two embedded variables,
    `username` and `password`. CrackQL uses Jinja-templating syntax, so variables
    are passed using double curly brackets (`{{}}`).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: CrackQL 预安装了一个示例的用户名和密码 CSV 字典，以及*login.graphql*查询，如[列表 7-6](#listing7-6)所示。正如你所看到的，它包含一个包含两个嵌入变量（`username`和`password`）的单一登录突变。CrackQL
    使用 Jinja 模板语法，因此变量通过双大括号（`{{}}`）传递。
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 7-6: The sample CrackQL login brute-force query'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-6：CrackQL 登录暴力破解查询示例
- en: 'When you execute the CrackQL command, the tool will automatically take each
    username and password variable from the CSV file and inject them into a duplicated
    login operation in the same query document. CrackQL’s verbose output provides
    payload details, as well as the output results:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行 CrackQL 命令时，该工具会自动从 CSV 文件中获取每个用户名和密码变量，并将它们注入到同一查询文档中的重复登录操作中。CrackQL
    的详细输出提供了有效载荷详情以及输出结果：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In cases where GraphQL query cost controls prevent the execution of large query
    batches, CrackQL has an optional `-b` (batch) argument, which you can use to define
    a more limited set of aliased operations, allowing your attack to fly under the
    radar.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GraphQL 查询成本控制阻止执行大批量查询的情况下，CrackQL 提供了一个可选的 `-b`（批处理）参数，允许你定义一个更有限的别名操作集，从而让攻击更难被发现。
- en: You could also use CrackQL for a variety of other attacks. Using a list of possible
    one-time password tokens, CrackQL could brute-force two-factor authentication.
    It can also perform account enumeration attacks, by automating the scanning for
    valid emails or usernames, or fuzz for unique object identifiers to exploit *insecure
    direct object reference (IDOR)* vulnerabilities, where, by directly referencing
    an object identifier, we are able to access the object without being authorized
    to do so.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 CrackQL 执行多种其他攻击。通过使用一次性密码令牌的列表，CrackQL 可以暴力破解双因素认证。它还可以执行账户枚举攻击，通过自动扫描有效的电子邮件或用户名，或通过模糊测试唯一的对象标识符来利用*不安全的直接对象引用（IDOR）*漏洞，在这种漏洞中，通过直接引用对象标识符，我们能够在未授权的情况下访问该对象。
- en: 'When performing attacks against authenticated queries, you’ll likely need to
    pass it authentication headers and possibly cookies. CrackQL allows you to do
    so using the *config.py* file, which accepts `COOKIES` and `HEADERS` variables.
    Here is an example of how to supply the tool with custom headers and cookies:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在对认证查询进行攻击时，你可能需要传递身份验证头部信息，可能还需要 cookie。CrackQL 允许你通过 *config.py* 文件来做到这一点，该文件接受
    `COOKIES` 和 `HEADERS` 变量。以下是如何为工具提供自定义头部和 cookie 的示例：
- en: '[PRE15]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When performing a penetration test, you can obtain these headers by inspecting
    the network traffic with tools such as the Firefox Developer Tools’ Network tab.
    Look at any GraphQL requests that are sent after you perform an initial login
    to a website. At that point, you should see unique authentication headers or session
    cookies.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行渗透测试时，可以通过使用类似 Firefox 开发者工具的网络标签页来检查网络流量，获取这些头部信息。查看你在初次登录到网站后发送的任何 GraphQL
    请求。此时，你应该看到独特的身份验证头部或会话 cookie。
- en: Using Allow-Listed Operation Names
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用允许列表的操作名称
- en: Certain in-band GraphQL implementations may make some queries and mutations
    publicly available for unauthenticated clients, such as those for login or account
    registration. Some of these deployments use *operation name-based allow lists*,
    a weak enforcement control, to reject all unauthenticated requests unless their
    operation names are in an allow list. However, operation names can be defined
    by the client, so an attacker can bypass these authentication mechanisms by simply
    spoofing an operation’s name.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 某些内嵌式 GraphQL 实现可能会使一些查询和突变对未认证客户端公开可用，例如登录或账户注册的查询。这些部署中的一些使用*基于操作名称的允许列表*，这是一种较弱的执行控制，除非操作名称在允许列表中，否则会拒绝所有未认证的请求。然而，操作名称可以由客户端定义，因此攻击者可以通过简单地伪造操作名称来绕过这些身份验证机制。
- en: 'The following is an example of an unauthenticated mutation. As you can see,
    it would allow a user to register a new user account:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个未认证的突变示例。如你所见，它将允许用户注册一个新账户：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: An implementation may choose to allow-list this `register` operation by using
    its operation name `RegisterAccount`. As attackers, we can take advantage of this
    by sending a request like the one in [Listing 7-7](#listing7-7).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 实现可以选择通过使用其操作名称 `RegisterAccount` 来将此 `register` 操作加入允许列表。作为攻击者，我们可以利用这一点，通过发送类似[清单
    7-7](#listing7-7)中的请求来绕过验证。
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 7-7: An example operation that could bypass authentication by using
    an allow-listed operation name'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 7-7：一个可以通过使用允许列表操作名称绕过身份验证的示例操作
- en: We used the allowed operation name to withdraw money with a withdrawal mutation.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了允许的操作名称通过一个提款突变来提取资金。
- en: Forging and Leaking JWT Credentials
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 伪造和泄露 JWT 凭证
- en: 'While JWT tokens can be encrypted using JSON Web Encryption (RFC 7516), they
    often aren’t. And when they aren’t, they may leak sensitive data. For example,
    take a look at the payload section of the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JWT令牌可以使用JSON Web Encryption（RFC 7516）进行加密，但通常并不会。而当它们不加密时，可能会泄漏敏感数据。例如，看一下以下载荷部分：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When we Base64-decode the payload, we discover a hardcoded credential, `api_token`,
    in the payload section:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对载荷进行Base64解码时，我们会发现在载荷部分中有一个硬编码的凭据，`api_token`：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can gain a lot of insight into an application by decoding and testing the
    contents of JWT tokens.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过解码和测试JWT令牌的内容来深入了解应用程序。
- en: Another way to bypass weak JWT authentication controls is by forging our own
    JWT tokens. If a GraphQL API fails to correctly verify the signature of a JWT
    token, it becomes vulnerable to forgery-based attacks, in which an attacker can
    encode their own user details.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种绕过弱JWT认证控制的方法是伪造自己的JWT令牌。如果GraphQL API未能正确验证JWT令牌的签名，它将容易受到基于伪造的攻击，攻击者可以编码他们自己的用户详细信息。
- en: 'Let’s perform a JWT forgery attack against DVGA by forging the JWT token of
    an administrator. First, copy the `accessToken` JWT we received in “Brute-Forcing
    Passwords by Using Query Batching” on page 173, when we successfully brute-forced
    the *operator* password. We can verify that the `accessToken` is valid by sending
    it as a `token` argument in the `me` query operation in DVGA:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过伪造管理员的JWT令牌对DVGA进行JWT伪造攻击。首先，复制我们在“通过查询批处理暴力破解密码”中成功暴力破解*操作员*密码时收到的`accessToken`
    JWT。我们可以通过将其作为`me`查询操作中的`token`参数发送来验证`accessToken`是否有效：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'DVGA will authenticate the user based on the identity claim in the JWT and
    use the `me` query operation to return the authenticated user object fields:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: DVGA将根据JWT中的身份声明对用户进行身份验证，并使用`me`查询操作返回经过身份验证的用户对象字段：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, let’s paste the JWT string into [https://jwt.io](https://jwt.io), as shown
    in [Figure 7-3](#figure7-3). This website will automatically decode and present
    the three JWT segments in a more human-readable form.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将JWT字符串粘贴到 [https://jwt.io](https://jwt.io)，如[图7-3](#figure7-3)所示。该网站将自动解码并以更易读的形式呈现三个JWT段。
- en: 'In the right panel, we can directly modify the decoded payload’s JSON data,
    changing the `"identity": "operator"` line to `"identity": "admin"`. You’ll notice
    that [https://jwt.io](https://jwt.io) will automatically encode the payload changes
    in the left panel.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '在右侧面板中，我们可以直接修改解码后的载荷JSON数据，将`"identity": "operator"`行更改为`"identity": "admin"`。您会注意到
    [https://jwt.io](https://jwt.io) 将自动在左侧面板中编码载荷更改。'
- en: '![](image_fi/502840c07/f07003.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/502840c07/f07003.png)'
- en: 'Figure 7-3: The DVGA operator’s `accessToken`, decoded using [https://jwt.io](https://jwt.io)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图7-3：使用 [https://jwt.io](https://jwt.io) 解码后的DVGA运算符的`accessToken`
- en: 'Now try using this forged JWT token against the `me` operation. Simply copy
    the JWT and paste it into the query’s `token` argument. Because DVGA doesn’t verify
    the JWT signature, it will authenticate our request with the forged JWT token
    and return the admin user’s password:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试使用伪造的JWT令牌进行`me`操作。只需复制JWT并粘贴到查询的`token`参数中。由于DVGA未验证JWT签名，它将使用我们伪造的JWT令牌对我们的请求进行身份验证并返回管理员用户的密码：
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When a client changes a JWT token, its signature should become invalid. GraphQL
    APIs that don’t validate this signature by using their secret key will be prone
    to forgery-based attacks.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端更改JWT令牌时，其签名应变为无效。不验证此签名的GraphQL API将容易受到基于伪造的攻击。
- en: Authorization Testing
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权测试
- en: As with authentication, developers can take several approaches to implementing
    authorization. When given a limited GraphQL user account, we, as hackers, should
    see how far we can escalate our privileges. In particular, we should determine
    whether we’re able to bypass controls intended to prevent us from reading user
    data or performing certain elevated functions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与认证一样，开发人员可以采用多种方法实现授权。当给定有限的GraphQL用户帐户时，作为黑客，我们应该看看我们能够提升多少权限。特别是，我们应确定是否能够绕过旨在防止我们读取用户数据或执行某些提升功能的控制。
- en: Like REST, GraphQL can be vulnerable to a variety of authorization attacks,
    depending on how the API handles permission controls. Failure to protect unauthorized
    access at the function level may result in the leakage of sensitive data or the
    execution of damaging operations.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 像REST一样，GraphQL可能会因API处理权限控制不当而容易受到各种授权攻击的威胁。在函数级别未能保护未经授权访问可能导致敏感数据泄露或执行破坏性操作。
- en: GraphQL-specific authorization flaws typically arise when permission checks
    occur at the resolver level or after the execution of any business logic or state
    changes. Let’s learn to detect some of these authorization approaches and explore
    the attacks to which they might be vulnerable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 特有的授权漏洞通常发生在权限检查发生在解析器级别，或者在任何业务逻辑或状态变化执行后。让我们学习如何检测这些授权方法，并探索它们可能面临的攻击。
- en: Detecting the Authorization Layer
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检测授权层
- en: We can go about detecting whether an API uses authorization controls, and of
    what type, in several ways.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式来检测 API 是否使用授权控制，以及使用的是哪种类型的控制。
- en: Finding Schema Directives
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 查找模式指令
- en: We mentioned earlier that developers sometimes implement authorization by using
    schema directives. You can identify these schema directives if you have access
    to the API’s SDL files. Alternatively, you can send a specialized introspection
    query, like the one in [Listing 7-8](#listing7-8).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，开发者有时通过使用模式指令来实现授权。如果你有权限访问 API 的 SDL 文件，你可以识别这些模式指令。或者，你可以发送一个专门的 introspection
    查询，比如 [列表 7-8](#listing7-8) 中的查询。
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Listing 7-8: An introspection query to fetch directive names and arguments'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-8：获取指令名称和参数的 introspection 查询
- en: Running this query will return a list of all the query- and schema-level directives
    in the target server. If you notice the `@auth` directive in the list, you can
    assume that the schema supports it. Of course, developers can call directives
    different things, so also look for names like `@authorize`, `@authorization`,
    `@authz`, and others.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个查询将返回目标服务器中所有查询级别和模式级别的指令列表。如果你在列表中发现 `@auth` 指令，你可以假设该模式支持它。当然，开发者可能会给指令取不同的名字，因此还要留意类似
    `@authorize`、`@authorization`、`@authz` 等名称。
- en: Finding Authentication Directives in the Schema
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在模式中查找身份验证指令
- en: If we perform an introspection query to identify directives, we’ll know whether
    an `@auth` directive exists. However, we won’t know where this directive is applied
    in the schema, as this information isn’t exposed in an introspection query. That’s
    because clients don’t call schema-level directives; instead, developers use them
    to protect against unauthorized access, among other use cases.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行一个 introspection 查询来识别指令，我们将知道是否存在 `@auth` 指令。然而，我们并不知道该指令在模式中的应用位置，因为这些信息在
    introspection 查询中并未暴露。这是因为客户端不会调用模式级别的指令；相反，开发者使用它们来防止未经授权的访问等情况。
- en: Take a look at the `User` object type in [Listing 7-9](#listing7-9) as an example.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [列表 7-9](#listing7-9) 中的 `User` 对象类型作为示例。
- en: '[PRE24]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 7-9: An `@auth` directive usage example in a schema'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7-9：模式中 `@auth` 指令的使用示例
- en: You’ll find scanning the schema for `@auth` directives useful in white-box penetration
    tests, which provide you with the SDL files. But in black-box tests that provide
    no access to the schema, you might know that the `password` field exists, for
    example, but not that the `@auth` directive applies to it.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在白盒渗透测试中，扫描 `@auth` 指令的模式非常有用，白盒测试提供了 SDL 文件。但在黑盒测试中，如果无法访问模式，你可能知道 `password`
    字段的存在，但并不知道 `@auth` 指令是否应用于该字段。
- en: The GraphQL developer community has discussed exposing information about the
    use of schema-level directives in the introspection system. However, many GraphQL
    implementations currently don’t expose this information.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 开发者社区曾讨论过在 introspection 系统中暴露关于使用模式级别指令的信息。然而，目前许多 GraphQL 实现并未暴露这些信息。
- en: Enumerating Paths with graphql-path-enum
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 graphql-path-enum 枚举路径
- en: 'To test authorization controls, you should try accessing sensitive fields in
    as many ways as you can imagine. For example, consider the following excerpt from
    the DVGA’s schema, in which three queries access the `PasteObject`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试授权控制，你应该尝试通过尽可能多的方式访问敏感字段。例如，考虑 DVGA 模式中的以下片段，其中有三个查询访问 `PasteObject`：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As a client, you could return information about pastes by using either `pastes`,
    `paste`, or `readAndBurn`. When implementing in-band authorization, a developer
    might accidentally protect only some of these queries. As such, determine all
    possible paths to a given object type.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 作为客户端，你可以通过使用 `pastes`、`paste` 或 `readAndBurn` 返回粘贴信息。在实施带内授权时，开发者可能会不小心只保护其中一些查询。因此，确定访问给定对象类型的所有可能路径。
- en: 'Schemas can be very large, so you’ll find it helpful to automate the process
    of identifying all paths to a given object type. For this task, we’ll use graphql-path-enum.
    This tool expects two important arguments: the introspection JSON response and
    the name of an object type we want to test for authorization issues. Let’s use
    it to find all paths to the `PasteObject` object type.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 模式可能非常庞大，因此在识别所有通往特定对象类型路径的过程中自动化处理将非常有帮助。对于这个任务，我们将使用graphql-path-enum。这个工具期望两个重要的参数：内省JSON响应和我们想要测试授权问题的对象类型的名称。让我们使用它来查找到`PasteObject`对象类型的所有路径。
- en: First, run a full introspection query by pasting the query from [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/queries/introspection_query.txt](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/queries/introspection_query.txt)
    into Altair. Send the request and copy the response to a file named *introspection.json*.
    Next, provide graphql-path-enum with this file and tell it to search for all paths
    leading to the `PasteObject` object, as shown in [Listing 7-10](#listing7-10).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过将查询从[https://github.com/dolevf/Black-Hat-GraphQL/blob/master/queries/introspection_query.txt](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/queries/introspection_query.txt)粘贴到Altair中来运行完整的内省查询。发送请求并将响应复制到名为*introspection.json*的文件中。接下来，提供这个文件给graphql-path-enum，并告诉它搜索所有导致`PasteObject`对象的路径，如[7-10列表](#listing7-10)中所示。
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 7-10: Performing type path enumeration with graphql-path-enum'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7-10：使用graphql-path-enum执行类型路径枚举
- en: As you can see, graphql-path-enum traversed the introspection response and identified
    all possible query paths to the object. Now we can manually send these three queries
    to see whether any of them grant access to objects that other queries don’t.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，graphql-path-enum遍历了内省响应并标识了通向对象的所有可能查询路径。现在我们可以手动发送这三个查询，看看是否有任何一个允许访问其他查询不允许的对象。
- en: If you’d like to practice schema traversal in a large, complex GraphQL API,
    try running graphql-path-enum against the `Vehicle` object type in the popular
    Star Wars API (SWAPI). This API’s schema is larger than that of the DVGA and should
    illustrate the importance of path enumeration when testing for authorization issues.
    You can access the SWAPI schema at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch07/starwars-schema.json](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch07/starwars-schema.json).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在一个大而复杂的GraphQL API中练习模式遍历，请尝试对着名的星球大战API（SWAPI）中的`Vehicle`对象类型运行graphql-path-enum。这个API的模式比DVGA的模式要大，并且应该说明在测试授权问题时路径枚举的重要性。您可以在[https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch07/starwars-schema.json](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch07/starwars-schema.json)访问SWAPI模式。
- en: Brute-Forcing Arguments and Fields with CrackQL
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用CrackQL进行参数和字段的暴力破解
- en: 'Because graphql-path-enum works for only object types, you might try the field-stuffing
    technique discussed in Chapter 6 to test for weak or nonexistent authorization
    controls intended to limit the amount of data an unprivileged user can view. We
    can also use CrackQL to programmatically brute-force arguments and fields to which
    we shouldn’t have access. Imagine a query that looks like the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因为graphql-path-enum仅适用于对象类型，您可以尝试在第6章中讨论的字段填充技术，以测试旨在限制非特权用户可以查看的数据量的弱或不存在的授权控制。我们还可以使用CrackQL来程序化地暴力破解我们不应该访问的参数和字段。想象一下以下查询：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, say that accessing information about certain users requires special authorization
    permissions. We know that the user IDs are numerical and incremental, but not
    which are protected. Let’s attempt to brute-force them all with CrackQL.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设访问某些用户信息需要特殊的授权权限。我们知道用户ID是数字递增的，但不知道哪些受保护。让我们尝试用CrackQL来暴力破解它们。
- en: 'In the CrackQL folder, under *sample-queries*, create a new file named *users.graphql*
    with the following content:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在CrackQL文件夹下的*sample-queries*文件夹中，创建一个名为*users.graphql*的新文件，并包含以下内容：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This query uses the `users` field with an `id` parameter of the `Int` type.
    Because the query takes an `id` argument, we can attempt to enumerate accounts
    by incrementally supplying a list of numerical user identifiers. CrackQL will
    render the `{{id|int}}` string and replace it with words from a wordlist we will
    create next.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询使用了带有`Int`类型的`id`参数的`users`字段。因为查询接受`id`参数，我们可以尝试通过逐步提供数字用户标识符列表来枚举帐户。CrackQL将渲染`{{id|int}}`字符串，并使用我们即将创建的词表中的单词替换它。
- en: 'Let’s create this dictionary of possible user IDs as a one-column CSV wordlist.
    Such a list is easy to generate with some Bash-fu:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个可能的用户ID字典，作为一个单列CSV词表。使用一些Bash技巧可以轻松生成这样的列表：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, check that the file was generated properly by printing the first five
    lines:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过打印前五行来检查文件是否已正确生成：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now run CrackQL to find valid user IDs and retrieve their username and password
    fields:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '现在运行 CrackQL 以查找有效的用户 ID 并检索其用户名和密码字段：  '
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also, in the same fashion, brute-force fields that you suspect you
    won’t be able to access because of authorization controls by simply modifying
    the original query to include these potential fields:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '你还可以以相同的方式，暴力破解你怀疑由于授权控制无法访问的字段，只需修改原始查询以包含这些潜在字段：  '
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: CrackQL will save the output of all attempts under the *~/CrackQL/results* folder.
    If these fields are accessible, you’ll see the responses to them there.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 'CrackQL 会将所有尝试的输出保存在 *~/CrackQL/results* 文件夹中。如果这些字段是可访问的，你将在该处看到相应的响应。  '
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '概述  '
- en: In this chapter, you learned about in-band and out-of-band GraphQL authentication
    and authorization architectural models. We reviewed a few traditional controls
    developers may have adopted in their GraphQL deployments and called out the weaknesses
    to which they might be susceptible. For example, GraphQL implementations that
    use JWT tokens might be vulnerable to token forging. We also directed your attention
    to newer, GraphQL-specific authentication and authorization libraries and plug-ins,
    such as GraphQL Modules, GraphQL Shield, and custom schema directives.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '本章介绍了带内和带外 GraphQL 身份验证与授权的架构模型。我们回顾了一些开发者可能在其 GraphQL 部署中采用的传统控制方法，并指出了这些方法可能容易受到的弱点。例如，使用
    JWT 令牌的 GraphQL 实现可能容易受到令牌伪造的攻击。我们还将你的注意力引导到一些更新的、专门为 GraphQL 设计的身份验证与授权库和插件，如
    GraphQL Modules、GraphQL Shield 和自定义 schema 指令。  '
- en: By taking advantage of GraphQL features like alias-based query batching, we
    can brute-force in-band authentication operations manually or use CrackQL to do
    this automatically. Using graphql-path-enum, we can enumerate paths to types,
    and using CrackQL once again, we can potentially access fields without proper
    authorization controls.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '通过利用 GraphQL 的特性，如基于别名的查询批处理，我们可以手动进行暴力破解带内身份验证操作，或者使用 CrackQL 自动完成此操作。使用 graphql-path-enum，我们可以枚举类型的路径，再次使用
    CrackQL，我们可以在没有适当授权控制的情况下访问字段。  '
- en: 'In the next chapter, we’ll turn to another age-old vulnerability class: injections,
    which continue to wreak havoc even against modern API services like GraphQL.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '在下一章中，我们将讨论另一类古老的漏洞：注入攻击，这些攻击即便在现代 API 服务（如 GraphQL）面前依然能够肆虐。  '
