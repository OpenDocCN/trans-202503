- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication and Authorization Bypasses
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: Out of the box, GraphQL has no authentication or authorization controls. As
    a result, the ecosystem has created its own or adopted those seen in traditional
    systems. In this chapter, we’ll cover the common GraphQL authentication and authorization
    implementations. Then we’ll discuss attacks that target some of their weaknesses.
  prefs: []
  type: TYPE_NORMAL
- en: '*Authentication* is the mechanism by which a client proves their identity to
    a server. It answers the question: Is the user really who they say they are? Authentication
    attacks target a client’s identity, attempting to either steal credentials or
    spoof them to authenticate with a server, take certain actions on their behalf,
    or steal data to which they have access.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Authorization* controls are responsible for granting access to data and ensuring
    that the actions an entity takes, whether they’re a human or a machine, match
    their assigned roles, groups, and permissions. Authorization attacks attempt to
    either bypass a security control entirely or poke holes in it, allowing an attacker
    to take actions that wouldn’t otherwise be possible. For example, they might gain
    unauthorized access to system data or perform privileged actions, such as setting
    another user’s password.'
  prefs: []
  type: TYPE_NORMAL
- en: Authentication and authorization controls can be challenging to implement. This
    is especially true when an application creates its own mechanisms from scratch
    instead of using the many battle-tested frameworks available for specific programming
    languages. Performing security testing of such controls is also a nontrivial task;
    security tools (such as API application scanners) struggle to identify authorization
    and authentication issues. One of the primary reasons is that scanners have no
    contextual understanding of the application’s business logic.
  prefs: []
  type: TYPE_NORMAL
- en: For years, hackers have defeated both authentication and authorization defenses
    by taking advantage of weak passwords, default credentials, forged tokens, flawed
    account recovery processes, replay attacks, and poor rate-limit controls. Not
    only is exploiting these weaknesses possible in GraphQL implementations, but,
    in many cases, GraphQL’s client-empowering features actually enable hackers to
    optimize their attacks, as you’ll soon learn.
  prefs: []
  type: TYPE_NORMAL
- en: The State of Authentication and Authorization in GraphQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GraphQL spec has left implementers to fend for themselves when it comes
    to authentication and authorization. This lack of a detailed standard has led
    developers to select and deploy their own GraphQL authentication and authorization
    controls from a variety of libraries, tools, and configurations, often leading
    to vulnerabilities and implementation gaps.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll sink our teeth into the ecosystem-driven authentication
    and authorization services, libraries, and plug-ins available for GraphQL. Broadly,
    these approaches follow two distinct architectural deployment models: in-band
    and out-of-band.'
  prefs: []
  type: TYPE_NORMAL
- en: In-Band vs. Out-of-Band
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In an *in-band* authentication and authorization architecture, developers implement
    client login, signup, role-based access controls, and other permission controls
    directly in the GraphQL API. The same GraphQL instance that provides clients with
    their application data also controls the logic that authenticates clients and
    grants them permissions to view data. In-band GraphQL architectures typically
    host query or mutation operations that enable clients to send credentials to the
    API. The API is responsible for verifying these credentials and then issuing tokens
    to the clients.
  prefs: []
  type: TYPE_NORMAL
- en: '*Out-of-band* authentication and authorization architectures implement the
    access control and permissions logic on either a separate internal web application
    service or an external system. In such an architecture, the GraphQL API isn’t
    responsible for managing client login, signup, or even access control. Instead,
    it offloads authorization decisions to another component, such as an API gateway,
    a container sidecar, or another server on the network. This allows developers
    to decouple the authorization logic from the GraphQL application.'
  prefs: []
  type: TYPE_NORMAL
- en: Of the two architectural styles, in-band architectures tend to be more vulnerable
    to authentication and authorization attacks. Their added complexity increases
    an API’s attack surface drastically. These APIs often duplicate permission logic
    for each entry point into the service, and as you’ll see later in this chapter,
    we, as hackers, can take advantage of even the slightest misaligned control.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, some contributors to the GraphQL ecosystem advocate for keeping authentication
    and authorization logic outside of GraphQL. The current industry best practice
    is to delegate authorization logic to the *business logic layer* of an application,
    which serves as the single source of truth for all business domain rules. It should
    sit between the GraphQL layer and the *persistence layer* (also known as the *database*
    or *datastore* layer), as shown in [Figure 7-1](#figure7-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c07/f07001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-1: The gateway, API, business, and persistence layers'
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, authentication for the entire GraphQL API should occur in an external
    or third-party *gateway layer*, which passes authenticated user contexts along
    to the API.
  prefs: []
  type: TYPE_NORMAL
- en: Common Approaches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no way to know what kinds of controls you’ll come across during your
    GraphQL hacking adventures. However, this section lists some of the common approaches
    we’ve seen in our research and testing. By understanding these techniques, you’ll
    be better equipped to detect them, as well as evaluate the vulnerabilities to
    which they may be susceptible.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Basic Authentication
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'One of the most rudimentary GraphQL authentication methods is *HTTP basic authentication*.
    Defined in RFC 7617, this scheme involves the inclusion of a Base64-encoded username
    and password in the header of a client request. The header looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The Base64-encoded username and password are joined by a colon into a single
    credential.
  prefs: []
  type: TYPE_NORMAL
- en: Basic authentication is a simple technique that does not require cookies, session
    identifiers, or login pages. To detect basic authentication, we can use our browser.
    [Figure 7-2](#figure7-2) is an example of an automatic browser pop-up used to
    collect and encode credentials for basic authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c07/f07002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-2: A browser pop-up example of basic authentication'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the weaknesses of this method is the lack of confidentiality protections
    in place when transmitting the credentials to a GraphQL server over HTTP. Imagine
    a basic authentication header such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the credentials are encoded using Base64 and sent on every request
    (by contrast, other systems might generate a temporary session token upon login),
    the attack window from which to steal such credentials is larger. The risk of
    transmitting credentials over an unencrypted channel can be mitigated through
    the use of TLS. However, if the credentials are stolen, an attacker can Base64-decode
    them fairly easily. To test this, open your terminal and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Another weakness in basic authentication is the lack of any supported logout
    feature that would invalidate the credential. An attacker who steals basic authentication
    credentials has permanent access to the API until an admin changes the credentials.
    It’s rare to see basic authentication used in production-grade applications. You
    have a higher chance of stumbling upon the mechanism in testing or staging environments,
    as a quick-and-dirty method of protecting the application, but anything is possible!
  prefs: []
  type: TYPE_NORMAL
- en: OAuth 2.0 and JSON Web Token
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*Open Authorization (OAuth)* is an authorization framework that enables a third
    party to obtain temporary access to an HTTP service such as a GraphQL API. This
    access is obtained by orchestrating a grant process between the user and the API,
    or by allowing a third-party application to obtain access on behalf of the user.'
  prefs: []
  type: TYPE_NORMAL
- en: You may have encountered OAuth in the past if you’ve ever logged in to a website
    by clicking a button that says something like *Log in with Google*. We’ll only
    scratch the surface of OAuth 2.0 in this section, but if you’re interested in
    learning more about it, you can find information at [https://datatracker.ietf.org/doc/html/rfc6749](https://datatracker.ietf.org/doc/html/rfc6749).
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you’re performing a penetration test against an application, such
    as an e-commerce app, that has a login mechanism in place to prevent unauthorized
    access. The OAuth protocol allows the e-commerce app (or the *client*, in OAuth
    terminology) to request authorization from a *resource owner* (you, the penetration
    tester, who needs to log in). When the authorization request is granted (also
    called an *authorization grant*), the e-commerce app will obtain an access token
    that it can use to access certain resources on a resource server. This resource
    server can be a GraphQL server. It will check the access token and, if it is found
    valid, service the request by allowing the client to perform queries to a resource
    (also called a *protected resource*).
  prefs: []
  type: TYPE_NORMAL
- en: Applications that leverage the OAuth 2.0 framework can use *JSON Web Token (JWT)*
    as their token format. JWT is an open standard (defined in RFC 7519) that allows
    for the secure transmission of information between systems via a JSON object.
    Servers can verify JWT tokens through digital signatures and encryption. A JWT
    token comprises three distinct sections that are Base64-encoded and separated
    by periods (`.`), as shown in [Listing 7-1](#listing7-1). These three parts are
    the header, payload, and signature.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-1: A sample JWT token'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *header*, or the JWT token’s first section, defines two important details:
    the type of token and the signing algorithm. When we Base64-decode this header,
    we should be able see its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `typ` key is a header parameter that declares structural media type information
    about the JWT token. In this case, the media type is `JWT`. The full list of possible
    media types can be found at [https://www.iana.org/assignments/media-types/media-types.xhtml](https://www.iana.org/assignments/media-types/media-types.xhtml).
    This header parameter is considered optional but can be set so the application
    reading the header is aware of the object type structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `alg` key defines the JWT token’s signing algorithm used to ensure the
    token’s integrity. This key can represent different signing algorithms, such as
    these:'
  prefs: []
  type: TYPE_NORMAL
- en: No digital signature (`none`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HMAC with SHA-256 (`HS256`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HMAC with SHA-384 (`HS384`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RSA with SHA-256 (`RS256`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RSA with SHA-384 (`RS384`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Hash-based message authentication code (HMAC)* is a symmetric cryptographic
    authentication technique (meaning it uses a shared secret), whereas *Rivest-Shamir-Adleman
    (RSA)* is asymmetric (using public- and private-key pairs). The full list of signing
    algorithms can be found in RFC 7518.'
  prefs: []
  type: TYPE_NORMAL
- en: A common attack against applications using JWT involves setting the `alg` header
    parameter to `none`. If an application accepts unsigned JWT tokens, hackers can
    tamper with their JWT token to identify as another user or perform sensitive actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *payload* section, or the second part of the JWT, contains relevant information
    about the user, as well as any additional data the developers might find useful
    to include. In our example, the decoded payload should match this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Most JWT payloads will include a few standard elements, called *claims*, including
    an `iat` field, which represents the timestamp at which the JWT was initiated,
    and the `exp` field, which represents the expiry timestamp in Unix timestamp format.
    You can learn more about JWT fields by reading the RFC 7519 documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The last part of the JWT is the *signature*, which ensures that the entire JWT
    wasn’t tampered with. Any manual change to the JWT should invalidate this signature,
    causing the GraphQL server to reject the token. As you’ll soon learn, vulnerabilities
    in a GraphQL server’s signature verification may allow an attacker to forge JWT
    tokens. In “Forging and Leaking JWT Credentials” on page 178, we’ll touch on a
    few common JWT implementation weaknesses and how to exploit them.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL Modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When testing JavaScript-based GraphQL implementations, you may come across a
    utility library known as *GraphQL Modules*, built by The Guild ([https://www.the-guild.dev](https://www.the-guild.dev)).
    This library separates GraphQL schemas into smaller, reusable modules that act
    as middleware. Developers can then use these to wrap their resolvers. [Listing
    7-2](#listing7-2) is the Authentication module, which provides GraphQL clients
    with a standard set of login, signup, and user-lookup mutations and queries.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-2: The Authentication module from the GraphQL Modules library'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the module defines a query named `me` that returns a `User`
    object, as well as two mutations, named `login` and `signup`, that accept `username`
    and `password` arguments and return a `User` object.
  prefs: []
  type: TYPE_NORMAL
- en: Developers could also implement custom `login` query and `signup` mutation operations
    in their GraphQL APIs without using an external library. In “Authentication Testing”
    on page 171, we’ll teach you how to defeat in-band authentication operations like
    the examples mentioned here by using batched queries, introduced in Chapter 5,
    and CrackQL, installed in Chapter 2.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL Shield
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '*GraphQL Shield* is another middleware library, built by The Guild, for generating
    an authorization layer in GraphQL APIs. It allows developers to define rules that
    either permit or deny client access. [Listing 7-3](#listing7-3) shows queries
    and mutations protected by GraphQL Shield, which defines the permissions and roles
    required to access each query.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-3: A GraphQL Shield code example'
  prefs: []
  type: TYPE_NORMAL
- en: Clients wishing to use the `frontPage` query don’t have to be authenticated,
    as defined by the rule `not(isAuthenticated)`, whereas to use the `customers`
    query, they have to both be authenticated and have an admin user, as indicated
    by `and(isAuthenticated, isAdmin)`. The `and` operator mandates that both conditions
    must be true for permission to be granted.
  prefs: []
  type: TYPE_NORMAL
- en: A developer community actively maintains GraphQL Shield and continuously improves
    it. As of this writing, the last documented vulnerability in GraphQL Shield was
    an authorization bypass that dates back to 2020 in versions earlier than 6.0.6.
  prefs: []
  type: TYPE_NORMAL
- en: When performing a code review, look for the GraphQL Shield component called
    the `fallbackRule`. This rule can determine whether a request should be allowed
    or denied by default whenever a rule is not defined. By default, `fallbackRule`
    is set to `allow`. To read more about GraphQL Shield rules, refer to the official
    documentation at [https://www.graphql-shield.com/docs/rules#logic-rules](https://www.graphql-shield.com/docs/rules#logic-rules).
  prefs: []
  type: TYPE_NORMAL
- en: Schema Directives
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: GraphQL deployments might use custom schema-level directives to apply both authentication
    and authorization controls on certain operations and fields. By decorating schema
    components, these custom directives can control what clients can and can’t do
    in the API. We can use them to enforce security at the query level, type level,
    field level, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The graphql-directive-auth library ([https://github.com/graphql-community/graphql-directive-auth](https://github.com/graphql-community/graphql-directive-auth))
    provides one example of how developers could apply directives to solve authentication
    and authorization gaps in their APIs. In some implementations, the `@auth` directive
    accepts a `requires` argument, which takes a string value representing the role
    or group a user needs in order to query the field. Clients usually send these
    user groups or roles through a JWT payload. The directive logic analyzes these
    to either allow or deny access to protected elements of the schema.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization directives can have various other names or arguments. [Table 7-1](#table7-1)
    is a list of common ones you might encounter in your introspection hunts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 7-1: Common GraphQL Authorization Directives'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Directive name** | **Argument name** | **Argument type** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@auth` | `requires` | `String` |'
  prefs: []
  type: TYPE_TB
- en: '| `@protect` | `role` | `String` |'
  prefs: []
  type: TYPE_TB
- en: '| `@hasRole` | `role` | `String` |'
  prefs: []
  type: TYPE_TB
- en: Some `@auth` directives might also use an argument called `permissions`, which
    accepts a list of scope grants.
  prefs: []
  type: TYPE_NORMAL
- en: IP-Based Allow Listing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Some GraphQL APIs, particularly those deployed in internal systems that aren’t
    public facing, may choose not to authenticate individual client requests. Instead,
    they might opt to use an allow list of source IP addresses to authorize clients.
    In this technique, the server checks the client IP address included in a network
    request against a list of addresses or network range (such as *10.0.0.0/24*).
  prefs: []
  type: TYPE_NORMAL
- en: This IP address often gets passed to the API by a public-facing network device,
    such as a reverse proxy or a load balancer. Applications will then attempt to
    discover the IP address by looking for HTTP headers set on incoming requests.
    A few common HTTP headers for this purpose are `X-Forwarded-For`, `X-Real-IP`,
    `X-Originating-IP`, and `X-Host`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because clients can spoof these headers, reverse proxies may blindly forward
    misinformation to the application. For example, here is how you might pass a custom
    `X-Forwarded-For` header to DVGA with cURL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: If the application allows only requests to the GraphQL API that originate from
    the network *10.0.0.0/24*, injecting such a header at a later stage could allow
    an attacker to bypass the IP-based allow list and communicate with the application.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you’re testing GraphQL authentication, you’ll encounter certain operations
    that aren’t protected by any authentication layer. For example, unauthenticated
    users might have access to queries, while only authenticated users might be able
    to perform more sensitive, state-changing actions using mutations. You might find
    this model in use on a blog: any client can read posts, whereas only authenticated
    users can write comments.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to do a thorough scan of the target GraphQL server and schema
    for any unprotected queries. This section will outline how you can detect and
    defeat certain GraphQL authentication controls.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the Authentication Layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the best ways to determine whether a target GraphQL application is protected
    by an authentication layer is by sending it a canary query. Use either of the
    introspection queries from Chapter 6 or craft your own to probe the schema for
    a range of operations, objects, and types. Depending on the response you receive,
    you may be able to detect the type of authentication used, as well as the layer
    at which authentication controls are implemented. In particular, keep an eye out
    for status codes, error messages, and differences in the responses to query variations.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Status Codes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A sure way to verify that some sort of authentication layer exists on a GraphQL
    target is by analyzing the HTTP response you receive after sending a canary query.
    Most GraphQL implementations will always return a *200 OK* status code, even when
    the query contains typos or errors. However, if you receive a *403 Forbidden Error*,
    it’s possible that out-of-band authentication and authorization control, like
    a gateway or a WAF, has blocked your request from reaching the API in the first
    place.
  prefs: []
  type: TYPE_NORMAL
- en: Error Messages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Error messages can obviously reveal the presence of authentication controls,
    but they might also tell us exactly what type of authentication the API requires
    and where in the architecture these checks occur. [Table 7-2](#table7-2) shows
    a list of common in-band GraphQL authentication error messages and the authentication
    implementation known to raise the error message by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 7-2: Common GraphQL Authentication Errors'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Error message** | **Possible authentication implementation** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Authentication credentials are missing. Authorization header is required
    and must contain a value.` | OAuth 2.0 Bearer with JSON Web Token |'
  prefs: []
  type: TYPE_TB
- en: '| `Not Authorised!` | GraphQL Shield |'
  prefs: []
  type: TYPE_TB
- en: '| `Not logged in` `Auth required`'
  prefs: []
  type: TYPE_NORMAL
- en: '`API key is required` | GraphQL Modules |'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Invalid token!` `Invalid role!` | graphql-directive-auth |'
  prefs: []
  type: TYPE_TB
- en: Error messages can be customized and might differ from those shown here. Reference
    Chapter 6 for additional information on how to abuse errors to extract valuable
    information from GraphQL. For example, a combination of a *200 OK* status code
    and an error message could indicate that authentication is required. Because these
    details may vary from one GraphQL API to another, we recommend checking all avenues.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication-Related Fields
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another great way to detect an authentication layer is to use introspection
    queries to identify any authentication-related query or mutation operations. By
    design, in-band GraphQL authentication requires authentication, session management,
    and identity-based operations. For example, a client will most likely need to
    send unauthenticated mutation requests that perform login and sign-up operations
    to create and access their authenticated accounts. We can use the introspection
    query in [Listing 7-4](#listing7-4) to analyze the schema for any mutation operations
    related to authentication.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-4: An introspection query used to identify all mutations'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check whether the query returns any mutation names similar to these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`me`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`login`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`logout`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`signup`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`register`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`createUser`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`createAccount`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If so, you can infer that the API has an authentication layer, which means you
    can begin testing its resiliency against password brute-force attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Brute-Forcing Passwords by Using Query Batching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A classic authentication attack, password brute-forcing works against systems
    that fail to implement rate limits or other automated account-takeover prevention
    controls. To perform one, an attacker sends many login requests to a system in
    an attempt to correctly guess a password. This programmatic attack usually accepts
    a dictionary of possible user credentials or iterates through a sequence of characters
    to generate possible credential combinations.
  prefs: []
  type: TYPE_NORMAL
- en: Security controls such as WAFs are great at preventing excessive numbers of
    HTTP requests from a single client, and often throttle or ban the client when
    they detect such activity. However, in Chapter 5, we introduced *query batching*,
    which essentially allows a client to pack multiple query operations in a single
    HTTP request. We can take advantage of this batching feature to brute-force credentials
    by using several operations in only a single HTTP request, effectively evading
    security controls such as WAFs.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of batch operations: array-based and alias-based. Tools
    like BatchQL leverage array-based query batching to send multiple operations in
    a single request. However, if you return to the GraphQL Threat Matrix screenshot
    shown in Figure 3-4 of Chapter 3, you’ll notice that few GraphQL implementations
    support this type of batching. By contrast, all major GraphQL implementations
    support alias-based query batching, as it’s defined in the GraphQL spec.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use aliases to execute a password brute-force attack against DVGA’s GraphQL’s
    authentication layer. First, we’ll need to include multiple login operations with
    different credentials in a single GraphQL document. [Listing 7-5](#listing7-5)
    shows a GraphQL document with 10 login mutation aliases targeting the *admin*
    and *operator* user accounts in DVGA. You can also find the query in the book’s
    GitHub repository at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch07/password-brute-force.graphql](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch07/password-brute-force.graphql).
  prefs: []
  type: TYPE_NORMAL
- en: 'Each alias operation has a unique identifier, as well as a target username
    and a potential password. If one of the operations succeeds, the server should
    return the attacked user’s JWT access token (`accessToken`) in the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-5: A password brute-forcing example using batched queries'
  prefs: []
  type: TYPE_NORMAL
- en: Executing this password brute-force query against DVGA will result in the large
    response shown next. As you can see, most of this data consists of `Authentication
    Failure` errors. However, for `alias10`, we receive a valid `accessToken`, meaning
    we correctly brute-forced the *operator* password, which was set to *password123*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Even if a security control protected the API by banning clients from making
    more than, say, five HTTP login requests per minute, this attack would evade such
    logic, because we sent only a single HTTP request while performing 10 login attempts.
  prefs: []
  type: TYPE_NORMAL
- en: Brute-Forcing Passwords with CrackQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Manually building the large GraphQL document needed to successfully brute-force
    login credentials would be extremely time-consuming. In Chapter 2, you installed
    a GraphQL password brute-forcing and fuzzing tool called *CrackQL*. This tool
    accepts a single GraphQL query or mutation operation and automatically generates
    the alias payloads by using a CSV wordlist. Let’s run the same password brute-force
    attack but, this time, use CrackQL to automate it.
  prefs: []
  type: TYPE_NORMAL
- en: Enter the CrackQL directory and then execute the brute-force attack against
    DVGA. The `-t` (target) argument specifies the destination GraphQL endpoint URL,
    the `-q` (query) argument takes a sample query (`login.graphql`), and the `-i`
    (input) argument defines the list of usernames and passwords to use in the attack.
    The `--verbose` argument allows us to view additional information such as the
    final payload before it is sent to DVGA.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: CrackQL comes preinstalled with a sample username and password CSV dictionary,
    as well as the *login.graphql* query, shown in [Listing 7-6](#listing7-6). As
    you can see, it contains a single login mutation with two embedded variables,
    `username` and `password`. CrackQL uses Jinja-templating syntax, so variables
    are passed using double curly brackets (`{{}}`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-6: The sample CrackQL login brute-force query'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you execute the CrackQL command, the tool will automatically take each
    username and password variable from the CSV file and inject them into a duplicated
    login operation in the same query document. CrackQL’s verbose output provides
    payload details, as well as the output results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In cases where GraphQL query cost controls prevent the execution of large query
    batches, CrackQL has an optional `-b` (batch) argument, which you can use to define
    a more limited set of aliased operations, allowing your attack to fly under the
    radar.
  prefs: []
  type: TYPE_NORMAL
- en: You could also use CrackQL for a variety of other attacks. Using a list of possible
    one-time password tokens, CrackQL could brute-force two-factor authentication.
    It can also perform account enumeration attacks, by automating the scanning for
    valid emails or usernames, or fuzz for unique object identifiers to exploit *insecure
    direct object reference (IDOR)* vulnerabilities, where, by directly referencing
    an object identifier, we are able to access the object without being authorized
    to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'When performing attacks against authenticated queries, you’ll likely need to
    pass it authentication headers and possibly cookies. CrackQL allows you to do
    so using the *config.py* file, which accepts `COOKIES` and `HEADERS` variables.
    Here is an example of how to supply the tool with custom headers and cookies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When performing a penetration test, you can obtain these headers by inspecting
    the network traffic with tools such as the Firefox Developer Tools’ Network tab.
    Look at any GraphQL requests that are sent after you perform an initial login
    to a website. At that point, you should see unique authentication headers or session
    cookies.
  prefs: []
  type: TYPE_NORMAL
- en: Using Allow-Listed Operation Names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Certain in-band GraphQL implementations may make some queries and mutations
    publicly available for unauthenticated clients, such as those for login or account
    registration. Some of these deployments use *operation name-based allow lists*,
    a weak enforcement control, to reject all unauthenticated requests unless their
    operation names are in an allow list. However, operation names can be defined
    by the client, so an attacker can bypass these authentication mechanisms by simply
    spoofing an operation’s name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of an unauthenticated mutation. As you can see,
    it would allow a user to register a new user account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: An implementation may choose to allow-list this `register` operation by using
    its operation name `RegisterAccount`. As attackers, we can take advantage of this
    by sending a request like the one in [Listing 7-7](#listing7-7).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-7: An example operation that could bypass authentication by using
    an allow-listed operation name'
  prefs: []
  type: TYPE_NORMAL
- en: We used the allowed operation name to withdraw money with a withdrawal mutation.
  prefs: []
  type: TYPE_NORMAL
- en: Forging and Leaking JWT Credentials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While JWT tokens can be encrypted using JSON Web Encryption (RFC 7516), they
    often aren’t. And when they aren’t, they may leak sensitive data. For example,
    take a look at the payload section of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When we Base64-decode the payload, we discover a hardcoded credential, `api_token`,
    in the payload section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We can gain a lot of insight into an application by decoding and testing the
    contents of JWT tokens.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to bypass weak JWT authentication controls is by forging our own
    JWT tokens. If a GraphQL API fails to correctly verify the signature of a JWT
    token, it becomes vulnerable to forgery-based attacks, in which an attacker can
    encode their own user details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s perform a JWT forgery attack against DVGA by forging the JWT token of
    an administrator. First, copy the `accessToken` JWT we received in “Brute-Forcing
    Passwords by Using Query Batching” on page 173, when we successfully brute-forced
    the *operator* password. We can verify that the `accessToken` is valid by sending
    it as a `token` argument in the `me` query operation in DVGA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'DVGA will authenticate the user based on the identity claim in the JWT and
    use the `me` query operation to return the authenticated user object fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Next, let’s paste the JWT string into [https://jwt.io](https://jwt.io), as shown
    in [Figure 7-3](#figure7-3). This website will automatically decode and present
    the three JWT segments in a more human-readable form.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the right panel, we can directly modify the decoded payload’s JSON data,
    changing the `"identity": "operator"` line to `"identity": "admin"`. You’ll notice
    that [https://jwt.io](https://jwt.io) will automatically encode the payload changes
    in the left panel.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/502840c07/f07003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7-3: The DVGA operator’s `accessToken`, decoded using [https://jwt.io](https://jwt.io)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try using this forged JWT token against the `me` operation. Simply copy
    the JWT and paste it into the query’s `token` argument. Because DVGA doesn’t verify
    the JWT signature, it will authenticate our request with the forged JWT token
    and return the admin user’s password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When a client changes a JWT token, its signature should become invalid. GraphQL
    APIs that don’t validate this signature by using their secret key will be prone
    to forgery-based attacks.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with authentication, developers can take several approaches to implementing
    authorization. When given a limited GraphQL user account, we, as hackers, should
    see how far we can escalate our privileges. In particular, we should determine
    whether we’re able to bypass controls intended to prevent us from reading user
    data or performing certain elevated functions.
  prefs: []
  type: TYPE_NORMAL
- en: Like REST, GraphQL can be vulnerable to a variety of authorization attacks,
    depending on how the API handles permission controls. Failure to protect unauthorized
    access at the function level may result in the leakage of sensitive data or the
    execution of damaging operations.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL-specific authorization flaws typically arise when permission checks
    occur at the resolver level or after the execution of any business logic or state
    changes. Let’s learn to detect some of these authorization approaches and explore
    the attacks to which they might be vulnerable.
  prefs: []
  type: TYPE_NORMAL
- en: Detecting the Authorization Layer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can go about detecting whether an API uses authorization controls, and of
    what type, in several ways.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Schema Directives
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: We mentioned earlier that developers sometimes implement authorization by using
    schema directives. You can identify these schema directives if you have access
    to the API’s SDL files. Alternatively, you can send a specialized introspection
    query, like the one in [Listing 7-8](#listing7-8).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-8: An introspection query to fetch directive names and arguments'
  prefs: []
  type: TYPE_NORMAL
- en: Running this query will return a list of all the query- and schema-level directives
    in the target server. If you notice the `@auth` directive in the list, you can
    assume that the schema supports it. Of course, developers can call directives
    different things, so also look for names like `@authorize`, `@authorization`,
    `@authz`, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Finding Authentication Directives in the Schema
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If we perform an introspection query to identify directives, we’ll know whether
    an `@auth` directive exists. However, we won’t know where this directive is applied
    in the schema, as this information isn’t exposed in an introspection query. That’s
    because clients don’t call schema-level directives; instead, developers use them
    to protect against unauthorized access, among other use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at the `User` object type in [Listing 7-9](#listing7-9) as an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-9: An `@auth` directive usage example in a schema'
  prefs: []
  type: TYPE_NORMAL
- en: You’ll find scanning the schema for `@auth` directives useful in white-box penetration
    tests, which provide you with the SDL files. But in black-box tests that provide
    no access to the schema, you might know that the `password` field exists, for
    example, but not that the `@auth` directive applies to it.
  prefs: []
  type: TYPE_NORMAL
- en: The GraphQL developer community has discussed exposing information about the
    use of schema-level directives in the introspection system. However, many GraphQL
    implementations currently don’t expose this information.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerating Paths with graphql-path-enum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To test authorization controls, you should try accessing sensitive fields in
    as many ways as you can imagine. For example, consider the following excerpt from
    the DVGA’s schema, in which three queries access the `PasteObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As a client, you could return information about pastes by using either `pastes`,
    `paste`, or `readAndBurn`. When implementing in-band authorization, a developer
    might accidentally protect only some of these queries. As such, determine all
    possible paths to a given object type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Schemas can be very large, so you’ll find it helpful to automate the process
    of identifying all paths to a given object type. For this task, we’ll use graphql-path-enum.
    This tool expects two important arguments: the introspection JSON response and
    the name of an object type we want to test for authorization issues. Let’s use
    it to find all paths to the `PasteObject` object type.'
  prefs: []
  type: TYPE_NORMAL
- en: First, run a full introspection query by pasting the query from [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/queries/introspection_query.txt](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/queries/introspection_query.txt)
    into Altair. Send the request and copy the response to a file named *introspection.json*.
    Next, provide graphql-path-enum with this file and tell it to search for all paths
    leading to the `PasteObject` object, as shown in [Listing 7-10](#listing7-10).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 7-10: Performing type path enumeration with graphql-path-enum'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, graphql-path-enum traversed the introspection response and identified
    all possible query paths to the object. Now we can manually send these three queries
    to see whether any of them grant access to objects that other queries don’t.
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to practice schema traversal in a large, complex GraphQL API,
    try running graphql-path-enum against the `Vehicle` object type in the popular
    Star Wars API (SWAPI). This API’s schema is larger than that of the DVGA and should
    illustrate the importance of path enumeration when testing for authorization issues.
    You can access the SWAPI schema at [https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch07/starwars-schema.json](https://github.com/dolevf/Black-Hat-GraphQL/blob/master/ch07/starwars-schema.json).
  prefs: []
  type: TYPE_NORMAL
- en: Brute-Forcing Arguments and Fields with CrackQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because graphql-path-enum works for only object types, you might try the field-stuffing
    technique discussed in Chapter 6 to test for weak or nonexistent authorization
    controls intended to limit the amount of data an unprivileged user can view. We
    can also use CrackQL to programmatically brute-force arguments and fields to which
    we shouldn’t have access. Imagine a query that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Now, say that accessing information about certain users requires special authorization
    permissions. We know that the user IDs are numerical and incremental, but not
    which are protected. Let’s attempt to brute-force them all with CrackQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the CrackQL folder, under *sample-queries*, create a new file named *users.graphql*
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This query uses the `users` field with an `id` parameter of the `Int` type.
    Because the query takes an `id` argument, we can attempt to enumerate accounts
    by incrementally supplying a list of numerical user identifiers. CrackQL will
    render the `{{id|int}}` string and replace it with words from a wordlist we will
    create next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create this dictionary of possible user IDs as a one-column CSV wordlist.
    Such a list is easy to generate with some Bash-fu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, check that the file was generated properly by printing the first five
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now run CrackQL to find valid user IDs and retrieve their username and password
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also, in the same fashion, brute-force fields that you suspect you
    won’t be able to access because of authorization controls by simply modifying
    the original query to include these potential fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: CrackQL will save the output of all attempts under the *~/CrackQL/results* folder.
    If these fields are accessible, you’ll see the responses to them there.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you learned about in-band and out-of-band GraphQL authentication
    and authorization architectural models. We reviewed a few traditional controls
    developers may have adopted in their GraphQL deployments and called out the weaknesses
    to which they might be susceptible. For example, GraphQL implementations that
    use JWT tokens might be vulnerable to token forging. We also directed your attention
    to newer, GraphQL-specific authentication and authorization libraries and plug-ins,
    such as GraphQL Modules, GraphQL Shield, and custom schema directives.
  prefs: []
  type: TYPE_NORMAL
- en: By taking advantage of GraphQL features like alias-based query batching, we
    can brute-force in-band authentication operations manually or use CrackQL to do
    this automatically. Using graphql-path-enum, we can enumerate paths to types,
    and using CrackQL once again, we can potentially access fields without proper
    authorization controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we’ll turn to another age-old vulnerability class: injections,
    which continue to wreak havoc even against modern API services like GraphQL.'
  prefs: []
  type: TYPE_NORMAL
