<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="index: http://www.index.com/" xml:lang="en" lang="en">
<head>
<title>13. Network Authentication</title>
<link href="../styles/stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="sbo-rt-content"><section aria-labelledby="ch13" epub:type="chapter" role="doc-chapter">
<hgroup>
<h2 class="CHAPTER" id="ch13">
<span class="CN"><span aria-label=" Page 421. " epub:type="pagebreak" id="pg_421" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">13</samp></span>
<span class="CT"><samp class="SANS_Dogma_OT_Bold_B_11">NETWORK AUTHENTICATION</samp></span>
</h2>
</hgroup>
<figure class="opener"><img alt="" class="opener" height="386" src="../images/chapter.jpg" width="386"/></figure>
<p class="ChapterIntro">The previous chapter discussed interactive authentication, which allows a user to log in to a computer and interact with a desktop. By contrast, <i>network authentication</i> occurs when the user has already authenticated to a Windows system but wants to use resources on another Windows system, typically over a network.</p>
<p class="TX">The simplest approach to performing network authentication might seem to be to transfer the user’s credentials to the remote system. The service that receives the credentials could then call the <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp> API and specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Network</samp> logon type to create a noninteractive logon session. However, this approach isn’t very secure. To use <samp class="SANS_TheSansMonoCd_W5Regular_11">LsaLogonUser</samp>, a network-facing service must know the user’s full credentials, and providing a remote system with these credentials is problematic for many reasons. For one, we must trust the remote service to handle the credentials securely. For another, if the authentication takes place over a hostile network, an attacker could capture the credentials.</p>
<p class="TX"><span aria-label=" Page 422. " epub:type="pagebreak" id="pg_422" role="doc-pagebreak"></span>To mitigate these security issues, Windows implements multiple network authentication protocols. These protocols don’t require sending a network service the user’s credentials or transferring a plaintext password over the network. (Of course, there are always caveats, which we’ll identify over the course of this chapter.) You’ll find these network authentication protocols in the security packages we discussed in the previous chapter, and you can access them via a generic API, which allows an application to easily change the authentication protocol used.</p>
<p class="TX">This chapter begins by describing the <i>NT LAN Manager (NTLM)</i> authentication protocol, the oldest Windows protocol still in use, in some depth, covering how it uses the user’s credentials to prevent their disclosure over the network. Then we’ll look at a well-known attack, <i>NTLM relay</i>, and the ways Microsoft has tried to mitigate it.</p>
<section aria-labelledby="sec1" epub:type="division">
<h3 class="H1" id="sec1"><span id="h1-98"></span><samp class="SANS_Futura_Std_Bold_B_11">NTLM Network Authentication</samp></h3>
<p class="TNI1">NTLM derives from the <i>LAN Manager (LM)</i> authentication protocol, which supported the Server Message Block (SMB) file sharing protocol as part of the LAN Manager operating system. Microsoft reimplemented the authentication protocol in Windows 3.11 (the infamous Windows for Workgroups), then built upon it further and dubbed it NTLM when it introduced Windows NT. In the latest versions of Windows, there are three variants of NTLM in use:</p>
<p class="RunInPara1"><b>NTLMv1    </b>The original NTLM version, introduced in Windows NT 3.1</p>
<p class="RunInPara"><b>NTLMv2    </b>A version of NTLM introduced in NT 4 Service Pack 4 that added additional security features</p>
<p class="RunInPara2"><b>NTLMv2 Session    </b>NTLMv1, but with the additional security features from NTLMv2</p>
<p class="TX">We’ll focus on NTLMv2, the only version whose values are accepted by default on Windows Vista and above. You might still encounter NTLMv1 or NTLMv2 Session in mixed operating system environments (for example, when accessing Linux-based network storage devices), but in a modern Windows environment, these should be rare.</p>
<p class="TX"><a href="chapter13.xhtml#fig13-1">Figure 13-1</a> shows an overview of the NTLM authentication process that occurs between a Windows client application and a Windows server.</p>
<span aria-label=" Page 423. " epub:type="pagebreak" id="pg_423" role="doc-pagebreak"></span>
<figure class="IMG"><img alt="" class="img1" height="1113" id="fig13-1" src="../images/Figure13-1.jpg" width="1381"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-1: An overview of the NTLM authentication protocol</samp></p></figcaption>
</figure>
<p class="TX">NTLM authentication begins when the client application makes a network connection to the server. The client and the server then exchange a sequence of binary <i>authentication tokens</i> generated by the LSAs on the two machines. For the NTLM, these tokens consist of three authentication messages: the client’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> message, which specifies which features the client supports <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>; the server’s <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> message, which selects one of the client’s features and provides a random challenge value to use in the exchange <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>; and the client’s <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> message, which contains a value that proves the client’s knowledge of the user’s password to the server <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">At a high level, the authentication process occurs between the two LSAs. However, it’s up to the application and server to transport these authentication tokens over some network protocol. Microsoft describes the authentication protocol in <i>MS-NLMP</i>, available online. The document omits some features, which I’ll point out as we walk through an example.</p>
<section aria-labelledby="sec2" epub:type="division">
<h4 class="H2" id="sec2"><span id="h2-138"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">NTLM Authentication Using PowerShell</samp></h4>
<p class="TNI1">Let’s perform network authentication using PowerShell so you can see what information the authentication tokens contain. We’ll use a local user account, though a domain account would work just as well.</p>
<section aria-labelledby="sec3" epub:type="division">
<h5 class="H3" id="sec3"><span id="h3-35"></span><span aria-label=" Page 424. " epub:type="pagebreak" id="pg_424" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Initializing the Client</samp></h5>
<p class="TNI1">The authentication process starts when the client application calls the Security Support Provider Interface (SSPI) API <samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireCredentialsHandle</samp>. The system implements the SSPI APIs to abstract the authentication protocol implemented by a security package. This allows applications to more easily change the network authentication protocol they use.</p>
<p class="TX">This <samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireCredentialsHandle</samp> API selects the security package used for network authentication and provides explicit credentials for the authentication if needed. It returns a handle for use by a second SSPI API, <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>, which uses the selected security package but executes in the LSA.</p>
<p class="TX">The security package in the LSA processes <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp>, then requests and returns a <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> authentication token to the caller. The <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token describes which authentication features the client supports and should be sent to the server over the network protocol. <a href="chapter13.xhtml#Lis13-1">Listing 13-1</a> performs this client initialization in PowerShell.</p>
<span id="Lis13-1"></span><pre><code>PS&gt; <b>$credout = New-LsaCredentialHandle -Package "NTLM"</b>
<b>-UseFlag Outbound -UserName $env:USERNAME -Domain $env:USERDOMAIN</b>
PS&gt; <b>$client = New-LsaClientContext -CredHandle $credout</b>
PS&gt; <b>$negToken = $client.Token</b>
PS&gt; <b>Format-LsaAuthToken -Token $negToken</b>
&lt;NTLM NEGOTIATE&gt;
Flags: Unicode, Oem, RequestTarget, NTLM, AlwaysSign, ExtendedSessionSecurity,
Version, Key128Bit, Key56Bit
Version: 10.0.XXXXX.XX
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-1: Initializing a client for NTLM authentication and formatting a NEGOTIATE authentication token</span></p>
<p class="TX">We start by getting the credentials handle using the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp> command, which calls <samp class="SANS_TheSansMonoCd_W5Regular_11">AcquireCredentialsHandle</samp>. By specifying <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp> using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Package</samp> parameter, we select the use of the NTLM security package. We also specify that these credentials are for outbound authentication (that is, from a client to a server). Lastly, we specify the username and domain from the current environment.</p>
<p class="TX">Notice that we do not specify a password; this is because the LSA has already cached the password for us in our logon session. The fact that we don’t need to specify the password is a key part of <i>Integrated Windows Authentication (IWA)</i>, which allows users to automatically authenticate to the network authentication using their credentials, without prompting them for a password.</p>
<p class="TX">With the credentials handle, we create a client authentication context by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaClientContext</samp> command and specifying the handle. Under the hood, this command calls the <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp> API. If the call to the API succeeds, the client context now contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token. We store a copy of the token for later use, then pass it to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp> command to parse its contents and print them to the shell.</p>
<p class="TX"><span aria-label=" Page 425. " epub:type="pagebreak" id="pg_425" role="doc-pagebreak"></span>The main component of the token is a list of flags that reflect the features the client requests, the features the client supports, and which parts of the token are valid. In this case, the token has nine flags set, though these can change depending on the system’s configuration. <a href="chapter13.xhtml#tab13-1">Table 13-1</a> shows what the flags mean in this context.</p>
<table class="Basic-Table">
<caption><p class="TT" id="tab13-1"><span class="Heavy"><samp class="SANS_Futura_Std_Heavy_B_11">Table 13-1:</samp></span> <samp class="SANS_Futura_Std_Book_11">Select NTLM Flags</samp></p></caption>
<thead>
<tr>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Flag name</samp></p></th>
<th class="Basic-Table TCH" scope="col"><p class="TableHeader"><samp class="SANS_Futura_Std_Heavy_B_11">Description</samp></p></th>
</tr>
</thead>
<tbody>
<tr>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Unicode</samp></p></td>
<td class="Basic-Table TBF"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The client supports Unicode strings.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Oem</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The client supports byte character strings (for example, ASCII).</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">RequestTarget</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The client requires the server to send a target name in the response.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">NTLM</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The client requests to use the NTLM hash.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">AlwaysSign</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The client requests that the authentication be signed to ensure integrity.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedSessionSecurity</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The client requests NTLMv2 Session security.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Version</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The client has sent the operating system and NTLM protocol version.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Key128Bit</samp></p></td>
<td class="Basic-Table TB"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The client requests a 128-bit signing key.</samp></p></td>
</tr>
<tr>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_TheSansMonoCd_W5Regular_11">Key56Bit</samp></p></td>
<td class="Basic-Table TBL"><p class="TableBody"><samp class="SANS_Futura_Std_Book_11">The client requests a 56-bit signing key.</samp></p></td>
</tr>
</tbody>
</table>
<p class="TX">You might wonder why the <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedSessionSecurity</samp> flag is set. This flag changes NTLMv1 to NTLMv2 Session security, but I mentioned earlier that NTLMv1 is disabled by default. The LSA sets the flag anyway, just in case the server responds with a request for NTLMv1. Except for <samp class="SANS_TheSansMonoCd_W5Regular_11">Version</samp>, these flags all indicate the features the client requires. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Version</samp> flag indicates major, minor, and build values of the operating system version, as well as the NTLM protocol version, which has been fixed at 15 since Windows Server 2003.</p>
<p class="TX">To ensure the integrity of the authentication protocol, NTLM generates an encryption key based on the values in the exchange, then uses it to apply a <i>message integrity code (MIC)</i> to the entire exchange. A MIC is a cryptographic hash of the authentication tokens sent and received in the current exchange. It’s used to detect whether the authentication tokens have been tampered with over the network.</p>
<p class="TX">Due to cryptography export restrictions, NTLM supports 40-bit keys as well as 56-bit and 128-bit keys, based on the presence of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Key56Bit</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Key128Bit</samp> flags. If neither flag is set, NTLM will use 40-bit keys. The <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp> command hides the underlying binary value of the authentication token, but to see the token in hex we can pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">AsBytes</samp> parameter to this command, as shown in <a href="chapter13.xhtml#Lis13-2">Listing 13-2</a>.</p>
<span id="Lis13-2"></span><pre><code>PS&gt; <b>Format-LsaAuthToken -Token $client.Token -AsBytes</b>
          00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  - 0123456789ABCDEF
-----------------------------------------------------------------------------
<span aria-label=" Page 426. " epub:type="pagebreak" id="pg_426" role="doc-pagebreak"></span><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> 00000000: 4E 54 4C 4D 53 53 50 00 01 00 00 00 07 82 08 A2  - NTLMSSP.........
00000010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  - ................
00000020: 0A 00 BA 47 00 00 00 0F                          - ...G....
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-2: Formatting the authentication token in hex</span></p>
<p class="TX">In hex, we can see the data has a format indicator at the beginning of <samp class="SANS_TheSansMonoCd_W5Regular_11">NTLMSSP</samp> <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. If you see this indicator in data you’re analyzing, there’s a good chance you’ve come across an NTLM network authentication process. I won’t display the hex of the rest of the tokens, as it’s easy enough to change the script to view the hex output if you’re interested in doing so.</p>
</section>
<section aria-labelledby="sec4" epub:type="division">
<h5 class="H3" id="sec4"><span id="h3-36"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Initializing the Server</samp></h5>
<p class="TNI1">The client has initialized its authentication context and generated a <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token. Now it must send this token to the server application so that it can initialize its own authentication context. When the server receives the token, it passes it to the LSA using the <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp> API. The LSA inspects the token, determines whether it supports the requested features, and generates a <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> authentication token in response. This token allows the server to verify that the client isn’t replaying values captured from a previous authentication exchange.</p>
<p class="TX">Let’s use PowerShell to demonstrate the server’s handling of NTLM. In <a href="chapter13.xhtml#Lis13-3">Listing 13-3</a>, we create the server authentication context in the same process as the client’s (remember, however, that the server will typically run on a different system).</p>
<span id="Lis13-3"></span><pre><code>PS&gt; <b>$credin = New-LsaCredentialHandle -Package "NTLM" -UseFlag Inbound</b>
PS&gt; <b>$server = New-LsaServerContext -CredHandle $credin</b>
PS&gt; <b>Update-LsaServerContext -Server $server -Token $client.Token</b>
PS&gt; <b>$challengeToken = $server.Token</b>
PS&gt; <b>Format-LsaAuthToken -Token $server.Token</b>
&lt;NTLM CHALLENGE&gt;
Flags     : Unicode, RequestTarget, NTLM, AlwaysSign, TargetTypeDomain,
ExtendedSessionSecurity, TargetInfo, Version, Key128Bit, Key56Bit
TargetName: DOMAIN
Challenge : D568EB90F6A283B8
Reserved  : 0000000000000000
Version   : 10.0.XXXXX.XX
=&gt; Target Info
NbDomainName - DOMAIN
NbComputerName - GRAPHITE
DnsDomainName - domain.local
DnsComputerName - GRAPHITE.domain.local
DnsTreeName - domain.local
Timestamp - 5/1 4:21:17 PM
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-3: Initializing the server for NTLM authentication and formatting the CHALLENGE authentication token</span></p>
<p class="TX">We start by creating the inbound credentials handle. You don’t need to provide any credentials to do this; in fact, NTLM would ignore the <span aria-label=" Page 427. " epub:type="pagebreak" id="pg_427" role="doc-pagebreak"></span>credentials even if you did provide them. Next, we create the server’s authentication context and provide the client’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token to the <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp> API by calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaServerContext</samp> PowerShell command. If the LSA accepts the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token, the server context will include its own token, the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> token. As before, we capture the token for later use and pass it to <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp> to print out the information it contains.</p>
<p class="TX">The token’s flags represent the values that the network authentication process supports and are based on the flags the client sent. For example, in <a href="chapter13.xhtml#Lis13-1">Listing 13-1</a> we saw that the client set both the <samp class="SANS_TheSansMonoCd_W5Regular_11">Oem</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unicode</samp> string format flags in its <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token, indicating that it can support both Unicode and byte character format strings. The server has elected to send strings in Unicode format, so it has cleared the <samp class="SANS_TheSansMonoCd_W5Regular_11">Oem</samp> flag in the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> token.</p>
<p class="TX">As requested by the client, the output also contains the <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetName</samp>, which in this case is the domain name of the server, indicated by the <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetTypeDomain</samp> flag. If the server were not in a domain network, the <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetName</samp> would be the server’s computer name, and the token would use the <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetTypeServer</samp> flag instead.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> token contains a random 8-byte server challenge generated by the LSA. All values calculated in the next step depend on the challenge’s value; because it’s different for every request, this prevents an attacker from capturing a previous authentication exchange and replaying it to the server. The final part of the token is the target information, indicated by the presence of the <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetInfo</samp> flag. This contains additional details about the server.</p>
<p class="TX">Note that NTLM can work in a connectionless mode, in which the client never sends the initial <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> message. In this case, the authentication process starts with the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> message from the server. However, connectionless NTLM authentication is rarely used in practice.</p>
</section>
<section aria-labelledby="sec5" epub:type="division">
<h5 class="H3" id="sec5"><span id="h3-37"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Passing the Token Back to the Client</samp></h5>
<p class="TNI1">Next, the server must send the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> token to the client’s authentication context. In a real network protocol, this would happen over the network, but in <a href="chapter13.xhtml#Lis13-4">Listing 13-4</a> we pass the token in the same script.</p>
<span id="Lis13-4"></span><pre><code>PS&gt; <b>Update-LsaClientContext -Client $client -Token $server.Token</b>
PS&gt; <b>$authToken = $client.Token</b>
PS&gt; <b>Format-LsaAuthToken -Token $client.Token</b>
&lt;NTLM AUTHENTICATE&gt;
Flags      : Unicode, RequestTarget, NTLM, AlwaysSign, ExtendedSessionSecurity,
TargetInfo, Version, Key128Bit, Key56Bit
Domain     : GRAPHITE
UserName   : user
Workstation: GRAPHITE
LM Response: 000000000000000000000000000000000000000000000000 <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>
&lt;NTLMv2 Challenge Response&gt;
NT Response          : 532BB4804DD9C9DF418F8A18D67F5510 <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>
Challenge Verison    : 1
Max Challenge Verison: 1
<span aria-label=" Page 428. " epub:type="pagebreak" id="pg_428" role="doc-pagebreak"></span>Reserved 1           : 0x0000
Reserved 2           : 0x00000000
Timestamp            : 5/1 5:14:01 PM
Client Challenge     : 0EC1FF45C43619A0 <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>
Reserved 3           : 0x00000000
NbDomainName - DOMAIN
NbComputerName - GRAPHITE
DnsDomainName - domain.local
DnsComputerName - GRAPHITE.domain.local
DnsTreeName - domain.local
Timestamp - 5/1 5:14:01 PM
Flags - MessageIntegrity <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>
SingleHost - Z4 0x0 - Custom Data: 0100000000200000 Machine ID: 5FB8... <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>
ChannelBinding - 00000000000000000000000000000000 <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>
TargetName -
&lt;/NTLMv2 Challenge Response&gt;
MIC        : F0E95DBEB53C885C0619FB61C5AF5956 <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-4: Updating the client for NTLM authentication and formatting the AUTHENTICATE token</span></p>
<p class="TX">We use the <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaClientContext</samp> command, which calls <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp> once again with the original credentials handle and the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> token. If <samp class="SANS_TheSansMonoCd_W5Regular_11">InitializeSecurityContext</samp> accepts the token, the LSA generates the final <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token, which we can then format. This is the only token that depends on the value of the password; the other two tokens can be generated without any special knowledge.</p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token starts with the final negotiated flags and the information about the user, including their username and domain. Because we’re using a local account, the domain is set to the workstation name, <samp class="SANS_TheSansMonoCd_W5Regular_11">GRAPHITE</samp>. Next comes the LM response, which in this case is all zeros <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The LM response is normally disabled, which is why it’s not specified, and NTLMv2 doesn’t use the LM hash at all.</p>
<p class="TX">We now continue to the full NTLMv2 response, which contains a lot of information. First is the 8-byte NT response <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, also called the <samp class="SANS_TheSansMonoCd_W5Regular_11">NTProofStr</samp> in the protocol’s documentation. We’ll come back to how this value is calculated in a moment. After the NT response are various parameters about the protocol, including the 8-byte client challenge <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. NTLMv1 already contained the server challenge to prevent replay, but NTLMv2 added the client challenge to make it harder for an attacker to use the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token to crack the user’s password.</p>
<aside aria-label="box-7" class="box">
<p class="BoxTitle" id="box-7"><samp class="SANS_Dogma_OT_Bold_B_11">CRACKING USER PASSWORDS</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">While the NTLM authentication protocol does not directly disclose the user’s password, the authentication tokens generate values that are causally related to the password. If an attacker can get a user to authenticate to a service they control, they can use the values from the tokens to mount a brute-force attack that retrieves the password’s original value, then authenticate as the user.</samp></p>
<p class="BoxBody"><span aria-label=" Page 429. " epub:type="pagebreak" id="pg_429" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Book_11">Brute-forcing can be very time-consuming, especially if the password is long and contains a mix of characters. To speed up password cracking, attackers might use</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">rainbow tables</samp><samp class="SANS_Futura_Std_Book_11">, which include many possible precomputed derivations of the authentication token’s values for different passwords. This process works best when only the password is unknown; otherwise, an attacker must build a new set of rainbow tables for each unknown value, such as the server challenge. Because the attacker can fix the server challenge when the user connects but the client challenge is randomly generated, rainbow tables work best with NTLMv1, which doesn’t involve a client challenge.</samp></p>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">The details of how exactly rainbow tables work are outside the scope of this book, but you can find plenty of resources online if you want to know more about them. Today, rainbow tables have fallen out of favor due to the deprecation of NTLMv1 and the improved performance of commodity computer graphics cards, which has sped up brute-force calculations. If you’ve captured an NTLMv2 exchange, you can use a tool such as hashcat to brute-force all passwords with fewer than eight characters in less than an hour on a single system. You can also purchase computing resources from a cloud computing platform to mount an attack against more complex passwords.</samp></p>
</aside>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token copies most of its target information from the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> message, although it contains a few additional entries. The flags indicate that the message contains a MIC with the <samp class="SANS_TheSansMonoCd_W5Regular_11">MessageIntegrity</samp> value <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, as you’ll soon see. The <samp class="SANS_TheSansMonoCd_W5Regular_11">SingleHost</samp> flag contains a random ID for the client machine that generated the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ChannelBinding</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">TargetName</samp> <span aria-label="annotation6" class="CodeAnnotationCode">❻</span> values are used to prevent credential relaying, an attack we’ll also come back to later; in this case, the flags aren’t specified. Last is the MIC, a keyed MD5 hash-based message authentication code (HMAC) calculated over the authentication tokens sent and received for the current exchange <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>. The key for the hash is calculated during the authentication process, and the MIC serves to detect whether the tokens have been tampered with.</p>
<p class="TX">The client sends the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token to the server, which again calls <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptSecurityContext</samp>, passing it the token. The LSA runs the calculations needed to verify that the NT response matches the expected value and that the MIC is valid, indicating the tokens haven’t been tampered with. If both values match the expected values, the authentication succeeds.</p>
<p class="TX">There are several differences between the formatted output generated by NTLMv1 and NTLMv2. First, if NTLMv1 is in use, the NT response in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token will be a 24-byte binary value rather than the structured response seen in <a href="chapter13.xhtml#Lis13-4">Listing 13-4</a>. For example, it might look like the following:</p>
<pre><code>NT Response: 96018E031BBF1666211D91304A0939D27EA972776C6C0191
</code></pre>
<p class="TX">You can also differentiate between NTLMv1 and NTLMv2 Session by looking at the flags and LM hash. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">ExtendedSessionSecurity</samp> flag is set, <span aria-label=" Page 430. " epub:type="pagebreak" id="pg_430" role="doc-pagebreak"></span>you know that NTLMv2 Session is in use; otherwise, the system is using NTLMv1. The LM hash field gets repurposed to contain the client challenge in NTLMv2, which might confuse you, as you might assume an LM hash has been negotiated. You can tell the difference between a hash and a client challenge because the client challenge is only 8 bytes long, as shown here:</p>
<pre><code>LM Response: CB00748C3F04CB5700000000000000000000000000000000
</code></pre>
<p class="TX">The remaining 16 bytes are padded with zeros.</p>
</section>
<section aria-labelledby="sec6" epub:type="division">
<h5 class="H3" id="sec6"><span id="h3-38"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Requesting a Token Object</samp></h5>
<p class="TNI1">Now that the authentication process has completed, the server can request that the LSA generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object for the authenticated user through the <samp class="SANS_TheSansMonoCd_W5Regular_11">QuerySecurityContextToken</samp> API, as shown in <a href="chapter13.xhtml#Lis13-5">Listing 13-5</a>.</p>
<span id="Lis13-5"></span><pre><code>PS&gt; <b>Update-LsaServerContext -Server $server -Token $client.Token</b>
PS&gt; <b>if ((Test-LsaContext $client) -and (Test-LsaContext $server)) {</b>
    <b>Use-NtObject($token = Get-LsaAccessToken $server) {</b>
        <b>Get-NtLogonSession -Token $token</b>
    <b>}</b>
<b>}</b>
LogonId           UserName       LogonType SessionId
-------           --------       --------- ---------
00000000-0057D74A GRAPHITE\user  Network   0
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-5: Completing the NTLM authentication process</span></p>
<p class="TX">We start by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">Update-LsaServerContext</samp> again to finalize the authentication process. Once all tokens have been transferred, the client and server contexts are placed into a <i>done state</i>, meaning they no longer need any more information to complete the authentication process. You can verify this state using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-LsaContext</samp> command.</p>
<p class="TX">With the authentication completed, we can call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaAccessToken</samp> command to return the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object for the user. We display the logon session for the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> and verify that it used network authentication.</p>
<aside aria-label="box-8" class="box">
<p class="BoxTitle" id="box-8"><samp class="SANS_Dogma_OT_Bold_B_11">NETWORK AUTHENTICATION AND LOCAL ADMINISTRATORS</samp></p>
<p class="BoxBodyFirst"><samp class="SANS_Futura_Std_Book_11">As a result of a network authentication exchange, the LSA generates a</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> <samp class="SANS_Futura_Std_Book_11">object using the groups and privileges of the local or domain policy. A quirk occurs if the authenticating user is both a local user and a member of the local</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Administrators</samp> <samp class="SANS_Futura_Std_Book_11">group and UAC is enabled. In that case, the LSA generates the UAC filtered token for the authentication rather than the full administrator token. This limits a local administrator’s ability to access remote services using a local</samp> <span aria-label=" Page 431. " epub:type="pagebreak" id="pg_431" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Book_11">account, as they will no longer be an administrator once authenticated to the remote system, which might prevent them from being able to use the service correctly.</samp></p>
<p class="BoxBody"><samp class="SANS_Futura_Std_Book_11">If the Windows system is joined to a domain, domain users won’t be limited by this policy if they’re added to the local</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Administrators</samp> <samp class="SANS_Futura_Std_Book_11">group. For example, Windows adds domain administrators to the local</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">Administrators</samp> <samp class="SANS_Futura_Std_Book_11">group by default, so they won’t be affected by the filtering. You can also disable the filtering by setting a system policy in the registry using the following command; however, as with all system modifications, this can weaken the system’s security and you should use it on test systems only:</samp></p>
<pre><code><samp class="SANS_TheSansMonoCd_W5Regular_11">PS&gt;</samp> <samp class="SANS_TheSansMonoCd_W7Bold_B_11">New-ItemProperty -Name "LocalAccountTokenFilterPolicy" -Value 1</samp>
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">-Force -PropertyType DWORD</samp>
<samp class="SANS_TheSansMonoCd_W7Bold_B_11">-Path 'HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System'</samp>
</code></pre>
<p class="BoxBodyLast"><samp class="SANS_Futura_Std_Book_11">A separate setting,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">FilterNetworkAuthenticationTokens</samp><samp class="SANS_Futura_Std_Book_11">, will always filter network authentication tokens, regardless of where they come from. This setting is disabled by default.</samp></p>
</aside>
</section>
</section>
<section aria-labelledby="sec7" epub:type="division">
<h4 class="H2" id="sec7"><span id="h2-139"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Cryptographic Derivation Process</samp></h4>
<p class="TNI1">The NTLM process never discloses the user’s password in plaintext on the network. Even so, NTLM uses the password’s value to derive the final NT response and MIC. Let’s use PowerShell to walk through this cryptographic derivation process and generate the NT response and MIC. To perform the derivation, we’ll need the user’s password, as well as the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> authentication tokens.</p>
<p class="TX">We also need a function that calculates the MD5 HMAC for a set of bytes. The MD5 HMAC is a keyed cryptographic hashing algorithm commonly used to sign data so its integrity can be verified. We’ll use this function, defined in <a href="chapter13.xhtml#Lis13-6">Listing 13-6</a>, multiple times in the derivation.</p>
<span id="Lis13-6"></span><pre><code>PS&gt; <b>function Get-Md5Hmac {</b>
<b>  </b><span aria-label="annotation1" class="CodeAnnotationCode2">❶</span><b> Param(</b>
<b>        $Key,</b>
<b>        $Data</b>
<b>    )</b>

<b>    $algo = [System.Security.Cryptography.HMACMD5]::new($Key)</b>
<b>    if ($Data -is [string]) {</b>
<b>        $Data = [System.Text.Encoding]::Unicode.GetBytes($Data)</b>
<b>    }</b>
<b>  </b><span aria-label="annotation2" class="CodeAnnotationCode2">❷</span> <b>$algo.ComputeHash($Data)</b>
<b>}</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-6: Defining the Get-Md5Hmac function</span></p>
<p class="TX"><span aria-label=" Page 432. " epub:type="pagebreak" id="pg_432" role="doc-pagebreak"></span>The function is simple: it creates the .NET class <samp class="SANS_TheSansMonoCd_W5Regular_11">HMACMD5</samp>, passing it a key <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, then calls <samp class="SANS_TheSansMonoCd_W5Regular_11">ComputeHash</samp> on the data <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. If the data is a string, it first converts it to a byte array in Unicode encoding.</p>
<p class="TX">The next function we define calculates the <i>NT one-way function version 2 (NTOWFv2)</i>, shown in <a href="chapter13.xhtml#Lis13-7">Listing 13-7</a>. This function converts the username, domain, and password into a 16-byte key for further use.</p>
<span id="Lis13-7"></span><pre><code>PS&gt; <b>function Get-NtOwfv2 {</b>
<b>    Param(</b>
<b>        $Password,</b>
<b>        $UserName,</b>
<b>        $Domain</b>
<b>    )</b>

<b>  </b><span aria-label="annotation1" class="CodeAnnotationCode">❶</span> <b>$key = Get-MD4Hash -String $Password</b>
<b>  </b><span aria-label="annotation2" class="CodeAnnotationCode">❷</span> <b>Get-Md5Hmac -Key $key -Data ($UserName.ToUpperInvariant() + $Domain)</b>
<b>}</b>

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>$key = Get-NtOwfv2 -Password "pwd" -UserName $authToken.UserName</b>
<b>-Domain $authToken.Domain</b>
PS&gt; <b>$key | Out-HexDump</b>
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> D6 B7 52 89 D4 54 09 71 D9 16 D5 23 CD FB 88 1F
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-7: Defining the NT one-way function</span></p>
<p class="TX">First, note that the system hashes the password using the MD4 algorithm <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. As mentioned previously, the SAM database stores these MD4 hashes so that the LSA doesn’t need to store their plaintext versions.</p>
<p class="TX">We supply the MD4 hash of the password as a key to the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp> function, then use this function to hash the uppercase username concatenated to the domain <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. In this case, these values are <samp class="SANS_TheSansMonoCd_W5Regular_11">user</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">GRAPHITE</samp>, so we hash the string <samp class="SANS_TheSansMonoCd_W5Regular_11">USERGRAPHITE</samp>.</p>
<p class="TX">To perform this operation, we call the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtOwfv2</samp> function we just defined with the username and domain from the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>, which we stored in the <samp class="SANS_TheSansMonoCd_W5Regular_11">$authToken</samp> variable. The function produces a 16-byte key <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>.</p>
<p class="TX">Now that we have a key based on the user’s password, we’ll use it to calculate the NT response value with the function defined in <a href="chapter13.xhtml#Lis13-8">Listing 13-8</a>.</p>
<span id="Lis13-8"></span><pre><code>PS&gt; <b>function Get-NtProofStr {</b>
<b>    Param(</b>
<b>        $Key,</b>
<b>        $ChallengeToken,</b>
<b>        $AuthToken</b>
<b>    )</b>

<b>  </b><span aria-label="annotation1" class="CodeAnnotationCode2">❶</span> <b>$data = $ChallengeToken.ServerChallenge</b>
<b>    $last_index = $AuthToken.NtChallengeResponse.Length - 1</b>
<b>    $data += $AuthToken.NtChallengeResponse[16..$last_index]</b>
<b>  </b><span aria-label="annotation2" class="CodeAnnotationCode2">❷</span> <b>Get-Md5Hmac -Key $Key -Data $data</b>
<b>}</b>
PS&gt; <b>$proof = Get-NtProofStr -Key $key -ChallengeToken $ChallengeToken</b>
<span aria-label=" Page 433. " epub:type="pagebreak" id="pg_433" role="doc-pagebreak"></span><b>-AuthToken $AuthToken</b>
PS&gt; <b>$proof | Out-HexDump</b>
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> 53 2B B4 80 4D D9 C9 DF 41 8F 8A 18 D6 7F 55 10
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-8: Calculating the NtProofStr value</span></p>
<p class="TX">We perform the calculation of the NT response using the NTOWFv2 key as well as the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> tokens. First we concatenate the 8-byte server challenge from the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NtChallengeResponse</samp> from the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token, minus the supplied 16-byte NT response <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Then we calculate the NT value using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp> function, with NTOWFv2 as the key <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The result <span aria-label="annotation3" class="CodeAnnotationCode">❸</span> should match the NT response value from <a href="chapter13.xhtml#Lis13-4">Listing 13-4</a> (if you used your actual password rather than the <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">pwd</samp> placeholder used in the listing).</p>
<p class="TX">The server can now verify that the client has access to the correct password for the user by checking whether the two NT response values match. However, we still want to verify that the messages haven’t been tampered with in some way, so we need to calculate the MIC. We define the function to do this in <a href="chapter13.xhtml#Lis13-9">Listing 13-9</a>.</p>
<span id="Lis13-9"></span><pre><code>PS&gt; <b>function Get-Mic {</b>
<b>    Param(</b>
<b>        $Key,</b>
<b>        $Proof,</b>
<b>        $NegToken,</b>
<b>        $ChallengeToken,</b>
<b>        $AuthToken</b>
<b>    )</b>

<b>  </b><span aria-label="annotation1" class="CodeAnnotationCode2">❶</span> <b>$session_key = Get-Md5Hmac -Key $Key -Data $Proof</b>

<b>    $auth_data = $AuthToken.ToArray()</b>
<b>  </b><span aria-label="annotation2" class="CodeAnnotationCode2">❷</span> <b>[array]::Clear($auth_data, $AuthToken.MessageIntegrityCodeOffset, 16)</b>
<b>  </b><span aria-label="annotation3" class="CodeAnnotationCode2">❸</span> <b>$data = $NegToken.ToArray() + $ChallengeToken.ToArray() + $auth_data</b>
<b>  </b><span aria-label="annotation4" class="CodeAnnotationCode2">❹</span> <b>Get-Md5Hmac -Key $session_key -Data $data</b>
<b>}</b>
PS&gt; <b>$mic = Get-Mic -Key $key -Proof $proof -NegToken $NegToken</b>
<b>-ChallengeToken $ChallengeToken -AuthToken $AuthToken</b>
PS&gt; <b>$mic | Out-HexDump</b>
<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> F0 E9 5D BE B5 3C 88 5C 06 19 FB 61 C5 AF 59 56
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-9: Calculating the message integrity code</span></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Mic</samp> function takes five parameters: the NTOWFv2 key, the NT response, and all three tokens transmitted back and forth between the client and server. The first task is to use <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp> again to calculate a session key <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We use the NTOWFv2 key for this HMAC operation and supply the NT response as data. Next, we zero the MIC field in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, then concatenate the tokens <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. We pass the session key and the concatenated tokens to <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Md5Hmac</samp> to generate the MIC <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. The value of the MIC <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> should match the one generated in <a href="chapter13.xhtml#Lis13-4">Listing 13-4</a>.</p>
</section>
<section aria-labelledby="sec8" epub:type="division">
<h4 class="H2" id="sec8"><span id="h2-140"></span><span aria-label=" Page 434. " epub:type="pagebreak" id="pg_434" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Pass-Through Authentication</samp></h4>
<p class="TNI1">For the client and server to successfully authenticate using NTLM, both parties must know the user’s password (or, more precisely, its NT hash). If you’re authenticating to a stand-alone machine, the password must be set in the machine’s local SAM database. Configuring this value isn’t too difficult in a small network, but on a large network consisting of many machines, doing it manually becomes unmanageable.</p>
<p class="TX">On a domain network, the domain controller is responsible for managing the user’s NT hash. So how can NTLM function in such an environment? The Netlogon service on the domain controller supports the concept of <i>pass-through authentication</i> to facilitate NTLM authentication on other systems in the domain. <a href="chapter13.xhtml#fig13-2">Figure 13-2</a> provides an example of the NTLM authentication process in a domain.</p>
<figure class="IMG"><img alt="" class="img1" height="795" id="fig13-2" src="../images/Figure13-2.jpg" width="1611"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-2: An overview of NTLM pass-through authentication</samp></p></figcaption>
</figure>
<p class="TX">The NTLM authentication process begins normally: the client sends the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token to the server <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>, which generates a challenge and returns it to the client in the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> token <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. The client then uses the user’s NT hash to generate the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token and sends it to the server <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>.</p>
<p class="TX">At this point, problems arise. The server doesn’t have the user’s NT hash, so it can’t derive necessary cryptographic values such as the NT challenge. Therefore, the server packages up the server challenge and the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token and sends these to the <samp class="SANS_TheSansMonoCd_W5Regular_11">NetrLogonSamLogon</samp> API on the domain controller <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. You might recall from <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span> that Windows uses this API for interactive authentication. The API has multiple modes, one of which can verify the NTLM authentication values without needing the user’s password.</p>
<p class="TX">Note that the domain controller doesn’t verify the MIC, as this requires all three authentication tokens. Instead, the server calculates the session <span aria-label=" Page 435. " epub:type="pagebreak" id="pg_435" role="doc-pagebreak"></span>key used for verification based on the user’s NT hash and NT challenge value and returns it to the requesting server. This allows it to ensure that the authentication hasn’t been tampered with.</p>
<p class="TX">The Windows server never has access to the user’s full password or NT hash, only the session key. This results in the <i>double hop problem</i>: the authenticated user can access resources stored locally on the server, but that user cannot be used to access resources on other servers on the domain network.</p>
<p class="TX">From a security perspective, this is a good thing, as it prevents a malicious service from repurposing a user’s identity. However, it also reduces flexibility, as it means that you can’t trivially implement an authenticated proxying service without requiring the user to reauthenticate to each service behind that proxy. Kerberos solves the double hop problem using delegation, as I’ll describe in more detail in <span class="Xref"><a href="chapter14.xhtml">Chapter 14</a></span>.</p>
</section>
<section aria-labelledby="sec9" epub:type="division">
<h4 class="H2" id="sec9"><span id="h2-141"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Local Loopback Authentication</samp></h4>
<p class="TNI1">In the previous example, I chose to specify a username and domain when getting the outbound authentication credentials handle. While Integrated Windows Authentication doesn’t require you to specify either a username or a domain, you need to do so if you want to create a network logon session on the local machine. Let’s change the script in <a href="chapter13.xhtml#Lis13-1">Listing 13-1</a> to build the outbound credentials without a username or domain:</p>
<pre><code>PS&gt; <b>$credout = New-LsaCredentialHandle -Package "NTLM" -UseFlag Outbound</b>
</code></pre>
<p class="TX">Now rerun the authentication session. The formatted tokens should look like those in <a href="chapter13.xhtml#Lis13-10">Listing 13-10</a>.</p>
<span id="Lis13-10"></span><pre><code>&lt;NTLM NEGOTIATE&gt;
Flags: Unicode, Oem, RequestTarget, NTLM, OemDomainSupplied,
OemWorkstationSupplied, AlwaysSign, ExtendedSessionSecurity, Version,
Key128Bit, Key56Bit
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> Domain: DOMAIN
Workstation: GRAPHITE
Version: 10.0.XXXXX.XX

&lt;NTLM CHALLENGE&gt;
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> Flags     : Unicode, RequestTarget, NTLM, LocalCall,...
TargetName: DOMAIN
Challenge : 9900CFB9C182FA39
<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> Reserved  : 5100010000000000
Version   : 10.0.XXXXX.XX
<var>--snip--</var>

&lt;NTLM AUTHENTICATE&gt;
<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> Flags      : Unicode, RequestTarget, NTLM, LocalCall,...
<span aria-label="annotation5" class="CodeAnnotationHang1">❺</span> LM Response:
NT Response:
Version    : 10.0.XXXXX.XX
MIC        : 34D1F09E07EF828ABC2780335EE3E452

<span aria-label=" Page 436. " epub:type="pagebreak" id="pg_436" role="doc-pagebreak"></span>PS&gt; <b>Get-NtLogonSession -Token $token</b>
LogonId           UserName       LogonType         SessionId
-------           --------       ---------         ---------
<span aria-label="annotation6" class="CodeAnnotationHang1">❻</span> 00000000-000A0908 GRAPHITE\user  Interactive       2

PS&gt; <b>Get-NtTokenId -Authentication</b>
LUID
----
<span aria-label="annotation7" class="CodeAnnotationHang1">❼</span> 00000000-000A0908
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-10: The formatted tokens from a local loopback authentication</span></p>
<p class="TX">You might notice that all three authentication tokens have changed. The first change is in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token, which now contains a domain name and workstation name <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. The next changes are in the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> token: a new flag has appeared, <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp> <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>, and a previously zeroed <samp class="SANS_TheSansMonoCd_W5Regular_11">Reserved</samp> field now has a value <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp> flag signifies that the authentication comes from the local machine, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">Reserved</samp> field is a unique identifier for the server security context that created the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> token.</p>
<p class="TX">The final changes are in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token. While the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp> flag is still present <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, both the <samp class="SANS_TheSansMonoCd_W5Regular_11">LM Response</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">NT Response</samp> fields are completely empty <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>. This clearly signifies that the authentication process has changed. If we check the final <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object’s logon session, we see that it’s an interactive session instead of a network session <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. The reason for this is that the LSA has returned a copy of the caller’s token to the server, as you can see by comparing the logon ID to the authentication ID from the effective token <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>.</p>
<p class="TX">Let’s take a closer look at the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp> flag. Its value is based on the domain and workstation names in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> authentication token. If these values refer to the local machine, local loopback authentication is enabled. There are no other unique identifiers in the initial token to key the flag on, and there doesn’t need to be an ongoing outbound authentication process for the flag to be selected. Also, the flag is not specified in the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token’s flags, so it’s not negotiated between the client and server.</p>
<p class="TX">At the time of writing, Microsoft does not document the <samp class="SANS_TheSansMonoCd_W5Regular_11">LocalCall</samp> flag in <i>MS-NLMP</i>, presumably because it shouldn’t be supported outside of the local machine. However, as you can see, merely providing the right <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token causes local loopback authentication to kick in. Documenting this flag would make it easier to diagnose authentication failures that could occur if the flag were present over the network.</p>
<p class="TX">Why does the LSA implement local loopback authentication? One reason is that network authentication would cause the user to be reauthenticated, and some local services, such as SMB, allow local interactive users, but not network users, to access file shares. Therefore, this local loopback allows the SMB server to see a local user and grant access.</p>
</section>
<section aria-labelledby="sec10" epub:type="division">
<h4 class="H2" id="sec10"><span id="h2-142"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Alternative Client Credentials</samp></h4>
<p class="TNI1">We’ve seen how to use PowerShell commands to authenticate as the calling user. This is normally the behavior you’ll want to implement, as the current user typically aims to access some network resource as themselves. However, <span aria-label=" Page 437. " epub:type="pagebreak" id="pg_437" role="doc-pagebreak"></span>the underlying APIs support several mechanisms that allow you to authenticate as a different user over the network. Changing your user identity is useful because it enables you to access a network resource without reauthenticating interactively.</p>
<section aria-labelledby="sec11" epub:type="division">
<h5 class="H3" id="sec11"><span id="h3-39"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Using Explicit Credentials</samp></h5>
<p class="TNI1">If you know the new user’s full credentials, you can specify them when creating the credentials handle for the client authentication context. To do this, call <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp> and pass it the <samp class="SANS_TheSansMonoCd_W5Regular_11">UserName</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">Domain</samp>, and <samp class="SANS_TheSansMonoCd_W5Regular_11">Password</samp> parameters.</p>
<p class="TX">However, you probably don’t want to leave a user’s password in PowerShell’s command history. One alternative is to specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">ReadCredential</samp> parameter, which will read the credentials from the user without storing them in the command history. <a href="chapter13.xhtml#Lis13-11">Listing 13-11</a> shows an example.</p>
<span id="Lis13-11"></span><pre><code>PS&gt; <b>$cout = New-LsaCredentialHandle -Package NTLM -UseFlag Outbound </b>
<b>-ReadCredential</b>
PS&gt; UserName: <b>admin</b>
PS&gt; Domain: <b>GRAPHITE</b>
PS&gt; Password:<b> ********</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-11: Creating a credentials handle with user-specified credentials</span></p>
<p class="TX">You can now pass the credentials handle to <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaClientContext</samp> to create the client context. You don’t need to change the server side, which uses the credentials managed by the LSA.</p>
</section>
<section aria-labelledby="sec12" epub:type="division">
<h5 class="H3" id="sec12"><span id="h3-40"></span><samp class="SANS_Futura_Std_Bold_Condensed_B_11">Impersonating a Token</samp></h5>
<p class="TNI1">When creating the credentials handle, the LSA usually determines the network credentials to use based on the calling user’s identity, which it retrieves from the primary token of the process that calls the SSPI API. However, if you have a different user’s token, you can impersonate them while creating the credentials handle to use a different identity. Run the command in <a href="chapter13.xhtml#Lis13-12">Listing 13-12</a> as an administrator.</p>
<span id="Lis13-12"></span><pre><code>PS&gt; <b>$credout = Invoke-NtToken -System {</b>
    <b>New-LsaCredentialHandle -Package "NTLM" -UseFlag Outbound</b>
<b>}</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-12: Creating the credentials handle for the</span> <samp class="SANS_Futura_Std_Book_11">SYSTEM</samp> <span class="Futura_Std_Book_Oblique_I_11">user</span></p>
<p class="TX">In <a href="chapter13.xhtml#Lis13-12">Listing 13-12</a>, we create a credentials handle for the <i>SYSTEM</i> user. The <i>SYSTEM</i> user doesn’t have any explicit password you can use to authenticate using the approach in <a href="chapter13.xhtml#Lis13-11">Listing 13-11</a>; therefore, you must impersonate the token to create a credentials handle for it.</p>
<p class="TX">You need to impersonate the token only once, when calling the <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp> command. All subsequent calls used to create and update the client context don’t require you to impersonate the token.</p>
<p class="TX"><span aria-label=" Page 438. " epub:type="pagebreak" id="pg_438" role="doc-pagebreak"></span>If you have the full credentials, another approach you could use is to create the token with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp> logon type, briefly mentioned in <span class="Xref"><a href="chapter12.xhtml">Chapter 12</a></span>. This will create a token with the same local user identity but replace the network authentication credentials, as illustrated in <a href="chapter13.xhtml#Lis13-13">Listing 13-13</a>.</p>
<span id="Lis13-13"></span><pre><code>PS&gt; <b>$password = Read-Host -AsSecureString -Prompt "Password"</b>
PS&gt; <b>$new_token = Get-NtToken -Logon -LogonType NewCredentials</b>
<b>-User "Administrator" -Domain "GRAPHITE" -SecurePassword $password</b>
PS&gt; <b>$credout = Invoke-NtToken $new_token {</b>
    <b>New-LsaCredentialHandle -Package "NTLM" -UseFlag Outbound</b>
<b>}</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-13: Creating a credentials handle with a NewCredentials token</span></p>
<p class="TX">Here, we create a credentials handle by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-NtToken</samp> command to generate a <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp>-type token, then impersonating it when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaCredentialHandle</samp>.</p>
<p class="TX">You might be wondering why, if you know the full credentials, you wouldn’t just specify them directly when creating the credentials handle. In this example, this would indeed be the simpler solution. However, you sometimes won’t have direct control over the creation of the credentials handle. This can happen if the network authentication occurs within another API that uses the caller’s identity to access a remote resource. In that case, you can impersonate the <samp class="SANS_TheSansMonoCd_W5Regular_11">NewCredentials</samp> token while calling the API to use the credentials you specified. Importantly, only the network credentials will change due to impersonation; the local identity will stay the same, so you won’t accidentally access local resources with the wrong user account.</p>
<p class="TX">Let’s finish this chapter by describing a practical attack against the NTLM authentication protocol. This attack allows you to repurpose the credentials of another user without needing to know the user’s password.</p>
</section>
</section>
</section>
<section aria-labelledby="sec13" epub:type="division">
<h3 class="H1" id="sec13"><span id="h1-99"></span><samp class="SANS_Futura_Std_Bold_B_11">The NTLM Relay Attack</samp></h3>
<p class="TNI1">One thing you might notice about NTLM is that, while the LSA performs the authentication, it’s up to the client and server applications to transport the authentication tokens. How does the LSA ensure that it’s authenticating to the right computer? It can’t do this directly: it needs the help of the client and server applications. This causes a security vulnerability that an actor could exploit with an attack called an <i>NTLM relay</i>. In this section, we’ll explore this attack and how Microsoft has tried to fix the vulnerability.</p>
<section aria-labelledby="sec14" epub:type="division">
<h4 class="H2" id="sec14"><span id="h2-143"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Attack Overview</samp></h4>
<p class="TNI1"><a href="chapter13.xhtml#fig13-3">Figure 13-3</a> shows the basic setup of an NTLM relay attack.</p>
<span aria-label=" Page 439. " epub:type="pagebreak" id="pg_439" role="doc-pagebreak"></span>
<figure class="IMG"><img alt="" class="img1" height="1161" id="fig13-3" src="../images/Figure13-3.jpg" width="1607"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-3: An example of an NTLM relay attack</samp></p></figcaption>
</figure>
<p class="TX">Three systems are involved: a Windows client machine, a Windows server, and the attacker’s machine. The attacker’s goal is to access the SMB file share on the server. However, they don’t have the credentials necessary to successfully perform NTLM authentication. The client, on the other hand, does have suitable credentials, and because of Interactive Windows Authentication, it will use those credentials without user interaction if asked nicely.</p>
<p class="TX">The first step is for the attacker to convince the client machine to connect to the attacker’s web server. While the attacker wants to access SMB, the NTLM authentication from the client can be over any protocol that supports authentication, including HTTP. Convincing the client to make a connection could be as simple as adding an image to a web page the client visits that points to the attacker’s web server.</p>
<p class="TX">The attacker accepts the client’s HTTP connection and starts the NTLM authentication process, which results in the client sending a <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token to the attacker <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. Instead of processing the token, the attacker now opens a new connection to the target SMB server and passes along the <samp class="SANS_TheSansMonoCd_W5Regular_11">NEGOTIATE</samp> token as if they had created it <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>.</p>
<p class="TX">The SMB server will respond with a <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> token, and the attacker can forward this to the client to continue the authentication process <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The client should respond with an <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token to the attacker’s web server, <span aria-label=" Page 440. " epub:type="pagebreak" id="pg_440" role="doc-pagebreak"></span>which it can forward to the SMB server <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. Assuming the server accepts the client’s credentials, the attacker has now established an authenticated connection to the SMB server without ever knowing the user’s password.</p>
<p class="TX">This attack is a serious security issue. Microsoft has tried to implement various fixes, mainly by adding more features to NTLM. However, the problem with these fixes is that they’re opt-in, for backward compatibility reasons: NTLM and SMB are such old protocols that certain clients and servers don’t support the new features. Still, let’s discuss the ways that Windows mitigates the vulnerability.</p>
</section>
<section aria-labelledby="sec15" epub:type="division">
<h4 class="H2" id="sec15"><span id="h2-144"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Active Server Challenges</samp></h4>
<p class="TNI1">The simplest way of performing an NTLM relay attack is to authenticate back to the victim’s machine. For example, in <a href="chapter13.xhtml#fig13-3">Figure 13-3</a>, the HTTP client and the SMB server could live on the same Windows machine. If the machine is both the client and the server, the authentication credentials will always be valid.</p>
<p class="TX">To fix this attack, Windows began maintaining a table of currently active server challenges and refusing to create the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token if the <samp class="SANS_TheSansMonoCd_W5Regular_11">CHALLENGE</samp> token included a server challenge issued by the same machine. There is a small chance of a collision occurring between two machines, but with a random 8-byte challenge, this will rarely happen.</p>
</section>
<section aria-labelledby="sec16" epub:type="division">
<h4 class="H2" id="sec16"><span id="h2-145"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Signing and Sealing</samp></h4>
<p class="TNI1">Another way of combatting the NTLM relay attack is to make the outer protocol containing the NTLM authentication, such as SMB, rely on the authentication process in some way. This boils down to using the only piece of information the attacker doesn’t have: the user’s password.</p>
<p class="TX">The SSPI APIs and NTLM support the inclusion of a randomly generated session key in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token that is encrypted by the user’s password. This session key can then be used to generate a MIC, which the documentation refers to as <i>signing</i>. The MIC is generated for the outer protocol using the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakeSignature</samp> SSPI API and verified using the <samp class="SANS_TheSansMonoCd_W5Regular_11">VerifySignature</samp> API. The key can also be used to encrypt and decrypt arbitrary data using the <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptMessage</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">DecryptMessage</samp> APIs, which the documentation refers to as <i>sealing</i>. Because the attacker can’t decrypt the session key without knowing the password, they can’t generate valid signed or encrypted data to communicate with the relayed server.</p>
<p class="TX">To request a session key, you specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Confidentiality</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">Integrity</samp> flag when creating the client or server context by using the <samp class="SANS_TheSansMonoCd_W5Regular_11">RequestAttribute</samp> parameter. For example, when calling <samp class="SANS_TheSansMonoCd_W5Regular_11">New-LsaClientContext</samp>, you can specify the following command:</p>
<pre><code>PS&gt; <b>$client = New-LsaClientContext -CredHandle $credout -RequestAttribute </b>
<b>Integrity</b>
</code></pre>
<p class="TX"><a href="chapter13.xhtml#Lis13-14">Listing 13-14</a> shows the client’s <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token if we specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Integrity</samp> request attribute flag when creating the client and server contexts.</p>
<span id="Lis13-14"></span><pre><code><span aria-label=" Page 441. " epub:type="pagebreak" id="pg_441" role="doc-pagebreak"></span>&lt;NTLM AUTHENTICATE&gt;
<span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> Flags      : Unicode, RequestTarget, Signing, NTLM, AlwaysSign,
ExtendedSessionSecurity, TargetInfo, Version,
Key128Bit, KeyExchange, Key56Bit
<var>--snip--</var>
&lt;/NTLMv2 Challenge Response&gt;
<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> Session Key: 5B13E92C08E140D37E156D2FE4B0EAB9
Version    : 10.0.18362.15
MIC        : 5F5E9B1F1556ADA1C07E83A715A7809F
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-14: Checking the AUTHENTICATE token for the session key</span></p>
<p class="TX">As the output shows, this changes the NTLM process in two important ways. First, the NTLM <samp class="SANS_TheSansMonoCd_W5Regular_11">KeyExchange</samp> flag has been added <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. This flag indicates that the client has generated a session key. The flags also now include <samp class="SANS_TheSansMonoCd_W5Regular_11">Signing</samp>, which indicates to the server that the client wants to allow the signing of content based on the session key. If the <samp class="SANS_TheSansMonoCd_W5Regular_11">Confidentiality</samp> request attribute flag is used, two <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> flags are set, <samp class="SANS_TheSansMonoCd_W5Regular_11">Signing</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Sealing</samp>.</p>
<p class="TX">If either flag is set, the NTLMv2 challenge contains an encrypted session key that the client generated <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. This is the base key used for all further cryptographic operations. The key is encrypted using the RC4 encryption algorithm and a key derived from the user’s hash and the NT response.</p>
<p class="TX">If you verify the MIC after enabling signing or sealing, you’ll notice that the value generated no longer matches the one in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token. This is because if the encrypted session key is available, it’s used instead of the base session key. You can fix this behavior by modifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-Mic</samp> function shown in <a href="chapter13.xhtml#Lis13-9">Listing 13-9</a>, adding the bold portion in <a href="chapter13.xhtml#Lis13-15">Listing 13-15</a>.</p>
<span id="Lis13-15"></span><pre><code>$session_key = Get-Md5Hmac -Key $Key -Data $Proof
<b>if ($authToken.EncryptedSessionKey.Count -gt 0) {</b>
    <b>$session_key = Unprotect-RC4 -Key $session_key</b>
<b>-Data $AuthToken.EncryptedSessionKey</b>
<b>}</b>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-15: Modifying the Get-Mic function to decrypt the session key for the MIC calculation</span></p>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">MakeSignature</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">VerifySignature</samp> APIs are exposed through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-LsaContextSignature</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-LsaContextSignature</samp> commands, while the <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptMessage</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">DecryptMessage</samp> APIs are exposed through the <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp> commands. We’ll cover the use of these encryption commands in the worked example at the end of this chapter; for now, <a href="chapter13.xhtml#Lis13-16">Listing 13-16</a> shows a simple use of the signature commands.</p>
<span id="Lis13-16"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> PS&gt; <b>$server = New-LsaServerContext -CredHandle $credin</b>
PS&gt; <b>Update-LsaServerContext $server $client</b>
PS&gt; <b>Update-LsaClientContext $client $server</b>
PS&gt; <b>Update-LsaServerContext $server $client</b>
PS&gt; <b>$msg = $(0, 1, 2, 3)</b>
<span aria-label=" Page 442. " epub:type="pagebreak" id="pg_442" role="doc-pagebreak"></span><span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> PS&gt; <b>$sig = Get-LsaContextSignature -Context $client -Message $msg</b>
PS&gt; <b>$sig | Out-HexDump</b>
01 00 00 00 A7 6F 57 90 8B 90 54 2B 00 00 00 00

<span aria-label="annotation3" class="CodeAnnotationHang1">❸</span> PS&gt; <b>Test-LsaContextSignature -Context $server -Message $msg -Signature $sig</b>
True

<span aria-label="annotation4" class="CodeAnnotationHang1">❹</span> PS&gt; <b>Test-LsaContextSignature -Context $server -Message $msg -Signature $sig</b>
False
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-16: Generating and verifying a message signature</span></p>
<p class="TX">We start by completing the client-to-server authentication process to set up integrity support <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. We then generate a signature for a simple 4-byte message using the client authentication context <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. This process assumes that the data is being sent to the server for verification; we can reverse it by specifying a different authentication context. We display the generated signature value as hex.</p>
<p class="TX">We then verify the signature with the server authentication context using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Test-LsaContextSignature</samp> command <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. The command returns a Boolean value indicating whether the signature is valid. For this call, the verification returns <samp class="SANS_TheSansMonoCd_W5Regular_11">True</samp>. However, if we check the signature a second time <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>, we now get <samp class="SANS_TheSansMonoCd_W5Regular_11">False</samp>, indicating that it is no longer valid. Why is that?</p>
<p class="TX">The client and server authentication contexts maintain a <i>sequence number</i>, which starts at 0 and increments for every signature or encryption operation. This sequence number is automatically included when generating or verifying a signature, and the server can use it to check whether an old signature has been replayed (for example, if an attacker is trying to send the same network data twice).</p>
<p class="TX">In the example in <a href="chapter13.xhtml#Lis13-16">Listing 13-16</a>, we generated the client’s signature with a sequence number of 0. In the first verification, the server’s authentication context also has an initial value of 0, so the verification succeeds. However, after the verification completes, the server’s sequence number is incremented to 1. So, when we try to verify the same signature again, the sequence numbers no longer match, and the verification fails.</p>
<p class="TX">The RC4 encryption algorithm used for signing and sealing has numerous weaknesses, which are outside the scope of this book. However, it offers some level of mitigation against NTLM relay attacks and provides basic integrity and confidentiality protections to the outer network protocol if no other key exchange mechanism is in place.</p>
<p class="TX">SMB supports signing and encryption derived from the authentication process. However, because of the weakness of RC4, SMB doesn’t use the <samp class="SANS_TheSansMonoCd_W5Regular_11">MakeSignature</samp> or <samp class="SANS_TheSansMonoCd_W5Regular_11">EncryptMessage</samp> APIs; instead, it extracts the decrypted session key using the <samp class="SANS_TheSansMonoCd_W5Regular_11">QueryContextAttribute</samp> SSPI API and uses its own encryption and integrity-checking algorithms. You can query for the session key by accessing the <samp class="SANS_TheSansMonoCd_W5Regular_11">SessionKey</samp> property on the client or server authentication context, as shown in <a href="chapter13.xhtml#Lis13-17">Listing 13-17</a>.</p>
<span id="Lis13-17"></span><pre><code><span aria-label=" Page 443. " epub:type="pagebreak" id="pg_443" role="doc-pagebreak"></span>PS&gt; <b>$server.SessionKey | Out-HexDump</b>
F3 FA 3A E0 8D F7 EE 34 75 C5 00 9F BF 77 0E E1
PS&gt; <b>$client.SessionKey | Out-HexDump</b>
F3 FA 3A E0 8D F7 EE 34 75 C5 00 9F BF 77 0E E1
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-17: Extracting the session keys for the authentication context</span></p>
</section>
<section aria-labelledby="sec17" epub:type="division">
<h4 class="H2" id="sec17"><span id="h2-146"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Target Names</samp></h4>
<p class="TNI1">Another technique for blocking NTLM relay attacks is to add an identifier to the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token that indicates the name of the target the NTLM authentication is for. Because the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token is protected by the MIC, which is derived from the user’s password, the target name is hard to tamper with.</p>
<p class="TX">In our NTLM relay example, if the client enabled target names, it might set the target name to <i>HTTP/attacker.domain.local</i>, where <i>HTTP</i> represents the type of service requested and <i>attacker.domain.local</i> is the address to which it’s authenticating. The attacker could pass the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token to the SMB server, but because the server runs a different service, <i>CIFS</i>, and sits on a different network address, <i>fileserver.domain.local</i>, the names will not match and authentication will fail.</p>
<p class="TX">To specify a target name, set the <samp class="SANS_TheSansMonoCd_W5Regular_11">Target</samp> parameter when creating the client authentication context:</p>
<pre><code>PS&gt; <b>$client = New-LsaClientContext -CredHandle $credout -Target "HTTP/localhost"</b>
</code></pre>
<p class="TX">Note that the target name can be completely arbitrary, but the service type or network address can’t be. For example, the name <i>BLAH</i> wouldn’t be rejected, but the name <i>BLAH/microsoft.com</i> would be (unless you happened to be running a server on <i>microsoft.com</i>). The name format follows that of the service principal name (SPN) used in Kerberos authentication. We’ll describe how Kerberos uses SPNs in the next chapter.</p>
<p class="TX">When you run the NTLM authentication, you should now see the target name in the NTLMv2 challenge response block:</p>
<pre><code>TargetName - HTTP/localhost
</code></pre>
<p class="TX">You can extract the target name from the server authentication content with the <samp class="SANS_TheSansMonoCd_W5Regular_11">ClientTargetName</samp> property:</p>
<pre><code>PS&gt; <b>$server.ClientTargetName</b>
HTTP/localhost
</code></pre>
<p class="TX">The problem with the target name protection is that it must be enabled to be effective. By default, clients won’t set it, and the SMB server does not require it to be specified. Also, an attacker can spoof the name, as it’s typically based on some network address. For example, the attacker might be able to poison the client’s DNS cache or use other local network attacks to hijack the server’s IP address.</p>
</section>
<section aria-labelledby="sec18" epub:type="division">
<h4 class="H2" id="sec18"><span id="h2-147"></span><span aria-label=" Page 444. " epub:type="pagebreak" id="pg_444" role="doc-pagebreak"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Channel Binding</samp></h4>
<p class="TNI1">The final protection against NTLM relay we’ll discuss is <i>channel binding</i>, which Microsoft also refers to as <i>Extended Protection for Authentication (EPA)</i>. The purpose of channel binding is to add an additional value to the NTLMv2 <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token that the MIC will protect from tampering.</p>
<p class="TX">Instead of using an arbitrary name, channel binding allows the client and server to specify a binary token related to some property of the outer network protocol. One common use of channel binding is in <i>Transport Layer Security (TLS)</i>, a generic network protocol that encrypts and verifies another streaming protocol. This prevents the encrypted protocol’s contents from being disclosed to anyone inspecting network traffic and enables tampering detection. It’s used, for example, to secure HTTP as HTTPS.</p>
<p class="TX">In a TLS communication, the client and server could specify the TLS server’s X.509 certificate as the channel binding token. The TLS protocol first verifies the certificate and ensures that the connection is really being made to the destination server. Then it binds the NTLM authentication to that channel. This prevents attackers from hijacking authentication by injecting data into the TLS channel. If the attacker instead redirects a TLS connection to their own server, the certificate will be different, and will use a different channel binding value.</p>
<p class="TX">To enable channel binding, specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">ChannelBinding</samp> parameter in the client and server authentication contexts:</p>
<pre><code>PS&gt; <b>$client = New-LsaClientContext -CredHandle $credout -ChannelBinding @(1, 2, 3)</b>
PS&gt; <b>$server = New-LsaServerContext -CredHandle $credin -ChannelBinding @(1, 2, 3)</b>
</code></pre>
<p class="TX">If you now run the NTLM authentication process, you’ll find that the channel binding value, which used to be all zeros, now has a value similar to the following:</p>
<pre><code>ChannelBinding - BAD4B8274DC394EDC375CA8ABF2D2AEE
</code></pre>
<p class="TX">The <samp class="SANS_TheSansMonoCd_W5Regular_11">ChannelBinding</samp> value is an MD5 hash of a <samp class="SANS_TheSansMonoCd_W5Regular_11">SEC_CHANNEL_BINDINGS</samp> structure, which includes the channel binding data specified to the authentication context. The value itself should always be the same for every authentication with the same data. For the implementation used in the PowerShell module, you can use the function in <a href="chapter13.xhtml#Lis13-18">Listing 13-18</a> to calculate the hash.</p>
<span id="Lis13-18"></span><pre><code>PS&gt; <b>function Get-BindingHash {</b>
    <b>Param(</b>
         <b>[byte[]]$ChannelBinding</b>
    <b>)</b>
    <b>$stm = [System.IO.MemoryStream]::new()</b>
    <b>$writer = [System.IO.BinaryWriter]::new($stm)</b>
    <b>$writer.Write(0) # dwInitiatorAddrType</b>
<span aria-label=" Page 445. " epub:type="pagebreak" id="pg_445" role="doc-pagebreak"></span>    <b>$writer.Write(0) # cbInitiatorLength</b>
    <b>$writer.Write(0) # dwAcceptorAddrType</b>
    <b>$writer.Write(0) # cbAcceptorLength</b>
    <b>$writer.Write($ChannelBinding.Count) # cbApplicationDataLength</b>
    <b>$writer.Write($ChannelBinding) # Application Data</b>
    <b>[System.Security.Cryptography.MD5Cng]::new().ComputeHash($stm.ToArray())</b>
<b>}</b>
PS&gt; <b>Get-BindingHash -ChannelBinding @(1, 2, 3) | Out-HexDump</b>
BA D4 B8 27 4D C3 94 ED C3 75 CA 8A BF 2D 2A EE
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-18: Calculating the channel binding hash</span></p>
<p class="TX">As with target names, systems must opt in to this feature. If the server does not specify a channel binding token, the channel binding hash in the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token won’t be checked. Only when the server specifies a channel binding token that doesn’t match will the authentication process fail.</p>
</section>
</section>
<section aria-labelledby="sec19" epub:type="division">
<h3 class="H1" id="sec19"><span id="h1-100"></span><samp class="SANS_Futura_Std_Bold_B_11">Worked Example</samp></h3>
<p class="TNI1">Let’s finish with a worked example using the commands you’ve learned about in this chapter. In this example, we’ll develop a simple network protocol that uses NTLM and the authentication context mechanisms to authenticate a user over a network, providing encryption and integrity verification. As this example will be quite complex, I’ll break it into sections.</p>
<section aria-labelledby="sec20" epub:type="division">
<h4 class="H2" id="sec20"><span id="h2-148"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Overview</samp></h4>
<p class="TNI1">The .NET framework already comes with the <samp class="SANS_TheSansMonoCd_W5Regular_11">NegotiateStream</samp> class, which uses the SSPI to authenticate and encrypt network communications. Nevertheless, you’ll find it instructive to build a similar mechanism yourself. The network protocol we’ll develop won’t be robust or even secure; it will merely demonstrate a practical use of the commands described in this chapter.</p>
<p class="TX">NTLM’s security properties (and its encryption and integrity verification mechanisms) are very weak by modern standards, so if you want a robust encrypted network protocol, use TLS instead. TLS is available through the <samp class="SANS_TheSansMonoCd_W5Regular_11">SslStream</samp> class in .NET.</p>
<p class="TX"><a href="chapter13.xhtml#fig13-4">Figure 13-4</a> shows a basic overview of the protocol we’ll build.</p>
<span aria-label=" Page 446. " epub:type="pagebreak" id="pg_446" role="doc-pagebreak"></span>
<figure class="IMG"><img alt="" class="img1" height="895" id="fig13-4" src="../images/Figure13-4.jpg" width="1378"/>
<figcaption><p class="CAP"><samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 13-4: An overview of the network protocol</samp></p></figcaption>
</figure>
<p class="TX">We’ll use TCP to facilitate communications between the client and the server <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. TCP is a reliable protocol built into almost every computing device on the planet—but because it’s a streaming protocol, there are no breaks between messages you send or receive. We need a way of breaking up the stream so that the client and server know when they’ve read a single message. For simplicity, we’ll send data as ASCII text, with a newline character at the end to indicate the end of a message.</p>
<p class="TX">Once we’ve established the TCP connection, we’ll perform an NTLM authentication <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. As the authentication tokens for NTLM are binary, we’ll encode them using the base64 algorithm, which converts binary data into a text string made of 64 ASCII characters.</p>
<p class="TX">We can then send messages back and forth between the client and the server <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. We’ll encrypt and decrypt the data using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Unprotect-LsaContextMessage</samp> PowerShell commands. As the encryption process generates encrypted messages and a separate signature, we’ll send them as two separate base64 text lines.</p>
</section>
<section aria-labelledby="sec21" epub:type="division">
<h4 class="H2" id="sec21"><span id="h2-149"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Code Module</samp></h4>
<p class="TNI1">The client and server will perform many of the same tasks, such as sending and receiving messages, so it makes sense to put that code into a separate module that both sides can easily reference. Create a directory for the example code and copy <a href="chapter13.xhtml#Lis13-19">Listing 13-19</a> into its own file with the name <i>network_protocol</i>_<i>common.psm1</i>, as both the server and client implementations will need to access it.</p>
<span id="Lis13-19"></span><pre><code><span aria-label=" Page 447. " epub:type="pagebreak" id="pg_447" role="doc-pagebreak"></span>Import-Module NtObjectManager
function Get-SocketClient {
    param(
        [Parameter(Mandatory)]
        $Socket
    )

    $Socket.Client.NoDelay = $true
    $stream = $Socket.GetStream()
    $reader = [System.IO.StreamReader]::new($stream)
    $writer = [System.IO.StreamWriter]::new($stream)
    $writer.AutoFlush = $true
    return @{
        Reader = $reader
        Writer = $writer
    }
}

function Send-Message {
    param(
        [Parameter(Mandatory)]
        $Client,
        [Parameter(Mandatory)]
        $Message
    )

    Write-Verbose "Sending Message"
    Format-HexDump -Byte $Message -ShowAll | Write-Verbose
    $text = [System.Convert]::ToBase64String($Message)
    $Client.Writer.WriteLine($text)
}

function Receive-Message {
    param(
        [Parameter(Mandatory)]
        $Client
    )

    $text = $Client.Reader.ReadLine()
    $ba = [System.Convert]::FromBase64String($text)
    Write-Verbose "Received Message"
    Format-HexDump -Byte $ba -ShowAll | Write-Verbose

    Write-Output -NoEnumerate $ba
}

function Send-TextMessage {
    param(
        [Parameter(Mandatory)]
        $Client,
        [Parameter(Mandatory)]
        $Message,
        [Parameter(Mandatory)]
        $Context
    )

<span aria-label=" Page 448. " epub:type="pagebreak" id="pg_448" role="doc-pagebreak"></span>    $bytes = [System.Text.Encoding]::UTF8.GetBytes($Message)
    $enc = Protect-LsaContextMessage -Context $Context -Message $bytes
    Send-Message -Client $Client -Message $enc.Message
    Send-Message -Client $Client -Message $enc.Signature
}

function Receive-TextMessage {
    param(
        [Parameter(Mandatory)]
        $Client,
        [Parameter(Mandatory)]
        $Context
    )

    $msg = Receive-Message -Client $Client
    if ($msg.Length -eq 0) {
        return ""
    }

    $sig = Receive-Message -Client $Client
    if ($sig.Length -eq 0) {
        return ""
    }

    $dec = Unprotect-LsaContextMessage -Context $Context -Message $msg -Signature $sig
    [System.Text.Encoding]::UTF8.GetString($dec)
}

Export-ModuleMember -Function 'Get-SocketClient', 'Send-Message',
'Receive-Message', 'Send-TextMessage', 'Receive-TextMessage'
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-19: The shared module code for the protocol</span></p>
<p class="TX">The module code contains five functions. The first function, <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SocketClient</samp>, accepts a connected TCP socket and creates a <samp class="SANS_TheSansMonoCd_W5Regular_11">StreamReader</samp> and a <samp class="SANS_TheSansMonoCd_W5Regular_11">StreamWriter</samp> class. These classes allow you to read and write text lines to a binary stream, in this case over the network. We also set the socket’s <samp class="SANS_TheSansMonoCd_W5Regular_11">NoDelay</samp> property, which disables something called the Nagle algorithm. The details of the algorithm are outside the scope of this book, but it ensures that the data written to the socket is sent to the network immediately, rather than being buffered.</p>
<p class="TX">The next two functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">Send-Message</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Receive-Message</samp>, send and receive a binary message over the TCP socket. To send a message, we first convert the binary data to a base64 string, then write it to the writer object. For the receiving function we do the reverse operation, reading a line from the TCP socket and converting it back to binary data from base64. Note that we’re printing the messages we’re sending and receiving using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-Verbose</samp> PowerShell command. By default, PowerShell won’t show this verbose output; I’ll show you how to enable that later.</p>
<p class="TX">The final two functions, <samp class="SANS_TheSansMonoCd_W5Regular_11">Send-TextMessage</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">Receive-TextMessage</samp>, send and receive encrypted text messages. To send an encrypted message, we convert the message into binary data using the UTF8 text encoding, which <span aria-label=" Page 449. " epub:type="pagebreak" id="pg_449" role="doc-pagebreak"></span>allows us to use any Unicode character in our string. We then encrypt the binary data using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Protect-LsaContextMessage</samp> command. We must send the encrypted data and signature as separate lines, using our existing <samp class="SANS_TheSansMonoCd_W5Regular_11">Send-Message</samp> command. Again, to receive data, we perform the inverse of the sending operation.</p>
</section>
<section aria-labelledby="sec22" epub:type="division">
<h4 class="H2" id="sec22"><span id="h2-150"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Server Implementation</samp></h4>
<p class="TNI1">We’ll start by implementing the server, as without a server it will be hard to test any client code. <a href="chapter13.xhtml#Lis13-20">Listing 13-20</a> contains the server implementation.</p>
<span id="Lis13-20"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> param(
    [switch]$Global,
    [int]$Port = 6543
)

<span aria-label="annotation2" class="CodeAnnotationHang1">❷</span> Import-Module "$PSScriptRoot\network_protocol_common.psm1"
$socket = $null
$listener = $null
$context = $null
$credin = $null

try {
  <span aria-label="annotation3" class="CodeAnnotationCode2">❸</span> $Address = if ($Global) {
        [ipaddress]::Any
    } else {
        [ipaddress]::Loopback
    }

  <span aria-label="annotation4" class="CodeAnnotationCode2">❹</span> $listener = [System.Net.Sockets.TcpListener]::new($Address, $port)
    $listener.Start()
    $socket = $listener.AcceptTcpClient()
    $client = Get-SocketClient -Socket $socket
    Write-Host "Connection received from $($socket.Client.RemoteEndPoint)"

  <span aria-label="annotation5" class="CodeAnnotationCode2">❺</span> $credin = New-LsaCredentialHandle -Package "NTLM" -UseFlag Inbound
    $context = New-LsaServerContext -CredHandle $credin
-RequestAttribute Confidentiality

  <span aria-label="annotation6" class="CodeAnnotationCode2">❻</span> $neg_token = Receive-Message -Client $client
    Update-LsaServerContext -Server $context -Token $neg_token
    Send-Message -Client $client -Message $context.Token.ToArray()
    $auth_token = Receive-Message -Client $client
    Update-LsaServerContext -Server $context -Token $auth_token

    if (!(Test-LsaContext -Context $context)) {
        throw "Authentication didn't complete as expected."
    }

  <span aria-label="annotation7" class="CodeAnnotationCode2">❼</span> $target = "BOOK/$($socket.Client.LocalEndPoint.Address)"
    if ($context.ClientTargetName -ne $target) {
        throw "Incorrect target name specified: $($context.ClientTargetName)."
    }

<span aria-label=" Page 450. " epub:type="pagebreak" id="pg_450" role="doc-pagebreak"></span>    $user = Use-NtObject($token = Get-LsaAccessToken -Server $context) {
        $token.User
    }
    Write-Host "User $user has authenticated."
  <span aria-label="annotation8" class="CodeAnnotationCode2">❽</span> Send-TextMessage -Client $client -Message "OK" -Context $context

  <span aria-label="annotation9" class="CodeAnnotationCode2">❾</span> $msg = Receive-TextMessage -Client $client -Context $context
    while($msg -ne "") {
        Write-Host "&gt; $msg"
        $reply = "User {0} said: {1}" -f $user, $msg.ToUpper()
        Send-TextMessage -Client $client -Message $reply -Context $context
        $msg = Receive-TextMessage -Client $client -Context $context
    }
} catch {
    Write-Error $_
} finally {
    if ($null -ne $socket) {
        $socket.Close()
    }
    if ($null -ne $listener) {
        $listener.Stop()
    }
    if ($null -ne $context) {
        $context.Dispose()
    }
    if ($null -ne $credin) {
        $credin.Dispose()
    }
}
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-20: A simple server implementation</span></p>
<p class="TX">Copy this code into its own script file in the same directory as the module file in <a href="chapter13.xhtml#Lis13-19">Listing 13-19</a>, and save it as <i>network_protocol_server.ps1</i>.</p>
<p class="TX">We start by defining some parameters <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. If you use the code as a script, you can make it act like a function by having it accept parameters on the command line. This makes it easy to change the script’s behavior. In this case, we define a <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp> parameter, which will change what network interfaces we bind the TCP server to, and a <samp class="SANS_TheSansMonoCd_W5Regular_11">Port</samp> parameter, which is the TCP port number.</p>
<p class="TX">Next, we import the common module <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. This ensures that the functions defined in <a href="chapter13.xhtml#Lis13-19">Listing 13-19</a> are available for the server to use. Then we set up the bind address <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. If <samp class="SANS_TheSansMonoCd_W5Regular_11">Global</samp> is set, then we bind to <samp class="SANS_TheSansMonoCd_W5Regular_11">Any</samp>, which represents all network interfaces; if not, we bind only to the loopback address, which is accessible only locally.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>It’s a common practice to bind to only the loopback address when testing server code. This ensures that other computers on the network can’t connect to your server and potentially abuse its functionality. Only bind to all network interfaces when you’re confident that any code you’ve written is secure, or when on a network with no other participants.</i></p>
</blockquote>
<p class="TX"><span aria-label=" Page 451. " epub:type="pagebreak" id="pg_451" role="doc-pagebreak"></span>Once we’ve determined the address, we create an instance of the <samp class="SANS_TheSansMonoCd_W5Regular_11">TcpListener</samp> class and bind to the address and TCP port <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. We call <samp class="SANS_TheSansMonoCd_W5Regular_11">Start</samp> to begin listening for new connections, and we wait for a connection by calling <samp class="SANS_TheSansMonoCd_W5Regular_11">AcceptTcpClient</samp>. At this point, without a client, the script will stop here. When a connection is made, we’ll receive a connected socket object that we can convert to the client using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Get-SocketClient</samp> command. We then print out the connected client address.</p>
<p class="TX">We can now set up a new server authentication context for NTLM <span aria-label="annotation5" class="CodeAnnotationCode">❺</span>, specifying the <samp class="SANS_TheSansMonoCd_W5Regular_11">Confidentiality</samp> request attribute to grant us the ability to encrypt and decrypt messages. We then negotiate the authentication with the client <span aria-label="annotation6" class="CodeAnnotationCode">❻</span>. If the authentication fails or we haven’t completed it after receiving the <samp class="SANS_TheSansMonoCd_W5Regular_11">AUTHENTICATE</samp> token, we throw an error to stop the server script.</p>
<p class="TX">We also check that the client provides a suitable target name during the authentication <span aria-label="annotation7" class="CodeAnnotationCode">❼</span>. It should be of the format <i>BOOK/&lt;ADDRESS&gt;</i>, where <i>&lt;ADDRESS&gt;</i> is the IP address of the server. If the target name doesn’t match, we’ll also throw a fatal error. To confirm the identity of the authenticated user, we query the <samp class="SANS_TheSansMonoCd_W5Regular_11">Token</samp> object from the context and print the user’s name. To inform the client that the authentication succeeded, we send a confirmation message <span aria-label="annotation8" class="CodeAnnotationCode">❽</span>. We encrypt this message, to ensure the session keys match.</p>
<p class="TX">Finally, we can start receiving text messages from the client <span aria-label="annotation9" class="CodeAnnotationCode">❾</span>. We read a text message, which we saw earlier will be decrypted and verified based on the negotiated authentication context. To prove it was received correctly, we write the message to the console. We then return the message to the client, appending the username to the message and uppercasing the text just for good measure.</p>
<p class="TX">If we receive an empty message, we treat this as the signal to close down the server; we’ll only accept the one connection. We make sure to clean up our resources, such as the TCP server, before leaving the script. Let’s now look at the client implementation.</p>
</section>
<section aria-labelledby="sec23" epub:type="division">
<h4 class="H2" id="sec23"><span id="h2-151"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Client Implementation</samp></h4>
<p class="TNI1">For the most part, the client implements the reverse operations of the server. <a href="chapter13.xhtml#Lis13-21">Listing 13-21</a> shows its code. Copy this into its own script file in the same directory as the module file from <a href="chapter13.xhtml#Lis13-19">Listing 13-19</a>, with the name <i>network_protocol_client.ps1</i>.</p>
<span id="Lis13-21"></span><pre><code><span aria-label="annotation1" class="CodeAnnotationHang1">❶</span> param(
    [ipaddress]$Address = [ipaddress]::Loopback,
    [int]$Port = 6543
)

Import-Module "$PSScriptRoot\network_protocol_common.psm1"

$socket = $null
$context = $null
$credout = $null

<span aria-label=" Page 452. " epub:type="pagebreak" id="pg_452" role="doc-pagebreak"></span>try {
  <span aria-label="annotation2" class="CodeAnnotationCode2">❷</span> $socket = [System.Net.Sockets.TcpClient]::new()
    $socket.Connect($Address, $port)
    $client = Get-SocketClient -Socket $socket
    Write-Host "Connected to server $($socket.Client.RemoteEndPoint)"

  <span aria-label="annotation3" class="CodeAnnotationCode2">❸</span> $credout = New-LsaCredentialHandle -Package "NTLM" -UseFlag Outbound
    $context = New-LsaClientContext -CredHandle $credout
-RequestAttribute Confidentiality -Target "BOOK/$Address"
    Send-Message -Client $client -Message $context.Token.ToArray()
    $chal_token = Receive-Message -Client $client
    Update-LsaClientContext -Client $context -Token $chal_token
    Send-Message -Client $client -Message $context.Token.ToArray()

    if (!(Test-LsaContext -Context $context)) {
        throw "Authentication didn't complete as expected."
    }

  <span aria-label="annotation4" class="CodeAnnotationCode2">❹</span> $ok_msg = Receive-TextMessage -Client $client -Context $context
    if ($ok_msg -ne "OK") {
        throw "Failed to authenticate."
    }

  <span aria-label="annotation5" class="CodeAnnotationCode2">❺</span> $msg = Read-Host -Prompt "MSG"
    while($msg -ne "") {
        Send-TextMessage -Client $client -Context $context -Message $msg
        $recv_msg = Receive-TextMessage -Client $client -Context $context
        Write-Host "&gt; $recv_msg"
        $msg = Read-Host -Prompt "MSG"
    }

} catch {
    Write-Error $_
} finally {
    if ($null -ne $socket) {
        $socket.Close()
    }
    if ($null -ne $context) {
        $context.Dispose()
    }
    if ($null -ne $credout) {
        $credout.Dispose()
    }
}
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-21: The client implementation</span></p>
<p class="TX">Again, we start by defining some parameters <span aria-label="annotation1" class="CodeAnnotationCode">❶</span>. In this case, we want to specify an IP address to connect to and its TCP port. By default, the client will connect to the loopback address on TCP port 6543. Next, we need to create the TCP socket <span aria-label="annotation2" class="CodeAnnotationCode">❷</span>. Because it’s a client, we can directly create a <samp class="SANS_TheSansMonoCd_W5Regular_11">TcpClient</samp> object to connect to the address and port. We can then wrap the socket with the stream readers and writers, like in the server implementation.</p>
<p class="TX"><span aria-label=" Page 453. " epub:type="pagebreak" id="pg_453" role="doc-pagebreak"></span>We create a client authentication context so that we can authenticate to the server <span aria-label="annotation3" class="CodeAnnotationCode">❸</span>. We’ll use the current user’s credentials for this purpose, but you can change this behavior if necessary. We also specify the target name so it matches the server’s; if we don’t do this, the server will disconnect us. We verify that we can read the <samp class="SANS_TheSansMonoCd_W5Regular_11">OK</samp> message sent from the server <span aria-label="annotation4" class="CodeAnnotationCode">❹</span>. If we don’t receive anything or the message does not match our expectations, it’s clear the authentication failed.</p>
<blockquote>
<p class="NOTE"><span class="NoteHead"><samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp></span></p>
<p class="NOTE-TXT"><i>You generally shouldn’t return detailed error information to a client in a network protocol. Sending a simple OK message, or nothing at all, may not help diagnose problems, but it prevents an attacker from finding out why the authentication failed. For example, if we sent the client the message BADPASSWORD if the password were wrong or BADUSER for an unknown user, an attacker could differentiate the two cases and try to brute-force a password for a valid user or enumerate valid usernames.</i></p>
</blockquote>
<p class="TX">If the authentication completed, we should now have a valid connection, so we can start sending messages. We read a text line from the console <span aria-label="annotation5" class="CodeAnnotationCode">❺</span> and send it to the server. We then wait for a reply and print it to the console. If we enter an empty line, the loop should exit, and the TCP socket should close. This should cause the server to receive an empty message, at which point the server can exit as well.</p>
</section>
<section aria-labelledby="sec24" epub:type="division">
<h4 class="H2" id="sec24"><span id="h2-152"></span><samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The NTLM Authentication Test</samp></h4>
<p class="TNI1">Let’s test the client and server we’ve just written. To do so, you’ll need two PowerShell consoles. In the first console, run the server script with the following command:</p>
<pre><code>PS&gt; <b>.\network_protocol_server.ps1</b>
</code></pre>
<p class="TX">Then, in the second console, run the client. When you see the <samp class="SANS_TheSansMonoCd_W5Regular_11">MSG</samp> prompt, enter a message, such as <samp class="SANS_TheSansMonoCd_W7Bold_B_11">Hello</samp>, to send to the server. The output in the client should resemble the following:</p>
<pre><code>PS&gt; <b>.\network_protocol_client.ps1</b>
Connected to server 127.0.0.1:6543
MSG: <b>Hello</b>
&gt; User GRAPHITE\user said: HELLO
MSG:
</code></pre>
<p class="TX">In the server console, the output should show the following:</p>
<pre><code>Connection received from 127.0.0.1:60830
User GRAPHITE\user has authenticated.
&gt; Hello
</code></pre>
<p class="TX">Now, if you press <small>ENTER</small> again in the client without typing a message, both the client and the server should exit without any errors.</p>
<p class="TX"><span aria-label=" Page 454. " epub:type="pagebreak" id="pg_454" role="doc-pagebreak"></span>You can play with the scripts to make them do different things. For example, if you want to use a different TCP port, you can specify the <samp class="SANS_TheSansMonoCd_W5Regular_11">Port</samp> parameter to the scripts. The following shows how to set the port to <samp class="SANS_TheSansMonoCd_W5Regular_11">11111</samp> for the server; the change would be the same for the client:</p>
<pre><code>PS&gt; <b>.\network_protocol_server.ps1 -Port 11111</b>
</code></pre>
<p class="TX">As a final note, let’s revisit the use of the <samp class="SANS_TheSansMonoCd_W5Regular_11">Write-Verbose</samp> command in the common module code. As you may have noticed when using the client and the server, the verbose output isn’t printed to the console. If you want to see the output, you can enable this by changing the value of the <samp class="SANS_TheSansMonoCd_W5Regular_11">$VerbosePreference</samp> global variable. This variable normally has the value of <samp class="SANS_TheSansMonoCd_W5Regular_11">SilentlyContinue</samp>, which ignores verbose output. If you change it to <samp class="SANS_TheSansMonoCd_W5Regular_11">Continue</samp>, the verbose output will appear. <a href="chapter13.xhtml#Lis13-22">Listing 13-22</a> changes this value before connecting the client.</p>
<span id="Lis13-22"></span><pre><code>PS&gt; <b>$VerbosePreference = "Continue"</b>
PS&gt; <b>.\network_protocol_client.ps1</b>
VERBOSE: Importing function 'Get-SocketClient'.
VERBOSE: Importing function 'Receive-Message'.
VERBOSE: Importing function 'Receive-TextMessage'.
VERBOSE: Importing function 'Send-Message'.
VERBOSE: Importing function 'Send-TextMessage'.
Connected to server 127.0.0.1:6543
VERBOSE: Sending Message
VERBOSE:           00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F  - 0123456789ABCDEF
-----------------------------------------------------------------------------
00000000: 4E 54 4C 4D 53 53 50 00 01 00 00 00 B7 B2 08 E2  - NTLMSSP.........
00000010: 09 00 09 00 2D 00 00 00 05 00 05 00 28 00 00 00  - ....-.......(...
<var>--snip--</var>
</code></pre>
<p class="ListingCaption"><span class="Futura_Std_Book_Oblique_I_11">Listing 13-22: Enabling verbose output for the client</span></p>
<p class="TX">You can observe that we now see part of the first NTLM authentication token being sent to the server. When you send messages back and forth between the client and server, you can verify that the data is encrypted by looking at the hex output.</p>
<p class="TX">This worked example was quite lengthy, but it should have given you a better idea of how network authentication can work in a real network scenario.</p>
</section>
</section>
<section aria-labelledby="sec25" epub:type="division">
<h3 class="H1" id="sec25"><span id="h1-101"></span><samp class="SANS_Futura_Std_Bold_B_11">Wrapping Up</samp></h3>
<p class="TNI1">This chapter described the NTLM authentication protocol and provided scripts to demonstrate its authentication process. We looked at negotiating authentication tokens, and using the <samp class="SANS_TheSansMonoCd_W5Regular_11">Format-LsaAuthToken</samp> PowerShell command to display the protocol state.</p>
<p class="TX">I also showed you how to derive some of the cryptographic values generated by the NTLM protocol using PowerShell. This included the final NT response value, which proves the knowledge of the user’s password, and the <span aria-label=" Page 455. " epub:type="pagebreak" id="pg_455" role="doc-pagebreak"></span>message integrity code, which protects the NTLM authentication tokens from tampering.</p>
<p class="TX">To describe the risks associated with NTLM authentication, we covered NTLM relay attacks and a few ways in which Windows tries to combat them, such as active server challenge records and channel binding. We also covered using the authentication context to generate signatures and encrypt messages.</p>
<p class="TX">Now that you better understand network authentication and the APIs used to generate authentication tokens, the next chapter focuses on the more complicated Kerberos authentication protocol.</p>
</section>
</section>
</div></body>
</html>