["```\n$ `cat /proc/1/status`\nName:   init                            *Name of command run by this process*\nState:  S (sleeping)                    *State of this process*\nTgid:   1                               *Thread group ID (traditional PID, getpid())*\nPid:    1                               *Actually, thread ID (gettid())*\nPPid:   0                               *Parent process ID*\nTracerPid:      0                       *PID of tracing process (0 if not traced)*\nUid:    0       0       0       0       *Real, effective, saved set, and FS UIDs*\nGid:    0       0       0       0       *Real, effective, saved set, and FS GIDs*\nFDSize: 256\n                             *# of file descriptor slots currently allocated*\nGroups:                                 *Supplementary group IDs*\nVmPeak:      852 kB                     *Peak virtual memory size*\nVmSize:      724 kB                     *Current virtual memory size*\nVmLck:         0 kB                     *Locked memory*\nVmHWM:       288 kB                     *Peak resident set size*\nVmRSS:       288 kB                     *Current resident set size*\nVmData:      148 kB                     *Data segment size*\nVmStk:        88 kB                     *Stack size*\nVmExe:       484 kB                     *Text (executable code) size*\nVmLib:         0 kB                     *Shared library code size*\nVmPTE:        12 kB                     *Size of page table (since 2.6.10)*\nThreads:        1                       *# of threads in this thread's thread group*\nSigQ:   0/3067                          *Current/max. queued signals (since 2.6.12)*\nSigPnd: 0000000000000000                *Signals pending for thread*\nShdPnd: 0000000000000000                *Signals pending for process (since 2.6)*\nSigBlk: 0000000000000000                *Blocked signals*\nSigIgn: fffffffe5770d8fc                *Ignored signals*\nSigCgt: 00000000280b2603                *Caught signals*\nCapInh: 0000000000000000                *Inheritable capabilities*\nCapPrm: 00000000ffffffff                *Permitted capabilities*\nCapEff: 00000000fffffeff                *Effective capabilities*\nCapBnd: 00000000ffffffff                *Capability bounding set (since 2.6.26)*\nCpus_allowed:   1                       *CPUs allowed, mask (since 2.6.24)*\nCpus_allowed_list:      0               *Same as above, list format (since 2.6.26)*\nMems_allowed:   1                       *Memory nodes allowed, mask (since 2.6.24)*\nMems_allowed_list:      0               *Same as above, list format (since 2.6.26)*\nvoluntary_ctxt_switches:     6998       *Voluntary context switches (since 2.6.23)*\nnonvoluntary_ctxt_switches:  107        *Involuntary context switches (since 2.6.23)*\nStack usage:    8 kB                    *Stack usage high-water mark (since 2.6.32)*\n```", "```\n# `echo 100000 > /proc/sys/kernel/pid_max`\n# `cat /proc/sys/kernel/pid_max`\n100000\n```", "```\n$ `su`                            *Privilege is required to update* pid_max *file*\nPassword:\n# `./procfs_pidmax 10000`\nOld value: 32768\n/proc/sys/kernel/pid_max now contains 10000\n```", "```\n`sysinfo/procfs_pidmax.c`\n#include <fcntl.h>\n#include \"tlpi_hdr.h\"\n\n#define MAX_LINE 100\n\nint\nmain(int argc, char *argv[])\n{\n    int fd;\n    char line[MAX_LINE];\n    ssize_t n;\n\n    fd = open(\"/proc/sys/kernel/pid_max\", (argc > 1) ? O_RDWR : O_RDONLY);\n    if (fd == -1)\n        errExit(\"open\");\n\n    n = read(fd, line, MAX_LINE);\n    if (n == -1)\n        errExit(\"read\");\n\n    if (argc > 1)\n        printf(\"Old value: \");\n    printf(\"%.*s\", (int) n, line);\n\n    if (argc > 1) {\n        if (write(fd, argv[1], strlen(argv[1])) != strlen(argv[1]))\n            fatal(\"write() failed\");\n\n        system(\"echo /proc/sys/kernel/pid_max now contains \"\n               \"`cat /proc/sys/kernel/pid_max`\");\n    }\n\n    exit(EXIT_SUCCESS);\n}\n     `sysinfo/procfs_pidmax.c`\n```", "```\n#include <sys/utsname.h>\n\nint `uname`(struct utsname **utsbuf*);\n```", "```\n#define _UTSNAME_LENGTH 65\n\nstruct utsname {\n    char sysname[_UTSNAME_LENGTH];      /* Implementation name */\n    char nodename[_UTSNAME_LENGTH];     /* Node name on network */\n    char release[_UTSNAME_LENGTH];      /* Implementation release level */\n    char version[_UTSNAME_LENGTH];      /* Release version level */\n    char machine[_UTSNAME_LENGTH];      /* Hardware on which system\n                                           is running */\n#ifdef _GNU_SOURCE                      /* Following is Linux-specific */\n    char domainname[_UTSNAME_LENGTH];   /* NIS domain name of host */\n#endif\n};\n```", "```\n$ `./t_uname`\nNode name:   tekapo\nSystem name: Linux\nRelease:     2.6.30-default\nVersion:     #3 SMP Fri Jul 17 10:25:00 CEST 2009\nMachine:     i686\nDomain name:\n```", "```\n`sysinfo/t_uname.c`\n#define _GNU_SOURCE\n#include <sys/utsname.h>\n#include \"tlpi_hdr.h\"\n\nint\nmain(int argc, char *argv[])\n{\n    struct utsname uts;\n\n    if (uname(&uts) == -1)\n        errExit(\"uname\");\n\n    printf(\"Node name:   %s\\n\", uts.nodename);\n    printf(\"System name: %s\\n\", uts.sysname);\n    printf(\"Release:     %s\\n\", uts.release);\n    printf(\"Version:     %s\\n\", uts.version);\n    printf(\"Machine:     %s\\n\", uts.machine);\n#ifdef _GNU_SOURCE\n    printf(\"Domain name: %s\\n\", uts.domainname);\n#endif\n    exit(EXIT_SUCCESS);\n}\n      `sysinfo/t_uname.c`\n```"]