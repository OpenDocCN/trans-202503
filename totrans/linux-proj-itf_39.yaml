- en: Chapter 39. Capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This chapter describes the Linux capabilities scheme, which divides the traditional
    all-or-nothing UNIX privilege scheme into individual capabilities that can be
    independently enabled or disabled. Using capabilities allows a program to perform
    some privileged operations, while preventing it from performing others.
  prefs: []
  type: TYPE_NORMAL
- en: Rationale for Capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The traditional UNIX privilege scheme divides processes into two categories:
    those whose effective user ID is 0 (superuser), which bypass all privilege checks,
    and all other processes, which are subject to privilege checking according to
    their user and group IDs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The coarse granularity of this scheme is a problem. If we want to allow a process
    to perform some operation that is permitted only to the superuser—for example,
    changing the system time—then we must run that process with an effective user
    ID of 0\. (If an unprivileged user needs to perform such operations, this is typically
    implemented using a set-user-ID-*root* program.) However, this grants the process
    privileges to perform a host of other actions as well—for example, bypassing all
    permission checks when accessing files—thus opening the door for a range of security
    breaches if the program behaves in unexpected ways (which may be the consequence
    of unforeseen circumstances, or because of deliberate manipulation by a malicious
    user). The traditional way of dealing with this problem was outlined in [Chapter 38](ch38.html
    "Chapter 38. Writing Secure Privileged Programs"): we drop effective privileges
    (i.e., change from an effective user ID of 0, while maintaining 0 in the saved
    set-user-ID) and temporarily reacquire them only when needed.'
  prefs: []
  type: TYPE_NORMAL
- en: The Linux capability scheme refines the handling of this problem. Rather than
    using a single privilege (i.e., effective user ID of 0) when performing security
    checks in the kernel, the superuser privilege is divided into distinct units,
    called *capabilities*. Each privileged operation is associated with a particular
    capability, and a process can perform that operation only if it has the corresponding
    capability (regardless of its effective user ID). Put another way, everywhere
    in this book that we talk about a privileged process on Linux, what we really
    mean is a process that has the relevant capability for performing a particular
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, the Linux capability scheme is invisible to us. The reason
    for this is that when an application that is unaware of capabilities assumes an
    effective user ID of 0, the kernel grants that process the complete range of capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux capabilities implementation is based on the POSIX 1003.1e draft standard
    ([http://wt.tuxomania.net/publications/posix.1e/](http://wt.tuxomania.net/publications/posix.1e/)).
    This standardization effort foundered in the late 1990s before it was completed,
    but various capabilities implementations are nevertheless based on the draft standard.
    (Some of the capabilities listed in [Table 39-1](ch39.html#operations_permitted_by_each_linux_capab
    "Table 39-1. Operations permitted by each Linux capability") are defined in the
    POSIX.1e draft, but many are Linux extensions.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Capability schemes are provided in a few other UNIX implementations, such as
    in Sun’s Solaris 10 and earlier Trusted Solaris releases, SGI’s Trusted Irix,
    and as part of the TrustedBSD project for FreeBSD ([Watson, 2000]). Similar schemes
    exist in some other operating systems; for example, the privilege mechanism in
    Digital’s VMS system.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux Capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 39-1](ch39.html#operations_permitted_by_each_linux_capab "Table 39-1. Operations
    permitted by each Linux capability") lists the Linux capabilities and provides
    an abbreviated (and incomplete) guide to the operations to which they apply.'
  prefs: []
  type: TYPE_NORMAL
- en: Process and File Capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each process has three associated capability sets—termed *permitted*, *effective*,
    and *inheritable*—that can contain zero or more of the capabilities listed in
    [Table 39-1](ch39.html#operations_permitted_by_each_linux_capab "Table 39-1. Operations
    permitted by each Linux capability"). Each file can likewise have three associated
    capability sets, with the same names. (For reasons that will become evident, the
    file effective capability set is really just a single bit that is either enabled
    or disabled.) We go into the details of each of these capability sets in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Process Capabilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For each process, the kernel maintains three capability sets (implemented as
    bit masks) in which zero or more of the capabilities specified in [Table 39-1](ch39.html#operations_permitted_by_each_linux_capab
    "Table 39-1. Operations permitted by each Linux capability") are enabled. The
    three sets are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Permitted*: These are the capabilities that a process *may* employ. The permitted
    set is a limiting superset for the capabilities that can be added to the effective
    and inheritable sets. If a process drops a capability from its permitted set,
    it can never reacquire that capability (unless it execs a program that once more
    confers the capability).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Effective*: These are the capabilities used by the kernel to perform privilege
    checking for the process. As long as it maintains a capability in its permitted
    set, a process can temporarily disable the capability by dropping it from the
    effective set, and then later restoring it to that set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Inheritable*: These are capabilities that may be carried over to the permitted
    set when a program is execed by this process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can view hexadecimal representations of the three capability sets for any
    process in the three fields `CapInh`, `CapPrm`, and `CapEff` in the Linux-specific
    `/proc/`*PID*`/status` file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *getpcap* program (part of the *libcap* package described in [Changing Process
    Capabilities Programmatically](ch39.html#changing_process_capabilities_programmat
    "Changing Process Capabilities Programmatically")) can be used to display the
    capabilities of a process in an easier-to-read format.
  prefs: []
  type: TYPE_NORMAL
- en: A child process produced via *fork()* inherits copies of its parent’s capability
    sets. We describe the treatment of capability sets during an *exec()* in Section
    39.5.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In reality, capabilities are a per-thread attribute that can be adjusted independently
    for each of the threads in a process. The capabilities of a specific thread within
    a multithreaded process are shown in the `/proc/`*PID*`/task/`*TID*`/status` file.
    The `/proc/`*PID*`/status` file shows the capabilities of the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: Before kernel 2.6.25, Linux represented capability sets using 32 bits. The addition
    of further capabilities in kernel 2.6.25 required a move to 64-bit sets.
  prefs: []
  type: TYPE_NORMAL
- en: File Capabilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If a file has associated capability sets, then these sets are used to determine
    the capabilities that are given to a process if it execs that file. There are
    three file capability sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Permitted*: This is a set of capabilities that may be added to the process’s
    permitted set during an *exec()*, regardless of the process’s existing capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Effective*: This is just a single bit. If it is enabled, then, during an *exec()*,
    the capabilities that are enabled in the process’s new permitted set are also
    enabled in the process’s new effective set. If the file effective bit is disabled,
    then, after an *exec()*, the process’s new effective set is initially empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Inheritable*: This set is masked against the process’s inheritable set to
    determine a set of capabilities that are to be enabled in the process’s permitted
    set after an *exec()*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Transformation of Process Capabilities During *exec()*](ch39.html#transformation_of_process_capabilities_d
    "Transformation of Process Capabilities During exec()") provides details of how
    file capabilities are used during an *exec()*.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The permitted and inheritable file capabilities were formerly known as *forced*
    and *allowed*. Those terms are now obsolete, but they are still informative. The
    permitted file capabilities are the ones that are *forced* into the process’s
    permitted set during an *exec()*, regardless of the process’s existing capabilities.
    The inheritable file capabilities are the ones that the file *allows* into the
    process’s permitted set during an *exec()*, if those capabilities are also enabled
    in the process’s inheritable capability set.
  prefs: []
  type: TYPE_NORMAL
- en: The capabilities associated with a file are stored in a *security* extended
    attribute ([Overview](ch16.html#overview-id1 "Overview")) named *security.capability*.
    The `CAP_SETFCAP` capability is required to update this extended attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Table 39-1. Operations permitted by each Linux capability
  prefs: []
  type: TYPE_NORMAL
- en: '| Capability | Permits process to |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_AUDIT_CONTROL` | (Since Linux 2.6.11) Enable and disable kernel audit
    logging; change filtering rules for auditing; retrieve auditing status and filtering
    rules |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_AUDIT_WRITE` | (Since Linux 2.6.11) Write records to the kernel auditing
    log |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_CHOWN` | Change file’s user ID (owner) or change file’s group ID to
    a group of which process is not a member (*chown()*) |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_DAC_OVERRIDE` | Bypass file read, write, and execute permission checks
    (DAC is an abbreviation for discretionary access control); read contents of `cwd`,
    `exe`, and `root` symbolic links in `/proc/`*PID* |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_DAC_READ_SEARCH` | Bypass file read permission checks and directory
    read and execute (search) permission checks |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_FOWNER` | Generally ignore permission checks on operations that normally
    require the process’s file-system user ID to match the file’s user ID *(chmod()*,
    *utime());* set i-node flags on arbitrary files; set and modify ACLs on arbitrary
    files; ignore effect of directory sticky bit when deleting files *(unlink()*,
    *rmdir()*, *rename());* specify `O_NOATIME` flag for arbitrary files in *open()*
    and *fcntl(F_SETFL)* |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_FSETID` | Modify a file without having the kernel turn off set-user-ID
    and set-group-ID bits (*write()*, *truncate()*); enable set-group-ID bit for a
    file whose group ID doesn’t match the process’s file-system group ID or supplementary
    group IDs (*chmod()*) |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_IPC_LOCK` | Override memory-locking restrictions (*mlock()*, *mlockall()*,
    *shmctl(SHM_LOCK)*, *shmctl(SHM_UNLOCK)*); employ *shmget()* `SHM_HUGETLB` flag
    and *mmap()* `MAP_HUGETLB` flag. |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_IPC_OWNER` | Bypass permission checks for operations on System V IPC
    objects |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_KILL` | Bypass permission checks for sending signals (*kill()*, *sigqueue()*)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_LEASE` | (Since Linux 2.4) Establish leases on arbitrary files (*fcntl(F_SETLEASE)*)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_LINUX_IMMUTABLE` | Set append and immutable i-node flags |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_MAC_ADMIN` | (Since Linux 2.6.25) Configure or make state changes for
    mandatory access control (MAC) (implemented by some Linux security modules) |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_MAC_OVERRIDE` | (Since Linux 2.6.25) Override MAC (implemented by some
    Linux security modules) |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_MKNOD` | (Since Linux 2.4) Use *mknod()* to create devices |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_NET_ADMIN` | Perform various network-related operations (e.g., setting
    privileged socket options, enabling multicasting, configuring network interfaces,
    and modifying routing tables) |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_NET_BIND_SERVICE` | Bind to privileged socket ports |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_NET_BROADCAST` | (Unused) Perform socket broadcasts and listen to multicasts
    |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_NET_RAW` | Use raw and packet sockets |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_SETGID` | Make arbitrary changes to process group IDs (*setgid()*, *setegid()*,
    *setregid()*, *setresgid()*, *setfsgid()*, *setgroups()*, *initgroups()*); forge
    group ID when passing credentials via UNIX domain socket (`SCM_CREDENTIALS`) |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_SETFCAP` | (Since Linux 2.6.24) Set file capabilities |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_SETPCAP` | If file capabilities are not supported, grant and remove
    capabilities in the process’s permitted set to or from any other process (including
    self); if file capabilities are supported, add any capability in the process’s
    capability bounding set to its inheritable set, drop capabilities from the bounding
    set, and change *securebits* flags |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_SETUID` | Make arbitrary changes to process user IDs (*setuid()*, *seteuid()*,
    *setreuid()*, *setresuid()*, *setfsuid()*); forge user ID when passing credentials
    via UNIX domain socket (`SCM_CREDENTIALS`) |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_SYS_ADMIN` | Exceed `/proc/sys/fs/file-max` limit in system calls that
    open files (e.g., *open()*, *shm_open()*, *pipe()*, *socket()*, *accept()*, *exec()*,
    *acct()*, *epoll_create())*; perform various system administration operations,
    including *quotactl()* (control disk quotas), *mount()* and *umount()*, *swapon()*
    and *swapoff()*, *pivot_root()*, *sethostname()* and *setdomainname()*; perform
    various *syslog(2)* operations; override `RLIMIT_NPROC` resource limit (*fork()*);
    call *lookup_dcookie()*; set *trusted* and *security* extended attributes; perform
    `IPC_SET` and `IPC_RMID` operations on arbitrary System V IPC objects; forge process
    ID when passing credentials via UNIX domain socket (`SCM_CREDENTIALS`); use *ioprio_set()*
    to assign `IOPRIO_CLASS_RT` scheduling class; employ *TIOCCONS ioctl();* employ
    `CLONE_NEWNS` flag with *clone()* and *unshare()*; perform `KEYCTL_CHOWN` and
    `KEYCTL_SETPERM` *keyctl()* operations; administer *random(4)* device; various
    device-specific operations |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_SYS_BOOT` | Use *reboot()* to reboot the system; call *kexec_load()*
    |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_SYS_CHROOT` | Use *chroot()* to set process root directory |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_SYS_MODULE` | Load and unload kernel modules (*init_module()*, *delete_module()*,
    *create_module()*) |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_SYS_NICE` | Raise nice value *(nice()*, *setpriority());* change nice
    value for arbitrary processes (*setpriority()*); set `SCHED_RR` and `SCHED_FIFO`
    realtime scheduling policies for calling process; reset `SCHED_RESET_ON_FORK`
    flag; set scheduling policies and priorities for arbitrary processes (*sched_setscheduler()*,
    *sched_setparam()*); set I/O scheduling class and priority for arbitrary processes
    (*ioprio_set()*); set CPU affinity for arbitrary processes (*sched_setaffinity()*);
    use *migrate_pages()* to migrate arbitrary processes and allow processes to be
    migrated to arbitrary nodes; apply *move_pages()* to arbitrary processes; use
    `MPOL_MF_MOVE_ALL` flag with *mbind()* and *move_pages()* |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_SYS_PACCT` | Use *acct()* to enable or disable process accounting |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_SYS_PTRACE` | Trace arbitrary processes using *ptrace()*; access `/proc/`*PID*`/environ`
    for arbitrary processes; apply *get_robust_list()* to arbitrary processes |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_SYS_RAWIO` | Perform operations on I/O ports using *iopl()* and *ioperm()*;
    access `/proc/kcore`; open `/dev/mem` and `/dev/kmem` |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_SYS_RESOURCE` | Use reserved space on file systems; make *ioctl()* calls
    controlling *ext3* journaling; override disk quota limits; increase hard resource
    limits (*setrlimit()*); override `RLIMIT_NPROC` resource limit (*fork()*); raise
    *msg_qbytes* limit for a System V message queue above limit in `/proc/sys/kernel/msgmnb;`
    bypass various POSIX message queue limits defined by files under `/proc/sys/fs/mqueue`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_SYS_TIME` | Modify system clock (*settimeofday()*, *stime()*, *adjtime()*,
    *adjtimex()*); set hardware clock |'
  prefs: []
  type: TYPE_TB
- en: '| `CAP_SYS_TTY_CONFIG` | Perform virtual hangup of terminal or pseudoterminal
    using *vhangup()* |'
  prefs: []
  type: TYPE_TB
- en: Purpose of the Process Permitted and Effective Capability Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *process permitted* capability set defines the capabilities that a process
    *may* employ. The *process effective* capability set defines the capabilities
    that are currently in effect for the process—that is, the set of capabilities
    that the kernel uses when checking whether the process has the necessary privilege
    to perform a particular operation.
  prefs: []
  type: TYPE_NORMAL
- en: The permitted capability set imposes an upper bound on the effective set. A
    process can *raise* a capability in its effective set only if that capability
    is in the permitted set. (The terms *add* to and *set* are sometimes used synonymously
    with *raise*. The converse operation is *drop*, or synonymously, *remove* or *clear*.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The relationship between the effective and permitted capability sets is analogous
    to that between the effective user ID and the saved set-user-ID for a set-user-ID-*root*
    program. Dropping a capability from the effective set is analogous to temporarily
    dropping an effective user ID of 0, while maintaining 0 in the saved set-user-ID.
    Dropping a capability from both the effective and permitted capability sets is
    analogous to permanently dropping superuser privileges by setting both the effective
    user ID and the saved set-user ID to nonzero values.
  prefs: []
  type: TYPE_NORMAL
- en: Purpose of the File Permitted and Effective Capability Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *file permitted* capability set provides a mechanism by which an executable
    file can give capabilities to a process. It specifies a group of capabilities
    that are to be assigned to the process’s permitted capability set during an *exec()*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *file effective* capability set is a single flag (bit) that is either enabled
    or disabled. To understand why this set consists of just a single bit, we need
    to consider the two cases that occur when a program is execed:'
  prefs: []
  type: TYPE_NORMAL
- en: The program may be *capability-dumb*, meaning that it doesn’t know about capabilities
    (i.e., it is designed as a traditional set-user-ID-*root* program). Such a program
    won’t know that it needs to raise capabilities in its effective set in order to
    be able to perform privileged operations. For such programs, an *exec()* should
    have the effect that all of the process’s new permitted capabilities are automatically
    also assigned to its effective set. This result is achieved by enabling the file
    effective bit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program may be *capability-aware*, meaning that it has been designed with
    the capabilities framework in mind, and it will make the appropriate system calls
    (discussed later) to raise and drop capabilities in its effective set. For such
    programs, least-privilege considerations mean that, after an *exec()*, all capabilities
    should initially be disabled in the process’s effective capability set. This result
    is achieved by disabling the file effective capability bit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Purpose of the Process and File Inheritable Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'At first glance, the use of permitted and effective sets for processes and
    files might seem a sufficient framework for a capabilities system. However, there
    are some situations where they do not suffice. For example, what if a process
    performing an *exec()* wants to preserve some of its current capabilities across
    the *exec()*? It might appear that the capabilities implementation could provide
    this feature simply by preserving the process’s permitted capabilities across
    an *exec()*. However, this approach would not handle the following cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Performing the *exec()* might require certain privileges (e.g., `CAP_DAC_OVERRIDE`)
    that we don’t want to preserve across the *exec()*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose that we explicitly dropped some permitted capabilities that we didn’t
    want to preserve across the *exec()*, but then the *exec()* failed. In this case,
    the program might need some of the permitted capabilities that it has already
    (irrevocably) dropped.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For these reasons, a process’s permitted capabilities are not preserved across
    an *exec()*. Instead, another capability set is introduced: the *inheritable set*.
    The inheritable set provides a mechanism by which a process can preserve some
    of its capabilities across an *exec()*.'
  prefs: []
  type: TYPE_NORMAL
- en: The *process inheritable* capability set specifies a group of capabilities that
    may be assigned to the process’s permitted capability set during an *exec()*.
    The corresponding *file inheritable* set is masked (ANDed) against the process
    inherited capability set to determine the capabilities that are actually added
    to the process’s permitted capability set during an *exec()*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a further, philosophical reason for not simply preserving the process
    permitted capability set across an *exec()*. The idea of the capabilities system
    is that all privileges given to a process are granted or controlled by the file
    that the process execs. Although the process inheritable set specifies capabilities
    that are passed across an *exec()*, these capabilities are masked by the file
    inheritable set.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning and Viewing File Capabilities from the Shell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The *setcap(8)* and *getcap(8)* commands, contained in the *libcap* package
    described in [Changing Process Capabilities Programmatically](ch39.html#changing_process_capabilities_programmat
    "Changing Process Capabilities Programmatically"), can be used to manipulate file
    capabilities sets. We demonstrate the use of these commands with a short example
    using the standard *date(1)* program. (This program is an example of a capability-dumb
    application according to the definition in [Purpose of the File Permitted and
    Effective Capability Sets](ch39.html#purpose_of_the_file_permitted_and_effect
    "Purpose of the File Permitted and Effective Capability Sets").) When run with
    privilege, *date(1)* can be used to change the system time. The *date* program
    is not set-user-ID-*root*, so normally the only way to run it with privilege is
    to become the superuser.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by displaying the current system time, and then try to change the
    time as an unprivileged user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Above, we see that the *date* command failed to change the system time, but
    nevertheless displayed its argument in the standard format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we become the superuser, which allows us to successfully change the system
    time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We now make a copy of the *date* program and assign it the capability that
    it needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The *setcap* command shown above assigns the *CAP_SYS_TIME* capability to the
    permitted (*p*) and effective (*e*) capability sets of the executable file. We
    then used the *getcap* command to verify the capabilities assigned to the file.
    (The syntax used by *setcap* and *getcap* for representing capability sets is
    described in the *cap_from_text(3)* manual page provided in the *libcap* package.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The file capabilities of our copy of the *date* program allow the program to
    be used by unprivileged users to set the system time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Modern Capabilities Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A complete implementation of capabilities requires the following:'
  prefs: []
  type: TYPE_NORMAL
- en: For each privileged operation, the kernel should check whether the process has
    the relevant capability, rather than checking for an effective (or file system)
    user ID of 0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel must provide system calls allowing a process’s capabilities to be
    retrieved and modified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The kernel must support the notion of attaching capabilities to an executable
    file, so that the process gains the associated capabilities when that file is
    execed. This is analogous to the set-user-ID bit, but allows the independent specification
    of all capabilities on the executable file. In addition, the system must provide
    a set of programming interfaces and commands for setting and viewing the capabilities
    attached to an executable file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Up to and including kernel 2.6.23, Linux met only the first two of these requirements.
    Since kernel 2.6.24, it is possible to attach capabilities to a file. Various
    other features were added in kernels 2.6.25 and 2.6.26 in order to complete the
    capabilities implementation.
  prefs: []
  type: TYPE_NORMAL
- en: For most of our discussion of capabilities, we’ll focus on the modern implementation.
    In [Older Kernels and Systems Without File Capabilities](ch39.html#older_kernels_and_systems_without_file_c
    "Older Kernels and Systems Without File Capabilities"), we consider how the implementation
    differed before file capabilities were introduced. Furthermore, file capabilities
    are an optional kernel component in modern kernels, but for the main part of our
    discussion, we’ll assume that this component is enabled. Later, we’ll describe
    the differences that occur if file capabilities are not enabled. (In several respects,
    the behavior is similar to that of Linux in kernels before 2.6.24, where file
    capabilities were not implemented.)
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we go into more detail on the Linux capabilities
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Transformation of Process Capabilities During *exec()*
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'During an *exec()*, the kernel sets new capabilities for the process based
    on the process’s current capabilities and the capability sets of the file being
    executed. The kernel calculates the new capabilities of the process using the
    following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the above rules, *P* denotes the value of a capability set prior to the *exec()*,
    *P’* denotes the value of a capability set after the *exec()*, and *F* denotes
    a file capability set. The identifier *cap_bset* denotes the value of the capability
    bounding set. Note that *exec()* leaves the process inheritable capability set
    unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: Capability Bounding Set
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The capability bounding set is a security mechanism that is used to limit the
    capabilities that a process can gain during an *exec()*. This set is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: During an *exec()*, the capability bounding set is ANDed with the file permitted
    capabilities to determine the permitted capabilities that are to be granted to
    the new program. In other words, an executable file’s permitted capability set
    can’t grant a permitted capability to a process if the capability is not in the
    bounding set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The capability bounding set is a limiting superset for the capabilities that
    can be added to the process’s inheritable set. This means that, unless the capability
    is in the bounding set, a process can’t add one of its permitted capabilities
    to its inheritable set and then—via the first of the capability transformation
    rules described above—have that capability preserved in its permitted set when
    it execs a file that has the capability in its inheritable set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The capability bounding set is a per-process attribute that is inherited by
    a child created via *fork()*, and preserved across an *exec()*. On a kernel that
    supports file capabilities, *init* (the ancestor of all processes) starts with
    a capability bounding set that contains all capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: If a process has the `CAP_SETPCAP` capability, then it can (irreversibly) remove
    capabilities from its bounding set using the *prctl()* `PR_CAPBSET_DROP` operation.
    (Dropping a capability from the bounding set doesn’t affect the process permitted,
    effective, and inheritable capability sets.) A process can determine if a capability
    is in its bounding set using the *prctl()* `PR_CAPBSET_READ` operation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More precisely, the capability bounding set is a per-thread attribute. Starting
    with Linux 2.6.26, this attribute is displayed as the `CapBnd` field in the Linux-specific
    `/proc/`*PID*`/task/`*TID*`/status` file. The `/proc/`*PID*`/status` file shows
    the bounding set of a process’s main thread.
  prefs: []
  type: TYPE_NORMAL
- en: Preserving *root* Semantics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to preserve the traditional semantics for the *root* user (i.e., *root*
    has all privileges) when executing a file, any capability sets associated with
    the file are ignored. Instead, for the purposes of the algorithm shown in [Transformation
    of Process Capabilities During *exec()*](ch39.html#transformation_of_process_capabilities_d
    "Transformation of Process Capabilities During exec()"), the file capability sets
    are notionally defined as follows during an *exec()*:'
  prefs: []
  type: TYPE_NORMAL
- en: If a set-user-ID-*root* program is being execed, or the real or effective user
    ID of the process calling *exec()* is 0, then the file inheritable and permitted
    sets are defined to be all ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a set-user-ID-*root* program is being execed, or the effective user ID of
    the process calling *exec()* is 0, then the file effective bit is defined to be
    set.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assuming that we are execing a set-user-ID-*root* program, these notional definitions
    of the file capability sets mean that the calculation of the process’s new permitted
    and effective capability sets in [Transformation of Process Capabilities During
    *exec()*](ch39.html#transformation_of_process_capabilities_d "Transformation of
    Process Capabilities During exec()") simplifies to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Effect on Process Capabilities of Changing User IDs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To preserve compatibility with the traditional meanings for transitions between
    0 and nonzero user IDs, the kernel does the following when changing process user
    IDs (using *setuid()*, and so on):'
  prefs: []
  type: TYPE_NORMAL
- en: If the real user ID, effective user ID, or saved set-user-ID previously had
    the value 0 and, as a result of the changes to the user IDs, all three of these
    IDs have a nonzero value, then the permitted and effective capability sets are
    cleared (i.e., all capabilities are permanently dropped).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the effective user ID is changed from 0 to a nonzero value, then the effective
    capability set is cleared (i.e., the effective capabilities are dropped, but those
    in the permitted set can be raised again).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the effective user ID is changed from a nonzero value to 0, then the permitted
    capability set is copied into the effective capability set (i.e., all permitted
    capabilities become effective).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the file-system user ID is changed from 0 to a nonzero value, then the following
    file-related capabilities are cleared from the effective capability set: `CAP_CHOWN`,
    `CAP_DAC_OVERRIDE`, `CAP_DAC_READ_SEARCH`, `CAP_FOWNER`, `CAP_FSETID`, `CAP_LINUX_IMMUTABLE`
    (since Linux 2.6.30), `CAP_MAC_OVERRIDE`, and `CAP_MKNOD` (since Linux 2.6.30).
    Conversely, if the file-system user ID is changed from a nonzero value to 0, then
    any of these capabilities that are enabled in the permitted set are enabled in
    the effective set. These manipulations are done to maintain the traditional semantics
    for manipulations of the Linux-specific file-system user ID.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Changing Process Capabilities Programmatically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A process can raise or drop capabilities from its capability sets using either
    the *capset()* system call or, preferably, the *libcap* API, which we describe
    below. Changes to process capabilities are subject to the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: If the process doesn’t have the `CAP_SETPCAP` capability in its effective set,
    then the new *inheritable* set must be a subset of the combination of the existing
    inheritable and permitted sets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new *inheritable* set must be a subset of the combination of the existing
    inheritable set and the capability bounding set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new *permitted* set must be a subset of the existing permitted set. In other
    words, a process can’t grant itself permitted capabilities that it doesn’t have.
    Put another way, a capability dropped from the permitted set can’t be reacquired.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new *effective* set is allowed to contain only capabilities that are also
    in the new permitted set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *libcap* API
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Up to this point, we have deliberately not shown the prototype of the *capset()*
    system call, or its counterpart *capget()*, which retrieves a process’s capabilities.
    This is because the use of these system calls should be avoided. Instead, the
    functions in the *libcap* library should be employed. These functions provide
    an interface that conforms with the withdrawn draft POSIX 1003.1e standard, along
    with some Linux extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reasons of space, we don’t describe the *libcap* API in detail. As an overview,
    we note that programs employing these functions typically carry out the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the *cap_get_proc()* function to retrieve a copy of the process’s current
    capability sets from the kernel and place it in a structure that the function
    allocates in user space. (Alternatively, we may use the *cap_init()* function
    to create a new, empty capability set structure.) In the *libcap* API, the *cap_t*
    data type is a pointer used to refer to such structures.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the *cap_set_flag()* function to update the user-space structure to raise
    (`CAP_SET`) and drop (`CAP_CLEAR`) capabilities from the permitted, effective,
    and inheritable sets stored in the user-space structure retrieved in the previous
    step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the *cap_set_proc()* function to pass the user-space structure back to the
    kernel in order to change the process’s capabilities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the *cap_free()* function to free the structure that was allocated by the
    *libcap* API in the first step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing, work is in progress on *libcap-ng*, a new, improved
    capabilities library API. Details can be found at [http://freshmeat.net/projects/libcap-ng](http://freshmeat.net/projects/libcap-ng).
  prefs: []
  type: TYPE_NORMAL
- en: Example program
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In [Example 8-2](ch08.html#authenticating_a_user_against_the_shadow "Example 8-2. Authenticating
    a user against the shadow password file"), in [Summary](ch08.html#summary-id7
    "Summary"), we presented a program that authenticates a username plus password
    against the standard password database. We noted that the program requires privilege
    in order to read the shadow password file, which is protected to prevent reading
    by users other than *root* or members of the *shadow* group. The traditional way
    of providing this program with the privileges that it requires would be to run
    it under a *root* login or to make it a set-user-ID-*root* program. We now present
    a modified version of this program that employs capabilities and the *libcap*
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to read the shadow password file as a normal user, we need to bypass
    the standard file permission checks. Scanning the capabilities listed in [Table 39-1](ch39.html#operations_permitted_by_each_linux_capab
    "Table 39-1. Operations permitted by each Linux capability"), we see that the
    appropriate capability is `CAP_DAC_READ_SEARCH`. Our modified version of the password
    authentication program is shown in [Example 39-1](ch39.html#a_capability-aware_program_that_authenti
    "Example 39-1. A capability-aware program that authenticates a user"). This program
    uses the *libcap* API to raise `CAP_DAC_READ_SEARCH` in its effective capability
    set just before accessing the shadow password file, and then drops the capability
    again immediately after this access. In order for an unprivileged user to employ
    the program, we must set this capability in the file permitted capability set,
    as shown in the following shell session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Example 39-1. A capability-aware program that authenticates a user
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Creating Capabilities-Only Environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding pages, we have described various ways in which a process with
    the user ID 0 (*root*) is treated specially with respect to capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: When a process with one or more user IDs that equal 0 sets all of its user IDs
    to nonzero values, its permitted and effective capability sets are cleared. (See
    Section 39.6.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a process with an effective user ID of 0 changes that user ID to a nonzero
    value, it loses its effective capabilities. When the reverse change is made, the
    permitted capability set is copied to the effective set. A similar procedure is
    followed for a subset of capabilities when the process’s file-system user ID is
    switched between 0 and nonzero values. (See Section 39.6.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a process with real or effective user ID of *root* execs a program, or any
    process execs a set-user-ID-*root* program, then the file inheritable and permitted
    sets are notionally defined to be all ones. If the process’s effective user ID
    is 0, or it is execing a set-user-ID-*root* program, then the file effective bit
    is notionally defined to be 1\. (See [Preserving *root* Semantics](ch39.html#preserving_root_semantics
    "Preserving root Semantics").) In the usual cases (i.e., both the real and effective
    user ID are *root*, or a set-user-ID-*root* program is being execed), this means
    the process gets all capabilities in its permitted and effective sets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a fully capability-based system, the kernel would not need to perform any
    of these special treatments of *root*. There would be no set-user-ID-*root* programs,
    and file capabilities would be used to grant just the minimum capabilities that
    a program requires.
  prefs: []
  type: TYPE_NORMAL
- en: Since existing applications aren’t engineered to make use of the file-capabilities
    infrastructure, the kernel must maintain the traditional handling of processes
    with the user ID 0\. Nevertheless, we may want an application to run in a purely
    capability-based environment in which *root* gets none of the special treatments
    described above. Starting with kernel 2.6.26, and if file capabilities are enabled
    in the kernel, Linux provides the *securebits* mechanism, which controls a set
    of per-process flags that enable or disable each of the three special treatments
    for *root*. (To be precise, the *securebits* flags are actually a per-thread attribute.)
  prefs: []
  type: TYPE_NORMAL
- en: The *securebits* mechanism controls the flags shown in [Table 39-2](ch39.html#the_securebits_flags
    "Table 39-2. The securebits flags"). The flags exist as related pairs of a *base*
    flag and a corresponding *locked* flag. Each of the base flags controls one of
    the special treatments of *root* described above. Setting the corresponding locked
    flag is a one-time operation that prevents further changes to the associated base
    flag—once set, the locked flag can’t be unset.
  prefs: []
  type: TYPE_NORMAL
- en: Table 39-2. The *securebits* flags
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag | Meaning if set |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SECBIT_KEEP_CAPS` | Don’t drop permitted capabilities when a process with
    one or more 0 user IDs sets all of its user IDs to nonzero values. This flag has
    an effect only if `SECBIT_NO_SETUID_FIXUP` is not also set. This flag is cleared
    on an *exec()*. |'
  prefs: []
  type: TYPE_TB
- en: '| `SECBIT_NO_SETUID_FIXUP` | Don’t change capabilities when effective or file-system
    user IDs are switched between 0 and nonzero values. |'
  prefs: []
  type: TYPE_TB
- en: '| `SECBIT_NOROOT` | If a process with a real or effective user ID of 0 does
    an *exec()*, or it execs a set-user-ID-*root* program, don’t grant it capabilities
    (unless the executable has file capabilities). |'
  prefs: []
  type: TYPE_TB
- en: '| `SECBIT_KEEP_CAPS_LOCKED` | Lock `SECBIT_KEEP_CAPS`. |'
  prefs: []
  type: TYPE_TB
- en: '| `SECBIT_NO_SETUID_FIXUP_LOCKED` | Lock `SECBIT_NO_SETUID_FIXUP`. |'
  prefs: []
  type: TYPE_TB
- en: '| `SECBIT_NOROOT_LOCKED` | Lock `SECBIT_NOROOT`. |'
  prefs: []
  type: TYPE_TB
- en: The *securebits* flag settings are inherited in a child created by *fork()*.
    All of the flag settings are preserved during *exec()*, except `SECBIT_KEEP_CAPS`,
    which is cleared for historical compatibility with the `PR_SET_KEEPCAPS` setting,
    described below.
  prefs: []
  type: TYPE_NORMAL
- en: 'A process can retrieve the *securebits* flags using the *prctl()* `PR_GET_SECUREBITS`
    operation. If a process has the `CAP_SETPCAP` capability, it can modify the *securebits*
    flags using the *prctl()* `PR_SET_SECUREBITS` operations. A purely capability-based
    application can irreversibly disable special treatment of *root* for the calling
    process and all of its descendants using the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After this call, the only way in which this process and its descendants can
    obtain capabilities is by executing programs that have file capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '`SECBIT_KEEP_CAPS` and the *prctl()* `PR_SET_KEEPCAPS` operation'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `SECBIT_KEEP_CAPS` flag prevents capabilities from being dropped when a
    process with one or more user IDs with the value 0 sets all of its user IDs to
    nonzero values. Roughly speaking, `SECBIT_KEEP_CAPS` provides half of the functionality
    provided by `SECBIT_NO_SETUID_FIXUP`. (As noted in [Table 39-2](ch39.html#the_securebits_flags
    "Table 39-2. The securebits flags"), `SECBIT_KEEP_CAPS` has an effect only if
    `SECBIT_NO_SETUID_FIXUP` is not set.) This flag exists to provide a *securebits*
    flag that mirrors the older *prctl()* `PR_SET_KEEPCAPS` operation, which controls
    the same attribute. (The one difference between the two mechanisms is that a process
    doesn’t need the `CAP_SETPCAP` capability to employ the *prctl()* `PR_SET_KEEPCAPS`
    operation.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Earlier, we noted that all of the *securebits* flags are preserved during an
    *exec()*, except `SECBIT_KEEP_CAPS`. The setting of the `SECBIT_KEEP_CAPS` bit
    was made the converse of the other *securebits* settings in order to maintain
    consistency with the treatment of the attribute set by the *prctl()* `PR_SET_KEEPCAPS`
    operation.
  prefs: []
  type: TYPE_NORMAL
- en: The *prctl()* `PR_SET_KEEPCAPS` operation is designed for use by set-user-ID-*root*
    programs running on older kernels that don’t support file capabilities. Such programs
    can still improve their security by programmatically dropping and raising capabilities
    as required (refer to [Older Kernels and Systems Without File Capabilities](ch39.html#older_kernels_and_systems_without_file_c
    "Older Kernels and Systems Without File Capabilities")).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, even if such a set-user-ID-*root* program drops all capabilities except
    those that it requires, it still maintains two important privileges: the ability
    to access files owned by *root* and the ability to regain capabilities by execing
    a program ([Preserving *root* Semantics](ch39.html#preserving_root_semantics "Preserving
    root Semantics")). The only way of permanently dropping these privileges is to
    set all of the process’s user IDs to nonzero values. But doing that normally results
    in the clearing of the permitted and effective capability sets (see the four points
    in [Effect on Process Capabilities of Changing User IDs](ch39.html#effect_on_process_capabilities_of_changi
    "Effect on Process Capabilities of Changing User IDs") concerning the effect of
    user ID changes on capabilities). This defeats the purpose, which is to permanently
    drop user ID 0, while maintaining some capabilities. To allow this possibility,
    the *prctl()* `PR_SET_KEEPCAPS` operation can be used to set the process attribute
    that prevents the permitted capability set from being cleared when all user IDs
    are changed to a nonzero value. (The process’s effective capability set is always
    cleared in this case, regardless of the setting of the “keep capabilities” attribute.)'
  prefs: []
  type: TYPE_NORMAL
- en: Discovering the Capabilities Required by a Program
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose we have a program that is unaware of capabilities and that is provided
    only in binary form, or we have a program whose source code is too large for us
    to easily read to determine which capabilities might be required to run it. If
    the program requires privileges, but shouldn’t be a set-user-ID-*root* program,
    then how can we determine the permitted capabilities to assign to the executable
    file with *setcap(8)*? There are two ways to answer this question:'
  prefs: []
  type: TYPE_NORMAL
- en: Use *strace(1)* ([Appendix A](apa.html "Appendix A. Tracing System Calls"))
    to see which system call fails with the error `EPERM`, the error used to indicate
    the lack of a required capability. By consulting the system call’s manual page
    or the kernel source code, we can then deduce what capability is required. This
    approach isn’t perfect, because an `EPERM` error can occasionally be generated
    for other reasons, some of which may have nothing to do with the capability requirements
    for the program. Furthermore, programs may legitimately make a system call that
    requires privilege, and then change their behavior after determining that they
    don’t have privilege for a particular operation. It can sometimes be difficult
    to distinguish such “false positives” when trying to determine the capabilities
    that an executable really does need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a kernel probe to produce monitoring output when the kernel is asked to
    perform capability checks. An example of how to do this is provided in [Hallyn,
    2007], an article written by one of the developers of file capabilities. For each
    request to check a capability, the probe shown in the article logs the kernel
    function that was called, the capability that was requested, and the name of the
    requesting program. Although this approach requires more work than the use of
    *strace(1)*, it can also help us more accurately determine the capabilities that
    a program requires.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Older Kernels and Systems Without File Capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we describe various differences in the implementation of capabilities
    in older kernels. We also describe the differences that occur on kernels where
    file capabilities are not supported. There are two scenarios where Linux doesn’t
    support file capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Before Linux 2.6.24, file capabilities were not implemented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since Linux 2.6.24, file capabilities can be disabled if the kernel is built
    without the `CONFIG_SECURITY_FILE_CAPABILITIES` option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although Linux introduced capabilities and allowed them to be attached to processes
    starting with kernel 2.2, the implementation of file capabilities appeared only
    several years later. The reasons that file capabilities remained unimplemented
    for so long were matters of policy, rather than technical difficulties. (Extended
    attributes, described in [Chapter 16](ch16.html "Chapter 16. Extended Attributes"),
    which are used to implement file capabilities, had been available since kernel
    2.6.) The weight of opinion among kernel developers was that requiring system
    administrators to set and monitor different sets of capabilities—some of whose
    consequences are subtle but far-reaching—for each privileged program would create
    an unmanageably complex administration task. By contrast, system administrators
    are familiar with the existing UNIX privilege model, know to treat set-user-ID
    programs with due caution, and can locate the set-user-ID and set-group-ID programs
    on a system using simple *find* commands. Nevertheless, the developers of file
    capabilities made the case that file capabilities could be made administratively
    workable, and eventually provided a convincing enough argument that file capabilities
    were integrated into the kernel.
  prefs: []
  type: TYPE_NORMAL
- en: The `CAP_SETPCAP` capability
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: On kernels that don’t support file capabilities (i.e., any kernel before 2.6.24,
    and kernels since 2.6.24 with file capabilities disabled), the semantics of the
    `CAP_SETPCAP` capability are different. Subject to rules that are analogous to
    those described in [Changing Process Capabilities Programmatically](ch39.html#changing_process_capabilities_programmat
    "Changing Process Capabilities Programmatically"), a process that has the `CAP_SETPCAP`
    capability in its effective set can theoretically change the capabilities of processes
    other than itself. Changes can be made to the capabilities of another process,
    all of the members of a specified process group, or all processes on the system
    except *init* and the caller itself. The final case excludes *init* because it
    is fundamental to the operation of the system. It also excludes the caller because
    the caller may be attempting to remove capabilities from every other process on
    the system, and we don’t want to remove the capabilities from the calling process
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: However, changing the capabilities of other processes is only a theoretical
    possibility. On older kernels, and on modern kernels where support for file capabilities
    is disabled, the capability bounding set (discussed next) always masks out the
    `CAP_SETPCAP` capability.
  prefs: []
  type: TYPE_NORMAL
- en: The capability bounding set
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Since Linux 2.6.25, the capability bounding set is a per-process attribute.
    However, on older kernels, the capability bounding set is a system-wide attribute
    that affects all processes on the system. The system-wide capability bounding
    set is initialized so that it always masks out `CAP_SETPCAP` (described above).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On kernels after 2.6.25, removing capabilities from the per-process bounding
    set is supported only if file capabilities are enabled in the kernel. In that
    case, *init*, the ancestor of all processes, starts with a bounding set containing
    all capabilities, and a copy of that bounding set is inherited by other processes
    created on the system. If file capabilities are disabled, then, because of the
    differences in the semantics of `CAP_SETPCAP` described above, *init* starts with
    a bounding set that contains all capabilities except `CAP_SETPCAP`.
  prefs: []
  type: TYPE_NORMAL
- en: There is one further change in the semantics of the capability bounding set
    in Linux 2.6.25\. As noted earlier ([Capability Bounding Set](ch39.html#capability_bounding_set
    "Capability Bounding Set")), on Linux 2.6.25 and later, the per-process capability
    bounding set acts as a limiting superset for the capabilities that can be added
    to the process’s inheritable set. In Linux 2.6.24 and earlier, the system-wide
    capability bounding set doesn’t have this masking effect. (It is not needed, because
    these kernels don’t support file capabilities.)
  prefs: []
  type: TYPE_NORMAL
- en: The system-wide capability bounding set is accessible via the Linux-specific
    `/proc/sys/kernel/cap-bound` file. A process must have the `CAP_SYS_MODULE` capability
    to be able to change the contents of `cap-bound`. However, only the *init* process
    can turn bits on in this mask; other privileged processes can only turn bits off.
    The upshot of these limitations is that on a system where file capabilities are
    not supported, we can never give the `CAP_SETPCAP` capability to a process. This
    is reasonable, since that capability can be used to subvert the entire kernel
    privilege-checking system. (In the unlikely case that we want to change this limitation,
    we must either load a kernel module that changes the value in the set, modify
    the source code of the *init* program, or change the initialization of the capability
    bounding set in the kernel source code and perform a kernel rebuild.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Confusingly, although it is a bit mask, the value in the system-wide cap-bound
    file is displayed as a signed decimal number. For example, the initial value of
    this file is -257\. This is the two’s complement interpretation of the bit mask
    with all bits except *(1 << 8)* turned on (i.e., in binary, 11111111 11111111
    11111110 11111111); `CAP_SETPCAP` has the value 8.
  prefs: []
  type: TYPE_NORMAL
- en: Using capabilities within a program on a system without file capabilities
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Even on a system that doesn’t support file capabilities, we can nevertheless
    employ capabilities to improve the security of a program. We do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Run the program in a process with an effective user ID of 0 (typically a set-user-ID-*root*
    program). Such a process is granted all capabilities (except `CAP_SETPCAP`, as
    noted earlier) in its permitted and effective sets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On program startup, use the *libcap* API to drop all capabilities from the effective
    set, and drop all capabilities except those that we may later need from the permitted
    set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `SECBIT_KEEP_CAPS` flag (or use the *prctl()* `PR_SET_KEEPCAPS` operation
    to achieve the same result), so that the next step does not drop capabilities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set all user IDs to nonzero values, to prevent the process from accessing files
    owned by *root* or gaining capabilities by doing an *exec()*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We could replace the two preceding steps by a single step that sets the `SECBIT_NOROOT`
    flag, if we want to prevent the process from regaining privileges on an *exec()*,
    but must allow it to access files owned by *root*. (Of course, allowing access
    to files owned by *root* leaves open the risk of some security vulnerability.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: During the rest of the program’s lifetime, use the *libcap* API to raise and
    drop the remaining permitted capabilities from the effective set as needed in
    order to perform privileged tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some applications built for Linux kernels before version 2.6.24 employed this
    approach.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Among the kernel developers who argued against the implementation of capabilities
    for executable files, one of the perceived virtues of the approach described in
    the main text was that the developer of an application knows which capabilities
    an executable requires. By contrast, a system administrator may not be able to
    easily determine this information.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Linux capabilities scheme divides privileged operations into distinct categories,
    and allows a process to be granted some capabilities, while being denied others.
    This scheme represents an improvement over the traditional all-or-nothing privilege
    mechanism, whereby a process has either privileges to perform all operations (user
    ID 0) or no privileges (nonzero user ID). Since kernel 2.6.24, Linux supports
    attaching capabilities to files, so that a process can gain selected capabilities
    by execing a program.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modify the program in [Example 35-2](ch35.html#modifying_process_scheduling_policies_an
    "Example 35-2. Modifying process scheduling policies and priorities") (`sched_set.c`,
    in [Privileges and resource limits affecting changes to scheduling parameters](ch35.html#privileges_and_resource_limits_affecting
    "Privileges and resource limits affecting changes to scheduling parameters"))
    to use file capabilities, so that it can be used by an unprivileged user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
