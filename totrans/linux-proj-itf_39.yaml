- en: Chapter 39. Capabilities
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 39 章. 能力
- en: This chapter describes the Linux capabilities scheme, which divides the traditional
    all-or-nothing UNIX privilege scheme into individual capabilities that can be
    independently enabled or disabled. Using capabilities allows a program to perform
    some privileged operations, while preventing it from performing others.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 Linux 权限能力方案，它将传统的全有或全无的 UNIX 权限方案分解为可以独立启用或禁用的各个能力。使用能力可以让程序执行某些特权操作，同时防止其执行其他操作。
- en: Rationale for Capabilities
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 能力的基本原理
- en: 'The traditional UNIX privilege scheme divides processes into two categories:
    those whose effective user ID is 0 (superuser), which bypass all privilege checks,
    and all other processes, which are subject to privilege checking according to
    their user and group IDs.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 UNIX 权限方案将进程分为两类：有效用户 ID 为 0（超级用户）的进程，绕过所有权限检查；以及所有其他进程，这些进程根据其用户和组 ID 进行权限检查。
- en: 'The coarse granularity of this scheme is a problem. If we want to allow a process
    to perform some operation that is permitted only to the superuser—for example,
    changing the system time—then we must run that process with an effective user
    ID of 0\. (If an unprivileged user needs to perform such operations, this is typically
    implemented using a set-user-ID-*root* program.) However, this grants the process
    privileges to perform a host of other actions as well—for example, bypassing all
    permission checks when accessing files—thus opening the door for a range of security
    breaches if the program behaves in unexpected ways (which may be the consequence
    of unforeseen circumstances, or because of deliberate manipulation by a malicious
    user). The traditional way of dealing with this problem was outlined in [Chapter 38](ch38.html
    "Chapter 38. Writing Secure Privileged Programs"): we drop effective privileges
    (i.e., change from an effective user ID of 0, while maintaining 0 in the saved
    set-user-ID) and temporarily reacquire them only when needed.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这一方案的粗粒度是一个问题。如果我们希望允许一个进程执行一些仅超级用户才允许的操作——例如，修改系统时间——那么我们必须使用有效用户 ID 为 0 来运行该进程。（如果没有特权的用户需要执行这些操作，通常会使用一个设置了用户
    ID 为 *root* 的程序来实现。）然而，这也会授予该进程执行许多其他操作的权限——例如，绕过访问文件时的所有权限检查——从而为一系列安全漏洞打开了大门，如果程序以意外方式行为（这可能是不可预见的情况所致，或是恶意用户故意操作的结果）。解决这个问题的传统方法在[第
    38 章](ch38.html "第 38 章. 编写安全的特权程序")中有所概述：我们放弃有效特权（即从有效用户 ID 0 变更，同时保持保存的用户 ID
    为 0），并且只有在需要时才临时重新获取这些特权。
- en: The Linux capability scheme refines the handling of this problem. Rather than
    using a single privilege (i.e., effective user ID of 0) when performing security
    checks in the kernel, the superuser privilege is divided into distinct units,
    called *capabilities*. Each privileged operation is associated with a particular
    capability, and a process can perform that operation only if it has the corresponding
    capability (regardless of its effective user ID). Put another way, everywhere
    in this book that we talk about a privileged process on Linux, what we really
    mean is a process that has the relevant capability for performing a particular
    operation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 权限能力方案改进了对这一问题的处理方式。与其在内核中执行安全检查时使用单一的特权（即有效用户 ID 为 0），不如将超级用户特权分为不同的单元，称为*能力*。每个特权操作都与特定的能力相关联，只有当进程具有相应的能力时，才能执行该操作（无论其有效用户
    ID 为何）。换句话说，在本书中我们讨论的所有 Linux 上的特权进程，实际上指的是那些具有执行特定操作所需能力的进程。
- en: Most of the time, the Linux capability scheme is invisible to us. The reason
    for this is that when an application that is unaware of capabilities assumes an
    effective user ID of 0, the kernel grants that process the complete range of capabilities.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，Linux 权限能力方案对我们是不可见的。原因在于，当一个不知道能力的应用程序假设其有效用户 ID 为 0 时，内核会授予该进程完整的能力范围。
- en: The Linux capabilities implementation is based on the POSIX 1003.1e draft standard
    ([http://wt.tuxomania.net/publications/posix.1e/](http://wt.tuxomania.net/publications/posix.1e/)).
    This standardization effort foundered in the late 1990s before it was completed,
    but various capabilities implementations are nevertheless based on the draft standard.
    (Some of the capabilities listed in [Table 39-1](ch39.html#operations_permitted_by_each_linux_capab
    "Table 39-1. Operations permitted by each Linux capability") are defined in the
    POSIX.1e draft, but many are Linux extensions.)
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 能力的实现基于 POSIX 1003.1e 草案标准（[http://wt.tuxomania.net/publications/posix.1e/](http://wt.tuxomania.net/publications/posix.1e/)）。该标准化工作在1990年代末期未能完成，但各种能力实现仍然基于该草案标准。（[表格
    39-1](ch39.html#operations_permitted_by_each_linux_capab "表格 39-1. 每个 Linux 能力允许的操作")中列出的一些能力是在
    POSIX.1e 草案中定义的，但许多是 Linux 的扩展。）
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: Capability schemes are provided in a few other UNIX implementations, such as
    in Sun’s Solaris 10 and earlier Trusted Solaris releases, SGI’s Trusted Irix,
    and as part of the TrustedBSD project for FreeBSD ([Watson, 2000]). Similar schemes
    exist in some other operating systems; for example, the privilege mechanism in
    Digital’s VMS system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一些其他 UNIX 实现也提供了能力方案，例如 Sun 的 Solaris 10 及其早期版本的受信任 Solaris、SGI 的受信任 Irix，以及作为
    TrustedBSD 项目一部分的 FreeBSD（[Watson, 2000]）。其他操作系统中也存在类似的方案，例如 Digital 的 VMS 系统中的特权机制。
- en: The Linux Capabilities
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux 能力
- en: '[Table 39-1](ch39.html#operations_permitted_by_each_linux_capab "Table 39-1. Operations
    permitted by each Linux capability") lists the Linux capabilities and provides
    an abbreviated (and incomplete) guide to the operations to which they apply.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 39-1](ch39.html#operations_permitted_by_each_linux_capab "表格 39-1. 每个 Linux
    能力允许的操作")列出了 Linux 的能力，并提供了简略（且不完整）的操作指南，说明这些能力适用于哪些操作。'
- en: Process and File Capabilities
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程和文件能力
- en: Each process has three associated capability sets—termed *permitted*, *effective*,
    and *inheritable*—that can contain zero or more of the capabilities listed in
    [Table 39-1](ch39.html#operations_permitted_by_each_linux_capab "Table 39-1. Operations
    permitted by each Linux capability"). Each file can likewise have three associated
    capability sets, with the same names. (For reasons that will become evident, the
    file effective capability set is really just a single bit that is either enabled
    or disabled.) We go into the details of each of these capability sets in the following
    sections.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进程都有三个相关的能力集——称为*许可*、*有效*和*可继承*——这些能力集可以包含[表格 39-1](ch39.html#operations_permitted_by_each_linux_capab
    "表格 39-1. 每个 Linux 能力允许的操作")中列出的零个或多个能力。每个文件也可以有三个相关的能力集，名称相同。（出于某些原因，文件的有效能力集实际上只是一个单一的位，能够开启或关闭。）我们将在接下来的章节中详细介绍这些能力集。
- en: Process Capabilities
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进程能力
- en: 'For each process, the kernel maintains three capability sets (implemented as
    bit masks) in which zero or more of the capabilities specified in [Table 39-1](ch39.html#operations_permitted_by_each_linux_capab
    "Table 39-1. Operations permitted by each Linux capability") are enabled. The
    three sets are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个进程，内核维护三个能力集（实现为位掩码），其中零个或多个[表格 39-1](ch39.html#operations_permitted_by_each_linux_capab
    "表格 39-1. 每个 Linux 能力允许的操作")中指定的能力被启用。这三个能力集如下：
- en: '*Permitted*: These are the capabilities that a process *may* employ. The permitted
    set is a limiting superset for the capabilities that can be added to the effective
    and inheritable sets. If a process drops a capability from its permitted set,
    it can never reacquire that capability (unless it execs a program that once more
    confers the capability).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*许可*: 这些是进程*可能*使用的能力。许可集是可以添加到有效集和可继承集中的能力的限制超集。如果进程从其许可集中删除某个能力，则永远无法重新获取该能力（除非它执行一个程序，该程序再次赋予该能力）。'
- en: '*Effective*: These are the capabilities used by the kernel to perform privilege
    checking for the process. As long as it maintains a capability in its permitted
    set, a process can temporarily disable the capability by dropping it from the
    effective set, and then later restoring it to that set.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有效*: 这些是内核用来执行进程权限检查的能力。只要进程在其许可集中保持某个能力，它可以通过将其从有效集移除，临时禁用该能力，然后稍后再将其恢复到有效集中。'
- en: '*Inheritable*: These are capabilities that may be carried over to the permitted
    set when a program is execed by this process.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可继承*: 这些是可以在程序被此进程执行时传递到许可集中的能力。'
- en: We can view hexadecimal representations of the three capability sets for any
    process in the three fields `CapInh`, `CapPrm`, and `CapEff` in the Linux-specific
    `/proc/`*PID*`/status` file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 Linux 特定的 `/proc/`*PID*`/status` 文件中的 `CapInh`、`CapPrm` 和 `CapEff` 这三个字段，查看任何进程的三个能力集的十六进制表示。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The *getpcap* program (part of the *libcap* package described in [Changing Process
    Capabilities Programmatically](ch39.html#changing_process_capabilities_programmat
    "Changing Process Capabilities Programmatically")) can be used to display the
    capabilities of a process in an easier-to-read format.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*getpcap* 程序（是 [程序化更改进程能力](ch39.html#changing_process_capabilities_programmat
    "Changing Process Capabilities Programmatically") 中描述的 *libcap* 包的一部分）可以用来以更易读的格式显示进程的能力。'
- en: A child process produced via *fork()* inherits copies of its parent’s capability
    sets. We describe the treatment of capability sets during an *exec()* in Section
    39.5.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 *fork()* 创建的子进程会继承父进程的能力集副本。我们在第 39.5 节中描述了 *exec()* 过程中能力集的处理。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In reality, capabilities are a per-thread attribute that can be adjusted independently
    for each of the threads in a process. The capabilities of a specific thread within
    a multithreaded process are shown in the `/proc/`*PID*`/task/`*TID*`/status` file.
    The `/proc/`*PID*`/status` file shows the capabilities of the main thread.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，能力是每个线程的属性，可以独立地调整进程中每个线程的能力。多线程进程中某个特定线程的能力显示在 `/proc/`*PID*`/task/`*TID*`/status`
    文件中。`/proc/`*PID*`/status` 文件显示的是主线程的能力。
- en: Before kernel 2.6.25, Linux represented capability sets using 32 bits. The addition
    of further capabilities in kernel 2.6.25 required a move to 64-bit sets.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在内核版本 2.6.25 之前，Linux 使用 32 位表示能力集。内核 2.6.25 中新增的能力集需要使用 64 位集来表示。
- en: File Capabilities
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件能力
- en: 'If a file has associated capability sets, then these sets are used to determine
    the capabilities that are given to a process if it execs that file. There are
    three file capability sets:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件具有相关的能力集，那么这些能力集将用于确定当进程执行该文件时授予其的能力。文件有三种能力集：
- en: '*Permitted*: This is a set of capabilities that may be added to the process’s
    permitted set during an *exec()*, regardless of the process’s existing capabilities.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*允许的*：这是一个可以在 *exec()* 过程中添加到进程允许集中的能力集，无论进程当前的能力集是什么。'
- en: '*Effective*: This is just a single bit. If it is enabled, then, during an *exec()*,
    the capabilities that are enabled in the process’s new permitted set are also
    enabled in the process’s new effective set. If the file effective bit is disabled,
    then, after an *exec()*, the process’s new effective set is initially empty.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有效的*：这只是一个单一的位。如果启用，那么在 *exec()* 过程中，进程的新允许集中的启用能力也将在进程的新有效集中启用。如果文件的有效位被禁用，那么在
    *exec()* 之后，进程的新有效集将最初为空。'
- en: '*Inheritable*: This set is masked against the process’s inheritable set to
    determine a set of capabilities that are to be enabled in the process’s permitted
    set after an *exec()*.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可继承的*：该集合与进程的可继承集合进行掩码操作，以确定在 *exec()* 后应启用进程的允许集中的哪些能力。'
- en: '[Transformation of Process Capabilities During *exec()*](ch39.html#transformation_of_process_capabilities_d
    "Transformation of Process Capabilities During exec()") provides details of how
    file capabilities are used during an *exec()*.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[*exec()*期间进程能力的转化](ch39.html#transformation_of_process_capabilities_d "Transformation
    of Process Capabilities During exec()") 提供了在 *exec()* 过程中如何使用文件能力的详细信息。'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The permitted and inheritable file capabilities were formerly known as *forced*
    and *allowed*. Those terms are now obsolete, but they are still informative. The
    permitted file capabilities are the ones that are *forced* into the process’s
    permitted set during an *exec()*, regardless of the process’s existing capabilities.
    The inheritable file capabilities are the ones that the file *allows* into the
    process’s permitted set during an *exec()*, if those capabilities are also enabled
    in the process’s inheritable capability set.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 允许的和可继承的文件能力以前被称为 *强制* 和 *允许*。这些术语现在已经过时，但仍然具有参考意义。允许的文件能力是在 *exec()* 过程中被 *强制*
    添加到进程的允许集中的能力，无论进程当前的能力集如何。可继承的文件能力是在 *exec()* 过程中由文件 *允许* 添加到进程的允许集中的能力，如果这些能力也在进程的可继承能力集中启用的话。
- en: The capabilities associated with a file are stored in a *security* extended
    attribute ([Overview](ch16.html#overview-id1 "Overview")) named *security.capability*.
    The `CAP_SETFCAP` capability is required to update this extended attribute.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 文件关联的能力存储在名为 *security.capability* 的 *security* 扩展属性中（[概述](ch16.html#overview-id1
    "概述")）。更新此扩展属性需要 `CAP_SETFCAP` 能力。
- en: Table 39-1. Operations permitted by each Linux capability
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 表 39-1. 每个 Linux 能力允许的操作
- en: '| Capability | Permits process to |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 能力 | 允许进程执行 |'
- en: '| --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `CAP_AUDIT_CONTROL` | (Since Linux 2.6.11) Enable and disable kernel audit
    logging; change filtering rules for auditing; retrieve auditing status and filtering
    rules |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_AUDIT_CONTROL` | （自 Linux 2.6.11）启用和禁用内核审计日志；更改审计的过滤规则；检索审计状态和过滤规则 |'
- en: '| `CAP_AUDIT_WRITE` | (Since Linux 2.6.11) Write records to the kernel auditing
    log |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_AUDIT_WRITE` | （自 Linux 2.6.11）将记录写入内核审计日志 |'
- en: '| `CAP_CHOWN` | Change file’s user ID (owner) or change file’s group ID to
    a group of which process is not a member (*chown()*) |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_CHOWN` | 更改文件的用户 ID（所有者）或将文件的组 ID 更改为进程不属于的组（*chown()*) |'
- en: '| `CAP_DAC_OVERRIDE` | Bypass file read, write, and execute permission checks
    (DAC is an abbreviation for discretionary access control); read contents of `cwd`,
    `exe`, and `root` symbolic links in `/proc/`*PID* |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_DAC_OVERRIDE` | 绕过文件读取、写入和执行权限检查（DAC 是“自主访问控制”的缩写）；读取 `/proc/`*PID*
    中的 `cwd`、`exe` 和 `root` 符号链接的内容 |'
- en: '| `CAP_DAC_READ_SEARCH` | Bypass file read permission checks and directory
    read and execute (search) permission checks |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_DAC_READ_SEARCH` | 绕过文件读取权限检查和目录读取与执行（搜索）权限检查 |'
- en: '| `CAP_FOWNER` | Generally ignore permission checks on operations that normally
    require the process’s file-system user ID to match the file’s user ID *(chmod()*,
    *utime());* set i-node flags on arbitrary files; set and modify ACLs on arbitrary
    files; ignore effect of directory sticky bit when deleting files *(unlink()*,
    *rmdir()*, *rename());* specify `O_NOATIME` flag for arbitrary files in *open()*
    and *fcntl(F_SETFL)* |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_FOWNER` | 通常忽略需要进程的文件系统用户 ID 与文件的用户 ID 匹配的操作的权限检查（*chmod()*, *utime()*)；在任意文件上设置
    i-node 标志；在任意文件上设置和修改 ACL；忽略删除文件时目录粘性位的影响（*unlink()*, *rmdir()*, *rename()*)；为任意文件指定
    `O_NOATIME` 标志，使用 *open()* 和 *fcntl(F_SETFL)* |'
- en: '| `CAP_FSETID` | Modify a file without having the kernel turn off set-user-ID
    and set-group-ID bits (*write()*, *truncate()*); enable set-group-ID bit for a
    file whose group ID doesn’t match the process’s file-system group ID or supplementary
    group IDs (*chmod()*) |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_FSETID` | 修改文件而不让内核关闭设置用户 ID 和设置组 ID 位（*write()*, *truncate()*)；为一个文件启用设置组
    ID 位，即使文件的组 ID 与进程的文件系统组 ID 或附加组 ID 不匹配（*chmod()*) |'
- en: '| `CAP_IPC_LOCK` | Override memory-locking restrictions (*mlock()*, *mlockall()*,
    *shmctl(SHM_LOCK)*, *shmctl(SHM_UNLOCK)*); employ *shmget()* `SHM_HUGETLB` flag
    and *mmap()* `MAP_HUGETLB` flag. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_IPC_LOCK` | 覆盖内存锁定限制（*mlock()*, *mlockall()*, *shmctl(SHM_LOCK)*, *shmctl(SHM_UNLOCK)*）；使用
    *shmget()* `SHM_HUGETLB` 标志和 *mmap()* `MAP_HUGETLB` 标志 |'
- en: '| `CAP_IPC_OWNER` | Bypass permission checks for operations on System V IPC
    objects |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_IPC_OWNER` | 绕过对 System V IPC 对象操作的权限检查 |'
- en: '| `CAP_KILL` | Bypass permission checks for sending signals (*kill()*, *sigqueue()*)
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_KILL` | 绕过发送信号（*kill()*, *sigqueue()*）的权限检查 |'
- en: '| `CAP_LEASE` | (Since Linux 2.4) Establish leases on arbitrary files (*fcntl(F_SETLEASE)*)
    |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_LEASE` | （自 Linux 2.4）在任意文件上建立租约（*fcntl(F_SETLEASE)*) |'
- en: '| `CAP_LINUX_IMMUTABLE` | Set append and immutable i-node flags |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_LINUX_IMMUTABLE` | 设置附加和不可变的 i-node 标志 |'
- en: '| `CAP_MAC_ADMIN` | (Since Linux 2.6.25) Configure or make state changes for
    mandatory access control (MAC) (implemented by some Linux security modules) |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_MAC_ADMIN` | （自 Linux 2.6.25）配置或修改强制访问控制（MAC）的状态（由某些 Linux 安全模块实现） |'
- en: '| `CAP_MAC_OVERRIDE` | (Since Linux 2.6.25) Override MAC (implemented by some
    Linux security modules) |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_MAC_OVERRIDE` | （自 Linux 2.6.25）覆盖 MAC（由某些 Linux 安全模块实现） |'
- en: '| `CAP_MKNOD` | (Since Linux 2.4) Use *mknod()* to create devices |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_MKNOD` | （自 Linux 2.4）使用 *mknod()* 创建设备 |'
- en: '| `CAP_NET_ADMIN` | Perform various network-related operations (e.g., setting
    privileged socket options, enabling multicasting, configuring network interfaces,
    and modifying routing tables) |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_NET_ADMIN` | 执行各种与网络相关的操作（例如，设置特权套接字选项、启用多播、配置网络接口和修改路由表） |'
- en: '| `CAP_NET_BIND_SERVICE` | Bind to privileged socket ports |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_NET_BIND_SERVICE` | 绑定到特权套接字端口 |'
- en: '| `CAP_NET_BROADCAST` | (Unused) Perform socket broadcasts and listen to multicasts
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_NET_BROADCAST` | （未使用）执行套接字广播并监听多播 |'
- en: '| `CAP_NET_RAW` | Use raw and packet sockets |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_NET_RAW` | 使用原始套接字和数据包套接字 |'
- en: '| `CAP_SETGID` | Make arbitrary changes to process group IDs (*setgid()*, *setegid()*,
    *setregid()*, *setresgid()*, *setfsgid()*, *setgroups()*, *initgroups()*); forge
    group ID when passing credentials via UNIX domain socket (`SCM_CREDENTIALS`) |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_SETGID` | 对进程组ID进行任意修改（*setgid()*, *setegid()*, *setregid()*, *setresgid()*,
    *setfsgid()*, *setgroups()*, *initgroups()*）；通过UNIX域套接字 (`SCM_CREDENTIALS`) 传递凭据时伪造组ID
    |'
- en: '| `CAP_SETFCAP` | (Since Linux 2.6.24) Set file capabilities |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_SETFCAP` | （自Linux 2.6.24起）设置文件能力 |'
- en: '| `CAP_SETPCAP` | If file capabilities are not supported, grant and remove
    capabilities in the process’s permitted set to or from any other process (including
    self); if file capabilities are supported, add any capability in the process’s
    capability bounding set to its inheritable set, drop capabilities from the bounding
    set, and change *securebits* flags |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_SETPCAP` | 如果文件能力不受支持，授予和移除进程允许集中的能力，或者从任何其他进程（包括自身）中添加或删除能力；如果文件能力受支持，将进程的能力边界集中的任何能力添加到其可继承集，删除能力边界集中的能力，并修改
    *securebits* 标志 |'
- en: '| `CAP_SETUID` | Make arbitrary changes to process user IDs (*setuid()*, *seteuid()*,
    *setreuid()*, *setresuid()*, *setfsuid()*); forge user ID when passing credentials
    via UNIX domain socket (`SCM_CREDENTIALS`) |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_SETUID` | 对进程用户ID进行任意修改（*setuid()*, *seteuid()*, *setreuid()*, *setresuid()*,
    *setfsuid()*）；通过UNIX域套接字 (`SCM_CREDENTIALS`) 传递凭据时伪造用户ID |'
- en: '| `CAP_SYS_ADMIN` | Exceed `/proc/sys/fs/file-max` limit in system calls that
    open files (e.g., *open()*, *shm_open()*, *pipe()*, *socket()*, *accept()*, *exec()*,
    *acct()*, *epoll_create())*; perform various system administration operations,
    including *quotactl()* (control disk quotas), *mount()* and *umount()*, *swapon()*
    and *swapoff()*, *pivot_root()*, *sethostname()* and *setdomainname()*; perform
    various *syslog(2)* operations; override `RLIMIT_NPROC` resource limit (*fork()*);
    call *lookup_dcookie()*; set *trusted* and *security* extended attributes; perform
    `IPC_SET` and `IPC_RMID` operations on arbitrary System V IPC objects; forge process
    ID when passing credentials via UNIX domain socket (`SCM_CREDENTIALS`); use *ioprio_set()*
    to assign `IOPRIO_CLASS_RT` scheduling class; employ *TIOCCONS ioctl();* employ
    `CLONE_NEWNS` flag with *clone()* and *unshare()*; perform `KEYCTL_CHOWN` and
    `KEYCTL_SETPERM` *keyctl()* operations; administer *random(4)* device; various
    device-specific operations |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_SYS_ADMIN` | 在打开文件的系统调用中超过 `/proc/sys/fs/file-max` 限制（例如，*open()*, *shm_open()*,
    *pipe()*, *socket()*, *accept()*, *exec()*, *acct()*, *epoll_create()*）；执行各种系统管理操作，包括
    *quotactl()*（控制磁盘配额）、*mount()* 和 *umount()*, *swapon()* 和 *swapoff()*, *pivot_root()*,
    *sethostname()* 和 *setdomainname()*；执行各种 *syslog(2)* 操作；覆盖 `RLIMIT_NPROC` 资源限制（*fork()*）；调用
    *lookup_dcookie()*；设置 *trusted* 和 *security* 扩展属性；对任意 System V IPC 对象执行 `IPC_SET`
    和 `IPC_RMID` 操作；通过UNIX域套接字 (`SCM_CREDENTIALS`) 传递凭据时伪造进程ID；使用 *ioprio_set()* 分配
    `IOPRIO_CLASS_RT` 调度类；使用 *TIOCCONS ioctl()*；与 *clone()* 和 *unshare()* 一起使用 `CLONE_NEWNS`
    标志；执行 `KEYCTL_CHOWN` 和 `KEYCTL_SETPERM` *keyctl()* 操作；管理 *random(4)* 设备；各种设备特定操作
    |'
- en: '| `CAP_SYS_BOOT` | Use *reboot()* to reboot the system; call *kexec_load()*
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_SYS_BOOT` | 使用 *reboot()* 重启系统；调用 *kexec_load()* |'
- en: '| `CAP_SYS_CHROOT` | Use *chroot()* to set process root directory |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_SYS_CHROOT` | 使用 *chroot()* 设置进程根目录 |'
- en: '| `CAP_SYS_MODULE` | Load and unload kernel modules (*init_module()*, *delete_module()*,
    *create_module()*) |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_SYS_MODULE` | 加载和卸载内核模块（*init_module()*, *delete_module()*, *create_module()*)
    |'
- en: '| `CAP_SYS_NICE` | Raise nice value *(nice()*, *setpriority());* change nice
    value for arbitrary processes (*setpriority()*); set `SCHED_RR` and `SCHED_FIFO`
    realtime scheduling policies for calling process; reset `SCHED_RESET_ON_FORK`
    flag; set scheduling policies and priorities for arbitrary processes (*sched_setscheduler()*,
    *sched_setparam()*); set I/O scheduling class and priority for arbitrary processes
    (*ioprio_set()*); set CPU affinity for arbitrary processes (*sched_setaffinity()*);
    use *migrate_pages()* to migrate arbitrary processes and allow processes to be
    migrated to arbitrary nodes; apply *move_pages()* to arbitrary processes; use
    `MPOL_MF_MOVE_ALL` flag with *mbind()* and *move_pages()* |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_SYS_NICE` | 提高优先级值（*nice()*, *setpriority()*）；改变任意进程的优先级值（*setpriority()*）；为调用进程设置
    `SCHED_RR` 和 `SCHED_FIFO` 实时调度策略；重置 `SCHED_RESET_ON_FORK` 标志；为任意进程设置调度策略和优先级（*sched_setscheduler()*,
    *sched_setparam()*）；为任意进程设置I/O调度类和优先级（*ioprio_set()*）；为任意进程设置CPU亲和性（*sched_setaffinity()*）；使用
    *migrate_pages()* 迁移任意进程，并允许进程迁移到任意节点；对任意进程应用 *move_pages()*；使用 `MPOL_MF_MOVE_ALL`
    标志与 *mbind()* 和 *move_pages()* |'
- en: '| `CAP_SYS_PACCT` | Use *acct()* to enable or disable process accounting |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_SYS_PACCT` | 使用 *acct()* 启用或禁用进程会计 |'
- en: '| `CAP_SYS_PTRACE` | Trace arbitrary processes using *ptrace()*; access `/proc/`*PID*`/environ`
    for arbitrary processes; apply *get_robust_list()* to arbitrary processes |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_SYS_PTRACE` | 使用 *ptrace()* 跟踪任意进程；访问 `/proc/`*PID*`/environ` 以获取任意进程的环境变量；对任意进程应用
    *get_robust_list()* |'
- en: '| `CAP_SYS_RAWIO` | Perform operations on I/O ports using *iopl()* and *ioperm()*;
    access `/proc/kcore`; open `/dev/mem` and `/dev/kmem` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_SYS_RAWIO` | 使用 *iopl()* 和 *ioperm()* 对 I/O 端口进行操作；访问 `/proc/kcore`；打开
    `/dev/mem` 和 `/dev/kmem` |'
- en: '| `CAP_SYS_RESOURCE` | Use reserved space on file systems; make *ioctl()* calls
    controlling *ext3* journaling; override disk quota limits; increase hard resource
    limits (*setrlimit()*); override `RLIMIT_NPROC` resource limit (*fork()*); raise
    *msg_qbytes* limit for a System V message queue above limit in `/proc/sys/kernel/msgmnb;`
    bypass various POSIX message queue limits defined by files under `/proc/sys/fs/mqueue`
    |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_SYS_RESOURCE` | 使用文件系统上的保留空间；进行 *ioctl()* 调用以控制 *ext3* 日志；覆盖磁盘配额限制；增加硬资源限制
    (*setrlimit()*); 覆盖 `RLIMIT_NPROC` 资源限制 (*fork()*); 提高 System V 消息队列中 *msg_qbytes*
    的限制；绕过 `/proc/sys/kernel/msgmnb` 中定义的各种 POSIX 消息队列限制；绕过 `/proc/sys/fs/mqueue`
    下文件定义的消息队列限制 |'
- en: '| `CAP_SYS_TIME` | Modify system clock (*settimeofday()*, *stime()*, *adjtime()*,
    *adjtimex()*); set hardware clock |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_SYS_TIME` | 修改系统时钟 (*settimeofday()*, *stime()*, *adjtime()*, *adjtimex()*);
    设置硬件时钟 |'
- en: '| `CAP_SYS_TTY_CONFIG` | Perform virtual hangup of terminal or pseudoterminal
    using *vhangup()* |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `CAP_SYS_TTY_CONFIG` | 使用 *vhangup()* 执行终端或伪终端的虚拟挂断 |'
- en: Purpose of the Process Permitted and Effective Capability Sets
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进程允许和有效能力集的目的
- en: The *process permitted* capability set defines the capabilities that a process
    *may* employ. The *process effective* capability set defines the capabilities
    that are currently in effect for the process—that is, the set of capabilities
    that the kernel uses when checking whether the process has the necessary privilege
    to perform a particular operation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程允许*能力集定义了进程*可以*使用的能力。*进程有效*能力集定义了当前对进程生效的能力——即内核在检查进程是否有必要权限以执行某个操作时所使用的能力集。'
- en: The permitted capability set imposes an upper bound on the effective set. A
    process can *raise* a capability in its effective set only if that capability
    is in the permitted set. (The terms *add* to and *set* are sometimes used synonymously
    with *raise*. The converse operation is *drop*, or synonymously, *remove* or *clear*.)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 允许能力集对有效能力集施加上限。只有当某项能力在允许集中的时候，进程才可以在其有效集里*提升*该能力。（术语 *add* 到和 *set* 有时与 *raise*
    同义。相反操作是 *drop*，或者同义的 *remove* 或 *clear*。）
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The relationship between the effective and permitted capability sets is analogous
    to that between the effective user ID and the saved set-user-ID for a set-user-ID-*root*
    program. Dropping a capability from the effective set is analogous to temporarily
    dropping an effective user ID of 0, while maintaining 0 in the saved set-user-ID.
    Dropping a capability from both the effective and permitted capability sets is
    analogous to permanently dropping superuser privileges by setting both the effective
    user ID and the saved set-user ID to nonzero values.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有效能力集与允许能力集之间的关系类似于有效用户 ID 与保存的 set-user-ID（针对 set-user-ID-*root* 程序）的关系。将某项能力从有效集移除类似于暂时移除有效用户
    ID 为 0，同时保持 0 在保存的 set-user-ID 中。将能力从有效集和允许集都移除类似于通过将有效用户 ID 和保存的 set-user-ID
    都设置为非零值，从而永久地移除超级用户权限。
- en: Purpose of the File Permitted and Effective Capability Sets
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件允许和有效能力集的目的
- en: The *file permitted* capability set provides a mechanism by which an executable
    file can give capabilities to a process. It specifies a group of capabilities
    that are to be assigned to the process’s permitted capability set during an *exec()*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件允许*能力集提供了一种机制，通过它可执行文件可以向进程授予能力。它指定了一组能力，这些能力将在 *exec()* 调用时分配到进程的允许能力集。'
- en: 'The *file effective* capability set is a single flag (bit) that is either enabled
    or disabled. To understand why this set consists of just a single bit, we need
    to consider the two cases that occur when a program is execed:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件有效*能力集是一个单一标志（位），可以启用或禁用。为了理解为何这个集合只有一个位，我们需要考虑当程序被 exec 时发生的两种情况：'
- en: The program may be *capability-dumb*, meaning that it doesn’t know about capabilities
    (i.e., it is designed as a traditional set-user-ID-*root* program). Such a program
    won’t know that it needs to raise capabilities in its effective set in order to
    be able to perform privileged operations. For such programs, an *exec()* should
    have the effect that all of the process’s new permitted capabilities are automatically
    also assigned to its effective set. This result is achieved by enabling the file
    effective bit.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序可能是*能力盲*的，意味着它不知道能力（即，它被设计为传统的设置用户ID-*root*程序）。这样的程序不会知道它需要在其有效能力集中提升能力，以便能够执行特权操作。对于这样的程序，*exec()*应该具有这样的效果：进程的所有新许可能力自动也会分配到其有效能力集中。通过启用文件有效位来实现这一结果。
- en: The program may be *capability-aware*, meaning that it has been designed with
    the capabilities framework in mind, and it will make the appropriate system calls
    (discussed later) to raise and drop capabilities in its effective set. For such
    programs, least-privilege considerations mean that, after an *exec()*, all capabilities
    should initially be disabled in the process’s effective capability set. This result
    is achieved by disabling the file effective capability bit.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序可能是*能力感知*的，意味着它在设计时考虑了能力框架，并会通过适当的系统调用（稍后讨论）在其有效能力集中提升和丢弃能力。对于这样的程序，最小特权原则意味着，在*exec()*调用后，进程的有效能力集中的所有能力应该最初被禁用。通过禁用文件有效能力位来实现这一结果。
- en: Purpose of the Process and File Inheritable Sets
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进程和文件可继承集的目的
- en: 'At first glance, the use of permitted and effective sets for processes and
    files might seem a sufficient framework for a capabilities system. However, there
    are some situations where they do not suffice. For example, what if a process
    performing an *exec()* wants to preserve some of its current capabilities across
    the *exec()*? It might appear that the capabilities implementation could provide
    this feature simply by preserving the process’s permitted capabilities across
    an *exec()*. However, this approach would not handle the following cases:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，使用进程和文件的许可集和有效集似乎是能力系统的足够框架。然而，在某些情况下，它们并不充分。例如，如果一个进程在执行*exec()*时希望保留其当前的一些能力怎么办？看起来，能力实现可以通过简单地保留进程的许可能力来提供这个功能。然而，这种方法无法处理以下情况：
- en: Performing the *exec()* might require certain privileges (e.g., `CAP_DAC_OVERRIDE`)
    that we don’t want to preserve across the *exec()*.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行*exec()*可能需要某些特权（例如，`CAP_DAC_OVERRIDE`），而这些特权我们不希望在*exec()*后保留。
- en: Suppose that we explicitly dropped some permitted capabilities that we didn’t
    want to preserve across the *exec()*, but then the *exec()* failed. In this case,
    the program might need some of the permitted capabilities that it has already
    (irrevocably) dropped.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们显式地丢弃了一些不想在*exec()*后保留的许可能力，但*exec()*调用失败了。在这种情况下，程序可能需要一些它已经（不可恢复地）丢弃的许可能力。
- en: 'For these reasons, a process’s permitted capabilities are not preserved across
    an *exec()*. Instead, another capability set is introduced: the *inheritable set*.
    The inheritable set provides a mechanism by which a process can preserve some
    of its capabilities across an *exec()*.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，进程的许可能力不会在*exec()*调用后保留。相反，另一个能力集被引入：*可继承集*。可继承集提供了一种机制，使得进程可以在*exec()*调用后保留其部分能力。
- en: The *process inheritable* capability set specifies a group of capabilities that
    may be assigned to the process’s permitted capability set during an *exec()*.
    The corresponding *file inheritable* set is masked (ANDed) against the process
    inherited capability set to determine the capabilities that are actually added
    to the process’s permitted capability set during an *exec()*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*进程可继承*能力集指定了一组能力，这些能力可能在*exec()*调用过程中被分配到进程的许可能力集中。对应的*文件可继承*能力集会与进程继承的能力集进行掩码（按位与运算），以确定实际添加到进程许可能力集中的能力。'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is a further, philosophical reason for not simply preserving the process
    permitted capability set across an *exec()*. The idea of the capabilities system
    is that all privileges given to a process are granted or controlled by the file
    that the process execs. Although the process inheritable set specifies capabilities
    that are passed across an *exec()*, these capabilities are masked by the file
    inheritable set.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅仅保留进程许可功能集跨越*exec()*调用，还有一个进一步的哲学原因。功能系统的理念是，所有赋予进程的特权都由进程执行的文件授予或控制。尽管进程可继承集指定了在*exec()*中传递的功能，但这些功能会被文件的可继承集屏蔽。
- en: Assigning and Viewing File Capabilities from the Shell
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从Shell分配和查看文件功能
- en: The *setcap(8)* and *getcap(8)* commands, contained in the *libcap* package
    described in [Changing Process Capabilities Programmatically](ch39.html#changing_process_capabilities_programmat
    "Changing Process Capabilities Programmatically"), can be used to manipulate file
    capabilities sets. We demonstrate the use of these commands with a short example
    using the standard *date(1)* program. (This program is an example of a capability-dumb
    application according to the definition in [Purpose of the File Permitted and
    Effective Capability Sets](ch39.html#purpose_of_the_file_permitted_and_effect
    "Purpose of the File Permitted and Effective Capability Sets").) When run with
    privilege, *date(1)* can be used to change the system time. The *date* program
    is not set-user-ID-*root*, so normally the only way to run it with privilege is
    to become the superuser.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*setcap(8)*和*getcap(8)*命令包含在*libcap*包中，该包在[程序化地更改进程功能](ch39.html#changing_process_capabilities_programmat
    "程序化地更改进程功能")中有所描述，能够操作文件功能集。我们通过一个简短的示例演示这些命令的使用，使用的是标准的*date(1)*程序。（根据[文件许可和有效功能集的目的](ch39.html#purpose_of_the_file_permitted_and_effect
    "文件许可和有效功能集的目的")的定义，该程序是一个功能缺失的应用示例。）当以特权运行时，*date(1)*可以用来更改系统时间。*date*程序没有设置用户ID为*root*，所以通常只有成为超级用户才能以特权运行它。'
- en: 'We begin by displaying the current system time, and then try to change the
    time as an unprivileged user:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先显示当前的系统时间，然后尝试作为普通用户更改时间：
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Above, we see that the *date* command failed to change the system time, but
    nevertheless displayed its argument in the standard format.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所示，我们看到*date*命令未能更改系统时间，但仍然以标准格式显示了其参数。
- en: 'Next, we become the superuser, which allows us to successfully change the system
    time:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们成为超级用户，这样就能成功更改系统时间：
- en: '[PRE1]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We now make a copy of the *date* program and assign it the capability that
    it needs:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在复制*date*程序，并为其分配所需的功能：
- en: '[PRE2]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The *setcap* command shown above assigns the *CAP_SYS_TIME* capability to the
    permitted (*p*) and effective (*e*) capability sets of the executable file. We
    then used the *getcap* command to verify the capabilities assigned to the file.
    (The syntax used by *setcap* and *getcap* for representing capability sets is
    described in the *cap_from_text(3)* manual page provided in the *libcap* package.)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 上面显示的*setcap*命令将*CAP_SYS_TIME*功能分配给可执行文件的许可（*p*）和有效（*e*）功能集。然后我们使用*getcap*命令验证分配给文件的功能。（*setcap*和*getcap*用于表示功能集的语法可在*libcap*包提供的*cap_from_text(3)*手册页中找到。）
- en: 'The file capabilities of our copy of the *date* program allow the program to
    be used by unprivileged users to set the system time:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的*date*程序副本的文件功能允许普通用户使用该程序设置系统时间：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Modern Capabilities Implementation
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现代功能实现
- en: 'A complete implementation of capabilities requires the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的功能实现需要以下内容：
- en: For each privileged operation, the kernel should check whether the process has
    the relevant capability, rather than checking for an effective (or file system)
    user ID of 0.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个特权操作，内核应该检查进程是否具有相关功能，而不是检查有效（或文件系统）用户ID是否为0。
- en: The kernel must provide system calls allowing a process’s capabilities to be
    retrieved and modified.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核必须提供系统调用，允许进程检索和修改其功能。
- en: The kernel must support the notion of attaching capabilities to an executable
    file, so that the process gains the associated capabilities when that file is
    execed. This is analogous to the set-user-ID bit, but allows the independent specification
    of all capabilities on the executable file. In addition, the system must provide
    a set of programming interfaces and commands for setting and viewing the capabilities
    attached to an executable file.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内核必须支持将能力附加到可执行文件的概念，这样进程在执行该文件时会获得相关的能力。这类似于设置用户ID位，但允许独立地指定可执行文件上的所有能力。此外，系统必须提供一组编程接口和命令，用于设置和查看附加到可执行文件的能力。
- en: Up to and including kernel 2.6.23, Linux met only the first two of these requirements.
    Since kernel 2.6.24, it is possible to attach capabilities to a file. Various
    other features were added in kernels 2.6.25 and 2.6.26 in order to complete the
    capabilities implementation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 直到内核版本2.6.23，Linux仅满足这两个要求中的前两个。从内核2.6.24开始，Linux支持将能力附加到文件上。在内核2.6.25和2.6.26中，添加了其他功能以完善能力的实现。
- en: For most of our discussion of capabilities, we’ll focus on the modern implementation.
    In [Older Kernels and Systems Without File Capabilities](ch39.html#older_kernels_and_systems_without_file_c
    "Older Kernels and Systems Without File Capabilities"), we consider how the implementation
    differed before file capabilities were introduced. Furthermore, file capabilities
    are an optional kernel component in modern kernels, but for the main part of our
    discussion, we’ll assume that this component is enabled. Later, we’ll describe
    the differences that occur if file capabilities are not enabled. (In several respects,
    the behavior is similar to that of Linux in kernels before 2.6.24, where file
    capabilities were not implemented.)
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对能力的讨论中，我们将专注于现代实现。在[旧内核和没有文件能力的系统](ch39.html#older_kernels_and_systems_without_file_c
    "旧内核和没有文件能力的系统")中，我们将讨论文件能力引入之前实现的不同之处。此外，文件能力在现代内核中是一个可选的内核组件，但在本部分讨论中，我们假设该组件已启用。稍后，我们将描述如果未启用文件能力时的不同之处。（在几个方面，其行为类似于Linux
    2.6.24之前的内核版本，在这些版本中并未实现文件能力。）
- en: In the following sections, we go into more detail on the Linux capabilities
    implementation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更详细地介绍Linux能力的实现。
- en: Transformation of Process Capabilities During *exec()*
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在*exec()*过程中，进程能力的转变
- en: 'During an *exec()*, the kernel sets new capabilities for the process based
    on the process’s current capabilities and the capability sets of the file being
    executed. The kernel calculates the new capabilities of the process using the
    following rules:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在*exec()*过程中，内核会根据进程当前的能力以及正在执行文件的能力集为进程设置新的能力。内核通过以下规则计算进程的新能力：
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the above rules, *P* denotes the value of a capability set prior to the *exec()*,
    *P’* denotes the value of a capability set after the *exec()*, and *F* denotes
    a file capability set. The identifier *cap_bset* denotes the value of the capability
    bounding set. Note that *exec()* leaves the process inheritable capability set
    unchanged.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述规则中，*P*表示*exec()*之前能力集的值，*P’*表示*exec()*之后能力集的值，而*F*表示文件能力集的值。标识符*cap_bset*表示能力边界集的值。请注意，*exec()*不会改变进程的可继承能力集。
- en: Capability Bounding Set
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 能力边界集
- en: 'The capability bounding set is a security mechanism that is used to limit the
    capabilities that a process can gain during an *exec()*. This set is used as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 能力边界集是一种安全机制，用于限制进程在*exec()*过程中能够获得的能力。该集的使用方式如下：
- en: During an *exec()*, the capability bounding set is ANDed with the file permitted
    capabilities to determine the permitted capabilities that are to be granted to
    the new program. In other words, an executable file’s permitted capability set
    can’t grant a permitted capability to a process if the capability is not in the
    bounding set.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*exec()*过程中，能力边界集与文件允许的能力集进行与操作，以确定授予新程序的允许能力。换句话说，如果某个能力不在边界集中，执行文件的允许能力集不能授予该能力给进程。
- en: The capability bounding set is a limiting superset for the capabilities that
    can be added to the process’s inheritable set. This means that, unless the capability
    is in the bounding set, a process can’t add one of its permitted capabilities
    to its inheritable set and then—via the first of the capability transformation
    rules described above—have that capability preserved in its permitted set when
    it execs a file that has the capability in its inheritable set.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能力边界集是一个限制性的超集，用于限制可以添加到进程的可继承集中的能力。这意味着，除非能力位于边界集内，否则进程不能将其允许的能力添加到其可继承集，并且通过上面描述的第一个能力转换规则，无法在执行具有可继承集能力的文件时，将该能力保留在其允许集内。
- en: The capability bounding set is a per-process attribute that is inherited by
    a child created via *fork()*, and preserved across an *exec()*. On a kernel that
    supports file capabilities, *init* (the ancestor of all processes) starts with
    a capability bounding set that contains all capabilities.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 能力边界集是一个进程级别的属性，通过*fork()*创建的子进程会继承该属性，并且在*exec()*中得以保留。在支持文件能力的内核中，*init*（所有进程的祖先）开始时具有包含所有能力的能力边界集。
- en: If a process has the `CAP_SETPCAP` capability, then it can (irreversibly) remove
    capabilities from its bounding set using the *prctl()* `PR_CAPBSET_DROP` operation.
    (Dropping a capability from the bounding set doesn’t affect the process permitted,
    effective, and inheritable capability sets.) A process can determine if a capability
    is in its bounding set using the *prctl()* `PR_CAPBSET_READ` operation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果进程具有`CAP_SETPCAP`能力，则它可以使用*prctl()*的`PR_CAPBSET_DROP`操作（不可逆地）从其边界集中删除能力。（从边界集中删除能力不会影响进程的允许、有效和可继承能力集。）进程可以使用*prctl()*的`PR_CAPBSET_READ`操作来确定某个能力是否在其边界集中。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More precisely, the capability bounding set is a per-thread attribute. Starting
    with Linux 2.6.26, this attribute is displayed as the `CapBnd` field in the Linux-specific
    `/proc/`*PID*`/task/`*TID*`/status` file. The `/proc/`*PID*`/status` file shows
    the bounding set of a process’s main thread.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 更准确地说，能力边界集是每个线程的属性。从Linux 2.6.26开始，该属性显示为Linux特有的`/proc/`*PID*`/task/`*TID*`/status`文件中的`CapBnd`字段。`/proc/`*PID*`/status`文件显示进程主线程的边界集。
- en: Preserving *root* Semantics
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保留*root*语义
- en: 'In order to preserve the traditional semantics for the *root* user (i.e., *root*
    has all privileges) when executing a file, any capability sets associated with
    the file are ignored. Instead, for the purposes of the algorithm shown in [Transformation
    of Process Capabilities During *exec()*](ch39.html#transformation_of_process_capabilities_d
    "Transformation of Process Capabilities During exec()"), the file capability sets
    are notionally defined as follows during an *exec()*:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在执行文件时保持传统的*root*用户语义（即*root*拥有所有权限），与文件相关的任何能力集都会被忽略。相反，为了在[执行过程能力转换](ch39.html#transformation_of_process_capabilities_d
    "Transformation of Process Capabilities During exec()")算法中，文件能力集在*exec()*期间会被假定为如下定义：
- en: If a set-user-ID-*root* program is being execed, or the real or effective user
    ID of the process calling *exec()* is 0, then the file inheritable and permitted
    sets are defined to be all ones.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果正在执行一个设置了用户ID为*root*的程序，或者调用*exec()*的进程的真实或有效用户ID是0，则文件的可继承集和允许集被定义为全1。
- en: If a set-user-ID-*root* program is being execed, or the effective user ID of
    the process calling *exec()* is 0, then the file effective bit is defined to be
    set.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果正在执行一个设置了用户ID为*root*的程序，或者调用*exec()*的进程的有效用户ID是0，则文件有效位被定义为已设置。
- en: 'Assuming that we are execing a set-user-ID-*root* program, these notional definitions
    of the file capability sets mean that the calculation of the process’s new permitted
    and effective capability sets in [Transformation of Process Capabilities During
    *exec()*](ch39.html#transformation_of_process_capabilities_d "Transformation of
    Process Capabilities During exec()") simplifies to the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在执行一个设置了用户ID为*root*的程序，那么这些假定的文件能力集定义意味着在[执行过程能力转换](ch39.html#transformation_of_process_capabilities_d
    "Transformation of Process Capabilities During exec()")中的进程新允许和有效能力集的计算可以简化为如下：
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Effect on Process Capabilities of Changing User IDs
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改用户ID对进程能力的影响
- en: 'To preserve compatibility with the traditional meanings for transitions between
    0 and nonzero user IDs, the kernel does the following when changing process user
    IDs (using *setuid()*, and so on):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持与传统含义的兼容性，内核在更改进程用户ID时（使用*setuid()*等方法）会执行以下操作：
- en: If the real user ID, effective user ID, or saved set-user-ID previously had
    the value 0 and, as a result of the changes to the user IDs, all three of these
    IDs have a nonzero value, then the permitted and effective capability sets are
    cleared (i.e., all capabilities are permanently dropped).
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如果真实用户 ID、有效用户 ID 或保存的用户 ID 之前的值为 0，并且由于用户 ID 的更改，这三个 ID 都变为非零值，则允许和有效的能力集将被清除（即，所有能力被永久丢弃）。  '
- en: If the effective user ID is changed from 0 to a nonzero value, then the effective
    capability set is cleared (i.e., the effective capabilities are dropped, but those
    in the permitted set can be raised again).
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如果有效用户 ID 从 0 更改为非零值，则有效能力集将被清空（即，有效能力被丢弃，但允许集中的能力可以再次提升）。  '
- en: If the effective user ID is changed from a nonzero value to 0, then the permitted
    capability set is copied into the effective capability set (i.e., all permitted
    capabilities become effective).
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如果有效用户 ID 从非零值更改为 0，则允许的能力集将被复制到有效能力集中（即，所有允许的能力变为有效）。  '
- en: 'If the file-system user ID is changed from 0 to a nonzero value, then the following
    file-related capabilities are cleared from the effective capability set: `CAP_CHOWN`,
    `CAP_DAC_OVERRIDE`, `CAP_DAC_READ_SEARCH`, `CAP_FOWNER`, `CAP_FSETID`, `CAP_LINUX_IMMUTABLE`
    (since Linux 2.6.30), `CAP_MAC_OVERRIDE`, and `CAP_MKNOD` (since Linux 2.6.30).
    Conversely, if the file-system user ID is changed from a nonzero value to 0, then
    any of these capabilities that are enabled in the permitted set are enabled in
    the effective set. These manipulations are done to maintain the traditional semantics
    for manipulations of the Linux-specific file-system user ID.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文件系统用户 ID 从 0 更改为非零值，则以下文件相关的能力将从有效能力集中清除：`CAP_CHOWN`、`CAP_DAC_OVERRIDE`、`CAP_DAC_READ_SEARCH`、`CAP_FOWNER`、`CAP_FSETID`、`CAP_LINUX_IMMUTABLE`（自
    Linux 2.6.30 起）、`CAP_MAC_OVERRIDE` 和 `CAP_MKNOD`（自 Linux 2.6.30 起）。相反，如果文件系统用户
    ID 从非零值更改为 0，则在允许集中启用的这些能力将被启用在有效集中。这些操作是为了保持对 Linux 特有的文件系统用户 ID 操作的传统语义。
- en: Changing Process Capabilities Programmatically
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '以编程方式更改进程能力  '
- en: 'A process can raise or drop capabilities from its capability sets using either
    the *capset()* system call or, preferably, the *libcap* API, which we describe
    below. Changes to process capabilities are subject to the following rules:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '进程可以使用 *capset()* 系统调用或更推荐的 *libcap* API 来提升或丢弃其能力集中的能力，下面我们将描述这些方法。进程能力的更改遵循以下规则：  '
- en: If the process doesn’t have the `CAP_SETPCAP` capability in its effective set,
    then the new *inheritable* set must be a subset of the combination of the existing
    inheritable and permitted sets.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如果进程的有效能力集没有 `CAP_SETPCAP` 能力，则新的 *可继承* 集必须是现有可继承集和允许集的组合的子集。  '
- en: The new *inheritable* set must be a subset of the combination of the existing
    inheritable set and the capability bounding set.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '新的 *可继承* 集必须是现有可继承集和能力边界集组合的子集。  '
- en: The new *permitted* set must be a subset of the existing permitted set. In other
    words, a process can’t grant itself permitted capabilities that it doesn’t have.
    Put another way, a capability dropped from the permitted set can’t be reacquired.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '新的 *允许* 集必须是现有允许集的子集。换句话说，进程不能授予自己没有的允许能力。换句话说，从允许集丢弃的能力不能重新获得。  '
- en: The new *effective* set is allowed to contain only capabilities that are also
    in the new permitted set.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '新的 *有效* 集仅允许包含新允许集中的能力。  '
- en: The *libcap* API
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '*libcap* API  '
- en: Up to this point, we have deliberately not shown the prototype of the *capset()*
    system call, or its counterpart *capget()*, which retrieves a process’s capabilities.
    This is because the use of these system calls should be avoided. Instead, the
    functions in the *libcap* library should be employed. These functions provide
    an interface that conforms with the withdrawn draft POSIX 1003.1e standard, along
    with some Linux extensions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '直到此时，我们故意没有显示 *capset()* 系统调用的原型，或其对应的 *capget()*，后者用于检索进程的能力。因为这些系统调用应该避免使用。相反，应该使用
    *libcap* 库中的函数。这些函数提供了一个符合撤回的 POSIX 1003.1e 草案标准，并带有一些 Linux 扩展的接口。  '
- en: 'For reasons of space, we don’t describe the *libcap* API in detail. As an overview,
    we note that programs employing these functions typically carry out the following
    steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '出于空间原因，我们不会详细描述 *libcap* API。概括来说，我们指出，使用这些函数的程序通常会执行以下步骤：  '
- en: Use the *cap_get_proc()* function to retrieve a copy of the process’s current
    capability sets from the kernel and place it in a structure that the function
    allocates in user space. (Alternatively, we may use the *cap_init()* function
    to create a new, empty capability set structure.) In the *libcap* API, the *cap_t*
    data type is a pointer used to refer to such structures.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*cap_get_proc()*函数从内核检索进程当前的能力集副本，并将其放入该函数在用户空间分配的结构中。（或者，我们可以使用*cap_init()*函数创建一个新的空能力集结构。）在*libcap*
    API中，*cap_t*数据类型是一个指针，用来引用这些结构。
- en: Use the *cap_set_flag()* function to update the user-space structure to raise
    (`CAP_SET`) and drop (`CAP_CLEAR`) capabilities from the permitted, effective,
    and inheritable sets stored in the user-space structure retrieved in the previous
    step.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*cap_set_flag()*函数更新用户空间结构，以提升（`CAP_SET`）和丢弃（`CAP_CLEAR`）从上一步中检索到的用户空间结构中的允许、有效和可继承能力集。
- en: Use the *cap_set_proc()* function to pass the user-space structure back to the
    kernel in order to change the process’s capabilities.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*cap_set_proc()*函数将用户空间结构传回内核，以改变进程的能力。
- en: Use the *cap_free()* function to free the structure that was allocated by the
    *libcap* API in the first step.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*cap_free()*函数释放由*libcap* API在第一步中分配的结构。
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, work is in progress on *libcap-ng*, a new, improved
    capabilities library API. Details can be found at [http://freshmeat.net/projects/libcap-ng](http://freshmeat.net/projects/libcap-ng).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写时，*libcap-ng*，一个改进版的能力库 API，仍在开发中。详情请访问[http://freshmeat.net/projects/libcap-ng](http://freshmeat.net/projects/libcap-ng)。
- en: Example program
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例程序
- en: In [Example 8-2](ch08.html#authenticating_a_user_against_the_shadow "Example 8-2. Authenticating
    a user against the shadow password file"), in [Summary](ch08.html#summary-id7
    "Summary"), we presented a program that authenticates a username plus password
    against the standard password database. We noted that the program requires privilege
    in order to read the shadow password file, which is protected to prevent reading
    by users other than *root* or members of the *shadow* group. The traditional way
    of providing this program with the privileges that it requires would be to run
    it under a *root* login or to make it a set-user-ID-*root* program. We now present
    a modified version of this program that employs capabilities and the *libcap*
    API.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 8-2](ch08.html#authenticating_a_user_against_the_shadow "示例 8-2。使用影子密码文件认证用户")和[总结](ch08.html#summary-id7
    "总结")中，我们展示了一个对用户名和密码进行验证的程序，验证内容是标准的密码数据库。我们提到，该程序需要特权才能读取影子密码文件，而该文件受保护，以防止除*root*或*shadow*组成员以外的用户读取。为该程序提供所需权限的传统方式是以*root*身份登录运行它，或者使其成为一个设置了用户ID为*root*的程序。我们现在展示一个修改版的程序，该程序使用了能力和*libcap*
    API。
- en: 'In order to read the shadow password file as a normal user, we need to bypass
    the standard file permission checks. Scanning the capabilities listed in [Table 39-1](ch39.html#operations_permitted_by_each_linux_capab
    "Table 39-1. Operations permitted by each Linux capability"), we see that the
    appropriate capability is `CAP_DAC_READ_SEARCH`. Our modified version of the password
    authentication program is shown in [Example 39-1](ch39.html#a_capability-aware_program_that_authenti
    "Example 39-1. A capability-aware program that authenticates a user"). This program
    uses the *libcap* API to raise `CAP_DAC_READ_SEARCH` in its effective capability
    set just before accessing the shadow password file, and then drops the capability
    again immediately after this access. In order for an unprivileged user to employ
    the program, we must set this capability in the file permitted capability set,
    as shown in the following shell session:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 为了作为普通用户读取影子密码文件，我们需要绕过标准的文件权限检查。在查看[表 39-1](ch39.html#operations_permitted_by_each_linux_capab
    "表 39-1。每个 Linux 能力允许的操作")列出的能力时，我们发现适当的能力是`CAP_DAC_READ_SEARCH`。我们修改后的密码认证程序版本展示在[示例
    39-1](ch39.html#a_capability-aware_program_that_authenti "示例 39-1。一个识别用户身份的能力感知程序")中。该程序在访问影子密码文件之前，使用*libcap*
    API提升`CAP_DAC_READ_SEARCH`到其有效能力集中，然后在访问后立即丢弃该能力。为了让一个非特权用户使用该程序，我们必须在文件允许的能力集中设置此能力，具体操作可见以下的
    shell 会话：
- en: '[PRE6]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Example 39-1. A capability-aware program that authenticates a user
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 39-1。一个识别用户身份的能力感知程序
- en: '[PRE7]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Creating Capabilities-Only Environments
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建仅具有能力的环境
- en: 'In the preceding pages, we have described various ways in which a process with
    the user ID 0 (*root*) is treated specially with respect to capabilities:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的页面中，我们描述了进程的用户 ID 为 0（*root*）时，在能力方面受到特殊对待的各种方式：
- en: When a process with one or more user IDs that equal 0 sets all of its user IDs
    to nonzero values, its permitted and effective capability sets are cleared. (See
    Section 39.6.)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个进程的一个或多个用户 ID 等于 0 并将其所有用户 ID 设置为非零值时，它的许可和有效能力集会被清除。（参见第 39.6 节。）
- en: When a process with an effective user ID of 0 changes that user ID to a nonzero
    value, it loses its effective capabilities. When the reverse change is made, the
    permitted capability set is copied to the effective set. A similar procedure is
    followed for a subset of capabilities when the process’s file-system user ID is
    switched between 0 and nonzero values. (See Section 39.6.)
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个有效用户 ID 为 0 的进程将该用户 ID 更改为非零值时，它会失去其有效能力。当进行反向更改时，许可能力集会被复制到有效集。对于当进程的文件系统用户
    ID 在 0 和非零值之间切换时，类似的过程也会发生。（参见第 39.6 节。）
- en: If a process with real or effective user ID of *root* execs a program, or any
    process execs a set-user-ID-*root* program, then the file inheritable and permitted
    sets are notionally defined to be all ones. If the process’s effective user ID
    is 0, or it is execing a set-user-ID-*root* program, then the file effective bit
    is notionally defined to be 1\. (See [Preserving *root* Semantics](ch39.html#preserving_root_semantics
    "Preserving root Semantics").) In the usual cases (i.e., both the real and effective
    user ID are *root*, or a set-user-ID-*root* program is being execed), this means
    the process gets all capabilities in its permitted and effective sets.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个具有真实或有效用户 ID 为 *root* 的进程执行一个程序，或者任何进程执行一个设置了用户 ID 为 *root* 的程序，则文件的可继承和许可集被认为是全
    1。如果进程的有效用户 ID 为 0，或者它正在执行一个设置了用户 ID 为 *root* 的程序，则文件的有效位被认为是 1。（参见 [保留 *root*
    语义](ch39.html#preserving_root_semantics "保留 root 语义")。）在通常情况下（即真实和有效用户 ID 都为 *root*，或正在执行一个设置了用户
    ID 为 *root* 的程序），这意味着该进程获得所有能力在其许可和有效集中的权限。
- en: In a fully capability-based system, the kernel would not need to perform any
    of these special treatments of *root*. There would be no set-user-ID-*root* programs,
    and file capabilities would be used to grant just the minimum capabilities that
    a program requires.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个完全基于能力的系统中，内核将不需要执行对 *root* 的任何特殊处理。将不会有设置用户 ID 为 *root* 的程序，并且文件能力将用于授予程序所需的最小能力。
- en: Since existing applications aren’t engineered to make use of the file-capabilities
    infrastructure, the kernel must maintain the traditional handling of processes
    with the user ID 0\. Nevertheless, we may want an application to run in a purely
    capability-based environment in which *root* gets none of the special treatments
    described above. Starting with kernel 2.6.26, and if file capabilities are enabled
    in the kernel, Linux provides the *securebits* mechanism, which controls a set
    of per-process flags that enable or disable each of the three special treatments
    for *root*. (To be precise, the *securebits* flags are actually a per-thread attribute.)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现有的应用程序并未设计成利用文件能力基础设施，内核必须保持对用户 ID 为 0 的进程的传统处理方式。尽管如此，我们可能希望某个应用程序运行在一个完全基于能力的环境中，在这个环境中，*root*
    不会受到上述任何特殊对待。从内核 2.6.26 开始，如果启用了文件能力，Linux 提供了 *securebits* 机制，该机制控制一组每个进程的标志，允许或禁用对
    *root* 的三种特殊处理方式。（准确来说，*securebits* 标志实际上是每个线程的属性。）
- en: The *securebits* mechanism controls the flags shown in [Table 39-2](ch39.html#the_securebits_flags
    "Table 39-2. The securebits flags"). The flags exist as related pairs of a *base*
    flag and a corresponding *locked* flag. Each of the base flags controls one of
    the special treatments of *root* described above. Setting the corresponding locked
    flag is a one-time operation that prevents further changes to the associated base
    flag—once set, the locked flag can’t be unset.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*securebits* 机制控制在 [表 39-2](ch39.html#the_securebits_flags "表 39-2. securebits
    标志") 中显示的标志。标志作为一对对的 *base* 标志和相应的 *locked* 标志存在。每个 *base* 标志控制上述对 *root* 的一种特殊处理。设置相应的锁定标志是一个一次性操作，它会阻止对关联的
    *base* 标志进一步更改——一旦设置，锁定标志就无法取消设置。'
- en: Table 39-2. The *securebits* flags
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 表 39-2. *securebits* 标志
- en: '| Flag | Meaning if set |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 设置时的含义 |'
- en: '| --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `SECBIT_KEEP_CAPS` | Don’t drop permitted capabilities when a process with
    one or more 0 user IDs sets all of its user IDs to nonzero values. This flag has
    an effect only if `SECBIT_NO_SETUID_FIXUP` is not also set. This flag is cleared
    on an *exec()*. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `SECBIT_KEEP_CAPS` | 当一个或多个用户 ID 为 0 的进程将其所有用户 ID 设置为非零值时，防止丢失已允许的能力。只有在未设置`SECBIT_NO_SETUID_FIXUP`的情况下，此标志才会生效。此标志会在*exec()*时被清除。|'
- en: '| `SECBIT_NO_SETUID_FIXUP` | Don’t change capabilities when effective or file-system
    user IDs are switched between 0 and nonzero values. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `SECBIT_NO_SETUID_FIXUP` | 在有效用户 ID 或文件系统用户 ID 在 0 和非零值之间切换时，不更改能力。|'
- en: '| `SECBIT_NOROOT` | If a process with a real or effective user ID of 0 does
    an *exec()*, or it execs a set-user-ID-*root* program, don’t grant it capabilities
    (unless the executable has file capabilities). |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `SECBIT_NOROOT` | 如果一个真实或有效用户 ID 为 0 的进程执行*exec()*，或者执行了一个设置了用户 ID 为*root*的程序，则不授予它能力（除非可执行文件具有文件能力）。|'
- en: '| `SECBIT_KEEP_CAPS_LOCKED` | Lock `SECBIT_KEEP_CAPS`. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `SECBIT_KEEP_CAPS_LOCKED` | 锁定`SECBIT_KEEP_CAPS`。|'
- en: '| `SECBIT_NO_SETUID_FIXUP_LOCKED` | Lock `SECBIT_NO_SETUID_FIXUP`. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `SECBIT_NO_SETUID_FIXUP_LOCKED` | 锁定`SECBIT_NO_SETUID_FIXUP`。|'
- en: '| `SECBIT_NOROOT_LOCKED` | Lock `SECBIT_NOROOT`. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `SECBIT_NOROOT_LOCKED` | 锁定`SECBIT_NOROOT`。|'
- en: The *securebits* flag settings are inherited in a child created by *fork()*.
    All of the flag settings are preserved during *exec()*, except `SECBIT_KEEP_CAPS`,
    which is cleared for historical compatibility with the `PR_SET_KEEPCAPS` setting,
    described below.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*securebits*标志设置会在通过*fork()*创建的子进程中继承。所有标志设置在*exec()*过程中都会被保留，除了`SECBIT_KEEP_CAPS`，它会被清除，以确保与`PR_SET_KEEPCAPS`设置的历史兼容性，如下所述。'
- en: 'A process can retrieve the *securebits* flags using the *prctl()* `PR_GET_SECUREBITS`
    operation. If a process has the `CAP_SETPCAP` capability, it can modify the *securebits*
    flags using the *prctl()* `PR_SET_SECUREBITS` operations. A purely capability-based
    application can irreversibly disable special treatment of *root* for the calling
    process and all of its descendants using the following call:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程可以通过*prctl()* `PR_GET_SECUREBITS`操作检索*securebits*标志。如果进程具有`CAP_SETPCAP`能力，它可以通过*prctl()*
    `PR_SET_SECUREBITS`操作修改*securebits*标志。一个完全基于能力的应用程序可以通过以下调用不可逆地禁用对调用进程及其所有后代的*root*特殊处理：
- en: '[PRE8]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After this call, the only way in which this process and its descendants can
    obtain capabilities is by executing programs that have file capabilities.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在此调用之后，该进程及其后代获取能力的唯一途径是执行具有文件能力的程序。
- en: '`SECBIT_KEEP_CAPS` and the *prctl()* `PR_SET_KEEPCAPS` operation'
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`SECBIT_KEEP_CAPS`和*prctl()* `PR_SET_KEEPCAPS`操作'
- en: The `SECBIT_KEEP_CAPS` flag prevents capabilities from being dropped when a
    process with one or more user IDs with the value 0 sets all of its user IDs to
    nonzero values. Roughly speaking, `SECBIT_KEEP_CAPS` provides half of the functionality
    provided by `SECBIT_NO_SETUID_FIXUP`. (As noted in [Table 39-2](ch39.html#the_securebits_flags
    "Table 39-2. The securebits flags"), `SECBIT_KEEP_CAPS` has an effect only if
    `SECBIT_NO_SETUID_FIXUP` is not set.) This flag exists to provide a *securebits*
    flag that mirrors the older *prctl()* `PR_SET_KEEPCAPS` operation, which controls
    the same attribute. (The one difference between the two mechanisms is that a process
    doesn’t need the `CAP_SETPCAP` capability to employ the *prctl()* `PR_SET_KEEPCAPS`
    operation.)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`SECBIT_KEEP_CAPS`标志可以防止当一个或多个用户 ID 为 0 的进程将其所有用户 ID 设置为非零值时丢失能力。大致来说，`SECBIT_KEEP_CAPS`提供了`SECBIT_NO_SETUID_FIXUP`所提供功能的一半。（如[表39-2](ch39.html#the_securebits_flags
    "表39-2. securebits标志")所述，`SECBIT_KEEP_CAPS`只有在未设置`SECBIT_NO_SETUID_FIXUP`时才会生效。）此标志的存在是为了提供一个与旧版*prctl()*
    `PR_SET_KEEPCAPS`操作相对应的*securebits*标志，二者控制相同的属性。（这两种机制的唯一区别是，进程不需要`CAP_SETPCAP`能力就可以使用*prctl()*
    `PR_SET_KEEPCAPS`操作。）'
- en: Note
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Earlier, we noted that all of the *securebits* flags are preserved during an
    *exec()*, except `SECBIT_KEEP_CAPS`. The setting of the `SECBIT_KEEP_CAPS` bit
    was made the converse of the other *securebits* settings in order to maintain
    consistency with the treatment of the attribute set by the *prctl()* `PR_SET_KEEPCAPS`
    operation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们提到过，所有*securebits*标志在*exec()*过程中都会被保留，除了`SECBIT_KEEP_CAPS`。设置`SECBIT_KEEP_CAPS`标志是为了与其他*securebits*设置保持一致，反向处理*prctl()*
    `PR_SET_KEEPCAPS`操作设置的属性。
- en: The *prctl()* `PR_SET_KEEPCAPS` operation is designed for use by set-user-ID-*root*
    programs running on older kernels that don’t support file capabilities. Such programs
    can still improve their security by programmatically dropping and raising capabilities
    as required (refer to [Older Kernels and Systems Without File Capabilities](ch39.html#older_kernels_and_systems_without_file_c
    "Older Kernels and Systems Without File Capabilities")).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*prctl()* `PR_SET_KEEPCAPS`操作是为运行在不支持文件能力的旧内核上的设置了用户ID为*root*的程序设计的。这类程序仍然可以通过编程的方式根据需要丢弃和提升能力，从而提高其安全性（参考[不支持文件能力的旧内核和系统](ch39.html#older_kernels_and_systems_without_file_c
    "不支持文件能力的旧内核和系统")）。'
- en: 'However, even if such a set-user-ID-*root* program drops all capabilities except
    those that it requires, it still maintains two important privileges: the ability
    to access files owned by *root* and the ability to regain capabilities by execing
    a program ([Preserving *root* Semantics](ch39.html#preserving_root_semantics "Preserving
    root Semantics")). The only way of permanently dropping these privileges is to
    set all of the process’s user IDs to nonzero values. But doing that normally results
    in the clearing of the permitted and effective capability sets (see the four points
    in [Effect on Process Capabilities of Changing User IDs](ch39.html#effect_on_process_capabilities_of_changi
    "Effect on Process Capabilities of Changing User IDs") concerning the effect of
    user ID changes on capabilities). This defeats the purpose, which is to permanently
    drop user ID 0, while maintaining some capabilities. To allow this possibility,
    the *prctl()* `PR_SET_KEEPCAPS` operation can be used to set the process attribute
    that prevents the permitted capability set from being cleared when all user IDs
    are changed to a nonzero value. (The process’s effective capability set is always
    cleared in this case, regardless of the setting of the “keep capabilities” attribute.)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使这样一个设置了用户ID为*root*的程序丢弃了除了所需的能力之外的所有能力，它仍然保持着两个重要的特权：访问*root*拥有的文件的能力，以及通过执行程序恢复能力的能力（[保持*root*语义](ch39.html#preserving_root_semantics
    "保持 root 语义")）。永久丢弃这些特权的唯一方法是将进程的所有用户ID设置为非零值。但这样做通常会导致许可和有效能力集被清除（请参见[更改用户ID对进程能力的影响](ch39.html#effect_on_process_capabilities_of_changi
    "更改用户ID对进程能力的影响")，其中提到用户ID变化对能力的影响）。这与目标相悖，目标是永久丢弃用户ID 0，同时保留一些能力。为了实现这一目标，可以使用*prctl()*
    `PR_SET_KEEPCAPS`操作来设置进程属性，防止在所有用户ID更改为非零值时清除许可能力集。（在这种情况下，进程的有效能力集始终会被清除，无论“保持能力”属性如何设置。）
- en: Discovering the Capabilities Required by a Program
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发现程序所需的能力
- en: 'Suppose we have a program that is unaware of capabilities and that is provided
    only in binary form, or we have a program whose source code is too large for us
    to easily read to determine which capabilities might be required to run it. If
    the program requires privileges, but shouldn’t be a set-user-ID-*root* program,
    then how can we determine the permitted capabilities to assign to the executable
    file with *setcap(8)*? There are two ways to answer this question:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个不关心能力的程序，并且该程序仅以二进制形式提供，或者我们有一个源代码过于庞大的程序，难以轻松阅读并确定其运行时可能需要哪些能力。如果程序需要特权，但不应当成为设置了用户ID为*root*的程序，那么我们如何确定应当分配给可执行文件的许可能力，并使用*setcap(8)*进行设置呢？回答这个问题有两种方法：
- en: Use *strace(1)* ([Appendix A](apa.html "Appendix A. Tracing System Calls"))
    to see which system call fails with the error `EPERM`, the error used to indicate
    the lack of a required capability. By consulting the system call’s manual page
    or the kernel source code, we can then deduce what capability is required. This
    approach isn’t perfect, because an `EPERM` error can occasionally be generated
    for other reasons, some of which may have nothing to do with the capability requirements
    for the program. Furthermore, programs may legitimately make a system call that
    requires privilege, and then change their behavior after determining that they
    don’t have privilege for a particular operation. It can sometimes be difficult
    to distinguish such “false positives” when trying to determine the capabilities
    that an executable really does need.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 *strace(1)* （[附录 A](apa.html "附录 A：系统调用追踪")）查看哪个系统调用因错误 `EPERM` 失败，该错误用于指示缺少所需的能力。通过查阅系统调用的手册页或内核源代码，我们可以推断出需要的能力。然而，这种方法并不完美，因为
    `EPERM` 错误有时也会由于其他原因产生，其中一些可能与程序所需的能力要求无关。此外，程序可能合法地执行一个需要特权的系统调用，然后在确定它们没有特定操作的特权后改变行为。在确定可执行文件实际需要的能力时，有时很难区分这种“假阳性”情况。
- en: Use a kernel probe to produce monitoring output when the kernel is asked to
    perform capability checks. An example of how to do this is provided in [Hallyn,
    2007], an article written by one of the developers of file capabilities. For each
    request to check a capability, the probe shown in the article logs the kernel
    function that was called, the capability that was requested, and the name of the
    requesting program. Although this approach requires more work than the use of
    *strace(1)*, it can also help us more accurately determine the capabilities that
    a program requires.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内核探针，在内核执行能力检查时产生监控输出。如何实现这一点的示例见于 [Hallyn, 2007]，这是一篇由文件能力开发者之一撰写的文章。对于每个检查能力的请求，文章中的探针会记录被调用的内核函数、请求的能力以及请求程序的名称。尽管这种方法比使用
    *strace(1)* 需要更多工作，但它也可以帮助我们更准确地确定程序所需的能力。
- en: Older Kernels and Systems Without File Capabilities
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旧版内核和没有文件能力的系统
- en: 'In this section, we describe various differences in the implementation of capabilities
    in older kernels. We also describe the differences that occur on kernels where
    file capabilities are not supported. There are two scenarios where Linux doesn’t
    support file capabilities:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了在较旧内核中实现能力的各种差异。我们还描述了在不支持文件能力的内核上发生的差异。Linux 不支持文件能力的情况有两种：
- en: Before Linux 2.6.24, file capabilities were not implemented.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux 2.6.24 之前，文件能力未实现。
- en: Since Linux 2.6.24, file capabilities can be disabled if the kernel is built
    without the `CONFIG_SECURITY_FILE_CAPABILITIES` option.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自 Linux 2.6.24 起，如果内核在构建时未启用 `CONFIG_SECURITY_FILE_CAPABILITIES` 选项，则可以禁用文件能力。
- en: Note
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Although Linux introduced capabilities and allowed them to be attached to processes
    starting with kernel 2.2, the implementation of file capabilities appeared only
    several years later. The reasons that file capabilities remained unimplemented
    for so long were matters of policy, rather than technical difficulties. (Extended
    attributes, described in [Chapter 16](ch16.html "Chapter 16. Extended Attributes"),
    which are used to implement file capabilities, had been available since kernel
    2.6.) The weight of opinion among kernel developers was that requiring system
    administrators to set and monitor different sets of capabilities—some of whose
    consequences are subtle but far-reaching—for each privileged program would create
    an unmanageably complex administration task. By contrast, system administrators
    are familiar with the existing UNIX privilege model, know to treat set-user-ID
    programs with due caution, and can locate the set-user-ID and set-group-ID programs
    on a system using simple *find* commands. Nevertheless, the developers of file
    capabilities made the case that file capabilities could be made administratively
    workable, and eventually provided a convincing enough argument that file capabilities
    were integrated into the kernel.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Linux自2.2版本起引入了能力并允许它们附加到进程上，但文件能力的实现直到几年后才出现。文件能力未实现如此长时间的原因是政策问题，而非技术困难。（用于实现文件能力的扩展属性，自2.6版本起就已可用，详见[第16章](ch16.html
    "第16章 扩展属性")。）内核开发人员的普遍观点是，要求系统管理员为每个特权程序设置和监控不同的能力集——其中一些后果细微但深远——会导致管理任务变得复杂且无法管理。相反，系统管理员熟悉现有的UNIX特权模型，知道要小心对待set-user-ID程序，并且可以使用简单的*find*命令定位系统中的set-user-ID和set-group-ID程序。然而，文件能力的开发者认为，文件能力可以通过行政管理得以实现，最终提供了一个足够有说服力的论据，使得文件能力被整合到内核中。
- en: The `CAP_SETPCAP` capability
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`CAP_SETPCAP`能力'
- en: On kernels that don’t support file capabilities (i.e., any kernel before 2.6.24,
    and kernels since 2.6.24 with file capabilities disabled), the semantics of the
    `CAP_SETPCAP` capability are different. Subject to rules that are analogous to
    those described in [Changing Process Capabilities Programmatically](ch39.html#changing_process_capabilities_programmat
    "Changing Process Capabilities Programmatically"), a process that has the `CAP_SETPCAP`
    capability in its effective set can theoretically change the capabilities of processes
    other than itself. Changes can be made to the capabilities of another process,
    all of the members of a specified process group, or all processes on the system
    except *init* and the caller itself. The final case excludes *init* because it
    is fundamental to the operation of the system. It also excludes the caller because
    the caller may be attempting to remove capabilities from every other process on
    the system, and we don’t want to remove the capabilities from the calling process
    itself.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在不支持文件能力的内核上（即，所有2.6.24之前的内核，以及自2.6.24以来禁用了文件能力的内核），`CAP_SETPCAP`能力的语义是不同的。根据类似于[以编程方式更改进程能力](ch39.html#changing_process_capabilities_programmat
    "以编程方式更改进程能力")中描述的规则，具有`CAP_SETPCAP`能力的进程可以理论上改变其他进程的能力。可以对另一个进程、指定进程组的所有成员，或除*init*进程和调用者本身外的系统上所有进程的能力进行更改。最后一个情况排除了*init*进程，因为它对于系统的操作至关重要。也排除了调用者，因为调用者可能试图从系统上每个其他进程中移除能力，而我们不希望移除调用者自身的能力。
- en: However, changing the capabilities of other processes is only a theoretical
    possibility. On older kernels, and on modern kernels where support for file capabilities
    is disabled, the capability bounding set (discussed next) always masks out the
    `CAP_SETPCAP` capability.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，改变其他进程的能力仅仅是一个理论上的可能性。在较老的内核上，以及在禁用了文件能力支持的现代内核上，能力边界集（接下来会讨论）总是会屏蔽`CAP_SETPCAP`能力。
- en: The capability bounding set
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 能力边界集
- en: Since Linux 2.6.25, the capability bounding set is a per-process attribute.
    However, on older kernels, the capability bounding set is a system-wide attribute
    that affects all processes on the system. The system-wide capability bounding
    set is initialized so that it always masks out `CAP_SETPCAP` (described above).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 自Linux 2.6.25版本以来，能力边界集是每个进程的属性。然而，在较老的内核上，能力边界集是一个系统范围的属性，影响系统上的所有进程。系统范围的能力边界集会初始化为始终屏蔽`CAP_SETPCAP`（如上所述）。
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On kernels after 2.6.25, removing capabilities from the per-process bounding
    set is supported only if file capabilities are enabled in the kernel. In that
    case, *init*, the ancestor of all processes, starts with a bounding set containing
    all capabilities, and a copy of that bounding set is inherited by other processes
    created on the system. If file capabilities are disabled, then, because of the
    differences in the semantics of `CAP_SETPCAP` described above, *init* starts with
    a bounding set that contains all capabilities except `CAP_SETPCAP`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.6.25之后的内核中，只有在内核启用了文件能力的情况下，才能从每个进程的边界集中移除能力。在这种情况下，*init*，作为所有进程的祖先，开始时具有包含所有能力的边界集，并且该边界集的副本会被其他在系统上创建的进程继承。如果禁用了文件能力，则由于上述`CAP_SETPCAP`语义的差异，*init*将以包含所有能力的边界集启动，除了`CAP_SETPCAP`。
- en: There is one further change in the semantics of the capability bounding set
    in Linux 2.6.25\. As noted earlier ([Capability Bounding Set](ch39.html#capability_bounding_set
    "Capability Bounding Set")), on Linux 2.6.25 and later, the per-process capability
    bounding set acts as a limiting superset for the capabilities that can be added
    to the process’s inheritable set. In Linux 2.6.24 and earlier, the system-wide
    capability bounding set doesn’t have this masking effect. (It is not needed, because
    these kernels don’t support file capabilities.)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux 2.6.25及以后的版本中，能力边界集的语义发生了进一步的变化。正如之前所提到的（[能力边界集](ch39.html#capability_bounding_set
    "能力边界集")），在Linux 2.6.25及更高版本中，每个进程的能力边界集充当着可以添加到进程可继承集合中的能力的限制超集。在Linux 2.6.24及更早版本中，系统范围的能力边界集没有这种掩码效果。（这并不需要，因为这些内核不支持文件能力。）
- en: The system-wide capability bounding set is accessible via the Linux-specific
    `/proc/sys/kernel/cap-bound` file. A process must have the `CAP_SYS_MODULE` capability
    to be able to change the contents of `cap-bound`. However, only the *init* process
    can turn bits on in this mask; other privileged processes can only turn bits off.
    The upshot of these limitations is that on a system where file capabilities are
    not supported, we can never give the `CAP_SETPCAP` capability to a process. This
    is reasonable, since that capability can be used to subvert the entire kernel
    privilege-checking system. (In the unlikely case that we want to change this limitation,
    we must either load a kernel module that changes the value in the set, modify
    the source code of the *init* program, or change the initialization of the capability
    bounding set in the kernel source code and perform a kernel rebuild.)
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 系统范围的能力边界集可以通过Linux特定的`/proc/sys/kernel/cap-bound`文件访问。一个进程必须具有`CAP_SYS_MODULE`能力才能更改`cap-bound`的内容。然而，只有*init*进程能够在此掩码中打开位；其他特权进程只能关闭位。这些限制的结果是，在不支持文件能力的系统上，我们永远无法将`CAP_SETPCAP`能力赋予某个进程。这是合理的，因为该能力可以用来破坏整个内核权限检查系统。（在不太可能的情况下，如果我们希望更改此限制，我们必须加载一个内核模块来更改集合中的值，修改*init*程序的源代码，或者更改内核源代码中能力边界集的初始化并进行内核重建。）
- en: Note
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Confusingly, although it is a bit mask, the value in the system-wide cap-bound
    file is displayed as a signed decimal number. For example, the initial value of
    this file is -257\. This is the two’s complement interpretation of the bit mask
    with all bits except *(1 << 8)* turned on (i.e., in binary, 11111111 11111111
    11111110 11111111); `CAP_SETPCAP` has the value 8.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 令人困惑的是，尽管它是一个位掩码，但系统范围的`cap-bound`文件中的值以带符号的十进制数显示。例如，该文件的初始值是-257\。这是将位掩码的所有位（除了*(1
    << 8)*）都打开时的二进制补码表示（即，二进制为11111111 11111111 11111110 11111111）；`CAP_SETPCAP`的值为8。
- en: Using capabilities within a program on a system without file capabilities
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在没有文件能力的系统上使用程序中的功能
- en: 'Even on a system that doesn’t support file capabilities, we can nevertheless
    employ capabilities to improve the security of a program. We do this as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在不支持文件能力的系统上，我们仍然可以利用能力来提高程序的安全性。我们通过以下方式做到这一点：
- en: Run the program in a process with an effective user ID of 0 (typically a set-user-ID-*root*
    program). Such a process is granted all capabilities (except `CAP_SETPCAP`, as
    noted earlier) in its permitted and effective sets.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以有效用户ID为0的进程（通常是set-user-ID-*root*程序）来运行该程序。此类进程在其许可和有效集合中被授予所有能力（除了之前提到的`CAP_SETPCAP`）。
- en: On program startup, use the *libcap* API to drop all capabilities from the effective
    set, and drop all capabilities except those that we may later need from the permitted
    set.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序启动时，使用*libcap* API从有效集合中丢弃所有能力，并从许可集合中丢弃所有不再需要的能力，除了可能稍后需要的那些。
- en: Set the `SECBIT_KEEP_CAPS` flag (or use the *prctl()* `PR_SET_KEEPCAPS` operation
    to achieve the same result), so that the next step does not drop capabilities.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 `SECBIT_KEEP_CAPS` 标志（或使用 *prctl()* `PR_SET_KEEPCAPS` 操作实现相同的效果），以确保下一步不会丢失能力。
- en: Set all user IDs to nonzero values, to prevent the process from accessing files
    owned by *root* or gaining capabilities by doing an *exec()*.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置所有用户 ID 为非零值，以防止进程访问 *root* 拥有的文件或通过执行 *exec()* 获取能力。
- en: Note
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We could replace the two preceding steps by a single step that sets the `SECBIT_NOROOT`
    flag, if we want to prevent the process from regaining privileges on an *exec()*,
    but must allow it to access files owned by *root*. (Of course, allowing access
    to files owned by *root* leaves open the risk of some security vulnerability.)
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们希望防止进程在 *exec()* 时重新获得特权，但又必须允许它访问 *root* 拥有的文件，我们可以通过设置 `SECBIT_NOROOT`
    标志来替代前面两步的操作。（当然，允许访问 *root* 拥有的文件会带来某些安全漏洞的风险。）
- en: During the rest of the program’s lifetime, use the *libcap* API to raise and
    drop the remaining permitted capabilities from the effective set as needed in
    order to perform privileged tasks.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序生命周期的剩余部分，根据需要使用 *libcap* API 来提升和删除有效集中的剩余允许能力，以执行特权任务。
- en: Some applications built for Linux kernels before version 2.6.24 employed this
    approach.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一些为 Linux 2.6.24 之前版本的内核构建的应用程序使用了这种方法。
- en: Note
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Among the kernel developers who argued against the implementation of capabilities
    for executable files, one of the perceived virtues of the approach described in
    the main text was that the developer of an application knows which capabilities
    an executable requires. By contrast, a system administrator may not be able to
    easily determine this information.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在反对为可执行文件实现能力的内核开发者中，主文中描述的方法的一个优点是，应用程序开发者知道可执行文件需要哪些能力。相比之下，系统管理员可能无法轻松确定这一信息。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: The Linux capabilities scheme divides privileged operations into distinct categories,
    and allows a process to be granted some capabilities, while being denied others.
    This scheme represents an improvement over the traditional all-or-nothing privilege
    mechanism, whereby a process has either privileges to perform all operations (user
    ID 0) or no privileges (nonzero user ID). Since kernel 2.6.24, Linux supports
    attaching capabilities to files, so that a process can gain selected capabilities
    by execing a program.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 能力机制将特权操作分为不同的类别，并允许一个进程获得某些能力，同时拒绝其他能力。这个机制相对于传统的全有或全无特权机制有了改进，在传统机制中，进程要么拥有执行所有操作的特权（用户
    ID 为 0），要么没有任何特权（非零用户 ID）。自内核 2.6.24 版本起，Linux 支持将能力附加到文件上，这样进程可以通过执行程序来获取所选的能力。
- en: Exercise
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Modify the program in [Example 35-2](ch35.html#modifying_process_scheduling_policies_an
    "Example 35-2. Modifying process scheduling policies and priorities") (`sched_set.c`,
    in [Privileges and resource limits affecting changes to scheduling parameters](ch35.html#privileges_and_resource_limits_affecting
    "Privileges and resource limits affecting changes to scheduling parameters"))
    to use file capabilities, so that it can be used by an unprivileged user.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 [示例 35-2](ch35.html#modifying_process_scheduling_policies_an "示例 35-2. 修改进程调度策略和优先级")
    中的程序（`sched_set.c`，位于 [影响调度参数变化的特权和资源限制](ch35.html#privileges_and_resource_limits_affecting
    "影响调度参数变化的特权和资源限制")），使其使用文件能力，以便可以由非特权用户使用。
