["```\nint a = 2 * 3;\n```", "```\nint b;\n```", "```\nfoo = 3 * 3;\n```", "```\n1 + a * 2;\n```", "```\nx = 3;\narray[2] = 100;\nmy_struct.member = x * 2;\n```", "```\n4 = 5;\nfoo && bar = 6;\na - 5 = b;\n```", "```\nexp = Constant(int)\n    **| Var(identifier)**\n    | Unary(unary_operator, exp)\n    | Binary(binary_operator, exp, exp)\n    **| Assignment(exp, exp)**\n```", "```\nstatement = Return(exp) **| Expression(exp) | Null**\n```", "```\nchar *s;\n/* ... */\nwhile ( ❶ *s++ != '\\0')\n  ❷ ;\n```", "```\ndeclaration = Declaration(identifier name, exp? init)\n```", "```\nif (a == 2)\n    return 4;\n```", "```\nif (a == 2)\n    int x = 0;\n```", "```\nif (a == 2) {\n    int x = 0;\n    return x;\n}\n```", "```\nint main(void) {\n    int a;\n    a = 2;\n    return a * 2;\n}\n```", "```\nfunction_definition = Function(identifier name, statement body)\n```", "```\nblock_item = S(statement) | D(declaration)\n```", "```\nfunction_definition = Function(identifier name, **block_item*** body)\n```", "```\nprogram = Program(function_definition)\nfunction_definition = Function(identifier name, **block_item*** body)\n**block_item = S(statement) | D(declaration)**\n**declaration = Declaration(identifier name, exp? init)**\nstatement = Return(exp) **| Expression(exp) | Null**\nexp = Constant(int)\n    **| Var(identifier)**\n    | Unary(unary_operator, exp)\n    | Binary(binary_operator, exp, exp)\n    **| Assignment(exp, exp)**\nunary_operator = Complement | Negate | Not\nbinary_operator = Add | Subtract | Multiply | Divide | Remainder | And | Or\n                | Equal | NotEqual | LessThan | LessOrEqual\n                | GreaterThan | GreaterOrEqual\n```", "```\n<program> ::= <function>\n<function> ::= \"int\" <identifier> \"(\" \"void\" \")\" \"{\" **{<block-item>}** \"}\"\n**<block-item> ::= <statement> | <declaration>**\n**<declaration> ::= \"int\" <identifier> [\"=\" <exp>] \";\"**\n<statement> ::= \"return\" <exp> \";\" **| <exp> \";\" | \";\"**\n<exp> ::= <factor> | <exp> <binop> <exp>\n<factor> ::= <int> **| <identifier>** | <unop> <factor> | \"(\" <exp> \")\"\n<unop> ::= \"-\" | \"~\" | \"!\"\n<binop> ::= \"-\" | \"+\" | \"*\" | \"/\" | \"%\" | \"&&\" | \"||\"\n          | \"==\" | \"!=\" | \"<\" | \"<=\" | \">\" | \">=\" **| \"=\"**\n<identifier> ::= ? An identifier token ?\n<int> ::= ? A constant token ?\n```", "```\nparse_function_definition(tokens):\n    // parse everything up through the open brace as before...\n    `--snip--`\n    function_body = []\n    while peek(tokens) != \"}\":\n        next_block_item = parse_block_item(tokens)\n        function_body.append(next_block_item)\n    take_token(tokens)\n    return Function(name, function_body)\n```", "```\nparse_exp(tokens, min_prec):\n    left = parse_factor(tokens)\n    next_token = peek(tokens)\n    while next_token is a binary operator and precedence(next_token) >= min_prec:\n        operator = parse_binop(tokens)\n        right = parse_exp(tokens, ❶ precedence(next_token) + 1)\n        left = Binary(operator, left, right)\n        next_token = peek(tokens)\n    return left\n```", "```\nright = parse_exp(tokens, precedence(next_token))\n```", "```\nparse_exp(tokens, min_prec):\n    left = parse_factor(tokens)\n    next_token = peek(tokens)\n    while next_token is a binary operator and precedence(next_token) >= min_prec:\n        **if next_token is \"=\":**\n            **take_token(tokens) // remove \"=\" from list of tokens**\n            **right = parse_exp(tokens, precedence(next_token))**\n            **left = Assignment(left, right)**\n        **else:**\n            operator = parse_binop(tokens)\n            right = parse_exp(tokens, precedence(next_token) + 1)\n            left = Binary(operator, left, right)\n        next_token = peek(tokens)\n    return left\n```", "```\n2 = a * 3; // ERROR: can't assign a value to a constant\n```", "```\nint a = 3;\nint a; // ERROR: a has already been declared!\n```", "```\nint main(void) {\n    a = 4; // ERROR: a has not been declared yet!\n    return a;\n}\n```", "```\nint main(void) {\n    int a = 4;\n    int b = a + 1;\n    a = b - 5;\n    return a + b;\n}\n```", "```\nint main(void) {\n    int a0 = 4;\n    int b1 = a0 + 1;\n    a0 = b1 - 5;\n    return a0 + b1;\n}\n```", "```\nint main(void) {\n    int a = 2;\n    if (a < 5) {\n        int a = 7;\n        return a;\n    }\n    return a;\n}\n```", "```\nint main(void) {\n    int a0 = 2;\n    if (a0 < 5) {\n        int a1 = 7;\n        return a1;\n    }\n    return a0;\n}\n```", "```\nresolve_declaration(Declaration(name, init), variable_map):\n  ❶ if name is in variable_map:\n        fail(\"Duplicate variable declaration!\")\n    unique_name = make_temporary()\n  ❷ variable_map.add(name, unique_name)\n  ❸ if init is not null:\n        init = resolve_exp(init, variable_map)\n  ❹ return Declaration(unique_name, init)\n```", "```\nresolve_statement(statement, variable_map):\n    match statement with\n    | Return(e) -> return Return(resolve_exp(e, variable_map))\n    | Expression(e) -> return Expression(resolve_exp(e, variable_map))\n    | Null -> return Null\n```", "```\nresolve_exp(e, variable_map):\n    match e with\n    | Assignment(left, right) ->\n        if left is not a Var node:\n            fail(\"Invalid lvalue!\")\n        return Assignment( ❶ resolve_exp(left, variable_map), ❷ resolve_exp(right, variable_map))\n    | Var(v) ->\n        if v is in variable_map:\n            return Var( ❸ variable_map.get(v))\n        else:\n            fail(\"Undeclared variable!\")\n    | `--snip--`\n```", "```\nemit_tacky(e, instructions):\n    match e with\n    | `--snip--`\n    | Var(v) -> return Var(v)\n    | Assignment(Var(v), rhs) ->\n        result = emit_tacky(rhs, instructions)\n        instructions.append(Copy(result, Var(v)))\n        return Var(v)\n```", "```\nint main(void) {\n    int b;\n    int a = 10 + 1;\n    b = a * 2;\n    return b;\n}\n```", "```\ntmp.2 = 10 + 1\na.1 = tmp.2\ntmp.3 = a.1 * 2\nb.0 = tmp.3\nReturn(b.0)\n```", "```\nint main(void) {\n    int a = 4;\n    a = 0;\n}\n```", "```\nint main(void) {\n    int a = 4;\n    a = 0;\n    **return 0;**\n}\n```", "```\n#include <stdio.h>\n\nint foo(void) {\n    printf(\"I'm living on the edge, baby!\");\n    // no return statement\n}\n\nint main(void) {\n    return foo(); // try to use return value from foo\n}\n```", "```\n#include <stdio.h>\n\nint foo(void) {\n    printf(\"I'm living on the edge, baby!\");\n    // no return statement\n}\n\nint main(void) {\n    foo();\n    return 0;\n}\n```", "```\n$ **./test_compiler** `**/path/to/your_compiler**` **--chapter 5 --extra-credit**\n```", "```\n$ **./test_compiler** `**/path/to/your_compiler**` **--chapter 5 --bitwise --compound --increment**\n```"]