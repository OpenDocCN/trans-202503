- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: 'Gettin’ Nerdy with It: Advanced Power Analysis'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 跟技术过招：高级功率分析
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: The previous two chapters, and power analysis literature in general, focused
    on theoretical understanding of the attacks and applying them in lab conditions.
    As people who have witnessed a plethora of such attacks, we can tell you that
    for the majority of actual targets, 10 percent of your time is spent getting the
    measurement set up in order; 10 percent of your time is running actual power analysis
    attacks, and the other 80 percent of your time is spent trying to figure out why
    the attacks are not showing any leakage. That is because your attack will show
    leakage only if you got every step from trace acquisition to trace analysis correct,
    and until you actually find leakage, it can be difficult to determine which step
    was wrong in the first place. In reality, power analysis requires patience, sprinkled
    with a lot of step analysis, a bunch of trial and error, and topped off with computing
    power. This chapter is more about the *art* of power analysis than the science.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 前两章以及一般的功率分析文献，集中于对攻击的理论理解和在实验室条件下的应用。作为那些亲眼见证了大量此类攻击的人，我们可以告诉你，对于大多数实际目标来说，你的时间有10%会花在设置测量设备的过程中；10%的时间会用来进行实际的功率分析攻击，其余的80%则是花费在试图弄明白攻击为什么没有泄漏信号上。这是因为，只有当你从踪迹获取到踪迹分析的每一步都做对了，攻击才会显示泄漏；而在你实际找到泄漏之前，很难确定最初的哪一步出了问题。实际上，功率分析需要耐心，配合大量的步骤分析，一系列的试错，并且需要强大的计算能力。本章更侧重于功率分析的*艺术*而非科学。
- en: In practice, you’ll need some extra tools to overcome the various obstacles
    that a real-life target will throw at you. These obstacles will largely determine
    how difficult it will be to extract a secret from a device successfully. Some
    properties inherent in the target you’re testing will affect the signal and noise
    characteristics, as will properties like programmability, device complexity and
    clock speed, type of side channel, and countermeasures. When measuring a software
    implementation of AES on a microcontroller, you’ll probably be able to identify
    the individual encryption rounds from a single trace with one eye closed and a
    hand behind your back. When you’re measuring a hardware AES running at 800 MHz
    embedded in a full System-on-Chip (SoC), forget about ever seeing the encryption
    rounds in a single trace. Many parallel processes cause amplitude noise—never
    mind that the leakage signal is extremely small. The simplest AES implementations
    may break in less than 100 traces and 5 minutes of analysis, whereas the most
    complex attacks we’ve seen succeed have passed beyond a billion(!) traces and
    months of analysis—and, sometimes the attack still fails.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你需要一些额外的工具来克服实际目标所带来的各种障碍。这些障碍在很大程度上决定了从设备中成功提取机密信息的难度。目标本身的一些固有特性会影响信号和噪声特性，像可编程性、设备复杂性、时钟速度、旁道类型和防护措施等特性也会有影响。当你在微控制器上测量AES的软件实现时，你可能仅需闭一只眼、把手放在背后，就能从一个迹象中识别出单独的加密轮次。但当你测量嵌入在800
    MHz的全系统芯片（SoC）上的硬件AES时，别指望在一个迹象中看到加密轮次。许多并行处理会导致幅度噪声——更不用说泄漏信号本身就非常微小了。最简单的AES实现可能在不到100个迹象和5分钟的分析时间内就被破解，而我们见过的最复杂攻击成功的例子，则已经超过了十亿(!)个迹象和几个月的分析——有时，攻击仍然会失败。
- en: In the next sections, we’ll provide tools to apply in various situations and
    a general recipe for how to approach the entire power analysis topic. Equipped
    with these tools, it’s up to you to find out if, when, and how to apply them on
    your favorite target. As such, this chapter is a bit of a mixed bag. First, we
    discuss a number of more powerful attacks and provide references. Next, we dive
    into a number of ways to measure key extraction success and how to measure improvements
    in your setup. Then, we talk about measuring real devices, as opposed to some
    easy lab-based, full-control targets. After that, there is a section on trace
    analysis and processing, and, finally, we provide some additional references.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将提供一些工具，以便在不同的情况下应用，并提供一个关于如何处理整个功率分析话题的一般方法。装备了这些工具后，接下来就取决于你来判断是否、何时以及如何将它们应用到你最喜欢的目标上。因此，本章有点像是一个混合包。首先，我们讨论一些更强大的攻击方法并提供参考文献。接着，我们深入探讨了几种衡量密钥提取成功与否的方法，以及如何衡量你设置的改进。然后，我们讨论了如何测量真实设备，而非一些简单的、实验室中完全可控的目标。接下来是关于踪迹分析和处理的部分，最后，我们提供了一些额外的参考资料。
- en: The Main Obstacles
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要障碍
- en: Power analysis comes in various flavors. We’ll refer to *simple power analysis
    (SPA)*, *differential power analysis (DPA)*, and the *correlation power attack
    (CPA)* in this chapter, or simply to *power analysis* when a statement applies
    to all three.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 电源分析有多种形式。在本章中，我们将提到*简单功耗分析（SPA）*，*差分功耗分析（DPA）*以及*相关功耗攻击（CPA）*，或者简称为*功耗分析*，当一种声明适用于这三种情况时。
- en: 'The differences between theory and attacking actual devices are significant.
    You’ll meet your main obstacles when doing actual power analysis. These obstacles
    include the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 理论与攻击实际设备之间的差异是显著的。在进行实际功率分析时，您将会遇到主要障碍。这些障碍包括以下几点：
- en: '**Amplitude noise**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**幅度噪声**'
- en: This is the hiss you hear when listening to AM radio transmissions, the noise
    from all the other electrical components in your setup, or the random noise added
    as a countermeasure. Various parts of your measurement setup will cause it, but
    non-interesting-yet-parallel operations in the actual device will also end up
    in your measurement. You’ll encounter amplitude noise in all measurements you
    take, and it’s a problem to your power attack because it obscures the actual power
    variations due to data leakage. For CPA, it causes your correlation peak to decrease
    in amplitude.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在听AM无线电传输时听到的嘶嘶声，你设置中所有其他电子组件的噪音，或者作为对策添加的随机噪声。你测量设置的各个部分会导致它，但实际设备中非感兴趣但并行的操作也会出现在你的测量中。你在进行的所有测量中都会遇到幅度噪声，它对功率攻击构成问题，因为它会掩盖由数据泄露引起的实际功率变化。对于CPA，它会导致您的相关峰值幅度降低。
- en: '**Temporal noise (also known as misalignment)**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**时间噪声（也称为错位）**'
- en: Timing jitter caused by oscilloscope triggering or nonconstant time paths to
    your target operation result in the operation of interest appearing at different
    times with each trace. This jitter affects a correlation power attack because
    the attack assumes that the leakage always appears at the same time index. The
    jitter has the undesired effect of widening your correlation peak and decreasing
    its amplitude.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由示波器触发或非恒定时间路径导致目标操作的时间抖动，使得感兴趣的操作在每次跟踪时出现不同的时间。这种抖动会影响相关功耗攻击，因为攻击假设泄露始终在相同的时间索引处出现。抖动会产生不良影响，扩大您的相关峰值并降低其幅度。
- en: '**Side-channel countermeasures**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**侧信道对策**'
- en: 'Yes, chip and device vendors also read this book. The unintentional noise sources
    just described can also be introduced by device designers intentionally to decrease
    the effectiveness of a power attack. Not only are noise sources introduced, but
    the leakage signals are decreased by using algorithms and chip designs such as
    masking and blinding (see Thomas S. Messerges’s “Securing the AES Finalists Against
    Power Analysis Attacks”), constant key rotation in a protocol (see Pankaj Rohatgi’s
    “Leakage Resistant Encryption and Decryption”), as well as constant power circuits
    (see Thomas Popp and Stefan Mangard’s “Masked Dual-Rail Pre-charge Logic: DPA-Resistance
    Without Routing Constraints”) and SCA-resistant cell libraries (see Kris Tiri
    and Ingrid Verbauwhede’s “A Logic Level Design Methodology for a Secure DPA Resistant
    ASIC or FPGA Implementation”).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '是的，芯片和设备供应商也会阅读本书。刚刚描述的无意噪声源也可以由设备设计者有意引入，以降低功率攻击的有效性。不仅引入噪声源，而且还通过使用掩蔽和盲化算法以及芯片设计（参见Thomas
    S. Messerges的“Securing the AES Finalists Against Power Analysis Attacks”）、协议中的常量密钥旋转（参见Pankaj
    Rohatgi的“Leakage Resistant Encryption and Decryption”）、以及常量功率电路（参见Thomas Popp和Stefan
    Mangard的“Masked Dual-Rail Pre-charge Logic: DPA-Resistance Without Routing Constraints”）和SCA抗性单元库（参见Kris
    Tiri和Ingrid Verbauwhede的“A Logic Level Design Methodology for a Secure DPA Resistant
    ASIC or FPGA Implementation”）来减少泄露信号。'
- en: Don’t despair, though. For each source of noise or countermeasure, a tool exists
    to recover at least some fraction of the leakage. As an attacker, your goal is
    to combine all these tools into a successful attack; as a defender, your goal
    is to present sufficient countermeasures that cause your attacker to run out of
    resources like skill, time, patience, computing power, and disk space.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，请不要绝望。对于每种噪声源或对策，都有工具可以恢复至少一部分泄露。作为攻击者，您的目标是将所有这些工具结合起来进行成功的攻击；作为防御者，您的目标是提供足够的对策，使得攻击者在技能、时间、耐心、计算能力和磁盘空间等资源上耗尽。
- en: More Powerful Attacks
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更强大的攻击
- en: What we’ve described so far about power analysis are actually some of the more
    basic attacks in the field. A variety of more powerful attacks exist, and many
    are well beyond the scope of this chapter. Nevertheless, we don’t want to leave
    you on the wrong side of the Dunning-Kruger curve of actual knowledge versus perceived
    knowledge. We want to make sure you have sufficient knowledge to know that you
    don’t have all the knowledge.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们所描述的关于功耗分析的内容，实际上是该领域中一些较为基础的攻击方式。还有各种更强大的攻击方式，许多已经超出了本章的范围。然而，我们不希望你在实际知识与感知知识的邓宁-克鲁格效应曲线的错误一侧。我们希望确保你有足够的知识，知道自己并不是拥有所有的知识。
- en: Everything you have learned up to now has used a *leakage model*. This model
    made some basic assumptions—for example, that greater power being drawn can mean
    that more wires are set high. A more powerful method is the template attack (see
    Suresh Chari, Josyula R. Rao, and Pankaj Rohatgi’s “Template Attacks”). In a *template
    attack*, instead of assuming a leakage model, you measure it directly from a device
    for which you know the data (and key!) being processed. The knowledge of the data
    and key provides you with an indication of the power used for a range of known
    data values, which is encoded in a template for each value. A template of known
    data values helps you recognize the unknown data values on the same or similar
    device.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止你学到的一切都是使用了*泄漏模型*。这个模型做了一些基本假设——例如，更大的功耗可能意味着更多的线路被拉高。一种更强大的方法是模板攻击（参见Suresh
    Chari, Josyula R. Rao和Pankaj Rohatgi的《模板攻击》）。在*模板攻击*中，与你假设泄漏模型不同，你直接从已知数据（以及密钥！）正在处理的设备上进行测量。数据和密钥的知识为你提供了一个指示，显示在已知数据值范围内使用的功耗，这些信息被编码在每个值的模板中。已知数据值的模板帮助你识别在相同或类似设备上未知的数据值。
- en: Making such a template model means you need a device you can completely control
    by setting your own key values and allowing the desired encryption to occur. The
    practicability of this approach varies because it may be difficult to reprogram
    your target device, or you may have only a single copy of the target that you
    can’t reprogram to generate templates. Other times, like with generic microcontrollers,
    you could access as many programmable devices as you need.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 制作这样的模板模型意味着你需要一个设备，可以通过设置自己的密钥值并允许所需的加密过程发生，从而完全控制它。这种方法的实用性因设备而异，因为可能难以重新编程目标设备，或者你可能只有目标设备的一个副本，无法重新编程以生成模板。其他情况下，比如通用微控制器，你可以访问需要的多个可编程设备。
- en: 'The advantage of template attacks is that they operate on a more precise model
    than CPA and, therefore, can perform key retrieval in fewer traces, possibly revealing
    an entire encryption key with just a *single encryption operation*. Another advantage
    is that if the device you’re attacking is performing some nonstandard algorithm,
    a template attack doesn’t require you to have a model for the leakage. The downside
    of these more powerful attacks is the computational complexity and memory requirements,
    which are greater than a simple correlation with a Hamming weight. Therefore,
    choosing whether to use templates or other techniques, such as *linear regression*
    (see Julien Doget, Emmanuel Prouff, Matthieu Rivain, and François-Xavier Standaert’s
    “Univariate Side Channel Attacks and Leakage Modeling”), *mutual information analysis*
    (see Benedikt Gierlichs, Lejla Batina, Pim Tuyls, and Bart Preneel’s “Mutual Information
    Analysis”), *deep learning* (see Guilherme Perin, Baris Ege, and Jasper van Woudenberg’s,
    “Lowering the Bar: Deep Learning for Side-Channel Analysis”), or *differential
    cluster analysis* (see Lejla Batina, Benedikt Gierlichs, and Kerstin Lemke-Rust’s
    “Differential Cluster Analysis”), depends on what is required or available in
    your attack circumstances, such as having the least number of traces, the shortest
    wall clock time, the least computational complexity, lesser human analysis, and
    any number of other circumstances.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 模板攻击的优势在于，它们比 CPA 操作在更精确的模型上，因此可以在更少的痕迹中执行密钥恢复，可能只需要*一次加密操作*就能揭示整个加密密钥。另一个优势是，如果你攻击的设备使用的是某种非标准算法，模板攻击不需要你为泄漏提供模型。这些更强大的攻击的缺点是计算复杂性和内存要求，通常比简单的与
    Hamming 权重的相关性要大。因此，选择使用模板或其他技术，如*线性回归*（参见 Julien Doget、Emmanuel Prouff、Matthieu
    Rivain 和 François-Xavier Standaert 的《单变量侧信道攻击和泄漏建模》）、*互信息分析*（参见 Benedikt Gierlichs、Lejla
    Batina、Pim Tuyls 和 Bart Preneel 的《互信息分析》）、*深度学习*（参见 Guilherme Perin、Baris Ege
    和 Jasper van Woudenberg 的《降低门槛：深度学习在侧信道分析中的应用》）或*差分聚类分析*（参见 Lejla Batina、Benedikt
    Gierlichs 和 Kerstin Lemke-Rust 的《差分聚类分析》），取决于你的攻击情况所需或可用的条件，如最少的痕迹数、最短的墙钟时间、最低的计算复杂性、更少的人工分析以及其他各种情况。
- en: In terms of more practical tips, Victor Lomné, Emmanuel Prouff, and Thomas Roche
    wrote “Behind the Scene of Side Channel Attacks — Extended Version,” which contains
    many tips on various attacks. Specifically, *conditional leakage averaging* for
    CPA can save a lot of time. You can find an implementation of it and various other
    algorithms as part of Riscure’s open source Jlsca project at [https://github.com/Riscure/Jlsca/](https://github.com/Riscure/Jlsca/).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在更实际的建议方面，Victor Lomné、Emmanuel Prouff 和 Thomas Roche 写了《Side Channel Attacks
    背后的场景 - 扩展版》，其中包含了许多关于各种攻击的技巧。特别是，*条件泄漏平均*对于 CPA 可以节省大量时间。你可以在 Riscure 的开源 Jlsca
    项目中找到它的实现及其他各种算法，网址是 [https://github.com/Riscure/Jlsca/](https://github.com/Riscure/Jlsca/)。
- en: At the end of this chapter, we’ll discuss further references.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束时，我们将进一步讨论参考资料。
- en: Measuring Success
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测量成功
- en: How we measure success in life is a topic prone to philosophical ramblings.
    Fortunately, engineers and scientists have little time for ramblings, so here
    are a variety of methods that allow us to measure the success of side-channel
    analysis attacks. We’ll discuss several data types and graphs you are likely to
    run into during your further research.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何衡量生活中的成功是一个容易引发哲学性长篇大论的话题。幸运的是，工程师和科学家没有太多时间去空谈，所以这里列出了一些方法，让我们能够衡量侧信道分析攻击的成功。我们将讨论在进一步研究中可能会遇到的几种数据类型和图表。
- en: Success Rate–Based Metrics
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于成功率的度量标准
- en: One of the original metrics used in academia was based on the success rate of
    the attack. The most basic version of it might be to test how many traces are
    required for an attack that *completely recovers the encryption key*. This metric
    generally isn’t too useful. If you’re just doing a single trial, it might be that
    you got exceptionally lucky; usually it would take more traces than what you have
    reported.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在学术界最初使用的度量标准之一是基于攻击成功率的。最基本的版本可能是测试进行一次攻击所需的痕迹数量，以*完全恢复加密密钥*。这个度量标准通常不是特别有用。如果你只做了一次试验，可能是你非常幸运；通常，所需的痕迹数量会超过你报告的数量。
- en: To counter this unrealistic situation, we use plots of the success rate versus
    number of traces. We will first refer to the *global success rate (GSR)*, which
    provides the percentage of attacks that successfully recovered the complete key
    for a particular number of traces. [Figure 11-1](#figure11-1) shows a sample GSR
    graph.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这种不现实的情况，我们使用成功率与轨迹数量的图表。我们首先会提到*全局成功率（GSR）*，它表示在给定数量的轨迹下，成功恢复完整密钥的攻击所占的百分比。[图
    11-1](#figure11-1)展示了一个示例 GSR 图。
- en: '![f11001](image_fi/278748c11/f11001.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![f11001](image_fi/278748c11/f11001.png)'
- en: 'Figure 11-1: Sample graph of global success rate for a leaky AES-256 target'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-1：泄露的 AES-256 目标的全局成功率示例图
- en: The graph in [Figure 11-1](#figure11-1) shows that if we had 40 traces recorded
    from the device, we would expect to recover the complete encryption key about
    80 percent of the time. We can find this metric simply by performing the experiment
    on the device many times, ideally with different encryption keys in case certain
    values of the key generate more leakage than other keys do.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-1](#figure11-1)中的图表显示，如果我们从设备记录了 40 个轨迹，我们预计会在约 80% 的情况下恢复完整的加密密钥。我们可以通过多次在设备上执行该实验来简单地找到这个度量，理想情况下还应使用不同的加密密钥，以防某些密钥值比其他密钥产生更多泄漏。'
- en: Rather than using the GSR, we might also plot the *partial success rate*. Here,
    *partial* means that we are considering each of the 16 bytes in the AES-128 key
    independently of the other bytes, which provides 16 values, each representing
    the probability of recovering the correct value for one particular byte, given
    a fixed number of traces.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 GSR，我们还可以绘制*部分成功率*。这里的*部分*意味着我们将 AES-128 密钥中的每一个字节独立地考虑，而不考虑其他字节，这样就得到了
    16 个值，每个值代表在给定数量的轨迹下，恢复某一个字节的正确值的概率。
- en: The global success rate could be misleading because in some particular implementations,
    one of the key bytes might not leak. The GSR, thus, will always be zero, since
    the entire encryption key is never recovered, but plots of the partial success
    rate will reveal whether only one of the 16 bytes cannot be recovered. We could
    then brute-force that last byte within 1 second, whereas a zero GSR would not
    have revealed a real probability of recovering the key.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 全局成功率可能会产生误导，因为在某些特定实现中，可能有一个密钥字节不会泄露。因此，GSR 将始终为零，因为整个加密密钥永远无法恢复，但部分成功率的图表将揭示是否只有
    16 个字节中的一个无法恢复。然后，我们可以在 1 秒钟内对最后一个字节进行暴力破解，而零 GSR 并未揭示恢复密钥的真实概率。
- en: Entropy-Based Metrics
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于熵的度量
- en: Entropy-based metrics are based on the principle that we can do some guessing
    to recover the key. The original AES-128 key would require, on average, 0.5 ×
    2^(128) guesses to recover the key without any prior knowledge. This number is
    so large, the key cannot be computed before the cluster brute-forcing the key
    will be melted and/or eaten by the sun as it transforms into a red giant (about
    5 billion years from now).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 基于熵的度量基于这样一个原理：我们可以通过一些猜测来恢复密钥。没有任何先验知识的情况下，恢复原始的 AES-128 密钥平均需要 0.5 × 2^(128)
    次猜测。这个数字如此之大，在暴力破解密钥的集群被熔化和/或被太阳吞噬成红巨星之前（大约 50 亿年后），密钥是无法计算出来的。
- en: The outcome of a side-channel analysis attack provides more information than
    a simple “key is XYZ” or “key not found.” In fact, each key guess has a confidence
    level associated with it—the confidence that a key guess is correct relative to
    a particular analysis method. In CPA, this confidence value is the absolute value
    of the correlation of that particular key guess. The outcome of a CPA attack on
    one byte of an AES-128 key is therefore a ranked list of key guesses with confidence
    levels, with our best guess at the top and worst guess at the bottom.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助通道分析攻击的结果提供的信息比简单的“密钥是 XYZ”或“未找到密钥”要多。事实上，每一个密钥猜测都有一个与之相关的置信度——即相对于某一分析方法，猜测该密钥正确的置信度。在
    CPA 中，这个置信度值是该特定密钥猜测的相关性的绝对值。因此，针对 AES-128 密钥的某一个字节进行 CPA 攻击的结果是一个带有置信度水平的密钥猜测排名列表，最佳猜测排在最上面，最差的猜测排在最底部。
- en: Let’s say that using a power analysis attack, we know the actual key byte is
    in the top three of each list. Then there are in total 3^(16) guesses to make
    for the key, which is about 43 million, so it can easily be done on a smartphone.
    We have, thus, reduced the entropy. The original key was a random collection of
    bits, but we now have some information about the most likely state of certain
    bits and can use this to speed up the brute-force attack.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用功率分析攻击，知道实际的密钥字节在每个列表的前三名中。那么，针对密钥的总共需要进行3^(16)次猜测，约为4300万次，因此它可以很容易地在智能手机上完成。因此，我们已经减少了熵。原始密钥是随机的一组比特，但我们现在对某些比特的最可能状态有了一些信息，并可以利用这些信息加速暴力破解攻击。
- en: 'The easiest plot to represent this is the *partial guessing entropy (PGE)*.
    The PGE asks the following question: after you performed the attack with a certain
    number of traces, how many key guesses were incorrectly ranked as more likely
    than the correct key value? If you are doing key guesses for each byte, you will
    have a PGE value for each byte of the key; for AES-128, you will end up with 16
    PGE plots. PGE provides information about the reduction in key-search space being
    made by the side-channel attack. [Figure 11-2](#figure11-2) shows an example of
    such a plot.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的图形表示方式是*部分猜测熵（PGE）*。PGE提问如下问题：在用一定数量的跟踪进行攻击后，有多少个关键猜测被错误地排名为比正确的关键值更可能？如果你对每个字节进行关键猜测，你将为每个字节的密钥得到一个PGE值；对于AES-128，你将得到16个PGE图。PGE提供了关于侧信道攻击减少的密钥搜索空间的信息。[图11-2](#figure11-2)展示了这样的图形示例。
- en: The graph in [Figure 11-2](#figure11-2) also averages all the 16 PGE plots to
    get an average PGE for the attack. The partial guessing entropy can be a little
    misleading, as we might not have an ideal way to combine guessing across all keys.
    For instance, if for one key byte the correct value is ranked first, and for a
    second key byte ranked third, we still need to take a worst-case assumption and
    brute-force all top three candidates. Such a brute-force attack very quickly becomes
    impossible, however, if the PGE is not even across all bytes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-2](#figure11-2)中的图形还将所有16个PGE图平均，以得到攻击的平均PGE。部分猜测熵可能会有些误导，因为我们可能没有理想的方式来结合所有密钥的猜测。例如，如果对于一个密钥字节，正确的值排名第一，而对于第二个密钥字节排名第三，我们仍然需要做出最坏情况下的假设，并对所有前三个候选值进行暴力破解。然而，如果PGE在所有字节中不均匀分布，进行这样的暴力破解攻击很快会变得不可能。'
- en: '![f11002](image_fi/278748c11/f11002.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![f11002](image_fi/278748c11/f11002.png)'
- en: 'Figure 11-2: Partial guessing entropy'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-2：部分猜测熵
- en: Algorithms for ideally combining the output of the attack exist, and they can
    be used to generate a true total guessing entropy (see Nicholas Veyrat-Charvillon,
    Benoît Gérard, François-Xavier Standaert’s “Security Evaluations Beyond Computing
    Power”). The total guessing entropy provides exact details of the reduction of
    the guessing space of the key that resulted from running the attack algorithm.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 存在理想的算法来结合攻击的输出，它们可以用来生成真正的总猜测熵（参见Nicholas Veyrat-Charvillon, Benoît Gérard,
    François-Xavier Standaert的《超越计算能力的安全评估》）。总猜测熵提供了关于通过运行攻击算法减少密钥猜测空间的详细信息。
- en: Correlation Peak Progression
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相关性峰值进展
- en: Another format is to plot the correlation of each key guess over a number of
    traces. This method is designed to show the progression of the amplitude of correlation
    peaks over time; see [Figure 11-3](#figure11-3) as an example. It shows for each
    key guess what the correlation peak is when we increase the number of traces.
    For wrong key guesses, this correlation will trend toward zero, whereas for the
    right key guess, it will trend toward the actual level of leakage.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种格式是绘制每个关键猜测在多个跟踪中的相关性。此方法旨在展示相关性峰值随时间的变化过程；参见[图11-3](#figure11-3)作为示例。它显示了每个关键猜测在我们增加跟踪数量时的相关性峰值。对于错误的关键猜测，这个相关性将趋向于零，而对于正确的关键猜测，它将趋向于实际的泄漏水平。
- en: '![f11003](image_fi/278748c11/f11003.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![f11003](image_fi/278748c11/f11003.png)'
- en: 'Figure 11-3: Plots of correlation peak vs. trace number show the correct guess.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-3：相关性峰值与跟踪数量的图表展示了正确的猜测。
- en: This graph removes information about at which point in time the maximum correlation
    peak occurred, but it now shows how that peak becomes differentiated from the
    “wrong guesses.” The point where the correct peak crosses over all the incorrect
    guesses is considered to be where the algorithm was broken. Plots of correlation
    output against the trace number show the correct key guess slowly evolving out
    of the noise of incorrect key guesses.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 该图去除了关于最大相关峰值发生时刻的信息，但现在显示了该峰值如何从“错误猜测”中区分开来。正确峰值交叉所有错误猜测的点被认为是算法被破解的地方。将相关输出与轨迹编号进行对比，显示了正确的密钥猜测如何从错误猜测的噪声中慢慢脱颖而出。
- en: An advantage of the graph shown in [Figure 11-3](#figure11-3) is that it indicates
    the margin between the incorrect and the correct guess. If that margin is large,
    you can be more confident that the attack will be successful in general.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-3](#figure11-3)中显示的图表的一个优点是它表示了错误猜测和正确猜测之间的差距。如果这个差距很大，你可以更有信心地认为攻击通常会成功。'
- en: Correlation Peak Height
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相关峰值高度
- en: 'The success metrics described so far provide an idea of how close you are to
    key extraction, but they do not help much in debugging your setup or trace-processing
    approach. For those tasks, there is one simple approach: looking at the output
    traces from the attack algorithm, such as correlation traces for CPA (or t-traces
    for TVLA, which we discuss later). These output traces are one of the main ways
    to improve your setup or processing.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止描述的成功度量提供了一个关于你距离密钥提取有多近的概念，但它们对于调试你的设置或跟踪处理方法帮助不大。对于这些任务，有一个简单的方法：查看攻击算法的输出轨迹，例如
    CPA 的相关轨迹（或者稍后我们讨论的 TVLA 的 t-轨迹）。这些输出轨迹是改进你的设置或处理的主要方式之一。
- en: The plot you make, such as in [Figure 11-4](#figure11-4), highlights all the
    correlation traces of incorrect key guesses in one color and the correct key guess
    in another color.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你所绘制的图，例如[图11-4](#figure11-4)，会将所有错误的密钥猜测的相关轨迹用一种颜色表示，而正确的密钥猜测用另一种颜色突出显示。
- en: '![f11004](image_fi/278748c11/f11004.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![f11004](image_fi/278748c11/f11004.png)'
- en: 'Figure 11-4: Plot of the raw output from the attack algorithm'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-4：攻击算法的原始输出图
- en: '[Figure 11-4](#figure11-4) shows that the correct key guess has the largest
    correlation peak, and it also provides the time index of this peak. This plot
    shows correlation as a function of time, where the correct key guess is highlighted
    in dark gray in the figure, and the incorrect guesses are light gray. Overlaying
    this plot with power traces can be useful for visualizing where the leakage happens.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-4](#figure11-4)显示了正确的密钥猜测具有最大的相关峰值，并提供了该峰值的时间索引。此图展示了相关性与时间的关系，其中正确的密钥猜测在图中以深灰色突出显示，错误的猜测则是浅灰色。将此图与功率轨迹叠加，可以有效地可视化泄漏发生的位置。'
- en: This type of plotting comes in very handy when you are optimizing your setup.
    Simply calculate the plot before and after you change one of your acquisition
    parameters or processing steps. If the peak gets stronger, you’ve improved your
    side-channel attack; if it decreases, it has gotten worse.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的绘图在优化设置时非常有用。只需在更改一个采集参数或处理步骤之前和之后计算图表。如果峰值变得更强，说明你的侧信道攻击得到了改进；如果峰值减弱，说明情况变得更糟。
- en: Measurements on Real Devices
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真实设备上的测量
- en: When the time comes to measure a real device—not a simple experimental platform
    designed for side-channel analysis—you need to make some additional considerations.
    This section briefly outlines them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备测量一个真实设备——而不是一个为侧信道分析设计的简单实验平台时——你需要做一些额外的考虑。本节简要概述了这些考虑事项。
- en: Device Operation
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备操作
- en: The first step in attacking a real device is operating it. The requirements
    for doing so depend on the attack you are performing, but we can give you some
    general guidance and hints on running crypto operations and choosing what inputs
    to send.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击真实设备的第一步是操作它。执行此操作的要求取决于你所进行的攻击，但我们可以为你提供一些关于运行加密操作和选择要发送的输入的总体指导和提示。
- en: Initiating Encryption
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启动加密
- en: Real devices may not provide an “encrypt this block” function. Part of the work
    in side-channel analysis attacks is to determine exactly how to attack such devices.
    For example, if we’re attacking a bootloader that authenticates firmware before
    decrypting it, we cannot just send random input data to decrypt. However, for
    power analysis, often just knowing the ciphertext or the plaintext is sufficient.
    In this case, we can just feed the original firmware image, which will pass the
    authenticity check and will then be decrypted. Since we know the ciphertext of
    the firmware, we can still perform a power attack.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 真实设备可能没有提供“加密此块”功能。在侧信道分析攻击中，部分工作是确定如何攻击此类设备。例如，如果我们正在攻击一个在解密固件之前进行认证的引导加载程序，我们不能仅仅发送随机输入数据来解密。然而，对于功率分析，通常仅知道密文或明文就足够了。在这种情况下，我们可以直接提供原始固件镜像，这样它就会通过真实性检查，然后被解密。由于我们知道固件的密文，我们仍然可以进行功率攻击。
- en: Similarly, many devices will have a challenge-response-based authentication
    function. These functions typically require you to respond to a random nonce value
    by encrypting it. The device will separately also encrypt the nonce. Now the device
    can verify whether the response from you was encrypted properly, thereby proving
    you share the same key as the device. If you send the device a random garbage
    value, the authentication check will ultimately fail. However, that failure is
    irrelevant; we have captured the nonce and the power signal of the device during
    encryption. If we collect a set of those signals, it could give us sufficient
    information for a power analysis attack. Proper implementations will include rate
    limiting or a fixed number of tries to avoid this attack.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，许多设备将具有基于挑战-响应的认证功能。这些功能通常要求你通过加密一个随机的 nonce 值来进行响应。设备也会单独加密这个 nonce。现在，设备可以验证你发送的响应是否被正确加密，从而证明你与设备共享相同的密钥。如果你向设备发送一个随机的垃圾值，认证检查最终会失败。然而，这种失败并不重要；我们已经在加密过程中捕获了设备的
    nonce 和功率信号。如果我们收集到一组这些信号，它可以为我们提供足够的信息来进行功率分析攻击。正确的实现通常会包括速率限制或固定尝试次数来避免此类攻击。
- en: Another problem when dealing with device communication will be timing the acquisition.
    As demonstrated previously, we don’t care about finding the exact moment the encryption
    happened, as the CPA attack will reveal this for us (assuming alignment, but we’ll
    talk about that later). We do need to get within the general vicinity of the correct
    timing (for example, by triggering our oscilloscope based on when we send the
    last packet of an encrypted block). We don’t know when the encryption occurs,
    but we do know that it clearly must occur sometime between sending that block
    and the device sending back a response message.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 处理设备通信时的另一个问题是时序捕获。正如之前所示，我们不关心找出加密发生的确切时刻，因为 CPA 攻击会为我们揭示这个时刻（假设对齐，但我们稍后会讨论）。我们确实需要接近正确时序（例如，通过在发送加密块的最后一个数据包时触发示波器）。我们不知道加密发生的确切时刻，但我们知道，它必须发生在发送该数据块和设备返回响应消息之间的某个时刻。
- en: Triggering based on sniffing I/O lines will be more difficult. Often the easiest
    way is to implement a custom device that monitors the I/O lines for the relevant
    activity. You could program a microcontroller simply to read all data being sent
    and set an I/O pin high when it detects the desired byte(s), which in turn triggers
    the oscilloscope.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 基于嗅探 I/O 线路的触发将会更困难。通常最简单的方法是实现一个自定义设备，监控 I/O 线路上的相关活动。你可以简单地编程一个微控制器，读取所有正在发送的数据，并在检测到期望的字节时将
    I/O 引脚置高，从而触发示波器。
- en: Starting and capturing the operation is mostly an engineering hurdle, but it’s
    important to make it as stable and jitter-free as possible. Jittery timing behavior
    results in timing noise and other issues down the line, which may make it impossible
    to do proper analysis of the traces later.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 启动和捕获操作主要是一个工程难题，但重要的是要尽可能保持其稳定性并避免抖动。抖动的时序行为会导致时序噪声和其他后续问题，这可能会使得之后无法对跟踪进行适当的分析。
- en: Repeating and Separating Operations
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重复和分离操作
- en: Another trick to remember is that if you have programmatic control over your
    target, it helps to get many operations in a single trace. You can do this by
    making the number of times that the target operation is called within one trace
    an input variable in your protocol. The simplest trick is to put a loop around
    the call to the operation on the target itself. In some cases, you can have it
    loop at a lower level by, for instance, giving an AES-ECB encryption engine a
    large number of blocks to encrypt.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个记忆技巧是，如果你能对目标进行程序控制，那么在单次跟踪中获取多个操作会更有帮助。你可以通过将目标操作在一次跟踪中被调用的次数作为协议中的输入变量来实现这一点。最简单的技巧是将一个循环包裹在对目标本身操作的调用周围。在某些情况下，你可以通过让它在更低的层级进行循环，例如，给AES-ECB加密引擎一个需要加密的大量数据块。
- en: Now, if you perform acquisitions with an increasing number of calls to the target
    operation (for instance, by doubling it every trace), you’ll soon start to see
    an expansion where the crypto operations are being performed. This happens because
    although a single crypto operation may be an invisible blip, the more operations
    you do, the longer they will take. At some point, it becomes visible in your trace.
    You then can easily pinpoint the timing of the operation and calculate the average
    duration of a single operation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在增加目标操作调用次数的同时进行采集（例如，每次跟踪时调用次数加倍），你很快就会看到加密操作所在的区域扩展。这是因为，尽管单个加密操作可能是一个不可见的波动，但你执行的操作越多，它们所需的时间就越长。到某个点时，它们会在你的跟踪中变得可见。然后，你可以轻松地确定操作的时间点，并计算单个操作的平均持续时间。
- en: It may also be worthwhile to experiment with a variable delay loop (or nop slide;
    *nop* means a no-operation, which effectively causes the processor to do nothing
    for a very specific amount of time) in between the operations. Once the previous
    trick has shown you the timing, you can use that information to separate the individual
    operation calls, which can actually help to detect leaks, because the leakage
    from one operation does not then bleed into successive operations.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以尝试在操作之间使用一个可变延迟循环（或者空操作滑动；*nop*表示无操作，实际上让处理器在特定时间内什么也不做）。一旦前面的技巧向你展示了时间信息，你可以利用这些信息将单独的操作调用分开，这实际上有助于检测泄露，因为一个操作的泄露不会渗透到后续操作中。
- en: From Random Inputs to Chosen Inputs
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从随机输入到选择性输入
- en: 'Up to now, we’ve been inputting fully random data into our crypto algorithms,
    which provides good properties for the CPA calculation. Some specific attacks
    require chosen inputs, like certain attacks on AES (see Kai Schramm, Gregor Leander,
    Patrick Felke, and Christof Paar’s “A Collision-Attack on AES: Combining Side
    Channel- and Differential-Attack”) or for the intermediate round variant of test
    vector leakage assessment (TVLA) using Welch’s t-test (more details in the “Test
    Vector Leakage Assessment” section later in this chapter).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在将完全随机的数据输入到加密算法中，这为CPA计算提供了良好的属性。一些特定的攻击需要选择性输入，比如对AES的某些攻击（请参见Kai
    Schramm、Gregor Leander、Patrick Felke和Christof Paar的《AES的碰撞攻击：结合侧信道攻击与差分攻击》）或使用Welch的t检验的中间轮次变体的测试向量泄漏评估（更多细节请参见本章稍后的“测试向量泄漏评估”部分）。
- en: Without going into the details of why (we will later), you can create a number
    of different sets during trace acquisition, such as measurements associated with
    constant or random input data, and various carefully chosen inputs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入探讨其原因（稍后会讨论），你可以在跟踪采集过程中创建不同的集合，例如与常数或随机输入数据相关的测量，以及各种精心选择的输入。
- en: You’ll be doing various statistical analyses on these sets, so it’s crucially
    important that the only statistically relevant differences between your sets are
    caused by differences in your input data. In reality, trace acquisition campaigns
    that run for more than a few hours will have detectable changes in perhaps the
    average power level (see the “Analysis Techniques” section later in this chapter).
    If you measure set A at minute 0 and set B at minute 60, your statistics will
    surely show power differences between those sets. These power differences may
    appear to be insignificant until you discover that suspected leakage is in fact
    due to your air conditioning kicking in at minute 59 and cooling the target device,
    and not due to a leaky target. Whenever you do statistical analysis over several
    sets, you must make sure there is no accidental correlation with anything but
    the input data. This means that for each trace you measure, you must randomly
    select for which set you want to generate input. You also do *not* even want the
    target to know for which set you are doing a measurement; all it needs to know
    is the data on which to operate. If you send the target information regarding
    the set, it will show up in your traces. If you interleave the sets instead of
    choose them randomly, it will show up in your traces. These uninteresting correlations
    are extremely hard to debug, as they will show up as (false) leakage, so you should
    work hard at avoiding them. You are detecting extremely small changes in power,
    and a switch statement running on the target based on the trace set is going to
    overshadow any interesting leakage.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你将对这些数据集进行各种统计分析，因此至关重要的是，你的数据集之间唯一的统计学差异应当是由输入数据的差异造成的。实际上，运行超过几小时的跟踪获取活动可能会在某些情况下出现可检测的变化，例如平均功率水平的变化（见本章稍后的“分析技术”部分）。如果你在第0分钟测量了A集，而在第60分钟测量了B集，那么你的统计数据肯定会显示这两个数据集之间的功率差异。这些功率差异可能看起来不显著，直到你发现怀疑的泄漏实际上是因为你的空调在第59分钟启动并冷却了目标设备，而不是因为目标设备存在泄漏。当你对多个数据集进行统计分析时，必须确保这些数据集之间的差异仅仅是由于输入数据造成的。这意味着，对于每个你测量的跟踪数据，你必须随机选择要生成输入数据的数据集。你也*不*希望目标设备知道你正在为哪个数据集进行测量；目标设备只需要知道操作的数据。如果你将关于数据集的信息发送给目标设备，它将出现在你的跟踪数据中。如果你不是随机选择，而是交替选择数据集，它也会出现在你的跟踪数据中。这些无关的相关性非常难以调试，因为它们会表现为（错误的）泄漏，因此你应该努力避免它们。你是在检测极小的功率变化，而基于跟踪数据集运行的目标设备的开关语句将会掩盖任何有趣的泄漏。
- en: The Measurement Probe
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测量探头
- en: 'To perform the side-channel attack, you need to measure your device’s power
    consumption. Taking this measurement was trivial when attacking a target board
    you designed, but it requires more creativity on real devices. We’ll discuss the
    two main methods: using a physical shunt resistor and using an electromagnetic
    probe.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行侧信道攻击，你需要测量设备的功耗。在攻击你自己设计的目标板时，进行这种测量非常简单，但在真实设备上则需要更多的创意。我们将讨论两种主要方法：使用物理分流电阻和使用电磁探头。
- en: Inserting Shunt Resistors
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 插入分流电阻
- en: If attempting to measure power on a “standard” board, you’ll need to make some
    modifications to the board for the power consumption measurements. This will differ
    from board to board, but as an example, see [Figure 11-5](#figure11-5), which
    shows how you can lift the leg of a thin quad flat pack (TQFP) package to insert
    a surface-mount resistor.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试在“标准”电路板上测量功率，你需要对电路板进行一些修改，以便进行功耗测量。不同的电路板会有所不同，但例如，[图11-5](#figure11-5)展示了如何通过抬起薄型四方扁平封装（TQFP）引脚，插入表面贴装电阻。
- en: '![f11005](image_fi/278748c11/f11005.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![f11005](image_fi/278748c11/f11005.png)'
- en: 'Figure 11-5: Inserting a resistor into the leg of a TQFP package'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-5：在TQFP封装的引脚中插入电阻
- en: You then have to connect your oscilloscope probe to either side of the resistor,
    which allows you to measure the voltage drop across the resistor and thereby the
    current consumption of a specific voltage net.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你需要将示波器探头连接到电阻的任一侧，这样你就可以测量电阻上的电压降，从而得出特定电压网的电流消耗。
- en: Electromagnetic Probes
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 电磁探头
- en: A more advanced alternative is to use an electromagnetic probe (also called
    an H-field probe, near-field probe, or magnetic field probe), which can be positioned
    above or close to the area of interest. The resulting analysis is called *electromagnetic
    analysis (EMA)*. EMA requires no modifications to the device under attack, as
    the probe can just be placed directly over the chip or above the decoupling capacitors
    around the chip. These probes are sold in sets known as *near-field probe sets*,
    and they typically include an amplifier.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更先进的替代方法是使用电磁探头（也叫做H场探头、近场探头或磁场探头），它可以放置在感兴趣区域的上方或附近。由此进行的分析称为*电磁分析（EMA）*。EMA不需要对被攻击设备进行任何修改，因为探头只需直接放置在芯片上方或芯片周围的去耦电容器上方。这些探头通常以*近场探头套件*的形式出售，通常包括一个放大器。
- en: The theory on why this works is simple. High-school physics teaches us that
    a current flowing through a wire creates a magnetic field around the wire. The
    righthand rule tells us that if we hold the wire such that our thumb is pointing
    in the direction of the current, the magnetic field lines would circle around
    the wire in the direction of our fingers. Now, any activity inside the chip is
    simply switching currents. Instead of measuring the switching current directly,
    we probe the switching magnetic field around it. This works on the principle that
    a switching magnetic field induces a current in a wire. We can measure that wire
    with a scope, which rather indirectly reflects the switching activity in the chip.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法有效的原理很简单。高中物理教我们，电流通过导线时，会在导线周围产生磁场。右手定则告诉我们，如果我们将导线握住，拇指指向电流方向，那么磁场线会沿着我们的手指方向围绕导线旋转。现在，芯片内部的任何活动实际上就是电流的开关。我们不是直接测量开关电流，而是探测它周围的开关磁场。这个原理基于这样一个事实：开关磁场会在导线中感应出电流。我们可以用示波器来测量这根导线，从而间接地反映出芯片中的开关活动。
- en: Rolling Your Own Electromagnetic Probe
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自制电磁探头
- en: As an alternative to buying a probe, you can build a simple probe yourself.
    Building your own EM probe is fun for the whole family, provided the family likes
    working with sharp objects, soldering irons, and chemicals. In addition to the
    probe, you’ll need to build a low-noise amplifier for increasing the strength
    of the signal your oscilloscope or other device is measuring.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 作为购买探头的替代方法，你可以自己制作一个简单的探头。自己动手制作电磁探头是全家都能享受的乐趣，前提是全家人喜欢使用尖锐物品、焊接工具和化学品。除了探头外，你还需要制作一个低噪声放大器，用来增强示波器或其他设备测量到的信号强度。
- en: The probe itself is built from a length of semi-flexible coaxial cable. You
    can purchase this from various sources (Digi-Key, eBay) by looking for “SMA to
    SMA cables,” such as Crystek Part Number CCSMA-MM-086-8, which is available from
    Digi-Key for around US$10\. Cutting this cable in half gives you two lengths of
    semi-flexible cable, each with an SMA connector on the one end (one of which is
    shown in [Figure 11-6](#figure11-6)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 探头本身由一段半柔性同轴电缆构成。你可以从各种来源购买这类电缆（例如Digi-Key，eBay），查找“SMA到SMA电缆”，比如Crystek部件号CCSMA-MM-086-8，可以在Digi-Key以大约10美元的价格购买。将这根电缆剪成两段后，你就得到了两根半柔性电缆，每根电缆一端有一个SMA连接器（其中一个在[图11-6](#figure11-6)中显示）。
- en: '![f11006](image_fi/278748c11/f11006.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![f11006](image_fi/278748c11/f11006.png)'
- en: 'Figure 11-6: Home-built EM probes from a semi-flexible SMA cable'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-6：用半柔性SMA电缆自制的电磁探头
- en: Cut a slot 1 around the entire outer shield. Strip away a few millimeters from
    the end 2. Gently round this into a circle 3, gripping the slot with pliers to
    stop the internal conductor wire from kinking. To complete the basic probe, solder
    the circle shut 4, making sure that the internal conductor wire is included in
    the solder connection between the outer shields.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个外部屏蔽上切一个槽 1。将末端剥去几毫米 2。轻轻将其圆成一个圆圈 3，用钳子夹住槽口，以防内部导线弯曲。完成基本探头时，将圆圈焊接闭合 4，确保内部导线包含在外部屏蔽之间的焊接连接中。
- en: Because the outer shield is conductive, you might want to coat the surface with
    a nonconductive material, such as a rubber coating like Plasti Dip, or wrap it
    with self-fusing tape.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于外部屏蔽是导电的，你可能需要给表面涂上一层非导电材料，比如像Plasti Dip这样的橡胶涂层，或者用自粘胶带将其包裹起来。
- en: The signal picked up at the narrow gap in this probe will be tiny, so you’ll
    need an amplifier to see any signal on your oscilloscope. You can use a simple
    IC as the basis for a low-noise amplifier. It requires a clean 3.3 V power supply,
    so consider also building the voltage regulator onto the circuit board. If your
    oscilloscope isn’t sufficiently sensitive, you might even need to chain two amplifiers
    together to achieve enough gain. [Figure 11-7](#figure11-7) shows an example of
    a simple amplifier built around a $0.50 IC (part number BGA2801,115).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个探头的狭缝处拾取到的信号将会非常微弱，因此你需要一个放大器才能在示波器上看到任何信号。你可以使用一个简单的集成电路（IC）作为低噪声放大器的基础。它需要一个干净的3.3
    V电源，因此建议将电压调节器也设计到电路板上。如果你的示波器灵敏度不够，甚至可能需要将两个放大器串联以获得足够的增益。[图 11-7](#figure11-7)展示了一个围绕着$0.50集成电路（型号BGA2801,115）构建的简单放大器示例。
- en: '![f11007](image_fi/278748c11/f11007.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![f11007](image_fi/278748c11/f11007.png)'
- en: 'Figure 11-7: Simple amplifier for an EM probe'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-7：电磁探头简单放大器
- en: If you want to build the amplifier yourself, see [Figure 11-8](#figure11-8)
    for the schematic.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想自己构建放大器，请参考[图 11-8](#figure11-8)的原理图。
- en: 'The choice of side-channel measurement can significantly affect the signal
    and noise characteristics. There is generally low noise when directly measuring
    power drawn by a chip, as compared to, for instance, the noise in an electromagnetic
    measurement, or in an acoustic side channel (see Daniel Genkin, Adi Shamir, and
    Eran Tromer’s “RSA Key Extraction via Low-Bandwidth Acoustic Cryptanalysis”),
    or in a measurement of the chassis potential (see Daniel Genkin, Itamar Pipman,
    and Eran Tromer’s “Get Your Hands Off My Laptop: Physical Side-Channel Key-Extraction
    Attacks on PCs”). However, a direct measurement of power means that you measure
    all of the power consumption, including the power drawn by processes you’re not
    interested in. On an SoC, you may get a better signal with an EM measurement if
    your probe is carefully positioned over the physical location of the leakage.
    You may encounter countermeasures that minimize leakage in direct power measurement
    but do not limit it in the EM measurement, or vice versa. As a rule of thumb,
    try EM first on complex chips and SoCs, and try power first on smaller microcontrollers.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 侧信道测量的选择可能会显著影响信号和噪声特性。直接测量芯片所消耗的电力通常噪声较低，相比之下，例如电磁测量、声学侧信道（参见Daniel Genkin、Adi
    Shamir 和 Eran Tromer的《RSA 密钥提取：低带宽声学密码分析》），或者机箱电位的测量（参见Daniel Genkin、Itamar Pipman
    和 Eran Tromer的《离我笔记本远点：PC上的物理侧信道密钥提取攻击》）通常噪声较高。然而，直接的功率测量意味着你测量的是所有的功耗，包括那些你不感兴趣的过程所消耗的电力。在片上系统（SoC）中，如果你的探头精确地定位在泄漏的物理位置，电磁测量可能会得到更好的信号。你可能会遇到一些反制措施，它们可以最小化直接功率测量中的泄漏，但在电磁测量中没有限制，反之亦然。作为经验法则，在复杂的芯片和SoC上，先尝试电磁测量，在较小的微控制器上，先尝试功率测量。
- en: '![f11008](image_fi/278748c11/f11008.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![f11008](image_fi/278748c11/f11008.png)'
- en: 'Figure 11-8: Schematic for simple amplifier for an EM probe'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-8：电磁探头简单放大器原理图
- en: Determining Sensitive Nets
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定敏感网
- en: Whether using a resistive shunt or an EM probe, we have to determine what part
    of the device must be measured. The objective is to measure power consumption
    of the logic circuit performing the sensitive operation—be it a hardware peripheral
    or the general-purpose core executing a software program.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用电阻分流器还是电磁探头，我们都必须确定需要测量设备的哪一部分。目标是测量执行敏感操作的逻辑电路的功耗——无论是硬件外设还是执行软件程序的通用核心。
- en: In the case of the resistive shunt, this means looking at power pins on the
    IC. Here you need to measure at one of the pins powering the internal cores, not
    at the pins that power the I/O pin drivers. Small microcontrollers might have
    a single power supply used for all parts of the microcontroller. Even these simple
    microcontrollers can have multiple power pins with the same name, so select one
    that’s most easily accessed. Be sure not to select a supply dedicated to the analog
    portion, such as the analog-to-digital converter power supply, as that will likely
    not power the components of interest.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在电阻分流的情况下，这意味着需要查看集成电路的电源引脚。这里你需要在为内部核心供电的引脚之一上进行测量，而不是那些为I/O引脚驱动器供电的引脚。小型微控制器可能有一个单独的电源供电给微控制器的所有部分。即便是这些简单的微控制器，也可能有多个名称相同的电源引脚，因此选择一个最容易接触到的引脚。一定要避免选择专门供给模拟部分的电源，比如模拟到数字转换器的电源，因为这些电源可能不会为你感兴趣的组件供电。
- en: More advanced devices might have four or more power supplies. For example, the
    memory, CPU, clock generator, and analog section could all be separate supplies.
    Again, you may need to do some experimentation, but almost certainly, the supply
    you want will be one of the supplies with the word *CPU* or *CORE* in the name.
    You can use the data you dug up with the help of Chapter 3 to identify the most
    likely targets.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 更先进的设备可能会有四个或更多电源供应。例如，存储器、CPU、时钟发生器和模拟部分可以都是单独的供应。再次强调，您可能需要进行一些实验，但几乎可以肯定，您想要的供应将是名称中带有
    *CPU* 或 *CORE* 的供应之一。您可以使用在第三章中帮助您挖掘的数据来识别最有可能的目标。
- en: If targeting a device using an EM probe, you’ll need to experiment to determine
    the correct orientation and location for the probe. It’s also worth placing the
    probe near the decoupling capacitors surrounding the target, as high currents
    will tend to flow through those parts. In this case, you would need to determine
    which decoupling capacitors are associated with the core components of the device,
    similar to determining which power supply to target.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用EM探针瞄准设备，您需要进行实验以确定探针的正确方向和位置。值得注意的是，将探针放置在围绕目标的去耦合电容器附近是有益的，因为高电流通常会流经这些部件。在这种情况下，您需要确定哪些去耦合电容器与设备的核心组件相关，类似于确定要瞄准哪个电源供应的方法。
- en: Letting your target run encryptions while displaying live trace captures on
    a screen can be enlightening. As the probe moves, you’ll see the captured traces
    vary wildly. A good rule of thumb is to find a place where the field is weak before
    and after the crypto phase and strong while performing the crypto routine. It
    helps to display a trigger that “hugs” the operation as well. It doesn’t hurt
    to move the probe around manually to get a quick sense of the leakage over various
    parts of the chip.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标运行加密同时在屏幕上显示实时迹线捕获可以提供启发。随着探针的移动，您将看到捕获的迹线变化剧烈。一个经验法则是在加密阶段之前和之后找到一个场强较弱的地方，并且在执行加密过程时场强较强。同时显示一个“拥抱”操作的触发器也有帮助。手动移动探针以快速了解芯片各个部分的泄漏也是有好处的。
- en: Automated Probe Scanning
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动探针扫描
- en: Mounting the probe on an XY stage and automatically capturing traces over various
    positions on the chip allows more precise localization of interesting areas. [Figure
    11-9](#figure11-9) shows a sample setup.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将探针安装在XY平台上，并在芯片的各个位置自动捕获迹线，可以更精确地定位感兴趣的区域。 [图 11-9](#figure11-9) 展示了一个示例设置。
- en: You can use TVLA to get another nice visualization, as explained in the “Test
    Vector Leakage Assessment” section later in this chapter. TVLA measures leakage
    without doing a CPA attack, so if you visualize the TVLA outcome, you’ll see a
    plot of actual leakage over the area of the chip. The downside is that in order
    to calculate TVLA values, you need to have two full measurement sets for each
    spot on the chip, which increases the length of your trace acquisition campaign
    dramatically.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用TVLA来获得另一种很好的可视化效果，如本章后面“测试向量泄漏评估”部分所述。TVLA测量泄漏而不进行CPA攻击，因此如果可视化TVLA结果，您将看到芯片区域的实际泄漏图。不利之处在于，为了计算TVLA值，您需要对每个芯片位置进行两套完整的测量集，这显著增加了您的迹线采集活动的时间。
- en: Probing more spots increases the chances that you find the *right* spot, but
    it decreases your efficiency. Scan at a spatial resolution that gives more continuous
    data gradients in the visualization to ensure that your XY scan step size is smaller
    than the sensitive area of your probe.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 探测更多的点增加了找到 *正确* 位置的机会，但降低了效率。在可视化中给出更连续数据梯度的空间分辨率进行扫描，以确保XY扫描步长小于探针的敏感区域。
- en: Scanning is of particular interest when combined with the technique described
    later in this chapter in the “Filtering for Visualization” section. If you know
    your target operation’s leakage frequency, you can visualize the signal strength
    at that frequency as a function of the position over your chip. This leads to
    pretty pictures such as the one in [Figure 11-10](#figure11-10), which shows an
    XY scan visualization of the leakage intensity over different areas on the chip
    in the 31-to-34 MHz band. These kinds of images can help localize areas of interest
    and can be done with as little as one trace per location.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当与本章后面描述的“用于可视化的过滤”部分结合使用时，扫描尤其引人关注。如果您知道目标操作的泄漏频率，您可以将该频率下的信号强度作为芯片上位置的函数进行可视化。这导致了如
    [图 11-10](#figure11-10) 所示的漏泄强度XY扫描可视化图，显示了31至34 MHz频段上芯片不同区域的漏泄强度。这些图像可以帮助定位感兴趣的区域，并且只需每个位置进行一次迹线测量即可完成。
- en: '![f11009](image_fi/278748c11/f11009.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![f11009](image_fi/278748c11/f11009.png)'
- en: 'Figure 11-9: Example of a Riscure electromagnetic probe mounted on an XY stage'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-9：Riscure 电磁探针安装在 XY 平台上的示例
- en: '![f11010](image_fi/278748c11/f11010.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![f11010](image_fi/278748c11/f11010.png)'
- en: 'Figure 11-10: XY scan visualization of leakage areas from a chip'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-10：芯片泄漏区域的 XY 扫描可视化
- en: Oscilloscope Setup
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 示波器设置
- en: An oscilloscope is an ideal tool for capturing and presenting the leakage signals
    from a magnetic probe. You’ll have to set up your oscilloscope carefully to get
    good information. We discussed the various input types available for your oscilloscope
    in Chapter 2, along with the general advice on avoiding the use of probes that
    will introduce considerable noise on a very small signal. To reduce noise further,
    some sort of amplification is often required on the input to the oscilloscope
    for boosting the signal.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 示波器是捕捉和展示来自磁性探针的泄漏信号的理想工具。你必须仔细设置示波器，以获取良好的信息。我们在第 2 章中讨论了示波器可用的各种输入类型，并提供了一些关于避免使用可能在非常小的信号上引入大量噪声的探头的一般建议。为了进一步减少噪声，通常需要对示波器的输入进行某种放大，以增强信号。
- en: You can use a *differential amplifier* to do this, which amplifies only the
    *difference* between the two signal points. Beyond just boosting the signal, the
    differential amplifier removes noise present on both signal points (called *common-mode*
    noise). In real life, this means that noise generated by the power supply will
    mostly be removed, leaving only the voltage variation that is measured across
    your measurement resistor.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用*差分放大器*来做到这一点，它只放大两个信号点之间的*差异*。除了增强信号外，差分放大器还去除了两个信号点上存在的噪声（称为*共模*噪声）。在现实中，这意味着电源产生的噪声会被大部分去除，只留下你在测量电阻器上测得的电压变化。
- en: Oscilloscope manufacturers sell commercial *differential probes*, but they’re
    typically extremely expensive. As an alternative, you can simply build a differential
    amplifier using a commercial operational amplifier (or *op-amp*). A differential
    probe can measure power consumption across the resistor to reduce noise contribution.
    A sample open source design is available as part of the ChipWhisperer project,
    which uses the Analog Devices AD8129\. [Figure 11-11](#figure11-11) is a photo
    of this probe in use on a physical device.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 示波器制造商出售商用*差分探头*，但它们通常非常昂贵。作为替代方案，你可以简单地使用商用运算放大器（或*运算放大器*）构建一个差分放大器。差分探头可以测量跨电阻器的功耗，以减少噪声的贡献。一个开放源代码设计作为
    ChipWhisperer 项目的一部分提供，其中使用了 Analog Devices AD8129。 [图 11-11](#figure11-11) 是该探头在物理设备上的使用照片。
- en: '![f11011](image_fi/278748c11/f11011.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![f11011](image_fi/278748c11/f11011.png)'
- en: 'Figure 11-11: A differential probe in use on a target board'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-11：差分探头在目标板上的使用
- en: In [Figure 11-11](#figure11-11), the differential probe has a positive (+) and
    negative (–) pin. These pins are marked on the lower-right side on the black probe
    PCB silkscreen. Wires 2 and 1 connect the positive and negative pins, respectively,
    to two sides of the shunt resistor mounted onto the target PCB. The differential
    probe is used in this example because the power flowing into the shunt resistor
    is noisy, and we want to remove this common-mode noise.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 11-11](#figure11-11)中，差分探头有正极（+）和负极（–）引脚。这些引脚标记在黑色探头 PCB 的右下角。线缆 2 和 1 分别将正极和负极引脚连接到安装在目标
    PCB 上的分流电阻的两侧。由于流入分流电阻的电力带有噪声，因此在这个例子中使用差分探头，我们希望去除这种共模噪声。
- en: The schematic for the differential probe is shown in [Figure 11-12](#figure11-12),
    in case you are curious about the details of its connection.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 差分探头的电路图如[图 11-12](#figure11-12)所示，如果你对其连接细节感兴趣，可以参考此图。
- en: '![f11012](image_fi/278748c11/f11012.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![f11012](image_fi/278748c11/f11012.png)'
- en: 'Figure 11-12: Differential probe schematic'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-12：差分探头电路图
- en: Sampling Rate
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 采样率
- en: So far, we assume you’ve magically been able to read your measurements into
    the computer. Previous chapters briefly explained that when setting up your oscilloscope,
    you need to select an appropriate sampling rate. The upper limit on this sampling
    rate is based on how much you paid for your oscilloscope; if you have enough money,
    you can buy 100 GS/s (giga-samples per second) or faster devices.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们假设你已经神奇地将测量数据读取到了计算机中。前几章简要解释了在设置示波器时，你需要选择一个合适的采样率。该采样率的上限取决于你为示波器支付了多少钱；如果你有足够的资金，你可以购买
    100 GS/s（每秒 10 亿次采样）或更快的设备。
- en: More is not always better. Longer traces mean lots of storage space and much
    longer processing times. You might want to sample at a very high rate and then
    *downsample* (that is, average consecutive samples) when storing your data, which
    will improve your waveforms considerably. First, downsampling results in a virtual
    increase in your scope’s quantization resolution. If your scope has an 8-bit ADC
    running at 100 MHz and you average every two samples, you effectively have a 9-bit
    scope running at 50 MHz. This is simply because if a sample value of 55 and a
    sample value of 56 are averaged, they produce 55.5\. The inclusion of these “half”
    values effectively adds 1 bit of resolution. Or, you can average over four consecutive
    samples to have an effective 10-bit scope at 25 MHz.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 更多的采样不一定更好。较长的波形意味着需要大量存储空间和更长的处理时间。你可能希望以非常高的速率进行采样，然后在存储数据时进行*下采样*（即对连续采样进行平均），这将显著改善你的波形。首先，下采样实际上会虚拟增加示波器的量化分辨率。如果你的示波器有一个以100
    MHz运行的8位ADC，并且你对每两个样本进行平均，那么你实际上拥有的是一个以50 MHz运行的9位示波器。这是因为，如果一个样本值为55，另一个样本值为56，它们的平均值为55.5。引入这些“半”值实际上增加了1位分辨率。或者，你可以对四个连续样本进行平均，以获得一个有效的10位示波器，运行在25
    MHz。
- en: Second, sampling fast reduces time jitter in the measurements. A trigger event
    happens at some point during a sampling period, and the scope will start measuring
    only at the next sampling period. The fact that the trigger event happens asynchronously
    to the oscilloscope sampling clock means there is jitter between the trigger event
    and the next sampling period. This jitter manifests itself as a misalignment in
    traces.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，快速采样可以减少测量中的时间抖动。触发事件发生在采样周期的某个时刻，示波器只有在下一个采样周期开始时才开始测量。触发事件与示波器采样时钟的异步性意味着触发事件和下一个采样周期之间存在抖动。这种抖动表现为波形对齐错误。
- en: Consider the situation where the oscilloscope is sampling at a slower rate,
    like 25 MS/s, meaning that samples are being taken every 40ns. Whenever the trigger
    event occurs (that is, the start of the encryption), you’ll have some delay until
    the start of the next sample. This delay would be on average 20ns (half the sample
    period), since the time base of the oscilloscope is completely independent of
    the time base on the target device.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设示波器以较慢的速率进行采样，如25 MS/s，这意味着每40ns采样一次。每当触发事件发生时（即加密开始时），你会有一些延迟，直到下一个采样开始。这个延迟平均为20ns（采样周期的一半），因为示波器的时间基准与目标设备的时间基准完全独立。
- en: If you sample much faster (say, at 1 GS/s), that delay from the trigger to the
    start of the first sample will be only 0.5ns, or 40 times better! Once you record
    the data, you can then downsample it to reduce your memory requirements. The resulting
    waveform will have the same number of points as if you performed the capture at
    25 MS/s, but now the jitter is no more than 0.5ns, thus considerably improving
    the outcome of a side-channel attack (see Colin O’Flynn and Zhizhang Chen’s, “Synchronous
    Sampling and Clock Recovery of Internal Oscillators for Side Channel Analysis
    and Fault Injection”).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以更快的速率进行采样（比如1 GS/s），从触发到第一个采样开始的延迟将只有0.5ns，或者说提高了40倍！一旦记录了数据，你就可以进行下采样以减少内存需求。所得波形将具有与在25
    MS/s下进行捕获时相同的点数，但现在抖动不超过0.5ns，从而显著改善侧信道攻击的结果（参见Colin O'Flynn和Zhizhang Chen的《内部振荡器的同步采样与时钟恢复用于侧信道分析与故障注入》）。
- en: True downsampling from a *digital signal processing (DSP)* perspective uses
    a filter, and any downsampling routines built in to a DSP framework for your language
    of choice would support this. However, in practice, downsampling by averaging
    consecutive points, or even only keeping every 40th sample point, tends to maintain
    exploitable leakage.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从*数字信号处理（DSP）*的角度来看，真正的下采样使用滤波器，并且任何内置在你选择的编程语言的DSP框架中的下采样程序都应该支持这一点。然而，实际上，通过平均连续点进行下采样，或者仅保留每40个样本点，往往会保持可利用的泄漏。
- en: Some oscilloscopes can perform this operation for you; some PicoScope devices
    have a downsample option that’s performed in hardware. Check your oscilloscope’s
    detailed programming manual to see whether this option exists.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示波器可以为你执行此操作；某些PicoScope设备具有硬件执行的下采样选项。请查阅示波器的详细编程手册，以查看是否存在此选项。
- en: Finally, you can use hardware that captures synchronously to the device clock.
    In Appendix A, we describe the ChipWhisperer hardware that’s designed specifically
    to perform this task. Some oscilloscopes will have a *reference in* capability,
    which usually allows the input of only up to a 10 MHz synchronization reference.
    This capability is less useful in real life, since it means you would have to
    feed your device from a 10 MHz clock (the same as the synchronization reference
    going to the scope) in order to achieve the synchronous sampling capability.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用与设备时钟同步捕获的硬件。在附录A中，我们描述了专门设计用于执行此任务的ChipWhisperer硬件。一些示波器具有*参考输入*功能，通常允许输入最多10
    MHz的同步参考信号。这个功能在现实生活中并不太有用，因为这意味着你必须将设备从一个10 MHz的时钟源（与示波器的同步参考信号相同）供电，以实现同步采样能力。
- en: Trace Set Analysis and Processing
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪集分析与处理
- en: 'The assumption so far has been that you record power traces and then perform
    an analysis algorithm. Realistically, you’ll include an intermediate step: preprocessing
    the traces, which means performing some action on them *before* passing them on
    to the analysis algorithm (such as CPA). All these steps aim to decrease noise,
    and/or increase the level of the leakage signal. Your measurement setup and CPA
    scripts at this point should be *fire and forget*. Trace processing is largely
    a process of trial-and-error and relies on experimentation to find what works
    best on your target. In this section, we assume you’ve made a trace set of measurements
    but haven’t yet started CPA.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的假设是，你记录了功率跟踪并进行分析算法。实际上，你将包含一个中间步骤：预处理跟踪数据，这意味着在将数据传递给分析算法（如CPA）之前，进行一些处理操作。所有这些步骤的目的是减少噪声，和/或提高泄漏信号的强度。此时，你的测量设置和CPA脚本应该是*一劳永逸*的。跟踪处理主要是一个试验和错误的过程，需要通过实验找到最适合你目标的方式。在本节中，我们假设你已经完成了一组跟踪数据的测量，但还没有开始进行CPA分析。
- en: Four main preprocessing techniques you might use include *normalizing/dropping*,
    *resynchronizing*, *filtering*, and *compression* (see the section “Processing
    Techniques” later in this chapter). To determine whether your preprocessing step
    is actually helping you, we’ll first describe some analysis techniques, such as
    calculating *average* and *standard deviations*, *filtering* (yes, again), *spectrum
    analysis*, *intermediate correlation*, *known-key CPA*, and *TVLA* (listed in
    the typical order you apply them). You won’t necessarily require them all, and
    when doing analysis on a simple, leaky experimental platform that you fully control,
    you’ll probably be able to ignore most of them completely. All of these techniques
    are *standard* digital signal processing (DSP) tools, applied in a power analysis
    context. Consult DSP literature for inspiration on more advanced techniques.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能使用的四种主要预处理技术包括*归一化/丢弃*、*重新同步*、*过滤*和*压缩*（请参见本章后面的“处理技术”部分）。为了确定你的预处理步骤是否真正有效，我们首先描述一些分析技术，例如计算*平均值*和*标准差*、*过滤*（是的，又来了）、*谱分析*、*中间相关*、*已知密钥CPA*和*TVLA*（按你应用它们的典型顺序列出）。你不一定需要全部使用它们，当你在一个简单的、完全可控的泄漏实验平台上进行分析时，可能可以完全忽略其中的大部分。这些技术都是*标准*的数字信号处理（DSP）工具，应用于功率分析的上下文中。可以参考DSP文献，寻找更先进的技术灵感。
- en: The analysis techniques become more valuable as you transition away from an
    experimental platform and move to real-life measurements made under non-ideal
    situations. You’ll use a preprocessing technique and then check its result using
    an analysis technique. If you know the key, you can always check whether your
    attack improved by using known-key CPA or TVLA. If you don’t know the key, you
    rinse and repeat until you think you’re ready to do CPA. If it works, hooray;
    if not, you’ll have to backtrack to each step to figure out whether you should
    try something else. Unfortunately, it isn’t a hard science, but the analysis techniques
    described here can give you some starting points.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你从实验平台过渡到在非理想情况下进行的实际测量，分析技巧变得更加宝贵。你将使用预处理技术，然后通过分析技巧检查其结果。如果你知道密钥，你可以通过已知密钥的CPA或TVLA来检查你的攻击是否有所改进。如果你不知道密钥，你需要不断尝试，直到认为自己准备好进行CPA。如果成功了，太好了；如果没有，你将不得不回溯每一步，弄清楚是否应该尝试其他方法。不幸的是，这不是一门精确的科学，但这里描述的分析技术可以为你提供一些起点。
- en: Analysis Techniques
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析技术
- en: This section describes some standard analysis techniques that provide a measure
    of how close you are to having a good enough signal for CPA. With CPA, you performed
    measurements using different input data. Many of the visualizations in the following
    section should first be performed with the same operation and with the same data,
    and then later you can use different information as you get closer to a CPA attack.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了一些标准分析技术，这些技术提供了一个衡量信号是否足够好以进行CPA的指标。在CPA中，你使用不同的输入数据进行了测量。接下来的许多可视化图应首先使用相同的操作和相同的数据执行，之后随着接近CPA攻击时，你可以使用不同的信息。
- en: Averages and Standard Deviations over a Data Acquisition Campaign (per Trace)
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 每个追踪的数据采集活动中的平均值和标准偏差
- en: Let’s say you represent each trace as a single point—namely, the average of
    all samples in that trace. Recall *t*[*d,j*] , where *j* = 0,1,…,*T* – 1 is the
    time index in the trace, and *d* = 0,1,…,*D* – 1 is the trace number. Your calculation
    is
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你将每个追踪表示为一个单一的点——即该追踪中所有样本的平均值。回想一下 *t*[*d,j*]，其中 *j* = 0,1,…,*T* - 1 是追踪中的时间索引，*d*
    = 0,1,…,*D* - 1 是追踪编号。你的计算公式是
- en: '![e11001](image_fi/278748c11/e11001.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![e11001](image_fi/278748c11/e11001.png)'
- en: Plotting all these points shows changes in the average of the traces over time
    and can help you find anomalies in your trace acquisition campaign; see, for instance,
    [Figure 11-13](#figure11-13).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制所有这些点展示了随着时间推移，平均值的变化，并可以帮助你发现追踪采集活动中的异常；例如，参见[图11-13](#figure11-13)。
- en: '![f11013](image_fi/278748c11/f11013.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![f11013](image_fi/278748c11/f11013.png)'
- en: 'Figure 11-13: Average value of all samples per trace, showing traces 58, 437,
    and 494 to be outliers'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-13：每个追踪的所有样本的平均值，显示追踪58、437和494为异常值
- en: One type of anomaly is a drifting average—for example, due to temperature changes
    (yes, you will see the air conditioning kick in) or due to a complete outlier
    caused, perhaps, by a missed trigger. You either want to correct these traces
    or drop them altogether. (See the “Normalizing Traces” section later in this chapter
    for details on what to do with this information.) The standard deviation will
    give you a different perspective on the same acquisition campaign. We recommend
    calculating them both, as the computational overhead is insignificant.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一种异常类型是漂移的平均值——例如，由于温度变化（是的，你会看到空调启动）或由于某个完全的异常值，可能是由于错过了触发。你要么修正这些追踪，要么直接丢弃它们。（有关如何处理这些信息的详细内容，请参见本章稍后的“标准化追踪”部分。）标准偏差将为同一采集活动提供不同的视角。我们建议同时计算它们，因为计算开销微不足道。
- en: Averages and Standard Deviations over Operations (per Sample)
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 每个操作的平均值和标准偏差（按样本）
- en: 'The other way of calculating an average is per sample:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 计算平均值的另一种方法是按样本计算：
- en: '![e11002](image_fi/278748c11/e11002.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![e11002](image_fi/278748c11/e11002.png)'
- en: This average can help provide a clearer view of what the operation you are capturing
    actually looks like, because it reduces amplitude noise. [Figure 11-14](#figure11-14)
    shows a raw trace in the upper graph and a sample-averaged trace in the lower
    graph.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个平均值有助于更清晰地展示你所捕获的操作的实际样子，因为它减少了幅度噪声。[图11-14](#figure11-14)展示了上图中的原始追踪和下图中的样本平均追踪。
- en: The sample-averaged trace makes the process steps more obvious. However, its
    usefulness decreases with increasing temporal noise. A little misalignment is
    typically not an issue for visualization, as you lose only high-frequency signals,
    but the more misaligned the traces are, the lower the highest frequencies that
    you can see will be. A little misalignment can be bad for CPA if your leakage
    is only in the higher frequencies. You can use the average to judge misalignment
    visually by looking at the higher-frequency content.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 样本平均追踪使得过程步骤更加明显。然而，随着时间噪声的增加，它的有用性会下降。轻微的错位通常对可视化没有影响，因为你仅失去高频信号，但追踪错位越严重，你能看到的最高频率就越低。如果你的泄漏信号仅在高频部分，轻微的错位可能会对CPA产生不利影响。你可以通过观察更高频内容来利用平均值直观判断错位情况。
- en: '![f11014](image_fi/278748c11/f11014.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![f11014](image_fi/278748c11/f11014.png)'
- en: 'Figure 11-14: Raw trace (top) and sample-averaged trace (bottom)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-14：原始追踪（上）和样本平均追踪（下）
- en: Another effective method is to calculate the standard deviation per sample.
    As a rule of thumb, the lower the standard deviation, the less misalignment you
    have, as shown in [Figure 11-15](#figure11-15). In this example, the time between
    300 and 460 samples has low standard deviation, indicating little misalignment.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有效的方法是计算每个样本的标准差。作为经验法则，标准差越低，错位越少，如[图11-15](#figure11-15)所示。在这个例子中，300到460个样本之间的时间具有较低的标准差，表明错位很小。
- en: Perfectly aligned traces with the same operations can still show differences
    for both the average and standard deviation, which is due to differences in data
    and therefore an indication of data leakage.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是完全对齐的轨迹，使用相同的操作，平均值和标准差仍然可能显示差异，这是由于数据差异引起的，因此表明数据泄漏。
- en: '![f11015](image_fi/278748c11/f11015.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![f11015](image_fi/278748c11/f11015.png)'
- en: 'Figure 11-15: Standard deviation over a trace set'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-15：轨迹集的标准差
- en: Filtering for Visualization
  id: totrans-155
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 可视化滤波
- en: Frequency filtering can be used as a method for generating visual representations
    of the trace data. You can aggressively cancel certain frequencies (usually high
    frequencies) to get a better view of operations being performed, without having
    to calculate an average over an entire trace set. A simple low-pass filter can
    be implemented by taking a moving average over samples (see [Figure 11-16](#figure11-16)).
    A low-pass filter is a quick way to clean up a visual representation of trace
    data.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 频率滤波可以作为生成轨迹数据可视化表示的一种方法。你可以大幅度地取消某些频率（通常是高频），以便更好地观察正在执行的操作，而无需对整个轨迹集计算平均值。通过对样本进行滑动平均，可以实现一个简单的低通滤波器（见[图11-16](#figure11-16)）。低通滤波器是清理轨迹数据可视化表示的快速方法。
- en: '![f11016](image_fi/278748c11/f11016.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![f11016](image_fi/278748c11/f11016.png)'
- en: 'Figure 11-16: Raw trace (top) and low-pass filtered race (bottom)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-16：原始轨迹（上）和低通滤波后的轨迹（下）
- en: 'You can also use more precise and computationally complex filters (see the
    “Frequency Filtering” section later in this chapter), but doing so may be overkill
    for visualization purposes. This visualization step is only to provide an idea
    of what’s going on below the noise; it’s not a preprocessing step, as you’ll likely
    remove the leakage signal as well. An exception is for some simple power analysis
    type of attacks: visualization of secret-dependent operations, such as square/multiply
    in RSA, can break the private key!'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用更精确且计算复杂的滤波器（见本章后面的“频率滤波”部分），但这样做对于可视化目的可能是过度的。这个可视化步骤仅仅是为了提供一个了解噪声下发生了什么的概念；它不是一个预处理步骤，因为你可能会同时去除泄漏信号。一个例外是一些简单的功率分析攻击：对RSA中的平方/乘法等依赖于密钥的操作进行可视化，可以破解私钥！
- en: Spectrum Analysis
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 频谱分析
- en: 'What you can’t see in the time domain may be visible in the frequency domain.
    If you don’t know what the frequency domain means, think about music and sound.
    If you record music, it captures the time domain information: the air pressure
    caused by sound waves through time. But when you listen to music, you hear the
    frequency domain: different pitches of sounds through time.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在时间域中你看不见的东西，可能在频率域中会可见。如果你不知道频率域是什么意思，可以考虑音乐和声音。如果你录制音乐，它捕捉的是时间域的信息：声音波通过时间产生的气压。但当你听音乐时，你听到的是频率域：不同音高的声音随时间的变化。
- en: 'Two visualizations are typically useful: the *average spectrum*, which is the
    “pure” frequency domain without any representation for time, and the *average
    spectrogram*, which is a combination of frequency and time information. The spectrum
    shows the magnitude of each frequency in a single trace and is a one-dimensional
    signal. It is obtained by calculating the fast Fourier transform (FFT) of a trace.
    The spectrogram shows the progression over time of all frequencies for a single
    trace. Because it adds a time dimension, it is a two-dimensional signal. It is
    calculated by doing an FFT over small chunks of a trace.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 两种可视化通常非常有用：*平均频谱*，这是没有时间表示的“纯”频率域，和*平均频谱图*，它是频率和时间信息的结合。频谱显示了单个轨迹中每个频率的幅度，是一维信号。它通过计算轨迹的快速傅里叶变换（FFT）获得。频谱图显示了单个轨迹中所有频率随时间的变化。因为它增加了时间维度，所以它是二维信号。它通过对轨迹的小块进行FFT计算得出。
- en: The average spectrum and average spectrogram represent the average of these
    signals over an entire trace set. When we say we look at the average, we mean
    we first calculate the signal for each individual trace and then average them
    all per sample.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 平均频谱和平均频谱图表示的是整个追踪集中的信号的平均值。当我们说查看平均值时，意思是我们首先计算每个单独追踪的信号，然后按每个样本将它们求平均。
- en: The chip spectrum shown in [Figure 11-17](#figure11-17) has a clock around 35
    MHz, which can be seen from the frequency spikes every 35 MHz. There are smaller
    spikes every 17.5 MHz, indicating that there are repeating processes that take
    two clock cycles.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11-17](#figure11-17)所示的芯片频谱大约有35 MHz的时钟，可以从每35 MHz的频率峰值中看到。每17.5 MHz会有较小的峰值，表明存在重复的过程需要两个时钟周期。'
- en: '![f11017](image_fi/278748c11/f11017.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![f11017](image_fi/278748c11/f11017.png)'
- en: 'Figure 11-17: Average spectrum over an entire trace set'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-17：整个追踪集的平均频谱
- en: You can perform a few interesting analyses. The frequency spikes every 35 MHz
    are caused by *harmonics* of a square wave at 35 MHz; in other words, they’re
    caused by a digital signal that switches on and off at 35 MHz. Would you suggest
    that this is the clock? Correct. The spectrum can be used to identify one or more
    clock domains on a system.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以进行一些有趣的分析。每35 MHz的频率峰值是由35 MHz方波的*谐波*引起的；换句话说，它们是由一个在35 MHz频率上开关的数字信号引起的。你是否建议这就是时钟？正确。频谱可以用来识别系统中一个或多个时钟域。
- en: This analysis can be particularly useful if your target (crypto) operation is
    running at a different clock frequency from that of other components. It gets
    even better when you do a differential analysis of two average spectra. Let’s
    say you know that some time section of your trace contains the target operation,
    and the rest of the trace does not. You now independently calculate the average
    spectrum for each of the two sections, and subtract one from the other; that is,
    you calculate the difference between these two averages. You’ll get a *differential
    spectrum*, showing exactly what frequencies are more (or less) active during the
    target operation, which can be a great starting point for frequency filtering
    (see the “Frequency Filtering”  section later in this chapter).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的目标（加密）操作与其他组件的时钟频率不同，这种分析会特别有用。当你对两个平均频谱进行差分分析时，它会变得更加有效。假设你知道追踪中的某一时间段包含目标操作，而其余部分不包含目标操作。现在你独立计算这两个部分的平均频谱，并将其中一个从另一个中减去；也就是说，你计算这两个平均值之间的差异。你将得到一个*差分频谱*，准确显示目标操作期间哪些频率更加（或更少）活跃，这可以成为频率滤波的一个很好的起点（参见本章后面的“频率滤波”部分）。
- en: Another way to find the frequency of an operation is to do known-key CPA on
    the frequency domain of traces. Known-key CPA is explained in the equally named
    section later in this chapter, but in a nutshell, because you know the key, you
    can find how close an unknown-key CPA is to recovering a key. To find the frequency
    of an operation, first transform all traces using FFT, and then perform known-key
    CPA on the transformed traces. Now you may be able to see at what frequencies
    the leakage appears. You can do the same trick with TVLA. These methods don’t
    always work, and you may need (significantly) more traces to get a signal.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 查找操作频率的另一种方法是对追踪的频域进行已知密钥CPA分析。已知密钥CPA将在本章后面的同名章节中进行解释，但简而言之，由于你知道密钥，你可以找到未知密钥CPA恢复密钥的接近程度。要查找操作的频率，首先使用FFT转换所有追踪数据，然后对转换后的追踪进行已知密钥CPA分析。现在你可能能够看到泄漏出现在哪些频率上。你也可以用TVLA做同样的操作。这些方法并不总是有效，可能需要（显著）更多的追踪数据才能得到信号。
- en: The nice thing about spectrum analysis is that it is relatively independent
    of timing and thus of misalignment, as we are not looking at the phase component
    of the signal. Instead of resynchronization of traces, you can actually do CPA
    on the spectrum, though the efficiency depends on the type of leakage (see “Correlation
    Power Analysis in the Frequency Domain” by O. Schimmel et al., presented at COSADE
    2010).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 频谱分析的一个好处是它相对独立于时序，因此也不容易受到对齐错误的影响，因为我们并不关心信号的相位分量。你可以在频谱上进行CPA，而不需要对追踪数据进行重新同步，尽管效率取决于泄漏的类型（参见O.
    Schimmel等人于2010年在COSADE大会上发表的“频域中的相关功率分析”）。
- en: The spectrogram, which does contain timing information, can also help you identify
    *interesting* events. If you know when your target operation starts, you may be
    able to see certain frequencies appear or disappear. Alternatively, if you don’t
    know when the target operation starts, it can be helpful to note a point in time
    where the frequency pattern changes. See [Figure 11-18](#figure11-18), where the
    entire spectrum clearly changes at, for example, 5ms and 57ms.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 含有时序信息的频谱图也可以帮助你识别*有趣*的事件。如果你知道目标操作的开始时间，你可能能看到某些频率的出现或消失。或者，如果你不知道目标操作的开始时间，注意频率模式变化的时间点也可能会有所帮助。参见[图11-18](#figure11-18)，在该图中，整个频谱在例如5ms和57ms时刻明显发生了变化。
- en: The change in frequency characteristics of the signal could be due to a cryptographic
    engine being started. Unlike with spectrum analysis, you’re looking at time-based
    information, so this spectrogram method is more sensitive to timing noise.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 信号频率特性的变化可能是由于加密引擎的启动。与频谱分析不同，你现在正在查看基于时间的信息，因此这种频谱图方法对时序噪声更为敏感。
- en: '![f11018](image_fi/278748c11/f11018.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![f11018](image_fi/278748c11/f11018.png)'
- en: 'Figure 11-18: Spectrogram over a cryptographic operation (top) and the original
    trace (bottom)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图11-18：加密操作的频谱图（上图）和原始追踪（下图）
- en: Intermediate Correlations
  id: totrans-175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 中间关联
- en: 'You know now that you can use CPA to determine keys by calculating a correlation
    trace for each key hypothesis. You can use the correlation trace for other purposes
    as well: to detect other data values that are being processed by the target, for
    instance, where the plaintext or ciphertext are being used in an operation. In
    this section, we assume you actually know the data values you want to correlate
    against, so no hypothesis testing is required. The most immediate and interesting
    candidates are plaintext and ciphertext consumed and produced by a cipher algorithm.
    With known data values and a leakage model, you can correlate traces and find
    out if and when those data values leak.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道，你可以使用CPA（相关功率分析）通过计算每个密钥假设的相关追踪来确定密钥。你还可以将相关追踪用于其他目的：例如，检测目标正在处理的其他数据值，例如明文或密文在某个操作中被使用。在本节中，我们假设你已经知道了要关联的数据值，因此不需要进行假设测试。最直接且有趣的候选数据值是由密码算法消耗和产生的明文和密文。通过已知的数据值和泄漏模型，你可以关联追踪并找出这些数据值是否以及何时泄漏。
- en: 'Let’s assume you have an AES encryption for which you know the plaintext of
    each execution, and you know that it leaks the Hamming weight (HW) of 8-bit values.
    You can now correlate the HW of each plaintext byte with your measurements and
    see when the algorithm consumes them; this is also known as *input correlation*.
    Depending on your trace acquisition window, you may see many moments of correlation:
    every bus transfer, buffer copy, or other processing of the plaintext may cause
    a spike. However, one of those spikes could be the actual input to the first `AddRoundKey`,
    soon after which you’ll want to attack the Substitute operation.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个AES加密算法，你知道每次执行时的明文，并且知道它泄漏了8位值的海明重量（HW）。现在，你可以将每个明文字节的HW与测量值进行关联，看看算法何时消耗它们；这也被称为*输入关联*。根据你的追踪采集窗口，你可能会看到很多关联时刻：每次总线传输、缓冲区复制或明文的其他处理操作都可能引起一个尖峰。然而，这些尖峰中的一个可能就是第一个`AddRoundKey`的实际输入，之后你可能会想要攻击替代操作。
- en: Another trick is to calculate the correlation with the ciphertext; this is also
    known as *output correlation*. Although plaintext spikes can theoretically appear
    throughout your trace, ciphertext spikes *can appear only after the crypto has
    completed.* Therefore, the first spike of ciphertext indicates that the crypto
    must have happened before that spike. A good rule of thumb is to dig for crypto
    operations between the first ciphertext spike and the plaintext spike immediately
    before that.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个技巧是计算与密文的相关性；这也被称为*输出关联*。尽管明文尖峰理论上可以出现在整个追踪过程中，密文尖峰*仅在加密操作完成后才会出现*。因此，密文的第一个尖峰表明加密操作必须在该尖峰之前发生。一个好的经验法则是在第一个密文尖峰和紧接其前的明文尖峰之间寻找加密操作。
- en: Observing a spike in ciphertext correlation is a good thing. It’s an indication
    that you have sufficient traces, insignificant misalignment, and a leakage model
    that captures the ciphertext. Of course, not seeing a spike means you need to
    fix any of the above, and you may not necessarily know which one. The approach
    is usually trial and error. Note that with CPA, you are attacking crypto intermediates,
    and not plaintext or ciphertext. Correlation with plaintext or ciphertext is,
    therefore, merely an indication you have your processing right; the actual crypto
    intermediates may need a slightly different alignment, a different filter, or
    more traces.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '在密文相关性中观察到波动是一个好现象。这表明你拥有足够的轨迹、微不足道的对齐误差，并且泄露模型能够捕捉到密文。当然，如果没有看到波动，意味着你需要修正上述任何问题，而你可能不一定知道是哪一个。这个方法通常是通过反复试错进行的。请注意，使用CPA时，你攻击的是加密中间值，而不是明文或密文。因此，与明文或密文的相关性仅表明你的处理是正确的；实际的加密中间值可能需要稍微不同的对齐方式、不同的滤波器，或者更多的轨迹。  '
- en: The final correlation trick you can use if you know the key to a crypto execution
    is *intermediate* *correlation*. If you know the key, ciphertext or plaintext,
    and the type of crypto implementation, you can calculate all intermediate states
    of the cipher algorithm. For instance, you can correlate with the HW of each of
    the 8-bit outputs of `MixColumns` in AES, for every round. This way, you should
    see 16 spikes for each round, slightly delayed with respect to each other. This
    idea can be extended to correlating with the HW of an entire 128-bit AES round
    state at once, which works in parallel implementations of AES.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你知道加密执行的密钥，最终你可以使用的相关性技巧是*中间* *相关性*。如果你知道密钥、密文或明文，并且了解加密实现的类型，你可以计算加密算法的所有中间状态。例如，你可以在AES的每一轮中，针对`MixColumns`的每个8位输出的硬件权重（HW）进行相关性分析。通过这种方式，你应该会看到每一轮有16个波动，这些波动彼此之间稍微有些延迟。这个思路可以扩展到对整个128位AES轮状态的硬件权重进行相关性分析，这适用于AES的并行实现。  '
- en: You can also use this trick to brute-force the leakage model—for instance, by
    not only calculating the HW but also the Hamming distance (HD) and seeing which
    gives the highest spikes. The downside is that you need to know the key, but the
    upside is that if you see spikes here, you’re getting close to a successful CPA.
    (The reason you can’t conclude you’re there yet is because CPA cares about “correct
    spikes” versus “incorrect spikes,” and we’ve analyzed only “correct spikes” here.)
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '你也可以利用这个技巧对泄露模型进行暴力破解——例如，既计算硬件权重（HW），又计算汉明距离（HD），然后观察哪一个出现的波动最大。缺点是你需要知道密钥，但优点是，如果你在这里看到波动，那么你就接近成功的CPA了。（你不能断定已经成功是因为CPA关注的是“正确波动”与“错误波动”的区别，而我们这里只分析了“正确波动”）。  '
- en: Known-Key CPA
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '已知密钥CPA  '
- en: The *known-key CPA* technique combines the results of the CPA and partial guessing
    entropy principles addressed earlier in this chapter to tell whether you actually
    can extract a key. You calculate a full CPA and then use PGE to analyze (for each
    subkey) the rank of the correct key candidate versus the number of traces. Once
    you see subkeys structurally drop in rank, you know you are on to something.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*已知密钥CPA*技术结合了本章前面讨论的CPA结果和部分猜测熵原则，用来判断你是否能够成功提取密钥。你需要计算完整的CPA，然后使用PGE分析（对于每个子密钥）正确的密钥候选排名与轨迹数量之间的关系。一旦你看到子密钥的排名结构性下降，你就知道你有了一些线索。  '
- en: 'Don’t get overexcited when just a few of your keys drop to very low ranks.
    Statistics can produce strange results. They may just as well go up again with
    a growing trace set. Only if most keys drop and stay low may you be on to something.
    We’ve also observed the opposite effect: 9 out of 10 key bytes at rank 1, whereas
    the last one takes forever to find. Again, statistics can produce strange results.
    Only when all subkeys are at a low rank do you enter the territory of being able
    to brute-force your way out.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有少数几个密钥的排名下降到非常低的时候，不要过于兴奋。统计数据可能会产生奇怪的结果。它们也可能随着轨迹集的增大而回升。只有当大多数密钥的排名下降并保持在低位时，你才可能找到了线索。我们也观察到相反的效果：9个密钥字节排名为1，而最后一个密钥却需要很长时间才能找到。同样，统计数据可能会产生奇怪的结果。只有当所有子密钥都排名较低时，你才进入了可以通过暴力破解来解决的阶段。
- en: In contrast to intermediate correlation, this method actually tells you whether
    you can extract a key. However, the computational complexity is significantly
    larger; you need to calculate 256 correlation values for each key byte, instead
    of one correlation value in the case of intermediate correlation. As with intermediate
    correlation, not seeing spikes can be caused by insufficient traces, significant
    misalignment, or a bad leakage model. It may take trial-and-error to determine
    this.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与中间相关性方法相比，这种方法实际上告诉你是否能够提取密钥。然而，计算复杂度要大得多；你需要计算每个密钥字节的256个相关值，而在中间相关性方法中只需计算一个相关值。和中间相关性一样，未能观察到峰值可能是由于轨迹不足、显著的对齐误差或不良的泄漏模型。这可能需要通过反复试验来确定。
- en: Test Vector Leakage Assessment
  id: totrans-186
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试向量泄漏评估
- en: '*Welch’s t-test* is a statistical test used to determine whether two sample
    sets have equal mean values. We’ll use this test to answer a simple question:
    if you have grouped power traces into two sets, are those sets statistically distinguishable?
    That is, if we have performed 100 encryption operations with key A and 100 encryption
    operations with key B, is there a detectable difference in the power traces? If
    the average power consumption of the device at a certain time in the trace differs
    for key A and key B, it might suggest that the device is leaking information.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '*Welch的t检验*是一种统计检验，用于确定两组样本是否具有相等的均值。我们将使用这个检验来回答一个简单的问题：如果你将电源轨迹分成两组，这两组是否在统计上是可区分的？也就是说，如果我们用密钥A执行了100次加密操作，再用密钥B执行了100次加密操作，电源轨迹中是否存在可检测的差异？如果在某个时间点，密钥A和密钥B的设备平均功耗不同，那么这可能表明设备正在泄漏信息。'
- en: 'We apply this test to a certain point in time for each of two sets of power
    traces. The result is the probability that the two sets of power traces have equal
    means at that point in time, regardless of the standard deviation. We’ll intentionally
    create two trace sets, and in each set, the target processes different values.
    If these values give rise to changes in the average power level, we then know
    we have leakage. See the “Trace Set Analysis and Processing” earlier in this chapter
    for notes on acquiring multiple sets and to learn more about choosing the input
    data. We cannot emphasize this enough: if you generated two sets by running 100
    traces with key A and then sequentially after that 100 with key B, your traces
    are useless. The statistical test is almost certain to find a difference between
    them, since physical changes (such as temperature) are quite likely to occur between
    the times when each set was captured. Before acquisition of each trace, randomly
    decide on the PC (not the target) whether it will be with key A or key B. Ask
    us how we know.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个测试应用于每一组电源轨迹的某一时间点。结果是这两组电源轨迹在该时间点具有相同均值的概率，无论标准差如何。我们将故意创建两组轨迹，每一组的目标进程处理不同的值。如果这些值导致平均功率水平发生变化，那么我们就知道存在泄漏。有关如何获取多个轨迹集和选择输入数据的更多信息，请参阅本章前面的“轨迹集分析与处理”部分。我们必须再次强调：如果你通过运行100条使用密钥A的轨迹，接着再运行100条使用密钥B的轨迹来生成这两组轨迹，那么你的轨迹是没有用的。统计测试几乎肯定会发现它们之间的差异，因为在每组轨迹采集时，物理变化（如温度）很可能已经发生。在每条轨迹的采集前，随机决定是使用密钥A还是密钥B（而非目标PC）。问问我们怎么知道。
- en: We can plot the value of Welch’s *t* over time and observe spikes where leakage
    is detected, similar to a correlation trace. The value of Welch’s *t* is calculated
    by
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以绘制Welch的*t*值随时间变化的图像，并观察到泄漏发生时的峰值，类似于相关性轨迹。Welch的*t*值是通过以下公式计算的：
- en: '![e11003](image_fi/278748c11/e11003.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![e11003](image_fi/278748c11/e11003.png)'
- en: where ![e11004](image_fi/278748c11/e11004.png) is the average sample value at
    time *j* for trace set *A*, *var()* is the sample variance, and *D*^(*A*) is the
    number of traces in trace set *A*. The higher *w*[*j*] is, the more likely it
    is that trace set *A* and trace set *B* actually are generated by a process with
    a different mean at time *j*. In our experience, for trace sets of at least a
    few hundred traces, absolute values for *w*[*j*] of say 10 and higher indicate
    that there most likely is leakage, and a CPA attack may succeed if *w*[*j*] is
    80 or higher. In other literature you’ll often see the value of 4.5, which in
    our experience has led to some false positives.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll give you a few sample sets for AES you can test so you get the idea of
    what we’re after here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Create one set with random input data and one set with constant input data.
    The idea is that if the target doesn’t leak, the power measurements inside the
    crypto algorithm should be statistically indistinguishable, even if the characteristics
    of the processed data clearly vary. Note that power measurements of the transporting
    of input data to the crypto engine will probably leak, which this test will detect.
    Obviously, differences in input data are not real leakage and cannot be exploited,
    so watch out for false *t* peaks caused by this “input leakage.”
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create one set where an intermediate data bit ***X*** has the value 0 and another
    set where ***X*** has the value 1. This example is of most interest when testing
    a bit in a middle round of AES, such as any AES state bit after the `SubBytes`
    or `MixColumns` operations in round 5\. With this test, there will be no false
    positives like “input leakage”; bits in round 5 of AES have effectively no correlation
    with the input or output bits of AES. If you want to test Hamming distance leakage,
    you can also calculate bit *X* as the XOR between, for instance, the input and
    output of an entire AES round. You should perform this test with a known key,
    but you can do it with fully random inputs. Since you don’t know which bit *X*
    actually leaks, you can calculate the statistics for all imaginable intermediate
    bits—for instance, for the 3 × 128 bits of state after `AddRoundKey`, `SubBytes`,
    and `MixColumns` (`ShiftRows` doesn’t flip bits) in round 5.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create one set where intermediate ***Y*** is ***A*** and another set where ***Y***
    is not ***A***. This is an extension of the previous idea. You can, for instance,
    test whether one byte of `SubBytes` output has a bias in the power measurements
    when its value is, for example, 0x80\. Again, you can calculate the t-test for
    any intermediate *Y* and value *A*, so you can run 16 × 256 tests for the `Substitute`
    output state in round 5.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create one set where the entire 128-bit round ***R*** state of AES has exactly
    ***N*** bits set to 1 and then create another random set. This one is clever.
    Let’s say we pick round *R* = 5, and we generate a 128-bit state with, say, *N*
    = 16 randomly selected bits set to 1\. This is a significant bias: under normal
    circumstances, on average, 64 bits are set to 1, and it’s highly unlikely for
    the biased state to appear. However, using the known key, we can calculate what
    plaintext would have generated that biased state under that key. Due to the properties
    of crypto, the bytes of these plaintexts will appear uniformly random. The same
    holds for the ciphertext. In fact, when calculating *t*, the only bias you may
    theoretically detect is actually in round *R*, because there shouldn’t be any
    other bias (except for some minor biasing of rounds *R* – 1 and *R* + 1). Therefore,
    you won’t get any *t* spikes caused by transfer of plaintext or ciphertext. Because
    you are biasing an entire round state, you may detect leakage with fewer traces
    than with the previous methods; therefore, it’s a great first way of detecting
    leakage before any CPA method can detect it.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you can see, you can use the t-test to detect various types of leakage. Note
    that we have not specified an explicit power model, which makes the t-test a more
    generic leakage detector than CPA and friends. The biasing of an inner round especially
    amplifies leakage. The t-test is a great tool to determine the timing of leaks,
    the location of EM leaks, or for improving filters by tuning them for the highest
    value of *t*. One cool trick that can help if you have a lot of misalignment is
    first to do an FFT and then calculate *t* in the frequency domain to find out
    at what frequency your leakage is.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The downsides to t-tests are that you may need the key and that these tests
    don’t actually do key extraction. In other words, you’ll still need to use CPA
    and figure out a power model, and you may not succeed. Just like CPA, not seeing
    spikes means you may need to improve your trace processing.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Because you aren’t actually recovering the key, it’s also easy for the t-test
    to produce false positives. These can occur because there is a statistical difference
    between the groups of traces unrelated to cryptographic leakage (for instance,
    due to not properly randomizing your acquisition campaign). In addition, the t-test
    will detect leakage related to the loading or unloading of data from the cryptographic
    core, which may be useless to attack. The t-test simply tells you that two groups
    have the same or different means, and *you* must correctly understand what that
    implies. It is, however, a really handy tool for tweaking your processing techniques:
    if the *t* value goes up, you’re heading in the right direction.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Processing Techniques
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the “Analysis Techniques” section earlier in this chapter, we presented
    some standard methods that provide a measure of how close you are to having a
    good-enough signal for CPA. In this section, we’ll describe some techniques for
    processing trace sets. Some practical advice: check your results after each step
    and twice on Sunday. Otherwise, it’s too easy to make a misstep and lose the leakage
    signal forever. It’s more time-efficient to detect issues earlier rather than
    later when you need to debug your entire processing chain.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Normalizing Traces
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once you have acquired a trace set, it’s always helpful to calculate the average
    and standard deviation per trace, as explained in the “Averages and Standard Deviations
    over Operations (per Sample)” section earlier in this chapter. You’ll see two
    things: outliers that in only one trace will jump outside the “normal” range and
    a slow drift of the normal range due to environmental conditions as well as possible
    errors/bugs in your acquisition. To improve your trace set’s quality, you’ll want
    to drop traces that are outliers by only allowing a certain range of average/standard
    deviation values. After that, you can correct for drift by *normalizing* traces.
    A typical normalization strategy is to subtract the average per trace and divide
    all sample values by the standard deviation for that trace. The result is that
    each trace has an average sample value of 0 and a standard deviation of 1.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Frequency Filtering
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'When capturing data with the oscilloscope, we can use analog filters on the
    input to the scope. These filters can also be computed digitally: a variety of
    environments provides libraries that easily allow you to pass traces through filters.
    Examples include scipy.signal for Python and SPUC for C++. Digital filters form
    the backbone of most digital signal processing work, so most programming languages
    have excellent filtering libraries.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: When doing *frequency* *filtering*, your aim is to take advantage of the fact
    that the leakage signal you are interested in, or some specific source of noise,
    may be present in a distinct part of the frequency spectrum. (The “Spectrum Analysis”
    section earlier in this chapter contains a description of how to analyze the spectrum
    for noise or signal.)
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: By either passing the signal or blocking the noise, you can improve the CPA’s
    effectiveness. You probably want to apply the same filter to the harmonics of
    the base signal; for instance, if your target clock is 4 MHz, it will probably
    help to keep 3.9–4.1, 7.9–8.1, 11.9–12.1 MHz, and so on. If your system has a
    switching regulator adding noise to your measurements, you might need a *high-pass*
    or *band-pass* filter to eliminate that noise. Often, *low-pass* filtering can
    help alleviate high-frequency noise present in these systems, but in some cases,
    your leakage signal is entirely in the high-frequency components, so high-pass
    filtering would rule out any chance of success! In other words, it requires some
    trial and error.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: For DPA, you most likely will be using (multi-)notch filters to pass or block
    base frequencies and their harmonics. A *finite impulse response (FIR)* or *infinite
    impulse response (IIR)* filter design for notch filtering can be complicated;
    you can always revert to the more computationally complex way of doing an FFT,
    and then block/pass arbitrary parts of the spectrum by setting the amplitude to
    0 and doing an inverse FFT.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Resynchronization
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Ideally, we would know when the encryption operation occurs, and we would trigger
    our oscilloscope to record that exact moment in time. Unfortunately, we might
    not have such a precise trigger but instead are triggering our oscilloscope based
    on a message being sent to the microcontroller. The amount of time that passes
    between the microcontroller receiving the message and performing the encryption
    isn’t constant, since it might not immediately act on the message.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: This discrepancy means we need to resynchronize multiple traces. [Figure 11-19](#figure11-19)
    shows three traces before resynchronization (*misaligned traces*), and the same
    three traces after resynchronization (*aligned traces*).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The three traces on the top are not synchronized. By doing a *sum of absolute
    difference (SAD)* process on the three traces, the synchronized output shows a
    clear trace on the bottom.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Applying the SAD method, you take a trace that forms your *reference trace*.
    This is the trace to which you’ll then align all others. From this reference trace,
    you select a group of points, usually some feature that appears in all the traces.
    Finally, you try to shift each trace such that the absolute difference between
    the two traces is minimized. This chapter comes with a small Jupyter notebook
    ([https://nostarch.com/hardwarehacking/](https://nostarch.com/hardwarehacking/))
    that implements the SAD and produces [Figure 11-19](#figure11-19).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![f11019](image_fi/278748c11/f11019.png)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-19: Synchronizing traces using the sum of absolute difference (SAD)
    method'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: An alternative is to use the *circular convolution theorem*.The convolution
    between two signals is basically the point-wise multiplication of two signals
    at different shifts *n*. The value of *n* at which this multiplication has the
    lowest value is the “best fitting” shift for those signals. The naïve calculation
    is very expensive. Luckily, you can obtain a convolution by performing an FFT
    on both signals, multiplying the signals point-wise, and then doing an inverse
    FFT. This process will give you the result of the convolution between two signals
    for each shift value *n*, after which you just need to scan for the minimum.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Several other simple resynchronization modules can be found in the ChipWhisperer
    software. Resynchronizing can become more advanced than simply applying a static
    shift. You might need to warp the traces in time or remove sections of a trace
    where an interrupt occurred in only a handful of traces. We don’t cover these
    details here, but see Jasper G. J. van Woudenberg, Marc F. Witteman, and Bram
    Bakker’s “Improving Differential Power Analysis by Elastic Alignment” for more
    details on *elastic alignment*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Trace Compression
  id: totrans-218
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Capturing long traces can take up a lot of disk and memory space. Using a high-speed
    oscilloscope sampling at GS/s or more, you’ll quickly discover that the size of
    your traces grows annoyingly large. Even worse, the analysis becomes very slow,
    since it is performed on every sample in succession.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: If the real objective is to find some leakage information about each clock cycle,
    you might guess that you don’t need every single sample of every clock cycle.
    Rather, it’s often sufficient to keep one sample from each clock cycle. This is
    called *trace compression*, since you greatly reduce the number of sample points.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: As previously mentioned in this chapter’s “Sampling Rate” section, you can perform
    trace compression by simply downsampling, but doing so won’t yield as much a savings
    as what true trace compression does.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: True trace compression uses a function to determine the value by which to represent
    each clock cycle. It could be the minimum, maximum, or average value over an entire
    clock cycle or over only a part of the entire clock cycle. If your target device
    has a stable crystal oscillator, you can perform this trace compression by taking
    samples at a certain offset from the trigger, since the device and sample clock
    should both be stable. For non-stable clocks, you’ll need to do some clock recovery—for
    instance, by finding peaks indicating clock start. Once you have the clock, you
    may find that only the first *x* percent of a clock cycle contains most of the
    leakage, so you can disregard the rest.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: When compressing EM probe measurements, take into account that the EM signal
    is the derivative of the power signal. So, for a single power spike, there will
    be a positive EM spike followed by a negative one. You don’t want to average the
    positive and negative parts of the captured waves; by their nature they cancel
    out! In this case, you just want to take the sum of the absolute sample values
    for that clock.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Deep Learning Using Convolutional Neural Networks
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Staying relevant requires that a field like side-channel analysis must keep
    up with the machine learning (ML) trends. There are actually two seemingly fruitful
    ways to frame the side-channel problem in terms of machine learning: the first
    being side-channel analysis as a sequence of steps by an (intelligent) agent,
    and the second way being side-channel analysis as a classification problem. This
    research topic is still young at the time of writing, but it’s an important one.
    Side-channel analysis is becoming increasingly important, and there aren’t enough
    of us to keep up with market demands. Any automation such as machine learning
    is crucial.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the *agent* frame: agents observe their world, perform an action,
    and are punished/rewarded in relation to how their actions change the world. We
    could train an agent to decide what steps to take next, such as deciding whether
    to use alignment, filtering, or resampling based on how high a *t* spike is. The
    future will tell whether this is brilliant or foolish, as this topic is currently
    unstudied.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider the *classification problem*. Classification is the science of
    taking in an object and assigning it to a class. For instance, modern-day deep
    learning classifiers can take in an arbitrary image and, with high accuracy, detect
    whether a cat or a dog is in the image. The neural networks used to perform the
    classification are trained by presenting millions of pictures that are already
    labeled with “cat” or “dog.” Training means tuning the network parameters such
    that they detect features in the images representative of either cats or dogs.
    The interesting part about neural networks is that the tuning happens purely by
    observation; no expert needs to describe the features needed to detect “cat” or
    “dog.” (At the time of writing, experts are still needed to design the structure
    of the network and how the network is trained). Side-channel analysis is essentially
    a classification problem: we try to classify intermediate values from traces we
    are presented with. Knowing the intermediate values, we can calculate the key.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-20](#figure11-20) illustrates the process where a neural network
    is being trained to perform side-channel analysis.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '![f11020](image_fi/278748c11/f11020.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-20: Training a neural network for side-channel analysis'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: We’ve replaced our lovely cats and dogs with a cute set of traces, which we
    individually label with the Hamming weight of the intermediate value we are targeting.
    For AES, this label could be the Hamming weight of a specific S-box output. This
    labeled set of traces will be the training set for the neural network, which will
    then, hopefully, learn how to determine the Hamming weight from a given trace.
    The outcome is a trained model that can be used for assigning probabilities over
    the Hamming weights for a new trace.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-21](#figure11-21) shows how a network’s classification can be used
    to obtain confidence values for intermediates (and thus keys).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: This diagram shows the neural network processing a single trace. The trace goes
    through the neural network, which results in a probability distribution over the
    Hamming weights. In this example, the most likely Hamming weight is 6 with a probability
    of 0.65.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: We can train a neural network by presenting it with traces and known intermediate
    values, as shown in [Figure 11-20](#figure11-20), and thereafter let the network
    classify a trace with an unknown intermediate value, as shown in [Figure 11-21](#figure11-21),
    which in effect is an SPA method. Such an SPA analysis can be useful for ECC or
    RSA, where we need to classify chunks of traces that represent the calculation
    over one or a few key bits.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![f11021](image_fi/278748c11/f11021.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-21: Using the network’s classification to help with finding keys'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: 'The DPA approach is to use the probability distribution (which is output of
    the neural network) for intermediate values, transform this probability distribution
    into confidence values over key bytes, and update these confidences for each observed
    trace. Here is where we diverge from usual neural network classification: we don’t
    care about classifying each trace perfectly, as long as on average we bias the
    confidence value for the relevant key byte. In other words, we don’t intend to
    identify a cat or dog perfectly in each picture, but we have a gazillion extremely
    noisy pictures of one animal, and we try to make out whether it is a cat.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'Properly trained networks, specifically convolutional neural networks, detect
    objects irrespective of orientation, scale, irrelevant color changes, and some
    level of noise. So, hypothetically, these networks would be able to reduce human
    effort by analyzing traces that need filtering and alignment. In the 2018 Black
    Hat talk by Jasper, “Lowering the Bar: Deep Learning for Side Channel Analysis”
    (available on YouTube), he shows the work of his co-authors Guilherme Perin and
    Baris Ege.He demonstrates that neural networks are a viable approach for analyzing
    traces of asymmetric crypto and software implementations of symmetric ciphers
    where there is misalignment and some noise. It’s still an open question how well
    this extends to hardware implementation with harder countermeasures. One interesting
    result from the work was that it broke a second-order masked implementation by
    detecting first-order leakage with the network.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this work is to eliminate the need for a human analyst to interpret
    traces. We have not yet reached that goal, though we arguably made it easier by
    shifting the effort to network design, rather than the multidomain complexities
    of side-channel analysis.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the introduction to this chapter, we mentioned it would be about the *art*
    of power analysis, as opposed to the *science* of power analysis. The science
    is the easy part—just trying to understand what the tools do. The art is in applying
    them at the right time in the right way or even designing your own tools. Achieving
    expertise in this art requires experience, which you’ll gain only through experimentation.
    For every skill level, there are interesting targets to play with. In our lab,
    we analyze multi-GHz SoCs, but that requires a team of people who’ve done this
    type of analysis professionally for a few years, and it may take a few months
    to start seeing any leakage. At the other end of the spectrum, in only a few hours,
    we are able to teach how to break the key on a simple microcontroller to people
    without experience. Whatever you play with, try to match it with your experience
    level.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Another great exercise is to build your own countermeasures. Grab a target you’re
    comfortable breaking that allows you to load your own code. Try to think what
    would really make it difficult for you as an attacker to break the implementation;
    one of the tricks to employ is to take one of the steps in your analysis and break
    the assumptions that step makes. A simple one is to randomize the timing of the
    algorithm, which breaks DPA and forces you to do alignment of the traces. This
    way, you improve your system’s security, you improve your attacker skills, and
    you give yourself something to do on the next weekend.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
