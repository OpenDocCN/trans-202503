<html><head></head><body>
<h2 class="h" id="ch11"><span epub:type="pagebreak" id="page_361" class="calibre1"/><strong class="calibre2"><span class="big">11</span><br class="calibre3"/>BIOLOGY</strong></h2>
<div class="bq">
<p class="center"><em class="calibre11">Modern biology is becoming very much a branch of information technology.</em></p>
<p class="center1">—Richard Dawkins</p>
</div>
<div class="image"><img alt="Image" src="../images/common.jpg" class="calibre6"/></div>
<p class="noindent">As Professor Dawkins points out, computation has become a central tool in many areas of biology. This was perhaps inevitable, as evolution is the central organizing principle of biology, and evolution occurs through the transmission of information in the form of a digital storage device known as DNA.</p>
<p class="indent">The biology ecosystem around Julia is sophisticated, wide-ranging, and growing rapidly. The language and its packages are being used in many areas of biological and medical research, in both industry and academia.</p>
<p class="indent">This chapter begins with a brief overview of the Julia biology landscape and proceeds directly to a detailed case study in simulated evolution.</p>
<h3 class="h2" id="ch11lev1"><strong class="calibre2">The Julia Biology Ecosystem</strong></h3>
<p class="noindent">Bioinformatics has become a major subfield of biology that is defined by the use of computers. It mainly deals with the analysis and manipulation of protein sequences, so it has a strong computational linguistics flavor. The BioJulia GitHub organization provides a starting place for browsing this large <span epub:type="pagebreak" id="page_362"/>collection of packages. It includes, among others, modules for handling the various file types that bioinformaticians have devised over the years.</p>
<p class="indent">To discover other Julia packages outside of the bioinformatics organization, we can turn to the general GitHub search methods described in “How to Find Public Packages” on <a href="ch03.xhtml#ch03lev1sec14" class="calibre10">page 80</a>. Many of these packages do not include general tags such as “biology,” so you can find them more easily with focused searches using terms such as <em class="calibre11">phylogenetics</em> or <em class="calibre11">ecology</em>.</p>
<p class="indent">The <span class="literal">Pumas</span> pharmaceutical modeling and simulation toolkit merits particular mention as a major success story for Julia in medicine and biology. <span class="literal">Pumas</span> is used by major corporations and research groups to develop and test drugs. Its GitHub page contains links to extensive documentation and tutorials.</p>
<p class="indent">Many Julia biology packages were created to work with other packages in the areas of statistics, equation solving, or other areas useful in mathematical biology. An example is <span class="literal">EvolutionaryModelingTools</span>, which works with the <span class="literal">DifferentialEquations</span> package (see “Combining DifferentialEquations with Measurements” on <a href="ch09.xhtml#ch09lev1sec20" class="calibre10">page 302</a>), providing macros to assist in setting up problems that use Gillespie’s algorithm (a method for attacking stochastic differential equations) in the simulation of models of infectious disease propagation and problems with a similar structure.</p>
<h3 class="h2" id="ch11lev2"><strong class="calibre2">Simulating Evolution with Agent-Based Modeling</strong></h3>
<p class="noindent"><em class="calibre11">Agent-based modeling (ABM)</em> is a simulation technique using a community of computational entities, the <em class="calibre11">agents</em>, interacting with each other and their environment through a set of <em class="calibre11">rules</em>. The agents may be representations of life forms, vehicles, or something more abstract, such as information. The rules can depend on time, the distance between agents, their movement, the state of the environment near the agent, or nearly anything else we can imagine. Agents may move, store data, die, and be born. The environment itself can change as well.</p>
<p class="indent">Researchers have used ABM to simulate traffic flow, the progress of infectious diseases, the collective behavior of social animals, the spread of opinions, and much more. See “Further Reading” on <a href="ch11.xhtml#fur11" class="calibre10">page 380</a> for some links to background information about this approach, and to documentation of the main packages used in this section.</p>
<p class="indent">Our project will be the simulation of evolution through natural selection in a population of two types of simple creatures representing predators and prey. We will see how the prey creatures, when allowed to inherit their “genes” from their parents, evolve to be better at evading their predators. This evolution results from random mutations in the inherited characteristics combined with the selection pressure from the predators eating the less evasive prey before they have a chance to reproduce.</p>
<p class="indent"><span epub:type="pagebreak" id="page_363"/>The <span class="literal">Agents</span> package provides a framework for a wide variety of ABM calculations. It attends to the lower-level details, such as calculating the motions of agents, enforcing boundary conditions, and searching for neighbors, allowing us to concentrate on programming the rules for agent interaction at a fairly high level.</p>
<p class="indent">The space in which the agents live can be a continuous physical space (the one we will use here); a grid space on which agents can only occupy discrete positions; a more abstract tree space, in which agents are not located physically, but within a tree data structure; and even a space defined on an actual road map, using OpenStreetMap data. The space can become an environment containing spatially and temporally varying conditions affecting the agents.</p>
<p class="indent">The agents have position and velocity properties and a unique ID. We can endow them, as well, with any data structures convenient for our simulation. We can create or destroy agents, or change any of their properties, based on their proximity to other agents, on time, or on environmental conditions. Agent proximity—nearest neighbors or neighbors within a given radius—is returned by a simple function call.</p>
<p class="indent">Any particular project typically will make use of only a small subset of <span class="literal">Agents</span>’s capabilities, and this section’s project is no exception.</p>
<h3 class="h2" id="ch11lev3"><strong class="calibre2">Overview of the Simulation Problem</strong></h3>
<p class="noindent">Our universe will contain two types of creatures: predators and prey. Each type has a simple behavior. Predators chase prey. If a predator manages to get very close to its target, it vanishes from the simulation, devoured by its pursuer. The predators choose their targets from among all those within their detection range, but they are polite: they won’t chase prey that one of their colleagues is already chasing. Predators have only one speed, which is somewhat faster than the one speed with which the prey are able to run. They turn toward their prey as they chase them, but their superior speed is offset by limited agility: they can turn only through some maximum angle at every simulation step. Like some actual predator species, our simulated predators adjust their reproductive rate to maintain a certain ratio of predator population to prey population.</p>
<p class="indent">The prey make turns at regular intervals according to a list of angles; each prey creature has its own list. When it reaches the end of the list, it goes back to the top. Prey don’t react to predators, they simply run around making their prescribed turns. One can imagine that their environment is rich with uniformly distributed food, as a property (which is called <span class="literal">mojo</span> in the program) gets incremented by a fixed amount at every step. If a prey creature manages to reach a predetermined amount of <span class="literal">mojo</span> without getting eaten, it reproduces. Reproduction is fatal; the creature is replaced by two descendants. Each descendant inherits a copy of its parent’s table of angles, with some random mutations.</p>
<p class="indent"><span epub:type="pagebreak" id="page_364"/>The only property that distinguishes different prey individuals, aside from their locations and velocities, is the list of angles. We initialize the agents with a random list, uniformly distributed from –<em class="calibre11">π</em> to <em class="calibre11">π</em>. Some lists of turns will, by chance, be slightly better than others in allowing the agent to survive longer, as they will, on average, make it more difficult for the predators, with their limited agility, to catch it. These agents will be more likely to reproduce, as will their children. Through mutation, some of these children may be even more likely to survive to reproduce. We hope to observe an evolution in the distribution of angles in the prey population, and an average increase in the ability to evade predation, as a result of this selection pressure.</p>
<p class="indent">The foregoing is an overview of the structure and aims of the project. In the next few sections, we’ll put together all the components of our simulation, in the order in which they appear in the complete program, which is assembled for convenience in the code section of the web supplement for this chapter at <a href="https://julia.lee-phillips.org" class="calibre10"><em class="calibre11">https://julia.lee-phillips.org</em></a>. When turning these ideas into a program, we’ll have to make everything concrete. For example, we’ll decide to make the list of angles contain eight elements. Many of these details are, within limits, arbitrary, and the reader might experiment with altering all or some of them, and perhaps improve upon the experiment described here.</p>
<h3 class="h2" id="ch11lev4"><strong class="calibre2">The Predator and Prey Agents</strong></h3>
<p class="noindent">The <span class="literal">Agents</span> package provides a convenient macro for defining our agents:</p>
<pre class="calibre13">using Agents, StatsBase, JLD2, Random

@agent Prey ContinuousAgent{2} begin
    mojo::Float64
    moves::Vector{Float64}
end

@agent Predator ContinuousAgent{2} begin
    victim::Int64
end</pre>
<p class="indent">First we import the needed packages. In addition to <span class="literal">Agents</span>, we need <span class="literal">StatsBase</span> for creating histograms of the angle distributions, <span class="literal">JLD2</span> for saving and loading simulation data (see <a href="ch09.xhtml#ch9lis4" class="calibre10">Listing 9-4</a> on <a href="ch09.xhtml#ch9lis4" class="calibre10">page 289</a>), and <span class="literal">Random</span> for random numbers (see “Random Numbers in Julia” on <a href="ch10.xhtml#ch10lev2" class="calibre10">page 307</a>).</p>
<p class="indent">The <span class="literal">@agent</span> macro defines the agents as composite types. After executing the macros in the listing, we have an agent type called <span class="literal">Prey</span> and another called <span class="literal">Predator</span>. The <span class="literal">ContinuousAgent{2}</span> notation means that the agents are destined to live in a continuous, two-dimensional space, where their positions are defined by a tuple of two floating-point numbers.</p>
<p class="indent">Each instance of <span class="literal">Prey</span> is endowed with two properties: <span class="literal">mojo</span>, the float that will determine when it’s ready to reproduce; and <span class="literal">moves</span>, its vector of <span epub:type="pagebreak" id="page_365"/>angles that determines the path it takes as it wanders blindly through the environment.</p>
<p class="indent">A predator has only one property: <span class="literal">victim</span> will be the ID of the individual prey that it’s chasing. If this is 0, it’s sitting still and waiting for a potential victim to wander within range.</p>
<h4 class="h3" id="ch11lev1sec1"><strong class="calibre2"><em class="calibre4">Constants Defining Model Behavior</em></strong></h4>
<p class="noindent">Certain parameters determining model behavior are defined in a list of constants, shown in <a href="ch11.xhtml#ch11lis1" class="calibre10">Listing 11-1</a>. We can alter these constants to experiment with evolution under different conditions without making changes to the program. These are declared <span class="literal">const</span>, a declaration we should apply to all global quantities in the interests of performance. In general, a program should not use non-<span class="literal">const</span> global variables.</p>
<pre class="calibre13">const NPrey = 16 # Number of Prey agents
const NPred = 8 # Number of Predator agents
const PPR = 0.5 # Predator/prey ratio
const M = 8  # Number of turns
const SBT = 100 # Steps between turns
const TAD = 0.2 # Target acquisition distance
const KD = 0.01 # Kill distance
const LS = 2 # Litter size
const MIPS = 0.1 # Mojo increase per step
const MNFR = 50.0 # Mojo needed for reproduction
const SPEEDR = 1.5 # Ratio (predator speed)/(prey speed)
const LAA = π/128 # Limit of angular agility
const dt = 0.001
const SEED = 43
const rng = Random.MersenneTwister(SEED)
const LF = open("logfile", "a+") # Logfile
const LI = 100 # Log interval</pre>
<p class="list" id="ch11lis1"><em class="calibre11">Listing 11-1: Constants defining the model</em></p>
<p class="indent">The predator population adjusts itself at every step to maintain the <span class="literal">PPR</span>, adding predators if needed and eliminating them if the ratio is more than 5 percent too large.</p>
<p class="indent">The parameter <span class="literal">M</span> is the length of the vector of angles that amounts to the prey’s genome. The prey will proceed in a straight line for <span class="literal">SBT</span> steps before turning through the next angle in the angle vector.</p>
<p class="indent">A predator can “see” a prey creature if it’s closer than the distance <span class="literal">TAD</span>. It begins chasing the first such prey that it sees that is not already being chased. If a predator manages to close the distance to its target to within <span class="literal">KD</span>, the target is eliminated.</p>
<p class="indent">When a prey creature reproduces, it replaces itself with <span class="literal">LS</span> descendants.</p>
<p class="indent">The prey creatures eat continuously as they run, increasing their <span class="literal">mojo</span> by <span class="literal">MIPS</span> every step. The <span class="literal">mojo</span> is really just a measure of how long a creature has survived. Once a prey creature’s <span class="literal">mojo</span> has reached <span class="literal">MNFR</span>, it reproduces.</p>
<p class="indent"><span epub:type="pagebreak" id="page_366"/>The predator’s straight-line speed is <span class="literal">SPEEDR</span> times the prey’s speed. The predator’s ability to corner is limited by <span class="literal">LAA</span>. It turns in the direction of the prey, adjusting its heading at every step, but can turn no more than <span class="literal">LAA</span> radians each time.</p>
<p class="indent">The <span class="literal">Agents</span> integration routine (a simple Euler step) uses a timestep of <span class="literal">dt</span>. This constant serves as an overall scale for agent speeds.</p>
<p class="indent">In order to be able to repeat simulations using identical sequences of random numbers, and to create ensembles of simulations when desired, we’ll use a random number generator with a seed that we can control (see “Random Numbers in Julia” on <a href="ch10.xhtml#ch10lev2" class="calibre10">page 307</a>). This is the purpose of <span class="literal">SEED</span> and the <span class="literal">rng</span>. Also, the <span class="literal">rand()</span> functions are somewhat more efficient when passed an <span class="literal">rng</span>, although this concern is not as acute as it has been in some past versions of Julia and the <span class="literal">Random</span> package.</p>
<h4 class="h3" id="ch11lev1sec2"><strong class="calibre2"><em class="calibre4">Utility Functions</em></strong></h4>
<p class="noindent">We’d like to have a few functions to make the code that orients the predators and changes the direction of the prey more concise:</p>
<pre class="calibre13">function vnorm(v)
    v ./ sqrt(v[1]^2 + v[2]^2)
end

function angle_between(a, b)
    atan(b[2], b[1]) - atan(a[2], a[1])
end

function turn(v, θ)
    M = [cos(θ) -sin(θ); sin(θ) cos(θ)]
    M * [v...]
end</pre>
<p class="indent">We’re going to need to normalize velocity vectors, which means adjusting their lengths to unity. This is what <span class="literal">vnorm()</span> does. The <span class="literal">angle_between()</span> function returns the angle between two vectors. The predators need this to calculate where to turn when chasing their food. And turning, both of predators and prey, relies on <span class="literal">turn()</span>, which, when supplied with a starting vector and an angle, returns the vector rotated through the angle.</p>
<p class="indent">In addition, we need a function to mutate the <span class="literal">moves</span> table. Without this, no evolution takes place:</p>
<pre class="calibre13">function rmutate!(moves, nms)
    for ms in rand(rng, 1:M, nms) # nms random mutation sites
        θ = moves[ms] + (2rand(rng) - 1) * π/4
        # Keep within ±π:
        if abs(θ) &lt; 1π
            moves[ms] = θ
        else
            <span epub:type="pagebreak" id="page_367"/>moves[ms] = (θ - sign(θ) * 2.0π) % 2.0π
        end
    end
end</pre>
<p class="indent">This makes a random change to a specified number of the angles in the table by an angle uniformly distributed from –<em class="calibre11">π</em>/4 to <em class="calibre11">π</em>/4.</p>
<h4 class="h3" id="ch11lev1sec3"><strong class="calibre2"><em class="calibre4">Model Initialization</em></strong></h4>
<p class="noindent">Every <span class="literal">Agents</span> simulation requires, in addition to the agents themselves, three data structures:</p>
<pre class="calibre13">arena = ContinuousSpace((1, 1); periodic=true)
properties = Dict(:stepno =&gt; 0, :total_step =&gt; 0)
model = ABM(Union{Prey, Predator}, arena; properties)</pre>
<p class="indent">The <span class="literal">arena</span> is the space in which the agents live and interact. Our space will be continuous, have coordinates running from 0 to 1 along each dimension, and have periodic boundary conditions. This makes the space infinite in the sense that an agent running off the right side will reemerge on the left side.</p>
<p class="indent">The <span class="literal">properties</span> is a dictionary of quantities relating to the simulation as a whole. In our simulation we use it just to keep track of how many steps have passed. For keeping track of when it’s time for the prey to make a turn, we use <span class="literal">stepno</span> and increment <span class="literal">total_step</span> at each step. The former could be derived from the latter, but maintaining the two counters can be convenient when restarting a simulation from a saved state. We initialize both counters to 0.</p>
<p class="indent">With these two objects in place we can initialize the <span class="literal">model</span>, which maintains the whole simulation state. Checkpointing and restarting the simulation requires merely saving the <span class="literal">model</span> to disk. The two positional arguments of its constructor are the agent types and the space. If we had only one type of agent, the call would look like <span class="literal">ABM(Prey, arena; properties)</span>, for example.</p>
<p class="indent">We choose <span class="literal">properties</span> for the name of the property dictionary because that name is used for a keyword in the model constructor, which makes the call to <span class="literal">ABM</span> simpler (see “Concise Syntax for Keyword Arguments” on <a href="ch06.xhtml#ch06lev1sec1" class="calibre10">page 154</a>).</p>
<div class="note">
<p class="notet"><strong class="calibre2"><span class="notes">NOTE</span></strong></p>
<p class="calibre26"><em class="calibre11">With the version of</em> <span class="codeitalic1">Agents</span> <em class="calibre11">used at the time of writing, we get a warning after constructing the model this way. The message warns us about a potential inefficiency when using a</em> <span class="codeitalic1">Union</span> <em class="calibre11">of agent types. This is an area of ongoing development effort, and the warning will probably disappear in future versions. The inefficiency doesn’t actually become a problem unless we use more than three agent types.</em></p>
</div>
<p class="indent">With <span class="literal">model</span> defined, we can initialize it by adding the agents:</p>
<pre class="calibre13">for i in 1:NPrey # Initialize Prey agents
    vel = vnorm(Tuple(rand(model.rng, 2).-0.5))
 <span epub:type="pagebreak" id="page_368"/><span class="ent">➊</span> moves = π*(2rand(model.rng, M) .- 1)
    add_agent!(Prey, model, vel, 0.0, moves)
end

for i in 1:NPred # Initialize Predator agents
    add_agent!(Predator, model, (0.0, 0.0), 0)
end</pre>
<p class="indent">The <span class="literal">add_agent!()</span> function is named using an exclamation point to remind us that it mutates one of its arguments: it alters <span class="literal">model</span> by adding agents to it. This function creates an agent at a random position within the <span class="literal">arena</span>. It expects an agent type as a first argument, the model in the second position, and a tuple giving the agent’s initial <em class="calibre11">x</em> and <em class="calibre11">y</em> velocities. Positional arguments following the third are passed to the agent constructor. Therefore, in the first loop, each <span class="literal">add_agent!()</span> call will create a <span class="literal">Prey</span> instance using <span class="literal">Prey(0.0, moves)</span>. The initial <span class="literal">mojo</span> is set to 0, and the starting vector of angles is randomly set <span class="ent">➊</span>.</p>
<h3 class="h2" id="ch11lev5"><strong class="calibre2">Functions to Extract Information from the Model</strong></h3>
<p class="noindent">Let’s look at some more short utility functions that accept the <span class="literal">model</span> as an argument and return information about its current state. We’ll use some of them in the calculation and others to extract data that we’ll store and use later when we analyze the results.</p>
<p class="indent">First we’ll need functions to give us a vector of all the prey or predators in the system:</p>
<pre class="calibre13">function preys(model)
    [a for a in allagents(model) if a isa Prey]
end

function predators(model)
    [a for a in allagents(model) if a isa Predator]
end</pre>
<p class="indent">Inside the list comprehensions we use the <span class="literal">allagents()</span> function, which creates an iterator over the agents of a model.</p>
<p class="indent">The following suggestively named functions simply call the ones just shown and return the lengths of the agent vectors:</p>
<pre class="calibre13">function number_of_predators(model)
    length(predators(model))
end

function number_of_preys(model)
    length(preys(model))
end</pre>
<p class="indent">Since the predators do not compete for prey with their colleagues, they need to know if a potential meal is already under pursuit:</p>
<pre class="calibre13"><span epub:type="pagebreak" id="page_369"/>function being_chased(model)
    [a.victim for a in predators(model)]
end</pre>
<p class="indent">This function returns a vector of all the <span class="literal">ID</span>s of prey creatures that are marked as victims by some predator. In order to determine if a potential meal is not already being chased, a predator checks whether its <span class="literal">ID</span> is in this list.</p>
<p class="indent">As mentioned earlier, we expect the vectors of angles to evolve. One way to get an overview of this process is to observe the evolution of the distribution of angles in the population (see “Distributions” on <a href="ch10.xhtml#ch10lev7" class="calibre10">page 321</a> for an overview of the concept of a distribution).</p>
<p class="indent">The following function gathers all the angles in all the <span class="literal">moves</span> vectors from all the prey creatures and returns a <span class="literal">Histogram</span> data structure representing a binning of the distribution into 40 equal buckets. We can then normalize and plot the results at various timesteps to analyze one aspect of the simulation:</p>
<pre class="calibre13">function moves_dist_data(model)
    moves_data = [m.moves for m in preys(model)]
    all_angles = [i for a in moves_data for i in a]
    fit(Histogram, all_angles, -π:2π/40:π)
end</pre>
<p class="indent">This function, and its use of <span class="literal">fit()</span> and the <span class="literal">Histogram</span> data structure, are the reason we imported the <span class="literal">StatsBase</span> package. The pattern in the comprehension in the second line, with its two <span class="literal">for</span> loops, is a common way to flatten a collection of collections.</p>
<h4 class="h3" id="ch11lev1sec4"><strong class="calibre2"><em class="calibre4">Stepping Through the Simulation</em></strong></h4>
<p class="noindent">The <span class="literal">agent_step!()</span> and <span class="literal">model_step!()</span> functions are at the core of any <span class="literal">Agents</span> simulation. At every timestep, the <span class="literal">agent_step!()</span> function updates each agent as it’s selected by the <em class="calibre11">scheduler</em>. This update can include moving the agent, changing its velocity, altering the values of its properties, or anything else that makes sense to apply to individual agents. The scheduler is the component of the calculation that selects which agents to update and in what order. In most <span class="literal">Agents</span> simulations, we can leave the order unspecified; allowing the scheduler to update the agents in an arbitrary order is the fastest option.</p>
<p class="indent">After the <span class="literal">agent_step!()</span> function comes (by default) the <span class="literal">model_step!()</span> function, which makes updates that apply to the model as a whole. This includes updates that require access to the entire agent population, including those that search for near neighbors.</p>
<p class="indent">The <span class="literal">agent_step!()</span> function is required, but <span class="literal">model_step!()</span> is optional; our calculation uses both. Also, there is an option to perform <span class="literal">model_step!()</span> before <span class="literal">agent_step!()</span> if the calculation needs that.</p>
<h5 class="h4" id="ch11sec1sec1"><span epub:type="pagebreak" id="page_370" class="calibre1"/><strong class="calibre2">Stepping the Agents</strong></h5>
<p class="noindent">The following shows the entire function for updating both predator and <span class="literal">Prey</span> agents:</p>
<pre class="calibre13">
function agent_step!(agent, model)
    move_agent!(agent, model, dt)
    if agent isa Predator &amp;&amp; agent.victim &gt; 0
        if agent.victim in keys(model.agents)
            if euclidean_distance(agent, model[agent.victim], model) &lt; KD
                kill_agent!(model[agent.victim], model)
                agent.victim = 0
                agent.vel = (0.0, 0.0) # Time to rest a bit <span class="ent">➊</span>
            else
                θp = angle_between(agent.vel,
                     get_direction(agent.pos, model[agent.victim].pos, model))
                θf = min(abs(θp), LAA) * sign(θp) <span class="ent">➋</span>
                agent.vel = Tuple(turn(agent.vel, θf))
            end
        else
            agent.victim = 0 # Already gone
        end
    end
    victims = being_chased(model)
    if agent isa Predator &amp;&amp; agent.victim == 0
        food = [a for a in nearby_agents(agent, model, TAD)
                if (a isa Prey &amp;&amp; !(a in victims))]
        if !isempty(food)
            agent.victim = food[1].id
            append!(victims, food[1].id)
           agent.vel = SPEEDR .* vnorm(get_direction(agent.pos, food[1].pos, model)) <span class="ent">➌</span>
        end
    end
    if agent isa Prey
        if agent.mojo &gt;= MNFR # Reproduce: add LS new Preys at my position
            for c in 1:LS
                child = add_agent!(agent.pos, Prey, model,
                                   vnorm(Tuple(rand(model.rng, 2).-0.5)), 0, agent.moves)
                rmutate!(child.moves, 2)
            end
            kill_agent!(agent, model) # Reproduction is fatal <span class="ent">➍</span>
        end
        if model.stepno == 0
            vel = turn(agent.vel, agent.moves[1])
            agent.vel = Tuple(vel) <span class="ent">➎</span>
            agent.moves = circshift(agent.moves, -1)
        <span epub:type="pagebreak" id="page_371"/>end
        agent.mojo += MIPS # I eat as I run
    end
end</pre>
<p class="indent">The <span class="literal">agent_step!()</span> function (which can be named anything, but we’ve used the conventional name) must accept <span class="literal">agent</span> and <span class="literal">model</span> as arguments. The scheduler passes each agent in turn to the function as it cycles through them.</p>
<p class="indent">The first line moves the agent by an amount determined through the timestep, <span class="literal">dt</span>.</p>
<p class="indent">We then kill off any <span class="literal">Prey</span> agents that have been caught by the predators that are chasing them, where “caught” means that the distance between them has become less than <span class="literal">KD</span>. We use <span class="literal">euclidean_distance()</span>, a function built into the package, to measure this distance.</p>
<p class="indent">After the meal, the predator waits, stationary <span class="ent">➊</span>, for another available prey to come within range.</p>
<p class="indent">If the prey is too far away to eat, we continue the chase by turning toward it. The first step is finding the current angle between the predator’s velocity vector and the vector between the positions of the predator and its prey. Fortunately, <span class="literal">Agents</span> comes with a function just for this: <span class="literal">get_direction()</span>. In calling this function, we use two additional features of the <span class="literal">model</span>: an agent’s position tuple is available as <span class="literal">agent.pos</span>, and <span class="literal">model[i]</span> returns the agent with <span class="literal">ID i</span>. Although <span class="literal">model</span>s aren’t arrays, the <span class="literal">Agents</span> package defines a <span class="literal">getindex()</span> method that enables this. After limiting the turning angle <span class="ent">➋</span> to the predator’s agility, set with the constant <span class="literal">LAA</span>, we update its velocity.</p>
<p class="indent">We then check for any sufficiently close eligible prey: any <span class="literal">Prey</span> agent within a distance <span class="literal">TAD</span> that’s not already being chased. If we find one, we set the predator’s velocity vector to point toward the prey, again using <span class="literal">get_direction()</span> <span class="ent">➌</span>.</p>
<p class="indent">Turning to the prey creatures, first we check if they have accumulated enough <span class="literal">mojo</span> to reproduce. Those who have enough give birth to <span class="literal">LS</span> copies, which are then mutated. We kill off the parent using the <span class="literal">kill_agent!()</span> function <span class="ent">➍</span>, which is part of the <span class="literal">Agents</span> package.</p>
<p class="indent">When it’s time to make a turn, we rotate the velocity using our <span class="literal">turn()</span> function. We need to convert the result to a <span class="literal">Tuple</span> <span class="ent">➎</span> because the package uses those to store agent velocities.</p>
<p class="indent">After making the turn, we rotate the agent’s private turn table with a function that we’re using for the first time: <span class="literal">circshift()</span>, which rotates an array. This invocation rotates the <span class="literal">moves</span> vector to the left, so its second element becomes its first and its first becomes its last. The outcome is that the prey makes the <span class="literal">M</span> turns stored in <span class="literal">moves</span> repeatedly (if it survives long enough to do so).</p>
<h5 class="h4" id="ch11sec1sec2"><span epub:type="pagebreak" id="page_372" class="calibre1"/><strong class="calibre2">Stepping the Model</strong></h5>
<p class="noindent">After the scheduler updates all the agents, it calls this function, passing the model as an argument:</p>
<pre class="calibre13">function model_step!(model)
    model.stepno = (model.stepno + 1) % SBT
    model.total_step += 1

    # Maintain predator/prey ratio:
    predators_pop = length(predators(model))
    prey_pop = length(preys(model))
    if predators_pop/prey_pop &lt; PPR
        for i in 1:Int(round(PPR*prey_pop - predators_pop))
            add_agent!(Predator, model, (0.0, 0.0), 0)
        end
    end
    if predators_pop/prey_pop &gt; 1.05PPR
        for i in 1:Int(round(predators_pop - PPR*prey_pop))
         <span class="ent">➊</span> kill_agent!(random_agent(model, a -&gt; a isa Predator), model)
        end
    end
    # Logging and checkpointing:
    if model.total_step % LI == 0
        write(LF, "$(model.total_step), $prey_pop, $predators_pop \n")
        flush(LF)
    end
end</pre>
<p class="indent">First we increment <span class="literal">model_step</span>, using modular arithmetic to maintain a cycle of length <span class="literal">SBT</span>; then we increment the total step. Since <span class="literal">total_step</span>, as well as its other properties, is stored along with the model, we can checkpoint and seamlessly restart the simulation by using <span class="literal">JLD2</span> to save and reload the model, and <span class="literal">total_step</span> will keep track of how long it’s been run.</p>
<p class="indent">We maintain the predator/prey ratio specified with <span class="literal">PPR</span> by adding or removing predators as needed. The <span class="literal">add_agent()</span> function from <span class="literal">Agents</span> adds an agent at a random position. The tuple in the argument list is its initial velocity, and subsequent arguments are passed to the agent constructor. In this case, there is only one such argument: the initial <span class="literal">victim</span> property is set to 0.</p>
<p class="indent">We remove agents by passing a random agent to <span class="literal">kill_agent()</span> using the function <span class="literal">random_agent()</span> <span class="ent">➊</span>. This <span class="literal">Agents</span> function takes, in its optional second argument, a function expressing a condition that the potentially doomed agent must satisfy.</p>
<p class="indent">Finally, the routine maintains a logfile, writing an entry every <span class="literal">LI</span> steps. We <span class="literal">flush()</span> the logfile so that we can take a look at it while the simulation is running. Without this call, the file may not be written until the calculation ends.</p>
<h4 class="h3" id="ch11lev1sec5"><span epub:type="pagebreak" id="page_373" class="calibre1"/><strong class="calibre2"><em class="calibre4">Running the Simulation</em></strong></h4>
<p class="noindent">The <span class="literal">run!()</span> function is <span class="literal">Agents</span>’s basic facility for stepping through a model, as shown in <a href="ch11.xhtml#ch11lis2" class="calibre10">Listing 11-2</a>. Its four positional arguments are the model, the function for updating the agents, the optional function for updating the model, and the total number of steps.</p>
<pre class="calibre13">function evolve!(model, nruns, nsteps_per_run)
    for run in 1:nruns
        adf, mdf = run!(model, agent_step!, model_step!, nsteps_per_run;
                        adata=[:mojo],
                        mdata=[:total_step, number_of_predators,
                               number_of_preys, moves_dist_data])

        jldsave("mdf$run"; mdf)
        jldsave("model$run"; model)
    end
end

evolve!(model, 10, 1000)</pre>
<p class="list" id="ch11lis2"><em class="calibre11">Listing 11-2: Running the simulation</em></p>
<p class="indent">It returns two dataframes (see “CSV Files” on <a href="ch10.xhtml#ch10lev1sec6" class="calibre10">page 332</a>): one for the agents and one for the model. The <span class="literal">adata</span> keyword argument is a <span class="literal">Vector</span> of quantities to include in the agent dataframe, and the <span class="literal">mdata</span> keyword argument is for the model dataframe. These quantities can be agent or model properties, which become symbols, or functions of the <span class="literal">model</span>. In the value for <span class="literal">mdata</span>, we’re using three functions that we defined with this in mind: we’re keeping track of the two population sizes and the angle distribution.</p>
<p class="indent">We’ve wrapped <span class="literal">run!()</span> in a function that calls it <span class="literal">nruns</span> times, each time asking it to run the model for <span class="literal">nsteps_per_run</span> steps, and uses the save function from <span class="literal">JLD2</span> to store the model dataframe and the entire model to disk.</p>
<p class="indent">To load the model from its saved version on disk, we can enter</p>
<pre class="calibre13"><span class="codestrong">mode = load(<span class="codeitalic">filepath</span>, "model")</span></pre>
<p class="noindent">where the string argument specifies the variable to be loaded from the file.</p>
<h4 class="h3" id="ch11lev1sec6"><strong class="calibre2"><em class="calibre4">Visualizing System Behavior</em></strong></h4>
<p class="noindent">The most convenient way to get a snapshot of the model at any time, or to create an animation of its progress, is to use two functions provided by the <span class="literal">InteractiveDynamics</span> package, which needs a separate import:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using InteractiveDynamics, CairoMakie</span></pre>
<p class="indent">We need to import a <span class="literal">Makie</span> library as well because <span class="literal">InteractiveDynamics</span> uses it for drawing. <span class="literal">Makie</span> is a graphics framework along more or less the same lines as the current standard, <span class="literal">Plots</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_374"/>As we plan to create visualizations of our model with its two agent types, let’s create functions that map the agent types to two distinct colors and shapes:</p>
<pre class="calibre13">function agent_color(agent)
   if agent isa Prey
       return :blue
   end
   if agent isa Predator &amp;&amp; agent.victim &gt; 0
       return :red
   end
   return :green
end

function agent_shape(agent)
   if agent isa Prey
       return '•'
   end
   return '⊙'
end</pre>
<p class="indent">These functions, when used together, will render prey creatures as blue dots and predators as circles with dots inside them. Predators on the chase will be red, while idle predators will be green.</p>
<p class="indent">After evolving the model to any step using <span class="literal">run!()</span>, we can create and save a picture of its state with the following calls:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">fig, _ = abmplot(model; ac=agent_color, as=20, am=agent_shape)</span>
julia&gt; <span class="codestrong">save("model_snapshot.pdf", fig)</span></pre>
<p class="indent">The plotting function, <span class="literal">abmplot()</span>, returns two values, of which we only need the first. The agent color (<span class="literal">ac</span>) and agent shape (<span class="literal">am</span>) use our functions defined earlier, and we set the agent marker size (<span class="literal">as</span>) to a value that worked well in the visualization. <a href="ch11.xhtml#ch11fig1" class="calibre10">Figure 11-1</a> shows the result after 10,000 steps.</p>
<div class="image1"><img alt="Image" id="ch11fig1" src="../images/ch11fig01.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 11-1: The model configuration at step 10,000</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_375"/>At the moment shown in <a href="ch11.xhtml#ch11fig1" class="calibre10">Figure 11-1</a>, there are 139 total agents. None of the predators happen to be idle at this moment, so they are all rendered in the same color.</p>
<p class="indent">We can also create an animation of the model using <span class="literal">abmvideo()</span>, which is supplied by <span class="literal">InteractiveDynamics</span> as well. It actually runs the model, beginning with the initial state supplied in its second argument, stepping through it using the same step functions that we supply to <span class="literal">run!()</span>:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">abmvideo("arena.mp4", model, agent_step!, model_step!;</span>
         <span class="codestrong">ac=agent_color, am=agent_shape,</span>
         <span class="codestrong">frames=500, framerate=30)</span></pre>
<p class="indent">The run stops after the number of steps given in the <span class="literal">frames</span> keyword argument, and the video file is saved with the name given in the first argument. We can use constants or, as we did here, functions for agent shapes and colors, as in <span class="literal">abmplot()</span>. You can view some animations made with this method in the online supplement for this chapter.</p>
<p class="indent"><span epub:type="pagebreak" id="page_376"/>Animations are excellent devices for verifying that an ABM simulation is working as intended and for communicating the results when the dynamic behavior is interesting. However, running the model through <span class="literal">abmvideo()</span> is much slower than running it with <span class="literal">run!()</span> because, in addition to the model calculations, the function renders an image at each step using <span class="literal">abmplot()</span> and assembles a video file. A strategy for long-running agent simulations, therefore, may be to run the calculation using <span class="literal">run!()</span> and then render subsets of steps as animations. This strategy requires periodically saving the model, as we do in our example within <span class="literal">agent_step!()</span>, so we have various saved states available to start from.</p>
<p class="indent">Two additional quirks to note about <span class="literal">abmvideo()</span> are that it doesn’t use the convention of the exclamation point in its name, despite mutating the model, and that it cannot generate dataframes directly as can <span class="literal">run!()</span>. We can get around this last issue by putting data recording into <span class="literal">model_step!()</span>, as we did in our example with logging. This is a more flexible approach in any case, as it allows us more control over the recorded data. For example, we might decide to add a row to the dataframes less frequently than every step.</p>
<p class="indent">The <span class="literal">CairoMakie</span> graphics library is appropriate for making high-quality plots and animations saved in files. For more immediate feedback, we can import <span class="literal">GLMakie</span> instead. If both are imported, the calls <span class="literal">GLMakie.activate!()</span> and <span class="literal">CairoMakie.activate!()</span> switch between them. When <span class="literal">GLMakie</span> is active, <span class="literal">abmplot()</span> and <span class="literal">abmvideo()</span> open a dedicated graphics window when using the REPL, or they can insert graphics into a computational notebook.</p>
<h3 class="h2" id="ch11lev6"><strong class="calibre2">Analyzing the Results</strong></h3>
<p class="noindent">The call to run the simulation in <a href="ch11.xhtml#ch11lis2" class="calibre10">Listing 11-2</a> stores the distribution of angles in the prey angle tables in the model dataframe at every timestep. These angles are initially uniformly distributed, so if the distribution changes over time, we know that some form of evolution is occurring. The angle distribution over the population doesn’t tell us everything about its character, but if we reach a point where the distribution has stopped evolving, this suggests that the population may have achieved some form of optimum in response to the selection pressure exerted by the predators.</p>
<p class="indent">We can plot a histogram of the distribution at any step by extracting <span class="literal">moves_dist_data</span> from the model dataframe. The dataframe for the 20th run looks like this:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">mdf20 = load("mdf20", "mdf")</span>
1001×5 DataFrame
  Row | step   total_step  number_of_predators  number_of_preys  moves_dist_data
      | Int64  Int64       Int64                Int64            ...Histogram
----------------------------------------------------------------------------------------------
    1 |     0       19000                 1787             3447  Histogram{Int64, 1, Tuple...
    2 |     1       19001                 1787             3444  Histogram{Int64, 1, Tuple...
    3 |     2       19002                 1787             3438  Histogram{Int64, 1, Tuple...
    4 |     3       19003                 1787             3434  Histogram{Int64, 1, Tuple...
  :   |   :        :                :                  :                         :
  <span epub:type="pagebreak" id="page_377"/>999 |   998       19998                 2559             5075  Histogram{Int64, 1, Tuple...
 1000 |   999       19999                 2559             5072  Histogram{Int64, 1, Tuple...
 1001 |  1000       20000                 2559             5069  Histogram{Int64, 1, Tuple...</pre>
<p class="indent">Here is the call to plot the histogram from the last row in this dataframe:</p>
<pre class="calibre13">julia&gt; <span class="codestrong">using LinearAlgebra, Plots</span>

julia&gt; <span class="codestrong">Plots.plot(normalize(mdf20.moves_dist_data[end], mode=:pdf);</span>
                  <span class="codestrong">xticks=([-π:π/2:π;], ["-π", "-π/2", "0", "π/2", "π"]),</span>
                  <span class="codestrong">legend=false, xlabel="θ", ylabel="PDF(θ)")</span></pre>
<p class="indent">We need the <span class="literal">LinearAlgebra</span> package for the <span class="literal">normalize()</span> function, which rescales the histogram of raw counts into one that can be interpreted as a probability density function (see “Probability Density Functions” on <a href="ch10.xhtml#ch10lev1sec4" class="calibre10">page 325</a>). This allows us to compare distributions from populations of different sizes directly. At this stage, there are 5,069 <span class="literal">Prey</span> agents, as can be read off from the dataframe, and comparing the distribution at earlier times shows that it seems to have converged to the shape shown in <a href="ch11.xhtml#ch11fig2" class="calibre10">Figure 11-2</a>.</p>
<div class="image1"><img alt="Image" id="ch11fig2" src="../images/ch11fig02.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 11-2: Evolved angle distribution</em></p>
<p class="indent">A bit of reflection reveals why the prey creatures may have evolved such a distribution. The predators are significantly faster than their prey (<span class="literal">SPEEDR</span> <span class="literal">= 1.5</span>) but they have severely limited agility: <span class="literal">LAA =</span> π<span class="literal">/128</span>, which means that they can turn no more than 1.4° in any step. If the prey try to run in a straight line, the predators are likely to catch them before they have a chance to reproduce. This fact produces the pronounced dip in the distribution near 0°. Making sharp turns of close to 180° buys the most time, and that’s where we find the peaks in the distribution.</p>
<p class="indent"><span epub:type="pagebreak" id="page_378"/>If this idea, that the prey have “learned” to avoid predators with these particular attributes, is correct, then a different species of predator with different attributes should give rise to a different angle distribution.</p>
<p class="indent">To test this idea, we need simply to change the <span class="literal">LAA</span> and <span class="literal">SPEEDR</span> constants and run the simulation again. After trying this with <span class="literal">SPEEDR = 1.05</span> and <span class="literal">LAA</span> = π<span class="literal">/16</span>, we observe the distribution shown in <a href="ch11.xhtml#ch11fig3" class="calibre10">Figure 11-3</a> after 13,000 steps.</p>
<div class="image1"><img alt="Image" id="ch11fig3" src="../images/ch11fig03.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 11-3: Evolved angle distribution with slower but more agile predators</em></p>
<p class="indent">This result is distinctly different and admits a clear intuitive explanation. These predators can only travel 5 percent faster than the prey, so their potential victims can often survive long enough to reproduce by simply continuing in something close to a straight line. Although slow, they are far more agile than the predators in the previous simulation, able to turn through 11.25° at each step, so prey who make many large turns are more likely to be caught. Hence we see a distribution with a broad peak near 0°, falling off at larger angles.</p>
<p class="indent">The distribution evolution is suggestive, but let’s see if we can confirm the idea that the prey have evolved to be better predator avoiders. We’ll do this by comparing the evolved population to unevolved populations with uniform distributions of angles in their <span class="literal">moves</span> tables. Since we use a seeded random number generator, we can create ensembles of populations by running the simulation multiple times while varying the <span class="literal">SEED</span>.</p>
<p class="indent">The ability of a population to survive in an environment with predators of a particular type is its <em class="calibre11">fitness</em>. The predators’ type in our model is defined by two parameters: <span class="literal">SPEEDR</span> and <span class="literal">LAA</span>, their speed and agility.</p>
<p class="indent">To test the fitness of the initial, unevolved population, we start with 200 <span class="literal">Prey</span> agents and 100 <span class="literal">Predator</span> agents, and turn off the <span class="literal">Prey</span> agents’ ability to reproduce. In such a situation, the prey population should decay roughly <span epub:type="pagebreak" id="page_379"/>exponentially, eventually dwindling to zero. We perform this experiment 10 times.</p>
<p class="indent">To test the fitness of the evolved population, we load the model after 20,000 steps and extract a random sample of 200 <span class="literal">Prey</span> agents from it. We put that sample into the arena with 100 predators and observe the population decay, repeating this experiment 10 times as well. Each experiment uses a different random seed, so we’ll get a different random sample each time.</p>
<p class="indent"><a href="ch11.xhtml#ch11fig4" class="calibre10">Figure 11-4</a> shows the results: the evolved population performs distinctly better than the initial population.</p>
<div class="image1"><img alt="Image" id="ch11fig4" src="../images/ch11fig04.jpg" class="calibre6"/></div>
<p class="figcap"><em class="calibre11">Figure 11-4: Comparing fitness</em></p>
<p class="indent">Of course, the evolved population becomes extinct as well, as it must without the ability to reproduce. But the comparison shows that the sharpturn strategy suggested by <a href="ch11.xhtml#ch11fig2" class="calibre10">Figure 11-2</a> is effective, as this population decays more slowly.</p>
<h3 class="h2" id="ch11lev7"><strong class="calibre2">Conclusion</strong></h3>
<p class="noindent">In this chapter, I presented a complete, detailed example of a research problem: we began with some curiosity about whether we could simulate natural selection acting on specific attributes of a population. Then we made the question concrete by devising a scenario where behavior was codified by a list of eight numbers. Next, we constructed a simulation capturing the mechanisms we wanted to study and observed that the simulation displayed evolution of the population, apparently converging to some optimum. Lastly, we tested the evolved population and found that it did have increased fitness.</p>
<p class="indent">The <span class="literal">Agents</span> package, and Julia’s expressiveness and efficiency, dramatically streamlined the path from initial speculation to a verifiable, quantitative, <span epub:type="pagebreak" id="page_380"/>and easily visualized result. The ability to try out a variety of scenarios and analyze and view the results, all within a unified interactive environment, and with no compromise in performance, is an unprecedented boon for the researcher.</p>
<div class="box">
<p class="boxtitle-d" id="fur11"><strong class="calibre2">FURTHER READING</strong></p>
<ul class="calibre12">
<li class="noindent1">For more information on BioJulia, the “bioinformatics infrastructure for the Julia language,” see <a href="https://biojulia.dev" class="calibre10"><em class="calibre11">https://biojulia.dev</em></a>.</li>
<li class="noindent1">The article “Julia for Biologists” provides an overview of the use of the language in biology: <a href="https://arxiv.org/abs/2109.09973" class="calibre10"><em class="calibre11">https://arxiv.org/abs/2109.09973</em></a>.</li>
<li class="noindent1">More details on <span class="literal">Agents.jl</span> is available at <a href="https://juliadynamics.github.io/Agents.jl/stable/" class="calibre10"><em class="calibre11">https://juliadynamics.github.io/Agents.jl/stable/</em></a>.</li>
<li class="noindent1">Watch a video about <span class="literal">Agents.jl</span> here: <a href="https://youtu.be/Iaco6v6TVXk" class="calibre10"><em class="calibre11">https://youtu.be/Iaco6v6TVXk</em></a>.</li>
<li class="noindent1">A detailed survey of the field of artificial life is available at <a href="https://www.ais.uni-bonn.de/SS09/skript_artif_life_pfeifer_unizh.pdf" class="calibre10"><em class="calibre11">https://www.ais.uni-bonn.de/SS09/skript_artif_life_pfeifer_unizh.pdf</em></a>.</li>
<li class="noindent1">For interesting anecdotes about artificial life simulations, visit <a href="https://direct.mit.edu/artl/article/26/2/274/93255/The-Surprising-Creativity-of-Digital-Evolution-A" class="calibre10"><em class="calibre11">https://direct.mit.edu/artl/article/26/2/274/93255/The-Surprising-Creativity-of-Digital-Evolution-A</em></a>.</li>
</ul>
</div>
</body></html>