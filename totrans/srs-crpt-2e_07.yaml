- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">BLOCK
    CIPHERS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">分组密码</samp>
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: During the Cold War, the United States and the Soviets developed their own ciphers.
    The US government created the Data Encryption Standard (DES), which was adopted
    as a federal standard from 1979 to 2005, while the KGB developed GOST 28147-89,
    an algorithm kept secret until 1990 and still used today. In 2000, the US-based
    National Institute of Standards and Technology (NIST) selected the successor to
    DES, the Advanced Encryption Standard (AES), an algorithm developed in Belgium
    and now found in most electronic devices. AES, DES, and GOST 28147-89 are all
    *block ciphers*, a type of cipher that combines a core algorithm working on blocks
    of data with a *mode of operation*, or a technique to process sequences of data
    blocks.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 冷战时期，美国和苏联各自开发了自己的密码。美国政府创建了数据加密标准（DES），该标准从1979年到2005年作为联邦标准使用，而苏联KGB则开发了GOST
    28147-89，这是一个直到1990年才公开的算法，至今仍在使用。2000年，美国国家标准与技术研究院（NIST）选择了DES的继任者——高级加密标准（AES），该算法在比利时开发，现在广泛应用于大多数电子设备。AES、DES和GOST
    28147-89都是*分组密码*，这是一种将处理数据块的核心算法与*操作模式*结合起来的密码类型，后者用于处理数据块序列。
- en: This chapter reviews the core algorithms that underlie block ciphers, discusses
    their modes of operation, and explains how they all work together. It also discusses
    how AES works and concludes with coverage of a classic attack tool from the 1970s,
    the meet-in-the-middle attack, and a favorite attack technique of the 2000s—padding
    oracles.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章回顾了构成分组密码的核心算法，讨论了它们的工作模式，并解释了它们如何协同工作。还讨论了AES的工作原理，并以介绍一种经典的攻击工具——1970年代的“中间人攻击”和2000年代流行的攻击技术——填充Oracle攻击作为结尾。
- en: <samp class="SANS_Futura_Std_Bold_B_11">What Is a Block Cipher?</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">什么是分组密码？</samp>
- en: 'A block cipher consists of an encryption algorithm and a decryption algorithm:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个分组密码由加密算法和解密算法组成：
- en: The *encryption algorithm* (**E**) takes a key, *K*, and a plaintext block,
    *P*, and produces a ciphertext block, *C*. We write an encryption operation as
    *C* = **E**(*K*, *P*).
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加密算法* (**E**) 接收一个密钥 *K* 和一个明文数据块 *P*，并生成一个密文数据块 *C*。我们将加密操作写作 *C* = **E**(*K*,
    *P*)。'
- en: The *decryption algorithm* (**D**) is the inverse of the encryption algorithm
    and decrypts a message to the original plaintext, *P*. We write this operation
    as *P* = **D**(*K*, *C*).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*解密算法* (**D**) 是加密算法的逆操作，将密文解密还原为原始明文 *P*。我们将此操作写作 *P* = **D**(*K*, *C*)。'
- en: Since they’re the inverse of each other, the encryption and decryption algorithms
    usually involve similar operations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是彼此的逆操作，加密和解密算法通常涉及相似的操作。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Goals</samp>
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">安全目标</samp>
- en: If you’ve followed earlier discussions about encryption, randomness, and indistinguishability,
    the definition of a secure block cipher will come as no surprise. We’ll continue
    to define security as random-looking-ness, so to speak.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经跟随之前关于加密、随机性和不可区分性的讨论，那么安全分组密码的定义应该不会让你感到惊讶。我们将继续将安全性定义为类似随机的特性，可以这么说。
- en: For a block cipher to be secure, it should be a *pseudorandom permutation (PRP)*,
    meaning that as long as the key is secret, an attacker shouldn’t be able to compute
    an output of the block cipher from any input. That is, as long as *K* is secret
    and random from an attacker’s perspective, they should have no clue what **E**(*K*,
    *P*) looks like, for any given *P*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保证分组密码的安全性，它应该是一个*伪随机置换（PRP）*，意味着只要密钥是保密的，攻击者就不应能够从任何输入计算出分组密码的输出。也就是说，只要*K*对攻击者而言是保密且随机的，他们应该无法知道**E**(*K*,
    *P*)的具体样式，无论给定什么样的*P*。
- en: More generally, attackers should be unable to discover any *pattern* in the
    input/output values of a block cipher. In other words, it should be impossible
    to tell a block cipher from a truly random permutation, given black-box access
    to the encryption and decryption functions for some fixed and unknown key. By
    the same token, attackers should be unable to recover a secure block cipher’s
    secret key; otherwise, they could use that key to tell the block cipher from a
    random permutation. This implies that attackers can’t predict the plaintext that
    corresponds to a given ciphertext the block cipher produces.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般来说，攻击者不应能够在块密码的输入/输出值中发现任何*模式*。换句话说，给定黑盒访问加密和解密函数以及某个固定且未知的密钥，应该无法将块密码与真正的随机置换区分开来。同样，攻击者也应该无法恢复安全块密码的密钥；否则，他们可以利用该密钥将块密码与随机置换区分开来。这意味着攻击者无法预测与给定密文对应的明文，即块密码所生成的密文。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Block Size</samp>
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">块大小</samp>
- en: 'Two values characterize a block cipher: the block size and the key size. Security
    depends on both values. Most block ciphers have either 64-bit or 128-bit blocks—DES’s
    blocks have 64 (2⁶) bits, and AES’s blocks have 128 (2⁷) bits. In computing, lengths
    that are generally measured as powers of two simplify data processing, storage,
    and addressing. But why 2⁶ and 2⁷ and not 2⁴ or 2^(16) bits?'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 块密码由两个值来表征：块大小和密钥大小。安全性依赖于这两个值。大多数块密码要么使用64位块，要么使用128位块——DES的块为64位（2⁶），AES的块为128位（2⁷）。在计算中，通常以2的幂来度量的长度简化了数据处理、存储和寻址。但为什么是2⁶和2⁷而不是2⁴或2^(16)位呢？
- en: It’s important that a block cipher’s blocks aren’t too large in order to minimize
    both the length of ciphertext and the memory footprint. Block ciphers first transform
    their input data into a sequence of blocks, which means that to encrypt a 16-bit
    message when blocks are 128 bits, you need to convert the message into a 128-bit
    block for the block cipher to process it and return a 128-bit ciphertext. The
    wider the blocks, the longer this overhead. To process a 128-bit block, you need
    at least 128 bits of memory. Blocks of 64, 128, or even 512 bits are short enough
    to fit in the registers of most CPUs or to implement using dedicated hardware
    circuits, allowing for efficient implementations in most cases. But larger blocks
    (for example, several kilobytes long) can have a noticeable impact on the cost
    and performance of implementations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 块密码的块大小不宜过大，以便最小化密文长度和内存占用。块密码首先将输入数据转换为一系列块，这意味着如果块的大小为128位，要加密一个16位的消息，需要将该消息转换为一个128位的块，以便块密码进行处理并返回一个128位的密文。块越宽，这种开销就越大。处理一个128位的块，至少需要128位内存。64位、128位甚至512位的块足够小，可以适应大多数CPU的寄存器或通过专用硬件电路实现，从而在大多数情况下实现高效的加密。然而，较大的块（例如，几个千字节长）可能会对实现的成本和性能产生明显影响。
- en: When ciphertexts’ length or memory footprint is critical, you may have to use
    64-bit blocks because these produce shorter ciphertexts and consume less memory.
    Otherwise, 128-bit or larger blocks are better, mainly because modern CPUs can
    often process 128-bit blocks more efficiently than 64-bit ones and they’re more
    secure (see the “Sweet32” attack, at *[https://<wbr>sweet32<wbr>.info](https://sweet32.info)*).
    In particular, CPUs can leverage instructions to efficiently process one or more
    128-bit blocks in parallel—for example, the Advanced Vector Extensions (AVX) family
    of instructions in Intel CPUs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当密文的长度或内存占用至关重要时，可能需要使用64位块，因为它们产生较短的密文并消耗更少的内存。否则，128位或更大的块更好，主要是因为现代CPU通常比64位块更高效地处理128位块，而且它们更安全（参见“Sweet32”攻击，见
    *[https://<wbr>sweet32<wbr>.info](https://sweet32.info)*）。特别是，CPU可以利用指令高效地并行处理一个或多个128位块——例如，英特尔CPU中的高级矢量扩展（AVX）指令集。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Codebook Attack</samp>
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">字典攻击</samp>
- en: 'While blocks shouldn’t be too large, they also shouldn’t be too small; otherwise,
    they may be susceptible to *codebook attacks*, which are attacks against block
    ciphers that are efficient only when using smaller blocks. With 16-bit blocks,
    the codebook attack works like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然块不应过大，但也不应过小；否则，它们可能会受到*字典攻击*的威胁，字典攻击是针对块密码的攻击，这种攻击仅在使用较小的块时才有效。使用16位块时，字典攻击的工作原理如下：
- en: 1.  Get the 65,536 (2^(16)) ciphertexts corresponding to each 16-bit plaintext
    block.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 获取与每个16位明文块对应的65,536（2^(16)）个密文。
- en: 2.  Build a lookup table—the *codebook*—mapping each ciphertext block to its
    corresponding plaintext block.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  构建一个查找表——*代码本*——将每个密文块映射到其对应的明文块。
- en: 3.  To decrypt an unknown ciphertext block, look up its corresponding plaintext
    block in the table.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  要解密一个未知的密文块，在表中查找其对应的明文块。
- en: When using 16-bit blocks, the lookup table needs only 2^(16) × 16 = 2^(20) bits
    of memory, or 128 kilobytes. With 32-bit blocks, memory needs to grow to 16 gigabytes,
    which is still manageable. But with 64-bit blocks, you’d have to store 2^(70)
    bits (a zettabit, or 128 exabytes), so forget about it. Codebook attacks are therefore
    not an issue for larger blocks of 128 bits or more.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用16位区块时，查找表只需要2^(16) × 16 = 2^(20)位的内存，约为128千字节。使用32位区块时，内存需求增加到16GB，仍然可以管理。但是，使用64位区块时，你必须存储2^(70)位（一个zettabit，或者128
    exabytes），那时就不行了。因此，对于128位或更大区块，代码本攻击并不是问题。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How to Construct Block Ciphers</samp>
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">如何构建区块密码</samp>
- en: 'There exist hundreds of block ciphers but only a handful of techniques to construct
    one. In practice, a block cipher isn’t a gigantic algorithm but a repetition of
    *rounds*, a short sequence of operations that’s weak on its own but strong in
    number. There are two main techniques to construct a round: substitution–permutation
    networks (as in AES) and Feistel schemes (as in DES). In this section, you’ll
    look at these techniques after viewing an attack that works when all rounds are
    identical to each other.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 存在数百种区块密码，但只有少数几种构建方法。实际上，区块密码并不是一个巨大的算法，而是一个轮次的重复——一种单独看可能很弱，但通过数量上来补强的短序列操作。构建一个轮次的主要方法有两种：替代-置换网络（如在AES中）和费斯特尔方案（如在DES中）。在这一部分中，你将先查看当所有轮次相同的时候，如何通过一种攻击来破解，然后再了解这些技术。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Block Cipher’s
    Rounds</samp>
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">区块密码的轮次</samp>
- en: Computing a block cipher boils down to computing a sequence of rounds*.* In
    a block cipher, a round is a basic transformation that’s simple to specify and
    to implement and is iterated several times to form the block cipher’s algorithm.
    This construction, consisting of a small component repeated many times, is simpler
    to implement and to analyze than a construction that consists of a single huge
    algorithm.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 计算区块密码实际上就是计算一系列的轮次*。* 在区块密码中，轮次是一个基本的变换，容易指定和实现，并且重复多次以形成区块密码的算法。这种结构由一个小的组件多次重复，比起由一个巨大的算法组成的结构，更容易实现和分析。
- en: For example, a block cipher with three rounds encrypts a plaintext by computing
    *C* = **R**[3](**R**[2](**R**[1](*P*))), where the rounds are **R**[1], **R**[2],
    and **R**[3], and *P* is a plaintext. Each round should also have an inverse so
    it’s possible for a recipient to compute back to plaintext. Specifically, *P*
    = **iR**[1](**iR**[2](**iR**[3](*C*))), where **iR**[1] is the inverse of **R**[1],
    and so on.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个具有三轮的区块密码通过计算 *C* = **R**[3](**R**[2](**R**[1](*P*))) 来加密一个明文，其中轮次是 **R**[1]、**R**[2]
    和 **R**[3]，*P* 是明文。每一轮还应该有一个逆操作，这样接收者就能够解密回明文。具体地，*P* = **iR**[1](**iR**[2](**iR**[3](*C*)))，其中
    **iR**[1] 是 **R**[1] 的逆操作，以此类推。
- en: The round functions—**R**[1], **R**[2], and so forth—are usually identical algorithms,
    but they are parameterized by a value we call the *round key*. Two round functions
    with two distinct round keys will behave differently and will therefore produce
    distinct outputs if fed with the same input.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 轮函数——**R**[1]、**R**[2]等——通常是相同的算法，但它们由一个我们称之为*轮密钥*的值进行参数化。两个具有不同轮密钥的轮函数会表现不同，因此，如果输入相同，它们会产生不同的输出。
- en: We derive round keys from the main key, *K*, using a *key schedule* algorithm.
    For example, **R**[1] takes the round key *K*[1], **R**[2] takes the round key
    *K*[2], and so on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过主密钥*K*使用*密钥调度*算法来推导轮密钥。例如，**R**[1]使用轮密钥*K*[1]，**R**[2]使用轮密钥*K*[2]，依此类推。
- en: Round keys should be different from each other in every round. For that matter,
    not all round keys should be equal to the key *K*; otherwise, all the rounds would
    be identical, and the block cipher would be less secure, as I’ll describe next.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每一轮的轮密钥应该彼此不同。也就是说，并非所有的轮密钥都应该与密钥*K*相等；否则，所有的轮次将会是相同的，区块密码的安全性将降低，接下来我将描述这一点。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Slide Attack</samp>
    <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">and Round Keys</samp>
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">滑动攻击</samp> <samp
    class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">和轮密钥</samp>
- en: In a block cipher, no round should be identical to another round in order to
    avoid a *slide attack*. As [Figure 4-1](chapter4.xhtml#fig4-1) shows, slide attacks
    look for two plaintext/ciphertext pairs (*P*[1], *C*[1]) and (*P*[2], *C*[2]),
    where *P*[2] = **R**(*P*[1]) if **R** is the cipher’s round. When rounds are identical,
    the relation between the two plaintexts, *P*[2] = **R**(*P*[1]), implies the relation
    *C*[2] = **R**(*C*[1]) between their respective ciphertexts. [Figure 4-1](chapter4.xhtml#fig4-1)
    shows three rounds, but the relation *C*[2] = **R**(*C*[1]) will hold no matter
    the number of rounds, be it 3, 10, or 100\. The problem is that knowing the input
    and output of a single round often helps recover the key. (For details, read the
    1999 paper “Advanced Slide Attacks” by Alex Biryukov and David Wagner, available
    at *[https://<wbr>www<wbr>.iacr<wbr>.org<wbr>/archive<wbr>/eurocrypt2000<wbr>/1807<wbr>/18070595<wbr>-new<wbr>.pdf](https://www.iacr.org/archive/eurocrypt2000/1807/18070595-new.pdf)*.)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在分组密码中，任何一轮不应与另一轮相同，以避免*滑动攻击*。如[图 4-1](chapter4.xhtml#fig4-1)所示，滑动攻击会寻找两个明文/密文对（*P*[1]，*C*[1]）和（*P*[2]，*C*[2]），其中*P*[2]
    = **R**(*P*[1])，**R**是密码的轮次。当轮次相同的时候，两个明文之间的关系*P*[2] = **R**(*P*[1])，就意味着它们的密文之间有相同的关系*C*[2]
    = **R**(*C*[1])。图 4-1展示了三个轮次，但关系*C*[2] = **R**(*C*[1])无论轮次数为3、10还是100都会成立。问题在于，知道某一轮的输入和输出往往有助于恢复密钥。（详情请参阅1999年由Alex
    Biryukov和David Wagner撰写的论文《高级滑动攻击》，可通过*[https://www.iacr.org/archive/eurocrypt2000/1807/18070595-new.pdf](https://www.iacr.org/archive/eurocrypt2000/1807/18070595-new.pdf)*获取。）
- en: '![](../images/fig4-1.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig4-1.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: The principle of
    the slide attack against block ciphers with identical rounds</samp>'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-1：针对具有相同轮次的分组密码的滑动攻击原理</samp>
- en: Using different round keys as parameters ensures that the rounds will behave
    differently and thus foil slide attacks.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的轮密钥作为参数可以确保各个轮次的行为不同，从而防止滑动攻击。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*One potential byproduct and benefit of using round keys is protection against*
    side-channel attacks*, or attacks that exploit information leaked from the implementation
    of a cipher (for example, electromagnetic emanations). If the transformation from
    the main key,* K*, to a round key,* K[i]*, isn’t invertible, then if an attacker
    finds* K[i]*, they can’t use that key to find* K*. Unfortunately, few block ciphers
    have a one-way key schedule. The key schedule of AES allows attackers to compute*
    K *from any round key,* K[i]*, for example.*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用轮密钥的一个潜在副产品和好处是防止*旁路攻击*，即利用密码实现过程中泄露的信息进行的攻击（例如，电磁辐射）。如果从主密钥* K*到轮密钥*K[i]*的转换是不可逆的，那么如果攻击者找到*K[i]*，他们就不能利用该密钥找到*K*。不幸的是，很少有分组密码具有单向密钥调度。AES的密钥调度允许攻击者从任何轮密钥*K[i]*计算*K*，例如。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Substitution–Permutation
    Networks</samp>
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">替代-置换网络</samp>
- en: If you’ve read textbooks about cryptography, you’ve likely come across confusion
    and diffusion. *Confusion* means that the input (plaintext and encryption key)
    undergoes complex transformations, and *diffusion* means that these transformations
    depend equally on all bits of the input. At a high level, confusion is about depth,
    whereas diffusion is about breadth. In the design of a block cipher, confusion
    and diffusion take the form of substitution and permutation operations, which
    we combine within substitution–permutation networks (SPNs).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你读过关于密码学的教科书，可能会接触到“混淆”和“扩散”这两个概念。*混淆*意味着输入（明文和加密密钥）会经历复杂的转换，而*扩散*意味着这些转换对输入的每一位都依赖相同。总体来说，混淆关注的是深度，而扩散关注的是广度。在分组密码的设计中，混淆和扩散通过替代和置换操作的形式体现，我们将其结合在替代-置换网络（SPN）中。
- en: Substitution often appears in the form of *S-boxes*, or *substitution boxes*,
    which are small lookup tables that transform chunks of 4 or 8 bits. For example,
    the first of the eight S-boxes of the block cipher Serpent is composed of the
    16 elements (3 8 f 1 a 6 5 b e d 4 2 7 0 9 c), where each element represents a
    4-bit nibble. This particular S-box maps the 4-bit nibble 0000 to 3 (0011), the
    4-bit nibble 0101 (5 in decimal) to 6 (0110), and so on.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 替代通常以*S盒*或*替代盒*的形式出现，它们是小型查找表，用来转换4位或8位的块。例如，分组密码Serpent的八个S盒中的第一个由16个元素（3 8
    f 1 a 6 5 b e d 4 2 7 0 9 c）组成，每个元素表示一个4位的nibble。这个特定的S盒将4位nibble 0000映射为3（0011），将4位nibble
    0101（十进制为5）映射为6（0110），依此类推。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*S-boxes must be carefully chosen to be cryptographically strong: they should
    be as nonlinear as possible (inputs and outputs should be related with complex
    equations) and have no statistical bias (meaning, for example, that flipping an
    input bit should potentially affect any of the output bits).*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*S盒必须小心选择以确保其密码学强度：它们应尽可能非线性（输入和输出应通过复杂的方程式相关联），且没有统计偏差（例如，翻转一个输入位应该可能影响输出位的任何位）。*'
- en: 'The permutation in a substitution–permutation network can be as simple as changing
    the order of the bits, which is easy to implement but doesn’t mix up the bits
    very much. Instead of a reordering of the bits, some ciphers use basic linear
    algebra and matrix multiplications to mix up the bits: they perform a series of
    multiplication operations with fixed values (the matrix’s coefficients) and then
    add the results. Such operations can quickly create dependencies between all the
    bits within a cipher and thus ensure strong diffusion. For example, the block
    cipher FOX transforms a 4-byte vector (*a*, *b*, *c*, *d*) to (*a*′, *b*′, *c*′,
    *d*′), which we define as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 替换–置换网络中的置换可以像改变位的顺序一样简单，这种方法容易实现，但并没有很好地混合位。某些密码算法使用基本的线性代数和矩阵乘法来混合位：它们执行一系列固定值（矩阵系数）的乘法操作，然后将结果相加。这种操作可以迅速在所有位之间创建依赖关系，从而确保强的扩散性。例如，块加密算法FOX将一个4字节向量
    (*a*, *b*, *c*, *d*) 转换为 (*a*′, *b*′, *c*′, *d*′)，我们定义如下：
- en: '![](../images/pg66-1.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg66-1.jpg)'
- en: In these equations, we interpret the numbers 2 and 253 as binary polynomials
    rather than integers; hence, we define additions and multiplications a bit differently
    than what we’re used to. For example, instead of having 2 + 2 = 4, we have 2 +
    2 = 0\. Regardless, each byte in the initial state affects all 4 bytes in the
    final state.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些方程中，我们将2和253解释为二进制多项式，而不是整数；因此，我们对加法和乘法的定义与我们习惯的略有不同。例如，我们不是有 2 + 2 = 4，而是
    2 + 2 = 0。无论如何，初始状态中的每个字节都会影响最终状态中的所有4个字节。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Feistel Schemes</samp>
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">费斯特尔方案</samp>
- en: 'In the 1970s, IBM engineer Horst Feistel designed a block cipher, Lucifer,
    that works as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在1970年代，IBM工程师霍斯特·费斯特尔设计了一种块加密算法Lucifer，其工作原理如下：
- en: 1.  Split the 64-bit block into two 32-bit halves, *L* and *R*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  将64位块拆分为两个32位的部分 *L* 和 *R*。
- en: 2.  Set *L* to *L* ⊕ **F**(*R*), where **F** is a substitution–permutation round.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  将 *L* 设置为 *L* ⊕ **F**(*R*)，其中 **F** 是一个替换–置换轮。
- en: 3.  Swap the values of *L* and *R*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  交换 *L* 和 *R* 的值。
- en: 4.  Go to step 2 and repeat 15 times.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  返回第2步并重复15次。
- en: 5.  Merge *L* and *R* into the 64-bit output block.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  将 *L* 和 *R* 合并为64位输出块。
- en: This construction is a *Feistel scheme*, as [Figure 4-2](chapter4.xhtml#fig4-2)
    shows. The left side is the scheme as just described; the right side is a functionally
    equivalent representation where, instead of swapping *L* and *R*, rounds alternate
    the operations *L* = *L* ⊕ **F**(*R*) and *R* = *R* ⊕ **F**(*L*).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构是一个*费斯特尔方案*，如[图4-2](chapter4.xhtml#fig4-2)所示。左侧是前面描述的方案；右侧是一个功能等效的表示形式，其中，轮次交替执行
    *L* = *L* ⊕ **F**(*R*) 和 *R* = *R* ⊕ **F**(*L*) 的操作，而不是交换 *L* 和 *R*。
- en: '![](../images/fig4-2.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig4-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: The Feistel scheme
    block cipher construction in two equivalent forms</samp>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图4-2：费斯特尔方案块加密结构的两种等效形式</samp>
- en: I’ve omitted the keys from [Figure 4-2](chapter4.xhtml#fig4-2) to simplify the
    diagrams, but note that the first **F** takes a round key, *K*[1], and the second
    **F** takes another round key, *K*[2]. In DES, the **F** functions take a 48-bit
    round key, which it derives from the 56-bit key, *K*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我已省略[图4-2](chapter4.xhtml#fig4-2)中的密钥，以简化图示，但请注意，第一个 **F** 使用一个轮密钥 *K*[1]，第二个
    **F** 使用另一个轮密钥 *K*[2]。在DES中，**F**函数使用一个48位的轮密钥，它从56位密钥 *K* 中推导出来。
- en: In a Feistel scheme, the **F** function can be either a pseudorandom permutation
    (PRP) or a pseudorandom function (PRF). A PRP yields distinct outputs for any
    two distinct inputs, whereas a PRF will have values *X* and *Y* for which **F**(*X*)
    = **F**(*Y*). But in a Feistel scheme, that difference doesn’t matter as long
    as **F** is cryptographically strong.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在费斯特尔方案中，**F**函数可以是伪随机置换（PRP）或伪随机函数（PRF）。PRP对于任何两个不同的输入都会产生不同的输出，而PRF则可能有 *X*
    和 *Y* 的值，使得 **F**(*X*) = **F**(*Y*)。但是在费斯特尔方案中，这种差异并不重要，只要 **F** 是密码学上强的。
- en: How many rounds should there be in a Feistel scheme? Well, DES performs 16 rounds,
    whereas GOST 28147-89 performs 32 rounds. If the **F** function is as strong as
    possible, four rounds are sufficient in theory, but real ciphers use more rounds
    to defend against potential weaknesses in **F**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在费斯特尔结构中应该进行多少轮？嗯，DES执行16轮，而GOST 28147-89执行32轮。如果**F**函数尽可能强大，从理论上讲，四轮就足够了，但现实中的加密算法使用更多轮来防御**F**中的潜在弱点。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Advanced Encryption Standard</samp>
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">高级加密标准</samp>
- en: AES is the most-used cipher in the world. Prior to the adoption of AES, the
    standard cipher in use was DES, with its ridiculous 56-bit security, as well as
    the upgraded version of DES known as Triple DES, or 3DES. Although 3DES provides
    a higher level of security (112-bit security), it’s inefficient because the key
    needs to be 168 bits long to get 112-bit security, and it’s slow in software (DES
    was created to be fast in integrated circuits, not on mainstream CPUs). AES fixes
    both issues.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: AES是世界上使用最广泛的密码算法。在AES被采用之前，使用的标准密码是DES，它的56位安全性极其低，还有升级版的DES，即Triple DES或3DES。尽管3DES提供了更高的安全级别（112位安全性），但它的效率较低，因为为了获得112位安全性，密钥需要达到168位，并且它在软件中的速度较慢（DES的设计初衷是为了在集成电路中运行快速，而不是在主流CPU上）。AES解决了这两个问题。
- en: NIST standardized AES in 2000 as a replacement for DES, at which point it became
    the world’s de facto encryption standard. Most commercial encryption products
    today support AES, and the NSA has approved it for protecting top-secret information.
    (Some countries do prefer to use their own ciphers, largely because they don’t
    want to use a US standard, but AES is actually more Belgian than it is American.)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: NIST在2000年将AES标准化为DES的替代方案，从那时起，它成为了世界上事实上的加密标准。今天，大多数商业加密产品都支持AES，NSA也批准了它用于保护最高机密信息。（一些国家确实更倾向于使用自己的密码算法，主要是因为它们不想使用美国的标准，但AES实际上比美国更具比利时特色。）
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*AES went by the name* Rijndael *(a portmanteau for its inventors’ names, Rijmen
    and Daemen, pronounced like “rain-dull”) when it was one of the 15 candidates
    in the AES competition, the process held by NIST from 1997 to 2000 to specify
    “an unclassified, publicly disclosed encryption algorithm capable of protecting
    sensitive government information well into the next century,” as stated in the
    1997 announcement of the competition in the* Federal Register. *The AES competition
    was a kind of “Got Talent” competition for cryptographers, where anyone could
    participate by submitting a cipher or breaking other contestants’ ciphers.*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*AES在成为AES竞赛中的15个候选算法之一时，曾以*Rijndael*（这是其发明者Rijmen和Daemen的名字合成词，发音类似于“rain-dull”）命名。该竞赛由NIST于1997年至2000年举行，目的是指定“一个未分类、公开披露的加密算法，能够有效保护敏感政府信息，直到下个世纪”，正如1997年在*《联邦公报》*中发布的竞赛公告所述。*AES竞赛就像是密码学家的“才艺大赛”，任何人都可以通过提交密码或破解其他参赛者的密码来参与。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES Internals</samp>
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES内部结构</samp>
- en: AES processes blocks of 128 bits using a secret key of 128, 192, or 256 bits,
    with the 128-bit key being the most common because it makes encryption slightly
    faster and because the difference between 128- and 256-bit security is meaningless
    for most applications.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: AES处理128位的块，使用128位、192位或256位的秘密密钥，其中128位密钥最为常见，因为它使加密稍微更快，并且对于大多数应用来说，128位和256位安全性的差异并不重要。
- en: Whereas some ciphers work with individual bits or 64-bit words, AES manipulates
    *bytes*. It views a 16-byte plaintext as a two-dimensional array of bytes (*s*
    = *s*[0], *s*[1], . . . , *s*[15]), as [Figure 4-3](chapter4.xhtml#fig4-3) illustrates.
    (We use the letter *s* because this array is the *internal state*, or just *state*.)
    AES transforms the bytes, columns, and rows of this array to produce a final value
    that is the ciphertext.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些密码算法处理单个比特或64位字不同，AES处理的是*字节*。它将16字节的明文视为一个二维字节数组（*s* = *s*[0]，*s*[1]，…，*s*[15]），如[图4-3](chapter4.xhtml#fig4-3)所示。（我们使用字母*s*是因为这个数组是*内部状态*，简称*状态*。）AES通过转换这个数组的字节、列和行来生成最终的密文。
- en: '![](../images/fig4-3.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig4-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: The internal state
    of AES as a 4×4 array of 16 bytes</samp>'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图4-3：AES的内部状态，作为一个4×4的16字节数组</samp>
- en: To transform its state, AES uses an SPN structure as in [Figure 4-4](chapter4.xhtml#fig4-4),
    with 10 rounds for 128-bit keys, 12 for 192-bit keys, and 14 for 256-bit keys.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-4.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-4: The internal operations
    of AES</samp>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-4](chapter4.xhtml#fig4-4) shows the four building blocks of an AES
    round (note that all but the last round are a sequence of SubBytes, ShiftRows,
    MixColumns, and AddRoundKey):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '**AddRoundKey **XORs a round key to the internal state.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '**SubBytes **Replaces each byte (*s*[0], *s*[1] . . . , *s*[15]) with another
    byte according to an S-box. In this example, the S-box is a lookup table of 256
    elements.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '**ShiftRows **Shifts the *i*th row of *i* positions, for *i* ranging from 0
    to 3 (see [Figure 4-5](chapter4.xhtml#fig4-5)).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '**MixColumns **Applies the same linear transformation to each of the four columns
    of the state (that is, each group of cells with the same shade of gray, as on
    the left side of [Figure 4-5](chapter4.xhtml#fig4-5)).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-5.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-5: ShiftRows rotates
    bytes within each row of the internal state.</samp>'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Remember that in an SPN, the *S* stands for substitution and the *P* for permutation.
    Here, the substitution layer is SubBytes, and the permutation layer is the combination
    of ShiftRows and MixColumns.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The key schedule function KeyExpansion, as [Figure 4-4](chapter4.xhtml#fig4-4)
    shows, is the AES key schedule algorithm. This expansion creates 11 round keys
    (*K*[0], *K*[1], . . . , *K*[10]) of 16 bytes each from the 16-byte key, using
    the same S-box as SubBytes and a combination of XORs. One important property of
    KeyExpansion is that given any round key, *K*i, an attacker can determine all
    other round keys as well as the main key, *K*, by reversing the algorithm. The
    ability to get the key from any round key reduces the cipher’s resistance to side-channel
    attacks, where an attacker may easily recover a round key.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Without these operations, AES would be totally insecure. Each operation contributes
    to AES’s security in a specific way:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Without KeyExpansion, all rounds would use the same key, *K*, and AES would
    be vulnerable to slide attacks.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without AddRoundKey, encryption wouldn’t depend on the key; hence, anyone could
    decrypt any ciphertext without the key.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SubBytes brings nonlinear operations, which add cryptographic strength. Without
    it, AES would just be a large system of linear equations that can be solved using
    high school algebra (namely, Gaussian elimination).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without ShiftRows, changes in a given column would never affect the other columns,
    meaning you could break AES by building four 2^(32)-element codebooks for each
    column. (Remember that in a secure block cipher, flipping a bit in the input should
    affect all the output bits.)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without MixColumns, changes in a byte wouldn’t affect any other bytes of the
    state. A chosen-plaintext attacker could then decrypt any ciphertext after storing
    16 lookup tables of 256 bytes each that hold the encrypted values of each possible
    value of a byte.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有 MixColumns，字节的变化不会影响状态中的任何其他字节。选择明文攻击者可以通过存储每个字节可能值的加密值的 16 个 256 字节的查找表来解密任何密文。
- en: 'Notice in [Figure 4-4](chapter4.xhtml#fig4-4) that the last round of AES doesn’t
    include the MixColumns operation. That operation is omitted to save useless computation:
    because MixColumns is linear, you could cancel its effect in the very last round
    by combining bits in a way that doesn’t depend on their value or the key. However,
    we can’t invert SubBytes without the state’s value being known prior to AddRoundKey.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 [图 4-4](chapter4.xhtml#fig4-4) 中，AES 的最后一轮不包括 MixColumns 操作。此操作被省略以节省不必要的计算：因为
    MixColumns 是线性的，你可以通过一种不依赖于其值或密钥的方式在最后一轮中消除其效果。然而，我们无法在不知道状态值的情况下逆转 SubBytes，除非在
    AddRoundKey 之前已知该值。
- en: 'To decrypt a ciphertext, AES unwinds each operation by taking its inverse function:
    the inverse lookup table of SubBytes reverses the SubBytes transformation, ShiftRow
    shifts in the opposite direction, MixColumns’s inverse is applied (as in the matrix
    inverse of the matrix encoding its operation), and AddRoundKey’s XOR is unchanged
    because the inverse of an XOR is another XOR.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密一个密文，AES 通过取其逆函数来逐步恢复每个操作：SubBytes 的逆查找表会逆转 SubBytes 变换，ShiftRow 会向相反方向移动，MixColumns
    的逆运算被应用（如同矩阵运算的矩阵逆），AddRoundKey 的 XOR 保持不变，因为 XOR 的逆操作还是 XOR。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES in Action</samp>
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES 实践</samp>
- en: As an exercise, you can use Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">cryptography</samp>
    library to encrypt and decrypt a block of data with AES, as in [Listing 4-1](chapter4.xhtml#Lis4-1).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以使用 Python 的 <samp class="SANS_TheSansMonoCd_W5Regular_11">cryptography</samp>
    库来加密和解密一个数据块，方法如 [清单 4-1](chapter4.xhtml#Lis4-1) 所示。
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-1: AES encryption
    and decryption of a block in Python</samp>'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单 4-1：Python 中的 AES 加密和解密一个数据块</samp>
- en: 'Running this script produces something like the following output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本会产生如下类似的输出：
- en: '[PRE1]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You’ll get different results because the key is randomized at every new execution.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到不同的结果，因为每次执行时密钥都会随机化。
- en: <samp class="SANS_Futura_Std_Bold_B_11">How to Implement AES</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">如何实现 AES</samp>
- en: Real AES software works differently than the algorithm in [Figure 4-4](chapter4.xhtml#fig4-4).
    You won’t find production-level AES code calling a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubBytes()</samp>
    function, then a <samp class="SANS_TheSansMonoCd_W5Regular_11">ShiftRows()</samp>
    function, and then a <samp class="SANS_TheSansMonoCd_W5Regular_11">MixColumns()</samp>
    function because that would be inefficient. Instead, fast AES software uses table-based
    implementations and native instructions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的 AES 软件与 [图 4-4](chapter4.xhtml#fig4-4) 中的算法工作方式不同。你不会在生产级别的 AES 代码中找到一个
    <samp class="SANS_TheSansMonoCd_W5Regular_11">SubBytes()</samp> 函数，接着是 <samp class="SANS_TheSansMonoCd_W5Regular_11">ShiftRows()</samp>
    函数，再然后是 <samp class="SANS_TheSansMonoCd_W5Regular_11">MixColumns()</samp> 函数，因为那样效率低下。相反，快速的
    AES 软件使用基于表格的实现和本地指令。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Table-Based Implementations</samp>
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">基于表格的实现</samp>
- en: Table-based implementations of AES replace the sequence SubBytes-ShiftRows-MixColumns
    with a combination of XORs and lookups in tables hardcoded into the program and
    loaded in memory at execution time. This is possible because MixColumns is equivalent
    to XORing four 32-bit values, where each depends on a single byte from the state
    and on SubBytes. Thus, you can build four tables with 256 entries each, one for
    each byte value, and implement the sequence SubBytes-MixColumns by looking up
    four 32-bit values and XORing them together.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 基于表格的 AES 实现将 SubBytes-ShiftRows-MixColumns 序列替换为一系列 XOR 操作和在程序中硬编码并在执行时加载到内存中的查找表。这是可能的，因为
    MixColumns 等价于对四个 32 位值进行 XOR 操作，每个值都依赖于来自状态的一个字节和 SubBytes。因此，你可以构建四个包含 256 个条目的表格，每个表格对应一个字节值，并通过查找四个
    32 位值并对它们进行 XOR 操作来实现 SubBytes-MixColumns 序列。
- en: For example, the table-based C implementation in the OpenSSL toolkit looks like
    [Listing 4-2](chapter4.xhtml#Lis4-2).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，OpenSSL 工具包中的基于表格的 C 实现类似于 [清单 4-2](chapter4.xhtml#Lis4-2)。
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-2: An excerpt of
    the table-based C implementation of AES in OpenSSL</samp>'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 4-2：OpenSSL 中基于表格的 AES 实现摘录</samp>
- en: A basic table-based implementation of AES encryption needs four 4KB’s worth
    of tables because each table stores 256 32-bit values, which occupy 256 × 32 =
    8,192 bits, or 1KB. Decryption requires another four tables and thus 4KB more.
    But there are tricks to reduce the storage from 4KB to 1, or even less.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个基本的基于表格的 AES 加密实现需要四个 4KB 的表格，因为每个表格存储 256 个 32 位值，占用 256 × 32 = 8,192 位，即
    1KB。解密还需要另四个表格，因此需要额外的 4KB 存储。但有一些技巧可以将存储从 4KB 减少到 1KB，甚至更少。
- en: Alas, table-based implementations are vulnerable to *cache-timing attacks*,
    which exploit timing variations when a program reads or writes elements in cache
    memory. Access time varies depending on the relative position in cache memory
    of the accessed elements. Timings thus leak information about the accessed element,
    which in turn leaks information on the secrets involved.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜的是，基于表格的实现容易受到*缓存时间攻击*的影响，攻击者通过利用程序读取或写入缓存内存元素时的时间差异来进行攻击。访问时间会根据访问元素在缓存内存中的相对位置而变化。因此，时间差泄漏了关于访问元素的信息，进而泄漏了涉及的秘密信息。
- en: 'Cache-timing attacks are difficult to avoid. One obvious solution would be
    to ditch lookup tables altogether by writing a program whose execution time doesn’t
    depend on its inputs, but that’s almost impossible to do and still retain the
    same speed, so chip manufacturers have opted for a radical solution: instead of
    relying on potentially vulnerable software, they rely on *hardware*.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存时间攻击很难避免。一个显而易见的解决方案是完全舍弃查找表，通过编写一个执行时间不依赖于输入的程序来避免这种攻击，但这样几乎不可能做到，同时还保持相同的速度。因此，芯片制造商选择了一种激进的解决方案：他们不再依赖可能存在漏洞的软件，而是依赖于*硬件*。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Native Instructions</samp>
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">原生指令</samp>
- en: 'AES native instructions (AES-NI) solve the problem of cache-timing attacks
    on AES software implementations. To understand how AES-NI works, think about the
    way software runs on hardware: to run a program, a microprocessor translates binary
    code into a series of instructions that integrated circuit components execute.
    For example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">MUL</samp> assembly
    instruction between two 32-bit values will activate the transistors implementing
    a 32-bit multiplier in the microprocessor. To implement a crypto algorithm, we
    usually express a combination of basic operations—additions, multiplications,
    XORs, and so on—and the microprocessor activates its adders, multipliers, and
    XOR circuits in the prescribed order.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: AES 原生指令（AES-NI）解决了 AES 软件实现中缓存时间攻击的问题。要理解 AES-NI 如何工作，可以想象软件如何在硬件上运行：为了运行一个程序，微处理器将二进制代码转换为一系列指令，然后集成电路组件执行这些指令。例如，两个
    32 位值之间的 <samp class="SANS_TheSansMonoCd_W5Regular_11">MUL</samp> 汇编指令会激活微处理器中实现
    32 位乘法器的晶体管。为了实现加密算法，我们通常将一系列基本操作——加法、乘法、异或等——组合在一起，然后微处理器按照预定的顺序激活其加法器、乘法器和异或电路。
- en: AES native instructions take this to a whole new level by providing developers
    with dedicated assembly instructions that compute AES. Instead of coding an AES
    round as a sequence of assembly instructions, when using AES-NI, you just call
    the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">AESENC</samp>, and
    the chip computes the round for you. Native instructions allow you to tell the
    processor to run an AES round instead of requiring you to program rounds as a
    combination of basic operations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: AES 原生指令通过提供专门的汇编指令来计算 AES，将开发人员的工作提升到全新水平。在使用 AES-NI 时，你无需将 AES 回合编写为一系列汇编指令，只需要调用指令
    <samp class="SANS_TheSansMonoCd_W5Regular_11">AESENC</samp>，芯片会为你计算回合。原生指令允许你指示处理器执行
    AES 回合，而不需要将回合编程为一系列基本操作的组合。
- en: A typical assembly implementation of AES using native instructions looks like
    [Listing 4-3](chapter4.xhtml#Lis4-3).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原生指令的典型 AES 汇编实现可以参考[列表 4-3](chapter4.xhtml#Lis4-3)。
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-3: An implementation
    of AES-128 using AES native instructions</samp>'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 4-3：使用 AES 原生指令实现的 AES-128</samp>
- en: This code encrypts the 128-bit plaintext initially in the register <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm0</samp>,
    assuming that registers <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm5</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm15</samp> hold the precomputed
    round keys, with each instruction writing its result into <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm0</samp>.
    The initial <samp class="SANS_TheSansMonoCd_W5Regular_11">PXOR</samp> instruction
    XORs the first round key prior to computing the first round, and the final <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AESENCLAST</samp> instruction performs
    the last round slightly differently from the others (MixColumns is omitted).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码加密了最初存储在寄存器<samp class="SANS_TheSansMonoCd_W5Regular_11">xmm0</samp>中的128位明文，假设寄存器<samp
    class="SANS_TheSansMonoCd_W5Regular_11">xmm5</samp>到<samp class="SANS_TheSansMonoCd_W5Regular_11">xmm15</samp>存储了预计算的轮密钥，每条指令将其结果写入<samp
    class="SANS_TheSansMonoCd_W5Regular_11">xmm0</samp>。初始的<samp class="SANS_TheSansMonoCd_W5Regular_11">PXOR</samp>指令在计算第一轮之前执行与第一轮密钥的异或操作，最后的<samp
    class="SANS_TheSansMonoCd_W5Regular_11">AESENCLAST</samp>指令执行最后一轮的方式与其他轮略有不同（MixColumns被省略）。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*AES is about 10 times faster on platforms that implement native instructions,
    which, as I write this, include virtually all laptop, desktop, and server microprocessors,
    as well as most mobile phones and tablets. Although Intel originally proposed
    AES instructions in 2008, they’re also available in AMD processors, and most architectures
    other than x86 also have equivalent instructions implementing AES in hardware.
    For example, the Armv8 instruction set contains the instructions <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESSE*</samp>
    (which calculates SubBytes and ShiftRows) and <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESMS*</samp>
    (which calculates MixColumns).*'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*AES在实现了本地指令的平台上速度大约是原来的10倍，正如我写这段文字时，几乎所有的笔记本、台式机和服务器微处理器，以及大多数手机和平板电脑都已经实现了这些指令。虽然Intel在2008年首次提出了AES指令，但这些指令也可以在AMD处理器中使用，除了x86之外的大多数架构也有等效的硬件实现AES的指令。例如，Armv8指令集包含了指令<samp
    class="SANS_TheSansMonoCd_W5Regular_11">*AESSE*</samp>（用于计算SubBytes和ShiftRows）和<samp
    class="SANS_TheSansMonoCd_W5Regular_11">*AESMS*</samp>（用于计算MixColumns）。*'
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*On Intel’s Ice Lake microarchitecture, the <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESENC*</samp>
    instruction has a latency of three cycles with a reciprocal throughput of half
    a cycle, meaning that a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESENC*</samp>
    takes three cycles to complete, and we can make two new calls to the instruction
    in each cycle. In fact, the internal structure of the micro-operations performing
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESENC*</samp> operation means
    that a new instruction computation can start before the previous one has finished.
    What’s more, the Ice Lake architecture uses a vectorized version of AES instructions,
    enabling several to be initiated at the same time. For more details, see the article
    “Making AES Great Again” by Nir Drucker, Shay Gueron, and Vlad Krasnov, available
    at* [https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2018<wbr>/392](https://eprint.iacr.org/2018/392)*.*'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在Intel的Ice Lake微架构上，<samp class="SANS_TheSansMonoCd_W5Regular_11">*AESENC*</samp>指令的延迟为三个周期，反向吞吐量为半个周期，意味着调用<samp
    class="SANS_TheSansMonoCd_W5Regular_11">*AESENC*</samp>需要三个周期才能完成，而我们可以在每个周期内发起两次新的指令调用。实际上，执行<samp
    class="SANS_TheSansMonoCd_W5Regular_11">*AESENC*</samp>操作的微操作的内部结构使得新指令的计算可以在前一个计算完成之前开始。更重要的是，Ice
    Lake架构使用了AES指令的向量化版本，可以同时启动多个指令。有关更多详细信息，请参阅Nir Drucker、Shay Gueron和Vlad Krasnov的文章《让AES重回巅峰》，文章可以在*
    [https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2018<wbr>/392](https://eprint.iacr.org/2018/392)*找到。*'
- en: ''
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*To encrypt a series of blocks one after the other, it takes 3 × 10 = 30 cycles
    to complete the 10 rounds, or 30 / 16 = 1.875 cycles per byte. At a frequency
    of 2 GHz (2 × 10**⁹* *cycles per second), this gives a theoretical maximum throughput
    of around 1GBps. If you can process blocks in parallel, then you don’t need one
    complete <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESENC*</samp> call before
    starting another. In this case, you can make two <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESENC*</samp>
    calls per cycle and obtain two results per cycle, offering a much higher theoretical
    throughput (up to more than 10GBps, at 2 GHz), depending on the data size and
    mode of operation.*'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*为了一个接一个地加密一系列的块，完成10轮需要3 × 10 = 30个周期，或者每个字节需要30 / 16 = 1.875个周期。在2 GHz的频率下（2
    × 10**⁹* *每秒周期数），这给出了大约1GBps的理论最大吞吐量。如果你能并行处理块，那么你就不需要在开始另一个之前完成一次完整的 <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESENC*</samp>
    调用。在这种情况下，你可以每个周期做两次 <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESENC*</samp>
    调用，并且每个周期获得两个结果，从而提供更高的理论吞吐量（在2 GHz时，最多超过10GBps），具体取决于数据大小和操作模式。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES Security</samp>
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES安全性</samp>
- en: AES is as secure as a block cipher can be, and it will never be broken. Fundamentally,
    AES is secure because all output bits depend on all input bits in some complex,
    pseudorandom way. To achieve this, the designers of AES carefully chose each component
    for a particular reason—MixColumns for its maximal diffusion properties and SubBytes
    for its optimal nonlinearity. This composition protects AES against whole classes
    of cryptanalytic attacks.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: AES的安全性是分组密码中最强的，它永远不会被破解。从根本上来说，AES是安全的，因为所有输出比特都依赖于所有输入比特，并且这种依赖是复杂的伪随机的方式。为了实现这一点，AES的设计者们精心选择了每个组件，基于特定的原因——MixColumns由于其最大扩散性，SubBytes由于其最优的非线性。这个组合使AES能够抵抗一类又一类的密码分析攻击。
- en: 'But there’s no proof that AES is immune to all possible attacks. For one thing,
    we don’t know what all possible attacks are, and we don’t always know how to prove
    that a cipher is secure against a given attack. The only way to really gain confidence
    in the security of AES is to crowdsource attacks: have many skilled people attempt
    to break AES and, ideally, fail to do so.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 但没有证据表明AES对所有可能的攻击都是免疫的。首先，我们不知道所有可能的攻击是什么，我们也不总是知道如何证明一个密码对某种特定攻击是安全的。真正增加对AES安全性信心的唯一方法是众包攻击：让许多有技能的人尝试破解AES，并且理想情况下，无法成功。
- en: After more than 15 years and hundreds of research publications, we’ve only scratched
    the surface of the theoretical security of AES. In 2011, cryptanalysts found a
    way to recover an AES-128 key by performing about 2^(126) operations instead of
    2^(128), a speedup of a factor of 4\. But this “attack” requires a high number
    of plaintext–ciphertext pairs—about 2^(88) bits’ worth. It’s a nice finding but
    not one you need to worry about.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 经过15年以上的研究和数百篇研究论文，我们才刚刚触及AES理论安全性的表面。2011年，密码分析师发现了一种方法，可以通过进行大约2^(126)次操作来恢复AES-128密钥，而不是2^(128)次操作，速度提升了4倍。但这个“攻击”需要大量的明文-密文对——大约需要2^(88)比特的数据。这是一个有趣的发现，但并不是你需要担心的事情。
- en: You should care about a million things when implementing and deploying crypto,
    but AES security is not one of them. The biggest threat to block ciphers isn’t
    in their core algorithms but in their modes of operation. If you’ve chosen an
    incorrect mode or misused the right one, even a strong cipher like AES won’t save
    you.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在实现和部署加密时，应该关注成千上万的事情，但AES的安全性并不是其中之一。对分组密码来说，最大的威胁不在于其核心算法，而在于其操作模式。如果你选择了错误的模式或误用了正确的模式，即便是像AES这样强大的密码也无法保护你。
- en: <samp class="SANS_Futura_Std_Bold_B_11">Modes of Operation</samp>
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">操作模式</samp>
- en: 'In [Chapter 1](chapter1.xhtml), I explained how encryption schemes combine
    a permutation with a mode of operation to handle messages of any length. In this
    section, I’ll cover the main modes of operations that block ciphers use, their
    security and functional properties, and how (not) to use them. I’ll begin with
    the dumbest one: electronic codebook.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](chapter1.xhtml)中，我解释了加密方案如何将置换与操作模式结合起来，以处理任意长度的消息。在这一节中，我将介绍分组密码使用的主要操作模式、它们的安全性和功能属性，以及如何（不）使用它们。我将从最愚蠢的那个开始：电子密码本。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Electronic Codebook
    Mode</samp>
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">电子密码本模式</samp>
- en: The simplest of the block cipher encryption modes is electronic codebook (ECB),
    which is barely a mode of operation at all. ECB takes plaintext blocks *P*[1],
    *P*[2], . . . , *P*N and processes each independently by computing *C*[1] = **E**(*K*,
    *P*[1]), *C*[2] = **E**(*K*, *P*[2]), and so on, as [Figure 4-6](chapter4.xhtml#fig4-6)
    shows. It’s a simple operation but also an insecure one—ECB is insecure, and you
    shouldn’t use it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的块密码加密模式是电子密码本（ECB），它几乎不算是一种操作模式。ECB处理明文块*P*[1]、*P*[2]、…、*P*[N]，通过计算*C*[1]
    = **E**(*K*, *P*[1])、*C*[2] = **E**(*K*, *P*[2])等，逐块独立处理，正如[图4-6](chapter4.xhtml#fig4-6)所示。这是一种简单的操作，但也是不安全的——ECB是不安全的，您不应使用它。
- en: '![](../images/fig4-6.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig4-6.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-6: ECB mode</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图4-6：ECB模式</samp>
- en: Marsh Ray, a cryptographer at Microsoft, once said, “Everybody knows ECB mode
    is bad because we can see the penguin.” He was referring to a famous illustration
    of ECB’s insecurity that uses an image of Linux’s mascot, Tux, as in [Figure 4-7](chapter4.xhtml#fig4-7).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 微软的密码学家Marsh Ray曾说过：“大家都知道ECB模式不好，因为我们能看到企鹅。”他指的是一种著名的ECB不安全性示例，使用了Linux吉祥物Tux的图像，如[图4-7](chapter4.xhtml#fig4-7)所示。
- en: '![](../images/fig4-7.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig4-7.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-7: The original image
    (left) and the ECB-encrypted image (right)</samp>'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图4-7：原始图像（左）和ECB加密图像（右）</samp>
- en: The original image of Tux is on the left, and the ECB-encrypted image that uses
    AES (though the underlying cipher doesn’t matter) is on the right. It’s easy to
    see the penguin’s shape in the encrypted version because ECB encrypted all the
    blocks of one shade of gray in the original image to the same new shade of gray
    in the new image; in other words, ECB encryption gives you the same image with
    different colors.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Tux的原始图像在左侧，使用AES加密后的ECB图像（尽管底层密码不重要）在右侧。由于ECB将原始图像中所有相同灰度的块加密为新图像中相同灰度的新色调，因此在加密版本中很容易看到企鹅的形状；换句话说，ECB加密生成的是颜色不同的相同图像。
- en: The Python program in [Listing 4-4](chapter4.xhtml#Lis4-4) also shows ECB’s
    insecurity. It picks a pseudorandom key and encrypts a 32-byte message <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    containing two blocks of null bytes. Notice that encryption yields two identical
    blocks and that repeating encryption with the same key and the same plaintext
    yields the same two blocks again.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单4-4](chapter4.xhtml#Lis4-4)中的Python程序也显示了ECB的不安全性。它选择一个伪随机密钥，并加密一个包含两个空字节块的32字节消息<samp
    class="SANS_TheSansMonoCd_W5Regular_11">p</samp>。请注意，加密产生了两个相同的块，并且使用相同的密钥和相同的明文重复加密时，又会产生相同的两个块。'
- en: '[PRE4]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-4: Using AES in ECB
    mode in Python</samp>'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">清单4-4：在Python中使用AES的ECB模式</samp>
- en: 'Running this script gives ciphertext blocks like this example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本将生成如下所示的密文块：
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When using the ECB mode, identical ciphertext blocks reveal identical plaintext
    blocks to an attacker, whether those are blocks within a single ciphertext or
    across different ciphertexts. This shows that block ciphers in ECB mode aren’t
    semantically secure.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用ECB模式时，相同的密文块会向攻击者揭示相同的明文块，无论这些块是在同一密文中，还是在不同的密文中。这表明，ECB模式下的块密码在语义上是不安全的。
- en: Another problem with ECB is that it takes only complete blocks of data, so if
    blocks were 16 bytes, as in AES, you could encrypt only chunks of 16 bytes, 32
    bytes, 48 bytes, or any other multiple of 16 bytes. There are a few ways to deal
    with this, as you’ll see with the next mode, CBC. (I won’t tell you how these
    tricks work with ECB because you shouldn’t use ECB in the first place.)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ECB的另一个问题是它只接受完整的数据块，因此如果数据块是16字节，比如在AES中，您只能加密16字节、32字节、48字节或其他16字节的倍数的数据块。解决这个问题有几种方法，您将在下一个模式CBC中看到。（我不会告诉您这些技巧如何在ECB中工作，因为您本不应使用ECB。）
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Cipher Block Chaining
    Mode</samp>
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">密码块链模式</samp>
- en: 'Cipher block chaining (CBC) is like ECB but with a small twist that makes a
    big difference: instead of encrypting the *i*th block, *P*i, as *C*i = **E**(*K*,
    *P*i), CBC sets *C*i = **E**(*K*, *P*i ⊕ *C*i [− 1]), where *C*i [− 1] is the
    previous ciphertext block—thereby *chaining* the blocks *C*i [− 1] and *C*i. When
    encrypting the first block, *P*[1], there is no previous ciphertext block to use,
    so CBC takes a random initial value (IV), as [Figure 4-8](chapter4.xhtml#fig4-8)
    illustrates.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 密码块链接（CBC）与电子密码本（ECB）类似，但有一个小小的变化，这个变化带来了很大的不同：CBC 不是直接加密第 *i* 个块 *P*i，像 *C*i
    = **E**(*K*, *P*i) 那样，而是设定 *C*i = **E**(*K*, *P*i ⊕ *C*i [− 1])，其中 *C*i [− 1]
    是前一个密文块——从而将块 *C*i [− 1] 和 *C*i 进行*链式*连接。当加密第一个块 *P*[1] 时，由于没有前一个密文块可用，CBC 会采用一个随机初始值（IV），正如[图
    4-8](chapter4.xhtml#fig4-8)所示。
- en: '![](../images/fig4-8.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig4-8.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-8: CBC mode</samp>'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-8: CBC 模式</samp>'
- en: CBC mode makes each ciphertext block dependent on all the previous blocks and
    ensures that identical plaintext blocks won’t be identical ciphertext blocks.
    The random initial value guarantees that two identical plaintexts will encrypt
    to distinct ciphertexts when calling the cipher twice with two distinct initial
    values.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: CBC 模式使得每个密文块都依赖于所有前面的块，确保相同的明文块不会变成相同的密文块。随机初始值保证了，当用两个不同的初始值两次调用密码算法时，相同的明文会加密成不同的密文。
- en: '[Listing 4-5](chapter4.xhtml#Lis4-5) illustrates these two benefits. This program
    takes an all-zero, 32-byte message (like the one in [Listing 4-4](chapter4.xhtml#Lis4-4)),
    encrypts it twice with CBC, and shows the two ciphertexts. The bolded line <samp
    class="SANS_TheSansMonoCd_W5Regular_11">iv = urandom(BLOCK _SIZE)</samp> picks
    a new random IV for each new encryption.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-5](chapter4.xhtml#Lis4-5) 演示了这两个优点。这个程序将一个全零的 32 字节消息（如[列表 4-4](chapter4.xhtml#Lis4-4)中的那样）进行两次
    CBC 加密，并显示两个密文。加粗的行 <samp class="SANS_TheSansMonoCd_W5Regular_11">iv = urandom(BLOCK
    _SIZE)</samp> 为每次新的加密选择一个新的随机 IV。'
- en: '[PRE6]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-5: Using AES in CBC
    mode</samp>'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">列表 4-5: 使用 AES 的 CBC 模式</samp>'
- en: 'The two plaintexts are the same (two all-zero blocks), but the encrypted blocks
    should be distinct, as in this example execution:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个明文是相同的（两个全零块），但加密后的块应该是不同的，正如这个执行示例所示：
- en: '[PRE7]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Alas, we often use CBC with a constant IV instead of a random one, which exposes
    identical plaintexts and plaintexts that start with identical blocks. For example,
    say CBC encrypts the two-block plaintext *P*[1] || *P*[2] to the two-block ciphertext
    *C*[1] || *C*[2]. If CBC encrypts *P*[1] || *P*[2]′ with the same IV, where *P*[2]′
    is some block distinct from *P*[2], then the ciphertext will look like *C*[1]
    || *C*[2]′, with *C*[2]′ different from *C*[2] but with the same first block *C*[1].
    Thus, an attacker can guess that the first block is the same for both plaintexts,
    even though they see only the ciphertexts.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，我们常常使用常量 IV 而不是随机 IV，这会暴露出相同的明文以及以相同块开始的明文。例如，假设 CBC 将两个块的明文 *P*[1] ||
    *P*[2] 加密成两个块的密文 *C*[1] || *C*[2]。如果 CBC 使用相同的 IV 加密 *P*[1] || *P*[2]′，其中 *P*[2]′
    是与 *P*[2] 不同的块，那么密文将变成 *C*[1] || *C*[2]′，其中 *C*[2]′ 与 *C*[2] 不同，但 *C*[1] 相同。因此，攻击者可以猜测两个明文的第一个块是相同的，即使他们只能看到密文。
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*In CBC mode, decryption needs to know the IV used to encrypt, so the IV is
    sent along with the ciphertext, in the clear.*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*在 CBC 模式下，解密需要知道加密时使用的 IV，因此 IV 会与密文一起明文发送。*'
- en: With CBC, decryption can be much faster than encryption due to parallelism.
    While encryption of a new block, *P*i, needs to wait for the previous block, *C*i
    [− 1], decryption of a block computes *P*i = **D**(*K*, *C*i) ⊕ *C*i [− 1], where
    there’s no need for the previous plaintext block, *P*i [− 1]. This means you can
    decrypt all blocks in parallel simultaneously, as long as you know the previous
    ciphertext block, which you usually will.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CBC 时，解密通常比加密更快，因为解密可以并行进行。虽然加密新块 *P*i 时需要等待前一个块 *C*i [− 1]，但解密一个块时，会计算 *P*i
    = **D**(*K*, *C*i) ⊕ *C*i [− 1]，其中不需要前一个明文块 *P*i [− 1]。这意味着，只要你知道前一个密文块，就可以并行解密所有块，通常你是知道的。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Message Encryption
    in CBC Mode</samp>
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">CBC 模式下的消息加密</samp>
- en: Let’s circle back to the block termination issue and look at how to process
    a plaintext whose length is not a multiple of the block length. For example, how
    would you encrypt an 18-byte plaintext with AES-CBC when blocks are 16 bytes?
    What do you do with the 2 bytes left? You’ll look at two widely used techniques
    to deal with this problem. The first one, padding, makes the ciphertext a bit
    longer than the plaintext, while the second one, *ciphertext stealing*, produces
    a ciphertext of the same length as the plaintext.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到块终止问题，看看如何处理长度不是块大小倍数的明文。例如，当块大小为16字节时，如何用AES-CBC加密18字节的明文？剩下的2个字节该怎么处理？你将看到两种广泛使用的技术来解决这个问题。第一种是填充，它使密文比明文稍长，而第二种是*密文偷取*，它生成与明文长度相同的密文。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Message Padding</samp>
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <code class="SANS_Futura_Std_Bold_Condensed_B_11">消息填充</code>
- en: Padding is a technique that allows you to encrypt a message of any length, even
    one smaller than a single block. The PKCS#7 standard and RFC 5652 specify padding
    for block ciphers, which we use almost everywhere we use CBC.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 填充是一种使你能够加密任何长度的消息的技术，即使是小于一个块的消息。PKCS#7标准和RFC 5652为块密码指定了填充方式，我们几乎在所有使用CBC的地方都使用它。
- en: 'We use padding to expand a message to fill a complete block by adding extra
    bytes to the plaintext. Here are the rules for padding 16-byte blocks:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用填充来扩展消息，通过向明文添加额外的字节来填充完整的块。以下是填充16字节块的规则：
- en: If there’s 1 byte left—for example, if the plaintext is 1 byte, 17 bytes, or
    33 bytes long—pad the message with 15 bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">0f</samp>
    (15 in decimal).
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果剩余1个字节——例如，明文是1字节、17字节或33字节长——则使用15个字节<code class="SANS_TheSansMonoCd_W5Regular_11">0f</code>（十进制为15）填充消息。
- en: If there are 2 bytes left, pad the message with 14 bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">0e</samp>
    (14 in decimal).
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果剩余2个字节，使用14个字节<code class="SANS_TheSansMonoCd_W5Regular_11">0e</code>（十进制为14）填充消息。
- en: If there are 3 bytes left, pad the message with 13 bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">0d</samp>
    (13 in decimal).
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果剩余3个字节，使用13个字节<code class="SANS_TheSansMonoCd_W5Regular_11">0d</code>（十进制为13）填充消息。
- en: If there are 15 plaintext bytes and a single byte missing to fill a block, padding
    adds a single <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> byte. If
    the plaintext is already a multiple of 16, the block length, add 16 bytes <samp
    class="SANS_TheSansMonoCd_W5Regular_11">10</samp> (16 in decimal). The trick generalizes
    to any block length up to 255 bytes (for larger blocks, a byte is too small to
    encode values greater than 255).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有15个明文字节，并且缺少一个字节来填充块，填充会添加一个<code class="SANS_TheSansMonoCd_W5Regular_11">01</code>字节。如果明文已经是16的倍数，即块长度，则会添加16个字节<code
    class="SANS_TheSansMonoCd_W5Regular_11">10</code>（十进制为16）。该技巧可以推广到任何块长度，最多可达到255字节（对于更大的块，1字节太小，无法编码大于255的值）。
- en: 'Decryption of a padded message works like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 填充消息的解密过程如下：
- en: 1.  Decrypt all the blocks as with unpadded CBC.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  像解密未填充的CBC一样解密所有块。
- en: '2.  Make sure that the last bytes of the last block conform to the padding
    rule: that they finish with at least one <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    byte, at least two <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp> bytes,
    or at least three <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp> bytes,
    and so on. If the padding isn’t valid—for example, if the last bytes are <samp
    class="SANS_TheSansMonoCd_W5Regular_11">01 02 03</samp>—the message is rejected.
    Otherwise, decryption strips the padding bytes and returns the plaintext bytes
    left.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  确保最后一个块的最后字节符合填充规则：即它们以至少一个<code class="SANS_TheSansMonoCd_W5Regular_11">01</code>字节、至少两个<code
    class="SANS_TheSansMonoCd_W5Regular_11">02</code>字节或至少三个<code class="SANS_TheSansMonoCd_W5Regular_11">03</code>字节结尾，依此类推。如果填充无效——例如，最后的字节是<code
    class="SANS_TheSansMonoCd_W5Regular_11">01 02 03</code>——则消息会被拒绝。否则，解密会去除填充字节并返回剩余的明文字节。
- en: One downside of padding is that it makes ciphertext longer by at least 1 byte
    and at most a block.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 填充的一个缺点是，它会使密文至少增加1字节，最多增加一个块的长度。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Ciphertext Stealing</samp>
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: <code class="SANS_Futura_Std_Bold_Condensed_B_11">密文偷取</code>
- en: 'Ciphertext stealing is another trick we use to encrypt a message whose length
    isn’t a multiple of the block size. Ciphertext stealing is more complex and less
    popular than padding, but it offers a few benefits:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 密文偷取是我们用来加密长度不是块大小倍数的消息的另一种技巧。密文偷取比填充更复杂且不太常用，但它提供了一些好处：
- en: Plaintexts can be of any *bit* length, not just bytes. You can, for example,
    encrypt a message of 131 bits.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ciphertexts are exactly the same length as plaintexts.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ciphertext stealing is not vulnerable to padding oracle attacks, powerful attacks
    that sometimes work against CBC with padding (as you’ll see in “Padding Oracle
    Attacks” on [page 83](#sec26)).
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In CBC mode, ciphertext stealing extends the last incomplete plaintext block
    with bits from the previous ciphertext block and then encrypts the resulting block.
    The last, incomplete ciphertext block is made up of the first bits from the previous
    ciphertext block—that is, the bits that haven’t been appended to the last plaintext
    block.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 4-9](chapter4.xhtml#fig4-9), we have three blocks, where the last
    block, *P*[3], is incomplete (represented by a zero). If *P*[3] is 3 bytes, we
    XOR it with the last 12 bits from the previous ciphertext block **E**(*K*, *P*[2])
    and return the encrypted result as *C*[2]. The last ciphertext block, *C*[3],
    then consists of the first 4 bytes of **E**(*K*, *P*[2]). Decryption is simply
    the inverse of this operation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-9.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-9: Ciphertext stealing
    for CBC-mode encryption</samp>'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: There aren’t any major problems with ciphertext stealing, but it’s inelegant
    and hard to get right, especially when NIST’s standard specifies three different
    ways to implement it (see Special Publication 800-38A).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Counter Mode</samp>
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To avoid the troubles and retain the benefits of ciphertext stealing, use counter
    mode (CTR). CTR is hardly a block cipher mode: it turns a block cipher into a
    stream cipher that just takes bits in and spits bits out and doesn’t embarrass
    itself with the notion of blocks. (I’ll discuss stream ciphers in detail in [Chapter
    5](chapter5.xhtml).)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: In CTR mode (see [Figure 4-10](chapter4.xhtml#fig4-10)), the block cipher algorithm
    won’t transform plaintext data. Instead, it encrypts blocks composed of a counter
    and a nonce. A *counter* is an integer that is incremented for each block. No
    two blocks should use the same counter within a message, but different messages
    can use the same sequence of counter values (1, 2, 3, . . .). A *nonce* is a number
    we use only once. It’s the same for all blocks in a single message, but no two
    messages should use the same nonce.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-10.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-10: CTR mode</samp>'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-10](chapter4.xhtml#fig4-10) shows that in CTR mode, encryption XORs
    the plaintext and the stream taken from “encrypting” the nonce, *N*, and counter,
    *Ctr*. Decryption is the same, so you need only the encryption algorithm for both
    encryption and decryption. The Python script in [Listing 4-6](chapter4.xhtml#Lis4-6)
    gives you a hands-on example.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-6: Using AES in CTR
    mode</samp>'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'The example execution encrypts a 4-byte plaintext and gets a 4-byte ciphertext.
    It then decrypts that ciphertext using the encryption function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As with the initial value in CBC, the encrypter supplies CTR’s nonce and sends
    it with the ciphertext in the clear. But unlike CBC’s initial value, CTR’s nonce
    doesn’t need to be random; it simply needs to be unique. A nonce should be unique
    for the same reason that we shouldn’t reuse a one-time pad: when calling the pseudorandom
    stream, *S*, if you encrypt *P*[1] to *C*[1] = *P*[1] ⊕ *S* and *P*[2] to *C*[2]
    = *P*[2] ⊕ *S* using the same nonce, then *C*[1] ⊕ *C*[2] reveals *P*[1] ⊕ *P*[2].'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: A random nonce will do the trick only if it’s long enough; for example, if the
    nonce is *n* bits, chances are that after 2*^n*^(/2) encryptions and as many nonces,
    you’ll run into duplicates. Sixty-four bits are insufficient for a random nonce,
    since you can expect a repetition after approximately 2^(32) nonces, which is
    an unacceptably low number.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The counter is guaranteed unique if it’s incremented for every new plaintext,
    and if it’s long enough—for example, a 64-bit counter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: One particular benefit to CTR is that it can be faster than any other mode.
    Not only is it parallelizable, but you can also start encrypting even before knowing
    the message by picking a nonce and computing the stream that you’ll later XOR
    with the plaintext.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Depending on the CTR version we implement, we may either concatenate the nonce
    the API uses as an argument to a counter (as in [Figure 4-10](chapter4.xhtml#fig4-10))
    or directly consider a counter as wide as a block.*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two must-know attacks on block ciphers: meet-in-the-middle attacks,
    a technique discovered in the 1970s but still used in many cryptanalytic attacks
    (not to be confused with man-in-the-middle attacks), and padding oracle attacks,
    a class of attacks discovered in 2002 by academic cryptographers, then mostly
    ignored, and finally rediscovered a decade later along with several vulnerable
    applications.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Meet-in-the-Middle
    Attacks</samp>
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The 3DES block cipher is an upgraded version of the 1970s standard DES that
    takes a key of 56 × 3 = 168 bits (an improvement on DES’s 56-bit key). But the
    security level of 3DES is 112 bits instead of 168 bits because of the *meet-in-the-middle
    (MitM)* attack.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-11](chapter4.xhtml#fig4-11) shows that 3DES encrypts a block using
    the DES encryption and decryption functions: first encryption with a key, *K*[1];
    then decryption with a key, *K*[2]; and finally encryption with another key, *K*[3].
    If *K*[1] = *K*[2], the first two calls cancel themselves out, and 3DES boils
    down to a single DES with key *K*[3]. 3DES does encrypt-decrypt-encrypt rather
    than encrypting thrice to allow systems to emulate DES when necessary using the
    new 3DES interface.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-11.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig4-11.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-11: The 3DES block
    cipher construction</samp>'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-11：3DES 块密码结构</samp>
- en: Why use triple DES and not just double DES—that is, why encrypt a plaintext
    *P* to **E**(*K*[2], **E**(*K*[1], *P*))? It turns out that the MitM attack makes
    double DES only as secure as single DES. [Figure 4-12](chapter4.xhtml#fig4-12)
    shows the MitM attack in action.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用三重 DES 而不是仅使用双重 DES——也就是说，为什么将明文 *P* 加密为 **E**(*K*[2], **E**(*K*[1], *P*))？事实证明，MitM
    攻击使双重 DES 的安全性仅与单一 DES 相当。[图 4-12](chapter4.xhtml#fig4-12) 展示了 MitM 攻击的实际应用。
- en: '![](../images/fig4-12.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig4-12.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-12: The MitM attack</samp>'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-12：MitM 攻击</samp>
- en: 'The MitM attack works as follows to attack double DES:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: MitM 攻击用于攻击双重 DES 的过程如下：
- en: 1.  Say you have *P* and *C* = **E**(*K*[2], **E**(*K*[1], *P*)) with two unknown
    56-bit keys, *K*[1] and *K*[2]. (DES takes 56-bit keys, so double DES takes 112
    key bits in total.) You build a key-value table with 2^(56) entries of **E**(*K*[1],
    *P*), where **E** is the DES encryption function and *K*[1] is the value stored.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  假设你有 *P* 和 *C* = **E**(*K*[2], **E**(*K*[1], *P*))，其中有两个未知的 56 位密钥，*K*[1]
    和 *K*[2]。（DES 使用 56 位密钥，因此双重 DES 总共使用 112 位密钥。）你构建一个包含 2^(56) 条目的密钥值表 **E**(*K*[1],
    *P*)，其中 **E** 是 DES 加密函数，*K*[1] 是存储的值。
- en: 2.  For all 2^(56) values of *K*[2], compute **D**(*K*[2], *C*) and check whether
    the resulting value appears in the table as an index (thus as a middle value,
    represented by a question mark in [Figure 4-12](chapter4.xhtml#fig4-12)).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  对于所有 2^(56) 个 *K*[2] 的值，计算 **D**(*K*[2], *C*)，并检查结果值是否作为索引出现在表中（因此作为中间值，如[图
    4-12](chapter4.xhtml#fig4-12)中的问号所示）。
- en: 3.  If you find a middle value as an index of the table, fetch the corresponding
    *K*[1] from the table and verify that the (*K*[1], *K*[2]) found is the right
    one by using other pairs of *P* and *C*. Encrypt *P* using *K*[1] and *K*[2] and
    then check that the ciphertext obtained is the given *C*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  如果你找到一个中间值作为表的索引，获取表中对应的 *K*[1] 并通过使用其他 *P* 和 *C* 对来验证所找到的 (*K*[1], *K*[2])
    是否正确。使用 *K*[1] 和 *K*[2] 对 *P* 进行加密，然后检查得到的密文是否为给定的 *C*。
- en: 'This method recovers *K*[1] and *K*[2] by performing about 2^(57) instead of
    2^(112) operations: step 1 encrypts 2^(56) blocks, and then step 2 decrypts at
    most 2^(56) blocks, for 2^(56) + 2^(56) = 2^(57) operations in total. You also
    need to store 2^(56) elements of 15 bytes each, or about 1 exabyte. That’s a lot,
    but there’s a trick that allows you to run the same attack with only negligible
    memory (as you’ll see in [Chapter 6](chapter6.xhtml)).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法通过执行约 2^(57) 次操作来恢复 *K*[1] 和 *K*[2]，而不是执行 2^(112) 次操作：步骤 1 对 2^(56) 个块进行加密，然后步骤
    2 对最多 2^(56) 个块进行解密，总共进行 2^(56) + 2^(56) = 2^(57) 次操作。你还需要存储 2^(56) 个每个 15 字节的元素，或者大约
    1 EB 的存储空间。虽然这需要大量存储，但有一个技巧可以让你在几乎不占用内存的情况下执行相同的攻击（正如你将在[第 6 章](chapter6.xhtml)中看到的）。
- en: You can apply the MitM attack to 3DES in almost the same way you would to double
    DES, except that the third stage will go through all 2^(112) values of *K*[2]
    and *K*[3]. The whole attack thus succeeds after performing about 2^(112) operations,
    meaning that 3DES gets only 112-bit security despite having 168 bits of key material.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 MitM 攻击几乎以与双重 DES 相同的方式应用于 3DES，唯一不同的是第三阶段将遍历所有 2^(112) 个 *K*[2] 和 *K*[3]
    的值。因此，整个攻击在执行大约 2^(112) 次操作后成功，这意味着尽管 3DES 具有 168 位密钥材料，它只获得了 112 位的安全性。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Padding Oracle Attacks</samp>
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">填充 Oracle 攻击</samp>
- en: 'We conclude this chapter with one of the simplest and yet most devastating
    attacks of the 2000s: the padding oracle attack. Remember that padding fills the
    plaintext with extra bytes to fill a block. A plaintext of 111 bytes, for example,
    is a sequence of six 16-byte blocks followed by 15 bytes. In this case, forming
    a complete block padding adds a <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    byte. For a 110-byte plaintext, padding adds 2 <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp>
    bytes. For a 109-byte plaintext, it adds 3 <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp>
    bytes, and so on, up to the case where we add 16 <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    bytes, where the hexadecimal value <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    is equal to 16.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的结尾是2000年代最简单却最具破坏力的攻击之一：填充 oracle 攻击。记住，填充是通过额外字节填充明文来完成块的填充。例如，一个 111 字节的明文是六个
    16 字节块，后面跟着 15 个字节。在这种情况下，形成一个完整的块填充会添加一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    字节。对于一个 110 字节的明文，填充会添加 2 个 <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp>
    字节。对于一个 109 字节的明文，它会添加 3 个 <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp>
    字节，依此类推，直到添加 16 个 <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> 字节，其中十六进制值
    <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp> 等于 16。
- en: A *padding oracle* is a system that behaves differently depending on whether
    the padding in a CBC-encrypted ciphertext is valid. You can see it as a black
    box or an API that returns either a *success* or an *error* value. You can, for
    example, obtain a padding oracle in a service on a remote host that sends error
    messages when it receives malformed ciphertexts. Given such an oracle, padding
    oracle attacks record which inputs have a valid padding and which don’t and then
    exploit this information to decrypt chosen ciphertext values.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*填充 oracle* 是一个系统，它的行为取决于 CBC 加密密文的填充是否有效。你可以将它看作一个黑盒或一个 API，当收到格式不正确的密文时，它返回一个
    *成功* 或 *错误* 的值。例如，你可以在远程主机上的某个服务中获得一个填充 oracle，当它接收到格式不正确的密文时，会发送错误消息。给定这样的 oracle，填充
    oracle 攻击记录哪些输入具有有效填充，哪些没有，然后利用这些信息来解密选定的密文值。'
- en: Say you want to decrypt a ciphertext block *C*[2]. I’ll call *X* the value you’re
    looking for, namely, **D**(*K*, *C*[2]), and *P*[2] the block obtained after decrypting
    in CBC mode (see [Figure 4-13](chapter4.xhtml#fig4-13)). If you pick a random
    block *C*[1] and send the two-block ciphertext *C*[1] || *C*[2] to the oracle,
    decryption will succeed only if *C*[1] ⊕ *X = P*[2] ends with valid padding—a
    single <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> byte, two <samp
    class="SANS_TheSansMonoCd_W5Regular_11">02</samp> bytes, or three <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp>
    bytes, and so on.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想解密一个密文块 *C*[2]。我将 *X* 称为你正在寻找的值，即 **D**(*K*, *C*[2])，*P*[2] 是在 CBC 模式下解密后得到的块（参见
    [图 4-13](chapter4.xhtml#fig4-13)）。如果你选择一个随机块 *C*[1] 并将两个块的密文 *C*[1] || *C*[2]
    发送到 oracle，只有当 *C*[1] ⊕ *X = P*[2] 以有效填充结尾时，解密才会成功——一个 <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    字节、两个 <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp> 字节、或者三个 <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp>
    字节，依此类推。
- en: '![](../images/fig4-13.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig4-13.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-13: Padding oracle
    attacks recover</samp> <samp class="SANS_Futura_Std_Book_11">X</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">by
    choosing</samp> <samp class="SANS_Futura_Std_Book_11">C</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">1</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and checking the validity of padding.</samp>'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图 4-13：填充 oracle 攻击恢复</samp>
    <samp class="SANS_Futura_Std_Book_11">X</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">通过选择</samp>
    <samp class="SANS_Futura_Std_Book_11">C</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">1</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">并检查填充的有效性。</samp>
- en: 'Based on this observation, padding oracle attacks on CBC encryption can decrypt
    a block *C*[2] like this (bytes are denoted in array notation: *C*[1][0] is *C*[1]’s
    first byte, *C*[1][1] its second byte, and so on up to *C*[1][15], *C*[1]’s last
    byte):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这一观察，CBC 加密中的填充 oracle 攻击可以像这样解密一个块 *C*[2]（字节以数组表示法表示：*C*[1][0] 是 *C*[1] 的第一个字节，*C*[1][1]
    是第二个字节，以此类推，到 *C*[1][15]，*C*[1] 的最后一个字节）：
- en: 1.  Pick a random block *C*[1] and vary its last byte until the padding oracle
    accepts the ciphertext as valid. Usually, in a valid ciphertext, *C*[1][15] ⊕
    *X*[15] = <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>, so you’ll find
    *X*[15] after trying around 128 values of *C*[1][15].
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  选择一个随机块 *C*[1]，并改变其最后一个字节，直到填充 oracle 接受该密文为有效。通常，在有效的密文中，*C*[1][15] ⊕ *X*[15]
    = <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>，所以你将在尝试大约 128 个 *C*[1][15]
    的值后找到 *X*[15]。
- en: 2.  Find the value *X*[14] by setting *C*[1][15] to *X*[15] ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp>
    and searching for the *C*[1][14] that gives correct padding. When the oracle accepts
    the ciphertext as valid, it means you’ve found *C*[1][14] such that *C*[1][14]
    ⊕ *X*[14] = <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp>.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Repeat steps 1 and 2 for all 16 bytes.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The attack needs on average 128 queries to the oracle for each of the 16 bytes,
    which is about 2,000 queries in total. (Note that each query must use the same
    initial value.)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In practice, implementing a padding oracle attack is a bit more complicated
    than what I’ve described because you have to deal with wrong guesses at step 1\.
    A ciphertext may have valid padding not because* P2 *ends with a single <samp
    class="SANS_TheSansMonoCd_W5Regular_11">01</samp> but because it ends with two
    <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp> bytes or three <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp>
    bytes. You can manage this by testing the validity of ciphertexts where more bytes
    are modified.*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s a lot to say about block ciphers, be it in how algorithms work or in
    how they can be attacked. For instance, Feistel networks and SPNs aren’t the only
    ways to build a block cipher. The block ciphers IDEA and FOX use the Lai–Massey
    construction, and Threefish uses ARX networks, a combination of addition, word
    rotations, and XORs.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: There are also many more modes than ECB, CBC, and CTR. Some modes are folklore
    techniques that nobody uses, like CFB and OFB, while others are for specific applications,
    like XTS for tweakable encryption or GCM for authenticated encryption.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve discussed Rijndael, the AES winner, but there were 14 other algorithms
    in the race: CAST-256, CRYPTON, DEAL, DFC, E2, FROG, HPC, LOKI97, Magenta, MARS,
    RC6, SAFER+, Serpent, and Twofish. I recommend looking them up to see how they
    work, how they were designed, how they have been attacked, and how fast they are.
    It’s also worth checking out the NSA’s designs (Skipjack and, more recently, SIMON
    and SPECK) and more recent “lightweight” block ciphers such as GIFT, KATAN, PRESENT,
    or PRINCE.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
