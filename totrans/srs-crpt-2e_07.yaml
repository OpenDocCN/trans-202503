- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">BLOCK
    CIPHERS</samp>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  prefs: []
  type: TYPE_IMG
- en: During the Cold War, the United States and the Soviets developed their own ciphers.
    The US government created the Data Encryption Standard (DES), which was adopted
    as a federal standard from 1979 to 2005, while the KGB developed GOST 28147-89,
    an algorithm kept secret until 1990 and still used today. In 2000, the US-based
    National Institute of Standards and Technology (NIST) selected the successor to
    DES, the Advanced Encryption Standard (AES), an algorithm developed in Belgium
    and now found in most electronic devices. AES, DES, and GOST 28147-89 are all
    *block ciphers*, a type of cipher that combines a core algorithm working on blocks
    of data with a *mode of operation*, or a technique to process sequences of data
    blocks.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter reviews the core algorithms that underlie block ciphers, discusses
    their modes of operation, and explains how they all work together. It also discusses
    how AES works and concludes with coverage of a classic attack tool from the 1970s,
    the meet-in-the-middle attack, and a favorite attack technique of the 2000s—padding
    oracles.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">What Is a Block Cipher?</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A block cipher consists of an encryption algorithm and a decryption algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: The *encryption algorithm* (**E**) takes a key, *K*, and a plaintext block,
    *P*, and produces a ciphertext block, *C*. We write an encryption operation as
    *C* = **E**(*K*, *P*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *decryption algorithm* (**D**) is the inverse of the encryption algorithm
    and decrypts a message to the original plaintext, *P*. We write this operation
    as *P* = **D**(*K*, *C*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since they’re the inverse of each other, the encryption and decryption algorithms
    usually involve similar operations.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Goals</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’ve followed earlier discussions about encryption, randomness, and indistinguishability,
    the definition of a secure block cipher will come as no surprise. We’ll continue
    to define security as random-looking-ness, so to speak.
  prefs: []
  type: TYPE_NORMAL
- en: For a block cipher to be secure, it should be a *pseudorandom permutation (PRP)*,
    meaning that as long as the key is secret, an attacker shouldn’t be able to compute
    an output of the block cipher from any input. That is, as long as *K* is secret
    and random from an attacker’s perspective, they should have no clue what **E**(*K*,
    *P*) looks like, for any given *P*.
  prefs: []
  type: TYPE_NORMAL
- en: More generally, attackers should be unable to discover any *pattern* in the
    input/output values of a block cipher. In other words, it should be impossible
    to tell a block cipher from a truly random permutation, given black-box access
    to the encryption and decryption functions for some fixed and unknown key. By
    the same token, attackers should be unable to recover a secure block cipher’s
    secret key; otherwise, they could use that key to tell the block cipher from a
    random permutation. This implies that attackers can’t predict the plaintext that
    corresponds to a given ciphertext the block cipher produces.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Block Size</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Two values characterize a block cipher: the block size and the key size. Security
    depends on both values. Most block ciphers have either 64-bit or 128-bit blocks—DES’s
    blocks have 64 (2⁶) bits, and AES’s blocks have 128 (2⁷) bits. In computing, lengths
    that are generally measured as powers of two simplify data processing, storage,
    and addressing. But why 2⁶ and 2⁷ and not 2⁴ or 2^(16) bits?'
  prefs: []
  type: TYPE_NORMAL
- en: It’s important that a block cipher’s blocks aren’t too large in order to minimize
    both the length of ciphertext and the memory footprint. Block ciphers first transform
    their input data into a sequence of blocks, which means that to encrypt a 16-bit
    message when blocks are 128 bits, you need to convert the message into a 128-bit
    block for the block cipher to process it and return a 128-bit ciphertext. The
    wider the blocks, the longer this overhead. To process a 128-bit block, you need
    at least 128 bits of memory. Blocks of 64, 128, or even 512 bits are short enough
    to fit in the registers of most CPUs or to implement using dedicated hardware
    circuits, allowing for efficient implementations in most cases. But larger blocks
    (for example, several kilobytes long) can have a noticeable impact on the cost
    and performance of implementations.
  prefs: []
  type: TYPE_NORMAL
- en: When ciphertexts’ length or memory footprint is critical, you may have to use
    64-bit blocks because these produce shorter ciphertexts and consume less memory.
    Otherwise, 128-bit or larger blocks are better, mainly because modern CPUs can
    often process 128-bit blocks more efficiently than 64-bit ones and they’re more
    secure (see the “Sweet32” attack, at *[https://<wbr>sweet32<wbr>.info](https://sweet32.info)*).
    In particular, CPUs can leverage instructions to efficiently process one or more
    128-bit blocks in parallel—for example, the Advanced Vector Extensions (AVX) family
    of instructions in Intel CPUs.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Codebook Attack</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While blocks shouldn’t be too large, they also shouldn’t be too small; otherwise,
    they may be susceptible to *codebook attacks*, which are attacks against block
    ciphers that are efficient only when using smaller blocks. With 16-bit blocks,
    the codebook attack works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Get the 65,536 (2^(16)) ciphertexts corresponding to each 16-bit plaintext
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Build a lookup table—the *codebook*—mapping each ciphertext block to its
    corresponding plaintext block.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  To decrypt an unknown ciphertext block, look up its corresponding plaintext
    block in the table.
  prefs: []
  type: TYPE_NORMAL
- en: When using 16-bit blocks, the lookup table needs only 2^(16) × 16 = 2^(20) bits
    of memory, or 128 kilobytes. With 32-bit blocks, memory needs to grow to 16 gigabytes,
    which is still manageable. But with 64-bit blocks, you’d have to store 2^(70)
    bits (a zettabit, or 128 exabytes), so forget about it. Codebook attacks are therefore
    not an issue for larger blocks of 128 bits or more.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How to Construct Block Ciphers</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There exist hundreds of block ciphers but only a handful of techniques to construct
    one. In practice, a block cipher isn’t a gigantic algorithm but a repetition of
    *rounds*, a short sequence of operations that’s weak on its own but strong in
    number. There are two main techniques to construct a round: substitution–permutation
    networks (as in AES) and Feistel schemes (as in DES). In this section, you’ll
    look at these techniques after viewing an attack that works when all rounds are
    identical to each other.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Block Cipher’s
    Rounds</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Computing a block cipher boils down to computing a sequence of rounds*.* In
    a block cipher, a round is a basic transformation that’s simple to specify and
    to implement and is iterated several times to form the block cipher’s algorithm.
    This construction, consisting of a small component repeated many times, is simpler
    to implement and to analyze than a construction that consists of a single huge
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a block cipher with three rounds encrypts a plaintext by computing
    *C* = **R**[3](**R**[2](**R**[1](*P*))), where the rounds are **R**[1], **R**[2],
    and **R**[3], and *P* is a plaintext. Each round should also have an inverse so
    it’s possible for a recipient to compute back to plaintext. Specifically, *P*
    = **iR**[1](**iR**[2](**iR**[3](*C*))), where **iR**[1] is the inverse of **R**[1],
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The round functions—**R**[1], **R**[2], and so forth—are usually identical algorithms,
    but they are parameterized by a value we call the *round key*. Two round functions
    with two distinct round keys will behave differently and will therefore produce
    distinct outputs if fed with the same input.
  prefs: []
  type: TYPE_NORMAL
- en: We derive round keys from the main key, *K*, using a *key schedule* algorithm.
    For example, **R**[1] takes the round key *K*[1], **R**[2] takes the round key
    *K*[2], and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Round keys should be different from each other in every round. For that matter,
    not all round keys should be equal to the key *K*; otherwise, all the rounds would
    be identical, and the block cipher would be less secure, as I’ll describe next.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Slide Attack</samp>
    <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">and Round Keys</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a block cipher, no round should be identical to another round in order to
    avoid a *slide attack*. As [Figure 4-1](chapter4.xhtml#fig4-1) shows, slide attacks
    look for two plaintext/ciphertext pairs (*P*[1], *C*[1]) and (*P*[2], *C*[2]),
    where *P*[2] = **R**(*P*[1]) if **R** is the cipher’s round. When rounds are identical,
    the relation between the two plaintexts, *P*[2] = **R**(*P*[1]), implies the relation
    *C*[2] = **R**(*C*[1]) between their respective ciphertexts. [Figure 4-1](chapter4.xhtml#fig4-1)
    shows three rounds, but the relation *C*[2] = **R**(*C*[1]) will hold no matter
    the number of rounds, be it 3, 10, or 100\. The problem is that knowing the input
    and output of a single round often helps recover the key. (For details, read the
    1999 paper “Advanced Slide Attacks” by Alex Biryukov and David Wagner, available
    at *[https://<wbr>www<wbr>.iacr<wbr>.org<wbr>/archive<wbr>/eurocrypt2000<wbr>/1807<wbr>/18070595<wbr>-new<wbr>.pdf](https://www.iacr.org/archive/eurocrypt2000/1807/18070595-new.pdf)*.)
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: The principle of
    the slide attack against block ciphers with identical rounds</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Using different round keys as parameters ensures that the rounds will behave
    differently and thus foil slide attacks.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*One potential byproduct and benefit of using round keys is protection against*
    side-channel attacks*, or attacks that exploit information leaked from the implementation
    of a cipher (for example, electromagnetic emanations). If the transformation from
    the main key,* K*, to a round key,* K[i]*, isn’t invertible, then if an attacker
    finds* K[i]*, they can’t use that key to find* K*. Unfortunately, few block ciphers
    have a one-way key schedule. The key schedule of AES allows attackers to compute*
    K *from any round key,* K[i]*, for example.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Substitution–Permutation
    Networks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’ve read textbooks about cryptography, you’ve likely come across confusion
    and diffusion. *Confusion* means that the input (plaintext and encryption key)
    undergoes complex transformations, and *diffusion* means that these transformations
    depend equally on all bits of the input. At a high level, confusion is about depth,
    whereas diffusion is about breadth. In the design of a block cipher, confusion
    and diffusion take the form of substitution and permutation operations, which
    we combine within substitution–permutation networks (SPNs).
  prefs: []
  type: TYPE_NORMAL
- en: Substitution often appears in the form of *S-boxes*, or *substitution boxes*,
    which are small lookup tables that transform chunks of 4 or 8 bits. For example,
    the first of the eight S-boxes of the block cipher Serpent is composed of the
    16 elements (3 8 f 1 a 6 5 b e d 4 2 7 0 9 c), where each element represents a
    4-bit nibble. This particular S-box maps the 4-bit nibble 0000 to 3 (0011), the
    4-bit nibble 0101 (5 in decimal) to 6 (0110), and so on.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*S-boxes must be carefully chosen to be cryptographically strong: they should
    be as nonlinear as possible (inputs and outputs should be related with complex
    equations) and have no statistical bias (meaning, for example, that flipping an
    input bit should potentially affect any of the output bits).*'
  prefs: []
  type: TYPE_NORMAL
- en: 'The permutation in a substitution–permutation network can be as simple as changing
    the order of the bits, which is easy to implement but doesn’t mix up the bits
    very much. Instead of a reordering of the bits, some ciphers use basic linear
    algebra and matrix multiplications to mix up the bits: they perform a series of
    multiplication operations with fixed values (the matrix’s coefficients) and then
    add the results. Such operations can quickly create dependencies between all the
    bits within a cipher and thus ensure strong diffusion. For example, the block
    cipher FOX transforms a 4-byte vector (*a*, *b*, *c*, *d*) to (*a*′, *b*′, *c*′,
    *d*′), which we define as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/pg66-1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In these equations, we interpret the numbers 2 and 253 as binary polynomials
    rather than integers; hence, we define additions and multiplications a bit differently
    than what we’re used to. For example, instead of having 2 + 2 = 4, we have 2 +
    2 = 0\. Regardless, each byte in the initial state affects all 4 bytes in the
    final state.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Feistel Schemes</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In the 1970s, IBM engineer Horst Feistel designed a block cipher, Lucifer,
    that works as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Split the 64-bit block into two 32-bit halves, *L* and *R*.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Set *L* to *L* ⊕ **F**(*R*), where **F** is a substitution–permutation round.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Swap the values of *L* and *R*.
  prefs: []
  type: TYPE_NORMAL
- en: 4.  Go to step 2 and repeat 15 times.
  prefs: []
  type: TYPE_NORMAL
- en: 5.  Merge *L* and *R* into the 64-bit output block.
  prefs: []
  type: TYPE_NORMAL
- en: This construction is a *Feistel scheme*, as [Figure 4-2](chapter4.xhtml#fig4-2)
    shows. The left side is the scheme as just described; the right side is a functionally
    equivalent representation where, instead of swapping *L* and *R*, rounds alternate
    the operations *L* = *L* ⊕ **F**(*R*) and *R* = *R* ⊕ **F**(*L*).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: The Feistel scheme
    block cipher construction in two equivalent forms</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: I’ve omitted the keys from [Figure 4-2](chapter4.xhtml#fig4-2) to simplify the
    diagrams, but note that the first **F** takes a round key, *K*[1], and the second
    **F** takes another round key, *K*[2]. In DES, the **F** functions take a 48-bit
    round key, which it derives from the 56-bit key, *K*.
  prefs: []
  type: TYPE_NORMAL
- en: In a Feistel scheme, the **F** function can be either a pseudorandom permutation
    (PRP) or a pseudorandom function (PRF). A PRP yields distinct outputs for any
    two distinct inputs, whereas a PRF will have values *X* and *Y* for which **F**(*X*)
    = **F**(*Y*). But in a Feistel scheme, that difference doesn’t matter as long
    as **F** is cryptographically strong.
  prefs: []
  type: TYPE_NORMAL
- en: How many rounds should there be in a Feistel scheme? Well, DES performs 16 rounds,
    whereas GOST 28147-89 performs 32 rounds. If the **F** function is as strong as
    possible, four rounds are sufficient in theory, but real ciphers use more rounds
    to defend against potential weaknesses in **F**.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Advanced Encryption Standard</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: AES is the most-used cipher in the world. Prior to the adoption of AES, the
    standard cipher in use was DES, with its ridiculous 56-bit security, as well as
    the upgraded version of DES known as Triple DES, or 3DES. Although 3DES provides
    a higher level of security (112-bit security), it’s inefficient because the key
    needs to be 168 bits long to get 112-bit security, and it’s slow in software (DES
    was created to be fast in integrated circuits, not on mainstream CPUs). AES fixes
    both issues.
  prefs: []
  type: TYPE_NORMAL
- en: NIST standardized AES in 2000 as a replacement for DES, at which point it became
    the world’s de facto encryption standard. Most commercial encryption products
    today support AES, and the NSA has approved it for protecting top-secret information.
    (Some countries do prefer to use their own ciphers, largely because they don’t
    want to use a US standard, but AES is actually more Belgian than it is American.)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*AES went by the name* Rijndael *(a portmanteau for its inventors’ names, Rijmen
    and Daemen, pronounced like “rain-dull”) when it was one of the 15 candidates
    in the AES competition, the process held by NIST from 1997 to 2000 to specify
    “an unclassified, publicly disclosed encryption algorithm capable of protecting
    sensitive government information well into the next century,” as stated in the
    1997 announcement of the competition in the* Federal Register. *The AES competition
    was a kind of “Got Talent” competition for cryptographers, where anyone could
    participate by submitting a cipher or breaking other contestants’ ciphers.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES Internals</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: AES processes blocks of 128 bits using a secret key of 128, 192, or 256 bits,
    with the 128-bit key being the most common because it makes encryption slightly
    faster and because the difference between 128- and 256-bit security is meaningless
    for most applications.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas some ciphers work with individual bits or 64-bit words, AES manipulates
    *bytes*. It views a 16-byte plaintext as a two-dimensional array of bytes (*s*
    = *s*[0], *s*[1], . . . , *s*[15]), as [Figure 4-3](chapter4.xhtml#fig4-3) illustrates.
    (We use the letter *s* because this array is the *internal state*, or just *state*.)
    AES transforms the bytes, columns, and rows of this array to produce a final value
    that is the ciphertext.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: The internal state
    of AES as a 4×4 array of 16 bytes</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: To transform its state, AES uses an SPN structure as in [Figure 4-4](chapter4.xhtml#fig4-4),
    with 10 rounds for 128-bit keys, 12 for 192-bit keys, and 14 for 256-bit keys.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-4: The internal operations
    of AES</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-4](chapter4.xhtml#fig4-4) shows the four building blocks of an AES
    round (note that all but the last round are a sequence of SubBytes, ShiftRows,
    MixColumns, and AddRoundKey):'
  prefs: []
  type: TYPE_NORMAL
- en: '**AddRoundKey **XORs a round key to the internal state.'
  prefs: []
  type: TYPE_NORMAL
- en: '**SubBytes **Replaces each byte (*s*[0], *s*[1] . . . , *s*[15]) with another
    byte according to an S-box. In this example, the S-box is a lookup table of 256
    elements.'
  prefs: []
  type: TYPE_NORMAL
- en: '**ShiftRows **Shifts the *i*th row of *i* positions, for *i* ranging from 0
    to 3 (see [Figure 4-5](chapter4.xhtml#fig4-5)).'
  prefs: []
  type: TYPE_NORMAL
- en: '**MixColumns **Applies the same linear transformation to each of the four columns
    of the state (that is, each group of cells with the same shade of gray, as on
    the left side of [Figure 4-5](chapter4.xhtml#fig4-5)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-5: ShiftRows rotates
    bytes within each row of the internal state.</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that in an SPN, the *S* stands for substitution and the *P* for permutation.
    Here, the substitution layer is SubBytes, and the permutation layer is the combination
    of ShiftRows and MixColumns.
  prefs: []
  type: TYPE_NORMAL
- en: The key schedule function KeyExpansion, as [Figure 4-4](chapter4.xhtml#fig4-4)
    shows, is the AES key schedule algorithm. This expansion creates 11 round keys
    (*K*[0], *K*[1], . . . , *K*[10]) of 16 bytes each from the 16-byte key, using
    the same S-box as SubBytes and a combination of XORs. One important property of
    KeyExpansion is that given any round key, *K*i, an attacker can determine all
    other round keys as well as the main key, *K*, by reversing the algorithm. The
    ability to get the key from any round key reduces the cipher’s resistance to side-channel
    attacks, where an attacker may easily recover a round key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Without these operations, AES would be totally insecure. Each operation contributes
    to AES’s security in a specific way:'
  prefs: []
  type: TYPE_NORMAL
- en: Without KeyExpansion, all rounds would use the same key, *K*, and AES would
    be vulnerable to slide attacks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without AddRoundKey, encryption wouldn’t depend on the key; hence, anyone could
    decrypt any ciphertext without the key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SubBytes brings nonlinear operations, which add cryptographic strength. Without
    it, AES would just be a large system of linear equations that can be solved using
    high school algebra (namely, Gaussian elimination).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without ShiftRows, changes in a given column would never affect the other columns,
    meaning you could break AES by building four 2^(32)-element codebooks for each
    column. (Remember that in a secure block cipher, flipping a bit in the input should
    affect all the output bits.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without MixColumns, changes in a byte wouldn’t affect any other bytes of the
    state. A chosen-plaintext attacker could then decrypt any ciphertext after storing
    16 lookup tables of 256 bytes each that hold the encrypted values of each possible
    value of a byte.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice in [Figure 4-4](chapter4.xhtml#fig4-4) that the last round of AES doesn’t
    include the MixColumns operation. That operation is omitted to save useless computation:
    because MixColumns is linear, you could cancel its effect in the very last round
    by combining bits in a way that doesn’t depend on their value or the key. However,
    we can’t invert SubBytes without the state’s value being known prior to AddRoundKey.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To decrypt a ciphertext, AES unwinds each operation by taking its inverse function:
    the inverse lookup table of SubBytes reverses the SubBytes transformation, ShiftRow
    shifts in the opposite direction, MixColumns’s inverse is applied (as in the matrix
    inverse of the matrix encoding its operation), and AddRoundKey’s XOR is unchanged
    because the inverse of an XOR is another XOR.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES in Action</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As an exercise, you can use Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">cryptography</samp>
    library to encrypt and decrypt a block of data with AES, as in [Listing 4-1](chapter4.xhtml#Lis4-1).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-1: AES encryption
    and decryption of a block in Python</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this script produces something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You’ll get different results because the key is randomized at every new execution.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How to Implement AES</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Real AES software works differently than the algorithm in [Figure 4-4](chapter4.xhtml#fig4-4).
    You won’t find production-level AES code calling a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubBytes()</samp>
    function, then a <samp class="SANS_TheSansMonoCd_W5Regular_11">ShiftRows()</samp>
    function, and then a <samp class="SANS_TheSansMonoCd_W5Regular_11">MixColumns()</samp>
    function because that would be inefficient. Instead, fast AES software uses table-based
    implementations and native instructions.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Table-Based Implementations</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Table-based implementations of AES replace the sequence SubBytes-ShiftRows-MixColumns
    with a combination of XORs and lookups in tables hardcoded into the program and
    loaded in memory at execution time. This is possible because MixColumns is equivalent
    to XORing four 32-bit values, where each depends on a single byte from the state
    and on SubBytes. Thus, you can build four tables with 256 entries each, one for
    each byte value, and implement the sequence SubBytes-MixColumns by looking up
    four 32-bit values and XORing them together.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the table-based C implementation in the OpenSSL toolkit looks like
    [Listing 4-2](chapter4.xhtml#Lis4-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-2: An excerpt of
    the table-based C implementation of AES in OpenSSL</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: A basic table-based implementation of AES encryption needs four 4KB’s worth
    of tables because each table stores 256 32-bit values, which occupy 256 × 32 =
    8,192 bits, or 1KB. Decryption requires another four tables and thus 4KB more.
    But there are tricks to reduce the storage from 4KB to 1, or even less.
  prefs: []
  type: TYPE_NORMAL
- en: Alas, table-based implementations are vulnerable to *cache-timing attacks*,
    which exploit timing variations when a program reads or writes elements in cache
    memory. Access time varies depending on the relative position in cache memory
    of the accessed elements. Timings thus leak information about the accessed element,
    which in turn leaks information on the secrets involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cache-timing attacks are difficult to avoid. One obvious solution would be
    to ditch lookup tables altogether by writing a program whose execution time doesn’t
    depend on its inputs, but that’s almost impossible to do and still retain the
    same speed, so chip manufacturers have opted for a radical solution: instead of
    relying on potentially vulnerable software, they rely on *hardware*.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Native Instructions</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'AES native instructions (AES-NI) solve the problem of cache-timing attacks
    on AES software implementations. To understand how AES-NI works, think about the
    way software runs on hardware: to run a program, a microprocessor translates binary
    code into a series of instructions that integrated circuit components execute.
    For example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">MUL</samp> assembly
    instruction between two 32-bit values will activate the transistors implementing
    a 32-bit multiplier in the microprocessor. To implement a crypto algorithm, we
    usually express a combination of basic operations—additions, multiplications,
    XORs, and so on—and the microprocessor activates its adders, multipliers, and
    XOR circuits in the prescribed order.'
  prefs: []
  type: TYPE_NORMAL
- en: AES native instructions take this to a whole new level by providing developers
    with dedicated assembly instructions that compute AES. Instead of coding an AES
    round as a sequence of assembly instructions, when using AES-NI, you just call
    the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">AESENC</samp>, and
    the chip computes the round for you. Native instructions allow you to tell the
    processor to run an AES round instead of requiring you to program rounds as a
    combination of basic operations.
  prefs: []
  type: TYPE_NORMAL
- en: A typical assembly implementation of AES using native instructions looks like
    [Listing 4-3](chapter4.xhtml#Lis4-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-3: An implementation
    of AES-128 using AES native instructions</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: This code encrypts the 128-bit plaintext initially in the register <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm0</samp>,
    assuming that registers <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm5</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm15</samp> hold the precomputed
    round keys, with each instruction writing its result into <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm0</samp>.
    The initial <samp class="SANS_TheSansMonoCd_W5Regular_11">PXOR</samp> instruction
    XORs the first round key prior to computing the first round, and the final <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AESENCLAST</samp> instruction performs
    the last round slightly differently from the others (MixColumns is omitted).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*AES is about 10 times faster on platforms that implement native instructions,
    which, as I write this, include virtually all laptop, desktop, and server microprocessors,
    as well as most mobile phones and tablets. Although Intel originally proposed
    AES instructions in 2008, they’re also available in AMD processors, and most architectures
    other than x86 also have equivalent instructions implementing AES in hardware.
    For example, the Armv8 instruction set contains the instructions <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESSE*</samp>
    (which calculates SubBytes and ShiftRows) and <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESMS*</samp>
    (which calculates MixColumns).*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*On Intel’s Ice Lake microarchitecture, the <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESENC*</samp>
    instruction has a latency of three cycles with a reciprocal throughput of half
    a cycle, meaning that a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESENC*</samp>
    takes three cycles to complete, and we can make two new calls to the instruction
    in each cycle. In fact, the internal structure of the micro-operations performing
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESENC*</samp> operation means
    that a new instruction computation can start before the previous one has finished.
    What’s more, the Ice Lake architecture uses a vectorized version of AES instructions,
    enabling several to be initiated at the same time. For more details, see the article
    “Making AES Great Again” by Nir Drucker, Shay Gueron, and Vlad Krasnov, available
    at* [https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2018<wbr>/392](https://eprint.iacr.org/2018/392)*.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*To encrypt a series of blocks one after the other, it takes 3 × 10 = 30 cycles
    to complete the 10 rounds, or 30 / 16 = 1.875 cycles per byte. At a frequency
    of 2 GHz (2 × 10**⁹* *cycles per second), this gives a theoretical maximum throughput
    of around 1GBps. If you can process blocks in parallel, then you don’t need one
    complete <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESENC*</samp> call before
    starting another. In this case, you can make two <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESENC*</samp>
    calls per cycle and obtain two results per cycle, offering a much higher theoretical
    throughput (up to more than 10GBps, at 2 GHz), depending on the data size and
    mode of operation.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES Security</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: AES is as secure as a block cipher can be, and it will never be broken. Fundamentally,
    AES is secure because all output bits depend on all input bits in some complex,
    pseudorandom way. To achieve this, the designers of AES carefully chose each component
    for a particular reason—MixColumns for its maximal diffusion properties and SubBytes
    for its optimal nonlinearity. This composition protects AES against whole classes
    of cryptanalytic attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there’s no proof that AES is immune to all possible attacks. For one thing,
    we don’t know what all possible attacks are, and we don’t always know how to prove
    that a cipher is secure against a given attack. The only way to really gain confidence
    in the security of AES is to crowdsource attacks: have many skilled people attempt
    to break AES and, ideally, fail to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: After more than 15 years and hundreds of research publications, we’ve only scratched
    the surface of the theoretical security of AES. In 2011, cryptanalysts found a
    way to recover an AES-128 key by performing about 2^(126) operations instead of
    2^(128), a speedup of a factor of 4\. But this “attack” requires a high number
    of plaintext–ciphertext pairs—about 2^(88) bits’ worth. It’s a nice finding but
    not one you need to worry about.
  prefs: []
  type: TYPE_NORMAL
- en: You should care about a million things when implementing and deploying crypto,
    but AES security is not one of them. The biggest threat to block ciphers isn’t
    in their core algorithms but in their modes of operation. If you’ve chosen an
    incorrect mode or misused the right one, even a strong cipher like AES won’t save
    you.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Modes of Operation</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 1](chapter1.xhtml), I explained how encryption schemes combine
    a permutation with a mode of operation to handle messages of any length. In this
    section, I’ll cover the main modes of operations that block ciphers use, their
    security and functional properties, and how (not) to use them. I’ll begin with
    the dumbest one: electronic codebook.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Electronic Codebook
    Mode</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The simplest of the block cipher encryption modes is electronic codebook (ECB),
    which is barely a mode of operation at all. ECB takes plaintext blocks *P*[1],
    *P*[2], . . . , *P*N and processes each independently by computing *C*[1] = **E**(*K*,
    *P*[1]), *C*[2] = **E**(*K*, *P*[2]), and so on, as [Figure 4-6](chapter4.xhtml#fig4-6)
    shows. It’s a simple operation but also an insecure one—ECB is insecure, and you
    shouldn’t use it.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-6: ECB mode</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Marsh Ray, a cryptographer at Microsoft, once said, “Everybody knows ECB mode
    is bad because we can see the penguin.” He was referring to a famous illustration
    of ECB’s insecurity that uses an image of Linux’s mascot, Tux, as in [Figure 4-7](chapter4.xhtml#fig4-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-7: The original image
    (left) and the ECB-encrypted image (right)</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: The original image of Tux is on the left, and the ECB-encrypted image that uses
    AES (though the underlying cipher doesn’t matter) is on the right. It’s easy to
    see the penguin’s shape in the encrypted version because ECB encrypted all the
    blocks of one shade of gray in the original image to the same new shade of gray
    in the new image; in other words, ECB encryption gives you the same image with
    different colors.
  prefs: []
  type: TYPE_NORMAL
- en: The Python program in [Listing 4-4](chapter4.xhtml#Lis4-4) also shows ECB’s
    insecurity. It picks a pseudorandom key and encrypts a 32-byte message <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    containing two blocks of null bytes. Notice that encryption yields two identical
    blocks and that repeating encryption with the same key and the same plaintext
    yields the same two blocks again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-4: Using AES in ECB
    mode in Python</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this script gives ciphertext blocks like this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When using the ECB mode, identical ciphertext blocks reveal identical plaintext
    blocks to an attacker, whether those are blocks within a single ciphertext or
    across different ciphertexts. This shows that block ciphers in ECB mode aren’t
    semantically secure.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with ECB is that it takes only complete blocks of data, so if
    blocks were 16 bytes, as in AES, you could encrypt only chunks of 16 bytes, 32
    bytes, 48 bytes, or any other multiple of 16 bytes. There are a few ways to deal
    with this, as you’ll see with the next mode, CBC. (I won’t tell you how these
    tricks work with ECB because you shouldn’t use ECB in the first place.)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Cipher Block Chaining
    Mode</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Cipher block chaining (CBC) is like ECB but with a small twist that makes a
    big difference: instead of encrypting the *i*th block, *P*i, as *C*i = **E**(*K*,
    *P*i), CBC sets *C*i = **E**(*K*, *P*i ⊕ *C*i [− 1]), where *C*i [− 1] is the
    previous ciphertext block—thereby *chaining* the blocks *C*i [− 1] and *C*i. When
    encrypting the first block, *P*[1], there is no previous ciphertext block to use,
    so CBC takes a random initial value (IV), as [Figure 4-8](chapter4.xhtml#fig4-8)
    illustrates.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-8: CBC mode</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: CBC mode makes each ciphertext block dependent on all the previous blocks and
    ensures that identical plaintext blocks won’t be identical ciphertext blocks.
    The random initial value guarantees that two identical plaintexts will encrypt
    to distinct ciphertexts when calling the cipher twice with two distinct initial
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-5](chapter4.xhtml#Lis4-5) illustrates these two benefits. This program
    takes an all-zero, 32-byte message (like the one in [Listing 4-4](chapter4.xhtml#Lis4-4)),
    encrypts it twice with CBC, and shows the two ciphertexts. The bolded line <samp
    class="SANS_TheSansMonoCd_W5Regular_11">iv = urandom(BLOCK _SIZE)</samp> picks
    a new random IV for each new encryption.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-5: Using AES in CBC
    mode</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The two plaintexts are the same (two all-zero blocks), but the encrypted blocks
    should be distinct, as in this example execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Alas, we often use CBC with a constant IV instead of a random one, which exposes
    identical plaintexts and plaintexts that start with identical blocks. For example,
    say CBC encrypts the two-block plaintext *P*[1] || *P*[2] to the two-block ciphertext
    *C*[1] || *C*[2]. If CBC encrypts *P*[1] || *P*[2]′ with the same IV, where *P*[2]′
    is some block distinct from *P*[2], then the ciphertext will look like *C*[1]
    || *C*[2]′, with *C*[2]′ different from *C*[2] but with the same first block *C*[1].
    Thus, an attacker can guess that the first block is the same for both plaintexts,
    even though they see only the ciphertexts.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In CBC mode, decryption needs to know the IV used to encrypt, so the IV is
    sent along with the ciphertext, in the clear.*'
  prefs: []
  type: TYPE_NORMAL
- en: With CBC, decryption can be much faster than encryption due to parallelism.
    While encryption of a new block, *P*i, needs to wait for the previous block, *C*i
    [− 1], decryption of a block computes *P*i = **D**(*K*, *C*i) ⊕ *C*i [− 1], where
    there’s no need for the previous plaintext block, *P*i [− 1]. This means you can
    decrypt all blocks in parallel simultaneously, as long as you know the previous
    ciphertext block, which you usually will.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Message Encryption
    in CBC Mode</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s circle back to the block termination issue and look at how to process
    a plaintext whose length is not a multiple of the block length. For example, how
    would you encrypt an 18-byte plaintext with AES-CBC when blocks are 16 bytes?
    What do you do with the 2 bytes left? You’ll look at two widely used techniques
    to deal with this problem. The first one, padding, makes the ciphertext a bit
    longer than the plaintext, while the second one, *ciphertext stealing*, produces
    a ciphertext of the same length as the plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Message Padding</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Padding is a technique that allows you to encrypt a message of any length, even
    one smaller than a single block. The PKCS#7 standard and RFC 5652 specify padding
    for block ciphers, which we use almost everywhere we use CBC.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use padding to expand a message to fill a complete block by adding extra
    bytes to the plaintext. Here are the rules for padding 16-byte blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: If there’s 1 byte left—for example, if the plaintext is 1 byte, 17 bytes, or
    33 bytes long—pad the message with 15 bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">0f</samp>
    (15 in decimal).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are 2 bytes left, pad the message with 14 bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">0e</samp>
    (14 in decimal).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are 3 bytes left, pad the message with 13 bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">0d</samp>
    (13 in decimal).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are 15 plaintext bytes and a single byte missing to fill a block, padding
    adds a single <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> byte. If
    the plaintext is already a multiple of 16, the block length, add 16 bytes <samp
    class="SANS_TheSansMonoCd_W5Regular_11">10</samp> (16 in decimal). The trick generalizes
    to any block length up to 255 bytes (for larger blocks, a byte is too small to
    encode values greater than 255).
  prefs: []
  type: TYPE_NORMAL
- en: 'Decryption of a padded message works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Decrypt all the blocks as with unpadded CBC.
  prefs: []
  type: TYPE_NORMAL
- en: '2.  Make sure that the last bytes of the last block conform to the padding
    rule: that they finish with at least one <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    byte, at least two <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp> bytes,
    or at least three <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp> bytes,
    and so on. If the padding isn’t valid—for example, if the last bytes are <samp
    class="SANS_TheSansMonoCd_W5Regular_11">01 02 03</samp>—the message is rejected.
    Otherwise, decryption strips the padding bytes and returns the plaintext bytes
    left.'
  prefs: []
  type: TYPE_NORMAL
- en: One downside of padding is that it makes ciphertext longer by at least 1 byte
    and at most a block.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Ciphertext Stealing</samp>
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Ciphertext stealing is another trick we use to encrypt a message whose length
    isn’t a multiple of the block size. Ciphertext stealing is more complex and less
    popular than padding, but it offers a few benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Plaintexts can be of any *bit* length, not just bytes. You can, for example,
    encrypt a message of 131 bits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ciphertexts are exactly the same length as plaintexts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ciphertext stealing is not vulnerable to padding oracle attacks, powerful attacks
    that sometimes work against CBC with padding (as you’ll see in “Padding Oracle
    Attacks” on [page 83](#sec26)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In CBC mode, ciphertext stealing extends the last incomplete plaintext block
    with bits from the previous ciphertext block and then encrypts the resulting block.
    The last, incomplete ciphertext block is made up of the first bits from the previous
    ciphertext block—that is, the bits that haven’t been appended to the last plaintext
    block.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 4-9](chapter4.xhtml#fig4-9), we have three blocks, where the last
    block, *P*[3], is incomplete (represented by a zero). If *P*[3] is 3 bytes, we
    XOR it with the last 12 bits from the previous ciphertext block **E**(*K*, *P*[2])
    and return the encrypted result as *C*[2]. The last ciphertext block, *C*[3],
    then consists of the first 4 bytes of **E**(*K*, *P*[2]). Decryption is simply
    the inverse of this operation.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-9: Ciphertext stealing
    for CBC-mode encryption</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: There aren’t any major problems with ciphertext stealing, but it’s inelegant
    and hard to get right, especially when NIST’s standard specifies three different
    ways to implement it (see Special Publication 800-38A).
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Counter Mode</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To avoid the troubles and retain the benefits of ciphertext stealing, use counter
    mode (CTR). CTR is hardly a block cipher mode: it turns a block cipher into a
    stream cipher that just takes bits in and spits bits out and doesn’t embarrass
    itself with the notion of blocks. (I’ll discuss stream ciphers in detail in [Chapter
    5](chapter5.xhtml).)'
  prefs: []
  type: TYPE_NORMAL
- en: In CTR mode (see [Figure 4-10](chapter4.xhtml#fig4-10)), the block cipher algorithm
    won’t transform plaintext data. Instead, it encrypts blocks composed of a counter
    and a nonce. A *counter* is an integer that is incremented for each block. No
    two blocks should use the same counter within a message, but different messages
    can use the same sequence of counter values (1, 2, 3, . . .). A *nonce* is a number
    we use only once. It’s the same for all blocks in a single message, but no two
    messages should use the same nonce.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-10: CTR mode</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-10](chapter4.xhtml#fig4-10) shows that in CTR mode, encryption XORs
    the plaintext and the stream taken from “encrypting” the nonce, *N*, and counter,
    *Ctr*. Decryption is the same, so you need only the encryption algorithm for both
    encryption and decryption. The Python script in [Listing 4-6](chapter4.xhtml#Lis4-6)
    gives you a hands-on example.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-6: Using AES in CTR
    mode</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The example execution encrypts a 4-byte plaintext and gets a 4-byte ciphertext.
    It then decrypts that ciphertext using the encryption function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the initial value in CBC, the encrypter supplies CTR’s nonce and sends
    it with the ciphertext in the clear. But unlike CBC’s initial value, CTR’s nonce
    doesn’t need to be random; it simply needs to be unique. A nonce should be unique
    for the same reason that we shouldn’t reuse a one-time pad: when calling the pseudorandom
    stream, *S*, if you encrypt *P*[1] to *C*[1] = *P*[1] ⊕ *S* and *P*[2] to *C*[2]
    = *P*[2] ⊕ *S* using the same nonce, then *C*[1] ⊕ *C*[2] reveals *P*[1] ⊕ *P*[2].'
  prefs: []
  type: TYPE_NORMAL
- en: A random nonce will do the trick only if it’s long enough; for example, if the
    nonce is *n* bits, chances are that after 2*^n*^(/2) encryptions and as many nonces,
    you’ll run into duplicates. Sixty-four bits are insufficient for a random nonce,
    since you can expect a repetition after approximately 2^(32) nonces, which is
    an unacceptably low number.
  prefs: []
  type: TYPE_NORMAL
- en: The counter is guaranteed unique if it’s incremented for every new plaintext,
    and if it’s long enough—for example, a 64-bit counter.
  prefs: []
  type: TYPE_NORMAL
- en: One particular benefit to CTR is that it can be faster than any other mode.
    Not only is it parallelizable, but you can also start encrypting even before knowing
    the message by picking a nonce and computing the stream that you’ll later XOR
    with the plaintext.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Depending on the CTR version we implement, we may either concatenate the nonce
    the API uses as an argument to a counter (as in [Figure 4-10](chapter4.xhtml#fig4-10))
    or directly consider a counter as wide as a block.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two must-know attacks on block ciphers: meet-in-the-middle attacks,
    a technique discovered in the 1970s but still used in many cryptanalytic attacks
    (not to be confused with man-in-the-middle attacks), and padding oracle attacks,
    a class of attacks discovered in 2002 by academic cryptographers, then mostly
    ignored, and finally rediscovered a decade later along with several vulnerable
    applications.'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Meet-in-the-Middle
    Attacks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The 3DES block cipher is an upgraded version of the 1970s standard DES that
    takes a key of 56 × 3 = 168 bits (an improvement on DES’s 56-bit key). But the
    security level of 3DES is 112 bits instead of 168 bits because of the *meet-in-the-middle
    (MitM)* attack.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-11](chapter4.xhtml#fig4-11) shows that 3DES encrypts a block using
    the DES encryption and decryption functions: first encryption with a key, *K*[1];
    then decryption with a key, *K*[2]; and finally encryption with another key, *K*[3].
    If *K*[1] = *K*[2], the first two calls cancel themselves out, and 3DES boils
    down to a single DES with key *K*[3]. 3DES does encrypt-decrypt-encrypt rather
    than encrypting thrice to allow systems to emulate DES when necessary using the
    new 3DES interface.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-11: The 3DES block
    cipher construction</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: Why use triple DES and not just double DES—that is, why encrypt a plaintext
    *P* to **E**(*K*[2], **E**(*K*[1], *P*))? It turns out that the MitM attack makes
    double DES only as secure as single DES. [Figure 4-12](chapter4.xhtml#fig4-12)
    shows the MitM attack in action.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-12: The MitM attack</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'The MitM attack works as follows to attack double DES:'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Say you have *P* and *C* = **E**(*K*[2], **E**(*K*[1], *P*)) with two unknown
    56-bit keys, *K*[1] and *K*[2]. (DES takes 56-bit keys, so double DES takes 112
    key bits in total.) You build a key-value table with 2^(56) entries of **E**(*K*[1],
    *P*), where **E** is the DES encryption function and *K*[1] is the value stored.
  prefs: []
  type: TYPE_NORMAL
- en: 2.  For all 2^(56) values of *K*[2], compute **D**(*K*[2], *C*) and check whether
    the resulting value appears in the table as an index (thus as a middle value,
    represented by a question mark in [Figure 4-12](chapter4.xhtml#fig4-12)).
  prefs: []
  type: TYPE_NORMAL
- en: 3.  If you find a middle value as an index of the table, fetch the corresponding
    *K*[1] from the table and verify that the (*K*[1], *K*[2]) found is the right
    one by using other pairs of *P* and *C*. Encrypt *P* using *K*[1] and *K*[2] and
    then check that the ciphertext obtained is the given *C*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method recovers *K*[1] and *K*[2] by performing about 2^(57) instead of
    2^(112) operations: step 1 encrypts 2^(56) blocks, and then step 2 decrypts at
    most 2^(56) blocks, for 2^(56) + 2^(56) = 2^(57) operations in total. You also
    need to store 2^(56) elements of 15 bytes each, or about 1 exabyte. That’s a lot,
    but there’s a trick that allows you to run the same attack with only negligible
    memory (as you’ll see in [Chapter 6](chapter6.xhtml)).'
  prefs: []
  type: TYPE_NORMAL
- en: You can apply the MitM attack to 3DES in almost the same way you would to double
    DES, except that the third stage will go through all 2^(112) values of *K*[2]
    and *K*[3]. The whole attack thus succeeds after performing about 2^(112) operations,
    meaning that 3DES gets only 112-bit security despite having 168 bits of key material.
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Padding Oracle Attacks</samp>
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We conclude this chapter with one of the simplest and yet most devastating
    attacks of the 2000s: the padding oracle attack. Remember that padding fills the
    plaintext with extra bytes to fill a block. A plaintext of 111 bytes, for example,
    is a sequence of six 16-byte blocks followed by 15 bytes. In this case, forming
    a complete block padding adds a <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    byte. For a 110-byte plaintext, padding adds 2 <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp>
    bytes. For a 109-byte plaintext, it adds 3 <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp>
    bytes, and so on, up to the case where we add 16 <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    bytes, where the hexadecimal value <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    is equal to 16.'
  prefs: []
  type: TYPE_NORMAL
- en: A *padding oracle* is a system that behaves differently depending on whether
    the padding in a CBC-encrypted ciphertext is valid. You can see it as a black
    box or an API that returns either a *success* or an *error* value. You can, for
    example, obtain a padding oracle in a service on a remote host that sends error
    messages when it receives malformed ciphertexts. Given such an oracle, padding
    oracle attacks record which inputs have a valid padding and which don’t and then
    exploit this information to decrypt chosen ciphertext values.
  prefs: []
  type: TYPE_NORMAL
- en: Say you want to decrypt a ciphertext block *C*[2]. I’ll call *X* the value you’re
    looking for, namely, **D**(*K*, *C*[2]), and *P*[2] the block obtained after decrypting
    in CBC mode (see [Figure 4-13](chapter4.xhtml#fig4-13)). If you pick a random
    block *C*[1] and send the two-block ciphertext *C*[1] || *C*[2] to the oracle,
    decryption will succeed only if *C*[1] ⊕ *X = P*[2] ends with valid padding—a
    single <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> byte, two <samp
    class="SANS_TheSansMonoCd_W5Regular_11">02</samp> bytes, or three <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp>
    bytes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-13: Padding oracle
    attacks recover</samp> <samp class="SANS_Futura_Std_Book_11">X</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">by
    choosing</samp> <samp class="SANS_Futura_Std_Book_11">C</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">1</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and checking the validity of padding.</samp>'
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this observation, padding oracle attacks on CBC encryption can decrypt
    a block *C*[2] like this (bytes are denoted in array notation: *C*[1][0] is *C*[1]’s
    first byte, *C*[1][1] its second byte, and so on up to *C*[1][15], *C*[1]’s last
    byte):'
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Pick a random block *C*[1] and vary its last byte until the padding oracle
    accepts the ciphertext as valid. Usually, in a valid ciphertext, *C*[1][15] ⊕
    *X*[15] = <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>, so you’ll find
    *X*[15] after trying around 128 values of *C*[1][15].
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Find the value *X*[14] by setting *C*[1][15] to *X*[15] ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp>
    and searching for the *C*[1][14] that gives correct padding. When the oracle accepts
    the ciphertext as valid, it means you’ve found *C*[1][14] such that *C*[1][14]
    ⊕ *X*[14] = <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp>.
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Repeat steps 1 and 2 for all 16 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: The attack needs on average 128 queries to the oracle for each of the 16 bytes,
    which is about 2,000 queries in total. (Note that each query must use the same
    initial value.)
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In practice, implementing a padding oracle attack is a bit more complicated
    than what I’ve described because you have to deal with wrong guesses at step 1\.
    A ciphertext may have valid padding not because* P2 *ends with a single <samp
    class="SANS_TheSansMonoCd_W5Regular_11">01</samp> but because it ends with two
    <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp> bytes or three <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp>
    bytes. You can manage this by testing the validity of ciphertexts where more bytes
    are modified.*'
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s a lot to say about block ciphers, be it in how algorithms work or in
    how they can be attacked. For instance, Feistel networks and SPNs aren’t the only
    ways to build a block cipher. The block ciphers IDEA and FOX use the Lai–Massey
    construction, and Threefish uses ARX networks, a combination of addition, word
    rotations, and XORs.
  prefs: []
  type: TYPE_NORMAL
- en: There are also many more modes than ECB, CBC, and CTR. Some modes are folklore
    techniques that nobody uses, like CFB and OFB, while others are for specific applications,
    like XTS for tweakable encryption or GCM for authenticated encryption.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve discussed Rijndael, the AES winner, but there were 14 other algorithms
    in the race: CAST-256, CRYPTON, DEAL, DFC, E2, FROG, HPC, LOKI97, Magenta, MARS,
    RC6, SAFER+, Serpent, and Twofish. I recommend looking them up to see how they
    work, how they were designed, how they have been attacked, and how fast they are.
    It’s also worth checking out the NSA’s designs (Skipjack and, more recently, SIMON
    and SPECK) and more recent “lightweight” block ciphers such as GIFT, KATAN, PRESENT,
    or PRINCE.'
  prefs: []
  type: TYPE_NORMAL
