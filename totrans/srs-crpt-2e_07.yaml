- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">4</samp> <samp class="SANS_Dogma_OT_Bold_B_11">BLOCK
    CIPHERS</samp>
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
- en: During the Cold War, the United States and the Soviets developed their own ciphers.
    The US government created the Data Encryption Standard (DES), which was adopted
    as a federal standard from 1979 to 2005, while the KGB developed GOST 28147-89,
    an algorithm kept secret until 1990 and still used today. In 2000, the US-based
    National Institute of Standards and Technology (NIST) selected the successor to
    DES, the Advanced Encryption Standard (AES), an algorithm developed in Belgium
    and now found in most electronic devices. AES, DES, and GOST 28147-89 are all
    *block ciphers*, a type of cipher that combines a core algorithm working on blocks
    of data with a *mode of operation*, or a technique to process sequences of data
    blocks.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: This chapter reviews the core algorithms that underlie block ciphers, discusses
    their modes of operation, and explains how they all work together. It also discusses
    how AES works and concludes with coverage of a classic attack tool from the 1970s,
    the meet-in-the-middle attack, and a favorite attack technique of the 2000s—padding
    oracles.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">What Is a Block Cipher?</samp>
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A block cipher consists of an encryption algorithm and a decryption algorithm:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: The *encryption algorithm* (**E**) takes a key, *K*, and a plaintext block,
    *P*, and produces a ciphertext block, *C*. We write an encryption operation as
    *C* = **E**(*K*, *P*).
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *decryption algorithm* (**D**) is the inverse of the encryption algorithm
    and decrypts a message to the original plaintext, *P*. We write this operation
    as *P* = **D**(*K*, *C*).
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since they’re the inverse of each other, the encryption and decryption algorithms
    usually involve similar operations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Security Goals</samp>
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’ve followed earlier discussions about encryption, randomness, and indistinguishability,
    the definition of a secure block cipher will come as no surprise. We’ll continue
    to define security as random-looking-ness, so to speak.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: For a block cipher to be secure, it should be a *pseudorandom permutation (PRP)*,
    meaning that as long as the key is secret, an attacker shouldn’t be able to compute
    an output of the block cipher from any input. That is, as long as *K* is secret
    and random from an attacker’s perspective, they should have no clue what **E**(*K*,
    *P*) looks like, for any given *P*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: More generally, attackers should be unable to discover any *pattern* in the
    input/output values of a block cipher. In other words, it should be impossible
    to tell a block cipher from a truly random permutation, given black-box access
    to the encryption and decryption functions for some fixed and unknown key. By
    the same token, attackers should be unable to recover a secure block cipher’s
    secret key; otherwise, they could use that key to tell the block cipher from a
    random permutation. This implies that attackers can’t predict the plaintext that
    corresponds to a given ciphertext the block cipher produces.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Block Size</samp>
  id: totrans-15
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Two values characterize a block cipher: the block size and the key size. Security
    depends on both values. Most block ciphers have either 64-bit or 128-bit blocks—DES’s
    blocks have 64 (2⁶) bits, and AES’s blocks have 128 (2⁷) bits. In computing, lengths
    that are generally measured as powers of two simplify data processing, storage,
    and addressing. But why 2⁶ and 2⁷ and not 2⁴ or 2^(16) bits?'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: It’s important that a block cipher’s blocks aren’t too large in order to minimize
    both the length of ciphertext and the memory footprint. Block ciphers first transform
    their input data into a sequence of blocks, which means that to encrypt a 16-bit
    message when blocks are 128 bits, you need to convert the message into a 128-bit
    block for the block cipher to process it and return a 128-bit ciphertext. The
    wider the blocks, the longer this overhead. To process a 128-bit block, you need
    at least 128 bits of memory. Blocks of 64, 128, or even 512 bits are short enough
    to fit in the registers of most CPUs or to implement using dedicated hardware
    circuits, allowing for efficient implementations in most cases. But larger blocks
    (for example, several kilobytes long) can have a noticeable impact on the cost
    and performance of implementations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: When ciphertexts’ length or memory footprint is critical, you may have to use
    64-bit blocks because these produce shorter ciphertexts and consume less memory.
    Otherwise, 128-bit or larger blocks are better, mainly because modern CPUs can
    often process 128-bit blocks more efficiently than 64-bit ones and they’re more
    secure (see the “Sweet32” attack, at *[https://<wbr>sweet32<wbr>.info](https://sweet32.info)*).
    In particular, CPUs can leverage instructions to efficiently process one or more
    128-bit blocks in parallel—for example, the Advanced Vector Extensions (AVX) family
    of instructions in Intel CPUs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Codebook Attack</samp>
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'While blocks shouldn’t be too large, they also shouldn’t be too small; otherwise,
    they may be susceptible to *codebook attacks*, which are attacks against block
    ciphers that are efficient only when using smaller blocks. With 16-bit blocks,
    the codebook attack works like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Get the 65,536 (2^(16)) ciphertexts corresponding to each 16-bit plaintext
    block.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Build a lookup table—the *codebook*—mapping each ciphertext block to its
    corresponding plaintext block.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 3.  To decrypt an unknown ciphertext block, look up its corresponding plaintext
    block in the table.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: When using 16-bit blocks, the lookup table needs only 2^(16) × 16 = 2^(20) bits
    of memory, or 128 kilobytes. With 32-bit blocks, memory needs to grow to 16 gigabytes,
    which is still manageable. But with 64-bit blocks, you’d have to store 2^(70)
    bits (a zettabit, or 128 exabytes), so forget about it. Codebook attacks are therefore
    not an issue for larger blocks of 128 bits or more.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How to Construct Block Ciphers</samp>
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There exist hundreds of block ciphers but only a handful of techniques to construct
    one. In practice, a block cipher isn’t a gigantic algorithm but a repetition of
    *rounds*, a short sequence of operations that’s weak on its own but strong in
    number. There are two main techniques to construct a round: substitution–permutation
    networks (as in AES) and Feistel schemes (as in DES). In this section, you’ll
    look at these techniques after viewing an attack that works when all rounds are
    identical to each other.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">A Block Cipher’s
    Rounds</samp>
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Computing a block cipher boils down to computing a sequence of rounds*.* In
    a block cipher, a round is a basic transformation that’s simple to specify and
    to implement and is iterated several times to form the block cipher’s algorithm.
    This construction, consisting of a small component repeated many times, is simpler
    to implement and to analyze than a construction that consists of a single huge
    algorithm.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: For example, a block cipher with three rounds encrypts a plaintext by computing
    *C* = **R**[3](**R**[2](**R**[1](*P*))), where the rounds are **R**[1], **R**[2],
    and **R**[3], and *P* is a plaintext. Each round should also have an inverse so
    it’s possible for a recipient to compute back to plaintext. Specifically, *P*
    = **iR**[1](**iR**[2](**iR**[3](*C*))), where **iR**[1] is the inverse of **R**[1],
    and so on.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The round functions—**R**[1], **R**[2], and so forth—are usually identical algorithms,
    but they are parameterized by a value we call the *round key*. Two round functions
    with two distinct round keys will behave differently and will therefore produce
    distinct outputs if fed with the same input.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: We derive round keys from the main key, *K*, using a *key schedule* algorithm.
    For example, **R**[1] takes the round key *K*[1], **R**[2] takes the round key
    *K*[2], and so on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Round keys should be different from each other in every round. For that matter,
    not all round keys should be equal to the key *K*; otherwise, all the rounds would
    be identical, and the block cipher would be less secure, as I’ll describe next.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Slide Attack</samp>
    <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">and Round Keys</samp>
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In a block cipher, no round should be identical to another round in order to
    avoid a *slide attack*. As [Figure 4-1](chapter4.xhtml#fig4-1) shows, slide attacks
    look for two plaintext/ciphertext pairs (*P*[1], *C*[1]) and (*P*[2], *C*[2]),
    where *P*[2] = **R**(*P*[1]) if **R** is the cipher’s round. When rounds are identical,
    the relation between the two plaintexts, *P*[2] = **R**(*P*[1]), implies the relation
    *C*[2] = **R**(*C*[1]) between their respective ciphertexts. [Figure 4-1](chapter4.xhtml#fig4-1)
    shows three rounds, but the relation *C*[2] = **R**(*C*[1]) will hold no matter
    the number of rounds, be it 3, 10, or 100\. The problem is that knowing the input
    and output of a single round often helps recover the key. (For details, read the
    1999 paper “Advanced Slide Attacks” by Alex Biryukov and David Wagner, available
    at *[https://<wbr>www<wbr>.iacr<wbr>.org<wbr>/archive<wbr>/eurocrypt2000<wbr>/1807<wbr>/18070595<wbr>-new<wbr>.pdf](https://www.iacr.org/archive/eurocrypt2000/1807/18070595-new.pdf)*.)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-1.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-1: The principle of
    the slide attack against block ciphers with identical rounds</samp>'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Using different round keys as parameters ensures that the rounds will behave
    differently and thus foil slide attacks.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*One potential byproduct and benefit of using round keys is protection against*
    side-channel attacks*, or attacks that exploit information leaked from the implementation
    of a cipher (for example, electromagnetic emanations). If the transformation from
    the main key,* K*, to a round key,* K[i]*, isn’t invertible, then if an attacker
    finds* K[i]*, they can’t use that key to find* K*. Unfortunately, few block ciphers
    have a one-way key schedule. The key schedule of AES allows attackers to compute*
    K *from any round key,* K[i]*, for example.*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Substitution–Permutation
    Networks</samp>
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’ve read textbooks about cryptography, you’ve likely come across confusion
    and diffusion. *Confusion* means that the input (plaintext and encryption key)
    undergoes complex transformations, and *diffusion* means that these transformations
    depend equally on all bits of the input. At a high level, confusion is about depth,
    whereas diffusion is about breadth. In the design of a block cipher, confusion
    and diffusion take the form of substitution and permutation operations, which
    we combine within substitution–permutation networks (SPNs).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Substitution often appears in the form of *S-boxes*, or *substitution boxes*,
    which are small lookup tables that transform chunks of 4 or 8 bits. For example,
    the first of the eight S-boxes of the block cipher Serpent is composed of the
    16 elements (3 8 f 1 a 6 5 b e d 4 2 7 0 9 c), where each element represents a
    4-bit nibble. This particular S-box maps the 4-bit nibble 0000 to 3 (0011), the
    4-bit nibble 0101 (5 in decimal) to 6 (0110), and so on.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*S-boxes must be carefully chosen to be cryptographically strong: they should
    be as nonlinear as possible (inputs and outputs should be related with complex
    equations) and have no statistical bias (meaning, for example, that flipping an
    input bit should potentially affect any of the output bits).*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*S盒必须小心选择以确保其密码学强度：它们应尽可能非线性（输入和输出应通过复杂的方程式相关联），且没有统计偏差（例如，翻转一个输入位应该可能影响输出位的任何位）。*'
- en: 'The permutation in a substitution–permutation network can be as simple as changing
    the order of the bits, which is easy to implement but doesn’t mix up the bits
    very much. Instead of a reordering of the bits, some ciphers use basic linear
    algebra and matrix multiplications to mix up the bits: they perform a series of
    multiplication operations with fixed values (the matrix’s coefficients) and then
    add the results. Such operations can quickly create dependencies between all the
    bits within a cipher and thus ensure strong diffusion. For example, the block
    cipher FOX transforms a 4-byte vector (*a*, *b*, *c*, *d*) to (*a*′, *b*′, *c*′,
    *d*′), which we define as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 替换–置换网络中的置换可以像改变位的顺序一样简单，这种方法容易实现，但并没有很好地混合位。某些密码算法使用基本的线性代数和矩阵乘法来混合位：它们执行一系列固定值（矩阵系数）的乘法操作，然后将结果相加。这种操作可以迅速在所有位之间创建依赖关系，从而确保强的扩散性。例如，块加密算法FOX将一个4字节向量
    (*a*, *b*, *c*, *d*) 转换为 (*a*′, *b*′, *c*′, *d*′)，我们定义如下：
- en: '![](../images/pg66-1.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/pg66-1.jpg)'
- en: In these equations, we interpret the numbers 2 and 253 as binary polynomials
    rather than integers; hence, we define additions and multiplications a bit differently
    than what we’re used to. For example, instead of having 2 + 2 = 4, we have 2 +
    2 = 0\. Regardless, each byte in the initial state affects all 4 bytes in the
    final state.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些方程中，我们将2和253解释为二进制多项式，而不是整数；因此，我们对加法和乘法的定义与我们习惯的略有不同。例如，我们不是有 2 + 2 = 4，而是
    2 + 2 = 0。无论如何，初始状态中的每个字节都会影响最终状态中的所有4个字节。
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Feistel Schemes</samp>
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">费斯特尔方案</samp>
- en: 'In the 1970s, IBM engineer Horst Feistel designed a block cipher, Lucifer,
    that works as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在1970年代，IBM工程师霍斯特·费斯特尔设计了一种块加密算法Lucifer，其工作原理如下：
- en: 1.  Split the 64-bit block into two 32-bit halves, *L* and *R*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  将64位块拆分为两个32位的部分 *L* 和 *R*。
- en: 2.  Set *L* to *L* ⊕ **F**(*R*), where **F** is a substitution–permutation round.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  将 *L* 设置为 *L* ⊕ **F**(*R*)，其中 **F** 是一个替换–置换轮。
- en: 3.  Swap the values of *L* and *R*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  交换 *L* 和 *R* 的值。
- en: 4.  Go to step 2 and repeat 15 times.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  返回第2步并重复15次。
- en: 5.  Merge *L* and *R* into the 64-bit output block.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 5.  将 *L* 和 *R* 合并为64位输出块。
- en: This construction is a *Feistel scheme*, as [Figure 4-2](chapter4.xhtml#fig4-2)
    shows. The left side is the scheme as just described; the right side is a functionally
    equivalent representation where, instead of swapping *L* and *R*, rounds alternate
    the operations *L* = *L* ⊕ **F**(*R*) and *R* = *R* ⊕ **F**(*L*).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构是一个*费斯特尔方案*，如[图4-2](chapter4.xhtml#fig4-2)所示。左侧是前面描述的方案；右侧是一个功能等效的表示形式，其中，轮次交替执行
    *L* = *L* ⊕ **F**(*R*) 和 *R* = *R* ⊕ **F**(*L*) 的操作，而不是交换 *L* 和 *R*。
- en: '![](../images/fig4-2.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig4-2.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-2: The Feistel scheme
    block cipher construction in two equivalent forms</samp>'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图4-2：费斯特尔方案块加密结构的两种等效形式</samp>
- en: I’ve omitted the keys from [Figure 4-2](chapter4.xhtml#fig4-2) to simplify the
    diagrams, but note that the first **F** takes a round key, *K*[1], and the second
    **F** takes another round key, *K*[2]. In DES, the **F** functions take a 48-bit
    round key, which it derives from the 56-bit key, *K*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我已省略[图4-2](chapter4.xhtml#fig4-2)中的密钥，以简化图示，但请注意，第一个 **F** 使用一个轮密钥 *K*[1]，第二个
    **F** 使用另一个轮密钥 *K*[2]。在DES中，**F**函数使用一个48位的轮密钥，它从56位密钥 *K* 中推导出来。
- en: In a Feistel scheme, the **F** function can be either a pseudorandom permutation
    (PRP) or a pseudorandom function (PRF). A PRP yields distinct outputs for any
    two distinct inputs, whereas a PRF will have values *X* and *Y* for which **F**(*X*)
    = **F**(*Y*). But in a Feistel scheme, that difference doesn’t matter as long
    as **F** is cryptographically strong.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在费斯特尔方案中，**F**函数可以是伪随机置换（PRP）或伪随机函数（PRF）。PRP对于任何两个不同的输入都会产生不同的输出，而PRF则可能有 *X*
    和 *Y* 的值，使得 **F**(*X*) = **F**(*Y*)。但是在费斯特尔方案中，这种差异并不重要，只要 **F** 是密码学上强的。
- en: How many rounds should there be in a Feistel scheme? Well, DES performs 16 rounds,
    whereas GOST 28147-89 performs 32 rounds. If the **F** function is as strong as
    possible, four rounds are sufficient in theory, but real ciphers use more rounds
    to defend against potential weaknesses in **F**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在费斯特尔结构中应该进行多少轮？嗯，DES执行16轮，而GOST 28147-89执行32轮。如果**F**函数尽可能强大，从理论上讲，四轮就足够了，但现实中的加密算法使用更多轮来防御**F**中的潜在弱点。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Advanced Encryption Standard</samp>
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">高级加密标准</samp>
- en: AES is the most-used cipher in the world. Prior to the adoption of AES, the
    standard cipher in use was DES, with its ridiculous 56-bit security, as well as
    the upgraded version of DES known as Triple DES, or 3DES. Although 3DES provides
    a higher level of security (112-bit security), it’s inefficient because the key
    needs to be 168 bits long to get 112-bit security, and it’s slow in software (DES
    was created to be fast in integrated circuits, not on mainstream CPUs). AES fixes
    both issues.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: AES是世界上使用最广泛的密码算法。在AES被采用之前，使用的标准密码是DES，它的56位安全性极其低，还有升级版的DES，即Triple DES或3DES。尽管3DES提供了更高的安全级别（112位安全性），但它的效率较低，因为为了获得112位安全性，密钥需要达到168位，并且它在软件中的速度较慢（DES的设计初衷是为了在集成电路中运行快速，而不是在主流CPU上）。AES解决了这两个问题。
- en: NIST standardized AES in 2000 as a replacement for DES, at which point it became
    the world’s de facto encryption standard. Most commercial encryption products
    today support AES, and the NSA has approved it for protecting top-secret information.
    (Some countries do prefer to use their own ciphers, largely because they don’t
    want to use a US standard, but AES is actually more Belgian than it is American.)
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: NIST在2000年将AES标准化为DES的替代方案，从那时起，它成为了世界上事实上的加密标准。今天，大多数商业加密产品都支持AES，NSA也批准了它用于保护最高机密信息。（一些国家确实更倾向于使用自己的密码算法，主要是因为它们不想使用美国的标准，但AES实际上比美国更具比利时特色。）
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: <samp class="SANS_Dogma_OT_Bold_B_15">注意</samp>
- en: '*AES went by the name* Rijndael *(a portmanteau for its inventors’ names, Rijmen
    and Daemen, pronounced like “rain-dull”) when it was one of the 15 candidates
    in the AES competition, the process held by NIST from 1997 to 2000 to specify
    “an unclassified, publicly disclosed encryption algorithm capable of protecting
    sensitive government information well into the next century,” as stated in the
    1997 announcement of the competition in the* Federal Register. *The AES competition
    was a kind of “Got Talent” competition for cryptographers, where anyone could
    participate by submitting a cipher or breaking other contestants’ ciphers.*'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*AES在成为AES竞赛中的15个候选算法之一时，曾以*Rijndael*（这是其发明者Rijmen和Daemen的名字合成词，发音类似于“rain-dull”）命名。该竞赛由NIST于1997年至2000年举行，目的是指定“一个未分类、公开披露的加密算法，能够有效保护敏感政府信息，直到下个世纪”，正如1997年在*《联邦公报》*中发布的竞赛公告所述。*AES竞赛就像是密码学家的“才艺大赛”，任何人都可以通过提交密码或破解其他参赛者的密码来参与。*'
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES Internals</samp>
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES内部结构</samp>
- en: AES processes blocks of 128 bits using a secret key of 128, 192, or 256 bits,
    with the 128-bit key being the most common because it makes encryption slightly
    faster and because the difference between 128- and 256-bit security is meaningless
    for most applications.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: AES处理128位的块，使用128位、192位或256位的秘密密钥，其中128位密钥最为常见，因为它使加密稍微更快，并且对于大多数应用来说，128位和256位安全性的差异并不重要。
- en: Whereas some ciphers work with individual bits or 64-bit words, AES manipulates
    *bytes*. It views a 16-byte plaintext as a two-dimensional array of bytes (*s*
    = *s*[0], *s*[1], . . . , *s*[15]), as [Figure 4-3](chapter4.xhtml#fig4-3) illustrates.
    (We use the letter *s* because this array is the *internal state*, or just *state*.)
    AES transforms the bytes, columns, and rows of this array to produce a final value
    that is the ciphertext.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些密码算法处理单个比特或64位字不同，AES处理的是*字节*。它将16字节的明文视为一个二维字节数组（*s* = *s*[0]，*s*[1]，…，*s*[15]），如[图4-3](chapter4.xhtml#fig4-3)所示。（我们使用字母*s*是因为这个数组是*内部状态*，简称*状态*。）AES通过转换这个数组的字节、列和行来生成最终的密文。
- en: '![](../images/fig4-3.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/fig4-3.jpg)'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-3: The internal state
    of AES as a 4×4 array of 16 bytes</samp>'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Book_Oblique_I_11">图4-3：AES的内部状态，作为一个4×4的16字节数组</samp>
- en: To transform its state, AES uses an SPN structure as in [Figure 4-4](chapter4.xhtml#fig4-4),
    with 10 rounds for 128-bit keys, 12 for 192-bit keys, and 14 for 256-bit keys.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-4.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-4: The internal operations
    of AES</samp>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-4](chapter4.xhtml#fig4-4) shows the four building blocks of an AES
    round (note that all but the last round are a sequence of SubBytes, ShiftRows,
    MixColumns, and AddRoundKey):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '**AddRoundKey **XORs a round key to the internal state.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '**SubBytes **Replaces each byte (*s*[0], *s*[1] . . . , *s*[15]) with another
    byte according to an S-box. In this example, the S-box is a lookup table of 256
    elements.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '**ShiftRows **Shifts the *i*th row of *i* positions, for *i* ranging from 0
    to 3 (see [Figure 4-5](chapter4.xhtml#fig4-5)).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '**MixColumns **Applies the same linear transformation to each of the four columns
    of the state (that is, each group of cells with the same shade of gray, as on
    the left side of [Figure 4-5](chapter4.xhtml#fig4-5)).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-5.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-5: ShiftRows rotates
    bytes within each row of the internal state.</samp>'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Remember that in an SPN, the *S* stands for substitution and the *P* for permutation.
    Here, the substitution layer is SubBytes, and the permutation layer is the combination
    of ShiftRows and MixColumns.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: The key schedule function KeyExpansion, as [Figure 4-4](chapter4.xhtml#fig4-4)
    shows, is the AES key schedule algorithm. This expansion creates 11 round keys
    (*K*[0], *K*[1], . . . , *K*[10]) of 16 bytes each from the 16-byte key, using
    the same S-box as SubBytes and a combination of XORs. One important property of
    KeyExpansion is that given any round key, *K*i, an attacker can determine all
    other round keys as well as the main key, *K*, by reversing the algorithm. The
    ability to get the key from any round key reduces the cipher’s resistance to side-channel
    attacks, where an attacker may easily recover a round key.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Without these operations, AES would be totally insecure. Each operation contributes
    to AES’s security in a specific way:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Without KeyExpansion, all rounds would use the same key, *K*, and AES would
    be vulnerable to slide attacks.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without AddRoundKey, encryption wouldn’t depend on the key; hence, anyone could
    decrypt any ciphertext without the key.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SubBytes brings nonlinear operations, which add cryptographic strength. Without
    it, AES would just be a large system of linear equations that can be solved using
    high school algebra (namely, Gaussian elimination).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without ShiftRows, changes in a given column would never affect the other columns,
    meaning you could break AES by building four 2^(32)-element codebooks for each
    column. (Remember that in a secure block cipher, flipping a bit in the input should
    affect all the output bits.)
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Without MixColumns, changes in a byte wouldn’t affect any other bytes of the
    state. A chosen-plaintext attacker could then decrypt any ciphertext after storing
    16 lookup tables of 256 bytes each that hold the encrypted values of each possible
    value of a byte.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice in [Figure 4-4](chapter4.xhtml#fig4-4) that the last round of AES doesn’t
    include the MixColumns operation. That operation is omitted to save useless computation:
    because MixColumns is linear, you could cancel its effect in the very last round
    by combining bits in a way that doesn’t depend on their value or the key. However,
    we can’t invert SubBytes without the state’s value being known prior to AddRoundKey.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'To decrypt a ciphertext, AES unwinds each operation by taking its inverse function:
    the inverse lookup table of SubBytes reverses the SubBytes transformation, ShiftRow
    shifts in the opposite direction, MixColumns’s inverse is applied (as in the matrix
    inverse of the matrix encoding its operation), and AddRoundKey’s XOR is unchanged
    because the inverse of an XOR is another XOR.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES in Action</samp>
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As an exercise, you can use Python’s <samp class="SANS_TheSansMonoCd_W5Regular_11">cryptography</samp>
    library to encrypt and decrypt a block of data with AES, as in [Listing 4-1](chapter4.xhtml#Lis4-1).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-1: AES encryption
    and decryption of a block in Python</samp>'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this script produces something like the following output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You’ll get different results because the key is randomized at every new execution.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How to Implement AES</samp>
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Real AES software works differently than the algorithm in [Figure 4-4](chapter4.xhtml#fig4-4).
    You won’t find production-level AES code calling a <samp class="SANS_TheSansMonoCd_W5Regular_11">SubBytes()</samp>
    function, then a <samp class="SANS_TheSansMonoCd_W5Regular_11">ShiftRows()</samp>
    function, and then a <samp class="SANS_TheSansMonoCd_W5Regular_11">MixColumns()</samp>
    function because that would be inefficient. Instead, fast AES software uses table-based
    implementations and native instructions.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Table-Based Implementations</samp>
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Table-based implementations of AES replace the sequence SubBytes-ShiftRows-MixColumns
    with a combination of XORs and lookups in tables hardcoded into the program and
    loaded in memory at execution time. This is possible because MixColumns is equivalent
    to XORing four 32-bit values, where each depends on a single byte from the state
    and on SubBytes. Thus, you can build four tables with 256 entries each, one for
    each byte value, and implement the sequence SubBytes-MixColumns by looking up
    four 32-bit values and XORing them together.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: For example, the table-based C implementation in the OpenSSL toolkit looks like
    [Listing 4-2](chapter4.xhtml#Lis4-2).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-2: An excerpt of
    the table-based C implementation of AES in OpenSSL</samp>'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: A basic table-based implementation of AES encryption needs four 4KB’s worth
    of tables because each table stores 256 32-bit values, which occupy 256 × 32 =
    8,192 bits, or 1KB. Decryption requires another four tables and thus 4KB more.
    But there are tricks to reduce the storage from 4KB to 1, or even less.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Alas, table-based implementations are vulnerable to *cache-timing attacks*,
    which exploit timing variations when a program reads or writes elements in cache
    memory. Access time varies depending on the relative position in cache memory
    of the accessed elements. Timings thus leak information about the accessed element,
    which in turn leaks information on the secrets involved.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Cache-timing attacks are difficult to avoid. One obvious solution would be
    to ditch lookup tables altogether by writing a program whose execution time doesn’t
    depend on its inputs, but that’s almost impossible to do and still retain the
    same speed, so chip manufacturers have opted for a radical solution: instead of
    relying on potentially vulnerable software, they rely on *hardware*.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Native Instructions</samp>
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'AES native instructions (AES-NI) solve the problem of cache-timing attacks
    on AES software implementations. To understand how AES-NI works, think about the
    way software runs on hardware: to run a program, a microprocessor translates binary
    code into a series of instructions that integrated circuit components execute.
    For example, a <samp class="SANS_TheSansMonoCd_W5Regular_11">MUL</samp> assembly
    instruction between two 32-bit values will activate the transistors implementing
    a 32-bit multiplier in the microprocessor. To implement a crypto algorithm, we
    usually express a combination of basic operations—additions, multiplications,
    XORs, and so on—and the microprocessor activates its adders, multipliers, and
    XOR circuits in the prescribed order.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: AES native instructions take this to a whole new level by providing developers
    with dedicated assembly instructions that compute AES. Instead of coding an AES
    round as a sequence of assembly instructions, when using AES-NI, you just call
    the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">AESENC</samp>, and
    the chip computes the round for you. Native instructions allow you to tell the
    processor to run an AES round instead of requiring you to program rounds as a
    combination of basic operations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: A typical assembly implementation of AES using native instructions looks like
    [Listing 4-3](chapter4.xhtml#Lis4-3).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-3: An implementation
    of AES-128 using AES native instructions</samp>'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: This code encrypts the 128-bit plaintext initially in the register <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm0</samp>,
    assuming that registers <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm5</samp>
    to <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm15</samp> hold the precomputed
    round keys, with each instruction writing its result into <samp class="SANS_TheSansMonoCd_W5Regular_11">xmm0</samp>.
    The initial <samp class="SANS_TheSansMonoCd_W5Regular_11">PXOR</samp> instruction
    XORs the first round key prior to computing the first round, and the final <samp
    class="SANS_TheSansMonoCd_W5Regular_11">AESENCLAST</samp> instruction performs
    the last round slightly differently from the others (MixColumns is omitted).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-115
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-116
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*AES is about 10 times faster on platforms that implement native instructions,
    which, as I write this, include virtually all laptop, desktop, and server microprocessors,
    as well as most mobile phones and tablets. Although Intel originally proposed
    AES instructions in 2008, they’re also available in AMD processors, and most architectures
    other than x86 also have equivalent instructions implementing AES in hardware.
    For example, the Armv8 instruction set contains the instructions <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESSE*</samp>
    (which calculates SubBytes and ShiftRows) and <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESMS*</samp>
    (which calculates MixColumns).*'
  id: totrans-117
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*On Intel’s Ice Lake microarchitecture, the <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESENC*</samp>
    instruction has a latency of three cycles with a reciprocal throughput of half
    a cycle, meaning that a call to <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESENC*</samp>
    takes three cycles to complete, and we can make two new calls to the instruction
    in each cycle. In fact, the internal structure of the micro-operations performing
    the <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESENC*</samp> operation means
    that a new instruction computation can start before the previous one has finished.
    What’s more, the Ice Lake architecture uses a vectorized version of AES instructions,
    enabling several to be initiated at the same time. For more details, see the article
    “Making AES Great Again” by Nir Drucker, Shay Gueron, and Vlad Krasnov, available
    at* [https://<wbr>eprint<wbr>.iacr<wbr>.org<wbr>/2018<wbr>/392](https://eprint.iacr.org/2018/392)*.*'
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*To encrypt a series of blocks one after the other, it takes 3 × 10 = 30 cycles
    to complete the 10 rounds, or 30 / 16 = 1.875 cycles per byte. At a frequency
    of 2 GHz (2 × 10**⁹* *cycles per second), this gives a theoretical maximum throughput
    of around 1GBps. If you can process blocks in parallel, then you don’t need one
    complete <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESENC*</samp> call before
    starting another. In this case, you can make two <samp class="SANS_TheSansMonoCd_W5Regular_11">*AESENC*</samp>
    calls per cycle and obtain two results per cycle, offering a much higher theoretical
    throughput (up to more than 10GBps, at 2 GHz), depending on the data size and
    mode of operation.*'
  id: totrans-121
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">AES Security</samp>
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: AES is as secure as a block cipher can be, and it will never be broken. Fundamentally,
    AES is secure because all output bits depend on all input bits in some complex,
    pseudorandom way. To achieve this, the designers of AES carefully chose each component
    for a particular reason—MixColumns for its maximal diffusion properties and SubBytes
    for its optimal nonlinearity. This composition protects AES against whole classes
    of cryptanalytic attacks.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'But there’s no proof that AES is immune to all possible attacks. For one thing,
    we don’t know what all possible attacks are, and we don’t always know how to prove
    that a cipher is secure against a given attack. The only way to really gain confidence
    in the security of AES is to crowdsource attacks: have many skilled people attempt
    to break AES and, ideally, fail to do so.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: After more than 15 years and hundreds of research publications, we’ve only scratched
    the surface of the theoretical security of AES. In 2011, cryptanalysts found a
    way to recover an AES-128 key by performing about 2^(126) operations instead of
    2^(128), a speedup of a factor of 4\. But this “attack” requires a high number
    of plaintext–ciphertext pairs—about 2^(88) bits’ worth. It’s a nice finding but
    not one you need to worry about.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: You should care about a million things when implementing and deploying crypto,
    but AES security is not one of them. The biggest threat to block ciphers isn’t
    in their core algorithms but in their modes of operation. If you’ve chosen an
    incorrect mode or misused the right one, even a strong cipher like AES won’t save
    you.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Modes of Operation</samp>
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [Chapter 1](chapter1.xhtml), I explained how encryption schemes combine
    a permutation with a mode of operation to handle messages of any length. In this
    section, I’ll cover the main modes of operations that block ciphers use, their
    security and functional properties, and how (not) to use them. I’ll begin with
    the dumbest one: electronic codebook.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Electronic Codebook
    Mode</samp>
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The simplest of the block cipher encryption modes is electronic codebook (ECB),
    which is barely a mode of operation at all. ECB takes plaintext blocks *P*[1],
    *P*[2], . . . , *P*N and processes each independently by computing *C*[1] = **E**(*K*,
    *P*[1]), *C*[2] = **E**(*K*, *P*[2]), and so on, as [Figure 4-6](chapter4.xhtml#fig4-6)
    shows. It’s a simple operation but also an insecure one—ECB is insecure, and you
    shouldn’t use it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-6.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-6: ECB mode</samp>'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Marsh Ray, a cryptographer at Microsoft, once said, “Everybody knows ECB mode
    is bad because we can see the penguin.” He was referring to a famous illustration
    of ECB’s insecurity that uses an image of Linux’s mascot, Tux, as in [Figure 4-7](chapter4.xhtml#fig4-7).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-7.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-7: The original image
    (left) and the ECB-encrypted image (right)</samp>'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The original image of Tux is on the left, and the ECB-encrypted image that uses
    AES (though the underlying cipher doesn’t matter) is on the right. It’s easy to
    see the penguin’s shape in the encrypted version because ECB encrypted all the
    blocks of one shade of gray in the original image to the same new shade of gray
    in the new image; in other words, ECB encryption gives you the same image with
    different colors.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: The Python program in [Listing 4-4](chapter4.xhtml#Lis4-4) also shows ECB’s
    insecurity. It picks a pseudorandom key and encrypts a 32-byte message <samp class="SANS_TheSansMonoCd_W5Regular_11">p</samp>
    containing two blocks of null bytes. Notice that encryption yields two identical
    blocks and that repeating encryption with the same key and the same plaintext
    yields the same two blocks again.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-4: Using AES in ECB
    mode in Python</samp>'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this script gives ciphertext blocks like this example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When using the ECB mode, identical ciphertext blocks reveal identical plaintext
    blocks to an attacker, whether those are blocks within a single ciphertext or
    across different ciphertexts. This shows that block ciphers in ECB mode aren’t
    semantically secure.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with ECB is that it takes only complete blocks of data, so if
    blocks were 16 bytes, as in AES, you could encrypt only chunks of 16 bytes, 32
    bytes, 48 bytes, or any other multiple of 16 bytes. There are a few ways to deal
    with this, as you’ll see with the next mode, CBC. (I won’t tell you how these
    tricks work with ECB because you shouldn’t use ECB in the first place.)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Cipher Block Chaining
    Mode</samp>
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Cipher block chaining (CBC) is like ECB but with a small twist that makes a
    big difference: instead of encrypting the *i*th block, *P*i, as *C*i = **E**(*K*,
    *P*i), CBC sets *C*i = **E**(*K*, *P*i ⊕ *C*i [− 1]), where *C*i [− 1] is the
    previous ciphertext block—thereby *chaining* the blocks *C*i [− 1] and *C*i. When
    encrypting the first block, *P*[1], there is no previous ciphertext block to use,
    so CBC takes a random initial value (IV), as [Figure 4-8](chapter4.xhtml#fig4-8)
    illustrates.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-8.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-8: CBC mode</samp>'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: CBC mode makes each ciphertext block dependent on all the previous blocks and
    ensures that identical plaintext blocks won’t be identical ciphertext blocks.
    The random initial value guarantees that two identical plaintexts will encrypt
    to distinct ciphertexts when calling the cipher twice with two distinct initial
    values.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-5](chapter4.xhtml#Lis4-5) illustrates these two benefits. This program
    takes an all-zero, 32-byte message (like the one in [Listing 4-4](chapter4.xhtml#Lis4-4)),
    encrypts it twice with CBC, and shows the two ciphertexts. The bolded line <samp
    class="SANS_TheSansMonoCd_W5Regular_11">iv = urandom(BLOCK _SIZE)</samp> picks
    a new random IV for each new encryption.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-5: Using AES in CBC
    mode</samp>'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'The two plaintexts are the same (two all-zero blocks), but the encrypted blocks
    should be distinct, as in this example execution:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Alas, we often use CBC with a constant IV instead of a random one, which exposes
    identical plaintexts and plaintexts that start with identical blocks. For example,
    say CBC encrypts the two-block plaintext *P*[1] || *P*[2] to the two-block ciphertext
    *C*[1] || *C*[2]. If CBC encrypts *P*[1] || *P*[2]′ with the same IV, where *P*[2]′
    is some block distinct from *P*[2], then the ciphertext will look like *C*[1]
    || *C*[2]′, with *C*[2]′ different from *C*[2] but with the same first block *C*[1].
    Thus, an attacker can guess that the first block is the same for both plaintexts,
    even though they see only the ciphertexts.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In CBC mode, decryption needs to know the IV used to encrypt, so the IV is
    sent along with the ciphertext, in the clear.*'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: With CBC, decryption can be much faster than encryption due to parallelism.
    While encryption of a new block, *P*i, needs to wait for the previous block, *C*i
    [− 1], decryption of a block computes *P*i = **D**(*K*, *C*i) ⊕ *C*i [− 1], where
    there’s no need for the previous plaintext block, *P*i [− 1]. This means you can
    decrypt all blocks in parallel simultaneously, as long as you know the previous
    ciphertext block, which you usually will.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Message Encryption
    in CBC Mode</samp>
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s circle back to the block termination issue and look at how to process
    a plaintext whose length is not a multiple of the block length. For example, how
    would you encrypt an 18-byte plaintext with AES-CBC when blocks are 16 bytes?
    What do you do with the 2 bytes left? You’ll look at two widely used techniques
    to deal with this problem. The first one, padding, makes the ciphertext a bit
    longer than the plaintext, while the second one, *ciphertext stealing*, produces
    a ciphertext of the same length as the plaintext.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Message Padding</samp>
  id: totrans-160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Padding is a technique that allows you to encrypt a message of any length, even
    one smaller than a single block. The PKCS#7 standard and RFC 5652 specify padding
    for block ciphers, which we use almost everywhere we use CBC.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'We use padding to expand a message to fill a complete block by adding extra
    bytes to the plaintext. Here are the rules for padding 16-byte blocks:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: If there’s 1 byte left—for example, if the plaintext is 1 byte, 17 bytes, or
    33 bytes long—pad the message with 15 bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">0f</samp>
    (15 in decimal).
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are 2 bytes left, pad the message with 14 bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">0e</samp>
    (14 in decimal).
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are 3 bytes left, pad the message with 13 bytes <samp class="SANS_TheSansMonoCd_W5Regular_11">0d</samp>
    (13 in decimal).
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are 15 plaintext bytes and a single byte missing to fill a block, padding
    adds a single <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> byte. If
    the plaintext is already a multiple of 16, the block length, add 16 bytes <samp
    class="SANS_TheSansMonoCd_W5Regular_11">10</samp> (16 in decimal). The trick generalizes
    to any block length up to 255 bytes (for larger blocks, a byte is too small to
    encode values greater than 255).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'Decryption of a padded message works like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Decrypt all the blocks as with unpadded CBC.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '2.  Make sure that the last bytes of the last block conform to the padding
    rule: that they finish with at least one <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    byte, at least two <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp> bytes,
    or at least three <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp> bytes,
    and so on. If the padding isn’t valid—for example, if the last bytes are <samp
    class="SANS_TheSansMonoCd_W5Regular_11">01 02 03</samp>—the message is rejected.
    Otherwise, decryption strips the padding bytes and returns the plaintext bytes
    left.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: One downside of padding is that it makes ciphertext longer by at least 1 byte
    and at most a block.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">Ciphertext Stealing</samp>
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'Ciphertext stealing is another trick we use to encrypt a message whose length
    isn’t a multiple of the block size. Ciphertext stealing is more complex and less
    popular than padding, but it offers a few benefits:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Plaintexts can be of any *bit* length, not just bytes. You can, for example,
    encrypt a message of 131 bits.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ciphertexts are exactly the same length as plaintexts.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ciphertext stealing is not vulnerable to padding oracle attacks, powerful attacks
    that sometimes work against CBC with padding (as you’ll see in “Padding Oracle
    Attacks” on [page 83](#sec26)).
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In CBC mode, ciphertext stealing extends the last incomplete plaintext block
    with bits from the previous ciphertext block and then encrypts the resulting block.
    The last, incomplete ciphertext block is made up of the first bits from the previous
    ciphertext block—that is, the bits that haven’t been appended to the last plaintext
    block.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 4-9](chapter4.xhtml#fig4-9), we have three blocks, where the last
    block, *P*[3], is incomplete (represented by a zero). If *P*[3] is 3 bytes, we
    XOR it with the last 12 bits from the previous ciphertext block **E**(*K*, *P*[2])
    and return the encrypted result as *C*[2]. The last ciphertext block, *C*[3],
    then consists of the first 4 bytes of **E**(*K*, *P*[2]). Decryption is simply
    the inverse of this operation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-9.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-9: Ciphertext stealing
    for CBC-mode encryption</samp>'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: There aren’t any major problems with ciphertext stealing, but it’s inelegant
    and hard to get right, especially when NIST’s standard specifies three different
    ways to implement it (see Special Publication 800-38A).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Counter Mode</samp>
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To avoid the troubles and retain the benefits of ciphertext stealing, use counter
    mode (CTR). CTR is hardly a block cipher mode: it turns a block cipher into a
    stream cipher that just takes bits in and spits bits out and doesn’t embarrass
    itself with the notion of blocks. (I’ll discuss stream ciphers in detail in [Chapter
    5](chapter5.xhtml).)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: In CTR mode (see [Figure 4-10](chapter4.xhtml#fig4-10)), the block cipher algorithm
    won’t transform plaintext data. Instead, it encrypts blocks composed of a counter
    and a nonce. A *counter* is an integer that is incremented for each block. No
    two blocks should use the same counter within a message, but different messages
    can use the same sequence of counter values (1, 2, 3, . . .). A *nonce* is a number
    we use only once. It’s the same for all blocks in a single message, but no two
    messages should use the same nonce.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-10.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-10: CTR mode</samp>'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-10](chapter4.xhtml#fig4-10) shows that in CTR mode, encryption XORs
    the plaintext and the stream taken from “encrypting” the nonce, *N*, and counter,
    *Ctr*. Decryption is the same, so you need only the encryption algorithm for both
    encryption and decryption. The Python script in [Listing 4-6](chapter4.xhtml#Lis4-6)
    gives you a hands-on example.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 4-6: Using AES in CTR
    mode</samp>'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'The example execution encrypts a 4-byte plaintext and gets a 4-byte ciphertext.
    It then decrypts that ciphertext using the encryption function:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As with the initial value in CBC, the encrypter supplies CTR’s nonce and sends
    it with the ciphertext in the clear. But unlike CBC’s initial value, CTR’s nonce
    doesn’t need to be random; it simply needs to be unique. A nonce should be unique
    for the same reason that we shouldn’t reuse a one-time pad: when calling the pseudorandom
    stream, *S*, if you encrypt *P*[1] to *C*[1] = *P*[1] ⊕ *S* and *P*[2] to *C*[2]
    = *P*[2] ⊕ *S* using the same nonce, then *C*[1] ⊕ *C*[2] reveals *P*[1] ⊕ *P*[2].'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: A random nonce will do the trick only if it’s long enough; for example, if the
    nonce is *n* bits, chances are that after 2*^n*^(/2) encryptions and as many nonces,
    you’ll run into duplicates. Sixty-four bits are insufficient for a random nonce,
    since you can expect a repetition after approximately 2^(32) nonces, which is
    an unacceptably low number.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The counter is guaranteed unique if it’s incremented for every new plaintext,
    and if it’s long enough—for example, a 64-bit counter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: One particular benefit to CTR is that it can be faster than any other mode.
    Not only is it parallelizable, but you can also start encrypting even before knowing
    the message by picking a nonce and computing the stream that you’ll later XOR
    with the plaintext.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-195
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Depending on the CTR version we implement, we may either concatenate the nonce
    the API uses as an argument to a counter (as in [Figure 4-10](chapter4.xhtml#fig4-10))
    or directly consider a counter as wide as a block.*'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">How Things Can Go Wrong</samp>
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two must-know attacks on block ciphers: meet-in-the-middle attacks,
    a technique discovered in the 1970s but still used in many cryptanalytic attacks
    (not to be confused with man-in-the-middle attacks), and padding oracle attacks,
    a class of attacks discovered in 2002 by academic cryptographers, then mostly
    ignored, and finally rediscovered a decade later along with several vulnerable
    applications.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Meet-in-the-Middle
    Attacks</samp>
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The 3DES block cipher is an upgraded version of the 1970s standard DES that
    takes a key of 56 × 3 = 168 bits (an improvement on DES’s 56-bit key). But the
    security level of 3DES is 112 bits instead of 168 bits because of the *meet-in-the-middle
    (MitM)* attack.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 4-11](chapter4.xhtml#fig4-11) shows that 3DES encrypts a block using
    the DES encryption and decryption functions: first encryption with a key, *K*[1];
    then decryption with a key, *K*[2]; and finally encryption with another key, *K*[3].
    If *K*[1] = *K*[2], the first two calls cancel themselves out, and 3DES boils
    down to a single DES with key *K*[3]. 3DES does encrypt-decrypt-encrypt rather
    than encrypting thrice to allow systems to emulate DES when necessary using the
    new 3DES interface.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-11.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-11: The 3DES block
    cipher construction</samp>'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Why use triple DES and not just double DES—that is, why encrypt a plaintext
    *P* to **E**(*K*[2], **E**(*K*[1], *P*))? It turns out that the MitM attack makes
    double DES only as secure as single DES. [Figure 4-12](chapter4.xhtml#fig4-12)
    shows the MitM attack in action.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-12.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-12: The MitM attack</samp>'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'The MitM attack works as follows to attack double DES:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Say you have *P* and *C* = **E**(*K*[2], **E**(*K*[1], *P*)) with two unknown
    56-bit keys, *K*[1] and *K*[2]. (DES takes 56-bit keys, so double DES takes 112
    key bits in total.) You build a key-value table with 2^(56) entries of **E**(*K*[1],
    *P*), where **E** is the DES encryption function and *K*[1] is the value stored.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 2.  For all 2^(56) values of *K*[2], compute **D**(*K*[2], *C*) and check whether
    the resulting value appears in the table as an index (thus as a middle value,
    represented by a question mark in [Figure 4-12](chapter4.xhtml#fig4-12)).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: 3.  If you find a middle value as an index of the table, fetch the corresponding
    *K*[1] from the table and verify that the (*K*[1], *K*[2]) found is the right
    one by using other pairs of *P* and *C*. Encrypt *P* using *K*[1] and *K*[2] and
    then check that the ciphertext obtained is the given *C*.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'This method recovers *K*[1] and *K*[2] by performing about 2^(57) instead of
    2^(112) operations: step 1 encrypts 2^(56) blocks, and then step 2 decrypts at
    most 2^(56) blocks, for 2^(56) + 2^(56) = 2^(57) operations in total. You also
    need to store 2^(56) elements of 15 bytes each, or about 1 exabyte. That’s a lot,
    but there’s a trick that allows you to run the same attack with only negligible
    memory (as you’ll see in [Chapter 6](chapter6.xhtml)).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: You can apply the MitM attack to 3DES in almost the same way you would to double
    DES, except that the third stage will go through all 2^(112) values of *K*[2]
    and *K*[3]. The whole attack thus succeeds after performing about 2^(112) operations,
    meaning that 3DES gets only 112-bit security despite having 168 bits of key material.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Padding Oracle Attacks</samp>
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We conclude this chapter with one of the simplest and yet most devastating
    attacks of the 2000s: the padding oracle attack. Remember that padding fills the
    plaintext with extra bytes to fill a block. A plaintext of 111 bytes, for example,
    is a sequence of six 16-byte blocks followed by 15 bytes. In this case, forming
    a complete block padding adds a <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>
    byte. For a 110-byte plaintext, padding adds 2 <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp>
    bytes. For a 109-byte plaintext, it adds 3 <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp>
    bytes, and so on, up to the case where we add 16 <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    bytes, where the hexadecimal value <samp class="SANS_TheSansMonoCd_W5Regular_11">10</samp>
    is equal to 16.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: A *padding oracle* is a system that behaves differently depending on whether
    the padding in a CBC-encrypted ciphertext is valid. You can see it as a black
    box or an API that returns either a *success* or an *error* value. You can, for
    example, obtain a padding oracle in a service on a remote host that sends error
    messages when it receives malformed ciphertexts. Given such an oracle, padding
    oracle attacks record which inputs have a valid padding and which don’t and then
    exploit this information to decrypt chosen ciphertext values.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Say you want to decrypt a ciphertext block *C*[2]. I’ll call *X* the value you’re
    looking for, namely, **D**(*K*, *C*[2]), and *P*[2] the block obtained after decrypting
    in CBC mode (see [Figure 4-13](chapter4.xhtml#fig4-13)). If you pick a random
    block *C*[1] and send the two-block ciphertext *C*[1] || *C*[2] to the oracle,
    decryption will succeed only if *C*[1] ⊕ *X = P*[2] ends with valid padding—a
    single <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp> byte, two <samp
    class="SANS_TheSansMonoCd_W5Regular_11">02</samp> bytes, or three <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp>
    bytes, and so on.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig4-13.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 4-13: Padding oracle
    attacks recover</samp> <samp class="SANS_Futura_Std_Book_11">X</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">by
    choosing</samp> <samp class="SANS_Futura_Std_Book_11">C</samp><samp class="SANS_Futura_Std_Book_Oblique_I-SUB_11">1</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">and checking the validity of padding.</samp>'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this observation, padding oracle attacks on CBC encryption can decrypt
    a block *C*[2] like this (bytes are denoted in array notation: *C*[1][0] is *C*[1]’s
    first byte, *C*[1][1] its second byte, and so on up to *C*[1][15], *C*[1]’s last
    byte):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: 1.  Pick a random block *C*[1] and vary its last byte until the padding oracle
    accepts the ciphertext as valid. Usually, in a valid ciphertext, *C*[1][15] ⊕
    *X*[15] = <samp class="SANS_TheSansMonoCd_W5Regular_11">01</samp>, so you’ll find
    *X*[15] after trying around 128 values of *C*[1][15].
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 2.  Find the value *X*[14] by setting *C*[1][15] to *X*[15] ⊕ <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp>
    and searching for the *C*[1][14] that gives correct padding. When the oracle accepts
    the ciphertext as valid, it means you’ve found *C*[1][14] such that *C*[1][14]
    ⊕ *X*[14] = <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp>.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 3.  Repeat steps 1 and 2 for all 16 bytes.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The attack needs on average 128 queries to the oracle for each of the 16 bytes,
    which is about 2,000 queries in total. (Note that each query must use the same
    initial value.)
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_15">NOTE</samp>
  id: totrans-224
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*In practice, implementing a padding oracle attack is a bit more complicated
    than what I’ve described because you have to deal with wrong guesses at step 1\.
    A ciphertext may have valid padding not because* P2 *ends with a single <samp
    class="SANS_TheSansMonoCd_W5Regular_11">01</samp> but because it ends with two
    <samp class="SANS_TheSansMonoCd_W5Regular_11">02</samp> bytes or three <samp class="SANS_TheSansMonoCd_W5Regular_11">03</samp>
    bytes. You can manage this by testing the validity of ciphertexts where more bytes
    are modified.*'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Further Reading</samp>
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s a lot to say about block ciphers, be it in how algorithms work or in
    how they can be attacked. For instance, Feistel networks and SPNs aren’t the only
    ways to build a block cipher. The block ciphers IDEA and FOX use the Lai–Massey
    construction, and Threefish uses ARX networks, a combination of addition, word
    rotations, and XORs.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: There are also many more modes than ECB, CBC, and CTR. Some modes are folklore
    techniques that nobody uses, like CFB and OFB, while others are for specific applications,
    like XTS for tweakable encryption or GCM for authenticated encryption.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve discussed Rijndael, the AES winner, but there were 14 other algorithms
    in the race: CAST-256, CRYPTON, DEAL, DFC, E2, FROG, HPC, LOKI97, Magenta, MARS,
    RC6, SAFER+, Serpent, and Twofish. I recommend looking them up to see how they
    work, how they were designed, how they have been attacked, and how fast they are.
    It’s also worth checking out the NSA’s designs (Skipjack and, more recently, SIMON
    and SPECK) and more recent “lightweight” block ciphers such as GIFT, KATAN, PRESENT,
    or PRINCE.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
