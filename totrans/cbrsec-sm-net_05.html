<html><head></head><body>
<div id="sbo-rt-content"><section aria-labelledby="header0501" class="chapter" epub:type="chapter" id="ch05" role="doc-chapter">
<header id="header0501">
<h1 class="cn"><span aria-label="66" class="page" epub:type="pagebreak" id="p66" role="doc-pagebreak"/><span aria-label="67" class="page" epub:type="pagebreak" id="p67" role="doc-pagebreak"/><a class="xref" href="nsp-enoka501485-0007.xhtml#rch05">5</a></h1>
<h1 class="ct">Creating a Virtual Private Network</h1>
</header>
<figure class="figure">
<p class="fig"><img alt="Chapter opening icon" height="100" src="images/nsp-enoka501485-ct.jpg" width="100"/></p>
</figure>
<p class="pf"><span class="page" data-locator="p67"/>A <i>virtual private network (VPN)</i> is a means of providing privacy and security for communications over the public internet. If you don’t want a malicious third party to intercept your Google search traffic as it traverses the internet from your local laptop to Google’s servers, you should use a VPN to encrypt the traffic between the two endpoints. If you frequently transfer sensitive files or data, such as personally identifiable information or banking information, it’s wise to protect this information using encryption.</p>
<p>The other primary function of a VPN is to extend a private network, such as those in homes and offices, from one geographic location to another. A VPN creates a tunnel over the internet from one network to a second network. This means that if a user usually based in Australia <span aria-label="68" class="page" epub:type="pagebreak" id="p68" role="doc-pagebreak"/>is traveling in Europe, they could connect to their home network from Europe as if they were physically located in Australia. Conversely, if a user located in Australia wants to <i>appear</i> as if they’re physically located in Europe, they can place the VPN endpoint in Europe, usually via some third-party service.</p>
<p>This chapter outlines a method for creating a private VPN whose <i>exit node</i> (that is, the place where the VPN tunnel ends) is located somewhere outside of your local network, in a different geographic location somewhere in the world, to make your actual physical location private. We’ll discuss how to achieve this with OpenVPN or Wireguard.</p>
<section>
<h2 class="ah" id="ah0701"><a class="xref" href="nsp-enoka501485-0007.xhtml#rah0701">Drawbacks of Third-Party VPNs and Remote Access Services</a></h2>
<p class="paft">Although you could subscribe to a VPN service like NordVPN or ExpressVPN, operating your own VPN is beneficial because you control everything about it, including connection and traffic logging levels, as well as the cost of the service. Also, whereas third-party services provide some benefits, such as the possibility of using multiple exit nodes in different locations, they usually don’t offer the ability to connect into your own network remotely. One last challenge of using third-party VPN services is that they usually set a limit to the number of devices you can connect at a time. A privately managed VPN has no such limitation.</p>
<p>Recently, there’s been a boom in the number of applications designed to allow remote access to endpoints from the wider internet. This includes software and vendors such as Teamviewer and AnyDesk. Although these solutions are convenient and have a low barrier to entry, they increase the attack surface of your private network by opening up remote access from your computer to the internet, something you should rarely do, if ever. There have also been several well-known compromises of these solutions, indicating that they are vulnerable to attack. A VPN provides a much more secure solution.</p>
</section>
<section>
<h2 class="ah" id="ah0702"><a class="xref" href="nsp-enoka501485-0007.xhtml#rah0702">OpenVPN</a></h2>
<p class="paft"><i>OpenVPN</i> is one of the most common VPN solutions available. Because of its age and ubiquity, you can be confident in its security when compared to newer solutions, which have been less rigorously tested for bugs and vulnerabilities. OpenVPN comes built-in to a variety of networking hardware, which is beneficial because in a lot of cases your router can act as your VPN endpoint inside of your network (that is, the VPN server). This means your router can also act as a VPN client, connecting to a VPN server in the cloud, and then everything connected to the router on your internal network can send and receive traffic via your VPN tunnel. Encrypting your internet traffic in this way provides much greater privacy than using the internet without a VPN. Ideally, though, you’ll want more control over the VPN exit node <span aria-label="69" class="page" epub:type="pagebreak" id="p69" role="doc-pagebreak"/>than this allows; most routers use either a cut-down version of Linux or a proprietary operating system, so you’ll learn how to create a VPN server using Ubuntu for greater flexibility.</p>
</section>
<section>
<h2 class="ah" id="ah0703"><a class="xref" href="nsp-enoka501485-0007.xhtml#rah0703">EasyRSA</a></h2>
<p class="paft">EasyRSA is a command-line utility for creating and managing certificate authorities. To encrypt and protect traffic, OpenVPN requires a <i>certificate authority (CA)</i> to issue certificates. <i>Digital certificates</i> are used to enable trust between different parties, usually networks and computers. <i>Public key infrastructure (PKI)</i> is responsible for the distribution, authentication, and revocation of public key certificates, which are used to verify ownership of digital certificates. These certificates contain the public key that an entity uses as part of a public/private key pair to encrypt data, which can then be decrypted only by the public key owner with the matching private key. This method secures most communication on the internet today.</p>
<p>The CA you create will generate, sign, verify, and revoke (if necessary) all the certificates required to encrypt and secure communications between the VPN server and VPN clients. Technically, you can install both OpenVPN and the CA on the same server, but doing so is less secure than installing them on separate servers. Any adversary who gains access to the server would have access to the certificates and private keys used by the server, as well as the ability to generate new certificates. Therefore, you’ll need two Ubuntu servers: one to act as the OpenVPN server and one to serve as the certificate server. You’ll use the certificate server to sign requests generated on the OpenVPN server for both the VPN server and any client devices connecting to the VPN, whether they’re laptops, workstations, mobile devices, or any other type of device.</p>
</section>
<section>
<h2 class="ah" id="ah0704"><a class="xref" href="nsp-enoka501485-0007.xhtml#rah0704">Wireguard</a></h2>
<p class="paft"><i>Wireguard</i>, a relatively new alternative to OpenVPN, is simple and incredibly fast by comparison. The drawback of being newer is that although Wireguard is open source, it’s had less time to be tested for bugs and vulnerabilities. However, it has gathered a sizable following in the security community and a good reputation for being reliable and secure.</p>
<p class="pcust1"><span class="ccust1">Note</span> If you plan to connect to your private network remotely, keep in mind that you’ll need a static IP address on your home or office internet connection, as well as some port forwarding on your border router. Most internet service providers supply static IP addresses upon request, usually for a nominal fee.</p>
<p class="hd" id="hd0701"><span aria-label="70" class="page" epub:type="pagebreak" id="p70" role="doc-pagebreak"/><a class="xref" href="nsp-enoka501485-0007.xhtml#rhd0701"><span class="ccust2">#19: Creating a VPN with OpenVPN</span></a></p>
<p class="paft">In this first project, you’ll start by creating an OpenVPN server and a certificate authority to secure communication via the VPN. Next, you’ll generate the relevant certificates, create the OpenVPN configuration files, configure the host firewall, and start the VPN. Finally, you’ll configure each of the VPN clients that will use this VPN to send and receive traffic, and you’ll connect to and test the VPN connection.</p>
<p>The entire process of spinning up an OpenVPN server in the cloud and connecting a client to it should take no longer than a couple of hours. Adding subsequent clients should take up to 30 minutes per endpoint. You’ll need to enable and configure a firewall on your server as part of creating your VPN. Ubuntu’s built-in firewall, the <i>Uncomplicated Firewall (UFW)</i>, is designed to reduce the complexity of firewall configuration. It’s much simpler than solutions like iptables (covered in <a class="xref" href="nsp-enoka501485-0012.xhtml#ch03">Chapter 3</a>). We’ll introduce you to UFW and its use in this project as an alternative host firewall solution. Alternatively, you can apply what you learned in <a class="xref" href="nsp-enoka501485-0012.xhtml#ch03">Chapter 3</a> and implement the same rules described for UFW in an iptables deployment. Even if you have a perimeter firewall in place like pfSense, be sure to enable either the host-based firewall offered by Ubuntu or iptables, as laid out in <a class="xref" href="nsp-enoka501485-0012.xhtml#ch03">Chapter 3</a>, to provide an additional layer of protection at the host level. Implementing a host-based firewall also allows more granular configuration of the servers’ network connections.</p>
<p>Once you enable the firewall, you’ll have to adjust the settings of the Ubuntu installation so that OpenVPN traffic is capable of traversing that firewall. (I’ll cover how to do this later in the project.)</p>
<p>Securing internet traffic originating inside your network will require a VPN exit node elsewhere, as well as a certificate server, so follow <a class="xref" href="nsp-enoka501485-0010.xhtml#hd0303">Project 3</a> in <a class="xref" href="nsp-enoka501485-0010.xhtml#ch01">Chapter 1</a> to create two base Ubuntu servers in the cloud, using the cloud service provider of your choice.</p>
<p>Once your Ubuntu servers are up and running, log in to the server you plan to use as your OpenVPN server (as opposed to the certificate authority) via SSH as a standard, non-root user:</p>
<pre>
<p class="cls">$ <code class="b">ssh</code> <code class="bi">user</code><code class="b">@</code><code class="bi">your_server_IP</code></p>
</pre>
<p>Once logged in to the OpenVPN server, at the bash terminal, use <code>apt</code> to install OpenVPN:</p>
<pre>
<p class="cls">$ <code class="b">sudo apt install openvpn -y</code></p>
</pre>
<p>You also need to install EasyRSA on both the OpenVPN server and the certificate server. Install the latest version using <code>apt</code> as well:</p>
<pre>
<p class="cls">$ <code class="b">sudo apt install easy-rsa -y</code></p>
</pre>
<p class="pcon">Make sure to install this on both Ubuntu servers. EasyRSA will be installed to the <i>/usr/share/easy-rsa/</i> directory by default.</p>
<section>
<h3 class="bh" id="bh0701"><span aria-label="71" class="page" epub:type="pagebreak" id="p71" role="doc-pagebreak"/><a class="xref" href="nsp-enoka501485-0007.xhtml#rbh0701">Set Up the Certificate Authority</a></h3>
<p class="paft">Next, you must configure and build the certificate server to act as a CA. The easiest way to do this is to make a copy of the template that EasyRSA provides and then modify its configuration to suit your needs. You can then initialize the PKI, build the CA, and generate its public certificate and private key.</p>
<p>Navigate to the <i>easy-rsa</i> folder on the certificate server and then create a copy of the <i>vars.example</i> file. Call it <i>vars</i>:</p>
<pre>
<p class="clf">$ <code class="b">cd /usr/share/easy-rsa/</code></p>
<p class="cll">$ <code class="b">sudo cp vars.example vars</code></p>
</pre>
<p class="pcon">Keep in mind that most of the time when a command in bash runs successfully, there will be no output to the screen, and you’ll be returned to the prompt.</p>
<p>Open the resulting <i>vars</i> file in a text editor:</p>
<pre>
<p class="cls">$ <code class="b">sudo nano vars</code></p>
</pre>
<p>In the file, find the <i>organizational fields</i> that contain information about the organization for which the certificates will be generated by this server; for example:</p>
<pre>
<p class="clf"><code class="i">--snip--</code></p>
<p class="cl">#set_var EASYRSA_REQ_COUNTRY    "US"</p>
<p class="cl">#set_var EASYRSA_REQ_PROVINCE   "California"</p>
<p class="cl">#set_var EASYRSA_REQ_CITY       "San Francisco"</p>
<p class="cl">#set_var EASYRSA_REQ_ORG        "Copyleft Certificate Co"</p>
<p class="cl">#set_var EASYRSA_REQ_EMAIL      "me@example.net"</p>
<p class="cl">#set_var EASYRSA_REQ_OU         "My Organizational Unit"</p>
<p class="cll"><code class="i">--snip--</code></p>
</pre>
<p>Each of these lines in the file is a comment by default, so they won’t be read or interpreted when the file is run; they’ll be ignored or suppressed. Remove the hash (<code>#</code>) at the beginning of each line to ensure they’re read when this file is invoked. Alter the values in quotations on the right to match your organization or personal network. The values can be anything you choose, but they can’t be blank. Here’s an example:</p>
<pre>
<p class="clf"><code class="i">--snip--</code></p>
<p class="cl">set_var EASYRSA_REQ_COUNTRY    "AU"</p>
<p class="cl">set_var EASYRSA_REQ_PROVINCE   "Queensland"</p>
<p class="cl">set_var EASYRSA_REQ_CITY       "Brisbane"</p>
<p class="cl">set_var EASYRSA_REQ_ORG        "Smithco"</p>
<p class="cl">set_var EASYRSA_REQ_EMAIL      "john@smithco.net"</p>
<p class="cl">set_var EASYRSA_REQ_OU         "Cyber Unit"</p>
<p class="cll"><code class="i">--snip--</code></p>
</pre>
<p>Save and close the file. Execute the <code>easyrsa</code> script within the <i>easy-rsa</i> folder (which should still be your current working directory) to initialize <span aria-label="72" class="page" epub:type="pagebreak" id="p72" role="doc-pagebreak"/>the PKI and then build the CA with the same <code>easyrsa</code> script, which will generate both the CA public certificate (<i>ca.crt</i>) and the private key (<i>ca.key</i>):</p>
<pre>
<p class="clf">$ <code class="b">sudo ./easyrsa init-pki</code></p>
<p class="cl"><code class="i">--snip--</code></p>
<p class="cl">Your newly created PKI dir is: /usr/share/easy-rsa/pki</p>
<p class="cl">$ <code class="b">sudo ./easyrsa build-ca nopass</code></p>
<p class="cl"><code class="i">--snip--</code></p>
<p class="cl">CA creation complete and you may now import and sign cert requests.</p>
<p class="cl">Your new CA certificate file for publishing is at:</p>
<p class="cll">/usr/share/easy-rsa/pki/ca.crt</p>
</pre>
<p>When prompted for the server’s Common Name, you can enter any string of characters you’d like, but it’s often easier to use the hostname of the server or press <span class="ac">enter</span> to accept the default Common Name. The output will contain the path to your PKI directory and <i>ca.crt</i> file; the <i>ca.key</i> file will be inside the <i>private</i> folder in the same location. The <code>nopass</code> option keeps you from being prompted for a password every time the CA is queried during this process.</p>
<p>That concludes the configuration of the CA server for now. The next set of configuration steps takes place on the OpenVPN server.</p>
</section>
<section>
<h3 class="bh" id="bh0702"><a class="xref" href="nsp-enoka501485-0007.xhtml#rbh0702">Create the OpenVPN Server Certificate and Key</a></h3>
<p class="paft">Each client you plan to connect to the VPN needs its own public certificate and private key. These files allow the certificate server, the VPN server, and any other clients on the VPN to authenticate the client and enable communication between all devices within the VPN. The VPN server also needs its own certificate and key for the same reasons. This part of the project describes how to sign a certificate and generate a key for the OpenVPN server. You’ll follow a similar process for connecting clients to the OpenVPN server.</p>
<p>On the OpenVPN server, navigate to the <i>easy-rsa</i> folder, and initialize the PKI for this server in the same way as before:</p>
<pre>
<p class="clf">$ <code class="b">cd /usr/share/easy-rsa</code></p>
<p class="cll">$ <code class="b">sudo ./easyrsa init-pki</code></p>
</pre>
<p>Just as every client connected to the VPN requires a certificate and key, the OpenVPN server itself needs a certificate signed by the CA. To this end, generate a certificate request from the OpenVPN server:</p>
<pre>
<p class="clf">$ <code class="b">sudo ./easyrsa gen-req server nopass</code></p>
<p class="cl">Using SSL: openssl OpenSSL 1.1.1f 31 Mar 2020</p>
<p class="cl">Generating a RSA private key</p>
<p class="cl">.................................+++++</p>
<p class="cl">........................................+++++</p>
<p class="cl">writing new private key to '/usr/share/easy-rsa/pki/private/server.key.2ljAQtgUYY'</p>
<p class="cl">-----</p>
<p class="cl">You are about to be asked to enter information that will be incorporated</p>
<p class="cl"><span aria-label="73" class="page" epub:type="pagebreak" id="p73" role="doc-pagebreak"/>into your certificate request.</p>
<p class="cl">What you are about to enter is what is called a Distinguished Name or a DN.</p>
<p class="cl">There are quite a few fields but you can leave some blank</p>
<p class="cl">For some fields there will be a default value,</p>
<p class="cl">If you enter '.', the field will be left blank.</p>
<p class="cl">-----</p>
<p class="cl">Common Name (eg: your user, host, or server name) [server]:</p>
<p class="clf">Keypair and certificate request completed. Your files are:</p>
<p class="cl">req: /usr/share/easy-rsa/pki/reqs/server.req</p>
<p class="cll">key: /usr/share/easy-rsa/pki/private/server.key</p>
</pre>
<p class="pcon">When prompted, press <span class="ac">enter</span> to accept the default Common Name for the VPN server, <code>server</code>, or give it a custom name. The output indicates that an RSA private key is generated and shows where the script stored the resulting server key and certificate request.</p>
<p>Copy the generated <i>server.key</i> file to the OpenVPN configuration directory on the VPN server:</p>
<pre>
<p class="cls">$ <code class="b">sudo cp /usr/share/easy-rsa/pki/private/server.key /etc/openvpn/</code></p>
</pre>
<p>Copy the <i>server.req</i> file to your certificate server using <code>rsync</code>, replacing the user and CA-ip placeholders with the relevant username and IP address for your certificate server:</p>
<pre>
<p class="cls">$ <code class="b">sudo rsync -ruhP /usr/share/easy-rsa/pki/reqs/server.req</code> <code class="bi">user</code><code class="b">@</code><code class="bi">CA</code><code class="i">_</code><code class="bi">ip</code><code class="b">:/tmp/</code></p>
</pre>
<p>Next, enter the following commands to log in to your certificate server and then import and sign the VPN certificate request generated earlier, enabling the VPN communications to be encrypted and secured:</p>
<pre>
<p class="clf">$ <code class="b">ssh</code> <code class="bi">user</code><code class="b">@</code><code class="bi">CA_ip</code></p>
<p class="cl">$ <code class="b">cd /usr/share/easy-rsa/</code></p>
<p class="cl">$ <code class="b">sudo ./easyrsa import-req /tmp/server.req</code> <!--<ccust1>1</ccust1>-->❶ <code class="i">server</code></p>
<p class="cll">$ <code class="b">sudo ./easyrsa sign-req</code> <!--<ccust1>2</ccust1>-->❷ <code class="b">server</code></p>
</pre>
<p>The first <code>easyrsa import-req</code> command imports the request. The second argument is the Common Name you created for your VPN server earlier <!--<ccust1>1</ccust1>-->❶. To sign the request, pass <code>easyrsa sign-req</code> the argument <code>server</code> <!--<ccust1>2</ccust1>-->❷ to specify the request type and then the Common Name again. (Later, when signing client requests, you’ll use the same command with <code>client</code> as the argument.)</p>
<p>When asked to confirm whether the details are correct, double-check to ensure the Common Name is set as expected and then type <code>yes</code> and press <span class="ac">enter</span> to complete the import and signing process. You’ll need to copy the resulting <i>server.crt</i> certificate file belonging to the OpenVPN server (along with the CA certificate) back to the OpenVPN server from the CA server so that each can authenticate the other:</p>
<pre>
<p class="clf">$ <code class="b">sudo rsync -ruhP /usr/share/easy-rsa/pki/issued/server.crt</code> <code class="bi">user</code><code class="b">@</code><code class="bi">vpn_ip</code><code class="b">:/tmp/</code></p>
<p class="cll">$ <code class="b">sudo rsync -ruhP /usr/share/easy-rsa/pki/ca.crt</code> <code class="bi">user</code><code class="b">@</code><code class="bi">vpn_ip</code><code class="b">:/tmp/</code></p>
</pre>
<p><span aria-label="74" class="page" epub:type="pagebreak" id="p74" role="doc-pagebreak"/>On the OpenVPN server, move the relevant files to the <i>/etc/openvpn/</i> directory:</p>
<pre>
<p class="clf">$ <code class="b">sudo mv /tmp/server.crt /etc/openvpn/</code></p>
<p class="cll">$ <code class="b">sudo mv /tmp/ca.crt /etc/openvpn/</code></p>
</pre>
<p>Next, you’ll need a Diffie-Hellman key to exchange keys between devices. A <i>Diffie-Hellman key exchange</i> is a way to communicate public and private key information between two parties over a public communication channel securely. Without this capability, it wouldn’t be possible to create secure encrypted channels over a public network like the internet.</p>
<p>You’ll also need an <i>HMAC signature</i> to make the process more secure. An HMAC signature, used in HMAC authentication and with a secret key, is a method of verifying the integrity of a message or payload. Using an HMAC signature in this process will maintain the key exchange’s integrity and allow you to verify the keys’ authenticity.</p>
<p>On your VPN server, navigate to your <i>easy-rsa</i> directory and generate a shared secret key using the <code>easyrsa</code> script created earlier:</p>
<pre>
<p class="clf">$ <code class="b">cd /usr/share/easy-rsa/</code></p>
<p class="cl">$ <code class="b">sudo ./easyrsa</code> <!--<ccust1>1</ccust1>-->❶ <code class="b">gen-dh</code></p>
<p class="cl">$ <code class="b">sudo</code> <!--<ccust1>2</ccust1>-->❷ <code class="b">openvpn --genkey secret ta.key</code></p>
<p class="cl">$ <code class="b">sudo cp /usr/share/easy-rsa/ta.key /etc/openvpn/</code></p>
<p class="cll">$ <code class="b">sudo cp /usr/share/easy-rsa/pki/dh.pem /etc/openvpn/</code></p>
</pre>
<p>The <code>gen-dh</code> argument <!--<ccust1>1</ccust1>-->❶ creates the Diffie-Hellman key, which may take a long time and generate a lot of output. The <code>openvpn --gen-key secret</code> <!--<ccust1>2</ccust1>-->❷ command quickly generates the HMAC signature, and you’ll see no output if it’s successful. These processes create the <i>/usr/share/easy-rsa/ta.key</i> and <i>/usr/share/easy-rsa/pki/dh.pem</i> files. Copy each of them to the OpenVPN configuration directory, <i>/etc/openvpn/</i>, on your OpenVPN server:</p>
<pre>
<p class="clf">$ <code class="b">sudo cp /usr/share/easy-rsa/ta.key /etc/openvpn/</code></p>
<p class="cll">$ <code class="b">sudo cp /usr/share/easy-rsa/pki/dh.pem /etc/openvpn/</code></p>
</pre>
<p>At this point, you’ve created all the required certificates and keys for the servers.</p>
<section>
<h4 class="ch" id="ch0701">Create a Client Certificate</h4>
<p class="paft">Next, you’ll need to create client certificates and keys to allow clients to connect to the VPN, which are the same as the server certificates but relate to each individual client device. The most efficient way to do this is to create the necessary files on the server, rather than on the client, which prevents you from having to transfer files between devices unnecessarily. On the OpenVPN server, create a safe location for the files:</p>
<pre>
<p class="cls">$ <code class="b">sudo mkdir -p /etc/openvpn/client-configs/keys/</code></p>
</pre>
<p><span aria-label="75" class="page" epub:type="pagebreak" id="p75" role="doc-pagebreak"/>Navigate to the <i>easy-rsa</i> directory, generate a new certificate request for the client, copy the key to the directory you just created, and securely copy the request file to your CA server as shown here:</p>
<pre>
<p class="clf">$ <code class="b">cd /usr/share/easy-rsa/</code></p>
<p class="cl">$ <code class="b">sudo ./easyrsa gen-req</code> <!--<ccust1>1</ccust1>-->❶ <code class="bi">myclient</code> <code class="b">nopass</code></p>
<p class="cl">$ <code class="b">sudo cp /usr/share/easy-rsa/pki/private/</code><code class="bi">myclient</code><code class="b">.key \</code></p>
<p class="cl"><code class="b">    /etc/openvpn/client-configs/keys/</code></p>
<p class="cll">$ <code class="b">sudo rsync -ruhP /usr/share/easy-rsa/pki/reqs/</code><code class="bi">myclient</code><code class="b">.req</code> <code class="bi">user</code><code class="b">@</code><code class="bi">CA_ip</code><code class="b">:/tmp/</code></p>
</pre>
<p>You’ll be asked for a passphrase for the request; enter one and be sure to save it for later reference. You’ll also be asked for a Common Name for your VPN client. This name will need to be different for each client that you provide access to the VPN, so consider using the client hostname (<code>myclient</code> in this example; change <code class="i">myclient</code> <!--<ccust1>1</ccust1>-->❶ to the client name of your choice).</p>
<p>On your certificate server, navigate to the <i>easy-rsa</i> directory:</p>
<pre>
<p class="cls">$ <code class="b">cd /usr/share/easy-rsa/</code></p>
</pre>
<p>Import the request using the client’s Common Name (<code>myclient</code> in this example) and then sign it using the <code>client</code> directive, rather than the <code>server</code> directive you used earlier:</p>
<pre>
<p class="clf">$ <code class="b">sudo ./easyrsa import-req /tmp/</code><code class="i">myclient</code><code class="b">.req</code> <code class="i">myclient</code></p>
<p class="cll">$ <code class="b">sudo ./easyrsa sign-req client</code> <code class="i">myclient</code></p>
</pre>
<p class="pcon">Confirm that the Common Name is correct and then type <code class="b">yes</code> and press <span class="ac">enter</span> to complete the command.</p>
<p>Finally, securely copy the newly generated certificate back to your OpenVPN server:</p>
<div class="codeline1">
<p class="cl1s">$ <code class="b">sudo rsync -ruhP /usr/share/easy-rsa/pki/issued/myclient.crt</code> <code class="bi">user@vpn_ip</code><code class="b">:/tmp/</code></p>
</div>
<p>For the VPN to function correctly, the <i>ta.key</i> and <i>ca.crt</i> files you created earlier, as well as the <i>myclient.crt</i> file, need to be in the client configuration directory on the OpenVPN server. On your VPN server, copy those files to the <i>/etc/openvpn/client-configs/keys/</i> directory:</p>
<pre>
<p class="clf">$ <code class="b">sudo cp /usr/share/easy-rsa/ta.key /etc/openvpn/client-configs/keys/</code></p>
<p class="cl">$ <code class="b">sudo mv /tmp/</code><code class="i">myclient</code><code class="b">.crt /etc/openvpn/client-configs/keys/</code></p>
<p class="cll">$ <code class="b">sudo cp /etc/openvpn/ca.crt /etc/openvpn/client-configs/keys/</code></p>
</pre>
<p>And with that, you’ve created the necessary files to connect a client to the OpenVPN server. You can repeat this process as many times as necessary. Just be sure to change the client name from <code>myclient</code> to something else each time you generate files for a new client.</p>
</section>
</section>
<section>
<h3 class="bh" id="bh0703"><span aria-label="76" class="page" epub:type="pagebreak" id="p76" role="doc-pagebreak"/><a class="xref" href="nsp-enoka501485-0007.xhtml#rbh0703">Configure OpenVPN</a></h3>
<p class="paft">Now that the certificate server is set up, you can configure the OpenVPN server. To do so, you’ll copy a template OpenVPN configuration and modify it to suit your needs.</p>
<p>On your OpenVPN server, copy the configuration template to the OpenVPN configuration directory:</p>
<div class="codeline1">
<p class="cl1s">$ <code class="b">sudo cp /usr/share/doc/openvpn/examples/sample-config-files/server.conf /etc/openvpn/</code></p>
</div>
<p>Open the resulting <i>server.conf</i> file in a text editor (this example uses nano):</p>
<pre>
<p class="cls">$ <code class="b">sudo nano /etc/openvpn/server.conf</code></p>
</pre>
<p>As with any configuration file, open it and familiarize yourself with its contents. You might notice that these configuration files use both <code>#</code> and <code>;</code> to mark lines as comments.</p>
<p>Once you feel comfortable with the options available, you might decide to alter the port or protocol your VPN uses. Find the lines that start with <code>port</code> or <code>proto</code>, and notice a semicolon is used to comment out the inactive lines:</p>
<pre>
<p class="clf"><code class="i">--snip--</code></p>
<p class="cl">port 1194</p>
<p class="cl"><code class="i">--snip--</code></p>
<p class="cl"><code class="b">;</code>proto tcp</p>
<p class="cl">proto udp</p>
<p class="cll"><code class="i">--snip--</code></p>
</pre>
<p>OpenVPN can run over either UDP or TCP, but it uses UDP by default, and the default port is 1194. However, you can tell it to run over any port you like, but if you make changes, you’ll need to make those same changes in any commands or files that follow. Also, make sure that the certificates and keys mentioned in this file match your configurations from earlier sections of the chapter:</p>
<pre>
<p class="clf"><code class="i">--snip--</code></p>
<p class="cl">ca <code class="b">ca.crt</code></p>
<p class="cl">cert <code class="b">server.crt</code></p>
<p class="cl">key <code class="b">server.key</code></p>
<p class="cll"><code class="i">--snip--</code></p>
</pre>
<p>When you reach the Diffie-Hellman section, ensure that the file matches the one you created earlier; the configuration file lists <i>dh2048.pem</i> by default, which will need to be changed to <i>dh.pem</i>:</p>
<pre>
<p class="clf"><code class="i">--snip--</code></p>
<p class="cl"><code class="b">#</code>dh dh2048.pem</p>
<p class="cl"><code class="b">dh dh.pem</code></p>
<p class="cll"><code class="i">--snip--</code></p>
</pre>
<p><span aria-label="77" class="page" epub:type="pagebreak" id="p77" role="doc-pagebreak"/>In addition, the <code>redirect-gateway</code> and <code>dhcp-option</code> DNS directives should not be commented out, so remove the semicolons at the beginning of those lines:</p>
<pre>
<p class="clf"><code class="i">--snip--</code></p>
<p class="cl">push "redirect-gateway def1 bypass-dhcp"</p>
<p class="cl"><code class="i">--snip--</code></p>
<p class="cl">push "dhcp-option DNS 208.67.222.222"</p>
<p class="cl">push "dhcp-option DNS 208.67.220.220"</p>
<p class="cll"><code class="i">--snip--</code></p>
</pre>
<p>These directives ensure that all traffic will traverse the VPN and not the unsecured internet. You can leave DNS with the default settings, or you can set it to any DNS servers you desire, such as Quad9 (<i>9.9.9.9</i>), Google (<i>8.8.8.8</i>), or your Pi-Hole DNS server if you have one configured as described in <a class="xref" href="nsp-enoka501485-0016.xhtml#ch07">Chapter 7</a>.</p>
<p>Next, check that the <code>tls-auth</code> directive is set to <code>0</code> and not commented out with a semicolon and that the <code>cipher</code> is set to <code>AES-256-CBC</code>. Then, immediately after the <code>cipher</code> directive, add an <code>auth</code> directive:</p>
<pre>
<p class="clf"><code class="i">--snip--</code></p>
<p class="cl">tls-auth ta.key 0</p>
<p class="cl"><code class="i">--snip--</code></p>
<p class="cl">cipher AES-256-CBC</p>
<p class="cl"><code class="b">auth SHA256</code></p>
<p class="cll"><code class="i">--snip--</code></p>
</pre>
<p>The <code>tls-auth</code> directive ensures that the HMAC signature you configured earlier will indeed be used to secure the VPN. Several settings are available for the cipher, and AES-256 is a reasonable choice as the encryption offered is good and well supported. The <code>SHA256</code> indicates the algorithm used for the HMAC message digest, meaning the hash calculated will be an SHA256 hash, which is considered secure and less prone to hash collisions than some other hashing algorithms.</p>
<p>To make the VPN more secure, remove the semicolons from the <code>user</code> and <code>group</code> directives, which makes the VPN service run with fewer privileges and ideally mitigates the risk of privilege escalation attacks:</p>
<pre>
<p class="clf"><code class="i">--snip--</code></p>
<p class="cl">user nobody</p>
<p class="cl">group nogroup</p>
<p class="cll"><code class="i">--snip--</code></p>
</pre>
<p class="pcon">After making these changes, save and close the configuration file.</p>
<p>The OpenVPN configuration is complete, but you’ll need to make some changes to the server’s network settings. First, you must configure IP forwarding or the VPN won’t do anything with the traffic received:</p>
<pre>
<p class="cls">$ <code class="b">sudo sysctl -w net.ipv4.ip_forward=1</code></p>
</pre>
<p>Reload <code>sysctl</code> to make the change take effect, as follows.</p>
<pre>
<p class="clf"><span aria-label="78" class="page" epub:type="pagebreak" id="p78" role="doc-pagebreak"/>$ <code class="b">sudo sysctl -p</code></p>
<p class="cll">net.ipv4.ip_forward = 1</p>
</pre>
<p class="pcon">The command may output the lines modified in the <i>sysctl.conf</i> file.</p>
<section>
<h4 class="ch" id="ch0702">Configure the Firewall</h4>
<p class="paft">The first step in this process is to find your VPN server’s public network interface; your server may have multiple network interfaces, and selecting the wrong interface for the following commands would result in a VPN that is unable to route traffic to the internet correctly:</p>
<pre>
<p class="clf">$ <code class="b">ip route | grep -i default</code></p>
<p class="cll">default via 202.182.98.1 dev <code class="b">ens3</code> proto dhcp src 202.182.98.40 metric 100</p>
</pre>
<p>In this output, the network interface is called <code>ens3</code>, but yours might be different. The <i>default route</i> shown by <code>ip route</code> will be the public network interface of your host. You’ll need this to configure your firewall correctly.</p>
<p>In most firewalls, the order in which you set your rules is the most important consideration. In UFW, rules are evaluated from rule files in the following order: first <i>before.rules</i>, then <i>user.rules</i>, and finally <i>after.rules</i>. The firewall must correctly identify and push through the VPN traffic, so rules are needed at the top of the firewall configuration. To do this in UFW, open the <i>before.rules</i> file in a text editor:</p>
<pre>
<p class="cls">$ <code class="b">sudo nano /etc/ufw/before.rules</code></p>
</pre>
<p>Then add these lines at the top of the file to allow OpenVPN client traffic via the public network interface you identified in the previous commands:</p>
<pre>
<p class="clf">*nat</p>
<p class="cl">:POSTROUTING ACCEPT [0:0]</p>
<p class="cl">-A POSTROUTING -s <code class="i">10.8.0.0/24</code>-o <code class="i">ens3</code> -j MASQUERADE</p>
<p class="cll">COMMIT</p>
</pre>
<p>The network <i>10.8.0.0/24</i> indicates the addresses that clients connecting to your VPN will be assigned. These addresses should be different from the addresses used in your network. If you use <i>192.168.1.x</i> addresses in your network, do not use <i>192.168.1.x</i> addresses for your VPN network addressing. As long as your network uses addresses other than <i>10.8.0.x</i>, the previous configuration is safe to use.</p>
<p>Save and close the file. UFW also needs to accept, rather than drop, forwarded packets. You can allow this by changing the UFW configuration file:</p>
<pre>
<p class="cls">$ <code class="b">sudo ufw default allow FORWARD</code></p>
</pre>
<p>Finally, the firewall needs to allow the port and protocol used for the VPN to send and receive traffic, as well as SSH for server administration. Enter the following command to allow the correct port and protocol based on the configurations you set in <i>etc/openvpn/server.conf</i>:</p>
<pre>
<p class="cls"><span aria-label="79" class="page" epub:type="pagebreak" id="p79" role="doc-pagebreak"/>$ <code class="b">sudo ufw allow 1194/udp</code></p>
</pre>
<p>Next, allow OpenSSH:</p>
<pre>
<p class="cls">$ <code class="b">sudo ufw allow OpenSSH</code></p>
</pre>
<p>Restart the firewall for the changes to take effect permanently:</p>
<pre>
<p class="clf">$ <code class="b">sudo ufw disable</code></p>
<p class="cll">$ <code class="b">sudo ufw enable</code></p>
</pre>
<p>Your SSH connection might be interrupted as the firewall restarts, and you may need to log in again.</p>
</section>
<section>
<h4 class="ch" id="ch0703">Start the VPN</h4>
<p class="paft">At this point, you’re ready to start the VPN. Do so using <code>systemctl</code>, the utility used to control services in Ubuntu, passing it your server’s Common Name:</p>
<pre>
<p class="cls">$ <code class="b">sudo systemctl start openvpn@</code><code class="bi">server</code></p>
</pre>
<p>Check the VPN’s status:</p>
<pre>
<p class="cls">$ <code class="b">sudo systemctl status openvpn@</code><code class="bi">server</code></p>
</pre>
<p>If it’s working properly, the output should say <code>active (running)</code>.</p>
<p>Press Q to return to the terminal and then make the VPN start whenever the server boots:</p>
<pre>
<p class="cls">$ <code class="b">sudo systemctl enable openvpn@</code><code class="bi">server</code></p>
</pre>
<p class="pcon">Your VPN should now be up and running and ready for client connections.</p>
</section>
<section>
<h4 class="ch" id="ch0704">Configure a VPN Client</h4>
<p class="paft">Clients must have <i>.ovpn</i> files configured to connect to the VPN server and send and receive traffic across the secure tunnel. Creating these configurations can be tedious if you have several clients to connect, so we’ll use an easily repeatable procedure to do it for us. We’ll generate configuration files on the OpenVPN server and then transfer those configuration files to the relevant clients.</p>
<p>On your OpenVPN server, create a safe location for the client configuration files (such as <i>/etc/openvpn/client-configs/files/</i>), copy another template provided by OpenVPN, and open the resulting <i>base.conf</i> file in a text editor:</p>
<pre>
<p class="clf">$ <code class="b">sudo mkdir -p /etc/openvpn/client-configs/files/</code></p>
<p class="cl">$ <code class="b">sudo cp /usr/share/doc/openvpn/examples/sample-config-files/client.conf \</code></p>
<p class="cl"><code class="b">    /etc/openvpn/client-configs/base.conf</code></p>
<p class="cll">$ <code class="b">nano /etc/openvpn/client-configs/base.conf</code></p>
</pre>
<p>Familiarize yourself with the file’s contents. If you made changes to the port or protocol in previous steps, make the same changes in this file.</p>
<pre>
<p class="clf"><span aria-label="80" class="page" epub:type="pagebreak" id="p80" role="doc-pagebreak"/><code class="i">--snip--</code></p>
<p class="cl">;proto tcp</p>
<p class="cl"><code class="b">proto udp</code></p>
<p class="cl"><code class="i">--snip--</code></p>
<p class="cl">remote <code class="bi">vpn_ip</code> <code class="b">1194</code></p>
<p class="cl">;remote <code class="bi">vpn_ip</code> <code class="b">1194</code></p>
<p class="cll"><code class="i">--snip--</code></p>
</pre>
<p>Also, uncomment the <code>user</code> and <code>group</code> directives:</p>
<pre>
<p class="clf"><code class="i">--snip--</code></p>
<p class="cl">user nobody</p>
<p class="cl">group nogroup</p>
<p class="cll"><code class="i">--snip--</code></p>
</pre>
<p>Comment out the SSL/TLS parameters:</p>
<pre>
<p class="clf"><code class="i">--snip--</code></p>
<p class="cl"><code class="b">#</code>ca ca.crt</p>
<p class="cl"><code class="b">#</code>cert client.crt</p>
<p class="cl"><code class="b">#</code>key client.key</p>
<p class="cll"><code class="i">--snip--</code></p>
</pre>
<p>Comment out the <code>tls-auth</code> directive:</p>
<pre>
<p class="clf"><code class="i">--snip--</code></p>
<p class="cl"><code class="b">#</code>tls-auth ta.key 1</p>
<p class="cll"><code class="i">--snip--</code></p>
</pre>
<p>Set the <code>cipher</code> and <code>auth</code> directives to the values found in the other configuration files:</p>
<pre>
<p class="clf"><code class="i">--snip--</code></p>
<p class="cl"><code class="b">cipher AES-256-CBC</code></p>
<p class="cl"><code class="b">auth SHA256</code></p>
<p class="cll"><code class="i">--snip--</code></p>
</pre>
<p>Finally, add the following line to the end of the file:</p>
<pre>
<p class="clf"><code class="i">--snip--</code></p>
<p class="cll">key-direction 1</p>
</pre>
<p>The <code>key-direction</code> directive indicates to the client which device in the client-server pair will provide the key and therefore the encryption for the VPN tunnel. This can be set to either <code>0</code> or <code>1</code>, but this configuration should be set to <code>1</code>, as this should provide better overall security by forcing different keys to be used for client-server and server-client communication. Save and close the file.</p>
<p>You can easily create client configurations by writing and executing a script to pull all of these elements together. Create an <i>.sh</i> file in which to put your script, make it executable, and then open it with a text editor (nano in this example):</p>
<pre>
<p class="clf"><span aria-label="81" class="page" epub:type="pagebreak" id="p81" role="doc-pagebreak"/>$ <code class="b">sudo touch /etc/openvpn/client-configs/client_config.sh</code></p>
<p class="cl">$ <code class="b">sudo chmod +x /etc/openvpn/client-configs/client_config.sh</code></p>
<p class="cll">$ <code class="b">sudo nano /etc/openvpn/client-configs/client_config.sh</code></p>
</pre>
<p>Copy the script in <a class="xref" href="nsp-enoka501485-0014.xhtml#lis0501">Listing 5-1</a> into the file.</p>
<figure class="figure" id="lis0501">
<pre>
<p class="clf">#!/bin/bash</p>
<p class="cl">KEY_DIR=/etc/openvpn/client-configs/keys</p>
<p class="cl">OUTPUT_DIR=/etc/openvpn/client-configs/files</p>
<p class="cl">BASE_CONFIG=/etc/openvpn/client-configs/base.conf</p>
<p class="clf">cat ${BASE_CONFIG} \</p>
<p class="clf">    &lt;(echo -e '&lt;ca&gt;') ${KEY_DIR}/ca.crt \</p>
<p class="clf">    &lt;(echo -e '&lt;/ca&gt;\n&lt;cert&gt;') ${KEY_DIR}/${1}.crt \</p>
<p class="cl">    &lt;(echo -e '&lt;/cert&gt;\n&lt;key&gt;') ${KEY_DIR}/${1}.key \</p>
<p class="cl">    &lt;(echo -e '&lt;/key&gt;\n&lt;tls-auth&gt;') ${KEY_DIR}/ta.key \</p>
<p class="cll">    &lt;(echo -e '&lt;/tls-auth&gt;') &gt; $ {OUTPUT_DIR}/${1}.ovpn</p>
</pre>
<p class="figh"><span class="fighn">Listing 5-1</span>: A script for generating client configuration (<i>.ovpn</i>) file</p>
</figure>
<p>Save and close the file. The first line tells bash that what follows in this file is a script. The next three lines are variables, which you can modify if your key directory, output directory, or base config files and folders are different from the examples in this chapter.</p>
<p>Execute the script from within the <i>client-configs</i> directory as shown in <a class="xref" href="nsp-enoka501485-0014.xhtml#lis0502">Listing 5-2</a>, with a client name as the only parameter. The client name should match one in the certificate and key files you created in earlier steps. To generate configuration files for further clients, be sure to generate their certificates and keys, and then use those files to create the relevant <i>.ovpn</i> file for that client with the script in <a class="xref" href="nsp-enoka501485-0014.xhtml#lis0501">Listing 5-1</a>. Don’t forget this entails creating a certificate request, transferring it to your certificate server for signing, and then transferring it back to your VPN server, in the <i>client-configs</i> directory.</p>
<p><a class="xref" href="nsp-enoka501485-0014.xhtml#lis0502">Listing 5-2</a> shows a run of the script for the <code>myclient</code> client, and a command to list the resulting file.</p>
<figure class="figure" id="lis0502">
<pre>
<p class="clf">$ <code class="b">cd /etc/openvpn/client-configs/</code></p>
<p class="cl">$ <code class="b">sudo ./client_config.sh</code> <code class="bi">myclient</code></p>
<p class="cl">$ <code class="b">ls -lah /etc/openvpn/client-configs/files/</code></p>
<p class="cl">total 20</p>
<p class="cl">drwxrwxr-x 2 test test 4096 Apr 28 23:22 ./</p>
<p class="cl">drwxrwxr-x 4 test test 4096 Apr 28 23:21 ../</p>
<p class="cll">-rw-rw-r-- 1 test test 11842 Apr 28 23:22 <code class="bi">myclient</code><code class="b">.ovpn</code></p>
</pre>
<p class="figh"><span class="fighn">Listing 5-2</span>: Executing the script from <a class="xref" href="nsp-enoka501485-0014.xhtml#lis0501">Listing 5-1</a></p>
</figure>
<p>Once the <i>.ovpn</i> file is created for this client, download the file to your local machine via rsync and then import it into the OpenVPN client for that device.</p>
<pre>
<p class="cls"><span aria-label="82" class="page" epub:type="pagebreak" id="p82" role="doc-pagebreak"/>$ <code class="b">rsync -ruhP</code> <code class="bi">user@vpn_ip:</code><code class="b">/etc/openvpn/client-configs/files/</code><code class="bi">myclient</code><code class="b">.ovpn ./</code></p>
</pre>
<p>OpenVPN has client applications for most operating systems, including Windows, Linux, macOS, iOS, and Android. You can find these on the OpenVPN website: <a class="url-i" href="https://openvpn.net/community-downloads/">https://openvpn.net/community-downloads/</a>.</p>
<p>With that done, you can now import the <i>.ovpn</i> configuration file, connect to your VPN, and use the internet in a much more private and secure manner. If you plan to connect to your VPN using a Linux client, you can install OpenVPN using the following command:</p>
<pre>
<p class="cls">$ <code class="b">sudo apt install openvpn -y</code></p>
</pre>
<p>Then, connect to your VPN using your configuration file and this command:</p>
<pre>
<p class="cls">$ <code class="b">sudo openvpn</code> <code class="bi">myclient</code><code class="b">.ovpn</code></p>
</pre>
<p>See “<a class="xref" href="nsp-enoka501485-0014.xhtml#ah0705">Test Your VPN</a>” on <a class="xref" href="nsp-enoka501485-0014.xhtml#p89">page 89</a> for additional testing you can do to ensure your VPN is secure.</p>
<p class="hd" id="hd0702"><a class="xref" href="nsp-enoka501485-0007.xhtml#rhd0702"><span class="ccust2">#20: Creating a VPN with Wireguard</span></a></p>
<p class="paft">Modern versions of Ubuntu (those from March 2020 onward) have Wireguard built into the kernel, so it’s simple to install and get up and running. Wireguard isn’t built into a lot of networking hardware at this stage, so you’ll have to configure each of your endpoints to connect to it manually, rather than simply configuring your router and passing all network traffic through the VPN tunnel. In this project, you’ll create a Wireguard server using the instructions to create a virtual machine in the cloud, and then you’ll install and configure Wireguard. We’ll create the relevant public and private key pairs for the server and any clients, configure the server firewall as required, configure and connect a client, and test the VPN to ensure that it’s working correctly. Your internet traffic will then be safe and secure, as long as you’re connected to your Wireguard VPN.</p>
</section>
</section>
<section>
<h3 class="bh" id="bh0704"><a class="xref" href="nsp-enoka501485-0007.xhtml#rbh0704">Installing Wireguard</a></h3>
<p class="paft">Create a new Ubuntu server using the instructions provided in <a class="xref" href="nsp-enoka501485-0010.xhtml#hd0303">Project 3</a> in <a class="xref" href="nsp-enoka501485-0010.xhtml#ch01">Chapter 1</a>. Log in to the server via SSH as a standard, non-root user:</p>
<pre>
<p class="cls">$ <code class="b">ssh</code> <code class="bi">user@your_server_IP</code></p>
</pre>
<p>Then, use <code>apt</code> to install Wireguard, specifying <code>-y</code> to skip the confirmation prompt:</p>
<pre>
<p class="cls">$ <code class="b">sudo apt install wireguard -y</code></p>
</pre>
<p>Next, you’ll create the necessary public and private keys required to connect to and encrypt your VPN.</p>
</section>
<section>
<h3 class="bh" id="bh0705"><span aria-label="83" class="page" epub:type="pagebreak" id="p83" role="doc-pagebreak"/><a class="xref" href="nsp-enoka501485-0007.xhtml#rbh0705">Set Up the Key Pairs</a></h3>
<p class="paft">Due to the sensitive nature of the files or folders you’re about to create, it’s wise to enforce more restrictive permissions than usual. You can run the following command to ensure that only the owner of a file can read and write to that file:</p>
<pre>
<p class="cls">$ <code class="b">umask 077</code></p>
</pre>
<p class="pcon">This <code>umask</code> command won’t last after you exit the terminal session, but only the owner is allowed to read and write to the folders and files you create during this session.</p>
<p>Now, using the <code>wg genkey</code> command, create the private Wireguard key:</p>
<pre>
<p class="cls">$ <code class="b">wg genkey | sudo tee /etc/wireguard/private.key</code></p>
</pre>
<p>The output shown in the terminal is your private key, which will be stored in the <i>private.key</i> file specified in the command. Do not share this key. Treat it like a password—it’s how your VPN will be secured.</p>
<p>With the private key created, you’ll need a corresponding public key to provide to your clients so they can authenticate to the server:</p>
<div class="codeline1">
<p class="cl1s">$ <code class="b">sudo cat /etc/wireguard/private.key | wg pubkey | sudo tee /etc/wireguard/public.key</code></p>
</div>
<p>This command first reads the contents of the <i>private.key</i> file using <code>cat</code>. Then, the <code>wg pubkey</code> command uses the private key to generate the public key. The public key is then output to the terminal and saved to the <i>public.key</i> file.</p>
<p>Now that you have your public/private key pair, you can configure your VPN server and clients.</p>
</section>
<section>
<h3 class="bh" id="bh0706"><a class="xref" href="nsp-enoka501485-0007.xhtml#rbh0706">Configure Wireguard</a></h3>
<p class="paft">Wireguard requires a configuration file to function. This file is not created when Wireguard is installed, so you need to create one from scratch. Create and open the <i>/etc/wireguard/wg0.conf</i> file using a text editor:</p>
<pre>
<p class="cls">$ <code class="b">sudo nano /etc/wireguard/wg0.conf</code></p>
</pre>
<p>Add the following contents to the file:</p>
<pre>
<p class="clf"><code class="b">[Interface]</code></p>
<p class="cl"><code class="b">PrivateKey =</code> <code class="bi">your_private_key</code></p>
<p class="cl"><code class="b">Address =</code> <code class="bi">10.8.0.1/24</code></p>
<p class="cl"><code class="b">ListenPort =</code> <code class="bi">26535</code></p>
<p class="cll"><code class="b">SaveConfig = true</code></p>
</pre>
<p>Replace <i>your_private_key</i> with the private key you created earlier. Your key will be the contents of your <i>/etc/wireguard/private.key</i> file. The address will be the address of your server within the subnet you want your VPN clients to be assigned when they connect to your server; ensure that this <span aria-label="84" class="page" epub:type="pagebreak" id="p84" role="doc-pagebreak"/>subnet is different from your private network. For example, if you use <i>192.168.1.x</i> addresses in your network, avoid using <i>192.168.1.x</i> addresses for your VPN. The listening port should be any port between 1025 and 65535, chosen at random. This port is the one your server and clients will use to communicate. Once complete, save and exit the configuration file.</p>
<p>At this point, the server’s network settings require some modification. Configure IP forwarding so the VPN will forward the traffic it receives using the following command and then restart <code>sysctl</code> so that the changes take effect:</p>
<pre>
<p class="clf">$ <code class="b">sudo sysctl -w net.ipv4.ip_forward=1</code></p>
<p class="cll">$ <code class="b">sudo sysctl -p</code></p>
</pre>
<p>Next, you need to configure the firewall to allow VPN traffic to ingress and egress the server.</p>
<section>
<h4 class="ch" id="ch0705">Configure the Firewall</h4>
<p class="paft">In this section we’ll discuss the use of the <i>Uncomplicated Firewall (UFW)</i>, Ubuntu’s built-in firewall that is designed to reduce the complexity of firewall configuration. To configure the firewall, first identify the correct network interface for the VPN. Specifying the wrong interface will result in a nonfunctional VPN. Enter the following command to locate your server’s default network interface:</p>
<pre>
<p class="clf">$ <code class="b">ip route | grep -i default</code></p>
<p class="cll">default via 172.16.90.1 dev <code class="b">ens33</code> proto dhcp metric 100</p>
</pre>
<p>In this output, the network interface is called <code>ens33</code> (yours might be different). The <i>default route</i> shown by <code>ip route</code> will be your host’s public network interface. You’ll need this to configure your firewall correctly.</p>
<p>Next, add the following rules to the bottom of your Wireguard configuration file by opening <i>/etc/wireguard/wg0.conf</i> with a text editor again and replacing <code>ens33</code> with your network interface name:</p>
<pre>
<p class="clf">$ <code class="b">sudo nano /etc/wireguard/wg0.conf</code></p>
<p class="cl"><code class="i">--snip--</code></p>
<p class="cl">SaveConfig = true</p>
<p class="cl"><code class="b">PostUp = ufw route allow in on wg0 out on</code> <code class="bi">ens33</code></p>
<p class="cl"><code class="b">PostUp = iptables -t nat -I POSTROUTING -o</code> <code class="bi">ens33</code> <code class="b">-j MASQUERADE</code></p>
<p class="cl"><code class="b">PreDown = ufw route delete allow in on wg0 out on</code> <code class="bi">ens33</code></p>
<p class="cll"><code class="b">PreDown = iptables -t nat -D POSTROUTING -o</code> <code class="bi">ens33</code> <code class="b">-j MASQUERADE</code></p>
</pre>
<p>Save and close the file. This allows Wireguard to modify the firewall configuration after Wireguard starts and before it stops to enable the VPN to function correctly.</p>
<p>Additionally, you need to allow traffic via the listening port you configured earlier in the chapter (port 26535 in the example):</p>
<pre>
<p class="cls">$ <code class="b">sudo ufw allow</code> <code class="bi">26535</code><code class="b">/udp</code></p>
</pre>
<p><span aria-label="85" class="page" epub:type="pagebreak" id="p85" role="doc-pagebreak"/>Next, allow OpenSSH:</p>
<pre>
<p class="cls">$ <code class="b">sudo ufw allow ssh</code></p>
</pre>
<p>Finally, with this rule updated, you need to disable and enable UFW to reload the rules (your SSH session might be interrupted, and you may need to log in again):</p>
<pre>
<p class="clf">$ <code class="b">sudo ufw disable</code></p>
<p class="cll">$ <code class="b">sudo ufw enable</code></p>
</pre>
<p>And with that, your firewall configuration is complete.</p>
</section>
<section>
<h4 class="ch" id="ch0706">Identify the DNS Server</h4>
<p class="paft">To secure your internet traffic, your VPN needs to have correctly configured DNS to prevent DNS leaks, which can compromise your security. To solve this problem, you’ll force your Wireguard VPN to use the DNS that’s used by the Wireguard server itself. Identify that DNS server(s) with the following command:</p>
<pre>
<p class="cls">$ <code class="b">resolvectl dns ens33</code></p>
</pre>
<p class="pcon">The resulting output is the DNS address you will provide to the client in its configuration later in this project—take note of it.</p>
</section>
<section>
<h4 class="ch" id="ch0707">Start the VPN</h4>
<p class="paft">Ideally, the VPN should start and be ready to accept client connections whenever the server starts up. You can achieve this by creating and starting a Wireguard system service using <code>systemctl</code>:</p>
<pre>
<p class="clf">$ <code class="b">sudo systemctl enable wg-quick@wg0.service</code></p>
<p class="cll">$ <code class="b">sudo systemctl start wg-quick@wg0.service</code></p>
</pre>
<p>Once done, check the status to ensure Wireguard is running:</p>
<pre>
<p class="cls">$ <code class="b">sudo systemctl status wg-quick@wg0.service</code></p>
</pre>
<p>If it’s working properly, the output should say <code>active</code>. If the service is not active or has a failed status, double-check your configuration file and firewall status to ensure there are no typos or other errors in your configuration.</p>
</section>
<section>
<h4 class="ch" id="ch0708">Configure a VPN Client</h4>
<p class="paft">There are official client applications available for Wireguard for Windows, macOS, Android, and iOS—the setup of which is reasonably similar across the board. The Linux client setup is a little more involved, but if you’ve been able to configure the Wireguard server successfully, configuring a Linux client will seem very familiar.</p>
</section>
<section>
<h4 class="ch" id="ch0709"><span aria-label="86" class="page" epub:type="pagebreak" id="p86" role="doc-pagebreak"/>Windows, macOS, Android, or iOS Client Configuration</h4>
<p class="paft">To configure a client on any of these operating systems, follow these steps:</p>
<ol style="list-style-type:none">
<li class="nlf">1. Download and install the relevant client program from <a class="url-i" href="https://www.wireguard.com/install/">https://www.wireguard.com/install/</a>.</li>
<li class="nl">2. In the client interface, click <b>+</b> or <b>Add Tunnel▸Add Empty Tunnel</b> to create a new VPN profile from scratch.</li>
<li class="nl">3. Note that the public and private keys for the client are displayed.</li>
<li class="nl">4. Supply a friendly name in the Name field.</li>
<li class="nl">5. Ignore any On Demand settings or check boxes.</li>
<li class="nl">6. Add the following details to the configuration, below the PrivateKey automatically generated for the client:
                <pre>
<p class="cl3f"><code class="i">--snip--</code></p>
<p class="cl3"><code class="b">Address =</code> <code class="bi">10.8.0.2</code></p>
<p class="cl3"><code class="b">DNS =</code> <code class="bi">108.61.10.10</code></p>
<p class="cl3f"><code class="b">[Peer]</code></p>
<p class="cl3"><code class="b">PublicKey =</code> <code class="bi">server_public_key</code></p>
<p class="cl3"><code class="b">AllowedIPs =</code> <code class="bi">0.0.0.0/0</code></p>
<p class="cl3l"><code class="b">Endpoint =</code> <code class="bi">server_public_ip:listening_port</code></p>
</pre>
<p class="nlp"><code>Address</code> is the IP address you want your client to have within the VPN subnet and should be different for every VPN client. <code>DNS</code> should be the IP address of the DNS server you identified in “<a class="xref" href="nsp-enoka501485-0014.xhtml#ch0706">Identify the DNS Server</a>” on <a class="xref" href="nsp-enoka501485-0014.xhtml#p85">page 85</a>. <code>PublicKey</code> is the public key you created for your Wireguard server earlier in the process. <code>AllowedIPs</code> is a setting used for <i>split tunneling</i>; traffic to and from the networks or addresses listed with this directive will be sent through the VPN tunnel, and all other traffic will go straight out and circumvent the VPN. Setting this to <code>0.0.0.0/0</code> sends all traffic from your client through the VPN. <code>Endpoint</code> is the public IP address of your VPN server, followed by the listening port you specified earlier (26535 in the example).</p>
</li>
<li class="nl">7. Save the configuration.</li>
<li class="nl">8. On the Wireguard server, stop the Wireguard service, noting that there will be downtime for any users currently connected, using the following:
                <pre>
<p class="cl3s">$ <code class="b">sudo systemctl stop wg-quick@wg0.service</code></p>
</pre>
</li>
<li class="nl">9. Open the <i>/etc/wireguard/wg0.conf</i> configuration file with a text editor:
                <pre>
<p class="cl3s">$ <code class="b">sudo nano /etc/wireguard/wg0.conf</code></p>
</pre>
</li>
<li class="nl"><span aria-label="87" class="page" epub:type="pagebreak" id="p87" role="doc-pagebreak"/>10. Add the client details to the bottom of the configuration file, keeping in mind that each peer you add will need its own [Peer] section added to this file:
                <pre>
<p class="cl3f"><code class="i">--snip--</code></p>
<p class="cl3"><code class="b">[Peer]</code></p>
<p class="cl3"><code class="b">PublicKey =</code> <code class="bi">client_public_key</code></p>
<p class="cl3l"><code class="b">AllowedIPs =</code> <code class="bi">10.8.0.2</code></p>
</pre>
<p class="nlp">This instance of <code>PublicKey</code> is the public key created for your Wireguard client by the client application. Within the <code>[Peer]</code> section of the file, <code>AllowedIPs</code> refers to the IP addresses allowed to send traffic through the VPN tunnel. Set this to the specific host IP you want your client to have on the VPN network, which must match the IP you configured for this peer in the client configuration.</p>
</li>
<li class="nl">11. Save and close the file.</li>
<li class="nl">12. Start the Wireguard service and double-check that the status says <code>active</code>:
                <pre>
<p class="cl3f">$ <code class="b">sudo systemctl start wg-quick@wg0.service</code></p>
<p class="cl3l">$ <code class="b">sudo systemctl status wg-quick@wg0.service</code></p>
</pre>
<p class="nlp">Back on your client, activate the VPN connection. Once successfully connected, ping your Wireguard server’s VPN address (such as 10.8.0.1):</p>
<pre>
<p class="cl3f">$ <code class="b">ping 10.8.0.1</code></p>
<p class="cl3">PING 10.8.0.1 (10.8.0.1): 56 data bytes</p>
<p class="cl3">64 bytes from 10.8.0.1: icmp_seq=0 ttl=57 time=43.969 ms</p>
<p class="cl3">64 bytes from 10.8.0.1: icmp_seq=0 ttl=57 time=43.969 ms</p>
<p class="cl3">64 bytes from 10.8.0.1: icmp_seq=0 ttl=57 time=43.969 ms</p>
<p class="cl3">64 bytes from 10.8.0.1: icmp_seq=0 ttl=57 time=43.969 ms</p>
<p class="cl3">--- 10.8.0.1 ping statistics ---</p>
<p class="cl3">4 packets transmitted, 4 packets received, 0.0% packet loss</p>
<p class="cl3l">round-trip min/avg/max/stddev = 43.969/43.969/43.969/0 ms</p>
</pre>
<p class="nlp">A successful result indicates your VPN connection is working between your client and server. Repeat this process for any additional clients.</p>
</li>
</ol>
</section>
<section>
<h4 class="ch" id="ch0710">Linux Client</h4>
<p class="paft">To configure a Linux client, follow these steps:</p>
<ol style="list-style-type:none">
<li class="nlf">1. Install Wireguard and resolvconf (used for DNS configuration):
                <pre>
<p class="cl3s">$ <code class="b">sudo apt install wireguard resolvconf -y</code></p>
</pre>
</li>
<li class="nl">2. Generate the client public/private key pair for the client:
                <pre>
<p class="cl3f">$ <code class="b">wg genkey | sudo tee /etc/wireguard/private.key</code></p>
<p class="cl3">$ <code class="b">sudo cat /etc/wireguard/private.key | wg pubkey | sudo tee \</code></p>
<p class="cl3l"><code class="b">     /etc/wireguard/public.key</code></p>
</pre>
</li>
<li class="nl"><span aria-label="88" class="page" epub:type="pagebreak" id="p88" role="doc-pagebreak"/>3. Create the Wireguard client configuration file:
                <pre>
<p class="cl3f">$ <code class="b">sudo nano /etc/wireguard/wg0.conf</code></p>
<p class="cl3"><code class="b">[Interface]</code></p>
<p class="cl3"><code class="b">PrivateKey =</code> <code class="bi">client_private_key</code></p>
<p class="cl3"><code class="b">Address =</code> <code class="bi">10.8.0.3</code></p>
<p class="cl3"><code class="b">DNS =</code> <code class="bi">108.61.10.10</code></p>
<p class="cl3f"><code class="b">[Peer]</code></p>
<p class="cl3"><code class="b">PublicKey =</code> <code class="bi">server_public_key</code></p>
<p class="cl3"><code class="b">AllowedIPs =</code> <code class="bi">0.0.0.0/0</code></p>
<p class="cl3l"><code class="b">Endpoint =</code> <code class="bi">server_public_ip:listening_port</code></p>
</pre>
</li>
<li class="nl">4. Save and close the file.</li>
<li class="nl">5. On the Wireguard server, stop the Wireguard service:
                <pre>
<p class="cl3s">$ <code class="b">sudo systemctl stop wg-quick@wg0.service</code></p>
</pre>
</li>
<li class="nl">6. Open the <i>/etc/wireguard/wg0.conf</i> configuration file with a text editor:
                <pre>
<p class="cl3s">$ <code class="b">sudo nano /etc/wireguard/wg0.conf</code></p>
</pre>
</li>
<li class="nl">7. Add the client details to the bottom of the configuration file:
                <pre>
<p class="cl3f"><code class="i">--snip--</code></p>
<p class="cl3"><code class="b">[Peer]</code></p>
<p class="cl3"><code class="b">PublicKey =</code> <code class="bi">client_public_key</code></p>
<p class="cl3l"><code class="b">AllowedIPs =</code> <code class="bi">10.8.0.3</code></p>
</pre>
<p class="nlp">This instance of <code>PublicKey</code> is the public key created for your Wireguard client by the client application. Within the <code>[Peer]</code> section of the file, <code>AllowedIPs</code> refers to the IP addresses allowed to send traffic through the VPN tunnel. Set this to the specific host IP you want your client to have on the VPN network.</p>
</li>
<li class="nl">8. Save and close the file.</li>
<li class="nl">9. Start the Wireguard service and double-check that the status says active:
                <pre>
<p class="cl3f">$ <code class="b">sudo systemctl start wg-quick@wg0.service</code></p>
<p class="cl3l">$ <code class="b">sudo systemctl status wg-quick@wg0.service</code></p>
</pre>
<p class="nlp">Back on your client, activate the VPN connection using the following command:</p>
<pre>
<p class="cl3s">$ <code class="b">wg-quick up wg0</code></p>
</pre>
<p class="nlp"><span aria-label="89" class="page" epub:type="pagebreak" id="p89" role="doc-pagebreak"/>Once successfully connected, ping your Wireguard server’s VPN address (such as 10.8.0.1). A successful result indicates your VPN connection is working between your client and server. To disconnect a Linux client from your VPN server, use the following command:</p>
<pre>
<p class="cl3s">$ <code class="b">wg-quick down wg0</code></p>
</pre>
<p class="nlp">Repeat this process for any additional clients you want to add.</p>
</li>
</ol>
</section>
</section>
</section>
<section>
<h2 class="ah" id="ah0705"><a class="xref" href="nsp-enoka501485-0007.xhtml#rah0705">Test Your VPN</a></h2>
<p class="paft">Regardless of which VPN you chose, find your public IP address from a website such as <a class="url-i" href="https://www.whatismyip.com/">https://www.whatismyip.com/</a> while not connected to the VPN. Once done, connect to your VPN and refresh the page. Your public IP address should now be the IP address of your VPN server. Another way to test your VPN is to use a service such as DNS leak at <a class="url-i" href="https://dnsleaktest.com/">https://dnsleaktest.com/</a>. Performing a standard test should show you clearly whether there are any issues with your VPN configuration. If your actual public IP is masked and the DNS leak test shows only the DNS servers you’ve configured the VPN to use, then you’ve been successful in setting up your own private VPN server.</p>
</section>
<section>
<h2 class="ah" id="ah0706"><a class="xref" href="nsp-enoka501485-0007.xhtml#rah0706">Summary</a></h2>
<p class="paft">Connecting multiple clients to either your OpenVPN or Wireguard servers will allow traffic to pass between them as if they were on the same network. This means you can easily manage multiple devices remotely simply by having them all connected to your VPN at the same time. This chapter covered setting up your own private VPN, which provides you with complete control, using either OpenVPN or the much lighter and faster Wireguard. Your private internet traffic will now be truly private and secure while you are connected to your VPN.</p>
</section>
</section>
</div></body></html>