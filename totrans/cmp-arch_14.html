<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><h2 class="chn"><span epub:type="pagebreak" id="page_245"/><strong>11</strong></h2>&#13;
<h2 class="cht"><strong>RETRO ARCHITECTURES</strong></h2>&#13;
<div class="image1"><img src="../images/f0245-01.jpg" alt="Image" width="252" height="252"/></div>&#13;
<p class="chq">Now that you’ve made it through the theory, let’s have some fun. <a href="part03.xhtml">Part III</a> will consolidate your theoretical knowledge by programming on a series of real, emulated architectures. It’s possible to skip around these chapters depending on your interests, but they present systems roughly in order of their complexity and history, so seeing and programming the earlier systems may help you understand the later ones.</p>&#13;
<p class="indent">We previously studied the Analytical Engine and Manchester Baby, and in this chapter we’ll progress to 1980s 8-bit and then 16-bit systems. Modern embedded systems are somewhat similar to these retro systems, so we’ll work with them in the next chapter. We’ll then look at 1990s desktop PCs, followed by modern smart and parallel architectures. At each step we’ll introduce new features that have stuck around into modern designs.</p>&#13;
<p class="indent">The basic structure of the classical CPU didn’t change very much from 1836 to 1990. The design served us well, from the Analytical Engine through what’s now known as the 1980s golden age of architectures. In this chapter, we’ll look at two designs from this golden age: the famous 8-bit 6502, as used in the Commodore 64, Nintendo Entertainment System (NES), and <span epub:type="pagebreak" id="page_246"/>BBC Micro; and the 16-bit 68000, which defined the 16-bit generation of machines, including the Commodore Amiga and Sega Megadrive. We’ll study these as relatively simple examples of classical CPUs, before things got complicated. These examples should help you to consolidate what you’ve learned in the previous chapters, so refer back to them if you need to look anything up as you go.</p>&#13;
<h3 class="h3" id="lev212">Programming in the 1980s Golden Age</h3>&#13;
<p class="noindent">Programming in the 1980s was dominated by architecture. The 1980s hardware market was highly heterogeneous, with many competing companies designing and producing different, incompatible machines. <a href="ch11.xhtml#ch11fig1">Figure 11-1</a> shows just a few of the different machines that came out over the course of the decade.</p>&#13;
<p class="indent">Instead of downloading apps, you could buy magazines full of printed assembly code that you would type out to run simple games and applications. Without modern operating systems, this code could read and write the machine’s entire memory space, so you could see exactly what was going on in your machine and be at one with its architecture.</p>&#13;
<p class="indent">Computer design companies such as Commodore could produce their own custom ROMs at much lower cost using programmable ROMS or PLAs than if they had to do their own photolithography, and these technologies were a major enabler of the multitude of home computer systems. In today’s language, these ROMs were basic input-output systems (BIOSes), collections of subroutines that, for example, print ASCII text to the screen; draw points, lines, and triangles; and make sounds. The programmer could also perform these tasks directly via I/O—that is, by loading and storing directly to I/O module addresses—but subroutines were provided for convenience to automate the process. You would call a subroutine on a ROM chip by putting the necessary arguments into CPU registers and then doing a jump to the subroutine address in the ROM.</p>&#13;
<p class="indent">ROM and RAM were equally important, and they worked together. RAM was a scarce resource for user data and user programs that made many calls to the subroutines in ROM. In addition to knowing ROM subroutine addresses by heart, programmers and communities often had conventions for favorite regions of RAM to use for different tasks, so they would generally know their way around the memory map of their whole computer.</p>&#13;
<p class="indent">Because of these conventions, users had much more direct access to their computers. The number of addresses was quite small: 32,768 (32 k<sub>2</sub>B) or 65,536 (64 k<sub>2</sub>B), and this meant you could find where variables like the number of lives in a game were stored, and then go inside the memory to edit them. Directly overwriting memory like this was called a <em>poke</em>, and successful pokes were collected onto <em>cheat disks</em> and passed around to modify games.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_247"/><img id="ch11fig1" src="../images/f0247-01.jpg" alt="Image" width="1089" height="1280"/></div>&#13;
<p class="figcap"><em>Figure 11-1: Different computers from the 1980s golden age</em></p>&#13;
<h4 class="h4" id="lev213"><span epub:type="pagebreak" id="page_248"/><em>8-Bit Era</em></h4>&#13;
<p class="noindent">The early 1980s was the 8-bit era: this was the time of the Commodore 64 and Atari 2600, games consoles like the Sega Master System and Nintendo NES, and the British machines BBC Micro and ZX Spectrum.</p>&#13;
<p class="indent">Some of these machines shared some subcomponents; for example, the 6502 was used in both the Commodore 64 and BBC Micro, and the Spectrum’s Z80 chip could be added to the BBC Micro as a second processor, so you could have friends sharing programs at this level. But the machines would have different graphics and sound chips containing different functions at different addresses that weren’t compatible, and typically each machine would have its own friends, user groups, and magazines form around it.</p>&#13;
<p class="indent">Computer graphics and music of this era looked (see <a href="ch11.xhtml#ch11fig2">Figure 11-2</a>) and sounded <em>like computers</em> because they reflected their architecture, creating a computer culture that has been lost today. You could actually feel the 8-bit-ness of an 8-bit game in a way that you don’t see 64-bit-ness in contemporary games.</p>&#13;
<div class="image"><img id="ch11fig2" src="../images/f0248-01.jpg" alt="Image" width="473" height="244"/></div>&#13;
<p class="figcap"><em>Figure 11-2: An example of typical 8-bit game graphics</em></p>&#13;
<p class="indent">Even just playing—rather than writing—games in the golden age could be subliminally educational about architecture. Games were usually written specifically to play with and explore the architecture, to push it to its limits, and to show off programming skills. For example, the 8-bit architecture encouraged games to use certain sizes of sprites and certain layouts of levels. You could animate <em>Space Invaders</em> easily by overwriting the area of memory where the <em>A</em> character was defined, replacing it with an 8×8 pixel space invader, then just print the <em>A</em> character on the screen to move it around, without needing any graphics commands. (The downside of this was that when you listed your program to debug it afterward, all the <em>A</em>s had also changed into space invaders.)</p>&#13;
<h4 class="h4" id="lev214"><span epub:type="pagebreak" id="page_249"/><em>16-Bit Era</em></h4>&#13;
<p class="noindent">The late 1980s introduced 16-bit machines and continued this style of assembly programming, but with the extra bits and more advanced I/O modules enabling a move to <em>sampling</em> of images and sounds rather than their pure computer generation, as on 8-bit machines. These developments gave rise to the distinctive 16-bit aesthetics of sprite-based games like <em>Sonic</em> and <em>Mario</em> (<a href="ch11.xhtml#ch11fig3">Figure 11-3</a>), and sample-based music by artists such as The Prodigy and the soundtracks of games such as <em>Streets of Rage 2</em>.</p>&#13;
<div class="image"><img id="ch11fig3" src="../images/f0249-01.jpg" alt="Image" width="473" height="418"/></div>&#13;
<p class="figcap"><em>Figure 11-3: An example of typical 16-bit game graphics</em></p>&#13;
<p class="indent">Popular machines included the Commodore Amiga, Atari ST, Sega Megadrive, and Nintendo SNES. High-performance programs such as games and demos were still mostly written in assembly, with full access to memory, but they would make heavier use of calls to additional graphics and sound hardware.</p>&#13;
<p class="indent">Companies continued to produce 16-bit machines into the early 1990s, including for many now-classic games. But by this time most programmers had shifted to the C language, which could compile into assembly code for multiple machines, making it easier to port software between them. Programmers came to rely more on heavyweight operating systems, also accessed primarily via C libraries. Together, C and operating systems acted to wrap and hide architecture, presenting higher-level and more portable interfaces to the machines, but ending the 1980s golden age of architecture-based programming.</p>&#13;
<p class="indent">Good times! Let’s relive them here by learning to program on two classic systems from the period, the 8-bit 6502-based Commodore 64 (C64) and the 16-bit 68000-based Commodore Amiga. For each system, we’ll first study its CPU in isolation, then its wider computer design. In the exercises, we’ll write assembly programs for a C64 animated text demo and a simple Amiga game.</p>&#13;
<h3 class="h3" id="lev215"><span epub:type="pagebreak" id="page_250"/>Working with the MOS 6502 8-Bit CPU</h3>&#13;
<p class="noindent">MOS Technology’s MOS 6502 was an 8-bit processor, designed in 1975 by Chuck Peddle. <em>MOS</em> stands for <em>metal-oxide semiconductor</em>, as in the MOS field-effect transistors, or MOSFETs, used by the company. The 6502 was used in many of the classic 8-bit micros of the 1980s: the Commodore 64, NES, Atari 2600, Apple II, and BBC Micro; it was also used in first-generation arcade machines such as <em>Asteroids</em>.</p>&#13;
<p class="indent">Here we’ll study the 6502 using the same steps as for the Analytical Engine and Manchester Baby. We’ll first examine its structures, including registers, the arithmetic logic unit (ALU), the decoder, and the control unit (CU). We’ll then look at its instruction set, including instructions for memory access, arithmetic, and control flow.</p>&#13;
<h4 class="h4" id="lev216"><em>Internal Subcomponents</em></h4>&#13;
<p class="noindent">The 6502 had 3,000 transistors and wires connecting them. The layout of these components was designed and drawn by hand on transparent sheets, with pens and masking tape, and then made directly into chips using photolithography.</p>&#13;
<p class="notes"><strong><span class="nt">NOTE</span></strong></p>&#13;
<p class="noindent"><em>The term</em> taping out <em>is still used to refer to the equivalent modern computerized process of finalizing photolithography mask designs. For chip designers, a tape-out marks the end of their work and handover to a fab plant. Like “shipping” for software companies, taping out can be a reason to have a large party, lasting until the chips arrive in the mail and fail to work.</em></p>&#13;
<p class="indenta">Physically, the 6502 appears as a plastic-packaged integrated circuit (IC) about 2 cm long, with 40 pins, as seen in <a href="ch09.xhtml#ch09fig2">Figure 9-2</a>. Eight of these are data pins, labeled D0 through D7. These pins read and write 8-bit words of data to and from memory, and they define the CPU as an 8-bit machine. The 6502 uses a 16-bit address space accessed by writing 16-bit addresses on the 16 address pins, A0 through A15. This enables up to 64 k<sub>2</sub>B to be addressed. The R/W is the control line that specifies whether we want to read or write to the address. The package also has pins for ground and supply voltage, a clock, and an IRQ (interrupt request) line. The clock sets the speed of the CPU, usually to around 1 to 3 MHz.</p>&#13;
<p class="indent">The actual silicon chip is much smaller than the outer package, about 5 mm<sup>2</sup>. <a href="ch11.xhtml#ch11fig4">Figure 11-4</a> shows a photograph of the chip under a microscope (known as a <em>die shot</em>).</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_251"/><img id="ch11fig4" src="../images/f0251-01.jpg" alt="Image" width="901" height="1001"/></div>&#13;
<p class="figcap"><em>Figure 11-4: A 6502 chip microscope photograph</em></p>&#13;
<p class="indent">Details of this chip’s design were lost for several decades, but they were recently fully reverse engineered at the transistor level in a heroic effort by the Visual 6502 project (<em><a href="http://visual6502.org">http://visual6502.org</a></em>). The workers on this project exposed the silicon by applying acid to dissolve some of the plastic casing. They then took die shots of the chip to reverse engineer its circuit diagram.</p>&#13;
<p class="indent">The circuit contains only transistors and copper wires, but some very skilled chip-reading people have learned to look at these and mentally chunk them into logic gates. From there, they were chunked into well-known simple machines. This painstaking process, guided by the surviving block diagram shown in <a href="ch11.xhtml#ch11fig5">Figure 11-5</a>, enabled the whole architecture to be reverse engineered and reconstructed.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_252"/><img id="ch11fig5" src="../images/f0252-01.jpg" alt="Image" width="905" height="1118"/></div>&#13;
<p class="figcap"><em>Figure 11-5: The original 6502 block diagram</em></p>&#13;
<p class="indent">The circuit in <a href="ch11.xhtml#ch11fig5">Figure 11-5</a> shows some recognizable subcomponents that are common to most classic-design chips. Each component is a digital logic simple machine. We’ll examine each of the main subcomponents in turn.</p>&#13;
<div class="sidebar">&#13;
<p class="stitle"><span epub:type="pagebreak" id="page_253"/><strong>THE MONSTER 6502</strong></p>&#13;
<p class="stext">As a result of the Visual 6502 project, the 6502 is now being manufactured again for use as a cheap, embedded processor—for example, in Internet of Things (IoT) devices—as well as for education, such as our present study. The design was also used by Eric Schlaepfer and Evil Mad Scientist Laboratories to create a fully functioning—but slower than the original—MOnSter 6502 rebuild from big transistors rather than ICs, shown here.</p>&#13;
<div class="imagec"><img src="../images/f0253-01.jpg" alt="Image" width="552" height="439"/></div>&#13;
</div>&#13;
<h4 class="h4a"><strong>User Registers</strong></h4>&#13;
<p class="noindent">In <a href="ch11.xhtml#ch11fig4">Figure 11-4</a> the registers and ALU are the regular area in the lower half of the chip. The 8 bits are stacked vertically, as in Babbage’s machines. There are three 8-bit user registers: two general-purpose ones called X and Y, and an accumulator called A.</p>&#13;
<p class="indent">The X and Y registers are intended to be usable together to represent 16-bit addresses, with the first 8 of the 16 bits stored in X and the second 8 bits stored in Y. It’s quite hard work to manipulate the two halves separately, so the architecture often provides methods to manipulate the two 8-bit halves of 16-bit addresses together.</p>&#13;
<p class="indent">It’s common to imagine and visualize 8-bit memory as divided into 256 pages of 256 bytes each. For example, 8-bit hex editors may display one page of memory on the screen at a time, like the pages of a book. Viewed this way, one of the two bytes is the page number and the other says what line on the page is used.</p>&#13;
<p class="notes"><strong><span class="nt">NOTE</span></strong></p>&#13;
<p class="noindent"><em>It’s common 6502 programming practice to use the 256 addresses in page 0 of memory as if they were additional registers. This is slower than using actual registers, so A, X, and Y are preferred in the first instance.</em></p>&#13;
<h4 class="h4a"><span epub:type="pagebreak" id="page_254"/><strong>Internal Registers</strong></h4>&#13;
<p class="noindent">Recall that the program counter keeps track of the current line number. Here, the program counter stores a 2 byte address. It’s automatically incremented by the CU after executing each instruction, unless it’s a flow control instruction. It can be accessed as 2 individual bytes (PCH, PCL) storing the high and low parts of the 16-bit address. On power-up, the 6502 copies the content of addresses FFFC and FFFD (usually ROM, and pointing to a ROM subroutine) into the program counter to tell it where to begin executing.</p>&#13;
<p class="indent">Here, the stack pointer is a single byte, and it’s assumed to refer to lines on page 1 of memory; note this is the second page, after page 0. In most programming styles, the stack isn’t accessed directly by the programmer, but rather is used internally by the subroutine instructions to push and pop the address of the calling line. However, it can also be accessed directly using instructions (<code>PHA</code> and <code>PLA</code>) that push and pop the contents of the accumulator to and from the stack.</p>&#13;
<p class="indent">The instruction register holds a copy of the current instruction; in the 6502, opcodes are 8 bits long and may require 0, 1, or 2 bytes of operand. Because the data bus is 8-bit, fetching instructions usually requires several steps; the opcode and operand need to be copied in one byte at a time. This is one of the reasons why 8-bit machines are slow: machines with larger word lengths could fetch whole instructions, including opcodes and operands, as single words.</p>&#13;
<p class="indent">The status register holds 8 bits of flags that can be tested and used by control flow instructions. These are set in the ALU, which we’ll turn to next.</p>&#13;
<h4 class="h4a"><strong>Arithmetic Logic Unit</strong></h4>&#13;
<p class="noindent">In the 6502, the ALU is physically built around the registers so that the 8 bits flow horizontally, as in Babbage’s machines. The registers-ALU area looks a lot like Babbage’s Difference Engine, and contains a similar parallel propagation of bits and carries. If you miniaturized Babbage’s metal machine onto a chip, this is pretty much what it would look like; only the scale has changed.</p>&#13;
<p class="indent">The ALU provides integer addition and subtraction simple machines, activated by instructions (<code>ADC</code>, <code>SBC</code>), along with dedicated increment and decrement (<code>INC</code>, <code>DEC</code>). There are bitshifts and bitwise Boolean instructions (<code>ASL,</code> <span epub:type="pagebreak" id="page_255"/><code>ASR; AND, ORA, EOR</code>). There are no multiplication or division instructions—these must be constructed in software from what’s available. There is also no floating point.</p>&#13;
<p class="indent"><a href="ch11.xhtml#ch11fig6">Figure 11-6</a> shows the ALU’s assigned meanings of the bits in the status register, which are written as side effects of its operations.</p>&#13;
<div class="image"><img id="ch11fig6" src="../images/f0255-01.jpg" alt="Image" width="371" height="227"/></div>&#13;
<p class="figcap"><em>Figure 11-6: The status register flags</em></p>&#13;
<p class="indent">The ALU’s operations include flagging if the result was zero (Z) or negative (N), if there was an overflow (V), and if there was a carry (C).</p>&#13;
<h4 class="h4a"><strong>Decoder</strong></h4>&#13;
<p class="noindent">In <a href="ch11.xhtml#ch11fig4">Figure 11-4</a>, the decoder is visible in the upper one-fifth of the die shot as a semi-regular binary structure. It looks like a load of binary numbers stored in an array, which is pretty much what it is. Opcodes are 8 bits, meaning that 256 distinct instructions are possible. Each opcode is decoded and used to activate a control line.</p>&#13;
<h4 class="h4a"><strong>Control Unit</strong></h4>&#13;
<p class="noindent">In <a href="ch11.xhtml#ch11fig4">Figure 11-4</a>, the CU forms the middle region of the chip. It appears visually as a highly irregular region. This is because every operation is different, so it’s implemented with entirely different circuitry. The 6502 CU often needs to do more work than later 16-bit machines, because the 6502 operates with 16-bit address and sometimes 16- or 24-bit instructions, which the CU has to break up into 8-bit chunks and marshal over the 8-bit bus.</p>&#13;
<h4 class="h4" id="lev217"><em>Programmer Interface</em></h4>&#13;
<p class="noindent"><a href="ch11.xhtml#ch11fig7">Figure 11-7</a> shows the complete instruction set for the 6502.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_256"/><img id="ch11fig7" src="../images/f0256-01.jpg" alt="Image" width="1121" height="755"/></div>&#13;
<p class="figcap"><em>Figure 11-7: The complete 6502 instruction set. For full definitions of these instructions, see</em> <a href="https://en.wikibooks.org/wiki/6502_Assembly">https://en.wikibooks.org/wiki/6502_Assembly</a>.</p>&#13;
<p class="indent">Because opcodes are 8-bit, there’s space for 256 instructions; notice, though, that the instruction set architecture contains a few less, so there are some gaps in the table.</p>&#13;
<h4 class="h4a"><strong>Load and Store</strong></h4>&#13;
<p class="noindent">Loading (<code>LD</code>) to and storing (<code>ST</code>) from the three user registers (X, Y, and A) is done using instructions such as:</p>&#13;
<pre>LDA #$00  ; load to accumulator the constant 8-bit hex integer 00&#13;
STA $0200 ; store accumulator contents to 16-bit hex address 0200&#13;
LDX $0200 ; load contents of address 0200 to register X&#13;
STX $0201 ; store contents of X into address 0201&#13;
LDY #$03  ; load 8-bit constant hex 03 to register Y&#13;
STY $0202 ; store contents of Y to address 0202</pre>&#13;
<p class="noindent">Offset addressing enables the value of a user register to be used as an offset to a given address. This is useful for iterating over arrays. For example:</p>&#13;
<pre>LDX #$01&#13;
STA $0200,X ; store the value of A at memory location $0201</pre>&#13;
<p class="noindent">Indirect addressing allows us to specify an address that in turns holds another address where we actually want to load or store:</p>&#13;
<span epub:type="pagebreak" id="page_257"/>&#13;
<pre>LDA ($c000) ; load to A from the address stored at address C000</pre>&#13;
<p class="noindent">Indirection and offsetting can be used together, such as:</p>&#13;
<pre>LDA ($01),Y</pre>&#13;
<p class="indent"><em>Zero-paging</em> is the 6502 convention that page 0 of memory is intended to function similarly to 256 additional registers. This requires specifying and moving around only 1 byte of address, as in:</p>&#13;
<pre>LDA $12   ; single byte address assumed to be from page 0</pre>&#13;
<p class="noindent">This is faster than moving 2 bytes around individually.</p>&#13;
<h4 class="h4a"><strong>Arithmetic</strong></h4>&#13;
<p class="noindent">The <code>ADC</code> instruction means “add data with carry.” It adds the integer contents of its address operand, and the carry bit from the status register, to the accumulator. The following program should end with hex value 0A<sub>16</sub> (decimal 10) in the accumulator:</p>&#13;
<pre>CLC       ; clear content of carry flag in status register&#13;
LDA #$07  ; load constant 07 to accumulator&#13;
STA $0200 ; store content of accumulator to address 0200&#13;
LDA #$03  ; load constant 03 to accumulator&#13;
ADC $0200 ; add with carry the content of 0200 into accumulator</pre>&#13;
<p class="noindent"><code>CLC</code> clears the carry flag; it’s important to do this before any new addition, unless you want the carry from a previous operation to get added in as well.</p>&#13;
<p class="indent">To add two 16-bit integers, we can make use of the carry status flag state, instead of clearing it. Each <code>ADC</code> reads and writes it, so we can split a 16-bit addition into a pair of two 8-bit additions with a carry. Here, the two inputs, <code>num1</code> and <code>num2</code>, and the output, <code>result</code>, are each split into low and high bytes:</p>&#13;
<pre>CLC&#13;
LDA num1_low&#13;
ADC num2_low&#13;
STA result_low&#13;
LDA num1_high&#13;
ADC num2_high&#13;
STA result_high</pre>&#13;
<p class="indent">Similarly, <code>SBC</code> is “subtract with carry,” so the following computes 7 – 3, resulting in the value 4 in the accumulator:</p>&#13;
<pre>SEC       ; set carry flag to 1 (needed to init subtraction)&#13;
LDA #$03  ; load constant 3 to accumulator&#13;
STA $0200 ; store constant 3 to address 0200&#13;
LDA #$07  ; load constant 7 to accumulator&#13;
SBC $0200 ; subtract content of 0200 from accumulator</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_258"/>We can increment (<code>INC</code> or <code>IN</code>) and decrement (<code>DEC</code> or <code>DE</code>) both address and register contents with instructions such as:</p>&#13;
<pre>LDX #$02&#13;
LDY #$04&#13;
INX&#13;
DEY&#13;
LDA #$07&#13;
STA $0200&#13;
INC $0200&#13;
DEC $0200</pre>&#13;
<p class="noindent">Here again, # denotes that the operand is a constant, with the other operands being addresses.</p>&#13;
<h4 class="h4a"><strong>Jump and Branches</strong></h4>&#13;
<p class="noindent"><code>JMP</code> is the jump instruction. The following program continually increments register X, which will overflow after FF<sub>16</sub>, going back to 00<sub>16</sub>:</p>&#13;
<pre>LDX #$02&#13;
mylabel:&#13;
  INX&#13;
  JMP mylabel</pre>&#13;
<p class="indent">Instead of specifying the line number to jump to—as a BASIC programmer of the era might—this notation first marks the destination line with a <em>label</em>—in this case, <code>mylabel</code>—then specifies the name of this label in the jump instruction. The label line doesn’t compile to machine code; it’s ignored when first seen by the assembler. But when the assembler sees the label again in the jump instruction, it replaces it with the address of the instruction following the label.</p>&#13;
<p class="indent">Conditional branching can be done in two stages. First, comparison instructions check if some condition is true and store the result in the status register. Then, branch instructions consult the status register to decide when to branch. For example, the following uses register X to count down from 5 to 2 then halt, by comparing X to 2 (<code>CPX</code>) and branching if the comparison isn’t equal (<code>BNE</code>):</p>&#13;
<span epub:type="pagebreak" id="page_259"/>&#13;
<pre>LDX #$05&#13;
mylabel:&#13;
  DEX&#13;
  CPX #$02&#13;
  BNE mylabel</pre>&#13;
<p class="indent">You can also branch (<code>B</code>) if the comparison was equal (<code>BEQ</code>), negative (on minus, <code>BMI</code>), or positive (on plus, <code>BPL</code>). Or if the carry (<code>C</code>) or overflow (<code>V</code>) flag is clear (<code>C</code>) or set (<code>S</code>): <code>BCC</code>, <code>BVC</code>, <code>BCS</code>, <code>BVS</code>, respectively.</p>&#13;
<h4 class="h4a"><strong>Subroutines</strong></h4>&#13;
<p class="noindent"><code>JSR</code> and <code>RTS</code> jump to and return from a subroutine, respectively. For example, the following program uses a common convention of placing arguments for a subroutine into addresses at the start of memory, which are then picked up by the subroutine code. <code>BRK</code> is “break,” roughly the 6502’s halt instruction (actually an interrupt). It’s needed to prevent the main program execution overrunning into the code of the subroutine after it.</p>&#13;
<pre>LDA #$5    ; load first argument to accumulator&#13;
STA $0001  ; put it in address 1 for sub to pick up&#13;
LDA #$4    ; load second argument to accumulator&#13;
STA $0002  ; put it in address 2 for sub to pick up&#13;
JSR mysub  ; call the subroutine&#13;
STA $0200  ; use subroutine's result, is in accumulator&#13;
BRK        ; halt&#13;
mysub:&#13;
  LDA #$00   ; reset the accumulator&#13;
  CLC        ; reset the carry&#13;
  ADC $0001  ; add in the first argument&#13;
  ADC $0002  ; add in the second argument&#13;
  RTS        ; return from subroutine</pre>&#13;
<p class="indent">In the exercises, you’ll see how to run the above and similar examples on an emulated standalone 6502. A 6502 by itself isn’t very exciting, though. We need a computer design to add memory and I/O to the CPU, so now let’s zoom out from the 6502 and look at a complete computer design, the Commodore 64, based upon it.</p>&#13;
<h3 class="h3" id="lev218"><span epub:type="pagebreak" id="page_260"/>8-Bit Computer Design with the Commodore 64</h3>&#13;
<p class="noindent">The 6502-based Commodore 64, or C64, was and still is the highest-selling computer model of all time. Released in 1982, it defined the 8-bit home computing market in most of the world by combining gaming features with the potential for business and creative applications. Commodore was so named because its founder, the colorful Holocaust survivor Jack Tramiel, originally wanted “General Computers,” like “General Electric,” but “General” was taken. Commodore is a lower, second-choice rank below general. The C64 board was shown previously in <a href="ch09.xhtml#ch09fig1">Figure 9-1</a>. Its name comes from the fact that it used the full 64 k<sub>2</sub>B of available memory from its 16-bit address space with 8-bit words (2<sup>16</sup> addresses × 8 bits = 64 k<sub>2</sub>B), unlike some other 6502-based machines.</p>&#13;
<h4 class="h4" id="lev219"><em>Understanding the Architecture</em></h4>&#13;
<p class="noindent">MOS produced several variants of the 6502 and assigned different model numbers to each. As with 7400 logic chips, “6502” is thus ambiguous, sometimes used to mean the original, numbered CPU design, and other times referring to all members of the family, which each have related numbers. The 6502 family member used in the Commodore 64 is more precisely known as the 6510.</p>&#13;
<p class="indent">In addition to a full 64 k<sub>2</sub>B of actual RAM, the C64 also added devices, I/O modules, and their own ROMs containing libraries of subroutines for talking to them (what we now call a BIOS). It’s this configuration that differentiates the C64 from other 6502-based machines as a programming platform.</p>&#13;
<p class="indent">The physical board layout is connected as in the block diagram of <a href="ch11.xhtml#ch11fig8">Figure 11-8</a>. The bus—consisting of 16-bit addressing and 8-bit data—dominates this diagram and connects the CPU, RAM, ROM, and I/O.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_261"/><img id="ch11fig8" src="../images/f0261-01.jpg" alt="Image" width="910" height="1203"/></div>&#13;
<p class="figcap"><em>Figure 11-8: A C64 block diagram</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_262"/><a href="ch11.xhtml#ch11fig9">Figure 11-9</a> shows the memory map for the C64.</p>&#13;
<div class="image"><img id="ch11fig9" src="../images/f0262-01.jpg" alt="Image" width="835" height="563"/></div>&#13;
<p class="figcap"><em>Figure 11-9: A C64 memory map</em></p>&#13;
<p class="indent">In this memory map, the RAM, ROM, and I/O are each assigned address ranges within the 16-bit address space. The I/O address space is broken down into ranges used by individual I/O modules and chips. (Because address space was a scarce resource at this time, the C64 enables the programmer to temporarily disconnect the ROMs from it and mount additional RAM in their place.)</p>&#13;
<div class="sidebar">&#13;
<p class="stitle"><strong>PETSCII CHARACTERS</strong></p>&#13;
<p class="stext">The Commodore 64 extended ASCII differently from Unicode, into a now dead branch of evolution called PETSCII, by using the first digit as a “shift” character and defining a second set of ASCII-like symbols. It also defined new visual symbols in the unshifted sector in place of control codes, including the C64’s iconic playing card symbols and bitmap graphic elements used for drawing and shown here.</p>&#13;
<div class="imagec"><img src="../images/f0262-02.jpg" alt="Image" width="788" height="269"/></div>&#13;
</div>&#13;
<h4 class="h4" id="lev220"><span epub:type="pagebreak" id="page_263"/><em>Programming the C64</em></h4>&#13;
<p class="noindent">Programming the C64 is done in 6502 assembly as discussed in the “Programmer Interface” section on <a href="ch11.xhtml#lev217">page 255</a>, but with added interactions with the particular ROMs and I/O modules mounted in the address space. The ROMs contain libraries of Commodore’s own subroutines (known as “KERNAL,” with an A). I/O includes a memory-mapped screen display that can be switched between character and pixel modes. Character mode allows PETSCII characters to be drawn at screen locations by writing their codes directly into this memory space. The state of the keyboard can be read by reading its memory-mapped space, but ROM subroutines are provided to simplify this process and decode its state to PETSCII character codes.</p>&#13;
<p class="indent">The following program illustrates these structures. It displays a scrolling message on a colored screen, and exits when the A key is pressed.</p>&#13;
<pre>screenbeg = $0400           ; const, beginning of screen memorymap&#13;
screenend = $07E7           ; const, end of screen memorymap&#13;
screenpos = $8000           ; variable, current position in screen&#13;
main:&#13;
    LDA #$02                ; black color code&#13;
    STA $D020               ; I/O border color&#13;
    STA $D021               ; I/O background color&#13;
    STA screenpos           ; screen position&#13;
loop:                       ; main game loop, once per frame&#13;
    JSR $E544               ; ROM routine, clears screen&#13;
    JSR drawframe           ; most of the work is done here&#13;
    JSR check_keyboard&#13;
    INC screenpos           ; increment current screen position&#13;
    JMP loop                ; do the loop, forever&#13;
drawframe:&#13;
    LDX #$00                ; regX tracks idx of char in the string&#13;
    LDY screenpos           ; regY keeps scrolling screen position&#13;
    CPY #$20                ; compare Y with constant 20&#13;
    BCS resetscreenpos      ; branch if Y&gt;20 (stored in carry bit)&#13;
drawmsgloop:                ; drop through to here if not branching&#13;
    LDA msg,X               ; load the xth char of the message&#13;
    BEQ return              ; exit when zero char (end of string)&#13;
    AND #$3F                ; convert ASCII to PETSCII&#13;
    STA screenbeg,Y         ; VDU: write char in A to memorymap offset Y&#13;
    INX                     ; increment idx of char in message&#13;
    INY                     ; increment location on screen&#13;
    CPY #$20                ; are we trying to write offscreen?&#13;
    BCS wraparound_y        ; if so, shift offset by screen width&#13;
    JMP drawmsgloop         ; loop (until all chars are done)&#13;
resetscreenpos:&#13;
    LDY #$00&#13;
    STY screenpos           ; reset the screenpos to 0&#13;
    JMP drawmsgloop&#13;
wraparound_y:               ; if Y trying to write off screen, wrap&#13;
    TYA                     ; transfer Y to accumulator&#13;
    SBC #$20                ; subtract with carry&#13;
    TAY                     ; transfer accumulator to Y&#13;
    JMP drawmsgloop&#13;
check_keyboard:&#13;
    JSR $FF9F               ; ROM SCANKEY IO, writes keybdmatrix to 00CB&#13;
    JSR $FFE4               ; ROM GETIN, convert matrix to keycode in acc&#13;
    CMP #65                 ; compare accumulator to ASCII 'A'&#13;
    BNE return&#13;
    BRK                     ; if 'A' pressed, quit&#13;
return:&#13;
    RTS&#13;
msg:&#13;
    .byte "HELLO C64!\0"    ; this is data, not an instruction</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_264"/>This creates a scrolling text result, as in <a href="ch11.xhtml#ch11fig10">Figure 11-10</a>.</p>&#13;
<div class="image"><img id="ch11fig10" src="../images/f0264-01.jpg" alt="Image" width="631" height="416"/></div>&#13;
<p class="figcap"><em>Figure 11-10: The hello C64 result. The text scrolls across the screen.</em></p>&#13;
<p class="indent">The program can be used as the starting point for writing a game, as it includes all of the basic game elements: a loop, display, keyboard read, and state update.</p>&#13;
<div class="sidebar">&#13;
<p class="stitle"><span epub:type="pagebreak" id="page_265"/><strong>CHIPTUNES</strong></p>&#13;
<p class="stext">In the 8-bit era, the sound chip was a genuine synthesizer, an actual musical instrument made in hardware and placed inside the computer.</p>&#13;
<p class="stext">The simplest way to generate tones is to use square waves. This is how a non-musician architect would go about building a sound chip, such as the Texas Instruments SN76489. Square waves alternate at a given frequency (musical pitch) between a digital 0 and 1, so they can be made entirely from digital logic rather than requiring the analog voltages that would be needed to make other waveforms. Limiting chips to square waves gave devices of the era their characteristic, primitive 8-bit sound.</p>&#13;
<p class="stext">As Commodore had bought MOS, they used MOS’s latest tone generator, the 6581 Sound Interface Device (SID), in the C64. SID was far superior to previous sound chips. It was designed as a real musical instrument, by a musical synthesizer designer. It added analog sawtooth and sine waves into the mix, and revolutionized 8-bit audio by adding analog filters to these waves. Filters emphasize or mute bands of harmonics in a musical signal. Both square and sawtooth waves have infinite harmonics, which provide good raw material for filters to act upon. Filters can be swept over notes in many different ways to create many effects, and this gave the C64 its large musical palette.</p>&#13;
<p class="stext">SID contains the analog device and an I/O module that interfaces it to the address space, so it attaches to the bus. In the C64, it’s controlled by writing parameters such as frequencies, volumes, and filter cutoffs to its assigned address space, D400 to D7FF, as in the following example, which plays a square wave on channel 1:</p>&#13;
<pre>main:&#13;
    LDA #$0F&#13;
    STA $D418 ; I/O SID volume&#13;
    LDA #$BE  ; attack duration = B, decay duration = E&#13;
    STA $D405 ; I/O SID ch1 attack and decay byte&#13;
    LDA #$F8  ; sustain level = F, release duration = 8&#13;
    STA $D406 ; I/O SID ch1 sustain and release byte&#13;
    LDA #$11  ; frequency high byte = 11&#13;
    STA $D401 ; I/O SID ch1 frequency high byte&#13;
    LDA #$25  ; frequency low byte = 25&#13;
    STA $D400 ; I/O SID ch1 frequency low byte&#13;
    LDA #$11  ; id for square wave waveform&#13;
    STA $D404 ; I/O SID ch1 ctl register&#13;
loop:&#13;
    JMP loop</pre>&#13;
<p class="stext">After SID’s release, the great 8-bit “chiptune” composers such as Rob Hubbard found highly creative ways to hack it to play samples and to appear to have many more voices than the three it had in hardware. SID presented a limited and constrained palette, encouraging minimalist, mathematical aesthetics. Hubbard was influenced by Philip Glass, Jean-Michel Jarre, and Kraftwerk. More recently, music producers in the 2010s, such as Max Martin and Dr. Luke, have used SID for its retro gaming sound.</p>&#13;
</div>&#13;
<h3 class="h3" id="lev221"><span epub:type="pagebreak" id="page_266"/>Working with the Motorola 68000 16-Bit CPU</h3>&#13;
<p class="noindent">The 16-bit era is somewhat misnamed: it should have been the “16/32-bit era.” This is because the defining chip of the era was the Motorola 68000, used in the Commodore Amiga, Atari ST, Apple Macintosh, and Sega Megadrive, as well as in arcade machines such as <em>Street Fighter II</em>. The 68000 used 16-bit data words, but also had 32-bit registers and an ALU inside the CPU. The Atari ST’s name refers to this hybrid “<em>S</em>ixteen/<em>T</em>hirty-two” nature of the 68000. Also known as the 68k, the 68000 was released in 1979 and appeared in computers in the later 1980s to define the 16-bit era.</p>&#13;
<p class="indent">Both the 6502 and 68000 descended from the earlier Motorola 6800, in separate branches of evolution. Their names reflect this, and they share some structures and instructions. This means that learning the 68000 is often an extension of what we learned about the 6502. If you’re unsure of how to do something in the 68000, you can often make a good guess based on the 6502 equivalent.</p>&#13;
<h4 class="h4" id="lev222"><em>Internal Subcomponents</em></h4>&#13;
<p class="noindent"><a href="ch11.xhtml#ch11fig11">Figure 11-11</a> shows a die shot of the Motorola 68000. In the figure, you can see the same basic structure as in the 6502, with the registers and ALU at the bottom, control logic in the center, and decoder near the top.</p>&#13;
<div class="image"><img id="ch11fig11" src="../images/f0266-01.jpg" alt="Image" width="709" height="801"/></div>&#13;
<p class="figcap"><em>Figure 11-11: A 68000 die shot</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_267"/>You can see that the registers and ALU section now has more repeated rows due to having more than 8 bits. Unlike the 6502, the digital logic is now too small to see when the whole CPU is shown on a printed page.</p>&#13;
<p class="indent">There are 16 user registers, all 32-bit, of which 8 are called D0 to D7 for “data registers,” and the others are called A0 to A7 for “address registers.” A7 is used as the stack pointer. There’s a 16-bit status register containing similar status bits to the 6502, and some extra information.</p>&#13;
<p class="indent">The bus has 16 data lines and 24 address lines. The addresses, however, refer to locations of bytes rather than 16-bit words, so there are 2<sup>24</sup> addressable bytes, which is 16 M<sub>2</sub>B of addressable memory. The 24-bit addresses are written as six hex characters, such as DFF102<sub>16</sub>.</p>&#13;
<p class="indent">The 68000 has a two-stage pipeline that fetches the next instruction while simultaneously decoding and executing the current one.</p>&#13;
<h4 class="h4" id="lev223"><em>Programmer Interface</em></h4>&#13;
<p class="noindent">As we’ve done for other machines, having seen the structure of the 68000 we’ll now examine the instruction set that it enables—via memory access, arithmetic, and flow control—and that you can use to write your own programs. The 16-bit era saw a widespread shift from the use of upper- to lowercase characters in programming, which we’ll respect from here onward.</p>&#13;
<h4 class="h4a"><strong>Data Movement</strong></h4>&#13;
<p class="noindent">A single <code>move</code> instruction is used for load, store, and register data transfers:</p>&#13;
<pre>move.l d0, d1         ; copy from register d0 to register d1&#13;
move.l #$1a2, d1      ; copy hex constant $1a2 to register d1&#13;
move.l $0a3ff24, d1   ; load longword from address 0a3ff24 to d1&#13;
move.l d1, $0a3ff24   ; store longword from d1 to address 0a3ff24</pre>&#13;
<p class="noindent">The <code>l</code> here stands for “longword” and moves 32 bits at a time. This is fast between registers. When accessing memory, the 32 bits must be split up by the CPU and sent over the 16-bit bus in two steps, sequenced by the CU.</p>&#13;
<p class="indent">If you only want to move 16-bit words (<code>w</code>) or 8-bit bytes (<code>b</code>) around, you can use variants of <code>move</code>:</p>&#13;
<pre>move.b d0, d1&#13;
move.w $0a3ff24, d1</pre>&#13;
<p class="indent">Indirect addressing is specified using parentheses:</p>&#13;
<pre>move.l ($0a3ff24), d1  ; load content from addr stored at addr 0a3ff24, to d1</pre>&#13;
<p class="noindent">Offset addressing includes the following:</p>&#13;
<pre>move.l (pc, 2), d1      ; load content from program counter plus 2&#13;
move.l (a1, a2), d1     ; load content from addr formed as sum of regs a1+a2&#13;
move.l (a1, a2, 2), d1  ; load content from addr formed as sum of regs a1+a2+2</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_268"/>A more complicated and unusual 68000 addressing mode combines indirect addressing with register incrementation; this is useful for iterating over data stored in contiguous addresses:</p>&#13;
<pre>move.l (a1)+, d1        ; load content from addr stored in register a1, to d1,&#13;
                        ; then increment a1 by number of bytes in a longword&#13;
move.l -(a1), d1        ; decrement a1 by number of bytes in a longword,&#13;
                        ; then load content from addr stored in register a1</pre>&#13;
<p class="noindent">For C programmers: this is roughly what <code>*(a++)</code> and <code>*(--a)</code> would compile into. Pushing and popping the stack doesn’t need dedicated instructions because it can be done using this mode with the stack pointer register:</p>&#13;
<pre>move.w (sp)+, d0       ; push from register d0 to stack&#13;
move.w d0, -(sp)       ; pop from stack to register d0</pre>&#13;
<p class="indent">Load effective addresses (<code>lea</code>) is a related 68000 instruction that can load the address of indirections. For example:</p>&#13;
<pre>lea (pc, 2), a1     ; put address of program counter +2 bytes into a1&#13;
lea (a1, 2), a3     ; put address a1+2 into a3&#13;
lea (a1, a2, 2), a3 ; put address a1+a2+2 into a3</pre>&#13;
<p class="noindent">Note that <code>lea</code> loads the numerical address itself, rather than the content of the address.</p>&#13;
<h4 class="h4a"><strong>Flow Control</strong></h4>&#13;
<p class="noindent">Due to their shared history, jumps, subroutines, and branches on the 68000 are the same as on the 6502. For example:</p>&#13;
<pre>start:&#13;
   jsr mysub        ; jump to subroutine&#13;
&#13;
   cmp #2, d0       ; compare values&#13;
   beq mylabel      ; branch if equal&#13;
   ble start        ; branch if less than or equal&#13;
   bne start        ; branch if not equal&#13;
&#13;
mylabel:&#13;
   jmp mylabel      ; infinite loop&#13;
&#13;
mysub:&#13;
   rts              ; return from subroutine</pre>&#13;
<p class="indent">That said, stack logic improved: with the 68000 you can push a series of arguments to the stack, make a jump to a subroutine, and pop them off from inside the subroutine. This allows subroutines to behave like functions with parameters.</p>&#13;
<h4 class="h4a"><span epub:type="pagebreak" id="page_269"/><strong>Arithmetic</strong></h4>&#13;
<p class="noindent">Here are some examples of arithmetic instructions:</p>&#13;
<pre>add.b d0, d4  ; add d0 to d4, store result in d4&#13;
sub.w #43, d4 ; subtract constant 43 from d4, store result in d4&#13;
muls d0, d4   ; multiply (signed) d0 with d4, store result in d4&#13;
mulu d0, d4   ; multiply (unsigned) d0 with d4, store result in d4&#13;
divs d0, d4   ; divide (signed) d0 by d4, store result in d4&#13;
divu d0, d4   ; divide (unsigned) d0 by d4, store result in d4&#13;
and d0, d1    ; bitwise and d0 with d1, store result in d1&#13;
asr d0, d1    ; arithmetic shift right d1 by d0 bits, store result in d1</pre>&#13;
<p class="indent">The addition and subtraction instructions are similar to those for the 6502. But unlike the 6502, the 68000 can perform multiplication and division in hardware.</p>&#13;
<h3 class="h3" id="lev224">16-Bit Computer Design with the Commodore Amiga</h3>&#13;
<p class="noindent"><em>Amiga</em> is the feminine of <em>amigo</em>, meaning <em>friend</em>, and Commodore’s 1985 Amiga was intended to have that kind of relationship with its users. Early versions of the Amiga were intended as high-end graphics workstations and marketed to self-described “creatives”—the market now targeted by Apple. However, the now-classic A500 model rapidly became a standard mass-market gaming platform. This became self-fulfilling as both developer and gamer populations increased together. Growth was accelerated by the ease of (illegally) cracking and copying game disks, with bars in many towns around the world hosting “Amiga nights” where they were traded. In Europe, the Amiga was adopted by the “demo scene,” a subculture of artistic assembly programmers who met up to compete at pushing the graphics and sound to their limits, not in games but in multimedia demonstrations. These scenes overlapped, with crackers adding demos to the boot sequences of newly cracked games (those with the copy-protection removed). Commodore management ignored all this and tried to push the Amiga in the business market, where it and the company were destroyed by beige-box PCs.</p>&#13;
<h4 class="h4a"><strong>Understanding the Architecture</strong></h4>&#13;
<p class="noindent">The classic A500 had 0.5 M<sub>2</sub>B of RAM, though it and its successors were upgradable to a few mebibytes. (This was still much smaller than the 16 M<sub>2</sub>B addressable by the CPU.) <a href="ch11.xhtml#ch11fig12">Figure 11-12</a> shows the A500 mainboard.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_270"/><img id="ch11fig12" src="../images/f0270-01.jpg" alt="Image" width="857" height="483"/></div>&#13;
<p class="figcap"><em>Figure 11-12: An Amiga A500 mainboard</em></p>&#13;
<p class="indentb">The design was based around four large custom chips, given human names:</p>&#13;
<p class="block2"><strong>Agnus</strong> This chip contained a coprocessor (“copper”) with its own separate RAM and bus, in addition to the main CPU system. The copper was responsible for graphics. Machine code for the copper could be written as data lines and sent to the copper as data by the main CPU program. (A similar system is used today in GPUs.) Agnus also contained a DMA-based “blitter,” used for copying sprites onto video RAM without CPU.</p>&#13;
<p class="block2"><strong>Paula</strong> This chip contained a sound device and its I/O module, as well as several other I/O modules, such as for disks and communications ports. It used DMA to read audio samples and other I/O data from RAM without CPU intervention.</p>&#13;
<p class="block2"><strong>Denise</strong> This was the VDU chip, reading sprites and bitplanes from RAM, compositing them together under various screen modes, and outputting CRT display controls.</p>&#13;
<p class="block2"><strong>Gary</strong> This was a memory controller, translating and routing addresses from the bus to particular chips and addresses within them.</p>&#13;
<p class="indenta">The A500 BIOS (called Kickstart) provides subroutines for accessing I/O, such as graphics and sound. It comes on a chip usually described as a ROM but that is more correctly considered an I/O module. This is because, unlike the C64 BIOS, these subroutines aren’t mounted into address space directly. Instead, they’re stored on a part of the chip that isn’t directly addressed. When a subset (library) of the subroutines is needed, a command is sent to the smaller, addressed part of the chip to copy them into a new location in RAM.</p>&#13;
<p class="indent">The whole computer was synchronized to the clock rate of the TV CRT scan display, meaning that it (and its games) ran at different speeds in the UK and US due to their different TV standards!</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_271"/>The Amiga was designed as a multimedia machine, and a fundamental requirement, especially for the 16-bit games of the time, was to quickly draw sprites—small images such as game characters—that are overlaid onto backgrounds to build up a scene.</p>&#13;
<p class="indent">A naive method to draw sprites is to store a primary copy of the sprite at a fixed location in RAM, then write a subroutine in assembly language to copy each pixel one at a time to a parameterized location in video RAM. However, this is very slow because every pixel in the sprite then needs to be loaded into the CPU and written out again to video RAM in sequence.</p>&#13;
<p class="indent">“Blitting” was a famous use of DMA in the Amiga copper to render sprites more efficiently. The copper could be commanded by the CPU to initiate a complete sprite “blit” by DMA. It would then read the sprite (or blitter object, “bob”) pixel by pixel from its location in regular RAM, and copy it into video RAM without any further CPU intervention.</p>&#13;
<p class="indent">“Hardware sprites” were a second method, in which the primary copy of the sprite was loaded into the VDU at the start of a game. The VDU contained its own dedicated digital logic to implement similar blitting commands internally. There were severe memory limits inside the VDU, allowing only eight hardware sprites, which could often be used for the animation frames of a main character in a game or for the mouse pointer symbol.</p>&#13;
<p class="indent">For backdrops of 2D games, “playfields” are another hardware acceleration, which allow backdrop images to be stored and scrolled around. Several can be overlaid with transparency masks to create parallax effects.</p>&#13;
<h4 class="h4a" id="ch11lev2sec1"><strong>Programming the Amiga</strong></h4>&#13;
<p class="noindent">The following is a short program that displays a spaceship sprite on the screen:<span epub:type="pagebreak" id="page_272"/><span epub:type="pagebreak" id="page_273"/></p>&#13;
<pre>custom      equ   $dff000     ; custom chips&#13;
bplcon0     equ   $100        ; bitplane control register 0 (misc, control bits)&#13;
bplcon1     equ   $102        ; bitplane control register 1 (horizontal, scroll)&#13;
bplcon2     equ   $104        ; bitplane control register 2 (priorities, misc)&#13;
bpl1mod     equ   $108        ; bitplane modulo&#13;
ddfstrt     equ   $092        ; data-fetch start&#13;
ddfstop     equ   $094        ; data-fetch stop&#13;
diwstrt     equ   $08E        ; display window start&#13;
diwstop     equ   $090        ; display window stop&#13;
copjmp1     equ   $088        ; copper restart at first location&#13;
cop1lc      equ   $080        ; copper list pointer&#13;
dmacon      equ   $096        ; DMA controller&#13;
sprpt       equ   $120        ; sprite pointer&#13;
&#13;
COLOR00     equ   $180        ; address to store COLOR00 (background)&#13;
COLOR01     equ   COLOR00+$02 ; address to store COLOR01 (foreground)&#13;
COLOR17     equ   COLOR00+$22 ; etc&#13;
COLOR18     equ   COLOR00+$24&#13;
COLOR19     equ   COLOR00+$26&#13;
BPL1PTH     equ   $0E0        ; bitplane 1 pointer hi byte&#13;
BPL1PTL     equ   BPL1PTH+$02 ; bitplane 1 pointer lo byte&#13;
SPR0PTH     equ   sprpt+$00   ; sprite0 pointer, hi byte&#13;
SPR0PTL     equ   SPR0PTH+$02 ; sprite0 pointer, lo byte&#13;
SPR1PTH     equ   sprpt+$04   ; sprite1 etc&#13;
SPR1PTL     equ   SPR1PTH+$02&#13;
SPR2PTH     equ   sprpt+$08&#13;
SPR2PTL     equ   SPR2PTH+$02&#13;
SPR3PTH     equ   sprpt+$0C&#13;
SPR3PTL     equ   SPR3PTH+$02&#13;
SPR4PTH     equ   sprpt+$10&#13;
SPR4PTL     equ   SPR4PTH+$02&#13;
SPR5PTH     equ   sprpt+$14&#13;
SPR5PTL     equ   SPR5PTH+$02&#13;
SPR6PTH     equ   sprpt+$18&#13;
SPR6PTL     equ   SPR6PTH+$02&#13;
SPR7PTH     equ   sprpt+$1C&#13;
SPR7PTL     equ   SPR7PTH+$02&#13;
&#13;
SHIPSPRITE equ $25000         ; address to store our ship sprite&#13;
DUMMYSPRITE equ $30000        ; address to store our dummy sprite&#13;
COPPERLIST equ $20000         ; address to store our copper list&#13;
BITPLANE1   equ $21000        ; address to store our bitplane data&#13;
&#13;
; Define bitplane1&#13;
        lea     custom,a0               ; a0 := address of custom chips&#13;
        move.w  #$1200,bplcon0(a0)      ; 1 bitplane color&#13;
        move.w  #$0000,bpl1mod(a0)      ; modulo := 0&#13;
        move.w  #$0000,bplcon1(a0)      ; horizontal scroll value := 0&#13;
        move.w  #$0024,bplcon2(a0)      ; give sprites priority over playfields&#13;
        move.w  #$0038,ddfstrt(a0)      ; data-fetch start&#13;
        move.w  #$00D0,ddfstop(a0)      ; data-fetch stop&#13;
&#13;
; Define display window&#13;
        move.w  #$3c81,diwstrt(a0)      ; set window start (hi byte = vertical, lo = horiz*2)&#13;
        move.w  #$ffc1,diwstop(a0)      ; set window stop (hi byte = vertical, lo = horiz*2)&#13;
&#13;
; Put RGB constants defining colors into the color registers&#13;
        move.w  #$000f,COLOR00(a0)      ; set color 00 (background) to blue (00f)&#13;
        move.w  #$0000,COLOR01(a0)      ; set color 01 (foreground) to black (000)&#13;
        move.w  #$0ff0,COLOR17(a0)      ; Set color 17 to yellow (ff0)&#13;
        move.w  #$00ff,COLOR18(a0)      ; Set color 18 to cyan (0ff)&#13;
        move.w  #$0f0f,COLOR19(a0)      ; Set color 19 to magenta (f0f)&#13;
&#13;
; Copy copper list data to addresses starting at COPPERLIST&#13;
        move.l #COPPERLIST,a1           ; a1 := copper list destination&#13;
        lea     copperl(pc),a2          ; a2 := copper list source&#13;
cloop:&#13;
        move.l  (a2),(a1)+              ; copy DMA command&#13;
        cmp.l   #$fffffffe,(a2)+        ; end of list?&#13;
        bne     cloop                   ; loop until whole list moved&#13;
&#13;
; Copy sprite to addresses starting at SHIPSPRITE&#13;
        move.l  #SHIPSPRITE,a1          ; a1 := sprite destination&#13;
        lea     sprite(pc),a2           ; a2 := sprite source&#13;
sprloop:&#13;
        move.l  (a2),(a1)+              ; copy DMA command&#13;
        cmp.l   #$00000000,(a2)+        ; end of sprite?&#13;
        bne     sprloop                 ; loop until whole sprite moved&#13;
&#13;
; All eight sprites are activated at the same time but we will only use one&#13;
; Write a blank sprite to DUMMYSPRITE, so the other sprites can point to it&#13;
        move.l #$00000000,DUMMYSPRITE&#13;
&#13;
; Point copper at our copper list data&#13;
        move.l #COPPERLIST,cop1lc(a0)&#13;
&#13;
gameloop:&#13;
&#13;
; Fill bitplane pixels with foreground color (1-bit plane in fore/background colors)&#13;
        move.l #BITPLANE1,a1            ; a1 := bitplane&#13;
        move.w #1999,d0                 ; 2000-1(for dbf) long words = 8000 bytes&#13;
floop:&#13;
        move.l #$ffffffff,(a1)+         ; put bit pattern $ffffffff as next row of 16*8 pixels&#13;
        dbf    d0,floop                 ; decrement, repeat until false&#13;
&#13;
; start DMA, to blit the sprite onto the bitplane&#13;
        move.w  d0,copjmp1(a0)          ; force load to copper program counter&#13;
        move.w #$83A0,dmacon(a0)        ; bitplane, copper, and sprite DMA&#13;
&#13;
    ;**your game logic would go here---read keyboard, move sprites**&#13;
&#13;
    jmp gameloop&#13;
&#13;
; Copper list for one bitplane, and eight sprites. Bitplane is at BITPLANE1&#13;
; Sprite 0 is at SHIPSPRITE; other (dummy) sprites are at DUMMYSPRITE&#13;
copperl:&#13;
        dc.w    BPL1PTH,$0002           ; bitplane 1 pointer := BITPLANE1&#13;
        dc.w    BPL1PTL,$1000&#13;
        dc.w    SPR0PTH,$0002           ; sprite 0 pointer := SHIPSPRITE&#13;
        dc.w    SPR0PTL,$5000&#13;
        dc.w    SPR1PTH,$0003           ; sprite 1 pointer := DUMMYSPRITE&#13;
        dc.w    SPR1PTL,$0000&#13;
        dc.w    SPR2PTH,$0003           ; sprite 2 pointer := DUMMYSPRITE&#13;
        dc.w    SPR2PTL,$0000&#13;
        dc.w    SPR3PTH,$0003           ; sprite 3 pointer := DUMMYSPRITE&#13;
        dc.w    SPR3PTL,$0000&#13;
        dc.w    SPR4PTH,$0003           ; sprite 4 pointer := DUMMYSPRITE&#13;
        dc.w    SPR4PTL,$0000&#13;
        dc.w    SPR5PTH,$0003           ; sprite 5 pointer := DUMMYSPRITE&#13;
        dc.w    SPR5PTL,$0000&#13;
        dc.w    SPR6PTH,$0003           ; sprite 6 pointer := DUMMYSPRITE&#13;
        dc.w    SPR6PTL,$0000&#13;
        dc.w    SPR7PTH,$0003           ; sprite 7 pointer := DUMMYSPRITE&#13;
        dc.w    SPR7PTL,$0000&#13;
        dc.w    $ffff,$fffe             ; copper list end&#13;
&#13;
; Sprite data. Stores (x,y) screen coordinate and image data&#13;
sprite:&#13;
        dc.w    $6da0,$7200             ; 6d = y location; a0 = x location; 72-6d = 5 = height)&#13;
&#13;
        dc.w    $0000,$0ff0             ; image data, 5 rows x 16 cols x 2 bit color&#13;
        dc.w    $0000,$33cc             ; each line describes one row of 16 pixels&#13;
        dc.w    $ffff,$0ff0             ; each pixel is described by a 2-bit color&#13;
        dc.w    $0000,$3c3c             ; the low pixel bits form the first word&#13;
        dc.w    $0000,$0ff0             ; the high pixel bits form the second word&#13;
&#13;
        dc.w    $0000,$0000             ; ... all zeros marks end of image data&#13;
</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_274"/>Here, the sprite is defined in the data segment at the end. Amiga programs tend to involve a lot of defining constants for use with the many complex ROM I/O subroutines used to call its graphics capabilities. In real life, library files would be included to make the most of these definitions, but they’re shown here in full as an illustration of a complete program.</p>&#13;
<p class="indent">A screenshot of the result is shown in <a href="ch11.xhtml#ch11fig13">Figure 11-13</a>. Note that the sprite doesn’t yet move, but further commands could be added to create a game loop that repeatedly reads the keyboard, updates the sprite location, then does the drawing. In real games, sprites aren’t usually defined as data lines in assembly; rather, they’re drawn in the famous pixel art program <em>Deluxe Paint</em>, then loaded into similar memory areas from files.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_275"/><img id="ch11fig13" src="../images/f0275-01.jpg" alt="Image" width="631" height="412"/></div>&#13;
<p class="figcap"><em>Figure 11-13: The Amiga sprite game result</em></p>&#13;
<h3 class="h3" id="lev225">Retro Peripherals</h3>&#13;
<p class="noindent">The 8-bit and 16-bit eras introduced many peripherals that either are still with us today or have had strong influences on modern standards. Let’s look at some of the most important ones here to complete our study of retro computing.</p>&#13;
<h4 class="h4" id="lev226"><em>Cathode Ray Tube Displays</em></h4>&#13;
<p class="noindent">While the Manchester Baby’s Williams tube, seen in the “Historical RAMs” box on <a href="ch10.xhtml#page_220">page 220</a>, wasn’t originally intended as a human display device, its programmers were quick to realize its potential for this use, and they soon began to write deliberately human-readable patterns to some parts of the screen as a form of output, with the rest of the screen storing internal data that appears as random patterns of on and off pixels. In recent decades, hackers have written simple retro arcade games to play on the Baby, displaying <em>Snake</em> and <em>Space Invaders</em> on parts of its Williams tube as the display.</p>&#13;
<p class="indent">These green-on-black pixels are the origin of the later cathode ray tube (CRT) green screen, and then color monitors, used as human displays in the retro age, as seen in <a href="ch01.xhtml#ch01fig31">Figure 1-31</a>.</p>&#13;
<p class="indent">Programmers grew accustomed to the green color scheme, and in the 1980s often switched their RGB monitors into high-resolution green-on-black modes with a hardware switch to aid their concentration and familiarity. Some claimed that using only the green pixels improved the precision of the display, as the red and blue sub-pixels are some distance away from the green so tend to blur the pixel when used. Today, we still follow this tradition when we put our terminal emulators and text editors such as Vim into green-on-black mode. This classic programming scheme is celebrated in the stylized computer code in the movies <em>Ghost in the Shell</em> and <em>The Matrix</em>.</p>&#13;
<p class="indent">To reduce costs, home computers of the golden age were often designed to use consumer television CRTs as RGB monitors. To display to a CRT monitor or TV, an 8-bit machine such as the C64 first needs to read the desired pixel values from video RAM, then arrange for them to be mapped <span epub:type="pagebreak" id="page_276"/>onto the strength of the CRT beam as it periodically scans the columns and rows of the screen.</p>&#13;
<p class="indent">CRT monitors produce complex visual halos around each pixel that blur into its neighbors, and pixel art for games of the time was optimized to work with this blurring, which looks completely unlike the result of playing retro games on a modern flat-screen monitor. The arcade game <em>Asteroids</em> exploited this effect to the extreme by turning up the brightness for the bullets to the maximum, resulting in the CRT ray functioning as a kind of death ray firing right into the player’s eyes—an effect that’s impossible to capture in emulation.</p>&#13;
<h4 class="h4" id="lev227"><em>User Input</em></h4>&#13;
<p class="noindent">Keyboards in the retro age were typically memory-mapped, with each key wired directly to an address in memory space to look like RAM. There would be a group of addresses together, each mapped to a key, and by loading from one you could determine if the key was up or down.</p>&#13;
<p class="indent">A mouse of the retro era is shown in <a href="ch11.xhtml#ch11fig14">Figure 11-14</a>.</p>&#13;
<div class="image"><img id="ch11fig14" src="../images/f0276-01.jpg" alt="Image" width="394" height="224"/></div>&#13;
<p class="figcap"><em>Figure 11-14: A ball mouse teardown</em></p>&#13;
<p class="indent">Mice like the one in <a href="ch11.xhtml#ch11fig14">Figure 11-14</a> work by physically rolling a thumb-sized rubber ball over your desk, which in turn spins two roller sensors detecting its horizontal and vertical rotations. The sensors convert the rotations into analog then digital signals to send down the wire to your computer.</p>&#13;
<h4 class="h4" id="lev228"><em>Serial Port</em></h4>&#13;
<p class="noindent">The serial port was, and still is, a simple communications protocol (formally the RS232 standard) found on retro machines but still very relevant in embedded systems today. The core of a serial port is two wires, called RX and TX, which stand for <em>receive</em> and <em>transmit</em>, respectively. These use digital voltages over time to transmit 0s and 1s, so there’s one wire sending information one way and another wire sending information the other way. A historical serial port has many other wires as well, as in the old days they were used as controls for many things, but nowadays we tend to use only RX and TX. Serial port connectors still have extra, mostly unused, pins from this history, as shown in <a href="ch11.xhtml#ch11fig15">Figure 11-15</a>.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_277"/><img id="ch11fig15" src="../images/f0277-01.jpg" alt="Image" width="394" height="296"/></div>&#13;
<p class="figcap"><em>Figure 11-15: A traditional serial port connector</em></p>&#13;
<p class="indent">Serial ports can run at different speeds. They may also use different conventions for error checking, which can add extra redundant bits, and for <em>stop bits</em>, which show where the boundaries of characters lie in the stream of 0s and 1s. You have to make sure the device at one end of the wire is using the same speed and conventions as the device at the other end of the wire.</p>&#13;
<h4 class="h4" id="lev229"><em>MIDI Interfaces</em></h4>&#13;
<p class="noindent"><em>MIDI (Musical Instrument Device Interface</em>, as seen in <a href="ch11.xhtml#ch11fig16">Figure 11-16</a>) has been the standard bus for musical keyboards, synthesizers, samplers, and 1980s keytars to communicate real-time, symbolic musical input and output since its standardization in 1983. It’s an early example of a bus hierarchy, in which an optional MIDI interface could be connected to the main bus; it also provides a secondary MIDI bus for multiple musical devices to communicate along.</p>&#13;
<div class="image"><img id="ch11fig16" src="../images/f0277-02.jpg" alt="Image" width="248" height="316"/></div>&#13;
<p class="figcap"><em>Figure 11-16: A MIDI connector</em></p>&#13;
<p class="indent">MIDI connections are composed of a pair of unidirectional buses. One is for the manager to send messages to devices, and the other is for devices to send messages to the manager. They’re buses in the sense that all devices use the same physical wires and can see all the messages on these wires, and so the devices must look out for which messages are addressed to them to read, and act on only those.</p>&#13;
<p class="indent">Each direction’s bus has its own connector and runs on three physical wires. (In fact, a standard MIDI connector has five pins, with two spare to help with related work such as supplying “phantom” power to devices.) One wire is 5 V, one is ground, and one is UART (universal asynchronous receiver-transmitter) data. The bus nature of the wire from the manager to the devices is seen in the MIDI specification that all devices have three sockets: “in,” “out,” and “thru,” where “thru” relays all “in” messages to the next device in a daisy-chain wiring scheme; other hardware adapters can merge the “out” messages from several devices onto a single wire, which is a rarer thing to want to do. As a 1980s standard, all messages are 8-bit words (known as “MIDI <span epub:type="pagebreak" id="page_278"/>bytes”), transmitted similarly to a serial port connection at a standard rate of 31.25Kbps.</p>&#13;
<p class="indent">MIDI, including recent extensions in MIDI 2.0, is still with us today.</p>&#13;
<h3 class="h3" id="lev230">Summary</h3>&#13;
<p class="noindent">For readers of a certain age, understanding and programming golden age machines can be a beautiful way to relive their youth and understand what was really going on inside their old machines. But for everyone else, these machines are still valuable to study because they bridge the gap between the simplest electronic computers, such as the Baby, and what you actually have on your desk and in your pocket today. Those modern machines have many more features that can be overwhelming, so by practicing on older machines of increasing power, you can build your confidence. To this end, this chapter studied an 8-bit system, the Commodore 64, and a 16-bit system, the Commodore Amiga. The two are related through their CPUs’ common ancestry, meaning they share some instructions and styles. Many of the ideas introduced by these classic systems are still in use today, as we will see in the next chapters.</p>&#13;
<h3 class="h3" id="lev231">Exercises</h3>&#13;
<h4 class="h4a"><strong>6502 Programming</strong></h4>&#13;
<ol class="number">&#13;
<li class="tm">Easy6502 is an open source 6502 emulator that runs in your browser. It’s written in JavaScript by Nick Morgan, the author of <em>JavaScript for Kids</em> and <em>JavaScript Crash Course</em>, also available from No Starch Press. Download Easy6502 with:<br/><pre>&gt; <span class="codestrong1">git clone <a href="https://github.com/charles-fox/easy6502.git">https://github.com/charles-fox/easy6502.git</a></span>&#13;
&gt; <span class="codestrong1">cd easy6502</span></pre></li>&#13;
<li class="tm">Open the downloaded <em>emulator.html</em> in your browser to run Easy6502. Then enter and run the sample 6502 programs from this chapter. The emulator shows the content of the registers on the right.</li>&#13;
<li class="tm">Try writing a 16-bit multiplication subroutine in 6502 assembly using Easy6502.</li>&#13;
<li class="tm">Nick’s own tutorial can be found in the downloaded <em>tutorial.html</em>. This gives many more 6502 programming details and builds up to writing a retro <em>Snake</em>-type game. Try to learn enough to understand how this game works, then try to modify it in some way, either to change the rules of the game or to transform it into another retro game such as <em>Space Invaders</em> or <em>Tetris</em>. Code built in this emulator can be ported to the C64 or other 6502-based machines, with some extra work to replace the graphics and I/O with calls to their specific designs.</li>&#13;
</ol>&#13;
<h4 class="h4a"><span epub:type="pagebreak" id="page_279"/><strong>C64 Programming</strong></h4>&#13;
<ol class="number">&#13;
<li class="tm">Nowadays, we can do C64 programming and assembling on a modern machine, then just run the resulting executable machine code on a C64 emulator, such as the open source VICE emulator, which can be installed locally. To get started, install the Dasm assembler from <em><a href="https://dasm-assembler.github.io">https://dasm-assembler.github.io</a></em>.</li>&#13;
<li class="tm">Put your assembly code in a file such as <em>hello.asm</em>. Dasm requires the following two lines to be added to the start of the file to tell it to generate an executable for the C64 rather than other machines. They must have exactly eight spaces of indent:<br/><pre>      processor 6502          ; define processor family for das&#13;
      org $C000               ; memory location for our code</pre></li>&#13;
<li class="tm">Assemble your code into a C64 program (<em>.prg</em>) with:<br/><pre>&gt; <span class="codestrong1">dasm hello.asm -ohello.prg</span></pre></li>&#13;
<li class="tm">The <em>.prg</em> file can be imported into a C64 emulator, such as the online JavaScript-based emulator at <em><a href="https://c64emulator.111mb.de">https://c64emulator.111mb.de</a></em>, or VICE. (For SID programs: some emulators, such as the JavaScript one mentioned here, have sound disabled by default, so you need to turn it on.)</li>&#13;
<li class="tm">If you’re lucky enough to have access to a real physical C64 and tape drive, you can also try converting your <em>.prg</em> files to tape images (<em>.tap</em>) and then sound waves (<em>.wav</em>) using a program such as <em>tap2wav.py</em> available at <em><a href="https://github.com/Zibri/C64">https://github.com/Zibri/C64</a></em>. Then record the <em>.wav</em> to a physical tape to load to the read machine. Try inspecting the <em>.tap</em> and <em>.wav</em> files to see the 0s and 1s along the way.</li>&#13;
</ol>&#13;
<h4 class="h4a"><strong>Programming a Sprite-Based Game on the Amiga</strong></h4>&#13;
<p class="noindent">Assemble and run the spaceship code shown in the “Programming the Amiga” section on <a href="ch11.xhtml#ch11lev2sec1">page 271</a> as follows:</p>&#13;
<ol class="number">&#13;
<li class="tm">Download the vasm cross-assembler from <em><a href="http://sun.hasenbraten.de/vasm">http://sun.hasenbraten.de/vasm</a></em>. Build it in Amiga mode with:<br/><pre>&gt; <span class="codestrong1">make CPU=m68k SYNTAX=mot</span></pre></li>&#13;
<li class="tm">Use vasm to assemble your assembly program with:<br/><pre>&gt; <span class="codestrong1">./vasmm68k_mot -kick1hunks -Fhunkexe -o myexe -nosym myprog.asm</span></pre></li>&#13;
<li class="tm"><span epub:type="pagebreak" id="page_280"/>Install <em>amitools</em> for Python from <em><a href="https://pypi.org/project/amitools/">https://pypi.org/project/amitools/</a></em>. Create a disk image and write the file to it, and make the disk image bootable with:<br/><pre>&gt; <span class="codestrong1">xdftool mydisc.adf create</span>&#13;
&gt; <span class="codestrong1">xdftool mydisc.adf format "title"</span>&#13;
&gt; <span class="codestrong1">xdftool mydisc.adf write myexe</span>&#13;
&gt; <span class="codestrong1">xdftool mydisc.adf boot install</span>&#13;
&gt; <span class="codestrong1">xdftool mydisc.adf makedir S</span>&#13;
&gt; <span class="codestrong1">echo myexe &gt; STARTUP-SEQUENCE</span>&#13;
&gt; <span class="codestrong1">xdftool mydisc.adf write STARTUP-SEQUENCE S/</span></pre></li>&#13;
<li class="tm">Download and install the FS-UAE Amiga emulator from <em><a href="https://fs-uae.net/download">https://fs-uae.net/download</a></em>. Run it and boot from your virtual <em>mydisk.adf</em> disk image.</li>&#13;
</ol>&#13;
<h4 class="h4a"><strong>More Challenging</strong></h4>&#13;
<ol class="number">&#13;
<li class="tm">Research how to read the Amiga keyboard or joystick, then extend the spaceship example into a simple game using the keyboard to move the sprite around. Research how to add double buffering to remove the flicker as the screen is redrawn during the loop.</li>&#13;
<li class="tm">Building your own 6502-based computer has recently become a popular hobby. Take a look around YouTube and <em><a href="https://hackaday.com">https://hackaday.com</a></em> to find examples of “6502 breadboard computers” and learn how they are made. You might try doing a rebuild of one of these existing designs, or making your own design.</li>&#13;
</ol>&#13;
<h3 class="h3" id="lev232">Further Reading</h3>&#13;
<ul class="bullet">&#13;
<li class="tm">To read the book that taught a generation of 8-bit programmer kids, see Lisa Watts and Mike Wharton, <em>Usborne Introduction to Machine Code for Beginners</em> (London: Usborne, 1983). The book is now freely available online at <em><a href="https://archive.org/details/machine-code-for-beginners">https://archive.org/details/machine-code-for-beginners</a></em>.</li>&#13;
<li class="tm">For a guided tour of the C64 system from 1983, see J. Butterfield, ed., “Commodore 64 Architecture,” <em>Computer!</em> 32 (January 1983): 208, <em><a href="https://www.atarimagazines.com/compute/issue32/112_1_COMMODORE_64_ARCHITECTURE.php">https://www.atarimagazines.com/compute/issue32/112_1_COMMODORE_64_ARCHITECTURE.php</a></em>.</li>&#13;
<li class="tm">For information on 8 bit–era audio programming, see James Vogel and Nevin Scrimshaw, <em>The Commodore 64 Music Book</em> (Boston: Birkhauser, 1983), <em><a href="https://archive.org/details/The_Commodore_64_Music_Book/page/n3/mode/2up">https://archive.org/details/The_Commodore_64_Music_Book/page/n3/mode/2up</a></em>.</li>&#13;
<li class="tm">See <em><a href="https://github.com/emu-russia/breaks">https://github.com/emu-russia/breaks</a></em> for a 6502 and NES rebuild in LogiSim.</li>&#13;
</ul>&#13;
</div>
</div>
</body></html>