- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reliable TCP Data Streams
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
- en: TCP allows you to reliably stream data between nodes on a network. This chapter
    takes a deeper dive into the protocol, focusing on the aspects directly influenced
    by the code we’ll write to establish TCP connections and transmit data over those
    connections. This knowledge should help you debug network-related issues in your
    programs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start by covering the TCP handshake process, its sequence numbers, acknowledgments,
    retransmissions, and other features. Next, we’ll implement the steps of a TCP
    session in Go, from dialing, listening, and accepting to the session termination.
    Then, we’ll discuss time-outs and temporary errors, how to detect them, and how
    to use them to keep our users happy. Finally, we’ll cover the early detection
    of unreliable network connections. Go’s standard library allows you to write robust
    TCP-based networking applications. But it doesn’t hold your hand. If you aren’t
    mindful of managing incoming data or properly closing connections, you’ll experience
    insidious bugs in your programs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: What Makes TCP Reliable?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TCP is reliable because it overcomes the effects of packet loss or receiving
    packets out of order. *Packet loss* occurs when data fails to reach its destination—typically
    because of data transmission errors (such as wireless network interference) or
    network congestion. *Network congestion* happens when nodes attempt to send more
    data over a network connection than the connection can handle, causing the nodes
    to discard the excess packets. For example, you can’t send data at a rate of 1
    gigabit per second (Gbps) over a 10 megabit-per-second (Mbps) connection. The
    10Mbps connection quickly becomes saturated, and nodes involved in the flow of
    the data drop the excess data.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: TCP adapts its data transfer rate to make sure it transmits data as fast as
    possible while keeping dropped packets to a minimum, even if the network conditions
    change—for example, the Wi-Fi signal fades, or the destination node becomes overwhelmed
    with data. This process, called *flow control*, does its best to make up for the
    deficiencies of the underlying network media. TCP cannot send good data over a
    bad network and is at the mercy of the network hardware.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: TCP also keeps track of received packets and retransmits unacknowledged packets,
    as necessary. Recipients can also receive packets out of sequence if, for example,
    data is rerouted in transit. Remember from Chapter 2 that routing protocols use
    metrics to determine how to route packets. These metrics may change as network
    conditions change. There is no guarantee that all packets you send take the same
    route for the duration of the TCP session. Thankfully, TCP organizes unordered
    packets and processes them in sequence.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Together with flow control and retransmission, these properties allow TCP to
    overcome packet loss and facilitate the delivery of data to the recipient. As
    a result, TCP eliminates the need for you to concern yourself with these errors.
    You are free to focus on the data you send and receive.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 配合流量控制和重传机制，这些特性使 TCP 能够克服数据包丢失并确保数据能够成功传输到接收方。因此，TCP 使你不必担心这些错误。你可以专注于发送和接收数据。
- en: Working with TCP Sessions
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 TCP 会话
- en: A *TCP session* allows you to deliver a stream of data of any size to a recipient
    and receive confirmation that the recipient received the data. This saves you
    from the inefficiency of sending a large amount of data across a network, only
    to find out at the end of the transmission that the recipient didn’t receive it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*TCP 会话* 使你能够将任何大小的数据流发送到接收方，并收到接收方已接收数据的确认。这避免了你发送大量数据时，网络传输完成后才发现接收方并未接收到数据的低效问题。'
- en: Much like the occasional head nod that people use to indicate they’re listening
    to someone speaking, streaming allows you to receive feedback from the recipient
    while the transfer is taking place so that you can correct any errors in real
    time. In fact, you can think of a TCP session as you would a conversation between
    two nodes. It starts with a greeting, progresses into the conversation, and concludes
    with a farewell.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 就像人们偶尔点头表示他们在听对方说话一样，流媒体传输允许你在传输过程中接收接收方的反馈，这样你可以实时纠正任何错误。实际上，你可以把 TCP 会话看作是两个节点之间的对话。它从问候开始，进入对话，最后以告别结束。
- en: As we discuss the specifics of TCP, I want you to understand that Go takes care
    of the implementation details for you. Your code will take advantage of the `net`
    package’s interfaces when working with TCP connections.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论 TCP 的具体细节时，我希望你明白 Go 会为你处理实现细节。当你处理 TCP 连接时，你的代码将会利用 `net` 包的接口。
- en: Establishing a Session with the TCP Handshake
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 TCP 三次握手建立会话
- en: A TCP connection uses a three-way handshake to introduce the client to the server
    and the server to the client. The handshake creates an established TCP session
    over which the client and server exchange data. [Figure 3-1](#figure3-1) illustrates
    the three messages sent in the handshake process.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 连接使用三次握手来引导客户端与服务器建立联系，同时也将服务器与客户端连接起来。三次握手创建了一个已建立的 TCP 会话，客户端与服务器可以通过该会话交换数据。[图
    3-1](#figure3-1)展示了握手过程中发送的三条消息。
- en: '![f03001](image_fi/500884c03/f03001.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![f03001](image_fi/500884c03/f03001.png)'
- en: 'Figure 3-1: The three-way handshake process leading to an established TCP session'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1：三次握手过程，最终建立 TCP 会话
- en: Before it can establish a TCP session, the server must listen for incoming connections.
    (I use the terms *server* and *client* in this chapter to refer to the listening
    node and dialing node, respectively. TCP itself doesn’t have a concept of a client
    and server, but an established session between two nodes, whereby one node reaches
    out to another node to establish the session.)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立 TCP 会话之前，服务器必须监听来自客户端的连接请求。（在本章中，我将 *服务器* 和 *客户端* 用于分别表示监听节点和拨号节点。TCP 本身并没有客户端和服务器的概念，而是指两个节点之间通过一个已建立的会话，其中一个节点联系另一个节点以建立该会话。）
- en: As the first step of the handshake, the client sends a packet with the *synchronize
    (SYN) flag* to the server. This SYN packet informs the server of the client’s
    capabilities and preferred window settings for the rest of the conversation. We’ll
    discuss the receive window shortly. Next, the server responds with its own packet,
    with both the *acknowledgment (ACK)* and SYN flags set. The ACK flag tells the
    client that the server acknowledges receipt of the client’s SYN packet. The server’s
    SYN packet tells the client what settings it’s agreed to for the duration of the
    conversation. Finally, the client replies with an ACK packet to acknowledge the
    server’s SYN packet, completing the three-way handshake.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 握手的第一步，客户端发送一个带有 *同步（SYN）标志* 的数据包给服务器。这个 SYN 数据包告诉服务器客户端的能力以及对话期间的窗口设置。稍后我们会讨论接收窗口。接下来，服务器回应自己的数据包，数据包中同时设置了
    *确认（ACK）* 和 SYN 标志。ACK 标志告诉客户端服务器已收到客户端的 SYN 数据包。服务器的 SYN 数据包告知客户端它同意的会话设置。最后，客户端回复一个
    ACK 数据包，确认服务器的 SYN 数据包，从而完成三次握手。
- en: Completion of the three-way handshake process establishes the TCP session, and
    nodes may then exchange data. The TCP session remains idle until either side has
    data to transmit. Unmanaged and lengthy idle TCP sessions may result in wasteful
    consumption of memory. We’ll cover techniques for managing idle connections in
    your code later in this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: When you initiate a connection in your code, Go will return either a connection
    object or an error. If you receive a connection object, the TCP handshake succeeded.
    You do not need to manage the handshake yourself.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Acknowledging Receipt of Packets by Using Their Sequence Numbers
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each TCP packet contains a *sequence number*, which the receiver uses to acknowledge
    receipt of each packet and properly order the packets for presentation to your
    Go application ([Figure 3-2](#figure3-2)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '![f03002](image_fi/500884c03/f03002.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3-2: Client and server exchanging sequence numbers'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The client’s operating system determines the initial sequence number(X in [Figure
    3-2](#figure3-2)) and sends it to the server in the client’s SYN packet during
    the handshake. The server acknowledges receipt of the packet by including this
    sequence number in its ACK packet to the client. Likewise, the server shares its
    generated sequence number Y in its SYN packet to the client. The client replies
    with its ACK to the server.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: An ACK packet uses the sequence number to tell the sender, “I’ve received all
    packets up to and including the packet with this sequence number.” One ACK packet
    can acknowledge the receipt of one or more packets from the sender. The sender
    uses the sequence number in the ACK packet to determine whether it needs to retransmit
    any packets. For example, if a sender transmits a bunch of packets with sequence
    numbers up through 100 but then receives an ACK from the receiver with sequence
    number 90, the sender knows it needs to retransmit packets from sequence numbers
    91 to 100.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: While writing and debugging network programs, it’s often necessary to view the
    traffic your code sends and receives. To capture and inspect TCP packets, I strongly
    recommend you familiarize yourself with Wireshark ([https://www.wireshark.org/](https://www.wireshark.org/)).
    This program will go a long way toward helping you understand how your code influences
    the data sent over the network. To learn more, see *Practical Packet Analysis*,
    3rd Edition, by Chris Sanders (No Starch, 2017).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: If you view your application’s network traffic in Wireshark, you may notice
    *selective acknowledgments (SACKs)*. These are ACK packets used to acknowledge
    the receipt of a *subset* of sent packets. For example, let’s assume the sender
    transmitted a hundred packets but only packets 1 to 59 and 81 to 100 made it to
    the receiver. The receiver could send a SACK to inform the sender what subset
    of packets it received.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Here again, Go handles the low-level details. Your code will not need to concern
    itself with sequence numbers and acknowledgments.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Receive Buffers and Window Sizes
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接收缓冲区和窗口大小
- en: Since TCP allows a single ACK packet to acknowledge the receipt of more than
    one incoming packet, the receiver must advertise to the sender how much space
    it has available in its receive buffer before it sends an acknowledgment. A *receive
    buffer* is a block of memory reserved for incoming data on a network connection.
    The receive buffer allows the node to accept a certain amount of data from the
    network without requiring an application to immediately read the data. Both the
    client and the server maintain their own per-connection receive buffer. When your
    Go code reads data from a network connection object, it reads the data from the
    connection’s receive buffer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TCP允许单个ACK报文确认多个传入的数据包，因此接收方必须在发送确认之前，告知发送方其接收缓冲区还有多少可用空间。*接收缓冲区*是为网络连接上的传入数据保留的内存块。接收缓冲区允许节点在不要求应用程序立即读取数据的情况下，接受一定量的数据。客户端和服务器都维护着各自的每个连接的接收缓冲区。当你的Go代码从网络连接对象中读取数据时，它是从该连接的接收缓冲区读取数据。
- en: 'ACK packets include a particularly important piece of information: the *window
    size*, which is the number of bytes the sender can transmit to the receiver without
    requiring an acknowledgment. If the client sends an ACK packet to the server with
    a window size of 24,537, the server knows it can send 24,537 bytes to the client
    before expecting the client to send another ACK packet. A window size of zero
    indicates that the receiver’s buffer is full and can no longer receive additional
    data. We’ll discuss this scenario a bit later in this chapter.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ACK报文包含一个特别重要的信息：*窗口大小*，即发送方可以在不需要确认的情况下发送给接收方的字节数。如果客户端向服务器发送一个窗口大小为24,537的ACK报文，服务器就知道它可以向客户端发送24,537字节的数据，而无需客户端发送另一个ACK报文。窗口大小为零表示接收方的缓冲区已满，无法再接收更多数据。我们将在本章稍后讨论这种情况。
- en: Both the client and the server keep track of each other’s window size and do
    their best to completely fill each other’s receive buffers. This method—of receiving
    the window size in an ACK packet, sending data, receiving an updated window size
    in the next ACK, and then sending more data—is known as a *sliding window*, as
    shown in [Figure 3-3](#figure3-3). Each side of the connection offers up a window
    of data that can it can receive at any one time.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器都跟踪彼此的窗口大小，并尽力填满彼此的接收缓冲区。这种方法——在ACK报文中接收窗口大小，发送数据，在下一个ACK中接收更新后的窗口大小，然后发送更多数据——被称为*滑动窗口*，如[图3-3](#figure3-3)所示。连接的每一方都提供了一个可以在任何时刻接收的数据窗口。
- en: '![f03003](image_fi/500884c03/f03003.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![f03003](image_fi/500884c03/f03003.png)'
- en: 'Figure 3-3: A client’s ACKs advertising the amount of data it can receive'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-3：客户端的ACK广告，表示它能接收的数据量
- en: In this snippet of communication, the client sends an ACK for previously received
    data. This ACK includes a window size of 3,072 bytes. The server now knows that
    it can send up to 3,072 bytes before it requires an ACK from the client. The server
    sends three packets with 1,024 bytes each to fill the client’s receive buffer.
    The client then sends another ACK with an updated window size of 2,048 bytes.
    This means that the application running on the client read 2,048 bytes from the
    receive buffer before the client sent its acknowledgment to the server. The server
    then sends two more packets of 1,024 bytes to fill the client’s receive buffer
    and waits for another ACK.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段通信片段中，客户端发送了一个确认报文（ACK），用于确认之前接收到的数据。这个ACK包含了一个窗口大小为3,072字节。服务器现在知道，在收到客户端的确认之前，它最多可以发送3,072字节的数据。服务器发送了三个数据包，每个数据包大小为1,024字节，用以填充客户端的接收缓冲区。然后，客户端发送了另一个ACK，并更新了窗口大小为2,048字节。这意味着客户端运行的应用程序在发送确认报文之前，从接收缓冲区读取了2,048字节的数据。然后，服务器再发送两个1,024字节的数据包来填充客户端的接收缓冲区，并等待另一个ACK。
- en: Here again, all you need to concern yourself with is reading and writing to
    the connection object Go gives you when you establish a TCP connection. If something
    goes wrong, Go will surely let you know by returning an error.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你只需要关心的是在建立TCP连接时，Go为你提供的连接对象的读写操作。如果发生了问题，Go肯定会通过返回错误通知你。
- en: Gracefully Terminating TCP Sessions
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优雅地终止TCP会话
- en: Like the handshake process, gracefully terminating a TCP session involves exchanging
    a sequence of packets. Either side of the connection may initiate the termination
    sequence by sending a *finish (FIN)* packet. In [Figure 3-4](#figure3-4), the
    client initiates the termination by sending a FIN packet to the server.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 像握手过程一样，优雅地终止 TCP 会话也需要交换一系列数据包。连接的任何一方都可以通过发送 *finish (FIN)* 数据包来启动终止序列。在[图
    3-4](#figure3-4)中，客户端通过向服务器发送 FIN 数据包来发起终止。
- en: '![f03004](image_fi/500884c03/f03004.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![f03004](image_fi/500884c03/f03004.png)'
- en: 'Figure 3-4: The client initiates a TCP session termination with the server.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-4：客户端向服务器发起 TCP 会话终止。
- en: The client’s connection state changes from ESTABLISHED to FIN_WAIT_1, which
    indicates the client is in the process of tearing down the connection from its
    end and is waiting for the server’s acknowledgment. The server acknowledges the
    client’s FIN and changes its connection state from ESTABLISHED to CLOSE_WAIT.
    The server sends its own FIN packet, changing its state to LAST_ACK, indicating
    it’s waiting for a final acknowledgment from the client. The client acknowledges
    the server’s FIN and enters a TIME_WAIT state, whose purpose is to allow the client’s
    final ACK packet to reach the server. The client waits for twice the maximum segment
    lifetime (the segment lifetime arbitrarily defaults to two minutes, per RFC 793,
    but your operating system may allow you to tweak this value), then changes its
    connection state to CLOSED without any further input required from the server.
    The *maximum segment lifetime* is the duration a TCP segment can remain in transit
    before the sender considers it abandoned. Upon receiving the client’s last ACK
    packet, the server immediately changes its connection state to CLOSED, fully terminating
    the TCP session.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的连接状态从 ESTABLISHED 变为 FIN_WAIT_1，表示客户端正在从自身端拆除连接，并等待服务器的确认。服务器确认客户端的 FIN
    后，将连接状态从 ESTABLISHED 变为 CLOSE_WAIT。服务器发送自己的 FIN 数据包，连接状态变为 LAST_ACK，表示它在等待客户端的最终确认。客户端确认服务器的
    FIN 后进入 TIME_WAIT 状态，目的是让客户端的最后一个 ACK 数据包能够到达服务器。客户端等待最大报文段生存时间的两倍（根据 RFC 793，报文段生存时间默认是两分钟，但操作系统可能允许你调整此值），然后将连接状态改为
    CLOSED，且不再需要服务器的任何进一步输入。*最大报文段生存时间*是指 TCP 报文段在传输中可以存在的最长时间，超过此时间发送方会认为它已经丢失。收到客户端最后一个
    ACK 数据包后，服务器立即将连接状态改为 CLOSED，完全终止 TCP 会话。
- en: Like the initial handshake, Go handles the details of the TCP connection teardown
    process when you close a connection object.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 像初始握手一样，当你关闭连接对象时，Go 会处理 TCP 连接拆除过程中的细节。
- en: Handling Less Graceful Terminations
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理不太优雅的连接终止
- en: Not all connections politely terminate. In some cases, the application that
    opened a TCP connection may crash or abruptly stop running for some reason. When
    this happens, the TCP connection is immediately closed. Any packets sent from
    the other side of the former connection will prompt the closed side of the connection
    to return a *reset (RST) packet*. The RST packet informs the sender that the receiver’s
    side of the connection closed and will no longer accept data. The sender should
    close its side of the connection knowing the receiver ignored any packets it did
    not acknowledge.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有连接都能礼貌地终止。在某些情况下，打开 TCP 连接的应用程序可能会崩溃或因为某种原因突然停止运行。这时，TCP 连接会立即关闭。来自原连接另一端的任何数据包都会触发关闭一端返回
    *reset (RST) 数据包*。RST 数据包通知发送方，接收方的连接已关闭，不再接受数据。发送方应该关闭连接的一侧，知道接收方忽略了任何未确认的数据包。
- en: Intermediate nodes, such as firewalls, can send RST packets to each node in
    a connection, effectively terminating the socket from the middle.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 中间节点，如防火墙，能够向连接中的每个节点发送 RST 数据包，从而在中间终止连接。
- en: Establishing a TCP Connection by Using Go’s Standard Library
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Go 标准库建立 TCP 连接
- en: The `net` package in Go’s standard library includes good support for creating
    TCP-based servers and clients capable of connecting to those servers. Even so,
    it’s your responsibility to make sure you handle the connection appropriately.
    Your software should be attentive to incoming data and always strive to gracefully
    shut down the connection. Let’s write a TCP server that can listen for incoming
    TCP connections, initiate connections from a client, accept and asynchronously
    handle each connection, exchange data, and terminate the connection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Binding, Listening for, and Accepting Connections
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To create a TCP server capable of listening for incoming connections (called
    a *listener*), use the `net.Listen` function. This function will return an object
    that implements the `net.Listener` interface. [Listing 3-1](#listing3-1) shows
    the creation of a listener.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 3-1: Creating a listener on 127.0.0.1 using a random port (*listen_test.go*)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: The `net.Listen` function accepts a network type 2 and an IP address and port
    separated by a colon 3. The function returns a `net.Listener` interface 1 and
    an `error` interface. If the function returns successfully, the listener is bound
    to the specified IP address and port. *Binding* means that the operating system
    has exclusively assigned the port on the given IP address to the listener. The
    operating system allows no other processes to listen for incoming traffic on bound
    ports. If you attempt to bind a listener to a currently bound port, `net.Listen`
    will return an error.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: You can choose to leave the IP address and port parameters empty. If the port
    is zero or empty, Go will randomly assign a port number to your listener. You
    can retrieve the listener’s address by calling its `Addr` method 5. Likewise,
    if you omit the IP address, your listener will be bound to all unicast and anycast
    IP addresses on the system. Omitting both the IP address and port, or passing
    in a colon for the second argument to `net.Listen`, will cause your listener to
    bind to all unicast and anycast IP addresses using a random port.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you should use `tcp` as the network type for `net.Listener`’s
    first argument. You can restrict the listener to just IPv4 addresses by passing
    in `tcp4` or exclusively bind to IPv6 addresses by passing in `tcp6`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: You should always be diligent about closing your listener gracefully by calling
    its `Close` method 4, often in a `defer` if it makes sense for your code. Granted,
    this is a test case, and Go will tear down the listener when the test completes,
    but it’s good practice nonetheless. Failure to close the listener may lead to
    memory leaks or deadlocks in your code, because calls to the listener’s `Accept`
    method may block indefinitely. Closing the listener immediately unblocks calls
    to the `Accept` method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-2](#listing3-2) demonstrates how a listener can accept incoming
    TCP connections.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 3-2: Accepting and handling incoming TCP connection requests'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Unless you want to accept only a single incoming connection, you need to use
    a `for` loop 1 so your server will accept each incoming connection, handle it
    in a goroutine, and loop back around, ready to accept the next connection. Serially
    accepting connections is perfectly acceptable and efficient, but beyond that point,
    you should use a goroutine to handle each connection. You could certainly write
    serialized code after accepting a connection if your use case demands it, but
    it would be woefully inefficient and fail to take advantage of Go’s strengths.
    We start the `for` loop by calling the listener’s `Accept` method 2. This method
    will block until the listener detects an incoming connection and completes the
    TCP handshake process between the client and the server. The call returns a `net.Conn`
    interface 3 and an `error`. If the handshake failed or the listener closed, for
    example, the error interface would be non-`nil`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你只想接受单个传入连接，否则你需要使用 `for` 循环 1，这样你的服务器就会接受每个传入连接，并在 goroutine 中处理它，然后继续循环，准备接受下一个连接。串行接受连接是完全可以接受的，而且效率也不错，但超出这个范围后，你应该使用
    goroutine 来处理每个连接。如果你的用例要求你可以写出串行化的代码来接受连接，但那样做会非常低效，并且无法充分发挥 Go 的优势。我们通过调用监听器的
    `Accept` 方法 2 来启动 `for` 循环。这个方法会阻塞，直到监听器检测到传入的连接并完成客户端和服务器之间的 TCP 握手过程。该调用返回一个
    `net.Conn` 接口 3 和一个 `error`。例如，如果握手失败或监听器关闭，错误接口将为非 `nil`。
- en: The connection interface’s underlying type is a pointer to a `net.TCPConn` object
    because you’re accepting TCP connections. The connection interface represents
    the server’s side of the TCP connection. In most cases, `net.Conn` provides all
    methods you’ll need for general interactions with the client. However, the `net.TCPConn`
    object provides additional functionality we’ll cover in Chapter 4 should you require
    more control.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 连接接口的底层类型是指向 `net.TCPConn` 对象的指针，因为你正在接受 TCP 连接。连接接口代表服务器端的 TCP 连接。在大多数情况下，`net.Conn`
    提供了与客户端进行一般交互所需的所有方法。然而，如果你需要更多的控制，`net.TCPConn` 对象提供了额外的功能，我们将在第 4 章讨论这些功能。
- en: To concurrently handle client connections, you spin off a goroutine to asynchronously
    handle each connection 4 so your listener can ready itself for the next incoming
    connection. Then you call the connection’s `Close` method 5 before the goroutine
    exits to gracefully terminate the connections by sending a FIN packet to the server.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了并发处理客户端连接，你会启动一个 goroutine 异步处理每个连接 4，这样监听器就可以为下一个传入的连接做好准备。然后，在 goroutine
    退出之前，你调用连接的 `Close` 方法 5，以通过发送 FIN 数据包来优雅地终止与服务器的连接。
- en: Establishing a Connection with a Server
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与服务器建立连接
- en: From the client’s side, Go’s standard library `net` package makes reaching out
    and establishing a connection with a server a simple matter. [Listing 3-3](#listing3-3)
    is a test that demonstrates the process of initiating a TCP connection with a
    server listening to 127.0.0.1 on a random port.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端的角度来看，Go 的标准库 `net` 包使得与服务器建立连接变得非常简单。[清单 3-3](#listing3-3) 是一个示例，演示了如何发起与监听在
    127.0.0.1 上的服务器的 TCP 连接，端口是随机选择的。
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 3-3: Establishing a connection to 127.0.0.1 (*dial_test.go*)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-3：建立与 127.0.0.1 的连接 (*dial_test.go*)
- en: You start by creating a listener on the IP address 127.0.0.1, which the client
    will connect to. You omit the port number altogether, so Go will randomly pick
    an available port for you. Then, you spin off the listener in a goroutine 1 so
    you can work with the client’s side of the connection later in the test. The listener’s
    goroutine contains code like [Listing 3-2](#listing3-2)’s for accepting incoming
    TCP connections in a loop, spinning off each connection into its own goroutine.
    (We often call this goroutine a *handler*. I’ll explain the implementation details
    of the handler shortly, but it will read up to 1024 bytes from the socket at a
    time and log what it received.)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你在 IP 地址 127.0.0.1 上创建一个监听器，客户端将连接到该地址。你完全省略了端口号，因此 Go 会随机选择一个可用的端口。然后，你将监听器放入一个
    goroutine 1 中，这样你就可以在测试的后续部分处理客户端的连接。监听器的 goroutine 包含类似 [清单 3-2](#listing3-2)
    的代码，用于循环接受传入的 TCP 连接，并将每个连接放入自己的 goroutine 中。（我们通常称这个 goroutine 为 *handler*。我稍后会解释
    handler 的实现细节，但它会一次从套接字读取最多 1024 字节，并记录它接收到的内容。）
- en: The standard library’s `net`.`Dial` function is like the `net.Listen` function
    in that it accepts a network 6 like `tcp` and an IP address and port combination
    7—in this case, the IP address and port of the listener to which it’s trying to
    connect. You can use a hostname in place of an IP address and a service name,
    like *http*, in place of a port number. If a hostname resolves to more than one
    IP address, Go will attempt a connection to each one in order until a connection
    succeeds or all IP addresses have been exhausted. Since IPv6 addresses include
    colon delimiters, you must enclose an IPv6 address in square brackets. For example,
    `"[2001:ed27::1]:https"` specifies port 443 at the IPv6 address 2001:ed27::1\.
    `Dial` returns a connection object 5 and an `error` interface value.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的`net`.`Dial`函数与`net.Listen`函数类似，都会接受一个网络协议（如`tcp`）以及一个IP地址和端口的组合——在此案例中，是目标监听器的IP地址和端口。你可以用主机名代替IP地址，用服务名（如*http*）代替端口号。如果主机名解析为多个IP地址，Go会按顺序尝试每一个，直到成功连接或所有IP地址尝试完毕。由于IPv6地址包含冒号分隔符，因此必须将IPv6地址用方括号括起来。例如，`"[2001:ed27::1]:https"`表示IPv6地址2001:ed27::1的443端口。`Dial`返回一个连接对象和一个`error`接口值。
- en: Now that you’ve established a successful connection to the listener, you initiate
    a graceful termination of the connection from the client’s side 8. After receiving
    the FIN packet, the `Read` method 4 returns the `io.EOF` error, indicating to
    the listener’s code that you closed your side of the connection. The connection’s
    handler 3 exits, calling the connection’s `Close` method on the way out. This
    sends a FIN packet to your connection, completing the graceful termination of
    the TCP session.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功连接到监听器，从客户端一侧启动优雅关闭连接。接收到FIN包后，`Read`方法会返回`io.EOF`错误，通知监听器代码你已经关闭了连接的一端。连接的处理程序会退出，并在退出时调用连接的`Close`方法。这将向你的连接发送一个FIN包，完成TCP会话的优雅终止。
- en: Finally, you close the listener 9. The listener’s `Accept` method 2 immediately
    unblocks and returns an error. This error isn’t necessarily a failure, so you
    simply log it and move on. It doesn’t cause your test to fail. The listener’s
    goroutine 1 exits, and the test completes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你关闭监听器。监听器的`Accept`方法会立即解除阻塞并返回一个错误。这个错误不一定是失败，所以你只需记录它并继续。这不会导致你的测试失败。监听器的goroutine退出，测试完成。
- en: Understanding Time-outs and Temporary Errors
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解超时和临时错误
- en: In a perfect world, your connection attempts will immediately succeed, and all
    read and write attempts will never fail. But you need to hope for the best and
    prepare for the worst. You need a way to determine whether an error is temporary
    or something that warrants termination of the connection altogether. The `error`
    interface doesn’t provide enough information to make that determination. Thankfully,
    Go’s `net` package provides more insight if you know how to use it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界里，你的连接尝试会立即成功，所有的读写尝试永远不会失败。但你需要期望最好的同时准备最坏的情况。你需要一种方式来判断一个错误是否是临时的，或者是否需要完全终止连接。`error`接口提供的信息不足以做出这种判断。幸运的是，Go的`net`包提供了更多的洞察，只要你知道如何使用它。
- en: 'Errors returned from functions and methods in the `net` package typically implement
    the `net.Error` interface, which includes two notable methods: `Timeout` and `Temporary`.
    The `Timeout` method returns `true` on Unix-based operating systems and Windows
    if the operating system tells Go that the resource is temporarily unavailable,
    the call would block, or the connection timed out. We’ll touch on time-outs and
    how you can use them to your advantage a bit later in this chapter. The `Temporary`
    method returns `true` if the error''s `Timeout` function returns `true`, the function
    call was interrupted, or there are too many open files on the system, usually
    because you’ve exceeded the operating system’s resource limit.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从`net`包中的函数和方法返回的错误通常实现了`net.Error`接口，其中包括两个重要的方法：`Timeout`和`Temporary`。当操作系统告诉Go资源暂时不可用、调用会被阻塞，或连接超时时，`Timeout`方法会返回`true`，在Unix系统和Windows中都是如此。稍后我们会讨论如何利用超时。`Temporary`方法会在错误的`Timeout`函数返回`true`、函数调用被中断，或者系统中打开的文件过多时返回`true`，通常是因为你超过了操作系统的资源限制。
- en: Since the functions and methods in the `net` package return the more general
    `error` interface, you’ll see the code in this chapter use type assertions to
    verify you received a `net.Error`, as in [Listing 3-4](#listing3-4).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 3-4: Asserting a `net.Error` to check whether the error was temporary'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Robust network code won’t rely exclusively on the `error` interface. Rather,
    it will readily use `net.Error`’s methods, or even dive in further and assert
    the underlying `net.OpError` struct, which contains more details about the connection,
    such as the operation that caused the error, the network type, the source address,
    and more. I encourage you to read the `net.OpError` documentation (available at
    [https://golang.org/pkg/net/#OpError/](https://golang.org/pkg/net/#OpError/))
    to learn more about specific errors beyond what the `net.Error` interface provides.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Timing Out a Connection Attempt with the DialTimeout Function
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using the `Dial` function has one potential problem: you are at the mercy of
    the operating system to time out each connection attempt. For example, if you
    use the `Dial` function in an interactive application and your operating system
    times out connection attempts after two hours, your application’s user may not
    want to wait that long, much less give your app a five-star rating.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: To keep your applications predictable and your users happy, it’d be better to
    control time-outs yourself. For example, you may want to initiate a connection
    to a low-latency service that responds quickly if it’s available. If the service
    isn’t responding, you’ll want to time out quickly and move onto the next service.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: One solution is to explicitly define a per-connection time-out duration and
    use the `DialTimeout` function instead. [Listing 3-5](#listing3-5) implements
    this solution.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 3-5: Specifying a time-out duration when initiating a TCP connection
    (*dial_timeout_test.go*)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Since the `net.DialTimeout` function 1 does not give you control of its `net.Dialer`
    to mock the dialer’s output, you’re using our own implementation that matches
    the signature. Your `DialTimeout` function overrides the `Control` function 2
    of the `net.Dialer` to return an error. You’re mocking a DNS time-out error.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the `net.Dial` function, the `DialTimeout` function includes an additional
    argument, the time-out duration 3. Since the time-out duration is five seconds
    in this case, the connection attempt will time out if a connection isn’t successful
    within five seconds. In this test, you dial 10.0.0.0, which is a non-routable
    IP address, meaning your connection attempt assuredly times out. For the test
    to pass, you need to first use a type assertion to verify you’ve received a `net.Error`4
    before you can check its `Timeout` method 5.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: If you dial a host that resolves to multiple IP addresses, Go starts a connection
    race between each IP address, giving the primary IP address a head start. The
    first connection to succeed persists, and the remaining contenders cancel their
    connection attempts. If all connections fail or time out, `net.DialTimeout` returns
    an error.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Using a Context with a Deadline to Time Out a Connection
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A more contemporary solution to timing out a connection attempt is to use a
    context from the standard library’s `context` package. A *context* is an object
    that you can use to send cancellation signals to your asynchronous processes.
    It also allows you to send a cancellation signal after it reaches a deadline or
    after its timer expires.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: All cancellable contexts have a corresponding `cancel` function returned upon
    instantiation. The `cancel` function offers increased flexibility since you can
    optionally cancel the context before the context reaches its deadline. You could
    also pass along its `cancel` function to hand off cancellation control to other
    bits of your code. For example, you could monitor for specific signals from your
    operating system, such as the one sent to your application when a user presses
    the ctrl-C key combination, to gracefully abort connection attempts and tear down
    existing connections before terminating your application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-6](#listing3-6) illustrates a test that accomplishes the same functionality
    as `DialTimeout`, using `context` instead.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 3-6: Using a context with a deadline to time out the connection attempt
    (*dial_context_test.go*)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Before you make a connection attempt, you create the context with a deadline
    of five seconds into the future 1, after which the context will automatically
    cancel. Next, you create the context and its `cancel` function by using the `context.WithDeadline`
    function 2, setting the deadline in the process. It’s good practice to defer the
    `cancel` function 3 to make sure the context is garbage collected as soon as possible.
    Then, you override the dialer’s `Control` function 4 to delay the connection just
    long enough to make sure you exceed the context’s deadline. Finally, you pass
    in the context as the first argument to the `DialContext` function 5. The sanity
    check 6 at the end of the test makes sure that reaching the deadline canceled
    the context, not an erroneous call to `cancel`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: As with `DialTimeout`, if a host resolves to multiple IP addresses, Go starts
    a connection race between each IP address, giving the primary IP address a head
    start. The first connection to succeed persists, and the remaining contenders
    cancel their connection attempts. If all connections fail or the context reaches
    its deadline, `net.Dialer.DialContext` returns an error.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Aborting a Connection by Canceling the Context
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Another advantage to using a context is the `cancel` function itself. You can
    use it to cancel the connection attempt on demand, without specifying a deadline,
    as shown in [Listing 3-7](#listing3-7).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 3-7: Directly canceling the context to abort the connection attempt'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: (*dial_cancel_test.go*)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Instead of creating a context with a deadline and waiting for the deadline to
    abort the connection attempt, you use `context.WithCancel` to return a context
    and a function to cancel the context 1. Since you’re manually canceling the context,
    you create a closure and spin it off in a goroutine to handle the connection attempt
    2. Once the dialer is attempting to connect to and handshake with the remote node,
    you call the `cancel` function 3to cancel the context. This causes the `DialContext`
    method to immediately return with a non-`nil` error, exiting the goroutine. You
    can check the context’s `Err` method to make sure the call to cancel was what
    resulted in the canceled context, as opposed to a deadline in [Listing 3-6](#listing3-6).
    In this case, the context’s `Err` method should return a `context.Canceled` error
    4.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Canceling Multiple Dialers
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can pass the same context to multiple `DialContext` calls and cancel all
    the calls at the same time by executing the context’s `cancel` function. For example,
    let’s assume you need to retrieve a resource via TCP that is on several servers.
    You can asynchronously dial each server, passing each dialer the same context.
    You can then abort the remaining dialers after you receive a response from one
    of the servers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: In [Listing 3-8](#listing3-8), you pass the same context to multiple dialers.
    When you receive the first response, you cancel the context and abort the remaining
    dialers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 3-8: Canceling all outstanding dialers after receiving the first response
    (*dial_fanout_test.go*)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'You create a context by using `context.WithDeadline`1 because you want to have
    three potential results when checking the context’s `Err` method: `context.Canceled`,
    `context.DeadlineExceeded`, or `nil`. You expect `Err` will return the `context.Canceled`
    error, since your test aborts the dialers with a call to the `cancel` function.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: First, you need a listener. This listener accepts a single connection and closes
    it after the successful handshake 2. Next, you create your dialers. Since you’re
    spinning up multiple dialers, it makes sense to abstract the dialing code to its
    own function 3. This anonymous function dials out to the given address by using
    `DialContext`. If it succeeds, it sends the dialer’s ID across the response channel,
    provided you haven’t yet canceled the context. You spin up multiple dialers by
    calling `dial` in separate goroutines using a `for` loop 4. If `dial` blocks on
    the call to `DialContext` because another dialer won the race, you cancel the
    context, either by way of the `cancel` function or the deadline, causing the dial
    function to exit early. You use a wait group to make sure the test doesn’t proceed
    until all `dial` goroutines terminate after you cancel the context.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Once the goroutines are running, one will win the race and make a successful
    connection to the listener. You receive the winning dialer’s ID on the `res` channel
    5, then abort the losing dialers by canceling the context. At this point, the
    call to `wg.Wait` blocks until the aborted dialer goroutines return. Finally,
    you make sure it was your call to `cancel` that caused the cancelation of the
    context 6. Calling `cancel` does not guarantee that `Err` will return `context.Canceled`.
    The deadline can cancel the context, at which point calls to `cancel` become a
    no-op and `Err` will return `context.DeadlineExceeded`. In practice, the distinction
    may not matter to you, but it’s there if you need it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Deadlines
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go’s network connection objects allow you to include deadlines for both read
    and write operations. Deadlines allow you to control how long network connections
    can remain idle, where no packets traverse the connection. You can control the
    `Read` deadline by using the `SetReadDeadline` method on the connection object,
    control the `Write` deadline by using the `SetWriteDeadline` method, or both by
    using the `SetDeadline` method. When a connection reaches its read deadline, all
    currently blocked and future calls to a network connection’s `Read` method immediately
    return a time-out error. Likewise, a network connection’s `Write` method returns
    a time-out error when the connection reaches its write deadline.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Go’s network connections don’t set any deadline for reading and writing operations
    by default, meaning your network connections may remain idle for a long time.
    This could prevent you from detecting network failures, like an unplugged cable,
    in a timely manner, because it’s tougher to detect network issues between two
    nodes when no traffic is in flight.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The server in [Listing 3-9](#listing3-9) implements a deadline on its connection
    object.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 3-9: A server-enforced deadline terminates the network connection (*deadline_test.go*).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Once the server accepts the client’s TCP connection, you set the connection’s
    read deadline 1. Since the client won’t send data, the call to `Read` will block
    until the connection exceeds the read deadline. After five seconds, `Read` returns
    an error, which you verify is a time-out 2. Any future reads to the connection
    object will immediately result in another time-out error. However, you can restore
    the functionality of the connection object by pushing the deadline forward again
    3. After you’ve done this, a second call to `Read` succeeds. The server closes
    its end of the network connection, which initiates the termination process with
    the client. The client, currently blocked on its `Read` call, returns `io.EOF`4
    when the network connection closes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: We typically use deadlines to provide a window of time during which the remote
    node can send data over the network connection. When you read data from the remote
    node, you push the deadline forward. The remote node sends more data, and you
    push the deadline forward again, and so on. If you don’t hear from the remote
    node in the allotted time, you can assume that either the remote node is gone
    and you never received its FIN or that it is idle.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a Heartbeat
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For long-running network connections that may experience extended idle periods
    at the application level, it’s wise to implement a heartbeat between nodes to
    advance the deadline. This allows you to quickly identify network issues and promptly
    reestablish a connection as opposed to waiting to detect the network error when
    your application goes to transmit data. In this way, you can help make sure your
    application always has a good network connection when it needs it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: For our purposes, a *heartbeat* is a message sent to the remote side with the
    intention of eliciting a reply, which we can use to advance the deadline of our
    network connection. Nodes send these messages at a regular interval, like a heartbeat.
    Not only is this method portable over various operating systems, but it also makes
    sure the application using the network connection is responding, since the application
    implements the heartbeat. Also, this technique tends to play well with firewalls
    that may block TCP keepalives. We’ll discuss keepalives in Chapter 4.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: To start, you’ll need a bit of code you can run in a goroutine to ping at regular
    intervals. You don’t want to needlessly ping the remote node when you recently
    received data from it, so you need a way to reset the ping timer. [Listing 3-10](#listing3-10)
    is a simple implementation from a file named *ping.go* that meets those requirements.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: I use *ping* and *pong* messages in my heartbeat examples, where the reception
    of a ping message—the challenge—tells the receiver it should reply with a pong
    message—the response. The challenge and response messages are arbitrary. You could
    use anything you want to here, provided the remote node knows your intention is
    to elicit its reply.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 3-10: A function that pings a network connection at a regular interval
    (*ping.go*)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: The `Pinger` function writes ping messages to a given writer at regular intervals.
    Because it’s meant to run in a goroutine, `Pinger` accepts a context as its first
    argument so you can terminate it and prevent it from leaking. Its remaining arguments
    include an `io.Writer` interface and a channel to signal a timer reset. You create
    a buffered channel and put a duration on it to set the timer’s initial interval
    1. If the interval isn’t greater than zero, you use the default ping interval.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'You initialize the timer to the interval 2 and set up a deferred call to drain
    the timer’s channel to avoid leaking it, if necessary. The endless `for` loop
    contains a `select` statement, where you block until one of three things happens:
    the context is canceled, a signal to reset the timer is received, or the timer
    expires. If the context is canceled 3, the function returns, and no further pings
    will be sent. If the code selects the `reset` channel 4, you shouldn’t send a
    ping, and the timer resets 6 before iterating on the `select` statement again.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: If the timer expires 5, you write a ping message to the writer, and the timer
    resets before the next iteration. If you wanted, you could use this `case` to
    keep track of any consecutive time-outs that occur while writing to the writer.
    To do this, you could pass in the context’s `cancel` function and call it here
    if you reach a threshold of consecutive time-outs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 3-11](#listing3-11) illustrates how to use the `Pinger` function introduced
    in [Listing 3-10](#listing3-10) by giving it a writer and running it in a goroutine.
    You can then read pings from the reader at the expected intervals and reset the
    ping timer with different intervals.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 3-11: Testing the pinger and resetting its ping timer interval (*ping_example_test.go*)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you create a buffered channel 1 that you’ll use to signal a
    reset of the `Pinger`’s timer. You put an initial ping interval of one second
    on the `resetTimer` channel before passing the channel to the `Pinger` function.
    You’ll use this duration to initialize the `Pinger`’s timer and dictate when to
    write the ping message to the writer.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: You run through a series of millisecond durations in a loop 2, passing each
    to the `receivePing` function. This function resets the ping timer to the given
    duration and then waits to receive the ping message on the given reader. Finally,
    it prints to stdout the time it takes to receive the ping message. Go checks stdout
    against the expected output in the example.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: During the first iteration 3, you pass in a duration of zero, which tells the
    `Pinger` to reset its timer by using the previous duration—one second in this
    example. As expected, the reader receives the ping message after one second. The
    second iteration 4 resets the ping timer to 200 ms. Once this expires, the reader
    receives the ping message. The third run resets the ping timer to 300 ms 5, and
    the ping arrives at the 300 ms mark.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: You pass in a zero duration for run 4 6, preserving the 300 ms ping timer from
    the previous run. I find the technique of using zero durations to mean “use the
    previous timer duration” useful because I do not need to keep track of the initial
    ping timer duration. I can simply initialize the timer with the duration I want
    to use for the remainder of the TCP session and reset the timer by passing in
    a zero duration every time I need to preempt the transmission of the next ping
    message. Changing the ping timer duration in the future involves the modification
    of a single line as opposed to every place I send on the `resetTimer` channel.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Runs 5 to 7 7 simply listen for incoming pings without resetting the ping timer.
    As expected, the reader receives a ping at 300 ms intervals for the last three
    runs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'With [Listing 3-10](#listing3-10) saved to a file named *ping.go* and [Listing
    3-11](#listing3-11) saved to a file named *ping_example_test.go*, you can run
    the example by executing the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Advancing the Deadline by Using the Heartbeat
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each side of a network connection could use a `Pinger` to advance its deadline
    if the other side becomes idle, whereas the previous examples showed only a single
    side using a `Pinger`. When either node receives data on the network connection,
    its ping timer should reset to stop the delivery of an unnecessary ping. [Listing
    3-12](#listing3-12) is a new file named *ping_test.go* that shows how you can
    use incoming messages to advance the deadline.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 3-12: Receiving data advances the deadline (*ping_test.go*)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: You start a listener that accepts a connection, spins off a `Pinger` set to
    ping every second, and sets the initial deadline to five seconds 1. From a client’s
    perspective, it receives four pings followed by an `io.EOF` when the server reaches
    its deadline and terminates its side of the connection. However, a client can
    advance the server’s deadline by sending the server data 5 before the server reaches
    its deadline.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: If the server reads data from its connection, it can be confident the network
    connection is still good. Therefore, it can inform the `Pinger` to reset 2 its
    timer and push the connection’s deadline forward 3. To preempt the termination
    of the socket, the client listens for four ping messages 4 from the server before
    sending an emphatic pong message 5. This should buy the client five more seconds
    until the server reaches its deadline. The client reads four more pings 6 and
    then waits for the inevitable. You check that a total of nine seconds 7 has elapsed
    by the time the server terminates the connection, indicating the client’s pong
    successfully triggered the reset of the ping timer.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: In practice, this method of advancing the ping timer cuts down on the consumption
    of bandwidth by unnecessary pings. There is rarely a need to challenge the remote
    side of a network connection if you just received data on the connection.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The strings `"ping"` and `"pong"` are arbitrary. You could use smaller payloads,
    such as a single byte, for the same purpose, provided both sides of the network
    connection agree upon what values constitute a ping and a pong.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: What You’ve Learned
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We covered a lot of ground in this chapter. We started with a dive into TCP’s
    handshake, sequences, and acknowledgments, the sliding window, and connection
    terminations. Then, we covered the process of establishing TCP connections using
    Go’s standard library. We talked about temporary errors, time-outs, listening
    for incoming connections, and dialing remote services. Finally, we covered techniques
    to help you detect and timely correct network integrity issues.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: I strongly recommend picking up *Practical Packet Analysis* by Chris Sanders
    (No Starch Press, 2017) and installing Wireshark. Manipulating your network code
    and seeing how it affects TCP traffic in Wireshark is a fantastic way to gain
    a deeper understanding of both TCP and Go’s networking packages. The next chapter
    covers sending and receiving data over TCP connections. Wireshark will help you
    gain a deeper understanding of data you send, including each payload’s effects
    on the sliding window. Familiarizing yourself with it now will pay dividends.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
