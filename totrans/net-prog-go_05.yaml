- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Reliable TCP Data Streams
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠的TCP数据流
- en: '![](image_fi/book_art/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](image_fi/book_art/chapterart.png)'
- en: TCP allows you to reliably stream data between nodes on a network. This chapter
    takes a deeper dive into the protocol, focusing on the aspects directly influenced
    by the code we’ll write to establish TCP connections and transmit data over those
    connections. This knowledge should help you debug network-related issues in your
    programs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: TCP允许你在网络上可靠地流式传输数据。本章将深入探讨该协议，重点介绍直接受我们为建立TCP连接和通过这些连接传输数据的代码影响的方面。这些知识将帮助你调试程序中的网络相关问题。
- en: We’ll start by covering the TCP handshake process, its sequence numbers, acknowledgments,
    retransmissions, and other features. Next, we’ll implement the steps of a TCP
    session in Go, from dialing, listening, and accepting to the session termination.
    Then, we’ll discuss time-outs and temporary errors, how to detect them, and how
    to use them to keep our users happy. Finally, we’ll cover the early detection
    of unreliable network connections. Go’s standard library allows you to write robust
    TCP-based networking applications. But it doesn’t hold your hand. If you aren’t
    mindful of managing incoming data or properly closing connections, you’ll experience
    insidious bugs in your programs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍TCP握手过程、序列号、确认、重传和其他特性。接下来，我们将使用Go实现TCP会话的步骤，从拨号、监听、接受到会话终止。然后，我们将讨论超时和临时错误，如何检测它们，以及如何利用它们让用户满意。最后，我们将讨论如何早期检测不可靠的网络连接。Go的标准库使你能够编写健壮的基于TCP的网络应用程序。但它不会手把手地教你。如果你没有注意管理传入数据或正确关闭连接，你的程序中会出现隐蔽的bug。
- en: What Makes TCP Reliable?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么使得TCP可靠？
- en: TCP is reliable because it overcomes the effects of packet loss or receiving
    packets out of order. *Packet loss* occurs when data fails to reach its destination—typically
    because of data transmission errors (such as wireless network interference) or
    network congestion. *Network congestion* happens when nodes attempt to send more
    data over a network connection than the connection can handle, causing the nodes
    to discard the excess packets. For example, you can’t send data at a rate of 1
    gigabit per second (Gbps) over a 10 megabit-per-second (Mbps) connection. The
    10Mbps connection quickly becomes saturated, and nodes involved in the flow of
    the data drop the excess data.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: TCP之所以可靠，是因为它克服了数据包丢失或接收乱序数据包的影响。*数据包丢失*发生在数据未能到达目标——通常是由于数据传输错误（如无线网络干扰）或网络拥塞。*网络拥塞*发生在节点试图通过网络连接发送超出连接处理能力的数据，导致节点丢弃多余的数据包。例如，你无法通过一个10兆比特每秒（Mbps）的连接以每秒1千兆比特（Gbps）的速率发送数据。10Mbps的连接很快就会饱和，参与数据流的节点会丢弃超出的数据。
- en: TCP adapts its data transfer rate to make sure it transmits data as fast as
    possible while keeping dropped packets to a minimum, even if the network conditions
    change—for example, the Wi-Fi signal fades, or the destination node becomes overwhelmed
    with data. This process, called *flow control*, does its best to make up for the
    deficiencies of the underlying network media. TCP cannot send good data over a
    bad network and is at the mercy of the network hardware.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: TCP会调整其数据传输速率，确保尽可能快速地传输数据，同时将丢包量保持在最小，即使网络状况发生变化——例如，Wi-Fi信号减弱，或者目标节点的数据过载。这一过程被称为*流量控制*，它尽力弥补底层网络媒体的不足。TCP无法在糟糕的网络上发送良好的数据，它依赖于网络硬件的支持。
- en: TCP also keeps track of received packets and retransmits unacknowledged packets,
    as necessary. Recipients can also receive packets out of sequence if, for example,
    data is rerouted in transit. Remember from Chapter 2 that routing protocols use
    metrics to determine how to route packets. These metrics may change as network
    conditions change. There is no guarantee that all packets you send take the same
    route for the duration of the TCP session. Thankfully, TCP organizes unordered
    packets and processes them in sequence.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: TCP还会跟踪已接收的数据包，并根据需要重新传输未确认的数据包。如果数据在传输过程中被重新路由，接收方也可能会接收到乱序的数据包。记住在第二章提到的，路由协议使用度量来确定如何路由数据包。这些度量会随着网络状况的变化而变化。不能保证在整个TCP会话期间，所有发送的数据包都会采取相同的路由。幸运的是，TCP会组织乱序的数据包，并按顺序处理它们。
- en: Together with flow control and retransmission, these properties allow TCP to
    overcome packet loss and facilitate the delivery of data to the recipient. As
    a result, TCP eliminates the need for you to concern yourself with these errors.
    You are free to focus on the data you send and receive.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 配合流量控制和重传机制，这些特性使 TCP 能够克服数据包丢失并确保数据能够成功传输到接收方。因此，TCP 使你不必担心这些错误。你可以专注于发送和接收数据。
- en: Working with TCP Sessions
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 TCP 会话
- en: A *TCP session* allows you to deliver a stream of data of any size to a recipient
    and receive confirmation that the recipient received the data. This saves you
    from the inefficiency of sending a large amount of data across a network, only
    to find out at the end of the transmission that the recipient didn’t receive it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*TCP 会话* 使你能够将任何大小的数据流发送到接收方，并收到接收方已接收数据的确认。这避免了你发送大量数据时，网络传输完成后才发现接收方并未接收到数据的低效问题。'
- en: Much like the occasional head nod that people use to indicate they’re listening
    to someone speaking, streaming allows you to receive feedback from the recipient
    while the transfer is taking place so that you can correct any errors in real
    time. In fact, you can think of a TCP session as you would a conversation between
    two nodes. It starts with a greeting, progresses into the conversation, and concludes
    with a farewell.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 就像人们偶尔点头表示他们在听对方说话一样，流媒体传输允许你在传输过程中接收接收方的反馈，这样你可以实时纠正任何错误。实际上，你可以把 TCP 会话看作是两个节点之间的对话。它从问候开始，进入对话，最后以告别结束。
- en: As we discuss the specifics of TCP, I want you to understand that Go takes care
    of the implementation details for you. Your code will take advantage of the `net`
    package’s interfaces when working with TCP connections.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论 TCP 的具体细节时，我希望你明白 Go 会为你处理实现细节。当你处理 TCP 连接时，你的代码将会利用 `net` 包的接口。
- en: Establishing a Session with the TCP Handshake
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 TCP 三次握手建立会话
- en: A TCP connection uses a three-way handshake to introduce the client to the server
    and the server to the client. The handshake creates an established TCP session
    over which the client and server exchange data. [Figure 3-1](#figure3-1) illustrates
    the three messages sent in the handshake process.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: TCP 连接使用三次握手来引导客户端与服务器建立联系，同时也将服务器与客户端连接起来。三次握手创建了一个已建立的 TCP 会话，客户端与服务器可以通过该会话交换数据。[图
    3-1](#figure3-1)展示了握手过程中发送的三条消息。
- en: '![f03001](image_fi/500884c03/f03001.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![f03001](image_fi/500884c03/f03001.png)'
- en: 'Figure 3-1: The three-way handshake process leading to an established TCP session'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-1：三次握手过程，最终建立 TCP 会话
- en: Before it can establish a TCP session, the server must listen for incoming connections.
    (I use the terms *server* and *client* in this chapter to refer to the listening
    node and dialing node, respectively. TCP itself doesn’t have a concept of a client
    and server, but an established session between two nodes, whereby one node reaches
    out to another node to establish the session.)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立 TCP 会话之前，服务器必须监听来自客户端的连接请求。（在本章中，我将 *服务器* 和 *客户端* 用于分别表示监听节点和拨号节点。TCP 本身并没有客户端和服务器的概念，而是指两个节点之间通过一个已建立的会话，其中一个节点联系另一个节点以建立该会话。）
- en: As the first step of the handshake, the client sends a packet with the *synchronize
    (SYN) flag* to the server. This SYN packet informs the server of the client’s
    capabilities and preferred window settings for the rest of the conversation. We’ll
    discuss the receive window shortly. Next, the server responds with its own packet,
    with both the *acknowledgment (ACK)* and SYN flags set. The ACK flag tells the
    client that the server acknowledges receipt of the client’s SYN packet. The server’s
    SYN packet tells the client what settings it’s agreed to for the duration of the
    conversation. Finally, the client replies with an ACK packet to acknowledge the
    server’s SYN packet, completing the three-way handshake.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 握手的第一步，客户端发送一个带有 *同步（SYN）标志* 的数据包给服务器。这个 SYN 数据包告诉服务器客户端的能力以及对话期间的窗口设置。稍后我们会讨论接收窗口。接下来，服务器回应自己的数据包，数据包中同时设置了
    *确认（ACK）* 和 SYN 标志。ACK 标志告诉客户端服务器已收到客户端的 SYN 数据包。服务器的 SYN 数据包告知客户端它同意的会话设置。最后，客户端回复一个
    ACK 数据包，确认服务器的 SYN 数据包，从而完成三次握手。
- en: Completion of the three-way handshake process establishes the TCP session, and
    nodes may then exchange data. The TCP session remains idle until either side has
    data to transmit. Unmanaged and lengthy idle TCP sessions may result in wasteful
    consumption of memory. We’ll cover techniques for managing idle connections in
    your code later in this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 完成三次握手过程后，TCP 会话建立，节点可以开始交换数据。TCP 会话保持空闲状态，直到一方有数据要传输。未管理的长时间空闲 TCP 会话可能导致内存的浪费。我们将在本章后面讨论如何在代码中管理空闲连接的技巧。
- en: When you initiate a connection in your code, Go will return either a connection
    object or an error. If you receive a connection object, the TCP handshake succeeded.
    You do not need to manage the handshake yourself.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在代码中发起连接时，Go 会返回一个连接对象或一个错误。如果你收到连接对象，则表示 TCP 握手成功。你无需自己管理握手过程。
- en: Acknowledging Receipt of Packets by Using Their Sequence Numbers
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用数据包的序列号确认接收数据包
- en: Each TCP packet contains a *sequence number*, which the receiver uses to acknowledge
    receipt of each packet and properly order the packets for presentation to your
    Go application ([Figure 3-2](#figure3-2)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 TCP 数据包都包含一个*序列号*，接收方用它来确认接收到每个数据包，并正确地对数据包进行排序，以便展示给你的 Go 应用程序（[图 3-2](#figure3-2)）。
- en: '![f03002](image_fi/500884c03/f03002.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![f03002](image_fi/500884c03/f03002.png)'
- en: 'Figure 3-2: Client and server exchanging sequence numbers'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-2：客户端和服务器交换序列号
- en: The client’s operating system determines the initial sequence number(X in [Figure
    3-2](#figure3-2)) and sends it to the server in the client’s SYN packet during
    the handshake. The server acknowledges receipt of the packet by including this
    sequence number in its ACK packet to the client. Likewise, the server shares its
    generated sequence number Y in its SYN packet to the client. The client replies
    with its ACK to the server.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的操作系统决定初始序列号（X，在[图 3-2](#figure3-2)中），并在握手过程中将其发送到服务器的 SYN 数据包中。服务器通过在其 ACK
    数据包中包含该序列号来确认收到该数据包。同样，服务器在其 SYN 数据包中将生成的序列号 Y 发送给客户端。客户端则通过 ACK 数据包回复服务器。
- en: An ACK packet uses the sequence number to tell the sender, “I’ve received all
    packets up to and including the packet with this sequence number.” One ACK packet
    can acknowledge the receipt of one or more packets from the sender. The sender
    uses the sequence number in the ACK packet to determine whether it needs to retransmit
    any packets. For example, if a sender transmits a bunch of packets with sequence
    numbers up through 100 but then receives an ACK from the receiver with sequence
    number 90, the sender knows it needs to retransmit packets from sequence numbers
    91 to 100.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ACK 数据包使用序列号告诉发送方：“我已接收到所有数据包，直到包括该序列号的包为止。”一个 ACK 数据包可以确认接收到一个或多个发送方的数据包。发送方使用
    ACK 数据包中的序列号来确定是否需要重新传输任何数据包。例如，如果发送方传输了多个序列号为 1 到 100 的数据包，但接收到来自接收方的序列号为 90
    的 ACK，发送方就知道它需要重新传输序列号为 91 到 100 的数据包。
- en: While writing and debugging network programs, it’s often necessary to view the
    traffic your code sends and receives. To capture and inspect TCP packets, I strongly
    recommend you familiarize yourself with Wireshark ([https://www.wireshark.org/](https://www.wireshark.org/)).
    This program will go a long way toward helping you understand how your code influences
    the data sent over the network. To learn more, see *Practical Packet Analysis*,
    3rd Edition, by Chris Sanders (No Starch, 2017).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写和调试网络程序时，经常需要查看你的代码发送和接收的流量。为了捕获和检查 TCP 数据包，我强烈建议你熟悉 Wireshark（[https://www.wireshark.org/](https://www.wireshark.org/)）。这个程序将极大帮助你理解你的代码如何影响网络上传输的数据。欲了解更多信息，请参阅
    Chris Sanders 所著的《*Practical Packet Analysis*》（第三版，No Starch，2017）。
- en: If you view your application’s network traffic in Wireshark, you may notice
    *selective acknowledgments (SACKs)*. These are ACK packets used to acknowledge
    the receipt of a *subset* of sent packets. For example, let’s assume the sender
    transmitted a hundred packets but only packets 1 to 59 and 81 to 100 made it to
    the receiver. The receiver could send a SACK to inform the sender what subset
    of packets it received.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Wireshark 中查看应用程序的网络流量，你可能会注意到*选择性确认（SACKs）*。这些是用于确认接收到*部分*发送数据包的 ACK 数据包。例如，假设发送方传输了
    100 个数据包，但只有数据包 1 到 59 和 81 到 100 到达接收方。接收方可以发送 SACK 数据包，告知发送方它接收到的部分数据包。
- en: Here again, Go handles the low-level details. Your code will not need to concern
    itself with sequence numbers and acknowledgments.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Go 处理了底层细节。你的代码无需关心序列号和确认信息。
- en: Receive Buffers and Window Sizes
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 接收缓冲区和窗口大小
- en: Since TCP allows a single ACK packet to acknowledge the receipt of more than
    one incoming packet, the receiver must advertise to the sender how much space
    it has available in its receive buffer before it sends an acknowledgment. A *receive
    buffer* is a block of memory reserved for incoming data on a network connection.
    The receive buffer allows the node to accept a certain amount of data from the
    network without requiring an application to immediately read the data. Both the
    client and the server maintain their own per-connection receive buffer. When your
    Go code reads data from a network connection object, it reads the data from the
    connection’s receive buffer.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于TCP允许单个ACK报文确认多个传入的数据包，因此接收方必须在发送确认之前，告知发送方其接收缓冲区还有多少可用空间。*接收缓冲区*是为网络连接上的传入数据保留的内存块。接收缓冲区允许节点在不要求应用程序立即读取数据的情况下，接受一定量的数据。客户端和服务器都维护着各自的每个连接的接收缓冲区。当你的Go代码从网络连接对象中读取数据时，它是从该连接的接收缓冲区读取数据。
- en: 'ACK packets include a particularly important piece of information: the *window
    size*, which is the number of bytes the sender can transmit to the receiver without
    requiring an acknowledgment. If the client sends an ACK packet to the server with
    a window size of 24,537, the server knows it can send 24,537 bytes to the client
    before expecting the client to send another ACK packet. A window size of zero
    indicates that the receiver’s buffer is full and can no longer receive additional
    data. We’ll discuss this scenario a bit later in this chapter.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ACK报文包含一个特别重要的信息：*窗口大小*，即发送方可以在不需要确认的情况下发送给接收方的字节数。如果客户端向服务器发送一个窗口大小为24,537的ACK报文，服务器就知道它可以向客户端发送24,537字节的数据，而无需客户端发送另一个ACK报文。窗口大小为零表示接收方的缓冲区已满，无法再接收更多数据。我们将在本章稍后讨论这种情况。
- en: Both the client and the server keep track of each other’s window size and do
    their best to completely fill each other’s receive buffers. This method—of receiving
    the window size in an ACK packet, sending data, receiving an updated window size
    in the next ACK, and then sending more data—is known as a *sliding window*, as
    shown in [Figure 3-3](#figure3-3). Each side of the connection offers up a window
    of data that can it can receive at any one time.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端和服务器都跟踪彼此的窗口大小，并尽力填满彼此的接收缓冲区。这种方法——在ACK报文中接收窗口大小，发送数据，在下一个ACK中接收更新后的窗口大小，然后发送更多数据——被称为*滑动窗口*，如[图3-3](#figure3-3)所示。连接的每一方都提供了一个可以在任何时刻接收的数据窗口。
- en: '![f03003](image_fi/500884c03/f03003.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![f03003](image_fi/500884c03/f03003.png)'
- en: 'Figure 3-3: A client’s ACKs advertising the amount of data it can receive'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图3-3：客户端的ACK广告，表示它能接收的数据量
- en: In this snippet of communication, the client sends an ACK for previously received
    data. This ACK includes a window size of 3,072 bytes. The server now knows that
    it can send up to 3,072 bytes before it requires an ACK from the client. The server
    sends three packets with 1,024 bytes each to fill the client’s receive buffer.
    The client then sends another ACK with an updated window size of 2,048 bytes.
    This means that the application running on the client read 2,048 bytes from the
    receive buffer before the client sent its acknowledgment to the server. The server
    then sends two more packets of 1,024 bytes to fill the client’s receive buffer
    and waits for another ACK.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段通信片段中，客户端发送了一个确认报文（ACK），用于确认之前接收到的数据。这个ACK包含了一个窗口大小为3,072字节。服务器现在知道，在收到客户端的确认之前，它最多可以发送3,072字节的数据。服务器发送了三个数据包，每个数据包大小为1,024字节，用以填充客户端的接收缓冲区。然后，客户端发送了另一个ACK，并更新了窗口大小为2,048字节。这意味着客户端运行的应用程序在发送确认报文之前，从接收缓冲区读取了2,048字节的数据。然后，服务器再发送两个1,024字节的数据包来填充客户端的接收缓冲区，并等待另一个ACK。
- en: Here again, all you need to concern yourself with is reading and writing to
    the connection object Go gives you when you establish a TCP connection. If something
    goes wrong, Go will surely let you know by returning an error.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你只需要关心的是在建立TCP连接时，Go为你提供的连接对象的读写操作。如果发生了问题，Go肯定会通过返回错误通知你。
- en: Gracefully Terminating TCP Sessions
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优雅地终止TCP会话
- en: Like the handshake process, gracefully terminating a TCP session involves exchanging
    a sequence of packets. Either side of the connection may initiate the termination
    sequence by sending a *finish (FIN)* packet. In [Figure 3-4](#figure3-4), the
    client initiates the termination by sending a FIN packet to the server.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 像握手过程一样，优雅地终止 TCP 会话也需要交换一系列数据包。连接的任何一方都可以通过发送 *finish (FIN)* 数据包来启动终止序列。在[图
    3-4](#figure3-4)中，客户端通过向服务器发送 FIN 数据包来发起终止。
- en: '![f03004](image_fi/500884c03/f03004.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![f03004](image_fi/500884c03/f03004.png)'
- en: 'Figure 3-4: The client initiates a TCP session termination with the server.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3-4：客户端向服务器发起 TCP 会话终止。
- en: The client’s connection state changes from ESTABLISHED to FIN_WAIT_1, which
    indicates the client is in the process of tearing down the connection from its
    end and is waiting for the server’s acknowledgment. The server acknowledges the
    client’s FIN and changes its connection state from ESTABLISHED to CLOSE_WAIT.
    The server sends its own FIN packet, changing its state to LAST_ACK, indicating
    it’s waiting for a final acknowledgment from the client. The client acknowledges
    the server’s FIN and enters a TIME_WAIT state, whose purpose is to allow the client’s
    final ACK packet to reach the server. The client waits for twice the maximum segment
    lifetime (the segment lifetime arbitrarily defaults to two minutes, per RFC 793,
    but your operating system may allow you to tweak this value), then changes its
    connection state to CLOSED without any further input required from the server.
    The *maximum segment lifetime* is the duration a TCP segment can remain in transit
    before the sender considers it abandoned. Upon receiving the client’s last ACK
    packet, the server immediately changes its connection state to CLOSED, fully terminating
    the TCP session.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的连接状态从 ESTABLISHED 变为 FIN_WAIT_1，表示客户端正在从自身端拆除连接，并等待服务器的确认。服务器确认客户端的 FIN
    后，将连接状态从 ESTABLISHED 变为 CLOSE_WAIT。服务器发送自己的 FIN 数据包，连接状态变为 LAST_ACK，表示它在等待客户端的最终确认。客户端确认服务器的
    FIN 后进入 TIME_WAIT 状态，目的是让客户端的最后一个 ACK 数据包能够到达服务器。客户端等待最大报文段生存时间的两倍（根据 RFC 793，报文段生存时间默认是两分钟，但操作系统可能允许你调整此值），然后将连接状态改为
    CLOSED，且不再需要服务器的任何进一步输入。*最大报文段生存时间*是指 TCP 报文段在传输中可以存在的最长时间，超过此时间发送方会认为它已经丢失。收到客户端最后一个
    ACK 数据包后，服务器立即将连接状态改为 CLOSED，完全终止 TCP 会话。
- en: Like the initial handshake, Go handles the details of the TCP connection teardown
    process when you close a connection object.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 像初始握手一样，当你关闭连接对象时，Go 会处理 TCP 连接拆除过程中的细节。
- en: Handling Less Graceful Terminations
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理不太优雅的连接终止
- en: Not all connections politely terminate. In some cases, the application that
    opened a TCP connection may crash or abruptly stop running for some reason. When
    this happens, the TCP connection is immediately closed. Any packets sent from
    the other side of the former connection will prompt the closed side of the connection
    to return a *reset (RST) packet*. The RST packet informs the sender that the receiver’s
    side of the connection closed and will no longer accept data. The sender should
    close its side of the connection knowing the receiver ignored any packets it did
    not acknowledge.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有连接都能礼貌地终止。在某些情况下，打开 TCP 连接的应用程序可能会崩溃或因为某种原因突然停止运行。这时，TCP 连接会立即关闭。来自原连接另一端的任何数据包都会触发关闭一端返回
    *reset (RST) 数据包*。RST 数据包通知发送方，接收方的连接已关闭，不再接受数据。发送方应该关闭连接的一侧，知道接收方忽略了任何未确认的数据包。
- en: Intermediate nodes, such as firewalls, can send RST packets to each node in
    a connection, effectively terminating the socket from the middle.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 中间节点，如防火墙，能够向连接中的每个节点发送 RST 数据包，从而在中间终止连接。
- en: Establishing a TCP Connection by Using Go’s Standard Library
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Go 标准库建立 TCP 连接
- en: The `net` package in Go’s standard library includes good support for creating
    TCP-based servers and clients capable of connecting to those servers. Even so,
    it’s your responsibility to make sure you handle the connection appropriately.
    Your software should be attentive to incoming data and always strive to gracefully
    shut down the connection. Let’s write a TCP server that can listen for incoming
    TCP connections, initiate connections from a client, accept and asynchronously
    handle each connection, exchange data, and terminate the connection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Go标准库中的`net`包提供了良好的支持，用于创建基于TCP的服务器和客户端，并能够连接到这些服务器。尽管如此，确保正确处理连接仍然是你的责任。你的软件应该时刻关注传入的数据，并始终努力优雅地关闭连接。让我们编写一个TCP服务器，能够监听传入的TCP连接，客户端发起连接，接受并异步处理每个连接，交换数据，并终止连接。
- en: Binding, Listening for, and Accepting Connections
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定、监听和接受连接
- en: To create a TCP server capable of listening for incoming connections (called
    a *listener*), use the `net.Listen` function. This function will return an object
    that implements the `net.Listener` interface. [Listing 3-1](#listing3-1) shows
    the creation of a listener.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个能够监听传入连接的TCP服务器（称为*监听器*），使用`net.Listen`函数。这个函数将返回一个实现了`net.Listener`接口的对象。[列表
    3-1](#listing3-1)展示了如何创建一个监听器。
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 3-1: Creating a listener on 127.0.0.1 using a random port (*listen_test.go*)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-1：使用随机端口在127.0.0.1上创建监听器 (*listen_test.go*)
- en: The `net.Listen` function accepts a network type 2 and an IP address and port
    separated by a colon 3. The function returns a `net.Listener` interface 1 and
    an `error` interface. If the function returns successfully, the listener is bound
    to the specified IP address and port. *Binding* means that the operating system
    has exclusively assigned the port on the given IP address to the listener. The
    operating system allows no other processes to listen for incoming traffic on bound
    ports. If you attempt to bind a listener to a currently bound port, `net.Listen`
    will return an error.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`net.Listen`函数接受一个网络类型2和一个由冒号分隔的IP地址和端口3。该函数返回一个`net.Listener`接口1和一个`error`接口。如果函数成功返回，监听器将绑定到指定的IP地址和端口。*绑定*意味着操作系统已将给定IP地址上的端口专门分配给监听器。操作系统不允许其他进程在绑定的端口上监听传入的流量。如果你尝试将监听器绑定到当前已绑定的端口，`net.Listen`将返回错误。'
- en: You can choose to leave the IP address and port parameters empty. If the port
    is zero or empty, Go will randomly assign a port number to your listener. You
    can retrieve the listener’s address by calling its `Addr` method 5. Likewise,
    if you omit the IP address, your listener will be bound to all unicast and anycast
    IP addresses on the system. Omitting both the IP address and port, or passing
    in a colon for the second argument to `net.Listen`, will cause your listener to
    bind to all unicast and anycast IP addresses using a random port.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择将IP地址和端口参数留空。如果端口为零或为空，Go将为你的监听器随机分配一个端口号。你可以通过调用其`Addr`方法5来检索监听器的地址。同样，如果省略IP地址，监听器将绑定到系统上的所有单播和任播IP地址。如果同时省略IP地址和端口，或者将冒号作为第二个参数传递给`net.Listen`，则会导致监听器绑定到所有单播和任播IP地址，并使用随机端口。
- en: In most cases, you should use `tcp` as the network type for `net.Listener`’s
    first argument. You can restrict the listener to just IPv4 addresses by passing
    in `tcp4` or exclusively bind to IPv6 addresses by passing in `tcp6`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你应该将`tcp`作为`net.Listener`第一个参数的网络类型。你可以通过传入`tcp4`来限制监听器仅绑定到IPv4地址，或者通过传入`tcp6`来专门绑定到IPv6地址。
- en: You should always be diligent about closing your listener gracefully by calling
    its `Close` method 4, often in a `defer` if it makes sense for your code. Granted,
    this is a test case, and Go will tear down the listener when the test completes,
    but it’s good practice nonetheless. Failure to close the listener may lead to
    memory leaks or deadlocks in your code, because calls to the listener’s `Accept`
    method may block indefinitely. Closing the listener immediately unblocks calls
    to the `Accept` method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终小心优雅地关闭监听器，调用其`Close`方法4，通常如果对你的代码有意义，可以在`defer`中进行。诚然，这是一个测试用例，Go会在测试完成时拆除监听器，但这仍然是良好的实践。不关闭监听器可能会导致内存泄漏或死锁，因为对监听器的`Accept`方法的调用可能会无限期阻塞。立即关闭监听器会解除`Accept`方法的阻塞。
- en: '[Listing 3-2](#listing3-2) demonstrates how a listener can accept incoming
    TCP connections.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 3-2](#listing3-2)演示了监听器如何接受传入的TCP连接。'
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 3-2: Accepting and handling incoming TCP connection requests'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3-2：接受并处理传入的TCP连接请求
- en: Unless you want to accept only a single incoming connection, you need to use
    a `for` loop 1 so your server will accept each incoming connection, handle it
    in a goroutine, and loop back around, ready to accept the next connection. Serially
    accepting connections is perfectly acceptable and efficient, but beyond that point,
    you should use a goroutine to handle each connection. You could certainly write
    serialized code after accepting a connection if your use case demands it, but
    it would be woefully inefficient and fail to take advantage of Go’s strengths.
    We start the `for` loop by calling the listener’s `Accept` method 2. This method
    will block until the listener detects an incoming connection and completes the
    TCP handshake process between the client and the server. The call returns a `net.Conn`
    interface 3 and an `error`. If the handshake failed or the listener closed, for
    example, the error interface would be non-`nil`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你只想接受单个传入连接，否则你需要使用 `for` 循环 1，这样你的服务器就会接受每个传入连接，并在 goroutine 中处理它，然后继续循环，准备接受下一个连接。串行接受连接是完全可以接受的，而且效率也不错，但超出这个范围后，你应该使用
    goroutine 来处理每个连接。如果你的用例要求你可以写出串行化的代码来接受连接，但那样做会非常低效，并且无法充分发挥 Go 的优势。我们通过调用监听器的
    `Accept` 方法 2 来启动 `for` 循环。这个方法会阻塞，直到监听器检测到传入的连接并完成客户端和服务器之间的 TCP 握手过程。该调用返回一个
    `net.Conn` 接口 3 和一个 `error`。例如，如果握手失败或监听器关闭，错误接口将为非 `nil`。
- en: The connection interface’s underlying type is a pointer to a `net.TCPConn` object
    because you’re accepting TCP connections. The connection interface represents
    the server’s side of the TCP connection. In most cases, `net.Conn` provides all
    methods you’ll need for general interactions with the client. However, the `net.TCPConn`
    object provides additional functionality we’ll cover in Chapter 4 should you require
    more control.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 连接接口的底层类型是指向 `net.TCPConn` 对象的指针，因为你正在接受 TCP 连接。连接接口代表服务器端的 TCP 连接。在大多数情况下，`net.Conn`
    提供了与客户端进行一般交互所需的所有方法。然而，如果你需要更多的控制，`net.TCPConn` 对象提供了额外的功能，我们将在第 4 章讨论这些功能。
- en: To concurrently handle client connections, you spin off a goroutine to asynchronously
    handle each connection 4 so your listener can ready itself for the next incoming
    connection. Then you call the connection’s `Close` method 5 before the goroutine
    exits to gracefully terminate the connections by sending a FIN packet to the server.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了并发处理客户端连接，你会启动一个 goroutine 异步处理每个连接 4，这样监听器就可以为下一个传入的连接做好准备。然后，在 goroutine
    退出之前，你调用连接的 `Close` 方法 5，以通过发送 FIN 数据包来优雅地终止与服务器的连接。
- en: Establishing a Connection with a Server
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与服务器建立连接
- en: From the client’s side, Go’s standard library `net` package makes reaching out
    and establishing a connection with a server a simple matter. [Listing 3-3](#listing3-3)
    is a test that demonstrates the process of initiating a TCP connection with a
    server listening to 127.0.0.1 on a random port.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端的角度来看，Go 的标准库 `net` 包使得与服务器建立连接变得非常简单。[清单 3-3](#listing3-3) 是一个示例，演示了如何发起与监听在
    127.0.0.1 上的服务器的 TCP 连接，端口是随机选择的。
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Listing 3-3: Establishing a connection to 127.0.0.1 (*dial_test.go*)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-3：建立与 127.0.0.1 的连接 (*dial_test.go*)
- en: You start by creating a listener on the IP address 127.0.0.1, which the client
    will connect to. You omit the port number altogether, so Go will randomly pick
    an available port for you. Then, you spin off the listener in a goroutine 1 so
    you can work with the client’s side of the connection later in the test. The listener’s
    goroutine contains code like [Listing 3-2](#listing3-2)’s for accepting incoming
    TCP connections in a loop, spinning off each connection into its own goroutine.
    (We often call this goroutine a *handler*. I’ll explain the implementation details
    of the handler shortly, but it will read up to 1024 bytes from the socket at a
    time and log what it received.)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你在 IP 地址 127.0.0.1 上创建一个监听器，客户端将连接到该地址。你完全省略了端口号，因此 Go 会随机选择一个可用的端口。然后，你将监听器放入一个
    goroutine 1 中，这样你就可以在测试的后续部分处理客户端的连接。监听器的 goroutine 包含类似 [清单 3-2](#listing3-2)
    的代码，用于循环接受传入的 TCP 连接，并将每个连接放入自己的 goroutine 中。（我们通常称这个 goroutine 为 *handler*。我稍后会解释
    handler 的实现细节，但它会一次从套接字读取最多 1024 字节，并记录它接收到的内容。）
- en: The standard library’s `net`.`Dial` function is like the `net.Listen` function
    in that it accepts a network 6 like `tcp` and an IP address and port combination
    7—in this case, the IP address and port of the listener to which it’s trying to
    connect. You can use a hostname in place of an IP address and a service name,
    like *http*, in place of a port number. If a hostname resolves to more than one
    IP address, Go will attempt a connection to each one in order until a connection
    succeeds or all IP addresses have been exhausted. Since IPv6 addresses include
    colon delimiters, you must enclose an IPv6 address in square brackets. For example,
    `"[2001:ed27::1]:https"` specifies port 443 at the IPv6 address 2001:ed27::1\.
    `Dial` returns a connection object 5 and an `error` interface value.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库的`net`.`Dial`函数与`net.Listen`函数类似，都会接受一个网络协议（如`tcp`）以及一个IP地址和端口的组合——在此案例中，是目标监听器的IP地址和端口。你可以用主机名代替IP地址，用服务名（如*http*）代替端口号。如果主机名解析为多个IP地址，Go会按顺序尝试每一个，直到成功连接或所有IP地址尝试完毕。由于IPv6地址包含冒号分隔符，因此必须将IPv6地址用方括号括起来。例如，`"[2001:ed27::1]:https"`表示IPv6地址2001:ed27::1的443端口。`Dial`返回一个连接对象和一个`error`接口值。
- en: Now that you’ve established a successful connection to the listener, you initiate
    a graceful termination of the connection from the client’s side 8. After receiving
    the FIN packet, the `Read` method 4 returns the `io.EOF` error, indicating to
    the listener’s code that you closed your side of the connection. The connection’s
    handler 3 exits, calling the connection’s `Close` method on the way out. This
    sends a FIN packet to your connection, completing the graceful termination of
    the TCP session.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功连接到监听器，从客户端一侧启动优雅关闭连接。接收到FIN包后，`Read`方法会返回`io.EOF`错误，通知监听器代码你已经关闭了连接的一端。连接的处理程序会退出，并在退出时调用连接的`Close`方法。这将向你的连接发送一个FIN包，完成TCP会话的优雅终止。
- en: Finally, you close the listener 9. The listener’s `Accept` method 2 immediately
    unblocks and returns an error. This error isn’t necessarily a failure, so you
    simply log it and move on. It doesn’t cause your test to fail. The listener’s
    goroutine 1 exits, and the test completes.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你关闭监听器。监听器的`Accept`方法会立即解除阻塞并返回一个错误。这个错误不一定是失败，所以你只需记录它并继续。这不会导致你的测试失败。监听器的goroutine退出，测试完成。
- en: Understanding Time-outs and Temporary Errors
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解超时和临时错误
- en: In a perfect world, your connection attempts will immediately succeed, and all
    read and write attempts will never fail. But you need to hope for the best and
    prepare for the worst. You need a way to determine whether an error is temporary
    or something that warrants termination of the connection altogether. The `error`
    interface doesn’t provide enough information to make that determination. Thankfully,
    Go’s `net` package provides more insight if you know how to use it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界里，你的连接尝试会立即成功，所有的读写尝试永远不会失败。但你需要期望最好的同时准备最坏的情况。你需要一种方式来判断一个错误是否是临时的，或者是否需要完全终止连接。`error`接口提供的信息不足以做出这种判断。幸运的是，Go的`net`包提供了更多的洞察，只要你知道如何使用它。
- en: 'Errors returned from functions and methods in the `net` package typically implement
    the `net.Error` interface, which includes two notable methods: `Timeout` and `Temporary`.
    The `Timeout` method returns `true` on Unix-based operating systems and Windows
    if the operating system tells Go that the resource is temporarily unavailable,
    the call would block, or the connection timed out. We’ll touch on time-outs and
    how you can use them to your advantage a bit later in this chapter. The `Temporary`
    method returns `true` if the error''s `Timeout` function returns `true`, the function
    call was interrupted, or there are too many open files on the system, usually
    because you’ve exceeded the operating system’s resource limit.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从`net`包中的函数和方法返回的错误通常实现了`net.Error`接口，其中包括两个重要的方法：`Timeout`和`Temporary`。当操作系统告诉Go资源暂时不可用、调用会被阻塞，或连接超时时，`Timeout`方法会返回`true`，在Unix系统和Windows中都是如此。稍后我们会讨论如何利用超时。`Temporary`方法会在错误的`Timeout`函数返回`true`、函数调用被中断，或者系统中打开的文件过多时返回`true`，通常是因为你超过了操作系统的资源限制。
- en: Since the functions and methods in the `net` package return the more general
    `error` interface, you’ll see the code in this chapter use type assertions to
    verify you received a `net.Error`, as in [Listing 3-4](#listing3-4).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`net`包中的函数和方法返回的是更通用的`error`接口，因此你会看到本章的代码使用类型断言来验证是否收到`net.Error`，如[Listing
    3-4](#listing3-4)所示。
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Listing 3-4: Asserting a `net.Error` to check whether the error was temporary'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 3-4：断言`net.Error`以检查错误是否是临时的
- en: Robust network code won’t rely exclusively on the `error` interface. Rather,
    it will readily use `net.Error`’s methods, or even dive in further and assert
    the underlying `net.OpError` struct, which contains more details about the connection,
    such as the operation that caused the error, the network type, the source address,
    and more. I encourage you to read the `net.OpError` documentation (available at
    [https://golang.org/pkg/net/#OpError/](https://golang.org/pkg/net/#OpError/))
    to learn more about specific errors beyond what the `net.Error` interface provides.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 稳健的网络代码不会仅仅依赖于`error`接口。相反，它会充分利用`net.Error`的方法，甚至进一步深入并断言底层的`net.OpError`结构体，该结构体包含有关连接的更多细节，如导致错误的操作、网络类型、源地址等。我鼓励你阅读`net.OpError`的文档（可以在[https://golang.org/pkg/net/#OpError/](https://golang.org/pkg/net/#OpError/)找到），以了解`net.Error`接口之外的具体错误。
- en: Timing Out a Connection Attempt with the DialTimeout Function
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`DialTimeout`函数进行连接超时处理
- en: 'Using the `Dial` function has one potential problem: you are at the mercy of
    the operating system to time out each connection attempt. For example, if you
    use the `Dial` function in an interactive application and your operating system
    times out connection attempts after two hours, your application’s user may not
    want to wait that long, much less give your app a five-star rating.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Dial`函数有一个潜在的问题：你只能依赖操作系统来超时每个连接尝试。例如，如果你在交互式应用程序中使用`Dial`函数，而你的操作系统在两个小时后超时连接尝试，那么应用程序的用户可能不想等这么久，更不用说给你的应用程序打五星好评了。
- en: To keep your applications predictable and your users happy, it’d be better to
    control time-outs yourself. For example, you may want to initiate a connection
    to a low-latency service that responds quickly if it’s available. If the service
    isn’t responding, you’ll want to time out quickly and move onto the next service.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持应用程序的可预测性并让用户满意，最好自己控制超时。例如，你可能希望连接到一个低延迟的服务，该服务在可用时会迅速响应。如果该服务没有响应，你将希望快速超时并切换到下一个服务。
- en: One solution is to explicitly define a per-connection time-out duration and
    use the `DialTimeout` function instead. [Listing 3-5](#listing3-5) implements
    this solution.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一种解决方案是显式定义每个连接的超时时间，并改用`DialTimeout`函数。[Listing 3-5](#listing3-5)实现了这个解决方案。
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Listing 3-5: Specifying a time-out duration when initiating a TCP connection
    (*dial_timeout_test.go*)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 3-5：在发起TCP连接时指定超时持续时间（*dial_timeout_test.go*）
- en: Since the `net.DialTimeout` function 1 does not give you control of its `net.Dialer`
    to mock the dialer’s output, you’re using our own implementation that matches
    the signature. Your `DialTimeout` function overrides the `Control` function 2
    of the `net.Dialer` to return an error. You’re mocking a DNS time-out error.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`net.DialTimeout`函数1没有让你控制其`net.Dialer`来模拟拨号器的输出，你正在使用我们自己实现的、符合签名的版本。你的`DialTimeout`函数重写了`net.Dialer`的`Control`函数2以返回一个错误。你在模拟DNS超时错误。
- en: Unlike the `net.Dial` function, the `DialTimeout` function includes an additional
    argument, the time-out duration 3. Since the time-out duration is five seconds
    in this case, the connection attempt will time out if a connection isn’t successful
    within five seconds. In this test, you dial 10.0.0.0, which is a non-routable
    IP address, meaning your connection attempt assuredly times out. For the test
    to pass, you need to first use a type assertion to verify you’ve received a `net.Error`4
    before you can check its `Timeout` method 5.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与`net.Dial`函数不同，`DialTimeout`函数包含一个额外的参数——超时持续时间3。由于此处的超时持续时间为五秒，如果连接未在五秒内成功建立，则连接尝试将超时。在这个测试中，你拨号到10.0.0.0，这是一个不可路由的IP地址，意味着你的连接尝试必然会超时。为了使测试通过，你需要首先使用类型断言来验证你已经收到`net.Error`4，然后才能检查它的`Timeout`方法5。
- en: If you dial a host that resolves to multiple IP addresses, Go starts a connection
    race between each IP address, giving the primary IP address a head start. The
    first connection to succeed persists, and the remaining contenders cancel their
    connection attempts. If all connections fail or time out, `net.DialTimeout` returns
    an error.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拨打一个解析到多个IP地址的主机，Go会在每个IP地址之间启动连接竞争，给主要IP地址一个先发优势。第一个成功的连接将继续存在，其余的竞争者会取消连接尝试。如果所有连接都失败或超时，`net.DialTimeout`会返回一个错误。
- en: Using a Context with a Deadline to Time Out a Connection
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用带有截止时间的上下文来超时连接
- en: A more contemporary solution to timing out a connection attempt is to use a
    context from the standard library’s `context` package. A *context* is an object
    that you can use to send cancellation signals to your asynchronous processes.
    It also allows you to send a cancellation signal after it reaches a deadline or
    after its timer expires.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更现代的解决方案是使用标准库的`context`包中的上下文来超时连接尝试。*上下文*是一个对象，你可以用它向异步进程发送取消信号。它还允许你在达到截止时间或计时器到期后发送取消信号。
- en: All cancellable contexts have a corresponding `cancel` function returned upon
    instantiation. The `cancel` function offers increased flexibility since you can
    optionally cancel the context before the context reaches its deadline. You could
    also pass along its `cancel` function to hand off cancellation control to other
    bits of your code. For example, you could monitor for specific signals from your
    operating system, such as the one sent to your application when a user presses
    the ctrl-C key combination, to gracefully abort connection attempts and tear down
    existing connections before terminating your application.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可取消的上下文在实例化时都会返回一个相应的`cancel`函数。`cancel`函数提供了更大的灵活性，因为你可以选择在上下文达到截止时间之前取消上下文。你还可以将其`cancel`函数传递给其他部分的代码，以移交取消控制。例如，你可以监听操作系统发出的特定信号，例如在用户按下ctrl-C键组合时发送到应用程序的信号，以便在终止应用程序之前优雅地中止连接尝试并拆除现有连接。
- en: '[Listing 3-6](#listing3-6) illustrates a test that accomplishes the same functionality
    as `DialTimeout`, using `context` instead.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-6](#listing3-6)展示了一个测试，它使用`context`代替`DialTimeout`实现相同的功能。'
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 3-6: Using a context with a deadline to time out the connection attempt
    (*dial_context_test.go*)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3-6：使用带有截止时间的上下文来超时连接尝试（*dial_context_test.go*）
- en: Before you make a connection attempt, you create the context with a deadline
    of five seconds into the future 1, after which the context will automatically
    cancel. Next, you create the context and its `cancel` function by using the `context.WithDeadline`
    function 2, setting the deadline in the process. It’s good practice to defer the
    `cancel` function 3 to make sure the context is garbage collected as soon as possible.
    Then, you override the dialer’s `Control` function 4 to delay the connection just
    long enough to make sure you exceed the context’s deadline. Finally, you pass
    in the context as the first argument to the `DialContext` function 5. The sanity
    check 6 at the end of the test makes sure that reaching the deadline canceled
    the context, not an erroneous call to `cancel`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在你进行连接尝试之前，你创建一个未来五秒的截止时间上下文 1，之后上下文会自动取消。接着，你使用`context.WithDeadline`函数 2 创建上下文及其`cancel`函数，并在过程中设置截止时间。良好的实践是延迟调用`cancel`函数
    3，以确保上下文尽快被垃圾回收。然后，你重写拨号器的`Control`函数 4，稍微延迟连接，确保超过上下文的截止时间。最后，你将上下文作为第一个参数传递给`DialContext`函数
    5。测试末尾的健全性检查 6 确保是达到截止时间取消了上下文，而不是错误地调用了`cancel`。
- en: As with `DialTimeout`, if a host resolves to multiple IP addresses, Go starts
    a connection race between each IP address, giving the primary IP address a head
    start. The first connection to succeed persists, and the remaining contenders
    cancel their connection attempts. If all connections fail or the context reaches
    its deadline, `net.Dialer.DialContext` returns an error.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与`DialTimeout`一样，如果一个主机解析到多个IP地址，Go会在每个IP地址之间启动连接竞争，给主要IP地址一个先发优势。第一个成功的连接将继续存在，其余的竞争者会取消连接尝试。如果所有连接都失败或上下文达到截止时间，`net.Dialer.DialContext`会返回一个错误。
- en: Aborting a Connection by Canceling the Context
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过取消上下文来中止连接
- en: Another advantage to using a context is the `cancel` function itself. You can
    use it to cancel the connection attempt on demand, without specifying a deadline,
    as shown in [Listing 3-7](#listing3-7).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上下文的另一个好处是`cancel`函数本身。你可以使用它按需取消连接尝试，而无需指定截止时间，如[示例 3-7](#listing3-7)所示。
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 3-7: Directly canceling the context to abort the connection attempt'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 示例3-7：直接取消上下文以中止连接尝试
- en: (*dial_cancel_test.go*)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: (*dial_cancel_test.go*)
- en: Instead of creating a context with a deadline and waiting for the deadline to
    abort the connection attempt, you use `context.WithCancel` to return a context
    and a function to cancel the context 1. Since you’re manually canceling the context,
    you create a closure and spin it off in a goroutine to handle the connection attempt
    2. Once the dialer is attempting to connect to and handshake with the remote node,
    you call the `cancel` function 3to cancel the context. This causes the `DialContext`
    method to immediately return with a non-`nil` error, exiting the goroutine. You
    can check the context’s `Err` method to make sure the call to cancel was what
    resulted in the canceled context, as opposed to a deadline in [Listing 3-6](#listing3-6).
    In this case, the context’s `Err` method should return a `context.Canceled` error
    4.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`context.WithCancel`来返回一个上下文和一个取消该上下文的函数，而不是创建一个带有截止日期的上下文并等待截止日期中止连接尝试1。由于你是手动取消上下文，因此你需要创建一个闭包，并在一个goroutine中启动它来处理连接尝试2。一旦拨号器尝试连接并与远程节点进行握手，你调用`cancel`函数3来取消上下文。这将导致`DialContext`方法立即返回一个非`nil`错误，从而退出goroutine。你可以检查上下文的`Err`方法，以确保取消调用是导致上下文被取消的原因，而不是[示例3-6](#listing3-6)中的截止日期。在这种情况下，上下文的`Err`方法应返回一个`context.Canceled`错误4。
- en: Canceling Multiple Dialers
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 取消多个拨号器
- en: You can pass the same context to multiple `DialContext` calls and cancel all
    the calls at the same time by executing the context’s `cancel` function. For example,
    let’s assume you need to retrieve a resource via TCP that is on several servers.
    You can asynchronously dial each server, passing each dialer the same context.
    You can then abort the remaining dialers after you receive a response from one
    of the servers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将相同的上下文传递给多个`DialContext`调用，并通过执行上下文的`cancel`函数同时取消所有调用。例如，假设你需要通过TCP检索一个位于多个服务器上的资源。你可以异步地拨打每个服务器，将相同的上下文传递给每个拨号器。然后，在收到其中一个服务器的响应后，你可以中止其余的拨号器。
- en: In [Listing 3-8](#listing3-8), you pass the same context to multiple dialers.
    When you receive the first response, you cancel the context and abort the remaining
    dialers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例3-8](#listing3-8)中，你将相同的上下文传递给多个拨号器。当你收到第一个响应时，你取消上下文并中止剩余的拨号器。
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 3-8: Canceling all outstanding dialers after receiving the first response
    (*dial_fanout_test.go*)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 示例3-8：在收到第一个响应后取消所有未完成的拨号器 (*dial_fanout_test.go*)
- en: 'You create a context by using `context.WithDeadline`1 because you want to have
    three potential results when checking the context’s `Err` method: `context.Canceled`,
    `context.DeadlineExceeded`, or `nil`. You expect `Err` will return the `context.Canceled`
    error, since your test aborts the dialers with a call to the `cancel` function.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用`context.WithDeadline`1创建一个上下文，因为你希望在检查上下文的`Err`方法时得到三种可能的结果：`context.Canceled`、`context.DeadlineExceeded`或`nil`。你预计`Err`将返回`context.Canceled`错误，因为你的测试通过调用`cancel`函数中止了拨号器。
- en: First, you need a listener. This listener accepts a single connection and closes
    it after the successful handshake 2. Next, you create your dialers. Since you’re
    spinning up multiple dialers, it makes sense to abstract the dialing code to its
    own function 3. This anonymous function dials out to the given address by using
    `DialContext`. If it succeeds, it sends the dialer’s ID across the response channel,
    provided you haven’t yet canceled the context. You spin up multiple dialers by
    calling `dial` in separate goroutines using a `for` loop 4. If `dial` blocks on
    the call to `DialContext` because another dialer won the race, you cancel the
    context, either by way of the `cancel` function or the deadline, causing the dial
    function to exit early. You use a wait group to make sure the test doesn’t proceed
    until all `dial` goroutines terminate after you cancel the context.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要一个监听器。这个监听器接受一个连接，并在成功握手后关闭该连接2。接下来，你创建你的拨号器。由于你要启动多个拨号器，因此将拨号代码抽象到一个独立的函数中是合理的3。这个匿名函数使用`DialContext`拨打给定的地址。如果成功，它会将拨号器的ID通过响应通道发送出去，前提是你还没有取消上下文。你通过在不同的goroutine中使用`for`循环调用`dial`来启动多个拨号器4。如果`dial`在调用`DialContext`时被阻塞，因为另一个拨号器赢得了竞赛，你会取消上下文，无论是通过`cancel`函数还是截止日期，导致拨号函数提前退出。你使用一个等待组来确保在取消上下文后，测试不会继续，直到所有`dial`的goroutine终止。
- en: Once the goroutines are running, one will win the race and make a successful
    connection to the listener. You receive the winning dialer’s ID on the `res` channel
    5, then abort the losing dialers by canceling the context. At this point, the
    call to `wg.Wait` blocks until the aborted dialer goroutines return. Finally,
    you make sure it was your call to `cancel` that caused the cancelation of the
    context 6. Calling `cancel` does not guarantee that `Err` will return `context.Canceled`.
    The deadline can cancel the context, at which point calls to `cancel` become a
    no-op and `Err` will return `context.DeadlineExceeded`. In practice, the distinction
    may not matter to you, but it’s there if you need it.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦goroutine开始运行，其中一个将赢得比赛并成功连接到监听器。你会在`res`通道5上收到获胜拨号器的ID，然后通过取消上下文来中止失败的拨号器。此时，`wg.Wait`的调用会阻塞，直到被中止的拨号器goroutine返回。最后，你确保是你调用的`cancel`导致了上下文的取消6。调用`cancel`并不能保证`Err`返回`context.Canceled`。截止时间可以取消上下文，此时调用`cancel`将变为无操作，`Err`将返回`context.DeadlineExceeded`。在实际操作中，这个区别可能对你来说无关紧要，但如果你需要，它还是存在的。
- en: Implementing Deadlines
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现截止时间
- en: Go’s network connection objects allow you to include deadlines for both read
    and write operations. Deadlines allow you to control how long network connections
    can remain idle, where no packets traverse the connection. You can control the
    `Read` deadline by using the `SetReadDeadline` method on the connection object,
    control the `Write` deadline by using the `SetWriteDeadline` method, or both by
    using the `SetDeadline` method. When a connection reaches its read deadline, all
    currently blocked and future calls to a network connection’s `Read` method immediately
    return a time-out error. Likewise, a network connection’s `Write` method returns
    a time-out error when the connection reaches its write deadline.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Go的网络连接对象允许你为读取和写入操作设置截止时间。截止时间允许你控制网络连接在没有数据包传输的情况下能保持空闲多久。你可以通过在连接对象上使用`SetReadDeadline`方法来控制`Read`截止时间，使用`SetWriteDeadline`方法来控制`Write`截止时间，或者通过`SetDeadline`方法同时控制两者。当连接达到其读取截止时间时，所有当前阻塞的和未来对网络连接`Read`方法的调用会立即返回超时错误。同样，当连接达到写入截止时间时，网络连接的`Write`方法会返回超时错误。
- en: Go’s network connections don’t set any deadline for reading and writing operations
    by default, meaning your network connections may remain idle for a long time.
    This could prevent you from detecting network failures, like an unplugged cable,
    in a timely manner, because it’s tougher to detect network issues between two
    nodes when no traffic is in flight.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Go的网络连接默认不设置读取和写入操作的截止时间，这意味着你的网络连接可能会长时间保持空闲。这可能导致你无法及时发现网络故障，例如断开连接的电缆，因为当没有流量传输时，检测两个节点之间的网络问题会更加困难。
- en: The server in [Listing 3-9](#listing3-9) implements a deadline on its connection
    object.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-9](#listing3-9)中的服务器实现了其连接对象的截止时间。'
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Listing 3-9: A server-enforced deadline terminates the network connection (*deadline_test.go*).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-9：服务器强制截止时间终止网络连接（*deadline_test.go*）。
- en: Once the server accepts the client’s TCP connection, you set the connection’s
    read deadline 1. Since the client won’t send data, the call to `Read` will block
    until the connection exceeds the read deadline. After five seconds, `Read` returns
    an error, which you verify is a time-out 2. Any future reads to the connection
    object will immediately result in another time-out error. However, you can restore
    the functionality of the connection object by pushing the deadline forward again
    3. After you’ve done this, a second call to `Read` succeeds. The server closes
    its end of the network connection, which initiates the termination process with
    the client. The client, currently blocked on its `Read` call, returns `io.EOF`4
    when the network connection closes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器接受客户端的TCP连接，你就为连接设置了读取截止时间1。由于客户端不会发送数据，`Read`方法的调用会阻塞，直到连接超过读取截止时间。五秒钟后，`Read`返回一个错误，你验证它是一个超时错误2。对连接对象的任何未来读取操作将立即导致另一个超时错误。然而，你可以通过再次将截止时间推迟来恢复连接对象的功能3。这样做之后，第二次调用`Read`会成功。服务器关闭其网络连接的一端，这会启动与客户端的终止过程。客户端当前在`Read`调用上被阻塞，当网络连接关闭时，返回`io.EOF`4。
- en: We typically use deadlines to provide a window of time during which the remote
    node can send data over the network connection. When you read data from the remote
    node, you push the deadline forward. The remote node sends more data, and you
    push the deadline forward again, and so on. If you don’t hear from the remote
    node in the allotted time, you can assume that either the remote node is gone
    and you never received its FIN or that it is idle.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用截止时间来提供一个窗口，在这个时间窗口内远程节点可以通过网络连接发送数据。当你从远程节点读取数据时，会将截止时间往后推。远程节点发送更多数据时，你再次将截止时间推后，以此类推。如果在规定的时间内没有收到远程节点的消息，你可以假设远程节点已消失且没有收到其
    FIN，或者它处于空闲状态。
- en: Implementing a Heartbeat
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现心跳
- en: For long-running network connections that may experience extended idle periods
    at the application level, it’s wise to implement a heartbeat between nodes to
    advance the deadline. This allows you to quickly identify network issues and promptly
    reestablish a connection as opposed to waiting to detect the network error when
    your application goes to transmit data. In this way, you can help make sure your
    application always has a good network connection when it needs it.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可能经历长时间空闲期的长期网络连接，明智的做法是在节点之间实现心跳，以便延长截止时间。这样可以让你迅速识别网络问题，并及时重新建立连接，而不是等到应用程序开始传输数据时才发现网络错误。通过这种方式，你可以确保应用程序在需要时始终拥有良好的网络连接。
- en: For our purposes, a *heartbeat* is a message sent to the remote side with the
    intention of eliciting a reply, which we can use to advance the deadline of our
    network connection. Nodes send these messages at a regular interval, like a heartbeat.
    Not only is this method portable over various operating systems, but it also makes
    sure the application using the network connection is responding, since the application
    implements the heartbeat. Also, this technique tends to play well with firewalls
    that may block TCP keepalives. We’ll discuss keepalives in Chapter 4.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说，*心跳*是向远程端发送的一条消息，目的是引发一个回复，我们可以利用这个回复来延长网络连接的截止时间。节点以定期的间隔发送这些消息，像心跳一样。这个方法不仅可以在各种操作系统上移植，而且还确保使用网络连接的应用程序正在响应，因为应用程序实现了心跳功能。此外，这种技术通常与可能阻塞
    TCP 保活的防火墙兼容。我们将在第 4 章讨论保活技术。
- en: To start, you’ll need a bit of code you can run in a goroutine to ping at regular
    intervals. You don’t want to needlessly ping the remote node when you recently
    received data from it, so you need a way to reset the ping timer. [Listing 3-10](#listing3-10)
    is a simple implementation from a file named *ping.go* that meets those requirements.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要一些代码，可以在 goroutine 中定期 ping。你不想在最近从远程节点收到数据时无谓地 ping 它，因此你需要一种重置 ping
    定时器的方式。[清单 3-10](#listing3-10) 是一个简单的实现，来自名为 *ping.go* 的文件，符合这些要求。
- en: I use *ping* and *pong* messages in my heartbeat examples, where the reception
    of a ping message—the challenge—tells the receiver it should reply with a pong
    message—the response. The challenge and response messages are arbitrary. You could
    use anything you want to here, provided the remote node knows your intention is
    to elicit its reply.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的心跳示例中，我使用了 *ping* 和 *pong* 消息，其中接收到 ping 消息—挑战—通知接收方应该回复 pong 消息—响应。挑战和响应消息是任意的。你可以在这里使用任何你想要的内容，只要远程节点知道你的目的是引发它的回复。
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 3-10: A function that pings a network connection at a regular interval
    (*ping.go*)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-10：一个定期发送网络连接 ping 请求的函数（*ping.go*）
- en: The `Pinger` function writes ping messages to a given writer at regular intervals.
    Because it’s meant to run in a goroutine, `Pinger` accepts a context as its first
    argument so you can terminate it and prevent it from leaking. Its remaining arguments
    include an `io.Writer` interface and a channel to signal a timer reset. You create
    a buffered channel and put a duration on it to set the timer’s initial interval
    1. If the interval isn’t greater than zero, you use the default ping interval.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pinger` 函数定期向给定的写入器发送 ping 消息。因为它是为了在 goroutine 中运行的，`Pinger` 将上下文作为第一个参数，这样你就可以终止它并防止其泄漏。它的其余参数包括一个
    `io.Writer` 接口和一个信号重置定时器的通道。你创建一个缓冲通道并设置一个持续时间，以确定定时器的初始间隔 1。如果间隔不大于零，则使用默认的 ping
    间隔。'
- en: 'You initialize the timer to the interval 2 and set up a deferred call to drain
    the timer’s channel to avoid leaking it, if necessary. The endless `for` loop
    contains a `select` statement, where you block until one of three things happens:
    the context is canceled, a signal to reset the timer is received, or the timer
    expires. If the context is canceled 3, the function returns, and no further pings
    will be sent. If the code selects the `reset` channel 4, you shouldn’t send a
    ping, and the timer resets 6 before iterating on the `select` statement again.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你将定时器初始化为间隔 2，并设置了一个延迟调用来清空定时器的通道，以避免必要时的泄漏。这个无尽的 `for` 循环包含一个 `select` 语句，在这里你会阻塞，直到发生以下三件事之一：上下文被取消、接收到重置定时器的信号，或定时器到期。如果上下文被取消
    3，函数返回，并且不再发送任何 ping。如果代码选择了 `reset` 通道 4，你不应该发送 ping，定时器会在再次迭代 `select` 语句之前重置
    6。
- en: If the timer expires 5, you write a ping message to the writer, and the timer
    resets before the next iteration. If you wanted, you could use this `case` to
    keep track of any consecutive time-outs that occur while writing to the writer.
    To do this, you could pass in the context’s `cancel` function and call it here
    if you reach a threshold of consecutive time-outs.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定时器到期 5，你将 ping 消息写入写入器，定时器会在下一次迭代前重置。如果你想的话，你可以使用这个 `case` 来跟踪在写入器写入过程中发生的任何连续超时。为此，你可以传入上下文的
    `cancel` 函数，并在达到连续超时阈值时调用它。
- en: '[Listing 3-11](#listing3-11) illustrates how to use the `Pinger` function introduced
    in [Listing 3-10](#listing3-10) by giving it a writer and running it in a goroutine.
    You can then read pings from the reader at the expected intervals and reset the
    ping timer with different intervals.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[清单 3-11](#listing3-11) 演示了如何使用 [清单 3-10](#listing3-10) 中介绍的 `Pinger` 函数，给它一个写入器并在
    goroutine 中运行。然后，你可以在预期的间隔内从读取器读取 ping 数据，并使用不同的间隔重置 ping 定时器。'
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Listing 3-11: Testing the pinger and resetting its ping timer interval (*ping_example_test.go*)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 3-11：测试 pinger 并重置其 ping 定时器间隔（*ping_example_test.go*）
- en: In this example, you create a buffered channel 1 that you’ll use to signal a
    reset of the `Pinger`’s timer. You put an initial ping interval of one second
    on the `resetTimer` channel before passing the channel to the `Pinger` function.
    You’ll use this duration to initialize the `Pinger`’s timer and dictate when to
    write the ping message to the writer.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你创建了一个缓冲通道 1，用于发送重置 `Pinger` 定时器的信号。在将通道传递给 `Pinger` 函数之前，你先在 `resetTimer`
    通道中设置了一个初始的 ping 间隔为一秒。你将使用这个持续时间来初始化 `Pinger` 的定时器，并决定何时将 ping 消息写入写入器。
- en: You run through a series of millisecond durations in a loop 2, passing each
    to the `receivePing` function. This function resets the ping timer to the given
    duration and then waits to receive the ping message on the given reader. Finally,
    it prints to stdout the time it takes to receive the ping message. Go checks stdout
    against the expected output in the example.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你在循环 2 中运行一系列毫秒级的持续时间，将每个持续时间传递给 `receivePing` 函数。此函数将 ping 定时器重置为给定的持续时间，然后等待在给定的读取器上接收
    ping 消息。最后，它会打印接收 ping 消息所花费的时间到标准输出。Go 会将标准输出与示例中的预期输出进行比较。
- en: During the first iteration 3, you pass in a duration of zero, which tells the
    `Pinger` to reset its timer by using the previous duration—one second in this
    example. As expected, the reader receives the ping message after one second. The
    second iteration 4 resets the ping timer to 200 ms. Once this expires, the reader
    receives the ping message. The third run resets the ping timer to 300 ms 5, and
    the ping arrives at the 300 ms mark.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次迭代 3 中，你传入了零的持续时间，这告诉 `Pinger` 使用先前的持续时间来重置定时器——在这个例子中为一秒。正如预期的那样，读取器在一秒后接收到
    ping 消息。第二次迭代 4 将 ping 定时器重置为 200 毫秒。一旦这个时间到期，读取器将接收到 ping 消息。第三次运行将 ping 定时器重置为
    300 毫秒 5，ping 消息会在 300 毫秒时到达。
- en: You pass in a zero duration for run 4 6, preserving the 300 ms ping timer from
    the previous run. I find the technique of using zero durations to mean “use the
    previous timer duration” useful because I do not need to keep track of the initial
    ping timer duration. I can simply initialize the timer with the duration I want
    to use for the remainder of the TCP session and reset the timer by passing in
    a zero duration every time I need to preempt the transmission of the next ping
    message. Changing the ping timer duration in the future involves the modification
    of a single line as opposed to every place I send on the `resetTimer` channel.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你为运行4 6传递了一个零时长，从而保留了上次运行的300毫秒ping计时器。我发现使用零时长来表示“使用上一个计时器时长”这一技巧很有用，因为我不需要追踪初始的ping计时器时长。我可以简单地用我想要在TCP会话剩余部分使用的时长来初始化计时器，并且每次需要预empt传输下一个ping消息时，通过传递零时长来重置计时器。将来要更改ping计时器时长，只需修改一行，而不是每次发送`resetTimer`通道时都进行修改。
- en: Runs 5 to 7 7 simply listen for incoming pings without resetting the ping timer.
    As expected, the reader receives a ping at 300 ms intervals for the last three
    runs.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 运行5到7次只需监听传入的ping，而不重置ping计时器。如预期所示，读者在最后三次运行时每隔300毫秒接收一次ping。
- en: 'With [Listing 3-10](#listing3-10) saved to a file named *ping.go* and [Listing
    3-11](#listing3-11) saved to a file named *ping_example_test.go*, you can run
    the example by executing the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将[清单3-10](#listing3-10)保存为名为*ping.go*的文件，并将[清单3-11](#listing3-11)保存为名为*ping_example_test.go*的文件，你可以通过执行以下命令运行示例：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Advancing the Deadline by Using the Heartbeat
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过使用心跳来提前截止时间
- en: Each side of a network connection could use a `Pinger` to advance its deadline
    if the other side becomes idle, whereas the previous examples showed only a single
    side using a `Pinger`. When either node receives data on the network connection,
    its ping timer should reset to stop the delivery of an unnecessary ping. [Listing
    3-12](#listing3-12) is a new file named *ping_test.go* that shows how you can
    use incoming messages to advance the deadline.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 网络连接的每一方都可以使用`Pinger`来提前推送截止时间，如果另一方变得空闲，而之前的示例只展示了单方使用`Pinger`。当任一节点在网络连接中收到数据时，其ping计时器应重置，以防止发送不必要的ping。[清单3-12](#listing3-12)是一个新文件，名为*ping_test.go*，展示了如何使用传入消息来提前推送截止时间。
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 3-12: Receiving data advances the deadline (*ping_test.go*)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 清单3-12：接收数据会提前截止时间（*ping_test.go*）
- en: You start a listener that accepts a connection, spins off a `Pinger` set to
    ping every second, and sets the initial deadline to five seconds 1. From a client’s
    perspective, it receives four pings followed by an `io.EOF` when the server reaches
    its deadline and terminates its side of the connection. However, a client can
    advance the server’s deadline by sending the server data 5 before the server reaches
    its deadline.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你启动一个监听器，接受一个连接，启动一个每秒ping一次的`Pinger`，并将初始截止时间设置为五秒。 从客户端的角度来看，它会收到四个ping消息，然后当服务器达到其截止时间并终止连接时，会收到一个`io.EOF`。然而，客户端可以通过在服务器达到截止时间之前发送数据，提前推送服务器的截止时间。
- en: If the server reads data from its connection, it can be confident the network
    connection is still good. Therefore, it can inform the `Pinger` to reset 2 its
    timer and push the connection’s deadline forward 3. To preempt the termination
    of the socket, the client listens for four ping messages 4 from the server before
    sending an emphatic pong message 5. This should buy the client five more seconds
    until the server reaches its deadline. The client reads four more pings 6 and
    then waits for the inevitable. You check that a total of nine seconds 7 has elapsed
    by the time the server terminates the connection, indicating the client’s pong
    successfully triggered the reset of the ping timer.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器从连接中读取数据，它可以确认网络连接仍然良好。因此，它可以通知`Pinger`重置其计时器并将连接的截止时间推后。为了避免套接字终止，客户端会在发送明确的pong消息之前，监听服务器发出的四个ping消息。这应该能为客户端争取五秒钟，直到服务器达到其截止时间。客户端会再读取四个ping消息，然后等待不可避免的结果。你可以检查到服务器终止连接时，总共已经过去了九秒，表明客户端的pong消息成功触发了ping计时器的重置。
- en: In practice, this method of advancing the ping timer cuts down on the consumption
    of bandwidth by unnecessary pings. There is rarely a need to challenge the remote
    side of a network connection if you just received data on the connection.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这种提前调整ping计时器的方法可以减少不必要的ping对带宽的消耗。如果你刚刚收到数据连接，通常不需要挑战网络连接的远程端。
- en: The strings `"ping"` and `"pong"` are arbitrary. You could use smaller payloads,
    such as a single byte, for the same purpose, provided both sides of the network
    connection agree upon what values constitute a ping and a pong.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串`"ping"`和`"pong"`是任意的。你可以使用更小的负载，比如一个字节，来达到相同的目的，只要网络连接的两端都达成共识，确定什么值表示ping和pong。
- en: What You’ve Learned
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你所学到的
- en: We covered a lot of ground in this chapter. We started with a dive into TCP’s
    handshake, sequences, and acknowledgments, the sliding window, and connection
    terminations. Then, we covered the process of establishing TCP connections using
    Go’s standard library. We talked about temporary errors, time-outs, listening
    for incoming connections, and dialing remote services. Finally, we covered techniques
    to help you detect and timely correct network integrity issues.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容涵盖了很多内容。我们从深入探讨TCP的握手、序列和确认、滑动窗口、以及连接终止开始。接着，我们介绍了使用Go的标准库建立TCP连接的过程。我们讨论了临时错误、超时、监听传入连接和拨打远程服务的情况。最后，我们讲解了帮助你检测和及时修正网络完整性问题的技术。
- en: I strongly recommend picking up *Practical Packet Analysis* by Chris Sanders
    (No Starch Press, 2017) and installing Wireshark. Manipulating your network code
    and seeing how it affects TCP traffic in Wireshark is a fantastic way to gain
    a deeper understanding of both TCP and Go’s networking packages. The next chapter
    covers sending and receiving data over TCP connections. Wireshark will help you
    gain a deeper understanding of data you send, including each payload’s effects
    on the sliding window. Familiarizing yourself with it now will pay dividends.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈推荐阅读Chris Sanders的《实用数据包分析》（Practical Packet Analysis）（No Starch Press，2017）并安装Wireshark。操控你的网络代码，看看它如何在Wireshark中影响TCP流量，是加深理解TCP和Go网络包的一个极好的方式。下一章将讲解如何通过TCP连接发送和接收数据。Wireshark将帮助你深入理解你发送的数据，包括每个负载对滑动窗口的影响。现在熟悉Wireshark，将为你带来丰厚的回报。
