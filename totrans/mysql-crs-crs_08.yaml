- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Performing Complex Joins with Multiple Tables
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/book_art/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: In [Chapter 5](c05.xhtml), you saw how to join two tables and display the data
    in one result set. In this chapter, you’ll create complex joins with more than
    two tables, learn about associative tables, and see how to combine or limit the
    results of a query. You’ll then explore different ways to temporarily save a query’s
    results in a table-like format, including temporary tables, derived tables, and
    Common Table Expressions (CTEs). Finally, you’ll learn how to work with subqueries,
    which let you nest one query inside another for more refined results.
  prefs: []
  type: TYPE_NORMAL
- en: Writing One Query with Two Join Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Joining three or more tables introduces greater complexity than joining two,
    as you might have different join types (like an inner and an outer join) in the
    same query. For example, [Figure 6-1](#figure6-1) illustrates three tables in
    the `police` database, which contains information on crimes, including the suspect
    and location.
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c06/f06001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-1: Three tables within the `police` database'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `location` table contains the locations where the crimes occurred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `crime` table contains a description of the crimes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `suspect` table contains information about the suspect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Say you want to write a query that joins all three tables to get a list of crimes,
    where they occurred, and the name of the suspect. The `police` database was designed
    so that there will always be a matching location in the `location` table for every
    crime in the `crime` table. However, there may not be a matching suspect in the
    `suspect` table because the police have not identified a suspect for every crime.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll perform an inner join between the `crime` and `location` tables, because
    you know there will be a match. But because there may not be a suspect match for
    each crime, you’ll do an outer join between the `crime` table and the `suspect`
    table. Your query might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you alias the tables with `c` for `crime`, `l` for `location`,
    and `s` for `suspect`. You use the `join` syntax for the inner join between the
    `crime` and `location` tables ❶, and the `left join` syntax for the outer join
    to the `suspect` table ❷.
  prefs: []
  type: TYPE_NORMAL
- en: Using a left join might cause some confusion in this context. When you were
    using `left join` with only two tables in [Chapter 5](c05.xhtml), it was easy
    to understand which was the left table and which was the right, because there
    were only two possibilities. But how does it work now that you’re joining three
    tables?
  prefs: []
  type: TYPE_NORMAL
- en: To understand multiple-table joins, imagine that MySQL is building temporary
    tables as it progresses through the query. MySQL joins the first two tables, `crime`
    and `location`, and the result of that join becomes the left table. Then MySQL
    does a `left join` between the `crime`/`location` combined table and the `suspect`
    table on the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'You used a *left* join for the outer join because you want all of the crimes
    and locations to appear regardless of whether there is a match with the `suspect`
    table on the right. The results of this query are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The suspect for the last crime was able to escape, so the value of the `suspect_name`
    on the last row is `null`. If you had used an inner join instead, the query wouldn’t
    have returned the last row, because inner joins return rows only where there is
    a match.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the null value that gets returned from an outer join to your advantage.
    Say you want to write a query to display only crimes where the suspect is not
    known. You could specify in the query that you want to see only rows where the
    suspect name `is` `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The results of this query are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Adding the `where` clause on the last line of the query showed you only rows
    that have no matching row in the `suspect` table, which limited your list to crimes
    with unknown suspects.
  prefs: []
  type: TYPE_NORMAL
- en: Joining Many Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL allows up to 61 tables in a join, though you’ll rarely need to write queries
    with that many. If you find yourself joining more than 10 tables, that’s a sign
    the database could be redesigned to make writing queries simpler.
  prefs: []
  type: TYPE_NORMAL
- en: The `wine` database has six tables you can use to help plan a trip to a winery.
    Let’s look at all six in turn.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `country` table stores the countries where the wineries are located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `region` table stores the regions within those countries where the wineries
    are located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `viticultural_area` table stores the wine-growing subregions where the
    wineries are located:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `wine_type` table stores information about the types of wine available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `winery` table stores information about the wineries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `portfolio` table stores information about the winery’s portfolio of wines—that
    is, which wines the winery offers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For example, the winery with a `winery_id` of `1` (Silva Vineyards) offers the
    wine with a `wine_type_id` of `1` (Chardonnay), which is in season (its `in_season_flag`—a
    boolean value—is `1`, indicating true).
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 6-1](#listing6-1) shows a query that joins all six tables to find
    a winery in the USA that has a Merlot in season and is offering tours.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-1: A query to list US wineries with in-season Merlot'
  prefs: []
  type: TYPE_NORMAL
- en: While this is a longer query than you’re used to, you’ve seen most of the syntax
    before. You create table aliases for each table name in the query (`country`,
    `region`, `viticultural_area`, `winery`, `portfolio`, and `wine_type`). When referring
    to columns in the query, you precede the column names with the table aliases and
    a period. For example, you precede the `offering_tours_flag` column with `w` because
    it is in the `winery` table, resulting in `w.offering_tours_flag`. (Remember from
    [Chapter 4](c04.xhtml) that it’s best practice to add the suffix `_flag` to columns
    that contain boolean values like `true` or `false`, which is the case with the
    `offering_tours` column, since a winery either offers tours or doesn’t.) Finally,
    you perform inner joins on each table with the word `join`, as there should be
    matching values when you join these tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike our earlier queries, this query contains some joins between tables where
    more than one condition must be met. For example, when you join the `country`
    and `region` tables, there are *two* conditions that need to be met:'
  prefs: []
  type: TYPE_NORMAL
- en: The value in the `country_id` column of the `country` table must match the value
    in the `country_id` column of the `region` table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value in the `country_name` column of the `country` table must equal `USA`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You handled the first condition using the `on` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you used the `and` keyword to specify the second condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can add more `and` statements to specify as many joining conditions as you
    need.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results of the query in [Listing 6-1](#listing6-1) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Associative Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Listing 6-1](#listing6-1), most of the tables are straightforward: the
    `winery` table stores a list of wineries, `region` stores a list of regions, `country`
    stores countries, and `viticultural_area` stores viticultural areas (wine-growing
    subregions).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `portfolio` table, however, is a little different. Remember, it stores
    information about which wines are in each winery’s portfolio. Here it is again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Its `winery_id` column is the primary key of the `winery` table, and its `wine_type_id`
    column is the primary key of the `wine_type` table. This makes `portfolio` an
    *associative table* because it associates rows that are stored in other tables
    to each other by referencing their primary keys, as illustrated in [Figure 6-2](#figure6-2).
  prefs: []
  type: TYPE_NORMAL
- en: '![](image_fi/503007c06/f06002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6-2: The `portfolio` table is an associative table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `portfolio` table represents *many-to-many relationships* because one winery
    can produce many wine types, and one wine type can be produced in many wineries.
    For example, winery `1` (Silva Vineyards) offers many wine types: `1` (Chardonnay),
    `2` (Cabernet Sauvignon), and `3` (Merlot). Wine type `1` (Chardonnay) is offered
    by many wineries: `1` (Silva Vineyards), `2` (Chateau Traileur Parc), and `3`
    (Winosaur Estate). The `portfolio` table contains that list of relationships between
    each `winery_id` and `wine_type_id` that tells us which wineries have which wine
    types. As a bonus, it also contains the `in_season_flag` column, which, as you’ve
    seen, tracks whether that wine is in season at that winery.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll look at different ways to work with the data that’s returned from
    your queries. We’ll start with some simple options for managing the data in your
    result set and then cover some more involved approaches in the latter half of
    the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the Data in Your Result Set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you’ll want to control how much data from your queries is displayed
    in your result set. For example, you might want to pare down your results or combine
    the results of several `select` statements. SQL provides keywords to add this
    functionality to your queries.
  prefs: []
  type: TYPE_NORMAL
- en: The limit Keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `limit` keyword lets you limit the number of rows displayed in your result
    set. For example, consider a table called `best_wine_contest` that holds the results
    of a contest where wine tasters voted for their favorite wines. If you query the
    table and `order by` the `place` column, you’ll see the wines that ranked the
    best first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to see only the top three wines, use `limit 3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `limit` keyword limited the results to three rows. To see only the wine
    that won top place, you could use `limit 1`.
  prefs: []
  type: TYPE_NORMAL
- en: The union Keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `union` keyword combines the results of multiple `select` statements into
    one result set. For example, the following query selects all the wine types from
    two different tables, `wine_type` and `best_wine_contest`, and shows them in one
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `wine_type` table has a column called `wine_type_name` that includes Chardonnay,
    Cabernet Sauvignon, and Merlot. The `best_wine_contest` table has a column called
    `wine_name` that includes Riesling, Pinot Grigio, Zinfandel, Malbec, and Verdejo.
    Using `union` allows you to see all of the wines together in one result set.
  prefs: []
  type: TYPE_NORMAL
- en: You can use `union` only when every `select` statement has the same number of
    columns. The union works in this example because you specified just one column
    in each of the `select` statements. The column name in the result set is usually
    taken from the first `select` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `union` keyword will remove duplicate values from the result set. For example,
    if you had Merlot in both the `wine_type` and the `best_wine_contest` tables,
    using `union` would produce a list of distinct wines, with Merlot listed only
    once. To see a list that includes duplicate values, use `union all`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The result would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now you can see that Merlot is listed twice.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll dive in a bit deeper to make your queries even more efficient by
    creating temporary result sets in a table-like format.
  prefs: []
  type: TYPE_NORMAL
- en: Temporary Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL allows you to create temporary tables—that is, a temporary result set
    that will exist only for your current session and then be automatically dropped.
    For example, you can create a temporary table using a tool like MySQL Workbench
    and then query that table within the tool. If you close and reopen MySQL Workbench,
    however, the temporary table will be gone. You can reuse a temporary table several
    times in a single session.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define a temporary table the same way you create a regular table, except
    that you use the syntax `create temporary table` instead of `create table`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `wp1` temporary table gets created with the column names and data types
    that you specified, without any rows.
  prefs: []
  type: TYPE_NORMAL
- en: To create a temporary table based on the results of a query, simply precede
    the query with the same `create temporary table` syntax, as shown in [Listing
    6-2](#listing6-2), and the resulting temporary table will contain the rows of
    data that were selected from the query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-2: Creating a temporary table'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here you create a temporary table called `winery_portfolio` that stores the
    results of a query joining the `winery`, `portfolio`, and `wine_type` tables from
    [Listing 6-1](#listing6-1) and [Figure 6-2](#figure6-2). The `winery` and `portfolio`
    tables are joined based on two conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The values of the `winery_id` columns in the tables match ❶.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The winery is offering tours. For this, you check that the `offering_tours_flag`
    in the `winery` table is set to `true` ❷.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Those results are joined with the `wine_type` table based on two conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The values of the `wine_type_id` columns in the tables match ❸.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `wine_type_name` in the `wine_type` table is `Merlot` ❹.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you’ve created a temporary table, you can query its contents by selecting
    from it, just as you would with a permanent table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can write a second query to select from the `winery_portfolio` temporary
    table and join it with other three tables from [Listing 6-1](#listing6-1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you are joining the `winery_portfolio` temporary table to the remaining
    tables that were part of the original query in [Listing 6-1](#listing6-1): `country`,
    `region`, and `viticultural_area`. In this way, you simplified a large, six-table
    query by isolating the data from three tables into a temporary table and then
    joining that temporary table with the other three tables. This query returns the
    same results as [Listing 6-1](#listing6-1).'
  prefs: []
  type: TYPE_NORMAL
- en: Common Table Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Common Table Expressions (CTEs), a feature introduced in MySQL version 8.0,
    are a temporary result set that you name and can then select from as if it were
    a table. You can use CTEs only for the duration of one query (versus temporary
    tables, which can be used for the entire session). [Listing 6-3](#listing6-3)
    shows how to use a CTE to simplify the query from [Listing 6-1](#listing6-1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 6-3: Naming and then querying a CTE'
  prefs: []
  type: TYPE_NORMAL
- en: First, you use the `with` keyword to give the CTE a name; here, you define the
    name `winery_portfolio_cte` for the results of the query shown between the parentheses
    ❶. Then you add another query ❷ that uses `winery_portfolio_cte` in a join as
    if it were a table ❸. The results are the same as those of [Listing 6-1](#listing6-1).
  prefs: []
  type: TYPE_NORMAL
- en: 'CTEs and temporary tables both temporarily save the results of a query in a
    table-like format. However, while temporary tables can be used more than once
    (that is, in multiple queries) in a session, CTEs can be used only for the duration
    of the query in which they are defined. After you run [Listing 6-3](#listing6-3),
    try to run another query to select from `winery_portfolio_cte`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: MySQL is looking for a *table* named `winery_portfolio_cte`, so it’s no surprise
    it can’t locate your CTE. Besides that, the CTE existed only for the duration
    of your query, so it’s no longer available.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive Common Table Expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recursion is a technique that is used when an object references itself. When
    I think of recursion, I think of Russian nesting dolls. You open the largest doll
    and discover a smaller doll within it; then you open that doll and find an even
    smaller doll within that; and so on until you reach the tiniest doll in the center.
    In other words, to see all the dolls, you start with the largest doll and then
    iterate through each smaller doll until you find a doll that doesn’t contain another
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion is useful when your data is organized as a hierarchy or a series of
    values where you need to know the previous value to arrive at the current value.
  prefs: []
  type: TYPE_NORMAL
- en: 'A recursive CTE references itself. Recursive CTEs have two `select` statements
    separated by a `union` statement. Take a look at this recursive CTE called `borg_scale_cte`,
    which contains a series of numbers between 6 and 20:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: First, you define the CTE as `recursive` and name it `borg_scale_cte` ❶. Then,
    the first `select` statement returns the first row containing the number `6` ❷.
    The second `select` statement returns all other rows with values `7` through `20`.
    It continually adds `1` to the `current_count` column and selects the resulting
    numbers ❸, so long as the `current_count` is less than `20` ❹.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last line, you use the wildcard character `*` to select all the values
    from the CTE, which returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You can also use a recursive CTE as if it were a table and join it with other
    tables, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Derived Tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Derived tables are an alternative to CTEs for creating a table of results just
    for use within a query. The SQL that creates the derived table goes within parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The query within the parentheses produces a derived table aliased as `wot` (short
    for *wineries offering tours*). You can treat `wot` as if it were just another
    table, joining it to the `portfolio` and `wine_type` tables, and selecting columns
    from it. As with a CTE, the derived table is available just for the duration of
    your query.
  prefs: []
  type: TYPE_NORMAL
- en: The choice to use a derived table rather than a CTE is often a matter of style.
    Some developers prefer to use CTEs because they feel CTEs are a more readable
    option. If you need to use recursion, however, you would have to use a CTE.
  prefs: []
  type: TYPE_NORMAL
- en: Subqueries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A subquery (or inner query) is a query nested within another query. A subquery
    is used to return data that will be used by the main query. When a query has a
    subquery, MySQL runs the subquery first, selects the resulting value from the
    database, and then passes it back to the outer query. For example, this SQL statement
    uses a subquery to return a list of all the wine-growing regions in the United
    States from the `wine` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this query is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The query has two parts: the outer query ❶ and the subquery ❷. Try running
    the subquery in isolation, without the outer query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The result shows that the `country_id` returned for USA is `3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'In your query, `3` is passed from the subquery to the outer query, which makes
    the entire SQL statement evaluate to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This results in a list of regions for `country_id 3` (`USA`) being returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Subqueries That Return More Than One Row
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Subqueries can return more than one row. Here’s the same query as before, this
    time including all countries, not just the USA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the line of the subquery that specifies that you want only USA regions
    is commented out ❷, so the `country_id` for all countries will be returned. When
    you run this query, instead of a list of regions, MySQL returns an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that the outer query expects only one row to be returned because
    you used the `=` syntax ❶. Instead, the subquery returns three rows: `country_id`
    `3` for the USA, `1` for France, and `2` for Spain. You should use `=` only when
    there is no possibility that the subquery could return more than one row.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a common mistake that you should be mindful of. Many developers have
    written a query that worked when they tested it, but all of a sudden, one day
    it starts producing `Subquery returns more than 1 row` errors. Nothing has changed
    about the query (unlike in this case where a line has been commented out), but
    the data in their database has changed. For example, new rows might have been
    added to a table, and the developer’s subquery now returns multiple rows where
    it used to return one.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write a query where more than one row can be returned from the subquery,
    you can use the `in` keyword instead of `=`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now that you’ve replaced `=` with `in`, the outer query can accept multiple
    rows back from the subquery without error, and you’ll get a list of regions for
    all countries.
  prefs: []
  type: TYPE_NORMAL
- en: Correlated Subqueries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a correlated subquery, a column from a table in the subquery is joined with
    a column from a table in the outer query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at two tables called `best_paid` and `employee` in the `pay`
    database. The `best_paid` table shows that the highest salary in the Sales department
    is $200,000, and the highest salary in the Manufacturing department is $80,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `employee` table stores a list of employees, their department, and their
    salary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use a correlated subquery to find the highest-paid employees in each
    department:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In the outer query, you select employees and salaries from the `employee` table.
    In the subquery, you join the results of the outer query with the `best_paid`
    table to determine if this employee has the highest salary for their department.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The results show that Wanda is the highest-paid employee in the Sales department
    and Betty and Sean are tied for the highest salary in the Manufacturing department.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you wrote complex SQL statements using multiple tables. You
    saw how to limit or combine the rows of your results, and you explored several
    different ways to write queries using result sets as if they were tables.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll compare values in your queries; for example, you’ll
    check that one value is more than another value, compare values that have different
    data types, and check whether a value matches some pattern.
  prefs: []
  type: TYPE_NORMAL
