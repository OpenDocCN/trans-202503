- en: <hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: 27 AND/OR OPERATORS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/chapter.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, I’ll discuss what may be the most glaring shortfall in all
    of Batch. It doesn’t support an and operator, nor is there an or operator. After
    a brief problem statement, I’ll detail a few techniques to simulate or mimic these
    two operators, handling both the true and false cases. The and is fairly straightforward,
    but the or requires more ingenuity.
  prefs: []
  type: TYPE_NORMAL
- en: As is often the case with Batch, you can look at a deficiency with frustration
    or as an inspiration for creativity. These techniques are a must for any Batch
    coder because without them, you can’t write even moderately interesting if commands.
  prefs: []
  type: TYPE_NORMAL
- en: The Problem Statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A certain conversation is a rite of passage for anyone learning Batch:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Bobby*: I have a syntax issue. I’m trying to code an if command with an and
    operator—you know, do something if variable1 equals A and variable2 equals B—nothing
    complex. I’d hoped that the syntax was simply the word *and*. That didn’t work,
    so I tried an ampersand and then two ampersands. I know that Batch can be unintuitive,
    so there must be some sort of funky syntax for the and operator, maybe an at sign
    with a tilde or some nonsense like that. So how do I code this?'
  prefs: []
  type: TYPE_NORMAL
- en: '*Jack*: Sorry, Batch doesn’t have an and operator.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Bobby*: Seriously? That makes no sense.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Jack*: Seriously, there is none.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Bobby*: You’re messing with me, aren’t you? Every programming language with
    an if command has an and operator. I think there’s a law.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Jack*: No, not every language. I can’t name another offhand, but Batch isn’t
    following the crowd on this one.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Bobby*: That’s like selling a car that doesn’t turn left. What are you supposed
    to do?'
  prefs: []
  type: TYPE_NORMAL
- en: '*Jack*: Take three rights. Oh ... and by the way, the or operator ... also
    not a thing.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Bobby*: I’m still not sure if you’re yanking my chain. It’s nowhere near April
    Fool’s Day, and I really need to get this thing working. Any suggestions?'
  prefs: []
  type: TYPE_NORMAL
- en: '*Jack*: I agree, Batch should have these operators, but this is where some
    creativity comes in handy. Anyone can code an and in Java or Perl, but doing it
    in Batch will fill you with a great sense of pride and accomplishment. The or
    operator is even more fun—or problematic, depending on your perspective.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I still remember playing the part of the novice in this conversation, and I’ve
    since experienced déjà vu countless times in the opposite role. I fear that some
    will think that I’m overstating the issue, but it has perplexed many. This and
    operator irredeemably does *not* return true if both comparisons are true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: That’s not to say that the command inside the code block never executes; in
    fact, the interpreter typically performs it after discarding the invalid if command.
    To further complicate matters, the invalid command might generate an error message
    to stderr, or not, and errorlevel might end up as a nonzero value, or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same is true for this *invalid* or operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It doesn’t return true if either or both of the comparisons are true.
  prefs: []
  type: TYPE_NORMAL
- en: But enough of what won’t work. There are solutions, some elegant and some functional,
    for building these operators.
  prefs: []
  type: TYPE_NORMAL
- en: Replicating the and Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first and most obvious technique to code around the lack of an and operator
    is the nested if command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the only possible solution if either conditional clause uses the exist
    keyword to determine whether a resource exists or the defined keyword to see whether
    a variable is defined. But if you are examining multiple variables for equality
    to constants or other variables, I’ll share a far more elegant solution. The following
    if command, with two resolved variables on one side of the equ operator and two
    values on the other, is functionally equivalent to the nested commands in the
    previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The lefthand side of the equality, %var1%-%var2%, has three parts inside the
    double quotes: the resolution of the first variable, a dash, and the resolution
    of the second variable. If the two variables are set to A and B, respectively,
    then "%var1%-%var2%" resolves to "A-B", and equality is found. If either variable
    (or both) is set to anything else the conditional clause is false.'
  prefs: []
  type: TYPE_NORMAL
- en: The dash delimiter serves two important purposes. Without the delimiter, we
    will erroneously find equality if one of the two variables resolves to AB and
    the other resolves to null. Also, it’s just far easier and more pleasant to read,
    especially when the comparisons become more complex. For example, the following
    two if commands—each containing a trio of compares—are very similar, but which
    one would you rather read?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: I’m using a dash as the delimiter, but most any understated character also works.
    Dots are another good option, but above all else, the delimiter that you choose
    should be a character that you don’t expect to be part of the data. (I’m hesitant
    to open this can of worms, but the conditional clause, "%A%-%B%" equ "%X%-%Y%",
    will incorrectly register as true if A and Y are set to a dash and B and X are
    null. While this theoretically is an issue, if you know your data and choose your
    delimiter wisely, it won’t be an issue in practice.)
  prefs: []
  type: TYPE_NORMAL
- en: Notice also that the two comparisons in the previous listing are case-insensitive.
    You can do the same for any multiple comparison with the addition of the /i option,
    but it applies universally—that is, to all three comparisons in this example.
    If you want to do a mix of case-sensitive and case-insensitive compares, nesting
    is your best option.
  prefs: []
  type: TYPE_NORMAL
- en: The prior logic would have required two and operators in most other languages.
    In Batch, you could have done it with three nested if commands, but the technique
    connecting operands with a dash is more succinct and readable than it would have
    been even with a true and operator.
  prefs: []
  type: TYPE_NORMAL
- en: Replicating the or Operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The or operator is as complex and varied as the and operator is straightforward
    and uniform. I’ll demonstrate the techniques best suited for different situations.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing One Variable to Multiple Values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A common application of the or operator is to determine whether the contents
    of a variable is equal to one out of two or more values. For instance, you can
    glean quite a bit from a state postal code. If it’s equal to WA, OR, or CA, the
    state is on the Pacific coast of the contiguous United States, and any one of
    a list of 10 values indicates that the state is on the Mississippi River.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build an or operator looking for one of multiple values being assigned to
    a single variable, I’ll once again turn to the eminently useful for command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The echo command executes if and only if the variable represents the postal
    code for one of the Dakota states.
  prefs: []
  type: TYPE_NORMAL
- en: The for command executes its code block twice, passing ND and then SD as the
    %%p variable. The code block contains just an if command comparing the contents
    of postalCode to what’s passed in as the for variable. Thus, the first execution
    of the if command looks to see if the variable resolves to ND, and the second
    execution compares the value of postalCode to SD. If the variable equals either
    ND or SD, the if command evaluates to true, triggering the execution of its block
    of code. This in essence is a Batch or operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example was for two possible values, but since the for command
    takes in a space-delimited list, you can pass any reasonable number of values.
    Here’s an example of a Batch or operator matching a variable on any one of six
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A single variable, such as postalCode or name, can’t take on two current values
    at once, meaning that with this technique, the conditional clause in the if command
    can evaluate to true at most once. This isn’t true of other variants of the or
    operator, meaning that other considerations and modifications come into play.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Multiple Variables to One Value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let’s flip the last example so that we compare multiple variables to a single
    hardcoded value. Perhaps a particular program has two functions, and we want to
    execute it if either of two variables is set to some common value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, the for command is using the resolved values of the two variables
    as its input, and it’s passing each to the if command and comparing them to A:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario, there’s the possibility for both variables to be equal to
    A. A true or proper or operator won’t execute the code inside the code block of
    the if command twice if both are true. To mimic this behavior, we must break out
    of the logic after the first true condition is satisfied and the code block is
    executed, and this is accomplished by the goto command branching control to the
    label just after the for loop.
  prefs: []
  type: TYPE_NORMAL
- en: Many times, it’s perfectly acceptable to execute the code block multiple times.
    For instance, if you’re setting some variable or variables when the condition
    is true, it won’t hurt to simply reset them to the same values, and in those situations,
    you can simplify the code by removing the goto and the label. Even so, this code
    isn’t bulletproof in all situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The technique in the previous example assumes that the variables don’t contain
    any embedded spaces. Since the for command accepts a space-delimited list, the
    interpreter treats a single value with an embedded space as two distinct values.
    The following listing accounts for the limitation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'I’ve encased each resolved input variable in double quotes, ensuring that we
    pass each one in its entirety into the code block. To account for what I’ve just
    added, I’ve also included a tilde to the resolution of the for variable to remove
    these double quotes while doing the comparison: %%~i.'
  prefs: []
  type: TYPE_NORMAL
- en: Only a double quote in the contents of one of these variables could break this
    code. Know your data.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing Multiple Variables and Values
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The prior examples demonstrate common yet fairly narrow cases. They won’t work
    for more complicated conditional clauses containing an or operator comparing multiple
    variables to various hardcoded values or comparing different variables to each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a specific example, a desired conditional clause might evaluate to true
    if one variable equals a particular value or if a second variable equals a third
    variable. That is, we might try to execute something like the following, but again
    this does *not* work in Batch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two ways to mimic this variant of the or operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The **else if** Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: 'With some brute force you can evaluate the first condition and use the else
    if construct from [Chapter 4](chapter4.xhtml) to evaluate subsequent conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This works but has a major drawback that I more than hinted at in the code
    itself. You must repeat the code block to be executed if the conditional clause
    in the if command is true. If this code consists of a single statement, that may
    be more than acceptable, but if the logic is more complex, even two or three lines
    of code, the code will quickly get messy. In such cases, it’s best to put that
    code block into a labeled method and call it from multiple locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The :CommonLogic routine may contain some involved logic and live elsewhere
    in the bat file, but if it’s only a handful of commands, I suggest placing it
    immediately after the else if construct inside a perpetually false if command.
    (See [Chapter 20](chapter20.xhtml) for more on this technique. Hint: if 0 equ
    1.) However, if the code block really doesn’t justify its own method (or even
    if it does), there’s another technique worth exploring.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Nested **for** Command Solution**'
  prefs: []
  type: TYPE_NORMAL
- en: This last technique for implementing an or operator isn’t a simple one, but
    it’s elegant, and I’ve employed it often. It mimics multiple compares of two items
    where just one match satisfies the condition, but where the two items can be any
    combination of resolved variables and hardcoded values. It even handles embedded
    spaces in any of the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this solution, I’ve wrapped the if command inside two nested for commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The input of the outer for command is a space-delimited set of colon-delimited
    pairs of values, where each pair is encased in double quotes. This means that
    each execution of the outer code block resolves a pair of values delimited by
    a colon as %%~i. The pair of values can be a combination of a resolved variable
    and a hardcoded value such as in the first pair: %var1%:A. In contrast, the second
    pair demonstrates a different possibility, that of two resolved variables: %var2%:%var3%.'
  prefs: []
  type: TYPE_NORMAL
- en: The inner for /F command successively accepts each pair resolved by %%~i and
    treats it as string input because of the encasing double quotes. (Notice that
    "%%~i" strips off and then adds back a set of double quotes. I could have used
    %%i, but the explicit double quotes make it clear that the input to the for /F
    command is a string.)
  prefs: []
  type: TYPE_NORMAL
- en: The tokens and delims clauses separate the pair by the colon delimiter into
    the %%j and %%k tokens ([Chapter 19](chapter19.xhtml)). Finally, the if command
    compares them for equality and executes the code block if true.
  prefs: []
  type: TYPE_NORMAL
- en: I’m using the same technique I employed earlier to break out of the logic so
    that it doesn’t execute multiple times. Once again, you can drop the goto command
    and the label if there’s no harm executing the code block more than once. If a
    colon might be in one of the values being compared, you can choose a different
    delimiter. Likewise, if a double quote might be in one of the values, you can
    drop the double quotes around each pair in the input list, but this will expose
    spaces and special characters in the data.
  prefs: []
  type: TYPE_NORMAL
- en: After you get a grasp on how it works, take another look with fresh eyes and
    ask yourself whether this looks like an if command with an or operator. Some may
    call it cryptic, and to be clear, an explanatory remark is definitely in order,
    but what I’ve presented here represents the most comprehensive complex Batch or
    operator you’re likely to encounter.
  prefs: []
  type: TYPE_NORMAL
- en: The else Keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There’s one last pertinent topic related to any if command that we must not
    forget: the else keyword. I’ve discussed executing one code block if multiple
    conditions are all true or if at least one of them is true, but often you’ll want
    to execute another code block if the ultimate result of the and or or conditional
    clause is false. Traditionally, this is the code block coming after the else keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The simulated and operator with multiple resolved variables and hardcoded values
    strung together lends itself to the use of an else code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This also works with the else if construct that can mimic the or operator.
    But you can only mimic the else keyword in the other situations, and I’ll share
    two very useful methods here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Preemptive Action Method**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to execute the else logic is to do it preemptively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, this works only if upon finding a match, you can easily undo the preemptive
    logic. If the else logic is copying or deleting a file, this technique is of no
    value, but if the logic is simply setting a variable to one of two values, you
    can do the else logic first and undo it if the if command evaluates to true. In
    essence, this is an if...else construct.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Branch Over Method**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method is to use that bit of space before the label used to break out
    of the code block on the first match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The goto command already ensures that the logic just above it executes no more
    than once, but now it also branches over the logic just after the completion of
    the for command. If this logic finds one match, it sets the variable to Match,
    but if the if command doesn’t find a match after exhausting the list in the input,
    only then does control fall to the set command setting the variable to NoMatchFound.
  prefs: []
  type: TYPE_NORMAL
- en: This method offers far greater flexibility. Instead of setting a variable, you
    can call a program if one match is found, and if not, delete a directory. The
    code isn’t doing anything preemptively, so it doesn’t have to undo anything. For
    this reason, the branch over method is a truer form of the if...else construct.
    The fact that the else logic comes last makes it look even more like the traditional
    construct. After seeing enough of these, you’ll start to interpret those two close
    parentheses as a kind of else keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, I’ve detailed a couple of methods to mimic the and operator
    of a conditional clause, and you’ve learned multiple techniques for simulating
    the or operator that satisfy many differing situations. I also demonstrated ways
    to mimic the else keyword, so as to execute logic that traditionally executes
    when a conditional clause is false.
  prefs: []
  type: TYPE_NORMAL
- en: It’s certainly true that the techniques discussed in this chapter are completely
    unnecessary in most languages, but they are a necessity for any Batch coder wanting
    to code more than rudimentary logic. They also fill the most prominent lacuna
    in the Batch universe as elegantly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Bobby shouldn’t be faulted for trying to use && as an and operator; nor should
    he be faulted if he tried using || as an or operator. Both are commonly used for
    these purposes in other languages. I haven’t mentioned it yet, but the && and
    || operators do have a place in Batch, but in relation to a completely different
    topic, conditional execution. In [Chapter 4](chapter4.xhtml), I detailed the most
    commonly used technique of conditional execution (the if command), but in the
    next chapter, I’ll return to this topic to share some lesser-known alternative
    techniques.
  prefs: []
  type: TYPE_NORMAL
