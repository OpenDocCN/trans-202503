<html><head></head><body><div id="sbo-rt-content"><h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_123"/><span class="big">5</span><br/>SNOBOL</h2>&#13;
<div class="image1"><img src="Images/common01.jpg" alt="Image" width="189" height="189"/></div>&#13;
<p class="noindent">SNOBOL is a text pattern matching language developed in the 1960s. Modern programmers might find its syntax quaint, and maybe even a tad frustrating, but I suspect the power of the language will shine through in the end as we explore its features, some of which are still with us in modern languages like Python.</p>&#13;
<p class="indent">SNOBOL, like Forth, is a denizen of the later Paleozoic. SNOBOL and Forth are of similar vintage, but they are extremely different. Forth is minimal and low level. SNOBOL is abstract and surprisingly powerful, though quirky.</p>&#13;
<p class="indent">In this chapter, we’ll explore SNOBOL, specifically SNOBOL4, the latest dialect of the language. SNOBOL is known for its pattern matching and string processing abilities, but it is a general-purpose language. As we’ll see, SNOBOL’s data handling facilities are surprisingly sophisticated and include an atypical level of flexibility. As Michael Shafto put it in 1982, “SNOBOL4 is the Alice’s Restaurant of programming languages: you can get anything you want” (see “Artificial Intelligence Programming in SNOBOL4,” available on this book’s GitHub site).</p>&#13;
<p class="indent">Let’s explore SNOBOL by reviewing the structure of the language and the interesting abilities it provides. We’ll walk through its features, look at <span epub:type="pagebreak" id="page_124"/>examples, and finish by building a simple machine learning classifier to link our explorations with the hopes of at least some computer scientists from the 1980s. As before, we’ll end with some closing thoughts.</p>&#13;
<h3 class="h3" id="lev1sec41"><strong>Installation</strong></h3>&#13;
<p class="noindent">To install SNOBOL, download it from <em><a href="http://ftp.ultimate.com/snobol4/">http://ftp.ultimate.com/snobol4/</a></em> by grabbing <em>snobol4-2.3.1.tar.gz</em>, or any later version you see on that site. Save the file in a subdirectory called <em>SNOBOL</em>. Once you have the file, expand it and build the SNOBOL executable as follows:</p>&#13;
<pre>$ <span class="codestrong1">tar xzf snobol4-2.3.1.tar.gz</span>&#13;
$ <span class="codestrong1">cd snobol4-2.3.1/</span>&#13;
$ <span class="codestrong1">./configure</span>&#13;
$ <span class="codestrong1">make</span></pre>&#13;
<p class="indent">The commands above generate a lot of output. Some are from the C compiler, including a few warnings we can safely ignore. The rest are from SNOBOL test scripts. When all is said and done, if you see a message about sending timing info to <span class="literal">timing@snobol4.org</span>, you’ll know that SNOBOL was successfully built and is running correctly.</p>&#13;
<h3 class="h3" id="lev1sec42"><strong>Origins and Philosophy</strong></h3>&#13;
<p class="noindent">SNOBOL (“StriNg Oriented and symBOlic Language”) was developed during the 1960s at AT&amp;T Bell Laboratories by David Farber, Ralph Griswold, and Ivan Polonsky. The name <em>SNOBOL</em> is a backronym, meaning the developers began with the acronym they wanted and worked backward to ensure they got it.</p>&#13;
<p class="indent">According to Farber, the original name for the language was “Symbolic EXpression Interpreter,” or SEXI. In the 1960s, running a computer program meant walking to the machine room with a stack of punch cards. Typically, the program name and username were marked on the deck. So Farber handed the young woman running the programs a stack labeled “SEXI Farber.” She read the name and laughingly said, “That’s what you think.” Clearly, a new name was needed. After much frustration, someone complained that they didn’t have a snowball’s chance in hell of coming up with a name; thus “SNOBOL” was born. The spelling pays homage to other similarly named languages of the time like COBOL and ALGOL. (Farber posted this story to his Interesting-People mailing list in December 2008.)</p>&#13;
<p class="indent">SNOBOL’s claim to fame is its powerful pattern-matching abilities. Current programming languages often rely on regular expressions, which have a separate history from SNOBOL, but SNOBOL’s matching skills were perfectly suited to the sort of highly structured data processing that was the focus of most computer mainframe use at the time. We’ll explore pattern matching throughout the chapter.</p>&#13;
<p class="indent">SNOBOL’s philosophy might best be summed up as “all the world’s a string.” Strings are almost everything in SNOBOL. Data in the 1960s was <span epub:type="pagebreak" id="page_125"/>typically textual, like records with fixed sizes and fields. SNOBOL’s pattern matching made processing such data (relatively) straightforward.</p>&#13;
<p class="indent">Even though SNOBOL manipulated structured text data, it did not itself make use of structured programming. Thus, there are no <span class="literal">for</span> or <span class="literal">while</span> loops in SNOBOL. For that matter, SNOBOL lacks even basic <span class="literal">if-then</span> constructs. The only way to control program flow is by using what amounts to a <span class="literal">goto</span> statement. However, in SNOBOL, gotos are rather flexible. One of SNOBOL’s unique concepts is that every line of code either succeeds or fails and where the program goes next depends on that fact. We’ll see this in action as we work through the examples. In SNOBOL, failure is definitely an option. In fact, it’s a requirement.</p>&#13;
<p class="indent">SNOBOL is dynamically typed and able to create new variables and data structures on the fly. SNOBOL can even create new code on the fly, though we won’t be so ambitious here. SNOBOL supports powerful arrays and tables, the latter of which are much like Python dictionaries. User-defined data structures are also available.</p>&#13;
<p class="indent">The best way to learn SNOBOL is to use SNOBOL. It really must be seen to be believed. So without further ado, let’s take a walk in the snow.</p>&#13;
<h3 class="h3" id="lev1sec43"><strong>The Language</strong></h3>&#13;
<p class="noindent">We’ll begin by learning how to get SNOBOL to do basic things like print “Hello, world!” Once we’ve figured that out, we’ll move to variables and user-defined data types. Next come arrays and tables, SNOBOL’s intrinsic data structures. Patterns follow, though some pattern use will already have snuck in. Patterns are the traditional reason for using SNOBOL, and are perhaps the one part of the language that best distinguishes it from most other languages.</p>&#13;
<p class="indent">SNOBOL allows user-defined functions. We’ll see how to define them and learn why the process is, to be blunt, ugly. Then we’ll close with disk files and command line arguments. We’ll learn how to control a SNOBOL program’s flow as we work through the examples, as that’s the best way to learn it. All the files mentioned in the following sections are in the <em>examples</em> directory under <em>SNOBOL</em>.</p>&#13;
<h4 class="h4" id="lev2sec38"><strong><em>Running SNOBOL</em></strong></h4>&#13;
<p class="noindent">SNOBOL runs interactively if started without a filename. This mode is available for quick calculations and testing ideas, but SNOBOL was meant to run code from a file or, originally, a stack of punch cards.</p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05list1">Listing 5-1</a> gets us started with <em>hello.sno</em>.</p>&#13;
<pre>*  hello.sno&#13;
    output = 'Hello, world!'&#13;
    output = 'Hello, '  "world!"&#13;
    output = 'Hello #' 9&#13;
    output =<span epub:type="pagebreak" id="page_126"/>&#13;
    output = "Goodbye!"&#13;
end</pre>&#13;
<p class="caption" id="ch05list1"><em>Listing 5-1: A SNOBOL greeting</em></p>&#13;
<p class="indent">This short program already has much to say about SNOBOL. First, comment lines begin with an asterisk (<span class="literal">*</span>). However, unlike in other languages, the asterisk <em>must</em> be in column 1. Either the entire line is a comment, or none of it is.</p>&#13;
<p class="indent">To print something in SNOBOL, we assign it to the special variable <span class="literal">output</span>. SNOBOL is not case sensitive, so <span class="literal">output</span> and <span class="literal">OUTPUT</span> are treated the same. The thing assigned to <span class="literal">output</span> is a string or something SNOBOL will implicitly convert into a string, like a number.</p>&#13;
<p class="indent">Concatenation is such a common operation in SNOBOL that space is used as the operator. So the first <span class="literal">output</span> statement in <a href="ch05.xhtml#ch05list1">Listing 5-1</a> assigns a string enclosed in single quotes while the second concatenates two strings together. Note the use of double quotes. Like Python, SNOBOL allows both kinds. As you can see from the next line, SNOBOL implicitly converts numbers, which may be integers or floating point, into strings. Lastly, to output a blank line, assign nothing. Assigning nothing is also the SNOBOL way of removing things from a string. We’ll see that in action when using patterns.</p>&#13;
<p class="indent">All SNOBOL programs end with <span class="literal">end</span>. Note that <span class="literal">end</span> is in column 1 and all the <span class="literal">output</span> statements are indented. SNOBOL doesn’t care how far statements are indented, only that they don’t begin in column 1. The only things allowed in column 1 are <span class="literal">*</span> for comments, <span class="literal">+</span> for line continuation (which is seldom used now), and labels, including <span class="literal">end</span>.</p>&#13;
<p class="indent">You can run <em>hello.sno</em> like you’d run a Python script.</p>&#13;
<pre>&gt; <span class="codestrong1">snobol4 hello.sno</span></pre>&#13;
<p class="noindent">This should give you the following output:</p>&#13;
<pre>Hello, world!&#13;
Hello, world!&#13;
Hello #9&#13;
&#13;
Goodbye!</pre>&#13;
<p class="indent">The output of <a href="ch05.xhtml#ch05list1">Listing 5-1</a> implies that SNOBOL always prints the string assigned to <span class="literal">output</span> on a line. There is no easy way to output a partial line followed by more text before ending the line. SNOBOL is line oriented, both for output and input. Thus, it is up to the programmer to build the entire line first before assigning it to <span class="literal">output</span>.</p>&#13;
<p class="indent">Now run <a href="ch05.xhtml#ch05list2">Listing 5-2</a>, <em>hello2.sno</em>.</p>&#13;
<pre>*  hello forever&#13;
loop  output = "You say goodbye and I say hello"  :(loop)&#13;
end</pre>&#13;
<p class="caption" id="ch05list2"><em>Listing 5-2: Hello, hello, hello</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_127"/>When you get bored, use CTRL-C to interrupt the program. This is our first SNOBOL loop. In SNOBOL, every line has the opportunity to execute a goto. The first part of the line, in column 1, is a label, <span class="literal">loop</span>. Labels are the targets SNOBOL uses when the goto portion of a line is executed. Labels, and other identifiers, must start with a letter. After that, letters, numbers, and underscores are allowed. Note that labels are global. That is, they must be unique across the entire program. Also, SNOBOL lines get rather lengthy and full of spaces, so we’ll remove extra spaces present in the source code files to save space in the text.</p>&#13;
<p class="indent">The goto portion of a SNOBOL line comes at the end. The number of spaces before the goto can vary, but no code comes after the goto. The colon (<span class="literal">:</span>) begins the goto. Target labels are enclosed in parentheses. We’ll encounter more sophisticated gotos as we proceed. Note that if there is no goto, control proceeds to the next line of code as in most programming languages.</p>&#13;
<p class="indent">One more item is worth noting here. The goto in <a href="ch05.xhtml#ch05list2">Listing 5-2</a> always executes whether the line succeeds or fails. Granted, this line will never fail, but we’ll see other lines that do and that indeed must fail. It’s part of how the language works. Forgetting to distinguish between success and failure and using a goto that always executes can lead to strange behavior. Of course, the potential dangers of <span class="literal">goto</span> statements are well known—see Edsger Dijkstra’s famous 1968 paper “Go To Statement Considered Harmful” (<em><a href="https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf">https://homepages.cwi.nl/~storm/teaching/reader/Dijkstra68.pdf</a></em>). However, with SNOBOL, it’s all we have to work with.</p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05list3">Listing 5-3</a> introduces a few new SNOBOL concepts.</p>&#13;
<pre>*  A bit of interaction&#13;
again output = "Name?"&#13;
  name = input&#13;
  output = differ(name, null) "Greetings, " name  :f(again)&#13;
  output = "Shall we play a game?"&#13;
  output = "On second thought, nah"&#13;
end</pre>&#13;
<p class="caption" id="ch05list3"><em>Listing 5-3: A bit of interaction</em></p>&#13;
<p class="indent">The first new concept is showing how to get input from the keyboard by referencing <span class="literal">input</span>; it returns a string that is assigned to the variable <span class="literal">name</span>. Notice that the variable <span class="literal">name</span> was not declared. Like Python, SNOBOL is dynamically typed, meaning that variables are created on demand and can hold whatever data is assigned to them.</p>&#13;
<p class="indent">The next line needs parsing. It’s an assignment to <span class="literal">output</span>, so it will ultimately print something on the screen. We see a constant string followed by <span class="literal">name</span>. There is space between them, so we expect the two to become a string using the name entered by the user. But what’s this <span class="literal">differ</span> thing? And the goto section is new, too.</p>&#13;
<p class="indent">Let’s start with the goto. It’s <span class="literal">:f(again)</span>. The colon begins the goto. The <span class="literal">f</span> stands for failure. If the line fails, goto <span class="literal">again</span>, the line that asks for the user’s name. Okay, this seems reasonable; if the user’s input isn’t valid, ask again.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_128"/>Now for the <span class="literal">differ</span> part: <span class="literal">differ</span> is a SNOBOL predicate. Like all predicates, its purpose is to determine whether something is true or false. However, unlike in any other programming language I’ve ever encountered, SNOBOL predicates don’t return true or false. If the predicate is false, the function <em>fails</em>, and if any portion of a SNOBOL line fails, the entire line fails. If a line fails and there is a goto for a failure condition, that goto is then executed. So if <span class="literal">differ</span> fails, the line fails, and flow continues with the line labeled <span class="literal">again</span>.</p>&#13;
<p class="indent">Truth in SNOBOL is the null string. I’m sure there’s a deep, philosophical implication to truth being null and empty, but we’ll stick with computer programming and avoid the headache. SNOBOL predicates that are true return the null string. So <span class="literal">differ</span> takes two objects and asks if they are not the same. Here the objects are whatever was assigned to <span class="literal">name</span> and SNOBOL’s constant for an empty string, <span class="literal">null</span>.</p>&#13;
<p class="indent">This line, then, is checking to see if the user pressed ENTER without typing anything. If so, <span class="literal">differ</span> fails and program flow returns to <span class="literal">again</span>. If the user enters some text, <span class="literal">differ</span> succeeds and returns the empty string, which, because it’s separated from the string constant by a space, is concatenated with the string and the name. Concatenating a null string doesn’t change anything. It’s like adding zero. So the line succeeds and <span class="literal">output</span> is assigned. The trick of using a predicate that concatenates a null string to a line is a common one in SNOBOL. However, the predicate doesn’t need to be used that way; it can be on a line by itself. For example, the following code works just as well:</p>&#13;
<pre>  differ(name, null)          :f(again)&#13;
  output = "Greetings, " name</pre>&#13;
<p class="noindent">If the <span class="literal">differ</span> is false, it fails, and the loop happens. If <span class="literal">differ</span> is true, the null string has no effect and the <span class="literal">output</span> proceeds.</p>&#13;
<p class="indent">We have figured out how to print strings and get user input and store it in a variable. We were also introduced to the overall structure of a SNOBOL program and learned a bit about gotos. Let’s continue our exploration by concentrating on variables and data types.</p>&#13;
<h4 class="h4" id="lev2sec39"><strong><em>Variables and Data Types</em></strong></h4>&#13;
<p class="noindent">As we’ve already seen, SNOBOL variables are created on demand and can hold any value. Strings, integers, and floats are SNOBOL’s primitive data types. In this section, we’ll work with these primitives and then go beyond them to create custom data types. This is the SNOBOL equivalent of structures in other languages like C.</p>&#13;
<h5 class="h5" id="lev3sec14"><strong>Integers and Floats</strong></h5>&#13;
<p class="noindent"><a href="ch05.xhtml#ch05list4">Listing 5-4</a> presents <em>temperature.sno</em>, a simple menu-driven program to convert between Fahrenheit and Celsius temperatures.</p>&#13;
<pre><span epub:type="pagebreak" id="page_129"/>menu  output =&#13;
      output = "(1) F to C or (2) C to F, 'q' to quit:"&#13;
      menu = input&#13;
      ident(menu,'2')                     :s(CtoF)&#13;
      ident(menu,'q')                     :s(end)&#13;
&#13;
* F to C&#13;
      output = "Fahrenheit temperature?"&#13;
      F = input&#13;
      C = (5. / 9.) * (F - 32.0)&#13;
      output = F " F = " C " C"           :(menu)&#13;
&#13;
* C to F&#13;
CtoF  output = "Celsius temperature?"&#13;
      C = input&#13;
      F = (9. / 5.) * C + 32.0&#13;
      output = C " C = " F " F"           :(menu)&#13;
end</pre>&#13;
<p class="caption" id="ch05list4"><em>Listing 5-4: Temperature conversion</em></p>&#13;
<p class="indent">The menu asks for the type of conversion or <span class="literal">q</span> to quit. The variable <span class="literal">menu</span> holds the user’s selection. Next comes a new predicate, <span class="literal">ident</span>. As you likely surmised from the name, <span class="literal">ident</span> is the opposite of <span class="literal">differ</span>; it’s true when the arguments are identical. Notice that <span class="literal">menu</span> is compared to the string constant <span class="literal">'2'</span> and not just 2. This is one place where SNOBOL’s permissive automatic string conversion is not applied. The value returned by <span class="literal">input</span> is always a string, so we must use a string with <span class="literal">ident</span>. If we did use 2 and not <span class="literal">'2'</span>, there would be no error, but the predicate would fail, and because there is no fail goto defined, SNOBOL would proceed to the next line instead.</p>&#13;
<p class="indent">The <span class="literal">ident</span> line shows us a new form of goto, <span class="literal">:s(CtoF)</span>. The <span class="literal">s</span> means success, and tells SNOBOL where to go if the line does not fail. In this case, not failing means the user selected option two. Thus, the program jumps to the label <span class="literal">CtoF</span> to convert Celsius to Fahrenheit. Likewise, the following line jumps to the end if the user entered a <span class="literal">q</span>. If the user entered neither <span class="literal">2</span> nor <span class="literal">q</span>, execution falls through to the code marked <span class="literal">F to C</span>.</p>&#13;
<p class="indent">The conversions ask the user for a temperature, perform the proper conversion, report the result, and then jump back to <span class="literal">menu</span>. The conversions also do something subtle behind the scenes. The requested temperature is assigned to either <span class="literal">F</span> or <span class="literal">C</span>, which are then used in the conversion equation. In this case, SNOBOL does automatically convert the input to a number. Unless the user explicitly enters a decimal point or uses scientific notation, the resulting number is an integer; otherwise, it’s a float. This means the programmer is responsible for ensuring that expressions perform the proper conversion as to type. To make the input an integer, multiply by 1. To make the input a float, multiply by 1.0 or use the <span class="literal">convert</span> function, which shows up later in this chapter.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_130"/>There is more to notice in <a href="ch05.xhtml#ch05list4">Listing 5-4</a>. Look carefully at how we’ve written the conversion formulas. First, we use decimal points to force floating-point computation. Without them, the division operation would use integer math, though the expected promotion from integer to float happens if there is a float in the expression. However, be careful because each subexpression needs a float as well. In that case, <span class="literal">(9 / 5) * 100.0 + 32.0</span> would be <span class="literal">132</span> rather than <span class="literal">212</span> because the fraction is pure integer math returning 1 instead of 1.8.</p>&#13;
<p class="indent">Notice that there are spaces around each of the operators in the conversions. These are not just for readability; SNOBOL requires them. Forgetting a space before or after an operator is an error, as SNOBOL will happily point out to you. Lastly, SNOBOL lacks the format specifiers found in languages like C and Python. SNOBOL expects the programmer to convert the number to a string with appropriate spacing and justification to format output. You’re on your own when formatting output in SNOBOL.</p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05list4">Listing 5-4</a> implemented a simple menu by checking the user’s input with <span class="literal">ident</span>. SNOBOL also allows <em>computed gotos</em>. A computed goto uses an expression to determine the target label. <a href="ch05.xhtml#ch05list5">Listing 5-5</a> shows <em>menu.sno</em>, which implements a simple menu with a computed goto.</p>&#13;
<pre>loop    output = "Select your entree:"&#13;
        output = "  0) Green eggs and ham"&#13;
        output = "  1) Purple pizza"&#13;
        output = "  2) Plaid tacos"&#13;
        output = "  3) Blue snocone"&#13;
        output = "  4) Quit"&#13;
        menu = input               &#13;
        order = "You ordered "       :($('menu' menu))&#13;
&#13;
menu0   order = order "green eggs and ham"   :(print)&#13;
menu1   order = order "a purple pizza"       :(print)&#13;
menu2   order = order "plaid tacos"          :(print)&#13;
menu3   order = order "a blue snocone"       :(print)&#13;
print   output =&#13;
        output = order&#13;
        output =                             :(loop)&#13;
menu4&#13;
end</pre>&#13;
<p class="caption" id="ch05list5"><em>Listing 5-5: Using a computed goto</em></p>&#13;
<p class="indent">The menu loop asks the user to select an entrée, then outputs the name of the selected entrée. Not a particularly useful program, but it does have one interesting feature: <span class="literal">($('menu' menu))</span>.</p>&#13;
<p class="indent">The label matching the string formed by the expression inside <span class="literal">$(...)</span> is the goto’s target. The <span class="literal">$(...)</span> syntax is a form of indirection that tells SNOBOL to build the target label on the fly using the expression inside the parentheses. The expression is <span class="literal">'menu' menu</span>, which concatenates the word <em>menu</em> with the user’s number. Naturally, an actual application would validate the user’s input first.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_131"/>Jumping to the proper label updates <span class="literal">order</span> and the desired entrée is displayed before jumping back to <span class="literal">loop</span>. If the user selects option four, the program jumps to label <span class="literal">menu4</span>, which falls through to <span class="literal">end</span> to exit the program.</p>&#13;
<h5 class="h5" id="lev3sec15"><strong>Indirection</strong></h5>&#13;
<p class="noindent">Consider the following sequence of SNOBOL instructions from an interactive session.</p>&#13;
<pre>snobol4&gt;  <span class="codestrong1">a = 123</span>&#13;
snobol4&gt;  <span class="codestrong1">b = .a</span>&#13;
snobol4&gt;  <span class="codestrong1">c = 'a'</span>&#13;
snobol4&gt;  <span class="codestrong1">output = a</span>&#13;
snobol4&gt;  <span class="codestrong1">output = b</span>&#13;
snobol4&gt;  <span class="codestrong1">output = c</span>&#13;
snobol4&gt;  <span class="codestrong1">output = $b</span>&#13;
snobol4&gt;  <span class="codestrong1">output = $c</span>&#13;
snobol4&gt;  <span class="codestrong1">output = $.a</span>&#13;
snobol4&gt; <span class="codestrong1">end</span>&#13;
&#13;
123&#13;
A&#13;
a&#13;
123&#13;
123&#13;
123</pre>&#13;
<p class="indent">The first line assigns <span class="literal">123</span> to <span class="literal">a</span>. The second uses the <em>name operator</em> (<span class="literal">.</span>) to assign the name of <span class="literal">a</span> to <span class="literal">b</span>. In SNOBOL, the name of a variable is similar to the address of a variable in languages like C. The third line sets <span class="literal">c</span> to the string <span class="literal">'a'</span>. Then come a series of <span class="literal">output</span> statements.</p>&#13;
<p class="indent">The first displays <span class="literal">a</span> returning <span class="literal">123</span>, as expected. The second outputs <span class="literal">b</span>, which returns the name of <span class="literal">a</span>, <span class="literal">A</span>. SNOBOL is case insensitive, so the name of a variable is shown in all caps. The third <span class="literal">output</span> prints the string <span class="literal">'a'</span>, again, as expected.</p>&#13;
<p class="indent">The last three <span class="literal">output</span> statements are more interesting. They all use indirect references (<span class="literal">$</span>) to output not the value of the variable, but the value of the variable whose name is in the first variable. The variable <span class="literal">b</span> was assigned to the name of <span class="literal">a</span>, meaning it is the string <span class="literal">'A'</span>. So the indirect reference looks to <span class="literal">b</span> to get the string <span class="literal">'A'</span> and then looks for a variable called <span class="literal">A</span>, finds it, and returns <em>its</em> value. So the output of <span class="literal">$b</span> is <span class="literal">123</span>, the value of <span class="literal">a</span>. Using a string with the variable name works as well, which is why the output of <span class="literal">$c</span> is also the value of <span class="literal">a</span>. Lastly, the name operator and indirect reference are inverses of each other, so <span class="literal">$.a</span> means “name of <span class="literal">a</span> indirectly referenced back to <span class="literal">a</span>,” resulting in the value of <span class="literal">a</span>.</p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05list6">Listing 5-6</a> shows another indirection example, that of the file <em>indirect.sno</em>.</p>&#13;
<pre> cosa1 = 'thing1'&#13;
 cosa2 = 'thing2'<span epub:type="pagebreak" id="page_132"/>&#13;
 $cosa1 = 'mea1'&#13;
 $cosa2 = 'mea2'&#13;
 $thing1 = 'kitu1'&#13;
 $thing2 = 'kitu2'&#13;
 output = cosa1 ' ' cosa2&#13;
 output = thing1 ' ' thing2&#13;
 output = $thing1 ' ' $thing2&#13;
 output = mea1 ' ' mea2&#13;
 output = $$cosa1 ' ' $$cosa2&#13;
end</pre>&#13;
<p class="caption" id="ch05list6"><em>Listing 5-6: Another indirection example</em></p>&#13;
<p class="indent">Take a look at the listing before reading further to see if you can guess what the output will be. Notice that the <span class="literal">output</span> statements use string concatenation to output two variables on one line with a single space between them. Read on when ready to see what SNOBOL says the output should be.</p>&#13;
<p class="indent">SNOBOL reports the following as the output of <a href="ch05.xhtml#ch05list6">Listing 5-6</a>:</p>&#13;
<pre>thing1 thing2&#13;
mea1 mea2&#13;
kitu1 kitu2&#13;
kitu1 kitu2&#13;
kitu1 kitu2</pre>&#13;
<p class="indent">The first line of <a href="ch05.xhtml#ch05list6">Listing 5-6</a> shouldn’t be mysterious. It’s normal variable output; <span class="literal">cosa1</span> and <span class="literal">cosa2</span> are the literal strings <span class="literal">'thing1'</span> and <span class="literal">'thing2'</span>.</p>&#13;
<p class="indent">At first glance, the second output line is a bit of a surprise. The code assigns variables <span class="literal">thing1</span> and <span class="literal">thing2</span> to <span class="literal">output</span>, but those variables are not explicitly defined in the code. The lines that create them are</p>&#13;
<pre> $cosa1 = 'mea1'&#13;
 $cosa2 = 'mea2'</pre>&#13;
<p class="noindent">where the indirect reference is used to assign not to <span class="literal">cosa1</span> and <span class="literal">cosa2</span>, but to the variables created by the current value of <span class="literal">cosa1</span> and <span class="literal">cosa2</span>, which are <span class="literal">'thing1'</span> and <span class="literal">'thing2'</span>. Therefore, <span class="literal">thing1</span> equals <span class="literal">'mea1'</span> and <span class="literal">thing2</span> equals <span class="literal">'mea2'</span>.</p>&#13;
<p class="indent">The next pair of lines in <a href="ch05.xhtml#ch05list6">Listing 5-6</a> are similar.</p>&#13;
<pre> $thing1 = 'kitu1'&#13;
 $thing2 = 'kitu2'</pre>&#13;
<p class="noindent">To create two new variables, <span class="literal">mea1</span> and <span class="literal">mea2</span> assigned <span class="literal">'kitu1'</span> and <span class="literal">'kitu2'</span>, respectively. This explains why the third line of output is <span class="literal">kitu1 kitu2</span>. The indirect reference on <span class="literal">thing1</span>, containing <span class="literal">'mea1'</span>, returns the value of <span class="literal">mea1</span>, which is <span class="literal">'kitu1'</span>, and likewise for <span class="literal">thing2</span>. Because they were created by assigning to <span class="literal">$thing1</span> and <span class="literal">$thing2</span>, the next output line makes sense, too.</p>&#13;
<p class="indent">The final assignment uses indirection twice on <span class="literal">cosa1</span>. The first indirection, that is, the rightmost <span class="literal">$</span>, returns <span class="literal">thing1</span>. The second indirection on <span class="literal">thing1</span> returns <span class="literal">mea1</span>’s value, which is <span class="literal">'kitu1'</span>. The same is true for <span class="literal">$$cosa2</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_133"/>SNOBOL’s indirection and dynamic creation of variables during runtime are quite powerful and equally confusing if not used carefully. For the curious, <em>cosa</em> means “thing” in Spanish. Likewise, <em>mea</em> is Hawaiian for “thing” and <em>kitu</em> is Swahili for, you guessed it, “thing.”</p>&#13;
<h5 class="h5" id="lev3sec16"><strong>User-Defined Data Types</strong></h5>&#13;
<p class="noindent">User-defined data types are created with the function <span class="literal">data</span>, which accepts a <em>string</em> as its argument. The string defines the name of the new type and the names of the elements of the type. SNOBOL creates a function to generate new instances of the type and functions with the names of the type elements. The latter functions are used to access elements of the type when it is used.</p>&#13;
<p class="indent">For example, consider the following instructions:</p>&#13;
<pre>snobol4&gt;  <span class="codestrong1">data('complex(real,imag)')</span>&#13;
snobol4&gt;  <span class="codestrong1">a = complex(1.5, 3.3)</span>&#13;
snobol4&gt;  <span class="codestrong1">b = complex(2.3,-0.4)</span>&#13;
snobol4&gt;  <span class="codestrong1">output = a</span>&#13;
snobol4&gt;  <span class="codestrong1">output = b</span>&#13;
snobol4&gt;  <span class="codestrong1">output = real(a) ' ' real(b)</span>&#13;
snobol4&gt;  <span class="codestrong1">output = imag(a) ' ' imag(b)</span>&#13;
snobol4&gt; <span class="codestrong1">end</span>&#13;
&#13;
COMPLEX&#13;
COMPLEX&#13;
1.5 2.3&#13;
3.3 -0.4</pre>&#13;
<p class="indent">The first line defines a new data type, <span class="literal">complex</span>, which has two elements <span class="literal">real</span> and <span class="literal">imag</span>. We can use this data type to hold a complex number. A complex number has two parts: a real part and an imaginary part. The real part is a floating-point number corresponding to a number on the number line. The imaginary part is also a floating-point number which is multiplied, conceptually, by the square root of <em>–</em>1. The square root of <em>–</em>1 doesn’t exist. No number multiplied by itself is negative, so it’s “imaginary.” Even though complex numbers don’t correspond to anything in the physical world, their properties are such that they make certain calculations vastly simpler. For our purposes, all we care about is that this new complex data type has two elements. Notice that the definition of <span class="literal">complex</span> is given as a string. Because of this, SNOBOL can create new data types on the fly at runtime, perhaps in response to user input or data read from a file. Also, and this is important, the data type string <em>must not</em> contain spaces. Thus, <span class="literal">'complex(real,imag)'</span> works, but <span class="literal">'complex(real, imag)'</span> generates an error.</p>&#13;
<p class="indent">After defining <span class="literal">complex</span>, we immediately create two instances of it, <span class="literal">a</span> and <span class="literal">b</span>. To create an instance, use the name of the data type and supply a value for all the elements. Next are four <span class="literal">output</span> statements, the first two of which use <span class="literal">a</span> and <span class="literal">b</span>. In this case, SNOBOL prints the name of the data type, <span class="literal">COMPLEX</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_134"/>The final two <span class="literal">output</span> statements use the <span class="literal">real</span> and <span class="literal">imag</span> functions SNOBOL created for us when <span class="literal">complex</span> was defined. We’ll learn how to create user-defined functions below. Here, SNOBOL does us a favor by making functions automatically. The functions return the respective elements of the <span class="literal">complex</span> variables passed to them. We’ll revisit the <span class="literal">complex</span> data type when we explore user-defined functions below.</p>&#13;
<h4 class="h4" id="lev2sec40"><strong><em>Arrays and Tables</em></strong></h4>&#13;
<p class="noindent">SNOBOL supports multidimensional arrays with flexible indexing. Array elements are not typed and any data can be stored in an array element, including another array. This means SNOBOL supports nested arrays—arrays within arrays. Few languages have such flexibility with arrays.</p>&#13;
<p class="indent">SNOBOL also supports associative arrays—or, to use modern terminology, dictionaries—though in SNOBOL they are called <em>tables</em>, a collection of key-value pairs. Like arrays, tables are not restricted in terms of the data they contain. However, unlike arrays, tables are not fixed in size and may grow as needed to accommodate more entries.</p>&#13;
<h5 class="h5" id="lev3sec17"><strong>Arrays</strong></h5>&#13;
<p class="noindent">SNOBOL arrays are created with the <span class="literal">array</span> function. The function’s argument determines the number of dimensions, the range of the indices for each dimension, and a default value for each element. Let’s examine different arrays to understand how they are defined and accessed. There are many small examples, so each will be presented as a code snippet and the resulting value of the element accessed. Most of the examples are in <em>array.sno</em>.</p>&#13;
<p class="indent">The following declarations create different versions of the array <span class="literal">A</span>:</p>&#13;
<pre>A = array(10)&#13;
A = array('0:9')&#13;
A = array('0:7,20,-1:1')&#13;
A = array('128,128',0)</pre>&#13;
<p class="noindent">The first is a 1D array with 10 elements indexed from [1, 10]. Like FORTRAN, SNOBOL indexes arrays from 1 unless told otherwise. The second is also a 10-element vector with indices in [0, 9]. Notice that the array specification is a string. This is required to specify nonstandard index ranges. The third line defines a 3D array. The indices of the first dimension are in [0, 7]. The second dimension uses the defaults, [1, 20]. Lastly, the third dimension uses <em>–</em>1, 0, and 1 as indices. The final line defines a 2D array with indices in [1, 128], specified as a string, with each element initialized to 0.</p>&#13;
<p class="indent">SNOBOL manages memory independently, meaning that this sequence of array declarations is allowed as a sequence of SNOBOL statements. Each new array declaration destroys the previous, automatically freeing its memory. If you try allocating a large array and get the <span class="literal">Insufficient storage to continue</span> error, the <span class="literal">-d</span> command line option tells SNOBOL to reserve more memory.</p>&#13;
<pre>&gt; <span class="codestrong1">snobol4 -d 10m big.sno</span></pre>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_135"/>Here, the argument <span class="literal">10m</span> allocates 10MB worth of <em>descriptors</em>, each of which uses 16 bytes. On my system, <span class="literal">-d 300m</span> took about 15 seconds to initiate an interactive session and used about 4.8GB of system memory. The price paid for SNOBOL’s array flexibility is speed and memory use compared to standard fixed-data type arrays.</p>&#13;
<p class="indent">Let’s see a SNOBOL array in action (<a href="ch05.xhtml#ch05list7">Listing 5-7</a>).</p>&#13;
<pre>A = array('0:9')&#13;
A[0] = 'one'&#13;
A[1] = 3.141592&#13;
A[2] = 123456&#13;
A[3] = array(6)&#13;
A[3][1] = 'nested'&#13;
output = 'A[2]    = ' A[2]&#13;
output = 'A[1]    = ' A[1]&#13;
output = 'A[0]    = ' A[0]&#13;
output = 'A[3]    = ' convert(A[3],'string')&#13;
output = 'A[3][1] = ' A[3][1]</pre>&#13;
<p class="caption" id="ch05list7"><em>Listing 5-7: A 1D array</em></p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05list7">Listing 5-7</a> defines a 1D array of 10 elements with indices in [0, 9]. The next three lines assign the array’s elements, first to a string, then a float, and lastly, an integer. The next line assigns <span class="literal">A[3]</span> to an array of six elements with indices in [1, 6]. This is a nested array because it is part of the larger 10-element array, <span class="literal">A</span>. To assign elements of the nested array requires first selecting the nested array with <span class="literal">A[3]</span> and then selecting the desired element of the nested array, here the first: <span class="literal">A[3][1] = 'nested'</span>.</p>&#13;
<p class="indent">The five <span class="literal">output</span> statements display the assigned values. There is something new here, the <span class="literal">convert</span> function, which changes a variable’s type. The <span class="literal">output</span> statement is concatenating a string with the value of the array element. However, <span class="literal">A[3]</span> is not something automatically converted into a string. Therefore, <span class="literal">convert</span> is used to represent it as a string. The first argument to <span class="literal">convert</span> is the object to be converted and the second argument is a string naming the target type, in this case a string. We’ll use <span class="literal">convert</span> again later to change between arrays and tables.</p>&#13;
<p class="indent">Now consider <a href="ch05.xhtml#ch05list8">Listing 5-8</a>.</p>&#13;
<pre>B = array('128,128',0)&#13;
B[11,22] = 5555&#13;
B[12,45] = array('11,11')&#13;
B[12,45]&lt;5,6&gt; = 'how are you?'&#13;
&#13;
data('complex(real,imag)')&#13;
B[12,45][1,2] = complex(3,0.141592)&#13;
output = real(B[12,45][1,2]) '+' imag(B[12,45][1,2]) 'i'</pre>&#13;
<p class="caption" id="ch05list8"><em>Listing 5-8: A 2D array</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_136"/>The array <span class="literal">B</span> is 2D with both indices in [1, 128] and all elements are initialized to 0. Assignments follow using both indices. Note that SNOBOL has no limit on the number of dimensions an array may use. Element <span class="literal">B[12,45]</span> has been assigned a nested 11×11 array. The assignment to <span class="literal">B[12,45]&lt;5,6&gt;</span> seems unusual, but it isn’t. SNOBOL allows <span class="literal">&lt;</span> and <span class="literal">&gt;</span> in place of square brackets for indexing arrays. Consider them a relic of the 1960s.</p>&#13;
<p class="indent">The following two lines define the complex data type we saw above and then use it to store a complex number in <span class="literal">B[12,45][1,2]</span>. The <span class="literal">output</span> statement displays the complex number using the <span class="literal">real</span> and <span class="literal">imag</span> functions to extract the real and imaginary parts before piecing them together as <span class="literal">3+0.141592i</span>, which is the usual way imaginary numbers are displayed.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Some languages, like Python, use <span class="literal">j</span> in place of <span class="literal">i</span> to indicate a complex number. Engineers do this because <span class="literal">i</span> usually refers to electric current in their world. Mathematicians prefer <span class="literal">i</span> because electric current doesn’t exist in <em>their</em> world.</em></p>&#13;
</div>&#13;
<p class="indent">Now consider <a href="ch05.xhtml#ch05list9">Listing 5-9</a> with two blocks of code.</p>&#13;
<pre>A = array('0:5')&#13;
A[0] = 'xyzzy'&#13;
D = A &#13;
D[0] = 12345&#13;
output = 'A[0] is now ' A[0] &#13;
&#13;
A[0] = 'xyzzy'&#13;
E = copy(A)&#13;
E[0] = 'plugh'&#13;
output = 'E[0] is ' E[0] &#13;
output = 'A[0] is still ' A[0]</pre>&#13;
<p class="caption" id="ch05list9"><em>Listing 5-9: Array references and copying</em></p>&#13;
<p class="indent">The first block defines <span class="literal">A</span> and sets <span class="literal">A[0]</span> to the string <span class="literal">'xyzzy'</span>. Next, it creates <span class="literal">D</span> by assigning <span class="literal">A</span>, after which it immediately sets <span class="literal">D[0]</span> to <span class="literal">12345</span>. The question is: what does the following <span class="literal">output</span> statement display? The answer is:</p>&#13;
<pre>A[0] is now 12345</pre>&#13;
<p class="noindent">This is because simple assignment of an array does not copy it; it only makes <span class="literal">D</span> refer to the same object as <span class="literal">A</span>. This behavior is typical of most programming languages. As arrays might occupy a significant portion of memory, it is best to copy them only when essential.</p>&#13;
<p class="indent">Now consider the second code block of <a href="ch05.xhtml#ch05list9">Listing 5-9</a>. It restores the original value of <span class="literal">A[0]</span> and creates <span class="literal">E</span> using the <span class="literal">copy</span> function before assigning <span class="literal">E[0]</span> the string <span class="literal">'plugh'</span>. Then come two <span class="literal">output</span> statements. We might guess the output at this point.</p>&#13;
<pre>E[0] is plugh&#13;
A[0] is still xyzzy</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_137"/>The <span class="literal">copy</span> function duplicated <span class="literal">A</span>, so updating <span class="literal">E[0]</span> did not alter the original array. However, be aware that <span class="literal">copy</span> makes only <em>shallow</em> copies. In a shallow copy, nested arrays are not copied, only referenced.</p>&#13;
<h5 class="h5" id="lev3sec18"><strong>Tables</strong></h5>&#13;
<p class="noindent">SNOBOL tables are like Python dictionaries. They associate a key with a value, which can also be any type of data. A few examples should suffice to illustrate their use (see <a href="ch05.xhtml#ch05list10">Listing 5-10</a>).</p>&#13;
<pre>data('complex(real,imag)')&#13;
t = table()&#13;
t[1] = 'one'&#13;
t[2.0] = 'two'&#13;
t[complex(2,3)] = 'three'&#13;
c = complex(2,3)&#13;
t[c] = 'four'&#13;
output = t[1]&#13;
output = t[2.0]&#13;
output = t[complex(2,3)]&#13;
output = t[c]</pre>&#13;
<p class="caption" id="ch05list10"><em>Listing 5-10: Using a table</em></p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05list10">Listing 5-10</a> shows almost all that is needed to understand a table. It first defines the now familiar <span class="literal">complex</span> data type, followed by a table, <span class="literal">t</span>. Four assignments to <span class="literal">t</span> follow, each with a different data type as the key. The four <span class="literal">output</span> statements produce</p>&#13;
<pre>one&#13;
two&#13;
&#13;
four</pre>&#13;
<p class="noindent">This might not match your expectations, as there is no <span class="literal">three</span> in the output. To recover the value for a key, the key used must match exactly. The key for <span class="literal">three</span> was <span class="literal">complex(2,3)</span>. That’s a perfectly valid key, but passing another instance of <span class="literal">complex(2,3)</span> will not find its value because the two do not evaluate to the same object in memory. Using <span class="literal">c</span> as a key does allow <span class="literal">four</span> to be recovered because <span class="literal">c</span> references the same data structure in memory. The last lesson from <a href="ch05.xhtml#ch05list10">Listing 5-10</a> is that referencing a key that doesn’t exist returns <span class="literal">null</span> but is not an error. To check whether a key is in the table, use the <span class="literal">ne</span> predicate to check the value returned against <span class="literal">null</span>.</p>&#13;
<p class="indent">The <span class="literal">table</span> declaration accepts up to two arguments. The first is the table’s initial size, the number of entries for which memory has already been allocated. Tables are dynamic, meaning they grow as needed. The second argument is the number of entries to grow by whenever the table must grow. If no arguments are given, <span class="literal">table()</span> is equivalent to <span class="literal">table(10,10)</span>. If you know the table will be large but mostly fixed when established, use a large first argument and a smaller second argument. Conversely, if you don’t know how <span epub:type="pagebreak" id="page_138"/>large the table will be but expect that many entries will be added, use a small initial size and a larger second argument.</p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05list11">Listing 5-11</a> defines a table with initial room for 100 entries, <span class="literal">z</span>.</p>&#13;
<pre>   z = table(100,25)&#13;
   z['one'] = 1&#13;
   z['two'] = 2&#13;
   z['three'] = 3&#13;
   z[3.14159265] = 'pi'&#13;
<span class="ent">➊</span> a = array(10)&#13;
<span class="ent">➋</span> a[7] = z&#13;
<span class="ent">➌</span> z[a] = a&#13;
   output = z['two']&#13;
   output = z[a]&#13;
   output = z[3.14159265]&#13;
<span class="ent">➍</span> output = z[a][7][a][7][a][7][3.14159265]</pre>&#13;
<p class="caption" id="ch05list11"><em>Listing 5-11: Another table example</em></p>&#13;
<p class="indent">The first four assignments to <span class="literal">z</span> are straightforward, though recalling the value of <em>π</em> to eight decimals so it can be used as a key to remember the string <span class="literal">'pi'</span> is admittedly rather silly. The example gets worse. We define an array, <span class="literal">a</span> <span class="ent">➊</span>, and assign the table, <span class="literal">z</span>, to its seventh element <span class="ent">➋</span>. Then, in the next line, we put <span class="literal">a</span> in the table <span class="ent">➌</span>. We’ve have an odd situation: the table we just placed <span class="literal">a</span> into is referenced by <span class="literal">a</span> itself.</p>&#13;
<p class="indent">The <span class="literal">output</span> statements generate</p>&#13;
<pre>2&#13;
ARRAY('10')&#13;
pi&#13;
pi</pre>&#13;
<p class="noindent">We get the integer <span class="literal">2</span>, the array <span class="literal">a</span>, the name <span class="literal">pi</span> from its floating-point value to eight decimals, and then the final output, also <span class="literal">pi</span>. The final output was generated by <span class="ent">➍</span>. Because <span class="literal">a</span> is in <span class="literal">z</span>, and <span class="literal">z</span> is in <span class="literal">a</span>, we can use an arbitrary number of pairs of references, first <span class="literal">[a]</span> to return the array followed by <span class="literal">[7]</span> to get <span class="literal">z</span> from the array, to finally arrive again at <span class="literal">z</span> and recover <span class="literal">pi</span>. Of course, this is a ludicrous thing to do, but SNOBOL doesn’t judge.</p>&#13;
<p class="indent">How can we know what keys a SNOBOL table has? In Python, we can use the <span class="literal">keys</span> method. In SNOBOL, we convert the table to an array to get at the keys. Likewise, we can convert a properly structured array into a table. <a href="ch05.xhtml#ch05list12">Listing 5-12</a> illustrates an example of each.</p>&#13;
<pre>     <span class="ent">➊</span> t = table()&#13;
        t['one'] = 1; t['two'] = 2; t['three'] = 3.3&#13;
     <span class="ent">➋</span> x = convert(t, 'array')&#13;
     <span class="ent">➌</span> i = 1&#13;
   loop output = 'key: ' x[i,1] ', value: ' x[i,2]  :f(cont)&#13;
        i = i + 1      :(loop)<span epub:type="pagebreak" id="page_139"/>&#13;
   &#13;
<span class="ent">➍</span> cont a = array('3,2')&#13;
        a[1,1] = 'one'; a[1,2] = 1&#13;
        a[2,1] = 'two'; a[2,2] = 2&#13;
        a[3,1] = 'three'; a[3,2] = 3&#13;
     <span class="ent">➎</span> y = convert(a, 'table')&#13;
        output = y['one']&#13;
        output = y['two']&#13;
        output = y['three']</pre>&#13;
<p class="caption" id="ch05list12"><em>Listing 5-12: Converting tables to arrays and arrays to tables</em></p>&#13;
<p class="indent">We first create a table <span class="ent">➊</span> and add three entries. Next, we call <span class="literal">convert</span> to change the table into an array, <span class="literal">x</span>. The array has <em>n</em> × 2 dimensions if there are <em>n</em> entries in the table. The first column is the key and the second column is the value. The keys and values are printed using a simple loop <span class="ent">➌</span>. Notice that the loop ends when accessing the array fails because the index, <span class="literal">i</span>, is too large. In SNOBOL, you code for failure.</p>&#13;
<p class="indent">To go the other way and convert an array into a table, consider <span class="ent">➍</span>. A 2D array is created with the first column as the key and the second column as the value. Another call to <span class="literal">convert</span> makes the properly structured array a table <span class="ent">➎</span>.</p>&#13;
<p class="indent">SNOBOL arrays and tables are flexible and more advanced than many other languages of the time.</p>&#13;
<p class="indent">And now for something completely different.</p>&#13;
<h4 class="h4" id="lev2sec41"><strong><em>A Blizzard of Patterns</em></strong></h4>&#13;
<p class="noindent">In this section, we’ll introduce patterns, though a thorough understanding of patterns is beyond what we can hope to cover in a single chapter. There are two types of pattern statements in SNOBOL. The first applies a pattern to a string. The second applies a pattern to a string and updates the portion of the string that matched the pattern. We’ll learn about patterns in B. F. Skinner fashion, a little bit at a time, with examples.</p>&#13;
<h5 class="h5" id="lev3sec19"><strong>A First Example</strong></h5>&#13;
<p class="noindent">Consider <a href="ch05.xhtml#ch05list13">Listing 5-13</a>, which presents a simple program accepting lines of text from the user until the string <span class="literal">'hello'</span> appears in one of the lines.</p>&#13;
<pre>loop  input 'hello'          :f(loop)&#13;
      output = "Greetings!"&#13;
end</pre>&#13;
<p class="caption" id="ch05list13"><em>Listing 5-13: A simple pattern example</em></p>&#13;
<p class="indent">The first line of the program calls <span class="literal">input</span> to return a string. The second string, which at first might appear to be concatenated because of the space, is a pattern, with the pattern matching a constant string. If the text returned by <span class="literal">input</span> has <span class="literal">'hello'</span> anywhere within it, the pattern match succeeds. If not, it fails, and the goto for failure asks the user for another string.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_140"/><a href="ch05.xhtml#ch05list13">Listing 5-13</a> is an example of the first type of pattern matching statement: a <em>text pattern</em>. In a pattern, success or failure of the match decides what happens next; however, as we’ll see, a pattern can generate new variables that hold pieces of the matched pattern. This means that many pattern matching statements are assigning data even if they don’t have explicit gotos.</p>&#13;
<p class="indent">The pattern matches only an explicit string of characters. If we want to check for other options, we use alternation, <span class="literal">|</span> (with spaces!). Therefore, to accept either <span class="literal">'hello'</span> or <span class="literal">'aloha'</span>, use <span class="literal">'hello' | 'aloha'</span> as the pattern.</p>&#13;
<p class="indent">As you might expect, SNOBOL has many bits and pieces for matching various patterns. The ones we’ll examine are <span class="literal">len</span>, <span class="literal">span</span>, <span class="literal">pos</span>, <span class="literal">any</span>, and <span class="literal">break</span>.</p>&#13;
<h5 class="h5" id="lev3sec20"><strong>Matching and Updating Strings</strong></h5>&#13;
<p class="noindent">The second pattern statement matches a pattern and updates the text matched with new text. See <a href="ch05.xhtml#ch05list14">Listing 5-14</a>.</p>&#13;
<pre>color = 'brown'&#13;
animal = 'cow'&#13;
text = 'how now brown cow?'&#13;
text color = 'blue'&#13;
text animal = 'giraffe'&#13;
output = text&#13;
end</pre>&#13;
<p class="caption" id="ch05list14"><em>Listing 5-14: Matching and updating a string</em></p>&#13;
<p class="indent">The output of this program is <span class="literal">how now blue giraffe?</span>, where <span class="literal">color</span> matched to change <span class="literal">brown</span> to <span class="literal">blue</span>, and <span class="literal">animal</span> matched to change <span class="literal">cow</span> to <span class="literal">giraffe</span>. If the match fails, the string is not updated. Note that a match succeeds when the first success happens. Therefore,</p>&#13;
<pre>text = 'The brown bear approached the brown car'&#13;
text 'brown' = 'black'&#13;
output = text</pre>&#13;
<p class="noindent">produces <span class="literal">The black bear approached the brown car</span>. To update all matches, use a loop.</p>&#13;
<pre>      text = 'The brown bear approached the brown car'&#13;
loop  text 'brown' = 'black'            :s(loop)&#13;
      output = text</pre>&#13;
<p class="noindent">This example loops for as long as the pattern <span class="literal">'brown'</span> is found, replacing it with <span class="literal">'black'</span> each time. The output is now <span class="literal">The black bear approached the black car</span>.</p>&#13;
<h5 class="h5" id="lev3sec21"><strong>Extracting Information from a String</strong></h5>&#13;
<p class="noindent">What if we want to extract the matched text? When used in a pattern, the name operator (<span class="literal">.</span>) extracts the matched text to a variable. See <a href="ch05.xhtml#ch05list15">Listing 5-15</a>.</p>&#13;
<pre><span class="ent">➊</span> dpat = span(',: ')&#13;
<span class="ent">➋</span> lpat = (break(',:') . last) dpat<span epub:type="pagebreak" id="page_141"/>&#13;
<span class="ent">➌</span> fpat = (break(',:') . first) dpat&#13;
<span class="ent">➍</span> apat = (rem . address)&#13;
<span class="ent">➎</span> text = 'Caesar,   Julius:  1313 Mockingbird Ln   '&#13;
<span class="ent">➏</span> text lpat fpat apat&#13;
<span class="ent">➐</span> output = first ' ' last ', address: ' trim(address)&#13;
   end</pre>&#13;
<p class="caption" id="ch05list15"><em>Listing 5-15: Capturing the matched text</em></p>&#13;
<p class="indent">Several new things are happening in <a href="ch05.xhtml#ch05list15">Listing 5-15</a>, so let’s go through it carefully. Structurally, the program consists of four pattern definitions, which are the variables ending in <span class="literal">pat</span>. This is followed by a piece of example text with a first name, last name, and address. Our goal is to break this text apart into its individual fields. The pattern matching line comes next, followed by an <span class="literal">output</span> statement to print the data in a new format.</p>&#13;
<p class="indent">Let’s explain what’s happening, line by line. First, we define <span class="literal">dpat</span> <span class="ent">➊</span>. This is a pattern to match one or more instances of a comma, colon, or space. That’s what <span class="literal">span</span> does; it matches the longest possible sequence consisting of nothing but the characters in its argument.</p>&#13;
<p class="indent">Next comes <span class="literal">lpat</span> <span class="ent">➋</span>. This pattern matches characters up to, but not including, the first occurrence of a comma or colon. That’s what <span class="literal">break</span> does. If the string is <span class="literal">abcde:f</span>, then <span class="literal">break(',:')</span> matches the string <span class="literal">abcde</span>, but not the colon.</p>&#13;
<p class="indent">The <span class="literal">break</span> is next to the name operator, followed by <span class="literal">last</span>, with the entire expression surrounded by parentheses. The expression matches characters up to, but not including, the first comma or colon, and stores them in the variable <span class="literal">last</span>. Looking at line <span class="ent">➎</span> makes it clear that <span class="literal">lpat</span> matches the last name.</p>&#13;
<p class="indent">However, <span class="ent">➋</span> has a <span class="literal">dpat</span> hanging at the end. It’s there to match the comma or colon that ended the <span class="literal">break</span>. As SNOBOL attempts to match a pattern, internally, it’s moving a <em>cursor</em> over the string, character by character, forward and sometimes backward to try other options. When the <span class="literal">break</span> of <span class="literal">lpat</span> matches, the cursor is looking at the comma or colon that ended the <span class="literal">break</span>. So we use <span class="literal">dpat</span> to skip it.</p>&#13;
<p class="indent">The definition of <span class="literal">fpat</span> <span class="ent">➌</span> is nearly identical to <span class="ent">➋</span>; however, the matched text is stored in <span class="literal">first</span>. That is, <span class="literal">fpat</span> matches the first name. As before, a <span class="literal">dpat</span> at the end of the pattern consumes the comma or colon that ended the <span class="literal"><em>break</em></span>.</p>&#13;
<p class="indent">The internal cursor has now matched the last name and first name. The remaining pattern, <span class="literal">apat</span>, uses the special pattern, <span class="literal">rem</span>, to match the remainder of the line and assign it to <span class="literal">address</span> <span class="ent">➍</span>.</p>&#13;
<p class="indent">To test the patterns, we define <span class="literal">text</span> to be a string with a last name, first name, and address using a comma and a colon as delimiters along with some extra spaces <span class="ent">➎</span>.</p>&#13;
<p class="indent">Lastly, we apply the patterns to <span class="literal">text</span> <span class="ent">➏</span>. Notice that, at first glance, <span class="ent">➏</span> is just a sequence of four variables in a row. However, SNOBOL knows to parse this as a string followed by a pattern. The string is <span class="literal">text</span>; therefore, the remaining variables form the pattern. The overall pattern is built by concatenating <span class="literal">lpat</span>, <span class="literal">fpat</span>, and <span class="literal">apat</span>. We might, for clarity, put parentheses around the three pattern variables. If we wanted to concatenate two or more text strings <span epub:type="pagebreak" id="page_142"/>and then apply a pattern, the parentheses would be placed around those variables.</p>&#13;
<p class="indent">When <span class="ent">➏</span> executes, the last name, first name, and address are extracted. To prove this, <span class="ent">➐</span> dumps the same information rearranged to be first name, then last name, followed by the address. Notice that <span class="literal">address</span> is passed to <span class="literal">trim</span>, the SNOBOL function to remove trailing spaces from a string. The output of <a href="ch05.xhtml#ch05list15">Listing 5-15</a> is <span class="literal">'Julius Caesar, address: 1313 Mockingbird Ln'</span>.</p>&#13;
<h5 class="h5" id="lev3sec22"><strong>More Elaborate Pattern Matching</strong></h5>&#13;
<p class="noindent">Let’s look at three more quick pattern matching examples. The first two manipulate a file of dates. The last one updates Lewis Carroll’s <em>Alice’s Adventures in Wonderland</em> to give “Bob” a chance to put himself in the story.</p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05list16">Listing 5-16</a> maps numeric dates in North American format (month, day, year) to European-style dates (day, month, year).</p>&#13;
<pre>*  Map North American dates to European dates&#13;
   <span class="ent">➊</span> pat = len(2) . month ('/' | '-') len(2) . day ('/' | '-') len(4) . year&#13;
loop  text = input                          :f(end)&#13;
   <span class="ent">➋</span> text pat = day '/' month '/' year     :f(bad)&#13;
      output = text                         :(loop)&#13;
bad   output = "unknown format"             :(loop)&#13;
end</pre>&#13;
<p class="caption" id="ch05list16"><em>Listing 5-16: Manipulating dates with patterns, take one</em></p>&#13;
<p class="indent">The pattern, <span class="literal">pat</span>, uses <span class="literal">len</span> to match the specified number of characters, regardless of what they are. The first two characters are assigned to <span class="literal">month</span>, followed by a slash or dash; then the next two characters are put in <span class="literal">day</span>, followed by another slash or dash and a four-character year.</p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05list15">Listing 5-15</a> is in the file <em>dates.sno</em>. There is another file in the same directory called <em>dates.txt</em> that contains a set of numeric dates. For example, the first few lines of the file are</p>&#13;
<pre>10-14-1066&#13;
10/12/1492&#13;
04/15/1912&#13;
07-24-1969&#13;
04/04-1968&#13;
11-23-1963</pre>&#13;
<p class="noindent">with some dates using slashes and some using dashes. A few even use a mix. <a href="ch05.xhtml#ch05list15">Listing 5-15</a> uses a <span class="literal">loop</span> to read the file, line by line. Each line is read with <span class="literal">input</span> using command line redirection and placed into <span class="literal">text</span>. If there is nothing left to read, the <span class="literal">input</span> command fails and SNOBOL jumps to the end.</p>&#13;
<p class="indent">If the read succeeds, the pattern is applied to <span class="literal">text</span>, but this time in the form <span class="literal">string pattern = update</span>, where the text matched by <span class="literal">pattern</span> is replaced by the text in <span class="literal">update</span>. Here, the replacement text is constructed from the day, month, and year matched by <span class="literal">pat</span>, using slashes between elements <span class="ent">➋</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_143"/>Notice that <span class="ent">➋</span> has a goto for failure. If the pattern doesn’t match, the input string is not a valid date format, so the program jumps to <span class="literal">bad</span> to output <span class="literal">unknown format</span> before jumping back to the loop to process the next input. If the pattern match doesn’t fail, <span class="literal">text</span> has been updated so it’s <span class="literal">output</span> before jumping to <span class="literal">loop</span> to read the next date.</p>&#13;
<p class="indent">Run <em>dates.sno</em> with</p>&#13;
<pre>&gt; <span class="codestrong1">snobol4 dates.sno &lt;dates.txt</span></pre>&#13;
<p class="noindent">to produce</p>&#13;
<pre>14/10/1066&#13;
12/10/1492&#13;
15/04/1912&#13;
24/07/1969&#13;
04/04/1968&#13;
23/11/1963&#13;
...&#13;
11/04/2020&#13;
03/01/1892&#13;
13/12/1989&#13;
09/04/1865&#13;
16/11/1093&#13;
unknown format</pre>&#13;
<p class="noindent">The final <span class="literal">unknown format</span> line corresponds to an input of <span class="literal">AVCDe-224*</span>, which is clearly not a valid date.</p>&#13;
<p class="indent">The next example uses <span class="literal">dates.txt</span>, but produces full dates instead of numeric dates. See <a href="ch05.xhtml#ch05list17">Listing 5-17</a>.</p>&#13;
<pre>*  Map numeric dates to full dates&#13;
      pat = len(2) . month ('/' | '-') len(2) . day ('/' | '-') len(4) . year&#13;
      m = array(12)&#13;
      m&lt;1&gt; = "January";  m&lt;2&gt; = "February";  m&lt;3&gt; = "March";  &#13;
      m&lt;4&gt; = "April";    m&lt;5&gt; = "May";       m&lt;6&gt; = "June";  &#13;
      m&lt;7&gt; = "July";     m&lt;8&gt; = "August";    m&lt;9&gt; = "September";  &#13;
      m&lt;10&gt; = "October"; m&lt;11&gt; = "November"; m&lt;12&gt; = "December"&#13;
&#13;
loop  text = input                                       :f(end)&#13;
      text pat                                           :f(bad)&#13;
      output = m&lt;month&gt; ' ' (1 * day) ', ' (1 * year)    :(loop)&#13;
bad   output = "unknown format"                          :(loop)&#13;
end</pre>&#13;
<p class="caption" id="ch05list17"><em>Listing 5-17: Manipulating dates with patterns, take two</em></p>&#13;
<p class="indent">The pattern, <span class="literal">pat</span>, is the same as in <a href="ch05.xhtml#ch05list16">Listing 5-16</a>. Additionally, we define <span class="literal">m</span>, an array holding the names of the months.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_144"/>The code runs in the same way as <a href="ch05.xhtml#ch05list16">Listing 5-16</a> but outputs a full date using the number of the month as the index into the array of names. Also, notice that both <span class="literal">day</span> and <span class="literal">year</span> are multiplied by 1. The text matched is a string. To output the day and year without leading 0s, as there are a few three-digit years in <span class="literal">dates.txt</span>, we convert the strings to integers. <a href="ch05.xhtml#ch05list17">Listing 5-17</a> is in the file <em>dates2.sno</em>. Run it to produce this output:</p>&#13;
<pre>October 14, 1066&#13;
October 12, 1492&#13;
April 15, 1912&#13;
July 24, 1969&#13;
April 4, 1968&#13;
November 23, 1963&#13;
...&#13;
April 11, 2020&#13;
January 3, 1892&#13;
December 13, 1989&#13;
April 9, 1865&#13;
November 16, 1093&#13;
unknown format</pre>&#13;
<p class="indent">For our final pattern example, with apologies to Lewis Carroll, we’ll update the first part of <em>Alice’s Adventures in Wonderland</em> to be <em>Bob’s Adventures in Wonderland.</em> The text we’ll work with is in the file <em>alice.txt</em>, and consists of the beginning part of <a href="ch01.xhtml#ch01">Chapter 1</a>.</p>&#13;
<p class="indent">The code we need is in <em>alice.sno</em> and <a href="ch05.xhtml#ch05list18">Listing 5-18</a>.</p>&#13;
<pre>*  Convert from Alice to Bob&#13;
        p = null | any(' .,?!)')&#13;
        s = pos(0) | ' ' | '('&#13;
loop    text = input                                :f(end)&#13;
s0      text s . a 'Alice' p . c   = a 'Bob' c      :s(s0)&#13;
s1      text s . a 'her' p . c     = a 'his' c      :s(s1)&#13;
s2      text s . a 'Her' p . c     = a 'His' c      :s(s2)&#13;
s3      text s . a 'herself' p . c = a 'himself' c  :s(s3)&#13;
s4      text s . a 'Herself' p . c = a 'Himself' c  :s(s4)&#13;
s5      text s . a 'she' p . c     = a 'he' c       :s(s5)&#13;
s6      text s . a 'She' p . c     = a 'He' c       :s(s6)&#13;
        output = text                               :(loop)&#13;
end</pre>&#13;
<p class="caption" id="ch05list18"><em>Listing 5-18: Making Bob’s Adventures in Wonderland</em></p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05list18">Listing 5-18</a> begins by defining two patterns, <span class="literal">p</span> and <span class="literal">s</span>. The first uses alternation to match nothing (<span class="literal">null</span>) or <span class="literal">any</span> single character that is a space, period, comma, question mark, exclamation point, or right parenthesis. The second <span epub:type="pagebreak" id="page_145"/>pattern uses <span class="literal">pos</span> to match cursor position zero, that is, the beginning of a line, a space, or a left parenthesis.</p>&#13;
<p class="indent">The remainder of the program is a loop from <span class="literal">input</span> to <span class="literal">output</span> via <span class="literal">loop</span>. Between the input and the output there are seven lines, <span class="literal">s0</span> through <span class="literal">s6</span>. Each of these lines is a loop (notice the success gotos) and has a similar format.</p>&#13;
<pre>text s . a 'string1' p . c = a 'string2' c</pre>&#13;
<p class="indent">The first part is the text read from the input file, <span class="literal">text</span>. The rest of the line up to the equals sign is a pattern. The pattern looks for a match to a word, such as the name <span class="literal">'Alice'</span>, storing the character before the word in <span class="literal">a</span> and the character after in <span class="literal">c</span>.</p>&#13;
<p class="indent">The matched text, if any, is replaced by the same leading and trailing character with the matched word updated. Thus, “Alice” is replaced with “Bob,” “her” is replaced with “his,” and so on. Recall that a match is successful after the first one is found, so if there are multiple occurrences of “Alice” in the line, only the first will be replaced with “Bob.” So we must loop until the match fails to replace all occurrences.</p>&#13;
<p class="indent">After all seven patterns are tested and matched as much as possible, the updated <span class="literal">text</span> is <span class="literal">output</span> and the loop begins again until there is no input left.</p>&#13;
<p class="indent">The first paragraph of <em>alice.txt</em> is</p>&#13;
<pre>Alice was beginning to get very tired of sitting by her sister on the&#13;
bank, and of having nothing to do: once or twice she had peeped into&#13;
the book her sister was reading, but it had no pictures or&#13;
conversations in it, "and what is the use of a book," thought Alice&#13;
"without pictures or conversations?"</pre>&#13;
<p class="noindent">The same paragraph after the “Bob” conversion is</p>&#13;
<pre>Bob was beginning to get very tired of sitting by his sister on the&#13;
bank, and of having nothing to do: once or twice he had peeped into&#13;
the book his sister was reading, but it had no pictures or&#13;
conversations in it, "and what is the use of a book," thought Bob&#13;
"without pictures or conversations?"</pre>&#13;
<p class="indent">The conversion isn’t foolproof, but that isn’t SNOBOL’s fault. There are cases in English where the word “her” should be changed to “his” and cases where it should become “him.” The code of <a href="ch05.xhtml#ch05list18">Listing 5-18</a> knows nothing of the context, so it always uses “his.”</p>&#13;
<p class="indent">There is much more to discover concerning SNOBOL patterns. An excellent place to learn more is <a href="ch02.xhtml#ch02">Chapter 2</a> of Griswold, Poage, and Polonsky’s <em>The SNOBOL4 Programming Language</em> (Prentice Hall, 1971). Versions of the second edition are floating around the internet if you care to take a look.</p>&#13;
<p class="indent">Let’s move on to SNOBOL’s user-defined functions, perhaps the least elegant part of the language (aside from relying solely on goto for flow control).</p>&#13;
<h4 class="h4" id="lev2sec42"><span epub:type="pagebreak" id="page_146"/><strong><em>Functions</em></strong></h4>&#13;
<p class="noindent">SNOBOL would be a weak language indeed if it had no facility for users to define functions. Thankfully, it does, though the syntax is a bit strange. In this section, we’ll learn how to define and use functions.</p>&#13;
<p class="indent">We’ll jump right in with <a href="ch05.xhtml#ch05list19">Listing 5-19</a>. This program, in the file <em>poly.sno</em>, defines a function to implement arbitrary polynomials of the form</p>&#13;
<p class="equationc"><em>y</em> = <em>a</em><em>x</em><sup>2</sup> + <em>b</em><em>x</em> + <em>c</em></p>&#13;
<p class="noindent">which we use to output (<em>x</em>, <em>y</em>) pairs for plotting the function.</p>&#13;
<pre>* Define a function&#13;
     <span class="ent">➊</span> define('poly(a,b,c,x)')            :(epoly)&#13;
poly    poly = a * x ** 2 + b * x + c      :(return)&#13;
epoly&#13;
&#13;
* Main body of the code&#13;
        x = -10&#13;
loop    output = x ' ' poly(1,2,2,x)&#13;
        x = x + 1&#13;
        ge(x,8)                            :f(loop)&#13;
end</pre>&#13;
<p class="caption" id="ch05list19"><em>Listing 5-19: A user-defined function</em></p>&#13;
<p class="indent">SNOBOL functions begin with a <span class="literal">define</span> statement <span class="ent">➊</span>. There are a couple of important things to notice about <span class="ent">➊</span>. First, the function declaration is a string. It begins with the name of the function (<span class="literal">poly</span>), followed by an opening parenthesis, the list of arguments, and a closing parenthesis. If the function uses local variables, they are listed next, separated by commas, as part of the string. Note that the string portion of the <span class="literal">define</span> statement <em>must not</em> include spaces. No spaces between the arguments, no spaces in the list of local variables, no spaces anywhere.</p>&#13;
<p class="indent">The next thing to notice is that the <span class="literal">define</span> statement ends with a goto (<span class="literal">epoly</span>). This label must jump to just beyond the end of the function’s body, that is, it must not include any code that is part of the function. The function’s body is the code between the <span class="literal">define</span> statement and the ending label, which here is <span class="literal">epoly</span>.</p>&#13;
<p class="indent">The function body begins with a label matching the function’s name, which is <span class="literal">poly</span> in this case. The body of the function is free to use the arguments, any local variables, and any global variables. The value returned by the function is assigned to a variable of the same name, as is sometimes done in other programming languages. In <a href="ch05.xhtml#ch05list19">Listing 5-19</a>, the variable <span class="literal">poly</span> is assigned the value of the quadratic.</p>&#13;
<p class="indent">To exit the function, SNOBOL defines two special goto labels: <span class="literal">return</span> and <span class="literal">freturn</span>. Use the former if the function was successful and the latter if not. The function <span class="literal">poly</span> always succeeds, so we use <span class="literal">return</span> to exit.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_147"/>SNOBOL allows recursion, as shown in <a href="ch05.xhtml#ch05list20">Listing 5-20</a>, which implements the factorial function. The factorial of an integer, <em>n</em>, is <em>n</em>! = <em>n</em>(<em>n –</em> 1)(<em>n –</em> 2)<em>…</em> 1. For example, 5! = 5 × 4 × 3 × 2 × 1 = 120.</p>&#13;
<p class="indent">Another way to think about the factorial of <em>n</em> is that it’s <em>n</em> times the factorial of <em>n –</em> 1, which is itself <em>n –</em> 1 times the factorial of <em>n –</em> 2, and so on down to 1. That’s the recursive version. In Python, we might write this process as</p>&#13;
<pre>def fact(n):&#13;
    if (n &lt; 1):&#13;
        return 0&#13;
    else:&#13;
        return n * fact(n-1)</pre>&#13;
<p class="noindent">where <span class="literal">fact</span> calls itself to solve the simpler problem. All recursive functions need a base case, something that stops the recursion. In this case, it’s checking if <em>n</em> is less than 1. This catches the edge case of 0! = 1.</p>&#13;
<p class="indent">Translating the recursive formula into SNOBOL leads to <a href="ch05.xhtml#ch05list20">Listing 5-20</a>.</p>&#13;
<pre>* Recursive factorial function&#13;
        define('fact(n)')       :(efact)&#13;
fact    fact = eq(n,0) 1        :s(return)&#13;
        fact = n * fact(n - 1)  :(return)&#13;
efact&#13;
&#13;
    output = "Enter a number:"&#13;
    n = input&#13;
    output = convert(n,'integer') "! = " fact(n)&#13;
end</pre>&#13;
<p class="caption" id="ch05list20"><em>Listing 5-20: A recursive factorial function</em></p>&#13;
<p class="indent">The definition accepts <em>n</em>. The first line of the body implements the base case. If <em>n</em> &gt; 0, then <span class="literal">eq(n,0)</span> fails, so <span class="literal">fact</span> is not assigned and the next line is executed. If <em>n</em> = 0, <span class="literal">eq(n,0)</span> succeeds, so we return from the function via <span class="literal">s(return)</span>.</p>&#13;
<p class="indent">The second line of <span class="literal">fact</span> implements the recursion. It assigns <span class="literal">fact</span> to <span class="literal">n</span> times whatever <span class="literal">fact(n - 1)</span> returns and then it returns via <span class="literal">(return)</span>.</p>&#13;
<p class="indent">The main code asks the user for a number and returns the factorial. Run it and enter integers in [0,20]. Beyond 20, integers overflow; however, if you enter a floating-point number, you can estimate larger factorials. Also, notice the use of <span class="literal">convert</span> to force <span class="literal">n</span> to be an integer for display purposes.</p>&#13;
<p class="indent">Let’s write a function to swap the value of two variables. This should be easy. Our first attempt is</p>&#13;
<pre>        define('swap(x,y)t')        :(eswap)&#13;
swap    t = x&#13;
        x = y&#13;
        y = t                       :(return)<span epub:type="pagebreak" id="page_148"/>&#13;
eswap&#13;
        a = 3&#13;
        b = 5&#13;
&#13;
        output = "a = " a ", b = " b&#13;
        swap(a,b)&#13;
        output = "a = " a ", b = " b&#13;
end</pre>&#13;
<p class="noindent">which defines <span class="literal">swap</span>. The value of <span class="literal">x</span> is kept in <span class="literal">t</span>, then <span class="literal">y</span> is assigned to <span class="literal">x</span> and <span class="literal">t</span> is assigned to <span class="literal">y</span>, followed by a return. The main body of the program sets <em>a</em> = 3 and <em>b</em> = 5, outputs their values, calls <span class="literal">swap</span>, and then outputs them again. Running the code produces</p>&#13;
<pre>a = 3, b = 5&#13;
a = 3, b = 5</pre>&#13;
<p class="noindent">This is clearly incorrect. The values haven’t changed. Why? The algorithm in <span class="literal">swap</span> is correct, so why didn’t the values change?</p>&#13;
<p class="indent">SNOBOL passes simple variables by <em>value</em>, meaning the value of <span class="literal">a</span> is assigned to <span class="literal">x</span>. So when <span class="literal">x</span> is updated in the body of <span class="literal">swap</span>, <span class="literal">a</span> is not affected. To update the variables, we need to pass the data by <em>reference</em> so <span class="literal">x</span> is really a synonym for <span class="literal">a</span>. After that, updates to <span class="literal">x</span> will affect <span class="literal">a</span>. Note that SNOBOL passes arrays and tables by reference.</p>&#13;
<p class="indent">The code above is wrong. I don’t want you to use it. However, the code in <a href="ch05.xhtml#ch05list21">Listing 5-21</a> does work correctly.</p>&#13;
<pre>* Function to swap two variables&#13;
        define('swap(x,y)t')        :(eswap)&#13;
swap    t = $x&#13;
        $x = $y&#13;
        $y = t                      :(return)&#13;
eswap&#13;
&#13;
        a = 3&#13;
        b = 5&#13;
        output = "a = " a ", b = " b&#13;
     <span class="ent">➊</span> swap(a,b)&#13;
        output = "a = " a ", b = " b&#13;
     <span class="ent">➋</span> swap(.a,.b)&#13;
        output = "a = " a ", b = " b&#13;
     <span class="ent">➌</span> swap('a','b')&#13;
        output = "a = " a ", b = " b&#13;
end</pre>&#13;
<p class="caption" id="ch05list21"><em>Listing 5-21: Passing variables by reference</em></p>&#13;
<p class="indent">Let’s focus on <span class="literal">swap</span>. It looks much like the wrong version, but it uses the indirection operator (<span class="literal">$</span>) before each argument, <span class="literal">$x</span>. Recall that indirection means “not this variable, but the variable named by this variable.” Think <span epub:type="pagebreak" id="page_149"/>of indirection as dereferencing a pointer in other languages. The <span class="literal">swap</span> function is now working directly with names passed to it rather than copies of the variables.</p>&#13;
<p class="indent">The main body of <a href="ch05.xhtml#ch05list21">Listing 5-21</a> will clarify. The first call to <span class="literal">swap</span> passes <span class="literal">a</span> and <span class="literal">b</span> <span class="ent">➊</span>. The second call uses the name operator to pass the names of <span class="literal">a</span> and <span class="literal">b</span> <span class="ent">➋</span>. The last call passes the literal strings <span class="literal">'a'</span> and <span class="literal">'b'</span>.</p>&#13;
<p class="indent">Running <a href="ch05.xhtml#ch05list21">Listing 5-21</a> produces</p>&#13;
<pre>a = 3, b = 5&#13;
a = 3, b = 5&#13;
a = 5, b = 3&#13;
a = 3, b = 5</pre>&#13;
<p class="noindent">The first output line shows us the original values of <span class="literal">a</span> and <span class="literal">b</span>. The second output line shows the effect of <span class="ent">➊</span> in <a href="ch05.xhtml#ch05list21">Listing 5-21</a>. There is no effect. The variables are unchanged because we passed their values rather than their names, so the indirection operator failed.</p>&#13;
<p class="indent">The third output line shows the effect of <span class="ent">➋</span>. Now <span class="literal">swap</span> is working. The name operator passed the strings <span class="literal">'a'</span> and <span class="literal">'b'</span>, which the indirection operator can interpret to mean that <span class="literal">a</span> and <span class="literal">b</span> are swapped.</p>&#13;
<p class="indent">The final output line shows the effect of <span class="ent">➌</span>. Here we pass the literal strings naming <span class="literal">a</span> and <span class="literal">b</span>. This is really what the name operator is doing, so <span class="literal">swap</span> works and swaps <span class="literal">a</span> and <span class="literal">b</span> again to restore them to their original values.</p>&#13;
<p class="indent">To sum up, SNOBOL passes simple variables by value, requiring the use of indirection to update them. However, arrays and tables are always passed by reference.</p>&#13;
<p class="indent">We know how to set up SNOBOL programs and how to create custom functions and data types. Now, let’s take a quick look at disk files.</p>&#13;
<h4 class="h4" id="lev2sec43"><strong><em>Input and Output</em></strong></h4>&#13;
<p class="noindent">We’ve seen <span class="literal">input</span> and <span class="literal">output</span> many times already. In this section, we’ll see how they work with disk files.</p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05list22">Listing 5-22</a> presents code to make an uppercase copy of a text file.</p>&#13;
<pre>   * Uppercase a file&#13;
           input('read', 10, 132, host(2,2))&#13;
           output('write', 11, 'W', host(2,3))&#13;
<span class="ent">➊</span> loop    text = read                         :f(close)&#13;
           text = replace(text, &amp;lcase, &amp;ucase)&#13;
        <span class="ent">➋</span> write = text                        :(loop)&#13;
   close   endfile(10)&#13;
           endfile(11)&#13;
   end</pre>&#13;
<p class="caption" id="ch05list22"><em>Listing 5-22: Uppercasing a disk file</em></p>&#13;
<p class="indent">There’s a lot here, so let’s walk through the code line by line. First, open the source text file by supplying arguments to <span class="literal">input</span>. The first argument is <span epub:type="pagebreak" id="page_150"/>not the name of the file. Instead, it’s the name of a variable SNOBOL associates with the file. It’s what we use to read data from the file, so let’s call it <span class="literal">read</span>. The next argument is a unit number. This is a throwback to old-style programming where unit numbers were associated with operating system devices. The unit number needs to be unique for each open file. Use numbers of at least 10 or higher. Think of the unit number as a file reference.</p>&#13;
<p class="indent">After the unit number comes the maximum line length. Input lines longer than this are truncated. Remember, this is a text file, and SNOBOL works with lines of text. The final argument is the name of the disk file. We’re using <span class="literal">host(2,2)</span>, which is specific to our version of SNOBOL. This is a link to the actual operating system. The first argument, <span class="literal">2</span>, refers to command line arguments. The second number refers to items on the command line. The second item is the first argument after the script name. Therefore, <span class="literal">host(2,2)</span> gives us the name of the first file.</p>&#13;
<p class="indent">To open the output file, we use <span class="literal">output</span>. As with <span class="literal">input</span>, the first argument is the name of a variable to which we will assign the output. We use unit <span class="literal">11</span> for output. The third argument is <span class="literal">'W'</span> to write a text file. Use <span class="literal">'A'</span> to append a file. The last argument is the name of the output file, here <span class="literal">host(2,3)</span>, which uses the second argument passed to the SNOBOL program.</p>&#13;
<p class="indent">The files are now open, so let’s read lines from the input, uppercase them, and write them to the output. At <span class="ent">➊</span> we use <span class="literal">read</span>, tied to the input file, to get a line in <span class="literal">text</span>. If the read fails, the input file is exhausted, so we jump to <span class="literal">close</span>. Otherwise, proceed to apply the intrinsic <span class="literal">replace</span> to the text to uppercase the line; <span class="literal">replace</span> updates all occurrences of characters in the second argument by the corresponding character in the third argument. To save typing, we use the predefined strings of lowercase and uppercase letters. SNOBOL variables beginning with <span class="literal">&amp;</span> are system-supplied variables. The output of this line uppercases <span class="literal">text</span>.</p>&#13;
<p class="indent">To dump the text to the output file, assign it to <span class="literal">write</span>, which is the variable associated with the output file <span class="ent">➋</span>. After dumping the newly uppercased text, we jump back to <span class="literal">loop</span> to continue.</p>&#13;
<p class="indent">Lastly, we need to close the input and output files before using <span class="literal">endfile</span> to exit.</p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05list22">Listing 5-22</a> is in the file <em>uppercase.sno</em>. Let’s run it on the <em>Alice’s Adventures in Wonderland</em> text to uppercase it.</p>&#13;
<pre>&gt; <span class="codestrong1">snobol4 uppercase.sno alice.txt uppercase.txt</span></pre>&#13;
<p class="noindent">The file <em>uppercase.txt</em> now contains <span class="literal">ALICE</span> in all caps.</p>&#13;
<p class="indent">The example above worked with a text file. SNOBOL can also work with binary data. Let’s write a simple file copy program to read and write binary data. <a href="ch05.xhtml#ch05list23">Listing 5-23</a> shows <em>copy.sno</em>.</p>&#13;
<pre>*  Copy a file using the command line&#13;
        src = host(2,2)&#13;
        dst = host(2,3)&#13;
        input('read', 10, 'B,4096', src)&#13;
        output('write', 11, 'B', dst)&#13;
<span epub:type="pagebreak" id="page_151"/><span class="ent">➊</span> loop    write = read         :f(close)s(loop)&#13;
   close   endfile(10)&#13;
           endfile(11)&#13;
   end</pre>&#13;
<p class="caption" id="ch05list23"><em>Listing 5-23: Copying a file</em></p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05list23">Listing 5-23</a> is quite similar to <a href="ch05.xhtml#ch05list22">Listing 5-22</a>, but the input and output files are opened in binary mode. For <span class="literal">input</span>, where before we supplied the maximum line length, we now have <span class="literal">'B,4096'</span>. This specifies binary mode, meaning no line endings are interpreted, and a buffer of 4096 bytes. This means the source file will be read in 4096-byte chunks, or fewer if there aren’t at least 4096 bytes left to read. For output, use <span class="literal">'B'</span> to indicate binary mode.</p>&#13;
<p class="indent">The loop, in this case, is a one-liner <span class="ent">➊</span>. Read a 4096-byte chunk of the input and immediately assign it to <span class="literal">write</span> to write it to the output file. When <span class="literal">read</span> fails, jump to close the files. Otherwise, jump back to this same line of code to continue the loop.</p>&#13;
<p class="indent">To test <em>copy.sno</em>, try the following:</p>&#13;
<pre>&gt; <span class="codestrong1">snobol4 copy.sno src.png dst.png</span></pre>&#13;
<p class="noindent">This should copy the given <em>src.png</em> image to <em>dst.png</em>. The image is of a young raccoon and is taken from the open source SciPy toolkit.</p>&#13;
<h3 class="h3" id="lev1sec44"><strong>Machine Learning with SNOBOL</strong></h3>&#13;
<p class="noindent">Let’s work through a little SNOBOL project to implement a simple machine learning classifier. Modern artificial intelligence is far removed from what computer scientists had in mind back when SNOBOL was new. Machine learning existed then, but the term “artificial intelligence” was not used to describe it for the most part.</p>&#13;
<p class="indent"><em>Artificial intelligence</em> now most often refers to that part of machine learning known as deep learning, that is, advanced neural networks, often with millions to billions of connections between the nodes (neurons). SNOBOL is not a good choice for such models. However, classical machine learning includes basic algorithms that are sometimes quite straightforward to implement and that sometimes perform quite well despite their simplicity.</p>&#13;
<p class="indent">Therefore, the goal of this section is to build a complete SNOBOL application to classify datasets using a simple machine learning technique—a <em>nearest neighbor</em> classifier.</p>&#13;
<h4 class="h4" id="lev2sec44"><strong><em>Machine Learning 101</em></strong></h4>&#13;
<p class="noindent">Machine learning maps feature vectors to class labels. A <em>feature vector</em> is a collection of numeric values called <em>features</em>; that’s our input. We take this input and try to assign it a <em>class label</em>, that is, a category or class. For example, one of the datasets we’ll work with relates to iris flowers. This dataset is perhaps the oldest in machine learning and one of the easiest to work with. It consists of 150 measurements of three different species of iris flowers.</p>&#13;
<p class="noindent"><span epub:type="pagebreak" id="page_152"/>There are four measurements per flower: two measuring the petal length and width and two measuring the sepal length in width. These four measurements are the features and the three different species are the classes.</p>&#13;
<p class="indent">Machine learning models must be trained so they can place an unknown sample into the correct class. <em>Training</em> involves learning the parameters of the model using a training set, a collection of feature vectors (<em>x</em>) and corresponding class labels (<em>y</em>). This is what the iris dataset gives us. The training set has 50 examples of each class, that is, each species of flower. We’ll use 100 of these 150 examples to train the classifier and the remaining 50 to test the model to see how well it learned to distinguish between iris species.</p>&#13;
<p class="indent">We hope that when given a set of features for a new flower the trained model will be able to place the new flower into the correct class (in other words, correctly identify the species). The nearest neighbor classifier treats the feature vector as a point in a multidimensional space, in this case a 4D space for the iris dataset, as there are four features per sample. The idea is to find the training set sample whose feature vector is the closest to the feature vector of the unknown input and then assign the unknown input to the training sample class. In this case, closest means the training sample with the smallest <em>distance</em> to the unknown input.</p>&#13;
<p class="indent">There are many concept words in the paragraphs above, so let’s make sure we know what they mean. Once we do, the operation of the classifier will become apparent or even obvious. <a href="ch05.xhtml#ch05tab1">Table 5-1</a> presents a brief machine learning glossary.</p>&#13;
<p class="tabcap" id="ch05tab1"><strong>Table 5-1:</strong> A Brief Machine Learning Glossary</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:40%"/>&#13;
<col style="width:60%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Term</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Meaning</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Feature</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">A measurement or characteristic of the data</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Feature vector</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">A collection of features describing an instance</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Class</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">The label, or group, the instance belongs to</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Model</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">A means for mapping feature vectors to class labels</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Training</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Using known feature vectors to teach the model</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">Distance</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw_bot"><p class="taba">The straight-line distance between two points</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">All machine learning models implement two phases: training and inference. During training, the training set, that is, the collection of feature vectors and their known class labels, is used to adjust the model’s parameters to the task at hand. Once trained, the model can be used for inference to assign class labels to new, unknown feature vectors. For the nearest neighbor classifier, training is so trivial as to be nonexistent: we use the training set as it is, as there are no parameters to learn.</p>&#13;
<p class="indent">To classify feature vectors, we scan through the training set to calculate the distance between the unknown feature vector and each of the training samples to find the closest training sample. We use that training sample’s class label as the class label for the unknown feature vector.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_153"/>For example, if we have a new set of measurements for an iris flower but don’t know its species, the nearest neighbor classifier searches the list of training set feature vectors for the sample closest to the unknown feature vector. It then declares the unknown input to be of the same class.</p>&#13;
<p class="indent">The word <em>distance</em> has been mentioned a few times now. Let’s put a formula to the word, so we have a way to measure the distance between two feature vectors.</p>&#13;
<p class="indent">There are different types of distances, but the one we’ll use here is the <em>Euclidean distance</em>, which is a generalization of the Pythagorean theorem. For example, in 4D, the distance between two points, (<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>, <em>a</em><sub>0</sub>, <em>b</em><sub>0</sub>) and (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>, <em>a</em><sub>1</sub>, <em>b</em><sub>1</sub>), is</p>&#13;
<div class="imagec"><img src="Images/f0153-01.jpg" alt="Image" width="440" height="38"/></div>&#13;
<p class="noindent">If we have 3D feature vectors, the distance between two points, (<em>x</em><sub>0</sub>, <em>y</em><sub>0</sub>, <em>z</em><sub>0</sub>) and (<em>x</em><sub>1</sub>, <em>y</em><sub>1</sub>, <em>z</em><sub>1</sub>), is</p>&#13;
<div class="imagec"><img src="Images/f0153-02.jpg" alt="Image" width="333" height="38"/></div>&#13;
<p class="noindent">For <em>n</em>-dimensional feature vectors, the distance is</p>&#13;
<div class="imagec"><img src="Images/f0153-03.jpg" alt="Image" width="159" height="77"/></div>&#13;
<p class="noindent">for two feature vectors, <em>x</em> and <em>y</em>. In the equation above, <em>i</em> is an index into the components of the vector. When we implement the Euclidean distance in code, <em>i</em> will be an index into an array.</p>&#13;
<p class="indent">The training set and the Euclidean distance are all we need to implement the nearest neighbor classifier, but how will we know if it’s working? For that, we need test data. This is another dataset like the training set, but one that wasn’t used to train the model.</p>&#13;
<p class="indent">We know the feature vectors and the correct class label for the test set. We’ll run each test set feature vector through the model, comparing the classifier’s predicted label with the correct class label. There are many ways to characterize the performance of a machine learning model, but in this case, all we need to measure is the model’s accuracy.</p>&#13;
<div class="imagec"><img src="Images/f0153-04.jpg" alt="Image" width="342" height="50"/></div>&#13;
<p class="noindent">A classifier that randomly guesses class labels will only be correct, on average, one time in <em>c</em>, where <em>c</em> is the number of classes in the dataset. There are three classes for the iris flowers, so we’d expect, if guessing, to be correct one time out of three, or about 33 percent of the time, meaning the accuracy is 0.3333. A perfect classifier makes no mistakes and has an accuracy of 1.0 or 100 percent.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_154"/>We now have enough background to get started. We have a model and we know how to train it and test it. Let’s write some code.</p>&#13;
<h4 class="h4" id="lev2sec45"><strong><em>Implementing the Classifier</em></strong></h4>&#13;
<p class="noindent">Let’s implement the classifier. Here’s our plan of attack:</p>&#13;
<ol>&#13;
<li class="noindent">Load the training and test datasets into SNOBOL arrays.</li>&#13;
<li class="noindent">For each test sample, assign the class label of the closest training  set sample.</li>&#13;
<li class="noindent">Compare the assigned labels to the known test labels.</li>&#13;
<li class="noindent">Report the classifier’s accuracy.</li>&#13;
</ol>&#13;
<p class="noindent">The code that follows is in the file <em>classify.sno</em>.</p>&#13;
<h5 class="h5" id="lev3sec23"><strong>Loading the Data</strong></h5>&#13;
<p class="noindent">This book’s GitHub site contains several datasets. Let’s walk through an example using the iris dataset. We’ll classify the others later.</p>&#13;
<p class="indent">The iris dataset is in four text files in the <em>datasets</em> directory:</p>&#13;
<pre>iris_train_data.txt&#13;
iris_train_labels.txt&#13;
iris_test_data.txt&#13;
iris_test_labels.txt</pre>&#13;
<p class="indent">The first two contain training data and the associated class labels. The second two hold test data.</p>&#13;
<p class="indent">For example, the training datafile begins with</p>&#13;
<pre>6.70000 3.00000 5.00000 1.70000&#13;
5.10000 3.50000 1.40000 0.30000&#13;
4.80000 3.40000 1.60000 0.20000&#13;
6.10000 2.80000 4.70000 1.20000&#13;
6.00000 3.40000 4.50000 1.60000</pre>&#13;
<p class="noindent">with the associated class labels</p>&#13;
<pre>1&#13;
0&#13;
0&#13;
1&#13;
1</pre>&#13;
<p class="noindent">meaning the first feature vector is a class 1 instance, whereas the second feature vector is an instance of class 0, and so on. The test dataset files are structured similarly.</p>&#13;
<p class="indent">We need SNOBOL code to load these text files. We’ll develop generic code, a SNOBOL function to load any datafile arranged such that each row represents a sample and each column represents a feature. Most machine learning datasets are structured this way.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_155"/>The iris training data results in a 2D array with 100 rows and four columns because there are four features per sample and 100 samples in the training set. The training labels will become a 2D array as well, with 100 rows and one column. This simplifies the implementation.</p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05list24">Listing 5-24</a> shows a function to load datafiles. It’s the most complex piece of code we need to develop, so it’s best to start with the worst, knowing that things will get easier later.</p>&#13;
<pre>       <span class="ent">➊</span> define('loadfile(name)pat,r,text,c,v')    :(eloadfile)&#13;
loadfile  input('reader', 10, , name)&#13;
       <span class="ent">➋</span> pat = break(' ') . v span(' ')&#13;
          r = 0&#13;
load_l02  text = reader ' '                         :f(load_l00)&#13;
          c = 0&#13;
load_l03  text pat =                                :f(load_l01)&#13;
          c = c + 1                                 :(load_l03)&#13;
load_l01  r = r + 1                                 :(load_l02)&#13;
load_l00  endfile(10)&#13;
       <span class="ent">➌</span> loadfile = array(r ',' c)&#13;
          input('reader', 10, , name)&#13;
          r = 1&#13;
load_l07  text = reader ' '                         :f(load_l04)&#13;
          c = 1&#13;
load_l06  text pat =                                :f(load_l05)&#13;
       <span class="ent">➍</span> loadfile[r,c] = 1.0 * v&#13;
          c = c + 1                                 :(load_l06)&#13;
load_l05  r = r + 1                                 :(load_l07)&#13;
load_l04  endfile(10)                               :(return)&#13;
eloadfile</pre>&#13;
<p class="caption" id="ch05list24"><em>Listing 5-24: Loading a datafile</em></p>&#13;
<p class="indent">The function accepts the name of the text file to load <span class="ent">➊</span>. Notice the list of local variables. This prevents hard-to-detect errors whereby the function might alter a global variable. The function itself consists of two loops. The first loop, from label <span class="literal">loadfile</span> through label <span class="literal">load_l00</span>, reads a line of text from the input file and parses it to count the number of features per sample. When the program reaches label <span class="literal">load_l00</span>, the number of rows in the file is in <span class="literal">r</span> and the number of columns is in <span class="literal">c</span>.</p>&#13;
<p class="indent">To extract a number from the current line, we do two things. First, we add a blank space to the input line (see label <span class="literal">load_l02</span>). Next, we perform a pattern match and update (see label <span class="literal">load_l03</span>). The pattern <span class="ent">➋</span> uses <span class="literal">break</span> to match all text up to the first blank, storing it in <span class="literal">v</span>, and then matches any number of blanks with <span class="literal">span</span>. The net effect of <span class="literal">pat</span> is to grab the text representing a feature value and end with the cursor at the beginning of the next feature. Label <span class="literal">load_l03</span> assigns nothing to the matched text, thereby removing it from <span class="literal">text</span>. This process repeats, with <span class="literal">c</span> incremented until the line is empty and the match fails to cause a jump to label <span class="literal">load_l01</span> to increment <span epub:type="pagebreak" id="page_156"/><span class="literal">r</span> and advance to the next line of the input file. When the input file is exhausted, control moves to label <span class="literal">load_l00</span> to close the file.</p>&#13;
<p class="indent">The purpose of the first loop is to learn the file’s dimensionality; it’s in <span class="literal">r</span> and <span class="literal">c</span>. The return value of the function is defined as an array of the appropriate size <span class="ent">➌</span>.</p>&#13;
<p class="indent">The input file is opened a second time, and the same read process happens again. This time, each matched feature value in <span class="literal">v</span> is placed into the array as a floating-point number <span class="ent">➍</span>. When the input file is again empty, the function returns.</p>&#13;
<h5 class="h5" id="lev3sec24"><strong>Calculating the Distance</strong></h5>&#13;
<p class="noindent">Classifying an unknown sample requires computing the distance between pairs of feature vectors. The code to do this is in <span class="literal">dist</span>. See <a href="ch05.xhtml#ch05list25">Listing 5-25</a>.</p>&#13;
<pre>          define('dist(x,y,i,j)sum,k')          :(edist)&#13;
dist      k = 1&#13;
dist_l00  sum = sum + (x[i,k] - y[j,k]) ** 2    :f(dist_l01)&#13;
          k = k + 1                             :(dist_l00)&#13;
dist_l01  dist = sqrt(sum)                      :(return)&#13;
edist</pre>&#13;
<p class="caption" id="ch05list25"><em>Listing 5-25: Calculating the Euclidean distance</em></p>&#13;
<p class="indent">The arguments to <span class="literal">dist</span> are the two datasets, <span class="literal">x</span> and <span class="literal">y</span>, which are 2D, and the rows to work with, <span class="literal">i</span> and <span class="literal">j</span>. The distance is the sum of the differences of each feature for the given rows. These are the columns of the arrays that we index with <span class="literal">k</span>.</p>&#13;
<p class="indent">The label <span class="literal">dist_l00</span> does all the work. It adds the square of the difference between the <em>k</em>th columns of <span class="literal">x</span> and <span class="literal">y</span> for the given rows to the existing sum. The loop fails when <span class="literal">k</span> exceeds the array’s bounds. The return value is the square root of this sum (the label <span class="literal">dist_l01</span>).</p>&#13;
<p class="indent">Some readers might be a bit confused by <a href="ch05.xhtml#ch05list25">Listing 5-25</a>, as <span class="literal">sum</span> is updated without being initialized. There is no error. SNOBOL treats undefined variables as null and adding a number to null returns the number, so there is no need to initialize <span class="literal">sum</span> explicitly.</p>&#13;
<h5 class="h5" id="lev3sec25"><strong>Finding the Nearest Training Sample</strong></h5>&#13;
<p class="noindent">We need to find the training sample that is closest to a given test sample. For that, we use the function <span class="literal">nearest</span>. See <a href="ch05.xhtml#ch05list26">Listing 5-26</a>.</p>&#13;
<pre>          define('samples(a)pat')                 :(esamples)&#13;
samples   pat = break(',') . samples&#13;
          prototype(a) pat                        :(return)&#13;
esamples&#13;
&#13;
          define('nearest(xtrn,ytrn,xtst,ytst,idx)s,i,mc,md,d')  :(enearest)<span epub:type="pagebreak" id="page_157"/>&#13;
nearest   i = 1&#13;
          s = samples(xtrn)&#13;
          nearest = ytrn[i,1]&#13;
          md = dist(xtrn, xtst, i, idx)&#13;
near_l01  i = i + 1&#13;
          le(i,s)                                 :f(return)&#13;
          d = dist(xtrn, xtst, i, idx)&#13;
          lt(d,md)                                :f(near_l01)&#13;
          nearest = ytrn[i,1]&#13;
          md = d                                  :(near_l01)&#13;
enearest</pre>&#13;
<p class="caption" id="ch05list26"><em>Listing 5-26: Finding the nearest training sample</em></p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05list26">Listing 5-26</a> actually defines two functions, <span class="literal">nearest</span> and <span class="literal">samples</span> (which is used by <span class="literal">nearest</span>). Let’s start with <span class="literal">samples</span>. It returns the number of rows in a 2D array. Given how we organize the data, that’s a sample, a feature vector.</p>&#13;
<p class="indent">The <span class="literal">samples</span> function defines a pattern (<span class="literal">pat</span>), matching text up to the first comma and storing it in the function name (<span class="literal">samples</span>). It then applies this pattern to whatever is returned by the SNOBOL <span class="literal">prototype</span> function. This function returns a string specifying the dimensionality of an array. Recall that arrays are declared using a string to specify the number and size of the dimensions. Our arrays are 2D, so <span class="literal">prototype</span> returns a string like <span class="literal">'100,4'</span>. The pattern extracts the first number. We won’t use it, but <em>classify.sno</em> also defines <span class="literal">features</span>, which is a function to return the number of features, the second number returned by <span class="literal">prototype</span>. Do take a look.</p>&#13;
<p class="indent">The algorithm for <span class="literal">nearest</span> scans through the training data, calculating the distance between the current training sample and the specified test sample. If that distance is smaller than the smallest found so far, it keeps track of the distance and the training sample’s class label. When the algorithm completes its pass through the training data, it returns the class label of the smallest distance; <span class="literal">nearest</span> classifies a given test set sample.</p>&#13;
<p class="indent">The long list of parameters to <span class="literal">nearest</span> passes the training set, both data (<span class="literal">xtrn</span>) and labels (<span class="literal">ytrn</span>), along with the test set data and labels, and <span class="literal">idx</span>, which is the current test set sample to classify.</p>&#13;
<p class="indent">The loop over the training set tracks <span class="literal">md</span>, which is the smallest distance found so far, storing the associated class label in <span class="literal">nearest</span>, the function value. The loop ends when <span class="literal">le(i,s)</span> fails where <span class="literal">i</span> is the row index and <span class="literal">s</span> is the number of samples in the training set. If <span class="literal">lt(d,md)</span> succeeds, the algorithm updates <span class="literal">md</span> and <span class="literal">nearest</span>.</p>&#13;
<h5 class="h5" id="lev3sec26"><strong>The Main Code</strong></h5>&#13;
<p class="noindent">The sections above describe the functions implementing each phase of the classification task. The main code, at the bottom of <em>classify.sno</em>, pulls these pieces together (see <a href="ch05.xhtml#ch05list27">Listing 5-27</a>).<span epub:type="pagebreak" id="page_158"/></p>&#13;
<pre>*  Train and test datasets&#13;
        x_train = loadfile(host(2,2))&#13;
        y_train = loadfile(host(2,3))&#13;
        x_test = loadfile(host(2,4))&#13;
        y_test = loadfile(host(2,5))&#13;
&#13;
*  Run the test data against the training to find the nearest neighbor&#13;
        i = 1; nc = 0; n = samples(x_test)&#13;
loop    le(i,n)                                     :f(stats)&#13;
        c = nearest(x_train, y_train, x_test, y_test, i)&#13;
     <span class="ent">➊</span> nc = eq(c, y_test[i,1]) nc + 1&#13;
        star = &#13;
        star = ne(c, y_test[i,1]) ' **'&#13;
        output = "test " i ": assigned " c ", actual " y_test[i,1] star&#13;
        i = i + 1                                   :(loop)&#13;
stats   output =&#13;
        output = 'accuracy ' (nc / (1.0 * n)) ' (' nc ' out of ' n ' correct)'&#13;
        output =&#13;
end</pre>&#13;
<p class="caption" id="ch05list27"><em>Listing 5-27: Putting the classifier together</em></p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05list27">Listing 5-27</a> first loads the training and test data. The feature vectors are in <span class="literal">x_train</span> and <span class="literal">x_test</span>, respectively. The associated class labels are in <span class="literal">y_train</span> and <span class="literal">y_test</span>. The filenames are passed on the command line, after <em>classify.sno</em>, with the training data and labels first, followed by test data and labels.</p>&#13;
<p class="indent">The following code is a loop that runs through each test sample. The call to <span class="literal">nearest</span> returns the assigned class label for test sample <span class="literal">i</span>. If the classification is correct, it increments the number correct counter, <span class="literal">nc</span> <span class="ent">➊</span>. Note that the SNOBOL construct of using the <span class="literal">eq</span> predicate in the same update statement. If the classification is wrong, <span class="literal">eq</span> fails, and the rest of the statement is skipped. There is no failure label, so execution continues with the next line. When all test samples have been classified, the overall accuracy is displayed before exiting.</p>&#13;
<p class="indent">The implementation is complete. Now the million-dollar question: does it work? Let’s see.</p>&#13;
<h4 class="h4" id="lev2sec46"><strong><em>Using the Classifier</em></strong></h4>&#13;
<p class="noindent">Let’s run <em>classify.sno</em> against the examples in the <em>datasets</em> directory. These datasets can be found on the UCI Machine Learning Repository website (<em><a href="https://archive.ics.uci.edu/ml/index.php">https://archive.ics.uci.edu/ml/index.php</a></em>). I downloaded the datasets and processed them to be in the form expected by <em>classify.sno</em>. The full dataset was randomly partitioned into training and test datasets using an 80/20 split. Feature vectors are in the “data” files, with the class labels, matching line for line, in the “labels” files.</p>&#13;
<p class="indent">The available datasets include those shown in <a href="ch05.xhtml#ch05tab2">Table 5-2</a>.<span epub:type="pagebreak" id="page_159"/></p>&#13;
<p class="tabcap" id="ch05tab2"><strong>Table 5-2:</strong> Available Datasets</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:25%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:15%"/>&#13;
<col style="width:45%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Dataset</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Features</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Classes</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Description</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">banknote</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">4</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">2</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Real or counterfeit notes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">cancer</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">10</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">2</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Breast cancer histology slide features</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">ecoli</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">7</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">8</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Characterizing <em>E. coli</em> bacteria</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">haberman</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">3</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">2</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Five year breast cancer survival</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">iris</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">4</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">3</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">Types of irises</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">seeds</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">7</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">3</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">Types of seeds</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba">wine</p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba">13</p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba">3</p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba">Wine origin</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">Let start with the irises. To run the classifier, use the following command line:</p>&#13;
<pre>&gt; <span class="codestrong1">snobol4 classify.sno iris_train_data.txt iris_train_labels.txt&#13;
             iris_test_data.txt iris_test_labels.txt</span></pre>&#13;
<p class="indent">The output begins with</p>&#13;
<pre>test 1: assigned 0., actual 0.&#13;
test 2: assigned 0., actual 0.      &#13;
test 3: assigned 1., actual 1.&#13;
test 4: assigned 2., actual 2.                                                   &#13;
test 5: assigned 1., actual 1.&#13;
test 6: assigned 2., actual 2.&#13;
test 7: assigned 0., actual 0.&#13;
test 8: assigned 1., actual 1.&#13;
test 9: assigned 2., actual 2.</pre>&#13;
<p class="noindent">and ends with</p>&#13;
<pre>test 45: assigned 1., actual 1.&#13;
test 46: assigned 1., actual 2. **&#13;
test 47: assigned 1., actual 1.&#13;
test 48: assigned 0., actual 0.&#13;
test 49: assigned 1., actual 1.&#13;
test 50: assigned 2., actual 2.&#13;
&#13;
accuracy 0.96 (48 out of 50 correct)</pre>&#13;
<p class="noindent">There are 50 test samples and the assigned and actual class labels are displayed for each sample. If the classifier made a mistake, the output is followed by <span class="literal">**</span> to mark it.</p>&#13;
<p class="indent">The overall accuracy was 96 percent, with only two mistakes. For such a simple classifier, this is not too shabby. Note that both errors were confusing between class 1 and class 2. For the iris dataset, class 0 is easily distinguished <span epub:type="pagebreak" id="page_160"/>from the other two, but class 1 and class 2 are relatively similar, so they are more likely to be confused.</p>&#13;
<p class="indent">Run the other example datasets in the same way. <a href="ch05.xhtml#ch05tab3">Table 5-3</a> shows the statistics, including the accuracy, number correctly classified, number tested, and the size of the training set.</p>&#13;
<p class="tabcap" id="ch05tab3"><strong>Table 5-3:</strong> Nearest Neighbor Classifier Accuracies by Dataset</p>&#13;
<table class="all">&#13;
<colgroup>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
<col style="width:20%"/>&#13;
</colgroup>&#13;
<thead>&#13;
<tr>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Dataset</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Accuracy (%)</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Correct</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Test</strong></p></th>&#13;
<th style="vertical-align: top;" class="table-h"><p class="taba"><strong>Train</strong></p></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">banknote</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">100.0</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">275</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">275</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">1097</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">cancer</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">94.2</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">129</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">137</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">546</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">ecoli</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">86.8</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">59</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">68</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">268</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">haberman</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">67.2</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">41</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">61</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">245</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">iris</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">96.0</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">48</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">50</p></td>&#13;
<td style="vertical-align: top;" class="table-1b"><p class="taba">100</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">seeds</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">92.9</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">39</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">42</p></td>&#13;
<td style="vertical-align: top;" class="table-1bw"><p class="taba">168</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba">wine</p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba">83.3</p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba">30</p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba">36</p></td>&#13;
<td style="vertical-align: top;" class="table-1b_bot"><p class="taba">142</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">The results range from perfection (banknotes) to a low of 67 percent (haberman). However, all things considered, this simple classifier performed quite well on these datasets.</p>&#13;
<p class="indent">There is another name for the nearest neighbor classifier: 1-nearest neighbor, where the <em>1</em> means only the nearest training sample is considered. This classifier can be generalized to consider the <em>k</em>-nearest neighbors where <em>k</em> &gt; 1 and is odd. For a <em>k</em>-nearest neighbor classifier, the <em>k</em>-nearest neighbors are located. The assigned class is the result of voting among the <em>k</em>-nearest neighbors. In the event of a tie, select one of the neighbors at random. Although nearest neighbor classifiers are seldom used, <em>k</em>-nearest neighbor classifiers are still an active research area in machine learning. I leave it as an exercise for the reader to convert <em>classify.sno</em> into a <em>k</em>-nearest neighbor classifier.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>The world of machine learning offers much more than the tiny bit we’ve explored here. Witness the rapidly expanding world of deep learning, which has already greatly affected our daily lives and will continue to do so for years to come. If your interest has been piqued, please take a look at my deep learning books</em> Practical Deep Learning: A Python-Based Introduction (2021) <em>and</em> Math for Deep Learning: What You Need to Know to Understand Neural Networks <em>(2021). Both are available from No Starch Press.</em></p>&#13;
</div>&#13;
<h3 class="h3" id="lev1sec45"><strong>Discussion</strong></h3>&#13;
<p class="noindent">What should we make of SNOBOL? I’ll admit, I like the language. The flexibility of its arrays and the table data structure are surprisingly “modern.” I also like its pattern-matching abilities, dynamic data typing, and automatic memory management.</p>&#13;
<p class="indent">But SNOBOL’s complete lack of structured programming abilities hurts. The only way to directly control program flow is with a goto. There are no structured control statements like <span class="literal">for</span> or <span class="literal">while</span>.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_161"/>Forth gets a bad rap for being a write-only programming language, but Forth uses structured programming, which is not even an option in SNOBOL. Using the success or failure of a statement as an essential element of program flow control is novel and intellectually engaging, but it ultimately makes working with the language difficult. However, I suspect much of that difficulty would fade with practice. The fact that SNOBOL labels are global is especially painful. Even some assemblers for old 8-bit microprocessors support local labels, something that would greatly benefit SNOBOL.</p>&#13;
<p class="indent">Historically, SNOBOL had a reputation for being slow. Thus, a simple timing test comparing SNOBOL and Python seems in order.</p>&#13;
<p class="indent"><a href="ch05.xhtml#ch05list28">Listing 5-28</a> shows two equivalent programs to initialize a 1,000,000-element array/list 20 times, first in Python and then in SNOBOL.</p>&#13;
<pre>Python:&#13;
       a = [0]*1000000&#13;
       for k in range(20):&#13;
           for i in range(1000000):&#13;
               a[i] = i&#13;
&#13;
SNOBOL:&#13;
        a = array(1000000)&#13;
        k = 1&#13;
loop0   i = 1&#13;
loop1   a[i] = i                :f(break1)&#13;
        i = i + 1               :(loop1)&#13;
break1  k = le(k,20) k + 1      :s(loop0)&#13;
end</pre>&#13;
<p class="caption" id="ch05list28"><em>Listing 5-28: Comparing SNOBOL and Python</em></p>&#13;
<p class="indent">The median runtime on my machine over 10 runs each is 2.363 seconds for Python and 3.548 seconds for SNOBOL. So yes, SNOBOL is slower, but not dramatically so. Note that to run the SNOBOL code, use <span class="codestrong">-d 1m</span> on the command line to reserve enough memory for the array.</p>&#13;
<p class="indent">In what ways does SNOBOL help us expand our conception of what it means to code? Several come to mind. SNOBOL uses global labels and is unstructured. This requires programmers to think clearly about the <em>entire</em> scope of the project, or at least to implement a disciplined approach to coding, one that is not enforced by the language itself as in other, newer programming languages. Without a global conception of the program, label confusion or spaghetti code is inevitable. Thus, clarity of thought is essential.</p>&#13;
<p class="indent">SNOBOL’s robust pattern matching and string update abilities enable a novel approach to string manipulation. As a result, some of the burden incumbent on the programmer regarding string manipulation in languages like C++, Python, or Java is alleviated. This means thinking in terms of strings and their evolution becomes a new paradigm for implementing algorithms.</p>&#13;
<p class="indent">Lastly, SNOBOL requires thinking in terms of statement success <em>and</em> statement failure. Typically, coding is for success, as we don’t want failures <span epub:type="pagebreak" id="page_162"/>to happen. Error control in SNOBOL is fine grained, which is both helpful and perhaps a bit dangerous.</p>&#13;
<p class="indent">All in all, SNOBOL is a surprisingly “modern” programming language. In many ways, it was well ahead of its time. SNOBOL itself evolved into Icon, also by Griswold, which uses structured programming constructs. Icon never caught on, but readers who are so inclined can learn more at <em><a href="https://www2.cs.arizona.edu/icon/">https://www2.cs.arizona.edu/icon/</a></em>. Regardless, SNOBOL is worth a bit of continued effort on our part. Indeed, we’ll see SNOBOL again in <a href="ch10.xhtml#ch10">Chapter 10</a> when we use it to implement Brainfuck.</p>&#13;
<h3 class="h3" id="lev1sec46"><strong>Summary</strong></h3>&#13;
<p class="noindent">This chapter introduced us to SNOBOL, a quirky pattern matching programming language from the 1960s. We worked through the language from its overall structure to specifics of its key features, with numerous examples. We learned about its unique approach to flow control and saw a tiny portion of its powerful text pattern matching abilities.</p>&#13;
<p class="indent">We implemented a simple machine learning classifier in SNOBOL as an exercise and saw that it performed well against some small-scale machine learning datasets.</p>&#13;
<p class="indent">We ended the chapter by discussing the language, what we liked about it, and what we were less enthused about. Our ultimate conclusion was that SNOBOL well deserves of a place at our table as a novel language that can help us learn to think differently about coding.</p>&#13;
<p class="indent">Let’s leave SNOBOL, with its successes and failures, and jump forward to the latter Mesozoic so we can experience the awe and mystery of CLIPS, a language designed for expert system development.</p>&#13;
</div></body></html>