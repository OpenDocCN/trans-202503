<html><head></head><body>
<h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_35"/><strong><span class="big">4</span></strong><br/><strong>IDENTIFYING ATTACK CAMPAIGNS USING MALWARE NETWORKS</strong></h2>
<div class="image1"><img alt="image" src="../images/common01.jpg"/></div>
<p class="noindent"><em>Malware network analysis</em> can turn malware datasets into valuable threat intelligence, revealing adversarial attack campaigns, common malware tactics, and sources of malware samples. This approach consists of analyzing the ways in which groups of malware samples are connected by their shared attributes, whether those are embedded IP addresses, hostnames, strings of printable characters, graphics, or similar.</p>
<p class="indent">For example, <a href="ch04.xhtml#ch04fig1">Figure 4-1</a> shows an example of the power of malware network analysis in a chart that took only seconds to generate with the techniques you’ll learn in this chapter.</p>
<div class="image"><span epub:type="pagebreak" id="page_36"/><a id="ch04fig1"/><img alt="image" src="../images/f0036-01.jpg"/></div>
<p class="figcap"><em>Figure 4-1: Nation-state malware's social network connections revealed via shared attribute analysis</em></p>
<p class="indent">The figure displays a group of nation state–grade malware samples (represented as oval-shaped nodes) and their “social” interconnections (the lines connecting the nodes). The connections are based on the fact that these samples “call back” to the same hostnames and IP addresses, indicating they were deployed by the same attackers. As you’ll learn in this chapter, you can use these connections to help differentiate between a coordinated attack on your organization and a disparate array of criminally motivated attackers.</p>
<p class="indent">By the end of the chapter you will have learned:</p>
<ul>
<li class="noindent">The fundamentals of network analysis theory as it relates to extracting threat intelligence from malware</li>
<li class="noindent">Ways to use visualizations to identify relationships between malware samples</li>
<li class="noindent">How to create, visualize, and extract intelligence from malware networks using Python and various open source toolkits for data analysis and visualization</li>
<li class="noindent">How to tie all this knowledge together to reveal and analyze attack campaigns within real-world malware datasets</li>
</ul>
<h3 class="h3" id="lev50"><span epub:type="pagebreak" id="page_37"/><strong>Nodes and Edges</strong></h3>
<p class="noindent">Before you can perform shared attribute analysis on malware, you need to understand some basics about networks. <em>Networks</em> are collections of connected objects (called <em>nodes</em>). The connections between these nodes are referred to as <em>edges</em>. As abstract mathematical objects, the nodes in a network can represent pretty much anything, as can their edges. What we care about for our purposes is the structure of the interconnections between these nodes and edges, as this can reveal telling details about malware.</p>
<p class="indent">When using networks to analyze malware, we can treat each individual malware file as the definition of a node, and we can treat relationships of interest (such as shared code or network behavior) as the definition of an edge. Similar malware files share edges and thus cluster together when we apply force-directed networks (you will see exactly how this works later). Alternatively, we can treat both malware samples and attributes as nodes unto themselves. For example, callback IP addresses have nodes, and so do malware samples. Whenever malware samples call back to a particular IP address, they are connected to that IP address node.</p>
<p class="indent">Networks of malware can be more complex than simply a set of nodes and edges. Specifically, they can have <em>attributes</em> attached to either nodes or edges, such as the percentage of code that two connected samples share. One common edge attribute is a <em>weight</em>, with greater weights indicating stronger connections between samples. Nodes may have their own attributes, such as the file size of the malware samples they represent, but these are typically referred to only as attributes.</p>
<h3 class="h3" id="lev51"><strong>Bipartite Networks</strong></h3>
<p class="noindent">A <em>bipartite network</em> is one whose nodes can be divided into two partitions (groups), where neither partition contains internal connections. Networks of this type can be used to show shared attributes between malware samples.</p>
<p class="indent"><a href="ch04.xhtml#ch04fig2">Figure 4-2</a> shows an example of a bipartite network in which malware sample nodes go in the bottom partition, and domain names the samples “call back” to (in order to communicate with the attacker) go in the other partition. Note that callbacks never connect directly to other callbacks, and malware samples never connect directly to other malware samples, as is characteristic of a bipartite network.</p>
<p class="indent">As you can see, even such a simple visualization reveals an important piece of intelligence: based on the malware samples’ shared callback servers, we can guess that <em>sample_014</em> was probably deployed by the same attacker as <em>sample_37D</em>. We can also guess that <em>sample_37D</em> and <em>sample_F7F</em> probably share the same attacker, and that <em>sample_014</em> and <em>sample_F7F</em> probably share the same attacker, because they’re connected by sample <em>sample_37D</em> (and indeed, the samples shown in <a href="ch04.xhtml#ch04fig2">Figure 4-2</a> all come from the same “APT1” Chinese attacker group).</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>We’d like to thank Mandiant and Mila Parkour for curating the APT1 samples and making them available to the research community.</em></p>
</div>
<div class="image"><span epub:type="pagebreak" id="page_38"/><a id="ch04fig2"/><img alt="image" src="../images/f0038-01.jpg"/></div>
<p class="figcap"><em>Figure 4-2: A bipartite network. The nodes on top (the attributed partition) are callback domain names. The nodes on the bottom (malware partition) are malware samples.</em></p>
<p class="indent">As the number of nodes and connections in our network grow very large, we might want to see just how the malware samples are related, without having to closely inspect all the attribute connections. We can examine malware sample similarity by creating a bipartite network <em>projection</em>, which is a simpler version of a bipartite network in which we link nodes in one partition of the network if they have nodes in the other partition (the <em>attribute</em> partition) in common. For example, in the case of the malware samples shown in <a href="ch04.xhtml#ch04fig1">Figure 4-1</a>, we’d be creating a network in which malware samples are linked if they share callback domain names.</p>
<p class="indent"><a href="ch04.xhtml#ch04fig3">Figure 4-3</a> shows the projected network of the shared-callback servers of the entire Chinese APT1 dataset referred to previously.</p>
<div class="image"><a id="ch04fig3"/><img alt="image" src="../images/f0038-02.jpg"/></div>
<p class="figcap"><em>Figure 4-3: A projection of malware samples from the APT1 dataset, showing connections between malware samples only if they share at least one server. The two big clusters were used in two different attack campaigns.</em></p>
<p class="indent"><span epub:type="pagebreak" id="page_39"/>The nodes here are malware samples, and they are linked if they share at least one callback server. By showing connections between malware samples only if they share callback servers, we can begin to see the overall “social network” of these malware samples. As you can see in <a href="ch04.xhtml#ch04fig3">Figure 4-3</a>, two large groupings exist (the large square cluster in the left-center area and the circular cluster in the top-right area), which upon further inspection turn out to correspond to two different campaigns carried out over the APT1 group’s 10-year history.</p>
<h3 class="h3" id="lev52"><strong>Visualizing Malware Networks</strong></h3>
<p class="noindent">As you perform shared attribute analysis of malware using networks, you’ll find that you rely heavily on network visualization software to create the networks like the ones shown thus far. This section introduces how these network visualizations can be created from an algorithmic perspective.</p>
<p class="indent">Crucially, the major challenge in doing network visualization is <em>network layout</em>, which is the process of deciding where to render each node in a network within a two- or three-dimensional coordinate space, depending on whether you want your visualization to be two- or three-dimensional. When you’re placing nodes on a network, the ideal way is to place them in the coordinate space such that their visual distance from one another is proportional to the shortest-path distance between them in the network. In other words, nodes that are two hops away from one another might be about two inches away from one another, and nodes that are three hops away might be about three inches apart. Doing this allows us to visualize clusters of similar nodes accurately to their actual relationship. As you’ll see in the next section, however, this is often difficult to achieve, especially when you’re working with more than three nodes.</p>
<h4 class="h4" id="lev53"><strong><em>The Distortion Problem</em></strong></h4>
<p class="noindent">As it turns out, it’s often impossible to solve this network layout problem perfectly. <a href="ch04.xhtml#ch04fig4">Figure 4-4</a> illustrates this difficulty.</p>
<p class="indent">As you can see in these simple networks, all nodes are connected to all other nodes by edges of equal weights of 1. The ideal layout for these connections would place all nodes equidistant from one another on the page. But as you can see, as we create networks of four and then five nodes, as in (c) and (d), we start to introduce progressively more distortion due to edges of unequal length. Unfortunately, we can only minimize, not eliminate this distortion, and that minimization becomes one of the major goals of network visualization algorithms.</p>
<div class="image"><span epub:type="pagebreak" id="page_40"/><a id="ch04fig4"/><img alt="image" src="../images/f0040-01.jpg"/></div>
<p class="figcap"><em>Figure 4-4: Perfect network layout is usually impossible on real-world malware networks. Simple cases like (a) and (b) allow us to lay out all nodes equidistantly. However, (c) adds distortion (the edges are no longer all equal length), and (d) shows even more distortion.</em></p>
<h4 class="h4" id="lev54"><strong><em>Force-Directed Algorithms</em></strong></h4>
<p class="noindent">To best minimize layout distortion, computer scientists often use <em>force-directed</em> layout algorithms. Force-directed algorithms are based on physical simulations of spring-like forces as well as magnetism. Simulating network edges as physical springs often leads to good node positioning, because the simulated springs push and pull to try to achieve uniform length between nodes and edges. To better visualize this concept, consider how a spring works: when you compress or stretch the spring, it “tries” to get back to its length at equilibrium. These properties correlate well with our desire to have all the edges of our network be equal length. Force-directed algorithms are what we focus on in this chapter.</p>
<h3 class="h3" id="lev55"><strong>Building Networks with NetworkX</strong></h3>
<p class="noindent">Now that you have a basic understanding of malware networks, you’re ready to learn how to create networks of malware relationships using the open source NetworkX Python network analysis library and the GraphViz open <span epub:type="pagebreak" id="page_41"/>source network visualization toolkit. I show you how to programmatically extract malware-related data and then use this data to build, visualize, and analyze networks to represent malware datasets.</p>
<p class="indent">Let’s begin with NetworkX, which is an open source project maintained by a team centered at Los Alamos National Laboratory and Python’s de facto network-processing library (recall that you can install the library dependencies in this chapter, including NetworkX, by entering this chapter’s code and data directory and the command <code>pip install -r requirements.txt</code>). If you know Python, you should find NetworkX to be surprisingly easy. Use the code in <a href="ch04.xhtml#ch04list1">Listing 4-1</a> to import NetworkX and instantiate a network.</p>
<pre>#<span class="codestrong1">!/usr/bin/python</span><br/>import networkx<br/><br/># instantiate a network with no nodes and no edges.<br/>network = networkx.Graph()</pre>
<p class="listing" id="ch04list1"><em>Listing 4-1: Instantiating a network</em></p>
<p class="indent">This code uses just one function call to the NetworkX <code>Graph</code> constructor to create a network in NetworkX.</p>
<div class="note">
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>
<p class="notep"><em>The NetworkX library uses the term</em> graph <em>in place of</em> network <em>sometimes, as the two terms are synonymous in computer science—they both indicate a set of nodes connected by edges.</em></p>
</div>
<h3 class="h3" id="lev56"><strong>Adding Nodes and Edges</strong></h3>
<p class="noindent">Now that we’ve instantiated a network, let’s add some nodes. A node in a NetworkX network can be any Python object. Here I show you how to add nodes of various types to our network:</p>
<pre>nodes = ["hello","world",1,2,3]<br/>for node in nodes:<br/>    network.add_node(node)</pre>
<p class="indent">As shown, we’ve added five nodes to our network: <code>"hello"</code>, <code>"world"</code>, <code>1</code>, <code>2</code>, and <code>3</code>.</p>
<p class="indent">Then, to add edges, we call <code>add_edge()</code>, as shown next:</p>
<pre><span class="ent">➊</span> network.add_edge("hello","world")<br/>   network.add_edge(1,2)<br/>   network.add_edge(1,3)</pre>
<p class="indent">Here, we’re connecting some of these five nodes via edges. For example, the first line of code <span class="ent">➊</span> connects the <code>"hello"</code> and <code>"world"</code> nodes together by creating an edge between them.</p>
<h4 class="h4" id="lev57"><span epub:type="pagebreak" id="page_42"/><strong><em>Adding Attributes</em></strong></h4>
<p class="noindent">NetworkX allows us to easily attach attributes to both nodes and edges. To attach an attribute to a node (and to access that attribute later), you can add the attribute as a keyword argument when you add the node to the network, like this:</p>
<pre>network.add_node(1,myattribute="foo")</pre>
<p class="indent">To add an attribute later, access the network’s <code>node</code> dictionary using the following syntax:</p>
<pre>network.node[1]["myattribute"] = "foo"</pre>
<p class="indent">Then, to access the node, access the <code>node</code> dictionary:</p>
<pre>print network.node[1]["myattribute"] # prints "foo"</pre>
<p class="indent">As with nodes, you can add attributes to edges using keyword arguments when you add the edges initially, as shown here:</p>
<pre>network.add_edge("node1","node2",myattribute="attribute of an edge")</pre>
<p class="indent">Similarly, you can add attributes to edges once they’ve been added to a network by using the <code>edge</code> dictionary, as shown here:</p>
<pre>network.edge["node1"]["node2"]["myattribute"] = "attribute of an edge"</pre>
<p class="indent">The <code>edge</code> dictionary is magical in that it allows you to access node attributes the other way around, without having to worry about which node you refer to first, as shown in <a href="ch04.xhtml#ch04list2">Listing 4-2</a>.</p>
<pre><span class="ent">➊</span> network.edge["node1"]["node2"]["myattribute"] = 321<br/><span class="ent">➋</span> print network.edge["node2"]["node1"]["myattribute"]  # prints 321</pre>
<p class="listing" id="ch04list2"><em>Listing 4-2: Using the</em> <span class="codeitalic">edge</span> <em>dictionary to access node attributes regardless of order</em></p>
<p class="indent">As you can see, the first line sets <code>myattribute</code> on an edge connecting <code>node1</code> and <code>node2</code> <span class="ent">➊</span>, and the second line accesses <code>myattribute</code> despite the <code>node1</code> and <code>node2</code> references being flipped <span class="ent">➋</span>.</p>
<h4 class="h4" id="lev58"><strong><em>Saving Networks to Disk</em></strong></h4>
<p class="noindent">To visualize our networks, we need to save them to disk from NetworkX in .<em>dot</em> format—a format commonly used in the network analysis world that can be imported into many network visualization toolkits. To save a network in .<em>dot</em> format, simply call the NetworkX <code>write_dot()</code> function, as shown in <a href="ch04.xhtml#ch04list3">Listing 4-3</a>.</p>
<pre><span epub:type="pagebreak" id="page_43"/>#!/usr/bin/python<br/>import networkx<br/>from networkx.drawing.nx_agraph import write_dot<br/><br/># instantiate a network, add some nodes, and connect them<br/>nodes = ["hello","world",1,2,3]<br/>network = networkx.Graph()<br/>for node in nodes:<br/>    network.add_node(node)<br/>network.add_edge("hello","world")<br/>write_dot(<span class="ent">➊</span>network,<span class="ent">➋</span>"network.dot")</pre>
<p class="listing" id="ch04list3"><em>Listing 4-3: Using</em> <span class="codeitalic">write_dot()</span> <em>to save networks to disk</em></p>
<p class="indent">As you can see, at the end of the code, we use the <code>write_dot()</code> function to specify the network we want to save <span class="ent">➊</span> as well as the path or filename we want to save it to <span class="ent">➋</span>.</p>
<h3 class="h3" id="lev59"><strong>Network Visualization with GraphViz</strong></h3>
<p class="noindent">Once we have written a network to disk using the <code>write_dot()</code> NetworkX function, we can visualize the resulting file using GraphViz. GraphViz is the best available command line package for visualizing your networks. It’s supported by researchers at AT&amp;T and has become a standard part of the network analysis toolbox used by data analysts. It contains a host of command line network layout tools that can be used to both lay out and render networks. GraphViz comes pre-installed on the virtual machine provided with this book and can also be downloaded at <em><a href="https://graphviz.gitlab.io/download/">https://graphviz.gitlab.io/download/</a></em>. Each GraphViz command line tool ingests networks expressed in <em>.dot</em> format and can be invoked using the following syntax to render a network as a <em>.png</em> file:</p>
<pre>$ <span class="codestrong1">&lt;</span><span class="codestrongitalic1">toolname</span><span class="codestrong1">&gt; &lt;</span><span class="codestrongitalic1">dotfile</span><span class="codestrong1">&gt; -T png –o &lt;</span><span class="codestrongitalic1">outputfile.png</span><span class="codestrong1">&gt;</span></pre>
<p class="indent">The <code>fdp</code> force-directed graph renderer is one GraphViz network visualization tool. It uses the same basic command line interface as every other GraphViz tool, as shown here:</p>
<pre>$ <span class="codestrong1">fdp apt1callback.dot –T png –o apt1callback.png</span></pre>
<p class="indent">Here, we specify that we want to use the <code>fdp</code> tool and name the network <em>.dot</em> file we want to lay out, which is <em>apt1callback.dot</em>, found in the <em>~/ch3/</em> directory of the data accompanying this book. We specify <code>–T png</code> to indicate the format (PNG) we wish to use. Finally, we specify where we want the output file to be saved using <code>-o</code> <code>apt1callback.png</code>.</p>
<h4 class="h4" id="lev60"><span epub:type="pagebreak" id="page_44"/><strong><em>Using Parameters to Adjust Networks</em></strong></h4>
<p class="noindent">The GraphViz tools include many parameters you can use to adjust the way your networks are drawn. Many of these parameters are set using the <code>–G</code> command-line flag in the following format:</p>
<pre>G<span class="codeitalic1">&lt;parametername&gt;</span>=<span class="codeitalic1">&lt;parametervalue&gt;</span></pre>
<p class="indent">Two particularly useful parameters are <code>overlap</code> and <code>splines</code>. Set <code>overlap</code> to <code>false</code> to tell GraphViz not to allow any nodes to overlap one another. Use the <code>splines</code> parameter to tell GraphViz to draw curved rather than straight lines to make it easier to follow the edges on your networks. The following are some ways to set the <code>overlap</code> and <code>splines</code> parameters in GraphViz.</p>
<p class="indent">Use the following to prevent nodes from overlapping:</p>
<pre>$ <span class="codestrong1">&lt;</span><span class="codestrongitalic1">toolname</span><span class="codestrong1">&gt; &lt;</span><span class="codestrongitalic1">dotfile</span><span class="codestrong1">&gt; -Goverlap=false -T png -o &lt;</span><span class="codestrongitalic1">outputfile.png</span><span class="codestrong1">&gt;</span></pre>
<p class="indent">Draw edges as curved lines (splines) to improve network readability:</p>
<pre>$ <span class="codestrong1">&lt;</span><span class="codestrongitalic1">toolname</span><span class="codestrong1">&gt; &lt;</span><span class="codestrongitalic1">dotfile</span><span class="codestrong1">&gt; -Gsplines=true -T png -o &lt;</span><span class="codestrongitalic1">outputfile.png</span><span class="codestrong1">&gt;</span></pre>
<p class="indent">Draw edges as curved lines (splines) to improve network readability, and don’t allow nodes to visually overlap:</p>
<pre>$ <span class="codestrong1">&lt;</span><span class="codestrongitalic1">toolname</span><span class="codestrong1">&gt; &lt;</span><span class="codestrongitalic1">dotfile</span><span class="codestrong1">&gt; -Gsplines=true –Goverlap=false -T png -o &lt;</span><span class="codestrongitalic1">outputfile.png</span><span class="codestrong1">&gt;</span></pre>
<p class="indent">Note that we simply list one parameter after the other: <span class="codestrong">-Gsplines=true</span> <span class="codestrong">–Goverlap=false</span> (the ordering doesn’t matter), followed by <span class="codestrong">-T png -o &lt;</span><span class="codestrong">outputfile</span><span class="codestrong">.png&gt;</span>.</p>
<p class="indent">In the next section, I go over some of the most useful GraphViz tools (in addition to <code>fdp</code>).</p>
<h4 class="h4" id="lev61"><strong><em>The GraphViz Command Line Tools</em></strong></h4>
<p class="noindent">Here are some of the available GraphViz tools I have found most useful, as well as some sense of when it is appropriate to use each tool.</p>
<h5 class="h5" id="lev62"><strong>fdp</strong></h5>
<p class="noindent">We used the <code>fdp</code> layout tool in the previous example, which we used to create a force-directed layout, as described in “<a href="ch04.xhtml#lev54">Force-Directed Algorithms</a>” on <a href="ch04.xhtml#page_40">page 40</a>. When you’re creating malware networks with fewer than 500 nodes, <code>fdp</code> does a good job of revealing network structure in a reasonable amount of time. But when you’re working with more than 500 nodes, and especially when connectivity between nodes is complex, you’ll find that <code>fdp</code> slows down fairly rapidly.</p>
<p class="indent"><span epub:type="pagebreak" id="page_45"/>To try out <code>fdp</code> on the APT1 shared callback server network shown in <a href="ch04.xhtml#ch04fig3">Figure 4-3</a>, enter the following from the <em>ch4</em> directory of the data accompanying this book (you must have GraphViz installed):</p>
<pre>$ <span class="codestrong1">fdp callback_servers_malware_projection.dot -T png -o fdp_servers.png –Goverlap=false</span></pre>
<p class="indent">This command will create a <em>.png</em> file (<span class="codestrong">fdp_servers.png</span>) that shows a network like the one displayed in <a href="ch04.xhtml#ch04fig5">Figure 4-5</a>.</p>
<div class="image"><a id="ch04fig5"/><img alt="image" src="../images/f0045-01.jpg"/></div>
<p class="figcap"><em>Figure 4-5: Layout of the APT1 samples using the</em> <span class="codeitalic">fdp</span> <em>tool</em></p>
<p class="indent">The <code>fdp</code> layout makes a number of themes apparent in the figure. First, two big clusters of samples are highly interrelated, as clearly seen in the upper-right and lower-left areas of the figure. Second, a number of pairs of samples are related, which can be seen in the lower right. Finally, many samples show no apparent relationship with one another and aren’t connected to any other nodes. It’s important to recall that this visualization is based on shared callback server relationships between nodes. It’s possible that the unconnected samples are related to other samples in the figure by way of other kinds of relationships, such as shared code relationships—relationships we’ll explore in <a href="ch05.xhtml#ch05">Chapter 5</a>.</p>
<h5 class="h5" id="lev63"><span epub:type="pagebreak" id="page_46"/><strong>sfdp</strong></h5>
<p class="noindent">The <code>sfdp</code> tool uses roughly the same approach to layout as <code>fdp</code>, but it scales better because it creates a hierarchy of simplifications, known as <em>coarsenings</em>, where nodes are merged into <em>supernodes</em> based on their proximity. After it completes its coarsenings, the <code>sfdp</code> tool lays out the merged versions of the graph that have far fewer nodes and edges, which dramatically speeds up the layout process. In this way, <code>sfdp</code> is able to perform fewer computations to find the best positions in the network. As a result, <code>sfdp</code> can lay out tens of thousands of nodes on a typical laptop, making it by far the best algorithm for laying out very large networks of malware.</p>
<p class="indent">This scalability comes at a cost, however: <code>sfdp</code> produces layouts that are sometimes less clear than layouts of the same-sized networks in <code>fdp</code>. For example, compare <a href="ch04.xhtml#ch04fig6">Figure 4-6</a>, which I created using <code>sfdp</code>, to the network created with <code>fdp</code>, shown in <a href="ch04.xhtml#ch04fig5">Figure 4-5</a>.</p>
<div class="image"><a id="ch04fig6"/><img alt="image" src="../images/f0046-01.jpg"/></div>
<p class="figcap"><em>Figure 4-6: Layout of the APT1 samples' shared callback server network using the</em> <span class="codeitalic">sfdp</span> <em>command</em></p>
<p class="indent">As you can see, there’s slightly more noise over each cluster in <a href="ch04.xhtml#ch04fig6">Figure 4-6</a>, making it slightly harder to see what’s going on.</p>
<p class="indent">To create this network, enter the <em>ch4</em> directory of the data accompanying this book and then enter the following code to produce the <em>sfdp_servers.png</em> image file shown in <a href="ch04.xhtml#ch04fig6">Figure 4-6</a>:</p>
<pre>$ <span class="codestrong1">sfdp callback_servers_malware_projection.dot -T png -o sfdp_servers.png –Goverlap=false</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_47"/>Note how the first item in this code specifies that we’re using the tool <code>sfdp</code>, as opposed to <code>fdp</code> from before. Everything else is the same, save the output filename.</p>
<h5 class="h5" id="lev64"><strong>neato</strong></h5>
<p class="noindent">The <code>neato</code> tool is the GraphViz implementation of a different force-directed network layout algorithm that creates simulated springs between all nodes (including unconnected nodes) to help push things to ideal positions, but at the cost of additional computation. It’s hard to know when <code>neato</code> will produce the best layout for a given network: my recommendation is that you try it, in conjunction with <code>fdp</code>, and see which layout you like more. <a href="ch04.xhtml#ch04fig7">Figure 4-7</a> shows what the <code>neato</code> layout looks like on the APT1 shared callback server network.</p>
<div class="image"><a id="ch04fig7"/><img alt="image" src="../images/f0047-01.jpg"/></div>
<p class="figcap"><em>Figure 4-7: Layout of the APT1 shared callback server network using the</em> <span class="codeitalic">neato</span> <em>layout</em></p>
<p class="indent">As you can see, in this case <code>neato</code> produces a similar network layout to those produced by <code>fdp</code> and <code>sfdp</code>. For some datasets, however, you’ll find that <code>neato</code> produces a better or worse layout—you just have to try it with your dataset and see. To try out <code>neato</code>, enter the following from the <em>ch4</em> directory of the data accompanying this book; this should produce the <em>neato_servers.png</em> network image file shown in <a href="ch04.xhtml#ch04fig7">Figure 4-7</a>:</p>
<pre>$ <span class="codestrong1">neato callback_servers_malware_projection.dot -T png -o neato_servers.png –Goverlap=false</span></pre>
<p class="indent"><span epub:type="pagebreak" id="page_48"/>To create this network, we simply revise the code we used to create <a href="ch04.xhtml#ch04fig6">Figure 4-6</a> to specify that we want to use the tool <code>neato</code> and then save the <em>.png</em> to <em>neato_servers.png</em>. Now that you know how to create these network visualizations, let’s look at ways to improve them.</p>
<h4 class="h4" id="lev65"><strong><em>Adding Visual Attributes to Nodes and Edges</em></strong></h4>
<p class="noindent">Beyond deciding on your general network layout, it can be useful to be able to specify how individual nodes and edges are to be rendered. For example, you might want to set edge thickness based on the strength of the connection between two nodes, or set node color based on what compromise each malware sample node is associated with, which would allow you to better visualize clusters of malware. NetworkX and GraphViz make it easy to do this by allowing you to specify visual attributes of nodes and edges simply by assigning values to a set of attributes. I discuss only a few such attributes in the sections that follow, but this topic is deep enough to fill an entire book.</p>
<h5 class="h5" id="lev66"><strong>Edge Width</strong></h5>
<p class="noindent">To set the width of the border that GraphViz draws around nodes, or the line that it draws for edges, you can set the <code>penwidth</code> attribute of nodes and edges to a number of your choice, as shown in <a href="ch04.xhtml#ch04list4">Listing 4-4</a>.</p>
<pre>   #!/usr/bin/python<br/>   import networkx<br/>   from networkx.drawing.nx_agraph import writedot<br/><br/><span class="ent">➊</span> g = networkx.Graph()<br/>   g.add_node(1)<br/>   g.add_node(2)<br/>   g.add_edge(1,2,<span class="ent">➋</span>penwidth=10) # make the edge extra wide<br/>   write_dot(g,'network.dot')</pre>
<p class="listing" id="ch04list4"><em>Listing 4-4: Setting the</em> <span class="codeitalic">penwidth</span> <em>attribute</em></p>
<p class="indent">Here, I create a simple network <span class="ent">➊</span> with two nodes connected by an edge, and I set the <code>penwidth</code> attribute of the edge to 10 <span class="ent">➋</span> (the default value is 1).</p>
<p class="indent">Run this code, and you should see an image that looks like <a href="ch04.xhtml#ch04fig8">Figure 4-8</a>.</p>
<div class="image"><a id="ch04fig8"/><img alt="image" src="../images/f0048-01.jpg"/></div>
<p class="figcap"><em>Figure 4-8: A simple network with an edge that has a</em> <span class="codeitalic">penwidth</span> <em>of 10</em></p>
<p class="indent">As you can see in <a href="ch04.xhtml#ch04fig8">Figure 4-8</a>, a <code>penwidth</code> of 10 results in a very thick edge. The width of the edge (or, the thickness of the node’s border if you set the <code>penwidth</code> of a node) scales proportionally with the value of <span epub:type="pagebreak" id="page_49"/>the <code>penwidth</code> attribute, so choose accordingly. For example, if your edge strength values vary from 1 to 1000, but you want to be able to see all the edges, you might want to consider assigning <code>penwidth</code> attributes based on log scaling of your edge strength values.</p>
<h5 class="h5" id="lev67"><strong>Node and Edge Color</strong></h5>
<p class="noindent">To set the color of a node’s border or an edge, use the <code>color</code> attribute. <a href="ch04.xhtml#ch04list5">Listing 4-5</a> shows how to do this.</p>
<pre>#!/usr/bin/python<br/><br/>import networkx<br/>from networkx.drawing.nx_agraph import write_dot<br/><br/>g = networkx.Graph()<br/>g.add_node(1,<span class="ent">➊</span>color="blue") # make the node outline blue<br/>g.add_node(2,<span class="ent">➋</span>color="pink") # make the node outline pink<br/>g.add_edge(1,2,<span class="ent">➌</span>color="red") # make the edge red<br/>write_dot(g,'network.dot')</pre>
<p class="listing" id="ch04list5"><em>Listing 4-5: Setting node and edge colors</em></p>
<p class="indent">Here, I create the same simple network I created in <a href="ch04.xhtml#ch04list4">Listing 4-4</a>, with two nodes and an edge connecting them. For each node that I create, I set its <code>color</code> value (<span class="ent">➊</span> and <span class="ent">➋</span>). I also set the <code>color</code> value for the edge <span class="ent">➌</span> when I create it.</p>
<p class="indent"><a href="ch04.xhtml#ch04fig9">Figure 4-9</a> shows the result of <a href="ch04.xhtml#ch04list5">Listing 4-5</a>. As expected, you should see that the first node (the edge) and the second node each have a unique color. For a complete list of colors you can use, refer to <em><a href="http://www.graphviz.org/doc/info/colors.html">http://www.graphviz.org/doc/info/colors.html</a></em>.</p>
<div class="image"><a id="ch04fig9"/><img alt="image" src="../images/f0049-01.jpg"/></div>
<p class="figcap"><em>Figure 4-9: A simple network that demonstrates how to set node and edge colors</em></p>
<p class="indent">Colors can be used to show different classes of nodes and edges.</p>
<h5 class="h5" id="lev68"><strong>Node Shape</strong></h5>
<p class="noindent">To set the shape of a node, use the <code>shape</code> attribute with a string specifying a shape, as defined at <em><a href="http://www.GraphViz.org/doc/info/shapes.html">http://www.GraphViz.org/doc/info/shapes.html</a></em>. Commonly used values are <code>box</code>, <code>ellipse</code>, <code>circle</code>, <code>egg</code>, <code>diamond</code>, <code>triangle</code>, <code>pentagon</code>, and <code>hexagon</code>. <a href="ch04.xhtml#ch04list6">Listing 4-6</a> shows how to set the <code>shape</code> attribute of a node.</p>
<pre><span epub:type="pagebreak" id="page_50"/>#!/usr/bin/python<br/><br/>import networkx<br/>from networkx.drawing.nx_agraph import write_dot<br/><br/>g = networkx.Graph()<br/>g.add_node(1,<span class="ent">➊</span>shape='diamond')<br/>g.add_node(2,<span class="ent">➋</span>shape='egg')<br/>g.add_edge(1,2)<br/><br/>write_dot(g,'network.dot')</pre>
<p class="listing" id="ch04list6"><em>Listing 4-6: Setting node shapes</em></p>
<p class="indent">Similar to the way we set a node’s color, we simply use the <code>shape</code> keyword argument in the <code>add_node()</code> function to specify the shape we want each node to take. Here, we set the first node to a diamond shape <span class="ent">➊</span> and the second node to an egg shape <span class="ent">➋</span>. The result of this code is shown in <a href="ch04.xhtml#ch04fig10">Figure 4-10</a>.</p>
<div class="image"><a id="ch04fig10"/><img alt="image" src="../images/f0050-01.jpg"/></div>
<p class="figcap"><em>Figure 4-10: A simple network that shows how we can set node shape</em></p>
<p class="indent">The results, showing a diamond-shaped node and an egg-shaped node, reflect the shapes that we specified in <a href="ch04.xhtml#ch04list6">Listing 4-6</a>.</p>
<h5 class="h5" id="lev69"><strong>Text Labels</strong></h5>
<p class="noindent">Finally, GraphViz also allows you to add labels to nodes and edges with the <code>label</code> attribute. Although nodes are automatically labeled based on their assigned ID (for example, the label for a node added as <em>123</em> would be <code>123</code>), you can specify labels using <code>label=&lt;</code><span class="codeitalic">my label attribute</span><code>&gt;</code>. Unlike nodes, edges aren’t labeled by default, but you can assign them labels using the <code>label</code> attribute. <a href="ch04.xhtml#ch04list7">Listing 4-7</a> shows how to create our now familiar two-node network but with <code>label</code> attributes attached to both nodes and the connecting edge.</p>
<pre>#!/usr/bin/python<br/><br/>import networkx<br/>from networkx.drawing.nx_agraph import write_dot<br/><br/>g = networkx.Graph()<br/>g.add_node(1,<span class="ent">➊</span>label="first node")<br/>g.add_node(2,<span class="ent">➋</span>label="second node")<br/><span epub:type="pagebreak" id="page_51"/>g.add_edge(1,2,<span class="ent">➌</span>label="link between first and second node")<br/><br/>write_dot(g,'network.dot')</pre>
<p class="listing" id="ch04list7"><em>Listing 4-7: Labeling nodes and edges</em></p>
<p class="indent">We label the nodes <code>first node</code> <span class="ent">➊</span> and <code>second node</code> <span class="ent">➋</span>, respectively. We also label the edge connecting them as the <code>link between first and second node</code> <span class="ent">➌</span>. <a href="ch04.xhtml#ch04fig11">Figure 4-11</a> shows the graphical output we expect.</p>
<div class="image"><a id="ch04fig11"/><img alt="image" src="../images/f0051-01.jpg"/></div>
<p class="figcap"><em>Figure 4-11: A simple network that shows how we can label nodes and edges</em></p>
<p class="indent">Now that you know how to manipulate basic attributes of nodes and edges, you’re ready to start building networks from the ground up.</p>
<h3 class="h3" id="lev70"><strong>Building Malware Networks</strong></h3>
<p class="noindent">We’ll begin our discussion of building malware networks by reproducing and expanding on the shared callback server example shown in <a href="ch04.xhtml#ch04fig1">Figure 4-1</a>, and then examine shared image analysis of malware.</p>
<p class="indent">The following program extracts callback domain names from malware files and then builds a bipartite network of malware samples. Next, it performs one projection of the network to show which malware samples share common callback servers, and it performs another projection to show which callback servers are called by common malware samples. Finally, the program saves the three networks—the original bipartite network, the malware sample projection, and the callback server projection—as files so that they can be visualized with GraphViz.</p>
<p class="indent">I walk you through the program, piece by piece. The complete code can be found in the data accompanying this book at the file path <em>ch4/callback_server_network.py</em>.</p>
<p class="indent"><a href="ch04.xhtml#ch04list8">Listing 4-8</a> shows how to get started by importing the requisite modules.</p>
<pre>#!/usr/bin/python<br/><br/>import pefile<span class="ent">➊</span><br/>import sys<br/><span epub:type="pagebreak" id="page_52"/>import argparse<br/>import os<br/>import pprint<br/>import networkx<span class="ent">➋</span><br/>import re<br/>from networkx.drawing.nx_agraph import write_dot<br/>import collections<br/>from networkx.algorithms import bipartite</pre>
<p class="listing" id="ch04list8"><em>Listing 4-8: Importing modules</em></p>
<p class="indent">Of the requisite modules we imported, the most notable are the <code>pefile</code> PE parsing module <span class="ent">➊</span>, which we use to parse the target PE binaries, and the <code>networkx</code> library <span class="ent">➋</span>, which we use to create the malware attribute network.</p>
<p class="indent">Next, we parse the command line arguments by adding the code in <a href="ch04.xhtml#ch04list9">Listing 4-9</a>.</p>
<pre>args = argparse.ArgumentParser("Visualize shared DLL import relationships<br/>between a directory of malware samples")<br/>args.add_argument(<span class="ent">➊</span>"target_path",help="directory with malware samples")<br/>args.add_argument(<span class="ent">➋</span>"output_file",help="file to write DOT file to")<br/>args.add_argument(<span class="ent">➌</span>"malware_projection",help="file to write DOT file to")<br/>args.add_argument(<span class="ent">➍</span>"resource_projection",help="file to write DOT file to")<br/>args = args.parse_args()</pre>
<p class="listing" id="ch04list9"><em>Listing 4-9: Parsing command line arguments</em></p>
<p class="indent">These arguments include <code>target_path</code> <span class="ent">➊</span> (the path to the directory where the malware we’re analyzing is), <code>output_file</code> <span class="ent">➋</span> (the path where we write the complete network), <code>malware_projection</code> <span class="ent">➌</span> (the path where we write a reduced version of the graph and show which malware samples share attributes), and <code>resource_projection</code> <span class="ent">➍</span> (the path where we write a reduced version of the graph and show which attributes are seen together within the malware samples).</p>
<p class="indent">Now we’re ready to get into the core of the program. <a href="ch04.xhtml#ch04list10">Listing 4-10</a> shows the code for creating a network for the program.</p>
<pre>   #!/usr/bin/python<br/><br/>   import pefile<br/><span class="ent">➊</span> import sys<br/>   import argparse<br/>   import os<br/>   import pprint<br/>   import networkx<br/>   import re<br/>   from networkx.drawing.nx_agraph import write_dot<br/>   import collections<br/>   from networkx.algorithms import bipartite<br/><br/>   args = argparse.ArgumentParser(<br/>   "Visualize shared hostnames between a directory of malware samples"<br/>   )<br/>   <span epub:type="pagebreak" id="page_53"/>args.add_argument("target_path",help="directory with malware samples")<br/>   args.add_argument("output_file",help="file to write DOT file to")<br/>   args.add_argument("malware_projection",help="file to write DOT file to")<br/>   args.add_argument("hostname_projection",help="file to write DOT file to")<br/>   args = args.parse_args()<br/>   network = networkx.Graph()<br/><br/>   valid_hostname_suffixes = map(<br/>   lambda string: string.strip(), open("domain_suffixes.txt")<br/>   )<br/>   valid_hostname_suffixes = set(valid_hostname_suffixes)<br/><span class="ent">➋</span> def find_hostnames(string):<br/>      possible_hostnames = re.findall(<br/>      r'(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-]{,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,6}',<br/>      string)<br/>      valid_hostnames = filter(<br/>              lambda hostname: hostname.split(".")[-1].lower() \<br/>              in valid_hostname_suffixes,<br/>              possible_hostnames<br/>      )<br/>      return valid_hostnames<br/><br/>  # search the target directory for valid Windows PE executable files<br/>  for root,dirs,files in os.walk(args.target_path):<br/>      for path in files:<br/>          # try opening the file with pefile to see if it's really a PE file<br/>          try:<br/>              pe = pefile.PE(os.path.join(root,path))<br/>          except pefile.PEFormatError:<br/>              continue<br/>          fullpath = os.path.join(root,path)<br/>          # extract printable strings from the target sample<br/>        <span class="ent">➌</span> strings = os.popen("strings '{0}'".format(fullpath)).read()<br/><br/>          # use the search_doc function in the included reg module <br/>          # to find hostnames<br/>        <span class="ent">➍</span> hostnames = find_hostnames(strings)<br/>          if len(hostnames):<br/>              # add the nodes and edges for the bipartite network<br/>              network.add_node(path,label=path[:32],color='black',penwidth=5,<br/>              bipartite=0)<br/>          for hostname in hostnames:<br/>            <span class="ent">➎</span> network.add_node(hostname,label=hostname,color='blue',<br/>                 penwidth=10,bipartite=1)<br/>              network.add_edge(hostname,path,penwidth=2)<br/>          if hostnames:<br/>              print "Extracted hostnames from:",path<br/>              pprint.pprint(hostnames)</pre>
<p class="listing" id="ch04list10"><em>Listing 4-10: Creating the network</em></p>
<p class="indent">We first create a fresh network by calling the <code>networkx.Graph()</code> constructor <span class="ent">➊</span>. Then we define the function <code>find_hostnames()</code>, which extracts <span epub:type="pagebreak" id="page_54"/>hostnames from strings <span class="ent">➋</span>. Don’t worry too much about the mechanics of this function: it’s essentially a regular expression and some string-filtering code that tries its best to identify domains.</p>
<p class="indent">Next, we iterate through all the files in the target directory, checking whether they are PE files by seeing if the <code>pefile.PE</code> class is able to load them (if not, we do not analyze the files). Finally, we extract hostname attributes from the current file by first extracting all printable strings from the file <span class="ent">➌</span> and then searching the strings for embedded hostname resources <span class="ent">➍</span>. If we find any, we add them as nodes in our network and then add edges from the node for the current malware sample to the hostname resource nodes <span class="ent">➎</span>.</p>
<p class="indent">Now we’re ready to wrap up the program, as shown in <a href="ch04.xhtml#ch04list11">Listing 4-11</a>.</p>
<pre>  # write the dot file to disk<br/><span class="ent">➊</span> write_dot(network, args.output_file)<br/><span class="ent">➋</span> malware = set(n for n,d in network.nodes(data=True) if d['bipartite']==0)<br/><span class="ent">➌</span> hostname = set(network)-malware<br/><br/>  # use NetworkX's bipartite network projection function to produce the malware<br/>  # and hostname projections<br/><span class="ent">➍</span> malware_network = bipartite.projected_graph(network, malware)<br/>  hostname_network = bipartite.projected_graph(network, hostname)<br/><br/>  # write the projected networks to disk as specified by the user<br/><span class="ent">➎</span> write_dot(malware_network,args.malware_projection)<br/>  write_dot(hostname_network,args.hostname_projection)</pre>
<p class="listing" id="ch04list11"><em>Listing 4-11: Writing networks to files</em></p>
<p class="indent">We start by writing our network to disk at the location specified in the command line arguments <span class="ent">➊</span>. Then we create the two reduced networks (the “projections” introduced earlier in this chapter) that show the malware relationships and the hostname resource relationships. We do this by first creating a Python set for containing the IDs of the malware nodes <span class="ent">➋</span> and another Python set for the IDs of the resource nodes <span class="ent">➌</span>. We then use the NetworkX-specific <code>projected_graph()</code> function <span class="ent">➍</span> to get projections for the malware and resource sets, and we write these networks to disk at the specified locations <span class="ent">➎</span>.</p>
<p class="indent">And that’s it! You can use this program on any of the malware datasets in this book to see malware relationships between the shared hostname resources embedded in the files. You can even use it on your own datasets to see what threat intelligence you can glean through this mode of analysis.</p>
<h3 class="h3" id="lev71"><strong>Building a Shared Image Relationship Network</strong></h3>
<p class="noindent">In addition to analyzing malware based on their shared callback servers, we can also analyze them based on their use of shared icons and other graphical assets. For example, <a href="ch04.xhtml#ch04fig12">Figure 4-12</a> shows a portion of the shared image analysis results for the Trojans found in <em>ch4/data/Trojans</em>.</p>
<div class="image"><span epub:type="pagebreak" id="page_55"/><a id="ch04fig12"/><img alt="image" src="../images/f0055-01.jpg"/></div>
<p class="figcap"><em>Figure 4-12: A visualization of the shared image asset network for a number of Trojans</em></p>
<p class="indent">You can see that all these Trojan horses pose as archive files and use the same archive file icon (shown in the center of the figure), even though they’re executables. The fact that they use exactly the same image as part of their effort to game the user indicates that they probably come from the same attacker. I confirmed this by running the malware samples through the Kaspersky antivirus engine, which assigns them all the same family name (ArchSMS).</p>
<p class="indent">Next, I show you how to produce the kind of visualization shown in <a href="ch04.xhtml#ch04fig12">Figure 4-12</a>, in order to see shared-image relationships between malware samples. To extract the images from the malware, we use the helper library <code>images</code>, which in turn relies on <code>wrestool</code> (discussed in <a href="ch01.xhtml#ch01">Chapter 1</a>) to create the <em>image_network.py</em> program. Recall that <code>wrestool</code> extracts images from Windows executables.</p>
<p class="indent">Let’s walk through the process of creating a shared image network, starting with the first part of the code, shown in <a href="ch04.xhtml#ch04list12">Listing 4-12</a>.</p>
<pre>   #!/usr/bin/python<br/><br/>   import pefile<br/>   import sys<br/>   import argparse<br/>   import os<br/>   import pprint<br/>   import logging<br/>   import networkx<br/>   import collections<br/>   import tempfile<br/>   <span epub:type="pagebreak" id="page_56"/>from networkx.drawing.nx_agraph import write_dot<br/>   from networkx.algorithms import bipartite<br/><br/>   # Use argparse to parse any command line arguments<br/><br/>   args = argparse.ArgumentParser(<br/>   "Visualize shared image relationships between a directory of malware samples"<br/>   )<br/>   args.add_argument("target_path",help="directory with malware samples")<br/>   args.add_argument("output_file",help="file to write DOT file to")<br/>   args.add_argument("malware_projection",help="file to write DOT file to")<br/>   args.add_argument("resource_projection",help="file to write DOT file to")<br/>   args = args.parse_args()<br/>   network = networkx.Graph()<br/><br/><span class="ent">➊</span> class ExtractImages():<br/>      def __init__(self,target_binary):<br/>          self.target_binary = target_binary<br/>          self.image_basedir = None<br/>          self.images = []<br/><br/>      def work(self):<br/>          self.image_basedir = tempfile.mkdtemp()<br/>          icondir = os.path.join(self.image_basedir,"icons")<br/>          bitmapdir = os.path.join(self.image_basedir,"bitmaps")<br/>          raw_resources = os.path.join(self.image_basedir,"raw")<br/>          for directory in [icondir,bitmapdir,raw_resources]:<br/>              os.mkdir(directory)<br/>          rawcmd = "wrestool -x {0} -o {1} 2&gt; \<br/>                   /dev/null".format(<br/>                   self.target_binary,raw_resources<br/>                   )<br/>          bmpcmd = "mv {0}/*.bmp {1} 2&gt; /dev/null".format(<br/>          raw_resources,bitmapdir<br/>          )<br/>          icocmd = "icotool -x {0}/*.ico -o {1} \<br/>                    2&gt; /dev/null".format(<br/>                    raw_resources,icondir<br/>                    )<br/>          for cmd in [rawcmd,bmpcmd,icocmd]:<br/>              try:<br/>                  os.system(cmd)<br/>              except Exception,msg:<br/>                  pass<br/>          for dirname in [icondir,bitmapdir]:<br/>              for path in os.listdir(dirname):<br/>                  logging.info(path)<br/>                  path = os.path.join(dirname,path)<br/>                  imagehash = hash(open(path).read())<br/>                  if path.endswith(".png"):<br/>                      self.images.append((path,imagehash))<br/>                  if path.endswith(".bmp"):<br/>                      self.images.append((path,imagehash))<br/><span epub:type="pagebreak" id="page_57"/>      def cleanup(self):<br/>          os.system("rm -rf {0}".format(self.image_basedir))<br/><br/>   # search the target directory for PE files to extract images from<br/>   image_objects = []<br/>   for root,dirs,files in os.walk(args.target_path):<span class="ent">➋</span><br/>      for path in files:<br/>          # try to parse the path to see if it's a valid PE file<br/>          try:<br/>              pe = pefile.PE(os.path.join(root,path))<br/>          except pefile.PEFormatError:<br/>              continue</pre>
<p class="listing" id="ch04list12"><em>Listing 4-12: Parsing the initial argument and file-loading code in our shared image network program</em></p>
<p class="indent">The program starts out much like the hostname graph program (starting at <a href="ch04.xhtml#ch04list8">Listing 4-8</a>) we just discussed. It first imports a number of modules, including <code>pefile</code> and <code>networkx</code>. Here, however, we also define the <code>ExtractImages</code> helper class <span class="ent">➊</span>, which we use to extract graphical assets from target malware samples. Then the program enters a loop in which we iterate over all the target malware binaries <span class="ent">➋</span>.</p>
<p class="indent">Now that we are in our loop, it’s time to extract graphical assets from the target malware binaries using the <code>ExtractImages</code> class (which under the hood is a wrapper around the <code>icoutils</code> programs discussed in <a href="ch01.xhtml#ch01">Chapter 1</a>). <a href="ch04.xhtml#ch04list13">Listing 4-13</a> shows the part of the code that does this.</p>
<pre>           fullpath = os.path.join(root,path)<br/>        <span class="ent">➊</span> images = ExtractImages(fullpath)<br/>        <span class="ent">➋</span> images.work()<br/>           image_objects.append(images)<br/><br/>           # create the network by linking malware samples to their images<br/>        <span class="ent">➌</span> for path, image_hash in images.images:<br/>               # set the image attribute on the image nodes to tell GraphViz to<br/>               # render images within these nodes<br/>               if not image_hash in network:<br/>                <span class="ent">➍</span> network.add_node(image_hash,image=path,label='',type='image')<br/>               node_name = path.split("/")[-1]<br/>               network.add_node(node_name,type="malware")<br/>            <span class="ent">➎</span> network.add_edge(node_name,image_hash)</pre>
<p class="listing" id="ch04list13"><em>Listing 4-13: Extracting graphical assets from target malware</em></p>
<p class="indent">First, we pass in a path to a target malware binary to the <code>ExtractImages</code> class <span class="ent">➊</span>, and then we call the resulting instance’s <code>work()</code> method <span class="ent">➋</span>. This results in the <code>ExtractImages</code> class creating a temporary directory in which it stores the malware images, and then storing a dictionary containing data about each image in the <code>images</code> class attribute.</p>
<p class="indent">Now that we have the list of extracted images from <code>ExtractImages</code>, we iterate over it <span class="ent">➌</span>, creating a new network node for an image if we haven’t seen its hash before <span class="ent">➍</span>, and linking the currently processed malware sample to the image in the network <span class="ent">➎</span>.</p>
<p class="indent"><span epub:type="pagebreak" id="page_58"/>Now that we have created our network of malware samples linked to the images that they contain, we are ready to write the graph to disk, as shown in <a href="ch04.xhtml#ch04list14">Listing 4-14</a>.</p>
<pre>   # write the bipartite network, then do the two projections and write them<br/><span class="ent">➊</span> write_dot(network, args.output_file)<br/>   malware = set(n for n,d in network.nodes(data=True) if d['type']=='malware')<br/>   resource = set(network) - malware<br/>   malware_network = bipartite.projected_graph(network, malware)<br/>   resource_network = bipartite.projected_graph(network, resource)<br/><br/><span class="ent">➋</span> write_dot(malware_network,args.malware_projection)<br/>   write_dot(resource_network,args.resource_projection)</pre>
<p class="listing" id="ch04list14"><em>Listing 4-14: Writing the graph to disk</em></p>
<p class="indent">We do this in exactly the same way that we did in <a href="ch04.xhtml#ch04list11">Listing 4-11</a>. First, we write the complete network to disk <span class="ent">➊</span>, and then we write the two projections (the projection for the malware and the projection for the images, which we refer to as <em>resources</em> here) to disk <span class="ent">➋</span>.</p>
<p class="indent">You can use <em>image_network.py</em> to analyze graphical assets in any of the malware datasets in this book, or to extract intelligence from malware datasets of your choice.</p>
<h3 class="h3" id="lev72"><strong>Summary</strong></h3>
<p class="noindent">In this chapter, you learned about the tools and methods necessary to perform shared attribute analysis on your own malware datasets. Specifically, you learned how networks, bipartite networks, and bipartite network projections can help identify the social connections between malware samples, why network layout is central to network visualization, and how force-directed networks work. You also learned how to create and visualize malware networks using Python and open source tools like NetworkX. In <a href="ch05.xhtml#ch05">Chapter 5</a>, you’ll learn how to build malware networks based on shared code relationships between samples.</p>
</body></html>