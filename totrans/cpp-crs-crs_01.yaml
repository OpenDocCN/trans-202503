- en: '**AN OVERTURE TO C PROGRAMMERS**'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**致 C 程序员的前言**'
- en: '*ARTHUR DENT: What’s the matter with him? HIG HURTENFLURST: His feet are the
    wrong size for his shoes.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*阿瑟·丹特：他怎么了？ 高·赫滕弗斯特：他的脚与鞋子不匹配。*'
- en: —Douglas Adams*, The Hitchhiker’s Guide to the Galaxy, “*Fit the Eleventh*”
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: —道格拉斯·亚当斯，《银河系漫游指南》，“*适配第十一条*”
- en: '![Image](../images/common.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../images/common.jpg)'
- en: This preface is meant for experienced C programmers who are considering whether
    or not to read this book. Non–C programmers are welcome to skip this prelude.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本前言是为有经验的 C 程序员准备的，帮助他们决定是否阅读本书。非 C 程序员可以跳过这一部分。
- en: Bjarne Stroustrup developed C++ from the C programming language. Although C++
    isn’t completely compatible with C, well-written C programs are often also valid
    C++ programs. Case in point, every example in *The C Programming Language* by
    Brian Kernighan and Dennis Ritchie is a legal C++ program.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 比雅尔内·斯特劳斯特鲁普（Bjarne Stroustrup）从 C 语言发展出了 C++。尽管 C++ 并不完全兼容 C，但写得好的 C 程序通常也是合法的
    C++ 程序。举例来说，Brian Kernighan 和 Dennis Ritchie 编写的《C 程序设计语言》中的每个例子，都是合法的 C++ 程序。
- en: One primary reason for C’s ubiquity in the system-programming community is that
    C allows programmers to write at a higher level of abstraction than assembly programming
    does. This tends to produce clearer, less error-prone, and more maintainable code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: C 语言在系统编程社区广泛使用的一个主要原因是，C 允许程序员以比汇编语言更高的抽象层次进行编程。这通常能产生更清晰、少出错、且更易维护的代码。
- en: 'Generally, system programmers aren’t willing to pay overhead for programming
    convenience, so C adheres to the zero-overhead principle: *what you don’t use,
    you don’t pay for*. The strong type system is a prime example of a zero-overhead
    abstraction. It’s used only at compile time to check for program correctness.
    After compile time, the types will have disappeared, and the emitted assembly
    code will show no trace of the type system.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，系统程序员不愿为编程便利性支付额外开销，因此 C 语言遵循零开销原则：*你不用的，就不需要为它付费*。强类型系统就是零开销抽象的典型例子。它只在编译时用于检查程序正确性。编译后，类型信息将消失，生成的汇编代码将不再体现类型系统的痕迹。
- en: As a descendant of C, C++ also takes zero-overhead abstraction and direct mapping
    to hardware very seriously. This commitment goes beyond just the C language features
    that C++ supports. Everything that C++ builds on top of C, including new language
    features, upholds these principles, and departures from either are made very deliberately.
    In fact, some C++ features incur even less overhead than corresponding C code.
    The `constexpr` keyword is one such example. It instructs the compiler to evaluate
    the expression at compile time (if possible), as shown in the program in [Listing
    1](anoverture.xhtml#anovertureex01).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 C 语言的后代，C++ 也非常重视零开销抽象和直接映射到硬件。这种承诺不仅仅局限于 C++ 支持的 C 语言特性。C++ 在 C 基础上构建的一切，包括新的语言特性，都遵循这些原则，任何偏离这些原则的地方都是经过深思熟虑的。实际上，一些
    C++ 特性比对应的 C 代码还要少开销。例如，`constexpr` 关键字就是一个例子。它指示编译器在编译时评估表达式（如果可能的话），如 [清单 1](anoverture.xhtml#anovertureex01)
    中的程序所示。
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Listing 1: A program illustrating `constexpr`*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 1：演示 `constexpr` 的程序*'
- en: The `isqrt` function computes the square root of the argument `n`. Starting
    at `1`, the function increments the local variable `i` until `i*i` is greater
    than or equal to `n`. If `i*i == n`, it returns `i`; otherwise, it returns `i-1`.
    Notice that the invocation of `isqrt` has a literal value, so the compiler could
    theoretically compute the result for you. The result will only ever take on one
    value ➊.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`isqrt` 函数计算参数 `n` 的平方根。从 `1` 开始，该函数递增局部变量 `i`，直到 `i*i` 大于或等于 `n`。如果 `i*i ==
    n`，则返回 `i`；否则，返回 `i-1`。请注意，`isqrt` 的调用有一个字面值，因此编译器理论上可以为你计算结果。结果最终只会是一个值 ➊。'
- en: Compiling [Listing 1](anoverture.xhtml#anovertureex01) on GCC 8.3 targeting
    x86-64 with `-O2` yields the assembly in [Listing 2](anoverture.xhtml#anovertureex02).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GCC 8.3 上编译 [清单 1](anoverture.xhtml#anovertureex01)，目标为 x86-64，使用 `-O2` 优化选项，生成的汇编代码可见于
    [清单 2](anoverture.xhtml#anovertureex02)。
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Listing 2: The assembly produced after compiling [Listing 1](anoverture.xhtml#anovertureex01)*'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 2：编译 [清单 1](anoverture.xhtml#anovertureex01) 后生成的汇编代码*'
- en: The salient result here is the second instruction in `main` ➊; rather than evaluating
    the square root of `1764` at runtime, the compiler evaluates it and outputs instructions
    to treat `x` as `42`. Of course, you could calculate the square root using a calculator
    and insert the result manually, but using `constexpr` provides lots of benefits.
    This approach can mitigate many errors associated with manually copying and pasting,
    and it makes your code more expressive.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里最显著的结果是 `main` 中的第二条指令 ➊；编译器并不是在运行时计算 `1764` 的平方根，而是计算出结果并输出指令，将 `x` 处理为 `42`。当然，你可以使用计算器计算平方根并手动插入结果，但使用
    `constexpr` 提供了许多好处。这种方法可以减少与手动复制粘贴相关的许多错误，使你的代码更加富有表现力。
- en: '**NOTE**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*If you’re not familiar with x86 assembly, refer to* The Art of Assembly Language,
    *2nd Edition, by Randall Hyde and* Professional Assembly Language *by Richard
    Blum*.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你不熟悉 x86 汇编语言，请参阅《汇编语言艺术》（第 2 版，Randall Hyde 著）和《专业汇编语言》（Richard Blum 著）。*'
- en: '**Upgrading to Super C**'
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**升级到超级 C**'
- en: Modern C++ compilers will accommodate most of your C programming habits. This
    makes it easy to embrace a few of the tactical niceties that the C++ language
    affords you while deliberately avoiding the language’s deeper themes. This style
    of C++—let’s call it *Super C*—is important to discuss for several reasons. First,
    seasoned C programmers can immediately benefit from applying simple, tactical-level
    C++ concepts to their programs. Second, Super C is *not* idiomatic C++. Simply
    sprinkling references and instances of `auto` around a C program might make your
    code more robust and readable, but you’ll need to learn other concepts to take
    full advantage of it. Third, in some austere environments (for example, embedded
    software, some operating system kernels, and heterogeneous computing), the available
    tool chains have incomplete C++ support. In such situations, it’s possible to
    benefit from at least some C++ idioms, and Super C is likely to be supported.
    This section covers some Super C concepts you can apply to your code immediately.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 C++ 编译器会支持大部分你的 C 编程习惯。这使得你能够轻松接受一些 C++ 语言提供的策略性优点，同时故意避开该语言的深层主题。我们可以将这种
    C++ 称为*超级 C*，它有几个值得讨论的原因。首先，经验丰富的 C 程序员可以通过将简单的、策略层面的 C++ 概念应用到他们的程序中，立即受益。其次，超级
    C*并非*惯用的 C++。简单地在 C 程序中撒上引用和 `auto` 实例，可能会使你的代码更健壮、更易读，但要想充分利用这些特性，你还需要学习其他概念。第三，在一些苛刻的环境中（例如，嵌入式软件、某些操作系统内核和异构计算），可用的工具链对
    C++ 的支持不完全。在这种情况下，你仍然可以从一些 C++ 惯用语中获益，而超级 C 很可能是被支持的。本节介绍了一些可以立即应用到代码中的超级 C 概念。
- en: '**NOTE**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*Some C-supported constructs won’t work in C++. See the links section of this
    book’s companion site,* [https://ccc.codes](https://ccc.codes).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*一些 C 支持的结构在 C++ 中无法使用。请参见本书配套网站的链接部分，* [https://ccc.codes](https://ccc.codes)。'
- en: '***Function Overloading***'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***函数重载***'
- en: 'Consider the following conversion functions from the standard C library:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑以下来自标准 C 库的转换函数：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'These functions achieve the same goal: they convert an integral type to a C-style
    string. In C, each function must have a unique name. But in C++ functions can
    share names as long as their arguments differ; this is called *function overloading*.
    You can use function overloading to create your own conversion functions, as [Listing
    3](anoverture.xhtml#anovertureex03) illustrates.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数实现相同的目标：它们将一个整型转换为 C 风格的字符串。在 C 语言中，每个函数必须有唯一的名称。但在 C++ 中，只要函数的参数不同，多个函数可以共享相同的名称；这就是所谓的*函数重载*。你可以利用函数重载创建自己的转换函数，正如[列表
    3](anoverture.xhtml#anovertureex03)所示。
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Listing 3: Calling overloaded functions*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 3：调用重载函数*'
- en: The data type of the first argument in each of the functions differs, so the
    C++ compiler has enough information from the arguments passed into `toa` to call
    the correct function. Each `toa` call is to a unique function. Here, you create
    the variables `a` ➊, `b` ➋, and `c` ➌, which are different types of `int` objects
    that correspond with one of the three `toa` functions. This is more convenient
    than defining separately named functions, because you just need to remember one
    name and the compiler figures out which function to call.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数中第一个参数的数据类型不同，因此 C++ 编译器从传递给 `toa` 的参数中获得足够的信息，以调用正确的函数。每次 `toa` 调用都是指向一个唯一的函数。这里，你创建了变量
    `a` ➊、`b` ➋ 和 `c` ➌，它们是不同类型的 `int` 对象，对应于三个 `toa` 函数中的一个。这比定义不同名称的函数更方便，因为你只需要记住一个名称，编译器会搞清楚调用哪个函数。
- en: '***References***'
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***参考资料***'
- en: Pointers are a crucial feature of C (and by extension most system programming).
    They enable you to handle large amounts of data efficiently by passing around
    data addresses instead of the actual data. Pointers are equally crucial to C++,
    but you have additional safety features available that defend against null dereferences
    and unintentional pointer reassignments.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 指针是C语言（以及扩展到大多数系统编程）的一个关键特性。它们通过传递数据地址而不是实际数据，使你能够高效地处理大量数据。指针对C++也同样重要，但你可以使用额外的安全特性来防止空指针解引用和无意的指针重新赋值。
- en: '*References* are a major improvement to handling pointers. They’re similar
    to pointers, but with some key differences. Syntactically, references differ from
    pointers in two important ways. First, you declare them with `&` rather than `*`,
    as [Listing 4](anoverture.xhtml#anovertureex04) illustrates.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*引用*是对指针处理的重大改进。它们与指针类似，但有一些关键的区别。从语法上讲，引用与指针在两个重要方面有所不同。首先，你使用`&`来声明引用，而不是`*`，正如[示例
    4](anoverture.xhtml#anovertureex04)所展示的那样。'
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*Listing 4: Code illustrating how to declare functions taking pointers and
    references*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 4：展示如何声明接受指针和引用的函数的代码*'
- en: Second, you interact with members using the dot operator `.` rather than the
    arrow operator `->`, as [Listing 5](anoverture.xhtml#anovertureex05) illustrates.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你使用点操作符`.`与成员进行交互，而不是箭头操作符`->`，正如[示例 5](anoverture.xhtml#anovertureex05)所示。
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Listing 5: A program illustrating the use of the dot and arrow operators*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 5：演示点操作符和箭头操作符使用的程序*'
- en: Under the hood, references are equivalent to pointers because they’re also a
    zero-overhead abstraction. The compiler produces similar code. To illustrate this,
    consider the results of compiling the `make_sentient` functions on GCC 8.3 targeting
    x86-64 with `-O2`. [Listing 6](anoverture.xhtml#anovertureex06) contains the assembly
    generated by compiling [Listing 5](anoverture.xhtml#anovertureex05).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，引用等同于指针，因为它们也是一种零开销的抽象。编译器生成的代码相似。为了说明这一点，考虑在GCC 8.3上编译`make_sentient`函数的结果，目标架构为x86-64，使用`-O2`优化选项。[示例
    6](anoverture.xhtml#anovertureex06)包含了通过编译[示例 5](anoverture.xhtml#anovertureex05)生成的汇编代码。
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Listing 6: The assembly generated from compiling [Listing 5](anoverture.xhtml#anovertureex05)*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 6：通过编译[示例 5](anoverture.xhtml#anovertureex05)生成的汇编代码*'
- en: However, at compile time, references provide some safety over raw pointers because,
    generally speaking, they cannot be null.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在编译时，引用相比原始指针提供了一些安全性，因为一般来说，引用不能为null。
- en: With pointers, you might add a `nullptr` check to be safe. For example, you
    might add a check to `make_sentient`, as in [Listing 7](anoverture.xhtml#anovertureex07).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于指针，你可能会添加一个`nullptr`检查以确保安全。例如，你可能会对`make_sentient`添加检查，就像在[示例 7](anoverture.xhtml#anovertureex07)中所示的那样。
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*Listing 7: A refactor of `make_sentient` from [Listing 5](anoverture.xhtml#anovertureex05)
    so it performs a `nullptr` check*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 7：对[示例 5](anoverture.xhtml#anovertureex05)中的`make_sentient`函数进行重构，以执行`nullptr`检查*'
- en: 'Such a check is unnecessary when taking a reference; however, this doesn’t
    mean that references are always valid. Consider the following function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用引用时，这样的检查是不必要的；然而，这并不意味着引用总是有效的。考虑以下函数：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `not_dinkum` function returns a reference, which is guaranteed to be non-null.
    But it’s pointing to garbage memory (probably in the returned-from stack frame
    of `not_dinkum`). You must never do this. The result will be utter misery, also
    known as *undefined runtime behavior:* it might crash, it might give you an error,
    or it might do something completely unexpected.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`not_dinkum`函数返回一个引用，该引用保证非null。但它指向的是垃圾内存（可能是从`not_dinkum`返回的栈帧中）。你绝不能这样做。结果将是彻底的痛苦，也就是*未定义的运行时行为*：它可能崩溃，可能给出错误，或者可能做出完全意想不到的事情。'
- en: One other safety feature of references is that they can’t be *reseated*. In
    other words, once a reference is initialized, it can’t be changed to point to
    another memory address, as [Listing 8](anoverture.xhtml#anovertureex08) shows.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 引用的另一个安全特性是它们不能被*重新设置*。换句话说，一旦引用被初始化，就不能再指向另一个内存地址，正如[示例 8](anoverture.xhtml#anovertureex08)所示。
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Listing 8: A program illustrating that references cannot be reseated*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 8：演示引用不能被重新设置的程序*'
- en: You declare `a_ref` as a reference to `int a` ➊. There is no way to reseat `a_ref`
    to point to another `int`. You might try to reseat `a` with operator= ➋, but this
    actually sets the value of `a` to the value of `b` instead of setting `a_ref`
    to reference `b.` After the snippet is run both `a` and `b` are equal to `100`,
    and `a_ref` still points to `a`. [Listing 9](anoverture.xhtml#anovertureex09)
    contains equivalent code using pointers instead.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你将`a_ref`声明为对`int a`的引用 ➊。无法重新为`a_ref`指向另一个`int`。你可能尝试使用赋值操作符`=`重置`a` ➋，但这实际上是将`a`的值设置为`b`的值，而不是将`a_ref`设置为引用`b`。在该代码片段运行后，`a`和`b`都等于`100`，并且`a_ref`仍然指向`a`。[清单
    9](anoverture.xhtml#anovertureex09)提供了使用指针的等效代码。
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*Listing 9: An equivalent program to [Listing 8](anoverture.xhtml#anovertureex08)
    using pointers*'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 9：使用指针的等效程序，参考[清单 8](anoverture.xhtml#anovertureex08)*'
- en: Here, you declare the pointer with a `*` instead of a `&` ➊. You assign the
    value of `b` to the memory pointed to by `a_ptr` ➋. With references, you don’t
    need any decoration on the left side of the equal sign. But if you omit the `*`
    in `*a_ptr`, the compiler would complain that you’re trying to assign an `int`
    to a pointer type.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用`*`声明指针，而不是`&` ➊。你将`b`的值赋给`a_ptr`指向的内存 ➋。使用引用时，你不需要在等号左边加任何装饰。但如果你省略`*`，例如在`*a_ptr`中，编译器会抱怨你试图将`int`类型赋给指针类型。
- en: References are just pointers with extra safety precautions and a sprinkle of
    syntactic sugar. When you put a reference on the left side of an equal sign, you’re
    setting the pointed-to value equal to the right side of the equal sign.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 引用实际上是具有额外安全防护和一些语法糖的指针。当你将引用放在等号的左侧时，你是在将右侧等号的值赋给指针所指向的值。
- en: '***auto Initialization***'
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***auto初始化***'
- en: 'C often requires you to repeat type information more than once. In C++, you
    can express a variable’s type information just once by utilizing the `auto` keyword.
    The compiler will know the variable’s type because it knows the type of the value
    being used to initialize the variable. Consider the following C++ variable initializations:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: C语言通常要求你重复多次类型信息，而在C++中，你只需使用`auto`关键字一次，就可以表达变量的类型信息。编译器将知道变量的类型，因为它知道用于初始化变量的值的类型。考虑以下C++变量初始化示例：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, `x` and `y` are both of `int` type. You might be surprised to know that
    the compiler can deduce the type of `y`, but consider that 42 is an integer literal.
    With `auto`, the compiler deduces the type on the right side of the equal sign
    `=` and sets the variable’s type to the same. Because an integer literal is of
    `int` type, in this example the compiler deduces that the type of `y` is also
    an `int`. This doesn’t seem like much of a benefit in such a simple example, but
    consider initializing a variable with a function’s return value, as [Listing 10](anoverture.xhtml#anovertureex10)
    illustrates.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`x`和`y`都是`int`类型。你可能会惊讶地发现编译器能够推导出`y`的类型，但请注意，42是一个整数字面量。使用`auto`时，编译器会推导出等号右侧的类型`=`，并将变量的类型设置为相同类型。由于整数字面量是`int`类型，因此在此示例中，编译器推导出`y`的类型也是`int`。在如此简单的示例中，这似乎没有太大好处，但请考虑用一个函数的返回值初始化变量，如[清单
    10](anoverture.xhtml#anovertureex10)所示。
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Listing 10: A toy program initializing a variable with the return value of
    a function*'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 10：一个使用函数返回值初始化变量的玩具程序*'
- en: The `auto` keyword is easier to read and is more amenable to code refactoring
    than explicitly declaring a variable’s type. If you use `auto` freely while declaring
    a function, there will be less work to do later if you need to change the return
    type of `make_mike`. The case for `auto` strengthens with more complex types,
    such as those involved with the template-laden code of the stdlib. The `auto`
    keyword makes the compiler do all the work of type deduction for you.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`auto`关键字更易读，且比显式声明变量类型更有利于代码重构。如果你在声明函数时自由使用`auto`，当你需要更改`make_mike`的返回类型时，你将需要做的工作会更少。随着代码复杂性增加，特别是涉及到标准库中模板代码时，`auto`的优势更加明显。`auto`关键字使编译器为你做所有类型推导的工作。'
- en: '**NOTE**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '*You can also add `const`, `volatile`, `&`, and `*` qualifiers to `auto`.*'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*你也可以在`auto`后添加`const`、`volatile`、`&`和`*`限定符。*'
- en: '***Namespaces and Implicit typedef of struct, union, and enum***'
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***命名空间和结构体、联合体和枚举的隐式类型定义***'
- en: 'C++ treats type tags as implicit `typedef` names. In C, when you want to use
    a `struct`, `union`, or `enum`, you have to assign a name to the type you’ve created
    using the `typedef` keyword. For example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: C++将类型标签视为隐式`typedef`名称。在C语言中，当你想使用`struct`、`union`或`enum`时，你必须使用`typedef`关键字为你创建的类型指定一个名称。例如：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In C++ land, you chortle at such code. Because the `typedef` keyword can be
    implicit, C++ allows you instead to declare the `Jabberwock` type like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在C++中，你可能会对这样的代码嗤之以鼻。因为`typedef`关键字可以是隐式的，C++允许你像这样声明`Jabberwock`类型：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is more convenient and saves some typing. What happens if you also want
    to define a `Jabberwock` function? Well, you shouldn’t, because reusing the same
    name for a data type and a function is likely to cause confusion. But if you’re
    really committed to it, C++ allows you to declare a `namespace` to create different
    scopes for identifiers. This helps to keep user types and functions tidy, as shown
    in [Listing 11](anoverture.xhtml#anovertureex11).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做更加方便，并且可以节省一些输入时间。如果你还想定义一个`Jabberwock`函数会怎样呢？嗯，你不应该这么做，因为将数据类型和函数使用相同的名称可能会引起混淆。不过，如果你真的决定这么做，C++允许你声明一个`namespace`来为标识符创建不同的作用域。这有助于保持用户类型和函数的整洁，如[列表
    11](anoverture.xhtml#anovertureex11)所示。
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Listing 11: Using namespaces to disambiguate functions and types with identical
    names*'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 11：使用命名空间消除具有相同名称的函数和类型的歧义*'
- en: 'In this example, `Jabberwock` the `struct` and `Jabberwock` the function now
    live together in frabjous harmony. By placing each element in its own `namespace`—the
    `struct` in the `Creature` namespace ➊ and the function in the `Func` namespace
    ➋—you can disambiguate which Jabberwock you mean. You can do such disambiguation
    in several ways. The simplest is to qualify the name with its `namespace`, for
    example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Jabberwock`结构体和`Jabberwock`函数现在和谐共存。通过将每个元素放置在自己的`namespace`中——结构体放在`Creature`命名空间
    ➊，函数放在`Func`命名空间 ➋——你就能消除歧义，明确你指的是哪个Jabberwock。你可以通过几种方式来消除歧义。最简单的方法是用它的`namespace`来限定名称，例如：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can also employ a `using` directive to import all the names in a `namespace`,
    so you’d no longer need to use the fully qualified element name. [Listing 12](anoverture.xhtml#anovertureex12)
    uses the `Creature` `namespace`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`using`指令导入`namespace`中的所有名称，这样你就不再需要使用完全限定的元素名称了。[列表 12](anoverture.xhtml#anovertureex12)使用了`Creature`命名空间。
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*Listing 12: Employing `using namespace` to refer to a type within the `Creature`
    namespace*'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 12：使用`using namespace`来引用`Creature`命名空间中的类型*'
- en: The `using namespace` ➊ enables you to omit the `namespace` qualification ➋.
    But you still need a qualifier on `Func::Jabberwock`, because it isn’t part of
    the `Creature` `namespace`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`using namespace` ➊使你能够省略`namespace`限定符 ➋。但你仍然需要在`Func::Jabberwock`前加上限定符，因为它不属于`Creature`命名空间。'
- en: Use of a `namespace` is idiomatic C++ and is a zero-overhead abstraction. Just
    like the rest of a type’s identifiers, the `namespace` is erased by the compiler
    when emitting assembly code. In large projects, it’s incredibly helpful for separating
    code in different libraries.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`namespace`是C++的惯用法，是一种零开销的抽象。就像类型的其他标识符一样，`namespace`在编译器生成汇编代码时会被去除。在大型项目中，它对于将不同库的代码进行分离非常有帮助。
- en: '***Intermingling C and C++ Object Files***'
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***C和C++目标文件的混合使用***'
- en: C and C++ code can coexist peacefully if you’re careful. Sometimes, it’s necessary
    for a C compiler to link object files emitted by a C++ compiler (and vice versa).
    Although this is possible, it requires a bit of work.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你小心操作，C和C++代码是可以和平共存的。有时，C编译器需要链接由C++编译器生成的目标文件（反之亦然）。虽然这是可能的，但需要一些额外的工作。
- en: Two issues are related to linking the files. First, the calling conventions
    in the C and C++ code could potentially be mismatched. For example, the protocols
    for how the stack and registers are set when you call a function could be different.
    These calling conventions are language-level mismatches and aren’t generally related
    to how you’ve written your functions. Second, C++ compilers emit different symbols
    than C compilers do. Sometimes the linker must identify an object by name. C++
    compilers assist by decorating the object, associating a string called a *decorated
    name* with the object. Because of function overloads, calling conventions, and
    `namespace` usage, the compiler must encode additional information about a function
    beyond just its name through decoration. This is done to ensure that the linker
    can uniquely identify the function. Unfortunately, there is no standard for how
    this decoration occurs in C++ (which is why you should use the same tool chain
    and settings when linking between translation units). C linkers know nothing about
    C++ name decoration, which can cause problems if decoration isn’t suppressed whenever
    you link against C code within C++ (and vice versa).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个问题与链接文件相关。首先，C 和 C++ 代码中的调用约定可能不匹配。例如，调用函数时堆栈和寄存器的设置协议可能不同。这些调用约定是语言级别的不匹配，通常与函数的编写方式无关。其次，C++
    编译器生成的符号与 C 编译器不同。有时，链接器必须通过名称识别一个对象。C++ 编译器通过修饰对象，将一个名为 *修饰名* 的字符串与对象关联，来提供帮助。由于函数重载、调用约定和
    `namespace` 的使用，编译器必须通过装饰对函数进行额外的信息编码，而不仅仅是它的名称。这是为了确保链接器能够唯一地识别该函数。不幸的是，C++ 中关于如何进行修饰没有标准（这就是为什么在链接翻译单元时，你应该使用相同的工具链和设置）。C
    链接器不了解 C++ 名称修饰，如果在 C++ 中链接 C 代码时没有抑制修饰（反之亦然），这可能会引发问题。
- en: The fix is simple. You wrap the code you want to compile with C-style linkages
    using the statement `extern "C"`, as in [Listing 13](anoverture.xhtml#anovertureex13).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方法很简单。你只需使用 `extern "C"` 语句包裹你希望以 C 风格链接的代码，如[清单 13](anoverture.xhtml#anovertureex13)所示。
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Listing 13: Employing C-style linkage*'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 13：使用 C 风格链接*'
- en: This header can be shared between C and C++ code. It works because `__cplusplus`
    is a special identifier that the C++ compiler defines (but the C compiler doesn’t).
    Accordingly, the C compiler sees the code in [Listing 14](anoverture.xhtml#anovertureex14)
    after preprocessing completes. [Listing 14](anoverture.xhtml#anovertureex14) illustrates
    the code that remains.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个头文件可以在 C 和 C++ 代码之间共享。之所以可行，是因为 `__cplusplus` 是一个 C++ 编译器定义的特殊标识符（但 C 编译器没有定义）。因此，C
    编译器在预处理完成后会看到[清单 14](anoverture.xhtml#anovertureex14)中的代码。[清单 14](anoverture.xhtml#anovertureex14)
    显示了剩余的代码。
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Listing 14: The code remaining after the preprocessor processes [Listing 13](anoverture.xhtml#anovertureex13)
    in a C environment*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 14：在 C 环境中，预处理器处理[清单 13](anoverture.xhtml#anovertureex13)后剩下的代码*'
- en: This is just a simple C header. The code between the `#ifdef __cplusplus` statements
    is removed during preprocessing, so the `extern "C"` wrapper isn’t visible. For
    the C++ compiler, `__cplusplus` *is* defined in `header.h`, so it sees the contents
    of [Listing 15](anoverture.xhtml#anovertureex15).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的 C 头文件。在预处理过程中，`#ifdef __cplusplus` 语句之间的代码会被移除，因此 `extern "C"` 包裹器不可见。对于
    C++ 编译器，`__cplusplus` *在* `header.h` 中定义，因此它会看到[清单 15](anoverture.xhtml#anovertureex15)的内容。
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '*Listing 15: The code remaining after the preprocessor processes [Listing 13](anoverture.xhtml#anovertureex13)
    in a C++ environment*'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*清单 15：在 C++ 环境中，预处理器处理[清单 13](anoverture.xhtml#anovertureex13)后剩下的代码*'
- en: Both `extract_arkenstone` and `MistyMountains` are now wrapped with `extern
    "C"`, so the compiler knows to use C linkage. Now your C source can call into
    compiled C++ code, and your C++ source can call into compiled C code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `extract_arkenstone` 和 `MistyMountains` 都已用 `extern "C"` 包裹，因此编译器知道使用 C 链接。现在你的
    C 源代码可以调用已编译的 C++ 代码，你的 C++ 源代码也可以调用已编译的 C 代码。
- en: '**C++ Themes**'
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**C++ 主题**'
- en: This section takes you on a brief tour of some core themes that make C++ the
    premier system-programming language. Don’t worry too much about the details. The
    point of the following subsections is to whet your appetite.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将简要介绍一些使 C++ 成为首选系统编程语言的核心主题。无需过于担心细节。以下小节的重点是激发你的兴趣。
- en: '***Expressing Ideas Concisely and Reusing Code***'
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***简洁表达思想和重用代码***'
- en: 'Well-crafted C++ code has an elegant, compact quality. Consider the evolution
    from ANSI-C to modern C++ in the following simple operation: looping over some
    array `v` with `n` elements, as [Listing 16](anoverture.xhtml#anovertureex16)
    illustrates.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 精心编写的 C++ 代码具有优雅和紧凑的特质。考虑以下简单操作，从 ANSI-C 到现代 C++ 的演变：遍历一个包含 `n` 个元素的数组 `v`，正如
    [列表 16](anoverture.xhtml#anovertureex16) 所示。
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Listing 16: A program illustrating several ways to iterate over an array*'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 16：一个展示多种方式遍历数组的程序*'
- en: This code snippet shows the different ways to declare loops in ANSI-C, C99,
    and C++. The index variable `i` in the ANSI-C ➊ and C99 ➋ examples are ancillary
    to what you’re trying to accomplish, which is to access each element of `v`. The
    C++ version ➌ utilizes a *range-based* `for` loop, which loops over in the range
    of values in `v` while hiding the details of how iteration is achieved. Like a
    lot of the zero-overhead abstractions in C++, this construct enables you to focus
    on meaning rather than syntax. Range-based `for` loops work with many types, and
    you can even make them work with user-defined types.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段展示了在 ANSI-C、C99 和 C++ 中声明循环的不同方式。在 ANSI-C ➊ 和 C99 ➋ 示例中，索引变量 `i` 对你要完成的任务没有直接帮助，你要做的是访问
    `v` 中的每个元素。C++ 版本 ➌ 使用了 *基于范围* 的 `for` 循环，它遍历 `v` 中的值范围，同时隐藏了迭代如何实现的细节。像 C++ 中许多零开销抽象一样，这种构造让你可以专注于意义而不是语法。基于范围的
    `for` 循环可以与许多类型一起使用，甚至可以让它们与用户定义的类型一起工作。
- en: 'Speaking of user-defined types, they allow you to express ideas directly in
    code. Suppose you want to design a function, `navigate_to`, that tells a hypothetical
    robot to navigate to some position given x and y coordinates. Consider the following
    prototype function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 说到用户定义类型，它们允许你直接在代码中表达思想。假设你想设计一个名为`navigate_to`的函数，告诉一个假设的机器人根据 x 和 y 坐标导航到某个位置。请看下面的原型函数：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What are `x` and `y`? What are their units? Your user must read the documentation
    (or possibly the source) to find out. Compare the following improved prototype:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`x` 和 `y` 是什么？它们的单位是什么？用户必须阅读文档（或可能是源代码）才能弄清楚。比较以下改进后的原型：'
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function is far clearer. There is no ambiguity about what `navigate_to`
    accepts. As long as you have a validly constructed `Position`, you know exactly
    how to call `navigate_to`. Worrying about units, conversions, and so on is now
    the responsibility of whoever constructs the `Position` class.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数要清晰得多。关于 `navigate_to` 接受什么参数没有任何模糊之处。只要你有一个有效构造的 `Position`，你就知道该如何调用 `navigate_to`。关于单位、转换等的担忧现在归构造
    `Position` 类的人员负责。
- en: You can also come close to this clarity in C99/C11 using a `const` pointer,
    but C++ also makes return types compact and expressive. Suppose you want to write
    a corollary function for the robot called `get_position` that—you guessed it—gets
    the position. In C, you have two options, as shown in [Listing 17](anoverture.xhtml#anovertureex17).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `const` 指针在 C99/C11 中接近这种清晰度，但 C++ 也使返回类型紧凑且富有表现力。假设你想为机器人写一个名为 `get_position`
    的附属函数，顾名思义，它获取位置。在 C 中，你有两种选择，如 [列表 17](anoverture.xhtml#anovertureex17) 所示。
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Listing 17: A C-style API for returning a user-defined type*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 17：返回用户定义类型的 C 风格 API*'
- en: 'In the first option, the caller is responsible for cleaning up the return value
    ➊, which has probably incurred a dynamic allocation (although this is unclear
    from the code). The caller is responsible for allocating a `Position` somewhere
    and passing it into `get_position` ➋. This latter approach is more idiomatic C-style,
    but the language is getting in the way: you’re just trying to get a position object,
    but you have to worry about whether the caller or the called function is responsible
    for allocating and deallocating memory. C++ lets you do all of this succinctly
    by returning user-defined types directly from functions, as shown in [Listing
    18](anoverture.xhtml#anovertureex18).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个选项中，调用者负责清理返回值 ➊，它可能已经进行了动态分配（尽管从代码中无法看出）。调用者负责在某个地方分配一个 `Position` 并将其传递给
    `get_position` ➋。这种方式更符合 C 风格，但语言却成了障碍：你只是想获取一个位置对象，却不得不担心是调用者还是被调用函数负责分配和释放内存。C++
    让你通过直接从函数返回用户定义的类型来简洁地完成所有这些操作，正如 [列表 18](anoverture.xhtml#anovertureex18) 所示。
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*Listing 18: Returning a user-defined type by value in C++*'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 18：在 C++ 中按值返回用户定义类型*'
- en: Because `get_position` returns a value ➊, the compiler can *elide the copy*,
    so it’s as if you’ve constructed an automatic `Position` variable directly ➋;
    there’s no runtime overhead. Functionally, you’re in very similar territory to
    the C-style pass by reference of [Listing 17](anoverture.xhtml#anovertureex17).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`get_position`返回一个值➊，编译器可以*省略复制*，所以就像是你直接构造了一个自动的`Position`变量➋；没有运行时开销。从功能上讲，你实际上处于类似于C风格通过引用传递的[示例
    17](anoverture.xhtml#anovertureex17)的情况。
- en: '***The C++ Standard Library***'
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***C++ 标准库***'
- en: The C++ Standard Library (stdlib) is a major reason for migrating from C. It
    contains high-performance, generic code that is guaranteed to be available right
    out of the standards-conforming box. The three broad components of the stdlib
    are containers, iterators, and algorithms.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: C++标准库（stdlib）是从C迁移的重要原因之一。它包含高性能的通用代码，并且保证在符合标准的环境中立即可用。stdlib的三个主要组件是容器、迭代器和算法。
- en: '*Containers* are the data structures. They’re responsible for holding sequences
    of objects. They’re correct, safe, and (usually) at least as efficient as what
    you could accomplish manually, meaning that writing your own versions of these
    containers would take great effort and wouldn’t turn out better than the stdlib
    containers. Containers are neatly partitioned into two categories: *sequence containers*
    and *associative containers*. The sequence containers are conceptually similar
    to arrays; they provide accesses to sequences of elements. Associative containers
    contain key/value pairs, so elements in the containers can be looked up by key.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*容器*是数据结构。它们负责存储对象序列。它们是正确、安全的，并且（通常）至少和你手动实现的效率相当，这意味着写你自己的这些容器版本将需要巨大努力，而且不可能比stdlib容器更好。容器被清晰地分为两大类：*顺序容器*和*关联容器*。顺序容器在概念上类似于数组；它们提供对元素序列的访问。关联容器包含键/值对，因此容器中的元素可以通过键查找。'
- en: The stdlib *algorithms* are general-purpose functions for common programming
    tasks, such as counting, searching, sorting, and transforming. Much like containers,
    the stdlib algorithms are extremely high quality and broadly applicable. Users
    should very rarely have to implement their own version, and using the stdlib algorithms
    greatly increases programmer productivity, code safety, and readability.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: stdlib的*算法*是用于常见编程任务的通用函数，例如计数、查找、排序和转换。就像容器一样，stdlib算法质量极高，并且适用范围广泛。用户通常不需要实现自己的版本，使用stdlib算法能大大提高程序员的生产力、代码安全性和可读性。
- en: '*Iterators* connect containers with algorithms. For many stdlib algorithm applications,
    the data you want to operate on resides in a container. Containers expose iterators
    to provide an even, common interface, and the algorithms consume the iterators,
    keeping programmers (including the implementers of the stdlib) from having to
    implement a custom algorithm for each container type.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*迭代器*将容器与算法连接起来。对于许多stdlib算法应用，您想操作的数据通常存储在容器中。容器暴露迭代器以提供一个统一的接口，算法则消费这些迭代器，避免程序员（包括stdlib的实现者）为每种容器类型实现自定义算法。'
- en: '[Listing 19](anoverture.xhtml#anovertureex19) shows how to sort a container
    of values using a few lines of code.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 19](anoverture.xhtml#anovertureex19)展示了如何使用几行代码对值容器进行排序。'
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '*Listing 19: Sorting a container of values using the stdlib*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 19：使用stdlib对值容器进行排序*'
- en: A good amount of computation is going on in the background, yet the code is
    compact and expressive. First, you initialize a `std::vector` container ➊. *Vectors*
    are the stdlib’s dynamically sized arrays. The *initializer braces* (the `{0,
    1, ...}`) set the initial values contained in `x`. You can access the elements
    of a `vector` just like the elements of an array using brackets (`[]`) and the
    index number. You use this technique to set the first element equal to `21` ➋.
    Because `vector` arrays are dynamically sized, you can append values to them using
    the `push_back` method ➌. The seemingly magical invocation of `std::sort` showcases
    the power of the algorithms in stdlib ➍. The methods `x.begin()` and `x.end()`
    return iterators that `std::sort` uses to sort `x` in place. The `sort` algorithm
    is decoupled from `vector` through the use of iterators.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 背后有大量计算在进行，但代码简洁且富有表现力。首先，你初始化了一个 `std::vector` 容器 ➊。*向量（Vector）*是标准库中的动态数组。*初始化括号*（`{0,
    1, ...}`）设置了 `x` 中包含的初始值。你可以像访问数组元素一样，通过括号（`[]`）和索引号访问 `vector` 中的元素。你用这种方法将第一个元素设置为
    `21` ➋。因为 `vector` 数组是动态大小的，你可以使用 `push_back` 方法向其中添加元素 ➌。`std::sort` 的神奇调用展示了标准库算法的强大功能
    ➍。`x.begin()` 和 `x.end()` 方法返回的迭代器被 `std::sort` 用来就地排序 `x`。`sort` 算法通过使用迭代器与 `vector`
    解耦。
- en: Thanks to iterators, you can use other containers in stdlib similarly. For example,
    you could use a `list` (the stdlib’s doubly linked list) rather than using a `vector`.
    Because `list` also exposes iterators through `.begin()` and `.end()` methods,
    you could call `sort` on the list iterators in the same way.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 得益于迭代器，你可以类似地使用标准库中的其他容器。例如，你可以使用 `list`（标准库中的双向链表）而不是使用 `vector`。因为 `list`
    也通过 `.begin()` 和 `.end()` 方法暴露了迭代器，你可以像对待 `vector` 迭代器一样对 `list` 迭代器调用 `sort`。
- en: Additionally, [Listing 19](anoverture.xhtml#anovertureex19) uses iostreams.
    *Iostreams* are the stdlib’s mechanism for performing buffered input and output.
    You use the put-to operator (`<<`) to stream the value of `x.size()` (the number
    of elements in `x`), some string literals, and the Fibonacci element `number`
    to `std::cout`, which encapsulates stdout ➎ ➏. The `std::endl` object is an I/O
    manipulator that writes `\n` and flushes the buffer, ensuring that the entire
    stream is written to stdout before executing the next instruction.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，[清单 19](anoverture.xhtml#anovertureex19)使用了输入输出流（iostreams）。*输入输出流*是标准库用于执行缓冲输入输出的机制。你使用输出运算符
    (`<<`) 将 `x.size()`（`x` 中元素的数量）、一些字符串字面量和斐波那契数列元素 `number` 流式传输到 `std::cout`，它封装了标准输出流
    ➎ ➏。`std::endl` 对象是一个输入输出操控符，它会写入 `\n` 并刷新缓冲区，确保整个流在执行下一条指令之前被写入标准输出。
- en: Now, just imagine all the hoops you’d have to jump through to write an equivalent
    program in C, and you’ll see why the stdlib is such a valuable tool.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下你需要跳过多少环节才能用 C 语言写出一个等效的程序，你就会明白为什么标准库（stdlib）是如此有价值的工具。
- en: '***Lambdas***'
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***Lambda 表达式***'
- en: '*Lambdas*, also called *unnamed* or *anonymous functions* in some circles,
    are another powerful language feature that improve the locality of code. In some
    cases, you should pass pointers to functions to use a pointer as the target of
    a newly created thread or to perform some transformation on each element of a
    sequence. It’s generally inconvenient to define a one-time-use free function.
    That’s where lambdas come in. A lambda is a new, custom function *defined inline
    with the other parameters of an invocation*. Consider the following one-liner,
    which computes the count of even numbers in `x`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*Lambda 表达式*，在某些圈子里也被称为*匿名函数*，是另一种强大的语言特性，它提升了代码的局部性。在某些情况下，你需要将指针传递给函数，以便将指针作为新创建线程的目标，或者对序列中的每个元素执行某种变换。定义一个一次性使用的自由函数通常不方便。这时，Lambda
    表达式就派上用场了。Lambda 表达式是一个新的、与调用参数同行定义的自定义函数。考虑下面这个一行代码，它计算 `x` 中偶数的数量：'
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This snippet uses the stdlib’s `count_if` algorithm to count the even numbers
    in `x`. The first two arguments to `std::count_if` match `std::sort`; they’re
    the iterators that define the range over which the algorithm will operate. The
    third argument is the lambda. The notation probably looks a bit foreign, but the
    basics are quite simple:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段使用了标准库的 `count_if` 算法来计算 `x` 中偶数的数量。`std::count_if` 的前两个参数与 `std::sort`
    相同；它们是定义算法操作范围的迭代器。第三个参数是 lambda 表达式。这个语法可能看起来有点陌生，但基础知识其实非常简单：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '*Capture* contains any objects you need from the scope where the lambda is
    defined to perform computation in the body. *Arguments* define the names and types
    of arguments the lambda expects to be invoked with. The *body* contains any computation
    that you want completed upon invocation. It might or might not return a value.
    The compiler will deduce the function prototype based on the types you’ve implied.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*捕获*包含了你需要从lambda定义的作用域中获取的对象，用于在函数体内进行计算。*参数*定义了lambda预期被调用时所接受的参数名称和类型。*函数体*包含了你希望在调用时完成的计算。它可能会返回值，也可能不会。编译器会根据你暗示的类型推导出函数的原型。'
- en: In the `std::count_if` invocation above, the lambda didn’t need to capture any
    variables. All the information it needs is taken as a single argument `number`.
    Because the compiler knows the type of the elements contained in `x`, you declare
    the type of `number` with `auto` so the compiler can deduce it for you. The lambda
    is invoked with each element of `x` passed in as the `number` parameter. In the
    body, the lambda returns `true` only when `number` is divisible by `2`, so only
    the even numbers are included in the count.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的`std::count_if`调用中，lambda不需要捕获任何变量。它所需的所有信息都作为一个单独的参数`number`传入。因为编译器知道`x`中包含元素的类型，所以你用`auto`声明`number`的类型，编译器会为你推导出类型。lambda会被调用，并将`x`中的每个元素作为`number`参数传入。在函数体内，当`number`能被`2`整除时，lambda才返回`true`，因此只有偶数会被计入。
- en: Lambdas don’t exist in C, and it’s not really possible to reconstruct them.
    You’d need to declare a separate function each time you need a function object,
    and it’s not possible to capture objects into a function in the same way.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda在C语言中不存在，实际上也不可能重建它们。每次需要一个函数对象时，你必须声明一个单独的函数，而且无法像在其他语言中那样将对象捕获到函数中。
- en: '***Generic Programming with Templates***'
  id: totrans-131
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***使用模板的通用编程***'
- en: '*Generic programming* is writing code once that works with different types
    rather than having to repeat the same code multiple times by copying and pasting
    each type you want to support. In C++, you use *templates* to produce generic
    code. Templates are a special kind of parameter that tells the compiler to represent
    a wide range of possible types.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '*通用编程*是编写一次代码，使其能与不同的类型一起工作，而不必通过复制和粘贴每种你希望支持的类型来多次重复相同的代码。在C++中，你使用*模板*来生成通用代码。模板是一种特殊的参数，它告诉编译器表示多种可能类型。'
- en: 'You’ve already used templates: all of the stdlib’s containers use templates.
    For the most part, the type of the objects in these containers doesn’t matter.
    For example, the logic for determining the number of elements in a container or
    returning its first element doesn’t depend on the element’s type.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用过模板：stdlib中的所有容器都使用模板。在大多数情况下，这些容器中对象的类型并不重要。例如，判断容器中元素数量的逻辑或返回其第一个元素的逻辑并不依赖于元素的类型。
- en: Suppose you want to write a function that adds three numbers of the same type.
    You want to accept any addable type. In C++, this is a straight-forward generic
    programming problem that you can solve directly with templates, as [Listing 20](anoverture.xhtml#anovertureex20)
    illustrates.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想编写一个函数来加和三个相同类型的数字。你希望接受任何可加的类型。在C++中，这是一个直接的通用编程问题，你可以通过模板直接解决，就像[示例 20](anoverture.xhtml#anovertureex20)所示。
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*Listing 20: Using templates to create a generic `add` function*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 20：使用模板创建通用的`add`函数*'
- en: When you declare `add` ➊, you don’t need to know `T`. You only need to know
    that all the arguments and the return value are of type `T` and that `T` is addable.
    When the compiler encounters `add` being called, it deduces `T` and generates
    a bespoke function on your behalf. That’s some serious code reuse!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明`add` ➊时，你不需要知道`T`。你只需要知道所有的参数和返回值都是`T`类型，并且`T`是可加的。当编译器遇到`add`被调用时，它会推导出`T`并为你生成一个定制的函数。这就是一种真正的代码重用！
- en: '***Class Invariants and Resource Management***'
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***类不变式与资源管理***'
- en: Perhaps the single greatest innovation C++ brings to system programming is the
    *object life cycle*. This concept has its roots in C, where objects have different
    storage durations depending on how you declare them in your code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 也许C++带给系统编程的最大创新是*对象生命周期*。这个概念源自C语言，在C语言中，根据对象在代码中的声明方式，对象具有不同的存储持续时间。
- en: C++ builds on top of this memory management model with constructors and destructors.
    These special functions are methods that belong to *user-defined types*. User-defined
    types are the basic building blocks of C++ applications. Think of them as `struct`
    objects that can also have functions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: C++ 在此内存管理模型的基础上，提供了构造函数和析构函数。这些特殊函数是属于 *用户定义类型* 的方法。用户定义类型是 C++ 应用程序的基本构建块。可以将它们视为可以包含函数的
    `struct` 对象。
- en: An object’s constructor is called just after its storage duration begins, and
    the destructor is called just before its storage duration ends. Both the constructor
    and destructor are functions with no return type and the same name as the enclosing
    class. To declare a destructor, add a `~` to the beginning of the class name,
    as [Listing 21](anoverture.xhtml#anovertureex21) illustrates.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的构造函数在其存储持续时间开始后立即调用，析构函数在其存储持续时间结束前立即调用。构造函数和析构函数都是没有返回类型的函数，且名称与封闭类相同。要声明析构函数，可以在类名的开头加上
    `~`，正如 [列表 21](anoverture.xhtml#anovertureex21) 所示。
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*Listing 21: A `Hal` class containing a constructor and a destructor*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 21：包含构造函数和析构函数的 `Hal` 类*'
- en: The first method in `Hal` is the *constructor* ➊. It sets up the `Hal` object
    and establishes its *class invariants*. Invariants are features of a class that
    don’t change once they’ve been constructed. With some help from the compiler and
    the runtime, the programmer decides what the invariants of a class are and ensures
    that their code enforces them. In this case, the constructor sets the `version`,
    which is an invariant, to `9000`. The *destructor* is the second method ➋. Whenever
    `Hal` is about to be deallocated, it prints `"Stop, Dave."` to the console. (Getting
    `Hal` to sing “Daisy Bell” is left as an exercise to the reader.)
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hal` 类中的第一个方法是 *构造函数* ➊。它设置 `Hal` 对象并建立其 *类不变量*。不变量是类的特性，一旦构造完成便不会改变。借助编译器和运行时的帮助，程序员决定类的不变量是什么，并确保代码强制执行这些不变量。在这种情况下，构造函数将不变量
    `version` 设置为 `9000`。*析构函数* 是第二个方法 ➋。每当 `Hal` 即将被释放时，它会在控制台上打印 `"Stop, Dave."`（让
    `Hal` 唱“Daisy Bell”留给读者作为练习）。'
- en: The compiler makes sure the constructor and destructor are invoked automatically
    for objects with static, local, and thread local storage duration. For objects
    with dynamic storage duration, you use the keywords `new` and `delete` to replace
    `malloc` and `free`, [Listing 22](anoverture.xhtml#anovertureex22) illustrates.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器确保对于具有静态、局部和线程局部存储持续时间的对象，构造函数和析构函数会自动调用。对于具有动态存储持续时间的对象，您需要使用关键字 `new` 和
    `delete` 来替代 `malloc` 和 `free`，[列表 22](anoverture.xhtml#anovertureex22) 做了说明。
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '*Listing 22: A program that creates and destroys a `Hal` object*'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 22：创建和销毁 `Hal` 对象的程序*'
- en: If (for whatever reason) the constructor is unable to achieve a good state,
    it typically throws an *exception*. As a C programmer, you might have dealt with
    exceptions when programming with some operating system APIs (for example, Windows
    Structured Exception Handling). When an exception is thrown, the stack unwinds
    until an exception handler is found, at which point the program recovers. Judicious
    use of exceptions can clean up code because you only have to check for error conditions
    where it makes sense to do so. C++ has language-level support for exceptions,
    as [Listing 23](anoverture.xhtml#anovertureex23) illustrates.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果（无论出于何种原因）构造函数无法使对象达到良好状态，它通常会抛出一个 *异常*。作为 C 程序员，您可能在使用某些操作系统 API（例如，Windows
    结构化异常处理）时处理过异常。当抛出异常时，栈会被展开，直到找到一个异常处理器，程序在此时会恢复。合理使用异常可以清理代码，因为您只需要在合适的地方检查错误条件。C++
    对异常提供了语言级的支持，正如 [列表 23](anoverture.xhtml#anovertureex23) 所示。
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '*Listing 23: A `try`-`catch` block*'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 23：`try`-`catch` 块*'
- en: You can put your code that might throw an exception in the block immediately
    following `try` ➊. If at any point an exception is thrown, the stack will unwind
    (graciously destructing any objects that go out of scope) and run any code that
    you’ve put after the `catch` expression ➋. If no exception is thrown, this `catch`
    code never executes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将可能抛出异常的代码放在 `try` 语句后面的代码块中 ➊。如果在任何时候抛出异常，栈将展开（优雅地销毁任何超出作用域的对象），并运行您在 `catch`
    表达式后面放置的代码 ➋。如果没有抛出异常，则此 `catch` 代码不会执行。
- en: Constructors, destructors, and exceptions are closely related to another core
    C++ theme, which is tying an object’s life cycle to the resources it owns. This
    is the resource allocation is initialization (RAII) concept (sometimes also called
    *constructor acquires, destructor releases*). Consider the C++ class in [Listing
    24](anoverture.xhtml#anovertureex24).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数、析构函数和异常与C++的另一个核心主题密切相关，那就是将对象的生命周期与它所拥有的资源绑定。这就是资源分配即初始化（RAII）概念（有时也叫做*构造函数获取，析构函数释放*）。考虑[列表
    24](anoverture.xhtml#anovertureex24)中的C++类。
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '*Listing 24: A `File` class*'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 24：一个`File`类*'
- en: 'The constructor of `File` ➊ takes two arguments. The first argument corresponds
    with the `path` of the file, and the second is a `bool` corresponding to whether
    the file mode should be open for write (`true`) or read (`false`). This argument’s
    value sets `file_mode` ➋ via the *ternary operator* `? :`. The ternary operator
    evaluates a Boolean expression and returns one of two values depending on the
    Boolean value. For example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`File`的构造函数➊接受两个参数。第一个参数与文件的`path`相对应，第二个参数是一个`bool`，表示文件模式是应该以写模式（`true`）还是读模式（`false`）打开。这个参数的值通过*三元运算符*`?:`设置`file_mode`➋。三元运算符会评估一个布尔表达式，并根据布尔值返回两个值中的一个。例如：'
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If the Boolean expression `x` is `true`, the expression’s value is `val_if_true`.
    If `x` is `false`, the value is `val_if_false` instead.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果布尔表达式`x`为`true`，则表达式的值为`val_if_true`。如果`x`为`false`，则值为`val_if_false`。
- en: In the `File` constructor code snippet in [Listing 24](anoverture.xhtml#anovertureex24),
    the constructor attempts to open the file at `path` with read/write access ➌.
    If anything goes wrong, the call will set `file_pointer` to `nullptr`, a special
    C++ value that’s similar to 0\. When this happens, you throw a `system_error`
    ➍. A `system_error` is just an object that encapsulates the details of a system
    error. If `file_pointer` isn’t `nullptr`, it’s valid to use. That’s this class’s
    invariant.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 24](anoverture.xhtml#anovertureex24)中的`File`构造函数代码片段中，构造函数尝试以读/写访问权限打开位于`path`的文件
    ➌。如果出现任何问题，调用将把`file_pointer`设置为`nullptr`，这是C++中一个类似于0的特殊值。当发生这种情况时，你会抛出一个`system_error`
    ➍。`system_error`只是一个封装了系统错误详细信息的对象。如果`file_pointer`不是`nullptr`，那么它是有效的。这就是该类的不变量。
- en: Now consider the program in [Listing 25](anoverture.xhtml#anovertureex25), which
    employs `File`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑[列表 25](anoverture.xhtml#anovertureex25)中的程序，它使用了`File`。
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '*Listing 25: A program employing the `File` class*'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '*列表 25：一个使用`File`类的程序*'
- en: The braces ➊ ➌ define a scope. Because the first `file` resides within this
    scope, the scope defines the lifetime of `file`. Once the constructor returns
    ➋, you know that `file.file_pointer` is valid thanks to the class invariant; based
    on the design of the constructor of `File`, you know `file.file_pointer` must
    be valid for the lifetime of the `File` object. You write a message using `fwrite`.
    There’s no need to call `fclose` explicitly, because `file` expires and the destructor
    cleans up `file.file_pointer` for you ➌. You open `File` again but this time for
    read access ➍. As long as the constructor returns, you know that *last_message.txt*
    was opened successfully and continue on reading into `read_message`. After printing
    the message, the destructor of `file` is called, and the `file.file_pointer` is
    again cleaned up.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号 ➊ ➌ 定义了一个作用域。因为第一个`file`位于这个作用域内，作用域定义了`file`的生命周期。一旦构造函数返回➋，你就知道`file.file_pointer`是有效的，这要归功于类的不变量；根据`File`构造函数的设计，你知道`file.file_pointer`在`File`对象的生命周期内必须是有效的。你使用`fwrite`写入消息。无需显式调用`fclose`，因为`file`过期，析构函数会为你清理`file.file_pointer`➌。你再次打开`File`，但这次是为了读访问
    ➍。只要构造函数返回，你就知道*last_message.txt*已成功打开，并继续读取到`read_message`中。打印完消息后，`file`的析构函数被调用，`file.file_pointer`再次被清理。
- en: Sometimes you need the flexibility of dynamic memory allocation, but you still
    want to lean on the object life cycle of C++ to ensure that you don’t leak memory
    or accidentally “use after free.” This is exactly the role of *smart pointers*,
    which manage the life cycle of dynamic objects through an ownership model. Once
    no smart pointer owns a dynamic object, the object destructs.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要动态内存分配的灵活性，但仍希望依赖C++的对象生命周期，以确保不会泄漏内存或不小心出现“使用已释放内存”的问题。这正是*智能指针*的作用，它通过所有权模型管理动态对象的生命周期。一旦没有智能指针拥有某个动态对象，该对象会被销毁。
- en: One such smart pointer is `unique_ptr`, which models exclusive ownership. [Listing
    26](anoverture.xhtml#anovertureex26) illustrates its basic usage.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个智能指针是`unique_ptr`，它模拟了独占所有权。[列表 26](anoverture.xhtml#anovertureex26)展示了它的基本用法。
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '*Listing 26: A program employing a `unique_ptr`*'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 26：使用`unique_ptr`的程序*'
- en: You dynamically allocate a `Foundation`, and the resulting `Foundation*` pointer
    is passed into the constructor of `second_foundation` using the braced-initialization
    syntax ➊. The `second_foundation` has type `unique_ptr`, which is just an RAII
    object wrapping the dynamic `Foundation`. When `second_foundation` is destructed
    ➋, the dynamic `Foundation` destructs appropriately.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你动态分配了一个`Foundation`，并使用大括号初始化语法将得到的`Foundation*`指针传递给`second_foundation`的构造函数
    ➊。`second_foundation`的类型是`unique_ptr`，它只是一个RAII对象，包装了动态`Foundation`。当`second_foundation`被销毁时
    ➋，动态`Foundation`会被适当地销毁。
- en: Smart pointers differ from regular, *raw* pointers because a raw pointer is
    simply a memory address. You must orchestrate all the memory management that’s
    involved with the address manually. On the other hand, smart pointers handle all
    these messy details. By wrapping a dynamic object with a smart pointer, you can
    rest assured that memory will be cleaned up appropriately as soon as the object
    is no longer needed. The compiler knows that the object is no longer needed because
    the smart pointer’s destructor is called when it falls out of scope.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 智能指针与普通的*裸*指针不同，因为裸指针只是一个内存地址。你必须手动管理与地址相关的所有内存管理工作。另一方面，智能指针处理了所有这些繁琐的细节。通过将动态对象包装在智能指针中，你可以放心，当对象不再需要时，内存会被适当地清理。编译器知道对象不再需要，因为当智能指针超出作用域时，它的析构函数会被调用。
- en: '***Move Semantics***'
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '***移动语义***'
- en: Sometimes, you want to transfer ownership of an object; this comes up often,
    for example, with `unique_ptr`. You can’t copy a `unique_ptr`, because once one
    of the copies of the `unique_ptr` is destructed, the remaining `unique_ptr` would
    hold a reference to the deleted object. Rather than copying the object, you use
    the `move` semantics of C++ to transfer ownership from one unique pointer to another,
    as [Listing 27](anoverture.xhtml#anovertureex27) illustrates.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你想要转移一个对象的所有权；这在很多情况下都会遇到，例如使用`unique_ptr`时。你不能复制一个`unique_ptr`，因为一旦其中一个`unique_ptr`的副本被销毁，剩下的`unique_ptr`会持有对已删除对象的引用。与其复制对象，你可以利用C++的`move`语义将所有权从一个`unique_ptr`转移到另一个，如[示例
    27](anoverture.xhtml#anovertureex27)所示。
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '*Listing 27: A program moving a `unique_ptr`*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*示例 27：移动`unique_ptr`的程序*'
- en: As before, you create `unique_ptr<Foundation>` ➊. You use it for some time and
    then decide to transfer ownership to a `Mutant` object. The `move` function tells
    the compiler that you want to make the transfer. After constructing `the_mule`
    ➋, the lifetime of `Foundation` is tied to the lifetime of `the_mule` through
    its member variable.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，你创建了`unique_ptr<Foundation>` ➊。你使用它一段时间后，决定将所有权转移给`Mutant`对象。`move`函数告诉编译器你想进行转移。在构造`the_mule`
    ➋后，`Foundation`的生命周期通过它的成员变量与`the_mule`的生命周期关联。
- en: '**Relax and Enjoy Your Shoes**'
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '**放松并享受你的鞋子**'
- en: C++ is *the* premier system programming language. Much of your C knowledge will
    map directly into C++, but you’ll also learn many new concepts. You can start
    gradually incorporating C++ into your C programs using Super C. As you become
    competent in some of the deeper themes of C++, you’ll find that writing modern
    C++ brings with it many substantial advantages over C. You’ll be able to express
    ideas concisely in code, capitalize on the impressive stdlib to work at a higher
    level of abstraction, employ templates to improve runtime performance and code
    reuse, and lean on the C++ object life cycle to manage resources.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: C++是*最*优秀的系统编程语言。你在C语言中的大部分知识可以直接迁移到C++中，但你也将学习到许多新概念。你可以通过使用Super C逐步将C++融入到你的C程序中。当你掌握C++的一些深层主题后，你会发现写现代C++相比C带来了许多显著的优势。你将能够用简洁的代码表达思想，利用强大的标准库在更高的抽象层次上工作，使用模板来提高运行时性能和代码重用，并依赖C++的对象生命周期来管理资源。
- en: I expect that the investment you’ll make learning C++ will yield vast dividends.
    After reading this book, I think you’ll agree.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你在学习C++时所做的投资将带来巨大的回报。读完这本书后，我想你会同意这个观点。
