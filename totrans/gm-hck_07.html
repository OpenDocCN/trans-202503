<html><head></head><body>
<h2 class="h2c" id="ch05"><span epub:type="pagebreak" id="page_97"/><span class="big1"><strong>5</strong></span><br/><strong>ADVANCED MEMORY FORENSICS</strong></h2>&#13;
<div class="image"><img src="../images/common.jpg" alt="image"/></div>&#13;
<p class="noindent">Whether you hack games as a hobby or a business, you’ll eventually find yourself between a rock and . . . an unintelligible memory dump. Be it a race with a rival bot developer to release a highly requested feature, a battle against a game company’s constant barrage of updates, or a struggle to locate some complex data structure in memory, you’ll need top-notch memory forensics skills to prevail.</p>&#13;
<p class="indent">Successful bot development is precariously balanced atop speed and skill, and tenacious hackers must rise to the challenge by swiftly releasing ingenious features, promptly responding to game updates, and readily searching for even the most elusive pieces of data. Doing this, however, requires a comprehensive understanding of common memory patterns, advanced data structures, and the purpose of different pieces of data.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_98"/>Those three aspects of memory forensics are perhaps the most effective weapons in your arsenal, and this chapter will teach you how to use them. First, I’ll discuss advanced memory-scanning techniques that focus on searching for data by understanding its purpose and usage. Next, I’ll teach you how to use memory patterns to tackle game updates and tweak your bots without having to relocate all of your addresses from scratch. To wrap up, I’ll dissect the four most common complex data structures in the C++ standard library (<code>std::string</code>, <code>std::vector</code>, <code>std::list</code>, and <code>std::map</code>) so you can recognize them in memory and enumerate their contents. By the end of the chapter, my hope is that you’ll have a deep understanding of memory forensics and be able to take on any challenge related to memory scanning.</p>&#13;
<h3 class="h3" id="ch00lev1sec100"><strong>Advanced Memory Scanning</strong></h3>&#13;
<p class="noindent">Within a game’s source code, each piece of data has a cold, calculated definition. When the game is being played, however, all of that data comes together to create something new. Players only experience the beautiful scenery, visceral sounds, and intense adventures; the data that drives these experiences is irrelevant.</p>&#13;
<p class="indent">With that in mind, imagine Hacker A has just started tearing into his favorite game, wanting to automate some of the boring bits with a bot. He doesn’t have a complete understanding of memory yet, and to him, the data is nothing but assumptions. He thinks, “I have 500 health, so I can find the health address by telling Cheat Engine to look for a 4-byte integer with a value of 500.” Hacker A has an accurate understanding of data: it’s just information (values) stored at particular locations (addresses) using defined structures (types).</p>&#13;
<p class="indent">Now imagine Hacker B, who already understands the game both inside and out; she knows how playing the game alters its state in memory, and the data no longer has any secrets. She knows that every defined property of the data can be determined given its purpose. Unlike Hacker A, Hacker B has an understanding of data that transcends the confines of a single variable declaration: she considers the data’s <em>purpose</em> and <em>usage</em>. In this section, we’ll discuss both.</p>&#13;
<p class="indent">Each piece of data in a game has a purpose, and the assembly code of the game must, at some point, reference the data to fulfill that purpose. Finding the unique code that uses a piece of data means finding a version-agnostic marker that persists across game updates until the data is either removed or its purpose is changed. Let me show you why this is important.</p>&#13;
<h4 class="h4" id="ch00lev1sec101"><strong><em>Deducing Purpose</em></strong></h4>&#13;
<p class="noindent">So far, I’ve only shown you how to blindly search memory for a given piece of data without considering how it’s being used. This method can be effective, but it is not always efficient. In many cases, it’s much quicker to deduce the purpose of data, determine what code might use that data, and then locate that code to ultimately find the address of the data.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_99"/>This might not sound easy, but neither does “scan the game’s memory for a specific value of a specific data type, and then continuously filter the result list based on changing criteria,” which is what you’ve learned to do thus far. So let’s look at how we might locate the address for health given its purpose. Consider the code in <a href="ch05.xhtml#ch5exe1">Listing 5-1</a>.</p>&#13;
<pre>struct PlayerVital {<br/>    int current, maximum;<br/>};<br/>PlayerVital health;<br/>--<span class="codeitalic">snip</span>--<br/>printString("Health: %d of %d\n", health.current, health.maximum);</pre>&#13;
<p class="listt"><a id="ch5exe1"/><em>Listing 5-1: A structure containing the player’s vitals, and a function that displays them</em></p>&#13;
<p class="indent">If you pretend that <code>printString()</code> is a fancy function to draw text on an in-game interface, then this code is pretty close to what you might find in a game. The <code>PlayerVital</code> structure has two properties: the <code>current</code> value and a <code>maximum</code> value. The value <code>health</code> is a <code>PlayerVital</code> structure, so it has these properties, too. Based on the name alone, you can deduce that <code>health</code> exists to display information about the player’s health, and you can see this purpose fulfilled when <code>printString()</code> uses the data.</p>&#13;
<p class="indent">Even without the code, you can intuitively draw similar conclusions by just looking at the health text displayed in the game’s interface; a computer can’t do anything without code, after all. Aside from the actual <code>health</code> variable, there are a few code elements that need to exist to show a player this text. First, there needs to be some function to display text. Second, the strings <code>Health</code> and <code>of</code> must be nearby.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Why do I assume the text is split into two separate strings instead of one? The game interface shows that the current health value is between these two strings, but there are many ways that could happen, including format strings,</em> <code><span class="codeitalic">strcat(</code>)</span><em>, or text aligned with multiple display text calls. When you’re analyzing data, it’s best to keep your assumptions broad to account for all possibilities.</em></p>&#13;
</div>&#13;
<p class="indent">To find <code>health</code> without using a memory scanner, we could utilize these two distinct strings. We probably wouldn’t have a clue what the function to display text looks like, where it is, or how many times it’s called, though. Realistically, the strings are all we would know to look for, and that’s enough. Let’s walk through it.</p>&#13;
<h4 class="h4" id="ch00lev1sec102"><strong><em>Finding the Player’s Health with OllyDbg</em></strong></h4>&#13;
<p class="noindent">I’ll walk you through how to track down the <code>health</code> structure in this section, but I’ve also included the binary I analyze in the book’s resource files. To follow along and get some hands-on practice, use the file <em>Chapter5_AdvancedMemoryForensics_Scanning.exe</em>.</p>&#13;
<p class="indent">First, open OllyDbg and attach it to the executable. Then, open OllyDbg’s Executable modules window and double-click the main module; in my example, the main module is the only <em>.exe</em> in the module’s window. <span epub:type="pagebreak" id="page_100"/>The CPU window should pop up. Now, right-click in the Disassembler pane and select <strong>Search for</strong> <span class="ent">▸</span> <strong>All referenced text strings</strong>. This should open the References window, shown in <a href="ch05.xhtml#ch5fig1">Figure 5-1</a>.</p>&#13;
<div class="image"><img src="../images/f05-01.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch5fig1"/><em>Figure 5-1: OllyDbg’s References window, showing only a list of strings. There would be a lot more than four in a real game.</em></p>&#13;
<p class="indent">From this window, right-click and select <strong>Search for text</strong>. A search dialog appears. Enter the string you’re looking for, as shown in <a href="ch05.xhtml#ch5fig2">Figure 5-2</a>, and make the search as broad as possible by disabling <strong>Case sensitive</strong> and enabling <strong>Entire scope</strong>.</p>&#13;
<div class="image"><img src="../images/f05-02.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch5fig2"/><em>Figure 5-2: Searching for strings in OllyDbg</em></p>&#13;
<p class="indent">Click <strong>OK</strong> to execute the search. The References window comes back into focus with the first match highlighted. Double-click the match to see the assembly code that uses the string inside the CPU window. The Disassembler pane focuses on the line of code at 0x401030, which pushes the format string parameter to <code>printString()</code>. You can see this line in <a href="ch05.xhtml#ch5fig3">Figure 5-3</a>, where I’ve highlighted the entire function call block.</p>&#13;
<div class="image"><img src="../images/f05-03.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch5fig3"/><em>Figure 5-3: Viewing the <code>printString()</code> call in the CPU window’s Disassembler pane</em></p>&#13;
<p class="indent">By reading the assembly code, you can get a very accurate understanding of exactly what the game is doing. The black bracket on the left shows that the string <code>Health</code> is inside a function call. Notice the arguments to that <span epub:type="pagebreak" id="page_101"/>function. In order, these are EAX <span class="ent">➊</span>, ECX <span class="ent">➋</span>, and the format string at 0x4020D0 <span class="ent">➌</span>. EAX is the value at 0x40301C, ECX is the value at 0x403018, and the format string contains <code>Health</code>. Since the string contains two format placeholders, you can assume that the remaining two parameters are the arguments for those placeholders.</p>&#13;
<p class="indent">Knowing what the arguments are and that they are pushed in reverse order, you can work backward and conclude that the original code looked something like <a href="ch05.xhtml#ch5exe2">Listing 5-2</a>.</p>&#13;
<pre>int currentHealth; // value at 0x403018<br/>int maxHealth;     // value at 0x40301C<br/>--<span class="codeitalic">snip</span>--<br/>someFunction("Health: %d of %d\n",<br/>    currentHealth, maxHealth);</pre>&#13;
<p class="listt"><a id="ch5exe2"/><em>Listing 5-2: How a game hacker might interpret the assembly that <a href="ch05.xhtml#ch5fig3">Figure 5-3</a> compiles to</em></p>&#13;
<p class="indent">The values stored in EAX and ECX are adjacent in memory, which means they may be part of a structure. To keep it simple, though, this example just shows them as variable definitions. Either way, these are the two numbers used to display the player’s health. Because both of these important values were displayed in the game’s UI, it was easy to make assumptions about the underlying code that displays them. When you know the purpose of a piece of data, you can quickly find the code responsible for fulfilling it; in this case, that knowledge helped us quickly find both addresses.</p>&#13;
<p class="indent">In many cases, finding addresses can be this easy, but some pieces of data have such complex purposes that it’s harder to guess what to look for. Figuring out how to search for map data or character locations in OllyDbg, for instance, can be pretty tricky.</p>&#13;
<p class="indent">Strings are far from the only markers that you can use to find the data you want to change in a game, but they are definitely the easiest to teach without giving contrived examples. Moreover, some games have logging or error strings embedded in their code, and poking around in the Referenced text strings window of OllyDbg can be a quick way to determine whether these strings are present. If you become familiar with a game’s logging practices, you’ll be able to find values even more easily.</p>&#13;
<h4 class="h4" id="ch00lev1sec103"><strong><em>Determining New Addresses After Game Updates</em></strong></h4>&#13;
<p class="noindent">When application code is modified and recompiled, a brand-new binary that reflects the changes is produced. This binary might be very similar to the previous one, or the binaries might be nothing alike; the difference between the two versions has a direct correlation to the complexity of the high-level changes. Small changes, like modified strings or updated constants, can leave binaries nearly identical and often have no effect on the addresses of code or data. But more complex changes—like added features, a new user interface, refactored internals, or new in-game content—often cause shifts in the location of crucial memory.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><span epub:type="pagebreak" id="page_102"/><strong>AUTOMATICALLY FIND CURRENTHEALTH AND MAXHEALTH</strong></p>&#13;
<p class="noindent">In “<a href="ch01.xhtml#ch00lev1sec28">Searching for Assembly Patterns</a>” on <a href="ch01.xhtml#page_19">page 19</a> and “<a href="ch01.xhtml#ch00lev1sec29">Searching for Strings</a>” on <a href="ch01.xhtml#page_21">page 21</a>, I showed a few Cheat Engine Lua scripts and explained how they worked. Using the <code>findString()</code> function in these examples, you can make Cheat Engine automatically locate the address of the format string that we just found manually in OllyDbg. Next, you can write a small function to scan for this address following byte 0x68 (the byte for the <code>PUSH</code> command, as you can see beside it at 0x401030 in <a href="ch05.xhtml#ch5fig3">Figure 5-3</a>) to locate the address of the code that pushes it to the stack. Then, you can read 4 bytes from <code>pushAddress - 5</code> and <code>pushAddress - 12</code> to locate <code>currentHealth</code> and <code>maxHealth</code>, respectively.</p>&#13;
<p class="indent">This may not seem useful since we’ve already found the addresses, but if this were a real game, these addresses would change when an update is released. Using this knowledge to automate finding them can be very helpful. If you’re up to the challenge, give it a whirl!</p>&#13;
</div>&#13;
<p class="indent">Due to constant bug fixes, content improvements, and feature additions, online games are among the most rapidly evolving types of software. Some games release updates as often as once a week, and game hackers often spend a majority of their time reverse engineering the new binaries in order to accordingly update their bots.</p>&#13;
<p class="indent">If you create advanced bots, they will become increasingly supported by a foundation of memory addresses. When an update comes, determining the new addresses for a large number of values and functions is the most time-consuming inevitability you will face. Relying on the “<a href="ch05.xhtml#ch05sb01">Tips for Winning the Update Race</a>” can be very beneficial, but the tips won’t help you locate the updated addresses. You can automatically locate some addresses using Cheat Engine scripts, but that won’t always work either. Sometimes you’ll have to do the dirty work by hand.</p>&#13;
<p class="indent">If you try to reinvent the wheel and find these addresses the same way you did initially, you’ll be wasting your time. You actually have a big advantage, though: the old binary and the addresses themselves. Using these two things, it is possible to find every single address you need to update in a fraction of the time.</p>&#13;
<p class="indent"><a href="ch05.xhtml#ch5fig4">Figure 5-4</a> shows two different disassemblies: a new game binary on the left and the previous version on the right. I have taken this image from an actual game (which will remain nameless) in order to give you a realistic example.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_103"/><img src="../images/f05-04.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch5fig4"/><em>Figure 5-4: Side-by-side disassemblies of two versions of one game</em></p>&#13;
<p class="indent">My bot modified the code at 0x047B542 (right), and I needed to find the corresponding code in the new version, which I discovered at 0x047B672 (left). This function call invokes a packet-parsing function when a packet has been received. In order to find this address originally (and by “originally,” I mean about 100 updates previous), I figured out how the game’s network protocol worked, set breakpoints on many network-related API calls, stepped through execution, and inspected data on the stack until I found something that looked similar to what I expected given my knowledge of the protocol.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart" id="ch05sb01"><strong>TIPS FOR WINNING THE UPDATE RACE</strong></p>&#13;
<p class="noindentb">In saturated markets, being the first bot developer to release a stable update is critical to success. The race starts the second the game updates, and hackers determined to be the fastest will spend hundreds of hours preparing. These are the most common ways to stay on top:</p>&#13;
<p class="noindenth1"><strong>Create update alarms</strong> By writing software that alerts you as soon as the game patches, you can begin working on your updates as soon as possible.</p>&#13;
<p class="noindenth1"><strong>Automate bot installs</strong> Games often schedule expected updates at times when the fewest players are online. Botters hate waking up and downloading new software before they bot, but they love waking up to find it silently installed while the game is patching.</p>&#13;
<p class="noindenth1"><strong>Use fewer addresses</strong> The less there is to update, the better. Consolidating related data into structures and eliminating unnecessary memory address usage can save a bunch of time.</p>&#13;
<p class="noindenth1"><strong>Have great test cases</strong> Data changes, and hackers make mistakes. Having ways to quickly test every feature can be the difference between a stable bot and one that randomly crashes, gets users killed, or even leads to their characters being banned from the game.</p>&#13;
<p class="indentt">Attacking updates with these practices will give you a sizable head start, but they might not always be enough to lead you to victory. Above all else, strive to understand reverse engineering as much as possible and use that understanding to your advantage.</p>&#13;
</div>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_104"/>I could have followed the same steps for each of the 100+ updates since then, but that would have been unnecessary. The code stayed relatively the same throughout the years, which let me use patterns from the old code to find that function call’s address in the new code.</p>&#13;
<p class="indent">Now, consider this chunk of assembly code:</p>&#13;
<pre>PUSH EDI<br/>PUSH EAX <br/>LEA EAX,DWORD PTR SS:[EBP-C] <br/>MOV DWORD PTR FS:[0],EAX <br/>MOV DWORD PTR SS:[EBP-10],ESP <br/>MOV DWORD PTR SS:[EBP-220],-1 <br/>MOV DWORD PTR SS:[EBP-4],0</pre>&#13;
<p class="indent">Does it look familiar? Compare it to <a href="ch05.xhtml#ch5fig4">Figure 5-4</a>, and you’ll see that this exact code exists right above the highlighted function call in both versions of the game. Regardless of what it does, the combination of operations looks pretty distinctive; because of the number of different offsets the code is using relative to EBP, it’s unlikely that an identical chunk of code exists in any other part of the binary.</p>&#13;
<p class="indent">Every time I have to update this address, I open the old binary in OllyDbg, highlight this chunk of operations, right-click, and select Asm2Clipboard <span class="ent">▸</span> Copy fixed asm to clipboard. Then, I open the new binary in OllyDbg, navigate to the CPU Window, press <small>CTRL</small>-S, paste the assembly code, and hit Find. In 9.5 cases out of 10, this places me directly above the function call I need to find in the new version.</p>&#13;
<p class="indent">When an update comes, you can use the same method to find nearly all of your known addresses. It should work for every address you can find easily in assembly code. There are a few caveats, though:</p>&#13;
<p class="bull">• OllyDbg limits search to eight operations, so you must find code markers of that size or smaller.</p>&#13;
<p class="bull">• The operations you use cannot contain any other addresses, as those addresses have likely changed.</p>&#13;
<p class="bull">• If parts of the game have changed that use the address you’re looking for, the code might be different.</p>&#13;
<p class="bull">• If the game changes compilers or switches optimization settings, almost all code will be entirely different.</p>&#13;
<p class="indent">As discussed in “Automatically Find <code>currentHealth</code> and <code>maxHealth</code>” on <a href="ch05.xhtml#page_102">page 102</a>, you can benefit from writing scripts that carry out these tasks for you. Serious game hackers work very hard to automatically locate as many addresses as possible, and some of the best bots are engineered to automatically detect their addresses at runtime, every time. It can be a lot of work initially, but the investment can definitely pay off.</p>&#13;
<h3 class="h3" id="ch00lev1sec104"><span epub:type="pagebreak" id="page_105"/><strong>Identifying Complex Structures in Game Data</strong></h3>&#13;
<p class="noindent"><a href="ch04.xhtml#ch04">Chapter 4</a> described how a game might store data in static structures. This knowledge will suffice when you’re trying to find simple data, but it falls short for data that is stored through dynamic structures. This is because dynamic structures might be scattered across different memory locations, follow long pointer chains, or require complex algorithms to actually extract the data from them.</p>&#13;
<p class="indent">This section explores common dynamic structures you’ll find in video game code, and how to read data from them once they’re found. To begin, I’ll talk about the underlying composition of each dynamic structure. Next, I’ll outline the algorithms needed to read the data from these structures. (For simplicity, each algorithm discussion assumes you have a pointer to an instance of the structure as well as some way to read from memory.) Lastly, I’ll cover tips and tricks that can help you determine when a value you’re searching for in memory is actually encapsulated in one of these structures, so you’ll know when to apply this knowledge. I’ll focus on C++, as its object-oriented nature and heavily used standard library are typically responsible for such structures.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>Some of these structures might differ slightly from machine to machine based on compilers, optimization settings, or standard library implementations, but the basic concepts will remain the same. Also, in the interest of brevity, I will be omitting irrelevant parts of these structures, such as custom allocators or comparison functions. Working example code can be found at</em> <a href="https://www.nostarch.com/gamehacking/">https://www.nostarch.com/gamehacking/</a> <em>in the resource files for <a href="ch05.xhtml#ch05">Chapter 5</a>.</em></p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec105"><strong><em>The std::string Class</em></strong></h4>&#13;
<p class="noindent">Instances of <code>std::string</code> are among the most common culprits of dynamic storage. This class from the C++ Standard Template Library (STL) abstracts string operations away from the developer while preserving efficiency, making it widely used in all types of software. A video game might use <code>std::string</code> structure for any string data, such as creature names.</p>&#13;
<h5 class="h5" id="ch00lev1sec106"><strong>Examining the Structure of a std::string</strong></h5>&#13;
<p class="noindent">When you strip away the member functions and other nondata components of the <code>std::string</code> class, this is the structure that remains:</p>&#13;
<pre>class string {<br/>    union {<br/>        char* dataP;<br/>        char dataA[16];<br/>    };<br/>    int length;<br/>};<br/><br/>// point to a string in memory<br/>string* _str = (string*)stringAddress;</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_106"/>The class reserves 16 characters that are presumably used to store the string in place. It also, however, declares that the first 4 bytes can be a pointer to a character. This might seem odd, but it’s a result of optimization. At some point, the developers of this class decided that 15 characters (plus a null terminator) was a suitable length for many strings, and they chose to save on memory allocations and de-allocations by reserving 16 bytes of memory in advance. To accommodate longer strings, they allowed the first 4 bytes of this reserved memory to be used as a pointer to the characters of these longer strings.</p>&#13;
<div class="note">&#13;
<p class="notet"><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>If the code were compiled to 64 bits, then it would actually be the first 8 (not 4) bytes that point to a character. Throughout this example, however, you can assume 32-bit addresses and that</em> <code><span class="codeitalic">int</code></span> <em>is the size of an address.</em></p>&#13;
</div>&#13;
<p class="indent">Accessing string data this way takes some overhead. The function to locate the right buffer looks something like this:</p>&#13;
<pre>const char* c_str() {<br/>    if (_str-&gt;length &lt;= 15)<br/>        return (const char*)&amp;_str-&gt;dataA[0];<br/>    else<br/>        return (const char*)_str-&gt;dataP;<br/>}</pre>&#13;
<p class="indent">The fact that a <code>std::string</code> can be either a complete string or a pointer to a longer string makes this particular structure quite tricky from a game-hacking perspective. Some games may use <code>std::string</code> to store strings that only rarely exceed 15 characters. When this is the case, you might implement bots that rely on these strings, never knowing that the underlying structure is in fact more complicated than a simple string.</p>&#13;
<h5 class="h5" id="ch00lev1sec107"><strong>Overlooking a std::string Can Ruin Your Fun</strong></h5>&#13;
<p class="noindent">Not knowing the true nature of the structure containing the data you need can lead you to write a bot that works only some of the time and fails when it counts. Imagine, for example, that you’re trying to figure out how a game stores creature data. In your hypothetical search, you find that all the creatures in the game are stored in an array of structures that look something like <a href="ch05.xhtml#ch5exe3">Listing 5-3</a>.</p>&#13;
<pre>struct creatureInfo {<br/>    int uniqueID;<br/>    char name[16];<br/>    int nameLength;<br/>    int healthPercent;<br/>    int xPosition;<br/>    int yPosition;<br/>    int modelID;<br/><span epub:type="pagebreak" id="page_107"/><br/>    int creatureType;<br/>};</pre>&#13;
<p class="listt"><a id="ch5exe3"/><em>Listing 5-3: How you might interpret creature data found in memory</em></p>&#13;
<p class="indent">After scanning the creature data in memory, say you notice that the first 4 bytes of each structure are unique for each creature, so you call those bytes the <code>uniqueID</code> and assume they form a single <code>int</code> property. Looking further in the memory, you find that the creature’s <code>name</code> is stored right after <code>uniqueID</code>, and after some deduction, you figure out the name is 16 bytes long. The next value you see in memory turns out to be the <code>nameLength</code>; it’s a bit strange that a null-terminated string has an associated length, but you ignore that oddity and continue analyzing the data in memory. After further analysis, you determine what the remaining values are for, define the structure shown in <a href="ch05.xhtml#ch5exe3">Listing 5-3</a>, and write a bot that automatically attacks creatures with certain names.</p>&#13;
<p class="indent">After weeks of testing your bot while hunting creatures with names like <em>Dragon</em>, <em>Cyclops</em>, <em>Giant</em>, and <em>Hound</em>, you decide it’s time to give your bot to your friends. For the inaugural use, you gather everyone together to kill a boss named <em>Super Bossman Supreme</em>. The entire team sets the bot to attack the boss first and target lesser creatures like a <em>Demon</em> or <em>Grim Reaper</em> when the boss goes out of range.</p>&#13;
<p class="indent">Once your team arrives at the boss’s dungeon . . . you’re all slowly obliterated.</p>&#13;
<p class="indent">What went wrong in this scenario? Your game must be storing creature names with <code>std::string</code>, not just a simple character array. The <code>name</code> and <code>nameLength</code> fields in <code>creatureInfo</code> are, in fact, part of a <code>std::string</code> field, and the <code>name</code> character array is a union of <code>dataA</code> and <code>dataP</code> members. <em>Super Bossman Supreme</em> is longer than 15 characters, and because the bot was not aware of the <code>std::string</code> implementation, it didn’t recognize the boss. Instead, it constantly retargeted summoned <em>Demon</em> creatures, effectively keeping you from targeting the boss while he slowly drained your health and supplies.</p>&#13;
<h5 class="h5" id="ch00lev1sec108"><strong>Determining Whether Data Is Stored in a std::string</strong></h5>&#13;
<p class="noindent">Without knowing how the <code>std::string</code> class is structured, you’d have trouble tracking down bugs like the hypothetical one I just described. But pair what you’ve learned here with experience, and you can avoid these kinds of bugs entirely. When you find a string like <code>name</code> in memory, don’t just assume it’s stored in a simple array. To figure out whether a string is in fact a <code>std::string</code>, ask yourself these questions:</p>&#13;
<p class="bull">• Why is the string length present for a null-terminated string? If you can’t think of a good reason, then you may have a <code>std::string</code> on your hands.</p>&#13;
<p class="bull">• Do some creatures (or other game elements, depending on what you’re looking for) have names longer than 16 letters, but you find room for only 16 characters in memory? If so, the data is almost definitely stored in a <code>std::string</code>.</p>&#13;
<p class="bull"><span epub:type="pagebreak" id="page_108"/>• Is the name stored in place, requiring the developer to use <code>strcpy()</code> to modify it? It’s probably a <code>std::string</code>, because working with raw C strings in this way is considered bad practice.</p>&#13;
<p class="indent">Finally, keep in mind that there is also a class called <code>std::wstring</code> that is used to store wide strings. The implementation is very similar, but <code>wchar_t</code> is used in place of every <code>char</code>.</p>&#13;
<h4 class="h4" id="ch00lev1sec109"><strong><em>The std::vector Class</em></strong></h4>&#13;
<p class="noindent">Games must keep track of many dynamic arrays of data, but managing dynamically sized arrays can be very tricky. For speed and flexibility, game developers often store such data using a templated STL class called <code>std::vector</code> instead of a simple array.</p>&#13;
<h5 class="h5" id="ch00lev1sec110"><strong>Examining the Structure of a std::vector</strong></h5>&#13;
<p class="noindent">A declaration of this class looks something like <a href="ch05.xhtml#ch5exe4">Listing 5-4</a>.</p>&#13;
<pre>template&lt;typename T&gt;<br/>class vector {<br/>    T* begin;<br/>    T* end;<br/>    T* reservationEnd;<br/>};</pre>&#13;
<p class="listt"><a id="ch5exe4"/><em>Listing 5-4: An abstracted <code>std::vector</code> object</em></p>&#13;
<p class="indent">This template adds an extra layer of abstraction, so I’ll continue this description using a <code>std::vector</code> declared with the <code>DWORD</code> type. Here’s how a game might declare that vector:</p>&#13;
<pre>std::vector&lt;DWORD&gt; _vec;</pre>&#13;
<p class="indent">Now, let’s dissect what a <code>std::vector</code> of <code>DWORD</code> objects would look like in memory. If you had the address of <code>_vec</code> and shared the same memory space, you could re-create the underlying structure of the class and access <code>_vec</code> as shown in <a href="ch05.xhtml#ch5exe5">Listing 5-5</a>.</p>&#13;
<pre>class vector {<br/>    DWORD* begin;<br/>    DWORD* end;<br/>    DWORD* tail;<br/>};<br/>// point to a vector in memory<br/>vector* _vec = (vector*)vectorAddress;</pre>&#13;
<p class="listt"><a id="ch5exe5"/><em>Listing 5-5: A <code>DWORD std::vector</code> object</em></p>&#13;
<p class="indent">You can treat the member <code>begin</code> like a raw array, as it points to the first element in the <code>std::vector</code> object. There is no array length member, though, <span epub:type="pagebreak" id="page_109"/>so you must calculate the vector’s length based on <code>begin</code> and <code>end</code>, which is an empty object following the final object in the array. The length calculation code looks like this:</p>&#13;
<pre>int length() {<br/>    return ((DWORD)_vec-&gt;end - (DWORD)_vec-&gt;begin) / sizeof(DWORD);<br/>}</pre>&#13;
<p class="indent">This function simply subtracts the address stored in <code>begin</code> from the address stored in <code>end</code> to find the number of bytes between them. Then, to calculate the number of objects, it divides the number of bytes by the number of bytes per object.</p>&#13;
<p class="indent">Using <code>begin</code> and this <code>length()</code> function, you can safely access elements in <code>_vec</code>. That code would look something like this:</p>&#13;
<pre>DWORD at(int index) {<br/>    if (index &gt;= _vec-&gt;length())<br/>        throw new std::out_of_range();<br/>    return _vec-&gt;begin[index];<br/>}</pre>&#13;
<p class="indent">Given an index, this code will fetch an item from the vector. But if the index is greater than the vector’s length, a <code>std::out_of_range</code> exception will be thrown. Adding values to a <code>std::vector</code> would be very expensive if the class couldn’t reserve or reuse memory, though. To remedy this, the class implements a function called <code>reserve()</code> that tells the vector how many objects to leave room for.</p>&#13;
<p class="indent">The absolute size of a <code>std::vector</code> (its <em>capacity</em>) is determined through an additional pointer, which is called <code>tail</code> in the vector class we’ve re-created. The calculation for the capacity resembles the length calculation:</p>&#13;
<pre>int capacity() {<br/>    return ((DWORD)_vec-&gt;tail - (DWORD)_vec-&gt;begin) / sizeof(DWORD);<br/>}</pre>&#13;
<p class="indent">To find the capacity of a <code>std::vector</code>, instead of subtracting the <code>begin</code> address from the <code>end</code> address, as you would to calculate length, this function subtracts the <code>begin</code> address from <code>tail</code>. Additionally, you can use this calculation a third time to determine the number of free elements in the vector by using <code>tail</code> and <code>end</code> instead:</p>&#13;
<pre>int freeSpace() {<br/>    return ((DWORD)_vec-&gt;tail - (DWORD)_vec-&gt;end) / sizeof(DWORD);<br/>}</pre>&#13;
<p class="indent">Given proper memory reading and writing functions, you can use the declaration in <a href="ch05.xhtml#ch5exe4">Listing 5-4</a> and the calculations that follow to access and manipulate vectors in the memory of a game. <a href="ch06.xhtml#ch06">Chapter 6</a> discusses reading memory in detail, but for now, let’s look at ways you can determine whether data you’re interested in is stored in a <code>std::vector</code>.</p>&#13;
<h5 class="h5" id="ch00lev1sec111"><span epub:type="pagebreak" id="page_110"/><strong>Determining Whether Data Is Stored in a std::vector</strong></h5>&#13;
<p class="noindent">Once you’ve found an array of data in a game’s memory, there are a few steps you can follow to determine whether it is stored in a <code>std::vector</code>. First, you can be sure that the array is not stored in a <code>std::vector</code> if it has a static address, because <code>std::vector</code> objects require pointer paths to access the underlying array. If the array <em>does</em> require a pointer path, having a final offset of <code>0</code> would indicate a <code>std::vector</code>. To confirm, you can change the final offset to <code>4</code> and check if it points to the final object in the array instead of the first one. If so, you’re almost definitely looking at a vector, as you’ve just confirmed the <code>begin</code> and <code>end</code> pointers.</p>&#13;
<h4 class="h4" id="ch00lev1sec112"><strong><em>The std::list Class</em></strong></h4>&#13;
<p class="noindent">Similar to <code>std::vector</code>, <code>std::list</code> is a class that you can use to store a collection of items in a linked list. The main differences are that <code>std::list</code> doesn’t require a contiguous storage space for elements, cannot directly access elements by their index, and can grow in size without affecting any previous elements. Due to the overhead required to access items, it is rare to see this class used in games, but it shows up in some special cases, which I’ll discuss in this section.</p>&#13;
<h5 class="h5" id="ch00lev1sec113"><strong>Examining the Structure of a std::list</strong></h5>&#13;
<p class="noindent">The <code>std::list</code> class looks something like <a href="ch05.xhtml#ch5exe6">Listing 5-6</a>.</p>&#13;
<pre>template&lt;typename T&gt;<br/>class listItem {<br/>    listItem&lt;T&gt;* next;<br/>    listItem&lt;T&gt;* prev;<br/>    T value;<br/>};<br/><br/>template&lt;typename T&gt;<br/>class list {<br/>    listItem&lt;T&gt;* root;<br/>    int size;<br/>};</pre>&#13;
<p class="listt"><a id="ch5exe6"/><em>Listing 5-6: An abstracted <code>std::list</code> object</em></p>&#13;
<p class="indent">There are two classes here: <code>listItem</code> and <code>list</code>. To avoid extra abstraction while explaining how <code>std::list</code> works, I’ll describe this object as it would look when the type is <code>DWORD</code>. Here’s how a game would declare a <code>std::list</code> of the <code>DWORD</code> type:</p>&#13;
<pre>std::list&lt;DWORD&gt; _lst;</pre>&#13;
<p class="indent">Given that declaration, the <code>std::list</code> is structured like the code in <a href="ch05.xhtml#ch5exe7">Listing 5-7</a>.</p>&#13;
<pre><span epub:type="pagebreak" id="page_111"/><br/>class listItem {<br/>    listItem* next;<br/>    listItem* prev;<br/>    DWORD value;<br/>};<br/>class list {<br/>    listItem* root;<br/>    int size;<br/>};<br/>// point to a list<br/>list* _lst = (list*)listAddress;</pre>&#13;
<p class="listt"><a id="ch5exe7"/><em>Listing 5-7: A <code>DWORD std::list</code> object</em></p>&#13;
<p class="indent">The class <code>list</code> represents the list header, while <code>listItem</code> represents a value stored in the list. Instead of being stored contiguously, the items in the list are stored independently. Each item contains a pointer to the item that comes after it (<code>next</code>) and the one that comes before it (<code>prev</code>), and these pointers are used to locate items in the list. The <code>root</code> item acts as a marker for the end of the list; the <code>next</code> pointer of the last item points to <code>root</code>, as does the <code>prev</code> pointer of the first item. The <code>root</code> item’s <code>next</code> and <code>prev</code> pointers also point to the first item and the last item, respectively. <a href="ch05.xhtml#ch5fig5">Figure 5-5</a> shows what this looks like.</p>&#13;
<p class="indent">Given this structure, you can use the following code to iterate over a <code>std::list</code> object:</p>&#13;
<div class="image"><img src="../images/f05-05.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch5fig5"/><em>Figure 5-5: A <code>std::list</code> flowchart</em></p>&#13;
<pre>// iterate forward<br/>listItem* it = _lst-&gt;root-&gt;next;<br/>for (; it != _lst-&gt;root; it = it-&gt;next)<br/>    printf("Value is %d\n", it-&gt;value);<br/><br/>// iterate backward<br/>listItem* it = _lst-&gt;root-&gt;prev;<br/>for (; it != _lst-&gt;root; it = it-&gt;prev)<br/>    printf("Value is %d\n", it-&gt;value);</pre>&#13;
<p class="indent">The first loop starts at the first item (<code>root-&gt;next</code>) and iterates forward (<code>it = it-&gt;next</code>) until it hits the end marker (<code>root</code>). The second loop starts at the last item (<code>root-&gt;pres</code>) and iterates backward (<code>it = it-&gt;prev</code>) until it hits the end marker (<code>root</code>). This iteration relies on <code>next</code> and <code>prev</code> because unlike objects in an array, objects in a <code>std::list</code> are not contiguous. Since the memory of each object in a <code>std::list</code> is not contiguous, there’s no quick-and-dirty way to calculate the size. Instead, the class just defines a <span epub:type="pagebreak" id="page_112"/>size member. Additionally, the concept of reserving space for new objects is irrelevant for lists, so there’s no variable or calculation to determine a list’s capacity.</p>&#13;
<h5 class="h5" id="ch00lev1sec114"><strong>Determining Whether Game Data Is Stored in a std::list</strong></h5>&#13;
<p class="noindent">Identifying objects stored in the <code>std::list</code> class can be tricky, but there are a few hints you can watch for. First, items in a <code>std::list</code> cannot have static addresses, so if the data you seek has a static address, then you’re in the clear. Items that are obviously part of a collection may, however, be part of a <code>std::list</code> if they’re not contiguous in memory.</p>&#13;
<p class="indent">Also consider that objects in a <code>std::list</code> can have infinitely long pointer chains (think <code>it-&gt;prev-&gt;next-&gt;prev-&gt;next-&gt;prev</code> . . .), and pointer scanning for them in Cheat Engine will show many more results when No Looping Pointers is turned off.</p>&#13;
<p class="indent">You can also use a script to detect when a value is stored in a linked list. <a href="ch05.xhtml#ch5exe8">Listing 5-8</a> shows a Cheat Engine script that does just this.</p>&#13;
<pre>function _verifyLinkedList(address)<br/>    local nextItem = readInteger(address) or 0<br/>    local previousItem = readInteger(address + 4) or 0<br/>    local nextItemBack = readInteger(nextItem + 4)<br/>    local previousItemForward = readInteger(previousItem)<br/><br/>    return (address == nextItemBack<br/>            and address == previousItemForward)<br/>end<br/><br/>function isValueInLinkedList(valueAddress)<br/>    for address = valueAddress - 8, valueAddress - 48, -4 do<br/>        if (_verifyLinkedList(address)) then<br/>            return address<br/>        end<br/>    end<br/>    return 0<br/>end<br/><br/>local node = isValueInLinkedList(addressOfSomeValue)<br/>if (node &gt; 0) then<br/>    print(string.format("Value in LL, top of node at 0x0%x", node))<br/>end</pre>&#13;
<p class="listt"><a id="ch5exe8"/><em>Listing 5-8: Determining whether data is in a <code>std::list</code> using a Cheat Engine Lua script</em></p>&#13;
<p class="indent">There’s quite a bit of code here, but what it’s doing is actually pretty simple. The <code>isValueInLinkedList()</code> function takes an address of some value and then looks backward for up to 40 bytes (10 integer objects, in case the <span epub:type="pagebreak" id="page_113"/>value is in some larger structure), starting 8 bytes above the address (two pointers must be present, and they are 4 bytes each). Because of memory alignment, this loop iterates in steps of 4 bytes.</p>&#13;
<p class="indent">On each iteration, the address is passed to the <code>_verifyLinkedList()</code> function, which is where the magic happens. If we look at it in terms of linked list structure as defined in this chapter, the function simply does this:</p>&#13;
<pre>return (node-&gt;next-&gt;prev == node &amp;&amp; node-&gt;prev-&gt;next == node)</pre>&#13;
<p class="indent">That is, the function basically assumes the memory address it’s given points to a linked list, and it makes sure the supposed node has valid next and previous nodes. If the nodes are valid, the assumption was correct and the address is that of a linked list node. If the nodes don’t exist or don’t point to the right locations, the assumption was wrong and the address is not part of a linked list.</p>&#13;
<p class="indent">Keep in mind that this script won’t give you the address of the list’s root node but simply the address of the node containing the value you’ve given it. To properly traverse a linked list, you’ll need to scan for a valid pointer path to the root node, so you’ll need its address.</p>&#13;
<p class="indent">Finding that address can require some searching of memory dumps, a lot of trial and error, and a ton of head scratching, but it’s definitely possible. The best way to start is to follow the chain of <code>prev</code> and <code>next</code> nodes until you find a node with data that is either blank, nonsensical, or filled with the value <code>0xBAADF00D</code> (some, but not all, standard library implementations use this value to mark root nodes).</p>&#13;
<p class="indent">This investigation can also be made easier if you know exactly how many nodes are in the list. Even without the list header, you can determine the amount of nodes by continuously following the next pointer until you end up back at your starting node, as in <a href="ch05.xhtml#ch5exe9">Listing 5-9</a>.</p>&#13;
<pre>function countLinkedListNodes(nodeAddress)<br/>    local counter = 0<br/>    local next = readInteger(nodeAddress)<br/>    while (next ~= nodeAddress) do<br/>        counter = counter + 1<br/>        next = readInteger(next)<br/>    end<br/>    return counter<br/>end</pre>&#13;
<p class="listt"><a id="ch5exe9"/><em>Listing 5-9: Determining the size of an arbitrary <code>std::list</code> using a Cheat Engine Lua script</em></p>&#13;
<p class="indent">First, this function creates a counter to store the number of nodes and a variable to store the next node’s address. The <code>while</code> loop then iterates over the nodes until it ends up back at the initial node. Finally, it returns the counter variable, which was incremented on every iteration of the loop.</p>&#13;
<div class="sidebar">&#13;
<p class="sidebart"><span epub:type="pagebreak" id="page_114"/><strong>FIND THE ROOT NODE WITH A SCRIPT</strong></p>&#13;
<p class="noindent">It’s actually possible to write a script that can find the root node, but I’ll leave it as an optional exercise for you. How does it work? Well, the root node must be in the chain of nodes, the list header points to the root, and the size of the list will immediately follow the root in memory. Given this information, you can write a script that will search for any memory containing a pointer to one of the list’s nodes, followed by the size of the list. More often than not, this piece of memory is the list header, and the node it points to is the root node.</p>&#13;
</div>&#13;
<h4 class="h4" id="ch00lev1sec115"><strong><em>The std::map Class</em></strong></h4>&#13;
<p class="noindent">Like a <code>std::list</code>, a <code>std::map</code> uses links between elements to form its structure. Unique to <code>std::map</code>, however, is the fact that each element stores two pieces of data (a key and a value), and sorting the elements is an inherent property of the underlying data structure: a red-black tree. The following code shows the structures that compose a <code>std::map</code>.</p>&#13;
<pre>template&lt;typename keyT, typename valT&gt;<br/>struct mapItem {<br/>    mapItem&lt;keyT, valT&gt;* left;<br/>    mapItem&lt;keyT, valT&gt;* parent;<br/>    mapItem&lt;keyT, valT&gt;* right;<br/>    keyT key;<br/>    valT value;<br/>};<br/><br/>template&lt;typename keyT, typename valT&gt;<br/>struct map {<br/>    DWORD irrelevant;<br/>    mapItem&lt;keyT, valT&gt;* rootNode;<br/>    int size;<br/>}</pre>&#13;
<p class="indent">A red-black tree is a self-balancing binary search tree, so a <code>std::map</code> is, too. In the STL’s <code>std::map</code> implementation, each element (or node) in the tree has three pointers: <code>left</code>, <code>parent</code>, and <code>right</code>. In addition to the pointers, each node also has a <code>key</code> and a <code>value</code>. The nodes are arranged in the tree based on a comparison between their keys. The <code>left</code> pointer of a node points to a node with a smaller key, and the <code>right</code> pointer points to a node with a larger key. The <code>parent</code> points to the upper node. The first node in the tree is called the <code>rootNode</code>, and nodes that lack children point to it.</p>&#13;
<h5 class="h5" id="ch00lev1sec116"><strong>Visualizing a std::map</strong></h5>&#13;
<p class="noindent"><a href="ch05.xhtml#ch5fig6">Figure 5-6</a> shows a <code>std::map</code> that has the keys 1, 6, 8, 11, 13, 15, 17, 22, 25, and 27.</p>&#13;
<div class="image"><span epub:type="pagebreak" id="page_115"/><img src="../images/f05-06.jpg" alt="image"/></div>&#13;
<p class="figcap"><a id="ch5fig6"/><em>Figure 5-6: A red-black tree</em></p>&#13;
<p class="indent">The top node (holding the value <code>13</code>) is pointed to by the <code>parent</code> of <code>rootNode</code>. Everything to the left of it has a smaller <code>key</code>, and everything to the right has a greater <code>key</code>. This is true for any node in the tree, and this truth enables efficient key-based search. While not represented in the image, the left pointer of the root node will point to the leftmost node (<code>1</code>), and the right pointer will point to the rightmost node (<code>27</code>).</p>&#13;
<h5 class="h5" id="ch00lev1sec117"><strong>Accessing Data in a std::map</strong></h5>&#13;
<p class="noindent">Once again, I’ll use a static <code>std::map</code> definition when discussing how to extract data from the structure. Since the template takes two types, I’ll also use some pseudotypes to keep things obvious. Here’s the declaration for the <code>std::map</code> object I’ll reference for the rest of the section:</p>&#13;
<pre>typedef int keyInt;<br/>typedef int valInt;<br/>std::map&lt;keyInt, valInt&gt; myMap;</pre>&#13;
<p class="indent">With this declaration, the structure of <code>myMap</code> becomes:</p>&#13;
<pre>struct mapItem {<br/>    mapItem* left;<br/>    mapItem* parent;<br/>    mapItem* right;<br/>    keyInt key;<br/>    valInt value;<br/>};<br/>struct map {<br/>    DWORD irrelevant;<br/>    mapItem* rootNode;<br/>    int size;<br/>}<br/>map* _map = (map*)mapAddress;</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_116"/>There are some important algorithms that you might need to access the data in a <code>std::map</code> structure in a game. First, blindly iterating over every item in the map can be useful if you just want to see all of the data. To do this sequentially, you could write an iteration function like this:</p>&#13;
<pre>void iterateMap(mapItem* node) {<br/>    if (node == _map-&gt;rootNode) return;<br/>    iterateMap(node-&gt;left);<br/>    printNode(node);<br/>    iterateMap(node-&gt;right);<br/>}</pre>&#13;
<p class="indent">A function to iterate over an entire map would first read the current node and check whether it’s the <code>rootNode</code>. If not, it would recurse left, print the node, and recurse right.</p>&#13;
<p class="indent">To call this function, you’d have to pass a pointer to the <code>rootNode</code> as follows:</p>&#13;
<pre>iterateMap(_map-&gt;rootNode-&gt;parent);</pre>&#13;
<p class="indent">The purpose of a <code>std::map</code>, however, is to store keyed data in a quickly searchable way. When you need to locate a node given a specific <code>key</code>, mimicking the internal search algorithm is preferable to scanning the entire tree. The code for searching a <code>std::map</code> looks something like this:</p>&#13;
<pre>mapItem* findItem(keyInt key, mapItem* node) {<br/>    if (node != _map-&gt;rootNode) {<br/>        if (key == node-&gt;key)<br/>            return node;<br/>        else if (key &lt; node-&gt;key)<br/>            return findItem(key, node-&gt;left);<br/>        else<br/>            return findItem(key, node-&gt;right);<br/>    } else return NULL;<br/>}</pre>&#13;
<p class="indent">Starting at the top of the tree, you simply recurse left if the current key is greater than the search key and recurse right if it is smaller. If the keys are equal, you return the current node. If you reach the bottom of the tree and don’t find the key, you return <code>NULL</code> because the key isn’t stored in the map.</p>&#13;
<p class="indent">Here’s one way you might use this <code>findItem()</code> function:</p>&#13;
<pre>mapItem* ret = findItem(someKey, _map-&gt;rootNode-&gt;parent);<br/>if (ret)<br/>    printNode(ret);</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_117"/>As long as <code>findItem()</code> doesn’t return <code>NULL</code>, this code should print a node from <code>_map</code>.</p>&#13;
<h5 class="h5" id="ch00lev1sec118"><strong>Determining Whether Game Data Is Stored in a std::map</strong></h5>&#13;
<p class="noindent">Typically, I don’t even consider whether data could be in a <code>std::map</code> until I know the collection is not an array, a <code>std::vector</code>, or a <code>std::list</code>. If you rule out all three options, then as with a <code>std::list</code>, you can look at the three integer values before the value and check if they point to memory that could possibly be other map nodes.</p>&#13;
<p class="indent">Once again, this can be done with a Lua script in Cheat Engine. The script is similar to the one I showed for lists, looping backward over memory to see if a valid node structure is found before the value. Unlike the list code, though, the function that verifies a node is much trickier. Take a look at the code in <a href="ch05.xhtml#ch5exe10">Listing 5-10</a>, and then I’ll dissect it.</p>&#13;
<pre>   function _verifyMap(address)<br/>       local parentItem = readInteger(address + 4) or 0<br/><br/>       local parentLeftItem = readInteger(parentItem + 0) or 0<br/>       local parentRightItem = readInteger(parentItem + 8) or 0<br/><br/><span class="ent">➊</span>     local validParent =<br/>           parentLeftItem == address<br/>           or parentRightItem == address<br/>       if (not validParent) then return false end<br/><br/>       local tries = 0<br/>       local lastChecked = parentItem<br/>       local parentsParent = readInteger(parentItem + 4) or 0<br/><span class="ent">➋</span>     while (readInteger(parentsParent + 4) ~= lastChecked and tries &lt; 200) do<br/>           tries = tries + 1<br/>           lastChecked = parentsParent<br/>           parentsParent = readInteger(parentsParent + 4) or 0<br/>       end<br/><br/>       return readInteger(parentsParent + 4) == lastChecked<br/>   end</pre>&#13;
<p class="listt"><a id="ch5exe10"/><em>Listing 5-10: Determining whether data is in a <code>std::map</code> using a Cheat Engine Lua script</em></p>&#13;
<p class="indent">Given <code>address</code>, this function checks if <code>address</code> is in a map structure. It first checks if there’s a valid parent node and, if so, checks whether that parent node points to <code>address</code> on either side <span class="ent">➊</span>. But this check isn’t enough. If the check passes, the function will also climb up the line of <code>parent</code> nodes until it reaches a node that is the parent of its own parent <span class="ent">➋</span>, trying 200 times before calling it quits. If the climb succeeds in finding a node that is its own grandparent, then <code>address</code> definitely points to a map node. This works because, as I outlined in “<a href="ch05.xhtml#ch00lev1sec116">Visualizing a <code>std::map</code></a>” on <a href="ch05.xhtml#page_114">page 114</a>, at the top of every map is a root node whose parent points to the first node in the tree, and that node’s parent points back to the root node.</p>&#13;
<div class="note">&#13;
<p class="notet"><span epub:type="pagebreak" id="page_118"/><strong><span class="notes">NOTE</span></strong></p>&#13;
<p class="notep"><em>I bet you didn’t expect to run into the grandfather paradox from time travel when reading a game-hacking book!</em></p>&#13;
</div>&#13;
<p class="indent">Using this function and a slightly modified backtracking loop from <a href="ch05.xhtml#ch5exe8">Listing 5-8</a>, you can automatically detect when a value is inside a map:</p>&#13;
<pre>function isValueInMap(valueAddress)<br/>    for address = valueAddress - 12, valueAddress - 52, -4 do<br/>        if (_verifyMap(address)) then<br/>            return address<br/>        end<br/>    end<br/>    return 0<br/>end<br/><br/>local node = isValueInMap(addressOfSomeValue)<br/>if (node &gt; 0) then<br/>    print(string.format("Value in map, top of node at 0x0%x", node))<br/>end</pre>&#13;
<p class="indent">Aside from function names, the only change in this code from <a href="ch05.xhtml#ch5exe8">Listing 5-8</a> is that it starts looping 12 bytes before the value instead of 8, because a map has three pointers instead of the two in a list. One good consequence of a map’s structure is that it’s easy to obtain the root node. When the <code>_verifyMap</code> function returns true, the <code>parentsParent</code> variable will contain the address of the root node. With some simple modifications, you could return this to the main call and have everything you need to read the data from a <code>std::map</code> in one place.</p>&#13;
<h3 class="h3" id="ch00lev1sec119"><strong>Closing Thoughts</strong></h3>&#13;
<p class="noindent">Memory forensics is the most time-consuming part of hacking games, and its obstacles can appear in all shapes and sizes. Using purpose, patterns, and a deep understanding of complex data structures, however, you can quickly overcome these obstacles. If you’re still a bit confused about what’s going on, make sure to download and play with the example code provided, as it contains proofs of concept for all of the algorithms covered in this chapter.</p>&#13;
<p class="indent">In <a href="ch06.xhtml#ch06">Chapter 6</a>, we’ll start diving in to the code you need to read from and write to a game’s memory from your own programs so you can take the first step in putting to work all of this information about memory structures, addresses, and data.</p>&#13;
</body></html>