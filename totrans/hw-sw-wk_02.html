<html><head></head><body>
<h2 class="h2" id="ch02"><a id="page_19"/><strong><span class="big">2</span></strong><br/><strong>Passwords</strong></h2>
<div class="image1"><img alt="image" src="graphics/common-01.jpg"/></div>
<p class="noindent">One of software’s most crucial tasks is the protection of passwords. That may be surprising. After all, aren’t passwords part of systems that <em>provide</em> protection? Don’t passwords secure our accounts with banks, web retailers, and online games?</p>
<p class="indent">The truth is, while passwords are the keystones of computer security, they can become the targets of attacks. If a remote computer accepts your identity based on your password, a process known as <em>authentication</em>, it must have a list of user passwords to compare against. That password list is a tempting target for attackers. Recent years have seen a number of large-scale thefts of customer account data. How does this happen, and what can be done to make breaches less likely? That’s what this chapter is about.</p>
<p class="indent">Before you learn how passwords are protected, though, you’ll see how they are transformed into binary numbers, a process that has important implications for both password storage and encryption.</p>
<h3 class="h3" id="ch02lev1sec01"><a id="page_20"/><strong>Transforming a Password into a Number</strong></h3>
<p class="noindent">In <a href="ch01.html#ch01">Chapter 1</a>, you saw how an individual character could be replaced by a number from the ASCII table. Here, you’ll see how a string of characters can be replaced by one big number, such as the 128-bit key we need for AES. In computing, transforming something into a number in a specified range is called <em>hashing</em>, and the resulting number is called a <em>hash code</em>, <em>hash value</em>, or just plain <em>hash</em>.</p>
<p class="indent">Here, the word <em>hash</em> means chopping something up and then cramming the pieces back together, as with hash browns. A particular hashing method is known as a <em>hash function</em>. Hashing a password always begins by converting each character in the password to a number using an encoding system such as ASCII. Hash functions differ in how they combine those numbers; the hash functions used in encryption and authentication systems must be carefully designed or security may be compromised.</p>
<h4 class="h4" id="ch02lev2sec01"><strong><em>Properties of Good Hash Functions</em></strong></h4>
<p class="noindent">Developing a good hash function is no easy task. To understand what hash functions are up against, consider the short password <em>dog</em>. That word contains 3 ASCII bytes, or a mere 24 bits of data, while an AES key is a minimum of 128 bits. Therefore a good hash function must be capable of transforming those 24 bits into a 128-bit hash code with the following properties.</p>
<h5 class="h5" id="ch02lev3sec01"><strong>Full Use of All Bits</strong></h5>
<p class="noindent">A major strength of a computer-based encryption system like AES is the <em>key size</em>, the sheer number of possible keys facing an attacker. This strength disappears, however, if all the possible keys aren’t actually being used. A good hash function must produce results across the full range of possible hash codes. Even for our short <em>dog</em> password, all 128 bits of the resulting hash code must be influenced by the original 24 bits of the password.</p>
<h5 class="h5" id="ch02lev3sec02"><strong>No Reversibility</strong></h5>
<p class="noindent">In <a href="ch01.html#ch01">Chapter 1</a>, you learned that an encryption method has to be reversible. A good hash function, in contrast, should <em>not</em> be reversible. I’ll discuss why this is important later in the chapter. For now, know that for a given hash code, there should be no direct way to recover a password that produced it. I say <em>a</em> password and not <em>the</em> password because multiple passwords may produce the same hash code, which is known as a hash <em>collision</em>. Because there are more possible passwords than hash codes, collisions are inevitable. A good hash function should make it difficult for attackers to find <em>any</em> password that produces a given hash code.</p>
<h5 class="h5" id="ch02lev3sec03"><a id="page_21"/><strong>Avalanche</strong></h5>
<p class="noindent">The avalanche property that’s vital to encryption is just as important in hashing. Small changes in the password should result in large changes in the hash code—especially since many people, when required to choose a new password, choose a slight variation of their old one. The hash code produced for <em>dog</em> should be very different from those produced by similar passwords such as <em>doge</em>, <em>Dog</em>, or <em>odg</em>.</p>
<h3 class="h3" id="ch02lev1sec02"><strong>The MD5 Hash Function</strong></h3>
<p class="noindent">Meeting all these criteria is not easy. Good hash functions solve this problem in a clever way. They start with a jumble of bits and use the bit patterns of the password to modify this jumble further. That’s the method of the widely used hash function called <em>MD5</em>—the fifth version of the <em>Message Digest</em> hash function.</p>
<h4 class="h4" id="ch02lev2sec02"><strong><em>Encoding the Password</em></strong></h4>
<p class="noindent">To get started, MD5 converts the password to a 512-bit block; I’ll call this the <em>encoded password</em>. The first part of this encoding consists of the ASCII codes of the characters in the password. For example, if the password is <em>BigFunTime</em>, the first character is a <em>B</em>, which has an ASCII byte of 01000010, so the first 8 bits of the encoded password are 01000010; the next 8 bits are the byte for <em>i</em>, which is 01101001; and so on. Thus, the 10 letters in our sample <em>BigFunTime</em> password will take up 80 bits out of 512.</p>
<p class="indent">Now the rest of the bits have to be filled up. The next bit is set to 1, and all the bits up to the last 64 are set to 0. The final 64 bits store a binary representation of the length, in bits, of the original password. In this case, the password is 10 characters, or 80 bits, long. The 64-bit binary representation of 80 is:</p>
<p class="programs">00000000 00000000 00000000 00000000 00000000 00000000 00000000 01010000</p>
<p class="indent">Clearly, we don’t need 64 bits to store the length of a password. Using 64 bits for the length allows MD5 to hash inputs of arbitrary length—the benefit of which we’ll see later.</p>
<p class="indent"><a href="ch02.html#ch2fig1">Figure 2-1</a> shows the encoding of the sample password, organized into 16 numbered rows of 32 bits each.</p>
<div class="image"><a id="page_22"/><img alt="image" src="graphics/f02-01.jpg"/></div>
<p class="figuret"><a id="ch2fig1"/><em>Figure 2-1: The password</em> BigFunTime <em>transformed into the 512 bits used as input to the MD5 hash function</em></p>
<p class="indent">This encoded password is full of zeros and therefore doesn’t meet the “fully uses all the bits” property of a good function, but that’s okay because this is not the hash code; it’s just the starting point.</p>
<h4 class="h4" id="ch02lev2sec03"><strong><em>Bitwise Operations</em></strong></h4>
<p class="noindent">The MD5 hash function uses a few operations I haven’t discussed before. Let’s go through these briefly.</p>
<h5 class="h5" id="ch02lev3sec04"><strong>Binary Addition</strong></h5>
<p class="noindent">The first new operation is <em>binary addition</em>. Binary addition is much like the decimal addition you already know but with binary numbers. For example, the 32-bit representation of the number 5 is:</p>
<p class="programs">00000000 00000000 00000000 00000101</p>
<p class="indent">The 32-bit representation of 46 is:</p>
<p class="programs">00000000 00000000 00000000 00101110</p>
<p class="indent">If we add 5 and 46 together, the result is 51. Likewise, the addition of those two binary representations results in the binary representation of 51:</p>
<p class="programs">00000000 00000000 00000000 00110011</p>
<p class="indent">Unlike normal addition, though, where sometimes the result has more digits than the operands, in binary addition the number of bits is fixed. If the result of adding two 32-bit binary numbers is greater than 32 bits, we <a id="page_23"/>ignore the “carry” at the left side of the result and keep only the 32 bits on the right. It’s like working with a cheap calculator that has just a two-digit display, so when you add 75 and 49, instead of displaying 124, it displays only the last two digits, 24.</p>
<h5 class="h5" id="ch02lev3sec05"><strong>Bitwise NOT</strong></h5>
<p class="noindent">The next new operation is called “not,” often written in all uppercase as <em>NOT</em>. As demonstrated in <a href="ch02.html#ch2fig2">Figure 2-2</a>, NOT “flips” all of the bits, replacing each 1 with a 0 and each 0 with a 1.</p>
<div class="image"><img alt="image" src="graphics/f02-02.jpg"/></div>
<p class="figuret"><a id="ch2fig2"/><em>Figure 2-2: The bitwise NOT operation. All bits are inverted. The 1 bits are highlighted for clarity.</em></p>
<h5 class="h5" id="ch02lev3sec06"><strong>Bitwise OR</strong></h5>
<p class="noindent">Up next is <em>OR</em>, sometimes called <em>inclusive-OR</em> to distinguish it from the exclusive-or (XOR) that you saw in <a href="ch01.html#ch01">Chapter 1</a>. The OR operation lines up two binary numbers with the same number of bits. In each position of the resulting binary number, you get a 1 if there’s a 1 in the first number <em>or</em> in the second number; otherwise, you get a 0, as shown in <a href="ch02.html#ch2fig3">Figure 2-3</a>.</p>
<div class="image"><img alt="image" src="graphics/f02-03.jpg"/></div>
<p class="figuret"><a id="ch2fig3"/><em>Figure 2-3: The bitwise OR operation. Bit positions are 1 in the result if they are 1 in either of the two inputs</em></p>
<p class="indent">Notice that unlike XOR, you can’t apply OR twice and get the original byte back. It’s a one-way trip.</p>
<h5 class="h5" id="ch02lev3sec07"><strong>Bitwise AND</strong></h5>
<p class="noindent">The last of the new operations is <em>AND</em>. Two binary numbers are aligned, and in each position, the result is 1 wherever both bits are 1 in that position; otherwise, the result is 0. So a 1 in the result means there was a 1 in that position in the first number <em>and</em> the second number, as seen in <a href="ch02.html#ch2fig4">Figure 2-4</a>. As with OR, the AND operation isn’t reversible.</p>
<div class="image"><a id="page_24"/><img alt="image" src="graphics/f02-04.jpg"/></div>
<p class="figuret"><a id="ch2fig4"/><em>Figure 2-4: The bitwise AND operation. Bit positions are 1 in the result if they are 1 in both of the two inputs.</em></p>
<h4 class="h4" id="ch02lev2sec04"><strong><em>MD5 Hashing Rounds</em></strong></h4>
<p class="noindent">Now we’re ready for some hashing. Pieces of the encoded password make only brief appearances in the MD5 process, but those appearances make all the difference. The MD5 process always starts with the same 128 bits, conceptually split into four 32-bit sections, labeled A through D, as shown in <a href="ch02.html#ch2fig5">Figure 2-5</a>.</p>
<div class="image"><img alt="image" src="graphics/f02-05.jpg"/></div>
<p class="figuret"><a id="ch2fig5"/><em>Figure 2-5: The starting configuration of the 128 bits of an MD5 hash code</em></p>
<p class="indent">From here, it’s all about shifting these bits around and flipping them, in a process that repeats a whopping 64 times. In this respect, the process is a lot like AES but with even more rounds. <a href="ch02.html#ch2fig6">Figure 2-6</a> is a broad diagram of one of the 64 rounds.</p>
<div class="image"><img alt="image" src="graphics/f02-06.jpg"/></div>
<p class="figuret"><a id="ch2fig6"/><em>Figure 2-6: One round of the MD5 hash function. In the result, three of the sections are transposed, while all four sections are combined to make a new section.</em></p>
<p class="indent">As shown, sections B, C, and D are simply transposed, so that the D section of one round becomes the A section of the next. The main action of MD5 occurs in the “extra scrambling” of each round, which creates a new <a id="page_25"/>section from the bits of all four sections of the previous round. The extra scrambling uses the irreversible operations AND, OR, and NOT to combine the bits of all four sections with one of the rows of the encoded password. Different rows of the encoded password are used in different rounds, so that eventually all the rows of the encoded password are used multiple times. Because of the transposition, the process needs just four rounds to replace each of the four original sections with the result of the extra scrambling. After the complete 64-round process, the original bits of the sections will have been thoroughly sifted together with the encoded password.</p>
<h4 class="h4" id="ch02lev2sec05"><strong><em>Meeting the Criteria of a Good Hash Function</em></strong></h4>
<p class="noindent">Because MD5 starts with an assortment of bits, then alters these bits over and over, adding in pieces of the encoded password, we can be sure that all the bits are affected along the way, giving us a true 128-bit hash code. The sheer number of operations that are irreversible—and remember, the actions described occur 64 times—means the hash function as a whole is not reversible. This rotation and alteration of the bits in the “extra scrambling” each round, combined with the rotation of the sections themselves, distribute the bits and bytes and create the desired avalanche.</p>
<p class="indent">MD5 meets all the baseline requirements for a good hash function. It does have a few subtle weaknesses, however, as you’ll soon see.</p>
<h3 class="h3" id="ch02lev1sec03"><strong>Digital Signatures</strong></h3>
<p class="noindent">Hash functions serve other purposes in security besides creating keys from passwords. One of the most important is the creation of file <em>signatures</em>. As stated earlier, MD5 can process any size of input. If the input is larger than 512 bits, it’s first divided into multiple 512-bit blocks. The MD5 process is then applied once per block. The first block starts with the initial 128 bits and each subsequent block starts with the hash code produced by the previous block. In this way, we could run the entire text of this book, an audio file, a video, or any other digital file through the function and get a single 128-bit hash code in return. This hash code would become the file’s signature.</p>
<p class="indent">Why does a file need a signature? Suppose you have decided to download FreeWrite, a (fictional) freeware word processor application. You’re wary, though, because of a bad experience in which you downloaded a freeware program that turned out to be bogus and riddled with malware. To avoid this, you want to be sure the FreeWrite file that you download is the same file that the developers uploaded. The developers could hash the file with MD5 and post the resulting hash code—the file signature—on their website, <a href="http://freewrite.com">freewrite.com</a>. This allows you to run the file through an MD5 hash program and compare the result to the code on the developer site. If the new result doesn’t match the signature, something has changed: the file, the signature, or both.</p>
<h4 class="h4" id="ch02lev2sec06"><a id="page_26"/><strong><em>The Problem of Identity</em></strong></h4>
<p class="noindent">Unfortunately, matching the posted hash code proves the FreeWrite file is legitimate only if the hash code was actually published by the developers. But what if an attacker copies the developer’s <a href="http://freewrite.com">freewrite.com</a> site to a similarly named domain like <a href="http://free-write.com">free-write.com</a>, and then posts a compromised file along with the hash of that compromised file? A digital signature is only as trustworthy as its provider. We’ll explore this problem in further detail in <a href="ch03.html#ch03">Chapter 3</a>.</p>
<h4 class="h4" id="ch02lev2sec07"><strong><em>Collision Attacks</em></strong></h4>
<p class="noindent">Even with a matching hash code from a legitimate source, though, a file might be trouble. Many different files will produce the same hash code, which means an attacker trying to modify a file for nefarious purposes can avoid detection if the new, modified file produces the same hash code.</p>
<p class="indent">It’s not too difficult to produce two files with the same hash code, which is known as a <em>collision attack</em>: just randomly generate files until two hash codes match. Finding a second file to match the <em>particular</em> hash code of another file is much harder. To be of any real use to an attacker, the file with the matching code can’t be a bunch of random bytes; it has to be a program that does something malicious on the attacker’s behalf.</p>
<p class="indent">Unfortunately, there are methods to produce a second file with the same MD5 code that is very similar to the first file. The discovery of this flaw in the MD5 hash function has led researchers to suggest that other hash functions be used for signatures. These more advanced hash functions usually have longer hash codes (up to 512 bits), more hashing rounds, and more complicated binary math during each round. As with encryption, though, there are no guarantees that flaws won’t be discovered in the more complicated hash functions as well. Proper use of signatures means staying one step ahead of known design flaws because attackers will exploit flaws mercilessly. Digital security is a cat-and-mouse game in which the good guys are the mice, trying to avoid being eaten, never able to defeat the cats, and only hoping to stay alive a little longer.</p>
<h3 class="h3" id="ch02lev1sec04"><strong>Passwords in Authentication Systems</strong></h3>
<p class="noindent">Nowhere is this cat-and-mouse game more evident than in authentication systems. Every place where you enter your password has to have a list of passwords to compare against, and properly securing the list requires great care.</p>
<h4 class="h4" id="ch02lev2sec08"><strong><em>The Dangers of Password Tables</em></strong></h4>
<p class="noindent">Let’s look at the most straightforward way passwords could be stored in a table. In this example, Northeast Money Bank (NEMB) stores the username and password of each of its customers, along with the account number and current balance. An excerpt from the password table is shown in <a href="ch02.html#ch2tab1">Table 2-1</a>.</p>
<p class="tablet"><a id="page_27"/><a id="ch2tab1"/><strong>Table 2-1:</strong> Poorly Designed Password Table</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="100%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Username</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Password</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Account number</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Balance</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table" valign="top"><p class="table">richguy22</p></td>
<td class="table" valign="top"><p class="table">ilikemoney</p></td>
<td class="table" valign="top"><p class="table">21647365</p></td>
<td class="table" valign="top"><p class="table">$27.21</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">mrgutman</p></td>
<td class="table" valign="top"><p class="table">falcon</p></td>
<td class="table" valign="top"><p class="table">32846519</p></td>
<td class="table" valign="top"><p class="table">$10,000.00</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">squire</p></td>
<td class="table" valign="top"><p class="table">yes90125</p></td>
<td class="table" valign="top"><p class="table">70023193</p></td>
<td class="table" valign="top"><p class="table">$145,398.44</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">burgomeister78</p></td>
<td class="table" valign="top"><p class="table">taco999</p></td>
<td class="table" valign="top"><p class="table">74766333</p></td>
<td class="table" valign="top"><p class="table">$732.23</p></td>
</tr>
</tbody>
</table>
<p class="indent">Just as Kerckhoffs’s principle says we can’t rely on encryption methods remaining secret, we shouldn’t rely on the password list remaining a secret, either. A disgruntled employee in the NEMB information technology department might easily acquire the file containing the list, or determined attackers on the outside might worm their way through the company defenses.</p>
<p class="indent">This is what’s known as a <em>single point of defense</em>, meaning that once anyone lays eyes on this table, the game is over. First, this table shows the account numbers and balances of all of the customers, so at the very least, that’s a major loss of privacy. What’s even worse is that each password is stored in the form entered by the user. Accessing this password list will allow attackers to log on as any customer—a disaster in the making.</p>
<p class="indent">Fortunately, the problems with this storage system are easily remedied. Knowing that, and knowing how dangerous the system is, you would think that it would never be used. Sadly, you would be wrong. Real companies are storing user passwords just like this. Some extremely large companies that probably spent a great deal of money on their websites have been caught following this practice.</p>
<h4 class="h4" id="ch02lev2sec09"><strong><em>Hashing Passwords</em></strong></h4>
<p class="noindent">If <a href="ch02.html#ch2tab1">Table 2-1</a> shows the wrong thing to do, what’s the right thing to do? One improvement is leaving the password out of the table and instead storing the hash code of the password, as shown by <a href="ch02.html#ch2tab2">Table 2-2</a>. (In the examples that follow, I show hash codes as decimal numbers to keep their length manageable.)</p>
<p class="tablet"><a id="ch2tab2"/><strong>Table 2-2:</strong> Password Table with Hashed Passwords</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="100%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Username</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Hash of password</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Account number</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Balance</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table" valign="top"><p class="table">richguy22</p></td>
<td class="table" valign="top"><p class="table">330,711,060,038,684,200,901,827,278,633,002,791,087</p></td>
<td class="table" valign="top"><p class="table">21647365</p></td>
<td class="table" valign="top"><p class="table">$27.21</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">mrgutman</p></td>
<td class="table" valign="top"><p class="table">332,375,033,828,033,552,423,319,316,163,101,084,850</p></td>
<td class="table" valign="top"><p class="table">32846519</p></td>
<td class="table" valign="top"><p class="table">$10,000.00</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">squire</p></td>
<td class="table" valign="top"><p class="table">295,149,488,455,763,164,542,524,060,437,757,020,453</p></td>
<td class="table" valign="top"><p class="table">70023193</p></td>
<td class="table" valign="top"><p class="table">$145,398.44</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">burgomeister78</p></td>
<td class="table" valign="top"><p class="table">133,039,589,388,270,767,475,032,770,360,311,206,892</p></td>
<td class="table" valign="top"><p class="table">74766333</p></td>
<td class="table" valign="top"><p class="table">$732.23</p></td>
</tr>
</tbody>
</table>
<p class="indent"><a id="page_28"/>When a user tries to log in, the submitted password is hashed and the result compared to the stored hash code. If they match, the user is logged in. Because the hash function isn’t reversible, getting access to the table isn’t the same as getting access to the passwords. An attacker can’t log on to an account with the hash code.</p>
<p class="indent">The account number and balance are still stored as plaintext, though, and it would be a good idea to encrypt them, making a table with only hash codes and ciphertext. The problem is if we used the hash of the password as our cipher key, then encrypting the data provides no additional protection because anyone who acquires this table will be able to decrypt the ciphertext.</p>
<p class="indent">There are several ways to solve this problem. One solution is to use one hash function to transform the password for authentication and another hash function to transform the password into a cipher key to encrypt the account number and balance. As long as the hash functions are not reversible, this solution would provide security for the account data even if an attacker got access to the table.</p>
<h4 class="h4" id="ch02lev2sec10"><strong><em>Dictionary Attacks</em></strong></h4>
<p class="noindent">Hashing the passwords is a good defense against attackers, but it’s not enough. Authentication systems are still vulnerable to <em>dictionary attacks</em>.</p>
<p class="indentb">In a basic dictionary attack, the attacker has no access to the password table and must guess the password. The attacker could just try random jumbles of characters but will have much more success with a <em>dictionary</em>, which in the world of software is simply a list of words. In this case, the dictionary is a list of the most common passwords, and it begins something like this:</p>
<p class="bull">• password</p>
<p class="bull">• 123456</p>
<p class="bull">• football</p>
<p class="bull">• mypassword</p>
<p class="bull">• abcdef</p>
<p class="indentt">To foil the basic dictionary attack, most sites count the number of failed logins and, after a certain number (perhaps as few as three), temporarily prevent further login attempts from a particular computer. This renders the attack impractical by increasing the time required to find the right password.</p>
<p class="indent">A different form of dictionary attack is used when an attacker has acquired a copy of a hashed and encrypted password table. In this case, the attacker hashes each password in the dictionary and compares it to each of the hash codes in the stolen table. When a match is discovered, the attacker knows the password that generates that user’s hash code. To save time, the attacker can run all the passwords in the dictionary through a selected hash function once and store the results in a dictionary like in <a href="ch02.html#ch2tab3">Table 2-3</a>.</p>
<p class="tablet"><a id="page_29"/><a id="ch2tab3"/><strong>Table 2-3:</strong> Dictionary with Hash Codes</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="100%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Password</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>MD5 hash code</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table" valign="top"><p class="table">password</p></td>
<td class="table" valign="top"><p class="table">126,680,608,771,750,945,340,162,210,354,335,764,377</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">123456</p></td>
<td class="table" valign="top"><p class="table">299,132,688,689,127,175,738,334,524,183,350,839,358</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">football</p></td>
<td class="table" valign="top"><p class="table">74,046,754,153,250,065,911,729,167,268,259,247,040</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">mypassword</p></td>
<td class="table" valign="top"><p class="table">69,792,856,232,803,413,714,004,936,714,872,372,804</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">abcdef</p></td>
<td class="table" valign="top"><p class="table">308,439,634,705,511,765,949,277,356,614,095,247,246</p></td>
</tr>
</tbody>
</table>
<p class="indent">Dictionaries demonstrate why it is important for users to choose passwords that aren’t obvious. The more obscure a password, the less likely it will be in an attacker’s dictionary.</p>
<h4 class="h4" id="ch02lev2sec11"><strong><em>Hash Tables</em></strong></h4>
<p class="noindent">Unfortunately, an attacker can dispense with the dictionary altogether and build a table of randomly generated passwords and their corresponding hash codes, which I’ll call a <em>precomputed hash table</em>. Of course, the number of potential passwords is enormous, so if the attacker wants a decent chance of getting a match, the hash table needs to be huge. Building a precomputed hash table takes a lot of computing power and time, but it only has to be built once, and then it can be used over and over again.</p>
<p class="indent">One weakness of the table is that its sheer size can make searching for a match extremely slow. When you consider how fast a word processor can find a particular word in a large document, this may seem surprising, but these precomputed tables are much larger than any file on your computer. Suppose an attacker has a table of all passwords composed of 10 or fewer uppercase and lowercase letters and digits. Even with these restrictions, the number of potential passwords is 62<sup>10</sup>, which is 839,299,365,868,340,224. The precomputed hash table won’t need every one of these potential passwords as entries, but it would need to have a sizable fraction. The table would be so large, though, it couldn’t fit in a computer’s internal memory. It couldn’t even fit on a hard drive—or just to get to the point, it’s so big it might need to be split across a million hard drives. And that’s just the storage problem. Unless you have the distributed computing power of Google, it’s not practical to search a table that large. (And searching a huge mass of data isn’t easy even for Google; we’ll explore searching in detail in <a href="ch07.html#ch07">Chapter 7</a>.)</p>
<h4 class="h4" id="ch02lev2sec12"><strong><em>Hash Chaining</em></strong></h4>
<p class="noindent">Because a precomputed hash table is too large to store and search, attackers use a clever technique called <em>hash chaining</em> to drastically reduce the number of entries in the table without reducing its effectiveness. This technique uses a different type of function called a <em>reduction function</em> that does the same <a id="page_30"/>sorts of mathematical gyrations as a hash function but with the opposite purpose. Instead of creating a hash code from a password, it creates a password from a hash code—not the password that produced the hash, but simply a sequence of characters with the form of a valid password.</p>
<p class="indent">Here’s an example of hash chaining. When <em>glopp26taz</em> is hashed using MD5, it produces this hash code:</p>
<p class="center">22,964,925,579,257,552,835,515,378,304,344,866,835</p>
<p class="indent">A reduction function transforms this hash code into another valid password, say, <em>7HGupp2tss</em>. This, in turn, is sent through the hash function, producing another hash code, which is sent through the reduction function to generate another password, and so on. An alternating series of passwords and hash codes, such as that shown in <a href="ch02.html#ch2fig7">Figure 2-7</a>, is a <em>hash chain</em>.</p>
<div class="image"><img alt="image" src="graphics/f02-07.jpg"/></div>
<p class="figuret"><a id="ch2fig7"/><em>Figure 2-7: In a hash chain, a hash function (H) alternates with a reduction function (R) that produces an arbitrary password from a hash code.</em></p>
<p class="indent">Instead of a table of passwords and hash codes, the attacker generates a series of hash chains, each of the same length, storing only the first and last links of each chain. The chain in <a href="ch02.html#ch2fig7">Figure 2-7</a> is shown as the third entry in <a href="ch02.html#ch2tab4">Table 2-4</a>. This table has 5 entries, but each entry is a chain of 3 password/hash pairs, making this the equivalent of a plain table of 15 entries.</p>
<p class="tablet"><a id="page_31"/><a id="ch2tab4"/><strong>Table 2-4:</strong> Hash Chain Table</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="100%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Start</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>End</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table" valign="top"><p class="table">sop3H4Yzai</p></td>
<td class="table" valign="top"><p class="table">302,796,960,148,170,554,741,517,711,430,674,339,836</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">5jhfHTeu4y</p></td>
<td class="table" valign="top"><p class="table">333,226,570,587,833,594,170,987,787,116,324,792,461</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">glopp26taz</p></td>
<td class="table" valign="top"><p class="table">33,218,269,111,507,728,124,938,049,521,416,301,013</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">YYhs9j2a22</p></td>
<td class="table" valign="top"><p class="table">145,483,602,575,738,705,325,298,600,400,764,586,970</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">Pr2u912mn1</p></td>
<td class="table" valign="top"><p class="table">737,08,819,301,203,417,973,443,363,267,460,459,460</p></td>
</tr>
</tbody>
</table>
<p class="indent"><a href="ch02.html#ch2fig8">Figure 2-8</a> shows an example of using the table. Our attacker is trying to recover the password for the target hash code 117,182,660,124,686,473, 413,705,332,853,526,309,255. The attacker must determine which chain in the table, if any, contains the target hash code. First, the target code is compared against every number in the End column of the table. In this case, no match is found, so the attacker runs the target hash code through the reduction function to make a new password, runs that result through the hashing function, and then searches for this new hash code in the End column of the table. This process will continue until a match is found, or after the process is run three times (the length of the chains in this table).</p>
<p class="indent">In this case, the initial target hash value is reduced to the password <em>pRh7T63y</em>, which, in turn, is hashed, and this new hash value appears in the third entry of the table, in the chain with the starting password <em>glopp26taz</em>. That identifies the hash chain in which the target password may appear, but the attacker must obtain the password by iterating through this chain. The starting password in that chain is hashed; the resulting hash value is not a match for the initial hash value, so it is reduced to a new password, <em>7HGupp2tss</em>, and hashed again. This hash code <em>does</em> match, which means <em>7HGupp2tss</em> is the password.</p>
<p class="indent">Hash code chains dramatically shrink the table while still providing the same amount of searchable data. For example, if a chain has 100 passwords and 100 hash codes, then the password matching any of those hash codes can be indirectly retrieved using that chain, even though the chain has only one password and hash code in the table. Therefore, a table with chains that long has the power of a regular precomputed hash table 100 times larger.</p>
<p class="indent">There are some potential snags, though. For one, searching takes more computational effort with hash chains. Also, because of collisions—multiple passwords that produce the same hash code—a matching chain doesn’t necessarily contain the searched-for hash code and its matching password, a problem known as <em>chain merging</em>. These are small consolations for those of us worried about our data security, however. There are methods for reducing the chain merging problem, but even without them, it’s clear that effective precomputed tables can be made for particular hash functions, rendering the passwords that use them vulnerable.</p>
<div class="image"><a id="page_32"/><img alt="image" src="graphics/f02-08.jpg"/></div>
<p class="figuret"><a id="ch2fig8"/><em>Figure 2-8: Using a hash chain table to find a password that produces a particular hash code. Neither the password nor the hash code is listed in the table.</em></p>
<h4 class="h4" id="ch02lev2sec13"><strong><em>Iterative Hashing</em></strong></h4>
<p class="noindent">One way to thwart the creation of precomputed hash tables is to apply the hash function more than once. Because the output of a hash function can itself be hashed, the original password can pass through the same hash function any number of times. This technique, unhelpfully, is also known as <em>hash chaining</em>, but to avoid confusion, I will refer to it as <em>iterative hashing</em>. <a href="ch02.html#ch2fig9">Figure 2-9</a> shows a five-deep iterative hashing of the password <em>football</em>.</p>
<div class="image"><a id="page_33"/><img alt="image" src="graphics/f02-09.jpg"/></div>
<p class="figuret"><a id="ch2fig9"/><em>Figure 2-9: Applying a hash function repeatedly</em></p>
<p class="indent">With this technique, passwords are repeatedly hashed when the password is stored and when the user logs in. To thwart this, the attacker has to produce a table based on the same idea, running the chosen hash code function the same number of times. From Kerchkoffs’s principle, we know that cryptographic systems shouldn’t depend on keeping their methods secret. The goal of iterative hashing isn’t to disguise how many times the password is hashed, but to make the creation of the attacker’s precomputed hash table as difficult as possible. In the example, the password runs through the hash function five times. That would multiply the time needed to create the attacker’s table by five as well. In real-world use, passwords can be run through hash functions hundreds or thousands of times. Is this enough to prevent the creation of useful precomputed hash tables? Maybe. Computers get faster every day. For the most part, this is wonderful, but the downside to ever-increasing computational power is that it keeps pushing the boundary of practical limitations, and so much of our information security is based on these practical limitations.</p>
<p class="indent">Someone setting up a password system based on iterative hashing has to choose the number of iterations. It’s fairly easy to choose a number that provides good security today. What’s difficult is predicting the number of iterations required a year from now, or 2 years, or 10.</p>
<p class="indent">You might think the best choice is some impossibly large number to guard against the power of future computers. The problem is that today’s computers would have real trouble processing legitimate logins. Would you be willing to wait five minutes to access one of your online accounts?</p>
<h4 class="h4" id="ch02lev2sec14"><a id="page_34"/><strong><em>Salting Passwords</em></strong></h4>
<p class="noindent">Authentication systems need a way to strengthen hashing without a performance-crushing number of hash iterations; that is, they need a method of storing passwords that requires an impractical time investment from attackers without creating an equally unrealistic time burden on legitimate access. That method is called <em>salt</em>. Salt is an apt term for this concept, and I commend whoever came up with it. In culinary usage, a pinch of salt profoundly changes the flavor of a dish. In cryptography, a small quantity of salt sprinkled on a password dramatically changes its hash code.</p>
<p class="indent">Here’s how it works: when a new user signs up for an account and selects a username and password, the system automatically generates the salt for that account. The salt is a string of characters, like a short, random password, that is combined with the user’s password before hashing. For example, user <em>mrgutman</em> chooses <em>falcon</em> as his password, and the system generates <em>h38T2</em> as the salt.</p>
<p class="indent">The salt and password can be combined in various ways, but the simplest is appending the salt to the end of the password, resulting in <em>falconh38T2</em> in this example. This combination is then hashed, and the hash code stored in the authentication table along with the username and the salt, as shown in <a href="ch02.html#ch2tab5">Table 2-5</a>.</p>
<p class="tablet"><a id="ch2tab5"/><strong>Table 2-5:</strong> Password Table Using Salt</p>
<table border="0" cellpadding="0" cellspacing="0" class="topbot" width="100%">
<thead>
<tr>
<td class="table_th" valign="top"><p class="table"><strong>Username</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Salt</strong></p></td>
<td class="table_th" valign="top"><p class="table"><strong>Hash of password + salt</strong></p></td>
</tr>
</thead>
<tbody>
<tr>
<td class="table" valign="top"><p class="table">richguy22</p></td>
<td class="table" valign="top"><p class="table">7Pmnq</p></td>
<td class="table" valign="top"><p class="table">106,736,954,704,360,738,602,545,963,558,770,944,412</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">mrgutman</p></td>
<td class="table" valign="top"><p class="table">h38T2</p></td>
<td class="table" valign="top"><p class="table">142,858,562,082,404,032,402,440,010,972,328,251,653</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">squire</p></td>
<td class="table" valign="top"><p class="table">93ndy</p></td>
<td class="table" valign="top"><p class="table">122,446,997,766,728,224,659,318,737,810,478,984,316</p></td>
</tr>
<tr>
<td class="table" valign="top"><p class="table">burgomeister78</p></td>
<td class="table" valign="top"><p class="table">HuOw2</p></td>
<td class="table" valign="top"><p class="table">64,383,697,378,169,783,622,186,691,431,070,835,777</p></td>
</tr>
</tbody>
</table>
<p class="indent">Each time a user requests access, the salt is added to the end of the entered password before hashing. An attacker who acquires a copy of this authentication table can’t get much use out of a precomputed hash table. Although the table might have a password that hashes to the given code, that password won’t produce the right code when combined with the salt. Instead, the attacker would need to create a table for a specific salt. That could be done, but remember that the salt is randomly chosen. If there are, say, 100,000 users in a stolen authentication table, and the salts are numerous enough that no salt is duplicated in the table, the attacker will need to create 100,000 tables. At this point, we can’t even call them precomputed tables because the attacker is creating them for each attack.</p>
<h4 class="h4" id="ch02lev2sec15"><a id="page_35"/><strong><em>Are Password Tables Safe?</em></strong></h4>
<p class="noindent">Salting and iterative hashing are typically used together, creating real headaches for an attacker. Iterative hashing increases the time requirement for creating a single precomputed hash table, and salting means an attacker has to make a multitude of tables. But is this combination enough?</p>
<p class="indent">There is no definitive answer to that question. Cryptography researchers and security experts continue to develop new defenses against unauthorized access. At the same time, though, attackers continue to find new methods to penetrate defenses. Advances in computational power and programming theory help whichever side takes advantage of them first.</p>
<p class="indent">Perhaps the most important lesson of this discussion is that security is often out of the user’s hands. There will always be vulnerabilities, but there’s no way for a user to know if a particular site or service is employing the best security practices. The salt technique, for example, benefits only systems that use it, and not every system does.</p>
<h3 class="h3" id="ch02lev1sec05"><strong>Password Storage Services</strong></h3>
<p class="noindent">That’s how passwords are stored on remote authentication systems. What about on the user end? How do we safely store our passwords?</p>
<p class="indent">A long time ago, I had so few passwords that I could safely entrust them to my memory, but eventually I knew I had to store passwords outside of my head. Writing the passwords on a piece of paper, though, is just a different kind of security liability. For a while, I had an elaborate homebrew solution involving a <em>.txt</em> file encrypted with AES and stored on a memory card that was kept in a metal box that was probably not 100 percent fireproof. This arrangement worked, except that every time I needed to look up a password, I had to go to the box, get the memory card, slot it into my computer, double-click the file, type the password (the one password I had to remember), and find the desired entry in my table.</p>
<p class="indent">Eventually I threw in the towel and signed up for a web-based password storage service. When I created an account with the service, I chose a master password. I then stored all my other passwords and usernames on this website. This information is stored in a way that renders it of little use to anyone who gains access to the raw data, so if my password at Amazon is <em>chickenfat</em> (it isn’t), then the word <em>chickenfat</em> isn’t stored anywhere on the password storage server. Instead, the passwords are encrypted by a program on my browser before being sent to the password storage site, using my chosen master password to generate the encryption key. Therefore, even if the server were breached, the attacker wouldn’t be able to retrieve my individual passwords without the master password.</p>
<p class="indent">The master password itself is not stored on the password storage site, either. When the encryption key is needed to encrypt or decrypt an individual login, the master password is salted and then hashed repeatedly, for as many iterations as I specify.</p>
<p class="indent"><a id="page_36"/>Although using a password storage service puts all of my eggs in one basket, so to speak, this frees me to use best practices for individual logins. Whereas previously I might have created passwords that were collages of words and numbers I thought I could remember, now my passwords are lengthy random jumbles. And they are all different because I no longer need to remember them all.</p>
<h3 class="h3" id="ch02lev1sec06"><strong>A Final Thought</strong></h3>
<p class="noindent">In all of this talk about authentication systems, I’ve avoided a crucial detail. Authentication systems compare stored user passwords to passwords provided during logons, but how does the remote computer doing the authentication get the users’ chosen passwords in the first place? Secure transmission requires encryption, which implies the users would have had to encrypt the passwords—but how could the remote system decrypt the encrypted passwords without having the passwords already? This brings us back to the shared key problem—none of what we talked about in this chapter can work unless that problem is solved. So that’s what we’ll do next.</p>
</body></html>