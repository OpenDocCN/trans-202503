["```\nstatic\n    u128    :uns128 := 123456789012345678901233567890;\n    i64     :int64  := −12345678901234567890;\n    lw      :lword  := $1234_5678_90ab_cdef_0000_ffff;\n```", "```\nmath.addq( *`left64`*, *`right64`*, *`dest64`* );\n    math.addl( *`left128`*, *`right128`*, *`dest128`* );\n```", "```\n*`dest64`* := *`left64`* + *`right64`*;    // *`dest64`*, *`left64`*, and *`right64`*\n                               // must be 8-byte operands\n*`dest128`* := *`left128`* + *`right128`*; // *`dest128`*, *`left128`*, and *`right128`*\n                               // must be 16-byte operands\n```", "```\nmath.andq( *`left64`*, *`right64`*, *`dest64`* );\n    math.andl( *`left128`*, *`right128`*, *`dest128`* );\n    math.divq( *`left64`*, *`right64`*, *`dest64`* );\n    math.divl( *`left128`*, *`right128`*, *`dest128`* );\n    math.idivq( *`left64`*, *`right64`*, *`dest64`* );\n    math.idivl( *`left128`*, *`right128`*, *`dest128`* );\n    math.modq( *`left64`*, *`right64`*, *`dest64`* );\n    math.modl( *`left128`*, *`right128`*, *`dest128`* );\n    math.imodq( *`left64`*, *`right64`*, *`dest64`* );\n    math.imodl( *`left128`*, *`right128`*, *`dest128`* );\n    math.mulq( *`left64`*, *`right64`*, *`dest64`* );\n    math.mull( *`left128`*, *`right128`*, *`dest128`* );\n    math.imulq( *`left64`*, *`right64`*, *`dest64`* );\n    math.imull( *`left128`*, *`right128`*, *`dest128`* );\n    math.orq( *`left64`*, *`right64`*, *`dest64`* );\n    math.orl( *`left128`*, *`right128`*, *`dest128`* );\n    math.subq( *`left64`*, *`right64`*, *`dest64`* );\n    math.subl( *`left128`*, *`right128`*, *`dest128`* );\n    math.xorq( *`left64`*, *`right64`*, *`dest64`* );\n    math.xorl( *`left128`*, *`right128`*, *`dest128`* );\n```", "```\n*`dest64`* := *`left64 op right64`*;\n*`dest128`* := *`left128 op right128`*;\n```", "```\nmath.negq( source:qword; var dest:qword );\nmath.negl( source:lword; var dest:lword );\nmath.notq( source:qword; var dest:qword );\nmath.notl( source:lword; var dest:lword );\nmath.shlq( count:uns32; source:qword; var dest:qword );\nmath.shll( count:uns32; source:lword; var dest:lword );\nmath.shrq( count:uns32; source:qword; var dest:qword );\nmath.shrl( count:uns32; source:lword; var dest:lword );\n```", "```\nStep 1: Add the least significant digits together:\n\n             289                      289\n            +456    produces         +456\n            ----                     ----\n                                        5 with carry 1.\n\n    Step 2: Add the next significant digits plus the carry:\n\n               1 (previous carry)\n             289                         289\n            +456        produces        +456\n            ----                        ----\n               5                          45 with carry 1.\n\n    Step 3: Add the most significant digits plus the carry:\n\n                                       1 (previous carry)\n             289                     289\n            +456        produces    +456\n            ----                    ----\n              45                     745\n```", "```\nadc( *`source`*, *`dest`* );  // *`dest`* := *`dest`* + *`source`* + C\n```", "```\nstatic\n    X: qword;\n    Y: qword;\n```", "```\nmov( (type dword X), eax );          // Add together the L.O. 32 bits\n    add( (type dword Y), eax );          // of the numbers and store the\n    mov( eax, (type dword Z) );          // result into the L.O. dword of Z.\n\n    mov( (type dword X[4]), eax );       // Add together (with carry) the\n    adc( (type dword Y[4]), eax );       // H.O. 32 bits and store the result\n    mov( eax, (type dword Z[4]) );       // into the H.O. dword of Z.\n```", "```\ntype\n    tBig: dword[4];           // Storage for four dwords is 128 bits.\n\nstatic\n    BigVal1: tBig;\n    BigVal2: tBig;\n    BigVal3: tBig;\n     .\n     .\n     .\n    mov( BigVal1[0], eax );   // Note there is no need for (type dword BigValx)\n    add( BigVal2[0], eax );   // because the base type of BitValx is dword.\n    mov( eax, BigVal3[0] );\n\n    mov( BigVal1[4], eax );\n    adc( BigVal2[4], eax );\n    mov( eax, BigVal3[4] );\n\n    mov( BigVal1[8], eax );\n    adc( BigVal2[8], eax );\n    mov( eax, BigVal3[8] );\n\n    mov( BigVal1[12], eax );\n    adc( BigVal2[12], eax );\n    mov( eax, BigVal3[12] );\n```", "```\nstatic\n    Left:        qword;\n    Right:       qword;\n    Diff:        qword;\n         .\n         .\n         .\n    mov( (type dword Left), eax );\n    sub( (type dword Right), eax );\n    mov( eax, (type dword Diff) );\n\n    mov( (type dword Left[4]), eax );\n    sbb( (type dword Right[4]), eax );\n    mov( (type dword Diff[4]), eax );\n```", "```\ntype\n    tBig: dword[4];  // Storage for four dwords is 128 bits.\n\nstatic\n    BigVal1: tBig;\n    BigVal2: tBig;\n    BigVal3: tBig;\n     .\n     .\n     .\n\n    // Compute BigVal3 := BigVal1 - BigVal2\n\n    mov( BigVal1[0], eax ); // Note there is no need for (type dword BigValx)\n    sub( BigVal2[0], eax ); // because the base type of BitValx is dword.\n    mov( eax, BigVal3[0] );\n\n    mov( BigVal1[4], eax );\n    sbb( BigVal2[4], eax );\n    mov( eax, BigVal3[4] );\n\n    mov( BigVal1[8], eax );\n    sbb( BigVal2[8], eax );\n    mov( eax, BigVal3[8] );\n\n    mov( BigVal1[12], eax );\n    sbb( BigVal2[12], eax );\n    mov( eax, BigVal3[12] );\n```", "```\n// This sequence transfers control to location \"IsGreater\" if\n// QwordValue > QwordValue2\\. It transfers control to \"IsLess\" if\n// QwordValue < QwordValue2\\. It falls through to the instruction\n// following this sequence if QwordValue = QwordValue2\\. To test for\n// inequality, change the \"IsGreater\" and \"IsLess\" operands to \"NotEqual\"\n// in this code.\n\n        mov( (type dword QWordValue[4]), eax );  // Get H.O. dword.\n        cmp( eax, (type dword QWordValue2[4]));\n        jg IsGreater;\n        jl IsLess;\n\n        mov( (type dword QWordValue[0]), eax );  // If H.O. dwords were equal,\n        cmp( eax, (type dword QWordValue2[0]));  // then we must compare the\n        jg IsGreater;                            // L.O. dwords.\n        jl IsLess;\n\n// Fall through to this point if the two values were equal.\n```", "```\nstatic\n    QW1: qword;\n    QW2: qword;\n\nconst\n    QW1d: text := \"(type dword QW1)\";\n    QW2d: text := \"(type dword QW2)\";\n```", "```\nmov( QW1d[4], eax );   // Get H.O. dword.\n    cmp( eax, QW2d[4] );\n    jg NotLess;\n    jl IsLess;\n\n    mov( QW1d[0], eax );   // Fall through to here if the H.O. dwords are equal.\n    cmp( eax, QW2d[0] );\n    jl IsLess;\nNotLess:\n```", "```\nmov( QW1d[4], eax );   // Get H.O. dword.\n    cmp( eax, QW2d[4] );\n    jg NotLessEQ;\n    jl IsLessEQ;\n\n    mov( QW1d[0], eax );   // Fall through to here if the H.O. dwords are equal.\n    cmp( eax, QW2d[0] );\n    jle IsLessEQ;\nNotLessEQ:\n```", "```\nmov( QW1d[4], eax );   // Get H.O. dword.\n    cmp( eax, QW2d[4] );\n    jg IsGtr;\n    jl NotGtr;\n\n    mov( QW1d[0], eax );   // Fall through to here if the H.O. dwords are equal.\n    cmp( eax, QW2d[0] );\n    jg IsGtr;\nNotGtr:\n```", "```\nmov( QW1d[4], eax );   // Get H.O. dword.\n    cmp( eax, QW2d[4] );\n    jg IsGtrEQ;\n    jl NotGtrEQ;\n\n    mov( QW1d[0], eax );   // Fall through to here if the H.O. dwords are equal.\n    cmp( eax, QW2d[0] );\n    jge IsGtrEQ;\nNotGtrEQ:\n```", "```\nmov( QW1d[4], eax );   // Get H.O. dword.\n    cmp( eax, QW2d[4] );\n    jne NotEqual;\n\n    mov( QW1d[0], eax );   // Fall through to here if the H.O. dwords are equal.\n    cmp( eax, QW2d[0] );\n    je IsEqual;\nNotEqual:\n```", "```\nmov( QW1d[4], eax );   // Get H.O. dword.\n    cmp( eax, QW2d[4] );\n    jne IsNotEqual;\n\n    mov( QW1d[0], eax );   // Fall through to here if the H.O. dwords are equal.\n    cmp( eax, QW2d[0] );\n    jne IsNotEqual;\n\n// Fall through to this point if they are equal.\n```", "```\nif\n( #{\n    mov( QW1d[4], eax );\n    cmp( eax, QW2d[4] );\n    jg true;\n\n    mov( QW1d[0], eax );\n    cmp( eax, QW2d[0] );\n    jng false;\n}# ) then\n\n    << Code to execute if QW1 > QW2 >>\n\nelse\n\n    << Code to execute if QW1 <= QW2 >>\n\nendif;\n```", "```\nstatic\n    Big1: uns128;\n    Big2: uns128;\n     .\n     .\n     .\n    if\n    ( #{\n        mov( Big1[12], eax );\n        cmp( eax, Big2[12] );\n        jb true;\n        ja false;\n        mov( Big1[8], eax );\n        cmp( eax, Big2[8] );\n        jb true;\n        ja false;\n        mov( Big1[4], eax );\n        cmp( eax, Big2[4] );\n        jb true;\n        ja false;\n        mov( Big1[0], eax );\n        cmp( eax, Big2[0] );\n        jnbe false;\n    }# ) then\n\n        << Code to execute if Big1 <= Big2 >>\n\n    else\n\n        << Code to execute if Big1 > Big2 >>\n\n    endif;\n```", "```\n1) Multiply the first two              2) Multiply 5*2:\n           digits together (5*3):\n\n            123                                      123\n             45                                       45\n            ---                                      ---\n             15                                       15\n                                                      10\n\n         3) Multiply 5*1:                       4) Multiply 4*3:\n\n            123                                      123\n             45                                       45\n            ---                                      ---\n             15                                       15\n             10                                       10\n              5                                        5\n                                                      12\n\n         5) Multiply 4*2:                       6) Multiply 4*1:\n\n             123                                     123\n              45                                      45\n             ---                                     ---\n              15                                      15\n              10                                      10\n               5                                       5\n              12                                      12\n               8                                       8\n                                                       4\n\n         7) Add all the partial products together:\n\n             123\n              45\n             ---\n              15\n              10\n               5\n              12\n               8\n               4\n          ------\n            5535\n```", "```\nprogram testMUL64;\n#include( \"stdlib.hhf\" )\n\nprocedure MUL64( Multiplier:qword; Multiplicand:qword; var Product:lword );\nconst\n    mp: text := \"(type dword Multiplier)\";\n    mc: text := \"(type dword Multiplicand)\";\n    prd:text := \"(type dword [edi])\";\n\nbegin MUL64;\n\n    mov( Product, edi );\n\n    // Multiply the L.O. dword of Multiplier times Multiplicand.\n\n    mov( mp, eax );\n    mul( mc, eax );     // Multiply L.O. dwords.\n    mov( eax, prd );    // Save L.O. dword of product.\n    mov( edx, ecx );    // Save H.O. dword of partial product result.\n\n    mov( mp, eax );\n    mul( mc[4], eax );  // Multiply mp(L.O.) * mc(H.O.)\n    add( ecx, eax );    // Add to the partial product.\n    adc( 0, edx );      // Don't forget the carry!\n    mov( eax, ebx );    // Save partial product for now.\n    mov( edx, ecx );\n\n    // Multiply the H.O. word of Multiplier with Multiplicand.\n\n    mov( mp[4], eax );  // Get H.O. dword of Multiplier.\n    mul( mc, eax );     // Multiply by L.O. word of Multiplicand.\n    add( ebx, eax );    // Add to the partial product.\n    mov( eax, prd[4] ); // Save the partial product.\n    adc( edx, ecx );    // Add in the carry!\n\n    mov( mp[4], eax );  // Multiply the two H.O. dwords together.\n    mul( mc[4], eax );\n    add( ecx, eax );    // Add in partial product.\n    adc( 0, edx );      // Don't forget the carry!\n    mov( eax, prd[8] ); // Save the partial product.\n    mov( edx, prd[12] );\n\nend MUL64;\n\nstatic\n    op1: qword;\n    op2: qword;\n    rslt: lword;\n\nbegin testMUL64;\n\n    // Initialize the qword values (note that static objects\n    // are initialized with 0 bits).\n\n    mov( 1234, (type dword op1 ));\n    mov( 5678, (type dword op2 ));\n    MUL64( op1, op2, rslt );\n\n    // The following only prints the L.O. qword, but\n    // we know the H.O. qword is 0 so this is okay.\n\n    stdout.put( \"rslt=\" );\n    stdout.putu64( (type qword rslt));\n\nend testMUL64;\n```", "```\nstatic\n    dividend: dword[2] := [$1234, 4];  // = $4_0000_1234.\n    divisor:  dword := 2;              // dividend/divisor = $2_0000_091A\n    quotient: dword[2];\n    remainder:dword;\n     .\n     .\n     .\n    mov( divisor, ebx );\n    mov( dividend[4], eax );\n    xor( edx, edx );            // Zero extend for unsigned division.\n    div( ebx, edx:eax );\n    mov( eax, quotient[4] );    // Save H.O. dword of the quotient (2).\n    mov( dividend[0], eax );    // Note that this code does *NOT* zero extend\n    div( ebx, edx:eax );        // eax into edx before this div instr.\n    mov( eax, quotient[0] );    // Save L.O. dword of the quotient ($91a).\n    mov( edx, remainder );      // Save away the remainder.\n```", "```\n// This code does *NOT* work!\n\n    mov( dividend[0], eax );    // Get dividend into edx:eax\n    mov( dividend[4], edx );\n    div( divisor, edx:eax );    // Divide edx:eax by divisor.\n```", "```\nprogram testDiv128;\n#include( \"stdlib.hhf\" )\n\nprocedure div128\n(\n        Dividend:   lword;\n        Divisor:    dword;\n    var QuotAdrs:   lword;\n    var Remainder:  dword\n);  @nodisplay;\n\nconst\n    Quotient: text := \"(type dword [edi])\";\n\nbegin div128;\n\n    push( eax );\n    push( edx );\n    push( edi );\n\n    mov( QuotAdrs, edi );       // Pointer to quotient storage.\n\n    mov( (type dword Dividend[12]), eax ); // Begin division with the H.O. dword.\n    xor( edx, edx );            // Zero extend into edx.\n    div( Divisor, edx:eax );    // Divide H.O. dword.\n    mov( eax, Quotient[12] );   // Store away H.O. dword of quotient.\n\n    mov( (type dword Dividend[8]), eax ); // Get dword #2 from the dividend.\n    div( Divisor, edx:eax );    // Continue the division.\n    mov( eax, Quotient[8] );    // Store away dword #2 of the quotient.\n\n    mov( (type dword Dividend[4]), eax ); // Get dword #1 from the dividend.\n    div( Divisor, edx:eax );    // Continue the division.\n    mov( eax, Quotient[4] );    // Store away dword #1 of the quotient.\n\n    mov( (type dword Dividend[0]), eax );    // Get the L.O. dword of the\n                                             // dividend.\n    div( Divisor, edx:eax );    // Finish the division.\n    mov( eax, Quotient[0] );    // Store away the L.O. dword of the quotient.\n\n    mov( Remainder, edi );      // Get the pointer to the remainder's value.\n    mov( edx, [edi] );          // Store away the remainder value.\n\n    pop( edi );\n    pop( edx );\n    pop( eax );\n\nend div128;\n\nstatic\n    op1:    lword   := $8888_8888_6666_6666_4444_4444_2222_2221;\n    op2:    dword   := 2;\n    quo:    lword;\n    rmndr:  dword;\n\nbegin testDiv128;\n\n    div128( op1, op2, quo, rmndr );\n\n    stdout.put\n    (\n        nl\n        nl\n        \"After the division: \" nl\n        nl\n        \"Quotient = $\",\n        quo[12], \"_\",\n        quo[8], \"_\",\n        quo[4], \"_\",\n        quo[0], nl\n\n        \"Remainder = \", (type uns32 rmndr )\n    );\n\nend testDiv128;\n```", "```\nQuotient := Dividend;\nRemainder := 0;\nfor i := 1 to NumberBits do\n\n    Remainder:Quotient := Remainder:Quotient SHL 1;\n    if Remainder >= Divisor then\n\n        Remainder := Remainder - Divisor;\n        Quotient := Quotient + 1;\n\n    endif\nendfor\n```", "```\nprogram testDiv128b;\n#include( \"stdlib.hhf\" )\n\n// div128-\n//\n// This procedure does a general 128/128 division operation using the\n// following algorithm (all variables are assumed to be 128-bit objects):\n//\n// Quotient := Dividend;\n// Remainder := 0;\n// for i := 1 to NumberBits do\n//\n//  Remainder:Quotient := Remainder:Quotient SHL 1;\n//  if Remainder >= Divisor then\n//\n//      Remainder := Remainder - Divisor;\n//      Quotient := Quotient + 1;\n//\n//  endif\n// endfor\n//\n\nprocedure div128\n(\n        Dividend:   lword;\n        Divisor:    lword;\n    var QuotAdrs:   lword;\n    var RmndrAdrs:  lword\n);  @nodisplay;\n\nconst\n    Quotient: text := \"Dividend\";   // Use the Dividend as the Quotient.\n\nvar\n    Remainder: lword;\n\nbegin div128;\n\n    push( eax );\n    push( ecx );\n    push( edi );\n\n    mov( 0, eax );                  // Set the remainder to 0.\n    mov( eax, (type dword Remainder[0]) );\n    mov( eax, (type dword Remainder[4]) );\n    mov( eax, (type dword Remainder[8]) );\n    mov( eax, (type dword Remainder[12]));\n\n    mov( 128, ecx );                // Count off 128 bits in ecx.\n    repeat\n\n        // Compute Remainder:Quotient := Remainder:Quotient SHL 1:\n\n        shl( 1, (type dword Dividend[0]) );  // See Section 8.1.12 to see\n        rcl( 1, (type dword Dividend[4]) );  // how this code shifts 256\n        rcl( 1, (type dword Dividend[8]) );  // bits to the left by 1 bit.\n        rcl( 1, (type dword Dividend[12]));\n        rcl( 1, (type dword Remainder[0]) );\n        rcl( 1, (type dword Remainder[4]) );\n        rcl( 1, (type dword Remainder[8]) );\n        rcl( 1, (type dword Remainder[12]));\n\n        // Do a 128-bit comparison to see if the remainder\n        // is greater than or equal to the divisor.\n\n        if\n        ( #{\n            mov( (type dword Remainder[12]), eax );\n            cmp( eax, (type dword Divisor[12]) );\n            ja true;\n            jb false;\n\n            mov( (type dword Remainder[8]), eax );\n            cmp( eax, (type dword Divisor[8]) );\n            ja true;\n            jb false;\n\n            mov( (type dword Remainder[4]), eax );\n            cmp( eax, (type dword Divisor[4]) );\n            ja true;\n            jb false;\n\n            mov( (type dword Remainder[0]), eax );\n            cmp( eax, (type dword Divisor[0]) );\n            jb false;\n        }# ) then\n\n            // Remainder := Remainder - Divisor\n\n            mov( (type dword Divisor[0]), eax );\n            sub( eax, (type dword Remainder[0]) );\n\n            mov( (type dword Divisor[4]), eax );\n            sbb( eax, (type dword Remainder[4]) );\n\n            mov( (type dword Divisor[8]), eax );\n            sbb( eax, (type dword Remainder[8]) );\n\n            mov( (type dword Divisor[12]), eax );\n            sbb( eax, (type dword Remainder[12]) );\n\n            // Quotient := Quotient + 1;\n\n            add( 1, (type dword Quotient[0]) );\n            adc( 0, (type dword Quotient[4]) );\n            adc( 0, (type dword Quotient[8]) );\n            adc( 0, (type dword Quotient[12]) );\n\n        endif;\n        dec( ecx );\n\n    until( @z );\n\n    // Okay, copy the quotient (left in the Dividend variable)\n    // and the remainder to their return locations.\n\n    mov( QuotAdrs, edi );\n    mov( (type dword Quotient[0]), eax );\n    mov( eax, [edi] );\n    mov( (type dword Quotient[4]), eax );\n    mov( eax, [edi+4] );\n    mov( (type dword Quotient[8]), eax );\n    mov( eax, [edi+8] );\n    mov( (type dword Quotient[12]), eax );\n    mov( eax, [edi+12] );\n\n    mov( RmndrAdrs, edi );\n    mov( (type dword Remainder[0]), eax );\n    mov( eax, [edi] );\n    mov( (type dword Remainder[4]), eax );\n    mov( eax, [edi+4] );\n    mov( (type dword Remainder[8]), eax );\n    mov( eax, [edi+8] );\n    mov( (type dword Remainder[12]), eax );\n    mov( eax, [edi+12] );\n\n    pop( edi );\n    pop( ecx );\n    pop( eax );\n\nend div128;\n\n// Some simple code to test out the division operation:\n\nstatic\n    op1:    lword    := $8888_8888_6666_6666_4444_4444_2222_2221;\n    op2:    lword    := 2;\n    quo:    lword;\n    rmndr:  lword;\n\nbegin testDiv128b;\n\n    div128( op1, op2, quo, rmndr );\n\n    stdout.put\n    (\n        nl\n        nl\n        \"After the division: \" nl\n        nl\n        \"Quotient = $\",\n        (type dword quo[12]), \"_\",\n        (type dword quo[8]), \"_\",\n        (type dword quo[4]), \"_\",\n        (type dword quo[0]), nl\n\n        \"Remainder = \", (type uns32 rmndr )\n    );\n\nend testDiv128b;\n```", "```\nneg( edx );\n    neg( eax );\n    sbb( 0, edx );\n```", "```\nstatic\n    Value: dword[4];\n     .\n     .\n     .\n    neg( Value[12] );      // Negate the H.O. double word.\n    neg( Value[8] );       // Neg previous dword in memory.\n    sbb( 0, Value[12] );   // Adjust H.O. dword.\n\n    neg( Value[4] );       // Negate the second dword in the object.\n    sbb( 0, Value[8] );    // Adjust third dword in object.\n    sbb( 0, Value[12] );   // Adjust the H.O. dword.\n\n    neg( Value );          // Negate the L.O. dword.\n    sbb( 0, Value[4] );    // Adjust second dword in object.\n    sbb( 0, Value[8] );    // Adjust third dword in object.\n    sbb( 0, Value[12] );   // Adjust the H.O. dword.\n```", "```\nstatic\n    Value: dword[5];   // 160-bit value.\n     .\n     .\n     .\n    mov( 0, eax );\n    sub( Value, eax );\n    mov( eax, Value );\n\n    mov( 0, eax );\n    sbb( Value[4], eax );\n    mov( eax, Value[4] );\n\n    mov( 0, eax );\n    sbb( Value[8], eax );\n    mov( eax, Value[8] );\n\n    mov( 0, eax );\n    sbb( Value[12], eax );\n    mov( eax, Value[12] );\n\n    mov( 0, eax );\n    sbb( Value[16], eax );\n    mov( eax, Value[16] );\n```", "```\nmov( (type dword *`source1`*), eax );\n    and( (type dword *`source2`*), eax );\n    mov( eax, (type dword *`dest`*) );\n\n    mov( (type dword *`source1`*[4]), eax );\n    and( (type dword *`source2`*[4]), eax );\n    mov( eax, (type dword *`dest`*[4]) );\n```", "```\nmov( (type dword *`source1`*), eax );\n    or( (type dword *`source2`*), eax );\n    mov( eax, (type dword *`dest`*) );\n\n    mov( (type dword *`source1`*[4]), eax );\n    or( (type dword *`source2`*[4]), eax );\n    mov( eax, (type dword *`dest`*[4]) );\n\n    mov( (type dword *`source1`*[8]), eax );\n    or( (type dword *`source2`*[8]), eax );\n    mov( eax, (type dword *`dest`*[8]) );\n```", "```\nmov( (type dword *`source1`*), eax );\n    xor( (type dword *`source2`*), eax );\n    mov( eax, (type dword *`dest`*) );\n\n    mov( (type dword *`source1`*[4]), eax );\n    xor( (type dword *`source2`*[4]), eax );\n    mov( eax, (type dword *`dest`*[4]) );\n```", "```\nnot( eax );\n    not( edx );\n```", "```\nshl( 1, eax );\n    rcl( 1, eax );\n```", "```\nshl( 1, (type dword *`Operand`*[0]) );\n    rcl( 1, (type dword *`Operand`*[4])  );\n    rcl( 1, (type dword *`Operand`*[8])  );\n```", "```\nShiftLoop:\n    shl( 1, (type dword *`Operand`*[0]) );\n    rcl( 1, (type dword *`Operand`*[4]) );\n    rcl( 1, (type dword *`Operand`*[8]) );\n    dec( ecx );\n    jnz ShiftLoop;\n```", "```\n// Extended-precision SAR:\n\n    sar( 1, (type dword *`Operand`*[8]) );\n    rcr( 1, (type dword *`Operand`*[4]) );\n    rcr( 1, (type dword *`Operand`*[0]) );\n\n// Double-precision SHR:\n\n    shr( 1, (type dword *`Operand`*[8]) );\n    rcr( 1, (type dword *`Operand`*[4]) );\n    rcr( 1, (type dword *`Operand`*[0]) );\n```", "```\nshld( *`constant`*, *`Operand1`*, *`Operand2`* );\n    shld( cl, *`Operand1`*, *`Operand2`* );\n    shrd( *`constant`*, *`Operand1`*, *`Operand2`* );\n    shrd( cl, *`Operand1`*, *`Operand2`* );\n```", "```\nstatic\n    ShiftMe: dword[3] := [ $1234, $5678, $9012 ];\n     .\n     .\n     .\n    mov( ShiftMe[4], eax )\n    shld( 6, eax, ShiftMe[8] );\n    mov( ShiftMe[0], eax );\n    shld( 6, eax, ShiftMe[4] );\n    shl( 6, ShiftMe[0] );\n```", "```\nrcl( 1, (type dword *`Operand`*[0]) );\n    rcl( 1, (type dword *`Operand`*[4])  );\n    rcl( 1, (type dword *`Operand`*[8])  );\n\n    rcr( 1, (type dword *`Operand`*[8]) );\n    rcr( 1, (type dword *`Operand`*[4])  );\n    rcr( 1, (type dword *`Operand`*[0])  );\n```", "```\n// Compute rol( 4, edx:eax );\n\n        mov( edx, ebx );\n        shld, 4, eax, edx );\n        shld( 4, ebx, eax );\n        bt( 0, eax );        // Set carry flag, if desired.\n```", "```\ntype\n    h128        :dword[4];\n    u128        :dword[4];\n    i128        :dword[4];\n```", "```\nprocedure puth128( b128: h128 ); @nodisplay;\nbegin puth128;\n\n    stdout.puth32( b128[12] );\n    stdout.puth32( b128[8] );\n    stdout.puth32( b128[4] );\n    stdout.puth32( b128[0] );\n\nend puth128;\n```", "```\nprogram out128;\n\n#include( \"stdlib.hhf\" );\n\n// 128-bit unsigned integer data type:\n\ntype\n    u128: dword[4];\n\n// DivideBy10-\n//\n//  Divides \"divisor\" by 10 using fast\n//  extended-precision division algorithm\n//  that employs the div instruction.\n//\n//  Returns quotient in \"quotient\".\n//  Returns remainder in eax.\n//  Trashes ebx, edx, and edi.\n\nprocedure DivideBy10( dividend:u128; var quotient:u128 ); @nodisplay;\nbegin DivideBy10;\n\n    mov( quotient, edi );\n    xor( edx, edx );\n    mov( dividend[12], eax );\n    mov( 10, ebx );\n    div( ebx, edx:eax );\n    mov( eax, [edi+12] );\n\n    mov( dividend[8], eax );\n    div( ebx, edx:eax );\n    mov( eax, [edi+8] );\n\n    mov( dividend[4], eax );\n    div( ebx, edx:eax );\n    mov( eax, [edi+4] );\n\n    mov( dividend[0], eax );\n    div( ebx, edx:eax );\n    mov( eax, [edi+0] );\n    mov( edx, eax );\n\nend DivideBy10;\n\n// Recursive version of putu128.\n// A separate \"shell\" procedure calls this so that\n// this code does not have to preserve all the registers\n// it uses (and DivideBy10 uses) on each recursive call.\n\nprocedure recursivePutu128( b128:u128 ); @nodisplay;\nvar\n    remainder: byte;\n\nbegin recursivePutu128;\n\n    // Divide by 10 and get the remainder (the char to print).\n\n    DivideBy10( b128, b128 );\n    mov( al, remainder );       // Save away the remainder (0..9).\n\n    // If the quotient (left in b128) is not 0, recursively\n    // call this routine to print the H.O. digits.\n\n    mov( b128[0], eax );    // If we logically OR all the dwords\n    or( b128[4], eax );     // together, the result is 0 if and\n    or( b128[8], eax );     // only if the entire number is 0.\n    or( b128[12], eax );\n    if( @nz ) then\n\n        recursivePutu128( b128 );\n\n    endif;\n\n    // Okay, now print the current digit.\n\n    mov( remainder, al );\n    or( '0', al );          // Converts 0..9 -> '0'..'9'.\n    stdout.putc( al );\n\nend recursivePutu128;\n\n// Nonrecursive shell to the above routine so we don't bother\n// saving all the registers on each recursive call.\n\nprocedure putu128( b128:u128 ); @nodisplay;\nbegin putu128;\n\n    push( eax );\n    push( ebx );\n    push( edx );\n    push( edi );\n\n    recursivePutu128( b128 );\n\n    pop( edi );\n    pop( edx );\n    pop( ebx );\n    pop( eax );\n\nend putu128;\n\n// Code to test the routines above:\n\nstatic\n    b0: u128 := [0, 0, 0, 0];             // decimal = 0\n    b1: u128 := [1234567890, 0, 0, 0];    // decimal = 1234567890\n    b2: u128 := [$8000_0000, 0, 0, 0];    // decimal = 2147483648\n    b3: u128 := [0, 1, 0, 0 ];            // decimal = 4294967296\n\n    // Largest uns128 value\n    // (decimal=340,282,366,920,938,463,463,374,607,431,768,211,455):\n\n    b4: u128 := [$FFFF_FFFF, $FFFF_FFFF, $FFFF_FFFF, $FFFF_FFFF ];\n\nbegin out128;\n\n    stdout.put( \"b0 = \" );\n    putu128( b0 );\n    stdout.newln();\n\n    stdout.put( \"b1 = \" );\n    putu128( b1 );\n    stdout.newln();\n\n    stdout.put( \"b2 = \" );\n    putu128( b2 );\n    stdout.newln();\n\n    stdout.put( \"b3 = \" );\n    putu128( b3 );\n    stdout.newln();\n\n    stdout.put( \"b4 = \" );\n    putu128( b4 );\n    stdout.newln();\n\nend out128;\n```", "```\nprocedure puti128( i128: u128 ); @nodisplay;\nbegin puti128;\n\n    if( (type int32 i128[12]) < 0 ) then\n\n        stdout.put( '-' );\n\n        // Extended-precision Negation:\n\n        push( eax );\n        mov( 0, eax );\n        sub( i128[0], eax );\n        mov( eax, i128[0] );\n\n        mov( 0, eax );\n        sbb( i128[4], eax );\n        mov( eax, i128[4] );\n\n        mov( 0, eax );\n        sbb( i128[8], eax );\n        mov( eax, i128[8] );\n\n        mov( 0, eax );\n        sbb( i128[12], eax );\n        mov( eax, i128[12] );\n        pop( eax );\n\n    endif;\n    putu128( i128 );\n\nend puti128;\n```", "```\nprocedure conv.setDelimiters( Delims:cset );\nprocedure conv.getDelimiters( var Delims:cset );\n```", "```\nstatic\n    Delimiters: cset;\n         .\n         .\n         .\n    conv.getDelimiters( Delimiters );\n\n    // Skip over leading delimiters in the string:\n\n    while( stdin.getc() in Delimiters ) do  /* getc did the work */ endwhile;\n    while( al in '0'..'9') do\n\n        // Convert character in al to numeric representation and\n        // accumulate result...\n\n        stdin.getc();\n\n    endwhile;\n    if( al not in Delimiters ) then\n\n        raise( ex.ConversionError );\n\n    endif;\n```", "```\nstatic\n    Delimiters: cset;\n         .\n         .\n         .\n        conv.getDelimiters( Delimiters );\n\n    // Skip over leading delimiters in the string:\n\n    while( stdin.peekc() in Delimiters ) do\n\n        // If at the end of the input buffer, we must explicitly read a\n        // new line of text from the user. stdin.peekc does not do this\n        // for us.\n\n        if( al = #0 ) then\n\n            stdin.ReadLn();\n\n        else\n\n            stdin.getc();  // Remove delimiter from the input stream.\n\n        endif;\n\n    endwhile;\n    while( stdin.peekc in '0'..'9') do\n\n        stdin.getc();     // Remove the input character from the input stream.\n\n        // Convert character in al to numeric representation and\n        // accumulate result...\n\n    endwhile;\n    if( al not in Delimiters ) then\n\n        raise( ex.ConversionError );\n\n    endif;\n```", "```\nwhile( stdin.peekc in {'0'..'9', '_'}) do\n\n        stdin.getc();  // Read the character from the input stream.\n\n        // Ignore underscores while processing numeric input.\n\n        if( al <> '_' ) then\n\n            // Convert character in al to numeric representation and\n            // accumulate result...\n\n        endif;\n\n    endwhile;\n```", "```\nprogram Xin128;\n\n#include( \"stdlib.hhf\" );\n\n// 128-bit unsigned integer data type:\n\ntype\n    b128: dword[4];\n\nprocedure getb128( var inValue:b128 ); @nodisplay;\nconst\n    HexChars  := {'0'..'9', 'a'..'f', 'A'..'F', '_'};\nvar\n    Delimiters: cset;\n    LocalValue: b128;\n\nbegin getb128;\n\n    push( eax );\n    push( ebx );\n\n    // Get a copy of the HLA standard numeric input delimiters:\n\n    conv.getDelimiters( Delimiters );\n\n    // Initialize the numeric input value to 0:\n\n    xor( eax, eax );\n    mov( eax, LocalValue[0] );\n    mov( eax, LocalValue[4] );\n    mov( eax, LocalValue[8] );\n    mov( eax, LocalValue[12] );\n\n    // By default, #0 is a member of the HLA Delimiters\n    // character set. However, someone may have called\n    // conv.setDelimiters and removed this character\n    // from the internal Delimiters character set. This\n    // algorithm depends upon #0 being in the Delimiters\n    // character set, so let's add that character in\n    // at this point just to be sure.\n\n    cs.unionChar( #0, Delimiters );\n\n    // If we're at the end of the current input\n    // line (or the program has yet to read any input),\n    // for the input of an actual character.\n\n    if( stdin.peekc() = #0 ) then\n\n        stdin.readLn();\n\n    endif;\n\n    // Skip the delimiters found on input. This code is\n    // somewhat convoluted because stdin.peekc does not\n    // force the input of a new line of text if the current\n    // input buffer is empty. We have to force that input\n    // ourselves in the event the input buffer is empty.\n\n    while( stdin.peekc() in Delimiters ) do\n\n        // If we're at the end of the line, read a new line\n        // of text from the user; otherwise, remove the\n        // delimiter character from the input stream.\n\n        if( al = #0 ) then\n\n            stdin.readLn(); // Force a new input line.\n\n        else\n\n            stdin.getc();   // Remove the delimiter from the input buffer.\n\n        endif;\n\n    endwhile;\n\n    // Read the hexadecimal input characters and convert\n    // them to the internal representation:\n\n    while( stdin.peekc() in HexChars ) do\n\n        // Actually read the character to remove it from the\n        // input buffer.\n\n        stdin.getc();\n\n        // Ignore underscores, process everything else.\n\n        if( al <> '_' ) then\n\n            if( al in '0'..'9' ) then\n\n                and( $f, al );  // '0'..'9' -> 0..9\n\n            else\n\n                and( $f, al );  // 'a'/'A'..'f'/'F' -> 1..6\n                add( 9, al );   // 1..6 -> 10..15\n\n            endif;\n\n            // Conversion algorithm is the following:\n            //\n            // (1) LocalValue := LocalValue * 16.\n            // (2) LocalValue := LocalValue + al\n            //\n            // Note that \"* 16\" is easily accomplished by\n            // shifting LocalValue to the left 4 bits.\n            //\n            // Overflow occurs if the H.O. 4 bits of LocalValue\n            // contain a nonzero value prior to this operation.\n\n            // First, check for overflow:\n\n            test( $F0, (type byte LocalValue[15]));\n            if( @nz ) then\n\n                raise( ex.ValueOutOfRange );\n\n            endif;\n\n            // Now multiply LocalValue by 16 and add in\n            // the current hexadecimal digit (in eax).\n\n            mov( LocalValue[8], ebx );\n            shld( 4, ebx, LocalValue[12] );\n            mov( LocalValue[4], ebx );\n            shld( 4, ebx, LocalValue[8] );\n            mov( LocalValue[0], ebx );\n            shld( 4, ebx, LocalValue[4] );\n            shl( 4, ebx );\n            add( eax, ebx );\n            mov( ebx, LocalValue[0] );\n\n        endif;\n\n    endwhile;\n\n    // Okay, we've encountered a non-hexadecimal character.\n    // Let's make sure it's a valid delimiter character.\n    // Raise the ex.ConversionError exception if it's invalid.\n\n    if( al not in Delimiters ) then\n\n        raise( ex.ConversionError );\n\n    endif;\n\n    // Okay, this conversion has been a success. Let's store\n    // away the converted value into the output parameter.\n\n    mov( inValue, ebx );\n    mov( LocalValue[0], eax );\n    mov( eax, [ebx] );\n\n    mov( LocalValue[4], eax );\n    mov( eax, [ebx+4] );\n\n    mov( LocalValue[8], eax );\n    mov( eax, [ebx+8] );\n\n    mov( LocalValue[12], eax );\n    mov( eax, [ebx+12] );\n\n    pop( ebx );\n    pop( eax );\n\nend getb128;\n\n// Code to test the routines above:\n\nstatic\n    b1:b128;\n\nbegin Xin128;\n\n    stdout.put( \"Input a 128-bit hexadecimal value: \" );\n    getb128( b1 );\n    stdout.put\n    (\n        \"The value is: $\",\n        b1[12], '_',\n        b1[8],  '_',\n        b1[4],  '_',\n        b1[0],\n        nl\n    );\n\nend Xin128;\n```", "```\nprogram Uin128;\n\n#include( \"stdlib.hhf\" );\n\n// 128-bit unsigned integer data type:\n\ntype\n    u128: dword[4];\n\nprocedure getu128( var inValue:u128 ); @nodisplay;\nvar\n    Delimiters: cset;\n    LocalValue: u128;\n    PartialSum: u128;\n\nbegin getu128;\n\n    push( eax );\n    push( ebx );\n    push( ecx );\n    push( edx );\n\n    // Get a copy of the HLA standard numeric input delimiters:\n\n    conv.getDelimiters( Delimiters );\n\n    // Initialize the numeric input value to 0:\n\n    xor( eax, eax );\n    mov( eax, LocalValue[0] );\n    mov( eax, LocalValue[4] );\n    mov( eax, LocalValue[8] );\n    mov( eax, LocalValue[12] );\n\n    // By default, #0 is a member of the HLA Delimiters\n    // character set. However, someone may have called\n    // conv.setDelimiters and removed this character\n    // from the internal Delimiters character set. This\n    // algorithm depends upon #0 being in the Delimiters\n    // character set, so let's add that character in\n    // at this point just to be sure.\n\n    cs.unionChar( #0, Delimiters );\n\n    // If we're at the end of the current input\n    // line (or the program has yet to read any input),\n    // wait for the input of an actual character.\n\n    if( stdin.peekc() = #0 ) then\n\n        stdin.readLn();\n\n    endif;\n\n    // Skip the delimiters found on input. This code is\n    // somewhat convoluted because stdin.peekc does not\n    // force the input of a new line of text if the current\n    // input buffer is empty. We have to force that input\n    // ourselves in the event the input buffer is empty.\n\n    while( stdin.peekc() in Delimiters ) do\n\n        // If we're at the end of the line, read a new line\n        // of text from the user; otherwise, remove the\n        // delimiter character from the input stream.\n\n        if( al = #0 ) then\n\n            stdin.readLn(); // Force a new input line.\n\n        else\n\n            stdin.getc();   // Remove the delimiter from the input buffer.\n\n        endif;\n\n    endwhile;\n\n    // Read the decimal input characters and convert\n    // them to the internal representation:\n\n    while( stdin.peekc() in '0'..'9' ) do\n\n        // Actually read the character to remove it from the\n        // input buffer.\n\n        stdin.getc();\n\n        // Ignore underscores, process everything else.\n\n        if( al <> '_' ) then\n\n            and( $f, al );              // '0'..'9' -> 0..9\n            mov( eax, PartialSum[0] );  // Save to add in later.\n\n            // Conversion algorithm is the following:\n            //\n            // (1) LocalValue := LocalValue * 10.\n            // (2) LocalValue := LocalValue + al\n            //\n            // First, multiply LocalValue by 10:\n\n            mov( 10, eax );\n            mul( LocalValue[0], eax );\n            mov( eax, LocalValue[0] );\n            mov( edx, PartialSum[4] );\n\n            mov( 10, eax );\n            mul( LocalValue[4], eax );\n            mov( eax, LocalValue[4] );\n            mov( edx, PartialSum[8] );\n\n            mov( 10, eax );\n            mul( LocalValue[8], eax );\n            mov( eax, LocalValue[8] );\n            mov( edx, PartialSum[12] );\n\n            mov( 10, eax );\n            mul( LocalValue[12], eax );\n            mov( eax, LocalValue[12] );\n\n            // Check for overflow. This occurs if edx\n            // contains a nonzero value.\n\n            if( edx /* <> 0 */ ) then\n\n                raise( ex.ValueOutOfRange );\n\n            endif;\n\n            // Add in the partial sums (including the\n            // most recently converted character).\n\n            mov( PartialSum[0], eax );\n            add( eax, LocalValue[0] );\n\n            mov( PartialSum[4], eax );\n            adc( eax, LocalValue[4] );\n\n            mov( PartialSum[8], eax );\n            adc( eax, LocalValue[8] );\n\n            mov( PartialSum[12], eax );\n            adc( eax, LocalValue[12] );\n\n            // Another check for overflow. If there\n            // was a carry out of the extended-precision\n            // addition above, we've got overflow.\n\n            if( @c ) then\n\n                raise( ex.ValueOutOfRange );\n\n            endif;\n\n        endif;\n\n    endwhile;\n\n    // Okay, we've encountered a non-decimal character.\n    // Let's make sure it's a valid delimiter character.\n    // Raise the ex.ConversionError exception if it's invalid.\n\n    if( al not in Delimiters ) then\n\n        raise( ex.ConversionError );\n\n    endif;\n\n    // Okay, this conversion has been a success. Let's store\n    // away the converted value into the output parameter.\n\n    mov( inValue, ebx );\n    mov( LocalValue[0], eax );\n    mov( eax, [ebx] );\n\n    mov( LocalValue[4], eax );\n    mov( eax, [ebx+4] );\n\n    mov( LocalValue[8], eax );\n    mov( eax, [ebx+8] );\n\n    mov( LocalValue[12], eax );\n    mov( eax, [ebx+12] );\n\n    pop( edx );\n    pop( ecx );\n    pop( ebx );\n    pop( eax );\n\nend getu128;\n\n// Code to test the routines above:\n\nstatic\n    b1:u128;\n\nbegin Uin128;\n\n    stdout.put( \"Input a 128-bit decimal value: \" );\n    getu128( b1 );\n    stdout.put\n    (\n        \"The value is: $\",\n        b1[12], '_',\n        b1[8],  '_',\n        b1[4],  '_',\n        b1[0],\n        nl\n    );\n\nend Uin128;\n```", "```\nstatic\n    var1: byte;\n    var2: word;\n         .\n         .\n         .\n// Unsigned addition:\n\n    movzx( var1, ax );\n    add( var2, ax );\n\n// Signed addition:\n\n    movsx( var1, ax );\n    add( var2, ax );\n```", "```\nmov( var2, ax );    // Load 16-bit value into ax.\n    .                   // Do some other operations leaving\n    .                   // a 16-bit quantity in ax.\n    add( var1, al );    // Add in the 8-bit value.\n    adc( 0, ah );       // Add carry into the H.O. word.\n```", "```\nmov( ax, bx );           // bx is the available register.\n    movsx( var1, ax );\n    add( bx, ax );\n```", "```\npush( ax );          // Save word value.\n    movsx( var1, ax );   // Sign extend 8-bit operand to 16 bits.\n    add( [esp], ax );    // Add in previous word value.\n    add( 2, esp );       // Pop junk from stack.\n```", "```\nmov( ax, temp );\n    movsx( var1, ax );\n    add( temp, ax );\n```", "```\nstatic\n    QVal:qword;\n    BVal:int8;\n     .\n     .\n     .\n    movsx( BVal, eax );\n    cdq();\n    add( (type dword QVal), eax );\n    adc( (type dword QVal[4]), edx );\n```", "```\nmov( $99, al );\n```", "```\nmov( bcd_1, al );    // Assume that bcd_1 and bcd_2 both contain\n    add( bcd_2, al );    // valid BCD values.\n    daa();\n```", "```\n// Assume \"bcd_1:byte[2];\", \"bcd_2:byte[2];\", and \"bcd_3:byte[2];\"\n\n    mov( bcd_1[0], al );\n    add( bcd_2[0], al );\n    daa();\n    mov( al, bcd_3[0] );\n    mov( bcd_1[1], al );\n    adc( bcd_2[1], al );\n    daa();\n    mov( al, bcd_3[1], al );\n\n// Carry is set at this point if there was unsigned overflow.\n```", "```\n// Two-digit (1-byte) decimal subtraction:\n\n    mov( bcd_1, al );    // Assume that bcd_1 and bcd_2 both contain\n    sub( bcd_2, al );    // valid BCD values.\n    das();\n\n// Four-digit (2-byte) decimal subtraction.\n// Assume \"bcd_1:byte[2];\", \"bcd_2:byte[2];\", and \"bcd_3:byte[2];\"\n\n    mov( bcd_1[0], al );\n    sub( bcd_2[0], al );\n    das();\n    mov( al, bcd_3[0] );\n    mov( bcd_1[1], al );\n    sbb( bcd_2[1], al );\n    das();\n    mov( al, bcd_3[1], al );\n\n// Carry is set at this point if there was unsigned overflow.\n```", "```\nmov( '9', al );\n    mov( '9', ah );    // \"99\" is in ah:al.\n    and( $0F0F, ax );  // Convert from ASCII to unpacked decimal.\n    aad();             // After this, ax contains 99.\n```", "```\nprogram MixedArithmetic;\n#include( \"stdlib.hhf\" )\n\nstatic\n    tb: tbyte := $654321;\n\nbegin MixedArithmetic;\n\n    fbld( tb );\n    fmul( 2.0 );\n    fiadd( 1 );\n    fbstp( tb );\n    stdout.put( \"bcd value is \" );\n    stdout.puth80( tb );\n    stdout.newln();\n\nend MixedArithmetic;\n```", "```\nif (*`character`* >= 'a') and (*`character`* <= 'z') then *`character`* :=\nchr(ord(*`character`*) - 32);\n```", "```\nmov( *`character`*, al );\n        if( al in 'a'..'z' ) then\n\n            and( $5f, al );        // Same as sub( 32, al ) in this code.\n\n        endif;\n        mov( al, *`character`* );\n```", "```\nmov( *`character`*, al );\n    lea( ebx, CnvrtLower );\n    xlat\n    mov( al, *`character`* );\n```", "```\nmov( [ebx+al*1], al );\n```", "```\nmov( *`character`*, al );\n        if( al in 'a'..'z' ) then\n\n            and( $5f, al );\n\n        elseif( al in 'A'..'Z' ) then\n\n            or( $20, al );\n\n        endif;\n        mov( al, *`character`* ):\n```", "```\nmov( *`character`*, al );\n        lea( ebx, SwapUL );\n        xlat();\n        mov( al, *`character`* );\n```", "```\nB := Func(X);\n```", "```\nfunction Func(X:dword):byte;\n```", "```\nmov( X, ebx );\n        mov( FuncTable[ ebx ], al );\n        mov( al, B );\n```", "```\nX := Posn mod 80\n```", "```\nY := Posn div 80\n```", "```\nmov( Posn, ax );\n        div( 80, ax );\n\n// X is now in ah, Y is now in al\n```", "```\nmovzx( Posn, ebx );            // Use a plain mov instr if Posn is\n        mov( YCoord[ebx], al );        // uns32 rather than an uns16 value.\n        mov( XCoord[ebx], ah );\n```", "```\nAddress := Base + index * size\n```", "```\nfunction F(x:dword):word;\n```", "```\nmov( X, ebx );\n        mov( F[ebx*2], ax );\n```", "```\nfunction val(x:word):word; begin\n    case x of\n        0: val := 1;\n        1: val := 1;\n        2: val := 4;\n        3: val := 27;\n        4: val := 256;\n        otherwise val := 0;\n    end;\nend;\n```", "```\nmov( 0, ax );            // ax = 0, assume x > 4.\n        movzx( x, ebx );         // Note that H.O. bits of ebx must be 0!\n        if( bx <= 4 ) then\n\n            mov( val[ ebx*2 ], ax );\n\n        endif;\n```", "```\nmovzx( x, ebx );\n        mov( Sines[ ebx*2], eax );  // Get sin(X) * 1000\n        imul( r, eax );             // Note that this extends eax into edx.\n        idiv( 1000, edx:eax );      // Compute (r*(sin(X)*1000)) / 1000\n```", "```\nprogram GenerateSines;\n#include( \"stdlib.hhf\" );\n\nvar\n    outFile: dword;\n    angle:   int32;\n    r:       int32;\n\nreadonly\n    RoundMode: uns16 := $23f;\n\nbegin GenerateSines;\n\n    // Open the file:\n\n    mov( fileio.openNew( \"sines.hla\" ), outFile );\n\n    // Emit the initial part of the declaration to the output file:\n\n    fileio.put\n    (\n        outFile,\n        stdio.tab,\n        \"sines: int32[360] := \" nl,\n        stdio.tab, stdio.tab, stdio.tab, \"[\" nl );\n\n    // Enable rounding control (round to the nearest integer).\n\n    fldcw( RoundMode );\n\n    // Emit the sines table:\n\n    for( mov( 0, angle); angle < 359; inc( angle )) do\n\n        // Convert angle in degrees to an angle in radians using\n        // radians := angle * 2.0 * pi / 360.0;\n\n        fild( angle );\n        fld( 2.0 );\n        fmulp();\n        fldpi();\n        fmulp();\n        fld( 360.0 );\n        fdivp();\n\n        // Okay, compute the sine of st0.\n\n        fsin();\n\n        // Multiply by 1000 and store the rounded result into\n        // the integer variable r.\n\n        fld( 1000.0 );\n        fmulp();\n        fistp( r );\n\n        // Write out the integers eight per line to the source file.\n        // Note: If (angle AND %111) is 0, then angle is evenly\n        // divisible by 8 and we should output a newline first.\n\n        test( %111, angle );\n        if( @z ) then\n\n            fileio.put\n            (\n                outFile,\n                nl,\n                stdio.tab,\n                stdio.tab,\n                stdio.tab,\n                stdio.tab,\n                r:5,\n                ','\n            );\n\n        else\n\n            fileio.put( outFile, r:5, ',' );\n\n        endif;\n\n    endfor;\n\n    // Output sine(359) as a special case (no comma following it).\n    // Note: This value was computed manually with a calculator.\n\n    fileio.put\n    (\n        outFile,\n        \"  −17\",\n        nl,\n        stdio.tab,\n        stdio.tab,\n        stdio.tab,\n        \"];\",\n        nl\n    );\n    fileio.close( outFile );\n\nend GenerateSines;\n```", "```\nsines: int32[360] :=\n            [\n\n                    0,   17,   35,   52,   70,   87,  105,  122,\n                  139,  156,  174,  191,  208,  225,  242,  259,\n                  276,  292,  309,  326,  342,  358,  375,  391,\n                  407,  423,  438,  454,  469,  485,  500,  515,\n                  530,  545,  559,  574,  588,  602,  616,  629,\n                  643,  656,  669,  682,  695,  707,  719,  731,\n                                                               .\n                                                               .\n                                                               .\n                 −643, −629, −616, −602, −588, −574, −559, −545,\n                 −530, −515, −500, −485, −469, −454, −438, −423,\n                 −407, −391, −375, −358, −342, −326, −309, −292,\n                 −276, −259, −242, −225, −208, −191, −174, −156,\n                 −139, −122, −105,  −87,  −70,  −52,  −35,  −17\n            ];\n```"]