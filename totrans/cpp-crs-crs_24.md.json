["```\n#include <iostream>\n#include <string>\n\nstruct Tracer { ➊\n  Tracer(std::string name_in)\n    : name{ std::move(name_in) } {\n    std::cout << name << \" constructed.\\n\";\n  }\n  ~Tracer() {\n    std::cout << name << \" destructed.\\n\";\n  }\nprivate:\n  const std::string name;\n};\n\nTracer static_tracer{ \"static Tracer\" }; ➋\n\nvoid run() { ➌\n  std::cout << \"Entering run()\\n\";\n  // ...\n  std::cout << \"Exiting run()\\n\";\n}\n\nint main() {\n  std::cout << \"Entering main()\\n\"; ➍\n  Tracer local_tracer{ \"local Tracer\" }; ➎\n  thread_local Tracer thread_local_tracer{ \"thread_local Tracer\" }; ➏\n  const auto* dynamic_tracer = new Tracer{ \"dynamic Tracer\" }; ➐\n  run(); ➑\n  delete dynamic_tracer; ➒\n  std::cout << \"Exiting main()\\n\"; ➓\n}\n-----------------------------------------------------------------------\nstatic Tracer constructed. ➋\nEntering main() ➍\nlocal Tracer constructed. ➎\nthread_local Tracer constructed. ➏\ndynamic Tracer constructed. ➐\nEntering run() ➑\nExiting run() ➑\ndynamic Tracer destructed. ➒\nExiting main() ➓\nlocal Tracer destructed. ➎\nthread_local Tracer destructed. ➏\nstatic Tracer destructed. ➋\n```", "```\n#include <cstdlib>\n#include <iostream>\n#include <string>\n\nstruct Tracer {\n--snip--\n};\n\nTracer static_tracer{ \"static Tracer\" };\n\n void run() {\n  std::cout << \"Registering a callback\\n\"; ➊\n  std::atexit([] { std::cout << \"***std::atexit callback executing***\\n\"; }); ➋\n  std::cout << \"Callback registered\\n\"; ➌\n}\n\nint main() {\n--snip--\n}\n-----------------------------------------------------------------------\nstatic Tracer constructed.\nEntering main()\nlocal Tracer constructed.\nthread_local Tracer constructed.\ndynamic Tracer constructed.\nRegistering a callback\nCallback registered ➌\ndynamic Tracer destructed.\nExiting main()\nlocal Tracer destructed.\nthread_local Tracer destructed.\n***std::atexit callback executing*** ➋\nstatic Tracer destructed.\n```", "```\n#include <cstdlib>\n#include <iostream>\n#include <string>\n\nstruct Tracer {\n--snip--\n};\n\nTracer static_tracer{ \"static Tracer\" };\n\nvoid run() {\n  std::cout << \"Registering a callback\\n\"; ➊\n  std::atexit([] { std::cout << \"***std::atexit callback executing***\\n\"; }); ➋\n  std::cout << \"Callback registered\\n\"; ➌\n  std::exit(0); ➍\n}\n\nint main() {\n--snip--\n}\n-----------------------------------------------------------------------\nstatic Tracer constructed.\nEntering main()\nlocal Tracer constructed.\nthread_local Tracer constructed.\ndynamic Tracer constructed.\nRegistering a callback ➊\nCallback registered ➌\nthread_local Tracer destructed.\n***std::atexit callback executing*** ➍\nstatic Tracer destructed.\n```", "```\ndynamic Tracer destructed.\nExiting main()\nlocal Tracer destructed.\n```", "```\n#include <cstdlib>\n#include <iostream>\n#include <string>\n\nstruct Tracer {\n--snip--\n};\n\nTracer static_tracer{ \"static Tracer\" };\n\nvoid run() {\n  std::cout << \"Registering a callback\\n\"; ➊\n  std::atexit([] { std::cout << \"***std::atexit callback executing***\\n\"; }); ➋\n  std::cout << \"Callback registered\\n\"; ➌\n  std::abort(); ➍\n}\n\nint main() {\n  --snip--\n}\n-----------------------------------------------------------------------\nstatic Tracer constructed.\nEntering main()\nlocal Tracer constructed.\nthread_local Tracer constructed.\ndynamic Tracer constructed.\nRegistering a callback\nCallback registered\n```", "```\n#include <cstdlib>\n#include <iostream>\n#include <string>\n\nint main() {\n  std::string command{ \"ping -c 4 google.com\" }; ➊\n  const auto result = std::system(command.c_str()); ➋\n  std::cout << \"The command \\'\" << command\n            << \"\\' returned \" << result << \"\\n\";\n}\n-----------------------------------------------------------------------\nPING google.com (172.217.15.78): 56 data bytes\n64 bytes from 172.217.15.78: icmp_seq=0 ttl=56 time=4.447 ms\n64 bytes from 172.217.15.78: icmp_seq=1 ttl=56 time=12.162 ms\n64 bytes from 172.217.15.78: icmp_seq=2 ttl=56 time=8.376 ms\n64 bytes from 172.217.15.78: icmp_seq=3 ttl=56 time=10.813 ms\n\n--- google.com ping statistics ---\n4 packets transmitted, 4 packets received, 0.0% packet loss\nround-trip min/avg/max/stddev = 4.447/8.950/12.162/2.932 ms\nThe command 'ping -c 4 google.com' returned 0 ➌\n```", "```\n#include <cstdlib>\n#include <iostream>\n#include <string>\n\nint main() {\n  std::string variable_name{ \"PATH\" }; ➊\n  std::string result{ std::getenv(variable_name.c_str()) }; ➋\n  std::cout << \"The variable \" << variable_name\n            << \" equals \" << result << \"\\n\"; ➌\n}\n-----------------------------------------------------------------------\nThe variable PATH equals /usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin\n```", "```\n#include <csignal>\n#include <iostream>\n#include <chrono>\n#include <thread>\n#include <atomic>\n\nstd::atomic_bool interrupted{}; ➊\n\nextern \"C\" void handler(int signal) {\n  std::cout << \"Handler invoked with signal \" << signal << \".\\n\"; ➋\n  interrupted = true; ➌\n}\n\nint main() {\n  using namespace std::chrono_literals;\n  std::signal(SIGINT, handler); ➍\n  while(!interrupted) { ➎\n    std::cout << \"Waiting...\" << std::endl; ➏\n    std::this_thread::sleep_for(1s);\n  }\n  std::cout << \"Interrupted!\\n\"; ➐\n}\n-----------------------------------------------------------------------\nWaiting...\nWaiting...\nWaiting...\nHandler invoked with signal 2.\nInterrupted! ➐\n```", "```\nvalue<int>()->default_value(42)\n```", "```\nvalue<std::string>()->multitoken()\n```", "```\nvalue<std::vector<std::string>>()\n```", "```\nbool_switch(&flag)\n```", "```\n#include <boost/program_options.hpp>\n#include <iostream>\n#include <string>\n\nint main(int argc, char** argv) {\n  using namespace boost::program_options;\n  bool is_recursive{}, is_help{};\n\n  options_description description{ \"mgrep [options] pattern path1 path2 ...\"\n}; ➊\n  description.add_options()\n          (\"help,h\", bool_switch(&is_help), \"display a help dialog\") ➋\n          (\"threads,t\", value<int>()->default_value(4),\n                        \"number of threads to use\") ➌\n          (\"recursive,r\", bool_switch(&is_recursive),\n                          \"search subdirectories recursively\") ➍\n          (\"pattern\", value<std::string>(), \"pattern to search for\") ➎\n          (\"paths\", value<std::vector<std::string>>(), \"path to search\"); ➏\n  std::cout << description; ➐\n}\n-----------------------------------------------------------------------\nmgrep [options] pattern path1 path2 ...:\n -h [ --help ]             display a help dialog\n -t [ --threads ] arg (=4) number of threads to use\n -r [ --recursive ]        search subdirectories recursively\n --pattern arg             pattern to search for\n --path arg                path to search\n```", "```\n  positional_options_description positional; ➊\n  positional.add(\"pattern\", 1); ➋\n  positional.add(\"path\", -1); ➌\n```", "```\ncommand_line_parser parser{ argc, argv }; ➊\nparser.options(description); ➋\nparser.positional(positional); ➌\nauto parsed_result = parser.run(); ➍\n```", "```\nvariables_map vm; ➊\nstore(parsed_result, vm); ➋\nnotify(vm); ➌\n```", "```\nif (is_help) std::cout << \"Is help.\\n\"; ➊\nif (is_recursive) std::cout << \"Is recursive.\\n\"; ➋\nstd::cout << \"Threads: \" << vm[\"threads\"].as<int>() << \"\\n\"; ➌\nif (!vm[\"pattern\"].empty()) { ➍\n  std::cout << \"Pattern: \" << vm[\"pattern\"].as<std::string>() << \"\\n\"; ➎\n} else {\n  std::cout << \"Empty pattern.\\n\";\n}\nif (!vm[\"path\"].empty()) { ➏\n  std::cout << \"Paths:\\n\";\n  for(const auto& path : vm[\"path\"].as<std::vector<std::string>>()) ➐\n    std::cout << \"\\t\" << path << \"\\n\";\n} else {\n  std::cout << \"Empty path.\\n\";\n}\n```", "```\n#include <boost/program_options.hpp>\n#include <iostream>\n#include <string>\n\nint main(int argc, char** argv) {\n  using namespace boost::program_options;\n  bool is_recursive{}, is_help{};\n\n  options_description description{ \"mgrep [options] pattern path1 path2 ...\" };\n  description.add_options()\n          (\"help,h\", bool_switch(&is_help), \"display a help dialog\")\n          (\"threads,t\", value<int>()->default_value(4),\n                        \"number of threads to use\")\n          (\"recursive,r\", bool_switch(&is_recursive),\n                         \"search subdirectories recursively\")\n          (\"pattern\", value<std::string>(), \"pattern to search for\")\n          (\"path\", value<std::vector<std::string>>(), \"path to search\");\n\n  positional_options_description positional;\n  positional.add(\"pattern\", 1);\n  positional.add(\"path\", -1);\n\n  command_line_parser parser{ argc, argv };\n  parser.options(description);\n  parser.positional(positional);\n\n  variables_map vm;\n  try {\n    auto parsed_result = parser.run(); ➊\n    store(parsed_result, vm);\n    notify(vm);\n  } catch (const std::exception& e) {\n    std::cerr << e.what() << \"\\n\";\n    return -1;\n  }\n\n  if (is_help) { ➋\n    std::cout << description;\n    return 0;\n  }\n  if (vm[\"pattern\"].empty()) { ➌\n    std::cerr << \"You must provide a pattern.\\n\";\n    return -1;\n  }\n  if (vm[\"path\"].empty()) { ➍\n    std::cerr << \"You must provide at least one path.\\n\";\n    return -1;\n  }\n  const auto threads = vm[\"threads\"].as<int>();\n  const auto& pattern = vm[\"pattern\"].as<std::string>();\n  const auto& paths = vm[\"path\"].as<std::vector<std::string>>();\n  // Continue program here ... ➎\n  std::cout << \"Ok.\" << std::endl;\n}\n```", "```\n$ ./mgrep ➊\nYou must provide a pattern.\n$ ./mgrep needle ➋\nYou must provide at least one path.\n$ ./mgrep --supercharge needle haystack1.txt haystack2.txt ➌\nunrecognised option '--supercharge'\n$ ./mgrep --help ➍\nmgrep [options] pattern path1 path2 ...:\n  -h [ --help ]             display a help dialog\n  -t [ --threads ] arg (=4) number of threads to use\n  -r [ --recursive ]        search subdirectories recursively\n  --pattern arg             pattern to search for\n  --path arg                path to search\n$ ./mgrep needle haystack1.txt haystack2.txt haystack3.txt ➎\nOk.\n$ ./mgrep --recursive needle haystack1.txt ➏\nOk.\n$ ./mgrep -rt 10 needle haystack1.txt haystack2.txt ➐\nOk.\n```", "```\n#define <NAME> <CODE>\n```", "```\n#include <cstdio>\n#define MESSAGE \"LOL\" ➊\n\nint main(){\n  printf(MESSAGE); ➋\n}\n-----------------------------------------------------------------------\nLOL\n```", "```\n#include <cstdio>\n\nint main(){\n  printf(\"LOL\");\n}\n```", "```\n#define <NAME>(<PARAMETERS>) <CODE>\n```", "```\n#include <cstdio>\n#define SAY_LOL_WITH(fn) fn(\"LOL\") ➊\n\nint main() {\n  SAY_LOL_WITH(printf); ➋\n}\n```", "```\n#ifndef MY_MACRO ➊\n// Segment 1 ➋\n#else\n// Segment 2 ➌\n#endif\n```", "```\n// step_function.h\n#ifndef STEP_FUNCTION_H ➊\nint step_function(int x);\n#define STEP_FUNCTION_H ➋\n#endif\n```", "```\n#pragma once ➊\nint step_function(int x);\n```", "```\n // sum.h\n#pragma once\nextern \"C\" int sum(const int* x, int len);\n```", "```\nint sum(const int* x, size_t len);\n```", "```\n// sum.h\n#pragma once\n\nextern \"C\" {\n  int sum_int(const int* x, int len);\n  double sum_double(const double* x, int len);\n--snip--\n}\n```"]