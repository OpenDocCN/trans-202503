- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Understanding Data Types
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 理解数据类型
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: 'It’s important to understand data types because storing data in the appropriate
    format is fundamental to building usable databases and performing accurate analysis.
    Whenever I dig into a new database, I check the *data type* specified for each
    column in each table. If I’m lucky, I can get my hands on a *data dictionary*:
    a document that lists each column; specifies whether it’s a number, character,
    or other type; and explains the column values. Unfortunately, many organizations
    don’t create and maintain good documentation, so it’s not unusual to hear, “We
    don’t have a data dictionary.” In that case, I inspect the table structures in
    pgAdmin to learn as much as I can.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 理解数据类型非常重要，因为以合适的格式存储数据是构建可用数据库和进行准确分析的基础。每当我深入研究一个新数据库时，我都会检查每个表中每一列指定的 *数据类型*。如果幸运的话，我能找到一个
    *数据字典*：这是一份列出每个列、指定它是数字、字符还是其他类型，并解释列值的文档。不幸的是，许多组织没有创建和维护良好的文档，因此常常会听到，“我们没有数据字典。”在这种情况下，我会在
    pgAdmin 中检查表格结构，尽可能多地了解信息。
- en: Data types are a programming concept applicable to more than just SQL. The concepts
    you’ll explore in this chapter will transfer well to additional languages you
    may want to learn.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型是一个编程概念，适用于不仅仅是 SQL。你将在本章中探讨的概念也适用于你可能想学习的其他编程语言。
- en: 'In a SQL database, each column in a table can hold one and only one data type,
    which you define in the `CREATE TABLE` statement by declaring the data type after
    the column name. In the following simple example table—which you can review but
    don’t need to create—you will find columns with three different data types: a
    date, an integer, and text.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL 数据库中，表格中的每一列只能存储一种数据类型，且必须在 `CREATE TABLE` 语句中通过在列名后声明数据类型来定义。在以下简单的示例表格中——你可以查看但无需创建——你会看到三个不同数据类型的列：一个日期、一个整数和一个文本。
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this table named `eagle_watch` (for a hypothetical inventory of bald eagles),
    we declare the `observation_date` column to hold date values by adding the `date`
    type declaration after its name. Similarly, we set `eagles_seen` to hold whole
    numbers with the `integer` type declaration and declare `notes` to hold characters
    via the `text` type.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在名为 `eagle_watch` 的表格中（假设是关于秃鹰的库存），我们通过在列名后添加 `date` 类型声明来声明 `observation_date`
    列存储日期值。同样，我们通过 `integer` 类型声明将 `eagles_seen` 设置为存储整数，并通过 `text` 类型声明将 `notes`
    设置为存储字符。
- en: 'These data types fall into the three categories you’ll encounter most:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据类型属于你最常遇到的三种类别：
- en: Characters Any character or symbol
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符 任何字符或符号
- en: Numbers Includes whole numbers and fractions
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数字包括整数和分数
- en: Dates and times Temporal information
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日期和时间 时间信息
- en: Let’s look at each data type in depth; I’ll note whether they’re part of standard
    ANSI SQL or specific to PostgreSQL. An overall, in-depth look at where PostgreSQL
    deviates from the SQL standard is available at [https://wiki.postgresql.org/wiki/PostgreSQL_vs_SQL_Standard](https://wiki.postgresql.org/wiki/PostgreSQL_vs_SQL_Standard).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解每种数据类型；我会标注它们是否属于标准 ANSI SQL，或者是 PostgreSQL 特有的。关于 PostgreSQL 与 SQL 标准的差异，可以在
    [https://wiki.postgresql.org/wiki/PostgreSQL_vs_SQL_Standard](https://wiki.postgresql.org/wiki/PostgreSQL_vs_SQL_Standard)
    找到全面的深入分析。
- en: Understanding Characters
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解字符
- en: '*Character string types* are general-purpose types suitable for any combination
    of text, numbers, and symbols. Character types include the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符字符串类型* 是通用类型，适用于任何文本、数字和符号的组合。字符类型包括以下几种：'
- en: '**`char(``n``)`**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**`char(``n``)`**'
- en: A fixed-length column where the character length is specified by `n`. A column
    set at `char(20)` stores 20 characters per row regardless of how many characters
    you insert. If you insert fewer than 20 characters in any row, PostgreSQL pads
    the rest of that column with spaces. This type, which is part of standard SQL,
    also can be specified with the longer name `character(``n``)`. Nowadays, `char(``n``)`
    is used infrequently and is mainly a remnant of legacy computer systems.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个固定长度的列，其中字符长度由 `n` 指定。设置为 `char(20)` 的列每行存储 20 个字符，无论插入多少字符。如果某行插入的字符少于 20
    个，PostgreSQL 会用空格填充该列的剩余部分。此类型是标准 SQL 的一部分，也可以使用更长的名称 `character(``n``)` 来指定。如今，`char(``n``)`
    使用较少，主要是遗留计算机系统的产物。
- en: '**`varchar(``n``)`**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**`varchar(``n``)`**'
- en: A variable-length column where the *maximum* length is specified by `n`. If
    you insert fewer characters than the maximum, PostgreSQL will not store extra
    spaces. For example, the string `blue` will take four spaces, whereas the string
    `123` will take three. In large databases, this practice saves considerable space.
    This type, included in standard SQL, also can be specified using the longer name
    `character varying(``n``)`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可变长度的列，其*最大*长度由 `n` 指定。如果插入的字符少于最大值，PostgreSQL 将不会存储额外的空格。例如，字符串 `blue` 将占用四个空间，而字符串
    `123` 将占用三个空间。在大型数据库中，这种做法节省了大量空间。这种类型，标准 SQL 中也有，包括用更长的名称 `character varying(``n``)`
    来指定。
- en: '**`text`**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**`text`**'
- en: A variable-length column of unlimited length. (According to the PostgreSQL documentation,
    the longest possible character string you can store is about 1 gigabyte.) The
    `text` type is not part of the SQL standard, but you’ll find similar implementations
    in other database systems, including Microsoft SQL Server and MySQL.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个长度不受限制的可变长度列。（根据 PostgreSQL 文档，你可以存储的最长字符串大约为 1 GB。）`text` 类型不是 SQL 标准的一部分，但你会在其他数据库系统中找到类似的实现，包括
    Microsoft SQL Server 和 MySQL。
- en: According to PostgreSQL documentation at [https://www.postgresql.org/docs/current/datatype-character.html](https://www.postgresql.org/docs/current/datatype-character.html),
    there is no substantial difference in performance among the three types. That
    may differ if you’re using another database manager, so it’s wise to check the
    docs. The flexibility and potential space savings of `varchar` and `text` seem
    to give them an advantage. But if you search discussions online, some users suggest
    that defining a column that will always have the same number of characters with
    `char` is a good way to signal what data it should contain. For instance, you
    might see `char(2)` used for US state postal abbreviations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 PostgreSQL 文档，[https://www.postgresql.org/docs/current/datatype-character.html](https://www.postgresql.org/docs/current/datatype-character.html)，这三种类型在性能上没有实质性的区别。如果你使用的是其他数据库管理器，情况可能有所不同，因此最好检查相关文档。`varchar`
    和 `text` 的灵活性及其潜在的空间节省似乎给它们带来了优势。但是，如果你在线查阅讨论，某些用户建议使用 `char` 来定义一个始终包含相同字符数的列，这样可以很好地指示它应包含的数据。例如，`char(2)`
    可能用于美国州的邮政缩写。
- en: To see these three character types in action, run the script shown in [Listing
    4-1](#listing4-1). This script will build and load a simple table and then export
    the data to a text file on your computer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这三种字符类型的实际应用，可以运行 [Listing 4-1](#listing4-1) 中显示的脚本。这个脚本将构建并加载一个简单的表格，然后将数据导出到你电脑上的一个文本文件。
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Listing 4-1: Character data types in action'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 4-1: 字符数据类型示例'
- en: We define three character columns 1 of different types and insert two rows of
    the same string into each 2. Unlike the `INSERT INTO` statement you learned in
    Chapter 2, here we’re not specifying the names of the columns. If the `VALUES`
    statements match the number of columns in the table, the database will assume
    you’re inserting values in the order the column definitions were specified in
    the table.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三种不同类型的字符列，并将相同的字符串插入到每一列的两行中。与第二章中学到的 `INSERT INTO` 语句不同，这里我们没有指定列的名称。如果
    `VALUES` 语句中的值与表中列的数量相匹配，数据库将假定你按照列定义的顺序插入值。
- en: 'Next, we use the PostgreSQL `COPY` keyword 3 to export the data to a text file
    named *typetest.txt* in a directory you specify. You’ll need to replace *C:\YourDirectory\*
    with the full path to the directory on your computer where you want to save the
    file. The examples in this book use Windows format—which use a backslash between
    folders and file names—and a path to a directory called *YourDirectory* on the
    C: drive. Windows users must set permissions for the destination folder according
    to the note in the section “Downloading Code and Data from GitHub” in Chapter
    1.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，我们使用 PostgreSQL 的 `COPY` 关键字将数据导出到一个名为 *typetest.txt* 的文本文件中，文件保存在你指定的目录里。你需要将
    *C:\YourDirectory\* 替换为你电脑上要保存该文件的目录的完整路径。本书中的示例使用的是 Windows 格式——它在文件夹和文件名之间使用反斜杠——并且路径指向位于
    C: 驱动器上的名为 *YourDirectory* 的目录。Windows 用户必须根据第一章中“从 GitHub 下载代码和数据”部分的说明设置目标文件夹的权限。'
- en: Linux and macOS file paths have a different format, with forward slashes between
    folders and filenames. On my Mac, for example, the path to a file on the desktop
    is */Users/anthony/Desktop/*. The directory must exist already; PostgreSQL won’t
    create it for you.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 和 macOS 的文件路径格式不同，文件夹和文件名之间使用正斜杠。例如，在我的 Mac 上，桌面文件的路径是 */Users/anthony/Desktop/*。目录必须已经存在；PostgreSQL
    不会为你创建它。
- en: In PostgreSQL, `COPY` `table_name` `FROM` is the import function, and `COPY`
    `table_name` `TO` is the export function. I’ll cover them in depth in Chapter
    5; for now, all you need to know is that the `WITH` keyword options 4 will format
    the data in the file with each column separated by a *pipe* (`|`) character. That
    way, you can easily see where spaces fill out the unused portions of the `char`
    column.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PostgreSQL 中，`COPY` `table_name` `FROM` 是导入功能，`COPY` `table_name` `TO` 是导出功能。我将在第五章中详细讲解它们；目前，你只需要知道的是，`WITH`
    关键字选项 4 会将文件中的数据格式化，每列由一个 *管道符* (`|`) 分隔。这样，你可以轻松看到 `char` 列中空白部分填充的位置。
- en: 'To see the output, open *typetest.txt* using the text editor you installed
    in Chapter 1 (not Word or Excel, or another spreadsheet application). The contents
    should look like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看输出，使用你在第一章中安装的文本编辑器打开 *typetest.txt*（而不是 Word、Excel 或其他电子表格应用程序）。其内容应如下所示：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Even though you specified 10 characters for both the `char` and `varchar` columns,
    only the `char` column outputs 10 characters in both rows, padding unused characters
    with spaces. The `varchar` and `text` columns store only the characters you inserted.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你为 `char` 和 `varchar` 列都指定了 10 个字符，只有 `char` 列会在两行中输出 10 个字符，并用空格填充未使用的字符。`varchar`
    和 `text` 列仅存储你插入的字符。
- en: Again, there’s no real performance difference among the three types, although
    this example shows that `char` can potentially consume more storage space than
    needed. A few unused spaces in each column might seem negligible, but multiply
    that over millions of rows in dozens of tables and you’ll soon wish you had been
    more economical.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，三种类型之间没有实际的性能差异，尽管这个例子显示了 `char` 可能会比实际需要的空间更多。每个列中的几个未使用的空格看似微不足道，但如果在数百万行的数十个表中进行相同的操作，很快你就会希望自己当初更节省空间。
- en: I tend to use `text` on all my character columns. That saves me from having
    to configure maximum lengths for multiple `varchar` columns and means I won’t
    need to modify a table later if the requirements for a character column change.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我倾向于在所有字符列中使用 `text`。这样可以避免为多个 `varchar` 列配置最大长度，也意味着如果字符列的要求发生变化，我以后不需要修改表。
- en: Understanding Numbers
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解数字
- en: 'Number columns hold various types of (you guessed it) numbers, but that’s not
    all: they also allow you to perform calculations on those numbers. That’s an important
    distinction from numbers you store as strings in a character column, which can’t
    be added, multiplied, divided, or perform any other math operation. Also, numbers
    stored as characters sort differently than numbers stored as numbers, so if you’re
    doing math or the numeric order is important, use number types.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 数字列包含各种类型的（你猜对了）数字，但不仅仅如此：它们还允许你对这些数字进行计算。这与将数字存储为字符列中的字符串有所不同，因为字符列中的字符串无法进行加法、乘法、除法或执行任何其他数学操作。此外，作为字符存储的数字排序方式不同于作为数字存储的数字，因此，如果你要进行数学运算或数字顺序很重要，应该使用数字类型。
- en: 'The SQL number types include the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 数字类型包括以下几种：
- en: Integers Whole numbers, both positive and negative
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整数 既包括正数，也包括负数的整数
- en: Fixed-point and floating-point Two formats of fractions of whole numbers
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定点数和浮点数 两种表示小数的格式
- en: We’ll look at each type separately.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分别查看每种类型。
- en: Using Integers
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用整数
- en: 'The integer data types are the most common number types you’ll find when exploring
    a SQL database. These are *whole numbers*, both positive and negative, including
    zero. Think of all the places integers appear in life: your street or apartment
    number, the serial number on your refrigerator, the number on a raffle ticket.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 整数数据类型是你在 SQL 数据库中最常见的数字类型。这些是 *整数*，包括正数、负数和零。想想生活中所有出现整数的地方：你的街道或公寓号码、冰箱上的序列号、彩票上的号码。
- en: 'The SQL standard provides three integer types: `smallint`, `integer`, and `bigint`.
    The difference between the three types is the maximum size of the numbers they
    can hold. [Table 4-1](#table4-1) shows the upper and lower limits of each, as
    well as how much storage each requires in bytes.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 标准提供了三种整数类型：`smallint`、`integer` 和 `bigint`。这三种类型的区别在于它们能够存储的数字的最大大小。[表
    4-1](#table4-1) 显示了每种类型的上下限，以及它们各自所需的存储空间（以字节为单位）。
- en: 'Table 4-1: Integer Data Types'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1：整数数据类型
- en: '| **Data type** | **Storage size** | **Range** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型** | **存储大小** | **范围** |'
- en: '| --- | --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `smallint` | 2 bytes | −32768 to +32767 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `smallint` | 2 字节 | −32768 到 +32767 |'
- en: '| `integer` | 4 bytes | −2147483648 to +2147483647 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `integer` | 4 字节 | −2147483648 到 +2147483647 |'
- en: '| `bigint` | 8 bytes | −9223372036854775808 to +9223372036854775807 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `bigint` | 8 字节 | −9223372036854775808 到 +9223372036854775807 |'
- en: The `bigint` type will cover just about any requirement you’ll ever have with
    a number column, though it eats up the most storage. Its use is a must if you’re
    working with numbers larger than about 2.1 billion, but you also can easily make
    it your go-to default and never worry about not being able to fit a number in
    the column. On the other hand, if you’re confident numbers will remain within
    the `integer` limit, that type is a good choice because it doesn’t consume as
    much space as `bigint` (a concern when dealing with millions of data rows).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`bigint`类型几乎可以满足你所有的数字列需求，尽管它占用的存储空间最大。如果你处理的是超过约 21 亿的数字，它是必须使用的类型，但你也可以轻松将其设为默认类型，永远不必担心数字无法存入该列。另一方面，如果你确定数字将保持在`integer`的限制范围内，那么选择该类型是一个不错的选择，因为它不像`bigint`那样消耗空间（尤其在处理百万级数据行时，这是一个重要的考量）。'
- en: 'When you know that values will remain constrained, `smallint` makes sense:
    days of the month or years are good examples. The `smallint` type will use half
    the storage as `integer`, so it’s a smart database design decision if the column
    values will always fit within its range.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道值会保持在某个范围内时，`smallint`是合适的选择：例如月份的天数或年份。`smallint`类型的存储空间是`integer`的一半，因此如果列的值始终适合其范围，选择它是一个明智的数据库设计决策。
- en: If you try to insert a number into any of these columns that is outside its
    range, the database will stop the operation and return an `out of range` error.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试向这些列中插入超出其范围的数字，数据库将停止操作并返回`超出范围`的错误。
- en: Auto-Incrementing Integers
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自增整数
- en: Sometimes, it’s helpful to create a column that holds integers that *auto-increment*
    each time you add a row to the table. For example, you might use an auto-incrementing
    column to create a unique ID number, also known as a *primary key*, for each row
    in the table. Each row then has its own ID that other tables in the database can
    reference, a concept I’ll cover in Chapter 7.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，创建一个每次向表中添加行时都会*自动递增*的整数列是很有帮助的。例如，你可以使用自增列为表中的每一行创建一个唯一的 ID 号码，也称为*主键*。这样每一行都会有自己的
    ID，其他表可以引用该 ID，这一概念我将在第 7 章中讲解。
- en: With PostgreSQL, you have two ways to auto-increment an integer column. One
    is the *serial* data type, a PostgreSQL-specific implementation of the ANSI SQL
    standard for auto-numbered *identity columns*. The other is the ANSI SQL standard
    `IDENTITY` keyword. Let’s start with serial.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PostgreSQL 中，你可以通过两种方式实现整数列的自动递增。一种是*serial*数据类型，这是 PostgreSQL 特有的实现，符合 ANSI
    SQL 标准中的自动编号*标识符列*。另一种是 ANSI SQL 标准中的`IDENTITY`关键字。我们先从 serial 开始。
- en: Auto-Incrementing with serial
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 serial 实现自增
- en: 'In Chapter 2, when you made the `teachers` table, you created an `id` column
    with the declaration of `bigserial`: this and its siblings `smallserial` and `serial`
    are not so much true data types as a special *implementation* of the corresponding
    `smallint`, `integer`, and `bigint` types. When you add a column with a serial
    type, PostgreSQL will auto-increment the value each time you insert a row, starting
    with 1, up to the maximum of each integer type.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 章中，当你创建`teachers`表时，你创建了一个`id`列并声明了`bigserial`类型：这个和它的兄弟类型`smallserial`、`serial`并不完全是独立的数据类型，而是对应的`smallint`、`integer`和`bigint`类型的特殊*实现*。当你添加一个自增列时，PostgreSQL
    会在每次插入行时自动递增该列的值，从 1 开始，直到每个整数类型的最大值。
- en: '[Table 4-2](#table4-2) shows the serial types and the ranges they cover.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-2](#table4-2)展示了自增类型及其覆盖的范围。'
- en: 'Table 4-2: Serial Data Types'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-2：序列数据类型
- en: '| **Data type** | **Storage size** | **Range** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型** | **存储大小** | **范围** |'
- en: '| --- | --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `smallserial` | 2 bytes | 1 to 32767 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `smallserial` | 2 字节 | 1 到 32767 |'
- en: '| `serial` | 4 bytes | 1 to 2147483647 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `serial` | 4 字节 | 1 到 2147483647 |'
- en: '| `bigserial` | 8 bytes | 1 to 9223372036854775807 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `bigserial` | 8 字节 | 1 到 9223372036854775807 |'
- en: 'To use a serial type on a column, declare it in the `CREATE TABLE` statement
    as you would an integer type. For example, you could create a table called `people`
    that has an `id` column equivalent in size to the `integer` data type:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要在列上使用序列类型，可以像声明整数类型一样，在`CREATE TABLE`语句中声明它。例如，你可以创建一个名为`people`的表，其中有一个`id`列，大小与`integer`数据类型相当：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Every time a new row with a `person_name` is added to the table, the `id` column
    will increment by 1.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每次向表中添加一行具有`person_name`的记录时，`id`列的值将递增 1。
- en: Auto-Incrementing with IDENTITY
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 IDENTITY 实现自增
- en: As of version 10, PostgreSQL includes support for `IDENTITY`, the standard SQL
    implementation for auto-incrementing integers. The `IDENTITY` syntax is more verbose,
    but some database users prefer it for its cross-compatibility with other database
    systems (such as Oracle) and also because it has an option to prevent users from
    accidentally inserting values in the auto-incrementing column (which serial types
    will permit).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本10开始，PostgreSQL支持`IDENTITY`，这是标准SQL中用于自动递增整数的实现。`IDENTITY`语法较为冗长，但一些数据库用户更倾向于使用它，因为它与其他数据库系统（如Oracle）具有跨平台兼容性，并且还提供了防止用户意外插入自动递增列值的选项（而序列类型则允许这种操作）。
- en: 'You can specify `IDENTITY` in two ways:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过两种方式指定`IDENTITY`：
- en: '`GENERATED ALWAYS AS IDENTITY` tells the database to always fill the column
    with an auto-incremented value. A user cannot insert a value into the `id` column
    without manually overriding that setting. See the `OVERRIDING SYSTEM VALUE` section
    of the PostgreSQL `INSERT` documentation at [https://www.postgresql.org/docs/current/sql-insert.html](https://www.postgresql.org/docs/current/sql-insert.html)
    for details.'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GENERATED ALWAYS AS IDENTITY`告诉数据库始终用自动递增的值填充该列。用户不能插入一个值到`id`列中，除非手动覆盖该设置。详细信息请参见PostgreSQL
    `INSERT`文档中的`OVERRIDING SYSTEM VALUE`部分，链接地址：[https://www.postgresql.org/docs/current/sql-insert.html](https://www.postgresql.org/docs/current/sql-insert.html)。'
- en: '`GENERATED BY DEFAULT AS IDENTITY` tells the database to fill the column with
    an auto-incremented value by default if the user does not supply one. This option
    allows for the possibility of duplicate values, which can make use of it problematic
    for creating key columns. I’ll delve into that more in Chapter 7.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GENERATED BY DEFAULT AS IDENTITY`告诉数据库，如果用户未提供值，则默认用自动递增的值填充该列。此选项允许出现重复值，这可能会使其在创建键列时变得具有问题。我将在第7章详细讨论这一点。'
- en: 'For now, we’ll stick with the first option, using `ALWAYS`. To create a table
    called `people` that has an `id` column populated via `IDENTITY`, you would use
    this syntax:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们将坚持使用第一种方式，即使用`ALWAYS`。要创建一个名为`people`的表，并通过`IDENTITY`填充`id`列，你可以使用以下语法：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For the `id` data type, we use `integer` followed by the keywords `GENERATED
    ALWAYS AS IDENTITY`. Now, every time we insert a `person_name` value into the
    table, the database will fill the `id` column with an auto-incremented value.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`id`数据类型，我们使用`integer`，后跟关键词`GENERATED ALWAYS AS IDENTITY`。现在，每次我们将`person_name`值插入表中时，数据库会自动为`id`列填充递增的值。
- en: Given its compatibility with the ANSI SQL standard, I’ll use `IDENTITY` for
    the remainder of the book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它与ANSI SQL标准的兼容性，我将在本书的其余部分使用`IDENTITY`。
- en: Using Decimal Numbers
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用十进制数
- en: '*Decimals* represent a whole number plus a fraction of a whole number; the
    fraction is represented by digits following a *decimal point*. In a SQL database,
    they’re handled by *fixed-point* and *floating-point* data types. For example,
    the distance from my house to the nearest grocery store is 6.7 miles; I could
    insert 6.7 into either a fixed-point or floating-point column with no complaint
    from PostgreSQL. The only difference is how the computer stores the data. In a
    moment, you’ll see that has important implications.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*十进制*表示一个整数加上一个整数的分数部分；该分数部分由*小数点*后的数字表示。在SQL数据库中，它们通过*定点*和*浮点*数据类型进行处理。例如，从我家到最近的杂货店的距离是6.7英里；我可以将6.7插入定点或浮点列，PostgreSQL都不会有任何投诉。唯一的区别是计算机存储数据的方式。稍后，你将看到这有重要的含义。'
- en: Understanding Fixed-Point Numbers
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解定点数
- en: The fixed-point type, also called the *arbitrary precision* type, is `numeric(``precision``,``scale``)`.
    You give the argument `precision` as the maximum number of digits to the left
    and right of the decimal point, and the argument `scale` as the number of digits
    allowable on the right of the decimal point. Alternately, you can specify this
    type using `decimal(``precision``,``scale``)`. Both are part of the ANSI SQL standard.
    If you omit specifying a scale value, the scale will be set to zero; in effect,
    that creates an integer. If you omit specifying the precision and the scale, the
    database will store values of any precision and scale up to the maximum allowed.
    (That’s up to 131,072 digits before the decimal point and 16,383 digits after
    the decimal point, according to the PostgreSQL documentation at [https://www.postgresql.org/docs/current/datatype-numeric.html](https://www.postgresql.org/docs/current/datatype-numeric.html).)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 定点类型，也叫做*任意精度*类型，表示为`numeric(``precision``,``scale``)`。你需要将参数`precision`指定为小数点左右的最大位数，参数`scale`则表示小数点右侧允许的位数。或者，你也可以使用`decimal(``precision``,``scale``)`来指定这种类型。两者都是ANSI
    SQL标准的一部分。如果你省略了`scale`值的指定，默认会设置为零；实际上，这样会创建一个整数。如果你省略了`precision`和`scale`的指定，数据库将存储任何精度和范围的值，直到最大值为止。（根据PostgreSQL文档[https://www.postgresql.org/docs/current/datatype-numeric.html](https://www.postgresql.org/docs/current/datatype-numeric.html)，这最大可以是小数点前131,072位，后面16,383位。）
- en: For example, let’s say you’re collecting rainfall totals from several local
    airports—not an unlikely data analysis task. The US National Weather Service provides
    this data with rainfall typically measured to two decimal places. (And, if you’re
    like me, you have a distant memory of your primary school math teacher explaining
    that two digits after a decimal is the hundredths place.)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你正在收集来自几个当地机场的降水数据——这并不是一个不常见的数据分析任务。美国国家气象局提供的数据通常将降水量测量到小数点后两位。（如果你像我一样，可能还记得小学数学老师讲解过小数点后两位是百分位。）
- en: To record rainfall in the database using five digits total (the precision) and
    two digits maximum to the right of the decimal (the scale), you’d specify it as
    `numeric(5,2)`. The database will always return two digits to the right of the
    decimal point, even if you don’t enter a number that contains two digits such
    as 1.47, 1.00, and 121.50.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要在数据库中记录降水量，总共使用五位数字（精度）并且小数点后最多两位（范围），你可以指定为`numeric(5,2)`。即使你输入的数字没有包含两位小数，如1.47、1.00和121.50，数据库也会始终返回小数点后两位。
- en: Understanding Floating-Point Types
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理解浮动类型
- en: The two floating-point types are `real` and `double precision`, both part of
    the SQL standard. The difference between the two is how much data they store.
    The `real` type allows precision to six decimal digits, and `double precision`
    to 15 decimal digits of precision, both of which include the number of digits
    on both sides of the point. These floating-point types are also called *variable-precision*
    types. The database stores the number in parts representing the digits and an
    exponent—the location where the decimal point belongs. So, unlike `numeric`, where
    we specify fixed precision and scale, the decimal point in a given column can
    “float” depending on the number.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 两种浮动类型是`real`和`double precision`，这两者都属于SQL标准的一部分。它们的区别在于存储的数据量。`real`类型允许六位小数精度，`double
    precision`则可以达到15位小数精度，二者都包括小数点两侧的位数。这些浮动类型也叫做*可变精度*类型。数据库将数字存储为表示位数的部分和一个指数—即小数点的位置。因此，与`numeric`类型中我们指定固定精度和范围不同，在给定列中小数点可以根据数字的不同而“浮动”。
- en: Using Fixed- and Floating-Point Types
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用定点和浮动类型
- en: Each type has differing limits on the number of total digits, or precision,
    it can hold, as shown in [Table 4-3](#table4-3).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型对总位数（即精度）有不同的限制，如[表 4-3](#table4-3)所示。
- en: 'Table 4-3: Fixed-Point and Floating-Point Data Types'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-3：定点和浮动数据类型
- en: '| **Data type** | **Storage size** | **Storage type** | **Range** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型** | **存储大小** | **存储类型** | **范围** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `numeric`, `decimal` | Variable | Fixed-point | Up to 131,072 digits before
    the decimal point; up to 16,383 digits after the decimal point |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `numeric`, `decimal` | 可变 | 定点类型 | 小数点前最多131,072位；小数点后最多16,383位 |'
- en: '| `real` | 4 bytes | Floating-point | 6 decimal digits precision |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `real` | 4 字节 | 浮动类型 | 6 位小数精度 |'
- en: '| `double precision` | 8 bytes | Floating-point | 15 decimal digits precision
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `double precision` | 8 字节 | 浮动类型 | 15 位小数精度 |'
- en: To see how each of the three data types handles the same numbers, create a small
    table and insert a variety of test cases, as shown in [Listing 4-2](#listing4-2).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看这三种数据类型如何处理相同的数字，创建一个小表格并插入各种测试用例，如[清单 4-2](#listing4-2)所示。
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Listing 4-2: Number data types in action'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-2：数字数据类型的应用
- en: 'We create a table with one column for each of the fractional data types 1 and
    load three rows into the table 2. Each row repeats the same number across all
    three columns. When the last line of the script runs and we select everything
    from the table, we get the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个表格，每个分数数据类型都有一列，并将三行数据加载到表格中。每一行在所有三列中重复相同的数字。当脚本的最后一行执行并选择表格中的所有内容时，我们得到以下结果：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice what happened. The `numeric` column, set with a scale of five, stores
    five digits after the decimal point whether or not you inserted that many. If
    fewer than five, it pads the rest with zeros. If more than five, it rounds them—as
    with the third-row number with 10 digits after the decimal.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意发生了什么。设置为五位刻度的`numeric`列，无论你插入多少位小数，总是保留五位小数。如果小于五位，它会用零填充；如果大于五位，它会进行四舍五入——例如第三行的小数点后有十位数字。
- en: The `real` and `double precision` columns add no padding. On the third row,
    you see PostgreSQL’s default behavior in those two columns, which is to output
    floating-point numbers using their shortest precise decimal representation rather
    than show the entire value. Note that older versions of PostgreSQL may display
    slightly different results.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`real`和`double precision`列没有填充。在第三行，你会看到PostgreSQL在这两列中的默认行为，它会输出浮点数的最简精确十进制表示，而不是显示完整的值。请注意，较旧版本的PostgreSQL可能会显示稍有不同的结果。'
- en: Running into Trouble with Floating-Point Math
  id: totrans-99
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 遇到浮点数学问题
- en: If you’re thinking, “Well, numbers stored as a floating-point look just like
    numbers stored as fixed,” tread cautiously. The way computers store floating-point
    numbers can lead to unintended mathematical errors. Look at what happens when
    we do some calculations on these numbers. Run the script in [Listing 4-3](#listing4-3).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在想，“嗯，作为浮点数存储的数字看起来和作为定点数存储的数字一样”，那就要小心了。计算机存储浮点数的方式可能导致意外的数学错误。看看当我们对这些数字进行一些计算时会发生什么。运行[清单
    4-3](#listing4-3)中的脚本。
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Listing 4-3: Rounding issues with float columns'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 4-3：浮动列的舍入问题
- en: 'Here, we multiply the `numeric_column` and the `real_column` by 10 million
    1 and use a `WHERE` clause to filter out just the first row 2. We should get the
    same result for both calculations, right? Here’s what the query returns:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将`numeric_column`和`real_column`分别乘以一千万，并使用`WHERE`子句筛选出第一行。我们应该得到相同的结果，对吧？下面是查询返回的结果：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Hello! No wonder floating-point types are referred to as “inexact.” It’s a good
    thing I’m not using this math to launch a mission to Mars or calculate the federal
    budget deficit.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你好！难怪浮点类型被称为“不精确”。好在我没有用这些数学来发射火星任务或计算联邦预算赤字。
- en: The reason floating-point math produces such errors is that the computer attempts
    to squeeze lots of information into a finite number of bits. The topic is the
    subject of a lot of writings and is beyond the scope of this book, but if you’re
    interested, you’ll find the link to a good synopsis at [https://www.nostarch.com/practical-sql-2nd-edition/](https://www.nostarch.com/practical-sql-2nd-edition/).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数学会产生这些错误的原因是，计算机试图将大量信息压缩到有限的位数中。这个话题已经有很多讨论，超出了本书的范围，但如果你感兴趣，可以在[https://www.nostarch.com/practical-sql-2nd-edition/](https://www.nostarch.com/practical-sql-2nd-edition/)找到一个很好的摘要链接。
- en: The storage required by the `numeric` data type is variable, and depending on
    the precision and scale specified, `numeric` can consume considerably more space
    than the floating-point types. If you’re working with millions of rows, it’s worth
    considering whether you can live with relatively inexact floating-point math.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`numeric`数据类型所需的存储空间是可变的，具体取决于指定的精度和刻度，`numeric`可能比浮点类型消耗更多的空间。如果你正在处理数百万行数据，值得考虑是否能接受相对不精确的浮点数学。'
- en: Choosing Your Number Data Type
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择你的数字数据类型
- en: 'For now, here are three guidelines to consider when you’re dealing with number
    data types:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，在处理数字数据类型时，请考虑以下三条指南：
- en: Use integers when possible. Unless your data uses decimals, stick with integer
    types.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用整数。除非你的数据使用小数，否则请坚持使用整数类型。
- en: If you’re working with decimal data and need calculations to be exact (dealing
    with money, for example), choose `numeric` or its equivalent, `decimal`. Float
    types will save space, but the inexactness of floating-point math won’t pass muster
    in many applications. Use them only when exactness is not as important.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在处理十进制数据并需要精确计算（例如处理货币），请选择 `numeric` 或其等效类型 `decimal`。浮动类型可以节省空间，但浮点数计算的不精确性在许多应用中是无法接受的。只有在精度不那么重要时，才使用它们。
- en: Choose a big enough number type. Unless you’re designing a database to hold
    millions of rows, err on the side of bigger. When using `numeric` or `decimal`,
    set the precision large enough to accommodate the number of digits on both sides
    of the decimal point. With whole numbers, use `bigint` unless you’re absolutely
    sure column values will be constrained to fit into the smaller `integer` or `smallint`
    type.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择一个足够大的数字类型。除非你在设计一个包含数百万行数据的数据库，否则最好选择更大的数据类型。当使用 `numeric` 或 `decimal` 时，确保精度足够大，以容纳小数点两边的数字。对于整数，除非你确定列值会被限制在较小的
    `integer` 或 `smallint` 类型中，否则使用 `bigint`。
- en: Understanding Dates and Times
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解日期和时间
- en: Whenever you enter a date into a search form, you’re reaping the benefit of
    databases having an awareness of the current time (received from the server) plus
    the ability to handle formats for dates, times, and the nuances of the calendar,
    such as leap years and time zones. This is essential for storytelling with data,
    because the issue of *when* something occurred is usually as valuable a question
    as who, what, or how many were involved.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你在搜索表单中输入日期时，你正在享受数据库对当前时间的感知（从服务器接收的）以及能够处理日期、时间格式和日历的细节（如闰年和时区）。这对于通过数据讲故事至关重要，因为关于*何时*发生某事的问题通常和“谁”、“什么”或“多少人”一样有价值。
- en: PostgreSQL’s date and time support includes the four major data types shown
    in [Table 4-4](#table4-4).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 的日期和时间支持包括 [表 4-4](#table4-4) 所示的四种主要数据类型。
- en: 'Table 4-4: Date and Time Data Types'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-4：日期和时间数据类型
- en: '| **Data type** | **Storage size** | **Description** | **Range** |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **数据类型** | **存储大小** | **描述** | **范围** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `timestamp` | 8 bytes | Date and time | 4713 BC to 294276 AD |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `timestamp` | 8 字节 | 日期和时间 | 公元前4713年到公元294276年 |'
- en: '| `date` | 4 bytes | Date (no time) | 4713 BC to 5874897 AD |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `date` | 4 字节 | 仅日期（无时间） | 公元前4713年到公元5874897年 |'
- en: '| `time` | 8 bytes | Time (no date) | 00:00:00 to 24:00:00 |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `time` | 8 字节 | 时间（无日期） | 00:00:00 到 24:00:00 |'
- en: '| `interval` | 16 bytes | Time interval | +/− 178,000,000 years |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `interval` | 16 字节 | 时间间隔 | +/− 1.78亿年 |'
- en: 'Here’s a rundown of data types for times and dates in PostgreSQL:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 PostgreSQL 中日期和时间数据类型的概述：
- en: '`t``imestamp` Records date and time, which are useful for a range of situations
    you might track: departures and arrivals of passenger flights, a schedule of Major
    League Baseball games, or incidents along a timeline. You will almost always want
    to add the keywords `with time zone` to ensure that the time recorded for an event
    includes the time zone where it occurred. Otherwise, times recorded in various
    places around the globe become impossible to compare. The format `timestamp with
    time zone` is part of the SQL standard; with PostgreSQL you can specify the same
    data type using `timestamptz`.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`timestamp` 记录日期和时间，适用于你可能跟踪的一系列情况：乘客航班的起降时间、大联盟棒球比赛的时间表，或时间线上的事件。你几乎总是希望在事件发生的时间后面加上
    `with time zone` 关键字，以确保记录的时间包括发生地点的时区。否则，不同地区记录的时间将无法进行比较。`timestamp with time
    zone` 格式是 SQL 标准的一部分；在 PostgreSQL 中，你可以使用 `timestamptz` 来指定相同的数据类型。'
- en: '`d``ate` Records just the date. Part of the SQL standard.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`date` 仅记录日期，是 SQL 标准的一部分。'
- en: '`t``ime` Records just the time and is part of the SQL standard. Although you
    can add the `with time zone` keywords, without a date the time zone will be meaningless.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`time` 仅记录时间，是 SQL 标准的一部分。虽然你可以添加 `with time zone` 关键字，但没有日期时，时区将没有意义。'
- en: '`i``nterval` Holds a value representing a unit of time expressed in the format
    `quantity unit`. It doesn’t record the start or end of a time period, only its
    length. Examples include `12 days` or `8 hours`. (The PostgreSQL documentation
    at [https://www.postgresql.org/docs/current/datatype-datetime.html](https://www.postgresql.org/docs/current/datatype-datetime.html)
    lists unit values ranging from `microsecond` to `millennium`.) You’ll typically
    use this type for calculations or filtering on other date and time columns. It’s
    also part of the SQL standard, although PostgreSQL-specific syntax offers more
    options.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`i``nterval` 表示一个时间单位的值，采用`数量 单位`的格式。它不记录时间段的开始或结束，只记录持续时间。示例包括`12天`或`8小时`。（PostgreSQL文档在[https://www.postgresql.org/docs/current/datatype-datetime.html](https://www.postgresql.org/docs/current/datatype-datetime.html)中列出了从`微秒`到`千年`的单位值。）你通常会使用此类型进行计算或过滤其他日期和时间列。它也是SQL标准的一部分，尽管PostgreSQL特有的语法提供了更多选项。'
- en: Let’s focus on the `timestamp with time zone` and `interval` types. To see these
    in action, run the script in [Listing 4-4](#listing4-4).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们关注一下`timestamp with time zone`和`interval`类型。要查看这些类型的实际应用，请运行[清单4-4](#listing4-4)中的脚本。
- en: '[PRE9]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Listing 4-4: The `timestamp` and `interval` types in action'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 清单4-4：`timestamp`和`interval`类型的实际应用
- en: 'Here, we create a table with a column for both types 1 and insert four rows
    2. For the first three rows, our insert for the `timestamp_column` uses the same
    date and time (December 31, 2022 at 1 am) using the International Organization
    for Standardization (ISO) format for dates and times: `YYYY``-``MM``-``DD HH``:``MM``:``SS`.
    SQL supports additional date formats (such as `MM/DD/YYYY`), but ISO is recommended
    for portability worldwide.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个包含这两种类型列的表，并插入四行数据。对于前三行，我们的`timestamp_column`插入使用相同的日期和时间（2022年12月31日凌晨1点），采用国际标准化组织（ISO）日期和时间格式：`YYYY``-``MM``-``DD
    HH``:``MM``:``SS`。SQL支持其他日期格式（如`MM/DD/YYYY`），但建议使用ISO格式，以确保全球的可移植性。
- en: 'Following the time, we specify a time zone but use a different format in each
    of the first three rows: in the first row, we use the abbreviation `EST`, which
    is Eastern standard time in the United States.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定时间之后，我们指定了时区，但在前三行中使用了不同的格式：在第一行中，我们使用了`EST`缩写，表示美国东部标准时间。
- en: In the second row, we set the time zone with the value `-8`. That represents
    the number of hours difference, or *offset*, from Coordinated Universal Time (UTC),
    the time standard for the world. The value of UTC is +/− 00:00, so `-8` specifies
    a time zone eight hours behind UTC. In the United States, when daylight saving
    time is in effect, `-8` is the value for the Alaska time zone. From November through
    early March, when the United States reverts to standard time, it refers to the
    Pacific time zone. (For a map of UTC time zones, see [https://en.wikipedia.org/wiki/Coordinated_Universal_Time#/media/File:Standard_World_Time_Zones.tif](https://en.wikipedia.org/wiki/Coordinated_Universal_Time#/media/File:Standard_World_Time_Zones.tif).)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行中，我们设置时区为`-8`。该值表示与世界协调时间（UTC）之间的小时差，或称为*偏移量*。UTC的值为+/−00:00，因此`-8`表示比UTC时间晚8小时。在美国，夏令时生效时，`-8`是阿拉斯加时区的值。从11月到次年3月初，美国恢复标准时间时，这个值指的是太平洋时区。（关于UTC时区的地图，参见[https://en.wikipedia.org/wiki/Coordinated_Universal_Time#/media/File:Standard_World_Time_Zones.tif](https://en.wikipedia.org/wiki/Coordinated_Universal_Time#/media/File:Standard_World_Time_Zones.tif)。）
- en: 'For the third row, we specify the time zone using the name of an area and location:
    `Australia/Melbourne`. That format uses values found in a standard time zone database
    often employed in computer programming. You can learn more about the time zone
    database at [https://en.wikipedia.org/wiki/Tz_database](https://en.wikipedia.org/wiki/Tz_database).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三行，我们使用地区和位置的名称来指定时区：`Australia/Melbourne`。该格式使用了一个标准时区数据库中的值，通常在计算机编程中使用。你可以在[https://en.wikipedia.org/wiki/Tz_database](https://en.wikipedia.org/wiki/Tz_database)了解更多关于时区数据库的信息。
- en: In the fourth row, instead of specifying dates, times, and time zones, the script
    uses PostgreSQL’s `now()` function 3, which captures the current transaction time
    from your hardware.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在第四行中，脚本没有指定具体的日期、时间和时区，而是使用PostgreSQL的`now()`函数，3该函数从你的硬件捕获当前事务时间。
- en: 'After the script runs, the output should look similar to (but not exactly like)
    this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本运行后，输出应该类似（但不完全相同）如下：
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Even though we supplied the same date and time in the first three rows on the
    `timestamp_column`, each row’s output differs. The reason is that pgAdmin reports
    the date and time relative to my time zone, which in the results shown is indicated
    by the UTC offset of `-05` at the end of each timestamp. A UTC offset of `-05`
    means five hours behind UTC, equivalent to the US Eastern time zone during fall
    and winter months when standard time is observed. If you live in a different time
    zone, you’ll likely see a different offset; the times and dates also may differ
    from what’s shown here. We can change how PostgreSQL reports these timestamp values,
    and I’ll cover how to do that plus other tips for wrangling dates and times in
    Chapter 12.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在`timestamp_column`的前三行中提供了相同的日期和时间，但每行的输出却不同。原因是pgAdmin根据我的时区报告日期和时间，在显示的结果中，每个时间戳的末尾都标出了`-05`的UTC偏移量。UTC偏移量`-05`表示比UTC时间晚五小时，相当于美国东部时区在秋冬季节采用标准时间时的时间。如果你生活在不同的时区，你可能会看到不同的偏移量；时间和日期也可能与你看到的有所不同。我们可以更改PostgreSQL报告这些时间戳值的方式，我将在第12章中介绍如何操作以及处理日期和时间的其他技巧。
- en: Finally, the `interval_column` shows the values you entered. PostgreSQL changed
    `1 century` to `100 years` and `1 week` to `7 days` because of its preferred default
    settings for interval display. Read the “Interval Input” section of the PostgreSQL
    documentation at [https://www.postgresql.org/docs/current/datatype-datetime.html](https://www.postgresql.org/docs/current/datatype-datetime.html)
    to learn more about options related to intervals.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`interval_column`显示了你输入的值。PostgreSQL将`1 century`转换为`100 years`，并将`1 week`转换为`7
    days`，这是因为它在区间显示的首选默认设置。阅读PostgreSQL文档中的“Interval Input”部分，了解更多有关区间的选项，网址是[https://www.postgresql.org/docs/current/datatype-datetime.html](https://www.postgresql.org/docs/current/datatype-datetime.html)。
- en: Using the interval Data Type in Calculations
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在计算中使用`interval`数据类型
- en: The `interval` data type is useful for easy-to-understand calculations on date
    and time data. For example, let’s say you have a column that holds the date a
    client signed a contract. Using interval data, you can add 90 days to each contract
    date to determine when to follow up with the client.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`interval`数据类型对于日期和时间数据的简易计算非常有用。例如，假设你有一列保存了客户签署合同的日期。使用区间数据，你可以在每个合同日期上加上90天，以确定何时与客户跟进。'
- en: To see how the `interval` data type works, we’ll use the `date_time_types` table
    we just created, as shown in [Listing 4-5](#listing4-5).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`interval`数据类型如何工作，我们将使用刚刚创建的`date_time_types`表，如[示例 4-5](#listing4-5)所示。
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 4-5: Using the `interval` data type'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 4-5：使用`interval`数据类型
- en: 'This is a typical `SELECT` statement, except we’ll compute a column called
    `new_date` 1 that contains the result of `timestamp_column` minus `interval_column`.
    (Computed columns are called *expressions*;we’ll use this technique often.) In
    each row, we subtract the unit of time indicated by the `interval` data type from
    the date. This produces the following result:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一条典型的`SELECT`语句，只是我们会计算一个名为`new_date`的列，该列包含`timestamp_column`减去`interval_column`的结果。（计算列称为*表达式*；我们将经常使用这种技巧。）在每一行中，我们从日期中减去`interval`数据类型指示的时间单位。这样会产生以下结果：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that the `new_date` column by default is formatted as type `timestamp with
    time zone`, allowing for the display of time values as well as dates if the interval
    value uses them. (You can see the data type listed in the pgAdmin results grid,
    listed beneath the column names.) Again, your output may be different based on
    your time zone.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`new_date`列默认格式化为`timestamp with time zone`类型，允许在区间值使用时显示时间值以及日期。（你可以在pgAdmin的结果网格中看到数据类型，显示在列名下方。）再次提醒，根据你的时区，输出可能会有所不同。
- en: Understanding JSON and JSONB
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解JSON和JSONB
- en: 'JSON, short for *JavaScript Object Notation*, is a structured data format used
    for both storing data and exchanging data between computer systems. All major
    programming languages support reading and writing data in JSON format, which organizes
    information in a collection of *key/value* pairs as well as lists of values. Here’s
    a simple example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是*JavaScript对象表示法*的缩写，是一种用于存储数据和在计算机系统之间交换数据的结构化数据格式。所有主要的编程语言都支持以JSON格式读取和写入数据，这种格式将信息组织为*键/值*对和数值列表。以下是一个简单的例子：
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This snippet of JSON shows the format’s basic structure. A *key*, for example
    `business_name`, is associated with a *value*—in this case, `Old Ebbitt Grill`.
    A key also can have as its value a collection of additional key/value pairs, as
    shown with `address`. The JSON standard enforces rules about formatting, such
    as separating keys and values with a colon and enclosing key names in double quotes.
    You can use online tools such as [https://jsonlint.com/](https://jsonlint.com/)
    to check whether a JSON object has valid formatting.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这段JSON代码展示了该格式的基本结构。例如，*键*（key）`business_name`与*值*（value）`Old Ebbitt Grill`相关联。键的值也可以是一个包含额外键值对的集合，如`address`所示。JSON标准对格式有严格要求，例如用冒号分隔键和值，并将键名用双引号括起来。你可以使用在线工具如[https://jsonlint.com/](https://jsonlint.com/)检查JSON对象是否具有有效的格式。
- en: 'PostgreSQL currently offers two data types for JSON, which both enforce valid
    JSON and support functions for working with data in that format:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL当前提供两种JSON数据类型，它们都强制执行有效的JSON格式，并支持处理该格式数据的函数：
- en: '`json` Stores an exact copy of the JSON text'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`json` 存储JSON文本的精确副本'
- en: '`jsonb` Stores the JSON text in a binary format'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`jsonb` 以二进制格式存储JSON文本'
- en: There are significant differences between the two. For example, `jsonb` supports
    indexing, which can improve processing speed.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者之间有显著的差异。例如，`jsonb`支持索引，这可以提高处理速度。
- en: JSON entered the SQL standard in 2016, but PostgreSQL added support several
    years earlier, starting with version 9.2\. PostgreSQL currently implements several
    functions found in the SQL standard but offers its own additional JSON functions
    and operators. We’ll cover these as well as both types more extensively in Chapter
    16.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: JSON在2016年成为SQL标准的一部分，但PostgreSQL早在几年之前就已支持，从版本9.2开始。PostgreSQL目前实现了SQL标准中的多个函数，并提供了自己的一些额外的JSON函数和操作符。我们将在第16章中更详细地介绍这些类型和功能。
- en: Using Miscellaneous Types
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用杂项类型
- en: 'Character, number, and date/time types will likely comprise the bulk of the
    work you do with SQL. But PostgreSQL supports many additional types, including
    but not limited to the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 字符、数字和日期/时间类型可能是你在使用SQL时处理的主要类型。但PostgreSQL支持许多其他类型，包括但不限于以下几种：
- en: A *Boolean* type that stores a value of `true` or `false`
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*布尔*类型，存储`true`或`false`的值'
- en: '*Geometric types* that include points, lines, circles, and other two-dimensional
    objects'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*几何类型*，包括点、线、圆及其他二维对象'
- en: '*Text search types* for PostgreSQL’s full-text search engine'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*PostgreSQL全文搜索引擎的文本搜索类型*'
- en: '*Network address types*, such as IP or MAC addresses'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*网络地址类型*，如IP地址或MAC地址'
- en: A *universally unique identifier* (*UUID*) type, sometimes used as a unique
    key value in tables
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*通用唯一标识符*（*UUID*）类型，有时用作表中的唯一键值'
- en: '*Range* types, which let you specify a range of values, such as integers or
    timestamps'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*范围*类型，允许你指定值的范围，如整数或时间戳'
- en: Types for storing *binary* data
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储*二进制*数据的类型
- en: An *XML* data type that stores information in that structured format
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*XML*数据类型，用于存储这种结构化格式的信息'
- en: I’ll cover these types as required throughout the book.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在本书中根据需要介绍这些类型。
- en: Transforming Values from One Type to Another with CAST
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CAST转换值的类型
- en: Occasionally, you may need to transform a value from its stored data type to
    another type. For example, you may want to retrieve a number as a character so
    you can combine it with text. Or you might need to convert dates stored as characters
    into an actual date type so you can sort them in date order or perform interval
    calculations. You can perform these conversions using the `CAST()` function.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要将一个值从其存储的数据类型转换为另一种类型。例如，你可能想将一个数字作为字符检索，以便与文本结合使用，或者你可能需要将存储为字符的日期转换为实际的日期类型，以便按照日期顺序排序或进行时间间隔计算。你可以使用`CAST()`函数来执行这些转换。
- en: The `CAST()` function succeeds only when the target data type can accommodate
    the original value. Casting an integer as text is possible, because the character
    types can include numbers. Casting text with letters of the alphabet as a number
    is not.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`CAST()`函数仅在目标数据类型能够容纳原始值时成功。例如，将整数转换为文本是可能的，因为字符类型可以包含数字。而将包含字母的文本转换为数字则不行。'
- en: '[Listing 4-6](#listing4-6) has three examples using the three data type tables
    we just created. The first two examples work, but the third will try to perform
    an invalid type conversion so you can see what a type casting error looks like.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4-6](#listing4-6)展示了使用我们刚创建的三张数据类型表的三个示例。前两个示例能正常工作，但第三个示例将尝试执行无效的类型转换，这样你就可以看到类型转换错误是什么样子的。'
- en: '[PRE14]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 4-6: Three `CAST()` examples'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4-6：三个`CAST()`示例
- en: The first `SELECT` statement 1 returns the `timestamp_column` value as a `varchar`,
    which you’ll recall is a variable-length character column. In this case, I’ve
    set the character length to 10, which means when converted to a character string,
    only the first 10 characters are kept. That’s handy in this case, because that
    just gives us the date segment of the column and excludes the time. Of course,
    there are better ways to remove the time from a timestamp, and I’ll cover those
    in “Extracting the Components of a timestamp Value” in Chapter 12.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`SELECT`语句1将`timestamp_column`的值作为`varchar`返回，你应该记得`varchar`是可变长度字符列。在这种情况下，我已将字符长度设置为10，这意味着转换为字符字符串时，只保留前10个字符。在这种情况下，这很方便，因为它只保留了列的日期部分，排除了时间。当然，也有更好的方法来从时间戳中去除时间，我将在第12章的“提取时间戳值的组成部分”中讲解。
- en: 'The second `SELECT` statement 2 returns the `numeric_column` value three times:
    in its original form and then as an integer and as `text`. Upon conversion to
    an integer, PostgreSQL rounds the value to a whole number. But with the `text`
    conversion, no rounding occurs.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`SELECT`语句2返回`numeric_column`的值三次：一次是原始形式，接着是整数形式，最后是`text`形式。在转换为整数时，PostgreSQL会将值四舍五入为整数。但在转换为`text`时，不会发生四舍五入。
- en: 'The final `SELECT`3 doesn’t work: it returns an error of `invalid input syntax
    for type integer` because letters can’t become integers!'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`SELECT`3不起作用：它返回错误`invalid input syntax for type integer`，因为字母不能转换为整数！
- en: Using CAST Shortcut Notation
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CAST快捷符号
- en: 'It’s always best to write SQL that can be read by another person who might
    pick it up later, and the way `CAST()` is written makes what you intended when
    you used it fairly obvious. However, PostgreSQL also offers a less-obvious shortcut
    notation that takes less space: the *double colon*.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最好编写别人也能阅读的SQL，这样当其他人后来接手时，他们能明白你写的代码。`CAST()`的写法使你在使用它时的意图相当明显。然而，PostgreSQL也提供了一种不那么显而易见的快捷符号，节省空间：*双冒号*。
- en: 'Insert the double colon in between the name of the column and the data type
    you want to convert it to. For example, these two statements cast `timestamp_column`
    as a `varchar`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在列名和你想要转换成的数据类型之间插入双冒号。例如，这两个语句将`timestamp_column`转换为`varchar`：
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Use whichever suits you, but be aware that the double colon is a PostgreSQL-only
    implementation not found in other SQL variants, and so won’t port.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用你觉得合适的方式，但要注意，双冒号是PostgreSQL特有的实现，其他SQL变种中没有，因此不能移植。
- en: Wrapping Up
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: You’re now equipped to better understand the nuances of the data formats you
    encounter while digging into databases. If you come across monetary values stored
    as floating-point numbers, you’ll be sure to convert them to decimals before performing
    any math. And you’ll know how to use the right kind of text column to keep your
    database from growing too big.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经具备了更好地理解你在深入研究数据库时遇到的数据格式的能力。如果你遇到作为浮动点数存储的货币值，你一定要在进行任何数学计算之前将其转换为十进制。而且，你还知道如何使用正确的文本列类型，以防止数据库过大。
- en: Next, I’ll continue with SQL foundations and show you how to import external
    data into your database.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将继续讲解SQL基础，并向你展示如何将外部数据导入到你的数据库中。
