- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding Data Types
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It’s important to understand data types because storing data in the appropriate
    format is fundamental to building usable databases and performing accurate analysis.
    Whenever I dig into a new database, I check the *data type* specified for each
    column in each table. If I’m lucky, I can get my hands on a *data dictionary*:
    a document that lists each column; specifies whether it’s a number, character,
    or other type; and explains the column values. Unfortunately, many organizations
    don’t create and maintain good documentation, so it’s not unusual to hear, “We
    don’t have a data dictionary.” In that case, I inspect the table structures in
    pgAdmin to learn as much as I can.'
  prefs: []
  type: TYPE_NORMAL
- en: Data types are a programming concept applicable to more than just SQL. The concepts
    you’ll explore in this chapter will transfer well to additional languages you
    may want to learn.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a SQL database, each column in a table can hold one and only one data type,
    which you define in the `CREATE TABLE` statement by declaring the data type after
    the column name. In the following simple example table—which you can review but
    don’t need to create—you will find columns with three different data types: a
    date, an integer, and text.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this table named `eagle_watch` (for a hypothetical inventory of bald eagles),
    we declare the `observation_date` column to hold date values by adding the `date`
    type declaration after its name. Similarly, we set `eagles_seen` to hold whole
    numbers with the `integer` type declaration and declare `notes` to hold characters
    via the `text` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'These data types fall into the three categories you’ll encounter most:'
  prefs: []
  type: TYPE_NORMAL
- en: Characters Any character or symbol
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Numbers Includes whole numbers and fractions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Dates and times Temporal information
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s look at each data type in depth; I’ll note whether they’re part of standard
    ANSI SQL or specific to PostgreSQL. An overall, in-depth look at where PostgreSQL
    deviates from the SQL standard is available at [https://wiki.postgresql.org/wiki/PostgreSQL_vs_SQL_Standard](https://wiki.postgresql.org/wiki/PostgreSQL_vs_SQL_Standard).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Characters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Character string types* are general-purpose types suitable for any combination
    of text, numbers, and symbols. Character types include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`char(``n``)`**'
  prefs: []
  type: TYPE_NORMAL
- en: A fixed-length column where the character length is specified by `n`. A column
    set at `char(20)` stores 20 characters per row regardless of how many characters
    you insert. If you insert fewer than 20 characters in any row, PostgreSQL pads
    the rest of that column with spaces. This type, which is part of standard SQL,
    also can be specified with the longer name `character(``n``)`. Nowadays, `char(``n``)`
    is used infrequently and is mainly a remnant of legacy computer systems.
  prefs: []
  type: TYPE_NORMAL
- en: '**`varchar(``n``)`**'
  prefs: []
  type: TYPE_NORMAL
- en: A variable-length column where the *maximum* length is specified by `n`. If
    you insert fewer characters than the maximum, PostgreSQL will not store extra
    spaces. For example, the string `blue` will take four spaces, whereas the string
    `123` will take three. In large databases, this practice saves considerable space.
    This type, included in standard SQL, also can be specified using the longer name
    `character varying(``n``)`.
  prefs: []
  type: TYPE_NORMAL
- en: '**`text`**'
  prefs: []
  type: TYPE_NORMAL
- en: A variable-length column of unlimited length. (According to the PostgreSQL documentation,
    the longest possible character string you can store is about 1 gigabyte.) The
    `text` type is not part of the SQL standard, but you’ll find similar implementations
    in other database systems, including Microsoft SQL Server and MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: According to PostgreSQL documentation at [https://www.postgresql.org/docs/current/datatype-character.html](https://www.postgresql.org/docs/current/datatype-character.html),
    there is no substantial difference in performance among the three types. That
    may differ if you’re using another database manager, so it’s wise to check the
    docs. The flexibility and potential space savings of `varchar` and `text` seem
    to give them an advantage. But if you search discussions online, some users suggest
    that defining a column that will always have the same number of characters with
    `char` is a good way to signal what data it should contain. For instance, you
    might see `char(2)` used for US state postal abbreviations.
  prefs: []
  type: TYPE_NORMAL
- en: To see these three character types in action, run the script shown in [Listing
    4-1](#listing4-1). This script will build and load a simple table and then export
    the data to a text file on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-1: Character data types in action'
  prefs: []
  type: TYPE_NORMAL
- en: We define three character columns 1 of different types and insert two rows of
    the same string into each 2. Unlike the `INSERT INTO` statement you learned in
    Chapter 2, here we’re not specifying the names of the columns. If the `VALUES`
    statements match the number of columns in the table, the database will assume
    you’re inserting values in the order the column definitions were specified in
    the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we use the PostgreSQL `COPY` keyword 3 to export the data to a text file
    named *typetest.txt* in a directory you specify. You’ll need to replace *C:\YourDirectory\*
    with the full path to the directory on your computer where you want to save the
    file. The examples in this book use Windows format—which use a backslash between
    folders and file names—and a path to a directory called *YourDirectory* on the
    C: drive. Windows users must set permissions for the destination folder according
    to the note in the section “Downloading Code and Data from GitHub” in Chapter
    1.'
  prefs: []
  type: TYPE_NORMAL
- en: Linux and macOS file paths have a different format, with forward slashes between
    folders and filenames. On my Mac, for example, the path to a file on the desktop
    is */Users/anthony/Desktop/*. The directory must exist already; PostgreSQL won’t
    create it for you.
  prefs: []
  type: TYPE_NORMAL
- en: In PostgreSQL, `COPY` `table_name` `FROM` is the import function, and `COPY`
    `table_name` `TO` is the export function. I’ll cover them in depth in Chapter
    5; for now, all you need to know is that the `WITH` keyword options 4 will format
    the data in the file with each column separated by a *pipe* (`|`) character. That
    way, you can easily see where spaces fill out the unused portions of the `char`
    column.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the output, open *typetest.txt* using the text editor you installed
    in Chapter 1 (not Word or Excel, or another spreadsheet application). The contents
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Even though you specified 10 characters for both the `char` and `varchar` columns,
    only the `char` column outputs 10 characters in both rows, padding unused characters
    with spaces. The `varchar` and `text` columns store only the characters you inserted.
  prefs: []
  type: TYPE_NORMAL
- en: Again, there’s no real performance difference among the three types, although
    this example shows that `char` can potentially consume more storage space than
    needed. A few unused spaces in each column might seem negligible, but multiply
    that over millions of rows in dozens of tables and you’ll soon wish you had been
    more economical.
  prefs: []
  type: TYPE_NORMAL
- en: I tend to use `text` on all my character columns. That saves me from having
    to configure maximum lengths for multiple `varchar` columns and means I won’t
    need to modify a table later if the requirements for a character column change.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Number columns hold various types of (you guessed it) numbers, but that’s not
    all: they also allow you to perform calculations on those numbers. That’s an important
    distinction from numbers you store as strings in a character column, which can’t
    be added, multiplied, divided, or perform any other math operation. Also, numbers
    stored as characters sort differently than numbers stored as numbers, so if you’re
    doing math or the numeric order is important, use number types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL number types include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Integers Whole numbers, both positive and negative
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fixed-point and floating-point Two formats of fractions of whole numbers
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll look at each type separately.
  prefs: []
  type: TYPE_NORMAL
- en: Using Integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The integer data types are the most common number types you’ll find when exploring
    a SQL database. These are *whole numbers*, both positive and negative, including
    zero. Think of all the places integers appear in life: your street or apartment
    number, the serial number on your refrigerator, the number on a raffle ticket.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL standard provides three integer types: `smallint`, `integer`, and `bigint`.
    The difference between the three types is the maximum size of the numbers they
    can hold. [Table 4-1](#table4-1) shows the upper and lower limits of each, as
    well as how much storage each requires in bytes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-1: Integer Data Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data type** | **Storage size** | **Range** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `smallint` | 2 bytes | −32768 to +32767 |'
  prefs: []
  type: TYPE_TB
- en: '| `integer` | 4 bytes | −2147483648 to +2147483647 |'
  prefs: []
  type: TYPE_TB
- en: '| `bigint` | 8 bytes | −9223372036854775808 to +9223372036854775807 |'
  prefs: []
  type: TYPE_TB
- en: The `bigint` type will cover just about any requirement you’ll ever have with
    a number column, though it eats up the most storage. Its use is a must if you’re
    working with numbers larger than about 2.1 billion, but you also can easily make
    it your go-to default and never worry about not being able to fit a number in
    the column. On the other hand, if you’re confident numbers will remain within
    the `integer` limit, that type is a good choice because it doesn’t consume as
    much space as `bigint` (a concern when dealing with millions of data rows).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you know that values will remain constrained, `smallint` makes sense:
    days of the month or years are good examples. The `smallint` type will use half
    the storage as `integer`, so it’s a smart database design decision if the column
    values will always fit within its range.'
  prefs: []
  type: TYPE_NORMAL
- en: If you try to insert a number into any of these columns that is outside its
    range, the database will stop the operation and return an `out of range` error.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-Incrementing Integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, it’s helpful to create a column that holds integers that *auto-increment*
    each time you add a row to the table. For example, you might use an auto-incrementing
    column to create a unique ID number, also known as a *primary key*, for each row
    in the table. Each row then has its own ID that other tables in the database can
    reference, a concept I’ll cover in Chapter 7.
  prefs: []
  type: TYPE_NORMAL
- en: With PostgreSQL, you have two ways to auto-increment an integer column. One
    is the *serial* data type, a PostgreSQL-specific implementation of the ANSI SQL
    standard for auto-numbered *identity columns*. The other is the ANSI SQL standard
    `IDENTITY` keyword. Let’s start with serial.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-Incrementing with serial
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In Chapter 2, when you made the `teachers` table, you created an `id` column
    with the declaration of `bigserial`: this and its siblings `smallserial` and `serial`
    are not so much true data types as a special *implementation* of the corresponding
    `smallint`, `integer`, and `bigint` types. When you add a column with a serial
    type, PostgreSQL will auto-increment the value each time you insert a row, starting
    with 1, up to the maximum of each integer type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-2](#table4-2) shows the serial types and the ranges they cover.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-2: Serial Data Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data type** | **Storage size** | **Range** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `smallserial` | 2 bytes | 1 to 32767 |'
  prefs: []
  type: TYPE_TB
- en: '| `serial` | 4 bytes | 1 to 2147483647 |'
  prefs: []
  type: TYPE_TB
- en: '| `bigserial` | 8 bytes | 1 to 9223372036854775807 |'
  prefs: []
  type: TYPE_TB
- en: 'To use a serial type on a column, declare it in the `CREATE TABLE` statement
    as you would an integer type. For example, you could create a table called `people`
    that has an `id` column equivalent in size to the `integer` data type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Every time a new row with a `person_name` is added to the table, the `id` column
    will increment by 1.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-Incrementing with IDENTITY
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As of version 10, PostgreSQL includes support for `IDENTITY`, the standard SQL
    implementation for auto-incrementing integers. The `IDENTITY` syntax is more verbose,
    but some database users prefer it for its cross-compatibility with other database
    systems (such as Oracle) and also because it has an option to prevent users from
    accidentally inserting values in the auto-incrementing column (which serial types
    will permit).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can specify `IDENTITY` in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GENERATED ALWAYS AS IDENTITY` tells the database to always fill the column
    with an auto-incremented value. A user cannot insert a value into the `id` column
    without manually overriding that setting. See the `OVERRIDING SYSTEM VALUE` section
    of the PostgreSQL `INSERT` documentation at [https://www.postgresql.org/docs/current/sql-insert.html](https://www.postgresql.org/docs/current/sql-insert.html)
    for details.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GENERATED BY DEFAULT AS IDENTITY` tells the database to fill the column with
    an auto-incremented value by default if the user does not supply one. This option
    allows for the possibility of duplicate values, which can make use of it problematic
    for creating key columns. I’ll delve into that more in Chapter 7.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For now, we’ll stick with the first option, using `ALWAYS`. To create a table
    called `people` that has an `id` column populated via `IDENTITY`, you would use
    this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For the `id` data type, we use `integer` followed by the keywords `GENERATED
    ALWAYS AS IDENTITY`. Now, every time we insert a `person_name` value into the
    table, the database will fill the `id` column with an auto-incremented value.
  prefs: []
  type: TYPE_NORMAL
- en: Given its compatibility with the ANSI SQL standard, I’ll use `IDENTITY` for
    the remainder of the book.
  prefs: []
  type: TYPE_NORMAL
- en: Using Decimal Numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Decimals* represent a whole number plus a fraction of a whole number; the
    fraction is represented by digits following a *decimal point*. In a SQL database,
    they’re handled by *fixed-point* and *floating-point* data types. For example,
    the distance from my house to the nearest grocery store is 6.7 miles; I could
    insert 6.7 into either a fixed-point or floating-point column with no complaint
    from PostgreSQL. The only difference is how the computer stores the data. In a
    moment, you’ll see that has important implications.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Fixed-Point Numbers
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The fixed-point type, also called the *arbitrary precision* type, is `numeric(``precision``,``scale``)`.
    You give the argument `precision` as the maximum number of digits to the left
    and right of the decimal point, and the argument `scale` as the number of digits
    allowable on the right of the decimal point. Alternately, you can specify this
    type using `decimal(``precision``,``scale``)`. Both are part of the ANSI SQL standard.
    If you omit specifying a scale value, the scale will be set to zero; in effect,
    that creates an integer. If you omit specifying the precision and the scale, the
    database will store values of any precision and scale up to the maximum allowed.
    (That’s up to 131,072 digits before the decimal point and 16,383 digits after
    the decimal point, according to the PostgreSQL documentation at [https://www.postgresql.org/docs/current/datatype-numeric.html](https://www.postgresql.org/docs/current/datatype-numeric.html).)
  prefs: []
  type: TYPE_NORMAL
- en: For example, let’s say you’re collecting rainfall totals from several local
    airports—not an unlikely data analysis task. The US National Weather Service provides
    this data with rainfall typically measured to two decimal places. (And, if you’re
    like me, you have a distant memory of your primary school math teacher explaining
    that two digits after a decimal is the hundredths place.)
  prefs: []
  type: TYPE_NORMAL
- en: To record rainfall in the database using five digits total (the precision) and
    two digits maximum to the right of the decimal (the scale), you’d specify it as
    `numeric(5,2)`. The database will always return two digits to the right of the
    decimal point, even if you don’t enter a number that contains two digits such
    as 1.47, 1.00, and 121.50.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Floating-Point Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The two floating-point types are `real` and `double precision`, both part of
    the SQL standard. The difference between the two is how much data they store.
    The `real` type allows precision to six decimal digits, and `double precision`
    to 15 decimal digits of precision, both of which include the number of digits
    on both sides of the point. These floating-point types are also called *variable-precision*
    types. The database stores the number in parts representing the digits and an
    exponent—the location where the decimal point belongs. So, unlike `numeric`, where
    we specify fixed precision and scale, the decimal point in a given column can
    “float” depending on the number.
  prefs: []
  type: TYPE_NORMAL
- en: Using Fixed- and Floating-Point Types
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Each type has differing limits on the number of total digits, or precision,
    it can hold, as shown in [Table 4-3](#table4-3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-3: Fixed-Point and Floating-Point Data Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data type** | **Storage size** | **Storage type** | **Range** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `numeric`, `decimal` | Variable | Fixed-point | Up to 131,072 digits before
    the decimal point; up to 16,383 digits after the decimal point |'
  prefs: []
  type: TYPE_TB
- en: '| `real` | 4 bytes | Floating-point | 6 decimal digits precision |'
  prefs: []
  type: TYPE_TB
- en: '| `double precision` | 8 bytes | Floating-point | 15 decimal digits precision
    |'
  prefs: []
  type: TYPE_TB
- en: To see how each of the three data types handles the same numbers, create a small
    table and insert a variety of test cases, as shown in [Listing 4-2](#listing4-2).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-2: Number data types in action'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create a table with one column for each of the fractional data types 1 and
    load three rows into the table 2. Each row repeats the same number across all
    three columns. When the last line of the script runs and we select everything
    from the table, we get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice what happened. The `numeric` column, set with a scale of five, stores
    five digits after the decimal point whether or not you inserted that many. If
    fewer than five, it pads the rest with zeros. If more than five, it rounds them—as
    with the third-row number with 10 digits after the decimal.
  prefs: []
  type: TYPE_NORMAL
- en: The `real` and `double precision` columns add no padding. On the third row,
    you see PostgreSQL’s default behavior in those two columns, which is to output
    floating-point numbers using their shortest precise decimal representation rather
    than show the entire value. Note that older versions of PostgreSQL may display
    slightly different results.
  prefs: []
  type: TYPE_NORMAL
- en: Running into Trouble with Floating-Point Math
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re thinking, “Well, numbers stored as a floating-point look just like
    numbers stored as fixed,” tread cautiously. The way computers store floating-point
    numbers can lead to unintended mathematical errors. Look at what happens when
    we do some calculations on these numbers. Run the script in [Listing 4-3](#listing4-3).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-3: Rounding issues with float columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we multiply the `numeric_column` and the `real_column` by 10 million
    1 and use a `WHERE` clause to filter out just the first row 2. We should get the
    same result for both calculations, right? Here’s what the query returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Hello! No wonder floating-point types are referred to as “inexact.” It’s a good
    thing I’m not using this math to launch a mission to Mars or calculate the federal
    budget deficit.
  prefs: []
  type: TYPE_NORMAL
- en: The reason floating-point math produces such errors is that the computer attempts
    to squeeze lots of information into a finite number of bits. The topic is the
    subject of a lot of writings and is beyond the scope of this book, but if you’re
    interested, you’ll find the link to a good synopsis at [https://www.nostarch.com/practical-sql-2nd-edition/](https://www.nostarch.com/practical-sql-2nd-edition/).
  prefs: []
  type: TYPE_NORMAL
- en: The storage required by the `numeric` data type is variable, and depending on
    the precision and scale specified, `numeric` can consume considerably more space
    than the floating-point types. If you’re working with millions of rows, it’s worth
    considering whether you can live with relatively inexact floating-point math.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing Your Number Data Type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For now, here are three guidelines to consider when you’re dealing with number
    data types:'
  prefs: []
  type: TYPE_NORMAL
- en: Use integers when possible. Unless your data uses decimals, stick with integer
    types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re working with decimal data and need calculations to be exact (dealing
    with money, for example), choose `numeric` or its equivalent, `decimal`. Float
    types will save space, but the inexactness of floating-point math won’t pass muster
    in many applications. Use them only when exactness is not as important.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choose a big enough number type. Unless you’re designing a database to hold
    millions of rows, err on the side of bigger. When using `numeric` or `decimal`,
    set the precision large enough to accommodate the number of digits on both sides
    of the decimal point. With whole numbers, use `bigint` unless you’re absolutely
    sure column values will be constrained to fit into the smaller `integer` or `smallint`
    type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Dates and Times
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever you enter a date into a search form, you’re reaping the benefit of
    databases having an awareness of the current time (received from the server) plus
    the ability to handle formats for dates, times, and the nuances of the calendar,
    such as leap years and time zones. This is essential for storytelling with data,
    because the issue of *when* something occurred is usually as valuable a question
    as who, what, or how many were involved.
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL’s date and time support includes the four major data types shown
    in [Table 4-4](#table4-4).
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-4: Date and Time Data Types'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data type** | **Storage size** | **Description** | **Range** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `timestamp` | 8 bytes | Date and time | 4713 BC to 294276 AD |'
  prefs: []
  type: TYPE_TB
- en: '| `date` | 4 bytes | Date (no time) | 4713 BC to 5874897 AD |'
  prefs: []
  type: TYPE_TB
- en: '| `time` | 8 bytes | Time (no date) | 00:00:00 to 24:00:00 |'
  prefs: []
  type: TYPE_TB
- en: '| `interval` | 16 bytes | Time interval | +/− 178,000,000 years |'
  prefs: []
  type: TYPE_TB
- en: 'Here’s a rundown of data types for times and dates in PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '`t``imestamp` Records date and time, which are useful for a range of situations
    you might track: departures and arrivals of passenger flights, a schedule of Major
    League Baseball games, or incidents along a timeline. You will almost always want
    to add the keywords `with time zone` to ensure that the time recorded for an event
    includes the time zone where it occurred. Otherwise, times recorded in various
    places around the globe become impossible to compare. The format `timestamp with
    time zone` is part of the SQL standard; with PostgreSQL you can specify the same
    data type using `timestamptz`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`d``ate` Records just the date. Part of the SQL standard.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`t``ime` Records just the time and is part of the SQL standard. Although you
    can add the `with time zone` keywords, without a date the time zone will be meaningless.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`i``nterval` Holds a value representing a unit of time expressed in the format
    `quantity unit`. It doesn’t record the start or end of a time period, only its
    length. Examples include `12 days` or `8 hours`. (The PostgreSQL documentation
    at [https://www.postgresql.org/docs/current/datatype-datetime.html](https://www.postgresql.org/docs/current/datatype-datetime.html)
    lists unit values ranging from `microsecond` to `millennium`.) You’ll typically
    use this type for calculations or filtering on other date and time columns. It’s
    also part of the SQL standard, although PostgreSQL-specific syntax offers more
    options.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s focus on the `timestamp with time zone` and `interval` types. To see these
    in action, run the script in [Listing 4-4](#listing4-4).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-4: The `timestamp` and `interval` types in action'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we create a table with a column for both types 1 and insert four rows
    2. For the first three rows, our insert for the `timestamp_column` uses the same
    date and time (December 31, 2022 at 1 am) using the International Organization
    for Standardization (ISO) format for dates and times: `YYYY``-``MM``-``DD HH``:``MM``:``SS`.
    SQL supports additional date formats (such as `MM/DD/YYYY`), but ISO is recommended
    for portability worldwide.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the time, we specify a time zone but use a different format in each
    of the first three rows: in the first row, we use the abbreviation `EST`, which
    is Eastern standard time in the United States.'
  prefs: []
  type: TYPE_NORMAL
- en: In the second row, we set the time zone with the value `-8`. That represents
    the number of hours difference, or *offset*, from Coordinated Universal Time (UTC),
    the time standard for the world. The value of UTC is +/− 00:00, so `-8` specifies
    a time zone eight hours behind UTC. In the United States, when daylight saving
    time is in effect, `-8` is the value for the Alaska time zone. From November through
    early March, when the United States reverts to standard time, it refers to the
    Pacific time zone. (For a map of UTC time zones, see [https://en.wikipedia.org/wiki/Coordinated_Universal_Time#/media/File:Standard_World_Time_Zones.tif](https://en.wikipedia.org/wiki/Coordinated_Universal_Time#/media/File:Standard_World_Time_Zones.tif).)
  prefs: []
  type: TYPE_NORMAL
- en: 'For the third row, we specify the time zone using the name of an area and location:
    `Australia/Melbourne`. That format uses values found in a standard time zone database
    often employed in computer programming. You can learn more about the time zone
    database at [https://en.wikipedia.org/wiki/Tz_database](https://en.wikipedia.org/wiki/Tz_database).'
  prefs: []
  type: TYPE_NORMAL
- en: In the fourth row, instead of specifying dates, times, and time zones, the script
    uses PostgreSQL’s `now()` function 3, which captures the current transaction time
    from your hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the script runs, the output should look similar to (but not exactly like)
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Even though we supplied the same date and time in the first three rows on the
    `timestamp_column`, each row’s output differs. The reason is that pgAdmin reports
    the date and time relative to my time zone, which in the results shown is indicated
    by the UTC offset of `-05` at the end of each timestamp. A UTC offset of `-05`
    means five hours behind UTC, equivalent to the US Eastern time zone during fall
    and winter months when standard time is observed. If you live in a different time
    zone, you’ll likely see a different offset; the times and dates also may differ
    from what’s shown here. We can change how PostgreSQL reports these timestamp values,
    and I’ll cover how to do that plus other tips for wrangling dates and times in
    Chapter 12.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `interval_column` shows the values you entered. PostgreSQL changed
    `1 century` to `100 years` and `1 week` to `7 days` because of its preferred default
    settings for interval display. Read the “Interval Input” section of the PostgreSQL
    documentation at [https://www.postgresql.org/docs/current/datatype-datetime.html](https://www.postgresql.org/docs/current/datatype-datetime.html)
    to learn more about options related to intervals.
  prefs: []
  type: TYPE_NORMAL
- en: Using the interval Data Type in Calculations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `interval` data type is useful for easy-to-understand calculations on date
    and time data. For example, let’s say you have a column that holds the date a
    client signed a contract. Using interval data, you can add 90 days to each contract
    date to determine when to follow up with the client.
  prefs: []
  type: TYPE_NORMAL
- en: To see how the `interval` data type works, we’ll use the `date_time_types` table
    we just created, as shown in [Listing 4-5](#listing4-5).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-5: Using the `interval` data type'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a typical `SELECT` statement, except we’ll compute a column called
    `new_date` 1 that contains the result of `timestamp_column` minus `interval_column`.
    (Computed columns are called *expressions*;we’ll use this technique often.) In
    each row, we subtract the unit of time indicated by the `interval` data type from
    the date. This produces the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `new_date` column by default is formatted as type `timestamp with
    time zone`, allowing for the display of time values as well as dates if the interval
    value uses them. (You can see the data type listed in the pgAdmin results grid,
    listed beneath the column names.) Again, your output may be different based on
    your time zone.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding JSON and JSONB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSON, short for *JavaScript Object Notation*, is a structured data format used
    for both storing data and exchanging data between computer systems. All major
    programming languages support reading and writing data in JSON format, which organizes
    information in a collection of *key/value* pairs as well as lists of values. Here’s
    a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This snippet of JSON shows the format’s basic structure. A *key*, for example
    `business_name`, is associated with a *value*—in this case, `Old Ebbitt Grill`.
    A key also can have as its value a collection of additional key/value pairs, as
    shown with `address`. The JSON standard enforces rules about formatting, such
    as separating keys and values with a colon and enclosing key names in double quotes.
    You can use online tools such as [https://jsonlint.com/](https://jsonlint.com/)
    to check whether a JSON object has valid formatting.
  prefs: []
  type: TYPE_NORMAL
- en: 'PostgreSQL currently offers two data types for JSON, which both enforce valid
    JSON and support functions for working with data in that format:'
  prefs: []
  type: TYPE_NORMAL
- en: '`json` Stores an exact copy of the JSON text'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`jsonb` Stores the JSON text in a binary format'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are significant differences between the two. For example, `jsonb` supports
    indexing, which can improve processing speed.
  prefs: []
  type: TYPE_NORMAL
- en: JSON entered the SQL standard in 2016, but PostgreSQL added support several
    years earlier, starting with version 9.2\. PostgreSQL currently implements several
    functions found in the SQL standard but offers its own additional JSON functions
    and operators. We’ll cover these as well as both types more extensively in Chapter
    16.
  prefs: []
  type: TYPE_NORMAL
- en: Using Miscellaneous Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Character, number, and date/time types will likely comprise the bulk of the
    work you do with SQL. But PostgreSQL supports many additional types, including
    but not limited to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A *Boolean* type that stores a value of `true` or `false`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Geometric types* that include points, lines, circles, and other two-dimensional
    objects'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Text search types* for PostgreSQL’s full-text search engine'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Network address types*, such as IP or MAC addresses'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A *universally unique identifier* (*UUID*) type, sometimes used as a unique
    key value in tables
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Range* types, which let you specify a range of values, such as integers or
    timestamps'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Types for storing *binary* data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An *XML* data type that stores information in that structured format
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I’ll cover these types as required throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming Values from One Type to Another with CAST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Occasionally, you may need to transform a value from its stored data type to
    another type. For example, you may want to retrieve a number as a character so
    you can combine it with text. Or you might need to convert dates stored as characters
    into an actual date type so you can sort them in date order or perform interval
    calculations. You can perform these conversions using the `CAST()` function.
  prefs: []
  type: TYPE_NORMAL
- en: The `CAST()` function succeeds only when the target data type can accommodate
    the original value. Casting an integer as text is possible, because the character
    types can include numbers. Casting text with letters of the alphabet as a number
    is not.
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 4-6](#listing4-6) has three examples using the three data type tables
    we just created. The first two examples work, but the third will try to perform
    an invalid type conversion so you can see what a type casting error looks like.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing 4-6: Three `CAST()` examples'
  prefs: []
  type: TYPE_NORMAL
- en: The first `SELECT` statement 1 returns the `timestamp_column` value as a `varchar`,
    which you’ll recall is a variable-length character column. In this case, I’ve
    set the character length to 10, which means when converted to a character string,
    only the first 10 characters are kept. That’s handy in this case, because that
    just gives us the date segment of the column and excludes the time. Of course,
    there are better ways to remove the time from a timestamp, and I’ll cover those
    in “Extracting the Components of a timestamp Value” in Chapter 12.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second `SELECT` statement 2 returns the `numeric_column` value three times:
    in its original form and then as an integer and as `text`. Upon conversion to
    an integer, PostgreSQL rounds the value to a whole number. But with the `text`
    conversion, no rounding occurs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final `SELECT`3 doesn’t work: it returns an error of `invalid input syntax
    for type integer` because letters can’t become integers!'
  prefs: []
  type: TYPE_NORMAL
- en: Using CAST Shortcut Notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s always best to write SQL that can be read by another person who might
    pick it up later, and the way `CAST()` is written makes what you intended when
    you used it fairly obvious. However, PostgreSQL also offers a less-obvious shortcut
    notation that takes less space: the *double colon*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Insert the double colon in between the name of the column and the data type
    you want to convert it to. For example, these two statements cast `timestamp_column`
    as a `varchar`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Use whichever suits you, but be aware that the double colon is a PostgreSQL-only
    implementation not found in other SQL variants, and so won’t port.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Up
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’re now equipped to better understand the nuances of the data formats you
    encounter while digging into databases. If you come across monetary values stored
    as floating-point numbers, you’ll be sure to convert them to decimals before performing
    any math. And you’ll know how to use the right kind of text column to keep your
    database from growing too big.
  prefs: []
  type: TYPE_NORMAL
- en: Next, I’ll continue with SQL foundations and show you how to import external
    data into your database.
  prefs: []
  type: TYPE_NORMAL
