<html><head></head><body>
<section>
<header>
<h1 class="chapter">
<span class="ChapterNumber"><span epub:type="pagebreak" title="77" id="Page_77"/>5</span><br/>
<span class="ChapterTitle">Decision and Control Statements</span></h1>
</header>
<figure class="opener">
<img src="image_fi/book_art/chapterart.png" alt=""/>
</figure>
<p class="ChapterIntro">A computer is a powerful instrument because it can make decisions based on the data it receives. For example, a computer can turn on an LED if a button is being pressed and turn off the LED if it isn’t. In this chapter we will see how C’s various decision and control statements operate. Then we’ll apply them to embedded programming by making our device respond to button presses.</p>
<h2 id="h1-501621c05-0001">The if Statement</h2>
<p class="BodyFirst">We use the <code>if</code> statement to execute some code only if some condition is true. Here is the general form of this statement:</p>
<pre><code>if (<var>condition</var>)
    <var>statement</var>;</code></pre>
<p><span epub:type="pagebreak" title="78" id="Page_78"/>To conditionally execute more than one statement, enclose the set of statements affected by the condition inside curly brackets (<code>{}</code>), as shown next. C will treat the set of statements as a single block:</p>
<pre><code>if (<var>condition</var>)  {
    <var>statement</var>;
    <var>statement</var>;
    <var>statement</var>;
    // ...
}</code></pre>
<p>C considers anything nonzero as true and zero as false. Therefore, if the condition is nonzero, the statements will execute. If the condition is zero, they will not.</p>
<p><a href="#table5-1" id="tableanchor5-1">Table 5-1</a> lists the other comparison operators.</p>
<figure>
<figcaption class="TableTitle"><p><a id="table5-1">Table 5-1</a>: The Comparison Operators</p></figcaption>
<table id="table-501621c05-0001" border="1">
<thead>
<tr>
<td><b>Operator</b></td>
<td><b>Description</b></td>
</tr>
</thead>
<tbody>
<tr>
<td><code>==</code></td>
<td>Equals</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>Less than</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>Less than or equal</td>
</tr>
<tr>
<td><code>!=</code></td>
<td>Not equals</td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>Greater than</td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>Greater than or equal</td>
</tr>
</tbody>
</table>
</figure>
<p>For example, if you wanted some code to execute only if a variable had a value of 5, you could use the equals (<code>==</code>) operator, as follows:</p>
<pre><code>if (aNumber == 5) {
    printf("The number is 5\n");
}</code></pre>
<p>A word of warning: C allows assignment inside conditionals. For example, the following code, which assigns a variable a value of 7 within the <code>if</code> statement, is legal:</p>
<pre><code>if (aNumber = 7) {
    printf("Something happened\n");
}</code></pre>
<p>This is the equivalent of the following code, which tests whether the variable is equal to zero after the assignment:</p>
<pre><code>aNumber = 7;        // Assignment
if (aNumber != 0) { // Test against zero
    printf("Something happened\n");
}</code></pre>
<p><span epub:type="pagebreak" title="79" id="Page_79"/>It is <em>not</em> the same as the following condition, which tests whether a variable is equal to 7:</p>
<pre><code>if (aNumber == 7)</code></pre>
<p>This problem was a nasty one in the early days of C when compiler technology was not what it is today. You’d make a mistake by accidentally writing something like the following code, only much more complicated:</p>
<pre><code>aNumber = 5;
if (aNumber = 7) {  // Notice the missing '=' character.
    printf("Something happened\n");
}</code></pre>
<p>The code within the <code>if</code> statement would be executed, as the variable would be reassigned a value of 7, which as a nonzero value would immediately make the condition true, even though you intended <code>aNumber</code> to be 5, not 7. With the modern GCC compiler, assignment in a condition generates a warning:</p>
<pre><code>equal.c:14:5: warning: suggest parentheses around assignment used as truth value [-Wparentheses]
 if (aNumber = 7) {</code></pre>
<p>Here, GCC is telling you that if you want to suppress the warning because you really want to combine an assignment statement and an <code>if</code> statement, you should write the code as follows:</p>
<pre><code>if ((aNumber = 7)) {   // Very very lousy programming</code></pre>
<p>I’ve added the comment because I consider it poor programming practice to combine statements. Make one statement do one thing. For example, when you need to do an assignment and a test, do the assignment and then do the test.</p>
<h2 id="h1-501621c05-0002">The if/else Statement</h2>
<p class="BodyFirst">We use the <code>if</code>/<code>else</code> statement when we want to make some statements execute if the condition is true and other statements execute when it is false. For example, consider the following:</p>
<pre><code>if ((number % 2) == 0) {
    printf("Number is even\n);
} else {
    printf("Number is odd\n);
}</code></pre>
<p>If the value of the <code>number</code> variable has a remainder of 0 when divided by 2, this code will print a message noting that the number is even; otherwise, it will print a message noting that the number is odd.</p>
<p><span epub:type="pagebreak" title="80" id="Page_80"/>Now we come to another of C’s darker little corners: you don’t have to put curly brackets (<code>{}</code>) around a single statement after an <code>if</code> or an <code>else</code>. Consider the following code, deliberately indented incorrectly:</p>
<pre><code>if (a == 1)
    if (b == 2)
        printf("Condition orange\n");
  else
    printf("Condition pink\n");</code></pre>
<p>Which <code>if</code> does the <code>else</code> go with, the first <code>if</code> or the second <code>if</code>?</p>
<p>a.	The first <code>if</code>: <code>if (a == 1)</code></p>
<p>b.	The second <code>if</code>: <code>if (b == 2)</code></p>
<p>c.	If you don’t write code like this, you don’t have to worry about such silly questions.</p>
<p>Let’s use answer C and rewrite the code. Which <code>if</code> does the <code>else</code> go with in the following code?</p>
<pre><code>if (a == 1) {
    if (b == 2) {
        printf("Condition orange\n");
    } else {
        printf("Condition pink\n");
    }
}</code></pre>
<p>Here, you can tell it goes with the second <code>if</code>. That’s the “official” answer to the previous question too, but by writing your code clearly, you can come up with the answer without having to go through the C language standard with a fine-tooth comb.</p>
<p>It should be noted that some style guides require that you always put the body of the <code>if</code> inside curly brackets; however, this is a decision best left up to the programmer.</p>
<h2 id="h1-501621c05-0003">Looping Statements</h2>
<p class="BodyFirst">A <em>loop</em> is a programming feature that repeats some code as long as a condition is met. C has three looping statements: <code>while</code>, <code>for</code>, and <code>do/while</code>. We’ll start with <code>while</code>, since it’s the simplest, followed by <code>for</code>. We won’t get into <code>do/while</code> because it’s rarely used.</p>
<h3 id="h2-501621c05-0001">The while Loop</h3>
<p class="BodyFirst">The general form of the <code>while</code> statement is as follows:</p>
<pre><code>while (<var>condition</var>)
    <var>statement</var>;</code></pre>
<p><span epub:type="pagebreak" title="81" id="Page_81"/>Remember that <var>statement</var> can be a single C statement or a series of statements enclosed in <code>{}</code>. To see how a <code>while</code> loop can be useful, let’s write a program that tests the numbers from 1 to 10 to see which ones are even and which ones are odd, as shown in <a href="#listing5-1" id="listinganchor5-1">Listing 5-1</a>.</p>
<p class="CodeLabel"><b><em>odd.c</em></b></p>
<pre><code>/*
 * Test to see if the numbers 1 through 10 are even
 * or odd.
 *
#include &lt;stdio.h&gt;

int main()
{
    int aNumber;  // Number to test for oddness
    aNumber = 1;
    while (aNumber &lt;= 10) {
        if ((aNumber % 2) == 1) {
            printf("%d is odd\n", aNumber);
        } else {
            printf("%d is even\n", aNumber);
        }
        ++aNumber;
    }
    return (0);
}</code></pre>
<p class="CodeListingCaption"><a id="listing5-1">Listing 5-1</a>: Testing for oddness</p>
<p>In the <code>main</code> function, we declare a variable, <code>aNumber</code>, to hold the value we’ll test in our <code>while</code> loop. Then we set that variable to <code>1</code>.</p>
<p>Next, we set the <code>while</code> loop to run as long as <code>aNumber</code> is less than or equal to 10. Inside the loop (that is, inside the brackets) we use the <code>if</code>/<code>else</code> statement introduced in the previous section of this chapter to check the remainder of dividing <code>aNumber</code> by 2. This lets us know whether it’s even or odd.</p>
<p>Before we finish the loop, we add 1 to <code>aNumber</code> with <code>++aNumber;</code>. Thus, the next time the loop runs, <code>aNumber</code> will have a value of 2, and so on. Eventually, when <code>aNumber</code>’s value reaches 11, the loop ends and the program exits with the return value <code>0</code>.</p>
<p>When this program runs, the output looks like this:</p>
<pre><code>1 is odd
2 is even
3 is odd
4 is even
5 is odd
6 is even
7 is odd
8 is even
9 is odd
10 is even</code></pre>
<h3 id="h2-501621c05-0002"><span epub:type="pagebreak" title="82" id="Page_82"/>The for Loop</h3>
<p class="BodyFirst">Our <code>while</code> loop had three main components: an initialization statement (<code>aNumber = 1</code>), a test statement (checking whether <code>aNumber</code> is greater or equal to 10), and a statement to increment the variable after the loop was executed (<code>++aNumber</code>).</p>
<p>This design pattern (initialization, condition, and increment) is so common it has its own statement: the <code>for</code> statement. We write this statement as follows:</p>
<pre><code>for (<var>initialization</var>; <var>condition</var>; <var>increment</var>)</code></pre>
<p>To see how it works, let’s convert our <code>while</code> loop into a <code>for</code> loop. The following code shows the same odd-or-even program using a <code>for</code> statement:</p>
<pre><code>/*
 * Test to see if the numbers 1 through 10 are even
 * or odd.
 */
#include &lt;stdio.h&gt;

int main()
{
    int aNumber;  // Number to test for oddness
    for (aNumber = 1; aNumber &lt;= 10; ++aNumber) {
        if ((aNumber % 2) == 1) {
            printf("%d is odd\n", aNumber);
        } else {
            printf("%d is even\n", aNumber);
        }
    }
    return (0);
}</code></pre>
<p>Notice that the <code>for</code> clause includes our three statements, separated by semicolons.</p>
<p>Any one of the statements may be left out of the <code>for</code> loop. For example, we could have written our program by initializing <code>aNumber</code> before entering the loop:</p>
<pre><code>aNumber = 1;
for (; aNumber &lt;= 10; ++aNumber) {</code></pre>
<p>Alternatively, we could increment the variable’s value within the loop’s body, rather than in the <code>for</code> clause:</p>
<pre><code>for (aNumber = 1; aNumber &lt;= 10;) {
    // Oddness test
    ++aNumber;</code></pre>
<p><span epub:type="pagebreak" title="83" id="Page_83"/>If the condition is left out, however, the loop will never terminate. This is why the following statement loops forever:</p>
<pre><code>for (;;)</code></pre>
<p>We use this “for-ever” loop in our embedded programs, because the programs should never exit.</p>
<h2 id="h1-501621c05-0004">Using the Button</h2>
<p class="BodyFirst">Now that we know how to make decisions, we’ll write a program that makes a decision based on the one input source our development board has by default: a blue button. Our program will make use of the one output we know how to control: the LED. Let’s turn our development board into a tiny computerized lamp.</p>
<p>Start System Workbench for STM32 and begin a new embedded project. The <em>main.c</em> file should look like this:</p>
<pre><code>/**
  **************************************************************
  * @file    main.c
  * @author  Steve Oualline
  * @version V1.0
  * @date    11-April-2018
  * @brief   Push the button -- flash the LED
  **************************************************************
*/

#include "stm32f0xx.h"
#include "stm32f0xx_nucleo.h"

int main(void)
{
  <span class="CodeAnnotationCode" aria-label="annotation1">1</span> GPIO_InitTypeDef GPIO_LedInit; // Init. for the LED
    GPIO_InitTypeDef GPIO_ButtonInit;  // Init. for push button
    GPIO_PinState result; // The result of reading the pin

    HAL_Init();

    // LED clock initialization
  <span class="CodeAnnotationCode" aria-label="annotation2">2</span> LED2_GPIO_CLK_ENABLE();

    // Initialize LED.
  <span class="CodeAnnotationCode" aria-label="annotation3">3</span> GPIO_LedInit.Pin = LED2_PIN;
    GPIO_LedInit.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_LedInit.Pull = GPIO_PULLUP;
    GPIO_LedInit.Speed = GPIO_SPEED_FREQ_HIGH;
    HAL_GPIO_Init(LED2_GPIO_PORT, &amp;GPIO_LedInit);

    // Push button clock initialization
    USER_BUTTON_GPIO_CLK_ENABLE();

<span epub:type="pagebreak" title="84" id="Page_84"/>    /* Configure GPIO pin : For button */
    GPIO_ButtonInit.Pin = USER_BUTTON_PIN;
    GPIO_ButtonInit.Mode = GPIO_MODE_INPUT;
  <span class="CodeAnnotationCode" aria-label="annotation4">4</span> GPIO_ButtonInit.Pull = GPIO_PULLDOWN;
    GPIO_ButtonInit.Speed = GPIO_SPEED_FREQ_HIGH;
    HAL_GPIO_Init(USER_BUTTON_GPIO_PORT, &amp;GPIO_ButtonInit);

    for(;;) {
        // Get the current state of the push button
        result = HAL_GPIO_ReadPin(USER_BUTTON_GPIO_PORT,
                                  USER_BUTTON_PIN);
        if (result == GPIO_PIN_SET)
            HAL_GPIO_WritePin(LED2_GPIO_PORT,
                              LED2_PIN, GPIO_PIN_SET);
        else
            HAL_GPIO_WritePin(LED2_GPIO_PORT,
                              LED2_PIN,GPIO_PIN_RESET);
    }
}</code></pre>
<p>Let’s go over this code in detail.</p>
<h3 id="h2-501621c05-0003">Initialization</h3>
<p class="BodyFirst">To begin our program, we’ll make use of a lot of code that is defined by the hardware abstraction layer (HAL). In the next few chapters, you’ll learn about every one of these pieces.</p>
<p>First, we define a new variable named <code>GPIO_LedInit</code> of type <code>GPIO_InitTypeDef</code> <span class="CodeAnnotation" aria-label="annotation1">1</span>. The <code>GPIO_InitTypeDef</code> type is not a standard C type: it’s defined by the HAL include files brought in at the top of the program. At this point, the details of this type don’t matter. We need the variable to define how the LED pin is going to be configured. (You’ll learn about defining variable types in later chapters.)</p>
<p>Similarly, we define another variable, <code>GPIO_ButtonInit</code>, to define how the button GPIO pin is going to be configured, and a variable to hold the state of the button pin (<code>GPIO_PinState</code>).</p>
<p>Inside the <code>main</code> procedure, the first thing we do is call <code>HAL_Init</code> to set up the hardware, as we did in the blink program from <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>. You need to call <code>HAL_Init</code> at the top of every STM32 program.</p>
<p>Next, we turn on the clock for <code>LED2</code> (the user LED) <span class="CodeAnnotation" aria-label="annotation2">2</span>. The <em>clock</em> controls how the data we write to the GPIO pin gets to the actual pin. Without this line, writing to the LED doesn’t work. Although it looks like a procedure call to a function named <code>LED2_GPIO_CLK_ENABLE</code>, it’s actually a preprocessor macro, which we will study later.</p>
<p>Now we come to the part where we assign values to the <code>GPIO_LedInit</code> variable <span class="CodeAnnotation" aria-label="annotation3">3</span>, which is a structure type that has a bunch of pieces we need to assign individually. Later, you will learn the details of what’s going on here.</p>
<p>Similar code initializes the pin used for the button, except that the pin mode is set to <code>GPIO_MODE_INPUT</code> because we’ll be reading the pin to get the state of the button, not writing it.</p>
<h3 id="h2-501621c05-0004"><span epub:type="pagebreak" title="85" id="Page_85"/>Choosing a Pulldown Circuit</h3>
<p class="BodyFirst">Notice that we set the <code>Pull</code> field to <code>GPIO_PULLDOWN</code> <span class="CodeAnnotation" aria-label="annotation4">4</span>, not <code>GPIO_PULLUP</code>.</p>
<p>The <code>Pull</code> field tells the CPU what type of pullup/pulldown circuity to use. An input pin can have one of three states: floating, pullup, and pulldown. <a href="#figure5-1" id="figureanchor5-1">Figure 5-1</a> shows the circuit for a <em>floating</em> input.</p>
<figure>
<img src="image_fi/501621c05/f05001.png" alt="f05001" class=""/>
<figcaption><p><a id="figure5-1">Figure 5-1</a>: A floating circuit</p></figcaption>
</figure>
<p>When the switch SW1 is open, no voltage is applied to the <code>User_Button_Pin</code>. As such, it could be high (about 3 volts or more) or low (less than about 3 volts) or somewhere in between. It could be set by whatever stray electrical noise is floating around near it. The key here is that there is no way to know the value of this signal unless it’s actually shorted to ground or power.</p>
<p>Now let’s take a look at an input with a <em>pullup</em> circuit (see <a href="#figure5-2" id="figureanchor5-2">Figure 5-2</a>).</p>
<figure>
<img src="image_fi/501621c05/f05002.png" alt="f05002" class=""/>
<figcaption><p><a id="figure5-2">Figure 5-2</a>: A pullup circuit</p></figcaption>
</figure>
<p>When SW1 is open, voltage flows though the resistor R1, raising (or <em>pulling up</em>) the <code>User_Button_Pin</code> to VCC, or a positive level. When SW1 is closed, the pin is shorted to ground (Gnd). R1 is a very big resistor, so the current flowing through it is negligible and the voltage on the pin goes to zero.</p>
<p>A <em>pulldown</em> circuit is similar, except R1 is connected to ground, and SW1 to VCC, so the <code>User_Button_Pin</code> goes to ground (that is, it’s pulled down to zero) if SW1 is open (see <a href="#figure5-3" id="figureanchor5-3">Figure 5-3</a>).</p>
<figure>
<img src="image_fi/501621c05/f05003.png" alt="f05003" class=""/>
<figcaption><p><a id="figure5-3">Figure 5-3</a>: A pulldown circuit</p></figcaption>
</figure>
<p>On the STM32 chip, circuits are cheap and pins are expensive. Therefore, the chip’s creators wanted to get as much out of each pin as possible. For every GPIO pin, there is a pullup resistor, a pulldown resistor, and the transistors to connect these resistors, depending on how the pin may be configured. This makes things easy, as we don’t have to put these resistors on the <span epub:type="pagebreak" title="86" id="Page_86"/>board ourselves. It also makes things difficult, however, because we have to program them. <a href="#figure5-4" id="figureanchor5-4">Figure 5-4</a> shows the internal wiring of a single GPIO pin on the STM32. (Even this is a simplified version.) The key thing to note is that there are pullup (R<sub>PU</sub>) and pulldown (R<sub>PD</sub>) internal resistors that can be turned on and off.</p>
<figure>
<img src="image_fi/501621c05/f05004.png" alt="f05004" class=""/>
<figcaption><p><a id="figure5-4">Figure 5-4</a>: STM32 internal wiring for a GPIO pin</p></figcaption>
</figure>
<p>We chose to use a pulldown circuit because the other side of the button is connected to +5 V, so when the button is not pressed and the switch is open, our pulldown resistor kicks in and the GPIO pin has a value of 0. When the button is pressed, the 5 V coming from the button cause the GPIO pin to have a value of 1. (A little current will also flow through the resistor, but that amount of current is negligible.)</p>
<h3 id="h2-501621c05-0005">Getting the State of the Button</h3>
<p class="BodyFirst">Next, we reach our main loop. The <code>for</code> statement loops forever, or until we reset the machine. Inside the loop, the first statement initializes a variable called <code>result</code> of type <code>GPIO_PinState</code> (a nonstandard type defined by the HAL include files) with the result of a call to the function <code>HAL_GPIO_ReadPin</code>. <code>HAL_GPIO_ReadPin</code> reads the GPIO pin connected to the button. More specifically, it reads the 32-bit GPIO port <code>USER_BUTTON_GPIO_PORT</code> and then tests the value of the <code>USER_BUTTON_PIN</code>. (A lot of the bit manipulation we covered in the previous chapter goes on inside the <code>HAL_GPIO_ReadPin</code> function.)</p>
<p>Now we test to see if the pin is set by comparing <code>result</code> to the symbol <code>GPIO_PIN_SET</code> (a constant defined by the HAL code), and then we turn on the LED pin if the button pin is set. Otherwise, we turn off the LED pin. (The code to do this was covered in <span class="xref" itemid="xref_target_Chapter 3">Chapter 3</span>.)</p>
<h3 id="h2-501621c05-0006"><span epub:type="pagebreak" title="87" id="Page_87"/>Running the Program</h3>
<p class="BodyFirst">When we run the program, the LED turns on. Press the user button and the LED turns off. Release the button and the LED will come back on, and so on. Although a simple operation, it took a lot of learning to get us here.</p>
<p>Unfortunately, we’ve made a very complex flashlight with a button that turns the light off instead of on. The good news is that it’s computer-controlled, so we can fix it in software. I’m going to leave that for you to figure out.</p>
<h2 id="h1-501621c05-0005">Loop Control</h2>
<p class="BodyFirst">Our programming example made basic use of looping statements, but C gives you several ways of adding extra control to your loops. The two major statements that modify the loop control are <code>break</code> and <code>continue</code>.</p>
<h3 id="h2-501621c05-0007">The break Statement</h3>
<p class="BodyFirst">The <code>break</code> statement allows you to exit a loop early (that is, break out of the loop). For example, consider the following short program, which looks through an array for a key number. If the number is there, the program prints it:</p>
<pre><code>/*
 * Find the key number in an array.
 */
#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;

#define ARRAY_SIZE  7   // Size of the array to search

int main()
{
    // Array to search
    int array[ARRAY_SIZE] = {4, 5, 23, 56, 79, 0, -5};
    static const int KEY = 56; // Key to search for

    for (unsigned int index = 0; index &lt; ARRAY_SIZE; ++index) {
        if (array[index] == KEY) {
            printf("Key (%d) found at index %d\n",
                   KEY, index);
          <span class="CodeAnnotationCode" aria-label="annotation1">1</span> break;
        }
    }
    return (0);
}</code></pre>
<p>This program searches an array for a key value. Once we find the key value, we’re done. We don’t want to go through the entire rest of the loop, so to exit, we use the <code>break</code> statement <span class="CodeAnnotation" aria-label="annotation1">1</span>.</p>
<h3 id="h2-501621c05-0008"><span epub:type="pagebreak" title="88" id="Page_88"/>The continue Statement</h3>
<p class="BodyFirst">The other loop control statement, <code>continue</code>, starts execution at the top of the loop. The following program prints a list of commands, skipping those that start with a dot. When we encounter one of these, we jump to the top of the loop with the <code>continue</code> command:</p>
<pre><code>/*
 * Find the key number in an array.
 */
#include &lt;stdio.h&gt;

#define COMMAND_COUNT 5 // Number of commands

// Commands, ones beginning with . are secret
static const char commands[COMMAND_COUNT][4] = {
    "help",
    "exec",
    ".adm",
    "quit"
};
int main()
{
    // Print the help text
    for (unsigned int index = 0;
         index &lt; COMMAND_COUNT;
         ++index) {
      <span class="CodeAnnotationCode" aria-label="annotation1">1</span> if (commands[index][0] == '.') {
            // Hidden command
          <span class="CodeAnnotationCode" aria-label="annotation2">2</span> continue;
        }
        printf("%s\n", commands[index]);
    }
    return (0);
}</code></pre>
<p>The key to this program is the test to see if we have a dot command <span class="CodeAnnotation" aria-label="annotation1">1</span> and then <code>continue</code> <span class="CodeAnnotation" aria-label="annotation2">2</span> to start over (thus skipping the rest of the loop and the <code>printf</code>).</p>
<h2 id="h1-501621c05-0006">Anti-patterns</h2>
<p class="BodyFirst">While you’re learning how to use loops, you should also learn how <em>not</em> to use loops. Several programming patterns have crept into the programming industry that do more to confuse things than promote good programming, which is why they’re called <em>anti-patterns</em>. I’m going to warn you about two.</p>
<h3 id="h2-501621c05-0009"><span epub:type="pagebreak" title="89" id="Page_89"/>The Empty while Loop</h3>
<p class="BodyFirst">The first anti-pattern is the empty <code>while</code> loop. Consider the following code:</p>
<pre><code>while (GPIO_PIN_SET == HAL_GPIO_ReadPin(USER_BUTTON_GPIO_PORT, USER_BUTTON_PIN))<b>;</b>
{
    // ... do something
}</code></pre>
<p>You probably gather that this code repeats some action as long as the user button is pressed. But it doesn’t. The reason it doesn’t is that the <code>while</code> loop affects a single statement only. You might assume that the statement within the <code>while</code> loop is the one enclosed in curly brackets, but there is a statement before the brackets too. It’s a very short statement and very easy to miss, because it’s an empty statement. We can tell it’s there because there is a semicolon after the statement:</p>
<pre><code>while (GPIO_PIN_SET == HAL_GPIO_ReadPin(USER_BUTTON_GPIO_PORT, USER_BUTTON_PIN))<b>;</b>
{
    // ... do something
}</code></pre>
<p>The semicolon is easy to overlook. That’s why I had to set it in boldface. It’s also why this type of coding is considered bad. Very bad.</p>
<p>The <code>continue</code> statement comes to our rescue. We can rewrite this <code>while</code> loop as follows:</p>
<pre><code>while (GPIO_PIN_SET == HAL_GPIO_ReadPin(BTN_PORT, BTN_PIN))
    continue;
{
    // ... do something
}</code></pre>
<p>Now we can see that the <code>while</code> loop controls the <code>continue</code> statement and nothing else. The indentation and the big obvious statement tell us that.</p>
<h3 id="h2-501621c05-0010">Assignment in while</h3>
<p class="BodyFirst">The second anti-pattern is assignment in the <code>while</code> loop:</p>
<pre><code>while ((result = ReadPin(BTN_PORT, BTN_PIN)) == GPIO_PIN_SET) {
    // ... statements
}</code></pre>
<p>This statement does two things at once. First, it calls <code>ReadPin</code> and assigns the result to <code>result</code>. Second, it tests <code>result</code> to see if it is set.</p>
<p><span epub:type="pagebreak" title="90" id="Page_90"/>Programs are much easier to understand and maintain if they do small, simple things one at a time. This shortcut saves typing a couple of newlines at the cost of program clarity. It could just as easily have been written like this:</p>
<pre><code>while (1) {
    result = ReadPin(BTN_PORT, BUTTON_PIN);
    if (result != GPIO_PIN_SET)
        break;
    // ... statements
}</code></pre>
<p>Our goal should be to make our programs as simple and easy to read as possible, not as compact and clever as possible.</p>
<h2 id="h1-501621c05-0007">Summary</h2>
<p class="BodyFirst">We now have two key aspects of computing under our belt: numbers and how to make decisions based on those numbers. Single decisions can be made with the <code>if</code> statement, while the <code>while</code> and <code>for</code> statements let us make repeating decisions. The <code>break</code> and <code>continue</code> keywords give us more control over those decisions.</p>
<p>Decision statements gave us the ability to write a small program that flashes the LED at the touch of a button. Although the program is simple, we took input, processed it, and produced output, which is the basis for a huge number of embedded programs. In the next few chapters, you’ll learn how to deal with more complex data and more complex ways of processing it, all of which builds on the basics you learned here.</p>
<h2 id="h1-501621c05-0008">Programming Problems</h2>
<ol class="decimal">
<li value="1">Write a program to produce a multiplication table for the numbers from 0 × 0 to 9 × 9.</li>
<li value="2">Write a program to count the number of bits that are set in a <code>uint32_t</code> integer. For example, the number 0x0000A0 has two bits set in it.</li>
<li value="3">Write a program that flashes a pattern on the LED. Use one array of integers to control the delay for LED on and LED off. Repeat the pattern.</li>
<li value="4">Write a program that blinks the letter “H” in Morse code using the LED. When the button is pressed, it blinks “E.” If you keep pressing the button, you’ll get all of “HELLO WORLD” in Morse code.</li>
<li value="5">Write a program to compute the first 10 primes.</li>
<li value="6">Write a program to find the largest and smallest elements in a set.</li>
<li value="7">Create a program that goes through a string and prints only the vowels.</li>
</ol>
</section>
</body></html>