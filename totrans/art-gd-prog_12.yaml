- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating Simulations and Games
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/chapterart.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sketch 89: Predator-Prey Simulation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Picture rabbits and coyotes living together in their natural environment. They
    don’t get along in the traditional sense: coyotes tend to eat rabbits when they
    can. Rabbits can breed very quickly, whereas coyotes cannot. And, of course, if
    rabbits are the only prey, then if the rabbits should all perish, the coyotes
    will also, soon after. This is a predator-prey relationship, and it can be simply
    modeled when there is only one species in each group.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mathematically the predator-prey relationship is represented by a pair of differential
    equations (don’t worry, very little actual math here) that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![c12eq001](Images/c12eq001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here ![c12i001](Images/c12i001.png) represents how fast the coyote population
    is growing, and ![c12i002](Images/c12i002.png) is how fast the rabbit population
    is growing. The solution to these equations, known as the Lotka-Volterra equations,
    is not important. The program will simulate them. In these equations, the variables
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*x*: The number of rabbits (prey animals)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*y*: The number of coyotes (predator species)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'α: The rate at which the rabbit population grows, unfettered'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'β: The rate at which prey and predators meet and a rabbit dies as a result'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'γ: The rate of death of predators due to natural causes or moving away'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'δ: The rate of growth of the predator population'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The simulation will begin with specified values of the four variables α, β,
    γ, and δ, (`alpha`, `beta`, `gamma`, and `delta`) and will have known initial
    population sizes. It will then compute a new population each time `draw()` executes,
    based on the preceding equations. This is the critical code for the rabbits 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And for the coyotes 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The populations are then rendered graphically in the window. We draw each rabbit
    as a green circle someplace on the screen (position does not matter) 1, and each
    coyote is a red circle 2. We can observe the relative populations increase and
    decrease as the predator population and the prey population change. If all of
    the prey die, the predators do too; if all of the predators die, the prey grows
    without limit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 90: Flocking Behavior'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Craig Reynolds created a system he called Boids in 1986\. It was a simulation
    of the behavior of birds when in a flock, or fish in a school. A flock is a collection
    of distinct objects of the same kind. They move, and wish to end up in the same
    place. They also don’t wish to hit each other. The simulation involves knowing
    where each object is, how fast it is moving, and what direction it is traveling,
    and then updating the position of each object iteratively. Three rules make the
    objects a flock:'
  prefs: []
  type: TYPE_NORMAL
- en: Separation Objects try to maintain a small distance between themselves and their
    neighbors. During each iteration, an object moves away (if possible) from any
    neighbor nearer than a distance *d*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alignment Objects try to match velocities with nearby objects. This keeps them
    moving in a similar direction and keeps them from spreading out too much. We compute
    a local velocity as seen from the object and then add a fraction of that to the
    object’s velocity for the next iteration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cohesion An object will try to move toward the center of mass of its neighbors.
    This keeps them in a group. We find the center of mass, not including the current
    object itself, and move the object a fraction (1 percent to 3 percent) of the
    way toward that point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each position is stored as a vector (`PVector` object) that has an x and y component.
    The vector array `FlockV` stores the velocity of each object. The `draw()` function
    calls functions that move and then draw the flock. `match()` computes a new velocity,
    trying to match neighbors 2; `toCenter()` moves each object toward the center
    of mass 3; and `away()` attempts to keep the spacing between objects 4. We call
    each of the three for each object during each iteration. Each of these functions
    returns a value that we add to the object’s position 1. Objects are small circles,
    and they will follow the mouse as we move it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 91: Simulating the Aurora'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Among objects that are difficult to render on a computer, the northern lights,
    or aurora, is near the top of the list. They flicker and roll, the colors change,
    the shape changes at various speeds, and they generally have no one specific shape.
    There have been efforts to draw them with more or less success; this sketch is
    one of those attempts.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many shapes that the aurora can take, and we will only attempt to
    draw one of those in this sketch: the typical curtain type, one example of which
    appears in [Figure 91-1](#figure91-1).'
  prefs: []
  type: TYPE_NORMAL
- en: '![f091001](Images/f091001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 91-1: Red and green aurora'
  prefs: []
  type: TYPE_NORMAL
- en: 'The sketch will make the color change slowly as a function of y position. Starting
    with a red value at the bottom of the auroral curtain, the hue will increase in
    pixels above. Starting with a hue value of `h`=15, the hue increases according
    to this equation 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Thus, the hue increases at a random rate, but it always increases as the y-coordinate
    changes. At the very top of the curtain, the brightness will decrease, fading
    the color away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, notice that the aurora appears to consist of vertical strokes and is
    banded horizontally. This is accomplished in the program by changing the saturation
    of the pixels periodically as a function of the x-coordinate 1. This is the code,
    where `i` is the horizontal position and `s` is the saturation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`i%3` is the remainder when `i` is divided by 3, so there is a somewhat random
    variation in the saturation, giving darker bands.'
  prefs: []
  type: TYPE_NORMAL
- en: The curtain effect is accomplished using a sine function to locate the pixels
    vertically. For a basic coordinate (`i`, `j`) the actual pixel will be at `(i,j-bb*sin(a*i))`,
    where the parameters `a` and `bb` change by a small and random amount during each
    iteration 3. This makes the curtain move.
  prefs: []
  type: TYPE_NORMAL
- en: The visual effect is enhanced using a pair of images. An image of stars is used
    as a background, mimicking the night sky. We draw the aurora over this, followed
    by a foreground image of trees and shrubs. This image is a stencil, with black
    objects on a transparent background. The result is a pleasing interpretation of
    the aurora, although it is far from perfect, and much work could be done to improve
    the realism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 92: A Dynamic Advertisement'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On video screens all over the world, we see public advertising. In airports,
    shopping malls, and even schools, promotional material of all kinds is presented
    to a captive audience. Video is a convenient medium, since the price of large
    plasma and LCD screens has dropped below $10 per inch. Video is a more dynamic
    medium as well, allowing ads that move and multiple presentations in sequence,
    something that printed posters and billboards can’t do.
  prefs: []
  type: TYPE_NORMAL
- en: The technology connected with video ads is well known too (Biteable Ad Maker,
    InVideo, even Adobe Premiere), and it’s available on the computer desktop. This
    sketch is one example of a simple advertisement—for a Tex-Mex restaurant. It is
    loosely based on a collection of actual video presentations seen in airports in
    North America.
  prefs: []
  type: TYPE_NORMAL
- en: 'First we need a good image of the subject (the product): a burrito. The image
    used here is publicly available ([https://commons.wikimedia.org/wiki/File:Carne-asada-burrito.jpg](https://commons.wikimedia.org/wiki/File:Carne-asada-burrito.jpg)),
    but in general such images are professional photographs taken at high resolution.
    In the sketch, this image is 800×431 pixels. We reduce it to a smaller size, 770×401,
    or 30 pixels smaller in each dimension. This is so we can slowly move the image
    for a more dynamic presentation. We display the image using this statement 1,
    where `xoff` and `yoff` are pixel offsets for positioning the image before display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'These offsets change in each frame by a small amount, up to a maximum of 30
    pixels, at which time the displacement reverses direction 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The values of `dx` and `dy` are very small, 0.05 and 0.03 respectively. They
    differ in value so that the image appears to move in a vaguely elliptical manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The text is displayed over the image in a fixed position, reinforcing the motion
    of the image. The text at the bottom remains the same throughout, but the text
    at the top changes. The implementation has two stages: if the variable `stage
    = 0`, we display the first text string (“It takes us hours to make it”) 3. After
    850 frames (about 28 seconds) have passed, we increment the variable `stage`,
    and as a result we display the second string (“It takes you five minutes to eat
    it”) 4. After 900 more frames, `stage` becomes 1 again and the cycle repeats.'
  prefs: []
  type: TYPE_NORMAL
- en: We could allow an arbitrary number of stages to allow for the presentation of
    multiple distinct messages and images, and in a random sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 93: Nim'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Nim is a game so old that its origins are lost to history. It was likely invented
    in China, and it is one of the oldest games known. It was also one of the first
    games to have a computer or electronic implementation and has been the frequent
    subject of assignments in computer programming classes. The game starts with three
    rows of objects, such as matches or coins, and there are a different number of
    objects in each row. A player may remove as many objects from one row as they
    choose, but they must remove at least one and must take them only from one row.
    Players take turns removing objects, and the player taking the final one is the
    winner.
  prefs: []
  type: TYPE_NORMAL
- en: This sketch will implement the game using 9, 7, and 5 coins, and it will play
    one side.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the stage for the game play involves reading an image for the object,
    in this case a penny, and drawing the correct number of them in the window. When
    the human player clicks the mouse over one of the coins, that coin and all of
    the coins to the left are removed, and the remaining ones will move left. Then
    the computer will remove some coins.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three rows 100 pixels apart, so when the player clicks the mouse,
    the row index is simply `i = (mouseY/100)-1`. The number of coins removed is the
    number of coins to the left, which in the case of the sketch is `j = (mouseX-10)/45+1`
    because of how we drew them (45 pixels apart, indented 10 from the left) 1. An
    array named `val` contains the number of coins in each row, so when the user clicks
    the mouse, this is the action 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This reduces the number of coins in row `(mouseY/100)-1` by `(mouseX-10)/45+1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then it is the computer’s turn. There is a strategy that will permit the computer
    to almost always win, as long as the user makes the first move. It involves computing
    a parity value and making a move to ensure that we maintain that parity value.
    Consider the initial state and the state after taking two coins from row 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Before** | **After** |'
  prefs: []
  type: TYPE_TB
- en: '| **Row 1** | `5 = 0 1 0 1` | `3 = 0 0 1 1` |'
  prefs: []
  type: TYPE_TB
- en: '| **Row 2** | `7 = 0 1 1 1` | `7 = 0 1 1 1` |'
  prefs: []
  type: TYPE_TB
- en: '| **Row 3** | `9 = 1 0 0 1` | `9 = 1 0 0 1` |'
  prefs: []
  type: TYPE_TB
- en: '| **Parity** | `1 0 1 1` | `1 1 0 1` |'
  prefs: []
  type: TYPE_TB
- en: 'The parity is determined by looking at each digit in the binary representation
    of the values. In each column position, the parity bit for that column is 1 if
    the number of 1 bits in the column is odd and 0 if it is even. We can calculate
    this using the exclusive OR operator, which in Processing is “`^`”, like so: `val[0]^val[1]^val[2]`
    3.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The strategy in Nim is to make a move that makes the parity value 0\. It turns
    out that this is always possible; in the preceding situation, the computer might
    remove 5 coins from row 3 giving this state:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Row 1** | `3 = 0 0 1 1` |'
  prefs: []
  type: TYPE_TB
- en: '| **Row 2** | `7 = 0 1 1 1` |'
  prefs: []
  type: TYPE_TB
- en: '| **Row 3** | `4 = 0 1 0 0` |'
  prefs: []
  type: TYPE_TB
- en: '| **Parity** | `0 0 0 0` |'
  prefs: []
  type: TYPE_TB
- en: 'This is what the sketch does after every move the player makes: computes the
    parity of all possible moves until it finds one with 0 parity 4.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 94: Pathfinding'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pathfinding amounts to finding a route from one place to another in two or three
    dimensions. Potential routes could be blocked by walls, rivers, wires, or a host
    of other obstacles. Of course, it is the *best* route that is desired, where “best”
    can be based on many factors, such as physical distance, time, or cost. In circuit
    design, we use pathfinding to create a connection between circuit elements. In
    computer games, it finds a path to get a game object from one place to another.
    This sketch will implement a basic pathfinding method in two dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: The method begins at some initial point, (*x*, *y*), and there is a destination
    or target point to be reached, (*x*[t], *y*[t]). Each neighbor (*x*[*n*], *y*[*n*])
    of (*x*, *y*) is *marked* with its distance to (*x*, *y*). Then we look at the
    neighbors of those locations (*x*[*n*], *y*[*n*]) and mark those locations with
    the distance to (*x*, *y*) by adding the distance to the neighbor (*x*[*n*], *y*[*n*])
    to the distance of (*x*[*n*], *y*[*n*]) to (*x*, *y*). We keep repeating this
    until we find ourselves at the target pixel (*x*[t], *y*[t]). Now we know the
    distance to the start pixel, and the best route can be traced backward following
    the connected locations having the smallest marked value. A neighbor must be an
    open space, not an obstacle, in order to be marked, so the route will never pass
    through obstacles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program begins by reading in an image on which obstacles appear in black
    and the background is white. The start and end positions of the path are specified
    in the program as x, y coordinates: `startx`, `starty`, and `endx`, `endy` (you
    can change these to find a different path).'
  prefs: []
  type: TYPE_NORMAL
- en: Beginning at the start coordinates, we examine the immediately neighboring pixels
    1. The neighbors of any pixel are the ones to the left, right, above, or below.
    The distance between pixels (*x*[0], *y*[0]) and (*x*[1], *y*[1]) is therefore
    |*x*[0] – *x*[1]| + |*y*[0] – *y*[1]| and is an integer. The distance between
    the start pixel and its neighbors is 1\. This way of measuring distance is called
    Manhattan distance; you could adapt the pathfinding method to use other distance
    measurements as well.
  prefs: []
  type: TYPE_NORMAL
- en: If one of the neighbors is the end of the path, the search is complete 2; otherwise
    we color the pixel a shade of cyan proportional to its distance from the start
    point. We use the red component of the RGB color as the distance, so as the red
    increases, the color gets brighter. We could instead use a separate 2D array to
    store distances, especially if floating-point distances are required, such as
    when calculating Euclidean distances.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we examine all pixels that have the red value 1 (those that are a distance
    1 from the start) in the same way, and set their neighbors to 2\. Then we set
    their neighbors to 3, and so on until we reach the end location.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, the distance to the start point is *N*. To trace a route back
    to the start, we look for a neighbor of the end location that has a value of *N*
    − 1; any one will do. Mark that location as being on the route, and look for a
    neighbor of that location that has a value of *N* − 2; mark it and repeat. At
    any moment there will be many pixels having a particular value, but only ones
    connected to the path are interesting. The path is complete when we reach the
    start location. The `drawRoute()` function searches the neighbors of the end pixel
    for a neighbor with a value of *N*, marks that pixel with a specific color, and
    then recursively finds a neighbor of that pixel, marks it, and so on 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The result is that a path is drawn on the displayed image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 95: Metaballs—A Lava Lamp'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![f095001](Images/f095001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 95-1: A lava lamp (shown in motion online: [https://en.wikipedia.org/wiki/File:Lava_lamp_(oT)_07_ies.ogv](https://en.wikipedia.org/wiki/File:Lava_lamp_(oT)_07_ies.ogv))'
  prefs: []
  type: TYPE_NORMAL
- en: This sketch represents an attempt to create a dynamic graphical simulation of
    a lava lamp, a popular item from the 1960s (see [Figure 95-1](#figure95-1)). Most
    North Americans will recognize one, because they have undergone a resurgence in
    popularity, perhaps due to an interest in retro furnishings. The lamp is a glass
    container filled with oil. There is an incandescent lamp at the bottom and some
    colored wax. When the lamp heats up, it melts the wax, and globules slowly rise
    to the top, changing shape. Cooling globules fall to the bottom, creating a dynamic
    visual effect as the smooth wax shapes interact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each blob in the lamp seems to move on its own, so we’ll use a collection of
    points with x, y coordinates that form the center of each blob, and these points
    can move about in a 2D area. We’ll create the actual blob in an interesting way:
    each one is a 3D function, and we’ll render a 2D view looking down at the part
    of the 3D blobs that have z (height) values greater than a threshold, like an
    aerial view of an island sticking out of the water ([Figure 95-2](#figure95-2)).
    These 3D functions are referred to as isosurfaces or metaballs.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f095002](Images/f095002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 95-2: How the threshold slices the 3D function'
  prefs: []
  type: TYPE_NORMAL
- en: As two metaballs get close to each other, the height of the area where they
    intersect is the sum of the two objects, and as they get nearer, this region will
    exceed the z threshold, so it will appear in the 2D rendering ([Figure 95-3](#figure95-3)).
    This creates the illusion of wax blobs interacting.
  prefs: []
  type: TYPE_NORMAL
- en: '![f095003](Images/f095003.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 95-3: How the metaballs add up to produce a blob'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a simple function for the metaball: a sphere, as defined by the
    function named `equation()` 5. It defines a pixel value at any point `x`, `y`
    with respect to a sphere `k` at some other point, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This sketch has six spheres defined by arrays `x` and `y`, and they move as
    defined by arrays `dx`and `dy`. The `setup()` function initializes the six spheres.
    The first one is quite large, does not move, and lies at the bottom of the region
    to simulate the large wax reservoir at the bottom of most lamps 1.
  prefs: []
  type: TYPE_NORMAL
- en: The `draw()` function calculates the sum of all spheres at any point in the
    drawing area 2. In many instances this will be zero, but as the balls get nearer,
    the sum increases and becomes visible if it is greater than the threshold `MINT`.
    Visible pixels will be drawn as green, and the background will be yellow. The
    balls are moved each iteration 3 and can change size randomly 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 96: A Robot Arm'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The word robot is often associated with a human-shaped mechanical device, but
    by far the most common robots are more restricted devices with a single function
    and a small range of motion. An example would be the kind of robot that welds
    joints or paints cars in factories. These frequently look like an arm, complete
    with multiple joints and some kind of tool at the end of the arm where the hand
    would be. This sketch allows a user to move a 2D simulated robot arm using key
    presses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The robot in the simulation is typical of the type described, such as the commercially
    available PUMA. It consists of three linked segments, each of which can be rotated
    at the joint, as shown in [Figure 96-1](#figure96-1). The joints are the shoulder
    (jangle1), joined by the bicep to the elbow (jangle2), joined by the forearm to
    the wrist (jangle3), which connects to the hand. The user controls the angles
    subtended by the joints using keys: jangle1 is controlled by Q and E, jangle2
    by A and D, and jangle3 by Z and C.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f096001-r](Images/f096001-r.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 96-1: Three linked segments forming a robot arm'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll represent each arm section by an image. The axis of rotation is not the
    upper-left corner or the center of the image but instead is a point in the image
    where the joint is connected to the previous one. The angle for any joint is increased
    by pressing one key and decreased by another, but because they are connected to
    each other, the rotations must be relative to the previous section. The rotations
    are computed from the shoulder down to the hand. Then the hand is drawn at the
    final rotated location (all three rotations), the forearm is drawn at the location
    previous (two rotations), and finally the bicep after its rotation. This is accomplished
    using the Processing functions `pushMatrix()` and `popMatrix()`: the shoulder
    joint is rotated and then the state pushed 1; the elbow is rotated and pushed
    2; the wrist is rotated and drawn. Then we restore the previous state, draw the
    bicep 3, and then perform one more restoration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The images that represent the arm parts must be analyzed and the results coded
    into the program as coordinates. For example, consider the elbow: this is where
    the bicep (`armA` in the code) meets the forearm (`armB` in the code). The point
    where they meet has an offset from both images by a different amount, as shown
    in [Figure 96-2](#figure96-2). For the bicep, the point of contact is (167, 37)
    as measured from its upper left. The connection to the forearm is at (31, 25)
    relative to the forearm image, which is its axis of rotation as well. So, to rotate
    the forearm, we first translate it by (−31, −25) so that it appears to rotate
    about the correct place. The forearm must be translated when drawn so that the
    connection on the bicep at (167, 37) aligns with the connection on the forearm
    at (31, 25), so the next translation is (167 − 30, −(37 − 24)), or (137, −13).
    We reverse the sign on the y-coordinate because the direction of y is reversed
    from the usual y-axis in mathematics. The coordinates of each connection point
    are obtained from the images, and if they change, the points will have to be remeasured.'
  prefs: []
  type: TYPE_NORMAL
- en: '![f096002-r](Images/f096002-r.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 96-2: The connection points between the arm segments'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 97: Lightning'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lightning moves quickly, randomly, and brightly. It would seem to be a difficult
    thing to capture in a computer graphic sense, and yet because it is in everyone’s
    experience, there are situations where it would be important to be able to draw
    lightning. This sketch is a basic attempt to do that.
  prefs: []
  type: TYPE_NORMAL
- en: As was the situation with the auroral simulation of Sketch 91, there is a history
    and literature on the subject of drawing lightning, and a lot of it is based on
    an effort to model the physical process by which lightning occurs in the real
    world. This is too complex to reproduce in a small program, but some of the fruits
    of that work can be useful. Researchers have measured the angle between a streak
    of lightning and a branch, for instance (about 16 degrees), and also the likelihood
    of a branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sketch will generate random lightning shapes as small, connected line
    segments. The length of the segment and an angle from the previous one will be
    random. A 2D array will hold the various segments for the main and branching parts.
    The main part is a sequence of line segments in the first part of the array: a
    line segment with starting point `x[0][i]` and `y[0][i]` connected to segment
    endpoint `x[0][i+1]`, `y[0][i+1]` 1. A branch will occur at random, with probability
    0.11 2, and it will occupy another row of the array, the first branch starting
    at `x[1][0]`, `y[1][0]`, the second at `x[2][0]`, `y[2][0]`, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: A branch can also terminate, with probability 0.2 3, but the main branch cannot.
    It will continue until it reaches a y value greater than 205, where it terminates
    4. A new lightning stroke will occur later, at a random time and x location 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each time `draw()` is called, a new section of each stroke is created and drawn,
    so the lightning is a dynamic display. It appears to descend from the top of the
    image down to the ground, or to the water in this case: a background image of
    a storm at sea is displayed, and the lightning appears to start in the clouds
    and strike the water.'
  prefs: []
  type: TYPE_NORMAL
- en: This scheme has some flaws. Sometimes, at random, strokes can appear in what
    a human would consider an unrealistic way. Branches can pass over each other,
    sometimes more than once. This *could* occur in real life, but it does not happen
    very often. A lightning path usually has a surrounding glow, too, and this is
    missing from the sketch. Lightning is also a source of illumination and would
    alter the ambient light in the scene. It is possible to reproduce this effect,
    but using a static image as the background makes it difficult to change the illumination.
    Finally, we add to the lightning strokes iteratively and, once they are determined
    to a specific point, do not change. Lightning paths have been seen to move along
    their length, not just at the lower end, but the effect is subtle.
  prefs: []
  type: TYPE_NORMAL
- en: The code offers chances for experimentation. We can alter the probabilities
    of the creation of a new branch or of an existing one being deleted. The length
    of each section, now random between 0 and 12, and the angle, random between −30
    and +30 degrees, can also have a significant visual impact on the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 98: The Computer Game Breakout'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The original game Breakout was designed and built in 1975 by legendary early
    builder of games Nolan Bushnell, Steve Wozniak (later of Apple fame), and Steve
    Bristow at Atari. In basic concept, it is a variation on Pong for one player,
    where the paddle is used to bounce a ball into bricks that vanish when hit. The
    original game has eight rows of rectangular bricks, with pairs of rows having
    the same color. The ball bounces off the sides and top of the game screen, and
    off a brick after it disappears, but is free to pass through the bottom. The player
    must move the paddle to hit the downward-moving ball to prevent it from disappearing.
    The player has three turns (that is, they can miss the ball three times) to clear
    the screen of bricks, and different colored bricks score a different number of
    points.
  prefs: []
  type: TYPE_NORMAL
- en: 'This sketch will implement a simplified version of the game. There are three
    rows of red bricks, all worth the same amount. There is no sound and no high score.
    The bricks are filled rectangles, 30 pixels by 15 pixels, and the ball is simply
    a small circle, 3 pixels across. A 2D array, `exists[][]`, is used to keep track
    of which bricks have been eliminated, and the brick in row `i` column `j` will
    be drawn if `exists[i][j]` is true. Drawing the bricks is therefore simple 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The ball is drawn at location `(x, y)` and is moved during each frame by an
    amount `(dx, dy)` 2. The paddle is simply a line drawn centered at `(px, py)`.
    Typing the A key moves the paddle left by 10 pixels (`px=px-10`), and typing D
    moves it right by the same amount. If the ball moves past the coordinate `py`
    (= 300) and its `x` value is between `px` − 30 and `px` + 30, then the ball changes
    y-direction (`dy=-dy`) and it appears to bounce. The ball also bounces off the
    top of the screen (`y==0`) and the sides (`x<0` or `x>width`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We test the ball against each brick for a collision during each frame; this
    is done using the absolute coordinates of each brick. If the brick at (i, j) exists,
    then these are the brick boundaries:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Dimension** | **Coordinate value** | **Boundary** | **Coordinate value**
    | **Boundary** |'
  prefs: []
  type: TYPE_TB
- en: '| X | i*30+20 | Left edge | i*30+50 | Right edge |'
  prefs: []
  type: TYPE_TB
- en: '| Y | j*15+30 | Top edge | j*15+45 | Bottom edge |'
  prefs: []
  type: TYPE_TB
- en: Simply check the ball’s coordinates against these values for every brick, and
    bounce if the ball is inside the brick 3, at the same time setting `exists[i][j]`
    to `false` and increasing the `score`.
  prefs: []
  type: TYPE_NORMAL
- en: After the ball falls past the bottom, we decrement `life` and the ball is redrawn
    at a random `x` location at `y` value 150\. The game is over when either the value
    of `life` is 0 or the `score` is the maximum of 36.
  prefs: []
  type: TYPE_NORMAL
- en: This simple version has flaws. The bounce off of the bricks is not dependent
    on the side of the brick that was hit; the y-direction of the ball is always changed.
    The bounce off the paddle is always the same, no matter where the point of impact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sketch 99: Midpoint Displacement—Simulating Terrain'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This sketch will generate a pseudo-random terrain profile, with a darkening
    sky and twinkling stars. The heart of this sketch is the midpoint displacement
    method for generating terrain, and while this example is only two-dimensional,
    it illustrates the more general algorithm pretty well.
  prefs: []
  type: TYPE_NORMAL
- en: The method starts with a line, which in the case of this sketch is a line that
    runs horizontally across the entire image. Next we select the midpoint of the
    line, displace it by a random value between `dy` and `–dy`, and create two lines
    as in [Figure 99-1](#figure99-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![f099001](Images/f099001.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 99-1: Splitting a line'
  prefs: []
  type: TYPE_NORMAL
- en: Then we do the same thing again with the two lines just created, except we decrease
    the value of `dy`. The result is four lines. Each time we generate a new line
    pair, the resulting segments can be split again using a smaller `dy` value until
    some termination criterion is reached. In the sketch, the initial value of `dy`
    is 75, and the splitting process ceases when it becomes smaller than 2\.
  prefs: []
  type: TYPE_NORMAL
- en: 'The splitting process is accomplished by a recursive procedure, `md()` 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, (`x0`, `y0`) and (`x1`, `y1`) are the line segment endpoints, and `dy`
    is the maximum value of the random height change. This procedure finds the midpoint
    and calls itself twice, passing the left and right halves of the line and a smaller
    `dy`. The process continues as illustrated in [Figure 99-2](#figure99-2) until
    we reach the minimum `dy` value.
  prefs: []
  type: TYPE_NORMAL
- en: The line endpoints are then saved in an array pair, `lx[]` and `ly[]`. We don’t
    actually draw the line segments but make a filled region by drawing a line from
    each endpoint down to the bottom of the window that is as thick as half of the
    line segment x width 3. The result is a horizon line with a convincing random
    nature.
  prefs: []
  type: TYPE_NORMAL
- en: '![f099002](Images/f099002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 99-2: Multiple recursive splits create a realistic horizon.'
  prefs: []
  type: TYPE_NORMAL
- en: The sky is a set of horizontal lines starting at a color of (50, 50, 240) and
    decreasing by 1 in the blue value for every two lines drawn 1. This produces a
    nice deep blue gradient in the sky.
  prefs: []
  type: TYPE_NORMAL
- en: The stars are simply small circles drawn in random locations, but they must
    appear in the same place during each frame, so the arrays `starx[]` and `stary[]`
    hold their locations. They don’t exactly twinkle, but we draw them with a probability
    of 99 percent so that once in a while one of the stars is not drawn during a particular
    frame 2. During any one frame it is likely that at least one star has gone dark.
    The overall effect is that of an evening sky and a rural landscape.
  prefs: []
  type: TYPE_NORMAL
