- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Creating Simulations and Games
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模拟和游戏
- en: '![](Images/chapterart.png)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/chapterart.png)'
- en: 'Sketch 89: Predator-Prey Simulation'
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图89：捕食者-猎物模拟
- en: 'Picture rabbits and coyotes living together in their natural environment. They
    don’t get along in the traditional sense: coyotes tend to eat rabbits when they
    can. Rabbits can breed very quickly, whereas coyotes cannot. And, of course, if
    rabbits are the only prey, then if the rabbits should all perish, the coyotes
    will also, soon after. This is a predator-prey relationship, and it can be simply
    modeled when there is only one species in each group.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下兔子和土狼共同生活在它们的自然环境中。它们在传统意义上并不和睦：土狼会在有机会时捕食兔子。兔子繁殖速度非常快，而土狼却不行。当然，如果兔子是唯一的猎物，那么一旦兔子全部死去，土狼也会很快灭绝。这是一种捕食者-猎物关系，当每组中只有一个物种时，它可以被简单建模。
- en: 'Mathematically the predator-prey relationship is represented by a pair of differential
    equations (don’t worry, very little actual math here) that look like this:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学角度看，捕食者-猎物关系通过一对微分方程表示（别担心，这里没有复杂的数学），其形式如下：
- en: '![c12eq001](Images/c12eq001.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![c12eq001](Images/c12eq001.png)'
- en: 'Here ![c12i001](Images/c12i001.png) represents how fast the coyote population
    is growing, and ![c12i002](Images/c12i002.png) is how fast the rabbit population
    is growing. The solution to these equations, known as the Lotka-Volterra equations,
    is not important. The program will simulate them. In these equations, the variables
    are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里![c12i001](Images/c12i001.png)表示土狼种群增长的速度，而![c12i002](Images/c12i002.png)表示兔子种群增长的速度。这些方程的解，即Lotka-Volterra方程，并不重要。程序将模拟它们。在这些方程中，变量如下：
- en: '*x*: The number of rabbits (prey animals)'
  id: totrans-8
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x*：兔子数量（猎物）'
- en: '*y*: The number of coyotes (predator species)'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*y*：土狼的数量（捕食者物种）'
- en: 'α: The rate at which the rabbit population grows, unfettered'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: α：兔子种群在不受约束的情况下增长的速率
- en: 'β: The rate at which prey and predators meet and a rabbit dies as a result'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: β：猎物和捕食者相遇的速率，以及兔子因相遇而死亡的速率
- en: 'γ: The rate of death of predators due to natural causes or moving away'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: γ：捕食者因自然原因或远离而死亡的速率
- en: 'δ: The rate of growth of the predator population'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: δ：捕食者种群增长的速率
- en: 'The simulation will begin with specified values of the four variables α, β,
    γ, and δ, (`alpha`, `beta`, `gamma`, and `delta`) and will have known initial
    population sizes. It will then compute a new population each time `draw()` executes,
    based on the preceding equations. This is the critical code for the rabbits 3:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟将从四个变量α、β、γ和δ的指定值（`alpha`、`beta`、`gamma`和`delta`）开始，并有已知的初始种群规模。然后，每次执行`draw()`时，它都会根据前述方程计算新的种群。这是兔子3的关键代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And for the coyotes 4:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 而对于土狼4的代码是：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The populations are then rendered graphically in the window. We draw each rabbit
    as a green circle someplace on the screen (position does not matter) 1, and each
    coyote is a red circle 2. We can observe the relative populations increase and
    decrease as the predator population and the prey population change. If all of
    the prey die, the predators do too; if all of the predators die, the prey grows
    without limit.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，种群数量会在窗口中以图形方式呈现。我们将每只兔子画成一个绿色圆圈，位于屏幕的某个地方（位置无关紧要）1，而每只土狼画成一个红色圆圈2。我们可以观察到，当捕食者种群和猎物种群变化时，它们的相对数量增减。如果所有猎物都死了，捕食者也会死；如果所有捕食者都死了，猎物则会无限增长。
- en: 'Sketch 90: Flocking Behavior'
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图90：群体行为
- en: 'Craig Reynolds created a system he called Boids in 1986\. It was a simulation
    of the behavior of birds when in a flock, or fish in a school. A flock is a collection
    of distinct objects of the same kind. They move, and wish to end up in the same
    place. They also don’t wish to hit each other. The simulation involves knowing
    where each object is, how fast it is moving, and what direction it is traveling,
    and then updating the position of each object iteratively. Three rules make the
    objects a flock:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 克雷格·雷诺兹（Craig Reynolds）在1986年创建了一个名为Boids的系统。它是模拟鸟群飞行或鱼群游动时的行为。鸟群是同类物体的集合，它们会一起移动，并希望最终停在同一地方。它们也不希望相互碰撞。这个模拟需要知道每个物体的位置、速度和运动方向，然后迭代地更新每个物体的位置。三条规则使得这些物体形成一个鸟群：
- en: Separation Objects try to maintain a small distance between themselves and their
    neighbors. During each iteration, an object moves away (if possible) from any
    neighbor nearer than a distance *d*.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分离对象尝试保持与邻居之间的距离尽可能小。在每次迭代中，若某个对象与邻居的距离小于*d*，它将尽可能远离该邻居。
- en: Alignment Objects try to match velocities with nearby objects. This keeps them
    moving in a similar direction and keeps them from spreading out too much. We compute
    a local velocity as seen from the object and then add a fraction of that to the
    object’s velocity for the next iteration.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对齐力：物体会尝试与附近的物体匹配速度，这样它们会朝相似的方向移动，并防止它们之间的间距过大。我们计算一个局部速度，视角为物体自身，然后将这个速度的一部分添加到物体的速度中，以便下一次迭代使用。
- en: Cohesion An object will try to move toward the center of mass of its neighbors.
    This keeps them in a group. We find the center of mass, not including the current
    object itself, and move the object a fraction (1 percent to 3 percent) of the
    way toward that point.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 聚合力：物体会尝试朝着邻居的质心移动，这样它们会保持在一起。我们找到质心（不包括当前物体本身），然后将物体移动一小部分（1%到3%）朝向那个点。
- en: Each position is stored as a vector (`PVector` object) that has an x and y component.
    The vector array `FlockV` stores the velocity of each object. The `draw()` function
    calls functions that move and then draw the flock. `match()` computes a new velocity,
    trying to match neighbors 2; `toCenter()` moves each object toward the center
    of mass 3; and `away()` attempts to keep the spacing between objects 4. We call
    each of the three for each object during each iteration. Each of these functions
    returns a value that we add to the object’s position 1. Objects are small circles,
    and they will follow the mouse as we move it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个位置都被存储为一个向量（`PVector`对象），该向量有x和y分量。向量数组`FlockV`存储每个物体的速度。`draw()`函数调用移动然后绘制群体的函数。`match()`计算一个新的速度，尝试匹配邻居2；`toCenter()`将每个物体朝着质心3移动；而`away()`则试图保持物体之间的间距4。在每次迭代中，我们会对每个物体调用这三个函数中的每一个。每个函数都会返回一个值，我们将其添加到物体的位置1。物体是小圆圈，当我们移动鼠标时，它们会跟随鼠标。
- en: 'Sketch 91: Simulating the Aurora'
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图91：模拟极光
- en: Among objects that are difficult to render on a computer, the northern lights,
    or aurora, is near the top of the list. They flicker and roll, the colors change,
    the shape changes at various speeds, and they generally have no one specific shape.
    There have been efforts to draw them with more or less success; this sketch is
    one of those attempts.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机上难以呈现的物体中，北极光或极光位列其中。它们闪烁并翻滚，颜色变化，形状以不同速度变化，且通常没有固定的形状。曾经有过不少努力来绘制极光，虽然成功与否不一，但这幅草图就是其中的一次尝试。
- en: 'There are many shapes that the aurora can take, and we will only attempt to
    draw one of those in this sketch: the typical curtain type, one example of which
    appears in [Figure 91-1](#figure91-1).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 极光可以呈现出多种形状，我们在这幅草图中只尝试绘制其中的一种：典型的窗帘型，类似的一个例子见于[图91-1](#figure91-1)。
- en: '![f091001](Images/f091001.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![f091001](Images/f091001.png)'
- en: 'Figure 91-1: Red and green aurora'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图91-1：红色和绿色的极光
- en: 'The sketch will make the color change slowly as a function of y position. Starting
    with a red value at the bottom of the auroral curtain, the hue will increase in
    pixels above. Starting with a hue value of `h`=15, the hue increases according
    to this equation 2:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图会使颜色随y位置变化缓慢地变化。从极光窗帘底部的红色值开始，色调会随着上方像素的增加而变换。初始色调值`h`=15，色调根据以下公式2增加：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Thus, the hue increases at a random rate, but it always increases as the y-coordinate
    changes. At the very top of the curtain, the brightness will decrease, fading
    the color away.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，色调以随机的速度增加，但它始终随着y坐标的变化而增加。在窗帘的最顶部，亮度会降低，颜色逐渐褪去。
- en: 'Next, notice that the aurora appears to consist of vertical strokes and is
    banded horizontally. This is accomplished in the program by changing the saturation
    of the pixels periodically as a function of the x-coordinate 1. This is the code,
    where `i` is the horizontal position and `s` is the saturation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，注意到极光似乎由垂直的笔触组成，并且在水平方向上呈带状。这可以通过在程序中定期改变像素的饱和度来实现，饱和度是x坐标1的函数。下面是代码，其中`i`是水平方向的位置，`s`是饱和度：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`i%3` is the remainder when `i` is divided by 3, so there is a somewhat random
    variation in the saturation, giving darker bands.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`i%3`是`i`除以3后的余数，因此饱和度会有一些随机变化，形成较暗的带状区域。'
- en: The curtain effect is accomplished using a sine function to locate the pixels
    vertically. For a basic coordinate (`i`, `j`) the actual pixel will be at `(i,j-bb*sin(a*i))`,
    where the parameters `a` and `bb` change by a small and random amount during each
    iteration 3. This makes the curtain move.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 窗帘效果通过使用正弦函数来定位像素的垂直位置实现。对于基本坐标（`i`，`j`），实际的像素位置会是`(i,j-bb*sin(a*i))`，其中参数`a`和`bb`在每次迭代中会发生微小且随机的变化3。这使得窗帘效果看起来在移动。
- en: The visual effect is enhanced using a pair of images. An image of stars is used
    as a background, mimicking the night sky. We draw the aurora over this, followed
    by a foreground image of trees and shrubs. This image is a stencil, with black
    objects on a transparent background. The result is a pleasing interpretation of
    the aurora, although it is far from perfect, and much work could be done to improve
    the realism.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 视觉效果通过一对图像得到增强。我们使用了一张星星的背景图像，模拟夜空。接着我们在其上绘制极光，然后再叠加一张前景图像，展示树木和灌木。这张图像是一个模板，黑色物体位于透明背景上。结果是对极光的一个令人愉悦的演绎，虽然远非完美，仍然有很多工作可以做来提高其现实感。
- en: 'Sketch 92: A Dynamic Advertisement'
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 92：动态广告
- en: On video screens all over the world, we see public advertising. In airports,
    shopping malls, and even schools, promotional material of all kinds is presented
    to a captive audience. Video is a convenient medium, since the price of large
    plasma and LCD screens has dropped below $10 per inch. Video is a more dynamic
    medium as well, allowing ads that move and multiple presentations in sequence,
    something that printed posters and billboards can’t do.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在全球的视频屏幕上，我们看到公共广告。在机场、购物中心，甚至学校中，各种推广材料都呈现给了被动观众。视频是一种便捷的媒介，因为大屏幕等离子和 LCD 屏幕的价格已经降到每英寸不到
    10 美元。视频也是一种更具动态感的媒介，可以展示移动的广告和连续展示的多种内容，这是印刷海报和广告牌无法做到的。
- en: The technology connected with video ads is well known too (Biteable Ad Maker,
    InVideo, even Adobe Premiere), and it’s available on the computer desktop. This
    sketch is one example of a simple advertisement—for a Tex-Mex restaurant. It is
    loosely based on a collection of actual video presentations seen in airports in
    North America.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与视频广告相关的技术也非常成熟（如 Biteable Ad Maker、InVideo，甚至 Adobe Premiere），并且这些工具可以在计算机桌面上使用。这个草图是一个简单广告的例子——为一家德州-墨西哥餐厅做的广告。它大致基于在北美机场看到的一些实际视频展示。
- en: 'First we need a good image of the subject (the product): a burrito. The image
    used here is publicly available ([https://commons.wikimedia.org/wiki/File:Carne-asada-burrito.jpg](https://commons.wikimedia.org/wiki/File:Carne-asada-burrito.jpg)),
    but in general such images are professional photographs taken at high resolution.
    In the sketch, this image is 800×431 pixels. We reduce it to a smaller size, 770×401,
    or 30 pixels smaller in each dimension. This is so we can slowly move the image
    for a more dynamic presentation. We display the image using this statement 1,
    where `xoff` and `yoff` are pixel offsets for positioning the image before display:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一张关于主题（产品）的好图：一个墨西哥卷饼。这里使用的图像是公开可用的（[https://commons.wikimedia.org/wiki/File:Carne-asada-burrito.jpg](https://commons.wikimedia.org/wiki/File:Carne-asada-burrito.jpg)），但通常这种图像是以高分辨率拍摄的专业照片。在草图中，这张图像的尺寸为
    800×431 像素。我们将其缩小为更小的尺寸，770×401，或每个维度小了 30 像素。这样做是为了让图像能够缓慢移动，呈现更具动态感的效果。我们使用语句
    1 来显示该图像，其中 `xoff` 和 `yoff` 是显示前的图像定位像素偏移量：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'These offsets change in each frame by a small amount, up to a maximum of 30
    pixels, at which time the displacement reverses direction 2:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这些偏移量在每一帧中会发生小的变化，最大变化为 30 像素，届时位移方向会发生反转 2：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The values of `dx` and `dy` are very small, 0.05 and 0.03 respectively. They
    differ in value so that the image appears to move in a vaguely elliptical manner.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`dx` 和 `dy` 的值非常小，分别为 0.05 和 0.03。它们的值不同，使得图像以模糊的椭圆形方式移动。'
- en: 'The text is displayed over the image in a fixed position, reinforcing the motion
    of the image. The text at the bottom remains the same throughout, but the text
    at the top changes. The implementation has two stages: if the variable `stage
    = 0`, we display the first text string (“It takes us hours to make it”) 3. After
    850 frames (about 28 seconds) have passed, we increment the variable `stage`,
    and as a result we display the second string (“It takes you five minutes to eat
    it”) 4. After 900 more frames, `stage` becomes 1 again and the cycle repeats.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 文字显示在图像上一个固定的位置，增强了图像的运动感。底部的文字保持不变，而顶部的文字会变化。实现分为两个阶段：如果变量 `stage = 0`，我们显示第一段文字（“我们花了几个小时制作它”）3。在
    850 帧（约 28 秒）后，变量 `stage` 增加，因此我们显示第二段文字（“你花五分钟就能吃掉它”）4。再过 900 帧后，`stage` 重新变为
    1，循环重复。
- en: We could allow an arbitrary number of stages to allow for the presentation of
    multiple distinct messages and images, and in a random sequence.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以允许任意数量的阶段，以便展示多个不同的消息和图像，并且以随机顺序播放。
- en: 'Sketch 93: Nim'
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图 93：尼姆
- en: Nim is a game so old that its origins are lost to history. It was likely invented
    in China, and it is one of the oldest games known. It was also one of the first
    games to have a computer or electronic implementation and has been the frequent
    subject of assignments in computer programming classes. The game starts with three
    rows of objects, such as matches or coins, and there are a different number of
    objects in each row. A player may remove as many objects from one row as they
    choose, but they must remove at least one and must take them only from one row.
    Players take turns removing objects, and the player taking the final one is the
    winner.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Nim 是一款历史悠久的游戏，其起源已无从考证。它可能是在中国发明的，是已知最古老的游戏之一。它也是最早实现计算机或电子版本的游戏之一，且一直是计算机编程课程中的常见作业题目。游戏开始时有三行物品，如火柴或硬币，每一行的物品数量不同。玩家可以从任意一行中移除任意数量的物品，但必须至少移除一个，并且只能从一行中移除物品。玩家轮流移除物品，最后移除物品的玩家获胜。
- en: This sketch will implement the game using 9, 7, and 5 coins, and it will play
    one side.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图将使用9、7和5枚硬币实现游戏，并且它将执行一方的操作。
- en: Setting the stage for the game play involves reading an image for the object,
    in this case a penny, and drawing the correct number of them in the window. When
    the human player clicks the mouse over one of the coins, that coin and all of
    the coins to the left are removed, and the remaining ones will move left. Then
    the computer will remove some coins.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 设置游戏玩法的前提是读取对象的图像，在本例中是一个便士，并在窗口中绘制正确数量的它们。当玩家点击其中一枚硬币时，这枚硬币以及其左侧的所有硬币将被移除，剩余的硬币将向左移动。然后，计算机会移除一些硬币。
- en: 'There are three rows 100 pixels apart, so when the player clicks the mouse,
    the row index is simply `i = (mouseY/100)-1`. The number of coins removed is the
    number of coins to the left, which in the case of the sketch is `j = (mouseX-10)/45+1`
    because of how we drew them (45 pixels apart, indented 10 from the left) 1. An
    array named `val` contains the number of coins in each row, so when the user clicks
    the mouse, this is the action 2:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 三行之间相隔100像素，所以当玩家点击鼠标时，行索引就是 `i = (mouseY/100)-1`。移除的硬币数量是左侧硬币的数量，在这个草图中，`j
    = (mouseX-10)/45+1`，这是因为我们绘制时的方式（每个硬币间隔45像素，距离左侧10像素）。一个名为`val`的数组包含每一行中的硬币数量，因此当用户点击鼠标时，这就是相应的操作：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This reduces the number of coins in row `(mouseY/100)-1` by `(mouseX-10)/45+1`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将减少第`(mouseY/100)-1`行中的硬币数量，减少的数量为`(mouseX-10)/45+1`。
- en: 'Then it is the computer’s turn. There is a strategy that will permit the computer
    to almost always win, as long as the user makes the first move. It involves computing
    a parity value and making a move to ensure that we maintain that parity value.
    Consider the initial state and the state after taking two coins from row 1:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后轮到计算机的回合。有一种策略可以让计算机几乎总是获胜，只要用户先走一步。该策略涉及计算奇偶性值，并做出移动以确保维持该奇偶性值。考虑初始状态和从第1行取走两枚硬币后的状态：
- en: '|  | **Before** | **After** |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '|  | **之前** | **之后** |'
- en: '| **Row 1** | `5 = 0 1 0 1` | `3 = 0 0 1 1` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| **第1行** | `5 = 0 1 0 1` | `3 = 0 0 1 1` |'
- en: '| **Row 2** | `7 = 0 1 1 1` | `7 = 0 1 1 1` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **第2行** | `7 = 0 1 1 1` | `7 = 0 1 1 1` |'
- en: '| **Row 3** | `9 = 1 0 0 1` | `9 = 1 0 0 1` |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| **第3行** | `9 = 1 0 0 1` | `9 = 1 0 0 1` |'
- en: '| **Parity** | `1 0 1 1` | `1 1 0 1` |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| **奇偶性** | `1 0 1 1` | `1 1 0 1` |'
- en: 'The parity is determined by looking at each digit in the binary representation
    of the values. In each column position, the parity bit for that column is 1 if
    the number of 1 bits in the column is odd and 0 if it is even. We can calculate
    this using the exclusive OR operator, which in Processing is “`^`”, like so: `val[0]^val[1]^val[2]`
    3.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 奇偶性是通过查看每个值的二进制表示中的每一位来确定的。在每一列中，如果该列中1的数量为奇数，则该列的奇偶性位为1；如果为偶数，则为0。我们可以通过使用异或运算符来计算这一点，在Processing中是“`^`”，像这样：`val[0]^val[1]^val[2]`。
- en: 'The strategy in Nim is to make a move that makes the parity value 0\. It turns
    out that this is always possible; in the preceding situation, the computer might
    remove 5 coins from row 3 giving this state:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Nim 游戏中的策略是做出一个使奇偶性值为0的移动。事实证明，这始终是可能的；在前面的情况中，计算机可能从第3行移除5个硬币，得到如下状态：
- en: '| **Row 1** | `3 = 0 0 1 1` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| **第1行** | `3 = 0 0 1 1` |'
- en: '| **Row 2** | `7 = 0 1 1 1` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| **第2行** | `7 = 0 1 1 1` |'
- en: '| **Row 3** | `4 = 0 1 0 0` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| **第3行** | `4 = 0 1 0 0` |'
- en: '| **Parity** | `0 0 0 0` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **奇偶性** | `0 0 0 0` |'
- en: 'This is what the sketch does after every move the player makes: computes the
    parity of all possible moves until it finds one with 0 parity 4.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这是草图在玩家每次移动后所做的操作：计算所有可能的移动的奇偶性，直到找到一个奇偶性为0的移动。
- en: 'Sketch 94: Pathfinding'
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图94：路径寻找
- en: Pathfinding amounts to finding a route from one place to another in two or three
    dimensions. Potential routes could be blocked by walls, rivers, wires, or a host
    of other obstacles. Of course, it is the *best* route that is desired, where “best”
    can be based on many factors, such as physical distance, time, or cost. In circuit
    design, we use pathfinding to create a connection between circuit elements. In
    computer games, it finds a path to get a game object from one place to another.
    This sketch will implement a basic pathfinding method in two dimensions.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 寻路就是在二维或三维空间中找到一条从一个地方到另一个地方的路线。潜在的路径可能会被墙壁、河流、电线或其他障碍物阻挡。当然，我们希望找到*最佳*路径，“最佳”可以基于许多因素，比如物理距离、时间或成本。在电路设计中，我们使用寻路来创建电路元件之间的连接。在计算机游戏中，它用于找到将游戏对象从一个地方移动到另一个地方的路径。这个示例将实现一种二维的基本寻路方法。
- en: The method begins at some initial point, (*x*, *y*), and there is a destination
    or target point to be reached, (*x*[t], *y*[t]). Each neighbor (*x*[*n*], *y*[*n*])
    of (*x*, *y*) is *marked* with its distance to (*x*, *y*). Then we look at the
    neighbors of those locations (*x*[*n*], *y*[*n*]) and mark those locations with
    the distance to (*x*, *y*) by adding the distance to the neighbor (*x*[*n*], *y*[*n*])
    to the distance of (*x*[*n*], *y*[*n*]) to (*x*, *y*). We keep repeating this
    until we find ourselves at the target pixel (*x*[t], *y*[t]). Now we know the
    distance to the start pixel, and the best route can be traced backward following
    the connected locations having the smallest marked value. A neighbor must be an
    open space, not an obstacle, in order to be marked, so the route will never pass
    through obstacles.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法从某个初始点（*x*，*y*）开始，并有一个目标点（*x*[t]，*y*[t]）要到达。每个邻居（*x*[*n*]，*y*[*n*]）的距离被*标记*为从（*x*，*y*）到（*x*[*n*]，*y*[*n*]）的距离。然后我们查看这些位置（*x*[*n*]，*y*[*n*]）的邻居，并通过将邻居（*x*[*n*]，*y*[*n*]）到（*x*，*y*）的距离加到（*x*[*n*]，*y*[*n*]）的距离上来标记这些位置。我们不断重复这个过程，直到我们到达目标像素（*x*[t]，*y*[t]）。现在我们知道了从起始像素的距离，可以通过追溯标记值最小的连接位置来追踪最佳路径。一个邻居必须是开放空间，而不是障碍物，才能被标记，因此路径永远不会穿过障碍物。
- en: 'The program begins by reading in an image on which obstacles appear in black
    and the background is white. The start and end positions of the path are specified
    in the program as x, y coordinates: `startx`, `starty`, and `endx`, `endy` (you
    can change these to find a different path).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 程序开始时读取一张图像，图像中的障碍物为黑色，背景为白色。路径的起点和终点在程序中通过x，y坐标指定：`startx`，`starty`，和`endx`，`endy`（你可以更改这些值来找到不同的路径）。
- en: Beginning at the start coordinates, we examine the immediately neighboring pixels
    1. The neighbors of any pixel are the ones to the left, right, above, or below.
    The distance between pixels (*x*[0], *y*[0]) and (*x*[1], *y*[1]) is therefore
    |*x*[0] – *x*[1]| + |*y*[0] – *y*[1]| and is an integer. The distance between
    the start pixel and its neighbors is 1\. This way of measuring distance is called
    Manhattan distance; you could adapt the pathfinding method to use other distance
    measurements as well.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从起始坐标开始，我们检查直接相邻的像素 1。任何像素的邻居是它左边、右边、上边或下边的像素。因此，像素（*x*[0]，*y*[0]）和（*x*[1]，*y*[1]）之间的距离为|*x*[0]
    – *x*[1]| + |*y*[0] – *y*[1]|，是一个整数。起始像素与其邻居之间的距离为1。这种测量距离的方式叫做曼哈顿距离；你也可以将寻路方法适配为使用其他距离度量方式。
- en: If one of the neighbors is the end of the path, the search is complete 2; otherwise
    we color the pixel a shade of cyan proportional to its distance from the start
    point. We use the red component of the RGB color as the distance, so as the red
    increases, the color gets brighter. We could instead use a separate 2D array to
    store distances, especially if floating-point distances are required, such as
    when calculating Euclidean distances.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其中一个邻居是路径的终点，则搜索完成 2；否则，我们将像素涂上与其距离起始点成比例的青色。我们使用RGB颜色中的红色分量作为距离，因此随着红色的增加，颜色会变得更亮。我们也可以使用一个单独的二维数组来存储距离，特别是当需要浮动距离时，比如计算欧几里得距离时。
- en: Next, we examine all pixels that have the red value 1 (those that are a distance
    1 from the start) in the same way, and set their neighbors to 2\. Then we set
    their neighbors to 3, and so on until we reach the end location.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们以相同的方式检查所有红色值为1的像素（那些与起始位置距离为1的像素），并将它们的邻居设置为2。然后我们将它们的邻居设置为3，以此类推，直到到达终点位置。
- en: 'At this point, the distance to the start point is *N*. To trace a route back
    to the start, we look for a neighbor of the end location that has a value of *N*
    − 1; any one will do. Mark that location as being on the route, and look for a
    neighbor of that location that has a value of *N* − 2; mark it and repeat. At
    any moment there will be many pixels having a particular value, but only ones
    connected to the path are interesting. The path is complete when we reach the
    start location. The `drawRoute()` function searches the neighbors of the end pixel
    for a neighbor with a value of *N*, marks that pixel with a specific color, and
    then recursively finds a neighbor of that pixel, marks it, and so on 3:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，距离起点的距离是*N*。为了追踪回起点的路线，我们寻找终点位置的一个邻居，邻居的值为*N* − 1；任何一个邻居都可以。将该位置标记为路径上的点，然后寻找该位置的一个邻居，邻居的值为*N*
    − 2；标记它并重复。任何时刻都会有许多像素具有特定值，但只有与路径连接的像素才是有趣的。当我们到达起点位置时，路径就完成了。`drawRoute()`函数会搜索终点像素的邻居，寻找一个值为*N*的邻居，标记该像素并递归地寻找该像素的邻居，再标记它，依此类推3：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The result is that a path is drawn on the displayed image.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是在显示的图像上绘制了一条路径。
- en: 'Sketch 95: Metaballs—A Lava Lamp'
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图95：元球—一盏熔岩灯
- en: '![f095001](Images/f095001.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![f095001](Images/f095001.png)'
- en: 'Figure 95-1: A lava lamp (shown in motion online: [https://en.wikipedia.org/wiki/File:Lava_lamp_(oT)_07_ies.ogv](https://en.wikipedia.org/wiki/File:Lava_lamp_(oT)_07_ies.ogv))'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图95-1：一盏熔岩灯（在线动态展示：[https://en.wikipedia.org/wiki/File:Lava_lamp_(oT)_07_ies.ogv](https://en.wikipedia.org/wiki/File:Lava_lamp_(oT)_07_ies.ogv)）
- en: This sketch represents an attempt to create a dynamic graphical simulation of
    a lava lamp, a popular item from the 1960s (see [Figure 95-1](#figure95-1)). Most
    North Americans will recognize one, because they have undergone a resurgence in
    popularity, perhaps due to an interest in retro furnishings. The lamp is a glass
    container filled with oil. There is an incandescent lamp at the bottom and some
    colored wax. When the lamp heats up, it melts the wax, and globules slowly rise
    to the top, changing shape. Cooling globules fall to the bottom, creating a dynamic
    visual effect as the smooth wax shapes interact.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个草图代表了尝试创建一个动态图形模拟的熔岩灯，这是1960年代的一个流行物品（见[图95-1](#figure95-1)）。大多数北美人都能认出它，因为熔岩灯已经重新流行起来，也许是因为人们对复古家具的兴趣。这个灯是一个充满油的玻璃容器。底部有一个白炽灯和一些彩色蜡。当灯加热时，蜡熔化，蜡球慢慢上升到顶部，形状发生变化。冷却的蜡球会掉到底部，创造出动态的视觉效果，因为光滑的蜡形相互作用。
- en: 'Each blob in the lamp seems to move on its own, so we’ll use a collection of
    points with x, y coordinates that form the center of each blob, and these points
    can move about in a 2D area. We’ll create the actual blob in an interesting way:
    each one is a 3D function, and we’ll render a 2D view looking down at the part
    of the 3D blobs that have z (height) values greater than a threshold, like an
    aerial view of an island sticking out of the water ([Figure 95-2](#figure95-2)).
    These 3D functions are referred to as isosurfaces or metaballs.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个蜡块在灯中似乎都在独立移动，因此我们将使用一组具有x、y坐标的点来表示每个蜡块的中心，这些点可以在2D区域中移动。我们将以有趣的方式创建实际的蜡块：每个蜡块都是一个3D函数，我们将渲染一个俯视图，看到的部分是具有大于阈值的z（高度）值的3D蜡块，就像俯瞰从水面冒出的岛屿一样（见[图95-2](#figure95-2)）。这些3D函数被称为等值面或元球。
- en: '![f095002](Images/f095002.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![f095002](Images/f095002.png)'
- en: 'Figure 95-2: How the threshold slices the 3D function'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图95-2：阈值如何切割3D函数
- en: As two metaballs get close to each other, the height of the area where they
    intersect is the sum of the two objects, and as they get nearer, this region will
    exceed the z threshold, so it will appear in the 2D rendering ([Figure 95-3](#figure95-3)).
    This creates the illusion of wax blobs interacting.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个元球接近时，它们交汇的区域的高度是两个物体的总和，随着它们靠得更近，这个区域将超过z阈值，因此会出现在2D渲染中（见[图95-3](#figure95-3)）。这就产生了蜡块相互作用的错觉。
- en: '![f095003](Images/f095003.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![f095003](Images/f095003.png)'
- en: 'Figure 95-3: How the metaballs add up to produce a blob'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图95-3：元球如何相加形成一个蜡块
- en: 'We will use a simple function for the metaball: a sphere, as defined by the
    function named `equation()` 5. It defines a pixel value at any point `x`, `y`
    with respect to a sphere `k` at some other point, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个简单的函数来表示元球：一个球体，正如通过名为`equation()`的函数定义的那样。它定义了在任意点`x`、`y`处相对于另一个点的球体`k`的像素值，如下所示：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This sketch has six spheres defined by arrays `x` and `y`, and they move as
    defined by arrays `dx`and `dy`. The `setup()` function initializes the six spheres.
    The first one is quite large, does not move, and lies at the bottom of the region
    to simulate the large wax reservoir at the bottom of most lamps 1.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例中有六个球体，由数组`x`和`y`定义，并且它们根据数组`dx`和`dy`的定义移动。`setup()`函数初始化这六个球体。第一个球体相当大，不会移动，位于区域的底部，用来模拟大多数灯具底部的大蜡油储存器1。
- en: The `draw()` function calculates the sum of all spheres at any point in the
    drawing area 2. In many instances this will be zero, but as the balls get nearer,
    the sum increases and becomes visible if it is greater than the threshold `MINT`.
    Visible pixels will be drawn as green, and the background will be yellow. The
    balls are moved each iteration 3 and can change size randomly 4.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw()`函数计算绘图区域内任何一点的所有球体的总和2。在许多情况下，这个总和为零，但随着球体逐渐靠近，总和增加，并且如果超过阈值`MINT`，则会变得可见。可见的像素会被绘制为绿色，背景会是黄色。球体每次迭代时会移动3，并且大小可以随机变化4。'
- en: 'Sketch 96: A Robot Arm'
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例96：机器人手臂
- en: The word robot is often associated with a human-shaped mechanical device, but
    by far the most common robots are more restricted devices with a single function
    and a small range of motion. An example would be the kind of robot that welds
    joints or paints cars in factories. These frequently look like an arm, complete
    with multiple joints and some kind of tool at the end of the arm where the hand
    would be. This sketch allows a user to move a 2D simulated robot arm using key
    presses.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 机器人一词通常与类人形机械装置相关联，但迄今为止，最常见的机器人通常是功能单一、运动范围较小的设备。例如，焊接接头或涂装汽车的机器人。这些机器人通常看起来像一只手臂，包含多个关节，并且在手臂的末端装有某种工具。这个示例允许用户通过按键移动一个二维仿真机器人手臂。
- en: 'The robot in the simulation is typical of the type described, such as the commercially
    available PUMA. It consists of three linked segments, each of which can be rotated
    at the joint, as shown in [Figure 96-1](#figure96-1). The joints are the shoulder
    (jangle1), joined by the bicep to the elbow (jangle2), joined by the forearm to
    the wrist (jangle3), which connects to the hand. The user controls the angles
    subtended by the joints using keys: jangle1 is controlled by Q and E, jangle2
    by A and D, and jangle3 by Z and C.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 仿真中的机器人是典型的此类机器人的代表，比如市面上可购买的PUMA机器人。它由三个连接的部分组成，每个部分都可以在关节处旋转，如[图96-1](#figure96-1)所示。关节分别是肩部（jangle1），由肱二头肌连接到肘部（jangle2），由前臂连接到手腕（jangle3），手腕再连接到手部。用户通过按键控制关节所形成的角度：jangle1由Q和E控制，jangle2由A和D控制，jangle3由Z和C控制。
- en: '![f096001-r](Images/f096001-r.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![f096001-r](Images/f096001-r.png)'
- en: 'Figure 96-1: Three linked segments forming a robot arm'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图96-1：三部分连接形成的机器人手臂
- en: 'We’ll represent each arm section by an image. The axis of rotation is not the
    upper-left corner or the center of the image but instead is a point in the image
    where the joint is connected to the previous one. The angle for any joint is increased
    by pressing one key and decreased by another, but because they are connected to
    each other, the rotations must be relative to the previous section. The rotations
    are computed from the shoulder down to the hand. Then the hand is drawn at the
    final rotated location (all three rotations), the forearm is drawn at the location
    previous (two rotations), and finally the bicep after its rotation. This is accomplished
    using the Processing functions `pushMatrix()` and `popMatrix()`: the shoulder
    joint is rotated and then the state pushed 1; the elbow is rotated and pushed
    2; the wrist is rotated and drawn. Then we restore the previous state, draw the
    bicep 3, and then perform one more restoration.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过图像表示每个手臂部分。旋转轴不是图像的左上角或中心，而是图像中关节与前一个部分连接的点。任何关节的角度可以通过按一个按键增加，通过按另一个按键减少，但由于它们是相互连接的，因此旋转必须相对于前一个部分进行计算。旋转从肩部开始，一直到手部。然后，手部会在最终旋转的位置绘制出来（所有三个旋转），前臂绘制在之前的位置（两个旋转），最后绘制旋转后的肱二头肌。这是通过使用Processing函数`pushMatrix()`和`popMatrix()`来实现的：首先旋转肩部关节，然后将状态推送1；接着旋转肘部并推送2；然后旋转手腕并绘制。接下来恢复之前的状态，绘制肱二头肌3，然后再进行一次恢复。
- en: 'The images that represent the arm parts must be analyzed and the results coded
    into the program as coordinates. For example, consider the elbow: this is where
    the bicep (`armA` in the code) meets the forearm (`armB` in the code). The point
    where they meet has an offset from both images by a different amount, as shown
    in [Figure 96-2](#figure96-2). For the bicep, the point of contact is (167, 37)
    as measured from its upper left. The connection to the forearm is at (31, 25)
    relative to the forearm image, which is its axis of rotation as well. So, to rotate
    the forearm, we first translate it by (−31, −25) so that it appears to rotate
    about the correct place. The forearm must be translated when drawn so that the
    connection on the bicep at (167, 37) aligns with the connection on the forearm
    at (31, 25), so the next translation is (167 − 30, −(37 − 24)), or (137, −13).
    We reverse the sign on the y-coordinate because the direction of y is reversed
    from the usual y-axis in mathematics. The coordinates of each connection point
    are obtained from the images, and if they change, the points will have to be remeasured.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 必须分析代表手臂部分的图像，并将结果编码到程序中作为坐标。例如，考虑肘部：这是肱二头肌（代码中的 `armA`）与前臂（代码中的 `armB`）相接触的地方。它们相接触的点分别与不同图像有不同的偏移量，如
    [图 96-2](#figure96-2) 所示。对于肱二头肌，接触点是从其左上角开始的 (167, 37)。与前臂的连接是相对于前臂图像的 (31, 25)，这也是其旋转轴。因此，为了旋转前臂，我们首先将其平移
    -31, -25，使其看起来围绕正确的位置旋转。当绘制前臂时，必须将其平移到肱二头肌上的连接点 (167, 37) 与前臂上 (31, 25) 的连接点对齐，因此下一个平移是
    (167 - 31, -(37 - 25))，即 (136, -12)。我们反转 y 坐标的符号，因为 y 的方向与数学中的通常 y 轴相反。每个连接点的坐标都来自图像，如果它们改变了，那么这些点将需要重新测量。
- en: '![f096002-r](Images/f096002-r.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![f096002-r](Images/f096002-r.png)'
- en: 'Figure 96-2: The connection points between the arm segments'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 96-2：手臂段之间的连接点
- en: 'Sketch 97: Lightning'
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sketch 97：闪电
- en: Lightning moves quickly, randomly, and brightly. It would seem to be a difficult
    thing to capture in a computer graphic sense, and yet because it is in everyone’s
    experience, there are situations where it would be important to be able to draw
    lightning. This sketch is a basic attempt to do that.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 闪电迅速、随机且明亮。从计算机图形的角度来看，捕捉它似乎是一件困难的事情，然而因为每个人都有相关经验，所以在某些情况下，能够绘制闪电是很重要的。这个 Sketch
    是对此的基本尝试。
- en: As was the situation with the auroral simulation of Sketch 91, there is a history
    and literature on the subject of drawing lightning, and a lot of it is based on
    an effort to model the physical process by which lightning occurs in the real
    world. This is too complex to reproduce in a small program, but some of the fruits
    of that work can be useful. Researchers have measured the angle between a streak
    of lightning and a branch, for instance (about 16 degrees), and also the likelihood
    of a branch.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 Sketch 91 的极光模拟中一样，关于绘制闪电的主题有其历史和文献，其中很多是基于模拟闪电在真实世界中发生的物理过程。这个过程太复杂了，无法在一个小程序中重现，但其中一些成果可能是有用的。例如，研究人员测量了闪电条与分支之间的角度（大约
    16 度），以及分支的可能性。
- en: 'This sketch will generate random lightning shapes as small, connected line
    segments. The length of the segment and an angle from the previous one will be
    random. A 2D array will hold the various segments for the main and branching parts.
    The main part is a sequence of line segments in the first part of the array: a
    line segment with starting point `x[0][i]` and `y[0][i]` connected to segment
    endpoint `x[0][i+1]`, `y[0][i+1]` 1. A branch will occur at random, with probability
    0.11 2, and it will occupy another row of the array, the first branch starting
    at `x[1][0]`, `y[1][0]`, the second at `x[2][0]`, `y[2][0]`, and so on.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Sketch 将生成随机的闪电形状，作为小的、连接的线段。每个段落的长度和与上一个段落的角度将是随机的。一个二维数组将保存主部分和分支部分的各种段落。主部分是数组的第一部分中的一系列线段：以起点
    `x[0][i]` 和 `y[0][i]` 连接到段落终点 `x[0][i+1]`, `y[0][i+1]` 1。分支将随机发生，概率为 0.11 2，并占据数组的另一行，第一个分支从
    `x[1][0]`, `y[1][0]` 开始，第二个从 `x[2][0]`, `y[2][0]` 开始，依此类推。
- en: A branch can also terminate, with probability 0.2 3, but the main branch cannot.
    It will continue until it reaches a y value greater than 205, where it terminates
    4. A new lightning stroke will occur later, at a random time and x location 2.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个分支也可能会终止，概率为 0.23，但主分支不能。它会继续直到达到大于 205 的 y 值，然后终止。新的闪电击发将在稍后的随机时间和 x 位置发生。
- en: 'Each time `draw()` is called, a new section of each stroke is created and drawn,
    so the lightning is a dynamic display. It appears to descend from the top of the
    image down to the ground, or to the water in this case: a background image of
    a storm at sea is displayed, and the lightning appears to start in the clouds
    and strike the water.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`draw()`时，都会创建并绘制每个笔画的新部分，因此闪电是一个动态展示。它似乎从图像顶部降到地面，或者在这个案例中，降到水面：显示了一个海上风暴的背景图像，闪电似乎从云层中开始并击中水面。
- en: This scheme has some flaws. Sometimes, at random, strokes can appear in what
    a human would consider an unrealistic way. Branches can pass over each other,
    sometimes more than once. This *could* occur in real life, but it does not happen
    very often. A lightning path usually has a surrounding glow, too, and this is
    missing from the sketch. Lightning is also a source of illumination and would
    alter the ambient light in the scene. It is possible to reproduce this effect,
    but using a static image as the background makes it difficult to change the illumination.
    Finally, we add to the lightning strokes iteratively and, once they are determined
    to a specific point, do not change. Lightning paths have been seen to move along
    their length, not just at the lower end, but the effect is subtle.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方案存在一些缺陷。有时，笔画会以人类认为不现实的方式随机出现。分支可能会互相交叉，有时甚至是多次交叉。*这*在现实生活中可能发生，但并不常见。闪电路径通常会有周围的光晕，但在这幅草图中缺失了这一效果。闪电也是光源，并会改变场景中的环境光。虽然有可能再现这种效果，但使用静态图像作为背景使得改变光照变得困难。最后，我们是迭代地添加闪电笔画，并且一旦它们被确定到某个特定点，就不再改变。闪电路径已被观察到沿着它们的长度移动，而不仅仅是在下端，但这一效果是微妙的。
- en: The code offers chances for experimentation. We can alter the probabilities
    of the creation of a new branch or of an existing one being deleted. The length
    of each section, now random between 0 and 12, and the angle, random between −30
    and +30 degrees, can also have a significant visual impact on the result.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 代码提供了实验的机会。我们可以改变新分支创建的概率，或者现有分支被删除的概率。每段的长度现在在0到12之间随机，角度也在−30到+30度之间随机，这些变化会对结果产生显著的视觉影响。
- en: 'Sketch 98: The Computer Game Breakout'
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 草图98：计算机游戏《打砖块》
- en: The original game Breakout was designed and built in 1975 by legendary early
    builder of games Nolan Bushnell, Steve Wozniak (later of Apple fame), and Steve
    Bristow at Atari. In basic concept, it is a variation on Pong for one player,
    where the paddle is used to bounce a ball into bricks that vanish when hit. The
    original game has eight rows of rectangular bricks, with pairs of rows having
    the same color. The ball bounces off the sides and top of the game screen, and
    off a brick after it disappears, but is free to pass through the bottom. The player
    must move the paddle to hit the downward-moving ball to prevent it from disappearing.
    The player has three turns (that is, they can miss the ball three times) to clear
    the screen of bricks, and different colored bricks score a different number of
    points.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 原始的《打砖块》游戏由传奇的早期游戏开发者诺兰·布什内尔、史蒂夫·沃兹尼亚克（后来成为苹果公司名人）和史蒂夫·布里斯托在1975年于雅达利设计和构建。从基本概念上看，它是一个单人版的乒乓球变种，玩家用挡板将球弹向砖块，砖块被击中后消失。原版游戏有八排矩形砖块，每两排砖块颜色相同。球会从屏幕的左右和顶部反弹，在砖块消失后也会反弹，但可以自由穿过底部。玩家必须移动挡板以击中向下移动的球，防止它消失。玩家有三次机会（也就是可以错过三次球），以清除屏幕上的砖块，不同颜色的砖块得分不同。
- en: 'This sketch will implement a simplified version of the game. There are three
    rows of red bricks, all worth the same amount. There is no sound and no high score.
    The bricks are filled rectangles, 30 pixels by 15 pixels, and the ball is simply
    a small circle, 3 pixels across. A 2D array, `exists[][]`, is used to keep track
    of which bricks have been eliminated, and the brick in row `i` column `j` will
    be drawn if `exists[i][j]` is true. Drawing the bricks is therefore simple 1:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这幅草图将实现一个简化版本的游戏。游戏中有三排红色砖块，所有砖块的得分相同。没有声音，也没有高分。砖块是填充矩形，尺寸为30像素×15像素，球则是一个简单的小圆圈，直径3像素。一个2D数组`exists[][]`用于跟踪哪些砖块已被消除，如果`exists[i][j]`为真，那么行`i`列`j`的砖块将被绘制。因此，绘制砖块非常简单。
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The ball is drawn at location `(x, y)` and is moved during each frame by an
    amount `(dx, dy)` 2. The paddle is simply a line drawn centered at `(px, py)`.
    Typing the A key moves the paddle left by 10 pixels (`px=px-10`), and typing D
    moves it right by the same amount. If the ball moves past the coordinate `py`
    (= 300) and its `x` value is between `px` − 30 and `px` + 30, then the ball changes
    y-direction (`dy=-dy`) and it appears to bounce. The ball also bounces off the
    top of the screen (`y==0`) and the sides (`x<0` or `x>width`).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 球的位置为`(x, y)`，并在每一帧中按`(dx, dy)`的量移动。球板只是画在`(px, py)`位置的水平线。按A键可以将球板向左移动10像素（`px=px-10`），按D键可以将其向右移动相同的距离。如果球越过底部坐标`py`（=300），并且其`x`值位于`px`−30和`px`+30之间，那么球的y方向会改变（`dy=-dy`），看起来就像是反弹。球还会从屏幕顶部（`y==0`）和两侧（`x<0`或`x>width`）反弹。
- en: 'We test the ball against each brick for a collision during each frame; this
    is done using the absolute coordinates of each brick. If the brick at (i, j) exists,
    then these are the brick boundaries:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每一帧中测试球与每个砖块的碰撞；这是通过使用每个砖块的绝对坐标来完成的。如果(i, j)位置的砖块存在，则该砖块的边界为：
- en: '| **Dimension** | **Coordinate value** | **Boundary** | **Coordinate value**
    | **Boundary** |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| **维度** | **坐标值** | **边界** | **坐标值** | **边界** |'
- en: '| X | i*30+20 | Left edge | i*30+50 | Right edge |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| X | i*30+20 | 左边缘 | i*30+50 | 右边缘 |'
- en: '| Y | j*15+30 | Top edge | j*15+45 | Bottom edge |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| Y | j*15+30 | 上边缘 | j*15+45 | 下边缘 |'
- en: Simply check the ball’s coordinates against these values for every brick, and
    bounce if the ball is inside the brick 3, at the same time setting `exists[i][j]`
    to `false` and increasing the `score`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 只需检查球的位置与每个砖块的坐标值，如果球位于砖块3内，则反弹，同时将`exists[i][j]`设置为`false`，并增加`score`。
- en: After the ball falls past the bottom, we decrement `life` and the ball is redrawn
    at a random `x` location at `y` value 150\. The game is over when either the value
    of `life` is 0 or the `score` is the maximum of 36.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在球掉到底部之后，我们将`life`减一，并将球重新绘制在`y`值为150的随机`x`位置。当`life`值为0或者`score`达到最大值36时，游戏结束。
- en: This simple version has flaws. The bounce off of the bricks is not dependent
    on the side of the brick that was hit; the y-direction of the ball is always changed.
    The bounce off the paddle is always the same, no matter where the point of impact.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单版本有缺陷。砖块的反弹不依赖于击中的砖块侧面；球的y方向始终会发生变化。无论撞击点在哪里，球从球板反弹的方式总是相同的。
- en: 'Sketch 99: Midpoint Displacement—Simulating Terrain'
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例99：中点偏移法——模拟地形
- en: This sketch will generate a pseudo-random terrain profile, with a darkening
    sky and twinkling stars. The heart of this sketch is the midpoint displacement
    method for generating terrain, and while this example is only two-dimensional,
    it illustrates the more general algorithm pretty well.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例将生成一个伪随机的地形轮廓，伴随着逐渐变暗的天空和闪烁的星星。这个示例的核心是使用中点偏移方法生成地形，虽然这个例子是二维的，但它很好地展示了更一般的算法。
- en: The method starts with a line, which in the case of this sketch is a line that
    runs horizontally across the entire image. Next we select the midpoint of the
    line, displace it by a random value between `dy` and `–dy`, and create two lines
    as in [Figure 99-1](#figure99-1).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法从一条线开始，在这个示例中是整张图像的水平线。接下来，我们选择该线的中点，将其按`dy`和`–dy`之间的随机值偏移，并像[图99-1](#figure99-1)那样创建两条线。
- en: '![f099001](Images/f099001.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![f099001](Images/f099001.png)'
- en: 'Figure 99-1: Splitting a line'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图99-1：分割一条线
- en: Then we do the same thing again with the two lines just created, except we decrease
    the value of `dy`. The result is four lines. Each time we generate a new line
    pair, the resulting segments can be split again using a smaller `dy` value until
    some termination criterion is reached. In the sketch, the initial value of `dy`
    is 75, and the splitting process ceases when it becomes smaller than 2\.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们对刚创建的两条线做相同的操作，除了减少`dy`的值。结果是四条线。每次我们生成一对新线段时，生成的段可以使用更小的`dy`值再次分割，直到达到某个终止标准。在这个示例中，`dy`的初始值是75，当其小于2时，分割过程停止。
- en: 'The splitting process is accomplished by a recursive procedure, `md()` 4:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 分割过程通过递归过程`md()`完成：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, (`x0`, `y0`) and (`x1`, `y1`) are the line segment endpoints, and `dy`
    is the maximum value of the random height change. This procedure finds the midpoint
    and calls itself twice, passing the left and right halves of the line and a smaller
    `dy`. The process continues as illustrated in [Figure 99-2](#figure99-2) until
    we reach the minimum `dy` value.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，(`x0`, `y0`) 和 (`x1`, `y1`) 是线段的端点，`dy` 是随机高度变化的最大值。该过程找到中点并调用自身两次，传递线段的左右两半以及更小的
    `dy`。这个过程会继续，如[图99-2](#figure99-2)所示，直到达到最小的 `dy` 值。
- en: The line endpoints are then saved in an array pair, `lx[]` and `ly[]`. We don’t
    actually draw the line segments but make a filled region by drawing a line from
    each endpoint down to the bottom of the window that is as thick as half of the
    line segment x width 3. The result is a horizon line with a convincing random
    nature.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，线段的端点会保存在一对数组中，`lx[]` 和 `ly[]`。我们实际上并不绘制线段，而是通过从每个端点绘制一条到窗口底部的线来创建一个填充区域，这条线的宽度是线段x宽度的一半3。结果是一个具有令人信服随机特性的地平线。
- en: '![f099002](Images/f099002.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![f099002](Images/f099002.png)'
- en: 'Figure 99-2: Multiple recursive splits create a realistic horizon.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图99-2：多次递归分割创建了一个逼真的地平线。
- en: The sky is a set of horizontal lines starting at a color of (50, 50, 240) and
    decreasing by 1 in the blue value for every two lines drawn 1. This produces a
    nice deep blue gradient in the sky.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 天空是一组水平线，起始颜色为（50, 50, 240），每绘制两条线，蓝色值减少1。这在天空中产生了美丽的深蓝色渐变效果。
- en: The stars are simply small circles drawn in random locations, but they must
    appear in the same place during each frame, so the arrays `starx[]` and `stary[]`
    hold their locations. They don’t exactly twinkle, but we draw them with a probability
    of 99 percent so that once in a while one of the stars is not drawn during a particular
    frame 2. During any one frame it is likely that at least one star has gone dark.
    The overall effect is that of an evening sky and a rural landscape.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 星星只是绘制在随机位置的小圆圈，但它们必须在每一帧中出现在相同的位置，因此数组 `starx[]` 和 `stary[]` 存储了它们的位置。它们并不真正闪烁，但我们以99%的概率绘制它们，这样偶尔某颗星星在某一帧中没有被绘制出来2。在任何一帧中，至少有一颗星星是暗的。整体效果呈现出傍晚的天空和乡村景观。
