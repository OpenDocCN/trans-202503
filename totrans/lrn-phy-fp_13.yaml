- en: '12'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CREATING STAND-ALONE PROGRAMS
  prefs: []
  type: TYPE_NORMAL
- en: '![Image](Images/common.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Up to this point, we’ve used GHCi to do all of our calculations and to show
    us the results. We’ve written fairly sophisticated source code files, but we’ve
    always loaded them into GHCi to use their functions. Haskell, however, is a full-featured,
    production-ready computer language, and it’s completely capable of compiling stand-alone
    programs that don’t require any GHCi involvement. The animations in [Chapter 13](ch13.xhtml)
    and later chapters are best carried out using stand-alone programs rather than
    GHCi.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explains three different ways to make a stand-alone (executable)
    program. The most basic way uses `ghc` to produce the executable program. With
    this method, you are responsible for installing any library packages that your
    program needs. The second way uses `cabal`, which will automatically install the
    library packages your program needs, but these packages must be listed in the
    appropriate place in a configuration file. The third way uses `stack`, which does
    even more things automatically, such as installing a version of the GHC compiler
    compatible with versions of packages you request. To make a stand-alone program,
    you need to use only one of these three methods. If you are new to Haskell, you
    may find the `stack` method to be the easiest to use.
  prefs: []
  type: TYPE_NORMAL
- en: For each of the three methods, we’ll go through the steps required to produce
    an executable program (a) for a very simple program and (b) for a program that
    uses both modules we have written and modules other people have written.
  prefs: []
  type: TYPE_NORMAL
- en: Using GHC to Make a Stand-Alone Program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we use GHC directly to make a stand-alone program. We do this
    first for a very simple program called “Hello, world!” and then for a more complex
    program that imports modules.
  prefs: []
  type: TYPE_NORMAL
- en: Hello, World!
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The simplest stand-alone program people often write when learning a new language
    is called “Hello, world!” All this program does is print the words “Hello, world!”
    and exit. For many computer languages, it makes sense to learn how to write the
    “Hello, world!” program very early in the process of learning the language. However,
    in Haskell, it doesn’t make sense to learn “Hello, world!” early because the “Hello,
    world!” program is all about producing an effect, namely printing something on
    the screen, while the core of Haskell programming, and functional programming
    in general, is about pure functions that have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'The “Hello, world!” program in Haskell consists of two lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Every stand-alone program needs a function called `main`, which usually has
    type `IO ()`. We first introduced `IO ()` in [Chapter 7](ch07.xhtml) as the type
    of an impure, or effectful, function that returns no meaningful value but produces
    an effect. In general, the type `IO a` represents a value of type `a` along with
    an effect.
  prefs: []
  type: TYPE_NORMAL
- en: The `main` function needs to produce some effect; otherwise, we wouldn’t be
    able to tell that the program actually ran. The purpose of the effectful function
    `main` is to describe to the compiler what we want the computer to *do*, and the
    type `IO ()` is the perfect type for this because it represents an effect without
    a meaningful value.
  prefs: []
  type: TYPE_NORMAL
- en: The function `putStrLn` is a Prelude function that takes a string as input,
    prints it on the screen, and advances to the next line so that any further printing
    occurs there. There is also a function called `putStr`, with the same type as
    `putStrLn`, that prints a string without advancing to the next line so that further
    printing occurs directly after the printed string. The `Ln` at the end of the
    name reminds us that the function advances to the next line after printing. The
    type of `putStrLn` shows us that it takes a string as input and produces an effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Suppose we put these two lines in a source code file named *hello.hs*. If your
    operating system offers a command line, the command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: will compile the source code file *hello.hs* to produce an executable file,
    called *hello*, that you can run. On a Linux system, you can run the program *hello*
    from the command line with the command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The dot-slash in front of the program name tells the operating system to execute
    the program called *hello* that is in the current working directory. Omitting
    the dot-slash will cause the operating system to search its standard search path
    for a program called *hello*, which it may not find if the current working directory
    is not included in the search path.
  prefs: []
  type: TYPE_NORMAL
- en: A Program That Imports Modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we look at compiling a stand-alone program that uses functions from the
    `SimpleVec` module we wrote in [Chapter 10](ch10.xhtml) and functions from the
    `Graphics` `.Gnuplot.Simple` module from the `gnuplot` package. The file *SimpleVec.hs*
    containing the source code for the `SimpleVec` module is available at [https://lpfp.io](https://lpfp.io).
    [Listing 12-1](ch12.xhtml#ch12list1) shows the stand-alone program we want to
    compile.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 12-1: The stand-alone program MakeTrajectoryGraph.hs, which uses functions
    from the SimpleVec module and the Graphics.Gnuplot.Simple module*'
  prefs: []
  type: TYPE_NORMAL
- en: The program in [Listing 12-1](ch12.xhtml#ch12list1) produces a graph of the
    trajectory of a ball thrown from the top of a building 10 m above the ground with
    an initial speed of 20 m/s at an angle 3^(0∘) above horizontal. The program produces
    a file named *projectile.png* containing the graph. To do its work, this program
    imports functions such as `projectilePos`, `xComp`, `zComp`, `iHat`, and `kHat`
    from the `SimpleVec` module of [Chapter 10](ch10.xhtml). The program also uses
    the `plotPath` function from the `Graphics.Gnuplot.Simple` module. Because the
    data constructors `Title`, `XLabel`, and so on of the `Attribute` data type are
    used, we import the `Attribute` data type with its constructors by appending the
    name of the type `Attribute` with two dots enclosed in parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll assume that the code in [Listing 12-1](ch12.xhtml#ch12list1) is contained
    in a source code file called *MakeTrajectoryGraph.hs*. To use `ghc` to compile
    the program, two things must be true:'
  prefs: []
  type: TYPE_NORMAL
- en: The file *SimpleVec.hs* containing the `SimpleVec` module must be present in
    the same directory as the file *MakeTrajectoryGraph.hs* containing the main program.
    We’ll call this directory the *working directory*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The working directory must have access to the `Graphics.Gnuplot.Simple` module.
    This requires that the `gnuplot` package be installed either (a) globally, so
    it can be accessed from any directory, or (b) locally, so it can be accessed from
    the working directory. To install the `gnuplot` package globally, issue the following
    command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On my computer, this command creates or changes the file */home/ walck/.ghc/x86_64-linux-8.10.5/environments/default*
    that contains the list of globally installed Haskell packages. To install the
    `gnuplot` package locally (in the working directory), issue the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command creates or changes a file with a name such as *.ghc .environment.x86_64-linux-8.10.5*
    in the current working directory. This file contains a list of packages installed
    locally (in the current working directory). See the appendix for more information
    about installing Haskell packages.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once these two criteria are met, we compile the source code file *Make TrajectoryGraph.hs*
    into an executable program by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This command must be issued from the same working directory that contains the
    file *MakeTrajectoryGraph.hs*, the file *SimpleVec.hs*, and access to the `Graphics.Gnuplot.Simple`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the compiler cannot find the `Graphics.Gnuplot.Simple` module, you will
    see an error like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you must install the `gnuplot` package, either globally or locally,
    so it is accessible from the working directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If all goes well, the compiler will produce an executable file called *Make
    TrajectoryGraph* in the current working directory. The executable file is not
    installed in any global location, so to run the program, you’ll need to give the
    full pathname of the executable file or run it from the directory in which it
    lives by prefixing the executable filename with `./`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of using `ghc` to make your executable program is there are no
    configuration files to worry about. The disadvantage is that any modules your
    program needs, whether written by you or someone else, must be accessible from
    the directory in which your program resides. As the number of library packages
    your program depends on increases, the burden of this installation increases,
    especially because versions of packages that are acceptable to your program may
    conflict with versions that are acceptable to other programs you write or to other
    library packages you want to use. The `cabal` and `stack` tools we’ll describe
    next were designed to manage this complexity, so you don’t need to deal with it
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cabal to Make a Stand-Alone Program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We used `cabal` to install a package in the previous section. But the `cabal`
    tool can play a larger role in your Haskell ecosystem, managing the modules and
    packages your stand-alone program needs and using versions that work together,
    even if they conflict with packages used by other projects you might have. To
    get basic information about what the `cabal` tool can do, issue the command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: at your command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in using `cabal` to manage the dependencies of your project is
    to make a fresh subdirectory that will contain the source code of your stand-alone
    program as well as some files that `cabal` needs to do its work. We create a new
    directory called *Trajectory* under the current directory using the following
    command. Use a unique name for this directory because the name will be the default
    name for the executable program as well as the project generally.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We enter this new directory, and make it the working directory, by issuing the
    command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'where `cd` stands for “change directory.” Inside this fresh directory, we issue
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This creates a file called *Trajectory.cabal* and a subdirectory called *app*,
    which contains a file called *Main.hs*. Older versions of `cabal` create *Main.hs*
    in the current directory rather than in the *app* subdirectory.
  prefs: []
  type: TYPE_NORMAL
- en: Imagining that you might want to share your code with others at some point,
    `cabal` wants you to have a file called *LICENSE* that contains the terms for
    which others may use your code. The `cabal` tool may demand that you have such
    a file before it will compile your code, so be prepared to produce one. The `cabal`
    program does not care about the contents of the *LICENSE* file, only that it exists.
  prefs: []
  type: TYPE_NORMAL
- en: The file *Main.hs* is a default source code file that contains a very simple
    program. To compile it, type
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: at your command prompt while the current working directory is *Trajectory*.
    If everything goes smoothly, `cabal` will compile the code in *Main.hs*, produce
    an executable file called *Trajectory*, and make that executable file available
    globally, meaning it can be run by giving its name, *Trajectory*, rather than
    its full pathname containing the directory structure leading to the file.
  prefs: []
  type: TYPE_NORMAL
- en: We can test the executable with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: and we should get a short welcome message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to using `cabal` to produce a stand-alone program for the code in
    [Listing 12-1](ch12.xhtml#ch12list1), we take a look at the file *Trajectory.cabal*.
    This is `cabal`’s configuration file that tells it how to go about compiling source
    code into executable code for the project in the current directory. The command
    `cabal` `init` shown earlier selected default values for several options when
    it created *Trajectory.cabal*. The lines we are interested in right now look something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first line indicates that the name of the executable program will be *Trajectory*.
    This default name matches the name of the project directory; however, we could
    change it to something else if we wanted to. The second line gives the name of
    the source code file that has the function `main` in it. By default, this file
    is called *Main.hs* and is located in the *app* subdirectory of the *Trajectory*
    directory. The lines preceded by double hyphens are comments. The line beginning
    with `build-depends:` is a list of packages that the main program depends on.
    By default, the *.cabal* file includes only a dependence on the package `base`.
    The `base` package makes all of the Prelude functions and types available. The
    line beginning with `hs-source-dirs:` is a list of subdirectories that contain
    source files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To compile the code in [Listing 12-1](ch12.xhtml#ch12list1), which is contained
    in the file *Make TrajectoryGraph.hs*, we need to do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy or move the file *MakeTrajectoryGraph.hs* into the *app* sub-directory
    of the *Trajectory* directory. Then edit *Trajectory.cabal* to change the name
    of the main source code file from *Main.hs* to *MakeTrajectoryGraph.hs*. The modified
    line in *Trajectory.cabal* looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Copy or move the file *SimpleVec.hs* containing the `SimpleVec` module into
    the *app* subdirectory of the *Trajectory* directory. (This file, along with all
    the other modules in this book, is available at [https://lpfp.io](https://lpfp.io).)
    Then edit *Trajectory.cabal* to uncomment (remove the double hyphen) the `other-modules:`
    line and add the `SimpleVec` module (without the *.hs* extension).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit *Trajectory.cabal* to include `gnuplot` in the `build-depends:` line.
    This allows us to import the module `Graphics.Gnuplot.Simple` in our main program.
    With all three changes, the modified lines in *Trajectory.cabal* look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While the `base` package has bounds on the allowed versions of `base`, we have
    not given version bounds on the `gnuplot` package. The purpose of version bounds
    is to allow code that is still in development to evolve in ways that are not compatible
    with previous versions. Library package writers follow conventions stating that
    minor changes and bug fixes are indicated by small changes in the version number,
    while major changes are indicated by bigger changes in the version number. Using
    version bounds, like those with `base` just shown, is a technique designed to
    ensure you are getting the functionality you expect.
  prefs: []
  type: TYPE_NORMAL
- en: Adding `gnuplot` to the list of build dependencies causes `cabal` to install
    the `gnuplot` package, but in a way that makes it private to this project, the
    project in the *Trajectory* directory. The `gnuplot` package will not be available
    in GHCi, for example, as a result of adding it to the build dependencies for this
    project. To make `gnuplot` available in GHCi, follow the instructions in the appendix.
  prefs: []
  type: TYPE_NORMAL
- en: Now reissue
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: to recompile the program called *Trajectory*. We can test the executable with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: and the executable should create a file called *projectile.png*.
  prefs: []
  type: TYPE_NORMAL
- en: The packages, such as `gnuplot`, that `cabal` installs reside at [*https://hackage.haskell.org*](https://hackage.haskell.org).
    You can go there to search for, browse, and read documentation about any of the
    packages `cabal` can install.
  prefs: []
  type: TYPE_NORMAL
- en: Using Stack to Make a Stand-Alone Program
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `stack` tool can manage the modules and packages your stand-alone program
    needs, using versions that work together, even if they conflict with packages
    used by other projects you might have. To get basic information about what the
    `stack` tool can do, issue the command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: at your command prompt.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in using `stack` to manage the dependencies of a new project
    called *Trajectory* is to issue the command
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will make a subdirectory with the name *Trajectory*. We enter this new
    directory, and make it the current directory, by issuing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this directory, we find several files and subdirectories that `stack`
    has created for us. The most important file is *Trajectory.cabal*, which contains
    important information about how your program gets compiled. The `stack` tool is
    built on top of the `cabal` tool and uses its configuration file. The most important
    lines from *Trajectory.cabal* look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we see two stanzas: one beginning with `library` and the other beginning
    with `executable`. The `library` stanza is in charge of the names, locations,
    and dependencies of modules we have written, such as `SimpleVec`. The names of
    modules we have written that we want `stack` to manage go under the heading `exposed-modules:`,
    and they are separated by commas if there is more than one module. The default
    program that comes with a new stack project uses only one module, named `Lib`.
    Here, we do not need to use the `other-modules:` heading; we can leave it alone.
    The directories in which our modules are located go under the heading `hs-source-dirs:`.
    By default, the subdirectory *src* under the directory *Trajectory* is the location
    for modules, and we do not need to change this. We will simply copy or move our
    modules into the *src* directory that `stack` created for us. Packages that we
    have not written but upon which our modules depend, such as `gnuplot`, are listed
    under the `build-depends:` heading.'
  prefs: []
  type: TYPE_NORMAL
- en: The first line of the `executable` stanza indicates that the name of the executable
    program will be *Trajectory-exe*. This default name matches the name we gave the
    project; however, we could change it to something else if we wanted to. The heading
    `main-is:` is followed by the name of the source code file that has the function
    `main` in it. The default value is *Main.hs*. In the `executable` stanza, as in
    the `library` stanza, we do not need to use the `other` `-modules:` heading; we
    can leave it alone. The directories in which the source code for our executable
    (stand-alone) programs are located go under the heading `hs-source-dirs:`. By
    default, the subdirectory *app* under the directory *Trajectory* is the location
    for main program source code, and we do not need to change this. We will simply
    copy or move our code into the *app* directory that `stack` created for us. At
    present, the *app* subdirectory contains the *Main.hs* source code file.
  prefs: []
  type: TYPE_NORMAL
- en: The file *Main.hs* is a default source code file that contains a very simple
    program. To compile it, type
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: at your command prompt while the current working directory is *Trajectory* (the
    directory containing the *.cabal* file). If everything goes smoothly, `stack`
    will compile the code in *Main.hs*, produce an executable file called *Trajectory
    -exe*, and make that executable file available globally, so it can be run, even
    from other directories, by giving its name, *Trajectory-exe*.
  prefs: []
  type: TYPE_NORMAL
- en: We can test the executable with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: and we should see a short text string appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to using `stack` to produce a stand-alone program for the code in
    [Listing 12-1](ch12.xhtml#ch12list1), contained in the file *MakeTrajectoryGraph.hs*,
    we need to do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy or move the file *MakeTrajectoryGraph.hs* into the *app* subdirectory
    of the *Trajectory* directory. Then edit *Trajectory.cabal* to change the name
    of the main source code file from *Main.hs* to *MakeTrajectory Graph.hs*. The
    modified line in *Trajectory.cabal* looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Copy or move the file *SimpleVec.hs* containing the `SimpleVec` module into
    the *src* subdirectory of the *Trajectory* directory. This file, along with all
    the other modules in this book, is available at [https://lpfp.io](https://lpfp.io).
    Then edit *Trajectory.cabal* to include the `SimpleVec` module in the `exposed-modules:`
    field of the `library` stanza.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Edit *Trajectory.cabal* to include the `gnuplot` package under the `build`
    `-depends:` heading of the `executable` stanza. This allows us to import the module
    `Graphics.Gnuplot.Simple` in our main program. With all three changes, the modified
    lines in *Trajectory.cabal* look like this: [PRE30]'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep in mind package names, not module names, need to be included in the list
    of build dependencies. When using `stack`, accidentally substituting the module
    name `Graphics.Gnuplot.Simple` for the package name `gnuplot` gives a parse error
    with no hint of what the real trouble is.
  prefs: []
  type: TYPE_NORMAL
- en: Now reissue
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: to recompile the program called *Trajectory-exe*. We can test the executable
    with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: and the executable should create a file called *projectile.png*.
  prefs: []
  type: TYPE_NORMAL
- en: The packages, such as `gnuplot`, that `stack` installs reside at [*https://hackage.haskell.org*](https://hackage.haskell.org).
    You can go there to search for, browse, and read documentation about any of the
    packages `stack` can install.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter showed three ways to produce a stand-alone Haskell program. The
    first uses `ghc`, and you must install any needed library packages yourself. The
    second uses `cabal`, which can help manage library package dependencies. The third
    uses `stack`, which can also help manage library package dependencies. In the
    next chapter, we will put these techniques to use in making animations.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Exercise 12.1.** The print function is useful inside a stand-alone program.
    Ask GHCi for the type of print, and GHCi will tell you that print is a function
    whose input can have any type that is an instance of Show and whose output is
    IO (), meaning that it *does* something. What print does is send the value of
    its input to your screen. You can print numbers, lists, strings, and anything
    that can be shown. You can use print inside of GHCi, but it is not needed there
    because GHCi automatically prints the value of whatever you give it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a stand-alone program that prints the first 21 powers of 2, starting
    with 2⁰ and ending with 2^(20). When you run your program, the output should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
