- en: <hgroup>
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: <hgroup>
- en: 8 ENDPOINT SECURITY
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8 ENDPOINT SECURITY
- en: </hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: </hgroup>
- en: '![](../images/opener.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/opener.jpg)'
- en: If you’ve made it this far in the book, you might have concluded that writing
    security tools for macOS is a challenging venture largely because of Apple itself.
    For example, if you want to capture the memory of a remote process, you’re out
    of luck, and enumerating all persistently installed items is possible, as you
    saw in [Chapter 5](chapter5.xhtml), yet requires reverse engineering a proprietary,
    undocumented database.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经读到这本书的这一部分，你可能已经得出结论，编写 macOS 的安全工具是一项具有挑战性的任务，主要原因在于 Apple 本身。例如，如果你想捕获远程进程的内存，那么你就无能为力了，列举所有持久安装的项目是可行的，正如你在[第
    5 章](chapter5.xhtml)中看到的那样，但这需要逆向工程一个专有的、未公开的数据库。
- en: But I’m not here to bash Apple, and as this chapter will demonstrate, the company
    has responded to our pleas by releasing Endpoint Security. Introduced in macOS
    10.15 (Catalina), it’s the first Apple framework designed specifically to help
    third-party developers build advanced user-mode security tools, such as those
    focused on detecting malware.^([1](#chapter8-1)) It’s hard to overstate the importance
    and power of Endpoint Security, which is why I’m dedicating two entire chapters
    to it.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但我不是来批评 Apple 的，正如本章将要展示的那样，该公司通过发布 Endpoint Security 来回应我们的呼声。它在 macOS 10.15（Catalina）中引入，是
    Apple 首个专为帮助第三方开发者构建高级用户模式安全工具而设计的框架，例如那些专注于检测恶意软件的工具。^([1](#chapter8-1)) Endpoint
    Security 的重要性和强大功能难以言表，这也是为什么我会专门 dedicating 两章内容来讨论它。
- en: In this chapter, I’ll provide an overview of the framework and discuss how to
    use its APIs to perform actions such as monitoring file and process events. The
    next chapter will focus on more advanced topics, such as muting and authorization
    events. In [Part III](part3.xhtml), I’ll show you how to build several tools atop
    Endpoint Security.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将概述该框架，并讨论如何使用其 API 执行如监控文件和进程事件等操作。下一章将重点介绍更高级的主题，如静音和授权事件。在[第三部分](part3.xhtml)中，我将向你展示如何在
    Endpoint Security 上构建几个工具。
- en: The majority of the code snippets presented in this chapter and the next come
    directly from the *ESPlayground* project, found in the Chapter 8 folder of this
    book’s GitHub repository ([*https://<wbr>github<wbr>.com<wbr>/Objective<wbr>-see<wbr>/TAOMM*](https://github.com/Objective-see/TAOMM)).
    This project contains the code in its entirety, so if you’re looking to build
    your own Endpoint Security tools, I recommend starting there.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和下一章中展示的大多数代码片段直接来自 *ESPlayground* 项目，该项目位于本书 GitHub 仓库的第 8 章文件夹中（[*https://<wbr>github<wbr>.com<wbr>/Objective<wbr>-see<wbr>/TAOMM*](https://github.com/Objective-see/TAOMM)）。这个项目包含完整的代码，因此，如果你想构建自己的
    Endpoint Security 工具，建议从那里开始。
- en: The Endpoint Security Workflow
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Endpoint Security 工作流
- en: Endpoint Security allows you to create a program (a *client*, in Apple parlance)
    and register for (or *subscribe to*) events of interest. Whenever these events
    occur on the system, Endpoint Security will deliver a message to your program.
    It can also block the events’ execution until your tool authorizes them. For example,
    imagine you’re interested in being notified anytime a new process starts so you
    can make sure it’s not malware. Using Endpoint Security, you can specify whether
    you’d like to simply receive notifications about new processes or whether the
    system should hold off on spawning the process until you’ve examined and authorized
    it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Endpoint Security 允许你创建一个程序（在 Apple 的术语中称为*客户端*）并注册感兴趣的事件（或*订阅*事件）。每当这些事件在系统上发生时，Endpoint
    Security 会将一条消息发送给你的程序。它还可以在你的工具授权之前阻止事件的执行。例如，假设你希望在每次新进程启动时收到通知，这样你就可以确保它不是恶意软件。使用
    Endpoint Security，你可以指定是仅接收新进程的通知，还是在你检查并授权之前，系统应暂时阻止该进程的启动。
- en: Many of Objective-See’s tools use Endpoint Security in the way I’ve just described.
    For example, BlockBlock uses Endpoint Security to monitor for persistent file
    events and to block non-notarized processes and scripts. [Figure 8-1](chapter8.xhtml#fig8-1)
    shows BlockBlock stopping malware that exploited a zero-day exploit (CVE-2021-30657)
    to bypass macOS code signing and notarization checks.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Objective-See 的工具使用了我刚才描述的 Endpoint Security。例如，BlockBlock 使用 Endpoint Security
    来监控持久文件事件，并阻止非公证进程和脚本。[图 8-1](chapter8.xhtml#fig8-1) 展示了 BlockBlock 阻止利用零日漏洞（CVE-2021-30657）绕过
    macOS 代码签名和公证检查的恶意软件。
- en: To keep malicious actors from abusing Endpoint Security’s power, macOS requires
    any tools leveraging it to fulfill several requirements. Most notable is obtaining
    the coveted *com.apple.developer.endpoint-security.client* entitlement from Apple.
    In [Part III](part3.xhtml) of this book, I’ll explain exactly how to ask Apple
    for this entitlement and, once it’s granted, generate and apply a provisioning
    profile so that you can deploy your tools to other macOS systems.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止恶意行为者滥用端点安全的功能，macOS要求任何利用端点安全的工具必须满足若干要求。最显著的一项是从苹果获得*com.apple.developer.endpoint-security.client*的授权。在本书的[第三部分](part3.xhtml)中，我将详细解释如何向苹果申请此授权，并在获得授权后生成并应用配置文件，以便你可以将你的工具部署到其他macOS系统。
- en: '![](../images/Figure8-1.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/Figure8-1.jpg)'
- en: 'Figure 8-1: BlockBlock uses Endpoint Security to stop untrusted scripts and
    processes from running.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图8-1：BlockBlock使用端点安全来阻止不受信任的脚本和进程运行。
- en: For now, as noted in the book’s introduction, disabling System Integrity Protection
    (SIP) and Apple Mobile File Integrity (AMFI) will allow you to locally develop
    and test tools that leverage Endpoint Security. You’ll still have to add the client
    entitlement, but with these two macOS security mechanisms disabled, you can grant
    it to yourself. In the *ESPlayground* project, you’ll find the required Endpoint
    Security client entitlement in the *ESPlayground .entitlements* file ([Listing
    8-1](chapter8.xhtml#Lis8-1)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如本书引言所述，暂时禁用系统完整性保护（SIP）和苹果移动文件完整性（AMFI）将允许你本地开发和测试利用端点安全的工具。你仍然需要添加客户端授权，但在禁用这两个macOS安全机制后，你可以将授权授予自己。在*ESPlayground*项目中，你可以在*ESPlayground.entitlements*文件中找到所需的端点安全客户端授权（[列表8-1](chapter8.xhtml#Lis8-1)）。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Listing 8-1: Specifying the required client entitlement'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8-1：指定所需的客户端授权
- en: The Code Signing Entitlements build setting references this file, so at compile
    time, it will be added to the project’s application bundle. As such, on a system
    with SIP and AMFI disabled, subscribing to and receiving Endpoint Security events
    will succeed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 代码签名授权构建设置引用了这个文件，因此在编译时，它会被添加到项目的应用程序包中。因此，在禁用SIP和AMFI的系统上，订阅并接收端点安全事件将成功。
- en: 'If you’re designing a tool that leverages Endpoint Security, you’ll likely
    take the same four steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在设计一个利用端点安全的工具，你可能会采取相同的四个步骤：
- en: 1.  Declare events of interest.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 1.  声明感兴趣的事件。
- en: 2.  Create a new client and callback handler block.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 2.  创建一个新的客户端和回调处理块。
- en: 3.  Subscribe to events.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 3.  订阅事件。
- en: 4.  Process events delivered to the handler block.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 4.  处理传递给处理块的事件。
- en: Let’s look at each of these steps, starting with understanding events of interest.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解这些步骤，从理解感兴趣的事件开始。
- en: Events of Interest
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 感兴趣的事件
- en: 'You can find the list of Endpoint Security events in the *ESTypes.h* header
    file. If you have Xcode installed, this and other Endpoint Security header files
    should live in its SDK directory: */Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/EndpointSecurity*.
    While Apple’s official developer documentation is sometimes incomplete, the header
    files *ESClient.h*, *ESMessage.h*, *EndpointSecurity.h*, and *ESTypes.h* are extremely
    well commented, and you should consider them authoritative sources of Endpoint
    Security information.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在*ESTypes.h*头文件中找到端点安全事件的列表。如果你安装了Xcode，这个文件和其他端点安全的头文件应该位于其SDK目录下：*/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/EndpointSecurity*。虽然苹果的官方开发文档有时不完整，但头文件*ESClient.h*、*ESMessage.h*、*EndpointSecurity.h*和*ESTypes.h*都有非常详细的注释，你应该将它们视为端点安全信息的权威来源。
- en: 'Within *ESTypes.h*, you can find the list of Endpoint Security events in an
    es_event_type_t enumeration:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在*ESTypes.h*中，你可以在es_event_type_t枚举中找到端点安全事件的列表：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let’s make a few observations. First, as the comments in the header file show,
    not all events are available on all versions of macOS. For example, you’ll find
    events related to XProtect malware detection or the addition of persistence items
    beginning in macOS 13 only.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做一些观察。首先，正如头文件中的注释所示，并非所有事件都在所有版本的macOS中可用。例如，你会发现与XProtect恶意软件检测或持久性项目添加相关的事件仅从macOS
    13开始才有。
- en: Second, although this header file and Apple’s developer documentation don’t
    directly document these event types, their names should give you a general idea
    of their purposes. For example, a tool interested in passively monitoring process
    executions should subscribe to the ES_EVENT_TYPE_NOTIFY _EXEC event. Also, as
    we’ll see, each event type is tied to a corresponding event structure, such as
    an es_event_exec_t. The framework header files document these well.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，虽然这个头文件和 Apple 的开发者文档没有直接记录这些事件类型，但它们的名称应该能给你一个大致的用途概念。例如，想要被动监控进程执行的工具应该订阅
    ES_EVENT_TYPE_NOTIFY_EXEC 事件。此外，正如我们将看到的，每个事件类型都与一个相应的事件结构相关联，例如 es_event_exec_t。框架头文件对此进行了很好的记录。
- en: 'Finally, the names in the header file fall into two categories: ES_EVENT _TYPE_AUTH_*
    and ES_EVENT_TYPE_NOTIFY_*. Authorization events most often originate from kernel
    mode and enter a pending state once delivered to Endpoint Security clients, requiring
    the client to explicitly authorize or deny them. For example, to allow only notarized
    processes to run, you’d first register for ES_EVENT_TYPE_AUTH_EXEC events, then
    check each delivered event and authorize only those that represent the spawning
    of notarized processes. I’ll discuss authorization events in the next chapter.
    Notification events originate in user mode and are for events that have already
    occurred. If you’re creating passive monitoring tools, such as a process monitor,
    you’ll subscribe to these.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，头文件中的名称分为两类：ES_EVENT_TYPE_AUTH_* 和 ES_EVENT_TYPE_NOTIFY_*。授权事件通常来源于内核模式，并在交付给
    Endpoint Security 客户端后进入待处理状态，需要客户端显式授权或拒绝它们。例如，要仅允许已验证的进程运行，你需要先注册 ES_EVENT_TYPE_AUTH_EXEC
    事件，然后检查每个交付的事件，仅授权那些代表已验证进程生成的事件。我将在下一章讨论授权事件。通知事件来源于用户模式，适用于已经发生的事件。如果你在创建被动监控工具，例如进程监控工具，你将订阅这些事件。
- en: The built-in macOS utility eslogger, found in */usr/bin*, provides a way to
    easily explore the Endpoint Security subsystem, as it captures and outputs Endpoint
    Security notifications directly from the terminal. For example, say you’d like
    to build a process monitor. What Endpoint Security events should your monitor
    subscribe to in order to receive information about processes? The ES_EVENT_TYPE_NOTIFY_EXEC
    event looks promising. Let’s use macOS’s eslogger to see if we’re on the right
    track.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 macOS 工具 eslogger，位于 */usr/bin*，提供了一种轻松探索 Endpoint Security 子系统的方式，因为它直接从终端捕获并输出
    Endpoint Security 通知。例如，假设你想构建一个进程监控工具。你的监控工具应该订阅哪些 Endpoint Security 事件，以便接收有关进程的信息？ES_EVENT_TYPE_NOTIFY_EXEC
    事件看起来很有前景。让我们使用 macOS 的 eslogger 来看看我们是否在正确的方向上。
- en: 'To capture and output Endpoint Security events of interest, execute eslogger
    with *root* privileges from the terminal while specifying the name of the event.
    The tool uses short names for Endpoint Security notification events, which you
    can list via the --list-events command line option:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获并输出感兴趣的 Endpoint Security 事件，可以从终端以 *root* 权限执行 eslogger，并指定事件的名称。该工具使用简短的名称表示
    Endpoint Security 通知事件，你可以通过 --list-events 命令行选项列出这些事件：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To view ES_EVENT_TYPE_NOTIFY_EXEC events, pass exec to eslogger:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 ES_EVENT_TYPE_NOTIFY_EXEC 事件，传递 exec 给 eslogger：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once eslogger is capturing process execution events, try executing a command
    such as say with the arguments Hello World. The tool should output detailed information
    about the executed event.^([2](#chapter8-2)) Here is a snippet of this output
    (which might look slightly different on your system, depending on your version
    of macOS):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 eslogger 捕获到进程执行事件，尝试执行一个命令，比如 say，参数为 Hello World。该工具应该输出关于执行事件的详细信息。^([2](#chapter8-2))
    这是输出的一个片段（在你的系统上可能会稍有不同，具体取决于你的 macOS 版本）：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, Endpoint Security provided not only the basics, such as the
    path and process ID of the newly executed process, but also code signing information,
    arguments, the parent PID, and more. Leveraging Endpoint Security can greatly
    simplify any security tool, saving it from having to generate additional information
    about the event itself.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Endpoint Security 不仅提供了基本信息，如新执行进程的路径和进程 ID，还提供了代码签名信息、参数、父进程 PID 等更多内容。利用
    Endpoint Security 可以大大简化任何安全工具，避免其必须生成关于事件本身的额外信息。
- en: '#### Clients, Handler Blocks, and Event Handling'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 客户端、处理程序块和事件处理'
- en: Now, you may be wondering how to subscribe to events and then programmatically
    interact with the information found within them. For example, how can you extract
    the path or arguments for the process notification event ES_EVENT_TYPE_NOTIFY_EXEC?
    First, you must create an Endpoint Security client.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会想知道如何订阅事件并以编程方式与其中的信息交互。例如，如何提取进程通知事件ES_EVENT_TYPE_NOTIFY_EXEC的路径或参数？首先，你必须创建一个Endpoint
    Security客户端。
- en: 'To create a new client, processes can invoke the Endpoint Security function
    es_new_client, which accepts a callback handler block and an out pointer to an
    es_client_t that Endpoint Security will initialize with the new client. The function
    returns a result of type es_new_client_result_t set to ES_NEW_CLIENT_RESULT_SUCCESS
    if the call succeeds. It might also return one of the following failure values,
    as detailed in *ESClient.h*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的客户端，进程可以调用Endpoint Security函数es_new_client，该函数接受一个回调处理程序块和一个指向es_client_t的输出指针，Endpoint
    Security将使用新客户端来初始化它。该函数返回一个类型为es_new_client_result_t的结果，如果调用成功，则设置为ES_NEW_CLIENT_RESULT_SUCCESS。它还可能返回以下失败值之一，如*ESClient.h*中详细说明：
- en: '**ES_NEW_CLIENT_RESULT_ERR_NOT_ENTITLED** The caller doesn’t have the *com.apple.developer.endpoint-security.client*
    entitlement.'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**ES_NEW_CLIENT_RESULT_ERR_NOT_ENTITLED** 调用者没有*com.apple.developer.endpoint-security.client*的授权。'
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**ES_NEW_CLIENT_RESULT_ERR_NOT_PERMITTED** The caller isn’t permitted to connect
    to the Endpoint Security subsystem, as it lacks TCC approval from the user.'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**ES_NEW_CLIENT_RESULT_ERR_NOT_PERMITTED** 调用者没有权限连接到Endpoint Security子系统，因为它没有得到用户的TCC批准。'
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**ES_NEW_CLIENT_RESULT_ERR_NOT_PRIVILEGED** The caller isn’t running with root
    privileges.'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**ES_NEW_CLIENT_RESULT_ERR_NOT_PRIVILEGED** 调用者没有root权限。'
- en: The header file provides additional details on these errors, as well as recommendations
    on how to fix each.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 头文件提供了有关这些错误的更多细节，以及如何修复每个错误的建议。
- en: 'After you’ve subscribed to events, the framework will automatically invoke
    the callback handler block passed to the es_new_client function for each event.
    In the invocation, the framework includes a pointer to a client and an es_message_t
    structure that will contain detailed information about the delivered event. The
    *ESMessage.h* file defines this message type:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在你订阅事件后，框架会自动为每个事件调用传递给es_new_client函数的回调处理程序块。在调用中，框架会包括一个指向客户端的指针和一个包含已传递事件详细信息的es_message_t结构。*ESMessage.h*文件定义了此消息类型：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We can consult the header file for a brief description of each structure member
    (or run eslogger to view this full structure for each event), but let’s cover
    a few important members here. At the start of the structure is the version field.
    This field is useful, as certain other fields may appear only in later versions.
    For example, the process’s CPU type (image_cputype) is available only if the version
    field is of type 6 or newer. Next are various timestamps and a deadline. I’ll
    discuss the deadline in [Chapter 9](chapter9.xhtml), as it plays an important
    role when dealing with event authorizations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查阅头文件，了解每个结构成员的简要描述（或运行eslogger查看每个事件的完整结构），但这里我们先介绍几个重要成员。在结构体的开头是版本字段。这个字段非常有用，因为某些其他字段可能仅在较新版本中才会出现。例如，进程的CPU类型（image_cputype）仅在版本字段为6或更高版本时才可用。接下来是各种时间戳和一个截止时间。我将在[第9章](chapter9.xhtml)中讨论截止时间，因为它在处理事件授权时起着重要作用。
- en: The es_process_t structure describes the process responsible for taking the
    action that triggered the event. Shortly, we’ll explore es_process_t structures
    in more detail, but for now, it suffices to understand that they contain information
    about a process, including audit tokens, code signing information, paths, and
    more.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: es_process_t结构描述了负责执行触发事件的操作的进程。稍后我们将更详细地探讨es_process_t结构，但现在足以理解它们包含关于进程的信息，包括审计令牌、代码签名信息、路径等。
- en: The next member discussed is the event_type, which will be set to the type of
    event that was delivered, for example, ES_EVENT_TYPE_NOTIFY_EXEC. This is useful
    because clients usually register for multiple event types. As each event type
    contains different data, it’s important to determine which event you’re dealing
    with. For example, a process monitor might do this with a switch statement ([Listing
    8-2](chapter8.xhtml#Lis8-2)).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个讨论的成员是event_type，它将设置为已传递事件的类型，例如ES_EVENT_TYPE_NOTIFY_EXEC。这非常有用，因为客户端通常会注册多个事件类型。由于每种事件类型包含不同的数据，因此确定你正在处理的事件类型非常重要。例如，一个进程监视器可能会使用switch语句来处理这些事件类型（[Listing
    8-2](chapter8.xhtml#Lis8-2)）。
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Listing 8-2: Handling multiple message types'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-2：处理多种消息类型
- en: 'The event-type-specific data in the es_message_t structure has a type of es_events_t.
    This type is a large union of types, found in *ESMessage.h*, that map to Endpoint
    Security events. For example, in this union, we find es _event_exec_t, the event
    type for ES_EVENT_TYPE_NOTIFY_EXEC. The same header file contains the definition
    of es_event_exec_t:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: es_message_t 结构中的事件类型特定数据的类型是 es_events_t。该类型是一个大型联合体，定义在 *ESMessage.h* 中，映射到
    Endpoint Security 事件。例如，在这个联合体中，我们找到了 es_event_exec_t，这是 ES_EVENT_TYPE_NOTIFY_EXEC
    事件类型。在同一个头文件中，定义了 es_event_exec_t：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Again, consult the header file for detailed comments about each member of the
    es_event_exec_t structure. Most relevant is the member named target, a pointer
    to an es_process_t structure representing the new process that is executed. Let’s
    take a closer look at this structure to see what information it provides about
    a process:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 再次参考头文件，查看 es_event_exec_t 结构每个成员的详细注释。最相关的是名为 target 的成员，它是指向 es_process_t
    结构的指针，表示被执行的新进程。让我们更仔细地看看这个结构，看看它提供了关于进程的哪些信息：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As with other structures in the header files, comments explain the many structure
    members. Of particular interest to us are the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与头文件中的其他结构一样，注释解释了许多结构成员。特别对我们感兴趣的是以下成员：
- en: Audit tokens (such as audit_token, responsible_audit_token, and parent_audit_token)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 审计令牌（例如 audit_token、responsible_audit_token 和 parent_audit_token）
- en: Code signing information (such as signing_id and team_id)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码签名信息（例如 signing_id 和 team_id）
- en: The executable (executable)
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可执行文件（executable）
- en: In previous chapters, I discussed the usefulness of building process hierarchies
    and the challenges of creating accurate ones. The Endpoint Security subsystem
    provides us with the audit tokens of both the direct parent and responsible process
    that spawned the new process, making building an accurate process hierarchy for
    the newly spawned process a breeze. The es_process_t structure contains this information
    directly, so we’re no longer required to manually build such hierarchies.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我讨论了构建进程层级的有用性以及创建准确进程层级所面临的挑战。Endpoint Security 子系统为我们提供了直接父进程和负责创建新进程的进程的审计令牌，使得为新创建的进程构建准确的进程层级变得轻而易举。es_process_t
    结构直接包含这些信息，因此我们不再需要手动构建这样的层级。
- en: 'Let’s now talk about the executable member of the es_process_t structure, a
    pointer to an es_file_t structure. As shown in the following structure definition,
    an es_file_t structure provides the path to a file on disk, such as to a process’s
    binary:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈 es_process_t 结构的可执行成员，它是指向 es_file_t 结构的指针。如以下结构定义所示，es_file_t 结构提供了磁盘上文件的路径，例如进程的二进制文件：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To get the actual path, you must understand one more structure, es_string_token_t.
    You’ll come across it often, as it’s how Endpoint Security stores strings such
    as filepaths. This simple structure defined in *ESTypes.h* contains only two members:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取实际路径，你必须了解另一个结构，es_string_token_t。你会经常遇到它，因为它是 Endpoint Security 存储字符串（如文件路径）的方式。这个简单的结构定义在
    *ESTypes.h* 中，仅包含两个成员：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The length member of the structure is the length of the string token. A comment
    in the header file notes that it’s equivalent to the value returned by strlen.
    You shouldn’t actually use strlen on the string data, however, as the data member
    of the structure isn’t guaranteed to be NULL terminated. To print es_string_token_t
    structures as a C-string, use the %.*s format string, which expects two arguments:
    the maximum number of characters to print and then a pointer to the characters
    ([Listing 8-3](chapter8.xhtml#Lis8-3)).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 结构中的 length 成员是字符串令牌的长度。头文件中的注释指出，它等同于 strlen 返回的值。然而，你不应该对字符串数据使用 strlen，因为结构的
    data 成员不能保证是以 NULL 结尾的。要将 es_string_token_t 结构打印为 C 字符串，使用 %.*s 格式字符串，它需要两个参数：要打印的最大字符数，然后是指向字符的指针（[Listing
    8-3](chapter8.xhtml#Lis8-3)）。
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Listing 8-3: Outputting es_string_token_t structures from within es_process_t
    structures'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Listing 8-3：从 es_process_t 结构中输出 es_string_token_t 结构
- en: First, the code extracts the string token for the process responsible for triggering
    the Endpoint Security event. It then prints out the path of this process, using
    the aforementioned format string and the length and data members of the string
    token structure. Recall that when an ES_EVENT_TYPE_NOTIFY_EXEC event occurs, the
    structure describing the newly spawned process can be found in the target member
    of the exec structure (located in the message’s event structure). The code then
    accesses this structure to print out the path of the newly spawned process.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，代码提取触发 Endpoint Security 事件的进程的字符串 token。然后，使用上述格式化字符串和字符串 token 结构的长度和数据成员打印出该进程的路径。回想一下，当发生
    ES_EVENT_TYPE_NOTIFY_EXEC 事件时，描述新创建进程的结构可以在 exec 结构的 target 成员中找到（该结构位于消息的事件结构中）。接着，代码访问该结构以打印出新创建进程的路径。
- en: Now, you’ll probably want to do more than just print out information about events.
    For example, for all new processes, you might extract their paths and store them
    in an array or pass each path to a function that checks if they’re notarized.
    To achieve this, you’ll likely want to convert the string token into a more programmatically
    friendly object such as an NSString. As shown in [Listing 8-4](chapter8.xhtml#Lis8-4),
    you can do this in a single line of code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能不仅仅希望打印出有关事件的信息。例如，对于所有新进程，你可能想提取它们的路径并将其存储在数组中，或者将每个路径传递给一个函数来检查它们是否经过公证。为了实现这一点，你可能需要将字符串
    token 转换为更易于编程操作的对象，如 NSString。如[列表 8-4](chapter8.xhtml#Lis8-4)所示，你可以通过一行代码来实现这一点。
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Listing 8-4: Converting an es_string_token_t to an NSString'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-4：将 es_string_token_t 转换为 NSString
- en: 'The code makes use of the NSString initWithBytes:length:encoding: method, passing
    in the string token’s data and length members and the string encoding NSUTF8StringEncoding.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '代码使用了 NSString 的 initWithBytes:length:encoding: 方法，传入字符串 token 的数据、长度成员以及字符串编码
    NSUTF8StringEncoding。'
- en: To actually start receiving events, you have to subscribe! With an Endpoint
    Security client in hand, invoke the es_subscribe API. As its parameters, it takes
    the newly created client, an array of events, and the number of events to subscribe
    to, which here includes process execution and exit events ([Listing 8-5](chapter8.xhtml#Lis8-5)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际开始接收事件，你必须订阅！手持 Endpoint Security 客户端后，调用 es_subscribe API。它的参数包括新创建的客户端、事件数组以及要订阅的事件数量，这里包括进程执行和退出事件（[列表
    8-5](chapter8.xhtml#Lis8-5)）。
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Listing 8-5: Subscribing to events'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-5：订阅事件
- en: Note that we compute the number of events rather than hardcoding it ❶. Once
    the es_subscribe function returns with no error, the Endpoint Security subsystem
    will begin asynchronously delivering events that match the types to which we have
    subscribed. Specifically, it will invoke the handler block we specified when creating
    the client.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们计算事件的数量，而不是硬编码它 ❶。一旦 es_subscribe 函数返回且没有错误，Endpoint Security 子系统将开始异步地传递与我们订阅的类型匹配的事件。具体来说，它将调用我们在创建客户端时指定的处理块。
- en: Creating a Process Monitor
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建进程监控器
- en: Let’s put what we’ve learned to use by creating a process monitor that relies
    on Endpoint Security. We’ll first subscribe to process events such as ES_EVENT_TYPE_NOTIFY_EXEC
    and then parse pertinent process information as we receive events.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个依赖于 Endpoint Security 的进程监控器来应用所学的内容。我们将首先订阅进程事件，如 ES_EVENT_TYPE_NOTIFY_EXEC，然后在接收到事件时解析相关的进程信息。
- en: NOTE
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意
- en: '*Only relevant snippets are provided here, but you can find the code in its
    entirety in the* ESPlayground *project’s* monitor.m *file. You can also find an
    open source, production-ready process monitor build atop Endpoint Security in
    the* ProcessMonitor *project in Objective-See’s GitHub repository at* [https://github.com/objective-see/ProcessMonitor*.*](https://github.com/objective-see/ProcessMonitor)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*这里仅提供相关的代码片段，完整的代码可以在* ESPlayground *项目的* monitor.m *文件中找到。你也可以在 Objective-See
    的 GitHub 仓库中的* ProcessMonitor *项目找到一个基于 Endpoint Security 的开源、生产就绪的进程监控构建，链接为*
    [https://github.com/objective-see/ProcessMonitor*.*](https://github.com/objective-see/ProcessMonitor)'
- en: We begin by specifying which Endpoint Security events we’re interested in. For
    a simple process monitor, we could stick to just the ES_EVENT_TYPE_NOTIFY_EXEC
    event. However, we’ll also register for the ES_EVENT_TYPE_NOTIFY_EXIT event to
    track process exits. We put these event types into an array ([Listing 8-6](chapter8.xhtml#Lis8-6)).
    Once we create an Endpoint Security client, we’ll subscribe to the events.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先指定感兴趣的 Endpoint Security 事件。对于一个简单的进程监控器，我们可以只关注 ES_EVENT_TYPE_NOTIFY_EXEC
    事件。然而，我们还会注册 ES_EVENT_TYPE_NOTIFY_EXIT 事件，以追踪进程退出。我们将这些事件类型放入一个数组中（[列表 8-6](chapter8.xhtml#Lis8-6)）。一旦创建了一个
    Endpoint Security 客户端，我们将订阅这些事件。
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Listing 8-6: Events of interest to a simple process monitor'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-6：简单进程监控器的关注事件
- en: In [Listing 8-7](chapter8.xhtml#Lis8-7), we create a client via the es_new_client
    API.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 8-7](chapter8.xhtml#Lis8-7)中，我们通过 es_new_client API 创建一个客户端。
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Listing 8-7: Creating a new Endpoint Security client'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-7：创建一个新的 Endpoint Security 客户端
- en: We invoke the es_new_client API to create a new client instance ❶ and leave
    the handler block unimplemented for now. Assuming the call succeeds, we’ll have
    a newly initialized client. The code checks the result of the call against the
    ES_NEW_CLIENT_RESULT_SUCCESS constant to confirm that this is the case ❷. Recall
    that if your project isn’t adequately entitled, if you’re running it via the terminal
    without granting it full disk access, or if your code isn’t running with root
    privileges, the call to es_new_client will fail.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用 es_new_client API 创建一个新的客户端实例 ❶，并暂时不实现处理程序块。假设调用成功，我们将得到一个新初始化的客户端。代码检查调用结果是否与
    ES_NEW_CLIENT_RESULT_SUCCESS 常量匹配，以确认这一点 ❷。请记住，如果您的项目没有适当授权，或者通过终端运行时未授予其完全磁盘访问权限，或者代码没有以
    root 权限运行，调用 es_new_client 将会失败。
- en: Subscribing to Events
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 订阅事件
- en: With a client in hand, we can subscribe to the process execution and exiting
    events by invoking the es_subscribe API ([Listing 8-8](chapter8.xhtml#Lis8-8)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 拿到客户端后，我们可以通过调用 es_subscribe API 来订阅进程执行和退出事件（[列表 8-8](chapter8.xhtml#Lis8-8)）。
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Listing 8-8: Subscribing to process events of interest'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-8：订阅关注的进程事件
- en: Note that we compute the number of events rather than hardcoding it ❶. Once
    the es_subscribe function returns, the Endpoint Security subsystem will begin
    asynchronously delivering events that match the types to which we have subscribed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们计算事件的数量，而不是硬编码它 ❶。一旦 es_subscribe 函数返回，Endpoint Security 子系统将开始异步传送与我们已订阅类型匹配的事件。
- en: Extracting Process Objects
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提取进程对象
- en: 'This brings us to the final step, which is to handle the delivered events.
    I mentioned that the handler block gets invoked with two parameters: the client
    of type es_client_t being sent the event and a pointer to the event message of
    type es_message_t. If we’re not working with authorization events, the client
    isn’t directly relevant, but we’ll make use of the message, which contains the
    information about the delivered event.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这带我们进入最后一步，即处理已传送的事件。我提到过，处理程序块会以两个参数被调用：类型为 es_client_t 的客户端（接收事件的客户端）和指向事件消息的指针，类型为
    es_message_t。如果我们不处理授权事件，客户端就不直接相关，但我们会使用消息，其中包含有关已传送事件的信息。
- en: First and foremost, we’ll extract a pointer to an es_process_t structure containing
    information about either the newly spawned process or the process that has just
    exited. Choosing which process structure to extract requires making use of the
    event type. For exiting (and most other) events, we’ll extract the message’s process
    member, which contains a pointer to the process responsible for taking the action
    that triggered the event. However, in the case of process execution events, we’re
    more interested in accessing the process that was just spawned. Thus, we’ll use
    the es_event_exec_t structure, whose target member is a pointer to the relevant
    es_process_t structure ([Listing 8-9](chapter8.xhtml#Lis8-9)).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将提取指向 es_process_t 结构的指针，该结构包含关于新启动进程或刚刚退出进程的信息。选择提取哪个进程结构需要根据事件类型来决定。对于退出（以及大多数其他）事件，我们将提取消息中的进程成员，该成员包含指向负责触发事件的进程的指针。然而，对于进程执行事件，我们更关心访问刚刚启动的进程。因此，我们将使用
    es_event_exec_t 结构，其 target 成员是指向相关 es_process_t 结构的指针（[列表 8-9](chapter8.xhtml#Lis8-9)）。
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Listing 8-9: Extracting the relevant process'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-9：提取相关进程
- en: We first extract the type of event from the message ❶, then switch on it ❷ to
    extract a pointer to an es_process_t structure. In the case of a process execution
    event, we extract the process that was just spawned from the es_event_exec_t structure
    ❸. For process exit messages, we extract the process directly from the message
    ❹.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从消息中提取事件类型 ❶，然后根据事件类型进行切换 ❷，从而提取指向 `es_process_t` 结构体的指针。在进程执行事件的情况下，我们从
    `es_event_exec_t` 结构体 ❸ 中提取刚刚启动的进程。对于进程退出消息，我们直接从消息中提取进程 ❹。
- en: Extracting Process Information
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提取进程信息
- en: Now that we have a pointer to an es_process_t structure, we can extract information
    such as the process’s audit token, PID, path, and code signing information. Also,
    for newly spawned processes, we can extract their arguments, and for exited processes,
    we can extract their exit code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了指向 `es_process_t` 结构体的指针，可以提取信息，比如进程的审计令牌、PID、路径以及代码签名信息。此外，对于新启动的进程，我们可以提取其参数，对于已退出的进程，我们可以提取其退出代码。
- en: Audit Tokens
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 审计令牌
- en: Let’s start simple, by extracting the process’s audit token ([Listing 8-10](chapter8.xhtml#Lis8-10)).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的开始，通过提取进程的审计令牌（[Listing 8-10](chapter8.xhtml#Lis8-10)）。
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Listing 8-10: Extracting an audit token'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-10: 提取审计令牌'
- en: The audit token is the first field in the es_process_t structure, of type audit_token_t.
    You can use this value directly or, as done here, extract it into an NSData object.
    Recall that an audit token allows you to uniquely and securely identify the process,
    as well as extract the other process’s information, such as its process ID. In
    [Listing 8-11](chapter8.xhtml#Lis8-11), we pass the audit token to the audit_token_to_pid
    function, which returns the PID.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 审计令牌是 `es_process_t` 结构体中的第一个字段，类型为 `audit_token_t`。你可以直接使用这个值，或者像这里所做的那样，将其提取到一个
    `NSData` 对象中。回想一下，审计令牌允许你唯一且安全地识别进程，并提取其他进程的信息，比如进程 ID。在 [Listing 8-11](chapter8.xhtml#Lis8-11)
    中，我们将审计令牌传递给 `audit_token_to_pid` 函数，该函数返回 PID。
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Listing 8-11: Converting an audit token to a process ID'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-11: 将审计令牌转换为进程 ID'
- en: We can also extract the process’s effective UID from the audit token by means
    of the audit_token_to_euid function.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过 `audit_token_to_euid` 函数从审计令牌中提取进程的有效 UID。
- en: Note that invoking these functions requires you to import the *bsm/libbsm.h*
    header file and link against the *libbsm* library.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，调用这些函数时需要导入 *bsm/libbsm.h* 头文件并链接 *libbsm* 库。
- en: Process Paths
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 进程路径
- en: In [Listing 8-12](chapter8.xhtml#Lis8-12), we extract the process path via a
    pointer to a structure named executable found within the es_process_t structure.
    This points to an es_file_t structure whose path field contains the process’s
    path.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Listing 8-12](chapter8.xhtml#Lis8-12) 中，我们通过指向 `es_process_t` 结构体中的 `executable`
    字段的指针提取进程路径。这个字段指向一个 `es_file_t` 结构体，其中的 `path` 字段包含进程的路径。
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Listing 8-12: Extracting a process’s path'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-12: 提取进程路径'
- en: Because this field is of type es_string_token_t, we convert it into a more manageable
    string object.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因为该字段的类型是 `es_string_token_t`，我们将其转换为一个更易于管理的字符串对象。
- en: Hierarchies
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 层级结构
- en: Using the es_process_t process structure also simplifies building process hierarchies.
    We could extract the parent process’s ID from the es_process_t structure. However,
    a comment in the *ESMessage.h* header file instead recommends using the parent_audit_token
    field, available in Endpoint Security messages of version 4 and newer. In those
    versions, we’ll also find the audit token of the responsible process in a field
    aptly named responsible_audit_token. In [Listing 8-13](chapter8.xhtml#Lis8-13),
    after ensuring that the message versions suffice, we extract these.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `es_process_t` 进程结构体也简化了进程层级的构建。我们可以从 `es_process_t` 结构体中提取父进程的 ID。然而，*ESMessage.h*
    头文件中的一条注释建议改为使用 `parent_audit_token` 字段，该字段在版本 4 及更高版本的 Endpoint Security 消息中可用。在这些版本中，我们还会在一个恰如其分命名的字段
    `responsible_audit_token` 中找到负责进程的审计令牌。在 [Listing 8-13](chapter8.xhtml#Lis8-13)
    中，在确保消息版本足够的情况下，我们提取这些信息。
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Listing 8-13: Extracting a parent and responsible process token'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 'Listing 8-13: 提取父进程和负责进程的令牌'
- en: We extract the parent PID ❶ and, for recent versions of Endpoint Security, the
    parent audit token ❷ and responsible process token ❸. These can then be used to
    build a process hierarchy.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提取父进程 PID ❶，对于较新版本的 Endpoint Security，提取父进程审计令牌 ❷ 和负责进程令牌 ❸。然后，这些信息可以用来构建进程层级结构。
- en: Script Paths
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 脚本路径
- en: Recall that es_event_exec_t structures describe ES_EVENT_TYPE_NOTIFY_EXEC events.
    So far, we’ve largely focused on the first field of this structure, a pointer
    to an es_process_t structure. However, other fields of the es_event _exec_t structure
    are useful to a process monitor, especially for heuristically detecting malware.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，es_event_exec_t 结构体描述了 ES_EVENT_TYPE_NOTIFY_EXEC 事件。到目前为止，我们主要关注该结构体的第一个字段，即指向
    es_process_t 结构体的指针。然而，es_event_exec_t 结构体的其他字段对进程监视器也是有用的，尤其是在启发式检测恶意软件时。
- en: For example, consider cases when the process being executed is a *script interpreter*,
    a program used to run a script. When a user executes a script, the operating system
    will determine the correct script interpreter behind the scenes and invoke it
    to execute the script. In this case, Endpoint Security will report the script
    interpreter as the process executed and display its path, such as */usr/bin/python3*.
    However, we’re more interested in *what* the interpreter is executing. If we’re
    able to determine the path to the script being indirectly executed, we can then
    scan it for known malware or use heuristics to determine if it’s likely malicious.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑当被执行的进程是 *脚本解释器* 的情况，脚本解释器是用来运行脚本的程序。当用户执行脚本时，操作系统会在后台确定正确的脚本解释器并调用它来执行脚本。在这种情况下，Endpoint
    Security 会报告脚本解释器作为执行的进程，并显示其路径，例如 */usr/bin/python3*。然而，我们更关心的是 *解释器* 正在执行 *什么*。如果我们能够确定间接执行的脚本路径，那么我们就可以扫描它以查找已知的恶意软件，或者使用启发式方法来判断它是否可能是恶意的。
- en: Luckily, messages in versions 2 and above of Endpoint Security provide this
    path in the script field of the es_event_exec_t structure. If the newly spawned
    process is not a script interpreter, this field will be NULL. Also, it won’t be
    set if the script was executed as an argument to the interpreter (for example,
    if the user ran python3 <path to some script>). In those cases, however, the script
    would show up as the process’s first argument.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Endpoint Security 2 版本及以上的消息会在 es_event_exec_t 结构体的脚本字段中提供此路径。如果新生成的进程不是脚本解释器，该字段将为空（NULL）。此外，如果脚本是作为解释器的参数执行的（例如，如果用户运行了
    python3 <某个脚本路径>），该字段也不会被设置。然而，在这种情况下，脚本会作为进程的第一个参数出现。
- en: '[Listing 8-14](chapter8.xhtml#Lis8-14) shows how to extract the path of a script
    via the script field.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 8-14](chapter8.xhtml#Lis8-14) 显示了如何通过脚本字段提取脚本的路径。'
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Listing 8-14: Extracting a script path'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-14：提取脚本路径
- en: We make sure we only attempt this extraction on compatible versions of Endpoint
    Security ❶ and if the script field is not NULL ❷.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保只在兼容版本的 Endpoint Security ❶ 上尝试此提取操作，并且脚本字段不为空（NULL）❷。
- en: 'If you directly execute a Python script, the process monitoring code within
    *ESPlayground* will report Python as the spawned process, along with the path
    to the script:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你直接执行一个 Python 脚本，*ESPlayground* 中的进程监控代码会报告 Python 为生成的进程，并给出脚本的路径：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This example captures the Realst malware, which contains a script named *installer.py*.
    Now we can inspect this script, which reveals malicious code designed to steal
    data and give attackers access to a user’s cryptocurrency wallet.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子捕获了 Realst 恶意软件，它包含一个名为 *installer.py* 的脚本。现在我们可以检查这个脚本，它揭示了旨在窃取数据并让攻击者访问用户加密货币钱包的恶意代码。
- en: Binary Architecture
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 二进制架构
- en: Another piece of information that Endpoint Security provides in the es_event_exec_t
    structure is the process’s architecture. In [Chapter 2](chapter2.xhtml), I discussed
    how to determine the architecture programmatically for any running process, but
    conveniently, the Endpoint Security subsystem can do this as well.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Endpoint Security 在 es_event_exec_t 结构体中提供的另一个信息是进程的架构。在[第二章](chapter2.xhtml)中，我讨论了如何以编程方式确定任何正在运行的进程的架构，但方便的是，Endpoint
    Security 子系统也可以做到这一点。
- en: To access the spawned process’s binary architecture, you can extract the image_cputype
    field (and image_cpusubtype, if you’re interested in the CPU subtype), as shown
    in [Listing 8-15](chapter8.xhtml#Lis8-15). This information is available only
    in versions 6 and above of Endpoint Security, so the code first checks for a compatible
    version.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问生成的进程的二进制架构，你可以提取 image_cputype 字段（如果你对 CPU 子类型感兴趣，也可以提取 image_cpusubtype），如[列表
    8-15](chapter8.xhtml#Lis8-15)所示。此信息仅在 Endpoint Security 版本 6 及以上可用，因此代码首先会检查兼容的版本。
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Listing 8-15: Extracting a process’s architecture'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-15：提取进程的架构
- en: This code should return values such as 0x100000C or 0x1000007. By consulting
    Apple’s *mach/machine.h* header file, you can see that these map to CPU_TYPE_ARM64
    (Apple Silicon) and CPU_TYPE_X86_64 (Intel), respectively.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该返回像 0x100000C 或 0x1000007 这样的值。通过查看 Apple 的 *mach/machine.h* 头文件，可以看到这些值分别对应
    CPU_TYPE_ARM64（Apple Silicon）和 CPU_TYPE_X86_64（Intel）。
- en: Code Signing
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码签名
- en: In [Chapter 3](chapter3.xhtml), you saw how to leverage the rather archaic Sec*
    APIs to manually extract code signing information. To simplify this extraction,
    Endpoint Security reports code signing information for the process responsible
    for the action that triggered the event in each message it delivers. Some events
    may also contain code signing information for other processes. For example, ES_EVENT_TYPE_NOTIFY_EXEC
    events contain the code signing information for newly spawned processes.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 3 章](chapter3.xhtml) 中，你已经看到如何利用那些相当古老的 Sec* API 手动提取代码签名信息。为了简化这个提取过程，Endpoint
    Security 会在每个消息中报告触发事件的进程的代码签名信息。有些事件还可能包含其他进程的代码签名信息。例如，ES_EVENT_TYPE_NOTIFY_EXEC
    事件包含新生成进程的代码签名信息。
- en: 'You can find code signing information for processes in their es_process_t structure
    in the following fields:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在进程的 es_process_t 结构体中的以下字段找到代码签名信息：
- en: '**uint32_t codesigning_flags** Contains a process’s code signing flags'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**uint32_t codesigning_flags** 包含进程的代码签名标志'
- en: ''
  id: totrans-144
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**bool is_platform_binary** Identifies platform binaries'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**bool is_platform_binary** 标识平台二进制文件'
- en: ''
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**uint8_t cdhash[20]** Stores the signature’s code directory hash'
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**uint8_t cdhash[20]** 存储签名的代码目录哈希'
- en: ''
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**es_string_token_t signing_id** Stores the signature ID'
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**es_string_token_t signing_id** 存储签名 ID'
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**es_string_token_t team_id** Stores the team ID'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**es_string_token_t team_id** 存储团队 ID'
- en: Let’s look at each of these fields, starting with codesigning_flags, whose values
    can be found in Apple’s *cs_blobs.h* header file. [Listing 8-16](chapter8.xhtml#Lis8-16)
    extracts the code signing flags from the es_process_t structure and then checks
    them for several common code signing values. Because the value of the codesigning_flags
    is a bit field, the code uses the logical AND (&) operator to check for specific
    code signing values.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个查看这些字段，从 codesigning_flags 开始，它的值可以在 Apple 的 *cs_blobs.h* 头文件中找到。[列表 8-16](chapter8.xhtml#Lis8-16)
    从 es_process_t 结构体中提取代码签名标志，并检查它们是否包含几个常见的代码签名值。由于 codesigning_flags 的值是一个位字段，代码使用逻辑与（&）运算符来检查特定的代码签名值。
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Listing 8-16: Extracting a process’s code signing flags'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-16：提取进程的代码签名标志
- en: Accessing and then extracting code signing flags could allow you to do things
    like investigate spawned processes whose signatures are ad hoc, meaning they’re
    untrusted. The widespread 3CX supply chain attack used a second-stage payload
    that was signed with an ad hoc signature.^([3](#chapter8-3))
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 访问并提取代码签名标志可能允许你执行类似调查生成进程的操作，这些进程的签名是临时的，意味着它们是不受信任的。广泛传播的 3CX 供应链攻击使用了一个二阶段的有效负载，该负载使用临时签名进行了签名。^([3](#chapter8-3))
- en: Also within the es_process_t structure, you’ll find the is_platform_binary field,
    which is a Boolean flag set to true for binaries that are part of macOS and signed
    solely with Apple certificates. It’s important to note that for Apple applications
    that aren’t preinstalled in macOS, such as Xcode, this field will be set to false.
    It’s also worth noting that the CS_PLATFORM_BINARY flag doesn’t appear to be set
    in the codesigning_flags field for platform binaries, so consult the value of
    the is_platform_binary field for this information instead.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 es_process_t 结构体中，你还会发现 is_platform_binary 字段，这是一个布尔标志，对于仅用 Apple 证书签名并且是
    macOS 一部分的二进制文件，该字段会被设置为 true。需要注意的是，对于那些没有预装在 macOS 中的 Apple 应用程序，例如 Xcode，这个字段会被设置为
    false。还需要注意的是，CS_PLATFORM_BINARY 标志似乎不会出现在平台二进制文件的 codesigning_flags 字段中，因此应查看
    is_platform_binary 字段的值来获取这一信息。
- en: WARNING
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '*If you’ve disabled AMFI, Endpoint Security may mark all processes, including
    third-party and potentially malicious ones, as platform binaries. Therefore, if
    you conduct tests on a machine with AMFI disabled, any decisions you make based
    on the is_platform_binary value will likely be incorrect.*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果你禁用了 AMFI，Endpoint Security 可能会将所有进程，包括第三方和潜在恶意的进程，都标记为平台二进制文件。因此，如果你在禁用
    AMFI 的机器上进行测试，基于 is_platform_binary 值做出的任何决策很可能是不正确的。*'
- en: I mentioned earlier in this chapter that you may be able to safely ignore platform
    binaries, as they’re part of the operating system. The reality isn’t quite this
    simple, however. You might want to account for *living off the land binaries (LOLBins)*,
    which are platform binaries that attackers can abuse to perform malicious actions
    on their behalf. One example is Python, which can execute malicious scripts as
    we just saw with the Realst malware. Other LOLBins may be more subtle. For example,
    malware could use the built-in whois tool to surreptitiously exfiltrate network
    traffic in an undetected manner if host-based security tools naively allow all
    traffic from platform binaries.^([4](#chapter8-4))
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章之前提到过，你可以安全地忽略平台二进制文件，因为它们是操作系统的一部分。然而，现实情况并非如此简单。你可能需要考虑 *living off the
    land binaries (LOLBins)*，这些是攻击者可以利用的平台二进制文件，用于代表他们执行恶意操作。一个例子是 Python，正如我们刚刚看到的
    Realst 恶意软件，它可以执行恶意脚本。其他 LOLBins 可能更为隐蔽。例如，恶意软件可能会使用内置的 whois 工具，在主机安全工具天真地允许所有来自平台二进制文件的流量时，偷偷地泄露网络流量。^([4](#chapter8-4))
- en: Given a pointer to an es_process_t structure, you can easily extract the is_platform_binary
    field. In [Listing 8-17](chapter8.xhtml#Lis8-17), we convert it to an object so
    we can, for example, store it in a dictionary.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个指向 es_process_t 结构体的指针，你可以轻松地提取 is_platform_binary 字段。在[列表 8-17](chapter8.xhtml#Lis8-17)中，我们将其转换为对象，以便例如可以将其存储在字典中。
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 8-17: Extracting a process’s platform binary status'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-17：提取进程的平台二进制状态
- en: Your code might not make use of the cdhash field, but [Listing 8-18](chapter8.xhtml#Lis8-18)
    shows how to extract and convert it into an object by making use of the CS_CDHASH_LEN
    constant found in Apple’s *cs_blobs.h* header file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码可能不会使用 cdhash 字段，但[列表 8-18](chapter8.xhtml#Lis8-18)展示了如何提取并利用 Apple 的 *cs_blobs.h*
    头文件中的 CS_CDHASH_LEN 常量将其转换为对象。
- en: '[PRE27]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Listing 8-18: Extracting a process’s code signing hash'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-18：提取进程的代码签名哈希
- en: Next in the es_process_t structure are the signing and team identifiers, stored
    as string tokens. As was discussed in [Chapter 3](chapter3.xhtml), these can tell
    you who signed the item and what team they’re a part of, which can reduce false
    positives or detect other related malware. As each of these values is an es_string_token_t,
    you’ll probably once again want to store them as more manageable objects ([Listing
    8-19](chapter8.xhtml#Lis8-19)).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 es_process_t 结构体中，接下来是签名和团队标识符，它们作为字符串令牌存储。如[第 3 章](chapter3.xhtml)中所讨论的，这些信息可以告诉你是谁签署了该项内容以及他们所属的团队，这有助于减少误报或检测到其他相关的恶意软件。由于这些值都是
    es_string_token_t，你可能会再次希望将它们存储为更易管理的对象（[列表 8-19](chapter8.xhtml#Lis8-19)）。
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Listing 8-19: Extracting a process’s signing and team IDs'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-19：提取进程的签名和团队 ID
- en: 'With this code signing extraction code added to the process monitoring logic
    in *ESPlayground*, let’s execute the aforementioned second-stage payload, *UpdateAgent*,
    used in the 3CX supply chain attack. It’s clear that the payload is signed with
    an ad hoc certificate (CS_ADHOC), which is often a red flag:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在将此代码签名提取代码添加到 *ESPlayground* 中的进程监控逻辑后，让我们执行前述的第二阶段有效载荷 *UpdateAgent*，这是 3CX
    供应链攻击中使用的。很明显，该有效载荷使用了临时证书（CS_ADHOC）进行签名，这通常是一个警告信号：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this code signing information made available by Endpoint Security, we’re
    close to wrapping up the process monitor’s logic.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Endpoint Security 提供的这些代码签名信息，我们接近完成进程监控逻辑的实现。
- en: Arguments
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 参数
- en: Let’s consider message-specific contents, starting with the process arguments
    found in ES_EVENT_TYPE_NOTIFY_EXEC messages. In [Chapter 1](chapter1.xhtml), I
    discussed the usefulness of process arguments for detecting malicious code and
    programmatically extracted them from running processes. If you’ve subscribed to
    Endpoint Security events of type ES_EVENT_TYPE_NOTIFY_EXEC, you’ll see that Endpoint
    Security has done most of the heavy lifting for you.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从消息特定内容开始，首先是 ES_EVENT_TYPE_NOTIFY_EXEC 消息中的进程参数。在[第 1 章](chapter1.xhtml)中，我讨论了进程参数在检测恶意代码中的重要性，并通过编程提取了正在运行的进程的参数。如果你订阅了类型为
    ES_EVENT_TYPE_NOTIFY_EXEC 的 Endpoint Security 事件，你会看到 Endpoint Security 已经为你完成了大部分繁重的工作。
- en: These events are es_event_exec_t structures that you can pass to two Endpoint
    Security helper APIs, es_exec_arg_count and es_exec_arg, to extract the arguments
    that triggered the Endpoint Security event ([Listing 8-20](chapter8.xhtml#Lis8-20)).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件是 es_event_exec_t 结构体，你可以将其传递给两个 Endpoint Security 辅助 API，es_exec_arg_count
    和 es_exec_arg，以提取触发 Endpoint Security 事件的参数（[列表 8-20](chapter8.xhtml#Lis8-20)）。
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Listing 8-20: Extracting a process’s arguments'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8-20：提取进程的参数
- en: After initializing an array to hold the arguments, the code invokes es_exec_arg_count
    to determine the number of arguments ❶. We perform this check within the initialization
    of a for loop to keep track of how many times we invoke the es_exec_arg function.
    Then we invoke the function with the current index to retrieve the argument at
    that index ❷. Because the argument is stored in an es_string_token_t structure,
    the code converts it into a string object ❸ and adds it to an array ❹.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化一个数组来存储参数后，代码调用 es_exec_arg_count 来确定参数的数量❶。我们在 for 循环的初始化中进行此检查，以跟踪我们调用
    es_exec_arg 函数的次数。然后，我们使用当前索引调用该函数，以获取该索引位置的参数❷。由于该参数存储在 es_string_token_t 结构中，代码将其转换为字符串对象❸，并将其添加到数组中❹。
- en: 'When we add this code to the *ESPlayground* project, we’re now able to observe
    process arguments, such as when the WindTape malware executes curl to exfiltrate
    recorded screen captures to the attackers’ command-and-control server:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将这段代码添加到 *ESPlayground* 项目时，我们现在可以观察到进程参数，例如，当 WindTape 恶意软件执行 curl 命令将录制的屏幕截图传输到攻击者的指挥与控制服务器时：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You could use the similar functions es_exec_env_count and es_exec_env to extract
    a process’s environment variables from an es_event_exec_t structure.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用类似的函数 es_exec_env_count 和 es_exec_env 从 es_event_exec_t 结构中提取进程的环境变量。
- en: Exit Status
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 退出状态
- en: 'When a process exits, we’ll receive a message from Endpoint Security because
    we’ve subscribed to ES_EVENT_TYPE_NOTIFY_EXIT events. Knowing when a process exits
    is useful for purposes such as the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当进程退出时，我们将收到来自 Endpoint Security 的消息，因为我们已订阅了 ES_EVENT_TYPE_NOTIFY_EXIT 事件。知道进程何时退出对于以下目的非常有用：
- en: '**Determining whether a process succeeded or failed** A process’s exit code
    provides insight into whether the process executed successfully. If the process
    is, for example, a malicious installer, this information could help us determine
    its impact.'
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**判断进程是否成功或失败** 进程的退出代码能提供有关进程是否成功执行的信息。例如，如果该进程是恶意安装程序，这些信息可以帮助我们判断其影响。'
- en: ''
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Performing any necessary cleanup** In many cases, security tools track activity
    over the lifetime of a process. For example, a ransomware detector could monitor
    each new process to detect those that rapidly create encrypted files. When a process
    exits, the detector can perform any necessary cleanup, such as freeing the processes
    list of created files and removing the process from any caches.'
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**执行任何必要的清理** 在许多情况下，安全工具会跟踪进程的生命周期活动。例如，勒索软件检测器可以监控每个新进程，以检测那些快速创建加密文件的进程。当进程退出时，检测器可以执行必要的清理工作，例如释放已创建文件的进程列表，并从缓存中移除该进程。'
- en: 'The event structure type for the ES_EVENT_TYPE_NOTIFY_EXIT event is es_event_exit_t.
    By consulting the *ESMessage.h* header file, we can see that it contains a single
    (nonreserved) field named stat containing the exit status of a process:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ES_EVENT_TYPE_NOTIFY_EXIT 事件的事件结构类型是 es_event_exit_t。通过查看 *ESMessage.h* 头文件，我们可以看到它包含一个名为
    stat 的单一（非保留）字段，表示进程的退出状态：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Knowing this, we extract the process’s exit code, as shown in [Listing 8-21](chapter8.xhtml#Lis8-21).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这一点后，我们提取进程的退出代码，如[清单 8-21](chapter8.xhtml#Lis8-21)所示。
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Listing 8-21: Extracting an exit code'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-21：提取退出代码
- en: Because the process monitor logic has also registered for process execution
    events (ES_EVENT_TYPE_NOTIFY_EXEC), the code first makes sure we’re dealing with
    a process exit (ES_EVENT_TYPE_NOTIFY_EXIT) ❶. If so, it then extracts the exit
    code ❷.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 因为进程监控逻辑也注册了进程执行事件（ES_EVENT_TYPE_NOTIFY_EXEC），所以代码首先确保我们正在处理的是进程退出事件（ES_EVENT_TYPE_NOTIFY_EXIT）❶。如果是，它会提取退出代码❷。
- en: Stopping the Client
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 停止客户端
- en: At some point, you might want to stop your Endpoint Security client. This is
    as simple as unsubscribing from events via the es_unsubscribe_all function, then
    deleting the client via es_delete_client. As shown in [Listing 8-22](chapter8.xhtml#Lis8-22),
    both functions take as arguments the client we previously created using the es_new_client
    function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能希望停止你的 Endpoint Security 客户端。只需通过 es_unsubscribe_all 函数取消订阅事件，然后通过
    es_delete_client 删除客户端。正如[清单 8-22](chapter8.xhtml#Lis8-22)所示，这两个函数都以我们之前使用 es_new_client
    函数创建的客户端作为参数。
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Listing 8-22: Stopping an Endpoint Security client'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 清单 8-22：停止 Endpoint Security 客户端
- en: See the *ESClient.h* header file for more details on the functions. For example,
    code should only call es_delete_client from the same thread that originally created
    the client.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 *ESClient.h* 头文件，了解更多有关函数的细节。例如，代码应该仅在创建客户端的相同线程中调用 es_delete_client。
- en: This wraps up the discussion of creating a process monitor capable of tracking
    process executions and exits, as well as extracting information from each event
    that we could feed into a variety of heuristic-based rules. Of course, you could
    register for many other Endpoint Security events. Let’s now explore file events,
    which provide the foundation for a file monitor.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分总结了如何创建一个能够跟踪进程执行和退出的进程监视器，并从每个事件中提取信息，这些信息可以用来输入到各种基于启发式的规则中。当然，你也可以注册许多其他的终端安全事件。接下来，我们来探讨文件事件，它们为文件监视器提供了基础。
- en: File Monitoring
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件监控
- en: File monitors are powerful tools for detecting and understanding malicious code.
    For example, infamous ransomware groups such as Lockbit have begun targeting macOS,^([5](#chapter8-5))
    so you might want to write software that can identify ransomware. In my 2016 research
    paper “Towards Generic Ransomware Detection,” I highlighted a simple yet effective
    approach to doing so.^([6](#chapter8-6)) In a nutshell, if we can monitor for
    the rapid creation of encrypted files by untrusted processes, we should be able
    to detect and thwart ransomware. Although any heuristic-based approach has its
    limitations, my method has proven successful even with new ransomware specimens.
    It even detected Lockbit’s foray into the macOS space in 2023.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 文件监视器是检测和理解恶意代码的强大工具。例如，臭名昭著的勒索软件团伙如 Lockbit 已经开始瞄准 macOS,^([5](#chapter8-5))
    所以你可能想编写能够识别勒索软件的软件。在我 2016 年的研究论文《朝向通用勒索软件检测》里，我强调了一种简单而有效的方法来实现这一目标。^([6](#chapter8-6))
    简而言之，如果我们能监控由不信任的进程迅速创建的加密文件，我们应该能够检测并阻止勒索软件。虽然任何基于启发式的方法都有其局限性，但我的方法即使面对新的勒索软件样本也证明了其有效性。它甚至检测到了
    Lockbit 在 2023 年进军 macOS 领域的情况。
- en: A core capability of this generic ransomware detection is the ability to monitor
    for the creation of files. Using Endpoint Security, it’s easy to create a file
    monitor that can detect file creation and other file I/O events.^([7](#chapter8-7))
    You can find source code for a fully featured file monitor in the *FileMonitor*
    project on Objective-See’s GitHub repository at [*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/FileMonitor*](https://github.com/objective-see/FileMonitor).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这种通用勒索软件检测的核心能力是监控文件的创建。使用终端安全性，可以轻松创建一个文件监视器，来检测文件创建和其他文件 I/O 事件。^([7](#chapter8-7))
    你可以在 Objective-See 的 GitHub 仓库中的 *FileMonitor* 项目找到一个功能齐全的文件监视器源代码，地址是 [*https://<wbr>github<wbr>.com<wbr>/objective<wbr>-see<wbr>/FileMonitor*](https://github.com/objective-see/FileMonitor)。
- en: 'Because I’ve already discussed how to create an Endpoint Security client and
    register for events of interest, I won’t spend time discussing these topics again.
    Instead, I’ll focus on the specifics of monitoring file events. In the *ESTypes.h*
    header file, we find many events covering file I/O. Some of the most useful notification
    events include:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我已经讨论过如何创建终端安全客户端并注册感兴趣的事件，所以我不会再次讨论这些主题。相反，我将专注于监控文件事件的具体细节。在 *ESTypes.h*
    头文件中，我们可以找到许多覆盖文件 I/O 的事件。最有用的通知事件之一包括：
- en: '**ES_EVENT_TYPE_NOTIFY_CREATE** Delivered when a new file is created'
  id: totrans-202
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**ES_EVENT_TYPE_NOTIFY_CREATE** 当新文件创建时传递'
- en: ''
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**ES_EVENT_TYPE_NOTIFY_OPEN** Delivered when a file is opened'
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**ES_EVENT_TYPE_NOTIFY_OPEN** 当文件打开时传递'
- en: ''
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**ES_EVENT_TYPE_NOTIFY_WRITE** Delivered when a file is written to'
  id: totrans-206
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**ES_EVENT_TYPE_NOTIFY_WRITE** 当文件被写入时传递'
- en: ''
  id: totrans-207
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**ES_EVENT_TYPE_NOTIFY_CLOSE** Delivered when a file is closed'
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**ES_EVENT_TYPE_NOTIFY_CLOSE** 当文件关闭时传递'
- en: ''
  id: totrans-209
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**ES_EVENT_TYPE_NOTIFY_RENAME** Delivered when a file is renamed'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**ES_EVENT_TYPE_NOTIFY_RENAME** 当文件重命名时传递'
- en: ''
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**ES_EVENT_TYPE_NOTIFY_UNLINK** Delivered when a file is deleted'
  id: totrans-212
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**ES_EVENT_TYPE_NOTIFY_UNLINK** 当文件被删除时传递'
- en: Let’s register for the events related to file creation, opening, closing, and
    deleting ([Listing 8-23](chapter8.xhtml#Lis8-23)).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们注册与文件创建、打开、关闭和删除相关的事件（[列表 8-23](chapter8.xhtml#Lis8-23)）。
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Listing 8-23: File I/O events of interest'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '列表 8-23: 关注的文件 I/O 事件'
- en: After creating a new Endpoint Security client using es_new_client, we can invoke
    the es_subscribe function with the new list of events of interest to subscribe
    to. The subsystem should then begin delivering file I/O events to us, encapsulated
    in es_message_t structures. Recall the es_message_t structure contains meta information
    about the event, such as the event type and process responsible for triggering
    it. A file monitor could use this information to map the delivered file event
    to the responsible process.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 es_new_client 创建一个新的 Endpoint Security 客户端后，我们可以使用新的感兴趣事件列表调用 es_subscribe
    函数来进行订阅。此时，子系统应开始将文件 I/O 事件传递给我们，这些事件封装在 es_message_t 结构中。回想一下，es_message_t 结构包含有关事件的元信息，例如事件类型和触发该事件的进程。文件监控器可以使用这些信息将传递的文件事件与负责的进程映射起来。
- en: Besides reporting the event type and responsible process, a file monitor should
    also capture the filepath (which, in the case of file creation events, leads to
    the created file). The steps required to extract the path depend on the specific
    file I/O event, so we’ll look at each in detail, starting with file creation events.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 除了报告事件类型和负责的进程外，文件监控器还应捕获文件路径（在文件创建事件中，这将指向创建的文件）。提取路径的步骤取决于具体的文件 I/O 事件，因此我们将详细查看每一种情况，从文件创建事件开始。
- en: 'We’ve subscribed to ES_EVENT_TYPE_NOTIFY_CREATE, so whenever a file is created,
    Endpoint Security will deliver a message to us. The event data for this event
    is stored in a structure of type es_event_create_t:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经订阅了 ES_EVENT_TYPE_NOTIFY_CREATE，因此每当文件被创建时，Endpoint Security 会将消息传递给我们。该事件的数据存储在
    es_event_create_t 类型的结构中：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Though this structure appears a bit involved at first blush, handling it is
    fairly trivial in most cases. The destination_type member should be set to one
    of two enumeration values ❶. Apple explains the difference between the two in
    the *ESMessage.h* header file:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个结构乍一看似乎比较复杂，但在大多数情况下，处理起来相当简单。destination_type 成员应该设置为两种枚举值之一 ❶。Apple 在
    *ESMessage.h* 头文件中解释了这两者之间的区别：
- en: Typically, ES_EVENT_TYPE_NOTIFY_CREATE events are fired after the object has
    been created and the destination_type will be ES_DESTINATION_TYPE_EXISTING_FILE.
    The exception to this is for notifications that occur if an ES client responds
    to an ES_EVENT_TYPE_AUTH_CREATE event with ES_AUTH_RESULT_DENY.
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 通常，ES_EVENT_TYPE_NOTIFY_CREATE 事件会在对象创建后触发，此时 destination_type 将是 ES_DESTINATION_TYPE_EXISTING_FILE。例外情况是，当
    ES 客户端对 ES_EVENT_TYPE_AUTH_CREATE 事件作出响应并返回 ES_AUTH_RESULT_DENY 时，会触发通知。
- en: As a simple file monitor won’t register for ES_EVENT_TYPE_AUTH_* events, we
    can focus on the former case here.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一个简单的文件监控器不会注册 ES_EVENT_TYPE_AUTH_* 类型的事件，因此我们可以专注于前者的情况。
- en: We’ll locate the path to the file that was just created in the existing_file
    member, found in the destination union of the es_event_create_t structure ❷. As
    existing_file is stored as an es_file_t, extracting the newly created file’s path
    is trivial, as shown in [Listing 8-24](chapter8.xhtml#Lis8-24).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 es_event_create_t 结构的 destination 联合体中的 existing_file 成员中找到刚创建的文件路径 ❷。由于
    existing_file 存储为 es_file_t 类型，提取新创建文件的路径非常简单，如[示例 8-24](chapter8.xhtml#Lis8-24)所示。
- en: '[PRE37]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Listing 8-24: Extracting a newly created filepath'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-24：提取新创建的文件路径
- en: Because we’ve also registered for ES_EVENT_TYPE_NOTIFY_OPEN events, Endpoint
    Security will deliver a message containing an es_event_open_t event structure
    whenever a file is opened. This structure contains an es_file_t pointer to a member-named
    file containing the path of the opened file. We extract it in [Listing 8-25](chapter8.xhtml#Lis8-25).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们也注册了 ES_EVENT_TYPE_NOTIFY_OPEN 事件，所以每当文件被打开时，Endpoint Security 会传递一个包含 es_event_open_t
    事件结构的消息。该结构包含一个指向成员命名为 file 的 es_file_t 指针，指向包含已打开文件路径的文件。我们在[示例 8-25](chapter8.xhtml#Lis8-25)中提取了该信息。
- en: '[PRE38]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Listing 8-25: Extracting an opened filepath'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 8-25：提取已打开的文件路径
- en: The logic for ES_EVENT_TYPE_NOTIFY_CLOSE and ES_EVENT_TYPE_NOTIFY_UNLINK is
    similar, as both event structures contain an es_file_t* with the file’s path.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ES_EVENT_TYPE_NOTIFY_CLOSE 和 ES_EVENT_TYPE_NOTIFY_UNLINK 的逻辑类似，因为这两个事件结构都包含一个指向文件路径的
    es_file_t*。
- en: I’ll end this section by discussing a file event that has both a source and
    destination path. For example, when a file is renamed, Endpoint Security delivers
    a message of type ES_EVENT_TYPE_NOTIFY_RENAME. In that case, the es_event_rename_t
    structure contains a pointer to an es_file_t structure for the source file (aptly
    named source), as well as one for the destination file (named existing_file).
    We can access the path of the original file via message->event.rename.source->path.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我将通过讨论一个同时包含源路径和目标路径的文件事件来结束这一部分。例如，当一个文件被重命名时，Endpoint Security会传递一个类型为ES_EVENT_TYPE_NOTIFY_RENAME的消息。在这种情况下，es_event_rename_t结构包含一个指向源文件（恰当地命名为source）的es_file_t结构指针，以及一个指向目标文件（命名为existing_file）的指针。我们可以通过message->event.rename.source->path来访问原始文件的路径。
- en: 'Obtaining the renamed file’s destination path is slightly nuanced, as we must
    first check the destination_type field of the es_event_rename_t structure. This
    field is an enumeration containing two values: ES_DESTINATION_TYPE_EXISTING_FILE
    and ES_DESTINATION_TYPE_NEW_PATH. For the existing file value, we can directly
    access the destination filepath via rename.destination.existing_file->path (assuming
    we have an es_event_rename_t structure named rename). For the destination value,
    however, we must concatenate the destination directory with the destination filename;
    we’ll find the directory in rename .destination.new_path.dir->path and the filename
    in rename.destination.new _path.filename.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 获取重命名文件的目标路径略有一些复杂，因为我们首先必须检查es_event_rename_t结构的destination_type字段。这个字段是一个枚举，包含两个值：ES_DESTINATION_TYPE_EXISTING_FILE和ES_DESTINATION_TYPE_NEW_PATH。对于现有文件值，我们可以通过rename.destination.existing_file->path直接访问目标文件路径（假设我们有一个名为rename的es_event_rename_t结构）。然而，对于目标值，我们必须将目标目录与目标文件名连接起来；我们将在rename.destination.new_path.dir->path中找到目录，在rename.destination.new_path.filename中找到文件名。
- en: Conclusion
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: This chapter introduced Endpoint Security, the de facto standard framework for
    writing security tools on macOS. We built foundational monitoring and detection
    tools by subscribing to notifications for process and file events. In the next
    chapter, I’ll continue discussing Endpoint Security but focus on more advanced
    topics, such as muting, as well as ES_EVENT_TYPE_AUTH_* events, which provide
    a mechanism for proactively detecting and thwarting malicious activity on the
    system. In [Part III](part3.xhtml), I’ll continue this discussion by detailing
    the creation of fully featured tools built atop Endpoint Security.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Endpoint Security，这是macOS上编写安全工具的事实标准框架。我们通过订阅进程和文件事件的通知构建了基础的监控和检测工具。在下一章中，我将继续讨论Endpoint
    Security，但将重点介绍更高级的话题，如静音处理，以及ES_EVENT_TYPE_AUTH_*事件，这些事件提供了主动检测和阻止系统上恶意活动的机制。在[第三部分](part3.xhtml)，我将继续讨论，并详细介绍基于Endpoint
    Security构建的功能全面的工具的创建。
- en: Notes
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: '[  1](#chapter8_1).  “Endpoint Security,” Apple Developer Documentation, [*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/endpointsecurity*](https://developer.apple.com/documentation/endpointsecurity).'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  1](#chapter8_1)。 “Endpoint Security”，Apple开发者文档，[*https://<wbr>developer<wbr>.apple<wbr>.com<wbr>/documentation<wbr>/endpointsecurity*](https://developer.apple.com/documentation/endpointsecurity)。'
- en: '[  2](#chapter8_2).  You can read more about eslogger in its man pages or in
    “Blue Teaming on macOS with eslogger,” CyberReason, October 3, 2022, [*https://<wbr>www<wbr>.cybereason<wbr>.com<wbr>/blog<wbr>/blue<wbr>-teaming<wbr>-on<wbr>-macos<wbr>-with<wbr>-eslogger*](https://www.cybereason.com/blog/blue-teaming-on-macos-with-eslogger).'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  2](#chapter8_2)。你可以在其手册页或在《Blue Teaming on macOS with eslogger》一文中了解更多关于eslogger的内容，CyberReason，2022年10月3日，[*https://<wbr>www<wbr>.cybereason<wbr>.com<wbr>/blog<wbr>/blue<wbr>-teaming<wbr>-on<wbr>-macos<wbr>-with<wbr>-eslogger*](https://www.cybereason.com/blog/blue-teaming-on-macos-with-eslogger)。'
- en: '[  3](#chapter8_3).  You can read about this malware in Patrick Wardle, “Ironing
    Out (the macOS) Details of a Smooth Operator (Part II),” Objective-See, April
    1, 2023, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x74<wbr>.html*](https://objective-see.org/blog/blog_0x74.html).'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  3](#chapter8_3)。你可以在Patrick Wardle的《Ironing Out (the macOS) Details of a
    Smooth Operator (Part II)》一文中了解更多关于此恶意软件的信息，Objective-See，2023年4月1日，[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x74<wbr>.html*](https://objective-see.org/blog/blog_0x74.html)。'
- en: '[  4](#chapter8_4).  For more information on macOS LOLBins, see the Living
    Off the Orchard: macOS Binaries (LOOBins) repository on GitHub: [*https://<wbr>github<wbr>.com<wbr>/infosecB<wbr>/LOOBins*](https://github.com/infosecB/LOOBins).'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  4](#chapter8_4)。有关macOS LOLBins的更多信息，请参阅GitHub上的Living Off the Orchard:
    macOS Binaries (LOOBins)库：[*https://<wbr>github<wbr>.com<wbr>/infosecB<wbr>/LOOBins*](https://github.com/infosecB/LOOBins)。'
- en: '[  5](#chapter8_5).  Patrick Wardle, “The LockBit Ransomware (Kinda) Comes
    for macOS,” Objective-See, April 16, 2023, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x75<wbr>.html*](https://objective-see.org/blog/blog_0x75.html).'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  5](#chapter8_5).  Patrick Wardle，“LockBit 勒索软件（有点）袭击 macOS，”Objective-See，2023年4月16日，[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x75<wbr>.html*](https://objective-see.org/blog/blog_0x75.html)。'
- en: '[  6](#chapter8_6).  Patrick Wardle, “Towards Generic Ransomware Detection,”
    Objective -See, April 20, 2016, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x0F<wbr>.html*](https://objective-see.org/blog/blog_0x0F.html).'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  6](#chapter8_6).  Patrick Wardle，“面向通用勒索软件检测，”Objective-See，2016年4月20日，[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x0F<wbr>.html*](https://objective-see.org/blog/blog_0x0F.html)。'
- en: '[  7](#chapter8_7).  To read more about creating a full file monitor, see Patrick
    Wardle, “Writing a File Monitor with Apple’s Endpoint Security Framework,” Objective-See,
    September 17, 2019, [*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x48<wbr>.html*](https://objective-see.org/blog/blog_0x48.html).
    See also [Chapter 11](chapter11.xhtml), which discusses the BlockBlock tool.'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '[  7](#chapter8_7).  要了解更多关于创建完整文件监视器的信息，请参阅 Patrick Wardle，“使用 Apple 的 Endpoint
    Security 框架编写文件监视器，”Objective-See，2019年9月17日，[*https://<wbr>objective<wbr>-see<wbr>.org<wbr>/blog<wbr>/blog<wbr>_0x48<wbr>.html*](https://objective-see.org/blog/blog_0x48.html)。另请参见[第11章](chapter11.xhtml)，其中讨论了
    BlockBlock 工具。'
