- en: '![](../images/pg2.jpg)'
  id: totrans-0
  prefs: []
  type: TYPE_IMG
- en: <samp class="SANS_Futura_Std_Book_Oblique_I_11">[Description](description-02.xhtml)</samp>
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: <hgroup>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_B_11">1</samp> <samp class="SANS_Dogma_OT_Bold_B_11">A
    MINIMAL COMPILER</samp>
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: </hgroup>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/opener-img.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll write a minimal compiler that can handle only the simplest
    C programs. You’ll learn how to read a simple assembly program, and you’ll implement
    four basic compiler passes that you’ll build on throughout the rest of the book.
    Let’s start by looking at these compiler passes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Four Compiler Passes</samp>
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The compiler you write in this chapter will process source code in four stages:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: The *lexer* breaks up the source code into a list of *tokens*. Tokens are the
    smallest syntactic units of a program; they include delimiters, arithmetic symbols,
    keywords, and identifiers. If a program is like a book, tokens are like individual
    words.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *parser* converts the list of tokens into an *abstract syntax tree (AST)*,
    which represents the program in a form we can easily traverse and analyze.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *assembly generation* pass converts the AST into assembly. At this stage,
    we still represent the assembly instructions in a data structure that the compiler
    can understand, not as text.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *code emission* pass writes the assembly code to a file so the assembler
    and linker can turn it into an executable.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a typical way of structuring a compiler, although the exact stages and
    intermediate representations vary. It’s also overkill for this chapter—you could
    compile the programs you’ll handle here in just one pass—but setting up this structure
    now makes it easier to expand your compiler in future chapters. As you implement
    more language features, you’ll extend these compiler stages and add a few new
    ones. Each chapter starts with a current diagram of the compiler’s architecture,
    including the stages you’ve already implemented and any you need to add. This
    chapter’s diagram shows the four stages you’re about to implement. In the diagrams
    for later chapters, new stages will be bolded.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Before you start coding, let’s take a quick look at how to compile C to assembly
    with the C compiler already installed on your system, and how to read assembly
    programs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Hello, Assembly!</samp>
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest C program looks like [Listing 1-1](chapter1.xhtml#list1-1).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-1: A simple program
    that returns the number 2</samp>'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: 'This program consists of a single function, <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>,
    containing a single <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement, which returns an integer (in this case, <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>).
    Save this program as *return_2.c*, then use the <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp>
    command to translate it into assembly:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you’re using macOS, this command may invoke Clang instead of GCC, but the
    command line options have the same effect. These options produce fairly readable
    assembly:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-S</samp> Don’t run the assembler
    or linker. This makes the compiler emit assembly instead of a binary file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-O</samp> Optimize the code. This
    eliminates some instructions we aren’t concerned with right now.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-fno-asynchronous-unwind-tables</samp> Don’t
    generate the unwind table, which is used for debugging. We don’t need it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_TheSansMonoCd_W7Bold_B_11">-fcf-protection=none</samp> Disable
    control-flow protection, a security feature that adds extra instructions we aren’t
    concerned with. Control-flow protection might already be disabled by default on
    your system, in which case this option won’t do anything. Skip this option if
    you’re using an old version of GCC or Clang that doesn’t support it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The result, stored in *return_2.s*, should look similar to [Listing 1-2](chapter1.xhtml#list1-2).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-2: The program from
    [Listing 1-1](chapter1.xhtml#list1-1) translated into assembly</samp>'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Your *.s* file might contain a few other lines, but you can safely ignore them
    for now. The four lines in [Listing 1-2](chapter1.xhtml#list1-2) are a complete
    assembly program. Assembly programs have several kinds of statements. The first
    line, <samp class="SANS_TheSansMonoCd_W5Regular_11">.globl main</samp>, is an
    *assembler directive*, a statement that provides directions for the assembler.
    Assembler directives always start with a period. Here, <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    is a *symbol*, a name for a memory address. Symbols appear in assembly instructions
    as well as assembler directives; for example, the instruction <samp class="SANS_TheSansMonoCd_W5Regular_11">jmp
    main</samp> jumps to whatever address the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    symbol refers to.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">.globl main</samp> directive
    tells the assembler that <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    is a *global* symbol. By default, you can use a symbol only in the same assembly
    file (and therefore the same object file) where it’s defined. But because <samp
    class="SANS_TheSansMonoCd_W5Regular_11">main</samp> is global, other object files
    can refer to it too. The assembler records this fact in a section of the object
    file called the *symbol table*, which the linker uses when it links object files
    together. The symbol table contains information about all the symbols in an object
    file or executable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: On the second line, we use <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    as a *label* for the code that follows it. Labels consist of a string or number
    followed by a colon. A label marks the location that a symbol refers to. This
    particular label defines <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    as the address of the <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp>
    instruction on the following line. The assembler doesn’t know this instruction’s
    final memory address, but it knows what *section* of the object file it’s in,
    as well as its offset from the start of that section. (An object file is made
    up of several sections that hold various kinds of data; there are separate sections
    for machine instructions, global variables, debug information, and so on. Different
    sections are loaded into different parts of the program’s address space at runtime.)
    The address of <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> will
    be in the *text section*, which contains machine instructions. Because <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    refers to the very first machine instruction in this assembly file, its offset
    within the text section is 0\. The assembler records this offset in the symbol
    table.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction on
    the next line is a *machine instruction*, which appears in the final executable.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> instruction in [Listing
    1-2](chapter1.xhtml#list1-2) moves the value <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    into a *register*, which is a very small and fast storage slot that has its own
    name and sits right on the CPU. Here, we move <samp class="SANS_TheSansMonoCd_W5Regular_11">2</samp>
    into the register named EAX, which can hold 32 bits. According to our platform’s
    calling convention, return values are passed to the caller in EAX (or RAX, the
    64-bit equivalent, depending on the return value’s type). Since the caller also
    knows about this convention, it can retrieve the return value from EAX after the
    function returns. The <samp class="SANS_TheSansMonoCd_W5Regular_11">l</samp> suffix
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> indicates that the
    operands to this instruction are *longwords*, or 32-bit integers (in x64 assembly,
    unlike most modern implementations of C, *long* means 32 bits). A <samp class="SANS_TheSansMonoCd_W5Regular_11">movq</samp>
    instruction operates on *quadwords*, or 64-bit integers. I’ll just write <samp
    class="SANS_TheSansMonoCd_W5Regular_11">mov</samp> when I want to refer to this
    instruction without specifying its size.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have another machine instruction, <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>,
    which returns control to the caller. You might see <samp class="SANS_TheSansMonoCd_W5Regular_11">retq</samp>
    here instead of <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>, since
    this instruction implicitly operates on a 64-bit return address. I’m skipping
    a lot of details, including what calling conventions are, who decides on them,
    and how <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp> knows where the
    caller is. I’ll revisit these when we add function calls in [Chapter 9](chapter9.xhtml).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Dogma_OT_Bold_B_39">NOTE</samp>
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*All the assembly listings in this book use AT&T syntax. Elsewhere, you might
    see x64 assembly written in Intel syntax. They’re two different notations for
    the same language; the biggest difference is that they put instruction operands
    in different orders.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, it’s fair to ask who the caller is, since <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    is the only function in this program. You might also wonder why we need the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">.globl main</samp> directive, since there
    don’t seem to be any other object files that could contain references to <samp
    class="SANS_TheSansMonoCd_W5Regular_11">main</samp>. The answer is that the linker
    adds a bit of wrapper code called <samp class="SANS_TheSansMonoCd_W5Regular_11">crt0</samp>
    to handle setup before <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    runs and teardown after it exits. (The <samp class="SANS_TheSansMonoCd_W5Regular_11">crt</samp>
    stands for *C Runtime*.) This wrapper code does the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Makes a function call to <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>.
    This is why <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> needs to
    be globally visible; if it isn’t, <samp class="SANS_TheSansMonoCd_W5Regular_11">crt0</samp>
    can’t call it.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieves the return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invokes the <samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp> system
    call, passing it the return value from <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>.
    Then, <samp class="SANS_TheSansMonoCd_W5Regular_11">exit</samp> handles whatever
    work needs to happen inside the operating system to terminate the process and
    turn the return value into an exit code.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The bottom line is that you don’t need to worry about process startup or teardown;
    you can treat <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp> like a
    normal function.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: The linker also associates each entry in the symbol table with a memory address
    through a process called *symbol resolution*. It then performs *relocation*, updating
    every place that uses a symbol to use the corresponding address instead. (Actually,
    the linking process is a lot more complicated than this! If you’d like to learn
    more, see “Additional Resources” on [page 21](#pg_21).)
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that the assembly in *return_2.s* works, assemble and link it, run
    it, and check the exit code with the <samp class="SANS_TheSansMonoCd_W5Regular_11">$?</samp>
    shell operator:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证*return_2.s*中的汇编代码是否有效，先汇编并链接它，然后运行，并使用<samp class="SANS_TheSansMonoCd_W5Regular_11">$?</samp>命令行操作符检查退出代码：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that you can pass an assembly file to the <samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp>
    command just like a regular source file. It assumes any input files with a *.s*
    extension contain assembly, so it assembles and links those files without trying
    to compile them first.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可以像普通源文件一样将汇编文件传递给<samp class="SANS_TheSansMonoCd_W5Regular_11">gcc</samp>命令。它假设所有扩展名为*.s*的输入文件都包含汇编代码，因此会直接汇编并链接这些文件，而不会先尝试编译它们。
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Compiler Driver</samp>
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <samp class="SANS_Futura_Std_Bold_B_11">编译器驱动程序</samp>
- en: 'As you learned in the [Introduction](introduction.xhtml), a compiler isn’t
    very useful on its own. You also need a *compiler driver* that calls the preprocessor,
    compiler, assembler, and linker. So, you’ll write a compiler driver before starting
    on the compiler itself. It should convert a source file to an executable in three
    steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[介绍](introduction.xhtml)中学到的，编译器单独并不十分有用。你还需要一个*编译器驱动程序*，它调用预处理器、编译器、汇编器和链接器。因此，你需要在开始编写编译器之前先编写一个编译器驱动程序。它应该通过三步将源文件转换为可执行文件：
- en: '1. Run this command to preprocess the source file:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 运行此命令以预处理源文件：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command preprocesses <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">INPUT_FILE</samp>
    and then writes the result to <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PREPROCESSED_FILE</samp>.
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">-E</samp> option tells GCC to
    run only the preprocessor, not the later steps of the compilation process. By
    default, the preprocessor emits *linemarkers* indicating the original source file,
    and the starting line number within that source file, for each part of the preprocessed
    output. (A preprocessed file might include code from multiple source files because
    of <samp class="SANS_TheSansMonoCd_W5Regular_11">#include</samp> directives.)
    The <samp class="SANS_TheSansMonoCd_W5Regular_11">-P</samp> option tells the preprocessor
    not to emit linemarkers; our lexer and parser won’t be able to process them. By
    convention, <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PREPROCESSED_FILE</samp>
    should have a *.i* file extension.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令首先对<samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">INPUT_FILE</samp>进行预处理，然后将结果写入<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PREPROCESSED_FILE</samp>。<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-E</samp>选项告诉GCC仅运行预处理器，而不执行编译过程的后续步骤。默认情况下，预处理器会生成*行标记*，指示原始源文件及该文件中每部分的起始行号。（由于<samp
    class="SANS_TheSansMonoCd_W5Regular_11">#include</samp>指令，预处理文件可能包含来自多个源文件的代码。）<samp
    class="SANS_TheSansMonoCd_W5Regular_11">-P</samp>选项告诉预处理器不生成行标记；我们的词法分析器和解析器将无法处理它们。按照惯例，<samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">PREPROCESSED_FILE</samp>文件应具有*.i*扩展名。
- en: 2. Compile the preprocessed source file and output an assembly file with a *.s*
    extension. You’ll have to stub out this step, since you haven’t written your compiler
    yet. Delete the preprocessed file when you’re done with it.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 编译预处理后的源文件，并生成一个扩展名为*.s*的汇编文件。你需要跳过这一步，因为你还没有编写编译器。完成后删除预处理文件。
- en: '3. Assemble and link the assembly file to produce an executable, using this
    command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 汇编并链接汇编文件，生成可执行文件，使用以下命令：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Delete the assembly file when you’re done with it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后删除汇编文件。
- en: 'Your compiler driver must have a specific command line interface so this book’s
    test script, *test_compiler*, can run it. It must be a command line program that
    accepts a path to a C source file as its only argument. If this command succeeds,
    it must produce an executable in the same directory as the input file, with the
    same name (minus the file extension). In other words, if you run <samp class="SANS_TheSansMonoCd_W5Regular_11">./</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11">YOUR_COMPILER /path/to/program.c</samp>,
    it should produce an executable at */path/to/program* and terminate with an exit
    code of 0\. If your compiler fails, the compiler driver should return a nonzero
    exit code and shouldn’t write any assembly or executable files; that’s how *test_compiler*
    verifies that your compiler catches errors in invalid programs. Finally, your
    compiler driver should support the following options, which *test_compiler* uses
    to test intermediate stages:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--lex</samp> | Directs it to
    run the lexer, but stop before parsing |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--parse</samp> | Directs it
    to run the lexer and parser, but stop before assembly generation |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">--codegen</samp> | Directs it
    to perform lexing, parsing, and assembly generation, but stop before code emission
    |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
- en: None of these options should produce any output files, and all should terminate
    with an exit code of 0 if they don’t hit any errors. You might also want to add
    a <samp class="SANS_TheSansMonoCd_W5Regular_11">-S</samp> option that directs
    your compiler to emit an assembly file, but not assemble or link it. You’ll need
    this option to run the tests in [Part III](part3.xhtml); it isn’t required for
    [Parts I](part1.xhtml) and [II](part2.xhtml), but it’s useful for debugging.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve written the compiler driver, you’re ready to start working on the
    actual compiler. You need to implement the four compiler passes listed at the
    beginning of the chapter: the lexer, which produces a list of tokens; the parser,
    which turns those tokens into an abstract syntax tree; the assembly generation
    pass, which converts the abstract syntax tree into assembly; and the code emission
    pass, which writes that assembly to a file. Let’s start with the lexer.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Lexer</samp>
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The lexer should read in a source file and produce a list of tokens. Before
    you can start writing the lexer, you need to know what tokens you might encounter.
    Here are all the tokens in [Listing 1-1](chapter1.xhtml#list1-1):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">int</samp> | A keyword |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">main</samp> | An identifier,
    whose value is “main” |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">(</samp> | An open parenthesis
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">void</samp> | A keyword |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">)</samp> | A close parenthesis
    |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">{</samp> | An open brace |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">return</samp> | A keyword |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">2</samp> | A constant, whose
    value is “2” |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">;</samp> | A semicolon |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W7Bold_B_11">}</samp> | A close brace |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
- en: I’ve used two lexer-specific terms here. An *identifier* is an ASCII letter
    or underscore followed by a mix of letters, underscores, and digits. Identifiers
    are case sensitive. An integer *constant* consists of one or more digits. (We’ll
    add character and floating-point constants in [Part II](part2.xhtml). We won’t
    implement hexadecimal or octal integer constants in this book.)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Note that the identifier and constant in this list of tokens have values, but
    the other types of tokens don’t. There are many possible identifiers (for example,
    <samp class="SANS_TheSansMonoCd_W5Regular_11">foo</samp>, <samp class="SANS_TheSansMonoCd_W5Regular_11">variable1</samp>,
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">my_cool_function</samp>), so
    each identifier token produced by the lexer must retain its specific name. Likewise,
    each constant token needs to hold an integer value. By contrast, there’s only
    one possible <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> keyword,
    so a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> keyword token
    doesn’t need to store any extra information. Even though <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    is the only identifier right now, you should build the lexer to support arbitrary
    identifiers later on. Also note that there are no whitespace tokens. If we were
    compiling a language like Python, where whitespace is significant, we’d need to
    include whitespace tokens.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: You can recognize each token type with a regular expression, or regex. [Table
    1-1](chapter1.xhtml#tab1-1) gives the corresponding regular expression for each
    token in Perl Compatible Regular Expressions (PCRE) syntax.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-1:</samp> <samp class="SANS_Futura_Std_Book_11">Tokens
    and Their Regular Expressions</samp>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Token</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Regular
    expression</samp> |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Identifier</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">[a-zA-Z_]\w*\b</samp>
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Constant</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">[0-9]+\b</samp>
    |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp> <samp class="SANS_Futura_Std_Book_11">keyword</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">int\b</samp> |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">void</samp> <samp class="SANS_Futura_Std_Book_11">keyword</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">void\b</samp> |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> <samp class="SANS_Futura_Std_Book_11">keyword</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">return\b</samp> |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Open parenthesis</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\(</samp>
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Close parenthesis</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">\)</samp>
    |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Open brace</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">{</samp>
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Close brace</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">}</samp>
    |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_Futura_Std_Book_11">Semicolon</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp>
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
- en: The process of tokenizing a program looks roughly like [Listing 1-3](chapter1.xhtml#list1-3).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-3: Converting a string
    to a sequence of tokens</samp>'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Note that identifiers, keywords, and constants must end at word boundaries,
    indicated by <samp class="SANS_TheSansMonoCd_W5Regular_11">\b</samp>. For example,
    the first three digits of <samp class="SANS_TheSansMonoCd_W5Regular_11">123;bar</samp>
    match the regular expression for a constant, and you should convert them into
    the constant <samp class="SANS_TheSansMonoCd_W5Regular_11">123</samp>. This is
    because <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> isn’t in the <samp
    class="SANS_TheSansMonoCd_W5Regular_11">\w</samp> character class, so the boundary
    between <samp class="SANS_TheSansMonoCd_W5Regular_11">3</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp>
    is a word boundary. However, the first three digits of <samp class="SANS_TheSansMonoCd_W5Regular_11">123bar</samp>
    don’t match the regular expression for a constant, because those digits are followed
    by more characters in the <samp class="SANS_TheSansMonoCd_W5Regular_11">\w</samp>
    character class instead of a word boundary. If your lexer sees a string like <samp
    class="SANS_TheSansMonoCd_W5Regular_11">123bar</samp>, it should raise an error,
    as the start of the string doesn’t match the regular expression for any token.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you’re ready to write your lexer. Here are a few tips to keep in mind:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '**Treat keywords like other identifiers.**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The regex for identifiers also matches keywords. Don’t try to simultaneously
    find the end of the next token and figure out whether it’s a keyword. First, find
    the end of the token. Then, if it looks like an identifier, check whether it matches
    any keywords.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '**Don’t split on whitespace.**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: It isn’t a good idea to start by splitting the string on whitespace, since whitespace
    isn’t the only boundary between tokens. For example, <samp class="SANS_TheSansMonoCd_W5Regular_11">main(void)</samp>
    has four tokens and no whitespace.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '**You only need to support ASCII characters.**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The test programs for this book contain only ASCII characters. The C standard
    provides a mechanism called *universal character names* to include non-ASCII characters
    in identifiers, but we won’t implement them. Many C implementations let you use
    Unicode characters directly, but you don’t need to support that either.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve written your lexer, the next step is testing it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">The Parser</samp>
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that you have a list of tokens, you’ll figure out how those tokens are
    grouped together into language constructs. In most programming languages, including
    C, this grouping is hierarchical: each language construct in the program is composed
    of several simpler constructs. Individual tokens represent the most basic constructs,
    like variables, constants, and arithmetic operators. Tree data structures are
    a natural way to express this hierarchical relationship. As I mentioned at the
    start of this chapter, the parser will accept the list of tokens produced by the
    lexer and generate a tree representation called an abstract syntax tree. After
    the parser has created the AST, the assembly generation stage will traverse it
    to figure out what assembly code to emit.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two approaches to writing a parser: you can write it by hand, or
    you can use a *parser generator* like Bison or ANTLR to produce your parsing code
    automatically. Using a parser generator is less work, but this book uses a handwritten
    parser. There are a few reasons for this. Most importantly, handwriting a parser
    provides you with a solid understanding of how your parser works. It’s easy to
    use a parser generator without fully understanding the code it produces. Many
    parser generators also have a steep learning curve, and you’re better off learning
    general techniques like recursive descent parsing *before* you spend time mastering
    specific tools.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Handwritten parsers also have some practical advantages over those produced
    by parser generators: they can be faster and easier to debug, they’re more flexible,
    and they provide better support for error handling. In fact, both GCC and Clang
    use handwritten parsers, which shows that writing a parser by hand isn’t just
    an academic exercise.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: That said, if you’d rather use a parser generator, that’s fine too. It all depends
    on what you’re hoping to get out of this book. Note, however, that I won’t talk
    about how to use those tools, so you’ll have to figure that out on your own. If
    you go that route, make sure to research what parsing libraries are available
    in your implementation language of choice.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Whichever option you choose, you’ll need to design the abstract syntax tree
    your parser should produce. Let’s start by taking a look at an example of an AST.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">An Example Abstract
    Syntax Tree</samp>
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Consider the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement
    in [Listing 1-4](chapter1.xhtml#list1-4).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-4: A simple</samp>
    <samp class="SANS_Futura_Std_Book_Oblique_I_11">if</samp> <samp class="SANS_Futura_Std_Book_Oblique_I_11">statement</samp>'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'The root node of the corresponding AST represents the whole <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statement. This node has two children:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: The condition, <samp class="SANS_TheSansMonoCd_W5Regular_11">a < b</samp>
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The statement body, <samp class="SANS_TheSansMonoCd_W5Regular_11">return 2</samp>
    <samp class="SANS_TheSansMonoCd_W5Regular_11">+</samp> <samp class="SANS_TheSansMonoCd_W5Regular_11">2;</samp>
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Each of these constructs can be broken down further. For example, the condition
    is a binary operation with three children:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The left operand, variable <samp class="SANS_TheSansMonoCd_W5Regular_11">a</samp>
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The operator, <samp class="SANS_TheSansMonoCd_W5Regular_11"><</samp>
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The right operand, variable <samp class="SANS_TheSansMonoCd_W5Regular_11">b</samp>
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Figure 1-1](#fig1-1) shows the whole AST for this code snippet, with an <samp
    class="SANS_TheSansMonoCd_W5Regular_11">If</samp> AST node representing the root
    of the <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, a <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Binary</samp> node representing the condition,
    and so on.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig1-1.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-1: An AST for a simple
    if statement [Description](description-03.xhtml)</samp>'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'The AST in [Figure 1-1](#fig1-1) contains the same information as [Listing
    1-4](chapter1.xhtml#list1-4): it shows what actions the program will take, and
    in what order. But unlike [Listing 1-4](chapter1.xhtml#list1-4), this AST presents
    that information in a way your compiler can easily work with. In later stages,
    the compiler will traverse the tree, performing a different action at each type
    of node it encounters. Your compiler will use this general strategy to accomplish
    a bunch of different tasks, from resolving variable names to generating assembly.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at the AST for the C program from [Listing 1-1](chapter1.xhtml#list1-1).
    [Figure 1-2](#fig1-2) shows this much simpler AST.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![](../images/fig1-2.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Figure 1-2: The AST for [Listing
    1-1](chapter1.xhtml#list1-1) [Description](description-04.xhtml)</samp>'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll define the necessary data structures to construct ASTs like [Figure
    1-2](#fig1-2) in code.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The AST Definition</samp>
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This book gives AST descriptions in a language designed for specifying ASTs,
    the *Zephyr Abstract Syntax Description Language (ASDL)*. I’m using ASDL here
    as convenient, programming language–neutral notation. You won’t use ASDL directly
    in your compiler; instead, you’ll define equivalent data structures in your chosen
    implementation language. The next few paragraphs include a very brief overview
    of ASDL. You can find a link to the original paper, which describes the whole
    language, in “Additional Resources” on [page 21](#pg_21).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-5](chapter1.xhtml#list1-5) has the ASDL definition for the tiny
    subset of C you’ll implement in this chapter (programs like [Listing 1-1](chapter1.xhtml#list1-1)).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-5: The abstract syntax
    tree definition for this chapter</samp>'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line in [Listing 1-5](chapter1.xhtml#list1-5) describes how to build one
    type of AST node. Note that every AST node in [Figure 1-2](#fig1-2) has a corresponding
    definition in ASDL. The root of this AST is the <samp class="SANS_TheSansMonoCd_W5Regular_11">program</samp>
    node. At the moment, this node can have exactly one child, of type <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>.
    A function definition has two children: a function name, of type <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier</samp>,
    and a function body, of type <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>.
    Right now, a function consists of a single statement and has no arguments. Later,
    you’ll add support for function arguments and more complex function bodies. Note
    that <samp class="SANS_TheSansMonoCd_W5Regular_11">name</samp> and <samp class="SANS_TheSansMonoCd_W5Regular_11">body</samp>
    in this definition are *field names*, human-friendly labels that don’t change
    the structure of the AST. Field names are optional in ASDL. When a field name
    is present, it comes immediately after the field type, like in <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier
    name</samp>.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'In ASDL, <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier</samp> is
    a built-in type that represents function and variable names; they’re basically
    strings, but we want to distinguish them from string literals like <samp class="SANS_TheSansMonoCd_W5Regular_11">"Hello,
    World!"</samp> because they appear in different parts of an AST. Since <samp class="SANS_TheSansMonoCd_W5Regular_11">identifier</samp>
    is a built-in type, it has no children. The other child of the <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>
    node is <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>. Right
    now, the only kind of statement is a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    statement. This statement has one child: its return value, of type <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>,
    short for *expression*. The only <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp>
    at the moment is a constant integer; <samp class="SANS_TheSansMonoCd_W5Regular_11">int</samp>
    is another built-in ASDL type, so the AST is finished.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statements
    aren’t the only statements in C, and constants aren’t the only expressions. In
    later chapters, we’ll add new constructors to represent the other kinds of statements
    and expressions. For example, we’ll add an <samp class="SANS_TheSansMonoCd_W5Regular_11">If</samp>
    constructor to <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>
    to represent <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The <samp class="SANS_TheSansMonoCd_W5Regular_11">statement?</samp> type indicates
    an optional statement, since <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp>
    statements don’t always have an <samp class="SANS_TheSansMonoCd_W5Regular_11">else</samp>
    clause. The <samp class="SANS_TheSansMonoCd_W5Regular_11">|</samp> symbol separates
    constructors. Here, it tells us that a <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>
    can be either a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement,
    defined by the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp> constructor,
    or an <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statement, defined
    by the <samp class="SANS_TheSansMonoCd_W5Regular_11">If</samp> constructor.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s your turn to implement the AST definition in [Listing 1-5](chapter1.xhtml#list1-5)
    in whatever language you’re using to write your compiler. The standard way to
    represent ASTs varies between programming languages. If you’re implementing your
    compiler in a functional language like F#, ML, or Haskell, you can define the
    AST using algebraic data types. Enums in Rust are basically algebraic data types,
    so they can also represent ASTs. If you’re using an object-oriented language like
    Java, you can define an abstract class for each type of node, then define classes
    that extend or inherit from those abstract classes for each constructor. For example,
    you might define an <samp class="SANS_TheSansMonoCd_W5Regular_11">Exp</samp> abstract
    class and <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant</samp> and <samp
    class="SANS_TheSansMonoCd_W5Regular_11">BinaryExp</samp> classes that extend it.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: If you’re still not sure how to write an AST definition, check out “Additional
    Resources” on [page 21](#pg_21).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">The Formal Grammar</samp>
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: An AST has all the information you’ll need in later stages of the compiler.
    It does not, however, tell you exactly what tokens make up each language construct.
    For example, nothing in the AST description in [Listing 1-5](chapter1.xhtml#list1-5)
    says that a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp> statement
    must end with a semicolon or that a function body needs to be enclosed in braces.
    (This is why it’s called an *abstract* syntax tree—by contrast, a *concrete* syntax
    tree includes every token from the original input.) Once you have an AST, those
    specific details are irrelevant, so it’s convenient to leave them out. When you’re
    parsing a sequence of tokens to construct your AST, though, those details matter
    a lot because they indicate where each language construct begins and ends.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: So, in addition to an AST description, you need a set of rules defining how
    to build a language construct from a list of tokens. This ruleset is called a
    *formal grammar*, and it corresponds closely to the AST description. [Listing
    1-6](chapter1.xhtml#list1-6) defines the formal grammar for C programs like [Listing
    1-1](chapter1.xhtml#list1-1).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-6: The formal grammar
    for this chapter</samp>'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'The grammar in [Listing 1-6](chapter1.xhtml#list1-6) is in *extended Backus-Naur
    form (EBNF)* notation. Each line of this grammar is a *production rule* that defines
    how a language construct can be formed from a sequence of other language constructs
    and tokens. Every symbol that appears on the left-hand side of a production rule
    (like <samp class="SANS_TheSansMonoCd_W5Regular_11"><function></samp>) is a *non-terminal
    symbol*. Individual tokens, like keywords, identifiers, and punctuation, are *terminal
    symbols*. All non-terminal symbols are wrapped in angle brackets, and specific
    tokens (like <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp>) are wrapped
    in quotation marks. The <samp class="SANS_TheSansMonoCd_W5Regular_11"><identifier></samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11"><int></samp> symbols represent
    individual identifier and constant tokens, respectively. Since these tokens aren’t
    fixed strings like the other terminal symbols, we describe each of them using
    a *special sequence*: a plain English description of the symbol, wrapped in question
    marks.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[Listing 1-6](chapter1.xhtml#list1-6) looks a lot like the AST definition in
    [Listing 1-5](chapter1.xhtml#list1-5). In fact, it has the same structure; every
    AST node in [Listing 1-5](chapter1.xhtml#list1-5) corresponds to a non-terminal
    symbol in [Listing 1-6](chapter1.xhtml#list1-6). The only difference is that [Listing
    1-6](chapter1.xhtml#list1-6) specifies exactly which tokens we’ll find at each
    node of the tree, which helps us figure out when we need to start processing a
    new node at the next level down in the AST, and when we’ve finished processing
    a node and can go back up to its parent on the level above.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as later chapters will introduce multiple constructors for some AST nodes,
    they’ll also introduce multiple production rules for the corresponding symbols.
    For example, here’s how you’ll add a production rule for <samp class="SANS_TheSansMonoCd_W5Regular_11"><statement></samp>
    to support <samp class="SANS_TheSansMonoCd_W5Regular_11">if</samp> statements:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that square brackets in EBNF indicate that something is optional, just
    like question marks in ASDL.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: You’ll refer to this formal grammar while writing the parser, but you won’t
    explicitly define these grammar rules anywhere in your compiler.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_Condensed_Oblique_BI_11">Recursive Descent
    Parsing</samp>
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that you have an AST definition and a formal grammar, let’s talk about how
    to actually write the parser. We’ll use a straightforward technique called *recursive
    descent parsing*, which uses a different function to parse each non-terminal symbol
    and return the corresponding AST node. For example, when the parser expects to
    encounter the <samp class="SANS_TheSansMonoCd_W5Regular_11"><statement></samp>
    symbol defined in [Listing 1-6](chapter1.xhtml#list1-6), it calls a function to
    parse that symbol and return the <samp class="SANS_TheSansMonoCd_W5Regular_11">statement</samp>
    AST node from [Listing 1-5](chapter1.xhtml#list1-5). The main parsing function
    parses the <samp class="SANS_TheSansMonoCd_W5Regular_11"><program></samp> symbol,
    which corresponds to the entire program. With each function call to handle a new
    symbol, the parser descends to a lower level in the tree. That’s where the *descent*
    in recursive descent comes from. (It’s called *recursive* descent because the
    grammar rules are often recursive, in which case the functions to process them
    are too. For example, the operand of an expression could be another expression;
    we’ll see an example of this in the next chapter.)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Let’s walk through one of these parsing functions. The pseudocode in [Listing
    1-7](chapter1.xhtml#list1-7) demonstrates how to parse a <samp class="SANS_TheSansMonoCd_W5Regular_11"><statement></samp>
    symbol.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-7: Parsing a statement</samp>'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'We call the <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_statement</samp>
    function when we expect the list of remaining tokens to start with a <samp class="SANS_TheSansMonoCd_W5Regular_11"><statement></samp>.
    According to [Listing 1-6](chapter1.xhtml#list1-6), a <samp class="SANS_TheSansMonoCd_W5Regular_11"><statement></samp>
    consists of three symbols: the <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    keyword, an <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp> symbol,
    and a <samp class="SANS_TheSansMonoCd_W5Regular_11">;</samp> token. First, we
    call a helper function, <samp class="SANS_TheSansMonoCd_W5Regular_11">expect</samp>,
    to verify that the first token really is a <samp class="SANS_TheSansMonoCd_W5Regular_11">return</samp>
    keyword. If it is, <samp class="SANS_TheSansMonoCd_W5Regular_11">expect</samp>
    discards it so we can move on to the next token. If it isn’t, we report a syntax
    error in the program. Next, we need to turn the <samp class="SANS_TheSansMonoCd_W5Regular_11"><exp></samp>
    symbol into an <samp class="SANS_TheSansMonoCd_W5Regular_11">exp</samp> AST node.
    Since this is a different non-terminal symbol, it should be handled by a separate
    function, <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>, which
    I haven’t defined here. We call <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_exp</samp>
    to get the AST node representing the return value; then we call <samp class="SANS_TheSansMonoCd_W5Regular_11">expect</samp>
    again to verify that this expression is followed by the last token, a semicolon.
    Finally, we construct the <samp class="SANS_TheSansMonoCd_W5Regular_11">Return</samp>
    AST node and return it.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Note that <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_statement</samp>
    removes all the tokens that made up the statement from the <samp class="SANS_TheSansMonoCd_W5Regular_11">tokens</samp>
    list. After <samp class="SANS_TheSansMonoCd_W5Regular_11">parse_statement</samp>
    returns, its caller keeps processing the remaining tokens in <samp class="SANS_TheSansMonoCd_W5Regular_11">tokens</samp>.
    If there are any tokens left after parsing the entire program, that’s a syntax
    error.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Right now, each symbol in the formal grammar has only one production rule. In
    later chapters, when some symbols have multiple production rules, the parser will
    need to figure out which production rule to use. It will do this by looking at
    the first few tokens in the list without removing them. Recursive descent parsers
    that look ahead a few tokens to figure out which production rule to use are called
    *predictive parsers.* The alternative to predictive parsing is *recursive descent
    with backtracking*, which involves trying each production rule in turn until you
    find one that works.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can write your own recursive descent parser. Remember that you’ll need
    to write one function to parse each non-terminal symbol in [Listing 1-6](chapter1.xhtml#list1-6).
    Here are a few tips to make it easier:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '**Write a pretty-printer.**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'A pretty-printer is a function that prints out your AST in a human-readable
    way. This will make debugging your parser a lot easier. A pretty-printed AST for
    the program in [Listing 1-1](chapter1.xhtml#list1-1) might look like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Give informative error messages.**'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: This will also help you debug your parser, and it will make your compiler more
    user-friendly too. An error message like <samp class="SANS_TheSansMonoCd_W5Regular_11">Expected
    ";" but found "return"</samp> is a lot more helpful than <samp class="SANS_TheSansMonoCd_W5Regular_11">Fail</samp>.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Assembly Generation</samp>
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The assembly generation stage should convert the AST into x64 assembly, traversing
    the AST in roughly the order the program executes to produce the appropriate assembly
    instructions for each node. First, define an appropriate data structure to represent
    the assembly program, just like you defined a data structure to represent the
    AST when you wrote the parser. You’re adding yet another data structure, instead
    of writing assembly to a file right away, so that you can modify the assembly
    code after you’ve generated it. You won’t need to rewrite any assembly in this
    chapter, but in later chapters you will.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: I’ll use ASDL again to describe the structure we’ll use to represent assembly.
    [Listing 1-8](chapter1.xhtml#list1-8) has the definition.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '<samp class="SANS_Futura_Std_Book_Oblique_I_11">Listing 1-8: The ASDL definition
    of an assembly program</samp>'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: This looks a lot like the AST definition from the last section! In fact, this
    *is* an AST definition, but for assembly programs, not C programs. Every node
    corresponds to a construct in assembly, like a single instruction, rather than
    a construct in C, like a statement. I’ll refer to the data structure defined in
    [Listing 1-8](chapter1.xhtml#list1-8) as the *assembly AST* to distinguish it
    from the AST defined in [Listing 1-5](chapter1.xhtml#list1-5).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s walk through [Listing 1-8](chapter1.xhtml#list1-8). The <samp class="SANS_TheSansMonoCd_W5Regular_11">program</samp>
    type represents a whole assembly program, which consists of a single <samp class="SANS_TheSansMonoCd_W5Regular_11">function_definition</samp>.
    A <samp class="SANS_TheSansMonoCd_W5Regular_11">function _definition</samp> has
    two fields: the function name and a list of instructions. The <samp class="SANS_TheSansMonoCd_W5Regular_11">*</samp>
    in <samp class="SANS_TheSansMonoCd_W5Regular_11">instruction*</samp> indicates
    that this field is a list. The <samp class="SANS_TheSansMonoCd_W5Regular_11">instruction</samp>
    type has two constructors to represent the two instructions that can appear in
    our assembly programs: <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    and <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>. The <samp class="SANS_TheSansMonoCd_W5Regular_11">mov</samp>
    instruction has two operands: it copies the first operand, the source, to the
    second operand, the destination. The <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    instruction doesn’t have any operands. The <samp class="SANS_TheSansMonoCd_W5Regular_11">operand</samp>
    type defines the two possible operands to an instruction: a register and an *immediate
    value*, or constant. For now, you don’t need to specify which register to operate
    on, because your generated code will use only EAX. You’ll refer to other registers
    in later chapters. This stage has a similar structure to the parser: you need
    a function to handle each type of AST node, which calls other functions to handle
    that node’s children. [Table 1-2](chapter1.xhtml#tab1-2) describes the assembly
    you should generate for each AST node.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-2:</samp> <samp class="SANS_Futura_Std_Book_11">Converting
    AST Nodes to Assembly</samp>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">AST node</samp> | <samp class="SANS_Futura_Std_Heavy_B_11">Assembly
    construct</samp> |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, body)</samp>
    | <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp>
    |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Return(exp)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Mov(exp, Register) Ret</samp> |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Constant(int)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp> |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
- en: This translation is pretty straightforward, but there are a couple of things
    to note. The first is that a single statement results in multiple assembly instructions.
    The second is that this translation works only if an expression can be represented
    as a single assembly operand. This is true right now because the only expression
    is a constant integer, but it won’t be once we add unary operators in the next
    chapter. At that point, your compiler will need to generate multiple instructions
    to calculate an expression and then figure out where that expression is stored
    in order to copy it into EAX.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Code Emission</samp>
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that your compiler can generate assembly instructions, the last step is
    writing those instructions to a file. This file will look a lot like the assembly
    program in [Listing 1-2](chapter1.xhtml#list1-2), but a couple of details vary
    by platform. First, if you’re on macOS, you should always add an underscore in
    front of the function name. For example, emit the label for the <samp class="SANS_TheSansMonoCd_W5Regular_11">main</samp>
    function as <samp class="SANS_TheSansMonoCd_W5Regular_11">_main</samp>. (Don’t
    add this underscore on Linux.)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, if you’re on Linux, you’ll need to add this line to the end of the
    file:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This line enables an important security hardening measure: it indicates that
    your code doesn’t need an *executable stack*. A region of memory is *executable*
    if the processor is permitted to execute machine instructions stored there. The
    *stack*, which you’ll learn more about in the next chapter, is a memory region
    that holds local variables and temporary values. It does not, under normal circumstances,
    hold machine instructions. Making the stack non-executable is a basic defense
    against certain security exploits, but this defense can’t be enabled for every
    program, because a few programs that use certain nonstandard language extensions
    actually need an executable stack. Including this line in an assembly file signals
    that it does *not* require an executable stack, which allows this security measure
    to be enabled. None of the code we generate in this book will require an executable
    stack, so we’ll always emit this line. (For more about executable stacks, see
    “Additional Resources” on [page 21](#pg_21).)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The code emission stage should traverse the assembly AST and print each construct
    it encounters, much like the assembly generation stage traverses the AST from
    [Listing 1-5](chapter1.xhtml#list1-5). Because the assembly AST corresponds so
    closely to the final assembly program, the code emission stage will be very simple,
    even as you add more functionality to the compiler in later chapters.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[Tables 1-3](chapter1.xhtml#tab1-3), [1-4](chapter1.xhtml#tab1-4), and [1-5](chapter1.xhtml#tab1-5)
    illustrate how to print each assembly construct.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-3:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Top-Level Assembly Constructs</samp>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly top-level construct</samp>
    | <samp class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Program(function_definition)</samp>
    | <samp class="SANS_Futura_Std_Book_11">Print out the function definition. On
    Linux, add at end of file:</samp>'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '|'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Function(name, instructions)</samp>
    |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-4:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Instructions</samp>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly instruction</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Mov(src, dst)</samp> | <samp
    class="SANS_TheSansMonoCd_W5Regular_11">movl</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><src></samp><samp
    class="SANS_TheSansMonoCd_W5Regular_11">,</samp> <samp class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><dst></samp>
    |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Ret</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">ret</samp>
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: <samp class="SANS_Futura_Std_Heavy_B_11">Table 1-5:</samp> <samp class="SANS_Futura_Std_Book_11">Formatting
    Assembly Operands</samp>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '| <samp class="SANS_Futura_Std_Heavy_B_11">Assembly operand</samp> | <samp
    class="SANS_Futura_Std_Heavy_B_11">Output</samp> |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Register</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">%eax</samp>
    |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
- en: '| <samp class="SANS_TheSansMonoCd_W5Regular_11">Imm(int)</samp> | <samp class="SANS_TheSansMonoCd_W5Regular_11">$</samp><samp
    class="SANS_TheSansMonoCd_W5Regular_Italic_I_11"><int></samp> |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: Make sure to include line breaks between instructions. You should also emit
    readable, well-formatted assembly code because you’ll spend a lot of time reading
    this assembly while you debug your compiler. You can make your assembly more readable
    by indenting every line except for labels, like in [Listing 1-2](chapter1.xhtml#list1-2).
    Consider including comments in your assembly programs too. A <samp class="SANS_TheSansMonoCd_W5Regular_11">#</samp>
    symbol in assembly comments out the rest of the line, similar to <samp class="SANS_TheSansMonoCd_W5Regular_11">//</samp>
    in C.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve implemented the code emission stage, you’ll be able to compile simple
    programs like [Listing 1-1](chapter1.xhtml#list1-1) into working executables.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Summary</samp>
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this chapter, you wrote a compiler that transforms a complete C program into
    an executable that runs on your computer. You learned how to interpret a program
    written in x64 assembly, a formal grammar in extended Backus-Naur form, and an
    AST definition in ASDL. The skills and concepts you learned in this chapter—and
    the four compiler stages you implemented—are the foundation for everything you’ll
    do in the rest of the book.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’ll add support for unary operators to your compiler.
    Along the way, you’ll learn how assembly programs manage the stack, and you’ll
    implement a new intermediate representation of the programs you compile to make
    them easier to analyze, transform, and optimize.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: <samp class="SANS_Futura_Std_Bold_B_11">Additional Resources</samp>
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about a few of the concepts introduced in this chapter, check
    out the following resources.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '**Linkers**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: “Beginner’s Guide to Linkers” by David Drysdale is a good starting point (*[https://<wbr>www<wbr>.lurklurk<wbr>.org<wbr>/linkers<wbr>/linkers<wbr>.html](https://www.lurklurk.org/linkers/linkers.html)*).
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ian Lance Taylor’s 20-part essay on linkers goes into a lot more depth. The
    first post is at *[https://<wbr>www<wbr>.airs<wbr>.com<wbr>/blog<wbr>/archives<wbr>/38](https://www.airs.com/blog/archives/38)*,
    and there’s a table of contents at *[https://<wbr>lwn<wbr>.net<wbr>/Articles<wbr>/276782<wbr>/](https://lwn.net/Articles/276782/)*.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Position Independent Code (PIC) in Shared Libraries,” a blog post by Eli Bendersky,
    provides an overview of how compilers, linkers, and assemblers work together to
    produce position-independent code, focusing on 32-bit machines (*[https://<wbr>eli<wbr>.thegreenplace<wbr>.net<wbr>/2011<wbr>/11<wbr>/03<wbr>/position<wbr>-independent<wbr>-code<wbr>-pic<wbr>-in<wbr>-shared<wbr>-libraries](https://eli.thegreenplace.net/2011/11/03/position-independent-code-pic-in-shared-libraries)*).
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Position Independent Code (PIC) in Shared Libraries on x64,” also by Eli Bendersky,
    builds on the previous article, focusing on 64-bit systems (*[https://<wbr>eli<wbr>.thegreenplace<wbr>.net<wbr>/2011<wbr>/11<wbr>/11<wbr>/position<wbr>-independent<wbr>-code<wbr>-pic<wbr>-in<wbr>-shared<wbr>-libraries<wbr>-on<wbr>-x64](https://eli.thegreenplace.net/2011/11/11/position-independent-code-pic-in-shared-libraries-on-x64)*).
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AST definitions**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: “Abstract Syntax Tree Implementation Idioms” by Joel Jones provides a good overview
    of how to implement ASTs in various programming languages (*[https://<wbr>hillside<wbr>.net<wbr>/plop<wbr>/plop2003<wbr>/Papers<wbr>/Jones<wbr>-ImplementingASTs<wbr>.pdf](https://hillside.net/plop/plop2003/Papers/Jones-ImplementingASTs.pdf)*).
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “The Zephyr Abstract Syntax Description Language” by Daniel Wang, Andrew Appel,
    Jeff Korn, and Christopher Serra is the original paper on ASDL. It includes examples
    of AST definitions in a few different languages (*[https://<wbr>www<wbr>.cs<wbr>.princeton<wbr>.edu<wbr>/~appel<wbr>/papers<wbr>/asdl97<wbr>.pdf](https://www.cs.princeton.edu/~appel/papers/asdl97.pdf)*).
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Executable stacks**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: “Executable Stack,” a blog post by Ian Lance Taylor, discusses which programs
    need executable stacks and describes how Linux systems figure out whether a program’s
    stack should be executable (*[https://<wbr>www<wbr>.airs<wbr>.com<wbr>/blog<wbr>/archives<wbr>/518](https://www.airs.com/blog/archives/518)*).
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
