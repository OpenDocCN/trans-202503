<html><head></head><body>
<h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_37"/><strong><span class="big">3</span><br/>BINARY ARITHMETIC AND BIT OPERATIONS</strong></h2>&#13;
<div class="image1"><img alt="Image" src="../images/comm1.jpg"/></div>&#13;
<p class="noindents">As <a href="ch02.xhtml#ch02">Chapter 2</a> explained, understanding how computers represent data in binary is a prerequisite to writing software that works well on them. Of equal importance is understanding how computers operate on binary data. That’s the focus of this chapter, which explores arithmetic, logical, and bit operations on binary data.</p>&#13;
<h3 class="h3" id="sec3_1"><strong>3.1 Arithmetic Operations on Binary and Hexadecimal Numbers</strong></h3>&#13;
<p class="noindent">Often, you need to manually operate on two binary (or hexadecimal) values in order to use the result in your source code. Although there are calculators that can compute such results, you should be able to perform simple arithmetic operations on binary operands by hand. Hexadecimal arithmetic is sufficiently painful that a hexadecimal calculator (or a software-based calculator <span epub:type="pagebreak" id="page_38"/>that supports hexadecimal operations, such as the Windows calculator, or a smartphone app) belongs on every programmer’s desk. Arithmetic operations on binary values, however, are easier than decimal arithmetic.</p>&#13;
<p class="indent">Knowing how to manually compute binary arithmetic results is essential because several important algorithms use these operations (or variants of them). This section describes how to manually add, subtract, multiply, and divide binary values, and how to perform various logical operations on them.</p>&#13;
<h4 class="h4" id="sec3_1_1"><strong><em>3.1.1 Adding Binary Values</em></strong></h4>&#13;
<p class="noindent">Adding two binary values is easy; there are only eight rules to learn:<sup><a href="footnotes.xhtml#fn3_1a" id="fn3_1">1</a></sup></p>&#13;
<ul>&#13;
<li class="noindent">0 + 0 = 0</li>&#13;
<li class="noindent">0 + 1 = 1</li>&#13;
<li class="noindent">1 + 0 = 1</li>&#13;
<li class="noindent">1 + 1 = 0 with carry</li>&#13;
<li class="noindent">Carry + 0 + 0 = 1</li>&#13;
<li class="noindent">Carry + 0 + 1 = 0 with carry</li>&#13;
<li class="noindent">Carry + 1 + 0 = 0 with carry</li>&#13;
<li class="noindent">Carry + 1 + 1 = 1 with carry</li>&#13;
</ul>&#13;
<p class="indent">Once you know these eight rules, you can add any two binary values together. Here’s a step-by-step example of binary addition:</p>&#13;
<pre>          0101<br/>&#13;
        + 0011<br/>&#13;
        ------<br/><br/>&#13;
Step 1: Add the LO bits (1 + 1 = 0 + carry).<br/>&#13;
            c<br/>&#13;
          0101<br/>&#13;
        + 0011<br/>&#13;
        ------<br/>&#13;
             0<br/><br/>&#13;
Step 2: Add the carry plus the bits in bit position 1 (carry + 0 + 1 = 0 + carry).<br/>&#13;
           c<br/>&#13;
          0101<br/>&#13;
        + 0011<br/>&#13;
        -------<br/>&#13;
            00<br/>&#13;
Step 3: Add the carry plus the bits in bit position 2 (carry + 1 + 0 = 0 + carry).<br/>&#13;
          c<br/>&#13;
          0101<br/>&#13;
        + 0011<br/>&#13;
        ------<br/>&#13;
           000<br/>&#13;
<span epub:type="pagebreak" id="page_39"/>Step 4: Add the carry plus the bits in bit position 3 (carry + 0 + 0 = 1).<br/>&#13;
          0101<br/>&#13;
        + 0011<br/>&#13;
        ------<br/>&#13;
          1000</pre>&#13;
<p class="indent">Here are some more examples:</p>&#13;
<pre>  1100_1101       1001_1111       0111_0111<br/>&#13;
+ 0011_1011     + 0001_0001     + 0000_1001<br/>&#13;
-----------     -----------     -----------<br/>&#13;
1_0000_1000       1011_0000       1000_0000</pre>&#13;
<h4 class="h4" id="sec3_1_2"><strong><em>3.1.2 Subtracting Binary Values</em></strong></h4>&#13;
<p class="noindent">Like addition, binary subtraction has eight rules:</p>&#13;
<ul>&#13;
<li class="noindent">0 – 0 = 0</li>&#13;
<li class="noindent">0 – 1 = 1 with a borrow</li>&#13;
<li class="noindent">1 – 0 = 1</li>&#13;
<li class="noindent">1 – 1 = 0</li>&#13;
<li class="noindent">0 – 0 – borrow = 1 with a borrow</li>&#13;
<li class="noindent">0 – 1 – borrow = 0 with a borrow</li>&#13;
<li class="noindent">1 – 0 – borrow = 0</li>&#13;
<li class="noindent">1 – 1 – borrow = 1 with a borrow</li>&#13;
</ul>&#13;
<p class="indent">Here’s a step-by-step example of binary subtraction:</p>&#13;
<pre>          0101<br/>&#13;
        - 0011<br/>&#13;
        ------<br/>&#13;
Step 1: Subtract the LO bits (1 – 1 = 0).<br/>&#13;
          0101<br/>&#13;
        - 0011<br/>&#13;
        ------<br/>&#13;
             0<br/>&#13;
Step 2: Subtract the bits in bit position 1 (0 – 1 = 1 + borrow).<br/>&#13;
          0101<br/>&#13;
        - 0011<br/>&#13;
           b<br/>&#13;
        ------<br/>&#13;
            10<br/><br/>&#13;
Step 3: Subtract the borrow and the bits in bit position 2 (1 – 0 – b = 0).<br/>&#13;
          0101<br/>&#13;
        - 0011<br/>&#13;
        ------<br/>&#13;
           010<br/>&#13;
<span epub:type="pagebreak" id="page_40"/>Step 4: Subtract the bits in bit position 3 (0 – 0 = 0).<br/>&#13;
          0101<br/>&#13;
        - 0011<br/>&#13;
        ------<br/>&#13;
          0010</pre>&#13;
<p class="indent">Here are some more examples:</p>&#13;
<pre>  1100_1101       1001_1111       0111_0111<br/>&#13;
- 0011_1011     - 0001_0001     - 0000_1001<br/>&#13;
-----------     -----------     -----------  <br/>&#13;
  1001_0010       1000_1110       0110_1110</pre>&#13;
<h4 class="h4" id="sec3_1_3"><strong><em>3.1.3 Multiplying Binary Values</em></strong></h4>&#13;
<p class="noindent">Multiplication of binary numbers is simple; it follows the same rules as decimal multiplication involving only 0s and 1s:</p>&#13;
<ul>&#13;
<li class="noindent">0 × 0 = 0</li>&#13;
<li class="noindent">0 × 1 = 0</li>&#13;
<li class="noindent">1 × 0 = 0</li>&#13;
<li class="noindent">1 × 1 = 1</li>&#13;
</ul>&#13;
<p class="indent">Here’s a step-by-step example of binary multiplication:</p>&#13;
<pre>      1010<br/>&#13;
   ×  0101<br/>&#13;
   -------<br/>&#13;
Step 1: Multiply the LO bit of the multiplier times the multiplicand.<br/>&#13;
      1010<br/>&#13;
   ×  0101<br/>&#13;
   -------<br/>&#13;
      1010    (1 × 1010)<br/><br/>&#13;
Step 2: Multiply bit 1 of the multiplier times the multiplicand.<br/>&#13;
      1010<br/>&#13;
   ×  0101<br/>&#13;
   -------<br/>&#13;
      1010    (1 × 1010)<br/>&#13;
      0000    (0 × 1010)<br/>&#13;
   -------<br/>&#13;
     01010    (partial sum)<br/><br/>&#13;
Step 3: Multiply bit 2 of the multiplier times the multiplicand.<br/>&#13;
      1010<br/>&#13;
   ×  0101<br/>&#13;
   -------<br/>&#13;
    001010    (previous partial sum)<br/>&#13;
    1010      (1 × 1010)<br/>&#13;
   -------<br/>&#13;
    110010    (partial sum)<br/><br/>&#13;
<span epub:type="pagebreak" id="page_41"/>Step 4: Multiply bit 3 of the multiplier times the multiplicand.<br/>&#13;
      1010<br/>&#13;
   ×  0101<br/>&#13;
   -------<br/>&#13;
    110010    (previous partial sum)<br/>&#13;
   0000       (0 × 1010)<br/>&#13;
   -------<br/>&#13;
   0110010    (product)</pre>&#13;
<h4 class="h4" id="sec3_1_4"><strong><em>3.1.4 Dividing Binary Values</em></strong></h4>&#13;
<p class="noindent">Binary division uses the same (longhand) division algorithm as decimal division. <a href="ch03.xhtml#ch03fig01">Figure 3-1</a> shows the steps in a decimal division problem.</p>&#13;
<div class="image"><img alt="image" src="../images/03fig01.jpg"/></div>&#13;
<p class="figcap"><a id="ch03fig01"/><em>Figure 3-1: Decimal division (3456/12)</em></p>&#13;
<p class="indent">This algorithm is easier in binary because at each step you don’t have to guess how many times 12 goes into the remainder or multiply 12 by your guess to obtain the amount to subtract. At each step in the binary algorithm, the divisor goes into the remainder exactly zero or one times. For example, consider the division of 27 (11011) by 3 (11) shown in <a href="ch03.xhtml#ch03fig02">Figure 3-2</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/03fig02.jpg"/></div>&#13;
<p class="figcap"><span epub:type="pagebreak" id="page_42"/><a id="ch03fig02"/><em>Figure 3-2: Longhand division in binary</em></p>&#13;
<h3 class="h3" id="sec3_2"><strong>3.2 Logical Operations on Bits</strong></h3>&#13;
<p class="noindent">There are four main logical operations we’ll need to perform on hexadecimal and binary numbers: AND, OR, XOR (exclusive-or), and NOT. In contrast to the arithmetic operations, a hexadecimal calculator isn’t necessary to perform these operations.</p>&#13;
<p class="indent">The logical AND, OR, and XOR operations accept two single-bit operands and compute the following results:</p>&#13;
<pre>AND:<br/>&#13;
            0 and 0 = 0<br/>&#13;
            0 and 1 = 0<br/>&#13;
            1 and 0 = 0<br/>&#13;
            1 and 1 = 1<br/><br/>&#13;
<span epub:type="pagebreak" id="page_43"/>OR:<br/>&#13;
            0 or 0 = 0<br/>&#13;
            0 or 1 = 1<br/>&#13;
            1 or 0 = 1<br/>&#13;
            1 or 1 = 1<br/><br/>&#13;
XOR:<br/>&#13;
            0 xor 0 = 0<br/>&#13;
            0 xor 1 = 1<br/>&#13;
            1 xor 0 = 1<br/>&#13;
            1 xor 1 = 0</pre>&#13;
<p class="indent"><a href="ch03.xhtml#ch03tab01">Tables 3-1</a>, <a href="ch03.xhtml#ch03tab02">3-2</a>, and <a href="ch03.xhtml#ch03tab03">3-3</a> show the <em>truth tables</em> for the AND, OR, and XOR operations, respectively. A truth table is just like the multiplication tables you encountered in elementary school. The values in the left column correspond to the left operand of the operation. The values in the top row correspond to the right operand. The result is at the intersection of the row and column (for a particular pair of operands).</p>&#13;
<p class="tabcap"><a id="ch03tab01"/><strong>Table 3-1:</strong> AND Truth Table</p>&#13;
<table class="table-all">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">AND</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="tabcap"><a id="ch03tab02"/><strong>Table 3-2:</strong> OR Truth Table</p>&#13;
<table class="table-all">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">OR</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="tabcap"><a id="ch03tab03"/><strong>Table 3-3:</strong> XOR Truth Table</p>&#13;
<table class="table-all">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">XOR</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<p class="indent">In plain English, the logical AND operation translates as, “If the first operand is 1 and the second operand is 1, the result is 1; otherwise the result is 0.” We could also state this as “If either or both operands are 0, the result is 0.” The logical AND operation is useful for forcing a 0 result. If one of the operands is 0, the result is 0 regardless of the value of the other operand. If one of the operands contains 1, then the result is the value of the other operand.</p>&#13;
<p class="indent">Colloquially, the logical OR operation is, “If the first operand or the second operand (or both) is 1, the result is 1; otherwise the result is 0.” This is also known as the <em>inclusive</em>-<em>OR</em> operation. If one of the operands to the logical-OR operation is 1, the result is 1. If an operand is 0, the result is the value of the other operand.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_44"/>In English, the logical XOR operation is, “If the first or second operand, but not both, is 1, the result is 1; otherwise, the result is 0.” If one of the operands is a 1, the result is the <em><a href="gloss01.xhtml#gloss01_126">inverse</a></em> of the other operand.</p>&#13;
<p class="indent">The logical NOT operation is <em>unary</em> (meaning it accepts only one operand). <a href="ch03.xhtml#ch03tab04">Table 3-4</a> is the truth table for the NOT operation. This operator inverts the value of its operand.</p>&#13;
<p class="tabcap"><a id="ch03tab04"/><strong>Table 3-4:</strong> NOT Truth Table</p>&#13;
<table class="table-all">&#13;
<colgroup>&#13;
<col style="width:30%"/>&#13;
<col style="width:35%"/>&#13;
<col style="width:35%"/>&#13;
</colgroup>&#13;
<tbody>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">NOT</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td class="table-b" style="vertical-align: top;"/>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">1</p></td>&#13;
<td class="table-b" style="vertical-align: top;"><p class="taba">0</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<h3 class="h3" id="sec3_3"><strong>3.3 Logical Operations on Binary Numbers and Bit Strings</strong></h3>&#13;
<p class="noindent">Because most programming languages manipulate groups of 8, 16, 32, or 64 bits, we need to extend the definition of these logical operations beyond single-bit operands to operate on a bit-by-bit (or <em><a href="gloss01.xhtml#gloss01_33">bitwise</a></em>) basis. Given two values, a bitwise logical function operates on bit 0 from both source operands, producing bit 0 in the result operand; it operates on bit 1 of both operands, producing bit 1 of the result; and so on. For example, if you want to compute the bitwise logical AND of two 8-bit numbers, you would logically AND each pair of bits in the two numbers:</p>&#13;
<pre>%1011_0101<br/>&#13;
%1110_1110<br/>&#13;
-----------<br/>&#13;
%1010_0100</pre>&#13;
<p class="indent">This bit-by-bit execution applies to the other logical operations as well. The ability to force bits to <code>0</code> or <code>1</code> using the logical AND and OR operations, and to invert bits using the logical XOR operation, is very important when you’re working with strings of bits (such as binary numbers). These operations let you selectively manipulate certain bits within a value while leaving other bits unaffected. For example, if you have an 8-bit binary value <em>X</em> and you want to guarantee that bits 4 through 7 contain <code>0</code>s, AND the value <em>X</em> with the binary value <code>%0000_1111</code>. This bitwise AND operation forces the HO 4 bits of <em>X</em> to <code>0</code> and leaves the LO 4 bits of <em>X</em> unchanged. Likewise, you could force the LO bit of <em>X</em> to <code>1</code> and invert bit number 2 of <em>X</em> by ORing <em>X</em> with <code>%0000_0001</code> and then exclusive-ORing (XORing) <em>X</em> with <code>%0000_0100</code>.</p>&#13;
<p class="indent">Manipulating bit strings with the logical AND, OR, and XOR operations is known as <em>masking</em>. This term originates from the fact that we can use certain values (<code>1</code> for AND, <code>0</code> for OR and XOR) to “mask out” or “mask in” certain bits in an operand while forcing other bits to <code>0</code>, <code>1</code>, or their inverse.</p>&#13;
<p class="indent">Several languages provide operators that let you compute the bitwise AND, OR, XOR, and NOT of their operands. The C/C++/Java/Swift language family uses the ampersand (<code>&amp;</code>) for bitwise AND, the pipe (<code>|</code>) for <span epub:type="pagebreak" id="page_45"/>bitwise OR, the caret (<code>^</code>) for bitwise XOR, and the tilde (<code>~</code>) for bitwise NOT, as shown here:</p>&#13;
<pre>// Here's a C/C++ example:<br/><br/>&#13;
    i = j &amp; k;    // Bitwise AND<br/>&#13;
    i = j | k;    // Bitwise OR<br/>&#13;
    i = j ^ k;    // Bitwise XOR<br/>&#13;
    i = ~j;       // Bitwise NOT</pre>&#13;
<p class="noindent">The Visual Basic and Free Pascal/Delphi languages let you use the <code>and</code>, <code>or</code>, <code>xor</code>, and <code>not</code> operators with integer operands. From 80x86 assembly language, you can use the <code>AND</code>, <code>OR</code>, <code>NOT</code>, and <code>XOR</code> instructions.</p>&#13;
<h3 class="h3" id="sec3_4"><strong>3.4 Useful Bit Operations</strong></h3>&#13;
<p class="noindent">Although bit operations may seem a bit abstract, they are quite useful for many non-obvious purposes. This section describes some of their useful properties in various languages.</p>&#13;
<h4 class="h4" id="sec3_4_1"><strong><em>3.4.1 Testing Bits in a Bit String Using AND</em></strong></h4>&#13;
<p class="noindent">You can use the bitwise AND operator to test individual bits in a bit string to see if they are <code>0</code> or <code>1</code>. If you logically AND a value with a bit string that contains a <code>1</code> in a certain bit position, the result of the AND will be <code>0</code> if the corresponding bit contains a <code>0</code>, and nonzero if that bit position contains <code>1</code>. Consider the following C/C++ code, which checks an integer value to see if it is odd or even by testing bit 0 of the integer:</p>&#13;
<pre>IsOdd = (<span class="EmpItalic1">ValueToTest</span> &amp; 1) != 0;</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_46"/>In binary form, here’s what this bitwise AND operation is doing:</p>&#13;
<pre>xxxx_xxxx_xxxx_xxxx_xxxx_xxxx_xxxx_xxxx  // Assuming <span class="EmpItalic1">ValueToTest</span> is 32 bits<br/>&#13;
0000_0000_0000_0000_0000_0000_0000_0001  // Bitwise AND with the value 1<br/>&#13;
---------------------------------------<br/>&#13;
0000_0000_0000_0000_0000_0000_0000_000x  // Result of bitwise AND</pre>&#13;
<p class="indent">The result is <code>0</code> if the LO bit of <span class="EmpItalic">ValueToTest</span> contains a <code>0</code> in bit position 0. The result is <code>1</code> if <span class="EmpItalic">ValueToTest</span> contains a <code>1</code> in bit position 1. This calculation ignores all other bits in <span class="EmpItalic">ValueToTest</span>.</p>&#13;
<h4 class="h4" id="sec3_4_2"><strong><em>3.4.2 Testing a Set of Bits for Zero/Not Zero Using AND</em></strong></h4>&#13;
<p class="noindent">You can also use the bitwise AND operator to see if all bits in a set are <code>0</code>. For example, one way to check if a number is evenly divisible by 16 is to see if the LO 4 bits are all <code>0</code>s. The following Free Pascal/Delphi statement uses the bitwise AND operator to accomplish this:</p>&#13;
<pre>IsDivisibleBy16 := (<span class="EmpItalic1">ValueToTest</span> and $f) = 0;</pre>&#13;
<p class="indent">In binary form, here’s what this bitwise AND operation is doing:</p>&#13;
<pre>xxxx_xxxx_xxxx_xxxx_xxxx_xxxx_xxxx_xxxx  // Assuming <span class="EmpItalic1">ValueToTest</span> is 32 bits<br/>&#13;
0000_0000_0000_0000_0000_0000_0000_1111  // Bitwise AND with $F<br/>&#13;
---------------------------------------<br/>&#13;
0000_0000_0000_0000_0000_0000_0000_xxxx  // Result of bitwise AND</pre>&#13;
<p class="indent">The result is <code>0</code> if and only if the LO 4 bits of <code>ValueToTest</code> are all <code>0</code>.</p>&#13;
<h4 class="h4" id="sec3_4_3"><strong><em>3.4.3 Comparing a Set of Bits Within a Binary String</em></strong></h4>&#13;
<p class="noindent">The AND and OR operations are particularly useful if you need to compare a subset of the bits in a binary value against some other value. For example, you might want to compare two 6-bit values found in bits 0, 1, 10, 16, 24, and 31 of a pair of 32-bit values. The trick is to set all the uninteresting bits to <code>0</code> and then compare the two results.<sup><a href="footnotes.xhtml#fn3_2a" id="fn3_2">2</a></sup></p>&#13;
<p class="indent">Consider the following three binary values; <code>x</code> denotes bits whose values we don’t care about:</p>&#13;
<pre>%1xxxxxx0xxxxxxx1xxxxx0xxxxxxxx10<br/>&#13;
%1xxxxxx0xxxxxxx1xxxxx0xxxxxxxx10<br/>&#13;
%1xxxxxx1xxxxxxx1xxxxx1xxxxxxxx11</pre>&#13;
<p class="indent">The first and second binary values (assuming we’re interested only in bits 31, 24, 16, 10, 1, and 0) are equal. If we compare either of the first two values against the third value, we’ll find that they are not equal. The third value is also greater than the first two. In C/C++ and assembly, this is how we could compare these values:</p>&#13;
<pre>// C/C++ example<br/><br/>&#13;
    if( (<span class="EmpItalic1">value1</span> &amp; 0x81010403) == (<span class="EmpItalic1">value2</span> &amp; 0x81010403))<br/>&#13;
    {<br/>&#13;
        // Do something if bits 31, 24, 16, 10, 1, and 0 of<br/>&#13;
        // <span class="EmpItalic1">value1</span> and <span class="EmpItalic1">value2</span> are equal<br/>&#13;
    }<br/><br/>&#13;
    if( (<span class="EmpItalic1">value1</span> &amp; 0x81010403) != (<span class="EmpItalic1">value3</span> &amp; 0x81010403))<br/>&#13;
    {<br/>&#13;
        // Do something if bits 31, 24, 16, 10, 1, and 0 of<br/>&#13;
        // <span class="EmpItalic1">value1</span> and <span class="EmpItalic1">value3</span> are not equal<br/>&#13;
    }<br/><br/>&#13;
// HLA/x86 assembly example:<br/><br/>&#13;
    mov( <span class="EmpItalic1">value1</span>, eax );        // EAX = <span class="EmpItalic1">value1</span><br/>&#13;
    and( $8101_0403, eax );   // Mask out unwanted bits in EAX<br/>&#13;
    mov( <span class="EmpItalic1">value2</span>, edx );        // EDX = <span class="EmpItalic1">value2</span><br/>&#13;
    and( $8101_0403, edx );   // Mask out the same set of unwanted bits in EDX<br/><br/>&#13;
<span epub:type="pagebreak" id="page_47"/>    if( eax = edx ) then      // See if the remaining bits match<br/><br/>&#13;
        // Do something if bits 31, 24, 16, 10, 1, and 0 of<br/>&#13;
        // <span class="EmpItalic1">value1</span> and <span class="EmpItalic1">value2</span> are equal<br/><br/>&#13;
    endif;<br/><br/>&#13;
    mov( <span class="EmpItalic1">value1</span>, eax );       // EAX = <span class="EmpItalic1">value1</span><br/>&#13;
    and( $8101_0403, eax );  // Mask out unwanted bits in EAX<br/>&#13;
    mov( <span class="EmpItalic1">value3</span>, edx );       // EDX = <span class="EmpItalic1">value2</span><br/>&#13;
    and( $8101_0403, edx );  // Mask out the same set of unwanted bits in EDX<br/><br/>&#13;
    if( eax &lt;&gt; edx ) then    // See if the remaining bits do not match<br/><br/>&#13;
        // Do something if bits 31, 24, 16, 10, 1, and 0 of<br/>&#13;
        // <span class="EmpItalic1">value1</span> and <span class="EmpItalic1">value3</span> are not equal<br/><br/>&#13;
    endif;</pre>&#13;
<h4 class="h4" id="sec3_4_4"><strong><em>3.4.4 Creating Modulo-</em>n <em>Counters Using AND</em></strong></h4>&#13;
<p class="noindent">A <a href="gloss01.xhtml#gloss01_164"><em>modulo-</em>n <em>counter</em></a> counts from 0<sup><a href="footnotes.xhtml#fn3_3a" id="fn3_3">3</a></sup> to some maximum value and then resets to 0. Modulo-<em>n</em> counters are great for creating repeating sequences of numbers such as 0, 1, 2, 3, 4, 5, . . . <em>n</em> – 1; 0, 1, 2, 3, 4, 5, . . . <em>n</em> – 1; 0, 1, . . . . You can use such sequences to create circular queues and other objects that reuse array elements upon encountering the end of the data structure. The normal way to create a modulo-<em>n</em> counter is to add 1 to the counter, divide the result by <em>n</em>, and then keep the remainder. The following code examples demonstrate the implementation of a modulo-<em>n</em> counter in C/C++, Pascal, and Visual Basic:</p>&#13;
<pre>cntr = (cntr + 1 ) % n;    // C/C++/Java/Swift<br/>&#13;
cntr := (cntr + 1) mod n;  // Pascal/Delphi<br/>&#13;
cntr = (cntr + 1) Mod n     ' Visual Basic</pre>&#13;
<p class="indent">However, division is an expensive operation, requiring far more time to execute than addition. In general, you’ll find it more efficient to implement modulo-<em>n</em> counters using a comparison rather than the remainder operator. Here’s a Pascal example:</p>&#13;
<pre>cntr := cntr + 1;      // Pascal example<br/>&#13;
if( cntr &gt;= n ) then<br/>&#13;
    cntr := 0;</pre>&#13;
<p class="indent">For certain special cases, when <em>n</em> is a power of 2, you can increment a modulo-<em>n</em> counter more efficiently and conveniently using the AND operation. To do so, increment your counter and then logically AND it with the value <em>x</em> = 2<sup><em>m</em></sup> – 1 (2<sup><em>m</em></sup> – 1 contains <code>1</code>s in bit positions 0..<em>m</em> – 1, and <code>0</code>s <span epub:type="pagebreak" id="page_48"/>everywhere else). Because the AND operation is much faster than division, AND-driven modulo-<em>n</em> counters are much more efficient than those using the remainder operator. On most CPUs, using the AND operator is quite a bit faster than using an <code>if</code> statement. The following examples show how to implement a modulo-<em>n</em> counter for <em>n</em> = 32 using the AND operation:</p>&#13;
<pre>//Note: 0x1f = 31 = 2<sup>5</sup> – 1, so n = 32 and m = 5<br/><br/>&#13;
    cntr = (cntr + 1) &amp; 0x1f;    // C/C++/Java/Swift example<br/>&#13;
    cntr := (cntr + 1) and $1f;  // Pascal/Delphi example<br/>&#13;
    cntr = (cntr + 1) and &amp;h1f    ' Visual Basic example</pre>&#13;
<p class="indent">The assembly language code is especially efficient:</p>&#13;
<pre>inc( eax );                      // Compute (eax + 1) mod 32<br/>&#13;
and( $1f, eax );</pre>&#13;
<h3 class="h3" id="sec3_5"><strong>3.5 Shifts and Rotates</strong></h3>&#13;
<p class="noindent">Another set of logical operations on bit strings are the <em>shift</em> and <em>rotate</em> operations. These functions can be further broken down into <em>shift lefts</em>, <em>rotate lefts</em>, <em>shift rights</em>, and <em>rotate rights</em>. These operations are very useful in many programs.</p>&#13;
<p class="indent">The shift left operation moves each bit in a bit string one position to the left, as shown in <a href="ch03.xhtml#ch03fig03">Figure 3-3</a>. Bit 0 moves into bit position 1, the previous value in bit position 1 moves into bit position 2, and so on.</p>&#13;
<div class="image"><img alt="image" src="../images/03fig03.jpg"/></div>&#13;
<p class="figcap"><a id="ch03fig03"/><em>Figure 3-3: Shift left operation (on a byte)</em></p>&#13;
<p class="indent">You might be asking two questions: “What goes into bit 0?” and “Where does the HO bit wind up?” We’ll shift a <code>0</code> into bit 0, and the previous value of the HO bit will be the <em>carry</em> out of this operation.</p>&#13;
<p class="indent">Several high-level languages (such as C/C++/C#, Swift, Java, and Free Pascal/Delphi) provide a shift left operator. In the C language family, this operator is <code>&lt;&lt;</code>. In Free Pascal/Delphi, you use the <code>shl</code> operator. Here are some examples:</p>&#13;
<pre>// C:<br/>&#13;
        cLang = d &lt;&lt; 1;     // Assigns d shifted left one position to<br/>&#13;
                            // variable "cLang"<br/>&#13;
// Delphi:<br/>&#13;
        Delphi := d shl 1;  // Assigns d shifted left one position to<br/>&#13;
                            // variable "Delphi"</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_49"/>Shifting the binary representation of a number one position to the left is equivalent to multiplying that value by 2. If you’re using a programming language that doesn’t provide an explicit shift left operator, you can simulate this by multiplying a binary integer value by 2. Although the multiplication operation is usually slower than the shift left operation, most compilers are smart enough to translate a multiplication by a constant power of 2 into a shift left operation. Therefore, you could write code like the following in Visual Basic to do a shift left:</p>&#13;
<pre>vb = d * 2</pre>&#13;
<p class="indent">A shift right operation is similar to a shift left, except we move the data in the opposite direction. Bit 7 moves into bit 6, bit 6 moves into bit 5, bit 5 moves into bit 4, and so on. During a shift right, we’ll move a <code>0</code> into bit 7, and bit 0 will be the carry out of the operation (see <a href="ch03.xhtml#ch03fig04">Figure 3-4</a>). C, C++, C#, Swift, and Java use the <code>&gt;&gt;</code> operator for a shift right operation. Free Pascal/Delphi uses the <code>shr</code> operator. Most assembly languages also provide a shift right instruction (<code>shr</code> on the 80x86).</p>&#13;
<div class="image"><img alt="image" src="../images/03fig04.jpg"/></div>&#13;
<p class="figcap"><a id="ch03fig04"/><em>Figure 3-4: The shift right operation (on a byte)</em></p>&#13;
<p class="indent">Shifting an unsigned binary value one position to the right divides that value by 2. For example, if you shift the unsigned representation of 254 (<code>$FE</code>) one place to the right, you get 127 (<code>$7F</code>), exactly as you’d expect. However, if you shift the 8-bit two’s complement binary representation of –2 (<code>$FE</code>) one position to the right, you get 127 (<code>$7F</code>), which is <em>not</em> correct. To divide a signed number by 2 using a shift, we use a third shift operation, <em>arithmetic shift right</em>, which doesn’t modify the value of the HO bit. <a href="ch03.xhtml#ch03fig05">Figure 3-5</a> shows the arithmetic shift right operation for an 8-bit operand.</p>&#13;
<div class="image"><img alt="image" src="../images/03fig05.jpg"/></div>&#13;
<p class="figcap"><a id="ch03fig05"/><em>Figure 3-5: Arithmetic shift right operation (on a byte)</em></p>&#13;
<p class="indent">This generally produces the result you expect for two’s complement signed operands. For example, if you perform the arithmetic shift right operation on –2 (<code>$FE</code>), you get –1 (<code>$FF</code>). Note, however, that this operation always rounds the numbers to the closest integer that is <em>less than or equal to the actual result</em>. If you arithmetically shift right –1 (<code>$FF</code>), the result is –1, not 0. Because –1 is less than 0, the arithmetic shift right operation rounds toward –1. This is not a “bug” in the arithmetic shift right operation; it just <span epub:type="pagebreak" id="page_50"/>uses a different (though valid) definition of integer division. The bottom line is that you probably won’t be able to use a signed division operator as a substitute for arithmetic shift right in languages that don’t support arithmetic shift right, because most integer division operators round toward 0.</p>&#13;
<p class="indent">It’s rare for a high-level language to support both the logical shift right and the arithmetic shift right. Worse still, the specifications for certain languages leave it up to the compiler’s implementer to decide whether to use an arithmetic shift right or a logical shift right operation. Therefore, it’s only safe to use the shift right operator on values whose HO bit will cause both forms of the shift right operation to produce the same result. To guarantee that a shift right is a logical shift right or an arithmetic shift right operation, you’ll either have to drop down into assembly language or handle the HO bit manually. The high-level code gets ugly really fast, so a quick inline assembly statement might be a better solution if your program doesn’t need to be portable across different CPUs. The following code demonstrates how to simulate a 32-bit logical shift right and arithmetic shift right in languages that don’t guarantee the type of shift they use:</p>&#13;
<pre>// Written in C/C++, assuming 32-bit integers, logical shift right:<br/>&#13;
    // Compute bit 30.<br/>&#13;
    Bit30 = ((<span class="EmpItalic1">ShiftThisValue</span> &amp; 0x80000000) != 0) ? 0x40000000 : 0;<br/>&#13;
    // Shifts bits 0..30.<br/>&#13;
    <span class="EmpItalic1">ShiftThisValue</span> = (<span class="EmpItalic1">ShiftThisValue</span> &amp; 0x7fffffff) &gt;&gt; 1;<br/>&#13;
    // Merge in Bit #30.<br/>&#13;
    <span class="EmpItalic1">ShiftThisValue</span> = <span class="EmpItalic1">ShiftThisValue</span> | Bit30; <br/><br/>&#13;
// Arithmetic shift right operation<br/><br/>&#13;
    Bits3031 = ((<span class="EmpItalic1">ShiftThisValue</span> &amp; 0x80000000) != 0) ? 0xC0000000 : 0;<br/>&#13;
    // Shifts bits 0..30.<br/>&#13;
    <span class="EmpItalic1">ShiftThisValue</span> = (<span class="EmpItalic1">ShiftThisValue</span> &amp; 0x7fffffff) &gt;&gt; 1;<br/>&#13;
    // Merge bits 30/31.<br/>&#13;
    <span class="EmpItalic1">ShiftThisValue</span> = <span class="EmpItalic1">ShiftThisValue</span> | Bits3031;</pre>&#13;
<p class="indent">Many assembly languages also provide various rotate instructions that circulate bits through an operand by taking the bits shifted out of one end of the operand and shifting them into the other end. Few high-level languages provide this operation; fortunately, you won’t need it very often. If you do, you can synthesize this operation using the shift operators available in your high-level language:</p>&#13;
<pre>// Pascal/Delphi Rotate Left, 32-bit example:<br/>&#13;
// Puts bit 31 into bit 0, clears other bits.<br/>&#13;
CarryOut := (<span class="EmpItalic1">ValueToRotate</span> shr 31); <br/>&#13;
ValueToRotate := (<span class="EmpItalic1">ValueToRotate</span> shl 1) or CarryOut;</pre>&#13;
<p class="indent">For more information on the type of shift and rotate operations that are possible, consult <em>The Art of Assembly Language</em> (No Starch Press).</p>&#13;
<h3 class="h3" id="sec3_6"><span epub:type="pagebreak" id="page_51"/><strong>3.6 Bit Fields and Packed Data</strong></h3>&#13;
<p class="noindent">CPUs generally operate most efficiently on byte, word, double-word and quad-word data types,<sup><a href="footnotes.xhtml#fn3_4a" id="fn3_4">4</a></sup> but occasionally you’ll need to work with a data type whose size is something other than 8, 16, 32, or 64 bits. In such cases, you may be able to save some memory by <em>packing</em> different strings of bits together as compactly as possible, without wasting any bits to align a particular data field on a byte or other boundary.</p>&#13;
<p class="indent">Consider a date of the form 04/02/01. It takes three numeric values to represent this date: month, day, and year. Months use the values 1 through 12, which require at least 4 bits to represent. Days use the range 1 through 31, which take 5 bits to represent. The year value, assuming that we’re working with values in the range 0 through 99, requires 7 bits. The total of 4 + 5 + 7 is 16 bits, or 2 bytes. We can pack our date data into 2 bytes rather than the 3 that would be required if we used a separate byte for each of the values. This saves 1 byte of memory for each date stored, which could be a substantial saving if you need to store many dates. You might arrange the bits as shown in <a href="ch03.xhtml#ch03fig06">Figure 3-6</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/03fig06.jpg"/></div>&#13;
<p class="figcap"><a id="ch03fig06"/><em>Figure 3-6: Short packed date format (16 bits)</em></p>&#13;
<p class="indent"><code>MMMM</code> represents the 4 bits that hold the month value, <code>DDDDD</code> the 5 bits that hold the day, and <code>YYYYYYY</code> the 7 bits that hold the year. Each collection of bits representing a data item is a <em>bit field</em>. We could represent April 2, 2001, with <code>$4101</code>:</p>&#13;
<pre>0100    00010    0000001    = %0100_0001_0000_0001 or $4101<br/>&#13;
 04      02       01</pre>&#13;
<p class="indent">Although packed values are space efficient (that is, they use little memory), they are computationally inefficient (slow!). The reason? It takes extra instructions to unpack the data from the various bit fields. These extra instructions take time to execute (and additional bytes to hold the instructions); hence, you must carefully consider whether packed data fields will save you anything. The following sample HLA/x86 code demonstrates packing and unpacking this 16-bit date format.</p>&#13;
<pre>program dateDemo;<br/><br/>&#13;
#include( "stdlib.hhf" )<br/><br/>&#13;
static<br/><br/>&#13;
<span epub:type="pagebreak" id="page_52"/>    day:        uns8;<br/>&#13;
    month:      uns8;<br/>&#13;
    year:       uns8;<br/>&#13;
    packedDate: word;<br/><br/>&#13;
begin dateDemo;<br/><br/>&#13;
    stdout.put( "Enter the current month, day, and year: " );<br/>&#13;
    stdin.get( month, day, year );<br/><br/>&#13;
    // Pack the data into the following bits:<br/>&#13;
    //<br/>&#13;
    //  15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0<br/>&#13;
    //   m  m  m  m  d  d  d  d  d  y  y  y  y  y  y  y<br/><br/>&#13;
    mov( 0, ax );<br/>&#13;
    mov( ax, packedDate );  // Just in case there is an error.<br/>&#13;
    if( month &gt; 12 ) then <br/>&#13;
        stdout.put( "Month value is too large", nl );<br/><br/>&#13;
    elseif( month = 0 ) then <br/>&#13;
        stdout.put( "Month value must be in the range 1..12", nl );<br/><br/>&#13;
    elseif( day &gt; 31 ) then <br/>&#13;
        stdout.put( "Day value is too large", nl );<br/><br/>&#13;
    elseif( day = 0 ) then <br/>&#13;
        stdout.put( "Day value must be in the range 1..31", nl );<br/><br/>&#13;
    elseif( year &gt; 99 ) then <br/>&#13;
        stdout.put( "Year value must be in the range 0..99", nl );<br/><br/>&#13;
    else<br/><br/>&#13;
        mov( month, al );<br/>&#13;
        shl( 5, ax );<br/>&#13;
        or( day, al );<br/>&#13;
        shl( 7, ax );<br/>&#13;
        or( year, al );<br/>&#13;
        mov( ax, packedDate );<br/><br/>&#13;
    endif;<br/><br/>&#13;
    // Okay, display the packed value:<br/>&#13;
    stdout.put( "Packed data = $", packedDate, nl );<br/><br/>&#13;
    // Unpack the date:<br/>&#13;
<span epub:type="pagebreak" id="page_53"/>    mov( packedDate, ax );<br/>&#13;
    and( $7f, al );         // Retrieve the year value.<br/>&#13;
    mov( al, year );<br/><br/>&#13;
    mov( packedDate, ax );  // Retrieve the day value.<br/>&#13;
    shr( 7, ax );<br/>&#13;
    and( %1_1111, al );<br/>&#13;
    mov( al, day );<br/><br/>&#13;
    mov( packedDate, ax );  // Retrieve the month value.<br/>&#13;
    rol( 4, ax );<br/>&#13;
    and( %1111, al );<br/>&#13;
    mov( al, month );<br/><br/>&#13;
    stdout.put( "The date is ", month, "/", day, "/", year, nl ); <br/>&#13;
   <br/>&#13;
end dateDemo;</pre>&#13;
<p class="indent">Keeping in mind the Y2K<sup><a href="footnotes.xhtml#fn3_5a" id="fn3_5">5</a></sup> problem, adopting a date format that supports only a two-digit year is rather foolish. Consider the better date format shown in <a href="ch03.xhtml#ch03fig07">Figure 3-7</a>.</p>&#13;
<div class="image"><img alt="image" src="../images/03fig07.jpg"/></div>&#13;
<p class="figcap"><a id="ch03fig07"/><em>Figure 3-7: Long packed date format (32 bits)</em></p>&#13;
<p class="indent">Because there are more bits in a 32-bit variable than are needed to hold the date, even accounting for years in the range 0 through 65,535, this format allots a full byte for the <code>month</code> and <code>day</code> fields. An application can manipulate these two fields as byte objects, reducing the overhead to pack and unpack these fields on processors that support byte access. This leaves fewer bits for the year, but 65,536 years is probably sufficient (it’s a safe bet that your software won’t be in use 63,000 years from now).</p>&#13;
<p class="indent">You could argue that this is no longer a packed date format. After all, we needed three numeric values, two of which fit just nicely into 1 byte each and one that should have at least 2 bytes. This “packed” date format consumes the same 4 bytes as the unpacked version, not the fewest bits possible. So, in this example, packed effectively means <em>packaged</em> or <em>encapsulated</em>. By packing the data into a double-word variable, the program can treat the date value as a single data value rather than as three separate variables. This means that you can often get away with a single machine instruction to operate on this data rather than three separate instructions.</p>&#13;
<p class="indent">Another difference between this long packed date format and the short date format in <a href="ch03.xhtml#ch03fig06">Figure 3-6</a> is that this long date format rearranges the <code>Year</code>, <code>Month</code>, and <code>Day</code> fields. This allows you to easily compare two dates using an unsigned integer comparison. Consider the following HLA/assembly code:</p>&#13;
<pre>mov( Date1, eax );        // Assume Date1 and Date2 are double-word variables<br/>&#13;
if( eax &gt; Date2 ) then    // using the long packed date format.<br/><br/>&#13;
    &lt;&lt; do something if Date1 &gt; Date2 &gt;&gt;<br/><br/>&#13;
endif;</pre>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_54"/>Had you kept the different date fields in separate variables or organized the fields differently, you wouldn’t have been able to compare <code>Date1</code> and <code>Date2</code> in such a straightforward way. Even if you don’t realize any space savings, packing data can make certain computations more convenient or even more efficient (contrary to what normally happens when you pack data).</p>&#13;
<p class="indent">Some high-level languages provide built-in support for packed data. For example, in C you can define structures like the following:</p>&#13;
<pre>struct<br/>&#13;
{<br/>&#13;
    unsigned bits0_3   :4;<br/>&#13;
    unsigned bits4_11  :8;<br/>&#13;
    unsigned bits12_15 :4;<br/>&#13;
    unsigned bits16_23 :8;<br/>&#13;
    unsigned bits24_31 :8;<br/>&#13;
} packedData;</pre>&#13;
<p class="indent">This structure specifies that each field is an unsigned object that holds 4, 8, 4, 8, and 8 bits, respectively. The <code>:</code><span class="EmpItalic">n</span> item after each declaration specifies the <em>minimum</em> number of bits the compiler will allocate for the given field.</p>&#13;
<p class="indent">Unfortunately, it isn’t possible to show how a C/C++ compiler will allocate the values from a 32-bit double word among the fields, because C/C++ compiler implementers are free to implement these bit fields any way they see fit. The arrangement of the bits within the bit string is arbitrary (for example, the compiler could allocate the <code>bits0_3</code> field in bits 28 through 31 of the ultimate object). The compiler can also inject extra bits between fields, or use a larger number of bits for each field (which is actually the same thing as injecting extra padding bits between fields). Most C compilers attempt to minimize extraneous padding, but compilers (especially on different CPUs) do vary. Therefore, C/C++ struct bit field declarations are almost guaranteed to be nonportable, and you can’t really count on what the compiler is going to do with those fields.</p>&#13;
<p class="indent">The advantage of using the compiler’s built-in data-packing capabilities is that the compiler automatically packs and unpacks the data for you. Given the following C/C++ code, the compiler would automatically emit the necessary machine instructions to store and retrieve the individual bit fields for you:</p>&#13;
<pre>struct<br/>&#13;
{<br/>&#13;
    unsigned year  :7;<br/>&#13;
    unsigned month :4;<br/>&#13;
    unsigned day   :5;<br/>&#13;
} ShortDate;<br/>&#13;
        . . .<br/>&#13;
    ShortDate.day = 28;<br/>&#13;
    ShortDate.month = 2;<br/>&#13;
    ShortDate.year = 3;  // 2003</pre>&#13;
<h3 class="h3" id="sec3_7"><span epub:type="pagebreak" id="page_55"/><strong>3.7 Packing and Unpacking Data</strong></h3>&#13;
<p class="noindent">The advantage of packed data types is efficient memory use. Consider the Social Security number (SSN) used in the United States, a nine-digit identification code in the following form (each <code>X</code> represents a single decimal digit):</p>&#13;
<pre>XXX–XX–XXXX</pre>&#13;
<p class="indent">Encoding an SSN using three separate (32-bit) integers takes 12 bytes. That’s more than the 11 bytes needed to represent the number using an array of characters. A better solution is to encode each field using short (16-bit) integers. Now it takes only 6 bytes to represent the SSN. Because the middle field in the SSN is always between 0 and 99, we can actually shave one more byte off the size of this structure by encoding the middle field with a single byte. Here’s a sample Free Pascal/Delphi record structure that defines this data structure:</p>&#13;
<pre>SSN :record<br/><br/>&#13;
        FirstField:  smallint;  // smallints are 16 bits in Free Pascal/Delphi<br/>&#13;
        SecondField: byte;<br/>&#13;
        ThirdField:  smallint;<br/><br/>&#13;
end;</pre>&#13;
<p class="indent">If we drop the hyphens in the SSN, the result is a nine-digit number. Because we can exactly represent all nine-digit values using 30 bits, we could encode any legal SSN using a 32-bit integer. However, some software that manipulates SSNs may need to operate on the individual fields. This means using expensive division, modulo, and multiplication operators in order to extract fields from a SSN you’ve encoded in a 32-bit integer format. Furthermore, converting SSNs to and from strings is more complicated when you’re using the 32-bit format.</p>&#13;
<p class="indent">Conversely, it’s easy to insert and extract individual bit fields using fast machine instructions, and it’s also less work to create a standard string representation (including the hyphens) of one of these fields. <a href="ch03.xhtml#ch03fig08">Figure 3-8</a> shows a straightforward implementation of the SSN packed data type using a separate string of bits for each field (note that this format uses 31 bits and ignores the HO bit).</p>&#13;
<div class="image"><img alt="image" src="../images/03fig08.jpg"/></div>&#13;
<p class="figcap"><a id="ch03fig08"/><em>Figure 3-8: SSN packed fields encoding</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_56"/>Fields that begin at bit position 0 in a packed data object can be accessed most efficiently, so you should arrange the fields in your packed data type such that the field you access most often<sup><a href="footnotes.xhtml#fn3_6a" id="fn3_6">6</a></sup> begins at bit 0. If you have no idea which field you’ll access most often, assign the fields so they begin on a byte boundary. If there are unused bits in your packed type, spread them throughout the structure so that individual fields begin on a byte boundary and those fields consume multiples of 8 bits.</p>&#13;
<p class="indent">We’ve got only one unused bit in the SSN example shown in <a href="ch03.xhtml#ch03fig08">Figure 3-8</a>, but it turns out that we can use this extra bit to align two fields on a byte boundary and ensure that one of those fields occupies a bit string whose length is a multiple of 8 bits. Consider <a href="ch03.xhtml#ch03fig09">Figure 3-9</a>, which shows a rearranged version of our SSN data type.</p>&#13;
<div class="image"><img alt="image" src="../images/03fig09.jpg"/></div>&#13;
<p class="figcap"><a id="ch03fig09"/><em>Figure 3-9: A (possibly) improved encoding of the SSN</em></p>&#13;
<p class="indent">One problem with the data format in <a href="ch03.xhtml#ch03fig09">Figure 3-9</a> is that we can’t sort SSNs in an intuitive way by comparing 32-bit unsigned integers.<sup><a href="footnotes.xhtml#fn3_7a" id="fn3_7">7</a></sup> If you intend to do a lot of sorting based on the entire SSN, the format in <a href="ch03.xhtml#ch03fig08">Figure 3-8</a> is probably better.</p>&#13;
<p class="indent">If this type of sorting isn’t important to you, the format in <a href="ch03.xhtml#ch03fig09">Figure 3-9</a> has some advantages. This packed type actually uses 8 bits (rather than 7) to represent <code>SecondField</code> (along with moving <code>SecondField</code> down to bit position 0); the extra bit will always contain <code>0</code>. This means that <code>SecondField</code> consumes bits 0 through 7 (a whole byte) and <code>ThirdField</code> begins on a byte boundary (bit position 8). <code>ThirdField</code> doesn’t consume a multiple of 8 bits, and <code>FirstField</code> doesn’t begin on a byte boundary, but we’ve done fairly well with this encoding, considering we only had one extra bit to play around with.</p>&#13;
<p class="indent">The next question is, “How do we access the fields of this packed type?” There are two separate activities here. We need to retrieve, or <em>extract</em>, the packed fields, and we need to <em>insert</em> data into these fields. The AND, OR, and SHIFT operations provide the tools for this.</p>&#13;
<p class="indent">When operating on these fields, it’s convenient to work with three separate variables rather than with the packed data directly. For our SSN example, we can create the three variables—<code>FirstField</code>, <code>SecondField</code>, and <code>ThirdField</code>—and then extract the actual data from the packed value into these three variables, operate on the variables, and insert the data from the variables back into their fields when we’re done.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_57"/>To extract the <code>SecondField</code> data from the packed format shown in <a href="ch03.xhtml#ch03fig09">Figure 3-9</a> (remember, the field aligned to bit 0 is the easiest one to access), copy the data from the packed representation to the <code>SecondField</code> variable and then mask out all but the <code>SecondField</code> bits using the AND operation. Because <code>SecondField</code> is a 7-bit value, the mask is an integer containing <code>1</code>s in bit positions 0 through 6 and <code>0</code>s everywhere else. The following C/C++ code demonstrates how to extract this field into the <code>SecondField</code> variable (assuming <span class="EmpItalic">packedValue</span> is a variable holding the 32-bit packed SSN):</p>&#13;
<pre>SecondField = <span class="EmpItalic1">packedValue</span> &amp; 0x7f;   // 0x7f = %0111_1111</pre>&#13;
<p class="indent">Extracting fields that are not aligned at bit 0 takes a little more work. Consider the <code>ThirdField</code> entry in <a href="ch03.xhtml#ch03fig09">Figure 3-9</a>. We can mask out all the bits associated with the first and second fields by logically ANDing the packed value with <code>%_11_1111_1111_1111_0000_0000</code> (<code>$3F_FF00</code>). However, this leaves the <code>ThirdField</code> value sitting in bits 8 through 21, which is not convenient for various arithmetic operations. The solution is to shift the masked value down 8 bits so that it’s aligned at bit 0 in our working variable. The following Pascal/Delphi code does this:</p>&#13;
<pre>ThirdField := (<span class="EmpItalic1">packedValue</span> and $3fff00) shr 8;</pre>&#13;
<p class="indent">You can also shift first and then do the logical AND operation (though this requires a different mask, <code>$11_1111_1111_1111 or $3FFF</code>). Here’s the C/C++/Swift code that extracts <code>ThirdField</code> using that technique:</p>&#13;
<pre>ThirdField = (<span class="EmpItalic1">packedValue</span> &gt;&gt; 8) &amp; 0x3FFF;</pre>&#13;
<p class="indent">To extract a field that is aligned against the HO bit, such as the first field in our SSN packed data type, shift the HO field down so that it’s aligned at bit 0. The logical shift right operation automatically fills in the HO bits of the result with <code>0</code>s, so no masking is necessary. The following Pascal/Delphi code demonstrates this:</p>&#13;
<pre>FirstField := <span class="EmpItalic1">packedValue</span> shr 22; // Delphi's SHR is a logical shift right.</pre>&#13;
<p class="indent">In HLA/x86 assembly language, we can easily access data at any arbitrary byte boundary in memory. That allows us to treat both the second and third fields as though they are aligned at bit 0 in the data structure. In addition, because the <code>SecondField</code> value is an 8-bit value (with the HO bit always containing <code>0</code>), it takes only a single machine instruction to unpack the data, as shown here:</p>&#13;
<pre>movzx( (type byte <span class="EmpItalic1">packedValue</span>), eax );</pre>&#13;
<p class="indent">This instruction fetches the first byte of <span class="EmpItalic">packedValue</span> (which is the LO 8 bits of <span class="EmpItalic">packedValue</span> on the 80x86) and zero-extends this value to 32 bits in EAX (<code>movzx</code> stands for “move with zero extension”). The EAX register contains the <code>SecondField</code> value after this instruction executes.</p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_58"/>The <code>ThirdField</code> value from our packed data type isn’t an even multiple of 8 bits long, so we’ll still need a masking operation to clear the unused bits from the 32-bit result we produce. However, because <code>ThirdField</code> is aligned on a byte (8-bit) boundary in our packed structure, we’ll be able to avoid the shift operation that was necessary in the high-level code. Here’s the HLA/x86 assembly code that extracts the third field from our <span class="EmpItalic">packedValue</span> object:</p>&#13;
<pre>mov( (type word <span class="EmpItalic1">packedValue</span>[1]), ax );    // Extracts bytes 1 &amp; 2 <br/>&#13;
                                        // from <span class="EmpItalic1">packedValue</span>.<br/>&#13;
and( $3FFF, eax );                      // Clears all the undesired bits.</pre>&#13;
<p class="indent">Extracting <code>FirstField</code> from the <span class="EmpItalic">packedValue</span> object in HLA/x86 assembly code is identical to the high-level code; we’ll simply shift the upper 10 bits (which comprise <code>FirstField</code>) down to bit 0:</p>&#13;
<pre>mov( <span class="EmpItalic1">packedValue</span>, eax );<br/>&#13;
shr( 22, eax );</pre>&#13;
<p class="indent">Assuming the data you want to insert appears in some variable and contains <code>0</code>s in the unused bits, inserting a field into a packed object requires three operations. First, if necessary, you shift the field’s data to the left so its alignment matches the corresponding field in the packed object. Next, clear the corresponding bits in the packed structure, then logically OR the shifted field into the packed object. <a href="ch03.xhtml#ch03fig10">Figure 3-10</a> shows the details of this operation.</p>&#13;
<div class="image"><img alt="image" src="../images/03fig10.jpg"/></div>&#13;
<p class="figcap"><a id="ch03fig10"/><em>Figure 3-10: Inserting <code>ThirdField</code> into the SSN packed type</em></p>&#13;
<p class="indent"><span epub:type="pagebreak" id="page_59"/>Here’s the C/C++/Swift code that accomplishes the operation shown in <a href="ch03.xhtml#ch03fig10">Figure 3-10</a>:</p>&#13;
<pre><span class="EmpItalic1">packedValue</span> = (<span class="EmpItalic1">packedValue</span> &amp; 0xFFc000FF) | (ThirdField &lt;&lt; 8 );</pre>&#13;
<p class="indent"><code>$FFC000FF</code> is the hexadecimal value that corresponds to <code>0</code>s in bit positions 8 through 21 and <code>1</code>s everywhere else.</p>&#13;
<h3 class="h3" id="sec3_8"><strong>3.8 For More Information</strong></h3>&#13;
<p class="ref">Hyde, Randall. <em>The Art of Assembly Language</em>. 2nd ed. San Francisco: No Starch Press, 2010.</p>&#13;
<p class="ref">Knuth, Donald E. <em>The Art of Computer Programming, Volume 2: Seminumerical Algorithms</em>. 3rd ed. Boston: Addison-Wesley, 1998.<span epub:type="pagebreak" id="page_60"/></p>&#13;
</body></html>